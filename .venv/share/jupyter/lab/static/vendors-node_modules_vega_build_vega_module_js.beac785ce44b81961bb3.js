"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_vega_build_vega_module_js"],{

/***/ "./node_modules/d3-geo-projection/src/math.js":
/*!****************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/math.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   abs: () => (/* binding */ abs),
/* harmony export */   acos: () => (/* binding */ acos),
/* harmony export */   arcosh: () => (/* binding */ arcosh),
/* harmony export */   arsinh: () => (/* binding */ arsinh),
/* harmony export */   asin: () => (/* binding */ asin),
/* harmony export */   atan: () => (/* binding */ atan),
/* harmony export */   atan2: () => (/* binding */ atan2),
/* harmony export */   ceil: () => (/* binding */ ceil),
/* harmony export */   cos: () => (/* binding */ cos),
/* harmony export */   cosh: () => (/* binding */ cosh),
/* harmony export */   degrees: () => (/* binding */ degrees),
/* harmony export */   epsilon: () => (/* binding */ epsilon),
/* harmony export */   epsilon2: () => (/* binding */ epsilon2),
/* harmony export */   exp: () => (/* binding */ exp),
/* harmony export */   floor: () => (/* binding */ floor),
/* harmony export */   halfPi: () => (/* binding */ halfPi),
/* harmony export */   log: () => (/* binding */ log),
/* harmony export */   max: () => (/* binding */ max),
/* harmony export */   min: () => (/* binding */ min),
/* harmony export */   pi: () => (/* binding */ pi),
/* harmony export */   pow: () => (/* binding */ pow),
/* harmony export */   quarterPi: () => (/* binding */ quarterPi),
/* harmony export */   radians: () => (/* binding */ radians),
/* harmony export */   round: () => (/* binding */ round),
/* harmony export */   sign: () => (/* binding */ sign),
/* harmony export */   sin: () => (/* binding */ sin),
/* harmony export */   sinci: () => (/* binding */ sinci),
/* harmony export */   sinh: () => (/* binding */ sinh),
/* harmony export */   sqrt: () => (/* binding */ sqrt),
/* harmony export */   sqrt1_2: () => (/* binding */ sqrt1_2),
/* harmony export */   sqrt2: () => (/* binding */ sqrt2),
/* harmony export */   sqrtPi: () => (/* binding */ sqrtPi),
/* harmony export */   tan: () => (/* binding */ tan),
/* harmony export */   tanh: () => (/* binding */ tanh),
/* harmony export */   tau: () => (/* binding */ tau)
/* harmony export */ });
var abs = Math.abs;
var atan = Math.atan;
var atan2 = Math.atan2;
var ceil = Math.ceil;
var cos = Math.cos;
var exp = Math.exp;
var floor = Math.floor;
var log = Math.log;
var max = Math.max;
var min = Math.min;
var pow = Math.pow;
var round = Math.round;
var sign = Math.sign || function(x) { return x > 0 ? 1 : x < 0 ? -1 : 0; };
var sin = Math.sin;
var tan = Math.tan;

var epsilon = 1e-6;
var epsilon2 = 1e-12;
var pi = Math.PI;
var halfPi = pi / 2;
var quarterPi = pi / 4;
var sqrt1_2 = Math.SQRT1_2;
var sqrt2 = sqrt(2);
var sqrtPi = sqrt(pi);
var tau = pi * 2;
var degrees = 180 / pi;
var radians = pi / 180;

function sinci(x) {
  return x ? x / Math.sin(x) : 1;
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function sqrt(x) {
  return x > 0 ? Math.sqrt(x) : 0;
}

function tanh(x) {
  x = exp(2 * x);
  return (x - 1) / (x + 1);
}

function sinh(x) {
  return (exp(x) - exp(-x)) / 2;
}

function cosh(x) {
  return (exp(x) + exp(-x)) / 2;
}

function arsinh(x) {
  return log(x + sqrt(x * x + 1));
}

function arcosh(x) {
  return log(x + sqrt(x * x - 1));
}


/***/ }),

/***/ "./node_modules/d3-geo-projection/src/mollweide.js":
/*!*********************************************************!*\
  !*** ./node_modules/d3-geo-projection/src/mollweide.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mollweideBromleyRaw: () => (/* binding */ mollweideBromleyRaw),
/* harmony export */   mollweideBromleyTheta: () => (/* binding */ mollweideBromleyTheta),
/* harmony export */   mollweideRaw: () => (/* binding */ mollweideRaw)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/index.js");
/* harmony import */ var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./math.js */ "./node_modules/d3-geo-projection/src/math.js");



function mollweideBromleyTheta(cp, phi) {
  var cpsinPhi = cp * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi), i = 30, delta;
  do phi -= delta = (phi + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi) - cpsinPhi) / (1 + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi));
  while ((0,_math_js__WEBPACK_IMPORTED_MODULE_0__.abs)(delta) > _math_js__WEBPACK_IMPORTED_MODULE_0__.epsilon && --i > 0);
  return phi / 2;
}

function mollweideBromleyRaw(cx, cy, cp) {

  function forward(lambda, phi) {
    return [cx * lambda * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(phi = mollweideBromleyTheta(cp, phi)), cy * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(phi)];
  }

  forward.invert = function(x, y) {
    return y = (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)(y / cy), [x / (cx * (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.cos)(y)), (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.asin)((2 * y + (0,_math_js__WEBPACK_IMPORTED_MODULE_0__.sin)(2 * y)) / cp)];
  };

  return forward;
}

var mollweideRaw = mollweideBromleyRaw(_math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2 / _math_js__WEBPACK_IMPORTED_MODULE_0__.halfPi, _math_js__WEBPACK_IMPORTED_MODULE_0__.sqrt2, _math_js__WEBPACK_IMPORTED_MODULE_0__.pi);

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
  return (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])(mollweideRaw)
      .scale(169.529);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bbox.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/bbox.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  var t = (0,_transform_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology.transform), key,
      x0 = Infinity, y0 = x0, x1 = -x0, y1 = -x0;

  function bboxPoint(p) {
    p = t(p);
    if (p[0] < x0) x0 = p[0];
    if (p[0] > x1) x1 = p[0];
    if (p[1] < y0) y0 = p[1];
    if (p[1] > y1) y1 = p[1];
  }

  function bboxGeometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(bboxGeometry); break;
      case "Point": bboxPoint(o.coordinates); break;
      case "MultiPoint": o.coordinates.forEach(bboxPoint); break;
    }
  }

  topology.arcs.forEach(function(arc) {
    var i = -1, n = arc.length, p;
    while (++i < n) {
      p = t(arc[i], i);
      if (p[0] < x0) x0 = p[0];
      if (p[0] > x1) x1 = p[0];
      if (p[1] < y0) y0 = p[1];
      if (p[1] > y1) y1 = p[1];
    }
  });

  for (key in topology.objects) {
    bboxGeometry(topology.objects[key]);
  }

  return [x0, y0, x1, y1];
}


/***/ }),

/***/ "./node_modules/topojson-client/src/bisect.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/bisect.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(a, x) {
  var lo = 0, hi = a.length;
  while (lo < hi) {
    var mid = lo + hi >>> 1;
    if (a[mid] < x) lo = mid + 1;
    else hi = mid;
  }
  return lo;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/feature.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/feature.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   object: () => (/* binding */ object)
/* harmony export */ });
/* harmony import */ var _reverse_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./reverse.js */ "./node_modules/topojson-client/src/reverse.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, o) {
  if (typeof o === "string") o = topology.objects[o];
  return o.type === "GeometryCollection"
      ? {type: "FeatureCollection", features: o.geometries.map(function(o) { return feature(topology, o); })}
      : feature(topology, o);
}

function feature(topology, o) {
  var id = o.id,
      bbox = o.bbox,
      properties = o.properties == null ? {} : o.properties,
      geometry = object(topology, o);
  return id == null && bbox == null ? {type: "Feature", properties: properties, geometry: geometry}
      : bbox == null ? {type: "Feature", id: id, properties: properties, geometry: geometry}
      : {type: "Feature", id: id, bbox: bbox, properties: properties, geometry: geometry};
}

function object(topology, o) {
  var transformPoint = (0,_transform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology.transform),
      arcs = topology.arcs;

  function arc(i, points) {
    if (points.length) points.pop();
    for (var a = arcs[i < 0 ? ~i : i], k = 0, n = a.length; k < n; ++k) {
      points.push(transformPoint(a[k], k));
    }
    if (i < 0) (0,_reverse_js__WEBPACK_IMPORTED_MODULE_0__["default"])(points, n);
  }

  function point(p) {
    return transformPoint(p);
  }

  function line(arcs) {
    var points = [];
    for (var i = 0, n = arcs.length; i < n; ++i) arc(arcs[i], points);
    if (points.length < 2) points.push(points[0]); // This should never happen per the specification.
    return points;
  }

  function ring(arcs) {
    var points = line(arcs);
    while (points.length < 4) points.push(points[0]); // This may happen if an arc has only two points.
    return points;
  }

  function polygon(arcs) {
    return arcs.map(ring);
  }

  function geometry(o) {
    var type = o.type, coordinates;
    switch (type) {
      case "GeometryCollection": return {type: type, geometries: o.geometries.map(geometry)};
      case "Point": coordinates = point(o.coordinates); break;
      case "MultiPoint": coordinates = o.coordinates.map(point); break;
      case "LineString": coordinates = line(o.arcs); break;
      case "MultiLineString": coordinates = o.arcs.map(line); break;
      case "Polygon": coordinates = polygon(o.arcs); break;
      case "MultiPolygon": coordinates = o.arcs.map(polygon); break;
      default: return null;
    }
    return {type: type, coordinates: coordinates};
  }

  return geometry(o);
}


/***/ }),

/***/ "./node_modules/topojson-client/src/identity.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/identity.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(x) {
  return x;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/index.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bbox: () => (/* reexport safe */ _bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"]),
/* harmony export */   feature: () => (/* reexport safe */ _feature_js__WEBPACK_IMPORTED_MODULE_1__["default"]),
/* harmony export */   merge: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__["default"]),
/* harmony export */   mergeArcs: () => (/* reexport safe */ _merge_js__WEBPACK_IMPORTED_MODULE_3__.mergeArcs),
/* harmony export */   mesh: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   meshArcs: () => (/* reexport safe */ _mesh_js__WEBPACK_IMPORTED_MODULE_2__.meshArcs),
/* harmony export */   neighbors: () => (/* reexport safe */ _neighbors_js__WEBPACK_IMPORTED_MODULE_4__["default"]),
/* harmony export */   quantize: () => (/* reexport safe */ _quantize_js__WEBPACK_IMPORTED_MODULE_5__["default"]),
/* harmony export */   transform: () => (/* reexport safe */ _transform_js__WEBPACK_IMPORTED_MODULE_6__["default"]),
/* harmony export */   untransform: () => (/* reexport safe */ _untransform_js__WEBPACK_IMPORTED_MODULE_7__["default"])
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _mesh_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mesh.js */ "./node_modules/topojson-client/src/mesh.js");
/* harmony import */ var _merge_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./merge.js */ "./node_modules/topojson-client/src/merge.js");
/* harmony import */ var _neighbors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./neighbors.js */ "./node_modules/topojson-client/src/neighbors.js");
/* harmony import */ var _quantize_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./quantize.js */ "./node_modules/topojson-client/src/quantize.js");
/* harmony import */ var _transform_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./transform.js */ "./node_modules/topojson-client/src/transform.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");










/***/ }),

/***/ "./node_modules/topojson-client/src/merge.js":
/*!***************************************************!*\
  !*** ./node_modules/topojson-client/src/merge.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   mergeArcs: () => (/* binding */ mergeArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



function planarRingArea(ring) {
  var i = -1, n = ring.length, a, b = ring[n - 1], area = 0;
  while (++i < n) a = b, b = ring[i], area += a[0] * b[1] - a[1] * b[0];
  return Math.abs(area); // Note: doubled area!
}

/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, mergeArcs.apply(this, arguments));
}

function mergeArcs(topology, objects) {
  var polygonsByArc = {},
      polygons = [],
      groups = [];

  objects.forEach(geometry);

  function geometry(o) {
    switch (o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "Polygon": extract(o.arcs); break;
      case "MultiPolygon": o.arcs.forEach(extract); break;
    }
  }

  function extract(polygon) {
    polygon.forEach(function(ring) {
      ring.forEach(function(arc) {
        (polygonsByArc[arc = arc < 0 ? ~arc : arc] || (polygonsByArc[arc] = [])).push(polygon);
      });
    });
    polygons.push(polygon);
  }

  function area(ring) {
    return planarRingArea((0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, {type: "Polygon", arcs: [ring]}).coordinates[0]);
  }

  polygons.forEach(function(polygon) {
    if (!polygon._) {
      var group = [],
          neighbors = [polygon];
      polygon._ = 1;
      groups.push(group);
      while (polygon = neighbors.pop()) {
        group.push(polygon);
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            polygonsByArc[arc < 0 ? ~arc : arc].forEach(function(polygon) {
              if (!polygon._) {
                polygon._ = 1;
                neighbors.push(polygon);
              }
            });
          });
        });
      }
    }
  });

  polygons.forEach(function(polygon) {
    delete polygon._;
  });

  return {
    type: "MultiPolygon",
    arcs: groups.map(function(polygons) {
      var arcs = [], n;

      // Extract the exterior (unique) arcs.
      polygons.forEach(function(polygon) {
        polygon.forEach(function(ring) {
          ring.forEach(function(arc) {
            if (polygonsByArc[arc < 0 ? ~arc : arc].length < 2) {
              arcs.push(arc);
            }
          });
        });
      });

      // Stitch the arcs into one or more rings.
      arcs = (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs);

      // If more than one ring is returned,
      // at most one of these rings can be the exterior;
      // choose the one with the greatest absolute area.
      if ((n = arcs.length) > 1) {
        for (var i = 1, k = area(arcs[0]), ki, t; i < n; ++i) {
          if ((ki = area(arcs[i])) > k) {
            t = arcs[0], arcs[0] = arcs[i], arcs[i] = t, k = ki;
          }
        }
      }

      return arcs;
    }).filter(function(arcs) {
      return arcs.length > 0;
    })
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/mesh.js":
/*!**************************************************!*\
  !*** ./node_modules/topojson-client/src/mesh.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   meshArcs: () => (/* binding */ meshArcs)
/* harmony export */ });
/* harmony import */ var _feature_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./feature.js */ "./node_modules/topojson-client/src/feature.js");
/* harmony import */ var _stitch_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stitch.js */ "./node_modules/topojson-client/src/stitch.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology) {
  return (0,_feature_js__WEBPACK_IMPORTED_MODULE_0__.object)(topology, meshArcs.apply(this, arguments));
}

function meshArcs(topology, object, filter) {
  var arcs, i, n;
  if (arguments.length > 1) arcs = extractArcs(topology, object, filter);
  else for (i = 0, arcs = new Array(n = topology.arcs.length); i < n; ++i) arcs[i] = i;
  return {type: "MultiLineString", arcs: (0,_stitch_js__WEBPACK_IMPORTED_MODULE_1__["default"])(topology, arcs)};
}

function extractArcs(topology, object, filter) {
  var arcs = [],
      geomsByArc = [],
      geom;

  function extract0(i) {
    var j = i < 0 ? ~i : i;
    (geomsByArc[j] || (geomsByArc[j] = [])).push({i: i, g: geom});
  }

  function extract1(arcs) {
    arcs.forEach(extract0);
  }

  function extract2(arcs) {
    arcs.forEach(extract1);
  }

  function extract3(arcs) {
    arcs.forEach(extract2);
  }

  function geometry(o) {
    switch (geom = o, o.type) {
      case "GeometryCollection": o.geometries.forEach(geometry); break;
      case "LineString": extract1(o.arcs); break;
      case "MultiLineString": case "Polygon": extract2(o.arcs); break;
      case "MultiPolygon": extract3(o.arcs); break;
    }
  }

  geometry(object);

  geomsByArc.forEach(filter == null
      ? function(geoms) { arcs.push(geoms[0].i); }
      : function(geoms) { if (filter(geoms[0].g, geoms[geoms.length - 1].g)) arcs.push(geoms[0].i); });

  return arcs;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/neighbors.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/neighbors.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bisect_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bisect.js */ "./node_modules/topojson-client/src/bisect.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(objects) {
  var indexesByArc = {}, // arc index -> array of object indexes
      neighbors = objects.map(function() { return []; });

  function line(arcs, i) {
    arcs.forEach(function(a) {
      if (a < 0) a = ~a;
      var o = indexesByArc[a];
      if (o) o.push(i);
      else indexesByArc[a] = [i];
    });
  }

  function polygon(arcs, i) {
    arcs.forEach(function(arc) { line(arc, i); });
  }

  function geometry(o, i) {
    if (o.type === "GeometryCollection") o.geometries.forEach(function(o) { geometry(o, i); });
    else if (o.type in geometryType) geometryType[o.type](o.arcs, i);
  }

  var geometryType = {
    LineString: line,
    MultiLineString: polygon,
    Polygon: polygon,
    MultiPolygon: function(arcs, i) { arcs.forEach(function(arc) { polygon(arc, i); }); }
  };

  objects.forEach(geometry);

  for (var i in indexesByArc) {
    for (var indexes = indexesByArc[i], m = indexes.length, j = 0; j < m; ++j) {
      for (var k = j + 1; k < m; ++k) {
        var ij = indexes[j], ik = indexes[k], n;
        if ((n = neighbors[ij])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ik)] !== ik) n.splice(i, 0, ik);
        if ((n = neighbors[ik])[i = (0,_bisect_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n, ij)] !== ij) n.splice(i, 0, ij);
      }
    }
  }

  return neighbors;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/quantize.js":
/*!******************************************************!*\
  !*** ./node_modules/topojson-client/src/quantize.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _bbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bbox.js */ "./node_modules/topojson-client/src/bbox.js");
/* harmony import */ var _untransform_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./untransform.js */ "./node_modules/topojson-client/src/untransform.js");



/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, transform) {
  if (topology.transform) throw new Error("already quantized");

  if (!transform || !transform.scale) {
    if (!((n = Math.floor(transform)) >= 2)) throw new Error("n must be â‰¥2");
    box = topology.bbox || (0,_bbox_js__WEBPACK_IMPORTED_MODULE_0__["default"])(topology);
    var x0 = box[0], y0 = box[1], x1 = box[2], y1 = box[3], n;
    transform = {scale: [x1 - x0 ? (x1 - x0) / (n - 1) : 1, y1 - y0 ? (y1 - y0) / (n - 1) : 1], translate: [x0, y0]};
  } else {
    box = topology.bbox;
  }

  var t = (0,_untransform_js__WEBPACK_IMPORTED_MODULE_1__["default"])(transform), box, key, inputs = topology.objects, outputs = {};

  function quantizePoint(point) {
    return t(point);
  }

  function quantizeGeometry(input) {
    var output;
    switch (input.type) {
      case "GeometryCollection": output = {type: "GeometryCollection", geometries: input.geometries.map(quantizeGeometry)}; break;
      case "Point": output = {type: "Point", coordinates: quantizePoint(input.coordinates)}; break;
      case "MultiPoint": output = {type: "MultiPoint", coordinates: input.coordinates.map(quantizePoint)}; break;
      default: return input;
    }
    if (input.id != null) output.id = input.id;
    if (input.bbox != null) output.bbox = input.bbox;
    if (input.properties != null) output.properties = input.properties;
    return output;
  }

  function quantizeArc(input) {
    var i = 0, j = 1, n = input.length, p, output = new Array(n); // pessimistic
    output[0] = t(input[0], 0);
    while (++i < n) if ((p = t(input[i], i))[0] || p[1]) output[j++] = p; // non-coincident points
    if (j === 1) output[j++] = [0, 0]; // an arc must have at least two points
    output.length = j;
    return output;
  }

  for (key in inputs) outputs[key] = quantizeGeometry(inputs[key]);

  return {
    type: "Topology",
    bbox: box,
    transform: transform,
    objects: outputs,
    arcs: topology.arcs.map(quantizeArc)
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/reverse.js":
/*!*****************************************************!*\
  !*** ./node_modules/topojson-client/src/reverse.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(array, n) {
  var t, j = array.length, i = j - n;
  while (i < --j) t = array[i], array[i++] = array[j], array[j] = t;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/stitch.js":
/*!****************************************************!*\
  !*** ./node_modules/topojson-client/src/stitch.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(topology, arcs) {
  var stitchedArcs = {},
      fragmentByStart = {},
      fragmentByEnd = {},
      fragments = [],
      emptyIndex = -1;

  // Stitch empty arcs first, since they may be subsumed by other arcs.
  arcs.forEach(function(i, j) {
    var arc = topology.arcs[i < 0 ? ~i : i], t;
    if (arc.length < 3 && !arc[1][0] && !arc[1][1]) {
      t = arcs[++emptyIndex], arcs[emptyIndex] = i, arcs[j] = t;
    }
  });

  arcs.forEach(function(i) {
    var e = ends(i),
        start = e[0],
        end = e[1],
        f, g;

    if (f = fragmentByEnd[start]) {
      delete fragmentByEnd[f.end];
      f.push(i);
      f.end = end;
      if (g = fragmentByStart[end]) {
        delete fragmentByStart[g.start];
        var fg = g === f ? f : f.concat(g);
        fragmentByStart[fg.start = f.start] = fragmentByEnd[fg.end = g.end] = fg;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else if (f = fragmentByStart[end]) {
      delete fragmentByStart[f.start];
      f.unshift(i);
      f.start = start;
      if (g = fragmentByEnd[start]) {
        delete fragmentByEnd[g.end];
        var gf = g === f ? f : g.concat(f);
        fragmentByStart[gf.start = g.start] = fragmentByEnd[gf.end = f.end] = gf;
      } else {
        fragmentByStart[f.start] = fragmentByEnd[f.end] = f;
      }
    } else {
      f = [i];
      fragmentByStart[f.start = start] = fragmentByEnd[f.end = end] = f;
    }
  });

  function ends(i) {
    var arc = topology.arcs[i < 0 ? ~i : i], p0 = arc[0], p1;
    if (topology.transform) p1 = [0, 0], arc.forEach(function(dp) { p1[0] += dp[0], p1[1] += dp[1]; });
    else p1 = arc[arc.length - 1];
    return i < 0 ? [p1, p0] : [p0, p1];
  }

  function flush(fragmentByEnd, fragmentByStart) {
    for (var k in fragmentByEnd) {
      var f = fragmentByEnd[k];
      delete fragmentByStart[f.start];
      delete f.start;
      delete f.end;
      f.forEach(function(i) { stitchedArcs[i < 0 ? ~i : i] = 1; });
      fragments.push(f);
    }
  }

  flush(fragmentByEnd, fragmentByStart);
  flush(fragmentByStart, fragmentByEnd);
  arcs.forEach(function(i) { if (!stitchedArcs[i < 0 ? ~i : i]) fragments.push([i]); });

  return fragments;
}


/***/ }),

/***/ "./node_modules/topojson-client/src/transform.js":
/*!*******************************************************!*\
  !*** ./node_modules/topojson-client/src/transform.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2, n = input.length, output = new Array(n);
    output[0] = (x0 += input[0]) * kx + dx;
    output[1] = (y0 += input[1]) * ky + dy;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/topojson-client/src/untransform.js":
/*!*********************************************************!*\
  !*** ./node_modules/topojson-client/src/untransform.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _identity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./identity.js */ "./node_modules/topojson-client/src/identity.js");


/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__(transform) {
  if (transform == null) return _identity_js__WEBPACK_IMPORTED_MODULE_0__["default"];
  var x0,
      y0,
      kx = transform.scale[0],
      ky = transform.scale[1],
      dx = transform.translate[0],
      dy = transform.translate[1];
  return function(input, i) {
    if (!i) x0 = y0 = 0;
    var j = 2,
        n = input.length,
        output = new Array(n),
        x1 = Math.round((input[0] - dx) / kx),
        y1 = Math.round((input[1] - dy) / ky);
    output[0] = x1 - x0, x0 = x1;
    output[1] = y1 - y0, y0 = y1;
    while (j < n) output[j] = input[j], ++j;
    return output;
  };
}


/***/ }),

/***/ "./node_modules/vega-canvas/build/vega-canvas.browser.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-canvas/build/vega-canvas.browser.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canvas: () => (/* binding */ domCanvas),
/* harmony export */   domCanvas: () => (/* binding */ domCanvas),
/* harmony export */   image: () => (/* binding */ domImage)
/* harmony export */ });
function domCanvas(w, h) {
  if (typeof document !== 'undefined' && document.createElement) {
    const c = document.createElement('canvas');
    if (c && c.getContext) {
      c.width = w;
      c.height = h;
      return c;
    }
  }
  return null;
}
const domImage = () => typeof Image !== 'undefined' ? Image : null;




/***/ }),

/***/ "./node_modules/vega-crossfilter/build/vega-crossfilter.module.js":
/*!************************************************************************!*\
  !*** ./node_modules/vega-crossfilter/build/vega-crossfilter.module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   crossfilter: () => (/* binding */ CrossFilter),
/* harmony export */   resolvefilter: () => (/* binding */ ResolveFilter)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/permute.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");




const array8 = n => new Uint8Array(n);
const array16 = n => new Uint16Array(n);
const array32 = n => new Uint32Array(n);

/**
 * Maintains CrossFilter state.
 */
function Bitmaps() {
  let width = 8,
    data = [],
    seen = array32(0),
    curr = array(0, width),
    prev = array(0, width);
  return {
    data: () => data,
    seen: () => seen = lengthen(seen, data.length),
    add(array) {
      for (let i = 0, j = data.length, n = array.length, t; i < n; ++i) {
        t = array[i];
        t._index = j++;
        data.push(t);
      }
    },
    remove(num, map) {
      // map: index -> boolean (true => remove)
      const n = data.length,
        copy = Array(n - num),
        reindex = data; // reuse old data array for index map
      let t, i, j;

      // seek forward to first removal
      for (i = 0; !map[i] && i < n; ++i) {
        copy[i] = data[i];
        reindex[i] = i;
      }

      // condense arrays
      for (j = i; i < n; ++i) {
        t = data[i];
        if (!map[i]) {
          reindex[i] = j;
          curr[j] = curr[i];
          prev[j] = prev[i];
          copy[j] = t;
          t._index = j++;
        } else {
          reindex[i] = -1;
        }
        curr[i] = 0; // clear unused bits
      }
      data = copy;
      return reindex;
    },
    size: () => data.length,
    curr: () => curr,
    prev: () => prev,
    reset: k => prev[k] = curr[k],
    all: () => width < 0x101 ? 0xff : width < 0x10001 ? 0xffff : 0xffffffff,
    set(k, one) {
      curr[k] |= one;
    },
    clear(k, one) {
      curr[k] &= ~one;
    },
    resize(n, m) {
      const k = curr.length;
      if (n > k || m > width) {
        width = Math.max(m, width);
        curr = array(n, width, curr);
        prev = array(n, width);
      }
    }
  };
}
function lengthen(array, length, copy) {
  if (array.length >= length) return array;
  copy = copy || new array.constructor(length);
  copy.set(array);
  return copy;
}
function array(n, m, array) {
  const copy = (m < 0x101 ? array8 : m < 0x10001 ? array16 : array32)(n);
  if (array) copy.set(array);
  return copy;
}

function Dimension (index, i, query) {
  const bit = 1 << i;
  return {
    one: bit,
    zero: ~bit,
    range: query.slice(),
    bisect: index.bisect,
    index: index.index,
    size: index.size,
    onAdd(added, curr) {
      const dim = this,
        range = dim.bisect(dim.range, added.value),
        idx = added.index,
        lo = range[0],
        hi = range[1],
        n1 = idx.length;
      let i;
      for (i = 0; i < lo; ++i) curr[idx[i]] |= bit;
      for (i = hi; i < n1; ++i) curr[idx[i]] |= bit;
      return dim;
    }
  };
}

/**
 * Maintains a list of values, sorted by key.
 */
function SortedIndex() {
  let index = array32(0),
    value = [],
    size = 0;
  function insert(key, data, base) {
    if (!data.length) return [];
    const n0 = size,
      n1 = data.length,
      addi = array32(n1);
    let addv = Array(n1),
      oldv,
      oldi,
      i;
    for (i = 0; i < n1; ++i) {
      addv[i] = key(data[i]);
      addi[i] = i;
    }
    addv = sort(addv, addi);
    if (n0) {
      oldv = value;
      oldi = index;
      value = Array(n0 + n1);
      index = array32(n0 + n1);
      merge(base, oldv, oldi, n0, addv, addi, n1, value, index);
    } else {
      if (base > 0) for (i = 0; i < n1; ++i) {
        addi[i] += base;
      }
      value = addv;
      index = addi;
    }
    size = n0 + n1;
    return {
      index: addi,
      value: addv
    };
  }
  function remove(num, map) {
    // map: index -> remove
    const n = size;
    let idx, i, j;

    // seek forward to first removal
    for (i = 0; !map[index[i]] && i < n; ++i);

    // condense index and value arrays
    for (j = i; i < n; ++i) {
      if (!map[idx = index[i]]) {
        index[j] = idx;
        value[j] = value[i];
        ++j;
      }
    }
    size = n - num;
  }
  function reindex(map) {
    for (let i = 0, n = size; i < n; ++i) {
      index[i] = map[index[i]];
    }
  }
  function bisect(range, array) {
    let n;
    if (array) {
      n = array.length;
    } else {
      array = value;
      n = size;
    }
    return [(0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectLeft)(array, range[0], 0, n), (0,d3_array__WEBPACK_IMPORTED_MODULE_2__.bisectRight)(array, range[1], 0, n)];
  }
  return {
    insert: insert,
    remove: remove,
    bisect: bisect,
    reindex: reindex,
    index: () => index,
    size: () => size
  };
}
function sort(values, index) {
  values.sort.call(index, (a, b) => {
    const x = values[a],
      y = values[b];
    return x < y ? -1 : x > y ? 1 : 0;
  });
  return (0,d3_array__WEBPACK_IMPORTED_MODULE_3__["default"])(values, index);
}
function merge(base, value0, index0, n0, value1, index1, n1, value, index) {
  let i0 = 0,
    i1 = 0,
    i;
  for (i = 0; i0 < n0 && i1 < n1; ++i) {
    if (value0[i0] < value1[i1]) {
      value[i] = value0[i0];
      index[i] = index0[i0++];
    } else {
      value[i] = value1[i1];
      index[i] = index1[i1++] + base;
    }
  }
  for (; i0 < n0; ++i0, ++i) {
    value[i] = value0[i0];
    index[i] = index0[i0];
  }
  for (; i1 < n1; ++i1, ++i) {
    value[i] = value1[i1];
    index[i] = index1[i1] + base;
  }
}

/**
 * An indexed multi-dimensional filter.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of dimension accessors to filter.
 * @param {Array} params.query - An array of per-dimension range queries.
 */
function CrossFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, Bitmaps(), params);
  this._indices = null;
  this._dims = null;
}
CrossFilter.Definition = {
  'type': 'CrossFilter',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'query',
    'type': 'array',
    'array': true,
    'required': true,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(CrossFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!this._dims) {
      return this.init(_, pulse);
    } else {
      var init = _.modified('fields') || _.fields.some(f => pulse.modified(f.fields));
      return init ? this.reinit(_, pulse) : this.eval(_, pulse);
    }
  },
  init(_, pulse) {
    const fields = _.fields,
      query = _.query,
      indices = this._indices = {},
      dims = this._dims = [],
      m = query.length;
    let i = 0,
      key,
      index;

    // instantiate indices and dimensions
    for (; i < m; ++i) {
      key = fields[i].fname;
      index = indices[key] || (indices[key] = SortedIndex());
      dims.push(Dimension(index, i, query[i]));
    }
    return this.eval(_, pulse);
  },
  reinit(_, pulse) {
    const output = pulse.materialize().fork(),
      fields = _.fields,
      query = _.query,
      indices = this._indices,
      dims = this._dims,
      bits = this.value,
      curr = bits.curr(),
      prev = bits.prev(),
      all = bits.all(),
      out = output.rem = output.add,
      mod = output.mod,
      m = query.length,
      adds = {};
    let add, index, key, mods, remMap, modMap, i, n, f;

    // set prev to current state
    prev.set(curr);

    // if pulse has remove tuples, process them first
    if (pulse.rem.length) {
      remMap = this.remove(_, pulse, output);
    }

    // if pulse has added tuples, add them to state
    if (pulse.add.length) {
      bits.add(pulse.add);
    }

    // if pulse has modified tuples, create an index map
    if (pulse.mod.length) {
      modMap = {};
      for (mods = pulse.mod, i = 0, n = mods.length; i < n; ++i) {
        modMap[mods[i]._index] = 1;
      }
    }

    // re-initialize indices as needed, update curr bitmap
    for (i = 0; i < m; ++i) {
      f = fields[i];
      if (!dims[i] || _.modified('fields', i) || pulse.modified(f.fields)) {
        key = f.fname;
        if (!(add = adds[key])) {
          indices[key] = index = SortedIndex();
          adds[key] = add = index.insert(f, pulse.source, 0);
        }
        dims[i] = Dimension(index, i, query[i]).onAdd(add, curr);
      }
    }

    // visit each tuple
    // if filter state changed, push index to add/rem
    // else if in mod and passes a filter, push index to mod
    for (i = 0, n = bits.data().length; i < n; ++i) {
      if (remMap[i]) {
        // skip if removed tuple
        continue;
      } else if (prev[i] !== curr[i]) {
        // add if state changed
        out.push(i);
      } else if (modMap[i] && curr[i] !== all) {
        // otherwise, pass mods through
        mod.push(i);
      }
    }
    bits.mask = (1 << m) - 1;
    return output;
  },
  eval(_, pulse) {
    const output = pulse.materialize().fork(),
      m = this._dims.length;
    let mask = 0;
    if (pulse.rem.length) {
      this.remove(_, pulse, output);
      mask |= (1 << m) - 1;
    }
    if (_.modified('query') && !_.modified('fields')) {
      mask |= this.update(_, pulse, output);
    }
    if (pulse.add.length) {
      this.insert(_, pulse, output);
      mask |= (1 << m) - 1;
    }
    if (pulse.mod.length) {
      this.modify(pulse, output);
      mask |= (1 << m) - 1;
    }
    this.value.mask = mask;
    return output;
  },
  insert(_, pulse, output) {
    const tuples = pulse.add,
      bits = this.value,
      dims = this._dims,
      indices = this._indices,
      fields = _.fields,
      adds = {},
      out = output.add,
      n = bits.size() + tuples.length,
      m = dims.length;
    let k = bits.size(),
      j,
      key,
      add;

    // resize bitmaps and add tuples as needed
    bits.resize(n, m);
    bits.add(tuples);
    const curr = bits.curr(),
      prev = bits.prev(),
      all = bits.all();

    // add to dimensional indices
    for (j = 0; j < m; ++j) {
      key = fields[j].fname;
      add = adds[key] || (adds[key] = indices[key].insert(fields[j], tuples, k));
      dims[j].onAdd(add, curr);
    }

    // set previous filters, output if passes at least one filter
    for (; k < n; ++k) {
      prev[k] = all;
      if (curr[k] !== all) out.push(k);
    }
  },
  modify(pulse, output) {
    const out = output.mod,
      bits = this.value,
      curr = bits.curr(),
      all = bits.all(),
      tuples = pulse.mod;
    let i, n, k;
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      if (curr[k] !== all) out.push(k);
    }
  },
  remove(_, pulse, output) {
    const indices = this._indices,
      bits = this.value,
      curr = bits.curr(),
      prev = bits.prev(),
      all = bits.all(),
      map = {},
      out = output.rem,
      tuples = pulse.rem;
    let i, n, k, f;

    // process tuples, output if passes at least one filter
    for (i = 0, n = tuples.length; i < n; ++i) {
      k = tuples[i]._index;
      map[k] = 1; // build index map
      prev[k] = f = curr[k];
      curr[k] = all;
      if (f !== all) out.push(k);
    }

    // remove from dimensional indices
    for (k in indices) {
      indices[k].remove(n, map);
    }
    this.reindex(pulse, n, map);
    return map;
  },
  // reindex filters and indices after propagation completes
  reindex(pulse, num, map) {
    const indices = this._indices,
      bits = this.value;
    pulse.runAfter(() => {
      const indexMap = bits.remove(num, map);
      for (const key in indices) indices[key].reindex(indexMap);
    });
  },
  update(_, pulse, output) {
    const dims = this._dims,
      query = _.query,
      stamp = pulse.stamp,
      m = dims.length;
    let mask = 0,
      i,
      q;

    // survey how many queries have changed
    output.filters = 0;
    for (q = 0; q < m; ++q) {
      if (_.modified('query', q)) {
        i = q;
        ++mask;
      }
    }
    if (mask === 1) {
      // only one query changed, use more efficient update
      mask = dims[i].one;
      this.incrementOne(dims[i], query[i], output.add, output.rem);
    } else {
      // multiple queries changed, perform full record keeping
      for (q = 0, mask = 0; q < m; ++q) {
        if (!_.modified('query', q)) continue;
        mask |= dims[q].one;
        this.incrementAll(dims[q], query[q], stamp, output.add);
        output.rem = output.add; // duplicate add/rem for downstream resolve
      }
    }
    return mask;
  },
  incrementAll(dim, query, stamp, out) {
    const bits = this.value,
      seen = bits.seen(),
      curr = bits.curr(),
      prev = bits.prev(),
      index = dim.index(),
      old = dim.bisect(dim.range),
      range = dim.bisect(query),
      lo1 = range[0],
      hi1 = range[1],
      lo0 = old[0],
      hi0 = old[1],
      one = dim.one;
    let i, j, k;

    // Fast incremental update based on previous lo index.
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one;
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one;
      }
    }

    // Fast incremental update based on previous hi index.
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one;
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];
        if (seen[k] !== stamp) {
          prev[k] = curr[k];
          seen[k] = stamp;
          out.push(k);
        }
        curr[k] ^= one;
      }
    }
    dim.range = query.slice();
  },
  incrementOne(dim, query, add, rem) {
    const bits = this.value,
      curr = bits.curr(),
      index = dim.index(),
      old = dim.bisect(dim.range),
      range = dim.bisect(query),
      lo1 = range[0],
      hi1 = range[1],
      lo0 = old[0],
      hi0 = old[1],
      one = dim.one;
    let i, j, k;

    // Fast incremental update based on previous lo index.
    if (lo1 < lo0) {
      for (i = lo1, j = Math.min(lo0, hi1); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (lo1 > lo0) {
      for (i = lo0, j = Math.min(lo1, hi0); i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    }

    // Fast incremental update based on previous hi index.
    if (hi1 > hi0) {
      for (i = Math.max(lo1, hi0), j = hi1; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        add.push(k);
      }
    } else if (hi1 < hi0) {
      for (i = Math.max(lo0, hi1), j = hi0; i < j; ++i) {
        k = index[i];
        curr[k] ^= one;
        rem.push(k);
      }
    }
    dim.range = query.slice();
  }
});

/**
 * Selectively filters tuples by resolving against a filter bitmap.
 * Useful for processing the output of a cross-filter transform.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.ignore - A bit mask indicating which filters to ignore.
 * @param {object} params.filter - The per-tuple filter bitmaps. Typically this
 *   parameter value is a reference to a {@link CrossFilter} transform.
 */
function ResolveFilter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
ResolveFilter.Definition = {
  'type': 'ResolveFilter',
  'metadata': {},
  'params': [{
    'name': 'ignore',
    'type': 'number',
    'required': true,
    'description': 'A bit mask indicating which filters to ignore.'
  }, {
    'name': 'filter',
    'type': 'object',
    'required': true,
    'description': 'Per-tuple filter bitmaps from a CrossFilter transform.'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(ResolveFilter, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const ignore = ~(_.ignore || 0),
      // bit mask where zeros -> dims to ignore
      bitmap = _.filter,
      mask = bitmap.mask;

    // exit early if no relevant filter changes
    if ((mask & ignore) === 0) return pulse.StopPropagation;
    const output = pulse.fork(pulse.ALL),
      data = bitmap.data(),
      curr = bitmap.curr(),
      prev = bitmap.prev(),
      pass = k => !(curr[k] & ignore) ? data[k] : null;

    // propagate all mod tuples that pass the filter
    output.filter(output.MOD, pass);

    // determine add & rem tuples via filter functions
    // for efficiency, we do *not* populate new arrays,
    // instead we add filter functions applied downstream

    if (!(mask & mask - 1)) {
      // only one filter changed
      output.filter(output.ADD, pass);
      output.filter(output.REM, k => (curr[k] & ignore) === mask ? data[k] : null);
    } else {
      // multiple filters changed
      output.filter(output.ADD, k => {
        const c = curr[k] & ignore,
          f = !c && c ^ prev[k] & ignore;
        return f ? data[k] : null;
      });
      output.filter(output.REM, k => {
        const c = curr[k] & ignore,
          f = c && !(c ^ (c ^ prev[k] & ignore));
        return f ? data[k] : null;
      });
    }

    // add filter to source data in case of reflow...
    return output.filter(output.SOURCE, t => pass(t._index));
  }
});




/***/ }),

/***/ "./node_modules/vega-dataflow/build/vega-dataflow.module.js":
/*!******************************************************************!*\
  !*** ./node_modules/vega-dataflow/build/vega-dataflow.module.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Dataflow: () => (/* binding */ Dataflow),
/* harmony export */   EventStream: () => (/* binding */ EventStream),
/* harmony export */   MultiPulse: () => (/* binding */ MultiPulse),
/* harmony export */   Operator: () => (/* binding */ Operator),
/* harmony export */   Parameters: () => (/* binding */ Parameters),
/* harmony export */   Pulse: () => (/* binding */ Pulse),
/* harmony export */   Transform: () => (/* binding */ Transform),
/* harmony export */   UniqueList: () => (/* binding */ UniqueList),
/* harmony export */   asyncCallback: () => (/* binding */ asyncCallback),
/* harmony export */   changeset: () => (/* binding */ changeset),
/* harmony export */   definition: () => (/* binding */ definition),
/* harmony export */   derive: () => (/* binding */ derive),
/* harmony export */   ingest: () => (/* binding */ ingest$1),
/* harmony export */   isChangeSet: () => (/* binding */ isChangeSet),
/* harmony export */   isTuple: () => (/* binding */ isTuple),
/* harmony export */   rederive: () => (/* binding */ rederive),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   stableCompare: () => (/* binding */ stableCompare),
/* harmony export */   transform: () => (/* binding */ transform),
/* harmony export */   transforms: () => (/* binding */ transforms),
/* harmony export */   tupleid: () => (/* binding */ tupleid)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-loader */ "./node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");




function UniqueList(idFunc) {
  const $ = idFunc || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
    list = [],
    ids = {};
  list.add = _ => {
    const id = $(_);
    if (!ids[id]) {
      ids[id] = 1;
      list.push(_);
    }
    return list;
  };
  list.remove = _ => {
    const id = $(_);
    if (ids[id]) {
      ids[id] = 0;
      const idx = list.indexOf(_);
      if (idx >= 0) list.splice(idx, 1);
    }
    return list;
  };
  return list;
}

/**
 * Invoke and await a potentially async callback function. If
 * an error occurs, trap it and route to Dataflow.error.
 * @param {Dataflow} df - The dataflow instance
 * @param {function} callback - A callback function to invoke
 *   and then await. The dataflow will be passed as the single
 *   argument to the function.
 */
async function asyncCallback (df, callback) {
  try {
    await callback(df);
  } catch (err) {
    df.error(err);
  }
}

const TUPLE_ID_KEY = Symbol('vega_id');
let TUPLE_ID = 1;

/**
 * Checks if an input value is a registered tuple.
 * @param {*} t - The value to check.
 * @return {boolean} True if the input is a tuple, false otherwise.
 */
function isTuple(t) {
  return !!(t && tupleid(t));
}

/**
 * Returns the id of a tuple.
 * @param {object} t - The input tuple.
 * @return {*} the tuple id.
 */
function tupleid(t) {
  return t[TUPLE_ID_KEY];
}

/**
 * Sets the id of a tuple.
 * @param {object} t - The input tuple.
 * @param {*} id - The id value to set.
 * @return {object} the input tuple.
 */
function setid(t, id) {
  t[TUPLE_ID_KEY] = id;
  return t;
}

/**
 * Ingest an object or value as a data tuple.
 * If the input value is an object, an id field will be added to it. For
 * efficiency, the input object is modified directly. A copy is not made.
 * If the input value is a literal, it will be wrapped in a new object
 * instance, with the value accessible as the 'data' property.
 * @param datum - The value to ingest.
 * @return {object} The ingested data tuple.
 */
function ingest$1(datum) {
  const t = datum === Object(datum) ? datum : {
    data: datum
  };
  return tupleid(t) ? t : setid(t, TUPLE_ID++);
}

/**
 * Given a source tuple, return a derived copy.
 * @param {object} t - The source tuple.
 * @return {object} The derived tuple.
 */
function derive(t) {
  return rederive(t, ingest$1({}));
}

/**
 * Rederive a derived tuple by copying values from the source tuple.
 * @param {object} t - The source tuple.
 * @param {object} d - The derived tuple.
 * @return {object} The derived tuple.
 */
function rederive(t, d) {
  for (const k in t) d[k] = t[k];
  return d;
}

/**
 * Replace an existing tuple with a new tuple.
 * @param {object} t - The existing data tuple.
 * @param {object} d - The new tuple that replaces the old.
 * @return {object} The new tuple.
 */
function replace(t, d) {
  return setid(d, tupleid(t));
}

/**
 * Generate an augmented comparator function that provides stable
 * sorting by tuple id when the given comparator produces ties.
 * @param {function} cmp - The comparator to augment.
 * @param {function} [f] - Optional tuple accessor function.
 * @return {function} An augmented comparator function.
 */
function stableCompare(cmp, f) {
  return !cmp ? null : f ? (a, b) => cmp(a, b) || tupleid(f(a)) - tupleid(f(b)) : (a, b) => cmp(a, b) || tupleid(a) - tupleid(b);
}

function isChangeSet(v) {
  return v && v.constructor === changeset;
}
function changeset() {
  const add = [],
    // insert tuples
    rem = [],
    // remove tuples
    mod = [],
    // modify tuples
    remp = [],
    // remove by predicate
    modp = []; // modify by predicate
  let clean = null,
    reflow = false;
  return {
    constructor: changeset,
    insert(t) {
      const d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
        n = d.length;
      for (let i = 0; i < n; ++i) add.push(d[i]);
      return this;
    },
    remove(t) {
      const a = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t) ? remp : rem,
        d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(t),
        n = d.length;
      for (let i = 0; i < n; ++i) a.push(d[i]);
      return this;
    },
    modify(t, field, value) {
      const m = {
        field: field,
        value: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(value)
      };
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) {
        m.filter = t;
        modp.push(m);
      } else {
        m.tuple = t;
        mod.push(m);
      }
      return this;
    },
    encode(t, set) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(t)) modp.push({
        filter: t,
        field: set
      });else mod.push({
        tuple: t,
        field: set
      });
      return this;
    },
    clean(value) {
      clean = value;
      return this;
    },
    reflow() {
      reflow = true;
      return this;
    },
    pulse(pulse, tuples) {
      const cur = {},
        out = {};
      let i, n, m, f, t, id;

      // build lookup table of current tuples
      for (i = 0, n = tuples.length; i < n; ++i) {
        cur[tupleid(tuples[i])] = 1;
      }

      // process individual tuples to remove
      for (i = 0, n = rem.length; i < n; ++i) {
        t = rem[i];
        cur[tupleid(t)] = -1;
      }

      // process predicate-based removals
      for (i = 0, n = remp.length; i < n; ++i) {
        f = remp[i];
        tuples.forEach(t => {
          if (f(t)) cur[tupleid(t)] = -1;
        });
      }

      // process all add tuples
      for (i = 0, n = add.length; i < n; ++i) {
        t = add[i];
        id = tupleid(t);
        if (cur[id]) {
          // tuple already resides in dataset
          // if flagged for both add and remove, cancel
          cur[id] = 1;
        } else {
          // tuple does not reside in dataset, add
          pulse.add.push(ingest$1(add[i]));
        }
      }

      // populate pulse rem list
      for (i = 0, n = tuples.length; i < n; ++i) {
        t = tuples[i];
        if (cur[tupleid(t)] < 0) pulse.rem.push(t);
      }

      // modify helper method
      function modify(t, f, v) {
        if (v) {
          t[f] = v(t);
        } else {
          pulse.encode = f;
        }
        if (!reflow) out[tupleid(t)] = t;
      }

      // process individual tuples to modify
      for (i = 0, n = mod.length; i < n; ++i) {
        m = mod[i];
        t = m.tuple;
        f = m.field;
        id = cur[tupleid(t)];
        if (id > 0) {
          modify(t, f, m.value);
          pulse.modifies(f);
        }
      }

      // process predicate-based modifications
      for (i = 0, n = modp.length; i < n; ++i) {
        m = modp[i];
        f = m.filter;
        tuples.forEach(t => {
          if (f(t) && cur[tupleid(t)] > 0) {
            modify(t, m.field, m.value);
          }
        });
        pulse.modifies(m.field);
      }

      // upon reflow request, populate mod with all non-removed tuples
      // otherwise, populate mod with modified tuples only
      if (reflow) {
        pulse.mod = rem.length || remp.length ? tuples.filter(t => cur[tupleid(t)] > 0) : tuples.slice();
      } else {
        for (id in out) pulse.mod.push(out[id]);
      }

      // set pulse garbage collection request
      if (clean || clean == null && (rem.length || remp.length)) {
        pulse.clean(true);
      }
      return pulse;
    }
  };
}

const CACHE = '_:mod:_';

/**
 * Hash that tracks modifications to assigned values.
 * Callers *must* use the set method to update values.
 */
function Parameters() {
  Object.defineProperty(this, CACHE, {
    writable: true,
    value: {}
  });
}
Parameters.prototype = {
  /**
   * Set a parameter value. If the parameter value changes, the parameter
   * will be recorded as modified.
   * @param {string} name - The parameter name.
   * @param {number} index - The index into an array-value parameter. Ignored if
   *   the argument is undefined, null or less than zero.
   * @param {*} value - The parameter value to set.
   * @param {boolean} [force=false] - If true, records the parameter as modified
   *   even if the value is unchanged.
   * @return {Parameters} - This parameter object.
   */
  set(name, index, value, force) {
    const o = this,
      v = o[name],
      mod = o[CACHE];
    if (index != null && index >= 0) {
      if (v[index] !== value || force) {
        v[index] = value;
        mod[index + ':' + name] = -1;
        mod[name] = -1;
      }
    } else if (v !== value || force) {
      o[name] = value;
      mod[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? 1 + value.length : -1;
    }
    return o;
  },
  /**
   * Tests if one or more parameters has been modified. If invoked with no
   * arguments, returns true if any parameter value has changed. If the first
   * argument is array, returns trues if any parameter name in the array has
   * changed. Otherwise, tests if the given name and optional array index has
   * changed.
   * @param {string} name - The parameter name to test.
   * @param {number} [index=undefined] - The parameter array index to test.
   * @return {boolean} - Returns true if a queried parameter was modified.
   */
  modified(name, index) {
    const mod = this[CACHE];
    if (!arguments.length) {
      for (const k in mod) {
        if (mod[k]) return true;
      }
      return false;
    } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(name)) {
      for (let k = 0; k < name.length; ++k) {
        if (mod[name[k]]) return true;
      }
      return false;
    }
    return index != null && index >= 0 ? index + 1 < mod[name] || !!mod[index + ':' + name] : !!mod[name];
  },
  /**
   * Clears the modification records. After calling this method,
   * all parameters are considered unmodified.
   */
  clear() {
    this[CACHE] = {};
    return this;
  }
};

let OP_ID = 0;
const PULSE = 'pulse',
  NO_PARAMS = new Parameters();

// Boolean Flags
const SKIP$1 = 1,
  MODIFIED = 2;

/**
 * An Operator is a processing node in a dataflow graph.
 * Each operator stores a value and an optional value update function.
 * Operators can accept a hash of named parameters. Parameter values can
 * either be direct (JavaScript literals, arrays, objects) or indirect
 * (other operators whose values will be pulled dynamically). Operators
 * included as parameters will have this operator added as a dependency.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {function(object, Pulse)} [update] - An update function. Upon
 *   evaluation of this operator, the update function will be invoked and the
 *   return value will be used as the new value of this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @see parameters
 */
function Operator(init, update, params, react) {
  this.id = ++OP_ID;
  this.value = init;
  this.stamp = -1;
  this.rank = -1;
  this.qrank = -1;
  this.flags = 0;
  if (update) {
    this._update = update;
  }
  if (params) this.parameters(params, react);
}
function flag(bit) {
  return function (state) {
    const f = this.flags;
    if (arguments.length === 0) return !!(f & bit);
    this.flags = state ? f | bit : f & ~bit;
    return this;
  };
}
Operator.prototype = {
  /**
   * Returns a list of target operators dependent on this operator.
   * If this list does not exist, it is created and then returned.
   * @return {UniqueList}
   */
  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },
  /**
   * Sets the value of this operator.
   * @param {*} value - the value to set.
   * @return {Number} Returns 1 if the operator value has changed
   *   according to strict equality, returns 0 otherwise.
   */
  set(value) {
    if (this.value !== value) {
      this.value = value;
      return 1;
    } else {
      return 0;
    }
  },
  /**
   * Indicates that operator evaluation should be skipped on the next pulse.
   * This operator will still propagate incoming pulses, but its update function
   * will not be invoked. The skip flag is reset after every pulse, so calling
   * this method will affect processing of the next pulse only.
   */
  skip: flag(SKIP$1),
  /**
   * Indicates that this operator's value has been modified on its most recent
   * pulse. Normally modification is checked via strict equality; however, in
   * some cases it is more efficient to update the internal state of an object.
   * In those cases, the modified flag can be used to trigger propagation. Once
   * set, the modification flag persists across pulses until unset. The flag can
   * be used with the last timestamp to test if a modification is recent.
   */
  modified: flag(MODIFIED),
  /**
   * Sets the parameters for this operator. The parameter values are analyzed for
   * operator instances. If found, this operator will be added as a dependency
   * of the parameterizing operator. Operator values are dynamically marshalled
   * from each operator parameter prior to evaluation. If a parameter value is
   * an array, the array will also be searched for Operator instances. However,
   * the search does not recurse into sub-arrays or object properties.
   * @param {object} params - A hash of operator parameters.
   * @param {boolean} [react=true] - A flag indicating if this operator should
   *   automatically update (react) when parameter values change. In other words,
   *   this flag determines if the operator registers itself as a listener on
   *   any upstream operators included in the parameters.
   * @param {boolean} [initonly=false] - A flag indicating if this operator
   *   should calculate an update only upon its initial evaluation, then
   *   deregister dependencies and suppress all future update invocations.
   * @return {Operator[]} - An array of upstream dependencies.
   */
  parameters(params, react, initonly) {
    react = react !== false;
    const argval = this._argval = this._argval || new Parameters(),
      argops = this._argops = this._argops || [],
      deps = [];
    let name, value, n, i;
    const add = (name, index, value) => {
      if (value instanceof Operator) {
        if (value !== this) {
          if (react) value.targets().add(this);
          deps.push(value);
        }
        argops.push({
          op: value,
          name: name,
          index: index
        });
      } else {
        argval.set(name, index, value);
      }
    };
    for (name in params) {
      value = params[name];
      if (name === PULSE) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(value).forEach(op => {
          if (!(op instanceof Operator)) {
            (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Pulse parameters must be operator instances.');
          } else if (op !== this) {
            op.targets().add(this);
            deps.push(op);
          }
        });
        this.source = value;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
        argval.set(name, -1, Array(n = value.length));
        for (i = 0; i < n; ++i) add(name, i, value[i]);
      } else {
        add(name, -1, value);
      }
    }
    this.marshall().clear(); // initialize values
    if (initonly) argops.initonly = true;
    return deps;
  },
  /**
   * Internal method for marshalling parameter values.
   * Visits each operator dependency to pull the latest value.
   * @return {Parameters} A Parameters object to pass to the update function.
   */
  marshall(stamp) {
    const argval = this._argval || NO_PARAMS,
      argops = this._argops;
    let item, i, op, mod;
    if (argops) {
      const n = argops.length;
      for (i = 0; i < n; ++i) {
        item = argops[i];
        op = item.op;
        mod = op.modified() && op.stamp === stamp;
        argval.set(item.name, item.index, op.value, mod);
      }
      if (argops.initonly) {
        for (i = 0; i < n; ++i) {
          item = argops[i];
          item.op.targets().remove(this);
        }
        this._argops = null;
        this._update = null;
      }
    }
    return argval;
  },
  /**
   * Detach this operator from the dataflow.
   * Unregisters listeners on upstream dependencies.
   */
  detach() {
    const argops = this._argops;
    let i, n, item, op;
    if (argops) {
      for (i = 0, n = argops.length; i < n; ++i) {
        item = argops[i];
        op = item.op;
        if (op._targets) {
          op._targets.remove(this);
        }
      }
    }

    // remove references to the source and pulse object,
    // if present, to prevent memory leaks of old data.
    this.pulse = null;
    this.source = null;
  },
  /**
   * Delegate method to perform operator processing.
   * Subclasses can override this method to perform custom processing.
   * By default, it marshalls parameters and calls the update function
   * if that function is defined. If the update function does not
   * change the operator value then StopPropagation is returned.
   * If no update function is defined, this method does nothing.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return The output pulse or StopPropagation. A falsy return value
   *   (including undefined) will let the input pulse pass through.
   */
  evaluate(pulse) {
    const update = this._update;
    if (update) {
      const params = this.marshall(pulse.stamp),
        v = update.call(this, params, pulse);
      params.clear();
      if (v !== this.value) {
        this.value = v;
      } else if (!this.modified()) {
        return pulse.StopPropagation;
      }
    }
  },
  /**
   * Run this operator for the current pulse. If this operator has already
   * been run at (or after) the pulse timestamp, returns StopPropagation.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
      rv = 0;
    } else {
      rv = this.evaluate(pulse);
    }
    return this.pulse = rv || pulse;
  }
};

/**
 * Add an operator to the dataflow graph. This function accepts a
 * variety of input argument types. The basic signature supports an
 * initial value, update function and parameters. If the first parameter
 * is an Operator instance, it will be added directly. If it is a
 * constructor for an Operator subclass, a new instance will be instantiated.
 * Otherwise, if the first parameter is a function instance, it will be used
 * as the update function and a null initial value is assumed.
 * @param {*} init - One of: the operator to add, the initial value of
 *   the operator, an operator class to instantiate, or an update function.
 * @param {function} [update] - The operator update function.
 * @param {object} [params] - The operator parameters.
 * @param {boolean} [react=true] - Flag indicating if this operator should
 *   listen for changes to upstream operators included as parameters.
 * @return {Operator} - The added operator.
 */
function add (init, update, params, react) {
  let shift = 1,
    op;
  if (init instanceof Operator) {
    op = init;
  } else if (init && init.prototype instanceof Operator) {
    op = new init();
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(init)) {
    op = new Operator(null, init);
  } else {
    shift = 0;
    op = new Operator(init, update);
  }
  this.rank(op);
  if (shift) {
    react = params;
    params = update;
  }
  if (params) this.connect(op, op.parameters(params, react));
  this.touch(op);
  return op;
}

/**
 * Connect a target operator as a dependent of source operators.
 * If necessary, this method will rerank the target operator and its
 * dependents to ensure propagation proceeds in a topologically sorted order.
 * @param {Operator} target - The target operator.
 * @param {Array<Operator>} - The source operators that should propagate
 *   to the target operator.
 */
function connect (target, sources) {
  const targetRank = target.rank,
    n = sources.length;
  for (let i = 0; i < n; ++i) {
    if (targetRank < sources[i].rank) {
      this.rerank(target);
      return;
    }
  }
}

let STREAM_ID = 0;

/**
 * Models an event stream.
 * @constructor
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @param {function(Object)} [receive] - Event callback function to invoke
 *   upon receipt of a new event. Use to override standard event processing.
 */
function EventStream(filter, apply, receive) {
  this.id = ++STREAM_ID;
  this.value = null;
  if (receive) this.receive = receive;
  if (filter) this._filter = filter;
  if (apply) this._apply = apply;
}

/**
 * Creates a new event stream instance with the provided
 * (optional) filter, apply and receive functions.
 * @param {function(Object, number): boolean} [filter] - Filter predicate.
 *   Events pass through when truthy, events are suppressed when falsy.
 * @param {function(Object): *} [apply] - Applied to input events to produce
 *   new event values.
 * @see EventStream
 */
function stream(filter, apply, receive) {
  return new EventStream(filter, apply, receive);
}
EventStream.prototype = {
  _filter: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  _apply: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
  targets() {
    return this._targets || (this._targets = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id));
  },
  consume(_) {
    if (!arguments.length) return !!this._consume;
    this._consume = !!_;
    return this;
  },
  receive(evt) {
    if (this._filter(evt)) {
      const val = this.value = this._apply(evt),
        trg = this._targets,
        n = trg ? trg.length : 0;
      for (let i = 0; i < n; ++i) trg[i].receive(val);
      if (this._consume) {
        evt.preventDefault();
        evt.stopPropagation();
      }
    }
  },
  filter(filter) {
    const s = stream(filter);
    this.targets().add(s);
    return s;
  },
  apply(apply) {
    const s = stream(null, apply);
    this.targets().add(s);
    return s;
  },
  merge() {
    const s = stream();
    this.targets().add(s);
    for (let i = 0, n = arguments.length; i < n; ++i) {
      arguments[i].targets().add(s);
    }
    return s;
  },
  throttle(pause) {
    let t = -1;
    return this.filter(() => {
      const now = Date.now();
      if (now - t > pause) {
        t = now;
        return 1;
      } else {
        return 0;
      }
    });
  },
  debounce(delay) {
    const s = stream();
    this.targets().add(stream(null, null, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(delay, e => {
      const df = e.dataflow;
      s.receive(e);
      if (df && df.run) df.run();
    })));
    return s;
  },
  between(a, b) {
    let active = false;
    a.targets().add(stream(null, null, () => active = true));
    b.targets().add(stream(null, null, () => active = false));
    return this.filter(() => active);
  },
  detach() {
    // ensures compatibility with operators (#2753)
    // remove references to other streams and filter functions that may
    // be bound to subcontexts that need to be garbage collected.
    this._filter = vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
    this._targets = null;
  }
};

/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor. The input must
 *  support the addEventListener method.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @param {function(object): *} [apply] - Event application function.
 *   If provided, this function will be invoked and the result will be
 *   used as the downstream event value.
 * @return {EventStream}
 */
function events (source, type, filter, apply) {
  const df = this,
    s = stream(filter, apply),
    send = function (e) {
      e.dataflow = df;
      try {
        s.receive(e);
      } catch (error) {
        df.error(error);
      } finally {
        df.run();
      }
    };
  let sources;
  if (typeof source === 'string' && typeof document !== 'undefined') {
    sources = document.querySelectorAll(source);
  } else {
    sources = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(source);
  }
  const n = sources.length;
  for (let i = 0; i < n; ++i) {
    sources[i].addEventListener(type, send);
  }
  return s;
}

function parse(data, format) {
  const locale = this.locale();
  return (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.read)(data, format, locale.timeParse, locale.utcParse);
}

/**
 * Ingests new data into the dataflow. First parses the data using the
 * vega-loader read method, then pulses a changeset to the target operator.
 * @param {Operator} target - The Operator to target with ingested data,
 *   typically a Collect transform instance.
 * @param {*} data - The input data, prior to parsing. For JSON this may
 *   be a string or an object. For CSV, TSV, etc should be a string.
 * @param {object} format - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @returns {Dataflow}
 */
function ingest(target, data, format) {
  data = this.parse(data, format);
  return this.pulse(target, this.changeset().insert(data));
}

/**
 * Request data from an external source, parse it, and return a Promise.
 * @param {string} url - The URL from which to load the data. This string
 *   is passed to the vega-loader load method.
 * @param {object} [format] - The data format description for parsing
 *   loaded data. This object is passed to the vega-loader read method.
 * @return {Promise} A Promise that resolves upon completion of the request.
 *   The resolved object contains the following properties:
 *   - data: an array of parsed data (or null upon error)
 *   - status: a code for success (0), load fail (-1), or parse fail (-2)
 */
async function request(url, format) {
  const df = this;
  let status = 0,
    data;
  try {
    data = await df.loader().load(url, {
      context: 'dataflow',
      response: (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.responseType)(format && format.type)
    });
    try {
      data = df.parse(data, format);
    } catch (err) {
      status = -2;
      df.warn('Data ingestion failed', url, err);
    }
  } catch (err) {
    status = -1;
    df.warn('Loading failed', url, err);
  }
  return {
    data,
    status
  };
}
async function preload(target, url, format) {
  const df = this,
    pending = df._pending || loadPending(df);
  pending.requests += 1;
  const res = await df.request(url, format);
  df.pulse(target, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(res.data || []));
  pending.done();
  return res;
}
function loadPending(df) {
  let accept;
  const pending = new Promise(a => accept = a);
  pending.requests = 0;
  pending.done = () => {
    if (--pending.requests === 0) {
      df._pending = null;
      accept(df);
    }
  };
  return df._pending = pending;
}

const SKIP = {
  skip: true
};

/**
 * Perform operator updates in response to events. Applies an
 * update function to compute a new operator value. If the update function
 * returns a {@link ChangeSet}, the operator will be pulsed with those tuple
 * changes. Otherwise, the operator value will be updated to the return value.
 * @param {EventStream|Operator} source - The event source to react to.
 *   This argument can be either an EventStream or an Operator.
 * @param {Operator|function(object):Operator} target - The operator to update.
 *   This argument can either be an Operator instance or (if the source
 *   argument is an EventStream), a function that accepts an event object as
 *   input and returns an Operator to target.
 * @param {function(Parameters,Event): *} [update] - Optional update function
 *   to compute the new operator value, or a literal value to set. Update
 *   functions expect to receive a parameter object and event as arguments.
 *   This function can either return a new operator value or (if the source
 *   argument is an EventStream) a {@link ChangeSet} instance to pulse
 *   the target operator with tuple changes.
 * @param {object} [params] - The update function parameters.
 * @param {object} [options] - Additional options hash. If not overridden,
 *   updated operators will be skipped by default.
 * @param {boolean} [options.skip] - If true, the operator will
 *  be skipped: it will not be evaluated, but its dependents will be.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @return {Dataflow}
 */
function on (source, target, update, params, options) {
  const fn = source instanceof Operator ? onOperator : onStream;
  fn(this, source, target, update, params, options);
  return this;
}
function onStream(df, stream, target, update, params, options) {
  const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, options, SKIP);
  let func, op;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(target)) target = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(target);
  if (update === undefined) {
    func = e => df.touch(target(e));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update)) {
    op = new Operator(null, update, params, false);
    func = e => {
      op.evaluate(e);
      const t = target(e),
        v = op.value;
      isChangeSet(v) ? df.pulse(t, v, options) : df.update(t, v, opt);
    };
  } else {
    func = e => df.update(target(e), update, opt);
  }
  stream.apply(func);
}
function onOperator(df, source, target, update, params, options) {
  if (update === undefined) {
    source.targets().add(target);
  } else {
    const opt = options || {},
      op = new Operator(null, updater(target, update), params, false);
    op.modified(opt.force);
    op.rank = source.rank; // immediately follow source
    source.targets().add(op); // add dependency

    if (target) {
      op.skip(true); // skip first invocation
      op.value = target.value; // initialize value
      op.targets().add(target); // chain dependencies
      df.connect(target, [op]); // rerank as needed, #1672
    }
  }
}
function updater(target, update) {
  update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(update) ? update : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(update);
  return target ? function (_, pulse) {
    const value = update(_, pulse);
    if (!target.skip()) {
      target.skip(value !== this.value).value = value;
    }
    return value;
  } : update;
}

/**
 * Assigns a rank to an operator. Ranks are assigned in increasing order
 * by incrementing an internal rank counter.
 * @param {Operator} op - The operator to assign a rank.
 */
function rank(op) {
  op.rank = ++this._rank;
}

/**
 * Re-ranks an operator and all downstream target dependencies. This
 * is necessary when upstream dependencies of higher rank are added to
 * a target operator.
 * @param {Operator} op - The operator to re-rank.
 */
function rerank(op) {
  const queue = [op];
  let cur, list, i;
  while (queue.length) {
    this.rank(cur = queue.pop());
    if (list = cur._targets) {
      for (i = list.length; --i >= 0;) {
        queue.push(cur = list[i]);
        if (cur === op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Cycle detected in dataflow graph.');
      }
    }
  }
}

/**
 * Sentinel value indicating pulse propagation should stop.
 */
const StopPropagation = {};

// Pulse visit type flags
const ADD = 1 << 0,
  REM = 1 << 1,
  MOD = 1 << 2,
  ADD_REM = ADD | REM,
  ADD_MOD = ADD | MOD,
  ALL = ADD | REM | MOD,
  REFLOW = 1 << 3,
  SOURCE = 1 << 4,
  NO_SOURCE = 1 << 5,
  NO_FIELDS = 1 << 6;

/**
 * A Pulse enables inter-operator communication during a run of the
 * dataflow graph. In addition to the current timestamp, a pulse may also
 * contain a change-set of added, removed or modified data tuples, as well as
 * a pointer to a full backing data source. Tuple change sets may not
 * be fully materialized; for example, to prevent needless array creation
 * a change set may include larger arrays and corresponding filter functions.
 * The pulse provides a {@link visit} method to enable proper and efficient
 * iteration over requested data tuples.
 *
 * In addition, each pulse can track modification flags for data tuple fields.
 * Responsible transform operators should call the {@link modifies} method to
 * indicate changes to data fields. The {@link modified} method enables
 * querying of this modification state.
 *
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The current propagation timestamp.
 * @param {string} [encode] - An optional encoding set name, which is then
 *   accessible as Pulse.encode. Operators can respond to (or ignore) this
 *   setting as appropriate. This parameter can be used in conjunction with
 *   the Encode transform in the vega-encode module.
 */
function Pulse(dataflow, stamp, encode) {
  this.dataflow = dataflow;
  this.stamp = stamp == null ? -1 : stamp;
  this.add = [];
  this.rem = [];
  this.mod = [];
  this.fields = null;
  this.encode = encode || null;
}
function materialize(data, filter) {
  const out = [];
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(data, filter, _ => out.push(_));
  return out;
}
function filter(pulse, flags) {
  const map = {};
  pulse.visit(flags, t => {
    map[tupleid(t)] = 1;
  });
  return t => map[tupleid(t)] ? null : t;
}
function addFilter(a, b) {
  return a ? (t, i) => a(t, i) && b(t, i) : b;
}
Pulse.prototype = {
  /**
   * Sentinel value indicating pulse propagation should stop.
   */
  StopPropagation,
  /**
   * Boolean flag indicating ADD (added) tuples.
   */
  ADD,
  /**
   * Boolean flag indicating REM (removed) tuples.
   */
  REM,
  /**
   * Boolean flag indicating MOD (modified) tuples.
   */
  MOD,
  /**
   * Boolean flag indicating ADD (added) and REM (removed) tuples.
   */
  ADD_REM,
  /**
   * Boolean flag indicating ADD (added) and MOD (modified) tuples.
   */
  ADD_MOD,
  /**
   * Boolean flag indicating ADD, REM and MOD tuples.
   */
  ALL,
  /**
   * Boolean flag indicating all tuples in a data source
   * except for the ADD, REM and MOD tuples.
   */
  REFLOW,
  /**
   * Boolean flag indicating a 'pass-through' to a
   * backing data source, ignoring ADD, REM and MOD tuples.
   */
  SOURCE,
  /**
   * Boolean flag indicating that source data should be
   * suppressed when creating a forked pulse.
   */
  NO_SOURCE,
  /**
   * Boolean flag indicating that field modifications should be
   * suppressed when creating a forked pulse.
   */
  NO_FIELDS,
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created.
   * @return {Pulse} - The forked pulse instance.
   * @see init
   */
  fork(flags) {
    return new Pulse(this.dataflow).init(this, flags);
  },
  /**
   * Creates a copy of this pulse with new materialized array
   * instances for the ADD, REM, MOD, and SOURCE arrays.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse} - The cloned pulse instance.
   * @see init
   */
  clone() {
    const p = this.fork(ALL);
    p.add = p.add.slice();
    p.rem = p.rem.slice();
    p.mod = p.mod.slice();
    if (p.source) p.source = p.source.slice();
    return p.materialize(ALL | SOURCE);
  },
  /**
   * Returns a pulse that adds all tuples from a backing source. This is
   * useful for cases where operators are added to a dataflow after an
   * upstream data pipeline has already been processed, ensuring that
   * new operators can observe all tuples within a stream.
   * @return {Pulse} - A pulse instance with all source tuples included
   *   in the add array. If the current pulse already has all source
   *   tuples in its add array, it is returned directly. If the current
   *   pulse does not have a backing source, it is returned directly.
   */
  addAll() {
    let p = this;
    const reuse = !p.source || p.add === p.rem // special case for indexed set (e.g., crossfilter)
    || !p.rem.length && p.source.length === p.add.length;
    if (reuse) {
      return p;
    } else {
      p = new Pulse(this.dataflow).init(this);
      p.add = p.source;
      p.rem = []; // new operators can ignore rem #2769
      return p;
    }
  },
  /**
   * Initialize this pulse based on the values of another pulse. This method
   * is used internally by {@link fork} to initialize a new forked tuple.
   * The dataflow, time stamp and field modification values are copied over.
   * By default, new empty ADD, REM and MOD arrays are created.
   * @param {Pulse} src - The source pulse to copy from.
   * @param {number} flags - Integer of boolean flags indicating which (if any)
   *   tuple arrays should be copied to the new pulse. The supported flag values
   *   are ADD, REM and MOD. Array references are copied directly: new array
   *   instances are not created. By default, source data arrays are copied
   *   to the new pulse. Use the NO_SOURCE flag to enforce a null source.
   * @return {Pulse} - Returns this Pulse instance.
   */
  init(src, flags) {
    const p = this;
    p.stamp = src.stamp;
    p.encode = src.encode;
    if (src.fields && !(flags & NO_FIELDS)) {
      p.fields = src.fields;
    }
    if (flags & ADD) {
      p.addF = src.addF;
      p.add = src.add;
    } else {
      p.addF = null;
      p.add = [];
    }
    if (flags & REM) {
      p.remF = src.remF;
      p.rem = src.rem;
    } else {
      p.remF = null;
      p.rem = [];
    }
    if (flags & MOD) {
      p.modF = src.modF;
      p.mod = src.mod;
    } else {
      p.modF = null;
      p.mod = [];
    }
    if (flags & NO_SOURCE) {
      p.srcF = null;
      p.source = null;
    } else {
      p.srcF = src.srcF;
      p.source = src.source;
      if (src.cleans) p.cleans = src.cleans;
    }
    return p;
  },
  /**
   * Schedules a function to run after pulse propagation completes.
   * @param {function} func - The function to run.
   */
  runAfter(func) {
    this.dataflow.runAfter(func);
  },
  /**
   * Indicates if tuples have been added, removed or modified.
   * @param {number} [flags] - The tuple types (ADD, REM or MOD) to query.
   *   Defaults to ALL, returning true if any tuple type has changed.
   * @return {boolean} - Returns true if one or more queried tuple types have
   *   changed, false otherwise.
   */
  changed(flags) {
    const f = flags || ALL;
    return f & ADD && this.add.length || f & REM && this.rem.length || f & MOD && this.mod.length;
  },
  /**
   * Forces a "reflow" of tuple values, such that all tuples in the backing
   * source are added to the MOD set, unless already present in the ADD set.
   * @param {boolean} [fork=false] - If true, returns a forked copy of this
   *   pulse, and invokes reflow on that derived pulse.
   * @return {Pulse} - The reflowed pulse instance.
   */
  reflow(fork) {
    if (fork) return this.fork(ALL).reflow();
    const len = this.add.length,
      src = this.source && this.source.length;
    if (src && src !== len) {
      this.mod = this.source;
      if (len) this.filter(MOD, filter(this, ADD));
    }
    return this;
  },
  /**
   * Get/set metadata to pulse requesting garbage collection
   * to reclaim currently unused resources.
   */
  clean(value) {
    if (arguments.length) {
      this.cleans = !!value;
      return this;
    } else {
      return this.cleans;
    }
  },
  /**
   * Marks one or more data field names as modified to assist dependency
   * tracking and incremental processing by transform operators.
   * @param {string|Array<string>} _ - The field(s) to mark as modified.
   * @return {Pulse} - This pulse instance.
   */
  modifies(_) {
    const hash = this.fields || (this.fields = {});
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_)) {
      _.forEach(f => hash[f] = true);
    } else {
      hash[_] = true;
    }
    return this;
  },
  /**
   * Checks if one or more data fields have been modified during this pulse
   * propagation timestamp.
   * @param {string|Array<string>} _ - The field(s) to check for modified.
   * @param {boolean} nomod - If true, will check the modified flag even if
   *   no mod tuples exist. If false (default), mod tuples must be present.
   * @return {boolean} - Returns true if any of the provided fields has been
   *   marked as modified, false otherwise.
   */
  modified(_, nomod) {
    const fields = this.fields;
    return !((nomod || this.mod.length) && fields) ? false : !arguments.length ? !!fields : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },
  /**
   * Adds a filter function to one more tuple sets. Filters are applied to
   * backing tuple arrays, to determine the actual set of tuples considered
   * added, removed or modified. They can be used to delay materialization of
   * a tuple set in order to avoid expensive array copies. In addition, the
   * filter functions can serve as value transformers: unlike standard predicate
   * function (which return boolean values), Pulse filters should return the
   * actual tuple value to process. If a tuple set is already filtered, the
   * new filter function will be appended into a conjuntive ('and') query.
   * @param {number} flags - Flags indicating the tuple set(s) to filter.
   * @param {function(*):object} filter - Filter function that will be applied
   *   to the tuple set array, and should return a data tuple if the value
   *   should be included in the tuple set, and falsy (or null) otherwise.
   * @return {Pulse} - Returns this pulse instance.
   */
  filter(flags, filter) {
    const p = this;
    if (flags & ADD) p.addF = addFilter(p.addF, filter);
    if (flags & REM) p.remF = addFilter(p.remF, filter);
    if (flags & MOD) p.modF = addFilter(p.modF, filter);
    if (flags & SOURCE) p.srcF = addFilter(p.srcF, filter);
    return p;
  },
  /**
   * Materialize one or more tuple sets in this pulse. If the tuple set(s) have
   * a registered filter function, it will be applied and the tuple set(s) will
   * be replaced with materialized tuple arrays.
   * @param {number} flags - Flags indicating the tuple set(s) to materialize.
   * @return {Pulse} - Returns this pulse instance.
   */
  materialize(flags) {
    flags = flags || ALL;
    const p = this;
    if (flags & ADD && p.addF) {
      p.add = materialize(p.add, p.addF);
      p.addF = null;
    }
    if (flags & REM && p.remF) {
      p.rem = materialize(p.rem, p.remF);
      p.remF = null;
    }
    if (flags & MOD && p.modF) {
      p.mod = materialize(p.mod, p.modF);
      p.modF = null;
    }
    if (flags & SOURCE && p.srcF) {
      p.source = p.source.filter(p.srcF);
      p.srcF = null;
    }
    return p;
  },
  /**
   * Visit one or more tuple sets in this pulse.
   * @param {number} flags - Flags indicating the tuple set(s) to visit.
   *   Legal values are ADD, REM, MOD and SOURCE (if a backing data source
   *   has been set).
   * @param {function(object):*} - Visitor function invoked per-tuple.
   * @return {Pulse} - Returns this pulse instance.
   */
  visit(flags, visitor) {
    const p = this,
      v = visitor;
    if (flags & SOURCE) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.source, p.srcF, v);
      return p;
    }
    if (flags & ADD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.add, p.addF, v);
    if (flags & REM) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.rem, p.remF, v);
    if (flags & MOD) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(p.mod, p.modF, v);
    const src = p.source;
    if (flags & REFLOW && src) {
      const sum = p.add.length + p.mod.length;
      if (sum === src.length) ; else if (sum) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, filter(p, ADD_MOD), v);
      } else {
        // if no add/rem/mod tuples, visit source
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray)(src, p.srcF, v);
      }
    }
    return p;
  }
};

/**
 * Represents a set of multiple pulses. Used as input for operators
 * that accept multiple pulses at a time. Contained pulses are
 * accessible via the public "pulses" array property. This pulse doe
 * not carry added, removed or modified tuples directly. However,
 * the visit method can be used to traverse all such tuples contained
 * in sub-pulses with a timestamp matching this parent multi-pulse.
 * @constructor
 * @param {Dataflow} dataflow - The backing dataflow instance.
 * @param {number} stamp - The timestamp.
 * @param {Array<Pulse>} pulses - The sub-pulses for this multi-pulse.
 */
function MultiPulse(dataflow, stamp, pulses, encode) {
  const p = this;
  let c = 0;
  this.dataflow = dataflow;
  this.stamp = stamp;
  this.fields = null;
  this.encode = encode || null;
  this.pulses = pulses;
  for (const pulse of pulses) {
    if (pulse.stamp !== stamp) continue;
    if (pulse.fields) {
      const hash = p.fields || (p.fields = {});
      for (const f in pulse.fields) {
        hash[f] = 1;
      }
    }
    if (pulse.changed(p.ADD)) c |= p.ADD;
    if (pulse.changed(p.REM)) c |= p.REM;
    if (pulse.changed(p.MOD)) c |= p.MOD;
  }
  this.changes = c;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiPulse, Pulse, {
  /**
   * Creates a new pulse based on the values of this pulse.
   * The dataflow, time stamp and field modification values are copied over.
   * @return {Pulse}
   */
  fork(flags) {
    const p = new Pulse(this.dataflow).init(this, flags & this.NO_FIELDS);
    if (flags !== undefined) {
      if (flags & p.ADD) this.visit(p.ADD, t => p.add.push(t));
      if (flags & p.REM) this.visit(p.REM, t => p.rem.push(t));
      if (flags & p.MOD) this.visit(p.MOD, t => p.mod.push(t));
    }
    return p;
  },
  changed(flags) {
    return this.changes & flags;
  },
  modified(_) {
    const p = this,
      fields = p.fields;
    return !(fields && p.changes & p.MOD) ? 0 : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.some(f => fields[f]) : fields[_];
  },
  filter() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support filtering.');
  },
  materialize() {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('MultiPulse does not support materialization.');
  },
  visit(flags, visitor) {
    const p = this,
      pulses = p.pulses,
      n = pulses.length;
    let i = 0;
    if (flags & p.SOURCE) {
      for (; i < n; ++i) {
        pulses[i].visit(flags, visitor);
      }
    } else {
      for (; i < n; ++i) {
        if (pulses[i].stamp === p.stamp) {
          pulses[i].visit(flags, visitor);
        }
      }
    }
    return p;
  }
});

/* eslint-disable require-atomic-updates */

/**
 * Evaluates the dataflow and returns a Promise that resolves when pulse
 * propagation completes. This method will increment the current timestamp
 * and process all updated, pulsed and touched operators. When invoked for
 * the first time, all registered operators will be processed. This method
 * should not be invoked by third-party clients, use {@link runAsync} or
 * {@link run} instead.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */
async function evaluate(encode, prerun, postrun) {
  const df = this,
    async = [];

  // if the pulse value is set, this is a re-entrant call
  if (df._pulse) return reentrant(df);

  // wait for pending datasets to load
  if (df._pending) await df._pending;

  // invoke prerun function, if provided
  if (prerun) await asyncCallback(df, prerun);

  // exit early if there are no updates
  if (!df._touched.length) {
    df.debug('Dataflow invoked, but nothing to do.');
    return df;
  }

  // increment timestamp clock
  const stamp = ++df._clock;

  // set the current pulse
  df._pulse = new Pulse(df, stamp, encode);

  // initialize priority queue, reset touched operators
  df._touched.forEach(op => df._enqueue(op, true));
  df._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  let count = 0,
    op,
    next,
    error;
  try {
    while (df._heap.size() > 0) {
      // dequeue operator with highest priority
      op = df._heap.pop();

      // re-queue if rank changed
      if (op.rank !== op.qrank) {
        df._enqueue(op, true);
        continue;
      }

      // otherwise, evaluate the operator
      next = op.run(df._getPulse(op, encode));
      if (next.then) {
        // await if operator returns a promise directly
        next = await next;
      } else if (next.async) {
        // queue parallel asynchronous execution
        async.push(next.async);
        next = StopPropagation;
      }

      // propagate evaluation, enqueue dependent operators
      if (next !== StopPropagation) {
        if (op._targets) op._targets.forEach(op => df._enqueue(op));
      }

      // increment visit counter
      ++count;
    }
  } catch (err) {
    df._heap.clear();
    error = err;
  }

  // reset pulse map
  df._input = {};
  df._pulse = null;
  df.debug(`Pulse ${stamp}: ${count} operators`);
  if (error) {
    df._postrun = [];
    df.error(error);
  }

  // invoke callbacks queued via runAfter
  if (df._postrun.length) {
    const pr = df._postrun.sort((a, b) => b.priority - a.priority);
    df._postrun = [];
    for (let i = 0; i < pr.length; ++i) {
      await asyncCallback(df, pr[i].callback);
    }
  }

  // invoke postrun function, if provided
  if (postrun) await asyncCallback(df, postrun);

  // handle non-blocking asynchronous callbacks
  if (async.length) {
    Promise.all(async).then(cb => df.runAsync(null, () => {
      cb.forEach(f => {
        try {
          f(df);
        } catch (err) {
          df.error(err);
        }
      });
    }));
  }
  return df;
}

/**
 * Queues dataflow evaluation to run once any other queued evaluations have
 * completed and returns a Promise that resolves when the queued pulse
 * propagation completes. If provided, a callback function will be invoked
 * immediately before evaluation commences. This method will ensure a
 * separate evaluation is invoked for each time it is called.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode package.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Promise} - A promise that resolves to this dataflow after
 *   evaluation completes.
 */
async function runAsync(encode, prerun, postrun) {
  // await previously queued functions
  while (this._running) await this._running;

  // run dataflow, manage running promise
  const clear = () => this._running = null;
  (this._running = this.evaluate(encode, prerun, postrun)).then(clear, clear);
  return this._running;
}

/**
 * Requests dataflow evaluation and the immediately returns this dataflow
 * instance. If there are pending data loading or other asynchronous
 * operations, the dataflow will evaluate asynchronously after this method
 * has been invoked. To track when dataflow evaluation completes, use the
 * {@link runAsync} method instead. This method will raise an error if
 * invoked while the dataflow is already in the midst of evaluation.
 * @param {string} [encode] - The name of an encoding set to invoke during
 *   propagation. This value is added to generated Pulse instances;
 *   operators can then respond to (or ignore) this setting as appropriate.
 *   This parameter can be used in conjunction with the Encode transform in
 *   the vega-encode module.
 * @param {function} [prerun] - An optional callback function to invoke
 *   immediately before dataflow evaluation commences.
 * @param {function} [postrun] - An optional callback function to invoke
 *   after dataflow evaluation completes. The callback will be invoked
 *   after those registered via {@link runAfter}.
 * @return {Dataflow} - This dataflow instance.
 */
function run(encode, prerun, postrun) {
  return this._pulse ? reentrant(this) : (this.evaluate(encode, prerun, postrun), this);
}

/**
 * Schedules a callback function to be invoked after the current pulse
 * propagation completes. If no propagation is currently occurring,
 * the function is invoked immediately. Callbacks scheduled via runAfter
 * are invoked immediately upon completion of the current cycle, before
 * any request queued via runAsync. This method is primarily intended for
 * internal use. Third-party callers using runAfter to schedule a callback
 * that invokes {@link run} or {@link runAsync} should not use this method,
 * but instead use {@link runAsync} with prerun or postrun arguments.
 * @param {function(Dataflow)} callback - The callback function to run.
 *   The callback will be invoked with this Dataflow instance as its
 *   sole argument.
 * @param {boolean} enqueue - A boolean flag indicating that the
 *   callback should be queued up to run after the next propagation
 *   cycle, suppressing immediate invocation when propagation is not
 *   currently occurring.
 * @param {number} [priority] - A priority value used to sort registered
 *   callbacks to determine execution order. This argument is intended
 *   for internal Vega use only.
 */
function runAfter(callback, enqueue, priority) {
  if (this._pulse || enqueue) {
    // pulse propagation is currently running, queue to run after
    this._postrun.push({
      priority: priority || 0,
      callback: callback
    });
  } else {
    // pulse propagation already complete, invoke immediately
    try {
      callback(this);
    } catch (err) {
      this.error(err);
    }
  }
}

/**
 * Raise an error for re-entrant dataflow evaluation.
 */
function reentrant(df) {
  df.error('Dataflow already running. Use runAsync() to chain invocations.');
  return df;
}

/**
 * Enqueue an operator into the priority queue for evaluation. The operator
 * will be enqueued if it has no registered pulse for the current cycle, or if
 * the force argument is true. Upon enqueue, this method also sets the
 * operator's qrank to the current rank value.
 * @param {Operator} op - The operator to enqueue.
 * @param {boolean} [force] - A flag indicating if the operator should be
 *   forceably added to the queue, even if it has already been previously
 *   enqueued during the current pulse propagation. This is useful when the
 *   dataflow graph is dynamically modified and the operator rank changes.
 */
function enqueue(op, force) {
  const q = op.stamp < this._clock;
  if (q) op.stamp = this._clock;
  if (q || force) {
    op.qrank = op.rank;
    this._heap.push(op);
  }
}

/**
 * Provide a correct pulse for evaluating an operator. If the operator has an
 * explicit source operator, we will try to pull the pulse(s) from it.
 * If there is an array of source operators, we build a multi-pulse.
 * Otherwise, we return a current pulse with correct source data.
 * If the pulse is the pulse map has an explicit target set, we use that.
 * Else if the pulse on the upstream source operator is current, we use that.
 * Else we use the pulse from the pulse map, but copy the source tuple array.
 * @param {Operator} op - The operator for which to get an input pulse.
 * @param {string} [encode] - An (optional) encoding set name with which to
 *   annotate the returned pulse. See {@link run} for more information.
 */
function getPulse(op, encode) {
  const s = op.source,
    stamp = this._clock;
  return s && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(s) ? new MultiPulse(this, stamp, s.map(_ => _.pulse), encode) : this._input[op.id] || singlePulse(this._pulse, s && s.pulse);
}
function singlePulse(p, s) {
  if (s && s.stamp === p.stamp) {
    return s;
  }
  p = p.fork();
  if (s && s !== StopPropagation) {
    p.source = s.source;
  }
  return p;
}

const NO_OPT = {
  skip: false,
  force: false
};

/**
 * Touches an operator, scheduling it to be evaluated. If invoked outside of
 * a pulse propagation, the operator will be evaluated the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the operator
 * will be queued for evaluation if and only if the operator has not yet been
 * evaluated on the current propagation timestamp.
 * @param {Operator} op - The operator to touch.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */
function touch(op, options) {
  const opt = options || NO_OPT;
  if (this._pulse) {
    // if in midst of propagation, add to priority queue
    this._enqueue(op);
  } else {
    // otherwise, queue for next propagation
    this._touched.add(op);
  }
  if (opt.skip) op.skip(true);
  return this;
}

/**
 * Updates the value of the given operator.
 * @param {Operator} op - The operator to update.
 * @param {*} value - The value to set.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.force] - If true, the operator will
 *   be re-evaluated even if its value has not changed.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */
function update(op, value, options) {
  const opt = options || NO_OPT;
  if (op.set(value) || opt.force) {
    this.touch(op, opt);
  }
  return this;
}

/**
 * Pulses an operator with a changeset of tuples. If invoked outside of
 * a pulse propagation, the pulse will be applied the next time this
 * dataflow is run. If invoked in the midst of pulse propagation, the pulse
 * will be added to the set of active pulses and will be applied if and
 * only if the target operator has not yet been evaluated on the current
 * propagation timestamp.
 * @param {Operator} op - The operator to pulse.
 * @param {ChangeSet} value - The tuple changeset to apply.
 * @param {object} [options] - Additional options hash.
 * @param {boolean} [options.skip] - If true, the operator will
 *   be skipped: it will not be evaluated, but its dependents will be.
 * @return {Dataflow}
 */
function pulse(op, changeset, options) {
  this.touch(op, options || NO_OPT);
  const p = new Pulse(this, this._clock + (this._pulse ? 0 : 1)),
    t = op.pulse && op.pulse.source || [];
  p.target = op;
  this._input[op.id] = changeset.pulse(p, t);
  return this;
}

function Heap(cmp) {
  let nodes = [];
  return {
    clear: () => nodes = [],
    size: () => nodes.length,
    peek: () => nodes[0],
    push: x => {
      nodes.push(x);
      return siftdown(nodes, 0, nodes.length - 1, cmp);
    },
    pop: () => {
      const last = nodes.pop();
      let item;
      if (nodes.length) {
        item = nodes[0];
        nodes[0] = last;
        siftup(nodes, 0, cmp);
      } else {
        item = last;
      }
      return item;
    }
  };
}
function siftdown(array, start, idx, cmp) {
  let parent, pidx;
  const item = array[idx];
  while (idx > start) {
    pidx = idx - 1 >> 1;
    parent = array[pidx];
    if (cmp(item, parent) < 0) {
      array[idx] = parent;
      idx = pidx;
      continue;
    }
    break;
  }
  return array[idx] = item;
}
function siftup(array, idx, cmp) {
  const start = idx,
    end = array.length,
    item = array[idx];
  let cidx = (idx << 1) + 1,
    ridx;
  while (cidx < end) {
    ridx = cidx + 1;
    if (ridx < end && cmp(array[cidx], array[ridx]) >= 0) {
      cidx = ridx;
    }
    array[idx] = array[cidx];
    idx = cidx;
    cidx = (idx << 1) + 1;
  }
  array[idx] = item;
  return siftdown(array, start, idx, cmp);
}

/**
 * A dataflow graph for reactive processing of data streams.
 * @constructor
 */
function Dataflow() {
  this.logger((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.logger)());
  this.logLevel(vega_util__WEBPACK_IMPORTED_MODULE_0__.Error);
  this._clock = 0;
  this._rank = 0;
  this._locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.defaultLocale)();
  try {
    this._loader = (0,vega_loader__WEBPACK_IMPORTED_MODULE_1__.loader)();
  } catch (e) {
    // do nothing if loader module is unavailable
  }
  this._touched = UniqueList(vega_util__WEBPACK_IMPORTED_MODULE_0__.id);
  this._input = {};
  this._pulse = null;
  this._heap = Heap((a, b) => a.qrank - b.qrank);
  this._postrun = [];
}
function logMethod(method) {
  return function () {
    return this._log[method].apply(this, arguments);
  };
}
Dataflow.prototype = {
  /**
   * The current timestamp of this dataflow. This value reflects the
   * timestamp of the previous dataflow run. The dataflow is initialized
   * with a stamp value of 0. The initial run of the dataflow will have
   * a timestap of 1, and so on. This value will match the
   * {@link Pulse.stamp} property.
   * @return {number} - The current timestamp value.
   */
  stamp() {
    return this._clock;
  },
  /**
   * Gets or sets the loader instance to use for data file loading. A
   * loader object must provide a "load" method for loading files and a
   * "sanitize" method for checking URL/filename validity. Both methods
   * should accept a URI and options hash as arguments, and return a Promise
   * that resolves to the loaded file contents (load) or a hash containing
   * sanitized URI data with the sanitized url assigned to the "href" property
   * (sanitize).
   * @param {object} _ - The loader instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current loader instance. Otherwise returns this Dataflow instance.
   */
  loader(_) {
    if (arguments.length) {
      this._loader = _;
      return this;
    } else {
      return this._loader;
    }
  },
  /**
   * Gets or sets the locale instance to use for formatting and parsing
   * string values. The locale object should be provided by the
   * vega-format library, and include methods such as format, timeFormat,
   * utcFormat, timeParse, and utcParse.
   * @param {object} _ - The locale instance to use.
   * @return {object|Dataflow} - If no arguments are provided, returns
   *   the current locale instance. Otherwise returns this Dataflow instance.
   */
  locale(_) {
    if (arguments.length) {
      this._locale = _;
      return this;
    } else {
      return this._locale;
    }
  },
  /**
   * Get or set the logger instance used to log messages. If no arguments are
   * provided, returns the current logger instance. Otherwise, sets the logger
   * and return this Dataflow instance. Provided loggers must support the full
   * API of logger objects generated by the vega-util logger method. Note that
   * by default the log level of the new logger will be used; use the logLevel
   * method to adjust the log level as needed.
   */
  logger(logger) {
    if (arguments.length) {
      this._log = logger;
      return this;
    } else {
      return this._log;
    }
  },
  /**
   * Logs an error message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit error messages.
   */
  error: logMethod('error'),
  /**
   * Logs a warning message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit warning messages.
   */
  warn: logMethod('warn'),
  /**
   * Logs a information message. By default, logged messages are written to
   * console output. The message will only be logged if the current log level is
   * high enough to permit information messages.
   */
  info: logMethod('info'),
  /**
   * Logs a debug message. By default, logged messages are written to console
   * output. The message will only be logged if the current log level is high
   * enough to permit debug messages.
   */
  debug: logMethod('debug'),
  /**
   * Get or set the current log level. If an argument is provided, it
   * will be used as the new log level.
   * @param {number} [level] - Should be one of None, Warn, Info
   * @return {number} - The current log level.
   */
  logLevel: logMethod('level'),
  /**
   * Empty entry threshold for garbage cleaning. Map data structures will
   * perform cleaning once the number of empty entries exceeds this value.
   */
  cleanThreshold: 1e4,
  // OPERATOR REGISTRATION
  add,
  connect,
  rank,
  rerank,
  // OPERATOR UPDATES
  pulse,
  touch,
  update,
  changeset,
  // DATA LOADING
  ingest,
  parse,
  preload,
  request,
  // EVENT HANDLING
  events,
  on,
  // PULSE PROPAGATION
  evaluate,
  run,
  runAsync,
  runAfter,
  _enqueue: enqueue,
  _getPulse: getPulse
};

/**
 * Abstract class for operators that process data tuples.
 * Subclasses must provide a {@link transform} method for operator processing.
 * @constructor
 * @param {*} [init] - The initial value for this operator.
 * @param {object} [params] - The parameters for this operator.
 * @param {Operator} [source] - The operator from which to receive pulses.
 */
function Transform(init, params) {
  Operator.call(this, init, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Transform, Operator, {
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Internally, this method calls {@link evaluate} to perform processing.
   * If {@link evaluate} returns a falsy value, the input pulse is returned.
   * This method should NOT be overridden, instead overrride {@link evaluate}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return the output pulse for this operator (or StopPropagation)
   */
  run(pulse) {
    if (pulse.stamp < this.stamp) return pulse.StopPropagation;
    let rv;
    if (this.skip()) {
      this.skip(false);
    } else {
      rv = this.evaluate(pulse);
    }
    rv = rv || pulse;
    if (rv.then) {
      rv = rv.then(_ => this.pulse = _);
    } else if (rv !== pulse.StopPropagation) {
      this.pulse = rv;
    }
    return rv;
  },
  /**
   * Overrides {@link Operator.evaluate} for transform operators.
   * Marshalls parameter values and then invokes {@link transform}.
   * @param {Pulse} pulse - the current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
       value (including undefined) will let the input pulse pass through.
  */
  evaluate(pulse) {
    const params = this.marshall(pulse.stamp),
      out = this.transform(params, pulse);
    params.clear();
    return out;
  },
  /**
   * Process incoming pulses.
   * Subclasses should override this method to implement transforms.
   * @param {Parameters} _ - The operator parameter values.
   * @param {Pulse} pulse - The current dataflow pulse.
   * @return {Pulse} The output pulse (or StopPropagation). A falsy return
   *   value (including undefined) will let the input pulse pass through.
   */
  transform() {}
});

const transforms = {};
function definition(type) {
  const t = transform(type);
  return t && t.Definition || null;
}
function transform(type) {
  type = type && type.toLowerCase();
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(transforms, type) ? transforms[type] : null;
}




/***/ }),

/***/ "./node_modules/vega-encode/build/vega-encode.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-encode/build/vega-encode.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   axisticks: () => (/* binding */ AxisTicks),
/* harmony export */   datajoin: () => (/* binding */ DataJoin),
/* harmony export */   encode: () => (/* binding */ Encode),
/* harmony export */   legendentries: () => (/* binding */ LegendEntries),
/* harmony export */   linkpath: () => (/* binding */ LinkPath),
/* harmony export */   pie: () => (/* binding */ Pie),
/* harmony export */   scale: () => (/* binding */ Scale),
/* harmony export */   sortitems: () => (/* binding */ SortItems),
/* harmony export */   stack: () => (/* binding */ Stack)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/round.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/value.js");






/**
 * Generates axis ticks for visualizing a spatial scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate ticks for.
 * @param {*} [params.count=10] - The approximate number of ticks, or
 *   desired tick interval, to use.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {function(*):string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid d3 4.0 format specifier.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */
function AxisTicks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(AxisTicks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) {
      return pulse.StopPropagation;
    }
    var locale = pulse.dataflow.locale(),
      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      ticks = this.value,
      scale = _.scale,
      tally = _.count == null ? _.values ? _.values.length : 10 : _.count,
      count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, tally, _.minstep),
      format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickFormat)(locale, scale, count, _.formatSpecifier, _.formatType, !!_.values),
      values = _.values ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.validTicks)(scale, _.values, count) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickValues)(scale, count);
    if (ticks) out.rem = ticks;
    ticks = values.map((value, i) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
      index: i / (values.length - 1 || 1),
      value: value,
      label: format(value)
    }));
    if (_.extra && ticks.length) {
      // add an extra tick pegged to the initial domain value
      // this is used to generate axes with 'binned' domains
      ticks.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: -1,
        extra: {
          value: ticks[0].value
        },
        label: ''
      }));
    }
    out.source = ticks;
    out.add = ticks;
    this.value = ticks;
    return out;
  }
});

/**
 * Joins a set of data elements against a set of visual items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): object} [params.item] - An item generator function.
 * @param {function(object): *} [params.key] - The key field associating data and visual items.
 */
function DataJoin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
function defaultItemCreate() {
  return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({});
}
function newMap(key) {
  const map = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)().test(t => t.exit);
  map.lookup = t => map.get(key(t));
  return map;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(DataJoin, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      item = _.item || defaultItemCreate,
      key = _.key || vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid,
      map = this.value;

    // prevent transient (e.g., hover) requests from
    // cascading across marks derived from marks
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(out.encode)) {
      out.encode = null;
    }
    if (map && (_.modified('key') || pulse.modified(key))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('DataJoin does not support modified key function or fields.');
    }
    if (!map) {
      pulse = pulse.addAll();
      this.value = map = newMap(key);
    }
    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      let x = map.get(k);
      if (x) {
        if (x.exit) {
          map.empty--;
          out.add.push(x);
        } else {
          out.mod.push(x);
        }
      } else {
        x = item(t);
        map.set(k, x);
        out.add.push(x);
      }
      x.datum = t;
      x.exit = false;
    });
    pulse.visit(pulse.MOD, t => {
      const k = key(t),
        x = map.get(k);
      if (x) {
        x.datum = t;
        out.mod.push(x);
      }
    });
    pulse.visit(pulse.REM, t => {
      const k = key(t),
        x = map.get(k);
      if (t === x.datum && !x.exit) {
        out.rem.push(x);
        x.exit = true;
        ++map.empty;
      }
    });
    if (pulse.changed(pulse.ADD_MOD)) out.modifies('datum');
    if (pulse.clean() || _.clean && map.empty > df.cleanThreshold) {
      df.runAfter(map.clean);
    }
    return out;
  }
});

/**
 * Invokes encoding functions for visual items.
 * @constructor
 * @param {object} params - The parameters to the encoding functions. This
 *   parameter object will be passed through to all invoked encoding functions.
 * @param {object} [params.mod=false] - Flag indicating if tuples in the input
 *   mod set that are unmodified by encoders should be included in the output.
 * @param {object} param.encoders - The encoding functions
 * @param {function(object, object): boolean} [param.encoders.update] - Update encoding set
 * @param {function(object, object): boolean} [param.encoders.enter] - Enter encoding set
 * @param {function(object, object): boolean} [param.encoders.exit] - Exit encoding set
 */
function Encode(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Encode, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ADD_REM),
      fmod = _.mod || false,
      encoders = _.encoders,
      encode = pulse.encode;

    // if an array, the encode directive includes additional sets
    // that must be defined in order for the primary set to be invoked
    // e.g., only run the update set if the hover set is defined
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(encode)) {
      if (out.changed() || encode.every(e => encoders[e])) {
        encode = encode[0];
        out.encode = null; // consume targeted encode directive
      } else {
        return pulse.StopPropagation;
      }
    }

    // marshall encoder functions
    var reenter = encode === 'enter',
      update = encoders.update || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
      enter = encoders.enter || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
      exit = encoders.exit || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy,
      set = (encode && !reenter ? encoders[encode] : update) || vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy;
    if (pulse.changed(pulse.ADD)) {
      pulse.visit(pulse.ADD, t => {
        enter(t, _);
        update(t, _);
      });
      out.modifies(enter.output);
      out.modifies(update.output);
      if (set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy && set !== update) {
        pulse.visit(pulse.ADD, t => {
          set(t, _);
        });
        out.modifies(set.output);
      }
    }
    if (pulse.changed(pulse.REM) && exit !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      pulse.visit(pulse.REM, t => {
        exit(t, _);
      });
      out.modifies(exit.output);
    }
    if (reenter || set !== vega_util__WEBPACK_IMPORTED_MODULE_2__.falsy) {
      const flag = pulse.MOD | (_.modified() ? pulse.REFLOW : 0);
      if (reenter) {
        pulse.visit(flag, t => {
          const mod = enter(t, _) || fmod;
          if (set(t, _) || mod) out.mod.push(t);
        });
        if (out.mod.length) out.modifies(enter.output);
      } else {
        pulse.visit(flag, t => {
          if (set(t, _) || fmod) out.mod.push(t);
        });
      }
      if (out.mod.length) out.modifies(set.output);
    }
    return out.changed() ? out : pulse.StopPropagation;
  }
});

/**
 * Generates legend entries for visualizing a scale.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Scale} params.scale - The scale to generate items for.
 * @param {*} [params.count=5] - The approximate number of items, or
 *   desired tick interval, to use.
 * @param {*} [params.limit] - The maximum number of entries to
 *   include in a symbol legend.
 * @param {Array<*>} [params.values] - The exact tick values to use.
 *   These must be legal domain values for the provided scale.
 *   If provided, the count argument is ignored.
 * @param {string} [params.formatSpecifier] - A format specifier
 *   to use in conjunction with scale.tickFormat. Legal values are
 *   any valid D3 format specifier string.
 * @param {function(*):string} [params.format] - The format function to use.
 *   If provided, the formatSpecifier argument is ignored.
 */
function LegendEntries(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LegendEntries, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value != null && !_.modified()) {
      return pulse.StopPropagation;
    }
    var locale = pulse.dataflow.locale(),
      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      items = this.value,
      type = _.type || vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
      scale = _.scale,
      limit = +_.limit,
      count = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.count == null ? 5 : _.count, _.minstep),
      lskip = !!_.values || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend,
      format = _.format || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFormat)(locale, scale, count, type, _.formatSpecifier, _.formatType, lskip),
      values = _.values || (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelValues)(scale, count),
      domain,
      fraction,
      size,
      offset,
      ellipsis;
    if (items) out.rem = items;
    if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.SymbolLegend) {
      if (limit && values.length > limit) {
        pulse.dataflow.warn('Symbol legend count exceeds limit, filtering items.');
        items = values.slice(0, limit - 1);
        ellipsis = true;
      } else {
        items = values;
      }
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(size = _.size)) {
        // if first value maps to size zero, remove from list (vega#717)
        if (!_.values && scale(items[0]) === 0) {
          items = items.slice(1);
        }
        // compute size offset for legend entries
        offset = items.reduce((max, value) => Math.max(max, size(value, _)), 0);
      } else {
        size = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(offset = size || 8);
      }
      items = items.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, items),
        value: value,
        offset: offset,
        size: size(value, _)
      }));
      if (ellipsis) {
        ellipsis = values[items.length];
        items.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
          index: items.length,
          label: `\u2026${values.length - items.length} entries`,
          value: ellipsis,
          offset: offset,
          size: size(ellipsis, _)
        }));
      }
    } else if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.GradientLegend) {
      domain = scale.domain(), fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleFraction)(scale, domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain));

      // if automatic label generation produces 2 or fewer values,
      // use the domain end points instead (fixes vega/vega#1364)
      if (values.length < 3 && !_.values && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
        values = [domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)];
      }
      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: fraction(value)
      }));
    } else {
      size = values.length - 1;
      fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.labelFraction)(scale);
      items = values.map((value, index) => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
        index: index,
        label: format(value, index, values),
        value: value,
        perc: index ? fraction(value) : 0,
        perc2: index === size ? 1 : fraction(values[index + 1])
      }));
    }
    out.source = items;
    out.add = items;
    this.value = items;
    return out;
  }
});

const sourceX = t => t.source.x;
const sourceY = t => t.source.y;
const targetX = t => t.target.x;
const targetY = t => t.target.y;

/**
 * Layout paths linking source and target elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function LinkPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, {}, params);
}
LinkPath.Definition = {
  'type': 'LinkPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sourceX',
    'type': 'field',
    'default': 'source.x'
  }, {
    'name': 'sourceY',
    'type': 'field',
    'default': 'source.y'
  }, {
    'name': 'targetX',
    'type': 'field',
    'default': 'target.x'
  }, {
    'name': 'targetY',
    'type': 'field',
    'default': 'target.y'
  }, {
    'name': 'orient',
    'type': 'enum',
    'default': 'vertical',
    'values': ['horizontal', 'vertical', 'radial']
  }, {
    'name': 'shape',
    'type': 'enum',
    'default': 'line',
    'values': ['line', 'arc', 'curve', 'diagonal', 'orthogonal']
  }, {
    'name': 'require',
    'type': 'signal'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(LinkPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sx = _.sourceX || sourceX,
      sy = _.sourceY || sourceY,
      tx = _.targetX || targetX,
      ty = _.targetY || targetY,
      as = _.as || 'path',
      orient = _.orient || 'vertical',
      shape = _.shape || 'line',
      path = Paths.get(shape + '-' + orient) || Paths.get(shape);
    if (!path) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('LinkPath unsupported type: ' + _.shape + (_.orient ? '-' + _.orient : ''));
    }
    pulse.visit(pulse.SOURCE, t => {
      t[as] = path(sx(t), sy(t), tx(t), ty(t));
    });
    return pulse.reflow(_.modified()).modifies(as);
  }
});
const line = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'L' + tx + ',' + ty;
const lineR = (sa, sr, ta, tr) => line(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));
const arc = (sx, sy, tx, ty) => {
  var dx = tx - sx,
    dy = ty - sy,
    rr = Math.hypot(dx, dy) / 2,
    ra = 180 * Math.atan2(dy, dx) / Math.PI;
  return 'M' + sx + ',' + sy + 'A' + rr + ',' + rr + ' ' + ra + ' 0 1' + ' ' + tx + ',' + ty;
};
const arcR = (sa, sr, ta, tr) => arc(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));
const curve = (sx, sy, tx, ty) => {
  const dx = tx - sx,
    dy = ty - sy,
    ix = 0.2 * (dx + dy),
    iy = 0.2 * (dy - dx);
  return 'M' + sx + ',' + sy + 'C' + (sx + ix) + ',' + (sy + iy) + ' ' + (tx + iy) + ',' + (ty - ix) + ' ' + tx + ',' + ty;
};
const curveR = (sa, sr, ta, tr) => curve(sr * Math.cos(sa), sr * Math.sin(sa), tr * Math.cos(ta), tr * Math.sin(ta));
const orthoX = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'V' + ty + 'H' + tx;
const orthoY = (sx, sy, tx, ty) => 'M' + sx + ',' + sy + 'H' + tx + 'V' + ty;
const orthoR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
    ss = Math.sin(sa),
    tc = Math.cos(ta),
    ts = Math.sin(ta),
    sf = Math.abs(ta - sa) > Math.PI ? ta <= sa : ta > sa;
  return 'M' + sr * sc + ',' + sr * ss + 'A' + sr + ',' + sr + ' 0 0,' + (sf ? 1 : 0) + ' ' + sr * tc + ',' + sr * ts + 'L' + tr * tc + ',' + tr * ts;
};
const diagonalX = (sx, sy, tx, ty) => {
  const m = (sx + tx) / 2;
  return 'M' + sx + ',' + sy + 'C' + m + ',' + sy + ' ' + m + ',' + ty + ' ' + tx + ',' + ty;
};
const diagonalY = (sx, sy, tx, ty) => {
  const m = (sy + ty) / 2;
  return 'M' + sx + ',' + sy + 'C' + sx + ',' + m + ' ' + tx + ',' + m + ' ' + tx + ',' + ty;
};
const diagonalR = (sa, sr, ta, tr) => {
  const sc = Math.cos(sa),
    ss = Math.sin(sa),
    tc = Math.cos(ta),
    ts = Math.sin(ta),
    mr = (sr + tr) / 2;
  return 'M' + sr * sc + ',' + sr * ss + 'C' + mr * sc + ',' + mr * ss + ' ' + mr * tc + ',' + mr * ts + ' ' + tr * tc + ',' + tr * ts;
};
const Paths = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.fastmap)({
  'line': line,
  'line-radial': lineR,
  'arc': arc,
  'arc-radial': arcR,
  'curve': curve,
  'curve-radial': curveR,
  'orthogonal-horizontal': orthoX,
  'orthogonal-vertical': orthoY,
  'orthogonal-radial': orthoR,
  'diagonal-horizontal': diagonalX,
  'diagonal-vertical': diagonalY,
  'diagonal-radial': diagonalR
});

/**
 * Pie and donut chart layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size pie segments.
 * @param {number} [params.startAngle=0] - The start angle (in radians) of the layout.
 * @param {number} [params.endAngle=2Ï€] - The end angle (in radians) of the layout.
 * @param {boolean} [params.sort] - Boolean flag for sorting sectors by value.
 */
function Pie(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Pie.Definition = {
  'type': 'Pie',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'startAngle',
    'type': 'number',
    'default': 0
  }, {
    'name': 'endAngle',
    'type': 'number',
    'default': 6.283185307179586
  }, {
    'name': 'sort',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['startAngle', 'endAngle']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Pie, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || ['startAngle', 'endAngle'],
      startAngle = as[0],
      endAngle = as[1],
      field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
      start = _.startAngle || 0,
      stop = _.endAngle != null ? _.endAngle : 2 * Math.PI,
      data = pulse.source,
      values = data.map(field),
      n = values.length,
      a = start,
      k = (stop - start) / (0,d3_array__WEBPACK_IMPORTED_MODULE_3__["default"])(values),
      index = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__["default"])(n),
      i,
      t,
      v;
    if (_.sort) {
      index.sort((a, b) => values[a] - values[b]);
    }
    for (i = 0; i < n; ++i) {
      v = values[index[i]];
      t = data[index[i]];
      t[startAngle] = a;
      t[endAngle] = a += v * k;
    }
    this.value = values;
    return pulse.reflow(_.modified()).modifies(as);
  }
});

const DEFAULT_COUNT = 5;
function includeZero(scale) {
  const type = scale.type;
  return !scale.bins && (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt);
}
function includePad(type) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(type) && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential;
}
const SKIP = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.toSet)(['set', 'modified', 'clear', 'type', 'scheme', 'schemeExtent', 'schemeCount', 'domain', 'domainMin', 'domainMid', 'domainMax', 'domainRaw', 'domainImplicit', 'nice', 'zero', 'bins', 'range', 'rangeStep', 'round', 'reverse', 'interpolate', 'interpolateGamma']);

/**
 * Maintains a scale function mapping data values to visual channels.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function Scale(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Scale, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var df = pulse.dataflow,
      scale$1 = this.value,
      key = scaleKey(_);
    if (!scale$1 || key !== scale$1.type) {
      this.value = scale$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scale)(key)();
    }
    for (key in _) if (!SKIP[key]) {
      // padding is a scale property for band/point but not others
      if (key === 'padding' && includePad(scale$1.type)) continue;
      // invoke scale property setter, raise warning if not found
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale$1[key]) ? scale$1[key](_[key]) : df.warn('Unsupported scale property: ' + key);
    }
    configureRange(scale$1, _, configureBins(scale$1, _, configureDomain(scale$1, _, df)));
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }
});
function scaleKey(_) {
  var t = _.type,
    d = '',
    n;

  // backwards compatibility pre Vega 5.
  if (t === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential) return vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' + vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear;
  if (isContinuousColor(_)) {
    n = _.rawDomain ? _.rawDomain.length : _.domain ? _.domain.length + +(_.domainMid != null) : 0;
    d = n === 2 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sequential + '-' : n === 3 ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.Diverging + '-' : '';
  }
  return (d + t || vega_scale__WEBPACK_IMPORTED_MODULE_1__.Linear).toLowerCase();
}
function isContinuousColor(_) {
  const t = _.type;
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isContinuous)(t) && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Time && t !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.UTC && (_.scheme || _.range && _.range.length && _.range.every(vega_util__WEBPACK_IMPORTED_MODULE_2__.isString));
}
function configureDomain(scale, _, df) {
  // check raw domain, if provided use that and exit early
  const raw = rawDomain(scale, _.domainRaw, df);
  if (raw > -1) return raw;
  var domain = _.domain,
    type = scale.type,
    zero = _.zero || _.zero === undefined && includeZero(scale),
    n,
    mid;
  if (!domain) return 0;

  // adjust domain based on zero, min, max settings
  if (zero || _.domainMin != null || _.domainMax != null || _.domainMid != null) {
    n = (domain = domain.slice()).length - 1 || 1;
    if (zero) {
      if (domain[0] > 0) domain[0] = 0;
      if (domain[n] < 0) domain[n] = 0;
    }
    if (_.domainMin != null) domain[0] = _.domainMin;
    if (_.domainMax != null) domain[n] = _.domainMax;
    if (_.domainMid != null) {
      mid = _.domainMid;
      const i = mid > domain[n] ? n + 1 : mid < domain[0] ? 0 : n;
      if (i !== n) df.warn('Scale domainMid exceeds domain min or max.', mid);
      domain.splice(i, 0, mid);
    }
  }

  // adjust continuous domain for minimum pixel padding
  if (includePad(type) && _.padding && domain[0] !== (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain)) {
    domain = padDomain(type, domain, _.range, _.padding, _.exponent, _.constant);
  }

  // set the scale domain
  scale.domain(domainCheck(type, domain, df));

  // if ordinal scale domain is defined, prevent implicit
  // domain construction as side-effect of scale lookup
  if (type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal) {
    scale.unknown(_.domainImplicit ? vega_scale__WEBPACK_IMPORTED_MODULE_1__.scaleImplicit : undefined);
  }

  // perform 'nice' adjustment as requested
  if (_.nice && scale.nice) {
    scale.nice(_.nice !== true && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.tickCount)(scale, _.nice) || null);
  }

  // return the cardinality of the domain
  return domain.length;
}
function rawDomain(scale, raw, df) {
  if (raw) {
    scale.domain(domainCheck(scale.type, raw, df));
    return raw.length;
  } else {
    return -1;
  }
}
function padDomain(type, domain, range, pad, exponent, constant) {
  var span = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(range) - range[0]),
    frac = span / (span - 2 * pad),
    d = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Log ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLog)(domain, null, frac) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Sqrt ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, 0.5) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Pow ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomPow)(domain, null, frac, exponent || 1) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Symlog ? (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomSymlog)(domain, null, frac, constant || 1) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.zoomLinear)(domain, null, frac);
  domain = domain.slice();
  domain[0] = d[0];
  domain[domain.length - 1] = d[1];
  return domain;
}
function domainCheck(type, domain, df) {
  if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isLogarithmic)(type)) {
    // sum signs of domain values
    // if all pos or all neg, abs(sum) === domain.length
    var s = Math.abs(domain.reduce((s, v) => s + (v < 0 ? -1 : v > 0 ? 1 : 0), 0));
    if (s !== domain.length) {
      df.warn('Log scale domain includes zero: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.stringValue)(domain));
    }
  }
  return domain;
}
function configureBins(scale, _, count) {
  let bins = _.bins;
  if (bins && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(bins)) {
    // generate bin boundary array
    const domain = scale.domain(),
      lo = domain[0],
      hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(domain),
      step = bins.step;
    let start = bins.start == null ? lo : bins.start,
      stop = bins.stop == null ? hi : bins.stop;
    if (!step) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Scale bins parameter missing step property.');
    if (start < lo) start = step * Math.ceil(lo / step);
    if (stop > hi) stop = step * Math.floor(hi / step);
    bins = (0,d3_array__WEBPACK_IMPORTED_MODULE_4__["default"])(start, stop + step / 2, step);
  }
  if (bins) {
    // assign bin boundaries to scale instance
    scale.bins = bins;
  } else if (scale.bins) {
    // no current bins, remove bins if previously set
    delete scale.bins;
  }

  // special handling for bin-ordinal scales
  if (scale.type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal) {
    if (!bins) {
      // the domain specifies the bins
      scale.bins = scale.domain();
    } else if (!_.domain && !_.domainRaw) {
      // the bins specify the domain
      scale.domain(bins);
      count = bins.length;
    }
  }

  // return domain cardinality
  return count;
}
function configureRange(scale, _, count) {
  var type = scale.type,
    round = _.round || false,
    range = _.range;

  // if range step specified, calculate full range extent
  if (_.rangeStep != null) {
    range = configureRangeStep(type, _, count);
  }

  // else if a range scheme is defined, use that
  else if (_.scheme) {
    range = configureScheme(type, _, count);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(range)) {
      if (scale.interpolator) {
        return scale.interpolator(range);
      } else {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)(`Scale type ${type} does not support interpolating color schemes.`);
      }
    }
  }

  // given a range array for an interpolating scale, convert to interpolator
  if (range && (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type)) {
    return scale.interpolator((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(flip(range, _.reverse), _.interpolate, _.interpolateGamma));
  }

  // configure rounding / interpolation
  if (range && _.interpolate && scale.interpolate) {
    scale.interpolate((0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolate)(_.interpolate, _.interpolateGamma));
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.round)) {
    scale.round(round);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scale.rangeRound)) {
    scale.interpolate(round ? d3_interpolate__WEBPACK_IMPORTED_MODULE_5__["default"] : d3_interpolate__WEBPACK_IMPORTED_MODULE_6__["default"]);
  }
  if (range) scale.range(flip(range, _.reverse));
}
function configureRangeStep(type, _, count) {
  if (type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Band && type !== vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Only band and point scales support rangeStep.');
  }

  // calculate full range based on requested step size and padding
  var outer = (_.paddingOuter != null ? _.paddingOuter : _.padding) || 0,
    inner = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Point ? 1 : (_.paddingInner != null ? _.paddingInner : _.padding) || 0;
  return [0, _.rangeStep * (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.bandSpace)(count, inner, outer)];
}
function configureScheme(type, _, count) {
  var extent = _.schemeExtent,
    name,
    scheme$1;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isArray)(_.scheme)) {
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateColors)(_.scheme, _.interpolate, _.interpolateGamma);
  } else {
    name = _.scheme.toLowerCase();
    scheme$1 = (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.scheme)(name);
    if (!scheme$1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)(`Unrecognized scheme name: ${_.scheme}`);
  }

  // determine size for potential discrete range
  count = type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Threshold ? count + 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.BinOrdinal ? count - 1 : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantile || type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Quantize ? +_.schemeCount || DEFAULT_COUNT : count;

  // adjust and/or quantize scheme as appropriate
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.isInterpolating)(type) ? adjustScheme(scheme$1, extent, _.reverse) : (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme$1) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.quantizeInterpolator)(adjustScheme(scheme$1, extent), count) : type === vega_scale__WEBPACK_IMPORTED_MODULE_1__.Ordinal ? scheme$1 : scheme$1.slice(0, count);
}
function adjustScheme(scheme, extent, reverse) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(scheme) && (extent || reverse) ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_1__.interpolateRange)(scheme, flip(extent || [0, 1], reverse)) : scheme;
}
function flip(array, reverse) {
  return reverse ? array.slice().reverse() : array;
}

/**
 * Sorts scenegraph items in the pulse source array.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting tuples.
 */
function SortItems(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(SortItems, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const mod = _.modified('sort') || pulse.changed(pulse.ADD) || pulse.modified(_.sort.fields) || pulse.modified('datum');
    if (mod) pulse.source.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort));
    this.modified(mod);
    return pulse;
  }
});

const Zero = 'zero',
  Center = 'center',
  Normalize = 'normalize',
  DefOutput = ['y0', 'y1'];

/**
 * Stack layout for visualization elements.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to stack.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {function(object,object): number} [params.sort] - A comparator for stack sorting.
 * @param {string} [offset='zero'] - Stack baseline offset. One of 'zero', 'center', 'normalize'.
 */
function Stack(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stack.Definition = {
  'type': 'Stack',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'offset',
    'type': 'enum',
    'default': Zero,
    'values': [Zero, Center, Normalize]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': DefOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Stack, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var as = _.as || DefOutput,
      y0 = as[0],
      y1 = as[1],
      sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort),
      field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_2__.one,
      stack = _.offset === Center ? stackCenter : _.offset === Normalize ? stackNormalize : stackZero,
      groups,
      i,
      n,
      max;

    // partition, sum, and sort the stack groups
    groups = partition(pulse.source, _.groupby, sort, field);

    // compute stack layouts per group
    for (i = 0, n = groups.length, max = groups.max; i < n; ++i) {
      stack(groups[i], max, field, y0, y1);
    }
    return pulse.reflow(_.modified()).modifies(as);
  }
});
function stackCenter(group, max, field, y0, y1) {
  var last = (max - group.sum) / 2,
    m = group.length,
    j = 0,
    t;
  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last += Math.abs(field(t));
  }
}
function stackNormalize(group, max, field, y0, y1) {
  var scale = 1 / group.sum,
    last = 0,
    m = group.length,
    j = 0,
    v = 0,
    t;
  for (; j < m; ++j) {
    t = group[j];
    t[y0] = last;
    t[y1] = last = scale * (v += Math.abs(field(t)));
  }
}
function stackZero(group, max, field, y0, y1) {
  var lastPos = 0,
    lastNeg = 0,
    m = group.length,
    j = 0,
    v,
    t;
  for (; j < m; ++j) {
    t = group[j];
    v = +field(t);
    if (v < 0) {
      t[y0] = lastNeg;
      t[y1] = lastNeg += v;
    } else {
      t[y0] = lastPos;
      t[y1] = lastPos += v;
    }
  }
}
function partition(data, groupby, sort, field) {
  var groups = [],
    get = f => f(t),
    map,
    i,
    n,
    m,
    t,
    k,
    g,
    s,
    max;

  // partition data points into stack groups
  if (groupby == null) {
    groups.push(data.slice());
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];
      if (!g) {
        map[k] = g = [];
        groups.push(g);
      }
      g.push(t);
    }
  }

  // compute sums of groups, sort groups as needed
  for (k = 0, max = 0, m = groups.length; k < m; ++k) {
    g = groups[k];
    for (i = 0, s = 0, n = g.length; i < n; ++i) {
      s += Math.abs(field(g[i]));
    }
    g.sum = s;
    if (s > max) max = s;
    if (sort) g.sort(sort);
  }
  groups.max = max;
  return groups;
}




/***/ }),

/***/ "./node_modules/vega-event-selector/build/vega-event-selector.module.js":
/*!******************************************************************************!*\
  !*** ./node_modules/vega-event-selector/build/vega-event-selector.module.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   parseSelector: () => (/* binding */ eventSelector)
/* harmony export */ });
const VIEW = 'view',
  LBRACK = '[',
  RBRACK = ']',
  LBRACE = '{',
  RBRACE = '}',
  COLON = ':',
  COMMA = ',',
  NAME = '@',
  GT = '>',
  ILLEGAL = /[[\]{}]/,
  DEFAULT_MARKS = {
    '*': 1,
    arc: 1,
    area: 1,
    group: 1,
    image: 1,
    line: 1,
    path: 1,
    rect: 1,
    rule: 1,
    shape: 1,
    symbol: 1,
    text: 1,
    trail: 1
  };
let DEFAULT_SOURCE, MARKS;

/**
 * Parse an event selector string.
 * Returns an array of event stream definitions.
 */
function eventSelector (selector, source, marks) {
  DEFAULT_SOURCE = source || VIEW;
  MARKS = marks || DEFAULT_MARKS;
  return parseMerge(selector.trim()).map(parseSelector);
}
function isMarkType(type) {
  return MARKS[type];
}
function find(s, i, endChar, pushChar, popChar) {
  const n = s.length;
  let count = 0,
    c;
  for (; i < n; ++i) {
    c = s[i];
    if (!count && c === endChar) return i;else if (popChar && popChar.indexOf(c) >= 0) --count;else if (pushChar && pushChar.indexOf(c) >= 0) ++count;
  }
  return i;
}
function parseMerge(s) {
  const output = [],
    n = s.length;
  let start = 0,
    i = 0;
  while (i < n) {
    i = find(s, i, COMMA, LBRACK + LBRACE, RBRACK + RBRACE);
    output.push(s.substring(start, i).trim());
    start = ++i;
  }
  if (output.length === 0) {
    throw 'Empty event selector: ' + s;
  }
  return output;
}
function parseSelector(s) {
  return s[0] === '[' ? parseBetween(s) : parseStream(s);
}
function parseBetween(s) {
  const n = s.length;
  let i = 1,
    b;
  i = find(s, i, RBRACK, LBRACK, RBRACK);
  if (i === n) {
    throw 'Empty between selector: ' + s;
  }
  b = parseMerge(s.substring(1, i));
  if (b.length !== 2) {
    throw 'Between selector must have two elements: ' + s;
  }
  s = s.slice(i + 1).trim();
  if (s[0] !== GT) {
    throw 'Expected \'>\' after between selector: ' + s;
  }
  b = b.map(parseSelector);
  const stream = parseSelector(s.slice(1).trim());
  if (stream.between) {
    return {
      between: b,
      stream: stream
    };
  } else {
    stream.between = b;
  }
  return stream;
}
function parseStream(s) {
  const stream = {
      source: DEFAULT_SOURCE
    },
    source = [];
  let throttle = [0, 0],
    markname = 0,
    start = 0,
    n = s.length,
    i = 0,
    j,
    filter;

  // extract throttle from end
  if (s[n - 1] === RBRACE) {
    i = s.lastIndexOf(LBRACE);
    if (i >= 0) {
      try {
        throttle = parseThrottle(s.substring(i + 1, n - 1));
      } catch (e) {
        throw 'Invalid throttle specification: ' + s;
      }
      s = s.slice(0, i).trim();
      n = s.length;
    } else throw 'Unmatched right brace: ' + s;
    i = 0;
  }
  if (!n) throw s;

  // set name flag based on first char
  if (s[0] === NAME) markname = ++i;

  // extract first part of multi-part stream selector
  j = find(s, i, COLON);
  if (j < n) {
    source.push(s.substring(start, j).trim());
    start = i = ++j;
  }

  // extract remaining part of stream selector
  i = find(s, i, LBRACK);
  if (i === n) {
    source.push(s.substring(start, n).trim());
  } else {
    source.push(s.substring(start, i).trim());
    filter = [];
    start = ++i;
    if (start === n) throw 'Unmatched left bracket: ' + s;
  }

  // extract filters
  while (i < n) {
    i = find(s, i, RBRACK);
    if (i === n) throw 'Unmatched left bracket: ' + s;
    filter.push(s.substring(start, i).trim());
    if (i < n - 1 && s[++i] !== LBRACK) throw 'Expected left bracket: ' + s;
    start = ++i;
  }

  // marshall event stream specification
  if (!(n = source.length) || ILLEGAL.test(source[n - 1])) {
    throw 'Invalid event selector: ' + s;
  }
  if (n > 1) {
    stream.type = source[1];
    if (markname) {
      stream.markname = source[0].slice(1);
    } else if (isMarkType(source[0])) {
      stream.marktype = source[0];
    } else {
      stream.source = source[0];
    }
  } else {
    stream.type = source[0];
  }
  if (stream.type.slice(-1) === '!') {
    stream.consume = true;
    stream.type = stream.type.slice(0, -1);
  }
  if (filter != null) stream.filter = filter;
  if (throttle[0]) stream.throttle = throttle[0];
  if (throttle[1]) stream.debounce = throttle[1];
  return stream;
}
function parseThrottle(s) {
  const a = s.split(COMMA);
  if (!s.length || a.length > 2) throw s;
  return a.map(_ => {
    const x = +_;
    if (x !== x) throw s;
    return x;
  });
}




/***/ }),

/***/ "./node_modules/vega-expression/build/vega-expression.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-expression/build/vega-expression.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ASTNode: () => (/* binding */ ASTNode),
/* harmony export */   ArrayExpression: () => (/* binding */ ArrayExpression),
/* harmony export */   BinaryExpression: () => (/* binding */ BinaryExpression),
/* harmony export */   CallExpression: () => (/* binding */ CallExpression),
/* harmony export */   ConditionalExpression: () => (/* binding */ ConditionalExpression),
/* harmony export */   Identifier: () => (/* binding */ Identifier),
/* harmony export */   Literal: () => (/* binding */ Literal),
/* harmony export */   LogicalExpression: () => (/* binding */ LogicalExpression),
/* harmony export */   MemberExpression: () => (/* binding */ MemberExpression),
/* harmony export */   ObjectExpression: () => (/* binding */ ObjectExpression),
/* harmony export */   Property: () => (/* binding */ Property),
/* harmony export */   RawCode: () => (/* binding */ RawCode),
/* harmony export */   UnaryExpression: () => (/* binding */ UnaryExpression),
/* harmony export */   codegenExpression: () => (/* binding */ codegen),
/* harmony export */   constants: () => (/* binding */ Constants),
/* harmony export */   functions: () => (/* binding */ Functions),
/* harmony export */   parseExpression: () => (/* binding */ parser)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");


const RawCode = 'RawCode';
const Literal = 'Literal';
const Property = 'Property';
const Identifier = 'Identifier';
const ArrayExpression = 'ArrayExpression';
const BinaryExpression = 'BinaryExpression';
const CallExpression = 'CallExpression';
const ConditionalExpression = 'ConditionalExpression';
const LogicalExpression = 'LogicalExpression';
const MemberExpression = 'MemberExpression';
const ObjectExpression = 'ObjectExpression';
const UnaryExpression = 'UnaryExpression';
function ASTNode(type) {
  this.type = type;
}
ASTNode.prototype.visit = function (visitor) {
  let c, i, n;
  if (visitor(this)) return 1;
  for (c = children(this), i = 0, n = c.length; i < n; ++i) {
    if (c[i].visit(visitor)) return 1;
  }
};
function children(node) {
  switch (node.type) {
    case ArrayExpression:
      return node.elements;
    case BinaryExpression:
    case LogicalExpression:
      return [node.left, node.right];
    case CallExpression:
      return [node.callee].concat(node.arguments);
    case ConditionalExpression:
      return [node.test, node.consequent, node.alternate];
    case MemberExpression:
      return [node.object, node.property];
    case ObjectExpression:
      return node.properties;
    case Property:
      return [node.key, node.value];
    case UnaryExpression:
      return [node.argument];
    case Identifier:
    case Literal:
    case RawCode:
    default:
      return [];
  }
}

/*
  The following expression parser is based on Esprima (http://esprima.org/).
  Original header comment and license for Esprima is included here:

  Copyright (C) 2013 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2013 Thaddee Tyl <thaddee.tyl@gmail.com>
  Copyright (C) 2013 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Ariya Hidayat <ariya.hidayat@gmail.com>
  Copyright (C) 2012 Mathias Bynens <mathias@qiwi.be>
  Copyright (C) 2012 Joost-Wim Boekesteijn <joost-wim@boekesteijn.nl>
  Copyright (C) 2012 Kris Kowal <kris.kowal@cixar.com>
  Copyright (C) 2012 Yusuke Suzuki <utatane.tea@gmail.com>
  Copyright (C) 2012 Arpad Borsos <arpad.borsos@googlemail.com>
  Copyright (C) 2011 Ariya Hidayat <ariya.hidayat@gmail.com>

  Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright
      notice, this list of conditions and the following disclaimer in the
      documentation and/or other materials provided with the distribution.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/
var TokenName, source, index, length, lookahead;
var TokenBooleanLiteral = 1,
  TokenEOF = 2,
  TokenIdentifier = 3,
  TokenKeyword = 4,
  TokenNullLiteral = 5,
  TokenNumericLiteral = 6,
  TokenPunctuator = 7,
  TokenStringLiteral = 8,
  TokenRegularExpression = 9;
TokenName = {};
TokenName[TokenBooleanLiteral] = 'Boolean';
TokenName[TokenEOF] = '<end>';
TokenName[TokenIdentifier] = 'Identifier';
TokenName[TokenKeyword] = 'Keyword';
TokenName[TokenNullLiteral] = 'Null';
TokenName[TokenNumericLiteral] = 'Numeric';
TokenName[TokenPunctuator] = 'Punctuator';
TokenName[TokenStringLiteral] = 'String';
TokenName[TokenRegularExpression] = 'RegularExpression';
var SyntaxArrayExpression = 'ArrayExpression',
  SyntaxBinaryExpression = 'BinaryExpression',
  SyntaxCallExpression = 'CallExpression',
  SyntaxConditionalExpression = 'ConditionalExpression',
  SyntaxIdentifier = 'Identifier',
  SyntaxLiteral = 'Literal',
  SyntaxLogicalExpression = 'LogicalExpression',
  SyntaxMemberExpression = 'MemberExpression',
  SyntaxObjectExpression = 'ObjectExpression',
  SyntaxProperty = 'Property',
  SyntaxUnaryExpression = 'UnaryExpression';

// Error messages should be identical to V8.
var MessageUnexpectedToken = 'Unexpected token %0',
  MessageUnexpectedNumber = 'Unexpected number',
  MessageUnexpectedString = 'Unexpected string',
  MessageUnexpectedIdentifier = 'Unexpected identifier',
  MessageUnexpectedReserved = 'Unexpected reserved word',
  MessageUnexpectedEOS = 'Unexpected end of input',
  MessageInvalidRegExp = 'Invalid regular expression',
  MessageUnterminatedRegExp = 'Invalid regular expression: missing /',
  MessageStrictOctalLiteral = 'Octal literals are not allowed in strict mode.',
  MessageStrictDuplicateProperty = 'Duplicate data property in object literal not allowed in strict mode';
var ILLEGAL = 'ILLEGAL',
  DISABLED = 'Disabled.';

// See also tools/generate-unicode-regex.py.
var RegexNonAsciiIdentifierStart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0370-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u064A\\u066E\\u066F\\u0671-\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE\\u06EF\\u06FA-\\u06FC\\u06FF\\u0710\\u0712-\\u072F\\u074D-\\u07A5\\u07B1\\u07CA-\\u07EA\\u07F4\\u07F5\\u07FA\\u0800-\\u0815\\u081A\\u0824\\u0828\\u0840-\\u0858\\u08A0-\\u08B2\\u0904-\\u0939\\u093D\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BD\\u09CE\\u09DC\\u09DD\\u09DF-\\u09E1\\u09F0\\u09F1\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A59-\\u0A5C\\u0A5E\\u0A72-\\u0A74\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABD\\u0AD0\\u0AE0\\u0AE1\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3D\\u0B5C\\u0B5D\\u0B5F-\\u0B61\\u0B71\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BD0\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D\\u0C58\\u0C59\\u0C60\\u0C61\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBD\\u0CDE\\u0CE0\\u0CE1\\u0CF1\\u0CF2\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D\\u0D4E\\u0D60\\u0D61\\u0D7A-\\u0D7F\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0E01-\\u0E30\\u0E32\\u0E33\\u0E40-\\u0E46\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB0\\u0EB2\\u0EB3\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EDC-\\u0EDF\\u0F00\\u0F40-\\u0F47\\u0F49-\\u0F6C\\u0F88-\\u0F8C\\u1000-\\u102A\\u103F\\u1050-\\u1055\\u105A-\\u105D\\u1061\\u1065\\u1066\\u106E-\\u1070\\u1075-\\u1081\\u108E\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176C\\u176E-\\u1770\\u1780-\\u17B3\\u17D7\\u17DC\\u1820-\\u1877\\u1880-\\u18A8\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1950-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19C1-\\u19C7\\u1A00-\\u1A16\\u1A20-\\u1A54\\u1AA7\\u1B05-\\u1B33\\u1B45-\\u1B4B\\u1B83-\\u1BA0\\u1BAE\\u1BAF\\u1BBA-\\u1BE5\\u1C00-\\u1C23\\u1C4D-\\u1C4F\\u1C5A-\\u1C7D\\u1CE9-\\u1CEC\\u1CEE-\\u1CF1\\u1CF5\\u1CF6\\u1D00-\\u1DBF\\u1E00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u2071\\u207F\\u2090-\\u209C\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CEE\\u2CF2\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2E2F\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA61F\\uA62A\\uA62B\\uA640-\\uA66E\\uA67F-\\uA69D\\uA6A0-\\uA6EF\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA801\\uA803-\\uA805\\uA807-\\uA80A\\uA80C-\\uA822\\uA840-\\uA873\\uA882-\\uA8B3\\uA8F2-\\uA8F7\\uA8FB\\uA90A-\\uA925\\uA930-\\uA946\\uA960-\\uA97C\\uA984-\\uA9B2\\uA9CF\\uA9E0-\\uA9E4\\uA9E6-\\uA9EF\\uA9FA-\\uA9FE\\uAA00-\\uAA28\\uAA40-\\uAA42\\uAA44-\\uAA4B\\uAA60-\\uAA76\\uAA7A\\uAA7E-\\uAAAF\\uAAB1\\uAAB5\\uAAB6\\uAAB9-\\uAABD\\uAAC0\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEA\\uAAF2-\\uAAF4\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABE2\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D\\uFB1F-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF21-\\uFF3A\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]'),
  // eslint-disable-next-line no-misleading-character-class
  RegexNonAsciiIdentifierPart = new RegExp('[\\xAA\\xB5\\xBA\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02C1\\u02C6-\\u02D1\\u02E0-\\u02E4\\u02EC\\u02EE\\u0300-\\u0374\\u0376\\u0377\\u037A-\\u037D\\u037F\\u0386\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03F5\\u03F7-\\u0481\\u0483-\\u0487\\u048A-\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0587\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0610-\\u061A\\u0620-\\u0669\\u066E-\\u06D3\\u06D5-\\u06DC\\u06DF-\\u06E8\\u06EA-\\u06FC\\u06FF\\u0710-\\u074A\\u074D-\\u07B1\\u07C0-\\u07F5\\u07FA\\u0800-\\u082D\\u0840-\\u085B\\u08A0-\\u08B2\\u08E4-\\u0963\\u0966-\\u096F\\u0971-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u09D7\\u09DC\\u09DD\\u09DF-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A33\\u0A35\\u0A36\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A59-\\u0A5C\\u0A5E\\u0A66-\\u0A75\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B44\\u0B47\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5C\\u0B5D\\u0B5F-\\u0B63\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0\\u0BD7\\u0BE6-\\u0BEF\\u0C00-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u0C2A-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C58\\u0C59\\u0C60-\\u0C63\\u0C66-\\u0C6F\\u0C81-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5\\u0CD6\\u0CDE\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D01-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D44\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D63\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D96\\u0D9A-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6\\u0DD8-\\u0DDF\\u0DE6-\\u0DEF\\u0DF2\\u0DF3\\u0E01-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB9\\u0EBB-\\u0EBD\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDC-\\u0EDF\\u0F00\\u0F18\\u0F19\\u0F20-\\u0F29\\u0F35\\u0F37\\u0F39\\u0F3E-\\u0F47\\u0F49-\\u0F6C\\u0F71-\\u0F84\\u0F86-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10A0-\\u10C5\\u10C7\\u10CD\\u10D0-\\u10FA\\u10FC-\\u1248\\u124A-\\u124D\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u13A0-\\u13F4\\u1401-\\u166C\\u166F-\\u167F\\u1681-\\u169A\\u16A0-\\u16EA\\u16EE-\\u16F8\\u1700-\\u170C\\u170E-\\u1714\\u1720-\\u1734\\u1740-\\u1753\\u1760-\\u176C\\u176E-\\u1770\\u1772\\u1773\\u1780-\\u17D3\\u17D7\\u17DC\\u17DD\\u17E0-\\u17E9\\u180B-\\u180D\\u1810-\\u1819\\u1820-\\u1877\\u1880-\\u18AA\\u18B0-\\u18F5\\u1900-\\u191E\\u1920-\\u192B\\u1930-\\u193B\\u1946-\\u196D\\u1970-\\u1974\\u1980-\\u19AB\\u19B0-\\u19C9\\u19D0-\\u19D9\\u1A00-\\u1A1B\\u1A20-\\u1A5E\\u1A60-\\u1A7C\\u1A7F-\\u1A89\\u1A90-\\u1A99\\u1AA7\\u1AB0-\\u1ABD\\u1B00-\\u1B4B\\u1B50-\\u1B59\\u1B6B-\\u1B73\\u1B80-\\u1BF3\\u1C00-\\u1C37\\u1C40-\\u1C49\\u1C4D-\\u1C7D\\u1CD0-\\u1CD2\\u1CD4-\\u1CF6\\u1CF8\\u1CF9\\u1D00-\\u1DF5\\u1DFC-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F7D\\u1F80-\\u1FB4\\u1FB6-\\u1FBC\\u1FBE\\u1FC2-\\u1FC4\\u1FC6-\\u1FCC\\u1FD0-\\u1FD3\\u1FD6-\\u1FDB\\u1FE0-\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-\\u1FFC\\u200C\\u200D\\u203F\\u2040\\u2054\\u2071\\u207F\\u2090-\\u209C\\u20D0-\\u20DC\\u20E1\\u20E5-\\u20F0\\u2102\\u2107\\u210A-\\u2113\\u2115\\u2119-\\u211D\\u2124\\u2126\\u2128\\u212A-\\u212D\\u212F-\\u2139\\u213C-\\u213F\\u2145-\\u2149\\u214E\\u2160-\\u2188\\u2C00-\\u2C2E\\u2C30-\\u2C5E\\u2C60-\\u2CE4\\u2CEB-\\u2CF3\\u2D00-\\u2D25\\u2D27\\u2D2D\\u2D30-\\u2D67\\u2D6F\\u2D7F-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u2DE0-\\u2DFF\\u2E2F\\u3005-\\u3007\\u3021-\\u302F\\u3031-\\u3035\\u3038-\\u303C\\u3041-\\u3096\\u3099\\u309A\\u309D-\\u309F\\u30A1-\\u30FA\\u30FC-\\u30FF\\u3105-\\u312D\\u3131-\\u318E\\u31A0-\\u31BA\\u31F0-\\u31FF\\u3400-\\u4DB5\\u4E00-\\u9FCC\\uA000-\\uA48C\\uA4D0-\\uA4FD\\uA500-\\uA60C\\uA610-\\uA62B\\uA640-\\uA66F\\uA674-\\uA67D\\uA67F-\\uA69D\\uA69F-\\uA6F1\\uA717-\\uA71F\\uA722-\\uA788\\uA78B-\\uA78E\\uA790-\\uA7AD\\uA7B0\\uA7B1\\uA7F7-\\uA827\\uA840-\\uA873\\uA880-\\uA8C4\\uA8D0-\\uA8D9\\uA8E0-\\uA8F7\\uA8FB\\uA900-\\uA92D\\uA930-\\uA953\\uA960-\\uA97C\\uA980-\\uA9C0\\uA9CF-\\uA9D9\\uA9E0-\\uA9FE\\uAA00-\\uAA36\\uAA40-\\uAA4D\\uAA50-\\uAA59\\uAA60-\\uAA76\\uAA7A-\\uAAC2\\uAADB-\\uAADD\\uAAE0-\\uAAEF\\uAAF2-\\uAAF6\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAB30-\\uAB5A\\uAB5C-\\uAB5F\\uAB64\\uAB65\\uABC0-\\uABEA\\uABEC\\uABED\\uABF0-\\uABF9\\uAC00-\\uD7A3\\uD7B0-\\uD7C6\\uD7CB-\\uD7FB\\uF900-\\uFA6D\\uFA70-\\uFAD9\\uFB00-\\uFB06\\uFB13-\\uFB17\\uFB1D-\\uFB28\\uFB2A-\\uFB36\\uFB38-\\uFB3C\\uFB3E\\uFB40\\uFB41\\uFB43\\uFB44\\uFB46-\\uFBB1\\uFBD3-\\uFD3D\\uFD50-\\uFD8F\\uFD92-\\uFDC7\\uFDF0-\\uFDFB\\uFE00-\\uFE0F\\uFE20-\\uFE2D\\uFE33\\uFE34\\uFE4D-\\uFE4F\\uFE70-\\uFE74\\uFE76-\\uFEFC\\uFF10-\\uFF19\\uFF21-\\uFF3A\\uFF3F\\uFF41-\\uFF5A\\uFF66-\\uFFBE\\uFFC2-\\uFFC7\\uFFCA-\\uFFCF\\uFFD2-\\uFFD7\\uFFDA-\\uFFDC]');

// Ensure the condition is true, otherwise throw an error.
// This is only to have a better contract semantic, i.e. another safety net
// to catch a logic error. The condition shall be fulfilled in normal case.
// Do NOT use this to enforce a certain condition on any user input.

function assert(condition, message) {
  /* istanbul ignore next */
  if (!condition) {
    throw new Error('ASSERT: ' + message);
  }
}
function isDecimalDigit(ch) {
  return ch >= 0x30 && ch <= 0x39; // 0..9
}
function isHexDigit(ch) {
  return '0123456789abcdefABCDEF'.includes(ch);
}
function isOctalDigit(ch) {
  return '01234567'.includes(ch);
}

// 7.2 White Space

function isWhiteSpace(ch) {
  return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && [0x1680, 0x180E, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].includes(ch);
}

// 7.3 Line Terminators

function isLineTerminator(ch) {
  return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
}

// 7.6 Identifier Names and Identifiers

function isIdentifierStart(ch) {
  return ch === 0x24 || ch === 0x5F ||
  // $ (dollar) and _ (underscore)
  ch >= 0x41 && ch <= 0x5A ||
  // A..Z
  ch >= 0x61 && ch <= 0x7A ||
  // a..z
  ch === 0x5C ||
  // \ (backslash)
  ch >= 0x80 && RegexNonAsciiIdentifierStart.test(String.fromCharCode(ch));
}
function isIdentifierPart(ch) {
  return ch === 0x24 || ch === 0x5F ||
  // $ (dollar) and _ (underscore)
  ch >= 0x41 && ch <= 0x5A ||
  // A..Z
  ch >= 0x61 && ch <= 0x7A ||
  // a..z
  ch >= 0x30 && ch <= 0x39 ||
  // 0..9
  ch === 0x5C ||
  // \ (backslash)
  ch >= 0x80 && RegexNonAsciiIdentifierPart.test(String.fromCharCode(ch));
}

// 7.6.1.1 Keywords

const keywords = {
  'if': 1,
  'in': 1,
  'do': 1,
  'var': 1,
  'for': 1,
  'new': 1,
  'try': 1,
  'let': 1,
  'this': 1,
  'else': 1,
  'case': 1,
  'void': 1,
  'with': 1,
  'enum': 1,
  'while': 1,
  'break': 1,
  'catch': 1,
  'throw': 1,
  'const': 1,
  'yield': 1,
  'class': 1,
  'super': 1,
  'return': 1,
  'typeof': 1,
  'delete': 1,
  'switch': 1,
  'export': 1,
  'import': 1,
  'public': 1,
  'static': 1,
  'default': 1,
  'finally': 1,
  'extends': 1,
  'package': 1,
  'private': 1,
  'function': 1,
  'continue': 1,
  'debugger': 1,
  'interface': 1,
  'protected': 1,
  'instanceof': 1,
  'implements': 1
};
function skipComment() {
  while (index < length) {
    const ch = source.charCodeAt(index);
    if (isWhiteSpace(ch) || isLineTerminator(ch)) {
      ++index;
    } else {
      break;
    }
  }
}
function scanHexEscape(prefix) {
  var i,
    len,
    ch,
    code = 0;
  len = prefix === 'u' ? 4 : 2;
  for (i = 0; i < len; ++i) {
    if (index < length && isHexDigit(source[index])) {
      ch = source[index++];
      code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  return String.fromCharCode(code);
}
function scanUnicodeCodePointEscape() {
  var ch, code, cu1, cu2;
  ch = source[index];
  code = 0;

  // At least, one hex digit is required.
  if (ch === '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  while (index < length) {
    ch = source[index++];
    if (!isHexDigit(ch)) {
      break;
    }
    code = code * 16 + '0123456789abcdef'.indexOf(ch.toLowerCase());
  }
  if (code > 0x10FFFF || ch !== '}') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  // UTF-16 Encoding
  if (code <= 0xFFFF) {
    return String.fromCharCode(code);
  }
  cu1 = (code - 0x10000 >> 10) + 0xD800;
  cu2 = (code - 0x10000 & 1023) + 0xDC00;
  return String.fromCharCode(cu1, cu2);
}
function getEscapedIdentifier() {
  var ch, id;
  ch = source.charCodeAt(index++);
  id = String.fromCharCode(ch);

  // '\u' (U+005C, U+0075) denotes an escaped character.
  if (ch === 0x5C) {
    if (source.charCodeAt(index) !== 0x75) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    ++index;
    ch = scanHexEscape('u');
    if (!ch || ch === '\\' || !isIdentifierStart(ch.charCodeAt(0))) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
    id = ch;
  }
  while (index < length) {
    ch = source.charCodeAt(index);
    if (!isIdentifierPart(ch)) {
      break;
    }
    ++index;
    id += String.fromCharCode(ch);

    // '\u' (U+005C, U+0075) denotes an escaped character.
    if (ch === 0x5C) {
      id = id.substr(0, id.length - 1);
      if (source.charCodeAt(index) !== 0x75) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      ++index;
      ch = scanHexEscape('u');
      if (!ch || ch === '\\' || !isIdentifierPart(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
      id += ch;
    }
  }
  return id;
}
function getIdentifier() {
  var start, ch;
  start = index++;
  while (index < length) {
    ch = source.charCodeAt(index);
    if (ch === 0x5C) {
      // Blackslash (U+005C) marks Unicode escape sequence.
      index = start;
      return getEscapedIdentifier();
    }
    if (isIdentifierPart(ch)) {
      ++index;
    } else {
      break;
    }
  }
  return source.slice(start, index);
}
function scanIdentifier() {
  var start, id, type;
  start = index;

  // Backslash (U+005C) starts an escaped character.
  id = source.charCodeAt(index) === 0x5C ? getEscapedIdentifier() : getIdentifier();

  // There is no keyword or literal with only one character.
  // Thus, it must be an identifier.
  if (id.length === 1) {
    type = TokenIdentifier;
  } else if (keywords.hasOwnProperty(id)) {
    // eslint-disable-line no-prototype-builtins
    type = TokenKeyword;
  } else if (id === 'null') {
    type = TokenNullLiteral;
  } else if (id === 'true' || id === 'false') {
    type = TokenBooleanLiteral;
  } else {
    type = TokenIdentifier;
  }
  return {
    type: type,
    value: id,
    start: start,
    end: index
  };
}

// 7.7 Punctuators

function scanPunctuator() {
  var start = index,
    code = source.charCodeAt(index),
    code2,
    ch1 = source[index],
    ch2,
    ch3,
    ch4;
  switch (code) {
    // Check for most common single-character punctuators.
    case 0x2E: // . dot
    case 0x28: // ( open bracket
    case 0x29: // ) close bracket
    case 0x3B: // ; semicolon
    case 0x2C: // , comma
    case 0x7B: // { open curly brace
    case 0x7D: // } close curly brace
    case 0x5B: // [
    case 0x5D: // ]
    case 0x3A: // :
    case 0x3F: // ?
    case 0x7E:
      // ~
      ++index;
      return {
        type: TokenPunctuator,
        value: String.fromCharCode(code),
        start: start,
        end: index
      };
    default:
      code2 = source.charCodeAt(index + 1);

      // '=' (U+003D) marks an assignment or comparison operator.
      if (code2 === 0x3D) {
        switch (code) {
          case 0x2B: // +
          case 0x2D: // -
          case 0x2F: // /
          case 0x3C: // <
          case 0x3E: // >
          case 0x5E: // ^
          case 0x7C: // |
          case 0x25: // %
          case 0x26: // &
          case 0x2A:
            // *
            index += 2;
            return {
              type: TokenPunctuator,
              value: String.fromCharCode(code) + String.fromCharCode(code2),
              start: start,
              end: index
            };
          case 0x21: // !
          case 0x3D:
            // =
            index += 2;

            // !== and ===
            if (source.charCodeAt(index) === 0x3D) {
              ++index;
            }
            return {
              type: TokenPunctuator,
              value: source.slice(start, index),
              start: start,
              end: index
            };
        }
      }
  }

  // 4-character punctuator: >>>=

  ch4 = source.substr(index, 4);
  if (ch4 === '>>>=') {
    index += 4;
    return {
      type: TokenPunctuator,
      value: ch4,
      start: start,
      end: index
    };
  }

  // 3-character punctuators: === !== >>> <<= >>=

  ch3 = ch4.substr(0, 3);
  if (ch3 === '>>>' || ch3 === '<<=' || ch3 === '>>=') {
    index += 3;
    return {
      type: TokenPunctuator,
      value: ch3,
      start: start,
      end: index
    };
  }

  // Other 2-character punctuators: ++ -- << >> && ||
  ch2 = ch3.substr(0, 2);
  if (ch1 === ch2[1] && '+-<>&|'.includes(ch1) || ch2 === '=>') {
    index += 2;
    return {
      type: TokenPunctuator,
      value: ch2,
      start: start,
      end: index
    };
  }
  if (ch2 === '//') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }

  // 1-character punctuators: < > = ! + - * % & | ^ /

  if ('<>=!+-*%&|^/'.includes(ch1)) {
    ++index;
    return {
      type: TokenPunctuator,
      value: ch1,
      start: start,
      end: index
    };
  }
  throwError({}, MessageUnexpectedToken, ILLEGAL);
}

// 7.8.3 Numeric Literals

function scanHexLiteral(start) {
  let number = '';
  while (index < length) {
    if (!isHexDigit(source[index])) {
      break;
    }
    number += source[index++];
  }
  if (number.length === 0) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt('0x' + number, 16),
    start: start,
    end: index
  };
}
function scanOctalLiteral(start) {
  let number = '0' + source[index++];
  while (index < length) {
    if (!isOctalDigit(source[index])) {
      break;
    }
    number += source[index++];
  }
  if (isIdentifierStart(source.charCodeAt(index)) || isDecimalDigit(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseInt(number, 8),
    octal: true,
    start: start,
    end: index
  };
}
function scanNumericLiteral() {
  var number, start, ch;
  ch = source[index];
  assert(isDecimalDigit(ch.charCodeAt(0)) || ch === '.', 'Numeric literal must start with a decimal digit or a decimal point');
  start = index;
  number = '';
  if (ch !== '.') {
    number = source[index++];
    ch = source[index];

    // Hex number starts with '0x'.
    // Octal number starts with '0'.
    if (number === '0') {
      if (ch === 'x' || ch === 'X') {
        ++index;
        return scanHexLiteral(start);
      }
      if (isOctalDigit(ch)) {
        return scanOctalLiteral(start);
      }

      // decimal number starts with '0' such as '09' is illegal.
      if (ch && isDecimalDigit(ch.charCodeAt(0))) {
        throwError({}, MessageUnexpectedToken, ILLEGAL);
      }
    }
    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }
    ch = source[index];
  }
  if (ch === '.') {
    number += source[index++];
    while (isDecimalDigit(source.charCodeAt(index))) {
      number += source[index++];
    }
    ch = source[index];
  }
  if (ch === 'e' || ch === 'E') {
    number += source[index++];
    ch = source[index];
    if (ch === '+' || ch === '-') {
      number += source[index++];
    }
    if (isDecimalDigit(source.charCodeAt(index))) {
      while (isDecimalDigit(source.charCodeAt(index))) {
        number += source[index++];
      }
    } else {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    }
  }
  if (isIdentifierStart(source.charCodeAt(index))) {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenNumericLiteral,
    value: parseFloat(number),
    start: start,
    end: index
  };
}

// 7.8.4 String Literals

function scanStringLiteral() {
  var str = '',
    quote,
    start,
    ch,
    code,
    octal = false;
  quote = source[index];
  assert(quote === '\'' || quote === '"', 'String literal must starts with a quote');
  start = index;
  ++index;
  while (index < length) {
    ch = source[index++];
    if (ch === quote) {
      quote = '';
      break;
    } else if (ch === '\\') {
      ch = source[index++];
      if (!ch || !isLineTerminator(ch.charCodeAt(0))) {
        switch (ch) {
          case 'u':
          case 'x':
            if (source[index] === '{') {
              ++index;
              str += scanUnicodeCodePointEscape();
            } else {
              str += scanHexEscape(ch);
            }
            break;
          case 'n':
            str += '\n';
            break;
          case 'r':
            str += '\r';
            break;
          case 't':
            str += '\t';
            break;
          case 'b':
            str += '\b';
            break;
          case 'f':
            str += '\f';
            break;
          case 'v':
            str += '\x0B';
            break;
          default:
            if (isOctalDigit(ch)) {
              code = '01234567'.indexOf(ch);

              // \0 is not octal escape sequence
              if (code !== 0) {
                octal = true;
              }
              if (index < length && isOctalDigit(source[index])) {
                octal = true;
                code = code * 8 + '01234567'.indexOf(source[index++]);

                // 3 digits are only allowed when string starts
                // with 0, 1, 2, 3
                if ('0123'.includes(ch) && index < length && isOctalDigit(source[index])) {
                  code = code * 8 + '01234567'.indexOf(source[index++]);
                }
              }
              str += String.fromCharCode(code);
            } else {
              str += ch;
            }
            break;
        }
      } else {
        if (ch === '\r' && source[index] === '\n') {
          ++index;
        }
      }
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      break;
    } else {
      str += ch;
    }
  }
  if (quote !== '') {
    throwError({}, MessageUnexpectedToken, ILLEGAL);
  }
  return {
    type: TokenStringLiteral,
    value: str,
    octal: octal,
    start: start,
    end: index
  };
}
function testRegExp(pattern, flags) {
  let tmp = pattern;
  if (flags.includes('u')) {
    // Replace each astral symbol and every Unicode code point
    // escape sequence with a single ASCII symbol to avoid throwing on
    // regular expressions that are only valid in combination with the
    // `/u` flag.
    // Note: replacing with the ASCII symbol `x` might cause false
    // negatives in unlikely scenarios. For example, `[\u{61}-b]` is a
    // perfectly valid pattern that is equivalent to `[a-b]`, but it
    // would be replaced by `[x-b]` which throws an error.
    tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}/g, ($0, $1) => {
      if (parseInt($1, 16) <= 0x10FFFF) {
        return 'x';
      }
      throwError({}, MessageInvalidRegExp);
    }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, 'x');
  }

  // First, detect invalid regular expressions.
  try {
    new RegExp(tmp);
  } catch (e) {
    throwError({}, MessageInvalidRegExp);
  }

  // Return a regular expression object for this pattern-flag pair, or
  // `null` in case the current environment doesn't support the flags it
  // uses.
  try {
    return new RegExp(pattern, flags);
  } catch (exception) {
    return null;
  }
}
function scanRegExpBody() {
  var ch, str, classMarker, terminated, body;
  ch = source[index];
  assert(ch === '/', 'Regular expression literal must start with a slash');
  str = source[index++];
  classMarker = false;
  terminated = false;
  while (index < length) {
    ch = source[index++];
    str += ch;
    if (ch === '\\') {
      ch = source[index++];
      // ECMA-262 7.8.5
      if (isLineTerminator(ch.charCodeAt(0))) {
        throwError({}, MessageUnterminatedRegExp);
      }
      str += ch;
    } else if (isLineTerminator(ch.charCodeAt(0))) {
      throwError({}, MessageUnterminatedRegExp);
    } else if (classMarker) {
      if (ch === ']') {
        classMarker = false;
      }
    } else {
      if (ch === '/') {
        terminated = true;
        break;
      } else if (ch === '[') {
        classMarker = true;
      }
    }
  }
  if (!terminated) {
    throwError({}, MessageUnterminatedRegExp);
  }

  // Exclude leading and trailing slash.
  body = str.substr(1, str.length - 2);
  return {
    value: body,
    literal: str
  };
}
function scanRegExpFlags() {
  var ch, str, flags;
  str = '';
  flags = '';
  while (index < length) {
    ch = source[index];
    if (!isIdentifierPart(ch.charCodeAt(0))) {
      break;
    }
    ++index;
    if (ch === '\\' && index < length) {
      throwError({}, MessageUnexpectedToken, ILLEGAL);
    } else {
      flags += ch;
      str += ch;
    }
  }
  if (flags.search(/[^gimuy]/g) >= 0) {
    throwError({}, MessageInvalidRegExp, flags);
  }
  return {
    value: flags,
    literal: str
  };
}
function scanRegExp() {
  var start, body, flags, value;
  lookahead = null;
  skipComment();
  start = index;
  body = scanRegExpBody();
  flags = scanRegExpFlags();
  value = testRegExp(body.value, flags.value);
  return {
    literal: body.literal + flags.literal,
    value: value,
    regex: {
      pattern: body.value,
      flags: flags.value
    },
    start: start,
    end: index
  };
}
function isIdentifierName(token) {
  return token.type === TokenIdentifier || token.type === TokenKeyword || token.type === TokenBooleanLiteral || token.type === TokenNullLiteral;
}
function advance() {
  skipComment();
  if (index >= length) {
    return {
      type: TokenEOF,
      start: index,
      end: index
    };
  }
  const ch = source.charCodeAt(index);
  if (isIdentifierStart(ch)) {
    return scanIdentifier();
  }

  // Very common: ( and ) and ;
  if (ch === 0x28 || ch === 0x29 || ch === 0x3B) {
    return scanPunctuator();
  }

  // String literal starts with single quote (U+0027) or double quote (U+0022).
  if (ch === 0x27 || ch === 0x22) {
    return scanStringLiteral();
  }

  // Dot (.) U+002E can also start a floating-point number, hence the need
  // to check the next character.
  if (ch === 0x2E) {
    if (isDecimalDigit(source.charCodeAt(index + 1))) {
      return scanNumericLiteral();
    }
    return scanPunctuator();
  }
  if (isDecimalDigit(ch)) {
    return scanNumericLiteral();
  }
  return scanPunctuator();
}
function lex() {
  const token = lookahead;
  index = token.end;
  lookahead = advance();
  index = token.end;
  return token;
}
function peek() {
  const pos = index;
  lookahead = advance();
  index = pos;
}
function finishArrayExpression(elements) {
  const node = new ASTNode(SyntaxArrayExpression);
  node.elements = elements;
  return node;
}
function finishBinaryExpression(operator, left, right) {
  const node = new ASTNode(operator === '||' || operator === '&&' ? SyntaxLogicalExpression : SyntaxBinaryExpression);
  node.operator = operator;
  node.left = left;
  node.right = right;
  return node;
}
function finishCallExpression(callee, args) {
  const node = new ASTNode(SyntaxCallExpression);
  node.callee = callee;
  node.arguments = args;
  return node;
}
function finishConditionalExpression(test, consequent, alternate) {
  const node = new ASTNode(SyntaxConditionalExpression);
  node.test = test;
  node.consequent = consequent;
  node.alternate = alternate;
  return node;
}
function finishIdentifier(name) {
  const node = new ASTNode(SyntaxIdentifier);
  node.name = name;
  return node;
}
function finishLiteral(token) {
  const node = new ASTNode(SyntaxLiteral);
  node.value = token.value;
  node.raw = source.slice(token.start, token.end);
  if (token.regex) {
    if (node.raw === '//') {
      node.raw = '/(?:)/';
    }
    node.regex = token.regex;
  }
  return node;
}
function finishMemberExpression(accessor, object, property) {
  const node = new ASTNode(SyntaxMemberExpression);
  node.computed = accessor === '[';
  node.object = object;
  node.property = property;
  if (!node.computed) property.member = true;
  return node;
}
function finishObjectExpression(properties) {
  const node = new ASTNode(SyntaxObjectExpression);
  node.properties = properties;
  return node;
}
function finishProperty(kind, key, value) {
  const node = new ASTNode(SyntaxProperty);
  node.key = key;
  node.value = value;
  node.kind = kind;
  return node;
}
function finishUnaryExpression(operator, argument) {
  const node = new ASTNode(SyntaxUnaryExpression);
  node.operator = operator;
  node.argument = argument;
  node.prefix = true;
  return node;
}

// Throw an exception

function throwError(token, messageFormat) {
  var error,
    args = Array.prototype.slice.call(arguments, 2),
    msg = messageFormat.replace(/%(\d)/g, (whole, index) => {
      assert(index < args.length, 'Message reference must be in range');
      return args[index];
    });
  error = new Error(msg);
  error.index = index;
  error.description = msg;
  throw error;
}

// Throw an exception because of the token.

function throwUnexpected(token) {
  if (token.type === TokenEOF) {
    throwError(token, MessageUnexpectedEOS);
  }
  if (token.type === TokenNumericLiteral) {
    throwError(token, MessageUnexpectedNumber);
  }
  if (token.type === TokenStringLiteral) {
    throwError(token, MessageUnexpectedString);
  }
  if (token.type === TokenIdentifier) {
    throwError(token, MessageUnexpectedIdentifier);
  }
  if (token.type === TokenKeyword) {
    throwError(token, MessageUnexpectedReserved);
  }

  // BooleanLiteral, NullLiteral, or Punctuator.
  throwError(token, MessageUnexpectedToken, token.value);
}

// Expect the next token to match the specified punctuator.
// If not, an exception will be thrown.

function expect(value) {
  const token = lex();
  if (token.type !== TokenPunctuator || token.value !== value) {
    throwUnexpected(token);
  }
}

// Return true if the next token matches the specified punctuator.

function match(value) {
  return lookahead.type === TokenPunctuator && lookahead.value === value;
}

// Return true if the next token matches the specified keyword

function matchKeyword(keyword) {
  return lookahead.type === TokenKeyword && lookahead.value === keyword;
}

// 11.1.4 Array Initialiser

function parseArrayInitialiser() {
  const elements = [];
  index = lookahead.start;
  expect('[');
  while (!match(']')) {
    if (match(',')) {
      lex();
      elements.push(null);
    } else {
      elements.push(parseConditionalExpression());
      if (!match(']')) {
        expect(',');
      }
    }
  }
  lex();
  return finishArrayExpression(elements);
}

// 11.1.5 Object Initialiser

function parseObjectPropertyKey() {
  index = lookahead.start;
  const token = lex();

  // Note: This function is called only from parseObjectProperty(), where
  // EOF and Punctuator tokens are already filtered out.

  if (token.type === TokenStringLiteral || token.type === TokenNumericLiteral) {
    if (token.octal) {
      throwError(token, MessageStrictOctalLiteral);
    }
    return finishLiteral(token);
  }
  return finishIdentifier(token.value);
}
function parseObjectProperty() {
  var token, key, id, value;
  index = lookahead.start;
  token = lookahead;
  if (token.type === TokenIdentifier) {
    id = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', id, value);
  }
  if (token.type === TokenEOF || token.type === TokenPunctuator) {
    throwUnexpected(token);
  } else {
    key = parseObjectPropertyKey();
    expect(':');
    value = parseConditionalExpression();
    return finishProperty('init', key, value);
  }
}
function parseObjectInitialiser() {
  var properties = [],
    property,
    name,
    key,
    map = {},
    toString = String;
  index = lookahead.start;
  expect('{');
  while (!match('}')) {
    property = parseObjectProperty();
    if (property.key.type === SyntaxIdentifier) {
      name = property.key.name;
    } else {
      name = toString(property.key.value);
    }
    key = '$' + name;
    if (Object.prototype.hasOwnProperty.call(map, key)) {
      throwError({}, MessageStrictDuplicateProperty);
    } else {
      map[key] = true;
    }
    properties.push(property);
    if (!match('}')) {
      expect(',');
    }
  }
  expect('}');
  return finishObjectExpression(properties);
}

// 11.1.6 The Grouping Operator

function parseGroupExpression() {
  expect('(');
  const expr = parseExpression();
  expect(')');
  return expr;
}

// 11.1 Primary Expressions

const legalKeywords = {
  'if': 1
};
function parsePrimaryExpression() {
  var type, token, expr;
  if (match('(')) {
    return parseGroupExpression();
  }
  if (match('[')) {
    return parseArrayInitialiser();
  }
  if (match('{')) {
    return parseObjectInitialiser();
  }
  type = lookahead.type;
  index = lookahead.start;
  if (type === TokenIdentifier || legalKeywords[lookahead.value]) {
    expr = finishIdentifier(lex().value);
  } else if (type === TokenStringLiteral || type === TokenNumericLiteral) {
    if (lookahead.octal) {
      throwError(lookahead, MessageStrictOctalLiteral);
    }
    expr = finishLiteral(lex());
  } else if (type === TokenKeyword) {
    throw new Error(DISABLED);
  } else if (type === TokenBooleanLiteral) {
    token = lex();
    token.value = token.value === 'true';
    expr = finishLiteral(token);
  } else if (type === TokenNullLiteral) {
    token = lex();
    token.value = null;
    expr = finishLiteral(token);
  } else if (match('/') || match('/=')) {
    expr = finishLiteral(scanRegExp());
    peek();
  } else {
    throwUnexpected(lex());
  }
  return expr;
}

// 11.2 Left-Hand-Side Expressions

function parseArguments() {
  const args = [];
  expect('(');
  if (!match(')')) {
    while (index < length) {
      args.push(parseConditionalExpression());
      if (match(')')) {
        break;
      }
      expect(',');
    }
  }
  expect(')');
  return args;
}
function parseNonComputedProperty() {
  index = lookahead.start;
  const token = lex();
  if (!isIdentifierName(token)) {
    throwUnexpected(token);
  }
  return finishIdentifier(token.value);
}
function parseNonComputedMember() {
  expect('.');
  return parseNonComputedProperty();
}
function parseComputedMember() {
  expect('[');
  const expr = parseExpression();
  expect(']');
  return expr;
}
function parseLeftHandSideExpressionAllowCall() {
  var expr, args, property;
  expr = parsePrimaryExpression();
  for (;;) {
    if (match('.')) {
      property = parseNonComputedMember();
      expr = finishMemberExpression('.', expr, property);
    } else if (match('(')) {
      args = parseArguments();
      expr = finishCallExpression(expr, args);
    } else if (match('[')) {
      property = parseComputedMember();
      expr = finishMemberExpression('[', expr, property);
    } else {
      break;
    }
  }
  return expr;
}

// 11.3 Postfix Expressions

function parsePostfixExpression() {
  const expr = parseLeftHandSideExpressionAllowCall();
  if (lookahead.type === TokenPunctuator) {
    if (match('++') || match('--')) {
      throw new Error(DISABLED);
    }
  }
  return expr;
}

// 11.4 Unary Operators

function parseUnaryExpression() {
  var token, expr;
  if (lookahead.type !== TokenPunctuator && lookahead.type !== TokenKeyword) {
    expr = parsePostfixExpression();
  } else if (match('++') || match('--')) {
    throw new Error(DISABLED);
  } else if (match('+') || match('-') || match('~') || match('!')) {
    token = lex();
    expr = parseUnaryExpression();
    expr = finishUnaryExpression(token.value, expr);
  } else if (matchKeyword('delete') || matchKeyword('void') || matchKeyword('typeof')) {
    throw new Error(DISABLED);
  } else {
    expr = parsePostfixExpression();
  }
  return expr;
}
function binaryPrecedence(token) {
  let prec = 0;
  if (token.type !== TokenPunctuator && token.type !== TokenKeyword) {
    return 0;
  }
  switch (token.value) {
    case '||':
      prec = 1;
      break;
    case '&&':
      prec = 2;
      break;
    case '|':
      prec = 3;
      break;
    case '^':
      prec = 4;
      break;
    case '&':
      prec = 5;
      break;
    case '==':
    case '!=':
    case '===':
    case '!==':
      prec = 6;
      break;
    case '<':
    case '>':
    case '<=':
    case '>=':
    case 'instanceof':
    case 'in':
      prec = 7;
      break;
    case '<<':
    case '>>':
    case '>>>':
      prec = 8;
      break;
    case '+':
    case '-':
      prec = 9;
      break;
    case '*':
    case '/':
    case '%':
      prec = 11;
      break;
  }
  return prec;
}

// 11.5 Multiplicative Operators
// 11.6 Additive Operators
// 11.7 Bitwise Shift Operators
// 11.8 Relational Operators
// 11.9 Equality Operators
// 11.10 Binary Bitwise Operators
// 11.11 Binary Logical Operators

function parseBinaryExpression() {
  var marker, markers, expr, token, prec, stack, right, operator, left, i;
  marker = lookahead;
  left = parseUnaryExpression();
  token = lookahead;
  prec = binaryPrecedence(token);
  if (prec === 0) {
    return left;
  }
  token.prec = prec;
  lex();
  markers = [marker, lookahead];
  right = parseUnaryExpression();
  stack = [left, token, right];
  while ((prec = binaryPrecedence(lookahead)) > 0) {
    // Reduce: make a binary expression from the three topmost entries.
    while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
      right = stack.pop();
      operator = stack.pop().value;
      left = stack.pop();
      markers.pop();
      expr = finishBinaryExpression(operator, left, right);
      stack.push(expr);
    }

    // Shift.
    token = lex();
    token.prec = prec;
    stack.push(token);
    markers.push(lookahead);
    expr = parseUnaryExpression();
    stack.push(expr);
  }

  // Final reduce to clean-up the stack.
  i = stack.length - 1;
  expr = stack[i];
  markers.pop();
  while (i > 1) {
    markers.pop();
    expr = finishBinaryExpression(stack[i - 1].value, stack[i - 2], expr);
    i -= 2;
  }
  return expr;
}

// 11.12 Conditional Operator

function parseConditionalExpression() {
  var expr, consequent, alternate;
  expr = parseBinaryExpression();
  if (match('?')) {
    lex();
    consequent = parseConditionalExpression();
    expect(':');
    alternate = parseConditionalExpression();
    expr = finishConditionalExpression(expr, consequent, alternate);
  }
  return expr;
}

// 11.14 Comma Operator

function parseExpression() {
  const expr = parseConditionalExpression();
  if (match(',')) {
    throw new Error(DISABLED); // no sequence expressions
  }
  return expr;
}
function parser (code) {
  source = code;
  index = 0;
  length = source.length;
  lookahead = null;
  peek();
  const expr = parseExpression();
  if (lookahead.type !== TokenEOF) {
    throw new Error('Unexpect token after expression.');
  }
  return expr;
}

var Constants = {
  NaN: 'NaN',
  E: 'Math.E',
  LN2: 'Math.LN2',
  LN10: 'Math.LN10',
  LOG2E: 'Math.LOG2E',
  LOG10E: 'Math.LOG10E',
  PI: 'Math.PI',
  SQRT1_2: 'Math.SQRT1_2',
  SQRT2: 'Math.SQRT2',
  MIN_VALUE: 'Number.MIN_VALUE',
  MAX_VALUE: 'Number.MAX_VALUE'
};

function Functions (codegen) {
  function fncall(name, args, cast, type) {
    let obj = codegen(args[0]);
    if (cast) {
      obj = cast + '(' + obj + ')';
      if (cast.lastIndexOf('new ', 0) === 0) obj = '(' + obj + ')';
    }
    return obj + '.' + name + (type < 0 ? '' : type === 0 ? '()' : '(' + args.slice(1).map(codegen).join(',') + ')');
  }
  function fn(name, cast, type) {
    return args => fncall(name, args, cast, type);
  }
  const DATE = 'new Date',
    STRING = 'String',
    REGEXP = 'RegExp';
  return {
    // MATH functions
    isNaN: 'Number.isNaN',
    isFinite: 'Number.isFinite',
    abs: 'Math.abs',
    acos: 'Math.acos',
    asin: 'Math.asin',
    atan: 'Math.atan',
    atan2: 'Math.atan2',
    ceil: 'Math.ceil',
    cos: 'Math.cos',
    exp: 'Math.exp',
    floor: 'Math.floor',
    hypot: 'Math.hypot',
    log: 'Math.log',
    max: 'Math.max',
    min: 'Math.min',
    pow: 'Math.pow',
    random: 'Math.random',
    round: 'Math.round',
    sin: 'Math.sin',
    sqrt: 'Math.sqrt',
    tan: 'Math.tan',
    clamp: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to clamp function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to clamp function.');
      const a = args.map(codegen);
      return 'Math.max(' + a[1] + ', Math.min(' + a[2] + ',' + a[0] + '))';
    },
    // DATE functions
    now: 'Date.now',
    utc: 'Date.UTC',
    datetime: DATE,
    date: fn('getDate', DATE, 0),
    day: fn('getDay', DATE, 0),
    year: fn('getFullYear', DATE, 0),
    month: fn('getMonth', DATE, 0),
    hours: fn('getHours', DATE, 0),
    minutes: fn('getMinutes', DATE, 0),
    seconds: fn('getSeconds', DATE, 0),
    milliseconds: fn('getMilliseconds', DATE, 0),
    time: fn('getTime', DATE, 0),
    timezoneoffset: fn('getTimezoneOffset', DATE, 0),
    utcdate: fn('getUTCDate', DATE, 0),
    utcday: fn('getUTCDay', DATE, 0),
    utcyear: fn('getUTCFullYear', DATE, 0),
    utcmonth: fn('getUTCMonth', DATE, 0),
    utchours: fn('getUTCHours', DATE, 0),
    utcminutes: fn('getUTCMinutes', DATE, 0),
    utcseconds: fn('getUTCSeconds', DATE, 0),
    utcmilliseconds: fn('getUTCMilliseconds', DATE, 0),
    // sequence functions
    length: fn('length', null, -1),
    // STRING functions
    parseFloat: 'parseFloat',
    parseInt: 'parseInt',
    upper: fn('toUpperCase', STRING, 0),
    lower: fn('toLowerCase', STRING, 0),
    substring: fn('substring', STRING),
    split: fn('split', STRING),
    trim: fn('trim', STRING, 0),
    // base64 encode/decode
    btoa: 'btoa',
    atob: 'atob',
    // REGEXP functions
    regexp: REGEXP,
    test: fn('test', REGEXP),
    // Control Flow functions
    if: function (args) {
      if (args.length < 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing arguments to if function.');
      if (args.length > 3) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Too many arguments to if function.');
      const a = args.map(codegen);
      return '(' + a[0] + '?' + a[1] + ':' + a[2] + ')';
    }
  };
}

function stripQuotes(s) {
  const n = s && s.length - 1;
  return n && (s[0] === '"' && s[n] === '"' || s[0] === '\'' && s[n] === '\'') ? s.slice(1, -1) : s;
}
function codegen (opt) {
  opt = opt || {};
  const allowed = opt.allowed ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.allowed) : {},
    forbidden = opt.forbidden ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(opt.forbidden) : {},
    constants = opt.constants || Constants,
    functions = (opt.functions || Functions)(visit),
    globalvar = opt.globalvar,
    fieldvar = opt.fieldvar,
    outputGlobal = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(globalvar) ? globalvar : id => `${globalvar}["${id}"]`;
  let globals = {},
    fields = {},
    memberDepth = 0;
  function visit(ast) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(ast)) return ast;
    const generator = Generators[ast.type];
    if (generator == null) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported type: ' + ast.type);
    return generator(ast);
  }
  const Generators = {
    Literal: n => n.raw,
    Identifier: n => {
      const id = n.name;
      if (memberDepth > 0) {
        return id;
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(forbidden, id)) {
        return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal identifier: ' + id);
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(constants, id)) {
        return constants[id];
      } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(allowed, id)) {
        return id;
      } else {
        globals[id] = 1;
        return outputGlobal(id);
      }
    },
    MemberExpression: n => {
      const d = !n.computed,
        o = visit(n.object);
      if (d) memberDepth += 1;
      const p = visit(n.property);
      if (o === fieldvar) {
        // strip quotes to sanitize field name (#1653)
        fields[stripQuotes(p)] = 1;
      }
      if (d) memberDepth -= 1;
      return o + (d ? '.' + p : '[' + p + ']');
    },
    CallExpression: n => {
      if (n.callee.type !== 'Identifier') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Illegal callee type: ' + n.callee.type);
      }
      const callee = n.callee.name,
        args = n.arguments,
        fn = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(functions, callee) && functions[callee];
      if (!fn) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized function: ' + callee);
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(fn) ? fn(args) : fn + '(' + args.map(visit).join(',') + ')';
    },
    ArrayExpression: n => '[' + n.elements.map(visit).join(',') + ']',
    BinaryExpression: n => '(' + visit(n.left) + ' ' + n.operator + ' ' + visit(n.right) + ')',
    UnaryExpression: n => '(' + n.operator + visit(n.argument) + ')',
    ConditionalExpression: n => '(' + visit(n.test) + '?' + visit(n.consequent) + ':' + visit(n.alternate) + ')',
    LogicalExpression: n => '(' + visit(n.left) + n.operator + visit(n.right) + ')',
    ObjectExpression: n => '{' + n.properties.map(visit).join(',') + '}',
    Property: n => {
      memberDepth += 1;
      const k = visit(n.key);
      memberDepth -= 1;
      return k + ':' + visit(n.value);
    }
  };
  function codegen(ast) {
    const result = {
      code: visit(ast),
      globals: Object.keys(globals),
      fields: Object.keys(fields)
    };
    globals = {};
    fields = {};
    return result;
  }
  codegen.functions = functions;
  codegen.constants = constants;
  return codegen;
}




/***/ }),

/***/ "./node_modules/vega-force/build/vega-force.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-force/build/vega-force.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   force: () => (/* binding */ Force)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/center.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/collide.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/manyBody.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/link.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/x.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/y.js");
/* harmony import */ var d3_force__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-force */ "./node_modules/d3-force/src/simulation.js");




const ForceMap = {
  center: d3_force__WEBPACK_IMPORTED_MODULE_2__["default"],
  collide: d3_force__WEBPACK_IMPORTED_MODULE_3__["default"],
  nbody: d3_force__WEBPACK_IMPORTED_MODULE_4__["default"],
  link: d3_force__WEBPACK_IMPORTED_MODULE_5__["default"],
  x: d3_force__WEBPACK_IMPORTED_MODULE_6__["default"],
  y: d3_force__WEBPACK_IMPORTED_MODULE_7__["default"]
};
const Forces = 'forces',
  ForceParams = ['alpha', 'alphaMin', 'alphaTarget', 'velocityDecay', 'forces'],
  ForceConfig = ['static', 'iterations'],
  ForceOutput = ['x', 'y', 'vx', 'vy'];

/**
 * Force simulation layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<object>} params.forces - The forces to apply.
 */
function Force(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Force.Definition = {
  'type': 'Force',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'static',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'restart',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'iterations',
    'type': 'number',
    'default': 300
  }, {
    'name': 'alpha',
    'type': 'number',
    'default': 1
  }, {
    'name': 'alphaMin',
    'type': 'number',
    'default': 0.001
  }, {
    'name': 'alphaTarget',
    'type': 'number',
    'default': 0
  }, {
    'name': 'velocityDecay',
    'type': 'number',
    'default': 0.4
  }, {
    'name': 'forces',
    'type': 'param',
    'array': true,
    'params': [{
      'key': {
        'force': 'center'
      },
      'params': [{
        'name': 'x',
        'type': 'number',
        'default': 0
      }, {
        'name': 'y',
        'type': 'number',
        'default': 0
      }]
    }, {
      'key': {
        'force': 'collide'
      },
      'params': [{
        'name': 'radius',
        'type': 'number',
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'default': 0.7
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'nbody'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': -30,
        'expr': true
      }, {
        'name': 'theta',
        'type': 'number',
        'default': 0.9
      }, {
        'name': 'distanceMin',
        'type': 'number',
        'default': 1
      }, {
        'name': 'distanceMax',
        'type': 'number'
      }]
    }, {
      'key': {
        'force': 'link'
      },
      'params': [{
        'name': 'links',
        'type': 'data'
      }, {
        'name': 'id',
        'type': 'field'
      }, {
        'name': 'distance',
        'type': 'number',
        'default': 30,
        'expr': true
      }, {
        'name': 'strength',
        'type': 'number',
        'expr': true
      }, {
        'name': 'iterations',
        'type': 'number',
        'default': 1
      }]
    }, {
      'key': {
        'force': 'x'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'x',
        'type': 'field'
      }]
    }, {
      'key': {
        'force': 'y'
      },
      'params': [{
        'name': 'strength',
        'type': 'number',
        'default': 0.1
      }, {
        'name': 'y',
        'type': 'field'
      }]
    }]
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'modify': false,
    'default': ForceOutput
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Force, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var sim = this.value,
      change = pulse.changed(pulse.ADD_REM),
      params = _.modified(ForceParams),
      iters = _.iterations || 300;

    // configure simulation
    if (!sim) {
      this.value = sim = simulation(pulse.source, _);
      sim.on('tick', rerun(pulse.dataflow, this));
      if (!_.static) {
        change = true;
        sim.tick(); // ensure we run on init
      }
      pulse.modifies('index');
    } else {
      if (change) {
        pulse.modifies('index');
        sim.nodes(pulse.source);
      }
      if (params || pulse.changed(pulse.MOD)) {
        setup(sim, _, 0, pulse);
      }
    }

    // run simulation
    if (params || change || _.modified(ForceConfig) || pulse.changed() && _.restart) {
      sim.alpha(Math.max(sim.alpha(), _.alpha || 1)).alphaDecay(1 - Math.pow(sim.alphaMin(), 1 / iters));
      if (_.static) {
        for (sim.stop(); --iters >= 0;) sim.tick();
      } else {
        if (sim.stopped()) sim.restart();
        if (!change) return pulse.StopPropagation; // defer to sim ticks
      }
    }
    return this.finish(_, pulse);
  },
  finish(_, pulse) {
    const dataflow = pulse.dataflow;

    // inspect dependencies, touch link source data
    for (let args = this._argops, j = 0, m = args.length, arg; j < m; ++j) {
      arg = args[j];
      if (arg.name !== Forces || arg.op._argval.force !== 'link') {
        continue;
      }
      for (var ops = arg.op._argops, i = 0, n = ops.length, op; i < n; ++i) {
        if (ops[i].name === 'links' && (op = ops[i].op.source)) {
          dataflow.pulse(op, dataflow.changeset().reflow());
          break;
        }
      }
    }

    // reflow all nodes
    return pulse.reflow(_.modified()).modifies(ForceOutput);
  }
});
function rerun(df, op) {
  return () => df.touch(op).run();
}
function simulation(nodes, _) {
  const sim = (0,d3_force__WEBPACK_IMPORTED_MODULE_8__["default"])(nodes),
    stop = sim.stop,
    restart = sim.restart;
  let stopped = false;
  sim.stopped = () => stopped;
  sim.restart = () => (stopped = false, restart());
  sim.stop = () => (stopped = true, stop());
  return setup(sim, _, true).on('end', () => stopped = true);
}
function setup(sim, _, init, pulse) {
  var f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.forces),
    i,
    n,
    p,
    name;
  for (i = 0, n = ForceParams.length; i < n; ++i) {
    p = ForceParams[i];
    if (p !== Forces && _.modified(p)) sim[p](_[p]);
  }
  for (i = 0, n = f.length; i < n; ++i) {
    name = Forces + i;
    p = init || _.modified(Forces, i) ? getForce(f[i]) : pulse && modified(f[i], pulse) ? sim.force(name) : null;
    if (p) sim.force(name, p);
  }
  for (n = sim.numForces || 0; i < n; ++i) {
    sim.force(Forces + i, null); // remove
  }
  sim.numForces = f.length;
  return sim;
}
function modified(f, pulse) {
  var k, v;
  for (k in f) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v = f[k]) && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(v))) return 1;
  }
  return 0;
}
function getForce(_) {
  var f, p;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(ForceMap, _.force)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized force: ' + _.force);
  }
  f = ForceMap[_.force]();
  for (p in _) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f[p])) setForceParam(f[p], _[p], _);
  }
  return f;
}
function setForceParam(f, v, _) {
  f((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(v) ? d => v(d, _) : v);
}




/***/ }),

/***/ "./node_modules/vega-format/build/vega-format.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-format/build/vega-format.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultLocale: () => (/* binding */ defaultLocale),
/* harmony export */   locale: () => (/* binding */ locale),
/* harmony export */   numberFormatDefaultLocale: () => (/* binding */ numberFormatDefaultLocale),
/* harmony export */   numberFormatLocale: () => (/* binding */ numberFormatLocale),
/* harmony export */   resetDefaultLocale: () => (/* binding */ resetDefaultLocale),
/* harmony export */   resetNumberFormatDefaultLocale: () => (/* binding */ resetNumberFormatDefaultLocale),
/* harmony export */   resetTimeFormatDefaultLocale: () => (/* binding */ resetTimeFormatDefaultLocale),
/* harmony export */   timeFormatDefaultLocale: () => (/* binding */ timeFormatDefaultLocale),
/* harmony export */   timeFormatLocale: () => (/* binding */ timeFormatLocale)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/formatSpecifier.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionPrefix.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionRound.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/precisionFixed.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/defaultLocale.js");
/* harmony import */ var d3_format__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-format */ "./node_modules/d3-format/src/locale.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/defaultLocale.js");
/* harmony import */ var d3_time_format__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-time-format */ "./node_modules/d3-time-format/src/locale.js");






function memoize (method) {
  const cache = {};
  return spec => cache[spec] || (cache[spec] = method(spec));
}

function trimZeroes(numberFormat, decimalChar) {
  return x => {
    const str = numberFormat(x),
      dec = str.indexOf(decimalChar);
    if (dec < 0) return str;
    let idx = rightmostDigit(str, dec);
    const end = idx < str.length ? str.slice(idx) : '';
    while (--idx > dec) if (str[idx] !== '0') {
      ++idx;
      break;
    }
    return str.slice(0, idx) + end;
  };
}
function rightmostDigit(str, dec) {
  let i = str.lastIndexOf('e'),
    c;
  if (i > 0) return i;
  for (i = str.length; --i > dec;) {
    c = str.charCodeAt(i);
    if (c >= 48 && c <= 57) return i + 1; // is digit
  }
}
function numberLocale(locale) {
  const format = memoize(locale.format),
    formatPrefix = locale.formatPrefix;
  return {
    format,
    formatPrefix,
    formatFloat(spec) {
      const s = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__["default"])(spec || ',');
      if (s.precision == null) {
        s.precision = 12;
        switch (s.type) {
          case '%':
            s.precision -= 2;
            break;
          case 'e':
            s.precision -= 1;
            break;
        }
        return trimZeroes(format(s),
        // number format
        format('.1f')(1)[1] // decimal point character
        );
      } else {
        return format(s);
      }
    },
    formatSpan(start, stop, count, specifier) {
      specifier = (0,d3_format__WEBPACK_IMPORTED_MODULE_2__["default"])(specifier == null ? ',f' : specifier);
      const step = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__.tickStep)(start, stop, count),
        value = Math.max(Math.abs(start), Math.abs(stop));
      let precision;
      if (specifier.precision == null) {
        switch (specifier.type) {
          case 's':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_4__["default"])(step, value))) {
                specifier.precision = precision;
              }
              return formatPrefix(specifier, value);
            }
          case '':
          case 'e':
          case 'g':
          case 'p':
          case 'r':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_5__["default"])(step, value))) {
                specifier.precision = precision - (specifier.type === 'e');
              }
              break;
            }
          case 'f':
          case '%':
            {
              if (!isNaN(precision = (0,d3_format__WEBPACK_IMPORTED_MODULE_6__["default"])(step))) {
                specifier.precision = precision - (specifier.type === '%') * 2;
              }
              break;
            }
        }
      }
      return format(specifier);
    }
  };
}
let defaultNumberLocale;
resetNumberFormatDefaultLocale();
function resetNumberFormatDefaultLocale() {
  return defaultNumberLocale = numberLocale({
    format: d3_format__WEBPACK_IMPORTED_MODULE_7__.format,
    formatPrefix: d3_format__WEBPACK_IMPORTED_MODULE_7__.formatPrefix
  });
}
function numberFormatLocale(definition) {
  return numberLocale((0,d3_format__WEBPACK_IMPORTED_MODULE_8__["default"])(definition));
}
function numberFormatDefaultLocale(definition) {
  return arguments.length ? defaultNumberLocale = numberFormatLocale(definition) : defaultNumberLocale;
}

function timeMultiFormat(format, interval, spec) {
  spec = spec || {};
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(`Invalid time multi-format specifier: ${spec}`);
  }
  const second = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS),
    minute = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES),
    hour = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS),
    day = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE),
    week = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK),
    month = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH),
    quarter = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER),
    year = interval(vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR),
    L = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MILLISECONDS] || '.%L'),
    S = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.SECONDS] || ':%S'),
    M = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MINUTES] || '%I:%M'),
    H = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.HOURS] || '%I %p'),
    d = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DATE] || spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.DAY] || '%a %d'),
    w = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.WEEK] || '%b %d'),
    m = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.MONTH] || '%B'),
    q = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.QUARTER] || '%B'),
    y = format(spec[vega_time__WEBPACK_IMPORTED_MODULE_0__.YEAR] || '%Y');
  return date => (second(date) < date ? L : minute(date) < date ? S : hour(date) < date ? M : day(date) < date ? H : month(date) < date ? week(date) < date ? d : w : year(date) < date ? quarter(date) < date ? m : q : y)(date);
}
function timeLocale(locale) {
  const timeFormat = memoize(locale.format),
    utcFormat = memoize(locale.utcFormat);
  return {
    timeFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? timeFormat(spec) : timeMultiFormat(timeFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.timeInterval, spec),
    utcFormat: spec => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isString)(spec) ? utcFormat(spec) : timeMultiFormat(utcFormat, vega_time__WEBPACK_IMPORTED_MODULE_0__.utcInterval, spec),
    timeParse: memoize(locale.parse),
    utcParse: memoize(locale.utcParse)
  };
}
let defaultTimeLocale;
resetTimeFormatDefaultLocale();
function resetTimeFormatDefaultLocale() {
  return defaultTimeLocale = timeLocale({
    format: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeFormat,
    parse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.timeParse,
    utcFormat: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcFormat,
    utcParse: d3_time_format__WEBPACK_IMPORTED_MODULE_9__.utcParse
  });
}
function timeFormatLocale(definition) {
  return timeLocale((0,d3_time_format__WEBPACK_IMPORTED_MODULE_10__["default"])(definition));
}
function timeFormatDefaultLocale(definition) {
  return arguments.length ? defaultTimeLocale = timeFormatLocale(definition) : defaultTimeLocale;
}

const createLocale = (number, time) => (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, number, time);
function locale(numberSpec, timeSpec) {
  const number = numberSpec ? numberFormatLocale(numberSpec) : numberFormatDefaultLocale();
  const time = timeSpec ? timeFormatLocale(timeSpec) : timeFormatDefaultLocale();
  return createLocale(number, time);
}
function defaultLocale(numberSpec, timeSpec) {
  const args = arguments.length;
  if (args && args !== 2) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('defaultLocale expects either zero or two arguments.');
  }
  return args ? createLocale(numberFormatDefaultLocale(numberSpec), timeFormatDefaultLocale(timeSpec)) : createLocale(numberFormatDefaultLocale(), timeFormatDefaultLocale());
}
function resetDefaultLocale() {
  resetNumberFormatDefaultLocale();
  resetTimeFormatDefaultLocale();
  return defaultLocale();
}




/***/ }),

/***/ "./node_modules/vega-functions/build/vega-functions.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/vega-functions/build/vega-functions.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DataPrefix: () => (/* binding */ DataPrefix),
/* harmony export */   IndexPrefix: () => (/* binding */ IndexPrefix),
/* harmony export */   ScalePrefix: () => (/* binding */ ScalePrefix),
/* harmony export */   SignalPrefix: () => (/* binding */ SignalPrefix),
/* harmony export */   bandspace: () => (/* binding */ bandspace),
/* harmony export */   bandwidth: () => (/* binding */ bandwidth),
/* harmony export */   codeGenerator: () => (/* binding */ codeGenerator),
/* harmony export */   codegenParams: () => (/* binding */ codegenParams),
/* harmony export */   containerSize: () => (/* binding */ containerSize),
/* harmony export */   contrast: () => (/* binding */ contrast),
/* harmony export */   copy: () => (/* binding */ copy),
/* harmony export */   data: () => (/* binding */ data),
/* harmony export */   dataVisitor: () => (/* binding */ dataVisitor),
/* harmony export */   dayAbbrevFormat: () => (/* binding */ dayAbbrevFormat),
/* harmony export */   dayFormat: () => (/* binding */ dayFormat),
/* harmony export */   debug: () => (/* binding */ debug),
/* harmony export */   domain: () => (/* binding */ domain),
/* harmony export */   encode: () => (/* binding */ encode),
/* harmony export */   expressionFunction: () => (/* binding */ expressionFunction),
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   functionContext: () => (/* binding */ functionContext),
/* harmony export */   geoArea: () => (/* binding */ geoArea),
/* harmony export */   geoBounds: () => (/* binding */ geoBounds),
/* harmony export */   geoCentroid: () => (/* binding */ geoCentroid),
/* harmony export */   geoScale: () => (/* binding */ geoScale),
/* harmony export */   geoShape: () => (/* binding */ geoShape),
/* harmony export */   inScope: () => (/* binding */ inScope),
/* harmony export */   indata: () => (/* binding */ indata),
/* harmony export */   indataVisitor: () => (/* binding */ indataVisitor),
/* harmony export */   indexof: () => (/* binding */ indexof),
/* harmony export */   info: () => (/* binding */ info),
/* harmony export */   invert: () => (/* binding */ invert),
/* harmony export */   join: () => (/* binding */ join),
/* harmony export */   lastindexof: () => (/* binding */ lastindexof),
/* harmony export */   luminance: () => (/* binding */ luminance),
/* harmony export */   merge: () => (/* binding */ merge),
/* harmony export */   modify: () => (/* binding */ modify),
/* harmony export */   monthAbbrevFormat: () => (/* binding */ monthAbbrevFormat),
/* harmony export */   monthFormat: () => (/* binding */ monthFormat),
/* harmony export */   parseExpression: () => (/* binding */ parser),
/* harmony export */   pathShape: () => (/* binding */ pathShape),
/* harmony export */   pinchAngle: () => (/* binding */ pinchAngle),
/* harmony export */   pinchDistance: () => (/* binding */ pinchDistance),
/* harmony export */   pluck: () => (/* binding */ pluck),
/* harmony export */   range: () => (/* binding */ range),
/* harmony export */   replace: () => (/* binding */ replace),
/* harmony export */   reverse: () => (/* binding */ reverse),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleGradient: () => (/* binding */ scaleGradient),
/* harmony export */   scaleVisitor: () => (/* binding */ scaleVisitor),
/* harmony export */   screen: () => (/* binding */ screen),
/* harmony export */   setdata: () => (/* binding */ setdata),
/* harmony export */   slice: () => (/* binding */ slice),
/* harmony export */   sort: () => (/* binding */ sort),
/* harmony export */   timeFormat: () => (/* binding */ timeFormat),
/* harmony export */   timeParse: () => (/* binding */ timeParse),
/* harmony export */   treeAncestors: () => (/* binding */ treeAncestors),
/* harmony export */   treePath: () => (/* binding */ treePath),
/* harmony export */   utcFormat: () => (/* binding */ utcFormat),
/* harmony export */   utcParse: () => (/* binding */ utcParse),
/* harmony export */   warn: () => (/* binding */ warn),
/* harmony export */   windowSize: () => (/* binding */ windowSize)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "./node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/area.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/bounds.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/centroid.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/lab.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_selections__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-selections */ "./node_modules/vega-selections/build/vega-selection.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");












function data(name) {
  const data = this.context.data[name];
  return data ? data.values.value : [];
}
function indata(name, field, value) {
  const index = this.context.data[name]['index:' + field],
    entry = index ? index.value.get(value) : undefined;
  return entry ? entry.count : entry;
}
function setdata(name, tuples) {
  const df = this.context.dataflow,
    data = this.context.data[name],
    input = data.input;
  df.pulse(input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(tuples));
  return 1;
}

function encode (item, name, retval) {
  if (item) {
    const df = this.context.dataflow,
      target = item.mark.source;
    df.pulse(target, df.changeset().encode(item, name));
  }
  return retval !== undefined ? retval : item;
}

const wrap = method => function (value, spec) {
  const locale = this.context.dataflow.locale();
  return value === null ? 'null' : locale[method](spec)(value);
};
const format = wrap('format');
const timeFormat = wrap('timeFormat');
const utcFormat = wrap('utcFormat');
const timeParse = wrap('timeParse');
const utcParse = wrap('utcParse');
const dateObj = new Date(2000, 0, 1);
function time(month, day, specifier) {
  if (!Number.isInteger(month) || !Number.isInteger(day)) return '';
  dateObj.setYear(2000);
  dateObj.setMonth(month);
  dateObj.setDate(day);
  return timeFormat.call(this, dateObj, specifier);
}
function monthFormat(month) {
  return time.call(this, month, 1, '%B');
}
function monthAbbrevFormat(month) {
  return time.call(this, month, 1, '%b');
}
function dayFormat(day) {
  return time.call(this, 0, 2 + day, '%A');
}
function dayAbbrevFormat(day) {
  return time.call(this, 0, 2 + day, '%a');
}

const DataPrefix = ':';
const IndexPrefix = '@';
const ScalePrefix = '%';
const SignalPrefix = '$';

function dataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to data functions must be a string literal.');
  }
  const data = args[0].value,
    dataName = DataPrefix + data;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(dataName, params)) {
    try {
      params[dataName] = scope.getData(data).tuplesRef();
    } catch (err) {
      // if data set does not exist, there's nothing to track
    }
  }
}
function indataVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to indata must be a string literal.');
  if (args[1].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to indata must be a string literal.');
  const data = args[0].value,
    field = args[1].value,
    indexName = IndexPrefix + field;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(indexName, params)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  }
}
function scaleVisitor(name, args, scope, params) {
  if (args[0].type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) {
    // add scale dependency
    addScaleDependency(scope, params, args[0].value);
  } else {
    // indirect scale lookup; add all scales as parameters
    for (name in scope.scales) {
      addScaleDependency(scope, params, name);
    }
  }
}
function addScaleDependency(scope, params, name) {
  const scaleName = ScalePrefix + name;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, scaleName)) {
    try {
      params[scaleName] = scope.scaleRef(name);
    } catch (err) {
      // TODO: error handling? warning?
    }
  }
}

/**
 * nameOrFunction must be a string or function that was registered.
 * Return undefined if scale is not recognized.
 */
function getScale(nameOrFunction, ctx) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(nameOrFunction)) {
    const maybeScale = ctx.scales[nameOrFunction];
    return maybeScale && (0,vega_scale__WEBPACK_IMPORTED_MODULE_2__.isRegisteredScale)(maybeScale.value) ? maybeScale.value : undefined;
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(nameOrFunction)) {
    return (0,vega_scale__WEBPACK_IMPORTED_MODULE_2__.isRegisteredScale)(nameOrFunction) ? nameOrFunction : undefined;
  }
  return undefined;
}
function internalScaleFunctions(codegen, fnctx, visitors) {
  // add helper method to the 'this' expression function context
  fnctx.__bandwidth = s => s && s.bandwidth ? s.bandwidth() : 0;

  // register AST visitors for internal scale functions
  visitors._bandwidth = scaleVisitor;
  visitors._range = scaleVisitor;
  visitors._scale = scaleVisitor;

  // resolve scale reference directly to the signal hash argument
  const ref = arg => '_[' + (arg.type === vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix + arg.value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ScalePrefix) + '+' + codegen(arg)) + ']';

  // define and return internal scale function code generators
  // these internal functions are called by mark encoders
  return {
    _bandwidth: args => `this.__bandwidth(${ref(args[0])})`,
    _range: args => `${ref(args[0])}.range()`,
    _scale: args => `${ref(args[0])}(${codegen(args[1])})`
  };
}

function geoMethod(methodName, globalMethod) {
  return function (projection, geojson, group) {
    if (projection) {
      // projection defined, use it
      const p = getScale(projection, (group || this).context);
      return p && p.path[methodName](geojson);
    } else {
      // projection undefined, use global method
      return globalMethod(geojson);
    }
  };
}
const geoArea = geoMethod('area', d3_geo__WEBPACK_IMPORTED_MODULE_8__["default"]);
const geoBounds = geoMethod('bounds', d3_geo__WEBPACK_IMPORTED_MODULE_9__["default"]);
const geoCentroid = geoMethod('centroid', d3_geo__WEBPACK_IMPORTED_MODULE_10__["default"]);
function geoScale(projection, group) {
  const p = getScale(projection, (group || this).context);
  return p && p.scale();
}

function inScope (item) {
  const group = this.context.group;
  let value = false;
  if (group) while (item) {
    if (item === group) {
      value = true;
      break;
    }
    item = item.mark.group;
  }
  return value;
}

function log(df, method, args) {
  try {
    df[method].apply(df, ['EXPRESSION'].concat([].slice.call(args)));
  } catch (err) {
    df.warn(err);
  }
  return args[args.length - 1];
}
function warn() {
  return log(this.context.dataflow, 'warn', arguments);
}
function info() {
  return log(this.context.dataflow, 'info', arguments);
}
function debug() {
  return log(this.context.dataflow, 'debug', arguments);
}

// https://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
function channel_luminance_value(channelValue) {
  const val = channelValue / 255;
  if (val <= 0.03928) {
    return val / 12.92;
  }
  return Math.pow((val + 0.055) / 1.055, 2.4);
}
function luminance(color) {
  const c = (0,d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb)(color),
    r = channel_luminance_value(c.r),
    g = channel_luminance_value(c.g),
    b = channel_luminance_value(c.b);
  return 0.2126 * r + 0.7152 * g + 0.0722 * b;
}

// https://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef
function contrast(color1, color2) {
  const lum1 = luminance(color1),
    lum2 = luminance(color2),
    lumL = Math.max(lum1, lum2),
    lumD = Math.min(lum1, lum2);
  return (lumL + 0.05) / (lumD + 0.05);
}

function merge () {
  const args = [].slice.call(arguments);
  args.unshift({});
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(...args);
}

function equal(a, b) {
  return a === b || a !== a && b !== b ? true : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(a) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(b) && a.length === b.length ? equalArray(a, b) : false : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? equalObject(a, b) : false;
}
function equalArray(a, b) {
  for (let i = 0, n = a.length; i < n; ++i) {
    if (!equal(a[i], b[i])) return false;
  }
  return true;
}
function equalObject(a, b) {
  for (const key in a) {
    if (!equal(a[key], b[key])) return false;
  }
  return true;
}
function removePredicate(props) {
  return _ => equalObject(props, _);
}
function modify (name, insert, remove, toggle, modify, values) {
  const df = this.context.dataflow,
    data = this.context.data[name],
    input = data.input,
    stamp = df.stamp();
  let changes = data.changes,
    predicate,
    key;
  if (df._trigger === false || !(input.value.length || insert || toggle)) {
    // nothing to do!
    return 0;
  }
  if (!changes || changes.stamp < stamp) {
    data.changes = changes = df.changeset();
    changes.stamp = stamp;
    df.runAfter(() => {
      data.modified = true;
      df.pulse(input, changes).run();
    }, true, 1);
  }
  if (remove) {
    predicate = remove === true ? vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(remove) || (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_3__.isTuple)(remove) ? remove : removePredicate(remove);
    changes.remove(predicate);
  }
  if (insert) {
    changes.insert(insert);
  }
  if (toggle) {
    predicate = removePredicate(toggle);
    if (input.value.some(predicate)) {
      changes.remove(predicate);
    } else {
      changes.insert(toggle);
    }
  }
  if (modify) {
    for (key in values) {
      changes.modify(modify, key, values[key]);
    }
  }
  return 1;
}

function pinchDistance(event) {
  const t = event.touches,
    dx = t[0].clientX - t[1].clientX,
    dy = t[0].clientY - t[1].clientY;
  return Math.hypot(dx, dy);
}
function pinchAngle(event) {
  const t = event.touches;
  return Math.atan2(t[0].clientY - t[1].clientY, t[0].clientX - t[1].clientX);
}

// memoize accessor functions
const accessors = {};
function pluck (data, name) {
  const accessor = accessors[name] || (accessors[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(name));
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) ? data.map(accessor) : accessor(data);
}

function array(seq) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(seq) || ArrayBuffer.isView(seq) ? seq : null;
}
function sequence(seq) {
  return array(seq) || ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(seq) ? seq : null);
}
function join(seq) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }
  return array(seq).join(...args);
}
function indexof(seq) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
    args[_key2 - 1] = arguments[_key2];
  }
  return sequence(seq).indexOf(...args);
}
function lastindexof(seq) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
    args[_key3 - 1] = arguments[_key3];
  }
  return sequence(seq).lastIndexOf(...args);
}
function slice(seq) {
  for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
    args[_key4 - 1] = arguments[_key4];
  }
  return sequence(seq).slice(...args);
}
function replace(str, pattern, repl) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(repl)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Function argument passed to replace.');
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(pattern) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp)(pattern)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Please pass a string or RegExp argument to replace.');
  return String(str).replace(pattern, repl);
}
function reverse(seq) {
  return array(seq).slice().reverse();
}
function sort(seq) {
  return array(seq).slice().sort(vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending);
}

function bandspace(count, paddingInner, paddingOuter) {
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_2__.bandSpace)(count || 0, paddingInner || 0, paddingOuter || 0);
}
function bandwidth(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.bandwidth ? s.bandwidth() : 0;
}
function copy(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.copy() : undefined;
}
function domain(name, group) {
  const s = getScale(name, (group || this).context);
  return s ? s.domain() : [];
}
function invert(name, range, group) {
  const s = getScale(name, (group || this).context);
  return !s ? undefined : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range) ? (s.invertRange || s.invert)(range) : (s.invert || s.invertExtent)(range);
}
function range(name, group) {
  const s = getScale(name, (group || this).context);
  return s && s.range ? s.range() : [];
}
function scale(name, value, group) {
  const s = getScale(name, (group || this).context);
  return s ? s(value) : undefined;
}

function scaleGradient (scale, p0, p1, count, group) {
  scale = getScale(scale, (group || this).context);
  const gradient = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Gradient)(p0, p1);
  let stops = scale.domain(),
    min = stops[0],
    max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops),
    fraction = vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;
  if (!(max - min)) {
    // expand scale if domain has zero span, fix #1479
    scale = (scale.interpolator ? (0,vega_scale__WEBPACK_IMPORTED_MODULE_2__.scale)('sequential')().interpolator(scale.interpolator()) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_2__.scale)('linear')().interpolate(scale.interpolate()).range(scale.range())).domain([min = 0, max = 1]);
  } else {
    fraction = (0,vega_scale__WEBPACK_IMPORTED_MODULE_2__.scaleFraction)(scale, min, max);
  }
  if (scale.ticks) {
    stops = scale.ticks(+count || 15);
    if (min !== stops[0]) stops.unshift(min);
    if (max !== (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(stops)) stops.push(max);
  }
  stops.forEach(_ => gradient.stop(fraction(_), scale(_)));
  return gradient;
}

function geoShape(projection, geojson, group) {
  const p = getScale(projection, (group || this).context);
  return function (context) {
    return p ? p.path.context(context)(geojson) : '';
  };
}
function pathShape(path) {
  let p = null;
  return function (context) {
    return context ? (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathRender)(context, p = p || (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.pathParse)(path)) : path;
  };
}

const datum = d => d.data;
function treeNodes(name, context) {
  const tree = data.call(context, name);
  return tree.root && tree.root.lookup || {};
}
function treePath(name, source, target) {
  const nodes = treeNodes(name, this),
    s = nodes[source],
    t = nodes[target];
  return s && t ? s.path(t).map(datum) : undefined;
}
function treeAncestors(name, node) {
  const n = treeNodes(name, this)[node];
  return n ? n.ancestors().map(datum) : undefined;
}

const _window = () => typeof window !== 'undefined' && window || null;
function screen() {
  const w = _window();
  return w ? w.screen : {};
}
function windowSize() {
  const w = _window();
  return w ? [w.innerWidth, w.innerHeight] : [undefined, undefined];
}
function containerSize() {
  const view = this.context.dataflow,
    el = view.container && view.container();
  return el ? [el.clientWidth, el.clientHeight] : [undefined, undefined];
}

function intersect (b, opt, group) {
  if (!b) return [];
  const [u, v] = b,
    box = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Bounds().set(u[0], u[1], v[0], v[1]),
    scene = group || this.context.dataflow.scenegraph().root;
  return (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.intersect)(scene, box, filter(opt));
}
function filter(opt) {
  let p = null;
  if (opt) {
    const types = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.marktype),
      names = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(opt.markname);
    p = _ => (!types.length || types.some(t => _.marktype === t)) && (!names.length || names.some(s => _.name === s));
  }
  return p;
}

/**
 * Appends a new point to the lasso
 *
 * @param {*} lasso the lasso in pixel space
 * @param {*} x the x coordinate in pixel space
 * @param {*} y the y coordinate in pixel space
 * @param {*} minDist the minimum distance, in pixels, that thenew point needs to be apart from the last point
 * @returns a new array containing the lasso with the new point
 */
function lassoAppend(lasso, x, y) {
  let minDist = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 5;
  lasso = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(lasso);
  const last = lasso[lasso.length - 1];

  // Add point to lasso if its the first point or distance to last point exceed minDist
  return last === undefined || Math.hypot(last[0] - x, last[1] - y) > minDist ? [...lasso, [x, y]] : lasso;
}

/**
 * Generates a svg path command which draws a lasso
 *
 * @param {*} lasso the lasso in pixel space in the form [[x,y], [x,y], ...]
 * @returns the svg path command that draws the lasso
 */
function lassoPath(lasso) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(lasso).reduce((svg, _ref, i) => {
    let [x, y] = _ref;
    return svg += i == 0 ? `M ${x},${y} ` : i === lasso.length - 1 ? ' Z' : `L ${x},${y} `;
  }, '');
}

/**
 * Inverts the lasso from pixel space to an array of vega scenegraph tuples
 *
 * @param {*} data the dataset
 * @param {*} pixelLasso the lasso in pixel space, [[x,y], [x,y], ...]
 * @param {*} unit the unit where the lasso is defined
 *
 * @returns an array of vega scenegraph tuples
 */
function intersectLasso(markname, pixelLasso, unit) {
  const {
    x,
    y,
    mark
  } = unit;
  const bb = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_4__.Bounds().set(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER, Number.MIN_SAFE_INTEGER);

  // Get bounding box around lasso
  for (const [px, py] of pixelLasso) {
    if (px < bb.x1) bb.x1 = px;
    if (px > bb.x2) bb.x2 = px;
    if (py < bb.y1) bb.y1 = py;
    if (py > bb.y2) bb.y2 = py;
  }

  // Translate bb against unit coordinates
  bb.translate(x, y);
  const intersection = intersect([[bb.x1, bb.y1], [bb.x2, bb.y2]], markname, mark);

  // Check every point against the lasso
  return intersection.filter(tuple => pointInPolygon(tuple.x, tuple.y, pixelLasso));
}

/**
 * Performs a test if a point is inside a polygon based on the idea from
 * https://wrf.ecse.rpi.edu/Research/Short_Notes/pnpoly.html
 *
 * This method will not need the same start/end point since it wraps around the edges of the array
 *
 * @param {*} test a point to test against
 * @param {*} polygon a polygon in the form [[x,y], [x,y], ...]
 * @returns true if the point lies inside the polygon, false otherwise
 */
function pointInPolygon(testx, testy, polygon) {
  let intersections = 0;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const [prevX, prevY] = polygon[j];
    const [x, y] = polygon[i];

    // count intersections
    if (y > testy != prevY > testy && testx < (prevX - x) * (testy - y) / (prevY - y) + x) {
      intersections++;
    }
  }

  // point is in polygon if intersection count is odd
  return intersections & 1;
}

// Expression function context object
const functionContext = {
  random() {
    return (0,vega_statistics__WEBPACK_IMPORTED_MODULE_6__.random)();
  },
  // override default
  cumulativeNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeNormal,
  cumulativeLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeLogNormal,
  cumulativeUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.cumulativeUniform,
  densityNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityNormal,
  densityLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityLogNormal,
  densityUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.densityUniform,
  quantileNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileNormal,
  quantileLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileLogNormal,
  quantileUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.quantileUniform,
  sampleNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleNormal,
  sampleLogNormal: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleLogNormal,
  sampleUniform: vega_statistics__WEBPACK_IMPORTED_MODULE_6__.sampleUniform,
  isArray: vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray,
  isBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean,
  isDate: vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate,
  isDefined(_) {
    return _ !== undefined;
  },
  isNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber,
  isObject: vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject,
  isRegExp: vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp,
  isString: vega_util__WEBPACK_IMPORTED_MODULE_0__.isString,
  isTuple: vega_dataflow__WEBPACK_IMPORTED_MODULE_3__.isTuple,
  isValid(_) {
    return _ != null && _ === _;
  },
  toBoolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  toDate(_) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate)(_);
  },
  // suppress extra arguments
  toNumber: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  toString: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  indexof,
  join,
  lastindexof,
  replace,
  reverse,
  sort,
  slice,
  flush: vega_util__WEBPACK_IMPORTED_MODULE_0__.flush,
  lerp: vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp,
  merge,
  pad: vega_util__WEBPACK_IMPORTED_MODULE_0__.pad,
  peek: vega_util__WEBPACK_IMPORTED_MODULE_0__.peek,
  pluck,
  span: vega_util__WEBPACK_IMPORTED_MODULE_0__.span,
  inrange: vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange,
  truncate: vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate,
  rgb: d3_color__WEBPACK_IMPORTED_MODULE_11__.rgb,
  lab: d3_color__WEBPACK_IMPORTED_MODULE_12__["default"],
  hcl: d3_color__WEBPACK_IMPORTED_MODULE_12__.hcl,
  hsl: d3_color__WEBPACK_IMPORTED_MODULE_11__.hsl,
  luminance,
  contrast,
  sequence: d3_array__WEBPACK_IMPORTED_MODULE_13__["default"],
  format,
  utcFormat,
  utcParse,
  utcOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcOffset,
  utcSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcSequence,
  timeFormat,
  timeParse,
  timeOffset: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeOffset,
  timeSequence: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeSequence,
  timeUnitSpecifier: vega_time__WEBPACK_IMPORTED_MODULE_7__.timeUnitSpecifier,
  monthFormat,
  monthAbbrevFormat,
  dayFormat,
  dayAbbrevFormat,
  quarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter,
  utcquarter: vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter,
  week: vega_time__WEBPACK_IMPORTED_MODULE_7__.week,
  utcweek: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcweek,
  dayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.dayofyear,
  utcdayofyear: vega_time__WEBPACK_IMPORTED_MODULE_7__.utcdayofyear,
  warn,
  info,
  debug,
  extent(_) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(_);
  },
  // suppress extra arguments
  inScope,
  intersect,
  clampRange: vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange,
  pinchDistance,
  pinchAngle,
  screen,
  containerSize,
  windowSize,
  bandspace,
  setdata,
  pathShape,
  panLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear,
  panLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog,
  panPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow,
  panSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog,
  zoomLinear: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear,
  zoomLog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog,
  zoomPow: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow,
  zoomSymlog: vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog,
  encode,
  modify,
  lassoAppend,
  lassoPath,
  intersectLasso
};
const eventFunctions = ['view', 'item', 'group', 'xy', 'x', 'y'],
  // event functions
  eventPrefix = 'event.vega.',
  // event function prefix
  thisPrefix = 'this.',
  // function context prefix
  astVisitors = {}; // AST visitors for dependency analysis

// export code generator parameters
const codegenParams = {
  forbidden: ['_'],
  allowed: ['datum', 'event', 'item'],
  fieldvar: 'datum',
  globalvar: id => `_[${(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(SignalPrefix + id)}]`,
  functions: buildFunctions,
  constants: vega_expression__WEBPACK_IMPORTED_MODULE_1__.constants,
  visitors: astVisitors
};

// export code generator
const codeGenerator = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.codegenExpression)(codegenParams);

// Build expression function registry
function buildFunctions(codegen) {
  const fn = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.functions)(codegen);
  eventFunctions.forEach(name => fn[name] = eventPrefix + name);
  for (const name in functionContext) {
    fn[name] = thisPrefix + name;
  }
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(fn, internalScaleFunctions(codegen, functionContext, astVisitors));
  return fn;
}

// Register an expression function
function expressionFunction(name, fn, visitor) {
  if (arguments.length === 1) {
    return functionContext[name];
  }

  // register with the functionContext
  functionContext[name] = fn;

  // if there is an astVisitor register that, too
  if (visitor) astVisitors[name] = visitor;

  // if the code generator has already been initialized,
  // we need to also register the function with it
  if (codeGenerator) codeGenerator.functions[name] = thisPrefix + name;
  return this;
}

// register expression functions with ast visitors
expressionFunction('bandwidth', bandwidth, scaleVisitor);
expressionFunction('copy', copy, scaleVisitor);
expressionFunction('domain', domain, scaleVisitor);
expressionFunction('range', range, scaleVisitor);
expressionFunction('invert', invert, scaleVisitor);
expressionFunction('scale', scale, scaleVisitor);
expressionFunction('gradient', scaleGradient, scaleVisitor);
expressionFunction('geoArea', geoArea, scaleVisitor);
expressionFunction('geoBounds', geoBounds, scaleVisitor);
expressionFunction('geoCentroid', geoCentroid, scaleVisitor);
expressionFunction('geoShape', geoShape, scaleVisitor);
expressionFunction('geoScale', geoScale, scaleVisitor);
expressionFunction('indata', indata, indataVisitor);
expressionFunction('data', data, dataVisitor);
expressionFunction('treePath', treePath, dataVisitor);
expressionFunction('treeAncestors', treeAncestors, dataVisitor);

// register Vega-Lite selection functions
expressionFunction('vlSelectionTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionIdTest', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionIdTest, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionResolve', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionResolve, vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionVisitor);
expressionFunction('vlSelectionTuples', vega_selections__WEBPACK_IMPORTED_MODULE_5__.selectionTuples);

function parser (expr, scope) {
  const params = {};

  // parse the expression to an abstract syntax tree (ast)
  let ast;
  try {
    expr = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(expr) ? expr : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(expr) + '';
    ast = (0,vega_expression__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr);
  } catch (err) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression parse error: ' + expr);
  }

  // analyze ast function calls for dependencies
  ast.visit(node => {
    if (node.type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.CallExpression) return;
    const name = node.callee.name,
      visit = codegenParams.visitors[name];
    if (visit) visit(name, node.arguments, scope, params);
  });

  // perform code generation
  const gen = codeGenerator(ast);

  // collect signal dependencies
  gen.globals.forEach(name => {
    const signalName = SignalPrefix + name;
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, signalName) && scope.getSignal(name)) {
      params[signalName] = scope.signalRef(name);
    }
  });

  // return generated expression code and dependencies
  return {
    $expr: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      code: gen.code
    }, scope.options.ast ? {
      ast
    } : null),
    $fields: gen.fields,
    $params: params
  };
}




/***/ }),

/***/ "./node_modules/vega-geo/build/vega-geo.module.js":
/*!********************************************************!*\
  !*** ./node_modules/vega-geo/build/vega-geo.module.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   contour: () => (/* binding */ Contour),
/* harmony export */   geojson: () => (/* binding */ GeoJSON),
/* harmony export */   geopath: () => (/* binding */ GeoPath),
/* harmony export */   geopoint: () => (/* binding */ GeoPoint),
/* harmony export */   geoshape: () => (/* binding */ GeoShape),
/* harmony export */   graticule: () => (/* binding */ Graticule),
/* harmony export */   heatmap: () => (/* binding */ Heatmap),
/* harmony export */   isocontour: () => (/* binding */ Isocontour),
/* harmony export */   kde2d: () => (/* binding */ KDE2D),
/* harmony export */   projection: () => (/* binding */ Projection)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/sum.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-projection */ "./node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/graticule.js");
/* harmony import */ var d3_color__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-color */ "./node_modules/d3-color/src/color.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/build/vega-canvas.browser.module.js");









function noop() {}
const cases = [[], [[[1.0, 1.5], [0.5, 1.0]]], [[[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [0.5, 1.0]]], [[[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 1.5], [0.5, 1.0]], [[1.0, 0.5], [1.5, 1.0]]], [[[1.0, 0.5], [1.0, 1.5]]], [[[1.0, 0.5], [0.5, 1.0]]], [[[0.5, 1.0], [1.0, 0.5]]], [[[1.0, 1.5], [1.0, 0.5]]], [[[0.5, 1.0], [1.0, 0.5]], [[1.5, 1.0], [1.0, 1.5]]], [[[1.5, 1.0], [1.0, 0.5]]], [[[0.5, 1.0], [1.5, 1.0]]], [[[1.0, 1.5], [1.5, 1.0]]], [[[0.5, 1.0], [1.0, 1.5]]], []];

// Implementation adapted from d3/d3-contour. Thanks!
function contours () {
  var dx = 1,
    dy = 1,
    smooth = smoothLinear;
  function contours(values, tz) {
    return tz.map(value => contour(values, value));
  }

  // Accumulate, smooth contour rings, assign holes to exterior rings.
  // Based on https://github.com/mbostock/shapefile/blob/v0.6.2/shp/polygon.js
  function contour(values, value) {
    var polygons = [],
      holes = [];
    isorings(values, value, ring => {
      smooth(ring, values, value);
      if (area(ring) > 0) polygons.push([ring]);else holes.push(ring);
    });
    holes.forEach(hole => {
      for (var i = 0, n = polygons.length, polygon; i < n; ++i) {
        if (contains((polygon = polygons[i])[0], hole) !== -1) {
          polygon.push(hole);
          return;
        }
      }
    });
    return {
      type: 'MultiPolygon',
      value: value,
      coordinates: polygons
    };
  }

  // Marching squares with isolines stitched into rings.
  // Based on https://github.com/topojson/topojson-client/blob/v3.0.0/src/stitch.js
  function isorings(values, value, callback) {
    var fragmentByStart = [],
      fragmentByEnd = [],
      x,
      y,
      t0,
      t1,
      t2,
      t3;

    // Special case for the first row (y = -1, t2 = t3 = 0).
    x = y = -1;
    t1 = values[0] >= value;
    cases[t1 << 1].forEach(stitch);
    while (++x < dx - 1) {
      t0 = t1, t1 = values[x + 1] >= value;
      cases[t0 | t1 << 1].forEach(stitch);
    }
    cases[t1 << 0].forEach(stitch);

    // General case for the intermediate rows.
    while (++y < dy - 1) {
      x = -1;
      t1 = values[y * dx + dx] >= value;
      t2 = values[y * dx] >= value;
      cases[t1 << 1 | t2 << 2].forEach(stitch);
      while (++x < dx - 1) {
        t0 = t1, t1 = values[y * dx + dx + x + 1] >= value;
        t3 = t2, t2 = values[y * dx + x + 1] >= value;
        cases[t0 | t1 << 1 | t2 << 2 | t3 << 3].forEach(stitch);
      }
      cases[t1 | t2 << 3].forEach(stitch);
    }

    // Special case for the last row (y = dy - 1, t0 = t1 = 0).
    x = -1;
    t2 = values[y * dx] >= value;
    cases[t2 << 2].forEach(stitch);
    while (++x < dx - 1) {
      t3 = t2, t2 = values[y * dx + x + 1] >= value;
      cases[t2 << 2 | t3 << 3].forEach(stitch);
    }
    cases[t2 << 3].forEach(stitch);
    function stitch(line) {
      var start = [line[0][0] + x, line[0][1] + y],
        end = [line[1][0] + x, line[1][1] + y],
        startIndex = index(start),
        endIndex = index(end),
        f,
        g;
      if (f = fragmentByEnd[startIndex]) {
        if (g = fragmentByStart[endIndex]) {
          delete fragmentByEnd[f.end];
          delete fragmentByStart[g.start];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[f.start] = fragmentByEnd[g.end] = {
              start: f.start,
              end: g.end,
              ring: f.ring.concat(g.ring)
            };
          }
        } else {
          delete fragmentByEnd[f.end];
          f.ring.push(end);
          fragmentByEnd[f.end = endIndex] = f;
        }
      } else if (f = fragmentByStart[endIndex]) {
        if (g = fragmentByEnd[startIndex]) {
          delete fragmentByStart[f.start];
          delete fragmentByEnd[g.end];
          if (f === g) {
            f.ring.push(end);
            callback(f.ring);
          } else {
            fragmentByStart[g.start] = fragmentByEnd[f.end] = {
              start: g.start,
              end: f.end,
              ring: g.ring.concat(f.ring)
            };
          }
        } else {
          delete fragmentByStart[f.start];
          f.ring.unshift(start);
          fragmentByStart[f.start = startIndex] = f;
        }
      } else {
        fragmentByStart[startIndex] = fragmentByEnd[endIndex] = {
          start: startIndex,
          end: endIndex,
          ring: [start, end]
        };
      }
    }
  }
  function index(point) {
    return point[0] * 2 + point[1] * (dx + 1) * 4;
  }
  function smoothLinear(ring, values, value) {
    ring.forEach(point => {
      var x = point[0],
        y = point[1],
        xt = x | 0,
        yt = y | 0,
        v0,
        v1 = values[yt * dx + xt];
      if (x > 0 && x < dx && xt === x) {
        v0 = values[yt * dx + xt - 1];
        point[0] = x + (value - v0) / (v1 - v0) - 0.5;
      }
      if (y > 0 && y < dy && yt === y) {
        v0 = values[(yt - 1) * dx + xt];
        point[1] = y + (value - v0) / (v1 - v0) - 0.5;
      }
    });
  }
  contours.contour = contour;
  contours.size = function (_) {
    if (!arguments.length) return [dx, dy];
    var _0 = Math.floor(_[0]),
      _1 = Math.floor(_[1]);
    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, contours;
  };
  contours.smooth = function (_) {
    return arguments.length ? (smooth = _ ? smoothLinear : noop, contours) : smooth === smoothLinear;
  };
  return contours;
}
function area(ring) {
  var i = 0,
    n = ring.length,
    area = ring[n - 1][1] * ring[0][0] - ring[n - 1][0] * ring[0][1];
  while (++i < n) area += ring[i - 1][1] * ring[i][0] - ring[i - 1][0] * ring[i][1];
  return area;
}
function contains(ring, hole) {
  var i = -1,
    n = hole.length,
    c;
  while (++i < n) if (c = ringContains(ring, hole[i])) return c;
  return 0;
}
function ringContains(ring, point) {
  var x = point[0],
    y = point[1],
    contains = -1;
  for (var i = 0, n = ring.length, j = n - 1; i < n; j = i++) {
    var pi = ring[i],
      xi = pi[0],
      yi = pi[1],
      pj = ring[j],
      xj = pj[0],
      yj = pj[1];
    if (segmentContains(pi, pj, point)) return 0;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) contains = -contains;
  }
  return contains;
}
function segmentContains(a, b, c) {
  var i;
  return collinear(a, b, c) && within(a[i = +(a[0] === b[0])], c[i], b[i]);
}
function collinear(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) === (c[0] - a[0]) * (b[1] - a[1]);
}
function within(p, q, r) {
  return p <= q && q <= r || r <= q && q <= p;
}

function quantize (k, nice, zero) {
  return function (values) {
    var ex = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extent)(values),
      start = zero ? Math.min(ex[0], 0) : ex[0],
      stop = ex[1],
      span = stop - start,
      step = nice ? (0,d3_array__WEBPACK_IMPORTED_MODULE_5__.tickStep)(start, stop, k) : span / (k + 1);
    return (0,d3_array__WEBPACK_IMPORTED_MODULE_6__["default"])(start + step, stop, step);
  };
}

/**
 * Generate isocontours (level sets) based on input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   specified, the levels, nice, resolve, and zero parameters are ignored.
 * @param {number} [params.levels] - The desired number of contour levels.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified levels.
 * @param {string} [params.resolve] - The method for resolving thresholds
 *   across multiple input grids. If 'independent' (the default), threshold
 *   calculation will be performed separately for each grid. If 'shared', a
 *   single set of threshold values will be used for all input grids.
 * @param {boolean} [params.zero] - Boolean flag indicating if the contour
 *   threshold values should include zero.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 * @param {boolean} [params.scale] - Optional numerical value by which to
 *   scale the output isocontour coordinates. This parameter can be useful
 *   to scale the contours to match a desired output resolution.
 * @param {string} [params.as='contour'] - The output field in which to store
 *   the generated isocontour data (default 'contour').
 */
function Isocontour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Isocontour.Definition = {
  'type': 'Isocontour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'levels',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'zero',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'scale',
    'type': 'number',
    'expr': true
  }, {
    'name': 'translate',
    'type': 'number',
    'array': true,
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'default': 'contour'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Isocontour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }
    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      source = pulse.materialize(pulse.SOURCE).source,
      field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
      contour = contours().smooth(_.smooth !== false),
      tz = _.thresholds || levels(source, field, _),
      as = _.as === null ? null : _.as || 'contour',
      values = [];
    source.forEach(t => {
      const grid = field(t);

      // generate contour paths in GeoJSON format
      const paths = contour.size([grid.width, grid.height])(grid.values, (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(tz) ? tz : tz(grid.values));

      // adjust contour path coordinates as needed
      transformPaths(paths, grid, t, _);

      // ingest; copy source data properties to output
      paths.forEach(p => {
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.rederive)(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(as != null ? {
          [as]: p
        } : p)));
      });
    });
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }
});
function levels(values, f, _) {
  const q = quantize(_.levels || 10, _.nice, _.zero !== false);
  return _.resolve !== 'shared' ? q : q(values.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(f(t).values)));
}
function transformPaths(paths, grid, datum, _) {
  let s = _.scale || grid.scale,
    t = _.translate || grid.translate;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(s)) s = s(datum, _);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(t)) t = t(datum, _);
  if ((s === 1 || s == null) && !t) return;
  const sx = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[0]) || 1,
    sy = ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isNumber)(s) ? s : s[1]) || 1,
    tx = t && t[0] || 0,
    ty = t && t[1] || 0;
  paths.forEach(transform(grid, sx, sy, tx, ty));
}
function transform(grid, sx, sy, tx, ty) {
  const x1 = grid.x1 || 0,
    y1 = grid.y1 || 0,
    flip = sx * sy < 0;
  function transformPolygon(coordinates) {
    coordinates.forEach(transformRing);
  }
  function transformRing(coordinates) {
    if (flip) coordinates.reverse(); // maintain winding order
    coordinates.forEach(transformPoint);
  }
  function transformPoint(coordinates) {
    coordinates[0] = (coordinates[0] - x1) * sx + tx;
    coordinates[1] = (coordinates[1] - y1) * sy + ty;
  }
  return function (geometry) {
    geometry.coordinates.forEach(transformPolygon);
    return geometry;
  };
}

function radius(bw, data, f) {
  const v = bw >= 0 ? bw : (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bandwidthNRD)(data, f);
  return Math.round((Math.sqrt(4 * v * v + 1) - 1) / 2);
}
function number(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(_) ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(+_);
}

// Implementation adapted from d3/d3-contour. Thanks!
function density2D () {
  var x = d => d[0],
    y = d => d[1],
    weight = vega_util__WEBPACK_IMPORTED_MODULE_1__.one,
    bandwidth = [-1, -1],
    dx = 960,
    dy = 500,
    k = 2; // log2(cellSize)

  function density(data, counts) {
    const rx = radius(bandwidth[0], data, x) >> k,
      // blur x-radius
      ry = radius(bandwidth[1], data, y) >> k,
      // blur y-radius
      ox = rx ? rx + 2 : 0,
      // x-offset padding for blur
      oy = ry ? ry + 2 : 0,
      // y-offset padding for blur
      n = 2 * ox + (dx >> k),
      // grid width
      m = 2 * oy + (dy >> k),
      // grid height
      values0 = new Float32Array(n * m),
      values1 = new Float32Array(n * m);
    let values = values0;
    data.forEach(d => {
      const xi = ox + (+x(d) >> k),
        yi = oy + (+y(d) >> k);
      if (xi >= 0 && xi < n && yi >= 0 && yi < m) {
        values0[xi + yi * n] += +weight(d);
      }
    });
    if (rx > 0 && ry > 0) {
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
      blurX(n, m, values0, values1, rx);
      blurY(n, m, values1, values0, ry);
    } else if (rx > 0) {
      blurX(n, m, values0, values1, rx);
      blurX(n, m, values1, values0, rx);
      blurX(n, m, values0, values1, rx);
      values = values1;
    } else if (ry > 0) {
      blurY(n, m, values0, values1, ry);
      blurY(n, m, values1, values0, ry);
      blurY(n, m, values0, values1, ry);
      values = values1;
    }

    // scale density estimates
    // density in points per square pixel or probability density
    const s = counts ? Math.pow(2, -2 * k) : 1 / (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(values);
    for (let i = 0, sz = n * m; i < sz; ++i) values[i] *= s;
    return {
      values: values,
      scale: 1 << k,
      width: n,
      height: m,
      x1: ox,
      y1: oy,
      x2: ox + (dx >> k),
      y2: oy + (dy >> k)
    };
  }
  density.x = function (_) {
    return arguments.length ? (x = number(_), density) : x;
  };
  density.y = function (_) {
    return arguments.length ? (y = number(_), density) : y;
  };
  density.weight = function (_) {
    return arguments.length ? (weight = number(_), density) : weight;
  };
  density.size = function (_) {
    if (!arguments.length) return [dx, dy];
    var _0 = +_[0],
      _1 = +_[1];
    if (!(_0 >= 0 && _1 >= 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid size');
    return dx = _0, dy = _1, density;
  };
  density.cellSize = function (_) {
    if (!arguments.length) return 1 << k;
    if (!((_ = +_) >= 1)) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid cell size');
    k = Math.floor(Math.log(_) / Math.LN2);
    return density;
  };
  density.bandwidth = function (_) {
    if (!arguments.length) return bandwidth;
    _ = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_);
    if (_.length === 1) _ = [+_[0], +_[0]];
    if (_.length !== 2) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('invalid bandwidth');
    return bandwidth = _, density;
  };
  return density;
}
function blurX(n, m, source, target, r) {
  const w = (r << 1) + 1;
  for (let j = 0; j < m; ++j) {
    for (let i = 0, sr = 0; i < n + r; ++i) {
      if (i < n) {
        sr += source[i + j * n];
      }
      if (i >= r) {
        if (i >= w) {
          sr -= source[i - w + j * n];
        }
        target[i - r + j * n] = sr / Math.min(i + 1, n - 1 + w - i, w);
      }
    }
  }
}
function blurY(n, m, source, target, r) {
  const w = (r << 1) + 1;
  for (let i = 0; i < n; ++i) {
    for (let j = 0, sr = 0; j < m + r; ++j) {
      if (j < m) {
        sr += source[i + j * n];
      }
      if (j >= r) {
        if (j >= w) {
          sr -= source[i + (j - w) * n];
        }
        target[i + (j - r) * n] = sr / Math.min(j + 1, m - 1 + w - j, w);
      }
    }
  }
}

/**
 * Perform 2D kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The [width, height] extent (in
 *   units of input pixels) over which to perform density estimation.
 * @param {function(object): number} params.x - The x-coordinate accessor.
 * @param {function(object): number} params.y - The y-coordinate accessor.
 * @param {function(object): number} [params.weight] - The weight accessor.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 *   This parameter determines the level of spatial approximation. For example,
 *   the default value of 4 maps to 2x reductions in both x- and y- dimensions.
 *   A value of 1 will result in an output raster grid whose dimensions exactly
 *   matches the size parameter.
 * @param {Array<number>} [params.bandwidth] - The KDE kernel bandwidths,
 *   in pixels. The input can be a two-element array specifying separate
 *   x and y bandwidths, or a single-element array specifying both. If the
 *   bandwidth is unspecified or less than zero, the bandwidth will be
 *   automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.as='grid'] - The output field in which to store
 *   the generated raster grid (default 'grid').
 */
function KDE2D(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
KDE2D.Definition = {
  'type': 'KDE2D',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'grid'
  }]
};
const PARAMS = ['x', 'y', 'weight', 'size', 'cellSize', 'bandwidth'];
function params(obj, _) {
  PARAMS.forEach(param => _[param] != null ? obj[param](_[param]) : 0);
  return obj;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(KDE2D, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) return pulse.StopPropagation;
    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      source = pulse.materialize(pulse.SOURCE).source,
      groups = partition(source, _.groupby),
      names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorName),
      kde = params(density2D(), _),
      as = _.as || 'grid',
      values = [];
    function set(t, vals) {
      for (let i = 0; i < names.length; ++i) t[names[i]] = vals[i];
      return t;
    }

    // generate density raster grids
    values = groups.map(g => (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(set({
      [as]: kde(g, _.counts)
    }, g.dims)));
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = values;
    return out;
  }
});
function partition(data, groupby) {
  var groups = [],
    get = f => f(t),
    map,
    i,
    n,
    t,
    k,
    g;

  // partition data points into groups
  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];
      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}

/**
 * Generate contours based on kernel-density estimation of point data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The dimensions [width, height] over which to compute contours.
 *  If the values parameter is provided, this must be the dimensions of the input data.
 *  If density estimation is performed, this is the output view dimensions in pixels.
 * @param {Array<number>} [params.values] - An array of numeric values representing an
 *  width x height grid of values over which to compute contours. If unspecified, this
 *  transform will instead attempt to compute contours for the kernel density estimate
 *  using values drawn from data tuples in the input pulse.
 * @param {function(object): number} [params.x] - The pixel x-coordinate accessor for density estimation.
 * @param {function(object): number} [params.y] - The pixel y-coordinate accessor for density estimation.
 * @param {function(object): number} [params.weight] - The data point weight accessor for density estimation.
 * @param {number} [params.cellSize] - Contour density calculation cell size.
 * @param {number} [params.bandwidth] - Kernel density estimation bandwidth.
 * @param {Array<number>} [params.thresholds] - Contour threshold array. If
 *   this parameter is set, the count and nice parameters will be ignored.
 * @param {number} [params.count] - The desired number of contours.
 * @param {boolean} [params.nice] - Boolean flag indicating if the contour
 *   threshold values should be automatically aligned to "nice"
 *   human-friendly values. Setting this flag may cause the number of
 *   thresholds to deviate from the specified count.
 * @param {boolean} [params.smooth] - Boolean flag indicating if the contour
 *   polygons should be smoothed using linear interpolation. The default is
 *   true. The parameter is ignored when using density estimation.
 */
function Contour(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Contour.Definition = {
  'type': 'Contour',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'values',
    'type': 'number',
    'array': true
  }, {
    'name': 'x',
    'type': 'field'
  }, {
    'name': 'y',
    'type': 'field'
  }, {
    'name': 'weight',
    'type': 'field'
  }, {
    'name': 'cellSize',
    'type': 'number'
  }, {
    'name': 'bandwidth',
    'type': 'number'
  }, {
    'name': 'count',
    'type': 'number'
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'thresholds',
    'type': 'number',
    'array': true
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Contour, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (this.value && !pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }
    var out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      contour = contours().smooth(_.smooth !== false),
      values = _.values,
      thresh = _.thresholds || quantize(_.count || 10, _.nice, !!values),
      size = _.size,
      grid,
      post;
    if (!values) {
      values = pulse.materialize(pulse.SOURCE).source;
      grid = params(density2D(), _)(values, true);
      post = transform(grid, grid.scale || 1, grid.scale || 1, 0, 0);
      size = [grid.width, grid.height];
      values = grid.values;
    }
    thresh = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isArray)(thresh) ? thresh : thresh(values);
    values = contour.size(size)(values, thresh);
    if (post) values.forEach(post);
    if (this.value) out.rem = this.value;
    this.value = out.source = out.add = (values || []).map(vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest);
    return out;
  }
});

const Feature = 'Feature';
const FeatureCollection = 'FeatureCollection';
const MultiPoint = 'MultiPoint';

/**
 * Consolidate an array of [longitude, latitude] points or GeoJSON features
 * into a combined GeoJSON object. This transform is particularly useful for
 * combining geo data for a Projection's fit argument. The resulting GeoJSON
 * data is available as this transform's value. Input pulses are unchanged.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.fields] - A two-element array
 *   of field accessors for the longitude and latitude values.
 * @param {function(object): *} params.geojson - A field accessor for
 *   retrieving GeoJSON feature data.
 */
function GeoJSON(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoJSON.Definition = {
  'type': 'GeoJSON',
  'metadata': {},
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'length': 2
  }, {
    'name': 'geojson',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoJSON, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var features = this._features,
      points = this._points,
      fields = _.fields,
      lon = fields && fields[0],
      lat = fields && fields[1],
      geojson = _.geojson || !fields && vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
      flag = pulse.ADD,
      mod;
    mod = _.modified() || pulse.changed(pulse.REM) || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(geojson)) || lon && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lon)) || lat && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(lat));
    if (!this.value || mod) {
      flag = pulse.SOURCE;
      this._features = features = [];
      this._points = points = [];
    }
    if (geojson) {
      pulse.visit(flag, t => features.push(geojson(t)));
    }
    if (lon && lat) {
      pulse.visit(flag, t => {
        var x = lon(t),
          y = lat(t);
        if (x != null && y != null && (x = +x) === x && (y = +y) === y) {
          points.push([x, y]);
        }
      });
      features = features.concat({
        type: Feature,
        geometry: {
          type: MultiPoint,
          coordinates: points
        }
      });
    }
    this.value = {
      type: FeatureCollection,
      features: features
    };
  }
});

/**
 * Map GeoJSON data to an SVG path string.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='path'] - The output field in which to store
 *   the generated path data (default 'path').
 */
function GeoPath(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPath.Definition = {
  'type': 'GeoPath',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPath, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
      path = this.value,
      field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
      as = _.as || 'path',
      flag = out.SOURCE;
    if (!path || _.modified()) {
      // parameters updated, reset and reflow
      this.value = path = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection);
      out.materialize().reflow();
    } else {
      flag = field === vega_util__WEBPACK_IMPORTED_MODULE_1__.identity || pulse.modified(field.fields) ? out.ADD_MOD : out.ADD;
    }
    const prev = initPath(path, _.pointRadius);
    out.visit(flag, t => t[as] = path(field(t)));
    path.pointRadius(prev);
    return out.modifies(as);
  }
});
function initPath(path, pointRadius) {
  const prev = path.pointRadius();
  path.context(null);
  if (pointRadius != null) {
    path.pointRadius(pointRadius);
  }
  return prev;
}

/**
 * Geo-code a longitude/latitude point to an x/y coordinate.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {Array<function(object): *>} params.fields - A two-element array of
 *   field accessors for the longitude and latitude values.
 * @param {Array<string>} [params.as] - A two-element array of field names
 *   under which to store the result. Defaults to ['x','y'].
 */
function GeoPoint(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoPoint.Definition = {
  'type': 'GeoPoint',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection',
    'required': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['x', 'y']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoPoint, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var proj = _.projection,
      lon = _.fields[0],
      lat = _.fields[1],
      as = _.as || ['x', 'y'],
      x = as[0],
      y = as[1],
      mod;
    function set(t) {
      const xy = proj([lon(t), lat(t)]);
      if (xy) {
        t[x] = xy[0];
        t[y] = xy[1];
      } else {
        t[x] = undefined;
        t[y] = undefined;
      }
    }
    if (_.modified()) {
      // parameters updated, reflow
      pulse = pulse.materialize().reflow(true).visit(pulse.SOURCE, set);
    } else {
      mod = pulse.modified(lon.fields) || pulse.modified(lat.fields);
      pulse.visit(mod ? pulse.ADD_MOD : pulse.ADD, set);
    }
    return pulse.modifies(as);
  }
});

/**
 * Annotate items with a geopath shape generator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(number, number): *} params.projection - The cartographic
 *   projection to apply.
 * @param {function(object): *} [params.field] - The field with GeoJSON data,
 *   or null if the tuple itself is a GeoJSON feature.
 * @param {string} [params.as='shape'] - The output field in which to store
 *   the generated path data (default 'shape').
 */
function GeoShape(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
GeoShape.Definition = {
  'type': 'GeoShape',
  'metadata': {
    'modifies': true,
    'nomod': true
  },
  'params': [{
    'name': 'projection',
    'type': 'projection'
  }, {
    'name': 'field',
    'type': 'field',
    'default': 'datum'
  }, {
    'name': 'pointRadius',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'shape'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(GeoShape, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
      shape = this.value,
      as = _.as || 'shape',
      flag = out.ADD;
    if (!shape || _.modified()) {
      // parameters updated, reset and reflow
      this.value = shape = shapeGenerator((0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.getProjectionPath)(_.projection), _.field || (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.field)('datum'), _.pointRadius);
      out.materialize().reflow();
      flag = out.SOURCE;
    }
    out.visit(flag, t => t[as] = shape);
    return out.modifies(as);
  }
});
function shapeGenerator(path, field, pointRadius) {
  const shape = pointRadius == null ? _ => path(field(_)) : _ => {
    var prev = path.pointRadius(),
      value = path.pointRadius(pointRadius)(field(_));
    path.pointRadius(prev);
    return value;
  };
  shape.context = _ => {
    path.context(_);
    return shape;
  };
  return shape;
}

/**
 * GeoJSON feature generator for creating graticules.
 * @constructor
 */
function Graticule(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
  this.generator = (0,d3_geo__WEBPACK_IMPORTED_MODULE_9__["default"])();
}
Graticule.Definition = {
  'type': 'Graticule',
  'metadata': {
    'changes': true,
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMajor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'extentMinor',
    'type': 'array',
    'array': true,
    'length': 2,
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'step',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'stepMajor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [90, 360]
  }, {
    'name': 'stepMinor',
    'type': 'number',
    'array': true,
    'length': 2,
    'default': [10, 10]
  }, {
    'name': 'precision',
    'type': 'number',
    'default': 2.5
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Graticule, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    var src = this.value,
      gen = this.generator,
      t;
    if (!src.length || _.modified()) {
      for (const prop in _) {
        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(gen[prop])) {
          gen[prop](_[prop]);
        }
      }
    }
    t = gen();
    if (src.length) {
      pulse.mod.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.replace)(src[0], t));
    } else {
      pulse.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(t));
    }
    src[0] = t;
    return pulse;
  }
});

/**
 * Render a heatmap image for input raster grid data.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} [params.field] - The field with raster grid
 *   data. If unspecified, the tuple itself is interpreted as a raster grid.
 * @param {string} [params.color] - A constant color value or function for
 *   individual pixel color. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {number} [params.opacity] - A constant opacity value or function for
 *   individual pixel opacity. If a function, it will be invoked with an input
 *   object that includes $x, $y, $value, and $max fields for the grid.
 * @param {string} [params.resolve] - The method for resolving maximum values
 *   across multiple input grids. If 'independent' (the default), maximum
 *   calculation will be performed separately for each grid. If 'shared',
 *   a single global maximum will be used for all input grids.
 * @param {string} [params.as='image'] - The output field in which to store
 *   the generated bitmap canvas images (default 'image').
 */
function Heatmap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Heatmap.Definition = {
  'type': 'heatmap',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'color',
    'type': 'string',
    'expr': true
  }, {
    'name': 'opacity',
    'type': 'number',
    'expr': true
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'image'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Heatmap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.changed() && !_.modified()) {
      return pulse.StopPropagation;
    }
    var source = pulse.materialize(pulse.SOURCE).source,
      shared = _.resolve === 'shared',
      field = _.field || vega_util__WEBPACK_IMPORTED_MODULE_1__.identity,
      opacity = opacity_(_.opacity, _),
      color = color_(_.color, _),
      as = _.as || 'image',
      obj = {
        $x: 0,
        $y: 0,
        $value: 0,
        $max: shared ? (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(source.map(t => (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(field(t).values))) : 0
      };
    source.forEach(t => {
      const v = field(t);

      // build proxy data object
      const o = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.extend)({}, t, obj);
      // set maximum value if not globally shared
      if (!shared) o.$max = (0,d3_array__WEBPACK_IMPORTED_MODULE_7__["default"])(v.values || []);

      // generate canvas image
      // optimize color/opacity if not pixel-dependent
      t[as] = toCanvas(v, o, color.dep ? color : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(color(o)), opacity.dep ? opacity : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity(o)));
    });
    return pulse.reflow(true).modifies(as);
  }
});

// get image color function
function color_(color, _) {
  let f;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(color)) {
    f = obj => (0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color(obj, _));
    f.dep = dependency(color);
  } else {
    // default to mid-grey
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)((0,d3_color__WEBPACK_IMPORTED_MODULE_10__.rgb)(color || '#888'));
  }
  return f;
}

// get image opacity function
function opacity_(opacity, _) {
  let f;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(opacity)) {
    f = obj => opacity(obj, _);
    f.dep = dependency(opacity);
  } else if (opacity) {
    f = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.constant)(opacity);
  } else {
    // default to [0, max] opacity gradient
    f = obj => obj.$value / obj.$max || 0;
    f.dep = true;
  }
  return f;
}

// check if function depends on individual pixel data
function dependency(f) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(f)) return false;
  const set = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.accessorFields)(f));
  return set.$x || set.$y || set.$value || set.$max;
}

// render raster grid to canvas
function toCanvas(grid, obj, color, opacity) {
  const n = grid.width,
    m = grid.height,
    x1 = grid.x1 || 0,
    y1 = grid.y1 || 0,
    x2 = grid.x2 || n,
    y2 = grid.y2 || m,
    val = grid.values,
    value = val ? i => val[i] : vega_util__WEBPACK_IMPORTED_MODULE_1__.zero,
    can = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_4__.canvas)(x2 - x1, y2 - y1),
    ctx = can.getContext('2d'),
    img = ctx.getImageData(0, 0, x2 - x1, y2 - y1),
    pix = img.data;
  for (let j = y1, k = 0; j < y2; ++j) {
    obj.$y = j - y1;
    for (let i = x1, r = j * n; i < x2; ++i, k += 4) {
      obj.$x = i - x1;
      obj.$value = value(i + r);
      const v = color(obj);
      pix[k + 0] = v.r;
      pix[k + 1] = v.g;
      pix[k + 2] = v.b;
      pix[k + 3] = ~~(255 * opacity(obj));
    }
  }
  ctx.putImageData(img, 0, 0);
  return can;
}

/**
 * Maintains a cartographic projection.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function Projection(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Projection, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let proj = this.value;
    if (!proj || _.modified('type')) {
      this.value = proj = create(_.type);
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_[prop] != null) set(proj, prop, _[prop]);
      });
    } else {
      vega_projection__WEBPACK_IMPORTED_MODULE_3__.projectionProperties.forEach(prop => {
        if (_.modified(prop)) set(proj, prop, _[prop]);
      });
    }
    if (_.pointRadius != null) proj.path.pointRadius(_.pointRadius);
    if (_.fit) fit(proj, _);
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
  }
});
function fit(proj, _) {
  const data = collectGeoJSON(_.fit);
  _.extent ? proj.fitExtent(_.extent, data) : _.size ? proj.fitSize(_.size, data) : 0;
}
function create(type) {
  const constructor = (0,vega_projection__WEBPACK_IMPORTED_MODULE_3__.projection)((type || 'mercator').toLowerCase());
  if (!constructor) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized projection type: ' + type);
  return constructor();
}
function set(proj, key, value) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.isFunction)(proj[key])) proj[key](value);
}
function collectGeoJSON(data) {
  data = (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(data);
  return data.length === 1 ? data[0] : {
    type: FeatureCollection,
    features: data.reduce((a, f) => a.concat(featurize(f)), [])
  };
}
function featurize(f) {
  return f.type === FeatureCollection ? f.features : (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(f).filter(d => d != null).map(d => d.type === Feature ? d : {
    type: Feature,
    geometry: d
  });
}




/***/ }),

/***/ "./node_modules/vega-hierarchy/build/vega-hierarchy.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/vega-hierarchy/build/vega-hierarchy.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   nest: () => (/* binding */ Nest),
/* harmony export */   pack: () => (/* binding */ Pack),
/* harmony export */   partition: () => (/* binding */ Partition),
/* harmony export */   stratify: () => (/* binding */ Stratify),
/* harmony export */   tree: () => (/* binding */ Tree),
/* harmony export */   treelinks: () => (/* binding */ TreeLinks),
/* harmony export */   treemap: () => (/* binding */ Treemap)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/hierarchy/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/pack/index.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/partition.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/stratify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/tree.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/cluster.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/binary.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/dice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/slice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/sliceDice.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/squarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/resquarify.js");
/* harmony import */ var d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-hierarchy */ "./node_modules/d3-hierarchy/src/treemap/index.js");




// Build lookup table mapping tuple keys to tree node instances
function lookup (tree, key, filter) {
  const map = {};
  tree.each(node => {
    const t = node.data;
    if (filter(t)) map[key(t)] = node;
  });
  tree.lookup = map;
  return tree;
}

/**
 * Nest tuples into a tree structure, grouped by key values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.keys - The key fields to nest by, in order.
 * @param {boolean} [params.generate=false] - A boolean flag indicating if
 *   non-leaf nodes generated by this transform should be included in the
 *   output. The default (false) includes only the input data (leaf nodes)
 *   in the data stream.
 */
function Nest(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Nest.Definition = {
  'type': 'Nest',
  'metadata': {
    'treesource': true,
    'changes': true
  },
  'params': [{
    'name': 'keys',
    'type': 'field',
    'array': true
  }, {
    'name': 'generate',
    'type': 'boolean'
  }]
};
const children = n => n.values;
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Nest, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Nest transform requires an upstream data source.');
    }
    var gen = _.generate,
      mod = _.modified(),
      out = pulse.clone(),
      tree = this.value;
    if (!tree || mod || pulse.changed()) {
      // collect nodes to remove
      if (tree) {
        tree.each(node => {
          if (node.children && (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.isTuple)(node.data)) {
            out.rem.push(node.data);
          }
        });
      }

      // generate new tree structure
      this.value = tree = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_2__["default"])({
        values: (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.array)(_.keys).reduce((n, k) => {
          n.key(k);
          return n;
        }, nest()).entries(out.source)
      }, children);

      // collect nodes to add
      if (gen) {
        tree.each(node => {
          if (node.children) {
            node = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)(node.data);
            out.add.push(node);
            out.source.push(node);
          }
        });
      }

      // build lookup table
      lookup(tree, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid);
    }
    out.source.root = tree;
    return out;
  }
});
function nest() {
  const keys = [],
    nest = {
      entries: array => entries(apply(array, 0), 0),
      key: d => (keys.push(d), nest)
    };
  function apply(array, depth) {
    if (depth >= keys.length) {
      return array;
    }
    const n = array.length,
      key = keys[depth++],
      valuesByKey = {},
      result = {};
    let i = -1,
      keyValue,
      value,
      values;
    while (++i < n) {
      keyValue = key(value = array[i]) + '';
      if (values = valuesByKey[keyValue]) {
        values.push(value);
      } else {
        valuesByKey[keyValue] = [value];
      }
    }
    for (keyValue in valuesByKey) {
      result[keyValue] = apply(valuesByKey[keyValue], depth);
    }
    return result;
  }
  function entries(map, depth) {
    if (++depth > keys.length) return map;
    const array = [];
    for (const key in map) {
      array.push({
        key,
        values: entries(map[key], depth)
      });
    }
    return array;
  }
  return nest;
}

/**
 * Abstract class for tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function HierarchyLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
const defaultSeparation = (a, b) => a.parent === b.parent ? 1 : 2;
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(HierarchyLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source || !pulse.source.root) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(this.constructor.name + ' transform requires a backing tree data source.');
    }
    const layout = this.layout(_.method),
      fields = this.fields,
      root = pulse.source.root,
      as = _.as || fields;
    if (_.field) root.sum(_.field);else root.count();
    if (_.sort) root.sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.stableCompare)(_.sort, d => d.data));
    setParams(layout, this.params, _);
    if (layout.separation) {
      layout.separation(_.separation !== false ? defaultSeparation : vega_util__WEBPACK_IMPORTED_MODULE_1__.one);
    }
    try {
      this.value = layout(root);
    } catch (err) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)(err);
    }
    root.each(node => setFields(node, fields, as));
    return pulse.reflow(_.modified()).modifies(as).modifies('leaf');
  }
});
function setParams(layout, params, _) {
  for (let p, i = 0, n = params.length; i < n; ++i) {
    p = params[i];
    if (p in _) layout[p](_[p]);
  }
}
function setFields(node, fields, as) {
  const t = node.data,
    n = fields.length - 1;
  for (let i = 0; i < n; ++i) {
    t[as[i]] = node[fields[i]];
  }
  t[as[n]] = node.children ? node.children.length : 0;
}

const Output$3 = ['x', 'y', 'r', 'depth', 'children'];

/**
 * Packed circle tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */
function Pack(params) {
  HierarchyLayout.call(this, params);
}
Pack.Definition = {
  'type': 'Pack',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'radius',
    'type': 'field',
    'default': null
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$3.length,
    'default': Output$3
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Pack, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_3__["default"],
  params: ['radius', 'size', 'padding'],
  fields: Output$3
});

const Output$2 = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];

/**
 * Partition tree layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */
function Partition(params) {
  HierarchyLayout.call(this, params);
}
Partition.Definition = {
  'type': 'Partition',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$2.length,
    'default': Output$2
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Partition, HierarchyLayout, {
  layout: d3_hierarchy__WEBPACK_IMPORTED_MODULE_4__["default"],
  params: ['size', 'round', 'padding'],
  fields: Output$2
});

/**
 * Stratify a collection of tuples into a tree structure based on
 * id and parent id fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.key - Unique key field for each tuple.
 * @param {function(object): *} params.parentKey - Field with key for parent tuple.
 */
function Stratify(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Stratify.Definition = {
  'type': 'Stratify',
  'metadata': {
    'treesource': true
  },
  'params': [{
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'parentKey',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Stratify, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    if (!pulse.source) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Stratify transform requires an upstream data source.');
    }
    let tree = this.value;
    const mod = _.modified(),
      out = pulse.fork(pulse.ALL).materialize(pulse.SOURCE),
      run = !tree || mod || pulse.changed(pulse.ADD_REM) || pulse.modified(_.key.fields) || pulse.modified(_.parentKey.fields);

    // prevent upstream source pollution
    out.source = out.source.slice();
    if (run) {
      tree = out.source.length ? lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__["default"])().id(_.key).parentId(_.parentKey)(out.source), _.key, vega_util__WEBPACK_IMPORTED_MODULE_1__.truthy) : lookup((0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_5__["default"])()([{}]), _.key, _.key);
    }
    out.source.root = this.value = tree;
    return out;
  }
});

const Layouts = {
  tidy: d3_hierarchy__WEBPACK_IMPORTED_MODULE_6__["default"],
  cluster: d3_hierarchy__WEBPACK_IMPORTED_MODULE_7__["default"]
};
const Output$1 = ['x', 'y', 'depth', 'children'];

/**
 * Tree layout. Depending on the method parameter, performs either
 * Reingold-Tilford 'tidy' layout or dendrogram 'cluster' layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function Tree(params) {
  HierarchyLayout.call(this, params);
}
Tree.Definition = {
  'type': 'Tree',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'tidy',
    'values': ['tidy', 'cluster']
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'nodeSize',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'separation',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output$1.length,
    'default': Output$1
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Tree, HierarchyLayout, {
  /**
   * Tree layout generator. Supports both 'tidy' and 'cluster' layouts.
   */
  layout(method) {
    const m = method || 'tidy';
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Layouts, m)) return Layouts[m]();else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Tree layout method: ' + m);
  },
  params: ['size', 'nodeSize'],
  fields: Output$1
});

/**
 * Generate tuples representing links between tree nodes.
 * The resulting tuples will contain 'source' and 'target' fields,
 * which point to parent and child node tuples, respectively.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function TreeLinks(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, [], params);
}
TreeLinks.Definition = {
  'type': 'TreeLinks',
  'metadata': {
    'tree': true,
    'generates': true,
    'changes': true
  },
  'params': []
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(TreeLinks, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const links = this.value,
      tree = pulse.source && pulse.source.root,
      out = pulse.fork(pulse.NO_SOURCE),
      lut = {};
    if (!tree) (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('TreeLinks transform requires a tree data source.');
    if (pulse.changed(pulse.ADD_REM)) {
      // remove previous links
      out.rem = links;

      // build lookup table of valid tuples
      pulse.visit(pulse.SOURCE, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1);

      // generate links for all edges incident on valid tuples
      tree.each(node => {
        const t = node.data,
          p = node.parent && node.parent.data;
        if (p && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] && lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(p)]) {
          out.add.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.ingest)({
            source: p,
            target: t
          }));
        }
      });
      this.value = out.add;
    } else if (pulse.changed(pulse.MOD)) {
      // build lookup table of modified tuples
      pulse.visit(pulse.MOD, t => lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(t)] = 1);

      // gather links incident on modified tuples
      links.forEach(link => {
        if (lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.source)] || lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.tupleid)(link.target)]) {
          out.mod.push(link);
        }
      });
    }
    return out;
  }
});

const Tiles = {
  binary: d3_hierarchy__WEBPACK_IMPORTED_MODULE_8__["default"],
  dice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_9__["default"],
  slice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_10__["default"],
  slicedice: d3_hierarchy__WEBPACK_IMPORTED_MODULE_11__["default"],
  squarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_12__["default"],
  resquarify: d3_hierarchy__WEBPACK_IMPORTED_MODULE_13__["default"]
};
const Output = ['x0', 'y0', 'x1', 'y1', 'depth', 'children'];

/**
 * Treemap layout.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to size nodes.
 */
function Treemap(params) {
  HierarchyLayout.call(this, params);
}
Treemap.Definition = {
  'type': 'Treemap',
  'metadata': {
    'tree': true,
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field'
  }, {
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'squarify',
    'values': ['squarify', 'resquarify', 'binary', 'dice', 'slice', 'slicedice']
  }, {
    'name': 'padding',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingInner',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingOuter',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingTop',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingRight',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingBottom',
    'type': 'number',
    'default': 0
  }, {
    'name': 'paddingLeft',
    'type': 'number',
    'default': 0
  }, {
    'name': 'ratio',
    'type': 'number',
    'default': 1.618033988749895
  }, {
    'name': 'round',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': Output.length,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Treemap, HierarchyLayout, {
  /**
   * Treemap layout generator. Adds 'method' and 'ratio' parameters
   * to configure the underlying tile method.
   */
  layout() {
    const x = (0,d3_hierarchy__WEBPACK_IMPORTED_MODULE_14__["default"])();
    x.ratio = _ => {
      const t = x.tile();
      if (t.ratio) x.tile(t.ratio(_));
    };
    x.method = _ => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_1__.hasOwnProperty)(Tiles, _)) x.tile(Tiles[_]);else (0,vega_util__WEBPACK_IMPORTED_MODULE_1__.error)('Unrecognized Treemap layout method: ' + _);
    };
    return x;
  },
  params: ['method', 'ratio', 'size', 'round', 'padding', 'paddingInner', 'paddingOuter', 'paddingTop', 'paddingRight', 'paddingBottom', 'paddingLeft'],
  fields: Output
});




/***/ }),

/***/ "./node_modules/vega-label/build/vega-label.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-label/build/vega-label.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   label: () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/build/vega-canvas.browser.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");





// bit mask for getting first 2 bytes of alpha value
const ALPHA_MASK = 0xff000000;
function baseBitmaps($, data) {
  const bitmap = $.bitmap();
  // when there is no base mark but data points are to be avoided
  (data || []).forEach(d => bitmap.set($(d.boundary[0]), $(d.boundary[3])));
  return [bitmap, undefined];
}
function markBitmaps($, baseMark, avoidMarks, labelInside, isGroupArea) {
  // create canvas
  const width = $.width,
    height = $.height,
    border = labelInside || isGroupArea,
    context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(width, height).getContext('2d'),
    baseMarkContext = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(width, height).getContext('2d'),
    strokeContext = border && (0,vega_canvas__WEBPACK_IMPORTED_MODULE_1__.canvas)(width, height).getContext('2d');

  // render all marks to be avoided into canvas
  avoidMarks.forEach(items => draw(context, items, false));
  draw(baseMarkContext, baseMark, false);
  if (border) {
    draw(strokeContext, baseMark, true);
  }

  // get canvas buffer, create bitmaps
  const buffer = getBuffer(context, width, height),
    baseMarkBuffer = getBuffer(baseMarkContext, width, height),
    strokeBuffer = border && getBuffer(strokeContext, width, height),
    layer1 = $.bitmap(),
    layer2 = border && $.bitmap();

  // populate bitmap layers
  let x, y, u, v, index, alpha, strokeAlpha, baseMarkAlpha;
  for (y = 0; y < height; ++y) {
    for (x = 0; x < width; ++x) {
      index = y * width + x;
      alpha = buffer[index] & ALPHA_MASK;
      baseMarkAlpha = baseMarkBuffer[index] & ALPHA_MASK;
      strokeAlpha = border && strokeBuffer[index] & ALPHA_MASK;
      if (alpha || strokeAlpha || baseMarkAlpha) {
        u = $(x);
        v = $(y);
        if (!isGroupArea && (alpha || baseMarkAlpha)) layer1.set(u, v); // update interior bitmap
        if (border && (alpha || strokeAlpha)) layer2.set(u, v); // update border bitmap
      }
    }
  }
  return [layer1, layer2];
}
function getBuffer(context, width, height) {
  return new Uint32Array(context.getImageData(0, 0, width, height).data.buffer);
}
function draw(context, items, interior) {
  if (!items.length) return;
  const type = items[0].mark.marktype;
  if (type === 'group') {
    items.forEach(group => {
      group.items.forEach(mark => draw(context, mark.items, interior));
    });
  } else {
    vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__.Marks[type].draw(context, {
      items: interior ? items.map(prepare) : items
    });
  }
}

/**
 * Prepare item before drawing into canvas (setting stroke and opacity)
 * @param {object} source item to be prepared
 * @returns prepared item
 */
function prepare(source) {
  const item = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.rederive)(source, {});
  if (item.stroke && item.strokeOpacity !== 0 || item.fill && item.fillOpacity !== 0) {
    return {
      ...item,
      strokeOpacity: 1,
      stroke: '#000',
      fillOpacity: 0
    };
  }
  return item;
}

const DIV = 5,
  // bit shift from x, y index to bit vector array index
  MOD = 31,
  // bit mask for index lookup within a bit vector
  SIZE = 32,
  // individual bit vector size
  RIGHT0 = new Uint32Array(SIZE + 1),
  // left-anchored bit vectors, full -> 0
  RIGHT1 = new Uint32Array(SIZE + 1); // right-anchored bit vectors, 0 -> full

RIGHT1[0] = 0;
RIGHT0[0] = ~RIGHT1[0];
for (let i = 1; i <= SIZE; ++i) {
  RIGHT1[i] = RIGHT1[i - 1] << 1 | 1;
  RIGHT0[i] = ~RIGHT1[i];
}
function Bitmap (w, h) {
  const array = new Uint32Array(~~((w * h + SIZE) / SIZE));
  function _set(index, mask) {
    array[index] |= mask;
  }
  function _clear(index, mask) {
    array[index] &= mask;
  }
  return {
    array: array,
    get: (x, y) => {
      const index = y * w + x;
      return array[index >>> DIV] & 1 << (index & MOD);
    },
    set: (x, y) => {
      const index = y * w + x;
      _set(index >>> DIV, 1 << (index & MOD));
    },
    clear: (x, y) => {
      const index = y * w + x;
      _clear(index >>> DIV, ~(1 << (index & MOD)));
    },
    getRange: (x, y, x2, y2) => {
      let r = y2,
        start,
        end,
        indexStart,
        indexEnd;
      for (; r >= y; --r) {
        start = r * w + x;
        end = r * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          if (array[indexStart] & RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]) {
            return true;
          }
        } else {
          if (array[indexStart] & RIGHT0[start & MOD]) return true;
          if (array[indexEnd] & RIGHT1[(end & MOD) + 1]) return true;
          for (let i = indexStart + 1; i < indexEnd; ++i) {
            if (array[i]) return true;
          }
        }
      }
      return false;
    },
    setRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;
      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _set(indexStart, RIGHT0[start & MOD] & RIGHT1[(end & MOD) + 1]);
        } else {
          _set(indexStart, RIGHT0[start & MOD]);
          _set(indexEnd, RIGHT1[(end & MOD) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i) _set(i, 0xffffffff);
        }
      }
    },
    clearRange: (x, y, x2, y2) => {
      let start, end, indexStart, indexEnd, i;
      for (; y <= y2; ++y) {
        start = y * w + x;
        end = y * w + x2;
        indexStart = start >>> DIV;
        indexEnd = end >>> DIV;
        if (indexStart === indexEnd) {
          _clear(indexStart, RIGHT1[start & MOD] | RIGHT0[(end & MOD) + 1]);
        } else {
          _clear(indexStart, RIGHT1[start & MOD]);
          _clear(indexEnd, RIGHT0[(end & MOD) + 1]);
          for (i = indexStart + 1; i < indexEnd; ++i) _clear(i, 0);
        }
      }
    },
    outOfBounds: (x, y, x2, y2) => x < 0 || y < 0 || y2 >= h || x2 >= w
  };
}

function scaler (width, height, padding) {
  const ratio = Math.max(1, Math.sqrt(width * height / 1e6)),
    w = ~~((width + 2 * padding + ratio) / ratio),
    h = ~~((height + 2 * padding + ratio) / ratio),
    scale = _ => ~~((_ + padding) / ratio);
  scale.invert = _ => _ * ratio - padding;
  scale.bitmap = () => Bitmap(w, h);
  scale.ratio = ratio;
  scale.padding = padding;
  scale.width = width;
  scale.height = height;
  return scale;
}

function placeAreaLabelNaive ($, bitmaps, avoidBaseMark, markIndex) {
  const width = $.width,
    height = $.height;

  // try to place a label within an input area mark
  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
      // area points
      n = items.length,
      // number of points
      textHeight = d.datum.fontSize,
      // label width
      textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxAreaWidth = 0,
      x1,
      x2,
      y1,
      y2,
      x,
      y,
      areaWidth;

    // for each area sample point
    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;
      x = (x1 + x2) / 2;
      y = (y1 + y2) / 2;
      areaWidth = Math.abs(x2 - x1 + y2 - y1);
      if (areaWidth >= maxAreaWidth) {
        maxAreaWidth = areaWidth;
        d.x = x;
        d.y = y;
      }
    }
    x = textWidth / 2;
    y = textHeight / 2;
    x1 = d.x - x;
    x2 = d.x + x;
    y1 = d.y - y;
    y2 = d.y + y;
    d.align = 'center';
    if (x1 < 0 && x2 <= width) {
      d.align = 'left';
    } else if (0 <= x1 && width < x2) {
      d.align = 'right';
    }
    d.baseline = 'middle';
    if (y1 < 0 && y2 <= height) {
      d.baseline = 'top';
    } else if (0 <= y1 && height < y2) {
      d.baseline = 'bottom';
    }
    return true;
  };
}

function outOfBounds(x, y, textWidth, textHeight, width, height) {
  let r = textWidth / 2;
  return x - r < 0 || x + r > width || y - (r = textHeight / 2) < 0 || y + r > height;
}
function collision($, x, y, textHeight, textWidth, h, bm0, bm1) {
  const w = textWidth * h / (textHeight * 2),
    x1 = $(x - w),
    x2 = $(x + w),
    y1 = $(y - (h = h / 2)),
    y2 = $(y + h);
  return bm0.outOfBounds(x1, y1, x2, y2) || bm0.getRange(x1, y1, x2, y2) || bm1 && bm1.getRange(x1, y1, x2, y2);
}

function placeAreaLabelReducedSearch ($, bitmaps, avoidBaseMark, markIndex) {
  const width = $.width,
    height = $.height,
    bm0 = bitmaps[0],
    // where labels have been placed
    bm1 = bitmaps[1]; // area outlines

  function tryLabel(_x, _y, maxSize, textWidth, textHeight) {
    const x = $.invert(_x),
      y = $.invert(_y);
    let lo = maxSize,
      hi = height,
      mid;
    if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
      // if the label fits at the current sample point,
      // perform binary search to find the largest font size that fits
      while (hi - lo >= 1) {
        mid = (lo + hi) / 2;
        if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
          hi = mid;
        } else {
          lo = mid;
        }
      }
      // place label if current lower bound exceeds prior max font size
      if (lo > maxSize) {
        return [x, y, lo, true];
      }
    }
  }

  // try to place a label within an input area mark
  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
      // area points
      n = items.length,
      // number of points
      textHeight = d.datum.fontSize,
      // label width
      textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__.textMetrics.width(d.datum, d.datum.text); // label height

    let maxSize = avoidBaseMark ? textHeight : 0,
      labelPlaced = false,
      labelPlaced2 = false,
      maxAreaWidth = 0,
      x1,
      x2,
      y1,
      y2,
      x,
      y,
      _x,
      _y,
      _x1,
      _xMid,
      _x2,
      _y1,
      _yMid,
      _y2,
      areaWidth,
      result,
      swapTmp;

    // for each area sample point
    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;
      if (x1 > x2) {
        swapTmp = x1;
        x1 = x2;
        x2 = swapTmp;
      }
      if (y1 > y2) {
        swapTmp = y1;
        y1 = y2;
        y2 = swapTmp;
      }
      _x1 = $(x1);
      _x2 = $(x2);
      _xMid = ~~((_x1 + _x2) / 2);
      _y1 = $(y1);
      _y2 = $(y2);
      _yMid = ~~((_y1 + _y2) / 2);

      // search along the line from mid point between the 2 border to lower border
      for (_x = _xMid; _x >= _x1; --_x) {
        for (_y = _yMid; _y >= _y1; --_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }

      // search along the line from mid point between the 2 border to upper border
      for (_x = _xMid; _x <= _x2; ++_x) {
        for (_y = _yMid; _y <= _y2; ++_y) {
          result = tryLabel(_x, _y, maxSize, textWidth, textHeight);
          if (result) {
            [d.x, d.y, maxSize, labelPlaced] = result;
          }
        }
      }

      // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas
      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2;

        // place label if it fits and improves the max area width
        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    }

    // record current label placement information, update label bitmap
    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

// pixel direction offsets for flood fill search
const X_DIR = [-1, -1, 1, 1];
const Y_DIR = [-1, 1, -1, 1];
function placeAreaLabelFloodFill ($, bitmaps, avoidBaseMark, markIndex) {
  const width = $.width,
    height = $.height,
    bm0 = bitmaps[0],
    // where labels have been placed
    bm1 = bitmaps[1],
    // area outlines
    bm2 = $.bitmap(); // flood-fill visitations

  // try to place a label within an input area mark
  return function (d) {
    const items = d.datum.datum.items[markIndex].items,
      // area points
      n = items.length,
      // number of points
      textHeight = d.datum.fontSize,
      // label width
      textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__.textMetrics.width(d.datum, d.datum.text),
      // label height
      stack = []; // flood fill stack

    let maxSize = avoidBaseMark ? textHeight : 0,
      labelPlaced = false,
      labelPlaced2 = false,
      maxAreaWidth = 0,
      x1,
      x2,
      y1,
      y2,
      x,
      y,
      _x,
      _y,
      lo,
      hi,
      mid,
      areaWidth;

    // for each area sample point
    for (let i = 0; i < n; ++i) {
      x1 = items[i].x;
      y1 = items[i].y;
      x2 = items[i].x2 === undefined ? x1 : items[i].x2;
      y2 = items[i].y2 === undefined ? y1 : items[i].y2;

      // add scaled center point to stack
      stack.push([$((x1 + x2) / 2), $((y1 + y2) / 2)]);

      // perform flood fill, visit points
      while (stack.length) {
        [_x, _y] = stack.pop();

        // exit if point already marked
        if (bm0.get(_x, _y) || bm1.get(_x, _y) || bm2.get(_x, _y)) continue;

        // mark point in flood fill bitmap
        // add search points for all (in bound) directions
        bm2.set(_x, _y);
        for (let j = 0; j < 4; ++j) {
          x = _x + X_DIR[j];
          y = _y + Y_DIR[j];
          if (!bm2.outOfBounds(x, y, x, y)) stack.push([x, y]);
        }

        // unscale point back to x, y space
        x = $.invert(_x);
        y = $.invert(_y);
        lo = maxSize;
        hi = height; // TODO: make this bound smaller

        if (!outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, lo, bm0, bm1) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          // if the label fits at the current sample point,
          // perform binary search to find the largest font size that fits
          while (hi - lo >= 1) {
            mid = (lo + hi) / 2;
            if (collision($, x, y, textHeight, textWidth, mid, bm0, bm1)) {
              hi = mid;
            } else {
              lo = mid;
            }
          }
          // place label if current lower bound exceeds prior max font size
          if (lo > maxSize) {
            d.x = x;
            d.y = y;
            maxSize = lo;
            labelPlaced = true;
          }
        }
      }

      // place label at slice center if not placed through other means
      // and if we're not avoiding overlap with other areas
      if (!labelPlaced && !avoidBaseMark) {
        // one span is zero, hence we can add
        areaWidth = Math.abs(x2 - x1 + y2 - y1);
        x = (x1 + x2) / 2;
        y = (y1 + y2) / 2;

        // place label if it fits and improves the max area width
        if (areaWidth >= maxAreaWidth && !outOfBounds(x, y, textWidth, textHeight, width, height) && !collision($, x, y, textHeight, textWidth, textHeight, bm0, null)) {
          maxAreaWidth = areaWidth;
          d.x = x;
          d.y = y;
          labelPlaced2 = true;
        }
      }
    }

    // record current label placement information, update label bitmap
    if (labelPlaced || labelPlaced2) {
      x = textWidth / 2;
      y = textHeight / 2;
      bm0.setRange($(d.x - x), $(d.y - y), $(d.x + x), $(d.y + y));
      d.align = 'center';
      d.baseline = 'middle';
      return true;
    } else {
      return false;
    }
  };
}

const Aligns = ['right', 'center', 'left'],
  Baselines = ['bottom', 'middle', 'top'];
function placeMarkLabel ($, bitmaps, anchors, offsets) {
  const width = $.width,
    height = $.height,
    bm0 = bitmaps[0],
    bm1 = bitmaps[1],
    n = offsets.length;
  return function (d) {
    const boundary = d.boundary,
      textHeight = d.datum.fontSize;

    // can not be placed if the mark is not visible in the graph bound
    if (boundary[2] < 0 || boundary[5] < 0 || boundary[0] > width || boundary[3] > height) {
      return false;
    }
    let textWidth = d.textWidth ?? 0,
      dx,
      dy,
      isInside,
      sizeFactor,
      insideFactor,
      x1,
      x2,
      y1,
      y2,
      xc,
      yc,
      _x1,
      _x2,
      _y1,
      _y2;

    // for each anchor and offset
    for (let i = 0; i < n; ++i) {
      dx = (anchors[i] & 0x3) - 1;
      dy = (anchors[i] >>> 0x2 & 0x3) - 1;
      isInside = dx === 0 && dy === 0 || offsets[i] < 0;
      sizeFactor = dx && dy ? Math.SQRT1_2 : 1;
      insideFactor = offsets[i] < 0 ? -1 : 1;
      x1 = boundary[1 + dx] + offsets[i] * dx * sizeFactor;
      yc = boundary[4 + dy] + insideFactor * textHeight * dy / 2 + offsets[i] * dy * sizeFactor;
      y1 = yc - textHeight / 2;
      y2 = yc + textHeight / 2;
      _x1 = $(x1);
      _y1 = $(y1);
      _y2 = $(y2);
      if (!textWidth) {
        // to avoid finding width of text label,
        if (!test(_x1, _x1, _y1, _y2, bm0, bm1, x1, x1, y1, y2, boundary, isInside)) {
          // skip this anchor/offset option if we fail to place a label with 1px width
          continue;
        } else {
          // Otherwise, find the label width
          textWidth = vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__.textMetrics.width(d.datum, d.datum.text);
        }
      }
      xc = x1 + insideFactor * textWidth * dx / 2;
      x1 = xc - textWidth / 2;
      x2 = xc + textWidth / 2;
      _x1 = $(x1);
      _x2 = $(x2);
      if (test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside)) {
        // place label if the position is placeable
        d.x = !dx ? xc : dx * insideFactor < 0 ? x2 : x1;
        d.y = !dy ? yc : dy * insideFactor < 0 ? y2 : y1;
        d.align = Aligns[dx * insideFactor + 1];
        d.baseline = Baselines[dy * insideFactor + 1];
        bm0.setRange(_x1, _y1, _x2, _y2);
        return true;
      }
    }
    return false;
  };
}

// Test if a label with the given dimensions can be added without overlap
function test(_x1, _x2, _y1, _y2, bm0, bm1, x1, x2, y1, y2, boundary, isInside) {
  return !(bm0.outOfBounds(_x1, _y1, _x2, _y2) || (isInside && bm1 || bm0).getRange(_x1, _y1, _x2, _y2));
}

// 8-bit representation of anchors
const TOP = 0x0,
  MIDDLE = 0x4,
  BOTTOM = 0x8,
  LEFT = 0x0,
  CENTER = 0x1,
  RIGHT = 0x2;

// Mapping from text anchor to number representation
const anchorCode = {
  'top-left': TOP + LEFT,
  'top': TOP + CENTER,
  'top-right': TOP + RIGHT,
  'left': MIDDLE + LEFT,
  'middle': MIDDLE + CENTER,
  'right': MIDDLE + RIGHT,
  'bottom-left': BOTTOM + LEFT,
  'bottom': BOTTOM + CENTER,
  'bottom-right': BOTTOM + RIGHT
};
const placeAreaLabel = {
  'naive': placeAreaLabelNaive,
  'reduced-search': placeAreaLabelReducedSearch,
  'floodfill': placeAreaLabelFloodFill
};
function labelLayout (texts, size, compare, offset, anchor, avoidMarks, avoidBaseMark, lineAnchor, markIndex, padding, method) {
  // early exit for empty data
  if (!texts.length) return texts;
  const positions = Math.max(offset.length, anchor.length),
    offsets = getOffsets(offset, positions),
    anchors = getAnchors(anchor, positions),
    marktype = markType(texts[0].datum),
    grouptype = marktype === 'group' && texts[0].datum.items[markIndex].marktype,
    isGroupArea = grouptype === 'area',
    boundary = markBoundary(marktype, grouptype, lineAnchor, markIndex),
    infPadding = padding === null || padding === Infinity,
    isNaiveGroupArea = isGroupArea && method === 'naive';
  let maxTextWidth = -1,
    maxTextHeight = -1;

  // prepare text mark data for placing
  const data = texts.map(d => {
    const textWidth = infPadding ? vega_scenegraph__WEBPACK_IMPORTED_MODULE_0__.textMetrics.width(d, d.text) : undefined;
    maxTextWidth = Math.max(maxTextWidth, textWidth);
    maxTextHeight = Math.max(maxTextHeight, d.fontSize);
    return {
      datum: d,
      opacity: 0,
      x: undefined,
      y: undefined,
      align: undefined,
      baseline: undefined,
      boundary: boundary(d),
      textWidth
    };
  });
  padding = padding === null || padding === Infinity ? Math.max(maxTextWidth, maxTextHeight) + Math.max(...offset) : padding;
  const $ = scaler(size[0], size[1], padding);
  let bitmaps;
  if (!isNaiveGroupArea) {
    // sort labels in priority order, if comparator is provided
    if (compare) {
      data.sort((a, b) => compare(a.datum, b.datum));
    }

    // flag indicating if label can be placed inside its base mark
    let labelInside = false;
    for (let i = 0; i < anchors.length && !labelInside; ++i) {
      // label inside if anchor is at center
      // label inside if offset to be inside the mark bound
      labelInside = anchors[i] === 0x5 || offsets[i] < 0;
    }

    // extract data information from base mark when base mark is to be avoided
    // base mark is implicitly avoided if it is a group area
    const baseMark = (marktype && avoidBaseMark || isGroupArea) && texts.map(d => d.datum);

    // generate bitmaps for layout calculation
    bitmaps = avoidMarks.length || baseMark ? markBitmaps($, baseMark || [], avoidMarks, labelInside, isGroupArea) : baseBitmaps($, avoidBaseMark && data);
  }

  // generate label placement function
  const place = isGroupArea ? placeAreaLabel[method]($, bitmaps, avoidBaseMark, markIndex) : placeMarkLabel($, bitmaps, anchors, offsets);

  // place all labels
  data.forEach(d => d.opacity = +place(d));
  return data;
}
function getOffsets(_, count) {
  const offsets = new Float64Array(count),
    n = _.length;
  for (let i = 0; i < n; ++i) offsets[i] = _[i] || 0;
  for (let i = n; i < count; ++i) offsets[i] = offsets[n - 1];
  return offsets;
}
function getAnchors(_, count) {
  const anchors = new Int8Array(count),
    n = _.length;
  for (let i = 0; i < n; ++i) anchors[i] |= anchorCode[_[i]];
  for (let i = n; i < count; ++i) anchors[i] = anchors[n - 1];
  return anchors;
}
function markType(item) {
  return item && item.mark && item.mark.marktype;
}

/**
 * Factory function for function for getting base mark boundary, depending
 * on mark and group type. When mark type is undefined, line or area: boundary
 * is the coordinate of each data point. When base mark is grouped line,
 * boundary is either at the start or end of the line depending on the
 * value of lineAnchor. Otherwise, use bounds of base mark.
 */
function markBoundary(marktype, grouptype, lineAnchor, markIndex) {
  const xy = d => [d.x, d.x, d.x, d.y, d.y, d.y];
  if (!marktype) {
    return xy; // no reactive geometry
  } else if (marktype === 'line' || marktype === 'area') {
    return d => xy(d.datum);
  } else if (grouptype === 'line') {
    return d => {
      const items = d.datum.items[markIndex].items;
      return xy(items.length ? items[lineAnchor === 'start' ? 0 : items.length - 1] : {
        x: NaN,
        y: NaN
      });
    };
  } else {
    return d => {
      const b = d.datum.bounds;
      return [b.x1, (b.x1 + b.x2) / 2, b.x2, b.y1, (b.y1 + b.y2) / 2, b.y2];
    };
  }
}

const Output = ['x', 'y', 'opacity', 'align', 'baseline'];
const Anchors = ['top-left', 'left', 'bottom-left', 'top', 'bottom', 'top-right', 'right', 'bottom-right'];

/**
 * Compute text label layout to annotate marks.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<number>} params.size - The size of the layout, provided as a [width, height] array.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting label data in priority order.
 * @param {Array<string>} [params.anchor] - Label anchor points relative to the base mark bounding box.
 *   The available options are 'top-left', 'left', 'bottom-left', 'top',
 *   'bottom', 'top-right', 'right', 'bottom-right', 'middle'.
 * @param {Array<number>} [params.offset] - Label offsets (in pixels) from the base mark bounding box.
 *   This parameter is parallel to the list of anchor points.
 * @param {number | null} [params.padding=0] - The amount (in pixels) that a label may exceed the layout size.
 *   If this parameter is null, a label may exceed the layout size without any boundary.
 * @param {string} [params.lineAnchor='end'] - For group line mark labels only, indicates the anchor
 *   position for labels. One of 'start' or 'end'.
 * @param {string} [params.markIndex=0] - For group mark labels only, an index indicating
 *   which mark within the group should be labeled.
 * @param {Array<number>} [params.avoidMarks] - A list of additional mark names for which the label
 *   layout should avoid overlap.
 * @param {boolean} [params.avoidBaseMark=true] - Boolean flag indicating if labels should avoid
 *   overlap with the underlying base mark being labeled.
 * @param {string} [params.method='naive'] - For area make labels only, a method for
 *   place labels. One of 'naive', 'reduced-search', or 'floodfill'.
 * @param {Array<string>} [params.as] - The output fields written by the transform.
 *   The default is ['x', 'y', 'opacity', 'align', 'baseline'].
 */
function Label(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.Transform.call(this, null, params);
}
Label.Definition = {
  type: 'Label',
  metadata: {
    modifies: true
  },
  params: [{
    name: 'size',
    type: 'number',
    array: true,
    length: 2,
    required: true
  }, {
    name: 'sort',
    type: 'compare'
  }, {
    name: 'anchor',
    type: 'string',
    array: true,
    default: Anchors
  }, {
    name: 'offset',
    type: 'number',
    array: true,
    default: [1]
  }, {
    name: 'padding',
    type: 'number',
    default: 0,
    null: true
  }, {
    name: 'lineAnchor',
    type: 'string',
    values: ['start', 'end'],
    default: 'end'
  }, {
    name: 'markIndex',
    type: 'number',
    default: 0
  }, {
    name: 'avoidBaseMark',
    type: 'boolean',
    default: true
  }, {
    name: 'avoidMarks',
    type: 'data',
    array: true
  }, {
    name: 'method',
    type: 'string',
    default: 'naive'
  }, {
    name: 'as',
    type: 'string',
    array: true,
    length: Output.length,
    default: Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_3__.inherits)(Label, vega_dataflow__WEBPACK_IMPORTED_MODULE_2__.Transform, {
  transform(_, pulse) {
    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.isFunction)(p) && pulse.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse.changed(pulse.ADD_REM) || modp('sort'))) return;
    if (!_.size || _.size.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.error)('Size parameter should be specified as a [width, height] array.');
    }
    const as = _.as || Output;

    // run label layout
    labelLayout(pulse.materialize(pulse.SOURCE).source || [], _.size, _.sort, (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.offset == null ? 1 : _.offset), (0,vega_util__WEBPACK_IMPORTED_MODULE_3__.array)(_.anchor || Anchors), _.avoidMarks || [], _.avoidBaseMark !== false, _.lineAnchor || 'end', _.markIndex || 0, _.padding === undefined ? 0 : _.padding, _.method || 'naive').forEach(l => {
      // write layout results to data stream
      const t = l.datum;
      t[as[0]] = l.x;
      t[as[1]] = l.y;
      t[as[2]] = l.opacity;
      t[as[3]] = l.align;
      t[as[4]] = l.baseline;
    });
    return pulse.reflow(mod).modifies(as);
  }
});




/***/ }),

/***/ "./node_modules/vega-loader/build/vega-loader.browser.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-loader/build/vega-loader.browser.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   format: () => (/* binding */ format),
/* harmony export */   formats: () => (/* binding */ formats),
/* harmony export */   inferType: () => (/* binding */ inferType),
/* harmony export */   inferTypes: () => (/* binding */ inferTypes),
/* harmony export */   loader: () => (/* binding */ loader),
/* harmony export */   read: () => (/* binding */ read),
/* harmony export */   responseType: () => (/* binding */ responseType),
/* harmony export */   typeParsers: () => (/* binding */ typeParsers)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_dsv__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-dsv */ "./node_modules/d3-dsv/src/dsv.js");
/* harmony import */ var topojson_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! topojson-client */ "./node_modules/topojson-client/src/index.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");





// Matches absolute URLs with optional protocol
//   https://...    file://...    //...
const protocol_re = /^(data:|([A-Za-z]+:)?\/\/)/;

// Matches allowed URIs. From https://github.com/cure53/DOMPurify/blob/master/src/regexp.js with added file://
const allowed_re = /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|cid|xmpp|file|data):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i; // eslint-disable-line no-useless-escape
const whitespace_re = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex

// Special treatment in node.js for the file: protocol
const fileProtocol = 'file://';

/**
 * Factory for a loader constructor that provides methods for requesting
 * files from either the network or disk, and for sanitizing request URIs.
 * @param {function} fetch - The Fetch API for HTTP network requests.
 *   If null or undefined, HTTP loading will be disabled.
 * @param {object} fs - The file system interface for file loading.
 *   If null or undefined, local file loading will be disabled.
 * @return {function} A loader constructor with the following signature:
 *   param {object} [options] - Optional default loading options to use.
 *   return {object} - A new loader instance.
 */
function loaderFactory (fetch, fs) {
  return options => ({
    options: options || {},
    sanitize: sanitize,
    load: load,
    fileAccess: false,
    file: fileLoader(fs),
    http: httpLoader(fetch)
  });
}

/**
 * Load an external resource, typically either from the web or from the local
 * filesystem. This function uses {@link sanitize} to first sanitize the uri,
 * then calls either {@link http} (for web requests) or {@link file} (for
 * filesystem loading).
 * @param {string} uri - The resource indicator (e.g., URL or filename).
 * @param {object} [options] - Optional loading options. These options will
 *   override any existing default options.
 * @return {Promise} - A promise that resolves to the loaded content.
 */
async function load(uri, options) {
  const opt = await this.sanitize(uri, options),
    url = opt.href;
  return opt.localFile ? this.file(url) : this.http(url, options);
}

/**
 * URI sanitizer function.
 * @param {string} uri - The uri (url or filename) to check.
 * @param {object} options - An options hash.
 * @return {Promise} - A promise that resolves to an object containing
 *  sanitized uri data, or rejects it the input uri is deemed invalid.
 *  The properties of the resolved object are assumed to be
 *  valid attributes for an HTML 'a' tag. The sanitized uri *must* be
 *  provided by the 'href' property of the returned object.
 */
async function sanitize(uri, options) {
  options = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options, options);
  const fileAccess = this.fileAccess,
    result = {
      href: null
    };
  let isFile, loadFile, base;
  const isAllowed = allowed_re.test(uri.replace(whitespace_re, ''));
  if (uri == null || typeof uri !== 'string' || !isAllowed) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Sanitize failure, invalid URI: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(uri));
  }
  const hasProtocol = protocol_re.test(uri);

  // if relative url (no protocol/host), prepend baseURL
  if ((base = options.baseURL) && !hasProtocol) {
    // Ensure that there is a slash between the baseURL (e.g. hostname) and url
    if (!uri.startsWith('/') && !base.endsWith('/')) {
      uri = '/' + uri;
    }
    uri = base + uri;
  }

  // should we load from file system?
  loadFile = (isFile = uri.startsWith(fileProtocol)) || options.mode === 'file' || options.mode !== 'http' && !hasProtocol && fileAccess;
  if (isFile) {
    // strip file protocol
    uri = uri.slice(fileProtocol.length);
  } else if (uri.startsWith('//')) {
    if (options.defaultProtocol === 'file') {
      // if is file, strip protocol and set loadFile flag
      uri = uri.slice(2);
      loadFile = true;
    } else {
      // if relative protocol (starts with '//'), prepend default protocol
      uri = (options.defaultProtocol || 'http') + ':' + uri;
    }
  }

  // set non-enumerable mode flag to indicate local file load
  Object.defineProperty(result, 'localFile', {
    value: !!loadFile
  });

  // set uri
  result.href = uri;

  // set default result target, if specified
  if (options.target) {
    result.target = options.target + '';
  }

  // set default result rel, if specified (#1542)
  if (options.rel) {
    result.rel = options.rel + '';
  }

  // provide control over cross-origin image handling (#2238)
  // https://developer.mozilla.org/en-US/docs/Web/HTML/CORS_enabled_image
  if (options.context === 'image' && options.crossOrigin) {
    result.crossOrigin = options.crossOrigin + '';
  }

  // return
  return result;
}

/**
 * File system loader factory.
 * @param {object} fs - The file system interface.
 * @return {function} - A file loader with the following signature:
 *   param {string} filename - The file system path to load.
 *   param {string} filename - The file system path to load.
 *   return {Promise} A promise that resolves to the file contents.
 */
function fileLoader(fs) {
  return fs ? filename => new Promise((accept, reject) => {
    fs.readFile(filename, (error, data) => {
      if (error) reject(error);else accept(data);
    });
  }) : fileReject;
}

/**
 * Default file system loader that simply rejects.
 */
async function fileReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No file system access.');
}

/**
 * HTTP request handler factory.
 * @param {function} fetch - The Fetch API method.
 * @return {function} - An http loader with the following signature:
 *   param {string} url - The url to request.
 *   param {object} options - An options hash.
 *   return {Promise} - A promise that resolves to the file contents.
 */
function httpLoader(fetch) {
  return fetch ? async function (url, options) {
    const opt = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, this.options.http, options),
      type = options && options.response,
      response = await fetch(url, opt);
    return !response.ok ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(response.status + '' + response.statusText) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(response[type]) ? response[type]() : response.text();
  } : httpReject;
}

/**
 * Default http request handler that simply rejects.
 */
async function httpReject() {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No HTTP fetch method available.');
}

const isValid = _ => _ != null && _ === _;
const isBoolean = _ => _ === 'true' || _ === 'false' || _ === true || _ === false;
const isDate = _ => !Number.isNaN(Date.parse(_));
const isNumber = _ => !Number.isNaN(+_) && !(_ instanceof Date);
const isInteger = _ => isNumber(_) && Number.isInteger(+_);
const typeParsers = {
  boolean: vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean,
  integer: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  number: vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber,
  date: vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate,
  string: vega_util__WEBPACK_IMPORTED_MODULE_0__.toString,
  unknown: vega_util__WEBPACK_IMPORTED_MODULE_0__.identity
};
const typeTests = [isBoolean, isInteger, isNumber, isDate];
const typeList = ['boolean', 'integer', 'number', 'date'];
function inferType(values, field) {
  if (!values || !values.length) return 'unknown';
  const n = values.length,
    m = typeTests.length,
    a = typeTests.map((_, i) => i + 1);
  for (let i = 0, t = 0, j, value; i < n; ++i) {
    value = field ? values[i][field] : values[i];
    for (j = 0; j < m; ++j) {
      if (a[j] && isValid(value) && !typeTests[j](value)) {
        a[j] = 0;
        ++t;
        if (t === typeTests.length) return 'string';
      }
    }
  }
  return typeList[a.reduce((u, v) => u === 0 ? v : u, 0) - 1];
}
function inferTypes(data, fields) {
  return fields.reduce((types, field) => {
    types[field] = inferType(data, field);
    return types;
  }, {});
}

function delimitedFormat(delimiter) {
  const parse = function (data, format) {
    const delim = {
      delimiter: delimiter
    };
    return dsv(data, format ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(format, delim) : delim);
  };
  parse.responseType = 'text';
  return parse;
}
function dsv(data, format) {
  if (format.header) {
    data = format.header.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join(format.delimiter) + '\n' + data;
  }
  return (0,d3_dsv__WEBPACK_IMPORTED_MODULE_3__["default"])(format.delimiter).parse(data + '');
}
dsv.responseType = 'text';

function isBuffer(_) {
  return typeof Buffer === 'function' && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(Buffer.isBuffer) ? Buffer.isBuffer(_) : false;
}
function json(data, format) {
  const prop = format && format.property ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(format.property) : vega_util__WEBPACK_IMPORTED_MODULE_0__.identity;
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(data) && !isBuffer(data) ? parseJSON(prop(data), format) : prop(JSON.parse(data));
}
json.responseType = 'json';
function parseJSON(data, format) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable)(data)) {
    data = [...data];
  }
  return format && format.copy ? JSON.parse(JSON.stringify(data)) : data;
}

const filters = {
  interior: (a, b) => a !== b,
  exterior: (a, b) => a === b
};
function topojson(data, format) {
  let method, object, property, filter;
  data = json(data, format);
  if (format && format.feature) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.feature;
    property = format.feature;
  } else if (format && format.mesh) {
    method = topojson_client__WEBPACK_IMPORTED_MODULE_1__.mesh;
    property = format.mesh;
    filter = filters[format.filter];
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing TopoJSON feature or mesh parameter.');
  }
  object = (object = data.objects[property]) ? method(data, object, filter) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid TopoJSON object: ' + property);
  return object && object.features || [object];
}
topojson.responseType = 'json';

const format = {
  dsv: dsv,
  csv: delimitedFormat(','),
  tsv: delimitedFormat('\t'),
  json: json,
  topojson: topojson
};
function formats(name, reader) {
  if (arguments.length > 1) {
    format[name] = reader;
    return this;
  } else {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(format, name) ? format[name] : null;
  }
}
function responseType(type) {
  const f = formats(type);
  return f && f.responseType || 'text';
}

function read (data, schema, timeParser, utcParser) {
  schema = schema || {};
  const reader = formats(schema.type || 'json');
  if (!reader) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown data format type: ' + schema.type);
  data = reader(data, schema);
  if (schema.parse) parse(data, schema.parse, timeParser, utcParser);
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, 'columns')) delete data.columns;
  return data;
}
function parse(data, types, timeParser, utcParser) {
  if (!data.length) return; // early exit for empty data

  const locale = (0,vega_format__WEBPACK_IMPORTED_MODULE_2__.timeFormatDefaultLocale)();
  timeParser = timeParser || locale.timeParse;
  utcParser = utcParser || locale.utcParse;
  let fields = data.columns || Object.keys(data[0]),
    datum,
    field,
    i,
    j,
    n,
    m;
  if (types === 'auto') types = inferTypes(data, fields);
  fields = Object.keys(types);
  const parsers = fields.map(field => {
    const type = types[field];
    let parts, pattern;
    if (type && (type.startsWith('date:') || type.startsWith('utc:'))) {
      parts = type.split(/:(.+)?/, 2); // split on first :
      pattern = parts[1];
      if (pattern[0] === '\'' && pattern[pattern.length - 1] === '\'' || pattern[0] === '"' && pattern[pattern.length - 1] === '"') {
        pattern = pattern.slice(1, -1);
      }
      const parse = parts[0] === 'utc' ? utcParser : timeParser;
      return parse(pattern);
    }
    if (!typeParsers[type]) {
      throw Error('Illegal format pattern: ' + field + ':' + type);
    }
    return typeParsers[type];
  });
  for (i = 0, n = data.length, m = fields.length; i < n; ++i) {
    datum = data[i];
    for (j = 0; j < m; ++j) {
      field = fields[j];
      datum[field] = parsers[j](datum[field]);
    }
  }
}

const loader = loaderFactory(typeof fetch !== 'undefined' && fetch,
// use built-in fetch API
null // no file system access
);




/***/ }),

/***/ "./node_modules/vega-parser/build/vega-parser.module.js":
/*!**************************************************************!*\
  !*** ./node_modules/vega-parser/build/vega-parser.module.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AxisDomainRole: () => (/* binding */ AxisDomainRole),
/* harmony export */   AxisGridRole: () => (/* binding */ AxisGridRole),
/* harmony export */   AxisLabelRole: () => (/* binding */ AxisLabelRole),
/* harmony export */   AxisRole: () => (/* binding */ AxisRole),
/* harmony export */   AxisTickRole: () => (/* binding */ AxisTickRole),
/* harmony export */   AxisTitleRole: () => (/* binding */ AxisTitleRole),
/* harmony export */   DataScope: () => (/* binding */ DataScope),
/* harmony export */   FrameRole: () => (/* binding */ FrameRole),
/* harmony export */   LegendEntryRole: () => (/* binding */ LegendEntryRole),
/* harmony export */   LegendLabelRole: () => (/* binding */ LegendLabelRole),
/* harmony export */   LegendRole: () => (/* binding */ LegendRole),
/* harmony export */   LegendSymbolRole: () => (/* binding */ LegendSymbolRole),
/* harmony export */   LegendTitleRole: () => (/* binding */ LegendTitleRole),
/* harmony export */   MarkRole: () => (/* binding */ MarkRole),
/* harmony export */   Scope: () => (/* binding */ Scope),
/* harmony export */   ScopeRole: () => (/* binding */ ScopeRole),
/* harmony export */   config: () => (/* binding */ defaults),
/* harmony export */   parse: () => (/* binding */ parse),
/* harmony export */   signal: () => (/* binding */ parseSignal),
/* harmony export */   signalUpdates: () => (/* binding */ parseSignalUpdates),
/* harmony export */   stream: () => (/* binding */ parseStream)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-functions */ "./node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-event-selector */ "./node_modules/vega-event-selector/build/vega-event-selector.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");






function parseAutosize (spec) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : {
    type: spec || 'pad'
  };
}

const number = _ => +_ || 0;
const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function parsePadding (spec) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? paddingObject(number(spec)) : spec.signal ? spec : {
    top: number(spec.top),
    bottom: number(spec.bottom),
    left: number(spec.left),
    right: number(spec.right)
  };
}

const encoder = _ => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _) : {
  value: _
};
function addEncode(object, name, value, set) {
  if (value != null) {
    const isEncoder = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) && value.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value[0]);

    // Always assign signal to update, even if the signal is from the enter block
    if (isEncoder) {
      object.update[name] = value;
    } else {
      object[set || 'enter'][name] = {
        value: value
      };
    }
    return 1;
  } else {
    return 0;
  }
}
function addEncoders(object, enter, update) {
  for (const name in enter) {
    addEncode(object, name, enter[name]);
  }
  for (const name in update) {
    addEncode(object, name, update[name], 'update');
  }
}
function extendEncode(encode, extra, skip) {
  for (const name in extra) {
    if (skip && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(skip, name)) continue;
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(encode[name] || {}, extra[name]);
  }
  return encode;
}
function has(key, encode) {
  return encode && (encode.enter && encode.enter[key] || encode.update && encode.update[key]);
}

const MarkRole = 'mark';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const AxisRole = 'axis';
const AxisDomainRole = 'axis-domain';
const AxisGridRole = 'axis-grid';
const AxisLabelRole = 'axis-label';
const AxisTickRole = 'axis-tick';
const AxisTitleRole = 'axis-title';
const LegendRole = 'legend';
const LegendBandRole = 'legend-band';
const LegendEntryRole = 'legend-entry';
const LegendGradientRole = 'legend-gradient';
const LegendLabelRole = 'legend-label';
const LegendSymbolRole = 'legend-symbol';
const LegendTitleRole = 'legend-title';
const TitleRole = 'title';
const TitleTextRole = 'title-text';
const TitleSubtitleRole = 'title-subtitle';

function applyDefaults (encode, type, role, style, config) {
  const defaults = {},
    enter = {};
  let update, key, skip, props;

  // if text mark, apply global lineBreak settings (#2370)
  key = 'lineBreak';
  if (type === 'text' && config[key] != null && !has(key, encode)) {
    applyDefault(defaults, key, config[key]);
  }

  // ignore legend and axis roles
  if (role == 'legend' || String(role).startsWith('axis')) {
    role = null;
  }

  // resolve mark config
  props = role === FrameRole ? config.group : role === MarkRole ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, config.mark, config[type]) : null;
  for (key in props) {
    // do not apply defaults if relevant fields are defined
    skip = has(key, encode) || (key === 'fill' || key === 'stroke') && (has('fill', encode) || has('stroke', encode));
    if (!skip) applyDefault(defaults, key, props[key]);
  }

  // resolve styles, apply with increasing precedence
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(style).forEach(name => {
    const props = config.style && config.style[name];
    for (const key in props) {
      if (!has(key, encode)) {
        applyDefault(defaults, key, props[key]);
      }
    }
  });
  encode = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, encode); // defensive copy
  for (key in defaults) {
    props = defaults[key];
    if (props.signal) {
      (update = update || {})[key] = props;
    } else {
      enter[key] = props;
    }
  }
  encode.enter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(enter, encode.enter);
  if (update) encode.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(update, encode.update);
  return encode;
}
function applyDefault(defaults, key, value) {
  defaults[key] = value && value.signal ? {
    signal: value.signal
  } : {
    value: value
  };
}

const scaleRef = scale => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(scale) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(scale) : scale.signal ? `(${scale.signal})` : field(scale);
function entry$1(enc) {
  if (enc.gradient != null) {
    return gradient(enc);
  }
  let value = enc.signal ? `(${enc.signal})` : enc.color ? color(enc.color) : enc.field != null ? field(enc.field) : enc.value !== undefined ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(enc.value) : undefined;
  if (enc.scale != null) {
    value = scale(enc, value);
  }
  if (value === undefined) {
    value = null;
  }
  if (enc.exponent != null) {
    value = `pow(${value},${property(enc.exponent)})`;
  }
  if (enc.mult != null) {
    value += `*${property(enc.mult)}`;
  }
  if (enc.offset != null) {
    value += `+${property(enc.offset)}`;
  }
  if (enc.round) {
    value = `round(${value})`;
  }
  return value;
}
const _color = (type, x, y, z) => `(${type}(${[x, y, z].map(entry$1).join(',')})+'')`;
function color(enc) {
  return enc.c ? _color('hcl', enc.h, enc.c, enc.l) : enc.h || enc.s ? _color('hsl', enc.h, enc.s, enc.l) : enc.l || enc.a ? _color('lab', enc.l, enc.a, enc.b) : enc.r || enc.g || enc.b ? _color('rgb', enc.r, enc.g, enc.b) : null;
}
function gradient(enc) {
  // map undefined to null; expression lang does not allow undefined
  const args = [enc.start, enc.stop, enc.count].map(_ => _ == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_));

  // trim null inputs from the end
  while (args.length && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args) == null) args.pop();
  args.unshift(scaleRef(enc.gradient));
  return `gradient(${args.join(',')})`;
}
function property(property) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(property) ? '(' + entry$1(property) + ')' : property;
}
function field(ref) {
  return resolveField((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(ref) ? ref : {
    datum: ref
  });
}
function resolveField(ref) {
  let object, level, field;
  if (ref.signal) {
    object = 'datum';
    field = ref.signal;
  } else if (ref.group || ref.parent) {
    level = Math.max(1, ref.level || 1);
    object = 'item';
    while (level-- > 0) {
      object += '.mark.group';
    }
    if (ref.parent) {
      field = ref.parent;
      object += '.datum';
    } else {
      field = ref.group;
    }
  } else if (ref.datum) {
    object = 'datum';
    field = ref.datum;
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(ref));
  }
  if (!ref.signal) {
    field = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath)(field).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join('][') : resolveField(field);
  }
  return object + '[' + field + ']';
}
function scale(enc, value) {
  const scale = scaleRef(enc.scale);
  if (enc.range != null) {
    // pull value from scale range
    value = `lerp(_range(${scale}), ${+enc.range})`;
  } else {
    // run value through scale and/or pull scale bandwidth
    if (value !== undefined) value = `_scale(${scale}, ${value})`;
    if (enc.band) {
      value = (value ? value + '+' : '') + `_bandwidth(${scale})` + (+enc.band === 1 ? '' : '*' + property(enc.band));
      if (enc.extra) {
        // include logic to handle extraneous elements
        value = `(datum.extra ? _scale(${scale}, datum.extra.value) : ${value})`;
      }
    }
    if (value == null) value = '0';
  }
  return value;
}

function rule (enc) {
  let code = '';
  enc.forEach(rule => {
    const value = entry$1(rule);
    code += rule.test ? `(${rule.test})?${value}:` : value;
  });

  // if no else clause, terminate with null (#1366)
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(code) === ':') {
    code += 'null';
  }
  return code;
}

function parseEncode (encode, type, role, style, scope, params) {
  const enc = {};
  params = params || {};
  params.encoders = {
    $encode: enc
  };
  encode = applyDefaults(encode, type, role, style, scope.config);
  for (const key in encode) {
    enc[key] = parseBlock(encode[key], type, params, scope);
  }
  return params;
}
function parseBlock(block, marktype, params, scope) {
  const channels = {},
    fields = {};
  for (const name in block) {
    if (block[name] != null) {
      // skip any null entries
      channels[name] = parse$1(expr(block[name]), scope, params, fields);
    }
  }
  return {
    $expr: {
      marktype,
      channels
    },
    $fields: Object.keys(fields),
    $output: Object.keys(block)
  };
}
function expr(enc) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(enc) ? rule(enc) : entry$1(enc);
}
function parse$1(code, scope, params, fields) {
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, scope);
  expr.$fields.forEach(name => fields[name] = 1);
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(params, expr.$params);
  return expr.$expr;
}

const OUTER = 'outer',
  OUTER_INVALID = ['value', 'update', 'init', 'react', 'bind'];
function outerError(prefix, name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(prefix + ' for "outer" push: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}
function parseSignal (signal, scope) {
  const name = signal.name;
  if (signal.push === OUTER) {
    // signal must already be defined, raise error if not
    if (!scope.signals[name]) outerError('No prior signal definition', name);
    // signal push must not use properties reserved for standard definition
    OUTER_INVALID.forEach(prop => {
      if (signal[prop] !== undefined) outerError('Invalid property ', prop);
    });
  } else {
    // define a new signal in the current scope
    const op = scope.addSignal(name, signal.value);
    if (signal.react === false) op.react = false;
    if (signal.bind) scope.addBinding(name, signal.bind);
  }
}

function Entry(type, value, params, parent) {
  this.id = -1;
  this.type = type;
  this.value = value;
  this.params = params;
  if (parent) this.parent = parent;
}
function entry(type, value, params, parent) {
  return new Entry(type, value, params, parent);
}
function operator(value, params) {
  return entry('operator', value, params);
}

// -----

function ref(op) {
  const ref = {
    $ref: op.id
  };
  // if operator not yet registered, cache ref to resolve later
  if (op.id < 0) (op.refs = op.refs || []).push(ref);
  return ref;
}
function fieldRef$1(field, name) {
  return name ? {
    $field: field,
    $name: name
  } : {
    $field: field
  };
}
const keyFieldRef = fieldRef$1('key');
function compareRef(fields, orders) {
  return {
    $compare: fields,
    $order: orders
  };
}
function keyRef(fields, flat) {
  const ref = {
    $key: fields
  };
  if (flat) ref.$flat = true;
  return ref;
}

// -----

const Ascending = 'ascending';
const Descending = 'descending';
function sortKey(sort) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort) ? '' : (sort.order === Descending ? '-' : '+') + aggrField(sort.op, sort.field);
}
function aggrField(op, field) {
  return (op && op.signal ? '$' + op.signal : op || '') + (op && field ? '_' : '') + (field && field.signal ? '$' + field.signal : field || '');
}

// -----

const Scope$1 = 'scope';
const View = 'view';
function isSignal(_) {
  return _ && _.signal;
}
function isExpr$1(_) {
  return _ && _.expr;
}
function hasSignal(_) {
  if (isSignal(_)) return true;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_)) for (const key in _) {
    if (hasSignal(_[key])) return true;
  }
  return false;
}
function value(specValue, defaultValue) {
  return specValue != null ? specValue : defaultValue;
}
function deref(v) {
  return v && v.signal || v;
}

const Timer = 'timer';
function parseStream(stream, scope) {
  const method = stream.merge ? mergeStream : stream.stream ? nestedStream : stream.type ? eventStream : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream specification: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
  return method(stream, scope);
}
function eventSource(source) {
  return source === Scope$1 ? View : source || View;
}
function mergeStream(stream, scope) {
  const list = stream.merge.map(s => parseStream(s, scope)),
    entry = streamParameters({
      merge: list
    }, stream, scope);
  return scope.addStream(entry).id;
}
function nestedStream(stream, scope) {
  const id = parseStream(stream.stream, scope),
    entry = streamParameters({
      stream: id
    }, stream, scope);
  return scope.addStream(entry).id;
}
function eventStream(stream, scope) {
  let id;
  if (stream.type === Timer) {
    id = scope.event(Timer, stream.throttle);
    stream = {
      between: stream.between,
      filter: stream.filter
    };
  } else {
    id = scope.event(eventSource(stream.source), stream.type);
  }
  const entry = streamParameters({
    stream: id
  }, stream, scope);
  return Object.keys(entry).length === 1 ? id : scope.addStream(entry).id;
}
function streamParameters(entry, stream, scope) {
  let param = stream.between;
  if (param) {
    if (param.length !== 2) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Stream "between" parameter must have 2 entries: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(stream));
    }
    entry.between = [parseStream(param[0], scope), parseStream(param[1], scope)];
  }
  param = stream.filter ? [].concat(stream.filter) : [];
  if (stream.marktype || stream.markname || stream.markrole) {
    // add filter for mark type, name and/or role
    param.push(filterMark(stream.marktype, stream.markname, stream.markrole));
  }
  if (stream.source === Scope$1) {
    // add filter to limit events from sub-scope only
    param.push('inScope(event.item)');
  }
  if (param.length) {
    entry.filter = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)('(' + param.join(')&&(') + ')', scope).$expr;
  }
  if ((param = stream.throttle) != null) {
    entry.throttle = +param;
  }
  if ((param = stream.debounce) != null) {
    entry.debounce = +param;
  }
  if (stream.consume) {
    entry.consume = true;
  }
  return entry;
}
function filterMark(type, name, role) {
  const item = 'event.item';
  return item + (type && type !== '*' ? '&&' + item + '.mark.marktype===\'' + type + '\'' : '') + (role ? '&&' + item + '.mark.role===\'' + role + '\'' : '') + (name ? '&&' + item + '.mark.name===\'' + name + '\'' : '');
}

// bypass expression parser for internal operator references
const OP_VALUE_EXPR = {
  code: '_.$value',
  ast: {
    type: 'Identifier',
    value: 'value'
  }
};
function parseUpdate (spec, scope, target) {
  const encode = spec.encode,
    entry = {
      target: target
    };
  let events = spec.events,
    update = spec.update,
    sources = [];
  if (!events) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal update missing events specification.');
  }

  // interpret as an event selector string
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(events)) {
    events = (0,vega_event_selector__WEBPACK_IMPORTED_MODULE_2__.parseSelector)(events, scope.isSubscope() ? Scope$1 : View);
  }

  // separate event streams from signal updates
  events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(events).filter(s => s.signal || s.scale ? (sources.push(s), 0) : 1);

  // merge internal operator listeners
  if (sources.length > 1) {
    sources = [mergeSources(sources)];
  }

  // merge event streams, include as source
  if (events.length) {
    sources.push(events.length > 1 ? {
      merge: events
    } : events[0]);
  }
  if (encode != null) {
    if (update) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signal encode and update are mutually exclusive.');
    update = 'encode(item(),' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(encode) + ')';
  }

  // resolve update value
  entry.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(update) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope) : update.expr != null ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update.expr, scope) : update.value != null ? update.value : update.signal != null ? {
    $expr: OP_VALUE_EXPR,
    $params: {
      $value: scope.signalRef(update.signal)
    }
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid signal update specification.');
  if (spec.force) {
    entry.options = {
      force: true
    };
  }
  sources.forEach(source => scope.addUpdate((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(streamSource(source, scope), entry)));
}
function streamSource(stream, scope) {
  return {
    source: stream.signal ? scope.signalRef(stream.signal) : stream.scale ? scope.scaleRef(stream.scale) : parseStream(stream, scope)
  };
}
function mergeSources(sources) {
  return {
    signal: '[' + sources.map(s => s.scale ? 'scale("' + s.scale + '")' : s.signal) + ']'
  };
}

function parseSignalUpdates (signal, scope) {
  const op = scope.getSignal(signal.name);
  let expr = signal.update;
  if (signal.init) {
    if (expr) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Signals can not include both init and update expressions.');
    } else {
      expr = signal.init;
      op.initonly = true;
    }
  }
  if (expr) {
    expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(expr, scope);
    op.update = expr.$expr;
    op.params = expr.$params;
  }
  if (signal.on) {
    signal.on.forEach(_ => parseUpdate(_, scope, op.id));
  }
}

const transform = name => (params, value, parent) => entry(name, value, params || undefined, parent);
const Aggregate = transform('aggregate');
const AxisTicks = transform('axisticks');
const Bound = transform('bound');
const Collect = transform('collect');
const Compare = transform('compare');
const DataJoin = transform('datajoin');
const Encode = transform('encode');
const Expression = transform('expression');
const Facet = transform('facet');
const Field = transform('field');
const Key = transform('key');
const LegendEntries = transform('legendentries');
const Load = transform('load');
const Mark = transform('mark');
const MultiExtent = transform('multiextent');
const MultiValues = transform('multivalues');
const Overlap = transform('overlap');
const Params = transform('params');
const PreFacet = transform('prefacet');
const Projection = transform('projection');
const Proxy = transform('proxy');
const Relay = transform('relay');
const Render = transform('render');
const Scale = transform('scale');
const Sieve = transform('sieve');
const SortItems = transform('sortitems');
const ViewLayout = transform('viewlayout');
const Values = transform('values');

let FIELD_REF_ID = 0;
const MULTIDOMAIN_SORT_OPS = {
  min: 'min',
  max: 'max',
  count: 'sum'
};
function initScale(spec, scope) {
  const type = spec.type || 'linear';
  if (!(0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isValidScaleType)(type)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(type));
  }
  scope.addScale(spec.name, {
    type,
    domain: undefined
  });
}
function parseScale(spec, scope) {
  const params = scope.getScale(spec.name).params;
  let key;
  params.domain = parseScaleDomain(spec.domain, spec, scope);
  if (spec.range != null) {
    params.range = parseScaleRange(spec, scope, params);
  }
  if (spec.interpolate != null) {
    parseScaleInterpolate(spec.interpolate, params);
  }
  if (spec.nice != null) {
    params.nice = parseScaleNice(spec.nice, scope);
  }
  if (spec.bins != null) {
    params.bins = parseScaleBins(spec.bins, scope);
  }
  for (key in spec) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, key) || key === 'name') continue;
    params[key] = parseLiteral(spec[key], scope);
  }
}
function parseLiteral(v, scope) {
  return !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(v) ? v : v.signal ? scope.signalRef(v.signal) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v));
}
function parseArray(v, scope) {
  return v.signal ? scope.signalRef(v.signal) : v.map(v => parseLiteral(v, scope));
}
function dataLookupError(name) {
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Can not find data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}

// -- SCALE DOMAIN ----

function parseScaleDomain(domain, spec, scope) {
  if (!domain) {
    if (spec.domainMin != null || spec.domainMax != null) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No scale domain defined for domainMin/domainMax to override.');
    }
    return; // default domain
  }
  return domain.signal ? scope.signalRef(domain.signal) : ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(domain) ? explicitDomain : domain.fields ? multipleDomain : singularDomain)(domain, spec, scope);
}
function explicitDomain(domain, spec, scope) {
  return domain.map(v => parseLiteral(v, scope));
}
function singularDomain(domain, spec, scope) {
  const data = scope.getData(domain.data);
  if (!data) dataLookupError(domain.data);
  return (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? data.valuesRef(scope, domain.field, parseSort(domain.sort, false)) : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? data.domainRef(scope, domain.field) : data.extentRef(scope, domain.field);
}
function multipleDomain(domain, spec, scope) {
  const data = domain.data,
    fields = domain.fields.reduce((dom, d) => {
      d = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(d) ? {
        data: data,
        field: d
      } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(d) || d.signal ? fieldRef(d, scope) : d;
      dom.push(d);
      return dom;
    }, []);
  return ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? ordinalMultipleDomain : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isQuantile)(spec.type) ? quantileMultipleDomain : numericMultipleDomain)(domain, scope, fields);
}
function fieldRef(data, scope) {
  const name = '_:vega:_' + FIELD_REF_ID++,
    coll = Collect({});
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data)) {
    coll.value = {
      $ingest: data
    };
  } else if (data.signal) {
    const code = 'setdata(' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ',' + data.signal + ')';
    coll.params.input = scope.signalRef(code);
  }
  scope.addDataPipeline(name, [coll, Sieve({})]);
  return {
    data: name,
    field: 'data'
  };
}
function ordinalMultipleDomain(domain, scope, fields) {
  const sort = parseSort(domain.sort, true);
  let a, v;

  // get value counts for each domain field
  const counts = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.countsRef(scope, f.field, sort);
  });

  // aggregate the results from each domain field
  const p = {
    groupby: keyFieldRef,
    pulse: counts
  };
  if (sort) {
    a = sort.op || 'count';
    v = sort.field ? aggrField(a, sort.field) : 'count';
    p.ops = [MULTIDOMAIN_SORT_OPS[a]];
    p.fields = [scope.fieldRef(v)];
    p.as = [v];
  }
  a = scope.add(Aggregate(p));

  // collect aggregate output
  const c = scope.add(Collect({
    pulse: ref(a)
  }));

  // extract values for combined domain
  v = scope.add(Values({
    field: keyFieldRef,
    sort: scope.sortRef(sort),
    pulse: ref(c)
  }));
  return ref(v);
}
function parseSort(sort, multidomain) {
  if (sort) {
    if (!sort.field && !sort.op) {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(sort)) sort.field = 'key';else sort = {
        field: 'key'
      };
    } else if (!sort.field && sort.op !== 'count') {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('No field provided for sort aggregate op: ' + sort.op);
    } else if (multidomain && sort.field) {
      if (sort.op && !MULTIDOMAIN_SORT_OPS[sort.op]) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multiple domain scales can not be sorted using ' + sort.op);
      }
    }
  }
  return sort;
}
function quantileMultipleDomain(domain, scope, fields) {
  // get value arrays for each domain field
  const values = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.domainRef(scope, f.field);
  });

  // combine value arrays
  return ref(scope.add(MultiValues({
    values: values
  })));
}
function numericMultipleDomain(domain, scope, fields) {
  // get extents for each domain field
  const extents = fields.map(f => {
    const data = scope.getData(f.data);
    if (!data) dataLookupError(f.data);
    return data.extentRef(scope, f.field);
  });

  // combine extents
  return ref(scope.add(MultiExtent({
    extents: extents
  })));
}

// -- SCALE BINS -----

function parseScaleBins(v, scope) {
  return v.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray(v, scope) : scope.objectProperty(v);
}

// -- SCALE NICE -----

function parseScaleNice(nice, scope) {
  return nice.signal ? scope.signalRef(nice.signal) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(nice) ? {
    interval: parseLiteral(nice.interval),
    step: parseLiteral(nice.step)
  } : parseLiteral(nice);
}

// -- SCALE INTERPOLATION -----

function parseScaleInterpolate(interpolate, params) {
  params.interpolate = parseLiteral(interpolate.type || interpolate);
  if (interpolate.gamma != null) {
    params.interpolateGamma = parseLiteral(interpolate.gamma);
  }
}

// -- SCALE RANGE -----

function parseScaleRange(spec, scope, params) {
  const config = scope.config.range;
  let range = spec.range;
  if (range.signal) {
    return scope.signalRef(range.signal);
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(range)) {
    if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, range)) {
      spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec, {
        range: config[range]
      });
      return parseScaleRange(spec, scope, params);
    } else if (range === 'width') {
      range = [0, {
        signal: 'width'
      }];
    } else if (range === 'height') {
      range = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) ? [0, {
        signal: 'height'
      }] : [{
        signal: 'height'
      }, 0];
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale range value: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
    }
  } else if (range.scheme) {
    params.scheme = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range.scheme) ? parseArray(range.scheme, scope) : parseLiteral(range.scheme, scope);
    if (range.extent) params.schemeExtent = parseArray(range.extent, scope);
    if (range.count) params.schemeCount = parseLiteral(range.count, scope);
    return;
  } else if (range.step) {
    params.rangeStep = parseLiteral(range.step, scope);
    return;
  } else if ((0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscrete)(spec.type) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    return parseScaleDomain(range, spec, scope);
  } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(range)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported range type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(range));
  }
  return range.map(v => ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? parseArray : parseLiteral)(v, scope));
}

function parseProjection (proj, scope) {
  const config = scope.config.projection || {},
    params = {};
  for (const name in proj) {
    if (name === 'name') continue;
    params[name] = parseParameter$1(proj[name], name, scope);
  }

  // apply projection defaults from config
  for (const name in config) {
    if (params[name] == null) {
      params[name] = parseParameter$1(config[name], name, scope);
    }
  }
  scope.addProjection(proj.name, params);
}
function parseParameter$1(_, name, scope) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.map(_ => parseParameter$1(_, name, scope)) : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? _ : _.signal ? scope.signalRef(_.signal) : name === 'fit' ? _ : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter object: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(_));
}

const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const Center = 'center';
const Vertical = 'vertical';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const Index = 'index';
const Label = 'label';
const Offset = 'offset';
const Perc = 'perc';
const Perc2 = 'perc2';
const Value = 'value';
const GuideLabelStyle = 'guide-label';
const GuideTitleStyle = 'guide-title';
const GroupTitleStyle = 'group-title';
const GroupSubtitleStyle = 'group-subtitle';

/** All values of LegendType */
const Symbols = 'symbol';
const Gradient = 'gradient';
const Discrete = 'discrete';
const Size = 'size';
const Shape = 'shape';
const Fill = 'fill';
const Stroke = 'stroke';
const StrokeWidth = 'strokeWidth';
const StrokeDash = 'strokeDash';
const Opacity = 'opacity';

// Encoding channels supported by legends
// In priority order of 'canonical' scale
const LegendScales = [Size, Shape, Fill, Stroke, StrokeWidth, StrokeDash, Opacity];
const Skip = {
  name: 1,
  style: 1,
  interactive: 1
};
const zero = {
  value: 0
};
const one = {
  value: 1
};

const GroupMark = 'group';
const RectMark = 'rect';
const RuleMark = 'rule';
const SymbolMark = 'symbol';
const TextMark = 'text';

function guideGroup (mark) {
  mark.type = GroupMark;
  mark.interactive = mark.interactive || false;
  return mark;
}

function lookup(spec, config) {
  const _ = (name, dflt) => value(spec[name], value(config[name], dflt));
  _.isVertical = s => Vertical === value(spec.direction, config.direction || (s ? config.symbolDirection : config.gradientDirection));
  _.gradientLength = () => value(spec.gradientLength, config.gradientLength || config.gradientWidth);
  _.gradientThickness = () => value(spec.gradientThickness, config.gradientThickness || config.gradientHeight);
  _.entryColumns = () => value(spec.columns, value(config.columns, +_.isVertical(true)));
  return _;
}
function getEncoding(name, encode) {
  const v = encode && (encode.update && encode.update[name] || encode.enter && encode.enter[name]);
  return v && v.signal ? v : v ? v.value : null;
}
function getStyle(name, scope, style) {
  const s = scope.config.style[style];
  return s && s[name];
}
function anchorExpr(s, e, m) {
  return `item.anchor === '${Start}' ? ${s} : item.anchor === '${End}' ? ${e} : ${m}`;
}
const alignExpr$1 = anchorExpr((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Left), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Right), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(Center));
function tickBand(_) {
  const v = _('tickBand');
  let offset = _('tickOffset'),
    band,
    extra;
  if (!v) {
    // if no tick band entry, fall back on other properties
    band = _('bandPosition');
    extra = _('tickExtra');
  } else if (v.signal) {
    // if signal, augment code to interpret values
    band = {
      signal: `(${v.signal}) === 'extent' ? 1 : 0.5`
    };
    extra = {
      signal: `(${v.signal}) === 'extent'`
    };
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
      offset = {
        signal: `(${v.signal}) === 'extent' ? 0 : ${offset}`
      };
    }
  } else if (v === 'extent') {
    // if constant, simply set values
    band = 1;
    extra = true;
    offset = 0;
  } else {
    band = 0.5;
    extra = false;
  }
  return {
    extra,
    band,
    offset
  };
}
function extendOffset(value, offset) {
  return !offset ? value : !value ? offset : !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? {
    value,
    offset
  } : Object.assign({}, value, {
    offset: extendOffset(value.offset, offset)
  });
}

function guideMark (mark, extras) {
  if (extras) {
    mark.name = extras.name;
    mark.style = extras.style || mark.style;
    mark.interactive = !!extras.interactive;
    mark.encode = extendEncode(mark.encode, extras, Skip);
  } else {
    mark.interactive = false;
  }
  return mark;
}

function legendGradient (spec, scale, config, userEncode) {
  const _ = lookup(spec, config),
    vertical = _.isVertical(),
    thickness = _.gradientThickness(),
    length = _.gradientLength();
  let enter, start, stop, width, height;
  if (vertical) {
    start = [0, 1];
    stop = [0, 0];
    width = thickness;
    height = length;
  } else {
    start = [0, 0];
    stop = [1, 0];
    width = length;
    height = thickness;
  }
  const encode = {
    enter: enter = {
      opacity: zero,
      x: zero,
      y: zero,
      width: encoder(width),
      height: encoder(height)
    },
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      fill: {
        gradient: scale,
        start: start,
        stop: stop
      }
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendGradientRole,
    encode
  }, userEncode);
}

function legendGradientDiscrete (spec, scale, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
    vertical = _.isVertical(),
    thickness = _.gradientThickness(),
    length = _.gradientLength();
  let u,
    v,
    uu,
    vv,
    adjust = '';
  vertical ? (u = 'y', uu = 'y2', v = 'x', vv = 'width', adjust = '1-') : (u = 'x', uu = 'x2', v = 'y', vv = 'height');
  const enter = {
    opacity: zero,
    fill: {
      scale: scale,
      field: Value
    }
  };
  enter[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = zero;
  enter[uu] = {
    signal: adjust + 'datum.' + Perc2,
    mult: length
  };
  enter[vv] = encoder(thickness);
  const encode = {
    enter: enter,
    update: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one
    }),
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gradientStrokeColor'),
    strokeWidth: _('gradientStrokeWidth')
  }, {
    // update
    opacity: _('gradientOpacity')
  });
  return guideMark({
    type: RectMark,
    role: LegendBandRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

const alignExpr = `datum.${Perc}<=0?"${Left}":datum.${Perc}>=1?"${Right}":"${Center}"`,
  baselineExpr = `datum.${Perc}<=0?"${Bottom}":datum.${Perc}>=1?"${Top}":"${Middle}"`;
function legendGradientLabels (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
    vertical = _.isVertical(),
    thickness = encoder(_.gradientThickness()),
    length = _.gradientLength();
  let overlap = _('labelOverlap'),
    enter,
    update,
    u,
    v,
    adjust = '';
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: value(spec.labelLimit, config.gradientLabelLimit)
  });
  if (vertical) {
    enter.align = {
      value: 'left'
    };
    enter.baseline = update.baseline = {
      signal: baselineExpr
    };
    u = 'y';
    v = 'x';
    adjust = '1-';
  } else {
    enter.align = update.align = {
      signal: alignExpr
    };
    enter.baseline = {
      value: 'top'
    };
    u = 'x';
    v = 'y';
  }
  enter[u] = update[u] = {
    signal: adjust + 'datum.' + Perc,
    mult: length
  };
  enter[v] = update[v] = thickness;
  thickness.offset = value(spec.labelOffset, config.gradientLabelOffset) || 0;
  overlap = overlap ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.' + Index
  } : undefined;

  // type, role, style, key, dataRef, encode, extras
  return guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

// userEncode is top-level, includes entries, symbols, labels
function legendSymbolGroups (spec, config, userEncode, dataRef, columns) {
  const _ = lookup(spec, config),
    entries = userEncode.entries,
    interactive = !!(entries && entries.interactive),
    name = entries ? entries.name : undefined,
    height = _('clipHeight'),
    symbolOffset = _('symbolOffset'),
    valueRef = {
      data: 'value'
    },
    xSignal = `(${columns}) ? datum.${Offset} : datum.${Size}`,
    yEncode = height ? encoder(height) : {
      field: Size
    },
    index = `datum.${Index}`,
    ncols = `max(1, ${columns})`;
  let encode, enter, update, nrows, sort;
  yEncode.mult = 0.5;

  // -- LEGEND SYMBOLS --
  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        mult: 0.5,
        offset: symbolOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  let baseFill = null,
    baseStroke = null;
  if (!spec.fill) {
    baseFill = config.symbolBaseFillColor;
    baseStroke = config.symbolBaseStrokeColor;
  }
  addEncoders(encode, {
    fill: _('symbolFillColor', baseFill),
    shape: _('symbolType'),
    size: _('symbolSize'),
    stroke: _('symbolStrokeColor', baseStroke),
    strokeDash: _('symbolDash'),
    strokeDashOffset: _('symbolDashOffset'),
    strokeWidth: _('symbolStrokeWidth')
  }, {
    // update
    opacity: _('symbolOpacity')
  });
  LegendScales.forEach(scale => {
    if (spec[scale]) {
      update[scale] = enter[scale] = {
        scale: spec[scale],
        field: Value
      };
    }
  });
  const symbols = guideMark({
    type: SymbolMark,
    role: LegendSymbolRole,
    key: Value,
    from: valueRef,
    clip: height ? true : undefined,
    encode
  }, userEncode.symbols);

  // -- LEGEND LABELS --
  const labelOffset = encoder(symbolOffset);
  labelOffset.offset = _('labelOffset');
  encode = {
    enter: enter = {
      opacity: zero,
      x: {
        signal: xSignal,
        offset: labelOffset
      },
      y: yEncode
    },
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    align: _('labelAlign'),
    baseline: _('labelBaseline'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontStyle: _('labelFontStyle'),
    fontWeight: _('labelFontWeight'),
    limit: _('labelLimit')
  });
  const labels = guideMark({
    type: TextMark,
    role: LegendLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: valueRef,
    encode
  }, userEncode.labels);

  // -- LEGEND ENTRY GROUPS --
  encode = {
    enter: {
      noBound: {
        value: !height
      },
      // ignore width/height in bounds calc
      width: zero,
      height: height ? encoder(height) : zero,
      opacity: zero
    },
    exit: {
      opacity: zero
    },
    update: update = {
      opacity: one,
      row: {
        signal: null
      },
      column: {
        signal: null
      }
    }
  };

  // annotate and sort groups to ensure correct ordering
  if (_.isVertical(true)) {
    nrows = `ceil(item.mark.items.length / ${ncols})`;
    update.row.signal = `${index}%${nrows}`;
    update.column.signal = `floor(${index} / ${nrows})`;
    sort = {
      field: ['row', index]
    };
  } else {
    update.row.signal = `floor(${index} / ${ncols})`;
    update.column.signal = `${index} % ${ncols}`;
    sort = {
      field: index
    };
  }
  // handle zero column case (implies infinite columns)
  update.column.signal = `(${columns})?${update.column.signal}:${index}`;

  // facet legend entries into sub-groups
  dataRef = {
    facet: {
      data: dataRef,
      name: 'value',
      groupby: Index
    }
  };
  return guideGroup({
    role: ScopeRole,
    from: dataRef,
    encode: extendEncode(encode, entries, Skip),
    marks: [symbols, labels],
    name,
    interactive,
    sort
  });
}
function legendSymbolLayout(spec, config) {
  const _ = lookup(spec, config);

  // layout parameters for legend entries
  return {
    align: _('gridAlign'),
    columns: _.entryColumns(),
    center: {
      row: true,
      column: false
    },
    padding: {
      row: _('rowPadding'),
      column: _('columnPadding')
    }
  };
}

// expression logic for align, anchor, angle, and baseline calculation
const isL = 'item.orient === "left"',
  isR = 'item.orient === "right"',
  isLR = `(${isL} || ${isR})`,
  isVG = `datum.vgrad && ${isLR}`,
  baseline = anchorExpr('"top"', '"bottom"', '"middle"'),
  alignFlip = anchorExpr('"right"', '"left"', '"center"'),
  exprAlign = `datum.vgrad && ${isR} ? (${alignFlip}) : (${isLR} && !(datum.vgrad && ${isL})) ? "left" : ${alignExpr$1}`,
  exprAnchor = `item._anchor || (${isLR} ? "middle" : "start")`,
  exprAngle = `${isVG} ? (${isL} ? -90 : 90) : 0`,
  exprBaseline = `${isLR} ? (datum.vgrad ? (${isR} ? "bottom" : "top") : ${baseline}) : "top"`;
function legendTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config);
  const encode = {
    enter: {
      opacity: zero
    },
    update: {
      opacity: one,
      x: {
        field: {
          group: 'padding'
        }
      },
      y: {
        field: {
          group: 'padding'
        }
      }
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    orient: _('titleOrient'),
    _anchor: _('titleAnchor'),
    anchor: {
      signal: exprAnchor
    },
    angle: {
      signal: exprAngle
    },
    align: {
      signal: exprAlign
    },
    baseline: {
      signal: exprBaseline
    },
    text: spec.title,
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    baseline: _('titleBaseline')
  });
  return guideMark({
    type: TextMark,
    role: LegendTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function clip (clip, scope) {
  let expr;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(clip)) {
    if (clip.signal) {
      expr = clip.signal;
    } else if (clip.path) {
      expr = 'pathShape(' + param(clip.path) + ')';
    } else if (clip.sphere) {
      expr = 'geoShape(' + param(clip.sphere) + ', {type: "Sphere"})';
    }
  }
  return expr ? scope.signalRef(expr) : !!clip;
}
function param(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && value.signal ? value.signal : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value);
}

function getRole (spec) {
  const role = spec.role || '';
  return role.startsWith('axis') || role.startsWith('legend') || role.startsWith('title') ? role : spec.type === GroupMark ? ScopeRole : role || MarkRole;
}

function definition (spec) {
  return {
    marktype: spec.type,
    name: spec.name || undefined,
    role: spec.role || getRole(spec),
    zindex: +spec.zindex || undefined,
    aria: spec.aria,
    description: spec.description
  };
}

function interactive (spec, scope) {
  return spec && spec.signal ? scope.signalRef(spec.signal) : spec === false ? false : true;
}

/**
 * Parse a data transform specification.
 */
function parseTransform (spec, scope) {
  const def = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_4__.definition)(spec.type);
  if (!def) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized transform type: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type));
  const t = entry(def.type.toLowerCase(), null, parseParameters(def, spec, scope));
  if (spec.signal) scope.addSignal(spec.signal, scope.proxy(t));
  t.metadata = def.metadata || {};
  return t;
}

/**
 * Parse all parameters of a data transform.
 */
function parseParameters(def, spec, scope) {
  const params = {},
    n = def.params.length;
  for (let i = 0; i < n; ++i) {
    const pdef = def.params[i];
    params[pdef.name] = parseParameter(pdef, spec, scope);
  }
  return params;
}

/**
 * Parse a data transform parameter.
 */
function parseParameter(def, spec, scope) {
  const type = def.type,
    value = spec[def.name];
  if (type === 'index') {
    return parseIndexParameter(def, spec, scope);
  } else if (value === undefined) {
    if (def.required) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing required ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(spec.type) + ' parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(def.name));
    }
    return;
  } else if (type === 'param') {
    return parseSubParameters(def, spec, scope);
  } else if (type === 'projection') {
    return scope.projectionRef(spec[def.name]);
  }
  return def.array && !isSignal(value) ? value.map(v => parameterValue(def, v, scope)) : parameterValue(def, value, scope);
}

/**
 * Parse a single parameter value.
 */
function parameterValue(def, value, scope) {
  const type = def.type;
  if (isSignal(value)) {
    return isExpr(type) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expression references can not be signals.') : isField(type) ? scope.fieldRef(value) : isCompare(type) ? scope.compareRef(value) : scope.signalRef(value.signal);
  } else {
    const expr = def.expr || isField(type);
    return expr && outerExpr(value) ? scope.exprRef(value.expr, value.as) : expr && outerField(value) ? fieldRef$1(value.field, value.as) : isExpr(type) ? (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(value, scope) : isData(type) ? ref(scope.getData(value).values) : isField(type) ? fieldRef$1(value) : isCompare(type) ? scope.compareRef(value) : value;
  }
}

/**
 * Parse parameter for accessing an index of another data set.
 */
function parseIndexParameter(def, spec, scope) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec.from)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Lookup "from" parameter must be a string literal.');
  }
  return scope.getData(spec.from).lookupRef(scope, spec.key);
}

/**
 * Parse a parameter that contains one or more sub-parameter objects.
 */
function parseSubParameters(def, spec, scope) {
  const value = spec[def.name];
  if (def.array) {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value)) {
      // signals not allowed!
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Expected an array of sub-parameters. Instead: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
    }
    return value.map(v => parseSubParameter(def, v, scope));
  } else {
    return parseSubParameter(def, value, scope);
  }
}

/**
 * Parse a sub-parameter object.
 */
function parseSubParameter(def, value, scope) {
  const n = def.params.length;
  let pdef;

  // loop over defs to find matching key
  for (let i = 0; i < n; ++i) {
    pdef = def.params[i];
    for (const k in pdef.key) {
      if (pdef.key[k] !== value[k]) {
        pdef = null;
        break;
      }
    }
    if (pdef) break;
  }
  // raise error if matching key not found
  if (!pdef) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported parameter: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));

  // parse params, create Params transform, return ref
  const params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(parseParameters(pdef, value, scope), pdef.key);
  return ref(scope.add(Params(params)));
}

// -- Utilities -----

const outerExpr = _ => _ && _.expr;
const outerField = _ => _ && _.field;
const isData = _ => _ === 'data';
const isExpr = _ => _ === 'expr';
const isField = _ => _ === 'field';
const isCompare = _ => _ === 'compare';

function parseData$1 (from, group, scope) {
  let facet, key, op, dataRef, parent;

  // if no source data, generate singleton datum
  if (!from) {
    dataRef = ref(scope.add(Collect(null, [{}])));
  }

  // if faceted, process facet specification
  else if (facet = from.facet) {
    if (!group) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only group marks can be faceted.');

    // use pre-faceted source data, if available
    if (facet.field != null) {
      dataRef = parent = getDataRef(facet, scope);
    } else {
      // generate facet aggregates if no direct data specification
      if (!from.data) {
        op = parseTransform((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
          type: 'aggregate',
          groupby: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(facet.groupby)
        }, facet.aggregate), scope);
        op.params.key = scope.keyRef(facet.groupby);
        op.params.pulse = getDataRef(facet, scope);
        dataRef = parent = ref(scope.add(op));
      } else {
        parent = ref(scope.getData(from.data).aggregate);
      }
      key = scope.keyRef(facet.groupby, true);
    }
  }

  // if not yet defined, get source data reference
  if (!dataRef) {
    dataRef = getDataRef(from, scope);
  }
  return {
    key: key,
    pulse: dataRef,
    parent: parent
  };
}
function getDataRef(from, scope) {
  return from.$ref ? from : from.data && from.data.$ref ? from.data : ref(scope.getData(from.data).output);
}

function DataScope(scope, input, output, values, aggr) {
  this.scope = scope; // parent scope object
  this.input = input; // first operator in pipeline (tuple input)
  this.output = output; // last operator in pipeline (tuple output)
  this.values = values; // operator for accessing tuples (but not tuple flow)

  // last aggregate in transform pipeline
  this.aggregate = aggr;

  // lookup table of field indices
  this.index = {};
}
DataScope.fromEntries = function (scope, entries) {
  const n = entries.length,
    values = entries[n - 1],
    output = entries[n - 2];
  let input = entries[0],
    aggr = null,
    i = 1;
  if (input && input.type === 'load') {
    input = entries[1];
  }

  // add operator entries to this scope, wire up pulse chain
  scope.add(entries[0]);
  for (; i < n; ++i) {
    entries[i].params.pulse = ref(entries[i - 1]);
    scope.add(entries[i]);
    if (entries[i].type === 'aggregate') aggr = entries[i];
  }
  return new DataScope(scope, input, output, values, aggr);
};
function fieldKey(field) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field) ? field : null;
}
function addSortField(scope, p, sort) {
  const as = aggrField(sort.op, sort.field);
  let s;
  if (p.ops) {
    for (let i = 0, n = p.as.length; i < n; ++i) {
      if (p.as[i] === as) return;
    }
  } else {
    p.ops = ['count'];
    p.fields = [null];
    p.as = ['count'];
  }
  if (sort.op) {
    p.ops.push((s = sort.op.signal) ? scope.signalRef(s) : sort.op);
    p.fields.push(scope.fieldRef(sort.field));
    p.as.push(as);
  }
}
function cache(scope, ds, name, optype, field, counts, index) {
  const cache = ds[name] || (ds[name] = {}),
    sort = sortKey(counts);
  let k = fieldKey(field),
    v,
    op;
  if (k != null) {
    scope = ds.scope;
    k = k + (sort ? '|' + sort : '');
    v = cache[k];
  }
  if (!v) {
    const params = counts ? {
      field: keyFieldRef,
      pulse: ds.countsRef(scope, field, counts)
    } : {
      field: scope.fieldRef(field),
      pulse: ref(ds.output)
    };
    if (sort) params.sort = scope.sortRef(counts);
    op = scope.add(entry(optype, undefined, params));
    if (index) ds.index[field] = op;
    v = ref(op);
    if (k != null) cache[k] = v;
  }
  return v;
}
DataScope.prototype = {
  countsRef(scope, field, sort) {
    const ds = this,
      cache = ds.counts || (ds.counts = {}),
      k = fieldKey(field);
    let v, a, p;
    if (k != null) {
      scope = ds.scope;
      v = cache[k];
    }
    if (!v) {
      p = {
        groupby: scope.fieldRef(field, 'key'),
        pulse: ref(ds.output)
      };
      if (sort && sort.field) addSortField(scope, p, sort);
      a = scope.add(Aggregate(p));
      v = scope.add(Collect({
        pulse: ref(a)
      }));
      v = {
        agg: a,
        ref: ref(v)
      };
      if (k != null) cache[k] = v;
    } else if (sort && sort.field) {
      addSortField(scope, v.agg.params, sort);
    }
    return v.ref;
  },
  tuplesRef() {
    return ref(this.values);
  },
  extentRef(scope, field) {
    return cache(scope, this, 'extent', 'extent', field, false);
  },
  domainRef(scope, field) {
    return cache(scope, this, 'domain', 'values', field, false);
  },
  valuesRef(scope, field, sort) {
    return cache(scope, this, 'vals', 'values', field, sort || true);
  },
  lookupRef(scope, field) {
    return cache(scope, this, 'lookup', 'tupleindex', field, false);
  },
  indataRef(scope, field) {
    return cache(scope, this, 'indata', 'tupleindex', field, true, true);
  }
};

function parseFacet (spec, scope, group) {
  const facet = spec.from.facet,
    name = facet.name,
    data = getDataRef(facet, scope);
  let op;
  if (!facet.name) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must have a name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }
  if (!facet.data) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must reference a data set: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }
  if (facet.field) {
    op = scope.add(PreFacet({
      field: scope.fieldRef(facet.field),
      pulse: data
    }));
  } else if (facet.groupby) {
    op = scope.add(Facet({
      key: scope.keyRef(facet.groupby),
      group: ref(scope.proxy(group.parent)),
      pulse: data
    }));
  } else {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Facet must specify groupby or field: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(facet));
  }

  // initialize facet subscope
  const subscope = scope.fork(),
    source = subscope.add(Collect()),
    values = subscope.add(Sieve({
      pulse: ref(source)
    }));
  subscope.addData(name, new DataScope(subscope, source, source, values));
  subscope.addSignal('parent', null);

  // parse faceted subflow
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseSubflow (spec, scope, input) {
  const op = scope.add(PreFacet({
      pulse: input.pulse
    })),
    subscope = scope.fork();
  subscope.add(Sieve());
  subscope.addSignal('parent', null);

  // parse group mark subflow
  op.params.subflow = {
    $subflow: subscope.parse(spec).toRuntime()
  };
}

function parseTrigger (spec, scope, name) {
  const remove = spec.remove,
    insert = spec.insert,
    toggle = spec.toggle,
    modify = spec.modify,
    values = spec.values,
    op = scope.add(operator());
  const update = 'if(' + spec.trigger + ',modify("' + name + '",' + [insert, remove, toggle, modify, values].map(_ => _ == null ? 'null' : _).join(',') + '),0)';
  const expr = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(update, scope);
  op.update = expr.$expr;
  op.params = expr.$params;
}

function parseMark (spec, scope) {
  const role = getRole(spec),
    group = spec.type === GroupMark,
    facet = spec.from && spec.from.facet,
    overlap = spec.overlap;
  let layout = spec.layout || role === ScopeRole || role === FrameRole,
    ops,
    op,
    store,
    enc,
    name,
    layoutRef,
    boundRef;
  const nested = role === MarkRole || layout || facet;

  // resolve input data
  const input = parseData$1(spec.from, group, scope);

  // data join to map tuples to visual items
  op = scope.add(DataJoin({
    key: input.key || (spec.key ? fieldRef$1(spec.key) : undefined),
    pulse: input.pulse,
    clean: !group
  }));
  const joinRef = ref(op);

  // collect visual items
  op = store = scope.add(Collect({
    pulse: joinRef
  }));

  // connect visual items to scenegraph
  op = scope.add(Mark({
    markdef: definition(spec),
    interactive: interactive(spec.interactive, scope),
    clip: clip(spec.clip, scope),
    context: {
      $context: true
    },
    groups: scope.lookup(),
    parent: scope.signals.parent ? scope.signalRef('parent') : null,
    index: scope.markpath(),
    pulse: ref(op)
  }));
  const markRef = ref(op);

  // add visual encoders
  op = enc = scope.add(Encode(parseEncode(spec.encode, spec.type, role, spec.style, scope, {
    mod: false,
    pulse: markRef
  })));

  // monitor parent marks to propagate changes
  op.params.parent = scope.encode();

  // add post-encoding transforms, if defined
  if (spec.transform) {
    spec.transform.forEach(_ => {
      const tx = parseTransform(_, scope),
        md = tx.metadata;
      if (md.generates || md.changes) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Mark transforms should not generate new data.');
      }
      if (!md.nomod) enc.params.mod = true; // update encode mod handling
      tx.params.pulse = ref(op);
      scope.add(op = tx);
    });
  }

  // if item sort specified, perform post-encoding
  if (spec.sort) {
    op = scope.add(SortItems({
      sort: scope.compareRef(spec.sort),
      pulse: ref(op)
    }));
  }
  const encodeRef = ref(op);

  // add view layout operator if needed
  if (facet || layout) {
    layout = scope.add(ViewLayout({
      layout: scope.objectProperty(spec.layout),
      legends: scope.legends,
      mark: markRef,
      pulse: encodeRef
    }));
    layoutRef = ref(layout);
  }

  // compute bounding boxes
  const bound = scope.add(Bound({
    mark: markRef,
    pulse: layoutRef || encodeRef
  }));
  boundRef = ref(bound);

  // if group mark, recurse to parse nested content
  if (group) {
    // juggle layout & bounds to ensure they run *after* any faceting transforms
    if (nested) {
      ops = scope.operators;
      ops.pop();
      if (layout) ops.pop();
    }
    scope.pushState(encodeRef, layoutRef || boundRef, joinRef);
    facet ? parseFacet(spec, scope, input) // explicit facet
    : nested ? parseSubflow(spec, scope, input) // standard mark group
    : scope.parse(spec); // guide group, we can avoid nested scopes
    scope.popState();
    if (nested) {
      if (layout) ops.push(layout);
      ops.push(bound);
    }
  }

  // if requested, add overlap removal transform
  if (overlap) {
    boundRef = parseOverlap(overlap, boundRef, scope);
  }

  // render / sieve items
  const render = scope.add(Render({
      pulse: boundRef
    })),
    sieve = scope.add(Sieve({
      pulse: ref(render)
    }, undefined, scope.parent()));

  // if mark is named, make accessible as reactive geometry
  // add trigger updates if defined
  if (spec.name != null) {
    name = spec.name;
    scope.addData(name, new DataScope(scope, store, render, sieve));
    if (spec.on) spec.on.forEach(on => {
      if (on.insert || on.remove || on.toggle) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Marks only support modify triggers.');
      }
      parseTrigger(on, scope, name);
    });
  }
}
function parseOverlap(overlap, source, scope) {
  const method = overlap.method,
    bound = overlap.bound,
    sep = overlap.separation;
  const params = {
    separation: isSignal(sep) ? scope.signalRef(sep.signal) : sep,
    method: isSignal(method) ? scope.signalRef(method.signal) : method,
    pulse: source
  };
  if (overlap.order) {
    params.sort = scope.compareRef({
      field: overlap.order
    });
  }
  if (bound) {
    const tol = bound.tolerance;
    params.boundTolerance = isSignal(tol) ? scope.signalRef(tol.signal) : +tol;
    params.boundScale = scope.scaleRef(bound.scale);
    params.boundOrient = bound.orient;
  }
  return ref(scope.add(Overlap(params)));
}

function parseLegend (spec, scope) {
  const config = scope.config.legend,
    encode = spec.encode || {},
    _ = lookup(spec, config),
    legendEncode = encode.legend || {},
    name = legendEncode.name || undefined,
    interactive = legendEncode.interactive,
    style = legendEncode.style,
    scales = {};
  let scale = 0,
    entryLayout,
    params,
    children;

  // resolve scales and 'canonical' scale name
  LegendScales.forEach(s => spec[s] ? (scales[s] = spec[s], scale = scale || spec[s]) : 0);
  if (!scale) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing valid scale for legend.');

  // resolve legend type (symbol, gradient, or discrete gradient)
  const type = legendType(spec, scope.scaleType(scale));

  // single-element data source for legend group
  const datum = {
    title: spec.title != null,
    scales: scales,
    type: type,
    vgrad: type !== 'symbol' && _.isVertical()
  };
  const dataRef = ref(scope.add(Collect(null, [datum])));

  // encoding properties for legend entry sub-group
  const entryEncode = {
    enter: {
      x: {
        value: 0
      },
      y: {
        value: 0
      }
    }
  };

  // data source for legend values
  const entryRef = ref(scope.add(LegendEntries(params = {
    type: type,
    scale: scope.scaleRef(scale),
    count: scope.objectProperty(_('tickCount')),
    limit: scope.property(_('symbolLimit')),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));

  // continuous gradient legend
  if (type === Gradient) {
    children = [legendGradient(spec, scale, config, encode.gradient), legendGradientLabels(spec, config, encode.labels, entryRef)];
    // adjust default tick count based on the gradient length
    params.count = params.count || scope.signalRef(`max(2,2*floor((${deref(_.gradientLength())})/100))`);
  }

  // discrete gradient legend
  else if (type === Discrete) {
    children = [legendGradientDiscrete(spec, scale, config, encode.gradient, entryRef), legendGradientLabels(spec, config, encode.labels, entryRef)];
  }

  // symbol legend
  else {
    // determine legend symbol group layout
    entryLayout = legendSymbolLayout(spec, config);
    children = [legendSymbolGroups(spec, config, encode, entryRef, deref(entryLayout.columns))];
    // pass symbol size information to legend entry generator
    params.size = sizeExpression(spec, scope, children[0].marks);
  }

  // generate legend marks
  children = [guideGroup({
    role: LegendEntryRole,
    from: dataRef,
    encode: entryEncode,
    marks: children,
    layout: entryLayout,
    interactive
  })];

  // include legend title if defined
  if (datum.title) {
    children.push(legendTitle(spec, config, encode.title, dataRef));
  }

  // parse legend specification
  return parseMark(guideGroup({
    role: LegendRole,
    from: dataRef,
    encode: extendEncode(buildLegendEncode(_, spec, config), legendEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}
function legendType(spec, scaleType) {
  let type = spec.type || Symbols;
  if (!spec.type && scaleCount(spec) === 1 && (spec.fill || spec.stroke)) {
    type = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isContinuous)(scaleType) ? Gradient : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Symbols;
  }
  return type !== Gradient ? type : (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.isDiscretizing)(scaleType) ? Discrete : Gradient;
}
function scaleCount(spec) {
  return LegendScales.reduce((count, type) => count + (spec[type] ? 1 : 0), 0);
}
function buildLegendEncode(_, spec, config) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset'),
    padding: _('padding'),
    titlePadding: _('titlePadding'),
    cornerRadius: _('cornerRadius'),
    fill: _('fillColor'),
    stroke: _('strokeColor'),
    strokeWidth: config.strokeWidth,
    strokeDash: config.strokeDash,
    x: _('legendX'),
    y: _('legendY'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}
function sizeExpression(spec, scope, marks) {
  const size = deref(getChannel('size', spec, marks)),
    strokeWidth = deref(getChannel('strokeWidth', spec, marks)),
    fontSize = deref(getFontSize(marks[1].encode, scope, GuideLabelStyle));
  return (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(`max(ceil(sqrt(${size})+${strokeWidth}),${fontSize})`, scope);
}
function getChannel(name, spec, marks) {
  return spec[name] ? `scale("${spec[name]}",datum)` : getEncoding(name, marks[0].encode);
}
function getFontSize(encode, scope, style) {
  return getEncoding('fontSize', encode) || getStyle('fontSize', scope, style);
}

const angleExpr = `item.orient==="${Left}"?-90:item.orient==="${Right}"?90:0`;
function parseTitle (spec, scope) {
  spec = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(spec) ? {
    text: spec
  } : spec;
  const _ = lookup(spec, scope.config.title),
    encode = spec.encode || {},
    userEncode = encode.group || {},
    name = userEncode.name || undefined,
    interactive = userEncode.interactive,
    style = userEncode.style,
    children = [];

  // single-element data source for group title
  const datum = {},
    dataRef = ref(scope.add(Collect(null, [datum])));

  // include title text
  children.push(buildTitle(spec, _, titleEncode(spec), dataRef));

  // include subtitle text
  if (spec.subtitle) {
    children.push(buildSubTitle(spec, _, encode.subtitle, dataRef));
  }

  // parse title specification
  return parseMark(guideGroup({
    role: TitleRole,
    from: dataRef,
    encode: groupEncode(_, userEncode),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}

// provide backwards-compatibility for title custom encode;
// the top-level encode block has been *deprecated*.
function titleEncode(spec) {
  const encode = spec.encode;
  return encode && encode.title || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: spec.name,
    interactive: spec.interactive,
    style: spec.style
  }, encode);
}
function groupEncode(_, userEncode) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    anchor: _('anchor'),
    align: {
      signal: alignExpr$1
    },
    angle: {
      signal: angleExpr
    },
    limit: _('limit'),
    frame: _('frame'),
    offset: _('offset') || 0,
    padding: _('subtitlePadding')
  });
  return extendEncode(encode, userEncode, Skip);
}
function buildTitle(spec, _, userEncode, dataRef) {
  const zero = {
      value: 0
    },
    text = spec.text,
    encode = {
      enter: {
        opacity: zero
      },
      update: {
        opacity: {
          value: 1
        }
      },
      exit: {
        opacity: zero
      }
    };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('color'),
    font: _('font'),
    fontSize: _('fontSize'),
    fontStyle: _('fontStyle'),
    fontWeight: _('fontWeight'),
    lineHeight: _('lineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleTextRole,
    style: GroupTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}
function buildSubTitle(spec, _, userEncode, dataRef) {
  const zero = {
      value: 0
    },
    text = spec.subtitle,
    encode = {
      enter: {
        opacity: zero
      },
      update: {
        opacity: {
          value: 1
        }
      },
      exit: {
        opacity: zero
      }
    };
  addEncoders(encode, {
    text: text,
    align: {
      signal: 'item.mark.group.align'
    },
    angle: {
      signal: 'item.mark.group.angle'
    },
    limit: {
      signal: 'item.mark.group.limit'
    },
    baseline: 'top',
    dx: _('dx'),
    dy: _('dy'),
    fill: _('subtitleColor'),
    font: _('subtitleFont'),
    fontSize: _('subtitleFontSize'),
    fontStyle: _('subtitleFontStyle'),
    fontWeight: _('subtitleFontWeight'),
    lineHeight: _('subtitleLineHeight')
  }, {
    // update
    align: _('align'),
    angle: _('angle'),
    baseline: _('baseline')
  });
  return guideMark({
    type: TextMark,
    role: TitleSubtitleRole,
    style: GroupSubtitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}

function parseData(data, scope) {
  const transforms = [];
  if (data.transform) {
    data.transform.forEach(tx => {
      transforms.push(parseTransform(tx, scope));
    });
  }
  if (data.on) {
    data.on.forEach(on => {
      parseTrigger(on, scope, data.name);
    });
  }
  scope.addDataPipeline(data.name, analyze(data, scope, transforms));
}

/**
 * Analyze a data pipeline, add needed operators.
 */
function analyze(data, scope, ops) {
  const output = [];
  let source = null,
    modify = false,
    generate = false,
    upstream,
    i,
    n,
    t,
    m;
  if (data.values) {
    // hard-wired input data set
    if (isSignal(data.values) || hasSignal(data.format)) {
      // if either values is signal or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, ingest upon dataflow init
      output.push(source = collect({
        $ingest: data.values,
        $format: data.format
      }));
    }
  } else if (data.url) {
    // load data from external source
    if (hasSignal(data.url) || hasSignal(data.format)) {
      // if either url or format has signal, use dynamic loader
      output.push(load(scope, data));
      output.push(source = collect());
    } else {
      // otherwise, request load upon dataflow init
      output.push(source = collect({
        $request: data.url,
        $format: data.format
      }));
    }
  } else if (data.source) {
    // derives from one or more other data sets
    source = upstream = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(data.source).map(d => ref(scope.getData(d).output));
    output.push(null); // populate later
  }

  // scan data transforms, add collectors as needed
  for (i = 0, n = ops.length; i < n; ++i) {
    t = ops[i];
    m = t.metadata;
    if (!source && !m.source) {
      output.push(source = collect());
    }
    output.push(t);
    if (m.generates) generate = true;
    if (m.modifies && !generate) modify = true;
    if (m.source) source = t;else if (m.changes) source = null;
  }
  if (upstream) {
    n = upstream.length - 1;
    output[0] = Relay({
      derive: modify,
      pulse: n ? upstream : upstream[0]
    });
    if (modify || n) {
      // collect derived and multi-pulse tuples
      output.splice(1, 0, collect());
    }
  }
  if (!source) output.push(collect());
  output.push(Sieve({}));
  return output;
}
function collect(values) {
  const s = Collect({}, values);
  s.metadata = {
    source: true
  };
  return s;
}
function load(scope, data) {
  return Load({
    url: data.url ? scope.property(data.url) : undefined,
    async: data.async ? scope.property(data.async) : undefined,
    values: data.values ? scope.property(data.values) : undefined,
    format: scope.objectProperty(data.format)
  });
}

const isX = orient => orient === Bottom || orient === Top;

// get sign coefficient based on axis orient
const getSign = (orient, a, b) => isSignal(orient) ? ifLeftTopExpr(orient.signal, a, b) : orient === Left || orient === Top ? a : b;

// condition on axis x-direction
const ifX = (orient, a, b) => isSignal(orient) ? ifXEnc(orient.signal, a, b) : isX(orient) ? a : b;

// condition on axis y-direction
const ifY = (orient, a, b) => isSignal(orient) ? ifYEnc(orient.signal, a, b) : isX(orient) ? b : a;
const ifTop = (orient, a, b) => isSignal(orient) ? ifTopExpr(orient.signal, a, b) : orient === Top ? {
  value: a
} : {
  value: b
};
const ifRight = (orient, a, b) => isSignal(orient) ? ifRightExpr(orient.signal, a, b) : orient === Right ? {
  value: a
} : {
  value: b
};
const ifXEnc = ($orient, a, b) => ifEnc(`${$orient} === '${Top}' || ${$orient} === '${Bottom}'`, a, b);
const ifYEnc = ($orient, a, b) => ifEnc(`${$orient} !== '${Top}' && ${$orient} !== '${Bottom}'`, a, b);
const ifLeftTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Left}' || ${$orient} === '${Top}'`, a, b);
const ifTopExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Top}'`, a, b);
const ifRightExpr = ($orient, a, b) => ifExpr(`${$orient} === '${Right}'`, a, b);
const ifEnc = (test, a, b) => {
  // ensure inputs are encoder objects (or null)
  a = a != null ? encoder(a) : a;
  b = b != null ? encoder(b) : b;
  if (isSimple(a) && isSimple(b)) {
    // if possible generate simple signal expression
    a = a ? a.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(a.value) : null;
    b = b ? b.signal || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(b.value) : null;
    return {
      signal: `${test} ? (${a}) : (${b})`
    };
  } else {
    // otherwise generate rule set
    return [(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      test
    }, a)].concat(b || []);
  }
};
const isSimple = enc => enc == null || Object.keys(enc).length === 1;
const ifExpr = (test, a, b) => ({
  signal: `${test} ? (${toExpr(a)}) : (${toExpr(b)})`
});
const ifOrient = ($orient, t, b, l, r) => ({
  signal: (l != null ? `${$orient} === '${Left}' ? (${toExpr(l)}) : ` : '') + (b != null ? `${$orient} === '${Bottom}' ? (${toExpr(b)}) : ` : '') + (r != null ? `${$orient} === '${Right}' ? (${toExpr(r)}) : ` : '') + (t != null ? `${$orient} === '${Top}' ? (${toExpr(t)}) : ` : '') + '(null)'
});
const toExpr = v => isSignal(v) ? v.signal : v == null ? null : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(v);
const mult = (sign, value) => value === 0 ? 0 : isSignal(sign) ? {
  signal: `(${sign.signal}) * ${value}`
} : {
  value: sign * value
};
const patch = (value, base) => {
  const s = value.signal;
  return s && s.endsWith('(null)') ? {
    signal: s.slice(0, -6) + base.signal
  } : value;
};

function fallback(prop, config, axisConfig, style) {
  let styleProp;
  if (config && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(config, prop)) {
    return config[prop];
  } else if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(axisConfig, prop)) {
    return axisConfig[prop];
  } else if (prop.startsWith('title')) {
    switch (prop) {
      case 'titleColor':
        styleProp = 'fill';
        break;
      case 'titleFont':
      case 'titleFontSize':
      case 'titleFontWeight':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style[GuideTitleStyle][styleProp];
  } else if (prop.startsWith('label')) {
    switch (prop) {
      case 'labelColor':
        styleProp = 'fill';
        break;
      case 'labelFont':
      case 'labelFontSize':
        styleProp = prop[5].toLowerCase() + prop.slice(6);
    }
    return style[GuideLabelStyle][styleProp];
  }
  return null;
}
function keys(objects) {
  const map = {};
  for (const obj of objects) {
    if (!obj) continue;
    for (const key in obj) map[key] = 1;
  }
  return Object.keys(map);
}
function axisConfig (spec, scope) {
  var config = scope.config,
    style = config.style,
    axis = config.axis,
    band = scope.scaleType(spec.scale) === 'band' && config.axisBand,
    orient = spec.orient,
    xy,
    or,
    key;
  if (isSignal(orient)) {
    const xyKeys = keys([config.axisX, config.axisY]),
      orientKeys = keys([config.axisTop, config.axisBottom, config.axisLeft, config.axisRight]);
    xy = {};
    for (key of xyKeys) {
      xy[key] = ifX(orient, fallback(key, config.axisX, axis, style), fallback(key, config.axisY, axis, style));
    }
    or = {};
    for (key of orientKeys) {
      or[key] = ifOrient(orient.signal, fallback(key, config.axisTop, axis, style), fallback(key, config.axisBottom, axis, style), fallback(key, config.axisLeft, axis, style), fallback(key, config.axisRight, axis, style));
    }
  } else {
    xy = orient === Top || orient === Bottom ? config.axisX : config.axisY;
    or = config['axis' + orient[0].toUpperCase() + orient.slice(1)];
  }
  const result = xy || or || band ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, axis, xy, or, band) : axis;
  return result;
}

function axisDomain (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
    orient = spec.orient;
  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('domainColor'),
    strokeCap: _('domainCap'),
    strokeDash: _('domainDash'),
    strokeDashOffset: _('domainDashOffset'),
    strokeWidth: _('domainWidth'),
    strokeOpacity: _('domainOpacity')
  });
  const pos0 = position(spec, 0);
  const pos1 = position(spec, 1);
  enter.x = update.x = ifX(orient, pos0, zero);
  enter.x2 = update.x2 = ifX(orient, pos1);
  enter.y = update.y = ifY(orient, pos0, zero);
  enter.y2 = update.y2 = ifY(orient, pos1);
  return guideMark({
    type: RuleMark,
    role: AxisDomainRole,
    from: dataRef,
    encode
  }, userEncode);
}
function position(spec, pos) {
  return {
    scale: spec.scale,
    range: pos
  };
}

function axisGrid (spec, config, userEncode, dataRef, band) {
  const _ = lookup(spec, config),
    orient = spec.orient,
    vscale = spec.gridScale,
    sign = getSign(orient, 1, -1),
    offset = offsetValue(spec.offset, sign);
  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('gridColor'),
    strokeCap: _('gridCap'),
    strokeDash: _('gridDash'),
    strokeDashOffset: _('gridDashOffset'),
    strokeOpacity: _('gridOpacity'),
    strokeWidth: _('gridWidth')
  });
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  const sz = ifX(orient, {
    signal: 'height'
  }, {
    signal: 'width'
  });
  const gridStart = vscale ? {
    scale: vscale,
    range: 0,
    mult: sign,
    offset: offset
  } : {
    value: 0,
    offset: offset
  };
  const gridEnd = vscale ? {
    scale: vscale,
    range: 1,
    mult: sign,
    offset: offset
  } : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(sz, {
    mult: sign,
    offset: offset
  });
  enter.x = update.x = ifX(orient, tickPos, gridStart);
  enter.y = update.y = ifY(orient, tickPos, gridStart);
  enter.x2 = update.x2 = ifY(orient, gridEnd);
  enter.y2 = update.y2 = ifX(orient, gridEnd);
  exit.x = ifX(orient, tickPos);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisGridRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}
function offsetValue(offset, sign) {
  if (sign === 1) ; else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(offset)) {
    offset = isSignal(sign) ? {
      signal: `(${sign.signal}) * (${offset || 0})`
    } : sign * (offset || 0);
  } else {
    let entry = offset = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, offset);
    while (entry.mult != null) {
      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(entry.mult)) {
        entry.mult = isSignal(sign) // no offset if sign === 1
        ? {
          signal: `(${entry.mult}) * (${sign.signal})`
        } : entry.mult * sign;
        return offset;
      } else {
        entry = entry.mult = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, entry.mult);
      }
    }
    entry.mult = sign;
  }
  return offset;
}

function axisTicks (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
    orient = spec.orient,
    sign = getSign(orient, -1, 1);
  let enter, exit, update;
  const encode = {
    enter: enter = {
      opacity: zero
    },
    update: update = {
      opacity: one
    },
    exit: exit = {
      opacity: zero
    }
  };
  addEncoders(encode, {
    stroke: _('tickColor'),
    strokeCap: _('tickCap'),
    strokeDash: _('tickDash'),
    strokeDashOffset: _('tickDashOffset'),
    strokeOpacity: _('tickOpacity'),
    strokeWidth: _('tickWidth')
  });
  const tickSize = encoder(size);
  tickSize.mult = sign;
  const tickPos = {
    scale: spec.scale,
    field: Value,
    band: band.band,
    extra: band.extra,
    offset: band.offset,
    round: _('tickRound')
  };
  update.y = enter.y = ifX(orient, zero, tickPos);
  update.y2 = enter.y2 = ifX(orient, tickSize);
  exit.x = ifX(orient, tickPos);
  update.x = enter.x = ifY(orient, zero, tickPos);
  update.x2 = enter.x2 = ifY(orient, tickSize);
  exit.y = ifY(orient, tickPos);
  return guideMark({
    type: RuleMark,
    role: AxisTickRole,
    key: Value,
    from: dataRef,
    encode
  }, userEncode);
}

function flushExpr(scale, threshold, a, b, c) {
  return {
    signal: 'flush(range("' + scale + '"), ' + 'scale("' + scale + '", datum.value), ' + threshold + ',' + a + ',' + b + ',' + c + ')'
  };
}
function axisLabels (spec, config, userEncode, dataRef, size, band) {
  const _ = lookup(spec, config),
    orient = spec.orient,
    scale = spec.scale,
    sign = getSign(orient, -1, 1),
    flush = deref(_('labelFlush')),
    flushOffset = deref(_('labelFlushOffset')),
    labelAlign = _('labelAlign'),
    labelBaseline = _('labelBaseline');
  let flushOn = flush === 0 || !!flush,
    update;
  const tickSize = encoder(size);
  tickSize.mult = sign;
  tickSize.offset = encoder(_('labelPadding') || 0);
  tickSize.offset.mult = sign;
  const tickPos = {
    scale: scale,
    field: Value,
    band: 0.5,
    offset: extendOffset(band.offset, _('labelOffset'))
  };
  const align = ifX(orient, flushOn ? flushExpr(scale, flush, '"left"', '"right"', '"center"') : {
    value: 'center'
  }, ifRight(orient, 'left', 'right'));
  const baseline = ifX(orient, ifTop(orient, 'bottom', 'top'), flushOn ? flushExpr(scale, flush, '"top"', '"bottom"', '"middle"') : {
    value: 'middle'
  });
  const offsetExpr = flushExpr(scale, flush, `-(${flushOffset})`, flushOffset, 0);
  flushOn = flushOn && flushOffset;
  const enter = {
    opacity: zero,
    x: ifX(orient, tickPos, tickSize),
    y: ifY(orient, tickPos, tickSize)
  };
  const encode = {
    enter: enter,
    update: update = {
      opacity: one,
      text: {
        field: Label
      },
      x: enter.x,
      y: enter.y,
      align,
      baseline
    },
    exit: {
      opacity: zero,
      x: enter.x,
      y: enter.y
    }
  };
  addEncoders(encode, {
    dx: !labelAlign && flushOn ? ifX(orient, offsetExpr) : null,
    dy: !labelBaseline && flushOn ? ifY(orient, offsetExpr) : null
  });
  addEncoders(encode, {
    angle: _('labelAngle'),
    fill: _('labelColor'),
    fillOpacity: _('labelOpacity'),
    font: _('labelFont'),
    fontSize: _('labelFontSize'),
    fontWeight: _('labelFontWeight'),
    fontStyle: _('labelFontStyle'),
    limit: _('labelLimit'),
    lineHeight: _('labelLineHeight')
  }, {
    align: labelAlign,
    baseline: labelBaseline
  });
  const bound = _('labelBound');
  let overlap = _('labelOverlap');

  // if overlap method or bound defined, request label overlap removal
  overlap = overlap || bound ? {
    separation: _('labelSeparation'),
    method: overlap,
    order: 'datum.index',
    bound: bound ? {
      scale,
      orient,
      tolerance: bound
    } : null
  } : undefined;
  if (update.align !== align) {
    update.align = patch(update.align, align);
  }
  if (update.baseline !== baseline) {
    update.baseline = patch(update.baseline, baseline);
  }
  return guideMark({
    type: TextMark,
    role: AxisLabelRole,
    style: GuideLabelStyle,
    key: Value,
    from: dataRef,
    encode,
    overlap
  }, userEncode);
}

function axisTitle (spec, config, userEncode, dataRef) {
  const _ = lookup(spec, config),
    orient = spec.orient,
    sign = getSign(orient, -1, 1);
  let enter, update;
  const encode = {
    enter: enter = {
      opacity: zero,
      anchor: encoder(_('titleAnchor', null)),
      align: {
        signal: alignExpr$1
      }
    },
    update: update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, enter, {
      opacity: one,
      text: encoder(spec.title)
    }),
    exit: {
      opacity: zero
    }
  };
  const titlePos = {
    signal: `lerp(range("${spec.scale}"), ${anchorExpr(0, 1, 0.5)})`
  };
  update.x = ifX(orient, titlePos);
  update.y = ifY(orient, titlePos);
  enter.angle = ifX(orient, zero, mult(sign, 90));
  enter.baseline = ifX(orient, ifTop(orient, Bottom, Top), {
    value: Bottom
  });
  update.angle = enter.angle;
  update.baseline = enter.baseline;
  addEncoders(encode, {
    fill: _('titleColor'),
    fillOpacity: _('titleOpacity'),
    font: _('titleFont'),
    fontSize: _('titleFontSize'),
    fontStyle: _('titleFontStyle'),
    fontWeight: _('titleFontWeight'),
    limit: _('titleLimit'),
    lineHeight: _('titleLineHeight')
  }, {
    // require update
    align: _('titleAlign'),
    angle: _('titleAngle'),
    baseline: _('titleBaseline')
  });
  autoLayout(_, orient, encode, userEncode);
  encode.update.align = patch(encode.update.align, enter.align);
  encode.update.angle = patch(encode.update.angle, enter.angle);
  encode.update.baseline = patch(encode.update.baseline, enter.baseline);
  return guideMark({
    type: TextMark,
    role: AxisTitleRole,
    style: GuideTitleStyle,
    from: dataRef,
    encode
  }, userEncode);
}
function autoLayout(_, orient, encode, userEncode) {
  const auto = (value, dim) => value != null ? (encode.update[dim] = patch(encoder(value), encode.update[dim]), false) : !has(dim, userEncode) ? true : false;
  const autoY = auto(_('titleX'), 'x'),
    autoX = auto(_('titleY'), 'y');
  encode.enter.auto = autoX === autoY ? encoder(autoX) : ifX(orient, encoder(autoX), encoder(autoY));
}

function parseAxis (spec, scope) {
  const config = axisConfig(spec, scope),
    encode = spec.encode || {},
    axisEncode = encode.axis || {},
    name = axisEncode.name || undefined,
    interactive = axisEncode.interactive,
    style = axisEncode.style,
    _ = lookup(spec, config),
    band = tickBand(_);

  // single-element data source for axis group
  const datum = {
    scale: spec.scale,
    ticks: !!_('ticks'),
    labels: !!_('labels'),
    grid: !!_('grid'),
    domain: !!_('domain'),
    title: spec.title != null
  };
  const dataRef = ref(scope.add(Collect({}, [datum])));

  // data source for axis ticks
  const ticksRef = ref(scope.add(AxisTicks({
    scale: scope.scaleRef(spec.scale),
    extra: scope.property(band.extra),
    count: scope.objectProperty(spec.tickCount),
    values: scope.objectProperty(spec.values),
    minstep: scope.property(spec.tickMinStep),
    formatType: scope.property(spec.formatType),
    formatSpecifier: scope.property(spec.format)
  })));

  // generate axis marks
  const children = [];
  let size;

  // include axis gridlines if requested
  if (datum.grid) {
    children.push(axisGrid(spec, config, encode.grid, ticksRef, band));
  }

  // include axis ticks if requested
  if (datum.ticks) {
    size = _('tickSize');
    children.push(axisTicks(spec, config, encode.ticks, ticksRef, size, band));
  }

  // include axis labels if requested
  if (datum.labels) {
    size = datum.ticks ? size : 0;
    children.push(axisLabels(spec, config, encode.labels, ticksRef, size, band));
  }

  // include axis domain path if requested
  if (datum.domain) {
    children.push(axisDomain(spec, config, encode.domain, dataRef));
  }

  // include axis title if defined
  if (datum.title) {
    children.push(axisTitle(spec, config, encode.title, dataRef));
  }

  // parse axis specification
  return parseMark(guideGroup({
    role: AxisRole,
    from: dataRef,
    encode: extendEncode(buildAxisEncode(_, spec), axisEncode, Skip),
    marks: children,
    aria: _('aria'),
    description: _('description'),
    zindex: _('zindex'),
    name,
    interactive,
    style
  }), scope);
}
function buildAxisEncode(_, spec) {
  const encode = {
    enter: {},
    update: {}
  };
  addEncoders(encode, {
    orient: _('orient'),
    offset: _('offset') || 0,
    position: value(spec.position, 0),
    titlePadding: _('titlePadding'),
    minExtent: _('minExtent'),
    maxExtent: _('maxExtent'),
    range: {
      signal: `abs(span(range("${spec.scale}")))`
    },
    translate: _('translate'),
    // accessibility support
    format: spec.format,
    formatType: spec.formatType
  });
  return encode;
}

function parseScope (spec, scope, preprocessed) {
  const signals = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals),
    scales = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.scales);

  // parse signal definitions, if not already preprocessed
  if (!preprocessed) signals.forEach(_ => parseSignal(_, scope));

  // parse cartographic projection definitions
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.projections).forEach(_ => parseProjection(_, scope));

  // initialize scale references
  scales.forEach(_ => initScale(_, scope));

  // parse data sources
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.data).forEach(_ => parseData(_, scope));

  // parse scale definitions
  scales.forEach(_ => parseScale(_, scope));

  // parse signal updates
  (preprocessed || signals).forEach(_ => parseSignalUpdates(_, scope));

  // parse axis definitions
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.axes).forEach(_ => parseAxis(_, scope));

  // parse mark definitions
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.marks).forEach(_ => parseMark(_, scope));

  // parse legend definitions
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.legends).forEach(_ => parseLegend(_, scope));

  // parse title, if defined
  if (spec.title) parseTitle(spec.title, scope);

  // parse collected lambda (anonymous) expressions
  scope.parseLambdas();
  return scope;
}

const rootEncode = spec => extendEncode({
  enter: {
    x: {
      value: 0
    },
    y: {
      value: 0
    }
  },
  update: {
    width: {
      signal: 'width'
    },
    height: {
      signal: 'height'
    }
  }
}, spec);
function parseView(spec, scope) {
  const config = scope.config;

  // add scenegraph root
  const root = ref(scope.root = scope.add(operator()));

  // parse top-level signal definitions
  const signals = collectSignals(spec, config);
  signals.forEach(_ => parseSignal(_, scope));

  // assign description, event, legend, and locale configuration
  scope.description = spec.description || config.description;
  scope.eventConfig = config.events;
  scope.legends = scope.objectProperty(config.legend && config.legend.layout);
  scope.locale = config.locale;

  // store root group item
  const input = scope.add(Collect());

  // encode root group item
  const encode = scope.add(Encode(parseEncode(rootEncode(spec.encode), GroupMark, FrameRole, spec.style, scope, {
    pulse: ref(input)
  })));

  // perform view layout
  const parent = scope.add(ViewLayout({
    layout: scope.objectProperty(spec.layout),
    legends: scope.legends,
    autosize: scope.signalRef('autosize'),
    mark: root,
    pulse: ref(encode)
  }));
  scope.operators.pop();

  // parse remainder of specification
  scope.pushState(ref(encode), ref(parent), null);
  parseScope(spec, scope, signals);
  scope.operators.push(parent);

  // bound / render / sieve root item
  let op = scope.add(Bound({
    mark: root,
    pulse: ref(parent)
  }));
  op = scope.add(Render({
    pulse: ref(op)
  }));
  op = scope.add(Sieve({
    pulse: ref(op)
  }));

  // track metadata for root item
  scope.addData('root', new DataScope(scope, input, input, op));
  return scope;
}
function signalObject(name, value) {
  return value && value.signal ? {
    name,
    update: value.signal
  } : {
    name,
    value
  };
}

/**
 * Collect top-level signals, merging values as needed. Signals
 * defined in the config signals arrays are added only if that
 * signal is not explicitly defined in the specification.
 * Built-in signals (autosize, background, padding, width, height)
 * receive special treatment. They are initialized using the
 * top-level spec property, or, if undefined in the spec, using
 * the corresponding top-level config property. If this property
 * is a signal reference object, the signal expression maps to the
 * signal 'update' property. If the spec's top-level signal array
 * contains an entry that matches a built-in signal, that entry
 * will be merged with the built-in specification, potentially
 * overwriting existing 'value' or 'update' properties.
 */
function collectSignals(spec, config) {
  const _ = name => value(spec[name], config[name]),
    signals = [signalObject('background', _('background')), signalObject('autosize', parseAutosize(_('autosize'))), signalObject('padding', parsePadding(_('padding'))), signalObject('width', _('width') || 0), signalObject('height', _('height') || 0)],
    pre = signals.reduce((p, s) => (p[s.name] = s, p), {}),
    map = {};

  // add spec signal array
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(spec.signals).forEach(s => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // merge if built-in signal
      s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(pre[s.name], s);
    } else {
      // otherwise add to signal list
      signals.push(s);
    }
    map[s.name] = s;
  });

  // add config signal array
  (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(config.signals).forEach(s => {
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s.name) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(pre, s.name)) {
      // add to signal list if not already defined
      signals.push(s);
    }
  });
  return signals;
}

function Scope(config, options) {
  this.config = config || {};
  this.options = options || {};
  this.bindings = [];
  this.field = {};
  this.signals = {};
  this.lambdas = {};
  this.scales = {};
  this.events = {};
  this.data = {};
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this.eventConfig = null;
  this.locale = null;
  this._id = 0;
  this._subid = 0;
  this._nextsub = [0];
  this._parent = [];
  this._encode = [];
  this._lookup = [];
  this._markpath = [];
}
function Subscope(scope) {
  this.config = scope.config;
  this.options = scope.options;
  this.legends = scope.legends;
  this.field = Object.create(scope.field);
  this.signals = Object.create(scope.signals);
  this.lambdas = Object.create(scope.lambdas);
  this.scales = Object.create(scope.scales);
  this.events = Object.create(scope.events);
  this.data = Object.create(scope.data);
  this.streams = [];
  this.updates = [];
  this.operators = [];
  this._id = 0;
  this._subid = ++scope._nextsub[0];
  this._nextsub = scope._nextsub;
  this._parent = scope._parent.slice();
  this._encode = scope._encode.slice();
  this._lookup = scope._lookup.slice();
  this._markpath = scope._markpath;
}
Scope.prototype = Subscope.prototype = {
  parse(spec) {
    return parseScope(spec, this);
  },
  fork() {
    return new Subscope(this);
  },
  isSubscope() {
    return this._subid > 0;
  },
  toRuntime() {
    this.finish();
    return {
      description: this.description,
      operators: this.operators,
      streams: this.streams,
      updates: this.updates,
      bindings: this.bindings,
      eventConfig: this.eventConfig,
      locale: this.locale
    };
  },
  id() {
    return (this._subid ? this._subid + ':' : 0) + this._id++;
  },
  add(op) {
    this.operators.push(op);
    op.id = this.id();
    // if pre-registration references exist, resolve them now
    if (op.refs) {
      op.refs.forEach(ref => {
        ref.$ref = op.id;
      });
      op.refs = null;
    }
    return op;
  },
  proxy(op) {
    const vref = op instanceof Entry ? ref(op) : op;
    return this.add(Proxy({
      value: vref
    }));
  },
  addStream(stream) {
    this.streams.push(stream);
    stream.id = this.id();
    return stream;
  },
  addUpdate(update) {
    this.updates.push(update);
    return update;
  },
  // Apply metadata
  finish() {
    let name, ds;

    // annotate root
    if (this.root) this.root.root = true;

    // annotate signals
    for (name in this.signals) {
      this.signals[name].signal = name;
    }

    // annotate scales
    for (name in this.scales) {
      this.scales[name].scale = name;
    }

    // annotate data sets
    function annotate(op, name, type) {
      let data, list;
      if (op) {
        data = op.data || (op.data = {});
        list = data[name] || (data[name] = []);
        list.push(type);
      }
    }
    for (name in this.data) {
      ds = this.data[name];
      annotate(ds.input, name, 'input');
      annotate(ds.output, name, 'output');
      annotate(ds.values, name, 'values');
      for (const field in ds.index) {
        annotate(ds.index[field], name, 'index:' + field);
      }
    }
    return this;
  },
  // ----

  pushState(encode, parent, lookup) {
    this._encode.push(ref(this.add(Sieve({
      pulse: encode
    }))));
    this._parent.push(parent);
    this._lookup.push(lookup ? ref(this.proxy(lookup)) : null);
    this._markpath.push(-1);
  },
  popState() {
    this._encode.pop();
    this._parent.pop();
    this._lookup.pop();
    this._markpath.pop();
  },
  parent() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._parent);
  },
  encode() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._encode);
  },
  lookup() {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(this._lookup);
  },
  markpath() {
    const p = this._markpath;
    return ++p[p.length - 1];
  },
  // ----

  fieldRef(field, name) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(field)) return fieldRef$1(field, name);
    if (!field.signal) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unsupported field reference: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(field));
    }
    const s = field.signal;
    let f = this.field[s];
    if (!f) {
      const params = {
        name: this.signalRef(s)
      };
      if (name) params.as = name;
      this.field[s] = f = ref(this.add(Field(params)));
    }
    return f;
  },
  compareRef(cmp) {
    let signal = false;
    const check = _ => isSignal(_) ? (signal = true, this.signalRef(_.signal)) : isExpr$1(_) ? (signal = true, this.exprRef(_.expr)) : _;
    const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.field).map(check),
      orders = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(cmp.order).map(check);
    return signal ? ref(this.add(Compare({
      fields: fields,
      orders: orders
    }))) : compareRef(fields, orders);
  },
  keyRef(fields, flat) {
    let signal = false;
    const check = _ => isSignal(_) ? (signal = true, ref(sig[_.signal])) : _;
    const sig = this.signals;
    fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(fields).map(check);
    return signal ? ref(this.add(Key({
      fields: fields,
      flat: flat
    }))) : keyRef(fields, flat);
  },
  sortRef(sort) {
    if (!sort) return sort;

    // including id ensures stable sorting
    const a = aggrField(sort.op, sort.field),
      o = sort.order || Ascending;
    return o.signal ? ref(this.add(Compare({
      fields: a,
      orders: this.signalRef(o.signal)
    }))) : compareRef(a, o);
  },
  // ----

  event(source, type) {
    const key = source + ':' + type;
    if (!this.events[key]) {
      const id = this.id();
      this.streams.push({
        id: id,
        source: source,
        type: type
      });
      this.events[key] = id;
    }
    return this.events[key];
  },
  // ----

  hasOwnSignal(name) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.signals, name);
  },
  addSignal(name, value) {
    if (this.hasOwnSignal(name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    const op = value instanceof Entry ? value : this.add(operator(value));
    return this.signals[name] = op;
  },
  getSignal(name) {
    if (!this.signals[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    return this.signals[name];
  },
  signalRef(s) {
    if (this.signals[s]) {
      return ref(this.signals[s]);
    } else if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.lambdas, s)) {
      this.lambdas[s] = this.add(operator(null));
    }
    return ref(this.lambdas[s]);
  },
  parseLambdas() {
    const code = Object.keys(this.lambdas);
    for (let i = 0, n = code.length; i < n; ++i) {
      const s = code[i],
        e = (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(s, this),
        op = this.lambdas[s];
      op.params = e.$params;
      op.update = e.$expr;
    }
  },
  property(spec) {
    return spec && spec.signal ? this.signalRef(spec.signal) : spec;
  },
  objectProperty(spec) {
    return !spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec) ? spec : this.signalRef(spec.signal || propertyLambda(spec));
  },
  exprRef(code, name) {
    const params = {
      expr: (0,vega_functions__WEBPACK_IMPORTED_MODULE_1__.parseExpression)(code, this)
    };
    if (name) params.expr.$name = name;
    return ref(this.add(Expression(params)));
  },
  addBinding(name, bind) {
    if (!this.bindings) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Nested signals do not support binding: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    this.bindings.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
      signal: name
    }, bind));
  },
  // ----

  addScaleProj(name, transform) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.scales, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate scale or projection name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    this.scales[name] = this.add(transform);
  },
  addScale(name, params) {
    this.addScaleProj(name, Scale(params));
  },
  addProjection(name, params) {
    this.addScaleProj(name, Projection(params));
  },
  getScale(name) {
    if (!this.scales[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    return this.scales[name];
  },
  scaleRef(name) {
    return ref(this.getScale(name));
  },
  scaleType(name) {
    return this.getScale(name).params.type;
  },
  projectionRef(name) {
    return this.scaleRef(name);
  },
  projectionType(name) {
    return this.scaleType(name);
  },
  // ----

  addData(name, dataScope) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    return this.data[name] = dataScope;
  },
  getData(name) {
    if (!this.data[name]) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Undefined data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    return this.data[name];
  },
  addDataPipeline(name, entries) {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(this.data, name)) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Duplicate data set name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
    }
    return this.addData(name, DataScope.fromEntries(this, entries));
  }
};
function propertyLambda(spec) {
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(spec) ? arrayLambda : objectLambda)(spec);
}
function arrayLambda(array) {
  const n = array.length;
  let code = '[';
  for (let i = 0; i < n; ++i) {
    const value = array[i];
    code += (i > 0 ? ',' : '') + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }
  return code + ']';
}
function objectLambda(obj) {
  let code = '{',
    i = 0,
    key,
    value;
  for (key in obj) {
    value = obj[key];
    code += (++i > 1 ? ',' : '') + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(key) + ':' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) ? value.signal || propertyLambda(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(value));
  }
  return code + '}';
}

/**
 * Standard configuration defaults for Vega specification parsing.
 * Users can provide their own (sub-)set of these default values
 * by passing in a config object to the top-level parse method.
 */
function defaults () {
  const defaultFont = 'sans-serif',
    defaultSymbolSize = 30,
    defaultStrokeWidth = 2,
    defaultColor = '#4c78a8',
    black = '#000',
    gray = '#888',
    lightGray = '#ddd';
  return {
    // default visualization description
    description: 'Vega visualization',
    // default padding around visualization
    padding: 0,
    // default for automatic sizing; options: 'none', 'pad', 'fit'
    // or provide an object (e.g., {'type': 'pad', 'resize': true})
    autosize: 'pad',
    // default view background color
    // covers the entire view component
    background: null,
    // default event handling configuration
    // preventDefault for view-sourced event types except 'wheel'
    events: {
      defaults: {
        allow: ['wheel']
      }
    },
    // defaults for top-level group marks
    // accepts mark properties (fill, stroke, etc)
    // covers the data rectangle within group width/height
    group: null,
    // defaults for basic mark types
    // each subset accepts mark properties (fill, stroke, etc)
    mark: null,
    arc: {
      fill: defaultColor
    },
    area: {
      fill: defaultColor
    },
    image: null,
    line: {
      stroke: defaultColor,
      strokeWidth: defaultStrokeWidth
    },
    path: {
      stroke: defaultColor
    },
    rect: {
      fill: defaultColor
    },
    rule: {
      stroke: black
    },
    shape: {
      stroke: defaultColor
    },
    symbol: {
      fill: defaultColor,
      size: 64
    },
    text: {
      fill: black,
      font: defaultFont,
      fontSize: 11
    },
    trail: {
      fill: defaultColor,
      size: defaultStrokeWidth
    },
    // style definitions
    style: {
      // axis & legend labels
      'guide-label': {
        fill: black,
        font: defaultFont,
        fontSize: 10
      },
      // axis & legend titles
      'guide-title': {
        fill: black,
        font: defaultFont,
        fontSize: 11,
        fontWeight: 'bold'
      },
      // headers, including chart title
      'group-title': {
        fill: black,
        font: defaultFont,
        fontSize: 13,
        fontWeight: 'bold'
      },
      // chart subtitle
      'group-subtitle': {
        fill: black,
        font: defaultFont,
        fontSize: 12
      },
      // defaults for styled point marks in Vega-Lite
      point: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'circle'
      },
      circle: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth
      },
      square: {
        size: defaultSymbolSize,
        strokeWidth: defaultStrokeWidth,
        shape: 'square'
      },
      // defaults for styled group marks in Vega-Lite
      cell: {
        fill: 'transparent',
        stroke: lightGray
      },
      view: {
        fill: 'transparent'
      }
    },
    // defaults for title
    title: {
      orient: 'top',
      anchor: 'middle',
      offset: 4,
      subtitlePadding: 3
    },
    // defaults for axes
    axis: {
      minExtent: 0,
      maxExtent: 200,
      bandPosition: 0.5,
      domain: true,
      domainWidth: 1,
      domainColor: gray,
      grid: false,
      gridWidth: 1,
      gridColor: lightGray,
      labels: true,
      labelAngle: 0,
      labelLimit: 180,
      labelOffset: 0,
      labelPadding: 2,
      ticks: true,
      tickColor: gray,
      tickOffset: 0,
      tickRound: true,
      tickSize: 5,
      tickWidth: 1,
      titlePadding: 4
    },
    // correction for centering bias
    axisBand: {
      tickOffset: -0.5
    },
    // defaults for cartographic projection
    projection: {
      type: 'mercator'
    },
    // defaults for legends
    legend: {
      orient: 'right',
      padding: 0,
      gridAlign: 'each',
      columnPadding: 10,
      rowPadding: 2,
      symbolDirection: 'vertical',
      gradientDirection: 'vertical',
      gradientLength: 200,
      gradientThickness: 16,
      gradientStrokeColor: lightGray,
      gradientStrokeWidth: 0,
      gradientLabelOffset: 2,
      labelAlign: 'left',
      labelBaseline: 'middle',
      labelLimit: 160,
      labelOffset: 4,
      labelOverlap: true,
      symbolLimit: 30,
      symbolType: 'circle',
      symbolSize: 100,
      symbolOffset: 0,
      symbolStrokeWidth: 1.5,
      symbolBaseFillColor: 'transparent',
      symbolBaseStrokeColor: gray,
      titleLimit: 180,
      titleOrient: 'top',
      titlePadding: 5,
      layout: {
        offset: 18,
        direction: 'horizontal',
        left: {
          direction: 'vertical'
        },
        right: {
          direction: 'vertical'
        }
      }
    },
    // defaults for scale ranges
    range: {
      category: {
        scheme: 'tableau10'
      },
      ordinal: {
        scheme: 'blues'
      },
      heatmap: {
        scheme: 'yellowgreenblue'
      },
      ramp: {
        scheme: 'blues'
      },
      diverging: {
        scheme: 'blueorange',
        extent: [1, 0]
      },
      symbol: ['circle', 'square', 'triangle-up', 'cross', 'diamond', 'triangle-right', 'triangle-down', 'triangle-left']
    }
  };
}

function parse (spec, config, options) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Input Vega specification must be an object.');
  }
  config = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig)(defaults(), config, spec.config);
  return parseView(spec, new Scope(config, options)).toRuntime();
}




/***/ }),

/***/ "./node_modules/vega-projection/build/vega-projection.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-projection/build/vega-projection.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getProjectionPath: () => (/* binding */ getProjectionPath),
/* harmony export */   projection: () => (/* binding */ projection),
/* harmony export */   projectionProperties: () => (/* binding */ projectionProperties)
/* harmony export */ });
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/path/index.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/albers.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/albersUsa.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/azimuthalEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/azimuthalEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/conicConformal.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/conicEqualArea.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/conicEquidistant.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/equalEarth.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/equirectangular.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/gnomonic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/identity.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/mercator.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/naturalEarth1.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/orthographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/stereographic.js");
/* harmony import */ var d3_geo__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-geo */ "./node_modules/d3-geo/src/projection/transverseMercator.js");
/* harmony import */ var d3_geo_projection__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-geo-projection */ "./node_modules/d3-geo-projection/src/mollweide.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");




const defaultPath = (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])();
const projectionProperties = [
// standard properties in d3-geo
'clipAngle', 'clipExtent', 'scale', 'translate', 'center', 'rotate', 'parallels', 'precision', 'reflectX', 'reflectY',
// extended properties in d3-geo-projections
'coefficient', 'distance', 'fraction', 'lobes', 'parallel', 'radius', 'ratio', 'spacing', 'tilt'];

/**
 * Augment projections with their type and a copy method.
 */
function create(type, constructor) {
  return function projection() {
    const p = constructor();
    p.type = type;
    p.path = (0,d3_geo__WEBPACK_IMPORTED_MODULE_1__["default"])().projection(p);
    p.copy = p.copy || function () {
      const c = projection();
      projectionProperties.forEach(prop => {
        if (p[prop]) c[prop](p[prop]());
      });
      c.path.pointRadius(p.path.pointRadius());
      return c;
    };
    return (0,vega_scale__WEBPACK_IMPORTED_MODULE_0__.registerScale)(p);
  };
}
function projection(type, proj) {
  if (!type || typeof type !== 'string') {
    throw new Error('Projection type must be a name string.');
  }
  type = type.toLowerCase();
  if (arguments.length > 1) {
    projections[type] = create(type, proj);
    return this;
  } else {
    return projections[type] || null;
  }
}
function getProjectionPath(proj) {
  return proj && proj.path || defaultPath;
}
const projections = {
  // base d3-geo projection types
  albers: d3_geo__WEBPACK_IMPORTED_MODULE_2__["default"],
  albersusa: d3_geo__WEBPACK_IMPORTED_MODULE_3__["default"],
  azimuthalequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_4__["default"],
  azimuthalequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_5__["default"],
  conicconformal: d3_geo__WEBPACK_IMPORTED_MODULE_6__["default"],
  conicequalarea: d3_geo__WEBPACK_IMPORTED_MODULE_7__["default"],
  conicequidistant: d3_geo__WEBPACK_IMPORTED_MODULE_8__["default"],
  equalEarth: d3_geo__WEBPACK_IMPORTED_MODULE_9__["default"],
  equirectangular: d3_geo__WEBPACK_IMPORTED_MODULE_10__["default"],
  gnomonic: d3_geo__WEBPACK_IMPORTED_MODULE_11__["default"],
  identity: d3_geo__WEBPACK_IMPORTED_MODULE_12__["default"],
  mercator: d3_geo__WEBPACK_IMPORTED_MODULE_13__["default"],
  mollweide: d3_geo_projection__WEBPACK_IMPORTED_MODULE_14__["default"],
  naturalEarth1: d3_geo__WEBPACK_IMPORTED_MODULE_15__["default"],
  orthographic: d3_geo__WEBPACK_IMPORTED_MODULE_16__["default"],
  stereographic: d3_geo__WEBPACK_IMPORTED_MODULE_17__["default"],
  transversemercator: d3_geo__WEBPACK_IMPORTED_MODULE_18__["default"]
};
for (const key in projections) {
  projection(key, projections[key]);
}




/***/ }),

/***/ "./node_modules/vega-regression/build/vega-regression.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-regression/build/vega-regression.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loess: () => (/* binding */ Loess),
/* harmony export */   regression: () => (/* binding */ Regression)
/* harmony export */ });
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");




function partition (data, groupby) {
  var groups = [],
    get = function (f) {
      return f(t);
    },
    map,
    i,
    n,
    t,
    k,
    g;

  // partition data points into stack groups
  if (groupby == null) {
    groups.push(data);
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];
      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(t);
    }
  }
  return groups;
}

/**
 * Compute locally-weighted regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.bandwidth=0.3] - The loess bandwidth.
 */
function Loess(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Loess.Definition = {
  'type': 'Loess',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0.3
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Loess, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
        groups = partition(source, _.groupby),
        names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
        m = names.length,
        as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
        values = [];
      groups.forEach(g => {
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLoess)(g, _.x, _.y, _.bandwidth || 0.3).forEach(p => {
          const t = {};
          for (let i = 0; i < m; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = p[0];
          t[as[1]] = p[1];
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }
    return out;
  }
});

const Methods = {
  constant: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionConstant,
  linear: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLinear,
  log: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionLog,
  exp: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionExp,
  pow: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPow,
  quad: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionQuad,
  poly: vega_statistics__WEBPACK_IMPORTED_MODULE_0__.regressionPoly
};
const degreesOfFreedom = (method, order) => method === 'poly' ? order : method === 'quad' ? 2 : 1;

/**
 * Compute regression fits for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.x - An accessor for the predictor data field.
 * @param {function(object): *} params.y - An accessor for the predicted data field.
 * @param {string} [params.method='linear'] - The regression method to apply.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<number>} [params.extent] - The domain extent over which to plot the regression line.
 * @param {number} [params.order=3] - The polynomial order. Only applies to the 'poly' method.
 */
function Regression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Regression.Definition = {
  'type': 'Regression',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'linear',
    'values': Object.keys(Methods)
  }, {
    'name': 'order',
    'type': 'number',
    'default': 3
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'params',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Regression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
        groups = partition(source, _.groupby),
        names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName),
        method = _.method || 'linear',
        order = _.order == null ? 3 : _.order,
        dof = degreesOfFreedom(method, order),
        as = _.as || [(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.x), (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.accessorName)(_.y)],
        fit = Methods[method],
        values = [];
      let domain = _.extent;
      if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.hasOwnProperty)(Methods, method)) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Invalid regression method: ' + method);
      }
      if (domain != null) {
        if (method === 'log' && domain[0] <= 0) {
          pulse.dataflow.warn('Ignoring extent with values <= 0 for log regression.');
          domain = null;
        }
      }
      groups.forEach(g => {
        const n = g.length;
        if (n <= dof) {
          pulse.dataflow.warn('Skipping regression with more parameters than data points.');
          return;
        }
        const model = fit(g, _.x, _.y, order);
        if (_.params) {
          // if parameter vectors requested return those
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({
            keys: g.dims,
            coef: model.coef,
            rSquared: model.rSquared
          }));
          return;
        }
        const dom = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(g, _.x),
          add = p => {
            const t = {};
            for (let i = 0; i < names.length; ++i) {
              t[names[i]] = g.dims[i];
            }
            t[as[0]] = p[0];
            t[as[1]] = p[1];
            values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
          };
        if (method === 'linear' || method === 'constant') {
          // for linear or constant regression we only need the end points
          dom.forEach(x => add([x, model.predict(x)]));
        } else {
          // otherwise return trend line sample points
          (0,vega_statistics__WEBPACK_IMPORTED_MODULE_0__.sampleCurve)(model.predict, dom, 25, 200).forEach(add);
        }
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }
    return out;
  }
});




/***/ }),

/***/ "./node_modules/vega-runtime/build/vega-runtime.module.js":
/*!****************************************************************!*\
  !*** ./node_modules/vega-runtime/build/vega-runtime.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   context: () => (/* binding */ context)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");



/**
 * Parse a serialized dataflow specification.
 */
function parse (spec) {
  const ctx = this,
    operators = spec.operators || [];

  // parse background
  if (spec.background) {
    ctx.background = spec.background;
  }

  // parse event configuration
  if (spec.eventConfig) {
    ctx.eventConfig = spec.eventConfig;
  }

  // parse locale configuration
  if (spec.locale) {
    ctx.locale = spec.locale;
  }

  // parse operators
  operators.forEach(entry => ctx.parseOperator(entry));

  // parse operator parameters
  operators.forEach(entry => ctx.parseOperatorParameters(entry));

  // parse streams
  (spec.streams || []).forEach(entry => ctx.parseStream(entry));

  // parse updates
  (spec.updates || []).forEach(entry => ctx.parseUpdate(entry));
  return ctx.resolve();
}

const Skip = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['rule']),
  Swap = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['group', 'image', 'rect']);
function adjustSpatial(encode, marktype) {
  let code = '';
  if (Skip[marktype]) return code;
  if (encode.x2) {
    if (encode.x) {
      if (Swap[marktype]) {
        code += 'if(o.x>o.x2)$=o.x,o.x=o.x2,o.x2=$;';
      }
      code += 'o.width=o.x2-o.x;';
    } else {
      code += 'o.x=o.x2-(o.width||0);';
    }
  }
  if (encode.xc) {
    code += 'o.x=o.xc-(o.width||0)/2;';
  }
  if (encode.y2) {
    if (encode.y) {
      if (Swap[marktype]) {
        code += 'if(o.y>o.y2)$=o.y,o.y=o.y2,o.y2=$;';
      }
      code += 'o.height=o.y2-o.y;';
    } else {
      code += 'o.y=o.y2-(o.height||0);';
    }
  }
  if (encode.yc) {
    code += 'o.y=o.yc-(o.height||0)/2;';
  }
  return code;
}
function canonicalType(type) {
  return (type + '').toLowerCase();
}
function isOperator(type) {
  return canonicalType(type) === 'operator';
}
function isCollect(type) {
  return canonicalType(type) === 'collect';
}

function expression(ctx, args, code) {
  // wrap code in return statement if expression does not terminate
  if (!code.endsWith(';')) {
    code = 'return(' + code + ');';
  }
  const fn = Function(...args.concat(code));
  return ctx && ctx.functions ? fn.bind(ctx.functions) : fn;
}

// generate code for comparing a single field
function _compare(u, v, lt, gt) {
  return `((u = ${u}) < (v = ${v}) || u == null) && v != null ? ${lt}
  : (u > v || v == null) && u != null ? ${gt}
  : ((v = v instanceof Date ? +v : v), (u = u instanceof Date ? +u : u)) !== u && v === v ? ${lt}
  : v !== v && u === u ? ${gt} : `;
}
var expressionCodegen = {
  /**
   * Parse an expression used to update an operator value.
   */
  operator: (ctx, expr) => expression(ctx, ['_'], expr.code),
  /**
   * Parse an expression provided as an operator parameter value.
   */
  parameter: (ctx, expr) => expression(ctx, ['datum', '_'], expr.code),
  /**
   * Parse an expression applied to an event stream.
   */
  event: (ctx, expr) => expression(ctx, ['event'], expr.code),
  /**
   * Parse an expression used to handle an event-driven operator update.
   */
  handler: (ctx, expr) => {
    const code = `var datum=event.item&&event.item.datum;return ${expr.code};`;
    return expression(ctx, ['_', 'event'], code);
  },
  /**
   * Parse an expression that performs visual encoding.
   */
  encode: (ctx, encode) => {
    const {
      marktype,
      channels
    } = encode;
    let code = 'var o=item,datum=o.datum,m=0,$;';
    for (const name in channels) {
      const o = 'o[' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name) + ']';
      code += `$=${channels[name].code};if(${o}!==$)${o}=$,m=1;`;
    }
    code += adjustSpatial(channels, marktype);
    code += 'return m;';
    return expression(ctx, ['item', '_'], code);
  },
  /**
   * Optimized code generators for access and comparison.
   */
  codegen: {
    get(path) {
      const ref = `[${path.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue).join('][')}]`;
      const get = Function('_', `return _${ref};`);
      get.path = ref;
      return get;
    },
    comparator(fields, orders) {
      let t;
      const map = (f, i) => {
        const o = orders[i];
        let u, v;
        if (f.path) {
          u = `a${f.path}`;
          v = `b${f.path}`;
        } else {
          (t = t || {})['f' + i] = f;
          u = `this.f${i}(a)`;
          v = `this.f${i}(b)`;
        }
        return _compare(u, v, -o, o);
      };
      const fn = Function('a', 'b', 'var u, v; return ' + fields.map(map).join('') + '0;');
      return t ? fn.bind(t) : fn;
    }
  }
};

/**
 * Parse a dataflow operator.
 */
function parseOperator(spec) {
  const ctx = this;
  if (isOperator(spec.type) || !spec.type) {
    ctx.operator(spec, spec.update ? ctx.operatorExpression(spec.update) : null);
  } else {
    ctx.transform(spec, spec.type);
  }
}

/**
 * Parse and assign operator parameters.
 */
function parseOperatorParameters(spec) {
  const ctx = this;
  if (spec.params) {
    const op = ctx.get(spec.id);
    if (!op) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid operator id: ' + spec.id);
    ctx.dataflow.connect(op, op.parameters(ctx.parseParameters(spec.params), spec.react, spec.initonly));
  }
}

/**
 * Parse a set of operator parameters.
 */
function parseParameters(spec, params) {
  params = params || {};
  const ctx = this;
  for (const key in spec) {
    const value = spec[key];
    params[key] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => parseParameter(v, ctx, params)) : parseParameter(value, ctx, params);
  }
  return params;
}

/**
 * Parse a single parameter.
 */
function parseParameter(spec, ctx, params) {
  if (!spec || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(spec)) return spec;
  for (let i = 0, n = PARSERS.length, p; i < n; ++i) {
    p = PARSERS[i];
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(spec, p.key)) {
      return p.parse(spec, ctx, params);
    }
  }
  return spec;
}

/** Reference parsers. */
var PARSERS = [{
  key: '$ref',
  parse: getOperator
}, {
  key: '$key',
  parse: getKey
}, {
  key: '$expr',
  parse: getExpression
}, {
  key: '$field',
  parse: getField
}, {
  key: '$encode',
  parse: getEncode
}, {
  key: '$compare',
  parse: getCompare
}, {
  key: '$context',
  parse: getContext
}, {
  key: '$subflow',
  parse: getSubflow
}, {
  key: '$tupleid',
  parse: getTupleId
}];

/**
 * Resolve an operator reference.
 */
function getOperator(_, ctx) {
  return ctx.get(_.$ref) || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Operator not defined: ' + _.$ref);
}

/**
 * Resolve an expression reference.
 */
function getExpression(_, ctx, params) {
  if (_.$params) {
    // parse expression parameters
    ctx.parseParameters(_.$params, params);
  }
  const k = 'e:' + _.$expr.code;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.parameterExpression(_.$expr), _.$fields));
}

/**
 * Resolve a key accessor reference.
 */
function getKey(_, ctx) {
  const k = 'k:' + _.$key + '_' + !!_.$flat;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.$key, _.$flat, ctx.expr.codegen));
}

/**
 * Resolve a field accessor reference.
 */
function getField(_, ctx) {
  if (!_.$field) return null;
  const k = 'f:' + _.$field + '_' + _.$name;
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.$field, _.$name, ctx.expr.codegen));
}

/**
 * Resolve a comparator function reference.
 */
function getCompare(_, ctx) {
  // As of Vega 5.5.3, $tupleid sort is no longer used.
  // Keep here for now for backwards compatibility.
  const k = 'c:' + _.$compare + '_' + _.$order,
    c = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.$compare).map(_ => _ && _.$tupleid ? vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid : _);
  return ctx.fn[k] || (ctx.fn[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(c, _.$order, ctx.expr.codegen));
}

/**
 * Resolve an encode operator reference.
 */
function getEncode(_, ctx) {
  const spec = _.$encode,
    encode = {};
  for (const name in spec) {
    const enc = spec[name];
    encode[name] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(ctx.encodeExpression(enc.$expr), enc.$fields);
    encode[name].output = enc.$output;
  }
  return encode;
}

/**
 * Resolve a context reference.
 */
function getContext(_, ctx) {
  return ctx;
}

/**
 * Resolve a recursive subflow specification.
 */
function getSubflow(_, ctx) {
  const spec = _.$subflow;
  return function (dataflow, key, parent) {
    const subctx = ctx.fork().parse(spec),
      op = subctx.get(spec.operators[0].id),
      p = subctx.signals.parent;
    if (p) p.set(parent);
    op.detachSubflow = () => ctx.detach(subctx);
    return op;
  };
}

/**
 * Resolve a tuple id reference.
 */
function getTupleId() {
  return vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
}

/**
 * Parse an event stream specification.
 */
function parseStream (spec) {
  var ctx = this,
    filter = spec.filter != null ? ctx.eventExpression(spec.filter) : undefined,
    stream = spec.stream != null ? ctx.get(spec.stream) : undefined,
    args;
  if (spec.source) {
    stream = ctx.events(spec.source, spec.type, filter);
  } else if (spec.merge) {
    args = spec.merge.map(_ => ctx.get(_));
    stream = args[0].merge.apply(args[0], args.slice(1));
  }
  if (spec.between) {
    args = spec.between.map(_ => ctx.get(_));
    stream = stream.between(args[0], args[1]);
  }
  if (spec.filter) {
    stream = stream.filter(filter);
  }
  if (spec.throttle != null) {
    stream = stream.throttle(+spec.throttle);
  }
  if (spec.debounce != null) {
    stream = stream.debounce(+spec.debounce);
  }
  if (stream == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid stream definition: ' + JSON.stringify(spec));
  }
  if (spec.consume) stream.consume(true);
  ctx.stream(spec, stream);
}

/**
 * Parse an event-driven operator update.
 */
function parseUpdate (spec) {
  var ctx = this,
    srcid = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(srcid = spec.source) ? srcid.$ref : srcid,
    source = ctx.get(srcid),
    target = null,
    update = spec.update,
    params = undefined;
  if (!source) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Source not defined: ' + spec.source);
  target = spec.target && spec.target.$expr ? ctx.eventExpression(spec.target.$expr) : ctx.get(spec.target);
  if (update && update.$expr) {
    if (update.$params) {
      params = ctx.parseParameters(update.$params);
    }
    update = ctx.handlerExpression(update.$expr);
  }
  ctx.update(spec, source, target, update, params);
}

const SKIP = {
  skip: true
};
function getState(options) {
  var ctx = this,
    state = {};
  if (options.signals) {
    var signals = state.signals = {};
    Object.keys(ctx.signals).forEach(key => {
      const op = ctx.signals[key];
      if (options.signals(key, op)) {
        signals[key] = op.value;
      }
    });
  }
  if (options.data) {
    var data = state.data = {};
    Object.keys(ctx.data).forEach(key => {
      const dataset = ctx.data[key];
      if (options.data(key, dataset)) {
        data[key] = dataset.input.value;
      }
    });
  }
  if (ctx.subcontext && options.recurse !== false) {
    state.subcontext = ctx.subcontext.map(ctx => ctx.getState(options));
  }
  return state;
}
function setState(state) {
  var ctx = this,
    df = ctx.dataflow,
    data = state.data,
    signals = state.signals;
  Object.keys(signals || {}).forEach(key => {
    df.update(ctx.signals[key], signals[key], SKIP);
  });
  Object.keys(data || {}).forEach(key => {
    df.pulse(ctx.data[key].input, df.changeset().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(data[key]));
  });
  (state.subcontext || []).forEach((substate, i) => {
    const subctx = ctx.subcontext[i];
    if (subctx) subctx.setState(substate);
  });
}

/**
 * Context objects store the current parse state.
 * Enables lookup of parsed operators, event streams, accessors, etc.
 * Provides a 'fork' method for creating child contexts for subflows.
 */
function context (df, transforms, functions, expr) {
  return new Context(df, transforms, functions, expr);
}
function Context(df, transforms, functions, expr) {
  this.dataflow = df;
  this.transforms = transforms;
  this.events = df.events.bind(df);
  this.expr = expr || expressionCodegen, this.signals = {};
  this.scales = {};
  this.nodes = {};
  this.data = {};
  this.fn = {};
  if (functions) {
    this.functions = Object.create(functions);
    this.functions.context = this;
  }
}
function Subcontext(ctx) {
  this.dataflow = ctx.dataflow;
  this.transforms = ctx.transforms;
  this.events = ctx.events;
  this.expr = ctx.expr;
  this.signals = Object.create(ctx.signals);
  this.scales = Object.create(ctx.scales);
  this.nodes = Object.create(ctx.nodes);
  this.data = Object.create(ctx.data);
  this.fn = Object.create(ctx.fn);
  if (ctx.functions) {
    this.functions = Object.create(ctx.functions);
    this.functions.context = this;
  }
}
Context.prototype = Subcontext.prototype = {
  fork() {
    const ctx = new Subcontext(this);
    (this.subcontext || (this.subcontext = [])).push(ctx);
    return ctx;
  },
  detach(ctx) {
    this.subcontext = this.subcontext.filter(c => c !== ctx);

    // disconnect all nodes in the subcontext
    // wipe out targets first for better efficiency
    const keys = Object.keys(ctx.nodes);
    for (const key of keys) ctx.nodes[key]._targets = null;
    for (const key of keys) ctx.nodes[key].detach();
    ctx.nodes = null;
  },
  get(id) {
    return this.nodes[id];
  },
  set(id, node) {
    return this.nodes[id] = node;
  },
  add(spec, op) {
    const ctx = this,
      df = ctx.dataflow,
      data = spec.value;
    ctx.set(spec.id, op);
    if (isCollect(spec.type) && data) {
      if (data.$ingest) {
        df.ingest(op, data.$ingest, data.$format);
      } else if (data.$request) {
        df.preload(op, data.$request, data.$format);
      } else {
        df.pulse(op, df.changeset().insert(data));
      }
    }
    if (spec.root) {
      ctx.root = op;
    }
    if (spec.parent) {
      let p = ctx.get(spec.parent.$ref);
      if (p) {
        df.connect(p, [op]);
        op.targets().add(p);
      } else {
        (ctx.unresolved = ctx.unresolved || []).push(() => {
          p = ctx.get(spec.parent.$ref);
          df.connect(p, [op]);
          op.targets().add(p);
        });
      }
    }
    if (spec.signal) {
      ctx.signals[spec.signal] = op;
    }
    if (spec.scale) {
      ctx.scales[spec.scale] = op;
    }
    if (spec.data) {
      for (const name in spec.data) {
        const data = ctx.data[name] || (ctx.data[name] = {});
        spec.data[name].forEach(role => data[role] = op);
      }
    }
  },
  resolve() {
    (this.unresolved || []).forEach(fn => fn());
    delete this.unresolved;
    return this;
  },
  operator(spec, update) {
    this.add(spec, this.dataflow.add(spec.value, update));
  },
  transform(spec, type) {
    this.add(spec, this.dataflow.add(this.transforms[canonicalType(type)]));
  },
  stream(spec, stream) {
    this.set(spec.id, stream);
  },
  update(spec, stream, target, update, params) {
    this.dataflow.on(stream, target, update, params, spec.options);
  },
  // expression parsing
  operatorExpression(expr) {
    return this.expr.operator(this, expr);
  },
  parameterExpression(expr) {
    return this.expr.parameter(this, expr);
  },
  eventExpression(expr) {
    return this.expr.event(this, expr);
  },
  handlerExpression(expr) {
    return this.expr.handler(this, expr);
  },
  encodeExpression(encode) {
    return this.expr.encode(this, encode);
  },
  // parse methods
  parse,
  parseOperator,
  parseOperatorParameters,
  parseParameters,
  parseStream,
  parseUpdate,
  // state methods
  getState,
  setState
};




/***/ }),

/***/ "./node_modules/vega-scale/build/vega-scale.module.js":
/*!************************************************************!*\
  !*** ./node_modules/vega-scale/build/vega-scale.module.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Band: () => (/* binding */ Band),
/* harmony export */   BinOrdinal: () => (/* binding */ BinOrdinal),
/* harmony export */   DiscreteLegend: () => (/* binding */ DiscreteLegend),
/* harmony export */   Diverging: () => (/* binding */ Diverging),
/* harmony export */   GradientLegend: () => (/* binding */ GradientLegend),
/* harmony export */   Identity: () => (/* binding */ Identity),
/* harmony export */   Linear: () => (/* binding */ Linear),
/* harmony export */   Log: () => (/* binding */ Log),
/* harmony export */   Ordinal: () => (/* binding */ Ordinal),
/* harmony export */   Point: () => (/* binding */ Point),
/* harmony export */   Pow: () => (/* binding */ Pow),
/* harmony export */   Quantile: () => (/* binding */ Quantile),
/* harmony export */   Quantize: () => (/* binding */ Quantize),
/* harmony export */   Sequential: () => (/* binding */ Sequential),
/* harmony export */   Sqrt: () => (/* binding */ Sqrt),
/* harmony export */   SymbolLegend: () => (/* binding */ SymbolLegend),
/* harmony export */   Symlog: () => (/* binding */ Symlog),
/* harmony export */   Threshold: () => (/* binding */ Threshold),
/* harmony export */   Time: () => (/* binding */ Time),
/* harmony export */   UTC: () => (/* binding */ UTC),
/* harmony export */   bandSpace: () => (/* binding */ bandSpace),
/* harmony export */   domainCaption: () => (/* binding */ domainCaption),
/* harmony export */   interpolate: () => (/* binding */ interpolate),
/* harmony export */   interpolateColors: () => (/* binding */ interpolateColors),
/* harmony export */   interpolateRange: () => (/* binding */ interpolateRange),
/* harmony export */   isContinuous: () => (/* binding */ isContinuous),
/* harmony export */   isDiscrete: () => (/* binding */ isDiscrete),
/* harmony export */   isDiscretizing: () => (/* binding */ isDiscretizing),
/* harmony export */   isInterpolating: () => (/* binding */ isInterpolating),
/* harmony export */   isLogarithmic: () => (/* binding */ isLogarithmic),
/* harmony export */   isQuantile: () => (/* binding */ isQuantile),
/* harmony export */   isRegisteredScale: () => (/* binding */ isRegisteredScale),
/* harmony export */   isTemporal: () => (/* binding */ isTemporal),
/* harmony export */   isValidScaleType: () => (/* binding */ isValidScaleType),
/* harmony export */   labelFormat: () => (/* binding */ labelFormat),
/* harmony export */   labelFraction: () => (/* binding */ labelFraction),
/* harmony export */   labelValues: () => (/* binding */ labelValues),
/* harmony export */   quantizeInterpolator: () => (/* binding */ quantizeInterpolator),
/* harmony export */   registerScale: () => (/* binding */ registerScale),
/* harmony export */   scale: () => (/* binding */ scale),
/* harmony export */   scaleCopy: () => (/* binding */ scaleCopy),
/* harmony export */   scaleFraction: () => (/* binding */ scaleFraction),
/* harmony export */   scaleImplicit: () => (/* reexport safe */ d3_scale__WEBPACK_IMPORTED_MODULE_1__.implicit),
/* harmony export */   scheme: () => (/* binding */ scheme),
/* harmony export */   tickCount: () => (/* binding */ tickCount),
/* harmony export */   tickFormat: () => (/* binding */ tickFormat),
/* harmony export */   tickValues: () => (/* binding */ tickValues),
/* harmony export */   validTicks: () => (/* binding */ validTicks)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisect.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/identity.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/linear.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/log.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/pow.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/symlog.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/time.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/utcTime.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/sequential.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/diverging.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantile.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/quantize.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/threshold.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/ordinal.js");
/* harmony import */ var d3_scale__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-scale */ "./node_modules/d3-scale/src/tickFormat.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/piecewise.js");
/* harmony import */ var d3_interpolate__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-interpolate */ "./node_modules/d3-interpolate/src/index.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Accent.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/category10.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Dark2.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/observable10.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Paired.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Pastel1.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Pastel2.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set1.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set2.js");
/* harmony import */ var d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! d3-scale-chromatic */ "./node_modules/d3-scale-chromatic/src/categorical/Set3.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");









function bandSpace (count, paddingInner, paddingOuter) {
  const space = count - paddingInner + paddingOuter * 2;
  return count ? space > 0 ? space : 1 : 0;
}

const Identity = 'identity';
const Linear = 'linear';
const Log = 'log';
const Pow = 'pow';
const Sqrt = 'sqrt';
const Symlog = 'symlog';
const Time = 'time';
const UTC = 'utc';
const Sequential = 'sequential';
const Diverging = 'diverging';
const Quantile = 'quantile';
const Quantize = 'quantize';
const Threshold = 'threshold';
const Ordinal = 'ordinal';
const Point = 'point';
const Band = 'band';
const BinOrdinal = 'bin-ordinal';

// categories
const Continuous = 'continuous';
const Discrete = 'discrete';
const Discretizing = 'discretizing';
const Interpolating = 'interpolating';
const Temporal = 'temporal';

function invertRange (scale) {
  return function (_) {
    let lo = _[0],
      hi = _[1],
      t;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    return [scale.invert(lo), scale.invert(hi)];
  };
}

function invertRangeExtent (scale) {
  return function (_) {
    const range = scale.range();
    let lo = _[0],
      hi = _[1],
      min = -1,
      max,
      t,
      i,
      n;
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    for (i = 0, n = range.length; i < n; ++i) {
      if (range[i] >= lo && range[i] <= hi) {
        if (min < 0) min = i;
        max = i;
      }
    }
    if (min < 0) return undefined;
    lo = scale.invertExtent(range[min]);
    hi = scale.invertExtent(range[max]);
    return [lo[0] === undefined ? lo[1] : lo[0], hi[1] === undefined ? hi[0] : hi[1]];
  };
}

function band() {
  const scale = (0,d3_scale__WEBPACK_IMPORTED_MODULE_1__["default"])().unknown(undefined),
    domain = scale.domain,
    ordinalRange = scale.range;
  let range$1 = [0, 1],
    step,
    bandwidth,
    round = false,
    paddingInner = 0,
    paddingOuter = 0,
    align = 0.5;
  delete scale.unknown;
  function rescale() {
    const n = domain().length,
      reverse = range$1[1] < range$1[0],
      stop = range$1[1 - reverse],
      space = bandSpace(n, paddingInner, paddingOuter);
    let start = range$1[reverse - 0];
    step = (stop - start) / (space || 1);
    if (round) {
      step = Math.floor(step);
    }
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) {
      start = Math.round(start);
      bandwidth = Math.round(bandwidth);
    }
    const values = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__["default"])(n).map(i => start + step * i);
    return ordinalRange(reverse ? values.reverse() : values);
  }
  scale.domain = function (_) {
    if (arguments.length) {
      domain(_);
      return rescale();
    } else {
      return domain();
    }
  };
  scale.range = function (_) {
    if (arguments.length) {
      range$1 = [+_[0], +_[1]];
      return rescale();
    } else {
      return range$1.slice();
    }
  };
  scale.rangeRound = function (_) {
    range$1 = [+_[0], +_[1]];
    round = true;
    return rescale();
  };
  scale.bandwidth = function () {
    return bandwidth;
  };
  scale.step = function () {
    return step;
  };
  scale.round = function (_) {
    if (arguments.length) {
      round = !!_;
      return rescale();
    } else {
      return round;
    }
  };
  scale.padding = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      paddingInner = paddingOuter;
      return rescale();
    } else {
      return paddingInner;
    }
  };
  scale.paddingInner = function (_) {
    if (arguments.length) {
      paddingInner = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingInner;
    }
  };
  scale.paddingOuter = function (_) {
    if (arguments.length) {
      paddingOuter = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return paddingOuter;
    }
  };
  scale.align = function (_) {
    if (arguments.length) {
      align = Math.max(0, Math.min(1, _));
      return rescale();
    } else {
      return align;
    }
  };
  scale.invertRange = function (_) {
    // bail if range has null or undefined values
    if (_[0] == null || _[1] == null) return;
    const reverse = range$1[1] < range$1[0],
      values = reverse ? ordinalRange().reverse() : ordinalRange(),
      n = values.length - 1;
    let lo = +_[0],
      hi = +_[1],
      a,
      b,
      t;

    // bail if either range endpoint is invalid
    if (lo !== lo || hi !== hi) return;

    // order range inputs, bail if outside of scale range
    if (hi < lo) {
      t = lo;
      lo = hi;
      hi = t;
    }
    if (hi < values[0] || lo > range$1[1 - reverse]) return;

    // binary search to index into scale range
    a = Math.max(0, (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, lo) - 1);
    b = lo === hi ? a : (0,d3_array__WEBPACK_IMPORTED_MODULE_4__.bisectRight)(values, hi) - 1;

    // increment index a if lo is within padding gap
    if (lo - values[a] > bandwidth + 1e-10) ++a;
    if (reverse) {
      // map + swap
      t = a;
      a = n - b;
      b = n - t;
    }
    return a > b ? undefined : domain().slice(a, b + 1);
  };
  scale.invert = function (_) {
    const value = scale.invertRange([_, _]);
    return value ? value[0] : value;
  };
  scale.copy = function () {
    return band().domain(domain()).range(range$1).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return rescale();
}
function pointish(scale) {
  const copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  scale.copy = function () {
    return pointish(copy());
  };
  return scale;
}
function point() {
  return pointish(band().paddingInner(1));
}

var map = Array.prototype.map;
function numbers(_) {
  return map.call(_, vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);
}

const slice = Array.prototype.slice;

function scaleBinOrdinal() {
  let domain = [],
    range = [];
  function scale(x) {
    return x == null || x !== x ? undefined : range[((0,d3_array__WEBPACK_IMPORTED_MODULE_4__["default"])(domain, x) - 1) % range.length];
  }
  scale.domain = function (_) {
    if (arguments.length) {
      domain = numbers(_);
      return scale;
    } else {
      return domain.slice();
    }
  };
  scale.range = function (_) {
    if (arguments.length) {
      range = slice.call(_);
      return scale;
    } else {
      return range.slice();
    }
  };
  scale.tickFormat = function (count, specifier) {
    return (0,d3_scale__WEBPACK_IMPORTED_MODULE_5__["default"])(domain[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain), count == null ? 10 : count, specifier);
  };
  scale.copy = function () {
    return scaleBinOrdinal().domain(scale.domain()).range(scale.range());
  };
  return scale;
}

/** Private scale registry: should not be exported */
const scales = new Map();
const VEGA_SCALE = Symbol('vega_scale');
function registerScale(scale) {
  scale[VEGA_SCALE] = true;
  return scale;
}

/**
 * Return true if object was created by a constructor from the vega-scale `scale` function.
 */
function isRegisteredScale(scale) {
  return scale && scale[VEGA_SCALE] === true;
}

/**
 * Augment scales with their type and needed inverse methods.
 */
function create(type, constructor, metadata) {
  const ctr = function scale() {
    const s = constructor();
    if (!s.invertRange) {
      s.invertRange = s.invert ? invertRange(s) : s.invertExtent ? invertRangeExtent(s) : undefined;
    }
    s.type = type;
    return registerScale(s);
  };
  ctr.metadata = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(metadata));
  return ctr;
}

/**
 * Registry function for adding and accessing scale constructor functions.
 * The *type* argument is a String indicating the name of the scale type.
 *
 * If the *scale* argument is not specified, this method returns the matching scale constructor in the registry, or `null` if not found.
 * If the *scale* argument is provided, it must be a scale constructor function to add to the registry under the given *type* name.
 * The *metadata* argument provides additional information to guide appropriate use of scales within Vega.
 *
 *  *metadata* can be either a string or string array. The valid string values are:
 * - `"continuous"` - the scale is defined over a continuous-valued domain.
 * - `"discrete"` - the scale is defined over a discrete domain and range.
 * - `"discretizing"` - the scale discretizes a continuous domain to a discrete range.
 * - `"interpolating"` - the scale range is defined using a color interpolator.
 * - `"log"` - the scale performs a logarithmic transform of the continuous domain.
 * - `"temporal"` - the scale domain is defined over date-time values.
 */
function scale(type, scale, metadata) {
  if (arguments.length > 1) {
    scales.set(type, create(type, scale, metadata));
    return this;
  } else {
    return isValidScaleType(type) ? scales.get(type) : undefined;
  }
}

// identity scale
scale(Identity, d3_scale__WEBPACK_IMPORTED_MODULE_6__["default"]);

// continuous scales
scale(Linear, d3_scale__WEBPACK_IMPORTED_MODULE_7__["default"], Continuous);
scale(Log, d3_scale__WEBPACK_IMPORTED_MODULE_8__["default"], [Continuous, Log]);
scale(Pow, d3_scale__WEBPACK_IMPORTED_MODULE_9__["default"], Continuous);
scale(Sqrt, d3_scale__WEBPACK_IMPORTED_MODULE_9__.sqrt, Continuous);
scale(Symlog, d3_scale__WEBPACK_IMPORTED_MODULE_10__["default"], Continuous);
scale(Time, d3_scale__WEBPACK_IMPORTED_MODULE_11__["default"], [Continuous, Temporal]);
scale(UTC, d3_scale__WEBPACK_IMPORTED_MODULE_12__["default"], [Continuous, Temporal]);

// sequential scales
scale(Sequential, d3_scale__WEBPACK_IMPORTED_MODULE_13__["default"], [Continuous, Interpolating]); // backwards compat
scale(`${Sequential}-${Linear}`, d3_scale__WEBPACK_IMPORTED_MODULE_13__["default"], [Continuous, Interpolating]);
scale(`${Sequential}-${Log}`, d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialLog, [Continuous, Interpolating, Log]);
scale(`${Sequential}-${Pow}`, d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialPow, [Continuous, Interpolating]);
scale(`${Sequential}-${Sqrt}`, d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSqrt, [Continuous, Interpolating]);
scale(`${Sequential}-${Symlog}`, d3_scale__WEBPACK_IMPORTED_MODULE_13__.sequentialSymlog, [Continuous, Interpolating]);

// diverging scales
scale(`${Diverging}-${Linear}`, d3_scale__WEBPACK_IMPORTED_MODULE_14__["default"], [Continuous, Interpolating]);
scale(`${Diverging}-${Log}`, d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingLog, [Continuous, Interpolating, Log]);
scale(`${Diverging}-${Pow}`, d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingPow, [Continuous, Interpolating]);
scale(`${Diverging}-${Sqrt}`, d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSqrt, [Continuous, Interpolating]);
scale(`${Diverging}-${Symlog}`, d3_scale__WEBPACK_IMPORTED_MODULE_14__.divergingSymlog, [Continuous, Interpolating]);

// discretizing scales
scale(Quantile, d3_scale__WEBPACK_IMPORTED_MODULE_15__["default"], [Discretizing, Quantile]);
scale(Quantize, d3_scale__WEBPACK_IMPORTED_MODULE_16__["default"], Discretizing);
scale(Threshold, d3_scale__WEBPACK_IMPORTED_MODULE_17__["default"], Discretizing);

// discrete scales
scale(BinOrdinal, scaleBinOrdinal, [Discrete, Discretizing]);
scale(Ordinal, d3_scale__WEBPACK_IMPORTED_MODULE_1__["default"], Discrete);
scale(Band, band, Discrete);
scale(Point, point, Discrete);
function isValidScaleType(type) {
  return scales.has(type);
}
function hasType(key, type) {
  const s = scales.get(key);
  return s && s.metadata[type];
}
function isContinuous(key) {
  return hasType(key, Continuous);
}
function isDiscrete(key) {
  return hasType(key, Discrete);
}
function isDiscretizing(key) {
  return hasType(key, Discretizing);
}
function isLogarithmic(key) {
  return hasType(key, Log);
}
function isTemporal(key) {
  return hasType(key, Temporal);
}
function isInterpolating(key) {
  return hasType(key, Interpolating);
}
function isQuantile(key) {
  return hasType(key, Quantile);
}

const scaleProps = ['clamp', 'base', 'constant', 'exponent'];
function interpolateRange(interpolator, range) {
  const start = range[0],
    span = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range) - start;
  return function (i) {
    return interpolator(start + i * span);
  };
}
function interpolateColors(colors, type, gamma) {
  return d3_interpolate__WEBPACK_IMPORTED_MODULE_18__["default"](interpolate(type || 'rgb', gamma), colors);
}
function quantizeInterpolator(interpolator, count) {
  const samples = new Array(count),
    n = count + 1;
  for (let i = 0; i < count;) samples[i] = interpolator(++i / n);
  return samples;
}
function scaleCopy(scale) {
  const t = scale.type,
    s = scale.copy();
  s.type = t;
  return s;
}
function scaleFraction(scale$1, min, max) {
  const delta = max - min;
  let i, t, s;
  if (!delta || !Number.isFinite(delta)) {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(0.5);
  } else {
    i = (t = scale$1.type).indexOf('-');
    t = i < 0 ? t : t.slice(i + 1);
    s = scale(t)().domain([min, max]).range([0, 1]);
    scaleProps.forEach(m => scale$1[m] ? s[m](scale$1[m]()) : 0);
    return s;
  }
}
function interpolate(type, gamma) {
  const interp = d3_interpolate__WEBPACK_IMPORTED_MODULE_19__[method(type)];
  return gamma != null && interp && interp.gamma ? interp.gamma(gamma) : interp;
}
function method(type) {
  return 'interpolate' + type.toLowerCase().split('-').map(s => s[0].toUpperCase() + s.slice(1)).join('');
}

const continuous = {
  blues: 'cfe1f2bed8eca8cee58fc1de74b2d75ba3cf4592c63181bd206fb2125ca40a4a90',
  greens: 'd3eecdc0e6baabdda594d3917bc77d60ba6c46ab5e329a512089430e7735036429',
  greys: 'e2e2e2d4d4d4c4c4c4b1b1b19d9d9d8888887575756262624d4d4d3535351e1e1e',
  oranges: 'fdd8b3fdc998fdb87bfda55efc9244f87f2cf06b18e4580bd14904b93d029f3303',
  purples: 'e2e1efd4d4e8c4c5e0b4b3d6a3a0cc928ec3827cb97566ae684ea25c3696501f8c',
  reds: 'fdc9b4fcb49afc9e80fc8767fa7051f6573fec3f2fdc2a25c81b1db21218970b13',
  blueGreen: 'd5efedc1e8e0a7ddd18bd2be70c6a958ba9144ad77319c5d2089460e7736036429',
  bluePurple: 'ccddecbad0e4a8c2dd9ab0d4919cc98d85be8b6db28a55a6873c99822287730f71',
  greenBlue: 'd3eecec5e8c3b1e1bb9bd8bb82cec269c2ca51b2cd3c9fc7288abd1675b10b60a1',
  orangeRed: 'fddcaffdcf9bfdc18afdad77fb9562f67d53ee6545e24932d32d1ebf130da70403',
  purpleBlue: 'dbdaebc8cee4b1c3de97b7d87bacd15b9fc93a90c01e7fb70b70ab056199045281',
  purpleBlueGreen: 'dbd8eac8cee4b0c3de93b7d872acd1549fc83892bb1c88a3097f8702736b016353',
  purpleRed: 'dcc9e2d3b3d7ce9eccd186c0da6bb2e14da0e23189d91e6fc61159ab07498f023a',
  redPurple: 'fccfccfcbec0faa9b8f98faff571a5ec539ddb3695c41b8aa908808d0179700174',
  yellowGreen: 'e4f4acd1eca0b9e2949ed68880c97c62bb6e47aa5e3297502083440e723b036034',
  yellowOrangeBrown: 'feeaa1fedd84fecc63feb746fca031f68921eb7215db5e0bc54c05ab3d038f3204',
  yellowOrangeRed: 'fee087fed16ffebd59fea849fd903efc7335f9522bee3423de1b20ca0b22af0225',
  blueOrange: '134b852f78b35da2cb9dcae1d2e5eff2f0ebfce0bafbbf74e8932fc5690d994a07',
  brownBlueGreen: '704108a0651ac79548e3c78af3e6c6eef1eac9e9e48ed1c74da79e187a72025147',
  purpleGreen: '5b1667834792a67fb6c9aed3e6d6e8eff0efd9efd5aedda971bb75368e490e5e29',
  purpleOrange: '4114696647968f83b7b9b4d6dadbebf3eeeafce0bafbbf74e8932fc5690d994a07',
  redBlue: '8c0d25bf363adf745ef4ae91fbdbc9f2efeed2e5ef9dcae15da2cb2f78b3134b85',
  redGrey: '8c0d25bf363adf745ef4ae91fcdccbfaf4f1e2e2e2c0c0c0969696646464343434',
  yellowGreenBlue: 'eff9bddbf1b4bde5b594d5b969c5be45b4c22c9ec02182b82163aa23479c1c3185',
  redYellowBlue: 'a50026d4322cf16e43fcac64fedd90faf8c1dcf1ecabd6e875abd04a74b4313695',
  redYellowGreen: 'a50026d4322cf16e43fcac63fedd8df9f7aed7ee8ea4d86e64bc6122964f006837',
  pinkYellowGreen: '8e0152c0267edd72adf0b3d6faddedf5f3efe1f2cab6de8780bb474f9125276419',
  spectral: '9e0142d13c4bf0704afcac63fedd8dfbf8b0e0f3a1a9dda269bda94288b55e4fa2',
  viridis: '440154470e61481a6c482575472f7d443a834144873d4e8a39568c35608d31688e2d708e2a788e27818e23888e21918d1f988b1fa08822a8842ab07f35b77943bf7154c56866cc5d7ad1518fd744a5db36bcdf27d2e21be9e51afde725',
  magma: '0000040404130b0924150e3720114b2c11603b0f704a107957157e651a80721f817f24828c29819a2e80a8327db6377ac43c75d1426fde4968e95462f1605df76f5cfa7f5efc8f65fe9f6dfeaf78febf84fece91fddea0fcedaffcfdbf',
  inferno: '0000040403130c0826170c3b240c4f330a5f420a68500d6c5d126e6b176e781c6d86216b932667a12b62ae305cbb3755c73e4cd24644dd513ae65c30ed6925f3771af8850ffb9506fca50afcb519fac62df6d645f2e661f3f484fcffa4',
  plasma: '0d088723069033059742039d5002a25d01a66a00a87801a88405a7900da49c179ea72198b12a90ba3488c33d80cb4779d35171da5a69e16462e76e5bed7953f2834cf68f44fa9a3dfca636fdb32ffec029fcce25f9dc24f5ea27f0f921',
  cividis: '00205100235800265d002961012b65042e670831690d346b11366c16396d1c3c6e213f6e26426e2c456e31476e374a6e3c4d6e42506e47536d4c566d51586e555b6e5a5e6e5e616e62646f66676f6a6a706e6d717270717573727976737c79747f7c75827f758682768985778c8877908b78938e789691789a94789e9778a19b78a59e77a9a177aea575b2a874b6ab73bbaf71c0b26fc5b66dc9b96acebd68d3c065d8c462ddc85fe2cb5ce7cf58ebd355f0d652f3da4ff7de4cfae249fce647',
  rainbow: '6e40aa883eb1a43db3bf3cafd83fa4ee4395fe4b83ff576eff6659ff7847ff8c38f3a130e2b72fcfcc36bee044aff05b8ff4576ff65b52f6673af27828ea8d1ddfa319d0b81cbecb23abd82f96e03d82e14c6edb5a5dd0664dbf6e40aa',
  sinebow: 'ff4040fc582af47218e78d0bd5a703bfbf00a7d5038de70b72f41858fc2a40ff402afc5818f4720be78d03d5a700bfbf03a7d50b8de71872f42a58fc4040ff582afc7218f48d0be7a703d5bf00bfd503a7e70b8df41872fc2a58ff4040',
  turbo: '23171b32204a3e2a71453493493eae4b49c54a53d7485ee44569ee4074f53c7ff8378af93295f72e9ff42ba9ef28b3e926bce125c5d925cdcf27d5c629dcbc2de3b232e9a738ee9d3ff39347f68950f9805afc7765fd6e70fe667cfd5e88fc5795fb51a1f84badf545b9f140c5ec3cd0e637dae034e4d931ecd12ef4c92bfac029ffb626ffad24ffa223ff9821ff8d1fff821dff771cfd6c1af76118f05616e84b14df4111d5380fcb2f0dc0260ab61f07ac1805a313029b0f00950c00910b00',
  browns: 'eedbbdecca96e9b97ae4a865dc9856d18954c7784cc0673fb85536ad44339f3632',
  tealBlues: 'bce4d89dd3d181c3cb65b3c245a2b9368fae347da0306a932c5985',
  teals: 'bbdfdfa2d4d58ac9c975bcbb61b0af4da5a43799982b8b8c1e7f7f127273006667',
  warmGreys: 'dcd4d0cec5c1c0b8b4b3aaa7a59c9998908c8b827f7e7673726866665c5a59504e',
  goldGreen: 'f4d166d5ca60b6c35c98bb597cb25760a6564b9c533f8f4f33834a257740146c36',
  goldOrange: 'f4d166f8be5cf8aa4cf5983bf3852aef701be2621fd65322c54923b142239e3a26',
  goldRed: 'f4d166f6be59f9aa51fc964ef6834bee734ae56249db5247cf4244c43141b71d3e',
  lightGreyRed: 'efe9e6e1dad7d5cbc8c8bdb9bbaea9cd967ddc7b43e15f19df4011dc000b',
  lightGreyTeal: 'e4eaead6dcddc8ced2b7c2c7a6b4bc64b0bf22a6c32295c11f85be1876bc',
  lightMulti: 'e0f1f2c4e9d0b0de9fd0e181f6e072f6c053f3993ef77440ef4a3c',
  lightOrange: 'f2e7daf7d5baf9c499fab184fa9c73f68967ef7860e8645bde515bd43d5b',
  lightTealBlue: 'e3e9e0c0dccf9aceca7abfc859afc0389fb9328dad2f7ca0276b95255988',
  darkBlue: '3232322d46681a5c930074af008cbf05a7ce25c0dd38daed50f3faffffff',
  darkGold: '3c3c3c584b37725e348c7631ae8b2bcfa424ecc31ef9de30fff184ffffff',
  darkGreen: '3a3a3a215748006f4d048942489e4276b340a6c63dd2d836ffeb2cffffaa',
  darkMulti: '3737371f5287197d8c29a86995ce3fffe800ffffff',
  darkRed: '3434347036339e3c38cc4037e75d1eec8620eeab29f0ce32ffeb2c'
};
const discrete = {
  accent: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_20__["default"],
  category10: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_21__["default"],
  category20: '1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5',
  category20b: '393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6',
  category20c: '3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9',
  dark2: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_22__["default"],
  observable10: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_23__["default"],
  paired: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_24__["default"],
  pastel1: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_25__["default"],
  pastel2: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_26__["default"],
  set1: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_27__["default"],
  set2: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_28__["default"],
  set3: d3_scale_chromatic__WEBPACK_IMPORTED_MODULE_29__["default"],
  tableau10: '4c78a8f58518e4575672b7b254a24beeca3bb279a2ff9da69d755dbab0ac',
  tableau20: '4c78a89ecae9f58518ffbf7954a24b88d27ab79a20f2cf5b43989483bcb6e45756ff9d9879706ebab0acd67195fcbfd2b279a2d6a5c99e765fd8b5a5'
};

function colors(palette) {
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(palette)) return palette;
  const n = palette.length / 6 | 0,
    c = new Array(n);
  for (let i = 0; i < n;) {
    c[i] = '#' + palette.slice(i * 6, ++i * 6);
  }
  return c;
}
function apply(_, f) {
  for (const k in _) scheme(k, f(_[k]));
}
const schemes = {};
apply(discrete, colors);
apply(continuous, _ => interpolateColors(colors(_)));
function scheme(name, scheme) {
  name = name && name.toLowerCase();
  if (arguments.length > 1) {
    schemes[name] = scheme;
    return this;
  } else {
    return schemes[name];
  }
}

const SymbolLegend = 'symbol';
const DiscreteLegend = 'discrete';
const GradientLegend = 'gradient';

const defaultFormatter = value => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? value.map(v => String(v)) : String(value);
const ascending = (a, b) => a[1] - b[1];
const descending = (a, b) => b[1] - a[1];

/**
 * Determine the tick count or interval function.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} count - The desired tick count or interval specifier.
 * @param {number} minStep - The desired minimum step between tick values.
 * @return {*} - The tick count or interval function.
 */
function tickCount(scale, count, minStep) {
  let step;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(count)) {
    if (scale.bins) {
      count = Math.max(count, scale.bins.length);
    }
    if (minStep != null) {
      count = Math.min(count, Math.floor((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(scale.domain()) / minStep || 1) + 1);
    }
  }
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(count)) {
    step = count.step;
    count = count.interval;
  }
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(count)) {
    count = scale.type === Time ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.timeInterval)(count) : scale.type == UTC ? (0,vega_time__WEBPACK_IMPORTED_MODULE_2__.utcInterval)(count) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Only time and utc scales accept interval strings.');
    if (step) count = count.every(step);
  }
  return count;
}

/**
 * Filter a set of candidate tick values, ensuring that only tick values
 * that lie within the scale range are included.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {Array<*>} ticks - The candidate tick values.
 * @param {*} count - The tick count or interval function.
 * @return {Array<*>} - The filtered tick values.
 */
function validTicks(scale, ticks, count) {
  let range = scale.range(),
    lo = range[0],
    hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(range),
    cmp = ascending;
  if (lo > hi) {
    range = hi;
    hi = lo;
    lo = range;
    cmp = descending;
  }
  lo = Math.floor(lo);
  hi = Math.ceil(hi);

  // filter ticks to valid values within the range
  // additionally sort ticks in range order (#2579)
  ticks = ticks.map(v => [v, scale(v)]).filter(_ => lo <= _[1] && _[1] <= hi).sort(cmp).map(_ => _[0]);
  if (count > 0 && ticks.length > 1) {
    const endpoints = [ticks[0], (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(ticks)];
    while (ticks.length > count && ticks.length >= 3) {
      ticks = ticks.filter((_, i) => !(i % 2));
    }
    if (ticks.length < 3) {
      ticks = endpoints;
    }
  }
  return ticks;
}

/**
 * Generate tick values for the given scale and approximate tick count or
 * interval value. If the scale has a 'ticks' method, it will be used to
 * generate the ticks, with the count argument passed as a parameter. If the
 * scale lacks a 'ticks' method, the full scale domain will be returned.
 * @param {Scale} scale - The scale for which to generate tick values.
 * @param {*} [count] - The approximate number of desired ticks.
 * @return {Array<*>} - The generated tick values.
 */
function tickValues(scale, count) {
  return scale.bins ? validTicks(scale, scale.bins, count) : scale.ticks ? scale.ticks(count) : scale.domain();
}

/**
 * Generate a label format function for a scale. If the scale has a
 * 'tickFormat' method, it will be used to generate the formatter, with the
 * count and specifier arguments passed as parameters. If the scale lacks a
 * 'tickFormat' method, the returned formatter performs simple string coercion.
 * If the input scale is a logarithmic scale and the format specifier does not
 * indicate a desired decimal precision, a special variable precision formatter
 * that automatically trims trailing zeroes will be generated.
 * @param {Scale} scale - The scale for which to generate the label formatter.
 * @param {*} [count] - The approximate number of desired ticks.
 * @param {string} [specifier] - The format specifier. Must be a legal d3
 *   specifier string (see https://github.com/d3/d3-format#formatSpecifier) or
 *   time multi-format specifier object.
 * @return {function(*):string} - The generated label formatter.
 */
function tickFormat(locale, scale, count, specifier, formatType, noSkip) {
  const type = scale.type;
  let format = defaultFormatter;
  if (type === Time || formatType === Time) {
    format = locale.timeFormat(specifier);
  } else if (type === UTC || formatType === UTC) {
    format = locale.utcFormat(specifier);
  } else if (isLogarithmic(type)) {
    const varfmt = locale.formatFloat(specifier);
    if (noSkip || scale.bins) {
      format = varfmt;
    } else {
      const test = tickLog(scale, count, false);
      format = _ => test(_) ? varfmt(_) : '';
    }
  } else if (scale.tickFormat) {
    // if d3 scale has tickFormat, it must be continuous
    const d = scale.domain();
    format = locale.formatSpan(d[0], d[d.length - 1], count, specifier);
  } else if (specifier) {
    format = locale.format(specifier);
  }
  return format;
}
function tickLog(scale, count, values) {
  const ticks = tickValues(scale, count),
    base = scale.base(),
    logb = Math.log(base),
    k = Math.max(1, base * count / ticks.length);

  // apply d3-scale's log format filter criteria
  const test = d => {
    let i = d / Math.pow(base, Math.round(Math.log(d) / logb));
    if (i * base < base - 0.5) i *= base;
    return i <= k;
  };
  return values ? ticks.filter(test) : test;
}

const symbols = {
  [Quantile]: 'quantiles',
  [Quantize]: 'thresholds',
  [Threshold]: 'domain'
};
const formats = {
  [Quantile]: 'quantiles',
  [Quantize]: 'domain'
};
function labelValues(scale, count) {
  return scale.bins ? binValues(scale.bins) : scale.type === Log ? tickLog(scale, count, true) : symbols[scale.type] ? thresholdValues(scale[symbols[scale.type]]()) : tickValues(scale, count);
}
function thresholdFormat(locale, scale, specifier) {
  const _ = scale[formats[scale.type]](),
    n = _.length;
  let d = n > 1 ? _[1] - _[0] : _[0],
    i;
  for (i = 1; i < n; ++i) {
    d = Math.min(d, _[i] - _[i - 1]);
  }

  // tickCount = 3 ticks times 10 for increased resolution
  return locale.formatSpan(0, d, 3 * 10, specifier);
}
function thresholdValues(thresholds) {
  const values = [-Infinity].concat(thresholds);
  values.max = +Infinity;
  return values;
}
function binValues(bins) {
  const values = bins.slice(0, -1);
  values.max = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(bins);
  return values;
}
const isDiscreteRange = scale => symbols[scale.type] || scale.bins;
function labelFormat(locale, scale, count, type, specifier, formatType, noSkip) {
  const format = formats[scale.type] && formatType !== Time && formatType !== UTC ? thresholdFormat(locale, scale, specifier) : tickFormat(locale, scale, count, specifier, formatType, noSkip);
  return type === SymbolLegend && isDiscreteRange(scale) ? formatRange(format) : type === DiscreteLegend ? formatDiscrete(format) : formatPoint(format);
}
const formatRange = format => (value, index, array) => {
  const limit = get(array[index + 1], get(array.max, +Infinity)),
    lo = formatValue(value, format),
    hi = formatValue(limit, format);
  return lo && hi ? lo + ' \u2013 ' + hi : hi ? '< ' + hi : '\u2265 ' + lo;
};
const get = (value, dflt) => value != null ? value : dflt;
const formatDiscrete = format => (value, index) => index ? format(value) : null;
const formatPoint = format => value => format(value);
const formatValue = (value, format) => Number.isFinite(value) ? format(value) : null;
function labelFraction(scale) {
  const domain = scale.domain(),
    count = domain.length - 1;
  let lo = +domain[0],
    hi = +(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(domain),
    span = hi - lo;
  if (scale.type === Threshold) {
    const adjust = count ? span / count : 0.1;
    lo -= adjust;
    hi += adjust;
    span = hi - lo;
  }
  return value => (value - lo) / span;
}

function format(locale, scale, specifier, formatType) {
  const type = formatType || scale.type;

  // replace abbreviated time specifiers to improve screen reader experience
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(specifier) && isTemporal(type)) {
    specifier = specifier.replace(/%a/g, '%A').replace(/%b/g, '%B');
  }
  return !specifier && type === Time ? locale.timeFormat('%A, %d %B %Y, %X') : !specifier && type === UTC ? locale.utcFormat('%A, %d %B %Y, %X UTC') : labelFormat(locale, scale, 5, null, specifier, formatType, true);
}
function domainCaption(locale, scale, opt) {
  opt = opt || {};
  const max = Math.max(3, opt.maxlen || 7),
    fmt = format(locale, scale, opt.format, opt.formatType);

  // if scale breaks domain into bins, describe boundaries
  if (isDiscretizing(scale.type)) {
    const v = labelValues(scale).slice(1).map(fmt),
      n = v.length;
    return `${n} boundar${n === 1 ? 'y' : 'ies'}: ${v.join(', ')}`;
  }

  // if scale domain is discrete, list values
  else if (isDiscrete(scale.type)) {
    const d = scale.domain(),
      n = d.length,
      v = n > max ? d.slice(0, max - 2).map(fmt).join(', ') + ', ending with ' + d.slice(-1).map(fmt) : d.map(fmt).join(', ');
    return `${n} value${n === 1 ? '' : 's'}: ${v}`;
  }

  // if scale domain is continuous, describe value range
  else {
    const d = scale.domain();
    return `values from ${fmt(d[0])} to ${fmt((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(d))}`;
  }
}




/***/ }),

/***/ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-scenegraph/build/vega-scenegraph.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bounds: () => (/* binding */ Bounds),
/* harmony export */   CanvasHandler: () => (/* binding */ CanvasHandler),
/* harmony export */   CanvasRenderer: () => (/* binding */ CanvasRenderer),
/* harmony export */   Gradient: () => (/* binding */ Gradient),
/* harmony export */   GroupItem: () => (/* binding */ GroupItem),
/* harmony export */   Handler: () => (/* binding */ Handler),
/* harmony export */   HybridHandler: () => (/* binding */ HybridHandler),
/* harmony export */   HybridRenderer: () => (/* binding */ HybridRenderer),
/* harmony export */   Item: () => (/* binding */ Item),
/* harmony export */   Marks: () => (/* binding */ Marks),
/* harmony export */   RenderType: () => (/* binding */ RenderType),
/* harmony export */   Renderer: () => (/* binding */ Renderer),
/* harmony export */   ResourceLoader: () => (/* binding */ ResourceLoader),
/* harmony export */   SVGHandler: () => (/* binding */ SVGHandler),
/* harmony export */   SVGRenderer: () => (/* binding */ SVGRenderer),
/* harmony export */   SVGStringRenderer: () => (/* binding */ SVGStringRenderer),
/* harmony export */   Scenegraph: () => (/* binding */ Scenegraph),
/* harmony export */   boundClip: () => (/* binding */ boundClip),
/* harmony export */   boundContext: () => (/* binding */ boundContext),
/* harmony export */   boundItem: () => (/* binding */ boundItem),
/* harmony export */   boundMark: () => (/* binding */ boundMark),
/* harmony export */   boundStroke: () => (/* binding */ boundStroke),
/* harmony export */   domChild: () => (/* binding */ domChild),
/* harmony export */   domClear: () => (/* binding */ domClear),
/* harmony export */   domCreate: () => (/* binding */ domCreate),
/* harmony export */   domFind: () => (/* binding */ domFind),
/* harmony export */   font: () => (/* binding */ font),
/* harmony export */   fontFamily: () => (/* binding */ fontFamily),
/* harmony export */   fontSize: () => (/* binding */ fontSize),
/* harmony export */   intersect: () => (/* binding */ intersect),
/* harmony export */   intersectBoxLine: () => (/* binding */ intersectBoxLine),
/* harmony export */   intersectPath: () => (/* binding */ intersectPath),
/* harmony export */   intersectPoint: () => (/* binding */ intersectPoint),
/* harmony export */   intersectRule: () => (/* binding */ intersectRule),
/* harmony export */   lineHeight: () => (/* binding */ lineHeight),
/* harmony export */   markup: () => (/* binding */ markup),
/* harmony export */   multiLineOffset: () => (/* binding */ multiLineOffset),
/* harmony export */   path: () => (/* reexport safe */ d3_path__WEBPACK_IMPORTED_MODULE_1__.path),
/* harmony export */   pathCurves: () => (/* binding */ curves),
/* harmony export */   pathEqual: () => (/* binding */ pathEqual),
/* harmony export */   pathParse: () => (/* binding */ parse),
/* harmony export */   pathRectangle: () => (/* binding */ vg_rect),
/* harmony export */   pathRender: () => (/* binding */ pathRender),
/* harmony export */   pathSymbols: () => (/* binding */ symbols),
/* harmony export */   pathTrail: () => (/* binding */ vg_trail),
/* harmony export */   point: () => (/* binding */ point),
/* harmony export */   renderModule: () => (/* binding */ renderModule),
/* harmony export */   resetSVGClipId: () => (/* binding */ resetSVGClipId),
/* harmony export */   resetSVGDefIds: () => (/* binding */ resetSVGDefIds),
/* harmony export */   sceneEqual: () => (/* binding */ sceneEqual),
/* harmony export */   sceneFromJSON: () => (/* binding */ sceneFromJSON),
/* harmony export */   scenePickVisit: () => (/* binding */ pickVisit),
/* harmony export */   sceneToJSON: () => (/* binding */ sceneToJSON),
/* harmony export */   sceneVisit: () => (/* binding */ visit),
/* harmony export */   sceneZOrder: () => (/* binding */ zorder),
/* harmony export */   serializeXML: () => (/* binding */ serializeXML),
/* harmony export */   setHybridRendererOptions: () => (/* binding */ setHybridRendererOptions),
/* harmony export */   textMetrics: () => (/* binding */ textMetrics)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/basis.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/basisClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/basisOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/bundle.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/cardinal.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/cardinalOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/cardinalClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/catmullRom.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/catmullRomClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/catmullRomOpen.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/linear.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/linearClosed.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/monotone.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/natural.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/curve/step.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/arc.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/area.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/line.js");
/* harmony import */ var d3_shape__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! d3-shape */ "./node_modules/d3-shape/src/symbol.js");
/* harmony import */ var d3_path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-path */ "./node_modules/d3-path/src/path.js");
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/build/vega-canvas.browser.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-loader */ "./node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");








let gradient_id = 0;
function resetSVGGradientId() {
  gradient_id = 0;
}
const patternPrefix = 'p_';
function isGradient(value) {
  return value && value.gradient;
}
function gradientRef(g, defs, base) {
  const type = g.gradient;
  let id = g.id,
    prefix = type === 'radial' ? patternPrefix : '';

  // check id, assign default values as needed
  if (!id) {
    id = g.id = 'gradient_' + gradient_id++;
    if (type === 'radial') {
      g.x1 = get(g.x1, 0.5);
      g.y1 = get(g.y1, 0.5);
      g.r1 = get(g.r1, 0);
      g.x2 = get(g.x2, 0.5);
      g.y2 = get(g.y2, 0.5);
      g.r2 = get(g.r2, 0.5);
      prefix = patternPrefix;
    } else {
      g.x1 = get(g.x1, 0);
      g.y1 = get(g.y1, 0);
      g.x2 = get(g.x2, 1);
      g.y2 = get(g.y2, 0);
    }
  }

  // register definition
  defs[id] = g;

  // return url reference
  return 'url(' + (base || '') + '#' + prefix + id + ')';
}
function get(val, def) {
  return val != null ? val : def;
}
function Gradient (p0, p1) {
  var stops = [],
    gradient;
  return gradient = {
    gradient: 'linear',
    x1: p0 ? p0[0] : 0,
    y1: p0 ? p0[1] : 0,
    x2: p1 ? p1[0] : 1,
    y2: p1 ? p1[1] : 0,
    stops: stops,
    stop: function (offset, color) {
      stops.push({
        offset: offset,
        color: color
      });
      return gradient;
    }
  };
}

const lookup = {
  'basis': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_5__["default"]
  },
  'basis-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_6__["default"]
  },
  'basis-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_7__["default"]
  },
  'bundle': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_8__["default"],
    tension: 'beta',
    value: 0.85
  },
  'cardinal': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_9__["default"],
    tension: 'tension',
    value: 0
  },
  'cardinal-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_10__["default"],
    tension: 'tension',
    value: 0
  },
  'cardinal-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_11__["default"],
    tension: 'tension',
    value: 0
  },
  'catmull-rom': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_12__["default"],
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_13__["default"],
    tension: 'alpha',
    value: 0.5
  },
  'catmull-rom-open': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_14__["default"],
    tension: 'alpha',
    value: 0.5
  },
  'linear': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_15__["default"]
  },
  'linear-closed': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_16__["default"]
  },
  'monotone': {
    horizontal: d3_shape__WEBPACK_IMPORTED_MODULE_17__.monotoneY,
    vertical: d3_shape__WEBPACK_IMPORTED_MODULE_17__.monotoneX
  },
  'natural': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_18__["default"]
  },
  'step': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_19__["default"]
  },
  'step-after': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_19__.stepAfter
  },
  'step-before': {
    curve: d3_shape__WEBPACK_IMPORTED_MODULE_19__.stepBefore
  }
};
function curves(type, orientation, tension) {
  var entry = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(lookup, type) && lookup[type],
    curve = null;
  if (entry) {
    curve = entry.curve || entry[orientation || 'vertical'];
    if (entry.tension && tension != null) {
      curve = curve[entry.tension](tension);
    }
  }
  return curve;
}

const paramCounts = {
  m: 2,
  l: 2,
  h: 1,
  v: 1,
  z: 0,
  c: 6,
  s: 4,
  q: 4,
  t: 2,
  a: 7
};
const commandPattern = /[mlhvzcsqta]([^mlhvzcsqta]+|$)/gi;
const numberPattern = /^[+-]?(([0-9]*\.[0-9]+)|([0-9]+\.)|([0-9]+))([eE][+-]?[0-9]+)?/;
const spacePattern = /^((\s+,?\s*)|(,\s*))/;
const flagPattern = /^[01]/;
function parse(path) {
  const commands = [];
  const matches = path.match(commandPattern) || [];
  matches.forEach(str => {
    let cmd = str[0];
    const type = cmd.toLowerCase();

    // parse parameters
    const paramCount = paramCounts[type];
    const params = parseParams(type, paramCount, str.slice(1).trim());
    const count = params.length;

    // error checking based on parameter count
    if (count < paramCount || count && count % paramCount !== 0) {
      throw Error('Invalid SVG path, incorrect parameter count');
    }

    // register the command
    commands.push([cmd, ...params.slice(0, paramCount)]);

    // exit now if we're done, also handles zero-param 'z'
    if (count === paramCount) {
      return;
    }

    // handle implicit line-to
    if (type === 'm') {
      cmd = cmd === 'M' ? 'L' : 'l';
    }

    // repeat command when given extended param list
    for (let i = paramCount; i < count; i += paramCount) {
      commands.push([cmd, ...params.slice(i, i + paramCount)]);
    }
  });
  return commands;
}
function parseParams(type, paramCount, segment) {
  const params = [];
  for (let index = 0; paramCount && index < segment.length;) {
    for (let i = 0; i < paramCount; ++i) {
      const pattern = type === 'a' && (i === 3 || i === 4) ? flagPattern : numberPattern;
      const match = segment.slice(index).match(pattern);
      if (match === null) {
        throw Error('Invalid SVG path, incorrect parameter type');
      }
      index += match[0].length;
      params.push(+match[0]);
      const ws = segment.slice(index).match(spacePattern);
      if (ws !== null) {
        index += ws[0].length;
      }
    }
  }
  return params;
}

const DegToRad = Math.PI / 180;
const Epsilon = 1e-14;
const HalfPi = Math.PI / 2;
const Tau = Math.PI * 2;
const HalfSqrt3 = Math.sqrt(3) / 2;

var segmentCache = {};
var bezierCache = {};
var join = [].join;

// Copied from Inkscape svgtopdf, thanks!
function segments(x, y, rx, ry, large, sweep, rotateX, ox, oy) {
  const key = join.call(arguments);
  if (segmentCache[key]) {
    return segmentCache[key];
  }
  const th = rotateX * DegToRad;
  const sin_th = Math.sin(th);
  const cos_th = Math.cos(th);
  rx = Math.abs(rx);
  ry = Math.abs(ry);
  const px = cos_th * (ox - x) * 0.5 + sin_th * (oy - y) * 0.5;
  const py = cos_th * (oy - y) * 0.5 - sin_th * (ox - x) * 0.5;
  let pl = px * px / (rx * rx) + py * py / (ry * ry);
  if (pl > 1) {
    pl = Math.sqrt(pl);
    rx *= pl;
    ry *= pl;
  }
  const a00 = cos_th / rx;
  const a01 = sin_th / rx;
  const a10 = -sin_th / ry;
  const a11 = cos_th / ry;
  const x0 = a00 * ox + a01 * oy;
  const y0 = a10 * ox + a11 * oy;
  const x1 = a00 * x + a01 * y;
  const y1 = a10 * x + a11 * y;
  const d = (x1 - x0) * (x1 - x0) + (y1 - y0) * (y1 - y0);
  let sfactor_sq = 1 / d - 0.25;
  if (sfactor_sq < 0) sfactor_sq = 0;
  let sfactor = Math.sqrt(sfactor_sq);
  if (sweep == large) sfactor = -sfactor;
  const xc = 0.5 * (x0 + x1) - sfactor * (y1 - y0);
  const yc = 0.5 * (y0 + y1) + sfactor * (x1 - x0);
  const th0 = Math.atan2(y0 - yc, x0 - xc);
  const th1 = Math.atan2(y1 - yc, x1 - xc);
  let th_arc = th1 - th0;
  if (th_arc < 0 && sweep === 1) {
    th_arc += Tau;
  } else if (th_arc > 0 && sweep === 0) {
    th_arc -= Tau;
  }
  const segs = Math.ceil(Math.abs(th_arc / (HalfPi + 0.001)));
  const result = [];
  for (let i = 0; i < segs; ++i) {
    const th2 = th0 + i * th_arc / segs;
    const th3 = th0 + (i + 1) * th_arc / segs;
    result[i] = [xc, yc, th2, th3, rx, ry, sin_th, cos_th];
  }
  return segmentCache[key] = result;
}
function bezier(params) {
  const key = join.call(params);
  if (bezierCache[key]) {
    return bezierCache[key];
  }
  var cx = params[0],
    cy = params[1],
    th0 = params[2],
    th1 = params[3],
    rx = params[4],
    ry = params[5],
    sin_th = params[6],
    cos_th = params[7];
  const a00 = cos_th * rx;
  const a01 = -sin_th * ry;
  const a10 = sin_th * rx;
  const a11 = cos_th * ry;
  const cos_th0 = Math.cos(th0);
  const sin_th0 = Math.sin(th0);
  const cos_th1 = Math.cos(th1);
  const sin_th1 = Math.sin(th1);
  const th_half = 0.5 * (th1 - th0);
  const sin_th_h2 = Math.sin(th_half * 0.5);
  const t = 8 / 3 * sin_th_h2 * sin_th_h2 / Math.sin(th_half);
  const x1 = cx + cos_th0 - t * sin_th0;
  const y1 = cy + sin_th0 + t * cos_th0;
  const x3 = cx + cos_th1;
  const y3 = cy + sin_th1;
  const x2 = x3 + t * sin_th1;
  const y2 = y3 - t * cos_th1;
  return bezierCache[key] = [a00 * x1 + a01 * y1, a10 * x1 + a11 * y1, a00 * x2 + a01 * y2, a10 * x2 + a11 * y2, a00 * x3 + a01 * y3, a10 * x3 + a11 * y3];
}

const temp = ['l', 0, 0, 0, 0, 0, 0, 0];
function scale$1(current, sX, sY) {
  const c = temp[0] = current[0];
  if (c === 'a' || c === 'A') {
    temp[1] = sX * current[1];
    temp[2] = sY * current[2];
    temp[3] = current[3];
    temp[4] = current[4];
    temp[5] = current[5];
    temp[6] = sX * current[6];
    temp[7] = sY * current[7];
  } else if (c === 'h' || c === 'H') {
    temp[1] = sX * current[1];
  } else if (c === 'v' || c === 'V') {
    temp[1] = sY * current[1];
  } else {
    for (var i = 1, n = current.length; i < n; ++i) {
      temp[i] = (i % 2 == 1 ? sX : sY) * current[i];
    }
  }
  return temp;
}
function pathRender (context, path, l, t, sX, sY) {
  var current,
    // current instruction
    previous = null,
    x = 0,
    // current x
    y = 0,
    // current y
    controlX = 0,
    // current control point x
    controlY = 0,
    // current control point y
    tempX,
    tempY,
    tempControlX,
    tempControlY,
    anchorX = 0,
    anchorY = 0;
  if (l == null) l = 0;
  if (t == null) t = 0;
  if (sX == null) sX = 1;
  if (sY == null) sY = sX;
  if (context.beginPath) context.beginPath();
  for (var i = 0, len = path.length; i < len; ++i) {
    current = path[i];
    if (sX !== 1 || sY !== 1) {
      current = scale$1(current, sX, sY);
    }
    switch (current[0]) {
      // first letter

      case 'l':
        // lineto, relative
        x += current[1];
        y += current[2];
        context.lineTo(x + l, y + t);
        break;
      case 'L':
        // lineto, absolute
        x = current[1];
        y = current[2];
        context.lineTo(x + l, y + t);
        break;
      case 'h':
        // horizontal lineto, relative
        x += current[1];
        context.lineTo(x + l, y + t);
        break;
      case 'H':
        // horizontal lineto, absolute
        x = current[1];
        context.lineTo(x + l, y + t);
        break;
      case 'v':
        // vertical lineto, relative
        y += current[1];
        context.lineTo(x + l, y + t);
        break;
      case 'V':
        // verical lineto, absolute
        y = current[1];
        context.lineTo(x + l, y + t);
        break;
      case 'm':
        // moveTo, relative
        x += current[1];
        y += current[2];
        anchorX = x;
        anchorY = y;
        context.moveTo(x + l, y + t);
        break;
      case 'M':
        // moveTo, absolute
        x = current[1];
        y = current[2];
        anchorX = x;
        anchorY = y;
        context.moveTo(x + l, y + t);
        break;
      case 'c':
        // bezierCurveTo, relative
        tempX = x + current[5];
        tempY = y + current[6];
        controlX = x + current[3];
        controlY = y + current[4];
        context.bezierCurveTo(x + current[1] + l,
        // x1
        y + current[2] + t,
        // y1
        controlX + l,
        // x2
        controlY + t,
        // y2
        tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;
      case 'C':
        // bezierCurveTo, absolute
        x = current[5];
        y = current[6];
        controlX = current[3];
        controlY = current[4];
        context.bezierCurveTo(current[1] + l, current[2] + t, controlX + l, controlY + t, x + l, y + t);
        break;
      case 's':
        // shorthand cubic bezierCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, x + current[1] + l, y + current[2] + t, tempX + l, tempY + t);

        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = x + current[1];
        controlY = y + current[2];
        x = tempX;
        y = tempY;
        break;
      case 'S':
        // shorthand cubic bezierCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.bezierCurveTo(controlX + l, controlY + t, current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        // set control point to 2nd one of this command
        // the first control point is assumed to be the reflection of
        // the second control point on the previous command relative
        // to the current point.
        controlX = current[1];
        controlY = current[2];
        break;
      case 'q':
        // quadraticCurveTo, relative
        // transform to absolute x,y
        tempX = x + current[3];
        tempY = y + current[4];
        controlX = x + current[1];
        controlY = y + current[2];
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;
      case 'Q':
        // quadraticCurveTo, absolute
        tempX = current[3];
        tempY = current[4];
        context.quadraticCurveTo(current[1] + l, current[2] + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = current[1];
        controlY = current[2];
        break;
      case 't':
        // shorthand quadraticCurveTo, relative

        // transform to absolute x,y
        tempX = x + current[1];
        tempY = y + current[2];
        if (previous[0].match(/[QqTt]/) === null) {
          // If there is no previous command or if the previous command was not a Q, q, T or t,
          // assume the control point is coincident with the current point
          controlX = x;
          controlY = y;
        } else if (previous[0] === 't') {
          // calculate reflection of previous control points for t
          controlX = 2 * x - tempControlX;
          controlY = 2 * y - tempControlY;
        } else if (previous[0] === 'q') {
          // calculate reflection of previous control points for q
          controlX = 2 * x - controlX;
          controlY = 2 * y - controlY;
        }
        tempControlX = controlX;
        tempControlY = controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        controlX = x + current[1];
        controlY = y + current[2];
        break;
      case 'T':
        tempX = current[1];
        tempY = current[2];

        // calculate reflection of previous control points
        controlX = 2 * x - controlX;
        controlY = 2 * y - controlY;
        context.quadraticCurveTo(controlX + l, controlY + t, tempX + l, tempY + t);
        x = tempX;
        y = tempY;
        break;
      case 'a':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + x + l, current[7] + y + t]);
        x += current[6];
        y += current[7];
        break;
      case 'A':
        drawArc(context, x + l, y + t, [current[1], current[2], current[3], current[4], current[5], current[6] + l, current[7] + t]);
        x = current[6];
        y = current[7];
        break;
      case 'z':
      case 'Z':
        x = anchorX;
        y = anchorY;
        context.closePath();
        break;
    }
    previous = current;
  }
}
function drawArc(context, x, y, coords) {
  const seg = segments(coords[5],
  // end x
  coords[6],
  // end y
  coords[0],
  // radius x
  coords[1],
  // radius y
  coords[3],
  // large flag
  coords[4],
  // sweep flag
  coords[2],
  // rotation
  x, y);
  for (let i = 0; i < seg.length; ++i) {
    const bez = bezier(seg[i]);
    context.bezierCurveTo(bez[0], bez[1], bez[2], bez[3], bez[4], bez[5]);
  }
}

const Tan30 = 0.5773502691896257;
const builtins = {
  'circle': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(r, 0);
      context.arc(0, 0, r, 0, Tau);
    }
  },
  'cross': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        s = r / 2.5;
      context.moveTo(-r, -s);
      context.lineTo(-r, s);
      context.lineTo(-s, s);
      context.lineTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, s);
      context.lineTo(r, s);
      context.lineTo(r, -s);
      context.lineTo(s, -s);
      context.lineTo(s, -r);
      context.lineTo(-s, -r);
      context.lineTo(-s, -s);
      context.closePath();
    }
  },
  'diamond': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(0, -r);
      context.lineTo(r, 0);
      context.lineTo(0, r);
      context.closePath();
    }
  },
  'square': {
    draw: function (context, size) {
      var w = Math.sqrt(size),
        x = -w / 2;
      context.rect(x, x, w, w);
    }
  },
  'arrow': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        s = r / 7,
        t = r / 2.5,
        v = r / 8;
      context.moveTo(-s, r);
      context.lineTo(s, r);
      context.lineTo(s, -v);
      context.lineTo(t, -v);
      context.lineTo(0, -r);
      context.lineTo(-t, -v);
      context.lineTo(-s, -v);
      context.closePath();
    }
  },
  'wedge': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        h = HalfSqrt3 * r,
        o = h - r * Tan30,
        b = r / 4;
      context.moveTo(0, -h - o);
      context.lineTo(-b, h - o);
      context.lineTo(b, h - o);
      context.closePath();
    }
  },
  'triangle': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        h = HalfSqrt3 * r,
        o = h - r * Tan30;
      context.moveTo(0, -h - o);
      context.lineTo(-r, h - o);
      context.lineTo(r, h - o);
      context.closePath();
    }
  },
  'triangle-up': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        h = HalfSqrt3 * r;
      context.moveTo(0, -h);
      context.lineTo(-r, h);
      context.lineTo(r, h);
      context.closePath();
    }
  },
  'triangle-down': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        h = HalfSqrt3 * r;
      context.moveTo(0, h);
      context.lineTo(-r, -h);
      context.lineTo(r, -h);
      context.closePath();
    }
  },
  'triangle-right': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        h = HalfSqrt3 * r;
      context.moveTo(h, 0);
      context.lineTo(-h, -r);
      context.lineTo(-h, r);
      context.closePath();
    }
  },
  'triangle-left': {
    draw: function (context, size) {
      var r = Math.sqrt(size) / 2,
        h = HalfSqrt3 * r;
      context.moveTo(-h, 0);
      context.lineTo(h, -r);
      context.lineTo(h, r);
      context.closePath();
    }
  },
  'stroke': {
    draw: function (context, size) {
      const r = Math.sqrt(size) / 2;
      context.moveTo(-r, 0);
      context.lineTo(r, 0);
    }
  }
};
function symbols(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(builtins, _) ? builtins[_] : customSymbol(_);
}
var custom = {};
function customSymbol(path) {
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(custom, path)) {
    const parsed = parse(path);
    custom[path] = {
      draw: function (context, size) {
        pathRender(context, parsed, 0, 0, Math.sqrt(size) / 2);
      }
    };
  }
  return custom[path];
}

// See http://spencermortensen.com/articles/bezier-circle/
const C = 0.448084975506; // C = 1 - c

function rectangleX(d) {
  return d.x;
}
function rectangleY(d) {
  return d.y;
}
function rectangleWidth(d) {
  return d.width;
}
function rectangleHeight(d) {
  return d.height;
}
function number(_) {
  return typeof _ === 'function' ? _ : () => +_;
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(value, max));
}
function vg_rect () {
  var x = rectangleX,
    y = rectangleY,
    width = rectangleWidth,
    height = rectangleHeight,
    crTL = number(0),
    crTR = crTL,
    crBL = crTL,
    crBR = crTL,
    context = null;
  function rectangle(_, x0, y0) {
    var buffer,
      x1 = x0 != null ? x0 : +x.call(this, _),
      y1 = y0 != null ? y0 : +y.call(this, _),
      w = +width.call(this, _),
      h = +height.call(this, _),
      s = Math.min(w, h) / 2,
      tl = clamp(+crTL.call(this, _), 0, s),
      tr = clamp(+crTR.call(this, _), 0, s),
      bl = clamp(+crBL.call(this, _), 0, s),
      br = clamp(+crBR.call(this, _), 0, s);
    if (!context) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_1__.path)();
    if (tl <= 0 && tr <= 0 && bl <= 0 && br <= 0) {
      context.rect(x1, y1, w, h);
    } else {
      var x2 = x1 + w,
        y2 = y1 + h;
      context.moveTo(x1 + tl, y1);
      context.lineTo(x2 - tr, y1);
      context.bezierCurveTo(x2 - C * tr, y1, x2, y1 + C * tr, x2, y1 + tr);
      context.lineTo(x2, y2 - br);
      context.bezierCurveTo(x2, y2 - C * br, x2 - C * br, y2, x2 - br, y2);
      context.lineTo(x1 + bl, y2);
      context.bezierCurveTo(x1 + C * bl, y2, x1, y2 - C * bl, x1, y2 - bl);
      context.lineTo(x1, y1 + tl);
      context.bezierCurveTo(x1, y1 + C * tl, x1 + C * tl, y1, x1 + tl, y1);
      context.closePath();
    }
    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }
  rectangle.x = function (_) {
    if (arguments.length) {
      x = number(_);
      return rectangle;
    } else {
      return x;
    }
  };
  rectangle.y = function (_) {
    if (arguments.length) {
      y = number(_);
      return rectangle;
    } else {
      return y;
    }
  };
  rectangle.width = function (_) {
    if (arguments.length) {
      width = number(_);
      return rectangle;
    } else {
      return width;
    }
  };
  rectangle.height = function (_) {
    if (arguments.length) {
      height = number(_);
      return rectangle;
    } else {
      return height;
    }
  };
  rectangle.cornerRadius = function (tl, tr, br, bl) {
    if (arguments.length) {
      crTL = number(tl);
      crTR = tr != null ? number(tr) : crTL;
      crBR = br != null ? number(br) : crTL;
      crBL = bl != null ? number(bl) : crTR;
      return rectangle;
    } else {
      return crTL;
    }
  };
  rectangle.context = function (_) {
    if (arguments.length) {
      context = _ == null ? null : _;
      return rectangle;
    } else {
      return context;
    }
  };
  return rectangle;
}

function vg_trail () {
  var x,
    y,
    size,
    defined,
    context = null,
    ready,
    x1,
    y1,
    r1;
  function point(x2, y2, w2) {
    const r2 = w2 / 2;
    if (ready) {
      var ux = y1 - y2,
        uy = x2 - x1;
      if (ux || uy) {
        // get normal vector
        var ud = Math.hypot(ux, uy),
          rx = (ux /= ud) * r1,
          ry = (uy /= ud) * r1,
          t = Math.atan2(uy, ux);

        // draw segment
        context.moveTo(x1 - rx, y1 - ry);
        context.lineTo(x2 - ux * r2, y2 - uy * r2);
        context.arc(x2, y2, r2, t - Math.PI, t);
        context.lineTo(x1 + rx, y1 + ry);
        context.arc(x1, y1, r1, t, t + Math.PI);
      } else {
        context.arc(x2, y2, r2, 0, Tau);
      }
      context.closePath();
    } else {
      ready = 1;
    }
    x1 = x2;
    y1 = y2;
    r1 = r2;
  }
  function trail(data) {
    var i,
      n = data.length,
      d,
      defined0 = false,
      buffer;
    if (context == null) context = buffer = (0,d3_path__WEBPACK_IMPORTED_MODULE_1__.path)();
    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) ready = 0;
      }
      if (defined0) point(+x(d, i, data), +y(d, i, data), +size(d, i, data));
    }
    if (buffer) {
      context = null;
      return buffer + '' || null;
    }
  }
  trail.x = function (_) {
    if (arguments.length) {
      x = _;
      return trail;
    } else {
      return x;
    }
  };
  trail.y = function (_) {
    if (arguments.length) {
      y = _;
      return trail;
    } else {
      return y;
    }
  };
  trail.size = function (_) {
    if (arguments.length) {
      size = _;
      return trail;
    } else {
      return size;
    }
  };
  trail.defined = function (_) {
    if (arguments.length) {
      defined = _;
      return trail;
    } else {
      return defined;
    }
  };
  trail.context = function (_) {
    if (arguments.length) {
      if (_ == null) {
        context = null;
      } else {
        context = _;
      }
      return trail;
    } else {
      return context;
    }
  };
  return trail;
}

function value$1(a, b) {
  return a != null ? a : b;
}
const x = item => item.x || 0,
  y = item => item.y || 0,
  w = item => item.width || 0,
  h = item => item.height || 0,
  xw = item => (item.x || 0) + (item.width || 0),
  yh = item => (item.y || 0) + (item.height || 0),
  sa = item => item.startAngle || 0,
  ea = item => item.endAngle || 0,
  pa = item => item.padAngle || 0,
  ir = item => item.innerRadius || 0,
  or = item => item.outerRadius || 0,
  cr = item => item.cornerRadius || 0,
  tl = item => value$1(item.cornerRadiusTopLeft, item.cornerRadius) || 0,
  tr = item => value$1(item.cornerRadiusTopRight, item.cornerRadius) || 0,
  br = item => value$1(item.cornerRadiusBottomRight, item.cornerRadius) || 0,
  bl = item => value$1(item.cornerRadiusBottomLeft, item.cornerRadius) || 0,
  sz = item => value$1(item.size, 64),
  ts = item => item.size || 1,
  def = item => !(item.defined === false),
  type = item => symbols(item.shape || 'circle');
const arcShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_20__["default"])().startAngle(sa).endAngle(ea).padAngle(pa).innerRadius(ir).outerRadius(or).cornerRadius(cr),
  areavShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__["default"])().x(x).y1(y).y0(yh).defined(def),
  areahShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_21__["default"])().y(y).x1(x).x0(xw).defined(def),
  lineShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_22__["default"])().x(x).y(y).defined(def),
  rectShape = vg_rect().x(x).y(y).width(w).height(h).cornerRadius(tl, tr, br, bl),
  symbolShape = (0,d3_shape__WEBPACK_IMPORTED_MODULE_23__["default"])().type(type).size(sz),
  trailShape = vg_trail().x(x).y(y).defined(def).size(ts);
function hasCornerRadius(item) {
  return item.cornerRadius || item.cornerRadiusTopLeft || item.cornerRadiusTopRight || item.cornerRadiusBottomRight || item.cornerRadiusBottomLeft;
}
function arc$1(context, item) {
  return arcShape.context(context)(item);
}
function area$1(context, items) {
  const item = items[0],
    interp = item.interpolate || 'linear';
  return (item.orient === 'horizontal' ? areahShape : areavShape).curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function line$1(context, items) {
  const item = items[0],
    interp = item.interpolate || 'linear';
  return lineShape.curve(curves(interp, item.orient, item.tension)).context(context)(items);
}
function rectangle(context, item, x, y) {
  return rectShape.context(context)(item, x, y);
}
function shape$1(context, item) {
  return (item.mark.shape || item.shape).context(context)(item);
}
function symbol$1(context, item) {
  return symbolShape.context(context)(item);
}
function trail$1(context, items) {
  return trailShape.context(context)(items);
}

var clip_id = 1;
function resetSVGClipId() {
  clip_id = 1;
}
function clip$1 (renderer, item, size) {
  var clip = item.clip,
    defs = renderer._defs,
    id = item.clip_id || (item.clip_id = 'clip' + clip_id++),
    c = defs.clipping[id] || (defs.clipping[id] = {
      id: id
    });
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    c.path = clip(null);
  } else if (hasCornerRadius(size)) {
    c.path = rectangle(null, size, 0, 0);
  } else {
    c.width = size.width || 0;
    c.height = size.height || 0;
  }
  return 'url(#' + id + ')';
}

function Bounds(b) {
  this.clear();
  if (b) this.union(b);
}
Bounds.prototype = {
  clone() {
    return new Bounds(this);
  },
  clear() {
    this.x1 = +Number.MAX_VALUE;
    this.y1 = +Number.MAX_VALUE;
    this.x2 = -Number.MAX_VALUE;
    this.y2 = -Number.MAX_VALUE;
    return this;
  },
  empty() {
    return this.x1 === +Number.MAX_VALUE && this.y1 === +Number.MAX_VALUE && this.x2 === -Number.MAX_VALUE && this.y2 === -Number.MAX_VALUE;
  },
  equals(b) {
    return this.x1 === b.x1 && this.y1 === b.y1 && this.x2 === b.x2 && this.y2 === b.y2;
  },
  set(x1, y1, x2, y2) {
    if (x2 < x1) {
      this.x2 = x1;
      this.x1 = x2;
    } else {
      this.x1 = x1;
      this.x2 = x2;
    }
    if (y2 < y1) {
      this.y2 = y1;
      this.y1 = y2;
    } else {
      this.y1 = y1;
      this.y2 = y2;
    }
    return this;
  },
  add(x, y) {
    if (x < this.x1) this.x1 = x;
    if (y < this.y1) this.y1 = y;
    if (x > this.x2) this.x2 = x;
    if (y > this.y2) this.y2 = y;
    return this;
  },
  expand(d) {
    this.x1 -= d;
    this.y1 -= d;
    this.x2 += d;
    this.y2 += d;
    return this;
  },
  round() {
    this.x1 = Math.floor(this.x1);
    this.y1 = Math.floor(this.y1);
    this.x2 = Math.ceil(this.x2);
    this.y2 = Math.ceil(this.y2);
    return this;
  },
  scale(s) {
    this.x1 *= s;
    this.y1 *= s;
    this.x2 *= s;
    this.y2 *= s;
    return this;
  },
  translate(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  },
  rotate(angle, x, y) {
    const p = this.rotatedPoints(angle, x, y);
    return this.clear().add(p[0], p[1]).add(p[2], p[3]).add(p[4], p[5]).add(p[6], p[7]);
  },
  rotatedPoints(angle, x, y) {
    var {
        x1,
        y1,
        x2,
        y2
      } = this,
      cos = Math.cos(angle),
      sin = Math.sin(angle),
      cx = x - x * cos + y * sin,
      cy = y - x * sin - y * cos;
    return [cos * x1 - sin * y1 + cx, sin * x1 + cos * y1 + cy, cos * x1 - sin * y2 + cx, sin * x1 + cos * y2 + cy, cos * x2 - sin * y1 + cx, sin * x2 + cos * y1 + cy, cos * x2 - sin * y2 + cx, sin * x2 + cos * y2 + cy];
  },
  union(b) {
    if (b.x1 < this.x1) this.x1 = b.x1;
    if (b.y1 < this.y1) this.y1 = b.y1;
    if (b.x2 > this.x2) this.x2 = b.x2;
    if (b.y2 > this.y2) this.y2 = b.y2;
    return this;
  },
  intersect(b) {
    if (b.x1 > this.x1) this.x1 = b.x1;
    if (b.y1 > this.y1) this.y1 = b.y1;
    if (b.x2 < this.x2) this.x2 = b.x2;
    if (b.y2 < this.y2) this.y2 = b.y2;
    return this;
  },
  encloses(b) {
    return b && this.x1 <= b.x1 && this.x2 >= b.x2 && this.y1 <= b.y1 && this.y2 >= b.y2;
  },
  alignsWith(b) {
    return b && (this.x1 == b.x1 || this.x2 == b.x2 || this.y1 == b.y1 || this.y2 == b.y2);
  },
  intersects(b) {
    return b && !(this.x2 < b.x1 || this.x1 > b.x2 || this.y2 < b.y1 || this.y1 > b.y2);
  },
  contains(x, y) {
    return !(x < this.x1 || x > this.x2 || y < this.y1 || y > this.y2);
  },
  width() {
    return this.x2 - this.x1;
  },
  height() {
    return this.y2 - this.y1;
  }
};

function Item(mark) {
  this.mark = mark;
  this.bounds = this.bounds || new Bounds();
}

function GroupItem(mark) {
  Item.call(this, mark);
  this.items = this.items || [];
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(GroupItem, Item);

class ResourceLoader {
  constructor(customLoader) {
    this._pending = 0;
    this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_3__.loader)();
  }
  pending() {
    return this._pending;
  }
  sanitizeURL(uri) {
    const loader = this;
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'href'
    }).then(opt => {
      decrement(loader);
      return opt;
    }).catch(() => {
      decrement(loader);
      return null;
    });
  }
  loadImage(uri) {
    const loader = this,
      Image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_2__.image)();
    increment(loader);
    return loader._loader.sanitize(uri, {
      context: 'image'
    }).then(opt => {
      const url = opt.href;
      if (!url || !Image) throw {
        url: url
      };
      const img = new Image();

      // set crossOrigin only if cors is defined; empty string sets anonymous mode
      // https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement/crossOrigin
      const cors = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(opt, 'crossOrigin') ? opt.crossOrigin : 'anonymous';
      if (cors != null) img.crossOrigin = cors;

      // attempt to load image resource
      img.onload = () => decrement(loader);
      img.onerror = () => decrement(loader);
      img.src = url;
      return img;
    }).catch(e => {
      decrement(loader);
      return {
        complete: false,
        width: 0,
        height: 0,
        src: e && e.url || ''
      };
    });
  }
  ready() {
    const loader = this;
    return new Promise(accept => {
      function poll(value) {
        if (!loader.pending()) accept(value);else setTimeout(() => {
          poll(true);
        }, 10);
      }
      poll(false);
    });
  }
}
function increment(loader) {
  loader._pending += 1;
}
function decrement(loader) {
  loader._pending -= 1;
}

function boundStroke (bounds, item, miter) {
  if (item.stroke && item.opacity !== 0 && item.strokeOpacity !== 0) {
    const sw = item.strokeWidth != null ? +item.strokeWidth : 1;
    bounds.expand(sw + (miter ? miterAdjustment(item, sw) : 0));
  }
  return bounds;
}
function miterAdjustment(item, strokeWidth) {
  // TODO: more sophisticated adjustment? Or miter support in boundContext?
  return item.strokeJoin && item.strokeJoin !== 'miter' ? 0 : strokeWidth;
}

const circleThreshold = Tau - 1e-8;
let bounds, lx, ly, rot, ma, mb, mc, md;
const add = (x, y) => bounds.add(x, y);
const addL = (x, y) => add(lx = x, ly = y);
const addX = x => add(x, bounds.y1);
const addY = y => add(bounds.x1, y);
const px = (x, y) => ma * x + mc * y;
const py = (x, y) => mb * x + md * y;
const addp = (x, y) => add(px(x, y), py(x, y));
const addpL = (x, y) => addL(px(x, y), py(x, y));
function boundContext (_, deg) {
  bounds = _;
  if (deg) {
    rot = deg * DegToRad;
    ma = md = Math.cos(rot);
    mb = Math.sin(rot);
    mc = -mb;
  } else {
    ma = md = 1;
    rot = mb = mc = 0;
  }
  return context$1;
}
const context$1 = {
  beginPath() {},
  closePath() {},
  moveTo: addpL,
  lineTo: addpL,
  rect(x, y, w, h) {
    if (rot) {
      addp(x + w, y);
      addp(x + w, y + h);
      addp(x, y + h);
      addpL(x, y);
    } else {
      add(x + w, y + h);
      addL(x, y);
    }
  },
  quadraticCurveTo(x1, y1, x2, y2) {
    const px1 = px(x1, y1),
      py1 = py(x1, y1),
      px2 = px(x2, y2),
      py2 = py(x2, y2);
    quadExtrema(lx, px1, px2, addX);
    quadExtrema(ly, py1, py2, addY);
    addL(px2, py2);
  },
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    const px1 = px(x1, y1),
      py1 = py(x1, y1),
      px2 = px(x2, y2),
      py2 = py(x2, y2),
      px3 = px(x3, y3),
      py3 = py(x3, y3);
    cubicExtrema(lx, px1, px2, px3, addX);
    cubicExtrema(ly, py1, py2, py3, addY);
    addL(px3, py3);
  },
  arc(cx, cy, r, sa, ea, ccw) {
    sa += rot;
    ea += rot;

    // store last point on path
    lx = r * Math.cos(ea) + cx;
    ly = r * Math.sin(ea) + cy;
    if (Math.abs(ea - sa) > circleThreshold) {
      // treat as full circle
      add(cx - r, cy - r);
      add(cx + r, cy + r);
    } else {
      const update = a => add(r * Math.cos(a) + cx, r * Math.sin(a) + cy);
      let s, i;

      // sample end points
      update(sa);
      update(ea);

      // sample interior points aligned with 90 degrees
      if (ea !== sa) {
        sa = sa % Tau;
        if (sa < 0) sa += Tau;
        ea = ea % Tau;
        if (ea < 0) ea += Tau;
        if (ea < sa) {
          ccw = !ccw; // flip direction
          s = sa;
          sa = ea;
          ea = s; // swap end-points
        }
        if (ccw) {
          ea -= Tau;
          s = sa - sa % HalfPi;
          for (i = 0; i < 4 && s > ea; ++i, s -= HalfPi) update(s);
        } else {
          s = sa - sa % HalfPi + HalfPi;
          for (i = 0; i < 4 && s < ea; ++i, s = s + HalfPi) update(s);
        }
      }
    }
  }
};
function quadExtrema(x0, x1, x2, cb) {
  const t = (x0 - x1) / (x0 + x2 - 2 * x1);
  if (0 < t && t < 1) cb(x0 + (x1 - x0) * t);
}
function cubicExtrema(x0, x1, x2, x3, cb) {
  const a = x3 - x0 + 3 * x1 - 3 * x2,
    b = x0 + x2 - 2 * x1,
    c = x0 - x1;
  let t0 = 0,
    t1 = 0,
    r;

  // solve for parameter t
  if (Math.abs(a) > Epsilon) {
    // quadratic equation
    r = b * b + c * a;
    if (r >= 0) {
      r = Math.sqrt(r);
      t0 = (-b + r) / a;
      t1 = (-b - r) / a;
    }
  } else {
    // linear equation
    t0 = 0.5 * c / b;
  }

  // calculate position
  if (0 < t0 && t0 < 1) cb(cubic(t0, x0, x1, x2, x3));
  if (0 < t1 && t1 < 1) cb(cubic(t1, x0, x1, x2, x3));
}
function cubic(t, x0, x1, x2, x3) {
  const s = 1 - t,
    s2 = s * s,
    t2 = t * t;
  return s2 * s * x0 + 3 * s2 * t * x1 + 3 * s * t2 * x2 + t2 * t * x3;
}

var context = (context = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_2__.canvas)(1, 1)) ? context.getContext('2d') : null;

const b = new Bounds();
function intersectPath(draw) {
  return function (item, brush) {
    // rely on (inaccurate) bounds intersection if no context
    if (!context) return true;

    // add path to offscreen graphics context
    draw(context, item);

    // get bounds intersection region
    b.clear().union(item.bounds).intersect(brush).round();
    const {
      x1,
      y1,
      x2,
      y2
    } = b;

    // iterate over intersection region
    // perform fine grained inclusion test
    for (let y = y1; y <= y2; ++y) {
      for (let x = x1; x <= x2; ++x) {
        if (context.isPointInPath(x, y)) {
          return true;
        }
      }
    }

    // false if no hits in intersection region
    return false;
  };
}
function intersectPoint(item, box) {
  return box.contains(item.x || 0, item.y || 0);
}
function intersectRect(item, box) {
  const x = item.x || 0,
    y = item.y || 0,
    w = item.width || 0,
    h = item.height || 0;
  return box.intersects(b.set(x, y, x + w, y + h));
}
function intersectRule(item, box) {
  const x = item.x || 0,
    y = item.y || 0,
    x2 = item.x2 != null ? item.x2 : x,
    y2 = item.y2 != null ? item.y2 : y;
  return intersectBoxLine(box, x, y, x2, y2);
}
function intersectBoxLine(box, x, y, u, v) {
  const {
      x1,
      y1,
      x2,
      y2
    } = box,
    dx = u - x,
    dy = v - y;
  let t0 = 0,
    t1 = 1,
    p,
    q,
    r,
    e;
  for (e = 0; e < 4; ++e) {
    if (e === 0) {
      p = -dx;
      q = -(x1 - x);
    }
    if (e === 1) {
      p = dx;
      q = x2 - x;
    }
    if (e === 2) {
      p = -dy;
      q = -(y1 - y);
    }
    if (e === 3) {
      p = dy;
      q = y2 - y;
    }
    if (Math.abs(p) < 1e-10 && q < 0) return false;
    r = q / p;
    if (p < 0) {
      if (r > t1) return false;else if (r > t0) t0 = r;
    } else if (p > 0) {
      if (r < t0) return false;else if (r < t1) t1 = r;
    }
  }
  return true;
}

function blend (context, item) {
  context.globalCompositeOperation = item.blend || 'source-over';
}

function value (value, dflt) {
  return value == null ? dflt : value;
}

function addStops(gradient, stops) {
  const n = stops.length;
  for (let i = 0; i < n; ++i) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient;
}
function gradient (context, spec, bounds) {
  const w = bounds.width(),
    h = bounds.height();
  let gradient;
  if (spec.gradient === 'radial') {
    gradient = context.createRadialGradient(bounds.x1 + value(spec.x1, 0.5) * w, bounds.y1 + value(spec.y1, 0.5) * h, Math.max(w, h) * value(spec.r1, 0), bounds.x1 + value(spec.x2, 0.5) * w, bounds.y1 + value(spec.y2, 0.5) * h, Math.max(w, h) * value(spec.r2, 0.5));
  } else {
    // linear gradient
    const x1 = value(spec.x1, 0),
      y1 = value(spec.y1, 0),
      x2 = value(spec.x2, 1),
      y2 = value(spec.y2, 0);
    if (x1 === x2 || y1 === y2 || w === h) {
      // axis aligned: use normal gradient
      gradient = context.createLinearGradient(bounds.x1 + x1 * w, bounds.y1 + y1 * h, bounds.x1 + x2 * w, bounds.y1 + y2 * h);
    } else {
      // not axis aligned: render gradient into a pattern (#2365)
      // this allows us to use normalized bounding box coordinates
      const image = (0,vega_canvas__WEBPACK_IMPORTED_MODULE_2__.canvas)(Math.ceil(w), Math.ceil(h)),
        ictx = image.getContext('2d');
      ictx.scale(w, h);
      ictx.fillStyle = addStops(ictx.createLinearGradient(x1, y1, x2, y2), spec.stops);
      ictx.fillRect(0, 0, w, h);
      return context.createPattern(image, 'no-repeat');
    }
  }
  return addStops(gradient, spec.stops);
}

function color (context, item, value) {
  return isGradient(value) ? gradient(context, value, item.bounds) : value;
}

function fill (context, item, opacity) {
  opacity *= item.fillOpacity == null ? 1 : item.fillOpacity;
  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.fillStyle = color(context, item, item.fill);
    return true;
  } else {
    return false;
  }
}

var Empty = [];
function stroke (context, item, opacity) {
  var lw = (lw = item.strokeWidth) != null ? lw : 1;
  if (lw <= 0) return false;
  opacity *= item.strokeOpacity == null ? 1 : item.strokeOpacity;
  if (opacity > 0) {
    context.globalAlpha = opacity;
    context.strokeStyle = color(context, item, item.stroke);
    context.lineWidth = lw;
    context.lineCap = item.strokeCap || 'butt';
    context.lineJoin = item.strokeJoin || 'miter';
    context.miterLimit = item.strokeMiterLimit || 10;
    if (context.setLineDash) {
      context.setLineDash(item.strokeDash || Empty);
      context.lineDashOffset = item.strokeDashOffset || 0;
    }
    return true;
  } else {
    return false;
  }
}

function compare(a, b) {
  return a.zindex - b.zindex || a.index - b.index;
}
function zorder(scene) {
  if (!scene.zdirty) return scene.zitems;
  var items = scene.items,
    output = [],
    item,
    i,
    n;
  for (i = 0, n = items.length; i < n; ++i) {
    item = items[i];
    item.index = i;
    if (item.zindex) output.push(item);
  }
  scene.zdirty = false;
  return scene.zitems = output.sort(compare);
}
function visit(scene, visitor) {
  var items = scene.items,
    i,
    n;
  if (!items || !items.length) return;
  const zitems = zorder(scene);
  if (zitems && zitems.length) {
    for (i = 0, n = items.length; i < n; ++i) {
      if (!items[i].zindex) visitor(items[i]);
    }
    items = zitems;
  }
  for (i = 0, n = items.length; i < n; ++i) {
    visitor(items[i]);
  }
}
function pickVisit(scene, visitor) {
  var items = scene.items,
    hit,
    i;
  if (!items || !items.length) return null;
  const zitems = zorder(scene);
  if (zitems && zitems.length) items = zitems;
  for (i = items.length; --i >= 0;) {
    if (hit = visitor(items[i])) return hit;
  }
  if (items === zitems) {
    for (items = scene.items, i = items.length; --i >= 0;) {
      if (!items[i].zindex) {
        if (hit = visitor(items[i])) return hit;
      }
    }
  }
  return null;
}

function drawAll(path) {
  return function (context, scene, bounds) {
    visit(scene, item => {
      if (!bounds || bounds.intersects(item.bounds)) {
        drawPath(path, context, item, item);
      }
    });
  };
}
function drawOne(path) {
  return function (context, scene, bounds) {
    if (scene.items.length && (!bounds || bounds.intersects(scene.bounds))) {
      drawPath(path, context, scene.items[0], scene.items);
    }
  };
}
function drawPath(path, context, item, items) {
  var opacity = item.opacity == null ? 1 : item.opacity;
  if (opacity === 0) return;
  if (path(context, items)) return;
  blend(context, item);
  if (item.fill && fill(context, item, opacity)) {
    context.fill();
  }
  if (item.stroke && stroke(context, item, opacity)) {
    context.stroke();
  }
}

function pick$1(test) {
  test = test || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy;
  return function (context, scene, x, y, gx, gy) {
    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return pickVisit(scene, item => {
      const b = item.bounds;
      // first hit test against bounding box
      if (b && !b.contains(gx, gy) || !b) return;
      // if in bounding box, perform more careful test
      if (test(context, item, x, y, gx, gy)) return item;
    });
  };
}
function hitPath(path, filled) {
  return function (context, o, x, y) {
    var item = Array.isArray(o) ? o[0] : o,
      fill = filled == null ? item.fill : filled,
      stroke = item.stroke && context.isPointInStroke,
      lw,
      lc;
    if (stroke) {
      lw = item.strokeWidth;
      lc = item.strokeCap;
      context.lineWidth = lw != null ? lw : 1;
      context.lineCap = lc != null ? lc : 'butt';
    }
    return path(context, o) ? false : fill && context.isPointInPath(x, y) || stroke && context.isPointInStroke(x, y);
  };
}
function pickPath(path) {
  return pick$1(hitPath(path));
}

function translate(x, y) {
  return 'translate(' + x + ',' + y + ')';
}
function rotate(a) {
  return 'rotate(' + a + ')';
}
function scale(scaleX, scaleY) {
  return 'scale(' + scaleX + ',' + scaleY + ')';
}
function translateItem(item) {
  return translate(item.x || 0, item.y || 0);
}
function rotateItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '');
}
function transformItem(item) {
  return translate(item.x || 0, item.y || 0) + (item.angle ? ' ' + rotate(item.angle) : '') + (item.scaleX || item.scaleY ? ' ' + scale(item.scaleX || 1, item.scaleY || 1) : '');
}

function markItemPath (type, shape, isect) {
  function attr(emit, item) {
    emit('transform', rotateItem(item));
    emit('d', shape(null, item));
  }
  function bound(bounds, item) {
    shape(boundContext(bounds, item.angle), item);
    return boundStroke(bounds, item).translate(item.x || 0, item.y || 0);
  }
  function draw(context, item) {
    var x = item.x || 0,
      y = item.y || 0,
      a = item.angle || 0;
    context.translate(x, y);
    if (a) context.rotate(a *= DegToRad);
    context.beginPath();
    shape(context, item);
    if (a) context.rotate(-a);
    context.translate(-x, -y);
  }
  return {
    type: type,
    tag: 'path',
    nested: false,
    attr: attr,
    bound: bound,
    draw: drawAll(draw),
    pick: pickPath(draw),
    isect: isect || intersectPath(draw)
  };
}

var arc = markItemPath('arc', arc$1);

function pickArea(a, p) {
  var v = a[0].orient === 'horizontal' ? p[1] : p[0],
    z = a[0].orient === 'horizontal' ? 'y' : 'x',
    i = a.length,
    min = +Infinity,
    hit,
    d;
  while (--i >= 0) {
    if (a[i].defined === false) continue;
    d = Math.abs(a[i][z] - v);
    if (d < min) {
      min = d;
      hit = a[i];
    }
  }
  return hit;
}
function pickLine(a, p) {
  var t = Math.pow(a[0].strokeWidth || 1, 2),
    i = a.length,
    dx,
    dy,
    dd;
  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    if (dd < t) return a[i];
  }
  return null;
}
function pickTrail(a, p) {
  var i = a.length,
    dx,
    dy,
    dd;
  while (--i >= 0) {
    if (a[i].defined === false) continue;
    dx = a[i].x - p[0];
    dy = a[i].y - p[1];
    dd = dx * dx + dy * dy;
    dx = a[i].size || 1;
    if (dd < dx * dx) return a[i];
  }
  return null;
}

function markMultiItemPath (type, shape, tip) {
  function attr(emit, item) {
    var items = item.mark.items;
    if (items.length) emit('d', shape(null, items));
  }
  function bound(bounds, mark) {
    var items = mark.items;
    if (items.length === 0) {
      return bounds;
    } else {
      shape(boundContext(bounds), items);
      return boundStroke(bounds, items[0]);
    }
  }
  function draw(context, items) {
    context.beginPath();
    shape(context, items);
  }
  const hit = hitPath(draw);
  function pick(context, scene, x, y, gx, gy) {
    var items = scene.items,
      b = scene.bounds;
    if (!items || !items.length || b && !b.contains(gx, gy)) {
      return null;
    }
    x *= context.pixelRatio;
    y *= context.pixelRatio;
    return hit(context, items, x, y) ? items[0] : null;
  }
  return {
    type: type,
    tag: 'path',
    nested: true,
    attr: attr,
    bound: bound,
    draw: drawOne(draw),
    pick: pick,
    isect: intersectPoint,
    tip: tip
  };
}

var area = markMultiItemPath('area', area$1, pickArea);

function clip (context, scene) {
  var clip = scene.clip;
  context.save();
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    context.beginPath();
    clip(context);
    context.clip();
  } else {
    clipGroup(context, scene.group);
  }
}
function clipGroup(context, group) {
  context.beginPath();
  hasCornerRadius(group) ? rectangle(context, group, 0, 0) : context.rect(0, 0, group.width || 0, group.height || 0);
  context.clip();
}

function offset$1(item) {
  const sw = value(item.strokeWidth, 1);
  return item.strokeOffset != null ? item.strokeOffset : item.stroke && sw > 0.5 && sw < 1.5 ? 0.5 - Math.abs(sw - 1) : 0;
}
function attr$5(emit, item) {
  emit('transform', translateItem(item));
}
function emitRectangle(emit, item) {
  const off = offset$1(item);
  emit('d', rectangle(null, item, off, off));
}
function background(emit, item) {
  emit('class', 'background');
  emit('aria-hidden', true);
  emitRectangle(emit, item);
}
function foreground(emit, item) {
  emit('class', 'foreground');
  emit('aria-hidden', true);
  if (item.strokeForeground) {
    emitRectangle(emit, item);
  } else {
    emit('d', '');
  }
}
function content(emit, item, renderer) {
  const url = item.clip ? clip$1(renderer, item, item) : null;
  emit('clip-path', url);
}
function bound$5(bounds, group) {
  if (!group.clip && group.items) {
    const items = group.items,
      m = items.length;
    for (let j = 0; j < m; ++j) {
      bounds.union(items[j].bounds);
    }
  }
  if ((group.clip || group.width || group.height) && !group.noBound) {
    bounds.add(0, 0).add(group.width || 0, group.height || 0);
  }
  boundStroke(bounds, group);
  return bounds.translate(group.x || 0, group.y || 0);
}
function rectanglePath(context, group, x, y) {
  const off = offset$1(group);
  context.beginPath();
  rectangle(context, group, (x || 0) + off, (y || 0) + off);
}
const hitBackground = hitPath(rectanglePath);
const hitForeground = hitPath(rectanglePath, false);
const hitCorner = hitPath(rectanglePath, true);
function draw$4(context, scene, bounds, markTypes) {
  visit(scene, group => {
    const gx = group.x || 0,
      gy = group.y || 0,
      fore = group.strokeForeground,
      opacity = group.opacity == null ? 1 : group.opacity;

    // draw group background
    if ((group.stroke || group.fill) && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);
      if (group.fill && fill(context, group, opacity)) {
        context.fill();
      }
      if (group.stroke && !fore && stroke(context, group, opacity)) {
        context.stroke();
      }
    }

    // setup graphics context, set clip and bounds
    context.save();
    context.translate(gx, gy);
    if (group.clip) clipGroup(context, group);
    if (bounds) bounds.translate(-gx, -gy);

    // draw group contents
    visit(group, item => {
      if (item.marktype === 'group' || markTypes == null || markTypes.includes(item.marktype)) {
        this.draw(context, item, bounds, markTypes);
      }
    });

    // restore graphics context
    if (bounds) bounds.translate(gx, gy);
    context.restore();

    // draw group foreground
    if (fore && group.stroke && opacity) {
      rectanglePath(context, group, gx, gy);
      blend(context, group);
      if (stroke(context, group, opacity)) {
        context.stroke();
      }
    }
  });
}
function pick(context, scene, x, y, gx, gy) {
  if (scene.bounds && !scene.bounds.contains(gx, gy) || !scene.items) {
    return null;
  }
  const cx = x * context.pixelRatio,
    cy = y * context.pixelRatio;
  return pickVisit(scene, group => {
    let hit, dx, dy;

    // first hit test bounding box
    const b = group.bounds;
    if (b && !b.contains(gx, gy)) return;

    // passed bounds check, test rectangular clip
    dx = group.x || 0;
    dy = group.y || 0;
    const dw = dx + (group.width || 0),
      dh = dy + (group.height || 0),
      c = group.clip;
    if (c && (gx < dx || gx > dw || gy < dy || gy > dh)) return;

    // adjust coordinate system
    context.save();
    context.translate(dx, dy);
    dx = gx - dx;
    dy = gy - dy;

    // test background for rounded corner clip
    if (c && hasCornerRadius(group) && !hitCorner(context, group, cx, cy)) {
      context.restore();
      return null;
    }
    const fore = group.strokeForeground,
      ix = scene.interactive !== false;

    // hit test against group foreground
    if (ix && fore && group.stroke && hitForeground(context, group, cx, cy)) {
      context.restore();
      return group;
    }

    // hit test against contained marks
    hit = pickVisit(group, mark => pickMark(mark, dx, dy) ? this.pick(mark, x, y, dx, dy) : null);

    // hit test against group background
    if (!hit && ix && (group.fill || !fore && group.stroke) && hitBackground(context, group, cx, cy)) {
      hit = group;
    }

    // restore state and return
    context.restore();
    return hit || null;
  });
}
function pickMark(mark, x, y) {
  return (mark.interactive !== false || mark.marktype === 'group') && mark.bounds && mark.bounds.contains(x, y);
}
var group = {
  type: 'group',
  tag: 'g',
  nested: false,
  attr: attr$5,
  bound: bound$5,
  draw: draw$4,
  pick: pick,
  isect: intersectRect,
  content: content,
  background: background,
  foreground: foreground
};

var metadata = {
  'xmlns': 'http://www.w3.org/2000/svg',
  'xmlns:xlink': 'http://www.w3.org/1999/xlink',
  'version': '1.1'
};

function getImage(item, renderer) {
  var image = item.image;
  if (!image || item.url && item.url !== image.url) {
    image = {
      complete: false,
      width: 0,
      height: 0
    };
    renderer.loadImage(item.url).then(image => {
      item.image = image;
      item.image.url = item.url;
    });
  }
  return image;
}
function imageWidth(item, image) {
  return item.width != null ? item.width : !image || !image.width ? 0 : item.aspect !== false && item.height ? item.height * image.width / image.height : image.width;
}
function imageHeight(item, image) {
  return item.height != null ? item.height : !image || !image.height ? 0 : item.aspect !== false && item.width ? item.width * image.height / image.width : image.height;
}
function imageXOffset(align, w) {
  return align === 'center' ? w / 2 : align === 'right' ? w : 0;
}
function imageYOffset(baseline, h) {
  return baseline === 'middle' ? h / 2 : baseline === 'bottom' ? h : 0;
}
function attr$4(emit, item, renderer) {
  const img = getImage(item, renderer),
    w = imageWidth(item, img),
    h = imageHeight(item, img),
    x = (item.x || 0) - imageXOffset(item.align, w),
    y = (item.y || 0) - imageYOffset(item.baseline, h),
    i = !img.src && img.toDataURL ? img.toDataURL() : img.src || '';
  emit('href', i, metadata['xmlns:xlink'], 'xlink:href');
  emit('transform', translate(x, y));
  emit('width', w);
  emit('height', h);
  emit('preserveAspectRatio', item.aspect === false ? 'none' : 'xMidYMid');
}
function bound$4(bounds, item) {
  const img = item.image,
    w = imageWidth(item, img),
    h = imageHeight(item, img),
    x = (item.x || 0) - imageXOffset(item.align, w),
    y = (item.y || 0) - imageYOffset(item.baseline, h);
  return bounds.set(x, y, x + w, y + h);
}
function draw$3(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check

    const img = getImage(item, this);
    let w = imageWidth(item, img);
    let h = imageHeight(item, img);
    if (w === 0 || h === 0) return; // early exit

    let x = (item.x || 0) - imageXOffset(item.align, w),
      y = (item.y || 0) - imageYOffset(item.baseline, h),
      opacity,
      ar0,
      ar1,
      t;
    if (item.aspect !== false) {
      ar0 = img.width / img.height;
      ar1 = item.width / item.height;
      if (ar0 === ar0 && ar1 === ar1 && ar0 !== ar1) {
        if (ar1 < ar0) {
          t = w / ar0;
          y += (h - t) / 2;
          h = t;
        } else {
          t = h * ar0;
          x += (w - t) / 2;
          w = t;
        }
      }
    }
    if (img.complete || img.toDataURL) {
      blend(context, item);
      context.globalAlpha = (opacity = item.opacity) != null ? opacity : 1;
      context.imageSmoothingEnabled = item.smooth !== false;
      context.drawImage(img, x, y, w, h);
    }
  });
}
var image = {
  type: 'image',
  tag: 'image',
  nested: false,
  attr: attr$4,
  bound: bound$4,
  draw: draw$3,
  pick: pick$1(),
  isect: vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy,
  // bounds check is sufficient
  get: getImage,
  xOffset: imageXOffset,
  yOffset: imageYOffset
};

var line = markMultiItemPath('line', line$1, pickLine);

function attr$3(emit, item) {
  var sx = item.scaleX || 1,
    sy = item.scaleY || 1;
  if (sx !== 1 || sy !== 1) {
    emit('vector-effect', 'non-scaling-stroke');
  }
  emit('transform', transformItem(item));
  emit('d', item.path);
}
function path$1(context, item) {
  var path = item.path;
  if (path == null) return true;
  var x = item.x || 0,
    y = item.y || 0,
    sx = item.scaleX || 1,
    sy = item.scaleY || 1,
    a = (item.angle || 0) * DegToRad,
    cache = item.pathCache;
  if (!cache || cache.path !== path) {
    (item.pathCache = cache = parse(path)).path = path;
  }
  if (a && context.rotate && context.translate) {
    context.translate(x, y);
    context.rotate(a);
    pathRender(context, cache, 0, 0, sx, sy);
    context.rotate(-a);
    context.translate(-x, -y);
  } else {
    pathRender(context, cache, x, y, sx, sy);
  }
}
function bound$3(bounds, item) {
  return path$1(boundContext(bounds, item.angle), item) ? bounds.set(0, 0, 0, 0) : boundStroke(bounds, item, true);
}
var path$2 = {
  type: 'path',
  tag: 'path',
  nested: false,
  attr: attr$3,
  bound: bound$3,
  draw: drawAll(path$1),
  pick: pickPath(path$1),
  isect: intersectPath(path$1)
};

function attr$2(emit, item) {
  emit('d', rectangle(null, item));
}
function bound$2(bounds, item) {
  var x, y;
  return boundStroke(bounds.set(x = item.x || 0, y = item.y || 0, x + item.width || 0, y + item.height || 0), item);
}
function draw$2(context, item) {
  context.beginPath();
  rectangle(context, item);
}
var rect = {
  type: 'rect',
  tag: 'path',
  nested: false,
  attr: attr$2,
  bound: bound$2,
  draw: drawAll(draw$2),
  pick: pickPath(draw$2),
  isect: intersectRect
};

function attr$1(emit, item) {
  emit('transform', translateItem(item));
  emit('x2', item.x2 != null ? item.x2 - (item.x || 0) : 0);
  emit('y2', item.y2 != null ? item.y2 - (item.y || 0) : 0);
}
function bound$1(bounds, item) {
  var x1, y1;
  return boundStroke(bounds.set(x1 = item.x || 0, y1 = item.y || 0, item.x2 != null ? item.x2 : x1, item.y2 != null ? item.y2 : y1), item);
}
function path(context, item, opacity) {
  var x1, y1, x2, y2;
  if (item.stroke && stroke(context, item, opacity)) {
    x1 = item.x || 0;
    y1 = item.y || 0;
    x2 = item.x2 != null ? item.x2 : x1;
    y2 = item.y2 != null ? item.y2 : y1;
    context.beginPath();
    context.moveTo(x1, y1);
    context.lineTo(x2, y2);
    return true;
  }
  return false;
}
function draw$1(context, scene, bounds) {
  visit(scene, item => {
    if (bounds && !bounds.intersects(item.bounds)) return; // bounds check
    var opacity = item.opacity == null ? 1 : item.opacity;
    if (opacity && path(context, item, opacity)) {
      blend(context, item);
      context.stroke();
    }
  });
}
function hit$1(context, item, x, y) {
  if (!context.isPointInStroke) return false;
  return path(context, item, 1) && context.isPointInStroke(x, y);
}
var rule = {
  type: 'rule',
  tag: 'line',
  nested: false,
  attr: attr$1,
  bound: bound$1,
  draw: draw$1,
  pick: pick$1(hit$1),
  isect: intersectRule
};

var shape = markItemPath('shape', shape$1);

var symbol = markItemPath('symbol', symbol$1, intersectPoint);

// memoize text width measurement
const widthCache = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache)();
var textMetrics = {
  height: fontSize,
  measureWidth: measureWidth,
  estimateWidth: estimateWidth,
  width: estimateWidth,
  canvas: useCanvas
};
useCanvas(true);
function useCanvas(use) {
  textMetrics.width = use && context ? measureWidth : estimateWidth;
}

// make simple estimate if no canvas is available
function estimateWidth(item, text) {
  return _estimateWidth(textValue(item, text), fontSize(item));
}
function _estimateWidth(text, currentFontHeight) {
  return ~~(0.8 * text.length * currentFontHeight);
}

// measure text width if canvas is available
function measureWidth(item, text) {
  return fontSize(item) <= 0 || !(text = textValue(item, text)) ? 0 : _measureWidth(text, font(item));
}
function _measureWidth(text, currentFont) {
  const key = `(${currentFont}) ${text}`;
  let width = widthCache.get(key);
  if (width === undefined) {
    context.font = currentFont;
    width = context.measureText(text).width;
    widthCache.set(key, width);
  }
  return width;
}
function fontSize(item) {
  return item.fontSize != null ? +item.fontSize || 0 : 11;
}
function lineHeight(item) {
  return item.lineHeight != null ? item.lineHeight : fontSize(item) + 2;
}
function lineArray(_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_) ? _.length > 1 ? _ : _[0] : _;
}
function textLines(item) {
  return lineArray(item.lineBreak && item.text && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(item.text) ? item.text.split(item.lineBreak) : item.text);
}
function multiLineOffset(item) {
  const tl = textLines(item);
  return ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl) ? tl.length - 1 : 0) * lineHeight(item);
}
function textValue(item, line) {
  const text = line == null ? '' : (line + '').trim();
  return item.limit > 0 && text.length ? truncate(item, text) : text;
}
function widthGetter(item) {
  if (textMetrics.width === measureWidth) {
    // we are using canvas
    const currentFont = font(item);
    return text => _measureWidth(text, currentFont);
  } else if (textMetrics.width === estimateWidth) {
    // we are relying on estimates
    const currentFontHeight = fontSize(item);
    return text => _estimateWidth(text, currentFontHeight);
  } else {
    // User defined textMetrics.width function in use (e.g. vl-convert)
    return text => textMetrics.width(item, text);
  }
}
function truncate(item, text) {
  var limit = +item.limit,
    width = widthGetter(item);
  if (width(text) < limit) return text;
  var ellipsis = item.ellipsis || '\u2026',
    rtl = item.dir === 'rtl',
    lo = 0,
    hi = text.length,
    mid;
  limit -= width(ellipsis);
  if (rtl) {
    while (lo < hi) {
      mid = lo + hi >>> 1;
      if (width(text.slice(mid)) > limit) lo = mid + 1;else hi = mid;
    }
    return ellipsis + text.slice(lo);
  } else {
    while (lo < hi) {
      mid = 1 + (lo + hi >>> 1);
      if (width(text.slice(0, mid)) < limit) lo = mid;else hi = mid - 1;
    }
    return text.slice(0, lo) + ellipsis;
  }
}
function fontFamily(item, quote) {
  var font = item.font;
  return (quote && font ? String(font).replace(/"/g, '\'') : font) || 'sans-serif';
}
function font(item, quote) {
  return '' + (item.fontStyle ? item.fontStyle + ' ' : '') + (item.fontVariant ? item.fontVariant + ' ' : '') + (item.fontWeight ? item.fontWeight + ' ' : '') + fontSize(item) + 'px ' + fontFamily(item, quote);
}
function offset(item) {
  // perform our own font baseline calculation
  // why? not all browsers support SVG 1.1 'alignment-baseline' :(
  // this also ensures consistent layout across renderers
  var baseline = item.baseline,
    h = fontSize(item);
  return Math.round(baseline === 'top' ? 0.79 * h : baseline === 'middle' ? 0.30 * h : baseline === 'bottom' ? -0.21 * h : baseline === 'line-top' ? 0.29 * h + 0.5 * lineHeight(item) : baseline === 'line-bottom' ? 0.29 * h - 0.5 * lineHeight(item) : 0);
}

const textAlign = {
  'left': 'start',
  'center': 'middle',
  'right': 'end'
};
const tempBounds = new Bounds();
function anchorPoint(item) {
  var x = item.x || 0,
    y = item.y || 0,
    r = item.radius || 0,
    t;
  if (r) {
    t = (item.theta || 0) - HalfPi;
    x += r * Math.cos(t);
    y += r * Math.sin(t);
  }
  tempBounds.x1 = x;
  tempBounds.y1 = y;
  return tempBounds;
}
function attr(emit, item) {
  var dx = item.dx || 0,
    dy = (item.dy || 0) + offset(item),
    p = anchorPoint(item),
    x = p.x1,
    y = p.y1,
    a = item.angle || 0,
    t;
  emit('text-anchor', textAlign[item.align] || 'start');
  if (a) {
    t = translate(x, y) + ' ' + rotate(a);
    if (dx || dy) t += ' ' + translate(dx, dy);
  } else {
    t = translate(x + dx, y + dy);
  }
  emit('transform', t);
}
function bound(bounds, item, mode) {
  var h = textMetrics.height(item),
    a = item.align,
    p = anchorPoint(item),
    x = p.x1,
    y = p.y1,
    dx = item.dx || 0,
    dy = (item.dy || 0) + offset(item) - Math.round(0.8 * h),
    // use 4/5 offset
    tl = textLines(item),
    w;

  // get dimensions
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
    // multi-line text
    h += lineHeight(item) * (tl.length - 1);
    w = tl.reduce((w, t) => Math.max(w, textMetrics.width(item, t)), 0);
  } else {
    // single-line text
    w = textMetrics.width(item, tl);
  }

  // horizontal alignment
  if (a === 'center') {
    dx -= w / 2;
  } else if (a === 'right') {
    dx -= w;
  } else ;
  bounds.set(dx += x, dy += y, dx + w, dy + h);
  if (item.angle && !mode) {
    bounds.rotate(item.angle * DegToRad, x, y);
  } else if (mode === 2) {
    return bounds.rotatedPoints(item.angle * DegToRad, x, y);
  }
  return bounds;
}
function draw(context, scene, bounds) {
  visit(scene, item => {
    var opacity = item.opacity == null ? 1 : item.opacity,
      p,
      x,
      y,
      i,
      lh,
      tl,
      str;
    if (bounds && !bounds.intersects(item.bounds) ||
    // bounds check
    opacity === 0 || item.fontSize <= 0 || item.text == null || item.text.length === 0) return;
    context.font = font(item);
    context.textAlign = item.align || 'left';
    p = anchorPoint(item);
    x = p.x1, y = p.y1;
    if (item.angle) {
      context.save();
      context.translate(x, y);
      context.rotate(item.angle * DegToRad);
      x = y = 0; // reset x, y
    }
    x += item.dx || 0;
    y += (item.dy || 0) + offset(item);
    tl = textLines(item);
    blend(context, item);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      lh = lineHeight(item);
      for (i = 0; i < tl.length; ++i) {
        str = textValue(item, tl[i]);
        if (item.fill && fill(context, item, opacity)) {
          context.fillText(str, x, y);
        }
        if (item.stroke && stroke(context, item, opacity)) {
          context.strokeText(str, x, y);
        }
        y += lh;
      }
    } else {
      str = textValue(item, tl);
      if (item.fill && fill(context, item, opacity)) {
        context.fillText(str, x, y);
      }
      if (item.stroke && stroke(context, item, opacity)) {
        context.strokeText(str, x, y);
      }
    }
    if (item.angle) context.restore();
  });
}
function hit(context, item, x, y, gx, gy) {
  if (item.fontSize <= 0) return false;
  if (!item.angle) return true; // bounds sufficient if no rotation

  // project point into space of unrotated bounds
  var p = anchorPoint(item),
    ax = p.x1,
    ay = p.y1,
    b = bound(tempBounds, item, 1),
    a = -item.angle * DegToRad,
    cos = Math.cos(a),
    sin = Math.sin(a),
    px = cos * gx - sin * gy + (ax - cos * ax + sin * ay),
    py = sin * gx + cos * gy + (ay - sin * ax - cos * ay);
  return b.contains(px, py);
}
function intersectText(item, box) {
  const p = bound(tempBounds, item, 2);
  return intersectBoxLine(box, p[0], p[1], p[2], p[3]) || intersectBoxLine(box, p[0], p[1], p[4], p[5]) || intersectBoxLine(box, p[4], p[5], p[6], p[7]) || intersectBoxLine(box, p[2], p[3], p[6], p[7]);
}
var text = {
  type: 'text',
  tag: 'text',
  nested: false,
  attr: attr,
  bound: bound,
  draw: draw,
  pick: pick$1(hit),
  isect: intersectText
};

var trail = markMultiItemPath('trail', trail$1, pickTrail);

var Marks = {
  arc: arc,
  area: area,
  group: group,
  image: image,
  line: line,
  path: path$2,
  rect: rect,
  rule: rule,
  shape: shape,
  symbol: symbol,
  text: text,
  trail: trail
};

function boundItem (item, func, opt) {
  var type = Marks[item.mark.marktype],
    bound = func || type.bound;
  if (type.nested) item = item.mark;
  return bound(item.bounds || (item.bounds = new Bounds()), item, opt);
}

var DUMMY = {
  mark: null
};
function boundMark (mark, bounds, opt) {
  var type = Marks[mark.marktype],
    bound = type.bound,
    items = mark.items,
    hasItems = items && items.length,
    i,
    n,
    item,
    b;
  if (type.nested) {
    if (hasItems) {
      item = items[0];
    } else {
      // no items, fake it
      DUMMY.mark = mark;
      item = DUMMY;
    }
    b = boundItem(item, bound, opt);
    bounds = bounds && bounds.union(b) || b;
    return bounds;
  }
  bounds = bounds || mark.bounds && mark.bounds.clear() || new Bounds();
  if (hasItems) {
    for (i = 0, n = items.length; i < n; ++i) {
      bounds.union(boundItem(items[i], bound, opt));
    }
  }
  return mark.bounds = bounds;
}

const keys = ['marktype', 'name', 'role', 'interactive', 'clip', 'items', 'zindex', 'x', 'y', 'width', 'height', 'align', 'baseline',
// layout
'fill', 'fillOpacity', 'opacity', 'blend',
// fill
'stroke', 'strokeOpacity', 'strokeWidth', 'strokeCap',
// stroke
'strokeDash', 'strokeDashOffset',
// stroke dash
'strokeForeground', 'strokeOffset',
// group
'startAngle', 'endAngle', 'innerRadius', 'outerRadius',
// arc
'cornerRadius', 'padAngle',
// arc, rect
'cornerRadiusTopLeft', 'cornerRadiusTopRight',
// rect, group
'cornerRadiusBottomLeft', 'cornerRadiusBottomRight', 'interpolate', 'tension', 'orient', 'defined',
// area, line
'url', 'aspect', 'smooth',
// image
'path', 'scaleX', 'scaleY',
// path
'x2', 'y2',
// rule
'size', 'shape',
// symbol
'text', 'angle', 'theta', 'radius', 'dir', 'dx', 'dy',
// text
'ellipsis', 'limit', 'lineBreak', 'lineHeight', 'font', 'fontSize', 'fontWeight', 'fontStyle', 'fontVariant',
// font
'description', 'aria', 'ariaRole', 'ariaRoleDescription' // aria
];
function sceneToJSON(scene, indent) {
  return JSON.stringify(scene, keys, indent);
}
function sceneFromJSON(json) {
  const scene = typeof json === 'string' ? JSON.parse(json) : json;
  return initialize(scene);
}
function initialize(scene) {
  var type = scene.marktype,
    items = scene.items,
    parent,
    i,
    n;
  if (items) {
    for (i = 0, n = items.length; i < n; ++i) {
      parent = type ? 'mark' : 'group';
      items[i][parent] = scene;
      if (items[i].zindex) items[i][parent].zdirty = true;
      if ('group' === (type || parent)) initialize(items[i]);
    }
  }
  if (type) boundMark(scene);
  return scene;
}

class Scenegraph {
  constructor(scene) {
    if (arguments.length) {
      this.root = sceneFromJSON(scene);
    } else {
      this.root = createMark({
        marktype: 'group',
        name: 'root',
        role: 'frame'
      });
      this.root.items = [new GroupItem(this.root)];
    }
  }
  toJSON(indent) {
    return sceneToJSON(this.root, indent || 0);
  }
  mark(markdef, group, index) {
    group = group || this.root.items[0];
    const mark = createMark(markdef, group);
    group.items[index] = mark;
    if (mark.zindex) mark.group.zdirty = true;
    return mark;
  }
}
function createMark(def, group) {
  const mark = {
    bounds: new Bounds(),
    clip: !!def.clip,
    group: group,
    interactive: def.interactive === false ? false : true,
    items: [],
    marktype: def.marktype,
    name: def.name || undefined,
    role: def.role || undefined,
    zindex: def.zindex || 0
  };

  // add accessibility properties if defined
  if (def.aria != null) {
    mark.aria = def.aria;
  }
  if (def.description) {
    mark.description = def.description;
  }
  return mark;
}

// create a new DOM element
function domCreate(doc, tag, ns) {
  if (!doc && typeof document !== 'undefined' && document.createElement) {
    doc = document;
  }
  return doc ? ns ? doc.createElementNS(ns, tag) : doc.createElement(tag) : null;
}

// find first child element with matching tag
function domFind(el, tag) {
  tag = tag.toLowerCase();
  var nodes = el.childNodes,
    i = 0,
    n = nodes.length;
  for (; i < n; ++i) if (nodes[i].tagName.toLowerCase() === tag) {
    return nodes[i];
  }
}

// retrieve child element at given index
// create & insert if doesn't exist or if tags do not match
function domChild(el, index, tag, ns) {
  var a = el.childNodes[index],
    b;
  if (!a || a.tagName.toLowerCase() !== tag.toLowerCase()) {
    b = a || null;
    a = domCreate(el.ownerDocument, tag, ns);
    el.insertBefore(a, b);
  }
  return a;
}

// remove all child elements at or above the given index
function domClear(el, index) {
  var nodes = el.childNodes,
    curr = nodes.length;
  while (curr > index) el.removeChild(nodes[--curr]);
  return el;
}

// generate css class name for mark
function cssClass(mark) {
  return 'mark-' + mark.marktype + (mark.role ? ' role-' + mark.role : '') + (mark.name ? ' ' + mark.name : '');
}

function point (event, el) {
  const rect = el.getBoundingClientRect();
  return [event.clientX - rect.left - (el.clientLeft || 0), event.clientY - rect.top - (el.clientTop || 0)];
}

function resolveItem (item, event, el, origin) {
  var mark = item && item.mark,
    mdef,
    p;
  if (mark && (mdef = Marks[mark.marktype]).tip) {
    p = point(event, el);
    p[0] -= origin[0];
    p[1] -= origin[1];
    while (item = item.mark.group) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
    }
    item = mdef.tip(mark.items, p);
  }
  return item;
}

class Handler {
  /**
   * Create a new Handler instance.
   * @param {object} [customLoader] - Optional loader instance for
   *   href URL sanitization. If not specified, a standard loader
   *   instance will be generated.
   * @param {function} [customTooltip] - Optional tooltip handler
   *   function for custom tooltip display.
   * @constructor
   */
  constructor(customLoader, customTooltip) {
    this._active = null;
    this._handlers = {};
    this._loader = customLoader || (0,vega_loader__WEBPACK_IMPORTED_MODULE_3__.loader)();
    this._tooltip = customTooltip || defaultTooltip;
  }

  /**
   * Initialize a new Handler instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {object} [obj] - Optional context object that should serve as
   *   the "this" context for event callbacks.
   * @return {Handler} - This handler instance.
   */
  initialize(el, origin, obj) {
    this._el = el;
    this._obj = obj || null;
    return this.origin(origin);
  }

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }

  /**
   * Get / set the origin coordinates of the visualization.
   */
  origin(origin) {
    if (arguments.length) {
      this._origin = origin || [0, 0];
      return this;
    } else {
      return this._origin.slice();
    }
  }

  /**
   * Get / set the scenegraph root.
   */
  scene(scene) {
    if (!arguments.length) return this._scene;
    this._scene = scene;
    return this;
  }

  /**
   * Add an event handler. Subclasses should override this method.
   */
  on(/*type, handler*/) {}

  /**
   * Remove an event handler. Subclasses should override this method.
   */
  off(/*type, handler*/) {}

  /**
   * Utility method for finding the array index of an event handler.
   * @param {Array} h - An array of registered event handlers.
   * @param {string} type - The event type.
   * @param {function} handler - The event handler instance to find.
   * @return {number} - The handler's array index or -1 if not registered.
   */
  _handlerIndex(h, type, handler) {
    for (let i = h ? h.length : 0; --i >= 0;) {
      if (h[i].type === type && (!handler || h[i].handler === handler)) {
        return i;
      }
    }
    return -1;
  }

  /**
   * Returns an array with registered event handlers.
   * @param {string} [type] - The event type to query. Any annotations
   *   are ignored; for example, for the argument "click.foo", ".foo" will
   *   be ignored and the method returns all "click" handlers. If type is
   *   null or unspecified, this method returns handlers for all types.
   * @return {Array} - A new array containing all registered event handlers.
   */
  handlers(type) {
    const h = this._handlers,
      a = [];
    if (type) {
      a.push(...h[this.eventName(type)]);
    } else {
      for (const k in h) {
        a.push(...h[k]);
      }
    }
    return a;
  }

  /**
   * Parses an event name string to return the specific event type.
   * For example, given "click.foo" returns "click"
   * @param {string} name - The input event type string.
   * @return {string} - A string with the event type only.
   */
  eventName(name) {
    const i = name.indexOf('.');
    return i < 0 ? name : name.slice(0, i);
  }

  /**
   * Handle hyperlink navigation in response to an item.href value.
   * @param {Event} event - The event triggering hyperlink navigation.
   * @param {Item} item - The scenegraph item.
   * @param {string} href - The URL to navigate to.
   */
  handleHref(event, item, href) {
    this._loader.sanitize(href, {
      context: 'href'
    }).then(opt => {
      const e = new MouseEvent(event.type, event),
        a = domCreate(null, 'a');
      for (const name in opt) a.setAttribute(name, opt[name]);
      a.dispatchEvent(e);
    }).catch(() => {});
  }

  /**
   * Handle tooltip display in response to an item.tooltip value.
   * @param {Event} event - The event triggering tooltip display.
   * @param {Item} item - The scenegraph item.
   * @param {boolean} show - A boolean flag indicating whether
   *   to show or hide a tooltip for the given item.
   */
  handleTooltip(event, item, show) {
    if (item && item.tooltip != null) {
      item = resolveItem(item, event, this.canvas(), this._origin);
      const value = show && item && item.tooltip || null;
      this._tooltip.call(this._obj, this, event, item, value);
    }
  }

  /**
   * Returns the size of a scenegraph item and its position relative
   * to the viewport.
   * @param {Item} item - The scenegraph item.
   * @return {object} - A bounding box object (compatible with the
   *   DOMRect type) consisting of x, y, width, heigh, top, left,
   *   right, and bottom properties.
   */
  getItemBoundingClientRect(item) {
    const el = this.canvas();
    if (!el) return;
    const rect = el.getBoundingClientRect(),
      origin = this._origin,
      bounds = item.bounds,
      width = bounds.width(),
      height = bounds.height();
    let x = bounds.x1 + origin[0] + rect.left,
      y = bounds.y1 + origin[1] + rect.top;

    // translate coordinate for each parent group
    while (item.mark && (item = item.mark.group)) {
      x += item.x || 0;
      y += item.y || 0;
    }

    // return DOMRect-compatible bounding box
    return {
      x,
      y,
      width,
      height,
      left: x,
      top: y,
      right: x + width,
      bottom: y + height
    };
  }
}

// The default tooltip display handler.
// Sets the HTML title attribute on the visualization container.
function defaultTooltip(handler, event, item, value) {
  handler.element().setAttribute('title', value || '');
}

class Renderer {
  /**
   * Create a new Renderer instance.
   * @param {object} [loader] - Optional loader instance for
   *   image and href URL sanitization. If not specified, a
   *   standard loader instance will be generated.
   * @constructor
   */
  constructor(loader) {
    this._el = null;
    this._bgcolor = null;
    this._loader = new ResourceLoader(loader);
  }

  /**
   * Initialize a new Renderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    this._el = el;
    return this.resize(width, height, origin, scaleFactor);
  }

  /**
   * Returns the parent container element for a visualization.
   * @return {DOMElement} - The containing DOM element.
   */
  element() {
    return this._el;
  }

  /**
   * Returns the scene element (e.g., canvas or SVG) of the visualization
   * Subclasses must override if the first child is not the scene element.
   * @return {DOMElement} - The scene (e.g., canvas or SVG) element.
   */
  canvas() {
    return this._el && this._el.firstChild;
  }

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length === 0) return this._bgcolor;
    this._bgcolor = bgcolor;
    return this;
  }

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {Renderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    this._width = width;
    this._height = height;
    this._origin = origin || [0, 0];
    this._scale = scaleFactor || 1;
    return this;
  }

  /**
   * Report a dirty item whose bounds should be redrawn.
   * This base class method does nothing. Subclasses that perform
   * incremental should implement this method.
   * @param {Item} item - The dirty item whose bounds should be redrawn.
   */
  dirty(/*item*/) {}

  /**
   * Render an input scenegraph, potentially with a set of dirty items.
   * This method will perform an immediate rendering with available resources.
   * The renderer may also need to perform image loading to perform a complete
   * render. This process can lead to asynchronous re-rendering of the scene
   * after this method returns. To receive notification when rendering is
   * complete, use the renderAsync method instead.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Renderer} - This renderer instance.
   */
  render(scene, markTypes) {
    const r = this;

    // bind arguments into a render call, and cache it
    // this function may be subsequently called for async redraw
    r._call = function () {
      r._render(scene, markTypes);
    };

    // invoke the renderer
    r._call();

    // clear the cached call for garbage collection
    // async redraws will stash their own copy
    r._call = null;
    return r;
  }

  /**
   * Internal rendering method. Renderer subclasses should override this
   * method to actually perform rendering.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(/*scene, markTypes*/
  ) {
    // subclasses to override
  }

  /**
   * Asynchronous rendering method. Similar to render, but returns a Promise
   * that resolves when all rendering is completed. Sometimes a renderer must
   * perform image loading to get a complete rendering. The returned
   * Promise will not resolve until this process completes.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   * @return {Promise} - A Promise that resolves when rendering is complete.
   */
  renderAsync(scene, markTypes) {
    const r = this.render(scene, markTypes);
    return this._ready ? this._ready.then(() => r) : Promise.resolve(r);
  }

  /**
   * Internal method for asynchronous resource loading.
   * Proxies method calls to the ImageLoader, and tracks loading
   * progress to invoke a re-render once complete.
   * @param {string} method - The method name to invoke on the ImageLoader.
   * @param {string} uri - The URI for the requested resource.
   * @return {Promise} - A Promise that resolves to the requested resource.
   */
  _load(method, uri) {
    var r = this,
      p = r._loader[method](uri);
    if (!r._ready) {
      // re-render the scene when loading completes
      const call = r._call;
      r._ready = r._loader.ready().then(redraw => {
        if (redraw) call();
        r._ready = null;
      });
    }
    return p;
  }

  /**
   * Sanitize a URL to include as a hyperlink in the rendered scene.
   * This method proxies a call to ImageLoader.sanitizeURL, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string to sanitize.
   * @return {Promise} - A Promise that resolves to the sanitized URL.
   */
  sanitizeURL(uri) {
    return this._load('sanitizeURL', uri);
  }

  /**
   * Requests an image to include in the rendered scene.
   * This method proxies a call to ImageLoader.loadImage, but also tracks
   * image loading progress and invokes a re-render once complete.
   * @param {string} uri - The URI string of the image.
   * @return {Promise} - A Promise that resolves to the loaded Image.
   */
  loadImage(uri) {
    return this._load('loadImage', uri);
  }
}

const KeyDownEvent = 'keydown';
const KeyPressEvent = 'keypress';
const KeyUpEvent = 'keyup';
const DragEnterEvent = 'dragenter';
const DragLeaveEvent = 'dragleave';
const DragOverEvent = 'dragover';
const PointerDownEvent = 'pointerdown';
const PointerUpEvent = 'pointerup';
const PointerMoveEvent = 'pointermove';
const PointerOutEvent = 'pointerout';
const PointerOverEvent = 'pointerover';
const MouseDownEvent = 'mousedown';
const MouseUpEvent = 'mouseup';
const MouseMoveEvent = 'mousemove';
const MouseOutEvent = 'mouseout';
const MouseOverEvent = 'mouseover';
const ClickEvent = 'click';
const DoubleClickEvent = 'dblclick';
const WheelEvent = 'wheel';
const MouseWheelEvent = 'mousewheel';
const TouchStartEvent = 'touchstart';
const TouchMoveEvent = 'touchmove';
const TouchEndEvent = 'touchend';
const Events = [KeyDownEvent, KeyPressEvent, KeyUpEvent, DragEnterEvent, DragLeaveEvent, DragOverEvent, PointerDownEvent, PointerUpEvent, PointerMoveEvent, PointerOutEvent, PointerOverEvent, MouseDownEvent, MouseUpEvent, MouseMoveEvent, MouseOutEvent, MouseOverEvent, ClickEvent, DoubleClickEvent, WheelEvent, MouseWheelEvent, TouchStartEvent, TouchMoveEvent, TouchEndEvent];
const TooltipShowEvent = PointerMoveEvent;
const TooltipHideEvent = MouseOutEvent;
const HrefEvent = ClickEvent;

class CanvasHandler extends Handler {
  constructor(loader, tooltip) {
    super(loader, tooltip);
    this._down = null;
    this._touch = null;
    this._first = true;
    this._events = {};

    // supported events
    this.events = Events;
    this.pointermove = move([PointerMoveEvent, MouseMoveEvent], [PointerOverEvent, MouseOverEvent], [PointerOutEvent, MouseOutEvent]);
    this.dragover = move([DragOverEvent], [DragEnterEvent], [DragLeaveEvent]), this.pointerout = inactive([PointerOutEvent, MouseOutEvent]);
    this.dragleave = inactive([DragLeaveEvent]);
  }
  initialize(el, origin, obj) {
    this._canvas = el && domFind(el, 'canvas');

    // add minimal events required for proper state management
    [ClickEvent, MouseDownEvent, PointerDownEvent, PointerMoveEvent, PointerOutEvent, DragLeaveEvent].forEach(type => eventListenerCheck(this, type));
    return super.initialize(el, origin, obj);
  }

  // return the backing canvas instance
  canvas() {
    return this._canvas;
  }

  // retrieve the current canvas context
  context() {
    return this._canvas.getContext('2d');
  }

  // to keep old versions of firefox happy
  DOMMouseScroll(evt) {
    this.fire(MouseWheelEvent, evt);
  }
  pointerdown(evt) {
    this._down = this._active;
    this.fire(PointerDownEvent, evt);
  }
  mousedown(evt) {
    this._down = this._active;
    this.fire(MouseDownEvent, evt);
  }
  click(evt) {
    if (this._down === this._active) {
      this.fire(ClickEvent, evt);
      this._down = null;
    }
  }
  touchstart(evt) {
    this._touch = this.pickEvent(evt.changedTouches[0]);
    if (this._first) {
      this._active = this._touch;
      this._first = false;
    }
    this.fire(TouchStartEvent, evt, true);
  }
  touchmove(evt) {
    this.fire(TouchMoveEvent, evt, true);
  }
  touchend(evt) {
    this.fire(TouchEndEvent, evt, true);
    this._touch = null;
  }

  // fire an event
  fire(type, evt, touch) {
    const a = touch ? this._touch : this._active,
      h = this._handlers[type];

    // set event type relative to scenegraph items
    evt.vegaType = type;

    // handle hyperlinks and tooltips first
    if (type === HrefEvent && a && a.href) {
      this.handleHref(evt, a, a.href);
    } else if (type === TooltipShowEvent || type === TooltipHideEvent) {
      this.handleTooltip(evt, a, type !== TooltipHideEvent);
    }

    // invoke all registered handlers
    if (h) {
      for (let i = 0, len = h.length; i < len; ++i) {
        h[i].handler.call(this._obj, evt, a);
      }
    }
  }

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
      h = this._handlers,
      i = this._handlerIndex(h[name], type, handler);
    if (i < 0) {
      eventListenerCheck(this, type);
      (h[name] || (h[name] = [])).push({
        type: type,
        handler: handler
      });
    }
    return this;
  }

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
      h = this._handlers[name],
      i = this._handlerIndex(h, type, handler);
    if (i >= 0) {
      h.splice(i, 1);
    }
    return this;
  }
  pickEvent(evt) {
    const p = point(evt, this._canvas),
      o = this._origin;
    return this.pick(this._scene, p[0], p[1], p[0] - o[0], p[1] - o[1]);
  }

  // find the scenegraph item at the current pointer position
  // x, y -- the absolute x, y pointer coordinates on the canvas element
  // gx, gy -- the relative coordinates within the current group
  pick(scene, x, y, gx, gy) {
    const g = this.context(),
      mark = Marks[scene.marktype];
    return mark.pick.call(this, g, scene, x, y, gx, gy);
  }
}
const eventBundle = type => type === TouchStartEvent || type === TouchMoveEvent || type === TouchEndEvent ? [TouchStartEvent, TouchMoveEvent, TouchEndEvent] : [type];

// lazily add listeners to the canvas as needed
function eventListenerCheck(handler, type) {
  eventBundle(type).forEach(_ => addEventListener(handler, _));
}
function addEventListener(handler, type) {
  const canvas = handler.canvas();
  if (canvas && !handler._events[type]) {
    handler._events[type] = 1;
    canvas.addEventListener(type, handler[type] ? evt => handler[type](evt) : evt => handler.fire(type, evt));
  }
}
function fireAll(handler, types, event) {
  types.forEach(type => handler.fire(type, event));
}
function move(moveEvents, overEvents, outEvents) {
  return function (evt) {
    const a = this._active,
      p = this.pickEvent(evt);
    if (p === a) {
      // active item and picked item are the same
      fireAll(this, moveEvents, evt); // fire move
    } else {
      // active item and picked item are different
      if (!a || !a.exit) {
        // fire out for prior active item
        // suppress if active item was removed from scene
        fireAll(this, outEvents, evt);
      }
      this._active = p; // set new active item
      fireAll(this, overEvents, evt); // fire over for new active item
      fireAll(this, moveEvents, evt); // fire move for new active item
    }
  };
}
function inactive(types) {
  return function (evt) {
    fireAll(this, types, evt);
    this._active = null;
  };
}

function devicePixelRatio() {
  return typeof window !== 'undefined' ? window.devicePixelRatio || 1 : 1;
}
function resize (canvas, width, height, origin, scaleFactor, opt) {
  const inDOM = typeof HTMLElement !== 'undefined' && canvas instanceof HTMLElement && canvas.parentNode != null,
    context = canvas.getContext('2d'),
    ratio = inDOM ? devicePixelRatio() : scaleFactor;
  canvas.width = width * ratio;
  canvas.height = height * ratio;
  for (const key in opt) {
    context[key] = opt[key];
  }
  if (inDOM && ratio !== 1) {
    canvas.style.width = width + 'px';
    canvas.style.height = height + 'px';
  }
  context.pixelRatio = ratio;
  context.setTransform(ratio, 0, 0, ratio, ratio * origin[0], ratio * origin[1]);
  return canvas;
}

class CanvasRenderer extends Renderer {
  constructor(loader) {
    super(loader);
    this._options = {};
    this._redraw = false;
    this._dirty = new Bounds();
    this._tempb = new Bounds();
  }
  initialize(el, width, height, origin, scaleFactor, options) {
    this._options = options || {};
    this._canvas = this._options.externalContext ? null : (0,vega_canvas__WEBPACK_IMPORTED_MODULE_2__.canvas)(1, 1, this._options.type); // instantiate a small canvas

    if (el && this._canvas) {
      domClear(el, 0).appendChild(this._canvas);
      this._canvas.setAttribute('class', 'marks');
    }

    // this method will invoke resize to size the canvas appropriately
    return super.initialize(el, width, height, origin, scaleFactor);
  }
  resize(width, height, origin, scaleFactor) {
    super.resize(width, height, origin, scaleFactor);
    if (this._canvas) {
      // configure canvas size and transform
      resize(this._canvas, this._width, this._height, this._origin, this._scale, this._options.context);
    } else {
      // external context needs to be scaled and positioned to origin
      const ctx = this._options.externalContext;
      if (!ctx) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('CanvasRenderer is missing a valid canvas or context');
      ctx.scale(this._scale, this._scale);
      ctx.translate(this._origin[0], this._origin[1]);
    }
    this._redraw = true;
    return this;
  }
  canvas() {
    return this._canvas;
  }
  context() {
    return this._options.externalContext || (this._canvas ? this._canvas.getContext('2d') : null);
  }
  dirty(item) {
    const b = this._tempb.clear().union(item.bounds);
    let g = item.mark.group;
    while (g) {
      b.translate(g.x || 0, g.y || 0);
      g = g.mark.group;
    }
    this._dirty.union(b);
  }
  _render(scene, markTypes) {
    const g = this.context(),
      o = this._origin,
      w = this._width,
      h = this._height,
      db = this._dirty,
      vb = viewBounds(o, w, h);

    // setup
    g.save();
    const b = this._redraw || db.empty() ? (this._redraw = false, vb.expand(1)) : clipToBounds(g, vb.intersect(db), o);
    this.clear(-o[0], -o[1], w, h);

    // render
    this.draw(g, scene, b, markTypes);

    // takedown
    g.restore();
    db.clear();
    return this;
  }
  draw(ctx, scene, bounds, markTypes) {
    if (scene.marktype !== 'group' && markTypes != null && !markTypes.includes(scene.marktype)) {
      return;
    }
    const mark = Marks[scene.marktype];
    if (scene.clip) clip(ctx, scene);
    mark.draw.call(this, ctx, scene, bounds, markTypes);
    if (scene.clip) ctx.restore();
  }
  clear(x, y, w, h) {
    const opt = this._options,
      g = this.context();
    if (opt.type !== 'pdf' && !opt.externalContext) {
      // calling clear rect voids vector output in pdf mode
      // and could remove external context content (#2615)
      g.clearRect(x, y, w, h);
    }
    if (this._bgcolor != null) {
      g.fillStyle = this._bgcolor;
      g.fillRect(x, y, w, h);
    }
  }
}
const viewBounds = (origin, width, height) => new Bounds().set(0, 0, width, height).translate(-origin[0], -origin[1]);
function clipToBounds(g, b, origin) {
  // expand bounds by 1 pixel, then round to pixel boundaries
  b.expand(1).round();

  // align to base pixel grid in case of non-integer scaling (#2425)
  if (g.pixelRatio % 1) {
    b.scale(g.pixelRatio).round().scale(1 / g.pixelRatio);
  }

  // to avoid artifacts translate if origin has fractional pixels
  b.translate(-(origin[0] % 1), -(origin[1] % 1));

  // set clip path
  g.beginPath();
  g.rect(b.x1, b.y1, b.width(), b.height());
  g.clip();
  return b;
}

class SVGHandler extends Handler {
  constructor(loader, tooltip) {
    super(loader, tooltip);
    const h = this;
    h._hrefHandler = listener(h, (evt, item) => {
      if (item && item.href) h.handleHref(evt, item, item.href);
    });
    h._tooltipHandler = listener(h, (evt, item) => {
      h.handleTooltip(evt, item, evt.type !== TooltipHideEvent);
    });
  }
  initialize(el, origin, obj) {
    let svg = this._svg;
    if (svg) {
      svg.removeEventListener(HrefEvent, this._hrefHandler);
      svg.removeEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.removeEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    this._svg = svg = el && domFind(el, 'svg');
    if (svg) {
      svg.addEventListener(HrefEvent, this._hrefHandler);
      svg.addEventListener(TooltipShowEvent, this._tooltipHandler);
      svg.addEventListener(TooltipHideEvent, this._tooltipHandler);
    }
    return super.initialize(el, origin, obj);
  }
  canvas() {
    return this._svg;
  }

  // add an event handler
  on(type, handler) {
    const name = this.eventName(type),
      h = this._handlers,
      i = this._handlerIndex(h[name], type, handler);
    if (i < 0) {
      const x = {
        type,
        handler,
        listener: listener(this, handler)
      };
      (h[name] || (h[name] = [])).push(x);
      if (this._svg) {
        this._svg.addEventListener(name, x.listener);
      }
    }
    return this;
  }

  // remove an event handler
  off(type, handler) {
    const name = this.eventName(type),
      h = this._handlers[name],
      i = this._handlerIndex(h, type, handler);
    if (i >= 0) {
      if (this._svg) {
        this._svg.removeEventListener(name, h[i].listener);
      }
      h.splice(i, 1);
    }
    return this;
  }
}

// wrap an event listener for the SVG DOM
const listener = (context, handler) => evt => {
  let item = evt.target.__data__;
  item = Array.isArray(item) ? item[0] : item;
  evt.vegaType = evt.type;
  handler.call(context._obj, evt, item);
};

const ARIA_HIDDEN = 'aria-hidden';
const ARIA_LABEL = 'aria-label';
const ARIA_ROLE = 'role';
const ARIA_ROLEDESCRIPTION = 'aria-roledescription';
const GRAPHICS_OBJECT = 'graphics-object';
const GRAPHICS_SYMBOL = 'graphics-symbol';
const bundle = (role, roledesc, label) => ({
  [ARIA_ROLE]: role,
  [ARIA_ROLEDESCRIPTION]: roledesc,
  [ARIA_LABEL]: label || undefined
});

// these roles are covered by related roles
// we can ignore them, no need to generate attributes
const AriaIgnore = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(['axis-domain', 'axis-grid', 'axis-label', 'axis-tick', 'axis-title', 'legend-band', 'legend-entry', 'legend-gradient', 'legend-label', 'legend-title', 'legend-symbol', 'title']);

// aria attribute generators for guide roles
const AriaGuides = {
  'axis': {
    desc: 'axis',
    caption: axisCaption
  },
  'legend': {
    desc: 'legend',
    caption: legendCaption
  },
  'title-text': {
    desc: 'title',
    caption: item => `Title text '${titleCaption(item)}'`
  },
  'title-subtitle': {
    desc: 'subtitle',
    caption: item => `Subtitle text '${titleCaption(item)}'`
  }
};

// aria properties generated for mark item encoding channels
const AriaEncode = {
  ariaRole: ARIA_ROLE,
  ariaRoleDescription: ARIA_ROLEDESCRIPTION,
  description: ARIA_LABEL
};
function ariaItemAttributes(emit, item) {
  const hide = item.aria === false;
  emit(ARIA_HIDDEN, hide || undefined);
  if (hide || item.description == null) {
    for (const prop in AriaEncode) {
      emit(AriaEncode[prop], undefined);
    }
  } else {
    const type = item.mark.marktype;
    emit(ARIA_LABEL, item.description);
    emit(ARIA_ROLE, item.ariaRole || (type === 'group' ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL));
    emit(ARIA_ROLEDESCRIPTION, item.ariaRoleDescription || `${type} mark`);
  }
}
function ariaMarkAttributes(mark) {
  return mark.aria === false ? {
    [ARIA_HIDDEN]: true
  } : AriaIgnore[mark.role] ? null : AriaGuides[mark.role] ? ariaGuide(mark, AriaGuides[mark.role]) : ariaMark(mark);
}
function ariaMark(mark) {
  const type = mark.marktype;
  const recurse = type === 'group' || type === 'text' || mark.items.some(_ => _.description != null && _.aria !== false);
  return bundle(recurse ? GRAPHICS_OBJECT : GRAPHICS_SYMBOL, `${type} mark container`, mark.description);
}
function ariaGuide(mark, opt) {
  try {
    const item = mark.items[0],
      caption = opt.caption || (() => '');
    return bundle(opt.role || GRAPHICS_SYMBOL, opt.desc, item.description || caption(item));
  } catch (err) {
    return null;
  }
}
function titleCaption(item) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(item.text).join(' ');
}
function axisCaption(item) {
  const datum = item.datum,
    orient = item.orient,
    title = datum.title ? extractTitle(item) : null,
    ctx = item.context,
    scale = ctx.scales[datum.scale].value,
    locale = ctx.dataflow.locale(),
    type = scale.type,
    xy = orient === 'left' || orient === 'right' ? 'Y' : 'X';
  return `${xy}-axis` + (title ? ` titled '${title}'` : '') + ` for a ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_4__.isDiscrete)(type) ? 'discrete' : type} scale` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_4__.domainCaption)(locale, scale, item)}`;
}
function legendCaption(item) {
  const datum = item.datum,
    title = datum.title ? extractTitle(item) : null,
    type = `${datum.type || ''} legend`.trim(),
    scales = datum.scales,
    props = Object.keys(scales),
    ctx = item.context,
    scale = ctx.scales[scales[props[0]]].value,
    locale = ctx.dataflow.locale();
  return capitalize(type) + (title ? ` titled '${title}'` : '') + ` for ${channelCaption(props)}` + ` with ${(0,vega_scale__WEBPACK_IMPORTED_MODULE_4__.domainCaption)(locale, scale, item)}`;
}
function extractTitle(item) {
  try {
    return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(item.items).items[0].text).join(' ');
  } catch (err) {
    return null;
  }
}
function channelCaption(props) {
  props = props.map(p => p + (p === 'fill' || p === 'stroke' ? ' color' : ''));
  return props.length < 2 ? props[0] : props.slice(0, -1).join(', ') + ' and ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(props);
}
function capitalize(s) {
  return s.length ? s[0].toUpperCase() + s.slice(1) : s;
}

const innerText = val => (val + '').replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
const attrText = val => innerText(val).replace(/"/g, '&quot;').replace(/\t/g, '&#x9;').replace(/\n/g, '&#xA;').replace(/\r/g, '&#xD;');
function markup() {
  let buf = '',
    outer = '',
    inner = '';
  const stack = [],
    clear = () => outer = inner = '',
    push = tag => {
      if (outer) {
        buf += `${outer}>${inner}`;
        clear();
      }
      stack.push(tag);
    },
    attr = (name, value) => {
      if (value != null) outer += ` ${name}="${attrText(value)}"`;
      return m;
    },
    m = {
      open(tag) {
        push(tag);
        outer = '<' + tag;
        for (var _len = arguments.length, attrs = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          attrs[_key - 1] = arguments[_key];
        }
        for (const set of attrs) {
          for (const key in set) attr(key, set[key]);
        }
        return m;
      },
      close() {
        const tag = stack.pop();
        if (outer) {
          buf += outer + (inner ? `>${inner}</${tag}>` : '/>');
        } else {
          buf += `</${tag}>`;
        }
        clear();
        return m;
      },
      attr,
      text: t => (inner += innerText(t), m),
      toString: () => buf
    };
  return m;
}
const serializeXML = node => _serialize(markup(), node) + '';
function _serialize(m, node) {
  m.open(node.tagName);
  if (node.hasAttributes()) {
    const attrs = node.attributes,
      n = attrs.length;
    for (let i = 0; i < n; ++i) {
      m.attr(attrs[i].name, attrs[i].value);
    }
  }
  if (node.hasChildNodes()) {
    const children = node.childNodes;
    for (const child of children) {
      child.nodeType === 3 // text node
      ? m.text(child.nodeValue) : _serialize(m, child);
    }
  }
  return m.close();
}

const stylesAttr = {
  fill: 'fill',
  fillOpacity: 'fill-opacity',
  stroke: 'stroke',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  strokeCap: 'stroke-linecap',
  strokeJoin: 'stroke-linejoin',
  strokeDash: 'stroke-dasharray',
  strokeDashOffset: 'stroke-dashoffset',
  strokeMiterLimit: 'stroke-miterlimit',
  opacity: 'opacity'
};
const stylesCss = {
  blend: 'mix-blend-mode'
};

// ensure miter limit default is consistent with canvas (#2498)
const rootAttributes = {
  'fill': 'none',
  'stroke-miterlimit': 10
};

const RootIndex = 0,
  xmlns = 'http://www.w3.org/2000/xmlns/',
  svgns = metadata.xmlns;
class SVGRenderer extends Renderer {
  constructor(loader) {
    super(loader);
    this._dirtyID = 0;
    this._dirty = [];
    this._svg = null;
    this._root = null;
    this._defs = null;
  }

  /**
   * Initialize a new SVGRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    // create the svg definitions cache
    this._defs = {};
    this._clearDefs();
    if (el) {
      this._svg = domChild(el, 0, 'svg', svgns);
      this._svg.setAttributeNS(xmlns, 'xmlns', svgns);
      this._svg.setAttributeNS(xmlns, 'xmlns:xlink', metadata['xmlns:xlink']);
      this._svg.setAttribute('version', metadata['version']);
      this._svg.setAttribute('class', 'marks');
      domClear(el, 1);

      // set the svg root group
      this._root = domChild(this._svg, RootIndex, 'g', svgns);
      setAttributes(this._root, rootAttributes);

      // ensure no additional child elements
      domClear(this._svg, RootIndex + 1);
    }

    // set background color if defined
    this.background(this._bgcolor);
    return super.initialize(el, width, height, origin, scaleFactor);
  }

  /**
   * Get / set the background color.
   */
  background(bgcolor) {
    if (arguments.length && this._svg) {
      this._svg.style.setProperty('background-color', bgcolor);
    }
    return super.background(...arguments);
  }

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    super.resize(width, height, origin, scaleFactor);
    if (this._svg) {
      setAttributes(this._svg, {
        width: this._width * this._scale,
        height: this._height * this._scale,
        viewBox: `0 0 ${this._width} ${this._height}`
      });
      this._root.setAttribute('transform', `translate(${this._origin})`);
    }
    this._dirty = [];
    return this;
  }

  /**
   * Returns the SVG element of the visualization.
   * @return {DOMElement} - The SVG element.
   */
  canvas() {
    return this._svg;
  }

  /**
   * Returns an SVG text string for the rendered content,
   * or null if this renderer is currently headless.
   */
  svg() {
    const svg = this._svg,
      bg = this._bgcolor;
    if (!svg) return null;
    let node;
    if (bg) {
      svg.removeAttribute('style');
      node = domChild(svg, RootIndex, 'rect', svgns);
      setAttributes(node, {
        width: this._width,
        height: this._height,
        fill: bg
      });
    }
    const text = serializeXML(svg);
    if (bg) {
      svg.removeChild(node);
      this._svg.style.setProperty('background-color', bg);
    }
    return text;
  }

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    // perform spot updates and re-render markup
    if (this._dirtyCheck()) {
      if (this._dirtyAll) this._clearDefs();
      this.mark(this._root, scene, undefined, markTypes);
      domClear(this._root, 1);
    }
    this.defs();
    this._dirty = [];
    ++this._dirtyID;
    return this;
  }

  // -- Manage rendering of items marked as dirty --

  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (item.dirty !== this._dirtyID) {
      item.dirty = this._dirtyID;
      this._dirty.push(item);
    }
  }

  /**
   * Check if a mark item is considered dirty.
   * @param {Item} item - The mark item.
   */
  isDirty(item) {
    return this._dirtyAll || !item._svg || !item._svg.ownerSVGElement || item.dirty === this._dirtyID;
  }

  /**
   * Internal method to check dirty status and, if possible,
   * make targetted updates without a full rendering pass.
   */
  _dirtyCheck() {
    this._dirtyAll = true;
    const items = this._dirty;
    if (!items.length || !this._dirtyID) return true;
    const id = ++this._dirtyID;
    let item, mark, type, mdef, i, n, o;
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      mark = item.mark;
      if (mark.marktype !== type) {
        // memoize mark instance lookup
        type = mark.marktype;
        mdef = Marks[type];
      }
      if (mark.zdirty && mark.dirty !== id) {
        this._dirtyAll = false;
        dirtyParents(item, id);
        mark.items.forEach(i => {
          i.dirty = id;
        });
      }
      if (mark.zdirty) continue; // handle in standard drawing pass

      if (item.exit) {
        // EXIT
        if (mdef.nested && mark.items.length) {
          // if nested mark with remaining points, update instead
          o = mark.items[0];
          if (o._svg) this._update(mdef, o._svg, o);
        } else if (item._svg) {
          // otherwise remove from DOM
          o = item._svg.parentNode;
          if (o) o.removeChild(item._svg);
        }
        item._svg = null;
        continue;
      }
      item = mdef.nested ? mark.items[0] : item;
      if (item._update === id) continue; // already visited

      if (!item._svg || !item._svg.ownerSVGElement) {
        // ENTER
        this._dirtyAll = false;
        dirtyParents(item, id);
      } else {
        // IN-PLACE UPDATE
        this._update(mdef, item._svg, item);
      }
      item._update = id;
    }
    return !this._dirtyAll;
  }

  // -- Construct & maintain scenegraph to SVG mapping ---

  /**
   * Render a set of mark items.
   * @param {SVGElement} el - The parent element in the SVG tree.
   * @param {object} scene - The mark parent to render.
   * @param {SVGElement} prev - The previous sibling in the SVG tree.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  mark(el, scene, prev, markTypes) {
    if (!this.isDirty(scene)) {
      return scene._svg;
    }
    const svg = this._svg,
      markType = scene.marktype,
      mdef = Marks[markType],
      events = scene.interactive === false ? 'none' : null,
      isGroup = mdef.tag === 'g';
    const parent = bind(scene, el, prev, 'g', svg);
    if (markType !== 'group' && markTypes != null && !markTypes.includes(markType)) {
      domClear(parent, 0);
      return scene._svg;
    }
    parent.setAttribute('class', cssClass(scene));

    // apply aria attributes to parent container element
    const aria = ariaMarkAttributes(scene);
    for (const key in aria) setAttribute(parent, key, aria[key]);
    if (!isGroup) {
      setAttribute(parent, 'pointer-events', events);
    }
    setAttribute(parent, 'clip-path', scene.clip ? clip$1(this, scene, scene.group) : null);
    let sibling = null,
      i = 0;
    const process = item => {
      const dirty = this.isDirty(item),
        node = bind(item, parent, sibling, mdef.tag, svg);
      if (dirty) {
        this._update(mdef, node, item);
        if (isGroup) recurse(this, node, item, markTypes);
      }
      sibling = node;
      ++i;
    };
    if (mdef.nested) {
      if (scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    }
    domClear(parent, i);
    return parent;
  }

  /**
   * Update the attributes of an SVG element for a mark item.
   * @param {object} mdef - The mark definition object
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  _update(mdef, el, item) {
    // set dom element and values cache
    // provides access to emit method
    element = el;
    values = el.__values__;

    // apply aria-specific properties
    ariaItemAttributes(emit, item);

    // apply svg attributes
    mdef.attr(emit, item, this);

    // some marks need special treatment
    const extra = mark_extras[mdef.type];
    if (extra) extra.call(this, mdef, el, item);

    // apply svg style attributes
    // note: element state may have been modified by 'extra' method
    if (element) this.style(element, item);
  }

  /**
   * Update the presentation attributes of an SVG element for a mark item.
   * @param {SVGElement} el - The SVG element.
   * @param {Item} item - The mark item.
   */
  style(el, item) {
    if (item == null) return;
    for (const prop in stylesAttr) {
      let value = prop === 'font' ? fontFamily(item) : item[prop];
      if (value === values[prop]) continue;
      const name = stylesAttr[prop];
      if (value == null) {
        el.removeAttribute(name);
      } else {
        if (isGradient(value)) {
          value = gradientRef(value, this._defs.gradient, href());
        }
        el.setAttribute(name, value + '');
      }
      values[prop] = value;
    }
    for (const prop in stylesCss) {
      setStyle(el, stylesCss[prop], item[prop]);
    }
  }

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   */
  defs() {
    const svg = this._svg,
      defs = this._defs;
    let el = defs.el,
      index = 0;
    for (const id in defs.gradient) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateGradient(el, defs.gradient[id], index);
    }
    for (const id in defs.clipping) {
      if (!el) defs.el = el = domChild(svg, RootIndex + 1, 'defs', svgns);
      index = updateClipping(el, defs.clipping[id], index);
    }

    // clean-up
    if (el) {
      index === 0 ? (svg.removeChild(el), defs.el = null) : domClear(el, index);
    }
  }

  /**
   * Clear defs caches.
   */
  _clearDefs() {
    const def = this._defs;
    def.gradient = {};
    def.clipping = {};
  }
}

// mark ancestor chain with a dirty id
function dirtyParents(item, id) {
  for (; item && item.dirty !== id; item = item.mark.group) {
    item.dirty = id;
    if (item.mark && item.mark.dirty !== id) {
      item.mark.dirty = id;
    } else return;
  }
}

// update gradient definitions
function updateGradient(el, grad, index) {
  let i, n, stop;
  if (grad.gradient === 'radial') {
    // SVG radial gradients automatically transform to normalized bbox
    // coordinates, in a way that is cumbersome to replicate in canvas.
    // We wrap the radial gradient in a pattern element, allowing us to
    // maintain a circular gradient that matches what canvas provides.
    let pt = domChild(el, index++, 'pattern', svgns);
    setAttributes(pt, {
      id: patternPrefix + grad.id,
      viewBox: '0,0,1,1',
      width: '100%',
      height: '100%',
      preserveAspectRatio: 'xMidYMid slice'
    });
    pt = domChild(pt, 0, 'rect', svgns);
    setAttributes(pt, {
      width: 1,
      height: 1,
      fill: `url(${href()}#${grad.id})`
    });
    el = domChild(el, index++, 'radialGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      fx: grad.x1,
      fy: grad.y1,
      fr: grad.r1,
      cx: grad.x2,
      cy: grad.y2,
      r: grad.r2
    });
  } else {
    el = domChild(el, index++, 'linearGradient', svgns);
    setAttributes(el, {
      id: grad.id,
      x1: grad.x1,
      x2: grad.x2,
      y1: grad.y1,
      y2: grad.y2
    });
  }
  for (i = 0, n = grad.stops.length; i < n; ++i) {
    stop = domChild(el, i, 'stop', svgns);
    stop.setAttribute('offset', grad.stops[i].offset);
    stop.setAttribute('stop-color', grad.stops[i].color);
  }
  domClear(el, i);
  return index;
}

// update clipping path definitions
function updateClipping(el, clip, index) {
  let mask;
  el = domChild(el, index, 'clipPath', svgns);
  el.setAttribute('id', clip.id);
  if (clip.path) {
    mask = domChild(el, 0, 'path', svgns);
    mask.setAttribute('d', clip.path);
  } else {
    mask = domChild(el, 0, 'rect', svgns);
    setAttributes(mask, {
      x: 0,
      y: 0,
      width: clip.width,
      height: clip.height
    });
  }
  domClear(el, 1);
  return index + 1;
}

// Recursively process group contents.
function recurse(renderer, el, group, markTypes) {
  // child 'g' element is second to last among children (path, g, path)
  // other children here are foreground and background path elements
  el = el.lastChild.previousSibling;
  let prev,
    idx = 0;
  visit(group, item => {
    prev = renderer.mark(el, item, prev, markTypes);
    ++idx;
  });

  // remove any extraneous DOM elements
  domClear(el, 1 + idx);
}

// Bind a scenegraph item to an SVG DOM element.
// Create new SVG elements as needed.
function bind(item, el, sibling, tag, svg) {
  let node = item._svg,
    doc;

  // create a new dom node if needed
  if (!node) {
    doc = el.ownerDocument;
    node = domCreate(doc, tag, svgns);
    item._svg = node;
    if (item.mark) {
      node.__data__ = item;
      node.__values__ = {
        fill: 'default'
      };

      // if group, create background, content, and foreground elements
      if (tag === 'g') {
        const bg = domCreate(doc, 'path', svgns);
        node.appendChild(bg);
        bg.__data__ = item;
        const cg = domCreate(doc, 'g', svgns);
        node.appendChild(cg);
        cg.__data__ = item;
        const fg = domCreate(doc, 'path', svgns);
        node.appendChild(fg);
        fg.__data__ = item;
        fg.__values__ = {
          fill: 'default'
        };
      }
    }
  }

  // (re-)insert if (a) not contained in SVG or (b) sibling order has changed
  if (node.ownerSVGElement !== svg || siblingCheck(node, sibling)) {
    el.insertBefore(node, sibling ? sibling.nextSibling : el.firstChild);
  }
  return node;
}

// check if two nodes are ordered siblings
function siblingCheck(node, sibling) {
  return node.parentNode && node.parentNode.childNodes.length > 1 && node.previousSibling != sibling; // treat null/undefined the same
}

// -- Set attributes & styles on SVG elements ---

let element = null,
  // temp var for current SVG element
  values = null; // temp var for current values hash

// Extra configuration for certain mark types
const mark_extras = {
  group(mdef, el, item) {
    const fg = element = el.childNodes[2];
    values = fg.__values__;
    mdef.foreground(emit, item, this);
    values = el.__values__; // use parent's values hash
    element = el.childNodes[1];
    mdef.content(emit, item, this);
    const bg = element = el.childNodes[0];
    mdef.background(emit, item, this);
    const value = item.mark.interactive === false ? 'none' : null;
    if (value !== values.events) {
      setAttribute(fg, 'pointer-events', value);
      setAttribute(bg, 'pointer-events', value);
      values.events = value;
    }
    if (item.strokeForeground && item.stroke) {
      const fill = item.fill;
      setAttribute(fg, 'display', null);

      // set style of background
      this.style(bg, item);
      setAttribute(bg, 'stroke', null);

      // set style of foreground
      if (fill) item.fill = null;
      values = fg.__values__;
      this.style(fg, item);
      if (fill) item.fill = fill;

      // leave element null to prevent downstream styling
      element = null;
    } else {
      // ensure foreground is ignored
      setAttribute(fg, 'display', 'none');
    }
  },
  image(mdef, el, item) {
    if (item.smooth === false) {
      setStyle(el, 'image-rendering', 'optimizeSpeed');
      setStyle(el, 'image-rendering', 'pixelated');
    } else {
      setStyle(el, 'image-rendering', null);
    }
  },
  text(mdef, el, item) {
    const tl = textLines(item);
    let key, value, doc, lh;
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
      // multi-line text
      value = tl.map(_ => textValue(item, _));
      key = value.join('\n'); // content cache key

      if (key !== values.text) {
        domClear(el, 0);
        doc = el.ownerDocument;
        lh = lineHeight(item);
        value.forEach((t, i) => {
          const ts = domCreate(doc, 'tspan', svgns);
          ts.__data__ = item; // data binding
          ts.textContent = t;
          if (i) {
            ts.setAttribute('x', 0);
            ts.setAttribute('dy', lh);
          }
          el.appendChild(ts);
        });
        values.text = key;
      }
    } else {
      // single-line text
      value = textValue(item, tl);
      if (value !== values.text) {
        el.textContent = value;
        values.text = value;
      }
    }
    setAttribute(el, 'font-family', fontFamily(item));
    setAttribute(el, 'font-size', fontSize(item) + 'px');
    setAttribute(el, 'font-style', item.fontStyle);
    setAttribute(el, 'font-variant', item.fontVariant);
    setAttribute(el, 'font-weight', item.fontWeight);
  }
};
function emit(name, value, ns) {
  // early exit if value is unchanged
  if (value === values[name]) return;

  // use appropriate method given namespace (ns)
  if (ns) {
    setAttributeNS(element, name, value, ns);
  } else {
    setAttribute(element, name, value);
  }

  // note current value for future comparison
  values[name] = value;
}
function setStyle(el, name, value) {
  if (value !== values[name]) {
    if (value == null) {
      el.style.removeProperty(name);
    } else {
      el.style.setProperty(name, value + '');
    }
    values[name] = value;
  }
}
function setAttributes(el, attrs) {
  for (const key in attrs) {
    setAttribute(el, key, attrs[key]);
  }
}
function setAttribute(el, name, value) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttribute(name, value);
  } else {
    // else remove DOM attribute
    el.removeAttribute(name);
  }
}
function setAttributeNS(el, name, value, ns) {
  if (value != null) {
    // if value is provided, update DOM attribute
    el.setAttributeNS(ns, name, value);
  } else {
    // else remove DOM attribute
    el.removeAttributeNS(ns, name);
  }
}
function href() {
  let loc;
  return typeof window === 'undefined' ? '' : (loc = window.location).hash ? loc.href.slice(0, -loc.hash.length) : loc.href;
}

class SVGStringRenderer extends Renderer {
  constructor(loader) {
    super(loader);
    this._text = null;
    this._defs = {
      gradient: {},
      clipping: {}
    };
  }

  /**
   * Returns the rendered SVG text string,
   * or null if rendering has not yet occurred.
   */
  svg() {
    return this._text;
  }

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   */
  _render(scene) {
    const m = markup();

    // svg tag
    m.open('svg', (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, metadata, {
      class: 'marks',
      width: this._width * this._scale,
      height: this._height * this._scale,
      viewBox: `0 0 ${this._width} ${this._height}`
    }));

    // background, if defined
    const bg = this._bgcolor;
    if (bg && bg !== 'transparent' && bg !== 'none') {
      m.open('rect', {
        width: this._width,
        height: this._height,
        fill: bg
      }).close();
    }

    // root content group
    m.open('g', rootAttributes, {
      transform: 'translate(' + this._origin + ')'
    });
    this.mark(m, scene);
    m.close(); // </g>

    // defs
    this.defs(m);

    // get SVG text string
    this._text = m.close() + '';
    return this;
  }

  /**
   * Render a set of mark items.
   * @param {object} m - The markup context.
   * @param {object} scene - The mark parent to render.
   */
  mark(m, scene) {
    const mdef = Marks[scene.marktype],
      tag = mdef.tag,
      attrList = [ariaItemAttributes, mdef.attr];

    // render opening group tag
    m.open('g', {
      'class': cssClass(scene),
      'clip-path': scene.clip ? clip$1(this, scene, scene.group) : null
    }, ariaMarkAttributes(scene), {
      'pointer-events': tag !== 'g' && scene.interactive === false ? 'none' : null
    });

    // render contained elements
    const process = item => {
      const href = this.href(item);
      if (href) m.open('a', href);
      m.open(tag, this.attr(scene, item, attrList, tag !== 'g' ? tag : null));
      if (tag === 'text') {
        const tl = textLines(item);
        if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(tl)) {
          // multi-line text
          const attrs = {
            x: 0,
            dy: lineHeight(item)
          };
          for (let i = 0; i < tl.length; ++i) {
            m.open('tspan', i ? attrs : null).text(textValue(item, tl[i])).close();
          }
        } else {
          // single-line text
          m.text(textValue(item, tl));
        }
      } else if (tag === 'g') {
        const fore = item.strokeForeground,
          fill = item.fill,
          stroke = item.stroke;
        if (fore && stroke) {
          item.stroke = null;
        }
        m.open('path', this.attr(scene, item, mdef.background, 'bgrect')).close();

        // recurse for group content
        m.open('g', this.attr(scene, item, mdef.content));
        visit(item, scene => this.mark(m, scene));
        m.close();
        if (fore && stroke) {
          if (fill) item.fill = null;
          item.stroke = stroke;
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgrect')).close();
          if (fill) item.fill = fill;
        } else {
          m.open('path', this.attr(scene, item, mdef.foreground, 'bgfore')).close();
        }
      }
      m.close(); // </tag>
      if (href) m.close(); // </a>
    };
    if (mdef.nested) {
      if (scene.items && scene.items.length) process(scene.items[0]);
    } else {
      visit(scene, process);
    }

    // render closing group tag
    return m.close(); // </g>
  }

  /**
   * Get href attributes for a hyperlinked mark item.
   * @param {Item} item - The mark item.
   */
  href(item) {
    const href = item.href;
    let attr;
    if (href) {
      if (attr = this._hrefs && this._hrefs[href]) {
        return attr;
      } else {
        this.sanitizeURL(href).then(attr => {
          // rewrite to use xlink namespace
          attr['xlink:href'] = attr.href;
          attr.href = null;
          (this._hrefs || (this._hrefs = {}))[href] = attr;
        });
      }
    }
    return null;
  }

  /**
   * Get an object of SVG attributes for a mark item.
   * @param {object} scene - The mark parent.
   * @param {Item} item - The mark item.
   * @param {array|function} attrs - One or more attribute emitters.
   * @param {string} tag - The tag being rendered.
   */
  attr(scene, item, attrs, tag) {
    const object = {},
      emit = (name, value, ns, prefixed) => {
        object[prefixed || name] = value;
      };

    // apply mark specific attributes
    if (Array.isArray(attrs)) {
      attrs.forEach(fn => fn(emit, item, this));
    } else {
      attrs(emit, item, this);
    }

    // apply style attributes
    if (tag) {
      style(object, item, scene, tag, this._defs);
    }
    return object;
  }

  /**
   * Render SVG defs, as needed.
   * Must be called *after* marks have been processed to ensure the
   * collected state is current and accurate.
   * @param {object} m - The markup context.
   */
  defs(m) {
    const gradient = this._defs.gradient,
      clipping = this._defs.clipping,
      count = Object.keys(gradient).length + Object.keys(clipping).length;
    if (count === 0) return; // nothing to do

    m.open('defs');
    for (const id in gradient) {
      const def = gradient[id],
        stops = def.stops;
      if (def.gradient === 'radial') {
        // SVG radial gradients automatically transform to normalized bbox
        // coordinates, in a way that is cumbersome to replicate in canvas.
        // We wrap the radial gradient in a pattern element, allowing us to
        // maintain a circular gradient that matches what canvas provides.

        m.open('pattern', {
          id: patternPrefix + id,
          viewBox: '0,0,1,1',
          width: '100%',
          height: '100%',
          preserveAspectRatio: 'xMidYMid slice'
        });
        m.open('rect', {
          width: '1',
          height: '1',
          fill: 'url(#' + id + ')'
        }).close();
        m.close(); // </pattern>

        m.open('radialGradient', {
          id: id,
          fx: def.x1,
          fy: def.y1,
          fr: def.r1,
          cx: def.x2,
          cy: def.y2,
          r: def.r2
        });
      } else {
        m.open('linearGradient', {
          id: id,
          x1: def.x1,
          x2: def.x2,
          y1: def.y1,
          y2: def.y2
        });
      }
      for (let i = 0; i < stops.length; ++i) {
        m.open('stop', {
          offset: stops[i].offset,
          'stop-color': stops[i].color
        }).close();
      }
      m.close();
    }
    for (const id in clipping) {
      const def = clipping[id];
      m.open('clipPath', {
        id: id
      });
      if (def.path) {
        m.open('path', {
          d: def.path
        }).close();
      } else {
        m.open('rect', {
          x: 0,
          y: 0,
          width: def.width,
          height: def.height
        }).close();
      }
      m.close();
    }
    m.close();
  }
}

// Helper function for attr for style presentation attributes
function style(s, item, scene, tag, defs) {
  let styleList;
  if (item == null) return s;
  if (tag === 'bgrect' && scene.interactive === false) {
    s['pointer-events'] = 'none';
  }
  if (tag === 'bgfore') {
    if (scene.interactive === false) {
      s['pointer-events'] = 'none';
    }
    s.display = 'none';
    if (item.fill !== null) return s;
  }
  if (tag === 'image' && item.smooth === false) {
    styleList = ['image-rendering: optimizeSpeed;', 'image-rendering: pixelated;'];
  }
  if (tag === 'text') {
    s['font-family'] = fontFamily(item);
    s['font-size'] = fontSize(item) + 'px';
    s['font-style'] = item.fontStyle;
    s['font-variant'] = item.fontVariant;
    s['font-weight'] = item.fontWeight;
  }
  for (const prop in stylesAttr) {
    let value = item[prop];
    const name = stylesAttr[prop];
    if (value === 'transparent' && (name === 'fill' || name === 'stroke')) ; else if (value != null) {
      if (isGradient(value)) {
        value = gradientRef(value, defs.gradient, '');
      }
      s[name] = value;
    }
  }
  for (const prop in stylesCss) {
    const value = item[prop];
    if (value != null) {
      styleList = styleList || [];
      styleList.push(`${stylesCss[prop]}: ${value};`);
    }
  }
  if (styleList) {
    s.style = styleList.join(' ');
  }
  return s;
}

/**
 * @typedef {Object} HybridRendererOptions
 *
 * @property {string[]} [svgMarkTypes=['text']] - An array of SVG mark types to render
 *                                                in the SVG layer. All other mark types
 *                                                will be rendered in the Canvas layer.
 * @property {boolean} [svgOnTop=true] - Flag to determine if SVG should be rendered on top.
 * @property {boolean} [debug=false] - Flag to enable or disable debugging mode. When true,
 *                                     the top layer will be stacked below the bottom layer
 *                                     rather than overlaid on top.
 */

/** @type {HybridRendererOptions} */
const OPTS = {
  svgMarkTypes: ['text'],
  svgOnTop: true,
  debug: false
};

/**
 * Configure the HybridRenderer
 *
 * @param {HybridRendererOptions} options - HybridRenderer configuration options.
 */
function setHybridRendererOptions(options) {
  OPTS['svgMarkTypes'] = options.svgMarkTypes ?? ['text'];
  OPTS['svgOnTop'] = options.svgOnTop ?? true;
  OPTS['debug'] = options.debug ?? false;
}
class HybridRenderer extends Renderer {
  constructor(loader) {
    super(loader);
    this._svgRenderer = new SVGRenderer(loader);
    this._canvasRenderer = new CanvasRenderer(loader);
  }

  /**
   * Initialize a new HybridRenderer instance.
   * @param {DOMElement} el - The containing DOM element for the display.
   * @param {number} width - The coordinate width of the display, in pixels.
   * @param {number} height - The coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {HybridRenderer} - This renderer instance.
   */
  initialize(el, width, height, origin, scaleFactor) {
    this._root_el = domChild(el, 0, 'div');
    const bottomEl = domChild(this._root_el, 0, 'div');
    const topEl = domChild(this._root_el, 1, 'div');
    this._root_el.style.position = 'relative';

    // Set position absolute to overlay svg on top of canvas
    if (!OPTS.debug) {
      bottomEl.style.height = '100%';
      topEl.style.position = 'absolute';
      topEl.style.top = '0';
      topEl.style.left = '0';
      topEl.style.height = '100%';
      topEl.style.width = '100%';
    }
    this._svgEl = OPTS.svgOnTop ? topEl : bottomEl;
    this._canvasEl = OPTS.svgOnTop ? bottomEl : topEl;

    // pointer-events to none on SVG layer so that canvas gets all events
    this._svgEl.style.pointerEvents = 'none';
    this._canvasRenderer.initialize(this._canvasEl, width, height, origin, scaleFactor);
    this._svgRenderer.initialize(this._svgEl, width, height, origin, scaleFactor);
    return super.initialize(el, width, height, origin, scaleFactor);
  }

  /**
   * Flag a mark item as dirty.
   * @param {Item} item - The mark item.
   */
  dirty(item) {
    if (OPTS.svgMarkTypes.includes(item.mark.marktype)) {
      this._svgRenderer.dirty(item);
    } else {
      this._canvasRenderer.dirty(item);
    }
    return this;
  }

  /**
   * Internal rendering method.
   * @param {object} scene - The root mark of a scenegraph to render.
   * @param {Array} markTypes - Array of the mark types to render.
   *                            If undefined, render all mark types
   */
  _render(scene, markTypes) {
    const allMarkTypes = markTypes ?? ['arc', 'area', 'image', 'line', 'path', 'rect', 'rule', 'shape', 'symbol', 'text', 'trail'];
    const canvasMarkTypes = allMarkTypes.filter(m => !OPTS.svgMarkTypes.includes(m));
    this._svgRenderer.render(scene, OPTS.svgMarkTypes);
    this._canvasRenderer.render(scene, canvasMarkTypes);
  }

  /**
   * Resize the display.
   * @param {number} width - The new coordinate width of the display, in pixels.
   * @param {number} height - The new coordinate height of the display, in pixels.
   * @param {Array<number>} origin - The new origin of the display, in pixels.
   *   The coordinate system will be translated to this point.
   * @param {number} [scaleFactor=1] - Optional scaleFactor by which to multiply
   *   the width and height to determine the final pixel size.
   * @return {SVGRenderer} - This renderer instance;
   */
  resize(width, height, origin, scaleFactor) {
    super.resize(width, height, origin, scaleFactor);
    this._svgRenderer.resize(width, height, origin, scaleFactor);
    this._canvasRenderer.resize(width, height, origin, scaleFactor);
    return this;
  }
  background(bgcolor) {
    // Propagate background color to lower canvas renderer
    if (OPTS.svgOnTop) {
      this._canvasRenderer.background(bgcolor);
    } else {
      this._svgRenderer.background(bgcolor);
    }
    return this;
  }
}

class HybridHandler extends CanvasHandler {
  constructor(loader, tooltip) {
    super(loader, tooltip);
  }
  initialize(el, origin, obj) {
    const canvas = domChild(domChild(el, 0, 'div'), OPTS.svgOnTop ? 0 : 1, 'div');
    return super.initialize(canvas, origin, obj);
  }
}

const Canvas = 'canvas';
const Hybrid = 'hybrid';
const PNG = 'png';
const SVG = 'svg';
const None = 'none';
const RenderType = {
  Canvas: Canvas,
  PNG: PNG,
  SVG: SVG,
  Hybrid: Hybrid,
  None: None
};
const modules = {};
modules[Canvas] = modules[PNG] = {
  renderer: CanvasRenderer,
  headless: CanvasRenderer,
  handler: CanvasHandler
};
modules[SVG] = {
  renderer: SVGRenderer,
  headless: SVGStringRenderer,
  handler: SVGHandler
};
modules[Hybrid] = {
  renderer: HybridRenderer,
  headless: HybridRenderer,
  handler: HybridHandler
};
modules[None] = {};
function renderModule(name, _) {
  name = String(name || '').toLowerCase();
  if (arguments.length > 1) {
    modules[name] = _;
    return this;
  } else {
    return modules[name];
  }
}

function intersect(scene, bounds, filter) {
  const hits = [],
    // intersection results
    box = new Bounds().union(bounds),
    // defensive copy
    type = scene.marktype;
  return type ? intersectMark(scene, box, filter, hits) : type === 'group' ? intersectGroup(scene, box, filter, hits) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Intersect scene must be mark node or group item.');
}
function intersectMark(mark, box, filter, hits) {
  if (visitMark(mark, box, filter)) {
    const items = mark.items,
      type = mark.marktype,
      n = items.length;
    let i = 0;
    if (type === 'group') {
      for (; i < n; ++i) {
        intersectGroup(items[i], box, filter, hits);
      }
    } else {
      for (const test = Marks[type].isect; i < n; ++i) {
        const item = items[i];
        if (intersectItem(item, box, test)) hits.push(item);
      }
    }
  }
  return hits;
}
function visitMark(mark, box, filter) {
  // process if bounds intersect and if
  // (1) mark is a group mark (so we must recurse), or
  // (2) mark is interactive and passes filter
  return mark.bounds && box.intersects(mark.bounds) && (mark.marktype === 'group' || mark.interactive !== false && (!filter || filter(mark)));
}
function intersectGroup(group, box, filter, hits) {
  // test intersect against group
  // skip groups by default unless filter says otherwise
  if (filter && filter(group.mark) && intersectItem(group, box, Marks.group.isect)) {
    hits.push(group);
  }

  // recursively test children marks
  // translate box to group coordinate space
  const marks = group.items,
    n = marks && marks.length;
  if (n) {
    const x = group.x || 0,
      y = group.y || 0;
    box.translate(-x, -y);
    for (let i = 0; i < n; ++i) {
      intersectMark(marks[i], box, filter, hits);
    }
    box.translate(x, y);
  }
  return hits;
}
function intersectItem(item, box, test) {
  // test bounds enclosure, bounds intersection, then detailed test
  const bounds = item.bounds;
  return box.encloses(bounds) || box.intersects(bounds) && test(item, box);
}

const clipBounds = new Bounds();
function boundClip (mark) {
  const clip = mark.clip;
  if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction)(clip)) {
    clip(boundContext(clipBounds.clear()));
  } else if (clip) {
    clipBounds.set(0, 0, mark.group.width, mark.group.height);
  } else return;
  mark.bounds.intersect(clipBounds);
}

const TOLERANCE = 1e-9;
function sceneEqual(a, b, key) {
  return a === b ? true : key === 'path' ? pathEqual(a, b) : a instanceof Date && b instanceof Date ? +a === +b : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(a) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber)(b) ? Math.abs(a - b) <= TOLERANCE : !a || !b || !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(a) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(b) ? a == b : objectEqual(a, b);
}
function pathEqual(a, b) {
  return sceneEqual(parse(a), parse(b));
}
function objectEqual(a, b) {
  var ka = Object.keys(a),
    kb = Object.keys(b),
    key,
    i;
  if (ka.length !== kb.length) return false;
  ka.sort();
  kb.sort();
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i]) return false;
  }
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!sceneEqual(a[key], b[key], key)) return false;
  }
  return typeof a === typeof b;
}

function resetSVGDefIds() {
  resetSVGClipId();
  resetSVGGradientId();
}




/***/ }),

/***/ "./node_modules/vega-selections/build/vega-selection.module.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vega-selections/build/vega-selection.module.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   selectionIdTest: () => (/* binding */ selectionIdTest),
/* harmony export */   selectionResolve: () => (/* binding */ selectionResolve),
/* harmony export */   selectionTest: () => (/* binding */ selectionTest),
/* harmony export */   selectionTuples: () => (/* binding */ selectionTuples),
/* harmony export */   selectionVisitor: () => (/* binding */ selectionVisitor)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/union.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/intersection.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-expression */ "./node_modules/vega-expression/build/vega-expression.module.js");




// Registers vega-util field accessors to protect against XSS attacks
const SELECTION_GETTER = Symbol('vega_selection_getter');
function getter(f) {
  if (!f.getter || !f.getter[SELECTION_GETTER]) {
    f.getter = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f.field);
    f.getter[SELECTION_GETTER] = true;
  }
  return f.getter;
}
const Intersect = 'intersect';
const Union = 'union';
const VlMulti = 'vlMulti';
const VlPoint = 'vlPoint';
const Or = 'or';
const And = 'and';
const SelectionId = '_vgsid_';
const $selectionId = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(SelectionId);

const TYPE_ENUM = 'E',
  TYPE_RANGE_INC = 'R',
  TYPE_RANGE_EXC = 'R-E',
  TYPE_RANGE_LE = 'R-LE',
  TYPE_RANGE_RE = 'R-RE',
  TYPE_PRED_LT = 'E-LT',
  TYPE_PRED_LTE = 'E-LTE',
  TYPE_PRED_GT = 'E-GT',
  TYPE_PRED_GTE = 'E-GTE',
  TYPE_PRED_VALID = 'E-VALID',
  TYPE_PRED_ONE_OF = 'E-ONE',
  UNIT_INDEX = 'index:unit';

// TODO: revisit date coercion?
function testPoint(datum, entry) {
  var fields = entry.fields,
    values = entry.values,
    n = fields.length,
    i = 0,
    dval,
    f;
  for (; i < n; ++i) {
    f = fields[i];
    dval = getter(f)(datum);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(dval)) dval = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(dval);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i])) values[i] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(values[i]);
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(values[i]) && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(values[i][0])) values[i] = values[i].map(vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber);
    if (f.type === TYPE_ENUM) {
      // Enumerated fields can either specify individual values (single/multi selections)
      // or an array of values (interval selections).
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(values[i]) ? !values[i].includes(dval) : dval !== values[i]) {
        return false;
      }
    } else {
      if (f.type === TYPE_RANGE_INC) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i])) return false;
      } else if (f.type === TYPE_RANGE_RE) {
        // Discrete selection of bins test within the range [bin_start, bin_end).
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], true, false)) return false;
      } else if (f.type === TYPE_RANGE_EXC) {
        // 'R-E'/'R-LE' included for completeness.
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, false)) return false;
      } else if (f.type === TYPE_RANGE_LE) {
        if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange)(dval, values[i], false, true)) return false;
      } else if (f.type === TYPE_PRED_LT) {
        if (dval >= values[i]) return false;
      } else if (f.type === TYPE_PRED_LTE) {
        if (dval > values[i]) return false;
      } else if (f.type === TYPE_PRED_GT) {
        if (dval <= values[i]) return false;
      } else if (f.type === TYPE_PRED_GTE) {
        if (dval < values[i]) return false;
      } else if (f.type === TYPE_PRED_VALID) {
        if (dval === null || isNaN(dval)) return false;
      } else if (f.type === TYPE_PRED_ONE_OF) {
        if (values[i].indexOf(dval) === -1) return false;
      }
    }
  }
  return true;
}

/**
 * Tests if a tuple is contained within an interactive selection.
 * @param {string} name - The name of the data set representing the selection.
 *  Tuples in the dataset are of the form
 *  {unit: string, fields: array<fielddef>, values: array<*>}.
 *  Fielddef is of the form
 *  {field: string, channel: string, type: 'E' | 'R'} where
 *  'type' identifies whether tuples in the dataset enumerate
 *  values for the field, or specify a continuous range.
 * @param {object} datum - The tuple to test for inclusion.
 * @param {string} op - The set operation for combining selections.
 *   One of 'intersect' or 'union' (default).
 * @return {boolean} - True if the datum is in the selection, false otherwise.
 */
function selectionTest(name, datum, op) {
  var data = this.context.data[name],
    entries = data ? data.values.value : [],
    unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
    intersect = op === Intersect,
    n = entries.length,
    i = 0,
    entry,
    miss,
    count,
    unit,
    b;
  for (; i < n; ++i) {
    entry = entries[i];
    if (unitIdx && intersect) {
      // multi selections union within the same unit and intersect across units.
      miss = miss || {};
      count = miss[unit = entry.unit] || 0;

      // if we've already matched this unit, skip.
      if (count === -1) continue;
      b = testPoint(datum, entry);
      miss[unit] = b ? -1 : ++count;

      // if we match and there are no other units return true
      // if we've missed against all tuples in this unit return false
      if (b && unitIdx.size === 1) return true;
      if (!b && count === unitIdx.get(unit).count) return false;
    } else {
      b = testPoint(datum, entry);

      // if we find a miss and we do require intersection return false
      // if we find a match and we don't require intersection return true
      if (intersect ^ b) return b;
    }
  }

  // if intersecting and we made it here, then we saw no misses
  // if not intersecting, then we saw no matches
  // if no active selections, return false
  return n && intersect;
}
const bisect = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])($selectionId),
  bisectLeft = bisect.left,
  bisectRight = bisect.right;
function selectionIdTest(name, datum, op) {
  const data = this.context.data[name],
    entries = data ? data.values.value : [],
    unitIdx = data ? data[UNIT_INDEX] && data[UNIT_INDEX].value : undefined,
    intersect = op === Intersect,
    value = $selectionId(datum),
    index = bisectLeft(entries, value);
  if (index === entries.length) return false;
  if ($selectionId(entries[index]) !== value) return false;
  if (unitIdx && intersect) {
    if (unitIdx.size === 1) return true;
    if (bisectRight(entries, value) - index < unitIdx.size) return false;
  }
  return true;
}

/**
 * Maps an array of scene graph items to an array of selection tuples.
 * @param {string} name  - The name of the dataset representing the selection.
 * @param {string} base  - The base object that generated tuples extend.
 *
 * @returns {array} An array of selection entries for the given unit.
 */
function selectionTuples(array, base) {
  return array.map(x => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(base.fields ? {
    values: base.fields.map(f => getter(f)(x.datum))
  } : {
    [SelectionId]: $selectionId(x.datum)
  }, base));
}

/**
 * Resolves selection for use as a scale domain or reads via the API.
 * @param {string} name - The name of the dataset representing the selection
 * @param {string} [op='union'] - The set operation for combining selections.
 *                 One of 'intersect' or 'union' (default).
 * @param {boolean} isMulti - Identifies a "multi" selection to perform more
 *                 expensive resolution computation.
 * @param {boolean} vl5 - With Vega-Lite v5, "multi" selections are now called "point"
 *                 selections, and thus the resolved tuple should reflect this name.
 *                 This parameter allows us to reflect this change without triggering
 *                 a major version bump for Vega.
 * @returns {object} An object of selected fields and values.
 */
function selectionResolve(name, op, isMulti, vl5) {
  var data = this.context.data[name],
    entries = data ? data.values.value : [],
    resolved = {},
    multiRes = {},
    types = {},
    entry,
    fields,
    values,
    unit,
    field,
    value,
    res,
    resUnit,
    type,
    union,
    n = entries.length,
    i = 0,
    j,
    m;

  // First union all entries within the same unit.
  for (; i < n; ++i) {
    entry = entries[i];
    unit = entry.unit;
    fields = entry.fields;
    values = entry.values;
    if (fields && values) {
      // Intentional selection stores
      for (j = 0, m = fields.length; j < m; ++j) {
        field = fields[j];
        res = resolved[field.field] || (resolved[field.field] = {});
        resUnit = res[unit] || (res[unit] = []);
        types[field.field] = type = field.type.charAt(0);
        union = ops[`${type}_union`];
        res[unit] = union(resUnit, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values[j]));
      }

      // If the same multi-selection is repeated over views and projected over
      // an encoding, it may operate over different fields making it especially
      // tricky to reliably resolve it. At best, we can de-dupe identical entries
      // but doing so may be more computationally expensive than it is worth.
      // Instead, for now, we simply transform our store representation into
      // a more human-friendly one.
      if (isMulti) {
        resUnit = multiRes[unit] || (multiRes[unit] = []);
        resUnit.push((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(values).reduce((obj, curr, j) => (obj[fields[j].field] = curr, obj), {}));
      }
    } else {
      // Short circuit extensional selectionId stores which hold sorted IDs unique to each unit.
      field = SelectionId;
      value = $selectionId(entry);
      res = resolved[field] || (resolved[field] = {});
      resUnit = res[unit] || (res[unit] = []);
      resUnit.push(value);
      if (isMulti) {
        resUnit = multiRes[unit] || (multiRes[unit] = []);
        resUnit.push({
          [SelectionId]: value
        });
      }
    }
  }

  // Then resolve fields across units as per the op.
  op = op || Union;
  if (resolved[SelectionId]) {
    resolved[SelectionId] = ops[`${SelectionId}_${op}`](...Object.values(resolved[SelectionId]));
  } else {
    Object.keys(resolved).forEach(field => {
      resolved[field] = Object.keys(resolved[field]).map(unit => resolved[field][unit]).reduce((acc, curr) => acc === undefined ? curr : ops[`${types[field]}_${op}`](acc, curr));
    });
  }
  entries = Object.keys(multiRes);
  if (isMulti && entries.length) {
    const key = vl5 ? VlPoint : VlMulti;
    resolved[key] = op === Union ? {
      [Or]: entries.reduce((acc, k) => (acc.push(...multiRes[k]), acc), [])
    } : {
      [And]: entries.map(k => ({
        [Or]: multiRes[k]
      }))
    };
  }
  return resolved;
}
var ops = {
  [`${SelectionId}_union`]: d3_array__WEBPACK_IMPORTED_MODULE_3__["default"],
  [`${SelectionId}_intersect`]: d3_array__WEBPACK_IMPORTED_MODULE_4__["default"],
  E_union: function (base, value) {
    if (!base.length) return value;
    var i = 0,
      n = value.length;
    for (; i < n; ++i) if (!base.includes(value[i])) base.push(value[i]);
    return base;
  },
  E_intersect: function (base, value) {
    return !base.length ? value : base.filter(v => value.includes(v));
  },
  R_union: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
      hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);
    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }
    if (!base.length) return [lo, hi];
    if (base[0] > lo) base[0] = lo;
    if (base[1] < hi) base[1] = hi;
    return base;
  },
  R_intersect: function (base, value) {
    var lo = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[0]),
      hi = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(value[1]);
    if (lo > hi) {
      lo = value[1];
      hi = value[0];
    }
    if (!base.length) return [lo, hi];
    if (hi < base[0] || base[1] < lo) {
      return [];
    } else {
      if (base[0] < lo) base[0] = lo;
      if (base[1] > hi) base[1] = hi;
    }
    return base;
  }
};

const DataPrefix = ':',
  IndexPrefix = '@';
function selectionVisitor(name, args, scope, params) {
  if (args[0].type !== vega_expression__WEBPACK_IMPORTED_MODULE_1__.Literal) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('First argument to selection functions must be a string literal.');
  const data = args[0].value,
    op = args.length >= 2 && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(args).value,
    field = 'unit',
    indexName = IndexPrefix + field,
    dataName = DataPrefix + data;

  // eslint-disable-next-line no-prototype-builtins
  if (op === Intersect && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, indexName)) {
    params[indexName] = scope.getData(data).indataRef(scope, field);
  }

  // eslint-disable-next-line no-prototype-builtins
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(params, dataName)) {
    params[dataName] = scope.getData(data).tuplesRef();
  }
}




/***/ }),

/***/ "./node_modules/vega-statistics/build/vega-statistics.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-statistics/build/vega-statistics.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bandwidthNRD: () => (/* binding */ estimateBandwidth),
/* harmony export */   bin: () => (/* binding */ bin),
/* harmony export */   bootstrapCI: () => (/* binding */ bootstrapCI),
/* harmony export */   cumulativeLogNormal: () => (/* binding */ cumulativeLogNormal),
/* harmony export */   cumulativeNormal: () => (/* binding */ cumulativeNormal),
/* harmony export */   cumulativeUniform: () => (/* binding */ cumulativeUniform),
/* harmony export */   densityLogNormal: () => (/* binding */ densityLogNormal),
/* harmony export */   densityNormal: () => (/* binding */ densityNormal),
/* harmony export */   densityUniform: () => (/* binding */ densityUniform),
/* harmony export */   dotbin: () => (/* binding */ dotbin),
/* harmony export */   quantileLogNormal: () => (/* binding */ quantileLogNormal),
/* harmony export */   quantileNormal: () => (/* binding */ quantileNormal),
/* harmony export */   quantileUniform: () => (/* binding */ quantileUniform),
/* harmony export */   quantiles: () => (/* binding */ quantiles),
/* harmony export */   quartiles: () => (/* binding */ quartiles),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   randomInteger: () => (/* binding */ integer),
/* harmony export */   randomKDE: () => (/* binding */ kde),
/* harmony export */   randomLCG: () => (/* binding */ lcg),
/* harmony export */   randomLogNormal: () => (/* binding */ lognormal),
/* harmony export */   randomMixture: () => (/* binding */ mixture),
/* harmony export */   randomNormal: () => (/* binding */ gaussian),
/* harmony export */   randomUniform: () => (/* binding */ uniform),
/* harmony export */   regressionConstant: () => (/* binding */ constant),
/* harmony export */   regressionExp: () => (/* binding */ exp),
/* harmony export */   regressionLinear: () => (/* binding */ linear),
/* harmony export */   regressionLoess: () => (/* binding */ loess),
/* harmony export */   regressionLog: () => (/* binding */ log),
/* harmony export */   regressionPoly: () => (/* binding */ poly),
/* harmony export */   regressionPow: () => (/* binding */ pow),
/* harmony export */   regressionQuad: () => (/* binding */ quad),
/* harmony export */   sampleCurve: () => (/* binding */ sampleCurve),
/* harmony export */   sampleLogNormal: () => (/* binding */ sampleLogNormal),
/* harmony export */   sampleNormal: () => (/* binding */ sampleNormal),
/* harmony export */   sampleUniform: () => (/* binding */ sampleUniform),
/* harmony export */   setRandom: () => (/* binding */ setRandom)
/* harmony export */ });
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ascending.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/quantile.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/deviation.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/median.js");


function* numbers (values, valueof) {
  if (valueof == null) {
    for (let value of values) {
      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      value = valueof(value, ++index, values);
      if (value != null && value !== '' && (value = +value) >= value) {
        yield value;
      }
    }
  }
}

function quantiles (array, p, f) {
  const values = Float64Array.from(numbers(array, f));

  // don't depend on return value from typed array sort call
  // protects against undefined sort results in Safari (vega/vega-lite#4964)
  values.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["default"]);
  return p.map(_ => (0,d3_array__WEBPACK_IMPORTED_MODULE_1__.quantileSorted)(values, _));
}

function quartiles (array, f) {
  return quantiles(array, [0.25, 0.50, 0.75], f);
}

// Scott, D. W. (1992) Multivariate Density Estimation:
// Theory, Practice, and Visualization. Wiley.
function estimateBandwidth (array, f) {
  const n = array.length,
    d = (0,d3_array__WEBPACK_IMPORTED_MODULE_2__["default"])(array, f),
    q = quartiles(array, f),
    h = (q[2] - q[0]) / 1.34,
    v = Math.min(d, h) || d || Math.abs(q[0]) || 1;
  return 1.06 * v * Math.pow(n, -0.2);
}

function bin (_) {
  // determine range
  const maxb = _.maxbins || 20,
    base = _.base || 10,
    logb = Math.log(base),
    div = _.divide || [5, 2];
  let min = _.extent[0],
    max = _.extent[1],
    step,
    level,
    minstep,
    v,
    i,
    n;
  const span = _.span || max - min || Math.abs(min) || 1;
  if (_.step) {
    // if step size is explicitly given, use that
    step = _.step;
  } else if (_.steps) {
    // if provided, limit choice to acceptable step sizes
    v = span / maxb;
    for (i = 0, n = _.steps.length; i < n && _.steps[i] < v; ++i);
    step = _.steps[Math.max(0, i - 1)];
  } else {
    // else use span to determine step size
    level = Math.ceil(Math.log(maxb) / logb);
    minstep = _.minstep || 0;
    step = Math.max(minstep, Math.pow(base, Math.round(Math.log(span) / logb) - level));

    // increase step size if too many bins
    while (Math.ceil(span / step) > maxb) {
      step *= base;
    }

    // decrease step size if allowed
    for (i = 0, n = div.length; i < n; ++i) {
      v = step / div[i];
      if (v >= minstep && span / v <= maxb) step = v;
    }
  }

  // update precision, min and max
  v = Math.log(step);
  const precision = v >= 0 ? 0 : ~~(-v / logb) + 1,
    eps = Math.pow(base, -precision - 1);
  if (_.nice || _.nice === undefined) {
    v = Math.floor(min / step + eps) * step;
    min = min < v ? v - step : v;
    max = Math.ceil(max / step) * step;
  }
  return {
    start: min,
    stop: max === min ? min + step : max,
    step: step
  };
}

var random = Math.random;
function setRandom(r) {
  random = r;
}

function bootstrapCI (array, samples, alpha, f) {
  if (!array.length) return [undefined, undefined];
  const values = Float64Array.from(numbers(array, f)),
    n = values.length,
    m = samples;
  let a, i, j, mu;
  for (j = 0, mu = Array(m); j < m; ++j) {
    for (a = 0, i = 0; i < n; ++i) {
      a += values[~~(random() * n)];
    }
    mu[j] = a / n;
  }
  mu.sort(d3_array__WEBPACK_IMPORTED_MODULE_0__["default"]);
  return [(0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(mu, alpha / 2), (0,d3_array__WEBPACK_IMPORTED_MODULE_1__["default"])(mu, 1 - alpha / 2)];
}

// Dot density binning for dot plot construction.
// Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
// https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
function dotbin (array, step, smooth, f) {
  f = f || (_ => _);
  const n = array.length,
    v = new Float64Array(n);
  let i = 0,
    j = 1,
    a = f(array[0]),
    b = a,
    w = a + step,
    x;
  for (; j < n; ++j) {
    x = f(array[j]);
    if (x >= w) {
      b = (a + b) / 2;
      for (; i < j; ++i) v[i] = b;
      w = x + step;
      a = x;
    }
    b = x;
  }
  b = (a + b) / 2;
  for (; i < j; ++i) v[i] = b;
  return smooth ? smoothing(v, step + step / 4) : v;
}

// perform smoothing to reduce variance
// swap points between "adjacent" stacks
// Wilkinson defines adjacent as within step/4 units
function smoothing(v, thresh) {
  const n = v.length;
  let a = 0,
    b = 1,
    c,
    d;

  // get left stack
  while (v[a] === v[b]) ++b;
  while (b < n) {
    // get right stack
    c = b + 1;
    while (v[b] === v[c]) ++c;

    // are stacks adjacent?
    // if so, compare sizes and swap as needed
    if (v[b] - v[b - 1] < thresh) {
      d = b + (a + c - b - b >> 1);
      while (d < b) v[d++] = v[b];
      while (d > b) v[d--] = v[a];
    }

    // update left stack indices
    a = b;
    b = c;
  }
  return v;
}

function lcg (seed) {
  // Random numbers using a Linear Congruential Generator with seed value
  // Uses glibc values from https://en.wikipedia.org/wiki/Linear_congruential_generator
  return function () {
    seed = (1103515245 * seed + 12345) % 2147483647;
    return seed / 2147483647;
  };
}

function integer (min, max) {
  if (max == null) {
    max = min;
    min = 0;
  }
  let a, b, d;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        d = b - a;
        return dist;
      } else {
        return a;
      }
    },
    max(_) {
      if (arguments.length) {
        b = _ || 0;
        d = b - a;
        return dist;
      } else {
        return b;
      }
    },
    sample() {
      return a + Math.floor(d * random());
    },
    pdf(x) {
      return x === Math.floor(x) && x >= a && x < b ? 1 / d : 0;
    },
    cdf(x) {
      const v = Math.floor(x);
      return v < a ? 0 : v >= b ? 1 : (v - a + 1) / d;
    },
    icdf(p) {
      return p >= 0 && p <= 1 ? a - 1 + Math.floor(p * d) : NaN;
    }
  };
  return dist.min(min).max(max);
}

const SQRT2PI = Math.sqrt(2 * Math.PI);
const SQRT2 = Math.SQRT2;

let nextSample = NaN;
function sampleNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  let x = 0,
    y = 0,
    rds,
    c;
  if (nextSample === nextSample) {
    x = nextSample;
    nextSample = NaN;
  } else {
    do {
      x = random() * 2 - 1;
      y = random() * 2 - 1;
      rds = x * x + y * y;
    } while (rds === 0 || rds > 1);
    c = Math.sqrt(-2 * Math.log(rds) / rds); // Box-Muller transform
    x *= c;
    nextSample = y * c;
  }
  return mean + x * stdev;
}
function densityNormal(value, mean, stdev) {
  stdev = stdev == null ? 1 : stdev;
  const z = (value - (mean || 0)) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI);
}

// Approximation from West (2009)
// Better Approximations to Cumulative Normal Functions
function cumulativeNormal(value, mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (value - mean) / stdev,
    Z = Math.abs(z);
  let cd;
  if (Z > 37) {
    cd = 0;
  } else {
    const exp = Math.exp(-Z * Z / 2);
    let sum;
    if (Z < 7.07106781186547) {
      sum = 3.52624965998911e-02 * Z + 0.700383064443688;
      sum = sum * Z + 6.37396220353165;
      sum = sum * Z + 33.912866078383;
      sum = sum * Z + 112.079291497871;
      sum = sum * Z + 221.213596169931;
      sum = sum * Z + 220.206867912376;
      cd = exp * sum;
      sum = 8.83883476483184e-02 * Z + 1.75566716318264;
      sum = sum * Z + 16.064177579207;
      sum = sum * Z + 86.7807322029461;
      sum = sum * Z + 296.564248779674;
      sum = sum * Z + 637.333633378831;
      sum = sum * Z + 793.826512519948;
      sum = sum * Z + 440.413735824752;
      cd = cd / sum;
    } else {
      sum = Z + 0.65;
      sum = Z + 4 / sum;
      sum = Z + 3 / sum;
      sum = Z + 2 / sum;
      sum = Z + 1 / sum;
      cd = exp / sum / 2.506628274631;
    }
  }
  return z > 0 ? 1 - cd : cd;
}

// Approximation of Probit function using inverse error function.
function quantileNormal(p, mean, stdev) {
  if (p < 0 || p > 1) return NaN;
  return (mean || 0) + (stdev == null ? 1 : stdev) * SQRT2 * erfinv(2 * p - 1);
}

// Approximate inverse error function. Implementation from "Approximating
// the erfinv function" by Mike Giles, GPU Computing Gems, volume 2, 2010.
// Ported from Apache Commons Math, http://www.apache.org/licenses/LICENSE-2.0
function erfinv(x) {
  // beware that the logarithm argument must be
  // commputed as (1.0 - x) * (1.0 + x),
  // it must NOT be simplified as 1.0 - x * x as this
  // would induce rounding errors near the boundaries +/-1
  let w = -Math.log((1 - x) * (1 + x)),
    p;
  if (w < 6.25) {
    w -= 3.125;
    p = -3.6444120640178196996e-21;
    p = -1.685059138182016589e-19 + p * w;
    p = 1.2858480715256400167e-18 + p * w;
    p = 1.115787767802518096e-17 + p * w;
    p = -1.333171662854620906e-16 + p * w;
    p = 2.0972767875968561637e-17 + p * w;
    p = 6.6376381343583238325e-15 + p * w;
    p = -4.0545662729752068639e-14 + p * w;
    p = -8.1519341976054721522e-14 + p * w;
    p = 2.6335093153082322977e-12 + p * w;
    p = -1.2975133253453532498e-11 + p * w;
    p = -5.4154120542946279317e-11 + p * w;
    p = 1.051212273321532285e-09 + p * w;
    p = -4.1126339803469836976e-09 + p * w;
    p = -2.9070369957882005086e-08 + p * w;
    p = 4.2347877827932403518e-07 + p * w;
    p = -1.3654692000834678645e-06 + p * w;
    p = -1.3882523362786468719e-05 + p * w;
    p = 0.0001867342080340571352 + p * w;
    p = -0.00074070253416626697512 + p * w;
    p = -0.0060336708714301490533 + p * w;
    p = 0.24015818242558961693 + p * w;
    p = 1.6536545626831027356 + p * w;
  } else if (w < 16.0) {
    w = Math.sqrt(w) - 3.25;
    p = 2.2137376921775787049e-09;
    p = 9.0756561938885390979e-08 + p * w;
    p = -2.7517406297064545428e-07 + p * w;
    p = 1.8239629214389227755e-08 + p * w;
    p = 1.5027403968909827627e-06 + p * w;
    p = -4.013867526981545969e-06 + p * w;
    p = 2.9234449089955446044e-06 + p * w;
    p = 1.2475304481671778723e-05 + p * w;
    p = -4.7318229009055733981e-05 + p * w;
    p = 6.8284851459573175448e-05 + p * w;
    p = 2.4031110387097893999e-05 + p * w;
    p = -0.0003550375203628474796 + p * w;
    p = 0.00095328937973738049703 + p * w;
    p = -0.0016882755560235047313 + p * w;
    p = 0.0024914420961078508066 + p * w;
    p = -0.0037512085075692412107 + p * w;
    p = 0.005370914553590063617 + p * w;
    p = 1.0052589676941592334 + p * w;
    p = 3.0838856104922207635 + p * w;
  } else if (Number.isFinite(w)) {
    w = Math.sqrt(w) - 5.0;
    p = -2.7109920616438573243e-11;
    p = -2.5556418169965252055e-10 + p * w;
    p = 1.5076572693500548083e-09 + p * w;
    p = -3.7894654401267369937e-09 + p * w;
    p = 7.6157012080783393804e-09 + p * w;
    p = -1.4960026627149240478e-08 + p * w;
    p = 2.9147953450901080826e-08 + p * w;
    p = -6.7711997758452339498e-08 + p * w;
    p = 2.2900482228026654717e-07 + p * w;
    p = -9.9298272942317002539e-07 + p * w;
    p = 4.5260625972231537039e-06 + p * w;
    p = -1.9681778105531670567e-05 + p * w;
    p = 7.5995277030017761139e-05 + p * w;
    p = -0.00021503011930044477347 + p * w;
    p = -0.00013871931833623122026 + p * w;
    p = 1.0103004648645343977 + p * w;
    p = 4.8499064014085844221 + p * w;
  } else {
    p = Infinity;
  }
  return p * x;
}
function gaussian (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleNormal(mu, sigma),
    pdf: value => densityNormal(value, mu, sigma),
    cdf: value => cumulativeNormal(value, mu, sigma),
    icdf: p => quantileNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function kde (support, bandwidth) {
  const kernel = gaussian();
  let n = 0;
  const dist = {
    data(_) {
      if (arguments.length) {
        support = _;
        n = _ ? _.length : 0;
        return dist.bandwidth(bandwidth);
      } else {
        return support;
      }
    },
    bandwidth(_) {
      if (!arguments.length) return bandwidth;
      bandwidth = _;
      if (!bandwidth && support) bandwidth = estimateBandwidth(support);
      return dist;
    },
    sample() {
      return support[~~(random() * n)] + bandwidth * kernel.sample();
    },
    pdf(x) {
      let y = 0,
        i = 0;
      for (; i < n; ++i) {
        y += kernel.pdf((x - support[i]) / bandwidth);
      }
      return y / bandwidth / n;
    },
    cdf(x) {
      let y = 0,
        i = 0;
      for (; i < n; ++i) {
        y += kernel.cdf((x - support[i]) / bandwidth);
      }
      return y / n;
    },
    icdf() {
      throw Error('KDE icdf not supported.');
    }
  };
  return dist.data(support);
}

function sampleLogNormal(mean, stdev) {
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  return Math.exp(mean + sampleNormal() * stdev);
}
function densityLogNormal(value, mean, stdev) {
  if (value <= 0) return 0;
  mean = mean || 0;
  stdev = stdev == null ? 1 : stdev;
  const z = (Math.log(value) - mean) / stdev;
  return Math.exp(-0.5 * z * z) / (stdev * SQRT2PI * value);
}
function cumulativeLogNormal(value, mean, stdev) {
  return cumulativeNormal(Math.log(value), mean, stdev);
}
function quantileLogNormal(p, mean, stdev) {
  return Math.exp(quantileNormal(p, mean, stdev));
}
function lognormal (mean, stdev) {
  let mu, sigma;
  const dist = {
    mean(_) {
      if (arguments.length) {
        mu = _ || 0;
        return dist;
      } else {
        return mu;
      }
    },
    stdev(_) {
      if (arguments.length) {
        sigma = _ == null ? 1 : _;
        return dist;
      } else {
        return sigma;
      }
    },
    sample: () => sampleLogNormal(mu, sigma),
    pdf: value => densityLogNormal(value, mu, sigma),
    cdf: value => cumulativeLogNormal(value, mu, sigma),
    icdf: p => quantileLogNormal(p, mu, sigma)
  };
  return dist.mean(mean).stdev(stdev);
}

function mixture (dists, weights) {
  let m = 0,
    w;
  function normalize(x) {
    const w = [];
    let sum = 0,
      i;
    for (i = 0; i < m; ++i) {
      sum += w[i] = x[i] == null ? 1 : +x[i];
    }
    for (i = 0; i < m; ++i) {
      w[i] /= sum;
    }
    return w;
  }
  const dist = {
    weights(_) {
      if (arguments.length) {
        w = normalize(weights = _ || []);
        return dist;
      }
      return weights;
    },
    distributions(_) {
      if (arguments.length) {
        if (_) {
          m = _.length;
          dists = _;
        } else {
          m = 0;
          dists = [];
        }
        return dist.weights(weights);
      }
      return dists;
    },
    sample() {
      const r = random();
      let d = dists[m - 1],
        v = w[0],
        i = 0;

      // first select distribution
      for (; i < m - 1; v += w[++i]) {
        if (r < v) {
          d = dists[i];
          break;
        }
      }
      // then sample from it
      return d.sample();
    },
    pdf(x) {
      let p = 0,
        i = 0;
      for (; i < m; ++i) {
        p += w[i] * dists[i].pdf(x);
      }
      return p;
    },
    cdf(x) {
      let p = 0,
        i = 0;
      for (; i < m; ++i) {
        p += w[i] * dists[i].cdf(x);
      }
      return p;
    },
    icdf() {
      throw Error('Mixture icdf not supported.');
    }
  };
  return dist.distributions(dists).weights(weights);
}

function sampleUniform(min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }
  return min + (max - min) * random();
}
function densityUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }
  return value >= min && value <= max ? 1 / (max - min) : 0;
}
function cumulativeUniform(value, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }
  return value < min ? 0 : value > max ? 1 : (value - min) / (max - min);
}
function quantileUniform(p, min, max) {
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }
  return p >= 0 && p <= 1 ? min + p * (max - min) : NaN;
}
function uniform (min, max) {
  let a, b;
  const dist = {
    min(_) {
      if (arguments.length) {
        a = _ || 0;
        return dist;
      } else {
        return a;
      }
    },
    max(_) {
      if (arguments.length) {
        b = _ == null ? 1 : _;
        return dist;
      } else {
        return b;
      }
    },
    sample: () => sampleUniform(a, b),
    pdf: value => densityUniform(value, a, b),
    cdf: value => cumulativeUniform(value, a, b),
    icdf: p => quantileUniform(p, a, b)
  };
  if (max == null) {
    max = min == null ? 1 : min;
    min = 0;
  }
  return dist.min(min).max(max);
}

function constant (data, x, y) {
  let mean = 0,
    n = 0;
  for (const d of data) {
    const val = y(d);
    if (x(d) == null || val == null || isNaN(val)) continue;
    mean += (val - mean) / ++n;
  }
  return {
    coef: [mean],
    predict: () => mean,
    rSquared: 0
  };
}

// Ordinary Least Squares
function ols (uX, uY, uXY, uX2) {
  const delta = uX2 - uX * uX,
    slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta,
    intercept = uY - slope * uX;
  return [intercept, slope];
}

function points(data, x, y, sort) {
  data = data.filter(d => {
    let u = x(d),
      v = y(d);
    return u != null && (u = +u) >= u && v != null && (v = +v) >= v;
  });
  if (sort) {
    data.sort((a, b) => x(a) - x(b));
  }
  const n = data.length,
    X = new Float64Array(n),
    Y = new Float64Array(n);

  // extract values, calculate means
  let i = 0,
    ux = 0,
    uy = 0,
    xv,
    yv,
    d;
  for (d of data) {
    X[i] = xv = +x(d);
    Y[i] = yv = +y(d);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }

  // mean center the data
  for (i = 0; i < n; ++i) {
    X[i] -= ux;
    Y[i] -= uy;
  }
  return [X, Y, ux, uy];
}
function visitPoints(data, x, y, callback) {
  let i = -1,
    u,
    v;
  for (const d of data) {
    u = x(d);
    v = y(d);
    if (u != null && (u = +u) >= u && v != null && (v = +v) >= v) {
      callback(u, v, ++i);
    }
  }
}

// Adapted from d3-regression by Harry Stevens
// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
function rSquared (data, x, y, uY, predict) {
  let SSE = 0,
    SST = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const sse = dy - predict(dx),
      sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}

// Adapted from d3-regression by Harry Stevens
// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
function linear (data, x, y) {
  let X = 0,
    Y = 0,
    XY = 0,
    X2 = 0,
    n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });
  const coef = ols(X, Y, XY, X2),
    predict = x => coef[0] + coef[1] * x;
  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

// Adapted from d3-regression by Harry Stevens
// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
function log (data, x, y) {
  let X = 0,
    Y = 0,
    XY = 0,
    X2 = 0,
    n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    ++n;
    dx = Math.log(dx);
    X += (dx - X) / n;
    Y += (dy - Y) / n;
    XY += (dx * dy - XY) / n;
    X2 += (dx * dx - X2) / n;
  });
  const coef = ols(X, Y, XY, X2),
    predict = x => coef[0] + coef[1] * Math.log(x);
  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, Y, predict)
  };
}

function exp (data, x, y) {
  // eslint-disable-next-line no-unused-vars
  const [xv, yv, ux, uy] = points(data, x, y);
  let YL = 0,
    XY = 0,
    XYL = 0,
    X2Y = 0,
    n = 0,
    dx,
    ly,
    xy;
  visitPoints(data, x, y, (_, dy) => {
    dx = xv[n++];
    ly = Math.log(dy);
    xy = dx * dy;
    YL += (dy * ly - YL) / n;
    XY += (xy - XY) / n;
    XYL += (xy * ly - XYL) / n;
    X2Y += (dx * xy - X2Y) / n;
  });
  const [c0, c1] = ols(XY / uy, YL / uy, XYL / uy, X2Y / uy),
    predict = x => Math.exp(c0 + c1 * (x - ux));
  return {
    coef: [Math.exp(c0 - c1 * ux), c1],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// Adapted from d3-regression by Harry Stevens
// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
function pow (data, x, y) {
  let X = 0,
    Y = 0,
    XY = 0,
    X2 = 0,
    YS = 0,
    n = 0;
  visitPoints(data, x, y, (dx, dy) => {
    const lx = Math.log(dx),
      ly = Math.log(dy);
    ++n;
    X += (lx - X) / n;
    Y += (ly - Y) / n;
    XY += (lx * ly - XY) / n;
    X2 += (lx * lx - X2) / n;
    YS += (dy - YS) / n;
  });
  const coef = ols(X, Y, XY, X2),
    predict = x => coef[0] * Math.pow(x, coef[1]);
  coef[0] = Math.exp(coef[0]);
  return {
    coef: coef,
    predict: predict,
    rSquared: rSquared(data, x, y, YS, predict)
  };
}

function quad (data, x, y) {
  const [xv, yv, ux, uy] = points(data, x, y),
    n = xv.length;
  let X2 = 0,
    X3 = 0,
    X4 = 0,
    XY = 0,
    X2Y = 0,
    i,
    dx,
    dy,
    x2;
  for (i = 0; i < n;) {
    dx = xv[i];
    dy = yv[i++];
    x2 = dx * dx;
    X2 += (x2 - X2) / i;
    X3 += (x2 * dx - X3) / i;
    X4 += (x2 * x2 - X4) / i;
    XY += (dx * dy - XY) / i;
    X2Y += (x2 * dy - X2Y) / i;
  }
  const X2X2 = X4 - X2 * X2,
    d = X2 * X2X2 - X3 * X3,
    a = (X2Y * X2 - XY * X3) / d,
    b = (XY * X2X2 - X2Y * X3) / d,
    c = -a * X2,
    predict = x => {
      x = x - ux;
      return a * x * x + b * x + c + uy;
    };

  // transform coefficients back from mean-centered space
  return {
    coef: [c - b * ux + a * ux * ux + uy, b - 2 * a * ux, a],
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}

// Adapted from d3-regression by Harry Stevens
// License: https://github.com/HarryStevens/d3-regression/blob/master/LICENSE
// ... which was adapted from regression-js by Tom Alexander
// Source: https://github.com/Tom-Alexander/regression-js/blob/master/src/regression.js#L246
// License: https://github.com/Tom-Alexander/regression-js/blob/master/LICENSE
function poly (data, x, y, order) {
  // use more efficient methods for lower orders
  if (order === 0) return constant(data, x, y);
  if (order === 1) return linear(data, x, y);
  if (order === 2) return quad(data, x, y);
  const [xv, yv, ux, uy] = points(data, x, y),
    n = xv.length,
    lhs = [],
    rhs = [],
    k = order + 1;
  let i, j, l, v, c;
  for (i = 0; i < k; ++i) {
    for (l = 0, v = 0; l < n; ++l) {
      v += Math.pow(xv[l], i) * yv[l];
    }
    lhs.push(v);
    c = new Float64Array(k);
    for (j = 0; j < k; ++j) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i + j);
      }
      c[j] = v;
    }
    rhs.push(c);
  }
  rhs.push(lhs);
  const coef = gaussianElimination(rhs),
    predict = x => {
      x -= ux;
      let y = uy + coef[0] + coef[1] * x + coef[2] * x * x;
      for (i = 3; i < k; ++i) y += coef[i] * Math.pow(x, i);
      return y;
    };
  return {
    coef: uncenter(k, coef, -ux, uy),
    predict: predict,
    rSquared: rSquared(data, x, y, uy, predict)
  };
}
function uncenter(k, a, x, y) {
  const z = Array(k);
  let i, j, v, c;

  // initialize to zero
  for (i = 0; i < k; ++i) z[i] = 0;

  // polynomial expansion
  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j; // binomial coefficent
      z[i - j] += v * Math.pow(x, j) * c;
    }
  }

  // bias term
  z[0] += y;
  return z;
}

// Given an array for a two-dimensional matrix and the polynomial order,
// solve A * x = b using Gaussian elimination.
function gaussianElimination(matrix) {
  const n = matrix.length - 1,
    coef = [];
  let i, j, k, r, t;
  for (i = 0; i < n; ++i) {
    r = i; // max row
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}

const maxiters = 2,
  epsilon = 1e-12;

// Adapted from science.js by Jason Davies
// Source: https://github.com/jasondavies/science.js/blob/master/src/stats/loess.js
// License: https://github.com/jasondavies/science.js/blob/master/LICENSE
function loess (data, x, y, bandwidth) {
  const [xv, yv, ux, uy] = points(data, x, y, true),
    n = xv.length,
    bw = Math.max(2, ~~(bandwidth * n)),
    // # nearest neighbors
    yhat = new Float64Array(n),
    residuals = new Float64Array(n),
    robustWeights = new Float64Array(n).fill(1);
  for (let iter = -1; ++iter <= maxiters;) {
    const interval = [0, bw - 1];
    for (let i = 0; i < n; ++i) {
      const dx = xv[i],
        i0 = interval[0],
        i1 = interval[1],
        edge = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
      let W = 0,
        X = 0,
        Y = 0,
        XY = 0,
        X2 = 0;
      const denom = 1 / Math.abs(xv[edge] - dx || 1); // avoid singularity!

      for (let k = i0; k <= i1; ++k) {
        const xk = xv[k],
          yk = yv[k],
          w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k],
          xkw = xk * w;
        W += w;
        X += xkw;
        Y += yk * w;
        XY += yk * xkw;
        X2 += xk * xkw;
      }

      // linear regression fit
      const [a, b] = ols(X / W, Y / W, XY / W, X2 / W);
      yhat[i] = a + b * dx;
      residuals[i] = Math.abs(yv[i] - yhat[i]);
      updateInterval(xv, i + 1, interval);
    }
    if (iter === maxiters) {
      break;
    }
    const medianResidual = (0,d3_array__WEBPACK_IMPORTED_MODULE_3__["default"])(residuals);
    if (Math.abs(medianResidual) < epsilon) break;
    for (let i = 0, arg, w; i < n; ++i) {
      arg = residuals[i] / (6 * medianResidual);
      // default to epsilon (rather than zero) for large deviations
      // keeping weights tiny but non-zero prevents singularites
      robustWeights[i] = arg >= 1 ? epsilon : (w = 1 - arg * arg) * w;
    }
  }
  return output(xv, yhat, ux, uy);
}

// weighting kernel for local regression
function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
}

// advance sliding window interval of nearest neighbors
function updateInterval(xv, i, interval) {
  const val = xv[i];
  let left = interval[0],
    right = interval[1] + 1;
  if (right >= xv.length) return;

  // step right if distance to new right edge is <= distance to old left edge
  // step when distance is equal to ensure movement over duplicate x values
  while (i > left && xv[right] - val <= val - xv[left]) {
    interval[0] = ++left;
    interval[1] = right;
    ++right;
  }
}

// generate smoothed output points
// average points with repeated x values
function output(xv, yhat, ux, uy) {
  const n = xv.length,
    out = [];
  let i = 0,
    cnt = 0,
    prev = [],
    v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      // average output values via online update
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      // add new output point
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}

// subdivide up to accuracy of 0.5 degrees
const MIN_RADIANS = 0.5 * Math.PI / 180;

// Adaptively sample an interpolated function over a domain extent
function sampleCurve (f, extent, minSteps, maxSteps) {
  minSteps = minSteps || 25;
  maxSteps = Math.max(minSteps, maxSteps || 200);
  const point = x => [x, f(x)],
    minX = extent[0],
    maxX = extent[1],
    span = maxX - minX,
    stop = span / maxSteps,
    prev = [point(minX)],
    next = [];
  if (minSteps === maxSteps) {
    // no adaptation, sample uniform grid directly and return
    for (let i = 1; i < maxSteps; ++i) {
      prev.push(point(minX + i / minSteps * span));
    }
    prev.push(point(maxX));
    return prev;
  } else {
    // sample minimum points on uniform grid
    // then move on to perform adaptive refinement
    next.push(point(maxX));
    for (let i = minSteps; --i > 0;) {
      next.push(point(minX + i / minSteps * span));
    }
  }
  let p0 = prev[0];
  let p1 = next[next.length - 1];
  const sx = 1 / span;
  const sy = scaleY(p0[1], next);
  while (p1) {
    // midpoint for potential curve subdivision
    const pm = point((p0[0] + p1[0]) / 2);
    const dx = pm[0] - p0[0] >= stop;
    if (dx && angleDelta(p0, pm, p1, sx, sy) > MIN_RADIANS) {
      // maximum resolution has not yet been met, and
      // subdivision midpoint is sufficiently different from endpoint
      // save subdivision, push midpoint onto the visitation stack
      next.push(pm);
    } else {
      // subdivision midpoint sufficiently similar to endpoint
      // skip subdivision, store endpoint, move to next point on the stack
      p0 = p1;
      prev.push(p1);
      next.pop();
    }
    p1 = next[next.length - 1];
  }
  return prev;
}
function scaleY(init, points) {
  let ymin = init;
  let ymax = init;
  const n = points.length;
  for (let i = 0; i < n; ++i) {
    const y = points[i][1];
    if (y < ymin) ymin = y;
    if (y > ymax) ymax = y;
  }
  return 1 / (ymax - ymin);
}
function angleDelta(p, q, r, sx, sy) {
  const a0 = Math.atan2(sy * (r[1] - p[1]), sx * (r[0] - p[0])),
    a1 = Math.atan2(sy * (q[1] - p[1]), sx * (q[0] - p[0]));
  return Math.abs(a0 - a1);
}




/***/ }),

/***/ "./node_modules/vega-time/build/vega-time.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/vega-time/build/vega-time.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DATE: () => (/* binding */ DATE),
/* harmony export */   DAY: () => (/* binding */ DAY),
/* harmony export */   DAYOFYEAR: () => (/* binding */ DAYOFYEAR),
/* harmony export */   HOURS: () => (/* binding */ HOURS),
/* harmony export */   MILLISECONDS: () => (/* binding */ MILLISECONDS),
/* harmony export */   MINUTES: () => (/* binding */ MINUTES),
/* harmony export */   MONTH: () => (/* binding */ MONTH),
/* harmony export */   QUARTER: () => (/* binding */ QUARTER),
/* harmony export */   SECONDS: () => (/* binding */ SECONDS),
/* harmony export */   TIME_UNITS: () => (/* binding */ TIME_UNITS),
/* harmony export */   WEEK: () => (/* binding */ WEEK),
/* harmony export */   YEAR: () => (/* binding */ YEAR),
/* harmony export */   dayofyear: () => (/* binding */ dayofyear),
/* harmony export */   timeBin: () => (/* binding */ bin),
/* harmony export */   timeFloor: () => (/* binding */ timeFloor),
/* harmony export */   timeInterval: () => (/* binding */ timeInterval),
/* harmony export */   timeOffset: () => (/* binding */ timeOffset),
/* harmony export */   timeSequence: () => (/* binding */ timeSequence),
/* harmony export */   timeUnitSpecifier: () => (/* binding */ timeUnitSpecifier),
/* harmony export */   timeUnits: () => (/* binding */ timeUnits),
/* harmony export */   utcFloor: () => (/* binding */ utcFloor),
/* harmony export */   utcInterval: () => (/* binding */ utcInterval),
/* harmony export */   utcOffset: () => (/* binding */ utcOffset),
/* harmony export */   utcSequence: () => (/* binding */ utcSequence),
/* harmony export */   utcdayofyear: () => (/* binding */ utcdayofyear),
/* harmony export */   utcweek: () => (/* binding */ utcweek),
/* harmony export */   week: () => (/* binding */ week)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/day.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/week.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/year.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/month.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/hour.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/minute.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/second.js");
/* harmony import */ var d3_time__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-time */ "./node_modules/d3-time/src/millisecond.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");




const YEAR = 'year';
const QUARTER = 'quarter';
const MONTH = 'month';
const WEEK = 'week';
const DATE = 'date';
const DAY = 'day';
const DAYOFYEAR = 'dayofyear';
const HOURS = 'hours';
const MINUTES = 'minutes';
const SECONDS = 'seconds';
const MILLISECONDS = 'milliseconds';
const TIME_UNITS = [YEAR, QUARTER, MONTH, WEEK, DATE, DAY, DAYOFYEAR, HOURS, MINUTES, SECONDS, MILLISECONDS];
const UNITS = TIME_UNITS.reduce((o, u, i) => (o[u] = 1 + i, o), {});
function timeUnits(units) {
  const u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(units).slice(),
    m = {};

  // check validity
  if (!u.length) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing time unit.');
  u.forEach(unit => {
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(UNITS, unit)) {
      m[unit] = 1;
    } else {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(`Invalid time unit: ${unit}.`);
    }
  });
  const numTypes = (m[WEEK] || m[DAY] ? 1 : 0) + (m[QUARTER] || m[MONTH] || m[DATE] ? 1 : 0) + (m[DAYOFYEAR] ? 1 : 0);
  if (numTypes > 1) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)(`Incompatible time units: ${units}`);
  }

  // ensure proper sort order
  u.sort((a, b) => UNITS[a] - UNITS[b]);
  return u;
}
const defaultSpecifiers = {
  [YEAR]: '%Y ',
  [QUARTER]: 'Q%q ',
  [MONTH]: '%b ',
  [DATE]: '%d ',
  [WEEK]: 'W%U ',
  [DAY]: '%a ',
  [DAYOFYEAR]: '%j ',
  [HOURS]: '%H:00',
  [MINUTES]: '00:%M',
  [SECONDS]: ':%S',
  [MILLISECONDS]: '.%L',
  [`${YEAR}-${MONTH}`]: '%Y-%m ',
  [`${YEAR}-${MONTH}-${DATE}`]: '%Y-%m-%d ',
  [`${HOURS}-${MINUTES}`]: '%H:%M'
};
function timeUnitSpecifier(units, specifiers) {
  const s = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, defaultSpecifiers, specifiers),
    u = timeUnits(units),
    n = u.length;
  let fmt = '',
    start = 0,
    end,
    key;
  for (start = 0; start < n;) {
    for (end = u.length; end > start; --end) {
      key = u.slice(start, end).join('-');
      if (s[key] != null) {
        fmt += s[key];
        start = end;
        break;
      }
    }
  }
  return fmt.trim();
}

const t0 = new Date();
function localYear(y) {
  t0.setFullYear(y);
  t0.setMonth(0);
  t0.setDate(1);
  t0.setHours(0, 0, 0, 0);
  return t0;
}
function dayofyear(d) {
  return localDayOfYear(new Date(d));
}
function week(d) {
  return localWeekNum(new Date(d));
}
function localDayOfYear(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_1__.timeDay.count(localYear(d.getFullYear()) - 1, d);
}
function localWeekNum(d) {
  return d3_time__WEBPACK_IMPORTED_MODULE_2__.timeSunday.count(localYear(d.getFullYear()) - 1, d);
}
function localFirst(y) {
  return localYear(y).getDay();
}
function localDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(-1, m, d, H, M, S, L);
    date.setFullYear(y);
    return date;
  }
  return new Date(y, m, d, H, M, S, L);
}
function utcdayofyear(d) {
  return utcDayOfYear(new Date(d));
}
function utcweek(d) {
  return utcWeekNum(new Date(d));
}
function utcDayOfYear(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_1__.utcDay.count(y - 1, d);
}
function utcWeekNum(d) {
  const y = Date.UTC(d.getUTCFullYear(), 0, 1);
  return d3_time__WEBPACK_IMPORTED_MODULE_2__.utcSunday.count(y - 1, d);
}
function utcFirst(y) {
  t0.setTime(Date.UTC(y, 0, 1));
  return t0.getUTCDay();
}
function utcDate(y, m, d, H, M, S, L) {
  if (0 <= y && y < 100) {
    const date = new Date(Date.UTC(-1, m, d, H, M, S, L));
    date.setUTCFullYear(d.y);
    return date;
  }
  return new Date(Date.UTC(y, m, d, H, M, S, L));
}

function floor(units, step, get, inv, newDate) {
  const s = step || 1,
    b = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(units),
    _ = (unit, p, key) => {
      key = key || unit;
      return getUnit(get[key], inv[key], unit === b && s, p);
    };
  const t = new Date(),
    u = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(units),
    y = u[YEAR] ? _(YEAR) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(2012),
    m = u[MONTH] ? _(MONTH) : u[QUARTER] ? _(QUARTER) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    d = u[WEEK] && u[DAY] ? _(DAY, 1, WEEK + DAY) : u[WEEK] ? _(WEEK, 1) : u[DAY] ? _(DAY, 1) : u[DATE] ? _(DATE, 1) : u[DAYOFYEAR] ? _(DAYOFYEAR, 1) : vega_util__WEBPACK_IMPORTED_MODULE_0__.one,
    H = u[HOURS] ? _(HOURS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    M = u[MINUTES] ? _(MINUTES) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    S = u[SECONDS] ? _(SECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    L = u[MILLISECONDS] ? _(MILLISECONDS) : vega_util__WEBPACK_IMPORTED_MODULE_0__.zero;
  return function (v) {
    t.setTime(+v);
    const year = y(t);
    return newDate(year, m(t), d(t, year), H(t), M(t), S(t), L(t));
  };
}
function getUnit(f, inv, step, phase) {
  const u = step <= 1 ? f : phase ? (d, y) => phase + step * Math.floor((f(d, y) - phase) / step) : (d, y) => step * Math.floor(f(d, y) / step);
  return inv ? (d, y) => inv(u(d, y), y) : u;
}

// returns the day of the year based on week number, day of week,
// and the day of the week for the first day of the year
function weekday(week, day, firstDay) {
  return day + week * 7 - (firstDay + 6) % 7;
}

// -- LOCAL TIME --

const localGet = {
  [YEAR]: d => d.getFullYear(),
  [QUARTER]: d => Math.floor(d.getMonth() / 3),
  [MONTH]: d => d.getMonth(),
  [DATE]: d => d.getDate(),
  [HOURS]: d => d.getHours(),
  [MINUTES]: d => d.getMinutes(),
  [SECONDS]: d => d.getSeconds(),
  [MILLISECONDS]: d => d.getMilliseconds(),
  [DAYOFYEAR]: d => localDayOfYear(d),
  [WEEK]: d => localWeekNum(d),
  [WEEK + DAY]: (d, y) => weekday(localWeekNum(d), d.getDay(), localFirst(y)),
  [DAY]: (d, y) => weekday(1, d.getDay(), localFirst(y))
};
const localInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, localFirst(y))
};
function timeFloor(units, step) {
  return floor(units, step || 1, localGet, localInv, localDate);
}

// -- UTC TIME --

const utcGet = {
  [YEAR]: d => d.getUTCFullYear(),
  [QUARTER]: d => Math.floor(d.getUTCMonth() / 3),
  [MONTH]: d => d.getUTCMonth(),
  [DATE]: d => d.getUTCDate(),
  [HOURS]: d => d.getUTCHours(),
  [MINUTES]: d => d.getUTCMinutes(),
  [SECONDS]: d => d.getUTCSeconds(),
  [MILLISECONDS]: d => d.getUTCMilliseconds(),
  [DAYOFYEAR]: d => utcDayOfYear(d),
  [WEEK]: d => utcWeekNum(d),
  [DAY]: (d, y) => weekday(1, d.getUTCDay(), utcFirst(y)),
  [WEEK + DAY]: (d, y) => weekday(utcWeekNum(d), d.getUTCDay(), utcFirst(y))
};
const utcInv = {
  [QUARTER]: q => 3 * q,
  [WEEK]: (w, y) => weekday(w, 0, utcFirst(y))
};
function utcFloor(units, step) {
  return floor(units, step || 1, utcGet, utcInv, utcDate);
}

const timeIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_3__.timeYear,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_4__.timeMonth.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_4__.timeMonth,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_2__.timeSunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_1__.timeDay,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_1__.timeDay,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_1__.timeDay,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_5__.timeHour,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_6__.timeMinute,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_7__.second,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_8__.millisecond
};
const utcIntervals = {
  [YEAR]: d3_time__WEBPACK_IMPORTED_MODULE_3__.utcYear,
  [QUARTER]: d3_time__WEBPACK_IMPORTED_MODULE_4__.utcMonth.every(3),
  [MONTH]: d3_time__WEBPACK_IMPORTED_MODULE_4__.utcMonth,
  [WEEK]: d3_time__WEBPACK_IMPORTED_MODULE_2__.utcSunday,
  [DATE]: d3_time__WEBPACK_IMPORTED_MODULE_1__.utcDay,
  [DAY]: d3_time__WEBPACK_IMPORTED_MODULE_1__.utcDay,
  [DAYOFYEAR]: d3_time__WEBPACK_IMPORTED_MODULE_1__.utcDay,
  [HOURS]: d3_time__WEBPACK_IMPORTED_MODULE_5__.utcHour,
  [MINUTES]: d3_time__WEBPACK_IMPORTED_MODULE_6__.utcMinute,
  [SECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_7__.second,
  [MILLISECONDS]: d3_time__WEBPACK_IMPORTED_MODULE_8__.millisecond
};
function timeInterval(unit) {
  return timeIntervals[unit];
}
function utcInterval(unit) {
  return utcIntervals[unit];
}
function offset(ival, date, step) {
  return ival ? ival.offset(date, step) : undefined;
}
function timeOffset(unit, date, step) {
  return offset(timeInterval(unit), date, step);
}
function utcOffset(unit, date, step) {
  return offset(utcInterval(unit), date, step);
}
function sequence(ival, start, stop, step) {
  return ival ? ival.range(start, stop, step) : undefined;
}
function timeSequence(unit, start, stop, step) {
  return sequence(timeInterval(unit), start, stop, step);
}
function utcSequence(unit, start, stop, step) {
  return sequence(utcInterval(unit), start, stop, step);
}

const durationSecond = 1000,
  durationMinute = durationSecond * 60,
  durationHour = durationMinute * 60,
  durationDay = durationHour * 24,
  durationWeek = durationDay * 7,
  durationMonth = durationDay * 30,
  durationYear = durationDay * 365;
const Milli = [YEAR, MONTH, DATE, HOURS, MINUTES, SECONDS, MILLISECONDS],
  Seconds = Milli.slice(0, -1),
  Minutes = Seconds.slice(0, -1),
  Hours = Minutes.slice(0, -1),
  Day = Hours.slice(0, -1),
  Week = [YEAR, WEEK],
  Month = [YEAR, MONTH],
  Year = [YEAR];
const intervals = [[Seconds, 1, durationSecond], [Seconds, 5, 5 * durationSecond], [Seconds, 15, 15 * durationSecond], [Seconds, 30, 30 * durationSecond], [Minutes, 1, durationMinute], [Minutes, 5, 5 * durationMinute], [Minutes, 15, 15 * durationMinute], [Minutes, 30, 30 * durationMinute], [Hours, 1, durationHour], [Hours, 3, 3 * durationHour], [Hours, 6, 6 * durationHour], [Hours, 12, 12 * durationHour], [Day, 1, durationDay], [Week, 1, durationWeek], [Month, 1, durationMonth], [Month, 3, 3 * durationMonth], [Year, 1, durationYear]];
function bin (opt) {
  const ext = opt.extent,
    max = opt.maxbins || 40,
    target = Math.abs((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)(ext)) / max;
  let i = (0,d3_array__WEBPACK_IMPORTED_MODULE_9__["default"])(i => i[2]).right(intervals, target),
    units,
    step;
  if (i === intervals.length) {
    units = Year, step = (0,d3_array__WEBPACK_IMPORTED_MODULE_10__.tickStep)(ext[0] / durationYear, ext[1] / durationYear, max);
  } else if (i) {
    i = intervals[target / intervals[i - 1][2] < intervals[i][2] / target ? i - 1 : i];
    units = i[0];
    step = i[1];
  } else {
    units = Milli;
    step = Math.max((0,d3_array__WEBPACK_IMPORTED_MODULE_10__.tickStep)(ext[0], ext[1], max), 1);
  }
  return {
    units,
    step
  };
}




/***/ }),

/***/ "./node_modules/vega-transforms/build/vega-transforms.module.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vega-transforms/build/vega-transforms.module.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   aggregate: () => (/* binding */ Aggregate),
/* harmony export */   bin: () => (/* binding */ Bin),
/* harmony export */   collect: () => (/* binding */ Collect),
/* harmony export */   compare: () => (/* binding */ Compare),
/* harmony export */   countpattern: () => (/* binding */ CountPattern),
/* harmony export */   cross: () => (/* binding */ Cross),
/* harmony export */   density: () => (/* binding */ Density),
/* harmony export */   dotbin: () => (/* binding */ DotBin),
/* harmony export */   expression: () => (/* binding */ Expression),
/* harmony export */   extent: () => (/* binding */ Extent),
/* harmony export */   facet: () => (/* binding */ Facet),
/* harmony export */   field: () => (/* binding */ Field),
/* harmony export */   filter: () => (/* binding */ Filter),
/* harmony export */   flatten: () => (/* binding */ Flatten),
/* harmony export */   fold: () => (/* binding */ Fold),
/* harmony export */   formula: () => (/* binding */ Formula),
/* harmony export */   generate: () => (/* binding */ Generate),
/* harmony export */   impute: () => (/* binding */ Impute),
/* harmony export */   joinaggregate: () => (/* binding */ JoinAggregate),
/* harmony export */   kde: () => (/* binding */ KDE),
/* harmony export */   key: () => (/* binding */ Key),
/* harmony export */   load: () => (/* binding */ Load),
/* harmony export */   lookup: () => (/* binding */ Lookup),
/* harmony export */   multiextent: () => (/* binding */ MultiExtent),
/* harmony export */   multivalues: () => (/* binding */ MultiValues),
/* harmony export */   params: () => (/* binding */ Params),
/* harmony export */   pivot: () => (/* binding */ Pivot),
/* harmony export */   prefacet: () => (/* binding */ PreFacet),
/* harmony export */   project: () => (/* binding */ Project),
/* harmony export */   proxy: () => (/* binding */ Proxy),
/* harmony export */   quantile: () => (/* binding */ Quantile),
/* harmony export */   relay: () => (/* binding */ Relay),
/* harmony export */   sample: () => (/* binding */ Sample),
/* harmony export */   sequence: () => (/* binding */ Sequence),
/* harmony export */   sieve: () => (/* binding */ Sieve),
/* harmony export */   subflow: () => (/* binding */ Subflow),
/* harmony export */   timeunit: () => (/* binding */ TimeUnit),
/* harmony export */   tupleindex: () => (/* binding */ TupleIndex),
/* harmony export */   values: () => (/* binding */ Values),
/* harmony export */   window: () => (/* binding */ Window)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/median.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/mean.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/min.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/max.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/range.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/bisector.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");






function multikey(f) {
  return x => {
    const n = f.length;
    let i = 1,
      k = String(f[0](x));
    for (; i < n; ++i) {
      k += '|' + f[i](x);
    }
    return k;
  };
}
function groupkey(fields) {
  return !fields || !fields.length ? function () {
    return '';
  } : fields.length === 1 ? fields[0] : multikey(fields);
}

function measureName(op, field, as) {
  return as || op + (!field ? '' : '_' + field);
}
const noop = () => {};
const base_op = {
  init: noop,
  add: noop,
  rem: noop,
  idx: 0
};
const AggregateOps = {
  values: {
    init: m => m.cell.store = true,
    value: m => m.cell.data.values(),
    idx: -1
  },
  count: {
    value: m => m.cell.num
  },
  __count__: {
    value: m => m.missing + m.valid
  },
  missing: {
    value: m => m.missing
  },
  valid: {
    value: m => m.valid
  },
  sum: {
    init: m => m.sum = 0,
    value: m => m.valid ? m.sum : undefined,
    add: (m, v) => m.sum += +v,
    rem: (m, v) => m.sum -= v
  },
  product: {
    init: m => m.product = 1,
    value: m => m.valid ? m.product : undefined,
    add: (m, v) => m.product *= v,
    rem: (m, v) => m.product /= v
  },
  mean: {
    init: m => m.mean = 0,
    value: m => m.valid ? m.mean : undefined,
    add: (m, v) => (m.mean_d = v - m.mean, m.mean += m.mean_d / m.valid),
    rem: (m, v) => (m.mean_d = v - m.mean, m.mean -= m.valid ? m.mean_d / m.valid : m.mean)
  },
  average: {
    value: m => m.valid ? m.mean : undefined,
    req: ['mean'],
    idx: 1
  },
  variance: {
    init: m => m.dev = 0,
    value: m => m.valid > 1 ? m.dev / (m.valid - 1) : undefined,
    add: (m, v) => m.dev += m.mean_d * (v - m.mean),
    rem: (m, v) => m.dev -= m.mean_d * (v - m.mean),
    req: ['mean'],
    idx: 1
  },
  variancep: {
    value: m => m.valid > 1 ? m.dev / m.valid : undefined,
    req: ['variance'],
    idx: 2
  },
  stdev: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid - 1)) : undefined,
    req: ['variance'],
    idx: 2
  },
  stdevp: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / m.valid) : undefined,
    req: ['variance'],
    idx: 2
  },
  stderr: {
    value: m => m.valid > 1 ? Math.sqrt(m.dev / (m.valid * (m.valid - 1))) : undefined,
    req: ['variance'],
    idx: 2
  },
  distinct: {
    value: m => m.cell.data.distinct(m.get),
    req: ['values'],
    idx: 3
  },
  ci0: {
    value: m => m.cell.data.ci0(m.get),
    req: ['values'],
    idx: 3
  },
  ci1: {
    value: m => m.cell.data.ci1(m.get),
    req: ['values'],
    idx: 3
  },
  median: {
    value: m => m.cell.data.q2(m.get),
    req: ['values'],
    idx: 3
  },
  q1: {
    value: m => m.cell.data.q1(m.get),
    req: ['values'],
    idx: 3
  },
  q3: {
    value: m => m.cell.data.q3(m.get),
    req: ['values'],
    idx: 3
  },
  min: {
    init: m => m.min = undefined,
    value: m => m.min = Number.isNaN(m.min) ? m.cell.data.min(m.get) : m.min,
    add: (m, v) => {
      if (v < m.min || m.min === undefined) m.min = v;
    },
    rem: (m, v) => {
      if (v <= m.min) m.min = NaN;
    },
    req: ['values'],
    idx: 4
  },
  max: {
    init: m => m.max = undefined,
    value: m => m.max = Number.isNaN(m.max) ? m.cell.data.max(m.get) : m.max,
    add: (m, v) => {
      if (v > m.max || m.max === undefined) m.max = v;
    },
    rem: (m, v) => {
      if (v >= m.max) m.max = NaN;
    },
    req: ['values'],
    idx: 4
  },
  argmin: {
    init: m => m.argmin = undefined,
    value: m => m.argmin || m.cell.data.argmin(m.get),
    add: (m, v, t) => {
      if (v < m.min) m.argmin = t;
    },
    rem: (m, v) => {
      if (v <= m.min) m.argmin = undefined;
    },
    req: ['min', 'values'],
    idx: 3
  },
  argmax: {
    init: m => m.argmax = undefined,
    value: m => m.argmax || m.cell.data.argmax(m.get),
    add: (m, v, t) => {
      if (v > m.max) m.argmax = t;
    },
    rem: (m, v) => {
      if (v >= m.max) m.argmax = undefined;
    },
    req: ['max', 'values'],
    idx: 3
  },
  exponential: {
    init: (m, r) => {
      m.exp = 0;
      m.exp_r = r;
    },
    value: m => m.valid ? m.exp * (1 - m.exp_r) / (1 - m.exp_r ** m.valid) : undefined,
    add: (m, v) => m.exp = m.exp_r * m.exp + v,
    rem: (m, v) => m.exp = (m.exp - v / m.exp_r ** (m.valid - 1)) / m.exp_r
  },
  exponentialb: {
    value: m => m.valid ? m.exp * (1 - m.exp_r) : undefined,
    req: ['exponential'],
    idx: 1
  }
};
const ValidAggregateOps = Object.keys(AggregateOps).filter(d => d !== '__count__');
function measure(key, value) {
  return (out, aggregate_param) => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    name: key,
    aggregate_param: aggregate_param,
    out: out || key
  }, base_op, value);
}
[...ValidAggregateOps, '__count__'].forEach(key => {
  AggregateOps[key] = measure(key, AggregateOps[key]);
});
function createMeasure(op, param, name) {
  return AggregateOps[op](name, param);
}
function compareIndex(a, b) {
  return a.idx - b.idx;
}
function resolve(agg) {
  const map = {};
  agg.forEach(a => map[a.name] = a);
  const getreqs = a => {
    if (!a.req) return;
    a.req.forEach(key => {
      if (!map[key]) getreqs(map[key] = AggregateOps[key]());
    });
  };
  agg.forEach(getreqs);
  return Object.values(map).sort(compareIndex);
}
function init() {
  this.valid = 0;
  this.missing = 0;
  this._ops.forEach(op => op.aggregate_param == null ? op.init(this) : op.init(this, op.aggregate_param));
}
function add(v, t) {
  if (v == null || v === '') {
    ++this.missing;
    return;
  }
  if (v !== v) return;
  ++this.valid;
  this._ops.forEach(op => op.add(this, v, t));
}
function rem(v, t) {
  if (v == null || v === '') {
    --this.missing;
    return;
  }
  if (v !== v) return;
  --this.valid;
  this._ops.forEach(op => op.rem(this, v, t));
}
function set(t) {
  this._out.forEach(op => t[op.out] = op.value(this));
  return t;
}
function compileMeasures(agg, field) {
  const get = field || vega_util__WEBPACK_IMPORTED_MODULE_0__.identity,
    ops = resolve(agg),
    out = agg.slice().sort(compareIndex);
  function ctr(cell) {
    this._ops = ops;
    this._out = out;
    this.cell = cell;
    this.init();
  }
  ctr.prototype.init = init;
  ctr.prototype.add = add;
  ctr.prototype.rem = rem;
  ctr.prototype.set = set;
  ctr.prototype.get = get;
  ctr.fields = agg.map(op => op.out);
  return ctr;
}

function TupleStore(key) {
  this._key = key ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(key) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid;
  this.reset();
}
const prototype$1 = TupleStore.prototype;
prototype$1.reset = function () {
  this._add = [];
  this._rem = [];
  this._ext = null;
  this._get = null;
  this._q = null;
};
prototype$1.add = function (v) {
  this._add.push(v);
};
prototype$1.rem = function (v) {
  this._rem.push(v);
};
prototype$1.values = function () {
  this._get = null;
  if (this._rem.length === 0) return this._add;
  const a = this._add,
    r = this._rem,
    k = this._key,
    n = a.length,
    m = r.length,
    x = Array(n - m),
    map = {};
  let i, j, v;

  // use unique key field to clear removed values
  for (i = 0; i < m; ++i) {
    map[k(r[i])] = 1;
  }
  for (i = 0, j = 0; i < n; ++i) {
    if (map[k(v = a[i])]) {
      map[k(v)] = 0;
    } else {
      x[j++] = v;
    }
  }
  this._rem = [];
  return this._add = x;
};

// memoizing statistics methods

prototype$1.distinct = function (get) {
  const v = this.values(),
    map = {};
  let n = v.length,
    count = 0,
    s;
  while (--n >= 0) {
    s = get(v[n]) + '';
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(map, s)) {
      map[s] = 1;
      ++count;
    }
  }
  return count;
};
prototype$1.extent = function (get) {
  if (this._get !== get || !this._ext) {
    const v = this.values(),
      i = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex)(v, get);
    this._ext = [v[i[0]], v[i[1]]];
    this._get = get;
  }
  return this._ext;
};
prototype$1.argmin = function (get) {
  return this.extent(get)[0] || {};
};
prototype$1.argmax = function (get) {
  return this.extent(get)[1] || {};
};
prototype$1.min = function (get) {
  const m = this.extent(get)[0];
  return m != null ? get(m) : undefined;
};
prototype$1.max = function (get) {
  const m = this.extent(get)[1];
  return m != null ? get(m) : undefined;
};
prototype$1.quartile = function (get) {
  if (this._get !== get || !this._q) {
    this._q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quartiles)(this.values(), get);
    this._get = get;
  }
  return this._q;
};
prototype$1.q1 = function (get) {
  return this.quartile(get)[0];
};
prototype$1.q2 = function (get) {
  return this.quartile(get)[1];
};
prototype$1.q3 = function (get) {
  return this.quartile(get)[2];
};
prototype$1.ci = function (get) {
  if (this._get !== get || !this._ci) {
    this._ci = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bootstrapCI)(this.values(), 1000, 0.05, get);
    this._get = get;
  }
  return this._ci;
};
prototype$1.ci0 = function (get) {
  return this.ci(get)[0];
};
prototype$1.ci1 = function (get) {
  return this.ci(get)[1];
};

/**
 * Group-by aggregation operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors to aggregate.
 * @param {Array<string>} [params.ops] - An array of strings indicating aggregation operations.
 * @param {Array<number>} [params.aggregate_params] - An optional array of parameters for aggregation operations.
 * @param {Array<string>} [params.as] - An array of output field names for aggregated values.
 * @param {boolean} [params.cross=false] - A flag indicating that the full
 *   cross-product of groupby values should be generated, including empty cells.
 *   If true, the drop parameter is ignored and empty cells are retained.
 * @param {boolean} [params.drop=true] - A flag indicating if empty cells should be removed.
 */
function Aggregate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this._adds = []; // array of added output tuples
  this._mods = []; // array of modified output tuples
  this._alen = 0; // number of active added tuples
  this._mlen = 0; // number of active modified tuples
  this._drop = true; // should empty aggregation cells be removed
  this._cross = false; // produce full cross-product of group-by values

  this._dims = []; // group-by dimension accessors
  this._dnames = []; // group-by dimension names

  this._measures = []; // collection of aggregation monoids
  this._countOnly = false; // flag indicating only count aggregation
  this._counts = null; // collection of count fields
  this._prev = null; // previous aggregation cells

  this._inputs = null; // array of dependent input tuple field names
  this._outputs = null; // array of output tuple field names
}
Aggregate.Definition = {
  'type': 'Aggregate',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'aggregate_params',
    'type': 'number',
    'null': true,
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'drop',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'cross',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Aggregate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const aggr = this,
      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      mod = _.modified();
    aggr.stamp = out.stamp;
    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      aggr._prev = aggr.value;
      aggr.value = mod ? aggr.init(_) : Object.create(null);
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      aggr.value = aggr.value || aggr.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    }

    // Indicate output fields and return aggregate tuples.
    out.modifies(aggr._outputs);

    // Should empty cells be dropped?
    aggr._drop = _.drop !== false;

    // If domain cross-product requested, generate empty cells as needed
    // and ensure that empty cells are not dropped
    if (_.cross && aggr._dims.length > 1) {
      aggr._drop = false;
      aggr.cross();
    }
    if (pulse.clean() && aggr._drop) {
      out.clean(true).runAfter(() => this.clean());
    }
    return aggr.changes(out);
  },
  cross() {
    const aggr = this,
      curr = aggr.value,
      dims = aggr._dnames,
      vals = dims.map(() => ({})),
      n = dims.length;

    // collect all group-by domain values
    function collect(cells) {
      let key, i, t, v;
      for (key in cells) {
        t = cells[key].tuple;
        for (i = 0; i < n; ++i) {
          vals[i][v = t[dims[i]]] = v;
        }
      }
    }
    collect(aggr._prev);
    collect(curr);

    // iterate over key cross-product, create cells as needed
    function generate(base, tuple, index) {
      const name = dims[index],
        v = vals[index++];
      for (const k in v) {
        const key = base ? base + '|' + k : k;
        tuple[name] = v[k];
        if (index < n) generate(key, tuple, index);else if (!curr[key]) aggr.cell(key, tuple);
      }
    }
    generate('', {}, 0);
  },
  init(_) {
    // initialize input and output fields
    const inputs = this._inputs = [],
      outputs = this._outputs = [],
      inputMap = {};
    function inputVisit(get) {
      const fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(get)),
        n = fields.length;
      let i = 0,
        f;
      for (; i < n; ++i) {
        if (!inputMap[f = fields[i]]) {
          inputMap[f] = 1;
          inputs.push(f);
        }
      }
    }

    // initialize group-by dimensions
    this._dims = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.groupby);
    this._dnames = this._dims.map(d => {
      const dname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(d);
      inputVisit(d);
      outputs.push(dname);
      return dname;
    });
    this.cellkey = _.key ? _.key : groupkey(this._dims);

    // initialize aggregate measures
    this._countOnly = true;
    this._counts = [];
    this._measures = [];
    const fields = _.fields || [null],
      ops = _.ops || ['count'],
      aggregate_params = _.aggregate_params || [null],
      as = _.as || [],
      n = fields.length,
      map = {};
    let field, op, aggregate_param, m, mname, outname, i;
    if (n !== ops.length) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unmatched number of fields and aggregate ops.');
    }
    for (i = 0; i < n; ++i) {
      field = fields[i];
      op = ops[i];
      aggregate_param = aggregate_params[i] || null;
      if (field == null && op !== 'count') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
      }
      mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      outname = measureName(op, mname, as[i]);
      outputs.push(outname);
      if (op === 'count') {
        this._counts.push(outname);
        continue;
      }
      m = map[mname];
      if (!m) {
        inputVisit(field);
        m = map[mname] = [];
        m.field = field;
        this._measures.push(m);
      }
      if (op !== 'count') this._countOnly = false;
      m.push(createMeasure(op, aggregate_param, outname));
    }
    this._measures = this._measures.map(m => compileMeasures(m, m.field));
    return Object.create(null); // aggregation cells (this.value)
  },
  // -- Cell Management -----

  cellkey: groupkey(),
  cell(key, t) {
    let cell = this.value[key];
    if (!cell) {
      cell = this.value[key] = this.newcell(key, t);
      this._adds[this._alen++] = cell;
    } else if (cell.num === 0 && this._drop && cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._adds[this._alen++] = cell;
    } else if (cell.stamp < this.stamp) {
      cell.stamp = this.stamp;
      this._mods[this._mlen++] = cell;
    }
    return cell;
  },
  newcell(key, t) {
    const cell = {
      key: key,
      num: 0,
      agg: null,
      tuple: this.newtuple(t, this._prev && this._prev[key]),
      stamp: this.stamp,
      store: false
    };
    if (!this._countOnly) {
      const measures = this._measures,
        n = measures.length;
      cell.agg = Array(n);
      for (let i = 0; i < n; ++i) {
        cell.agg[i] = new measures[i](cell);
      }
    }
    if (cell.store) {
      cell.data = new TupleStore();
    }
    return cell;
  },
  newtuple(t, p) {
    const names = this._dnames,
      dims = this._dims,
      n = dims.length,
      x = {};
    for (let i = 0; i < n; ++i) {
      x[names[i]] = dims[i](t);
    }
    return p ? (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.replace)(p.tuple, x) : (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(x);
  },
  clean() {
    const cells = this.value;
    for (const key in cells) {
      if (cells[key].num === 0) {
        delete cells[key];
      }
    }
  },
  // -- Process Tuples -----

  add(t) {
    const key = this.cellkey(t),
      cell = this.cell(key, t);
    cell.num += 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.add(t);
    const agg = cell.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].add(agg[i].get(t), t);
    }
  },
  rem(t) {
    const key = this.cellkey(t),
      cell = this.cell(key, t);
    cell.num -= 1;
    if (this._countOnly) return;
    if (cell.store) cell.data.rem(t);
    const agg = cell.agg;
    for (let i = 0, n = agg.length; i < n; ++i) {
      agg[i].rem(agg[i].get(t), t);
    }
  },
  celltuple(cell) {
    const tuple = cell.tuple,
      counts = this._counts;

    // consolidate stored values
    if (cell.store) {
      cell.data.values();
    }

    // update tuple properties
    for (let i = 0, n = counts.length; i < n; ++i) {
      tuple[counts[i]] = cell.num;
    }
    if (!this._countOnly) {
      const agg = cell.agg;
      for (let i = 0, n = agg.length; i < n; ++i) {
        agg[i].set(tuple);
      }
    }
    return tuple;
  },
  changes(out) {
    const adds = this._adds,
      mods = this._mods,
      prev = this._prev,
      drop = this._drop,
      add = out.add,
      rem = out.rem,
      mod = out.mod;
    let cell, key, i, n;
    if (prev) for (key in prev) {
      cell = prev[key];
      if (!drop || cell.num) rem.push(cell.tuple);
    }
    for (i = 0, n = this._alen; i < n; ++i) {
      add.push(this.celltuple(adds[i]));
      adds[i] = null; // for garbage collection
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      cell = mods[i];
      (cell.num === 0 && drop ? rem : mod).push(this.celltuple(cell));
      mods[i] = null; // for garbage collection
    }
    this._alen = this._mlen = 0; // reset list of active cells
    this._prev = null;
    return out;
  }
});

// epsilon bias to offset floating point error (#1737)
const EPSILON$1 = 1e-14;

/**
 * Generates a binning function for discretizing data.
 * @constructor
 * @param {object} params - The parameters for this operator. The
 *   provided values should be valid options for the {@link bin} function.
 * @param {function(object): *} params.field - The data field to bin.
 */
function Bin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Bin.Definition = {
  'type': 'Bin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'anchor',
    'type': 'number'
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 20
  }, {
    'name': 'base',
    'type': 'number',
    'default': 10
  }, {
    'name': 'divide',
    'type': 'number',
    'array': true,
    'default': [5, 2]
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2,
    'required': true
  }, {
    'name': 'span',
    'type': 'number'
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'steps',
    'type': 'number',
    'array': true
  }, {
    'name': 'minstep',
    'type': 'number',
    'default': 0
  }, {
    'name': 'nice',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'name',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['bin0', 'bin1']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Bin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const band = _.interval !== false,
      bins = this._bins(_),
      start = bins.start,
      step = bins.step,
      as = _.as || ['bin0', 'bin1'],
      b0 = as[0],
      b1 = as[1];
    let flag;
    if (_.modified()) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
    } else {
      flag = pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(_.field)) ? pulse.ADD_MOD : pulse.ADD;
    }
    pulse.visit(flag, band ? t => {
      const v = bins(t);
      // minimum bin value (inclusive)
      t[b0] = v;
      // maximum bin value (exclusive)
      // use convoluted math for better floating point agreement
      // see https://github.com/vega/vega/issues/830
      // infinite values propagate through this formula! #2227
      t[b1] = v == null ? null : start + step * (1 + (v - start) / step);
    } : t => t[b0] = bins(t));
    return pulse.modifies(band ? as : b0);
  },
  _bins(_) {
    if (this.value && !_.modified()) {
      return this.value;
    }
    const field = _.field,
      bins = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.bin)(_),
      step = bins.step;
    let start = bins.start,
      stop = start + Math.ceil((bins.stop - start) / step) * step,
      a,
      d;
    if ((a = _.anchor) != null) {
      d = a - (start + step * Math.floor((a - start) / step));
      start += d;
      stop += d;
    }
    const f = function (t) {
      let v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));
      return v == null ? null : v < start ? -Infinity : v > stop ? +Infinity : (v = Math.max(start, Math.min(v, stop - step)), start + step * Math.floor(EPSILON$1 + (v - start) / step));
    };
    f.start = start;
    f.stop = bins.stop;
    f.step = step;
    return this.value = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(f, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field), _.name || 'bin_' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field));
  }
});

function SortedList (idFunc, source, input) {
  const $ = idFunc;
  let data = source || [],
    add = input || [],
    rem = {},
    cnt = 0;
  return {
    add: t => add.push(t),
    remove: t => rem[$(t)] = ++cnt,
    size: () => data.length,
    data: (compare, resort) => {
      if (cnt) {
        data = data.filter(t => !rem[$(t)]);
        rem = {};
        cnt = 0;
      }
      if (resort && compare) {
        data.sort(compare);
      }
      if (add.length) {
        data = compare ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.merge)(compare, data, add.sort(compare)) : data.concat(add);
        add = [];
      }
      return data;
    }
  };
}

/**
 * Collects all data tuples that pass through this operator.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for additionally sorting the collected tuples.
 */
function Collect(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Collect.Definition = {
  'type': 'Collect',
  'metadata': {
    'source': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Collect, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
      list = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid, this.value, out.materialize(out.ADD).add),
      sort = _.sort,
      mod = pulse.changed() || sort && (_.modified('sort') || pulse.modified(sort.fields));
    out.visit(out.REM, list.remove);
    this.modified(mod);
    this.value = out.source = list.data((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(sort), mod);

    // propagate tree root if defined
    if (pulse.source && pulse.source.root) {
      this.value.root = pulse.source.root;
    }
    return out;
  }
});

/**
 * Generates a comparator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string|function>} params.fields - The fields to compare.
 * @param {Array<string>} [params.orders] - The sort orders.
 *   Each entry should be one of "ascending" (default) or "descending".
 */
function Compare(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$5, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Compare, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);
function update$5(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.compare)(_.fields, _.orders);
}

/**
 * Count regexp-defined pattern occurrences in a text field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the text field.
 * @param {string} [params.pattern] - RegExp string defining the text pattern.
 * @param {string} [params.case] - One of 'lower', 'upper' or null (mixed) case.
 * @param {string} [params.stopwords] - RegExp string of words to ignore.
 */
function CountPattern(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
CountPattern.Definition = {
  'type': 'CountPattern',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'case',
    'type': 'enum',
    'values': ['upper', 'lower', 'mixed'],
    'default': 'mixed'
  }, {
    'name': 'pattern',
    'type': 'string',
    'default': '[\\w"]+'
  }, {
    'name': 'stopwords',
    'type': 'string',
    'default': ''
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['text', 'count']
  }]
};
function tokenize(text, tcase, match) {
  switch (tcase) {
    case 'upper':
      text = text.toUpperCase();
      break;
    case 'lower':
      text = text.toLowerCase();
      break;
  }
  return text.match(match);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(CountPattern, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const process = update => tuple => {
      var tokens = tokenize(get(tuple), _.case, match) || [],
        t;
      for (var i = 0, n = tokens.length; i < n; ++i) {
        if (!stop.test(t = tokens[i])) update(t);
      }
    };
    const init = this._parameterCheck(_, pulse),
      counts = this._counts,
      match = this._match,
      stop = this._stop,
      get = _.field,
      as = _.as || ['text', 'count'],
      add = process(t => counts[t] = 1 + (counts[t] || 0)),
      rem = process(t => counts[t] -= 1);
    if (init) {
      pulse.visit(pulse.SOURCE, add);
    } else {
      pulse.visit(pulse.ADD, add);
      pulse.visit(pulse.REM, rem);
    }
    return this._finish(pulse, as); // generate output tuples
  },
  _parameterCheck(_, pulse) {
    let init = false;
    if (_.modified('stopwords') || !this._stop) {
      this._stop = new RegExp('^' + (_.stopwords || '') + '$', 'i');
      init = true;
    }
    if (_.modified('pattern') || !this._match) {
      this._match = new RegExp(_.pattern || '[\\w\']+', 'g');
      init = true;
    }
    if (_.modified('field') || pulse.modified(_.field.fields)) {
      init = true;
    }
    if (init) this._counts = {};
    return init;
  },
  _finish(pulse, as) {
    const counts = this._counts,
      tuples = this._tuples || (this._tuples = {}),
      text = as[0],
      count = as[1],
      out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    let w, t, c;
    for (w in counts) {
      t = tuples[w];
      c = counts[w] || 0;
      if (!t && c) {
        tuples[w] = t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({});
        t[text] = w;
        t[count] = c;
        out.add.push(t);
      } else if (c === 0) {
        if (t) out.rem.push(t);
        counts[w] = null;
        tuples[w] = null;
      } else if (t[count] !== c) {
        t[count] = c;
        out.mod.push(t);
      }
    }
    return out.modifies(as);
  }
});

/**
 * Perform a cross-product of a tuple stream with itself.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object):boolean} [params.filter] - An optional filter
 *   function for selectively including tuples in the cross product.
 * @param {Array<string>} [params.as] - The names of the output fields.
 */
function Cross(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Cross.Definition = {
  'type': 'Cross',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'filter',
    'type': 'expr'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['a', 'b']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Cross, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
      as = _.as || ['a', 'b'],
      a = as[0],
      b = as[1],
      reset = !this.value || pulse.changed(pulse.ADD_REM) || _.modified('as') || _.modified('filter');
    let data = this.value;
    if (reset) {
      if (data) out.rem = data;
      data = pulse.materialize(pulse.SOURCE).source;
      out.add = this.value = cross(data, a, b, _.filter || vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy);
    } else {
      out.mod = data;
    }
    out.source = this.value;
    return out.modifies(as);
  }
});
function cross(input, a, b, filter) {
  var data = [],
    t = {},
    n = input.length,
    i = 0,
    j,
    left;
  for (; i < n; ++i) {
    t[a] = left = input[i];
    for (j = 0; j < n; ++j) {
      t[b] = input[j];
      if (filter(t)) {
        data.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        t = {};
        t[a] = left;
      }
    }
  }
  return data;
}

const Distributions = {
  kde: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE,
  mixture: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomMixture,
  normal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomNormal,
  lognormal: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomLogNormal,
  uniform: vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomUniform
};
const DISTRIBUTIONS = 'distributions',
  FUNCTION = 'function',
  FIELD = 'field';

/**
 * Parse a parameter object for a probability distribution.
 * @param {object} def - The distribution parameter object.
 * @param {function():Array<object>} - A method for requesting
 *   source data. Used for distributions (such as KDE) that
 *   require sample data points. This method will only be
 *   invoked if the 'from' parameter for a target data source
 *   is not provided. Typically this method returns backing
 *   source data for a Pulse object.
 * @return {object} - The output distribution object.
 */
function parse(def, data) {
  const func = def[FUNCTION];
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(Distributions, func)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unknown distribution function: ' + func);
  }
  const d = Distributions[func]();
  for (const name in def) {
    // if data field, extract values
    if (name === FIELD) {
      d.data((def.from || data()).map(def[name]));
    }

    // if distribution mixture, recurse to parse each definition
    else if (name === DISTRIBUTIONS) {
      d[name](def[name].map(_ => parse(_, data)));
    }

    // otherwise, simply set the parameter
    else if (typeof d[name] === FUNCTION) {
      d[name](def[name]);
    }
  }
  return d;
}

/**
 * Grid sample points for a probability density. Given a distribution and
 * a sampling extent, will generate points suitable for plotting either
 * PDF (probability density function) or CDF (cumulative distribution
 * function) curves.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.distribution - The probability distribution. This
 *   is an object parameter dependent on the distribution type.
 * @param {string} [params.method='pdf'] - The distribution method to sample.
 *   One of 'pdf' or 'cdf'.
 * @param {Array<number>} [params.extent] - The [min, max] extent over which
 *   to sample the distribution. This argument is required in most cases, but
 *   can be omitted if the distribution (e.g., 'kde') supports a 'data' method
 *   that returns numerical sample points from which the extent can be deduced.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */
function Density(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const distributions = [{
  'key': {
    'function': 'normal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'lognormal'
  },
  'params': [{
    'name': 'mean',
    'type': 'number',
    'default': 0
  }, {
    'name': 'stdev',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'uniform'
  },
  'params': [{
    'name': 'min',
    'type': 'number',
    'default': 0
  }, {
    'name': 'max',
    'type': 'number',
    'default': 1
  }]
}, {
  'key': {
    'function': 'kde'
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'from',
    'type': 'data'
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }]
}];
const mixture = {
  'key': {
    'function': 'mixture'
  },
  'params': [{
    'name': 'distributions',
    'type': 'param',
    'array': true,
    'params': distributions
  }, {
    'name': 'weights',
    'type': 'number',
    'array': true
  }]
};
Density.Definition = {
  'type': 'Density',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'method',
    'type': 'string',
    'default': 'pdf',
    'values': ['pdf', 'cdf']
  }, {
    'name': 'distribution',
    'type': 'param',
    'params': distributions.concat(mixture)
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Density, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    if (!this.value || pulse.changed() || _.modified()) {
      const dist = parse(_.distribution, source(pulse)),
        minsteps = _.steps || _.minsteps || 25,
        maxsteps = _.steps || _.maxsteps || 200;
      let method = _.method || 'pdf';
      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }
      if (!_.extent && !dist.data) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing density extent parameter.');
      }
      method = dist[method];
      const as = _.as || ['value', 'density'],
        domain = _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(dist.data()),
        values = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(method, domain, minsteps, maxsteps).map(v => {
          const tuple = {};
          tuple[as[0]] = v[0];
          tuple[as[1]] = v[1];
          return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(tuple);
        });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }
    return out;
  }
});
function source(pulse) {
  return () => pulse.materialize(pulse.SOURCE).source;
}

// use either provided alias or accessor field name
function fieldNames(fields, as) {
  if (!fields) return null;
  return fields.map((f, i) => as[i] || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(f));
}
function partition$1(data, groupby, field) {
  const groups = [],
    get = f => f(t);
  let map, i, n, t, k, g;

  // partition data points into groups
  if (groupby == null) {
    groups.push(data.map(field));
  } else {
    for (map = {}, i = 0, n = data.length; i < n; ++i) {
      t = data[i];
      k = groupby.map(get);
      g = map[k];
      if (!g) {
        map[k] = g = [];
        g.dims = k;
        groups.push(g);
      }
      g.push(field(t));
    }
  }
  return groups;
}

const Output = 'bin';

/**
 * Dot density binning for dot plot construction.
 * Based on Leland Wilkinson, Dot Plots, The American Statistician, 1999.
 * https://www.cs.uic.edu/~wilkinson/Publications/dotplots.pdf
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to bin.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors to groupby.
 * @param {number} [params.step] - The step size (bin width) within which dots should be
 *   stacked. Defaults to 1/30 of the extent of the data *field*.
 * @param {boolean} [params.smooth=false] - A boolean flag indicating if dot density
 *   stacks should be smoothed to reduce variance.
 */
function DotBin(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
DotBin.Definition = {
  'type': 'DotBin',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'step',
    'type': 'number'
  }, {
    'name': 'smooth',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'as',
    'type': 'string',
    'default': Output
  }]
};
const autostep = (data, field) => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.span)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(data, field)) / 30;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(DotBin, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !(_.modified() || pulse.changed())) {
      return pulse; // early exit
    }
    const source = pulse.materialize(pulse.SOURCE).source,
      groups = partition$1(pulse.source, _.groupby, vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
      smooth = _.smooth || false,
      field = _.field,
      step = _.step || autostep(source, field),
      sort = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)((a, b) => field(a) - field(b)),
      as = _.as || Output,
      n = groups.length;

    // compute dotplot bins per group
    let min = Infinity,
      max = -Infinity,
      i = 0,
      j;
    for (; i < n; ++i) {
      const g = groups[i].sort(sort);
      j = -1;
      for (const v of (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.dotbin)(g, step, smooth, field)) {
        if (v < min) min = v;
        if (v > max) max = v;
        g[++j][as] = v;
      }
    }
    this.value = {
      start: min,
      stop: max,
      step: step
    };
    return pulse.reflow(true).modifies(as);
  }
});

/**
 * Wraps an expression function with access to external parameters.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function} params.expr - The expression function. The
 *  function should accept both a datum and a parameter object.
 *  This operator's value will be a new function that wraps the
 *  expression function with access to this operator's parameters.
 */
function Expression(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$4, params);
  this.modified(true);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Expression, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);
function update$4(_) {
  const expr = _.expr;
  return this.value && !_.modified('expr') ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(datum => expr(datum, _), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(expr), (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(expr));
}

/**
 * Computes extents (min/max) for a data field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field over which to compute extends.
 */
function Extent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [undefined, undefined], params);
}
Extent.Definition = {
  'type': 'Extent',
  'metadata': {},
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Extent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const extent = this.value,
      field = _.field,
      mod = pulse.changed() || pulse.modified(field.fields) || _.modified('field');
    let min = extent[0],
      max = extent[1];
    if (mod || min == null) {
      min = +Infinity;
      max = -Infinity;
    }
    pulse.visit(mod ? pulse.SOURCE : pulse.ADD, t => {
      const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber)(field(t));
      if (v != null) {
        // NaNs will fail all comparisons!
        if (v < min) min = v;
        if (v > max) max = v;
      }
    });
    if (!Number.isFinite(min) || !Number.isFinite(max)) {
      let name = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field);
      if (name) name = ` for field "${name}"`;
      pulse.dataflow.warn(`Infinite extent${name}: [${min}, ${max}]`);
      min = max = undefined;
    }
    this.value = [min, max];
  }
});

/**
 * Provides a bridge between a parent transform and a target subflow that
 * consumes only a subset of the tuples that pass through the parent.
 * @constructor
 * @param {Pulse} pulse - A pulse to use as the value of this operator.
 * @param {Transform} parent - The parent transform (typically a Facet instance).
 */
function Subflow(pulse, parent) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, pulse);
  this.parent = parent;
  this.count = 0;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Subflow, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator, {
  /**
   * Routes pulses from this subflow to a target transform.
   * @param {Transform} target - A transform that receives the subflow of tuples.
   */
  connect(target) {
    this.detachSubflow = target.detachSubflow;
    this.targets().add(target);
    return target.source = this;
  },
  /**
   * Add an 'add' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being added.
   */
  add(t) {
    this.count += 1;
    this.value.add.push(t);
  },
  /**
   * Add a 'rem' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being removed.
   */
  rem(t) {
    this.count -= 1;
    this.value.rem.push(t);
  },
  /**
   * Add a 'mod' tuple to the subflow pulse.
   * @param {Tuple} t - The tuple being modified.
   */
  mod(t) {
    this.value.mod.push(t);
  },
  /**
   * Re-initialize this operator's pulse value.
   * @param {Pulse} pulse - The pulse to copy from.
   * @see Pulse.init
   */
  init(pulse) {
    this.value.init(pulse, pulse.NO_SOURCE);
  },
  /**
   * Evaluate this operator. This method overrides the
   * default behavior to simply return the contained pulse value.
   * @return {Pulse}
   */
  evaluate() {
    // assert: this.value.stamp === pulse.stamp
    return this.value;
  }
});

/**
 * Facets a dataflow into a set of subflows based on a key.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): *} params.key - The key field to facet by.
 */
function Facet(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._keys = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(); // cache previously calculated key values

  // keep track of active subflows, use as targets array for listeners
  // this allows us to limit propagation to only updated subflows
  const a = this._targets = [];
  a.active = 0;
  a.forEach = f => {
    for (let i = 0, n = a.active; i < n; ++i) {
      f(a[i], i, a);
    }
  };
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Facet, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  activate(flow) {
    this._targets[this._targets.active++] = flow;
  },
  // parent argument provided by PreFacet subclass
  subflow(key, flow, pulse, parent) {
    const flows = this.value;
    let sf = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(flows, key) && flows[key],
      df,
      p;
    if (!sf) {
      p = parent || (p = this._group[key]) && p.tuple;
      df = pulse.dataflow;
      sf = new Subflow(pulse.fork(pulse.NO_SOURCE), this);
      df.add(sf).connect(flow(df, key, p));
      flows[key] = sf;
      this.activate(sf);
    } else if (sf.value.stamp < pulse.stamp) {
      sf.init(pulse);
      this.activate(sf);
    }
    return sf;
  },
  clean() {
    const flows = this.value;
    let detached = 0;
    for (const key in flows) {
      if (flows[key].count === 0) {
        const detach = flows[key].detachSubflow;
        if (detach) detach();
        delete flows[key];
        ++detached;
      }
    }

    // remove inactive targets from the active targets array
    if (detached) {
      const active = this._targets.filter(sf => sf && sf.count > 0);
      this.initTargets(active);
    }
  },
  initTargets(act) {
    const a = this._targets,
      n = a.length,
      m = act ? act.length : 0;
    let i = 0;
    for (; i < m; ++i) {
      a[i] = act[i];
    }
    for (; i < n && a[i] != null; ++i) {
      a[i] = null; // ensure old flows can be garbage collected
    }
    a.active = m;
  },
  transform(_, pulse) {
    const df = pulse.dataflow,
      key = _.key,
      flow = _.subflow,
      cache = this._keys,
      rekey = _.modified('key'),
      subflow = key => this.subflow(key, flow, pulse);
    this._group = _.group || {};
    this.initTargets(); // reset list of active subflows

    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
        k = cache.get(id);
      if (k !== undefined) {
        cache.delete(id);
        subflow(k).rem(t);
      }
    });
    pulse.visit(pulse.ADD, t => {
      const k = key(t);
      cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), k);
      subflow(k).add(t);
    });
    if (rekey || pulse.modified(key.fields)) {
      pulse.visit(pulse.MOD, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
          k0 = cache.get(id),
          k1 = key(t);
        if (k0 === k1) {
          subflow(k1).mod(t);
        } else {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    } else if (pulse.changed(pulse.MOD)) {
      pulse.visit(pulse.MOD, t => {
        subflow(cache.get((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t))).mod(t);
      });
    }
    if (rekey) {
      pulse.visit(pulse.REFLOW, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
          k0 = cache.get(id),
          k1 = key(t);
        if (k0 !== k1) {
          cache.set(id, k1);
          subflow(k0).rem(t);
          subflow(k1).add(t);
        }
      });
    }
    if (pulse.clean()) {
      df.runAfter(() => {
        this.clean();
        cache.clean();
      });
    } else if (cache.empty > df.cleanThreshold) {
      df.runAfter(cache.clean);
    }
    return pulse;
  }
});

/**
 * Generates one or more field accessor functions.
 * If the 'name' parameter is an array, an array of field accessors
 * will be created and the 'as' parameter will be ignored.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.name - The field name(s) to access.
 * @param {string} params.as - The accessor function name.
 */
function Field(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$3, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Field, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);
function update$3(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(_.name) ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.name).map(f => (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(f)) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.field)(_.name, _.as);
}

/**
 * Filters data tuples according to a predicate function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The predicate expression function
 *   that determines a tuple's filter status. Truthy values pass the filter.
 */
function Filter(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
Filter.Definition = {
  'type': 'Filter',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Filter, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
      cache = this.value,
      // cache ids of filtered tuples
      output = pulse.fork(),
      add = output.add,
      rem = output.rem,
      mod = output.mod,
      test = _.expr;
    let isMod = true;
    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      if (!cache.has(id)) rem.push(t);else cache.delete(id);
    });
    pulse.visit(pulse.ADD, t => {
      if (test(t, _)) add.push(t);else cache.set((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), 1);
    });
    function revisit(t) {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t),
        b = test(t, _),
        s = cache.get(id);
      if (b && s) {
        cache.delete(id);
        add.push(t);
      } else if (!b && !s) {
        cache.set(id, 1);
        rem.push(t);
      } else if (isMod && b && !s) {
        mod.push(t);
      }
    }
    pulse.visit(pulse.MOD, revisit);
    if (_.modified()) {
      isMod = false;
      pulse.visit(pulse.REFLOW, revisit);
    }
    if (cache.empty > df.cleanThreshold) df.runAfter(cache.clean);
    return output;
  }
});

/**
 * Flattens array-typed field values into new data objects.
 * If multiple fields are specified, they are treated as parallel arrays,
 * with output values included for each matching index (or null if missing).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} params.fields - An array of field
 *   accessors for the tuple fields that should be flattened.
 * @param {string} [params.index] - Optional output field name for index
 *   value. If unspecified, no index field is included in the output.
 * @param {Array<string>} [params.as] - Output field names for flattened
 *   array fields. Any unspecified fields will use the field name provided
 *   by the fields accessors.
 */
function Flatten(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Flatten.Definition = {
  'type': 'Flatten',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'index',
    'type': 'string'
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Flatten, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
      fields = _.fields,
      as = fieldNames(fields, _.as || []),
      index = _.index || null,
      m = as.length;

    // remove any previous results
    out.rem = this.value;

    // generate flattened tuples
    pulse.visit(pulse.SOURCE, t => {
      const arrays = fields.map(f => f(t)),
        maxlen = arrays.reduce((l, a) => Math.max(l, a.length), 0);
      let i = 0,
        j,
        d,
        v;
      for (; i < maxlen; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        for (j = 0; j < m; ++j) {
          d[as[j]] = (v = arrays[j][i]) == null ? null : v;
        }
        if (index) {
          d[index] = i;
        }
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    if (index) out.modifies(index);
    return out.modifies(as);
  }
});

/**
 * Folds one more tuple fields into multiple tuples in which the field
 * name and values are available under new 'key' and 'value' fields.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.fields - An array of field accessors
 *   for the tuple fields that should be folded.
 * @param {Array<string>} [params.as] - Output field names for folded key
 *   and value fields, defaults to ['key', 'value'].
 */
function Fold(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Fold.Definition = {
  'type': 'Fold',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': ['key', 'value']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Fold, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
      fields = _.fields,
      fnames = fields.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
      as = _.as || ['key', 'value'],
      k = as[0],
      v = as[1],
      n = fields.length;
    out.rem = this.value;
    pulse.visit(pulse.SOURCE, t => {
      for (let i = 0, d; i < n; ++i) {
        d = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        d[k] = fnames[i];
        d[v] = fields[i](t);
        out.add.push(d);
      }
    });
    this.value = out.source = out.add;
    return out.modifies(as);
  }
});

/**
 * Invokes a function for each data tuple and saves the results as a new field.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.expr - The formula function to invoke for each tuple.
 * @param {string} params.as - The field name under which to save the result.
 * @param {boolean} [params.initonly=false] - If true, the formula is applied to
 *   added tuples only, and does not update in response to modifications.
 */
function Formula(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Formula.Definition = {
  'type': 'Formula',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'expr',
    'type': 'expr',
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'required': true
  }, {
    'name': 'initonly',
    'type': 'boolean'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Formula, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const func = _.expr,
      as = _.as,
      mod = _.modified(),
      flag = _.initonly ? pulse.ADD : mod ? pulse.SOURCE : pulse.modified(func.fields) || pulse.modified(as) ? pulse.ADD_MOD : pulse.ADD;
    if (mod) {
      // parameters updated, need to reflow
      pulse = pulse.materialize().reflow(true);
    }
    if (!_.initonly) {
      pulse.modifies(as);
    }
    return pulse.visit(flag, t => t[as] = func(t, _));
  }
});

/**
 * Generates data tuples using a provided generator function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Parameters): object} params.generator - A tuple generator
 *   function. This function is given the operator parameters as input.
 *   Changes to any additional parameters will not trigger re-calculation
 *   of previously generated tuples. Only future tuples are affected.
 * @param {number} params.size - The number of tuples to produce.
 */
function Generate(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Generate, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.ALL),
      gen = _.generator;
    let data = this.value,
      num = _.size - data.length,
      add,
      rem,
      t;
    if (num > 0) {
      // need more tuples, generate and add
      for (add = []; --num >= 0;) {
        add.push(t = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(gen(_)));
        data.push(t);
      }
      out.add = out.add.length ? out.materialize(out.ADD).add.concat(add) : add;
    } else {
      // need fewer tuples, remove
      rem = data.slice(0, -num);
      out.rem = out.rem.length ? out.materialize(out.REM).rem.concat(rem) : rem;
      data = data.slice(-num);
    }
    out.source = this.value = data;
    return out;
  }
});

const Methods = {
  value: 'value',
  median: d3_array__WEBPACK_IMPORTED_MODULE_4__["default"],
  mean: d3_array__WEBPACK_IMPORTED_MODULE_5__["default"],
  min: d3_array__WEBPACK_IMPORTED_MODULE_6__["default"],
  max: d3_array__WEBPACK_IMPORTED_MODULE_7__["default"]
};
const Empty = [];

/**
 * Impute missing values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The value field to impute.
 * @param {Array<function(object): *>} [params.groupby] - An array of
 *   accessors to determine series within which to perform imputation.
 * @param {function(object): *} params.key - An accessor for a key value.
 *   Each key value should be unique within a group. New tuples will be
 *   imputed for any key values that are not found within a group.
 * @param {Array<*>} [params.keyvals] - Optional array of required key
 *   values. New tuples will be imputed for any key values that are not
 *   found within a group. In addition, these values will be automatically
 *   augmented with the key values observed in the input data.
 * @param {string} [method='value'] - The imputation method to use. One of
 *   'value', 'mean', 'median', 'max', 'min'.
 * @param {*} [value=0] - The constant value to use for imputation
 *   when using method 'value'.
 */
function Impute(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
}
Impute.Definition = {
  'type': 'Impute',
  'metadata': {
    'changes': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'key',
    'type': 'field',
    'required': true
  }, {
    'name': 'keyvals',
    'array': true
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'method',
    'type': 'enum',
    'default': 'value',
    'values': ['value', 'mean', 'median', 'max', 'min']
  }, {
    'name': 'value',
    'default': 0
  }]
};
function getValue(_) {
  var m = _.method || Methods.value,
    v;
  if (Methods[m] == null) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized imputation method: ' + m);
  } else if (m === Methods.value) {
    v = _.value !== undefined ? _.value : 0;
    return () => v;
  } else {
    return Methods[m];
  }
}
function getField(_) {
  const f = _.field;
  return t => t ? f(t) : NaN;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Impute, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    var out = pulse.fork(pulse.ALL),
      impute = getValue(_),
      field = getField(_),
      fName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.field),
      kName = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(_.key),
      gNames = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
      groups = partition(pulse.source, _.groupby, _.key, _.keyvals),
      curr = [],
      prev = this.value,
      m = groups.domain.length,
      group,
      value,
      gVals,
      kVal,
      g,
      i,
      j,
      l,
      n,
      t;
    for (g = 0, l = groups.length; g < l; ++g) {
      group = groups[g];
      gVals = group.values;
      value = NaN;

      // add tuples for missing values
      for (j = 0; j < m; ++j) {
        if (group[j] != null) continue;
        kVal = groups.domain[j];
        t = {
          _impute: true
        };
        for (i = 0, n = gVals.length; i < n; ++i) t[gNames[i]] = gVals[i];
        t[kName] = kVal;
        t[fName] = Number.isNaN(value) ? value = impute(group, field) : value;
        curr.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    }

    // update pulse with imputed tuples
    if (curr.length) out.add = out.materialize(out.ADD).add.concat(curr);
    if (prev.length) out.rem = out.materialize(out.REM).rem.concat(prev);
    this.value = curr;
    return out;
  }
});
function partition(data, groupby, key, keyvals) {
  var get = f => f(t),
    groups = [],
    domain = keyvals ? keyvals.slice() : [],
    kMap = {},
    gMap = {},
    gVals,
    gKey,
    group,
    i,
    j,
    k,
    n,
    t;
  domain.forEach((k, i) => kMap[k] = i + 1);
  for (i = 0, n = data.length; i < n; ++i) {
    t = data[i];
    k = key(t);
    j = kMap[k] || (kMap[k] = domain.push(k));
    gKey = (gVals = groupby ? groupby.map(get) : Empty) + '';
    if (!(group = gMap[gKey])) {
      group = gMap[gKey] = [];
      groups.push(group);
      group.values = gVals;
    }
    group[j - 1] = t;
  }
  groups.domain = domain;
  return groups;
}

/**
 * Extend input tuples with aggregate values.
 * Calcuates aggregate values and joins them with the input stream.
 * @constructor
 */
function JoinAggregate(params) {
  Aggregate.call(this, params);
}
JoinAggregate.Definition = {
  'type': 'JoinAggregate',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidAggregateOps
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(JoinAggregate, Aggregate, {
  transform(_, pulse) {
    const aggr = this,
      mod = _.modified();
    let cells;

    // process all input tuples to calculate aggregates
    if (aggr.value && (mod || pulse.modified(aggr._inputs, true))) {
      cells = aggr.value = mod ? aggr.init(_) : {};
      pulse.visit(pulse.SOURCE, t => aggr.add(t));
    } else {
      cells = aggr.value = aggr.value || this.init(_);
      pulse.visit(pulse.REM, t => aggr.rem(t));
      pulse.visit(pulse.ADD, t => aggr.add(t));
    }

    // update aggregation cells
    aggr.changes();

    // write aggregate values to input tuples
    pulse.visit(pulse.SOURCE, t => {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(t, cells[aggr.cellkey(t)].tuple);
    });
    return pulse.reflow(mod).modifies(this._outputs);
  },
  changes() {
    const adds = this._adds,
      mods = this._mods;
    let i, n;
    for (i = 0, n = this._alen; i < n; ++i) {
      this.celltuple(adds[i]);
      adds[i] = null; // for garbage collection
    }
    for (i = 0, n = this._mlen; i < n; ++i) {
      this.celltuple(mods[i]);
      mods[i] = null; // for garbage collection
    }
    this._alen = this._mlen = 0; // reset list of active cells
  }
});

/**
 * Compute kernel density estimates (KDE) for one or more data groups.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {function(object): *} params.field - An accessor for the data field
 *   to estimate.
 * @param {number} [params.bandwidth=0] - The KDE kernel bandwidth.
 *   If zero or unspecified, the bandwidth is automatically determined.
 * @param {boolean} [params.counts=false] - A boolean flag indicating if the
 *   output values should be probability estimates (false, default) or
 *   smoothed counts (true).
 * @param {string} [params.cumulative=false] - A boolean flag indicating if a
 *   density (false) or cumulative distribution (true) should be generated.
 * @param {Array<number>} [params.extent] - The domain extent over which to
 *   plot the density. If unspecified, the [min, max] data extent is used.
 * @param {string} [params.resolve='independent'] - Indicates how parameters for
 *   multiple densities should be resolved. If "independent" (the default), each
 *   density may have its own domain extent and dynamic number of curve sample
 *   steps. If "shared", the KDE transform will ensure that all densities are
 *   defined over a shared domain and curve steps, enabling stacking.
 * @param {number} [params.minsteps=25] - The minimum number of curve samples
 *   for plotting the density.
 * @param {number} [params.maxsteps=200] - The maximum number of curve samples
 *   for plotting the density.
 * @param {number} [params.steps] - The exact number of curve samples for
 *   plotting the density. If specified, overrides both minsteps and maxsteps
 *   to set an exact number of uniform samples. Useful in conjunction with
 *   a fixed extent to ensure consistent sample points for stacked densities.
 */
function KDE(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
KDE.Definition = {
  'type': 'KDE',
  'metadata': {
    'generates': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'cumulative',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'counts',
    'type': 'boolean',
    'default': false
  }, {
    'name': 'bandwidth',
    'type': 'number',
    'default': 0
  }, {
    'name': 'extent',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'resolve',
    'type': 'enum',
    'values': ['shared', 'independent'],
    'default': 'independent'
  }, {
    'name': 'steps',
    'type': 'number'
  }, {
    'name': 'minsteps',
    'type': 'number',
    'default': 25
  }, {
    'name': 'maxsteps',
    'type': 'number',
    'default': 200
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['value', 'density']
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(KDE, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS);
    if (!this.value || pulse.changed() || _.modified()) {
      const source = pulse.materialize(pulse.SOURCE).source,
        groups = partition$1(source, _.groupby, _.field),
        names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
        bandwidth = _.bandwidth,
        method = _.cumulative ? 'cdf' : 'pdf',
        as = _.as || ['value', 'density'],
        values = [];
      let domain = _.extent,
        minsteps = _.steps || _.minsteps || 25,
        maxsteps = _.steps || _.maxsteps || 200;
      if (method !== 'pdf' && method !== 'cdf') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Invalid density method: ' + method);
      }
      if (_.resolve === 'shared') {
        if (!domain) domain = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(source, _.field);
        minsteps = maxsteps = _.steps || maxsteps;
      }
      groups.forEach(g => {
        const density = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.randomKDE)(g, bandwidth)[method],
          scale = _.counts ? g.length : 1,
          local = domain || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(g);
        (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.sampleCurve)(density, local, minsteps, maxsteps).forEach(v => {
          const t = {};
          for (let i = 0; i < names.length; ++i) {
            t[names[i]] = g.dims[i];
          }
          t[as[0]] = v[0];
          t[as[1]] = v[1] * scale;
          values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
        });
      });
      if (this.value) out.rem = this.value;
      this.value = out.add = out.source = values;
    }
    return out;
  }
});

/**
 * Generates a key function.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<string>} params.fields - The field name(s) for the key function.
 * @param {boolean} params.flat - A boolean flag indicating if the field names
 *  should be treated as flat property names, side-stepping nested field
 *  lookups normally indicated by dot or bracket notation.
 */
function Key(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$2, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Key, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);
function update$2(_) {
  return this.value && !_.modified() ? this.value : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.key)(_.fields, _.flat);
}

/**
 * Load and parse data from an external source. Marshalls parameter
 * values and then invokes the Dataflow request method.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.url - The URL to load from.
 * @param {object} params.format - The data format options.
 */
function Load(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this._pending = null;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Load, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow;
    if (this._pending) {
      // update state and return pulse
      return output(this, pulse, this._pending);
    }
    if (stop(_)) return pulse.StopPropagation;
    if (_.values) {
      // parse and ingest values, return output pulse
      return output(this, pulse, df.parse(_.values, _.format));
    } else if (_.async) {
      // return promise for non-blocking async loading
      const p = df.request(_.url, _.format).then(res => {
        this._pending = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data);
        return df => df.touch(this);
      });
      return {
        async: p
      };
    } else {
      // return promise for synchronous loading
      return df.request(_.url, _.format).then(res => output(this, pulse, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(res.data)));
    }
  }
});
function stop(_) {
  return _.modified('async') && !(_.modified('values') || _.modified('url') || _.modified('format'));
}
function output(op, pulse, data) {
  data.forEach(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest);
  const out = pulse.fork(pulse.NO_FIELDS & pulse.NO_SOURCE);
  out.rem = op.value;
  op.value = out.source = out.add = data;
  op._pending = null;
  if (out.rem.length) out.clean(true);
  return out;
}

/**
 * Extend tuples by joining them with values from a lookup table.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Map} params.index - The lookup table map.
 * @param {Array<function(object): *} params.fields - The fields to lookup.
 * @param {Array<string>} params.as - Output field names for each lookup value.
 * @param {*} [params.default] - A default value to use if lookup fails.
 */
function Lookup(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
}
Lookup.Definition = {
  'type': 'Lookup',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'index',
    'type': 'index',
    'params': [{
      'name': 'from',
      'type': 'data',
      'required': true
    }, {
      'name': 'key',
      'type': 'field',
      'required': true
    }]
  }, {
    'name': 'values',
    'type': 'field',
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'array': true,
    'required': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true
  }, {
    'name': 'default',
    'default': null
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Lookup, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const keys = _.fields,
      index = _.index,
      values = _.values,
      defaultValue = _.default == null ? null : _.default,
      reset = _.modified(),
      n = keys.length;
    let flag = reset ? pulse.SOURCE : pulse.ADD,
      out = pulse,
      as = _.as,
      set,
      m,
      mods;
    if (values) {
      m = values.length;
      if (n > 1 && !as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Multi-field lookup requires explicit "as" parameter.');
      }
      if (as && as.length !== n * m) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('The "as" parameter has too few output field names.');
      }
      as = as || values.map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName);
      set = function (t) {
        for (var i = 0, k = 0, j, v; i < n; ++i) {
          v = index.get(keys[i](t));
          if (v == null) for (j = 0; j < m; ++j, ++k) t[as[k]] = defaultValue;else for (j = 0; j < m; ++j, ++k) t[as[k]] = values[j](v);
        }
      };
    } else {
      if (!as) {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Missing output field names.');
      }
      set = function (t) {
        for (var i = 0, v; i < n; ++i) {
          v = index.get(keys[i](t));
          t[as[i]] = v == null ? defaultValue : v;
        }
      };
    }
    if (reset) {
      out = pulse.reflow(true);
    } else {
      mods = keys.some(k => pulse.modified(k.fields));
      flag |= mods ? pulse.MOD : 0;
    }
    pulse.visit(flag, set);
    return out.modifies(as);
  }
});

/**
 * Computes global min/max extents over a collection of extents.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<number>>} params.extents - The input extents.
 */
function MultiExtent(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update$1, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiExtent, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);
function update$1(_) {
  if (this.value && !_.modified()) {
    return this.value;
  }
  const ext = _.extents,
    n = ext.length;
  let min = +Infinity,
    max = -Infinity,
    i,
    e;
  for (i = 0; i < n; ++i) {
    e = ext[i];
    if (e[0] < min) min = e[0];
    if (e[1] > max) max = e[1];
  }
  return [min, max];
}

/**
 * Merge a collection of value arrays.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<Array<*>>} params.values - The input value arrrays.
 */
function MultiValues(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator.call(this, null, update, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(MultiValues, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator);
function update(_) {
  return this.value && !_.modified() ? this.value : _.values.reduce((data, _) => data.concat(_), []);
}

/**
 * Operator whose value is simply its parameter hash. This operator is
 * useful for enabling reactive updates to values of nested objects.
 * @constructor
 * @param {object} params - The parameters for this operator.
 */
function Params(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Params, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.modified(_.modified());
    this.value = _;
    return pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS); // do not pass tuples
  }
});

/**
 * Aggregate and pivot selected field values to become new fields.
 * This operator is useful to construction cross-tabulations.
 * @constructor
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *  to groupby. These fields act just like groupby fields of an Aggregate transform.
 * @param {function(object): *} params.field - The field to pivot on. The unique
 *  values of this field become new field names in the output stream.
 * @param {function(object): *} params.value - The field to populate pivoted fields.
 *  The aggregate values of this field become the values of the new pivoted fields.
 * @param {string} [params.op] - The aggregation operation for the value field,
 *  applied per cell in the output stream. The default is "sum".
 * @param {number} [params.limit] - An optional parameter indicating the maximum
 *  number of pivoted fields to generate. The pivoted field names are sorted in
 *  ascending order prior to enforcing the limit.
 */
function Pivot(params) {
  Aggregate.call(this, params);
}
Pivot.Definition = {
  'type': 'Pivot',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'value',
    'type': 'field',
    'required': true
  }, {
    'name': 'op',
    'type': 'enum',
    'values': ValidAggregateOps,
    'default': 'sum'
  }, {
    'name': 'limit',
    'type': 'number',
    'default': 0
  }, {
    'name': 'key',
    'type': 'field'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Pivot, Aggregate, {
  _transform: Aggregate.prototype.transform,
  transform(_, pulse) {
    return this._transform(aggregateParams(_, pulse), pulse);
  }
});

// Shoehorn a pivot transform into an aggregate transform!
// First collect all unique pivot field values.
// Then generate aggregate fields for each output pivot field.
function aggregateParams(_, pulse) {
  const key = _.field,
    value = _.value,
    op = (_.op === 'count' ? '__count__' : _.op) || 'sum',
    fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(key).concat((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(value)),
    keys = pivotKeys(key, _.limit || 0, pulse);

  // if data stream content changes, pivot fields may change
  // flag parameter modification to ensure re-initialization
  if (pulse.changed()) _.set('__pivot__', null, null, true);
  return {
    key: _.key,
    groupby: _.groupby,
    ops: keys.map(() => op),
    fields: keys.map(k => get(k, key, value, fields)),
    as: keys.map(k => k + ''),
    modified: _.modified.bind(_)
  };
}

// Generate aggregate field accessor.
// Output NaN for non-existent values; aggregator will ignore!
function get(k, key, value, fields) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor)(d => key(d) === k ? value(d) : NaN, fields, k + '');
}

// Collect (and optionally limit) all unique pivot values.
function pivotKeys(key, limit, pulse) {
  const map = {},
    list = [];
  pulse.visit(pulse.SOURCE, t => {
    const k = key(t);
    if (!map[k]) {
      map[k] = 1;
      list.push(k);
    }
  });
  list.sort(vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending);
  return limit ? list.slice(0, limit) : list;
}

/**
 * Partitions pre-faceted data into tuple subflows.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(Dataflow, string): Operator} params.subflow - A function
 *   that generates a subflow of operators and returns its root operator.
 * @param {function(object): Array<object>} params.field - The field
 *   accessor for an array of subflow tuple objects.
 */
function PreFacet(params) {
  Facet.call(this, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(PreFacet, Facet, {
  transform(_, pulse) {
    const flow = _.subflow,
      field = _.field,
      subflow = t => this.subflow((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t), flow, pulse, t);
    if (_.modified('field') || field && pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('PreFacet does not support field modification.');
    }
    this.initTargets(); // reset list of active subflows

    if (field) {
      pulse.visit(pulse.MOD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.mod(_));
      });
      pulse.visit(pulse.ADD, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.add((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(_)));
      });
      pulse.visit(pulse.REM, t => {
        const sf = subflow(t);
        field(t).forEach(_ => sf.rem(_));
      });
    } else {
      pulse.visit(pulse.MOD, t => subflow(t).mod(t));
      pulse.visit(pulse.ADD, t => subflow(t).add(t));
      pulse.visit(pulse.REM, t => subflow(t).rem(t));
    }
    if (pulse.clean()) {
      pulse.runAfter(() => this.clean());
    }
    return pulse;
  }
});

/**
 * Performs a relational projection, copying selected fields from source
 * tuples to a new set of derived tuples.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {Array<function(object): *} params.fields - The fields to project,
 *   as an array of field accessors. If unspecified, all fields will be
 *   copied with names unchanged.
 * @param {Array<string>} [params.as] - Output field names for each projected
 *   field. Any unspecified fields will use the field name provided by
 *   the field accessor.
 */
function Project(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Project.Definition = {
  'type': 'Project',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'fields',
    'type': 'field',
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Project, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
      fields = _.fields,
      as = fieldNames(_.fields, _.as || []),
      derive = fields ? (s, t) => project(s, t, fields, as) : vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.rederive;
    let lut;
    if (this.value) {
      lut = this.value;
    } else {
      pulse = pulse.addAll();
      lut = this.value = {};
    }
    pulse.visit(pulse.REM, t => {
      const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
      out.rem.push(lut[id]);
      lut[id] = null;
    });
    pulse.visit(pulse.ADD, t => {
      const dt = derive(t, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)({}));
      lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
      out.add.push(dt);
    });
    pulse.visit(pulse.MOD, t => {
      out.mod.push(derive(t, lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]));
    });
    return out;
  }
});
function project(s, t, fields, as) {
  for (let i = 0, n = fields.length; i < n; ++i) {
    t[as[i]] = fields[i](s);
  }
  return t;
}

/**
 * Proxy the value of another operator as a pure signal value.
 * Ensures no tuples are propagated.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {*} params.value - The value to proxy, becomes the value of this operator.
 */
function Proxy(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Proxy, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = _.value;
    return _.modified('value') ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }
});

/**
 * Generates sample quantile values from an input data stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - An accessor for the data field
 *   over which to calculate quantile values.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors
 *   to groupby.
 * @param {Array<number>} [params.probs] - An array of probabilities in
 *   the range (0, 1) for which to compute quantile values. If not specified,
 *   the *step* parameter will be used.
 * @param {Array<number>} [params.step=0.01] - A probability step size for
 *   sampling quantile values. All values from one-half the step size up to
 *   1 (exclusive) will be sampled. This parameter is only used if the
 *   *quantiles* parameter is not provided.
 */
function Quantile(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Quantile.Definition = {
  'type': 'Quantile',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'probs',
    'type': 'number',
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 0.01
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'default': ['prob', 'value']
  }]
};
const EPSILON = 1e-14;
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Quantile, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS),
      as = _.as || ['prob', 'value'];
    if (this.value && !_.modified() && !pulse.changed()) {
      out.source = this.value;
      return out;
    }
    const source = pulse.materialize(pulse.SOURCE).source,
      groups = partition$1(source, _.groupby, _.field),
      names = (_.groupby || []).map(vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
      values = [],
      step = _.step || 0.01,
      p = _.probs || (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(step / 2, 1 - EPSILON, step),
      n = p.length;
    groups.forEach(g => {
      const q = (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.quantiles)(g, p);
      for (let i = 0; i < n; ++i) {
        const t = {};
        for (let i = 0; i < names.length; ++i) {
          t[names[i]] = g.dims[i];
        }
        t[as[0]] = p[i];
        t[as[1]] = q[i];
        values.push((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t));
      }
    });
    if (this.value) out.rem = this.value;
    this.value = out.add = out.source = values;
    return out;
  }
});

/**
 * Relays a data stream between data processing pipelines.
 * If the derive parameter is set, this transform will create derived
 * copies of observed tuples. This provides derived data streams in which
 * modifications to the tuples do not pollute an upstream data source.
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.derive=false] - Boolean flag indicating if
 *   the transform should make derived copies of incoming tuples.
 * @constructor
 */
function Relay(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Relay, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    let out, lut;
    if (this.value) {
      lut = this.value;
    } else {
      out = pulse = pulse.addAll();
      lut = this.value = {};
    }
    if (_.derive) {
      out = pulse.fork(pulse.NO_SOURCE);
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
        out.rem.push(lut[id]);
        lut[id] = null;
      });
      pulse.visit(pulse.ADD, t => {
        const dt = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.derive)(t);
        lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = dt;
        out.add.push(dt);
      });
      pulse.visit(pulse.MOD, t => {
        const dt = lut[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)];
        for (const k in t) {
          dt[k] = t[k];
          // down stream writes may overwrite re-derived tuples
          // conservatively mark all source fields as modified
          out.modifies(k);
        }
        out.mod.push(dt);
      });
    }
    return out;
  }
});

/**
 * Samples tuples passing through this operator.
 * Uses reservoir sampling to maintain a representative sample.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} [params.size=1000] - The maximum number of samples.
 */
function Sample(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, [], params);
  this.count = 0;
}
Sample.Definition = {
  'type': 'Sample',
  'metadata': {},
  'params': [{
    'name': 'size',
    'type': 'number',
    'default': 1000
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sample, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const out = pulse.fork(pulse.NO_SOURCE),
      mod = _.modified('size'),
      num = _.size,
      map = this.value.reduce((m, t) => (m[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] = 1, m), {});
    let res = this.value,
      cnt = this.count,
      cap = 0;

    // sample reservoir update function
    function update(t) {
      let p, idx;
      if (res.length < num) {
        res.push(t);
      } else {
        idx = ~~((cnt + 1) * (0,vega_statistics__WEBPACK_IMPORTED_MODULE_2__.random)());
        if (idx < res.length && idx >= cap) {
          p = res[idx];
          if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(p)]) out.rem.push(p); // eviction
          res[idx] = t;
        }
      }
      ++cnt;
    }
    if (pulse.rem.length) {
      // find all tuples that should be removed, add to output
      pulse.visit(pulse.REM, t => {
        const id = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t);
        if (map[id]) {
          map[id] = -1;
          out.rem.push(t);
        }
        --cnt;
      });

      // filter removed tuples out of the sample reservoir
      res = res.filter(t => map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)] !== -1);
    }
    if ((pulse.rem.length || mod) && res.length < num && pulse.source) {
      // replenish sample if backing data source is available
      cap = cnt = res.length;
      pulse.visit(pulse.SOURCE, t => {
        // update, but skip previously sampled tuples
        if (!map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) update(t);
      });
      cap = -1;
    }
    if (mod && res.length > num) {
      const n = res.length - num;
      for (let i = 0; i < n; ++i) {
        map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(res[i])] = -1;
        out.rem.push(res[i]);
      }
      res = res.slice(n);
    }
    if (pulse.mod.length) {
      // propagate modified tuples in the sample reservoir
      pulse.visit(pulse.MOD, t => {
        if (map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]) out.mod.push(t);
      });
    }
    if (pulse.add.length) {
      // update sample reservoir
      pulse.visit(pulse.ADD, update);
    }
    if (pulse.add.length || cap < 0) {
      // output newly added tuples
      out.add = res.filter(t => !map[(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid)(t)]);
    }
    this.count = cnt;
    this.value = out.source = res;
    return out;
  }
});

/**
 * Generates data tuples for a specified sequence range of numbers.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {number} params.start - The first number in the sequence.
 * @param {number} params.stop - The last number (exclusive) in the sequence.
 * @param {number} [params.step=1] - The step size between numbers in the sequence.
 */
function Sequence(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
Sequence.Definition = {
  'type': 'Sequence',
  'metadata': {
    'generates': true,
    'changes': true
  },
  'params': [{
    'name': 'start',
    'type': 'number',
    'required': true
  }, {
    'name': 'stop',
    'type': 'number',
    'required': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'data'
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sequence, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (this.value && !_.modified()) return;
    const out = pulse.materialize().fork(pulse.MOD),
      as = _.as || 'data';
    out.rem = this.value ? pulse.rem.concat(this.value) : pulse.rem;
    this.value = (0,d3_array__WEBPACK_IMPORTED_MODULE_8__["default"])(_.start, _.stop, _.step || 1).map(v => {
      const t = {};
      t[as] = v;
      return (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest)(t);
    });
    out.add = pulse.add.concat(this.value);
    return out;
  }
});

/**
 * Propagates a new pulse without any tuples so long as the input
 * pulse contains some added, removed or modified tuples.
 * @param {object} params - The parameters for this operator.
 * @constructor
 */
function Sieve(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
  this.modified(true); // always treat as modified
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Sieve, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.value = pulse.source;
    return pulse.changed() ? pulse.fork(pulse.NO_SOURCE | pulse.NO_FIELDS) : pulse.StopPropagation;
  }
});

/**
 * Discretize dates to specific time units.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The data field containing date/time values.
 */
function TimeUnit(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
const OUTPUT = ['unit0', 'unit1'];
TimeUnit.Definition = {
  'type': 'TimeUnit',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'field',
    'type': 'field',
    'required': true
  }, {
    'name': 'interval',
    'type': 'boolean',
    'default': true
  }, {
    'name': 'units',
    'type': 'enum',
    'values': vega_time__WEBPACK_IMPORTED_MODULE_3__.TIME_UNITS,
    'array': true
  }, {
    'name': 'step',
    'type': 'number',
    'default': 1
  }, {
    'name': 'maxbins',
    'type': 'number',
    'default': 40
  }, {
    'name': 'extent',
    'type': 'date',
    'array': true
  }, {
    'name': 'timezone',
    'type': 'enum',
    'default': 'local',
    'values': ['local', 'utc']
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 2,
    'default': OUTPUT
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TimeUnit, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const field = _.field,
      band = _.interval !== false,
      utc = _.timezone === 'utc',
      floor = this._floor(_, pulse),
      offset = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcInterval : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeInterval)(floor.unit).offset,
      as = _.as || OUTPUT,
      u0 = as[0],
      u1 = as[1],
      step = floor.step;
    let min = floor.start || Infinity,
      max = floor.stop || -Infinity,
      flag = pulse.ADD;
    if (_.modified() || pulse.changed(pulse.REM) || pulse.modified((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(field))) {
      pulse = pulse.reflow(true);
      flag = pulse.SOURCE;
      min = Infinity;
      max = -Infinity;
    }
    pulse.visit(flag, t => {
      const v = field(t);
      let a, b;
      if (v == null) {
        t[u0] = null;
        if (band) t[u1] = null;
      } else {
        t[u0] = a = b = floor(v);
        if (band) t[u1] = b = offset(a, step);
        if (a < min) min = a;
        if (b > max) max = b;
      }
    });
    floor.start = min;
    floor.stop = max;
    return pulse.modifies(band ? as : u0);
  },
  _floor(_, pulse) {
    const utc = _.timezone === 'utc';

    // get parameters
    const {
      units,
      step
    } = _.units ? {
      units: _.units,
      step: _.step || 1
    } : (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeBin)({
      extent: _.extent || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extent)(pulse.materialize(pulse.SOURCE).source, _.field),
      maxbins: _.maxbins
    });

    // check / standardize time units
    const tunits = (0,vega_time__WEBPACK_IMPORTED_MODULE_3__.timeUnits)(units),
      prev = this.value || {},
      floor = (utc ? vega_time__WEBPACK_IMPORTED_MODULE_3__.utcFloor : vega_time__WEBPACK_IMPORTED_MODULE_3__.timeFloor)(tunits, step);
    floor.unit = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.peek)(tunits);
    floor.units = tunits;
    floor.step = step;
    floor.start = prev.start;
    floor.stop = prev.stop;
    return this.value = floor;
  }
});

/**
 * An index that maps from unique, string-coerced, field values to tuples.
 * Assumes that the field serves as a unique key with no duplicate values.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The field accessor to index.
 */
function TupleIndex(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap)(), params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(TupleIndex, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const df = pulse.dataflow,
      field = _.field,
      index = this.value,
      set = t => index.set(field(t), t);
    let mod = true;
    if (_.modified('field') || pulse.modified(field.fields)) {
      index.clear();
      pulse.visit(pulse.SOURCE, set);
    } else if (pulse.changed()) {
      pulse.visit(pulse.REM, t => index.delete(field(t)));
      pulse.visit(pulse.ADD, set);
    } else {
      mod = false;
    }
    this.modified(mod);
    if (index.empty > df.cleanThreshold) df.runAfter(index.clean);
    return pulse.fork();
  }
});

/**
 * Extracts an array of values. Assumes the source data has already been
 * reduced as needed (e.g., by an upstream Aggregate transform).
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(object): *} params.field - The domain field to extract.
 * @param {function(*,*): number} [params.sort] - An optional
 *   comparator function for sorting the values. The comparator will be
 *   applied to backing tuples prior to value extraction.
 */
function Values(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Values, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    const run = !this.value || _.modified('field') || _.modified('sort') || pulse.changed() || _.sort && pulse.modified(_.sort.fields);
    if (run) {
      this.value = (_.sort ? pulse.source.slice().sort((0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort)) : pulse.source).map(_.field);
    }
  }
});

function WindowOp(op, field, param, as) {
  const fn = WindowOps[op](field, param);
  return {
    init: fn.init || vega_util__WEBPACK_IMPORTED_MODULE_0__.zero,
    update: function (w, t) {
      t[as] = fn.next(w);
    }
  };
}
const WindowOps = {
  row_number: function () {
    return {
      next: w => w.index + 1
    };
  },
  rank: function () {
    let rank;
    return {
      init: () => rank = 1,
      next: w => {
        const i = w.index,
          data = w.data;
        return i && w.compare(data[i - 1], data[i]) ? rank = i + 1 : rank;
      }
    };
  },
  dense_rank: function () {
    let drank;
    return {
      init: () => drank = 1,
      next: w => {
        const i = w.index,
          d = w.data;
        return i && w.compare(d[i - 1], d[i]) ? ++drank : drank;
      }
    };
  },
  percent_rank: function () {
    const rank = WindowOps.rank(),
      next = rank.next;
    return {
      init: rank.init,
      next: w => (next(w) - 1) / (w.data.length - 1)
    };
  },
  cume_dist: function () {
    let cume;
    return {
      init: () => cume = 0,
      next: w => {
        const d = w.data,
          c = w.compare;
        let i = w.index;
        if (cume < i) {
          while (i + 1 < d.length && !c(d[i], d[i + 1])) ++i;
          cume = i;
        }
        return (1 + cume) / d.length;
      }
    };
  },
  ntile: function (field, num) {
    num = +num;
    if (!(num > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('ntile num must be greater than zero.');
    const cume = WindowOps.cume_dist(),
      next = cume.next;
    return {
      init: cume.init,
      next: w => Math.ceil(num * next(w))
    };
  },
  lag: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index - offset;
        return i >= 0 ? field(w.data[i]) : null;
      }
    };
  },
  lead: function (field, offset) {
    offset = +offset || 1;
    return {
      next: w => {
        const i = w.index + offset,
          d = w.data;
        return i < d.length ? field(d[i]) : null;
      }
    };
  },
  first_value: function (field) {
    return {
      next: w => field(w.data[w.i0])
    };
  },
  last_value: function (field) {
    return {
      next: w => field(w.data[w.i1 - 1])
    };
  },
  nth_value: function (field, nth) {
    nth = +nth;
    if (!(nth > 0)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('nth_value nth must be greater than zero.');
    return {
      next: w => {
        const i = w.i0 + (nth - 1);
        return i < w.i1 ? field(w.data[i]) : null;
      }
    };
  },
  prev_value: function (field) {
    let prev;
    return {
      init: () => prev = null,
      next: w => {
        const v = field(w.data[w.index]);
        return v != null ? prev = v : prev;
      }
    };
  },
  next_value: function (field) {
    let v, i;
    return {
      init: () => (v = null, i = -1),
      next: w => {
        const d = w.data;
        return w.index <= i ? v : (i = find(field, d, w.index)) < 0 ? (i = d.length, v = null) : v = field(d[i]);
      }
    };
  }
};
function find(field, data, index) {
  for (let n = data.length; index < n; ++index) {
    const v = field(data[index]);
    if (v != null) return index;
  }
  return -1;
}
const ValidWindowOps = Object.keys(WindowOps);

function WindowState(_) {
  const ops = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.ops),
    fields = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.fields),
    params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.params),
    aggregate_params = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.aggregate_params),
    as = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(_.as),
    outputs = this.outputs = [],
    windows = this.windows = [],
    inputs = {},
    map = {},
    counts = [],
    measures = [];
  let countOnly = true;
  function visitInputs(f) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields)(f)).forEach(_ => inputs[_] = 1);
  }
  visitInputs(_.sort);
  ops.forEach((op, i) => {
    const field = fields[i],
      param = params[i],
      aggregate_param = aggregate_params[i] || null,
      mname = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName)(field),
      name = measureName(op, mname, as[i]);
    visitInputs(field);
    outputs.push(name);

    // Window operation
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(WindowOps, op)) {
      windows.push(WindowOp(op, field, param, name));
    }

    // Aggregate operation
    else {
      if (field == null && op !== 'count') {
        (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Null aggregate field specified.');
      }
      if (op === 'count') {
        counts.push(name);
        return;
      }
      countOnly = false;
      let m = map[mname];
      if (!m) {
        m = map[mname] = [];
        m.field = field;
        measures.push(m);
      }
      m.push(createMeasure(op, aggregate_param, name));
    }
  });
  if (counts.length || measures.length) {
    this.cell = cell(measures, counts, countOnly);
  }
  this.inputs = Object.keys(inputs);
}
const prototype = WindowState.prototype;
prototype.init = function () {
  this.windows.forEach(_ => _.init());
  if (this.cell) this.cell.init();
};
prototype.update = function (w, t) {
  const cell = this.cell,
    wind = this.windows,
    data = w.data,
    m = wind && wind.length;
  let j;
  if (cell) {
    for (j = w.p0; j < w.i0; ++j) cell.rem(data[j]);
    for (j = w.p1; j < w.i1; ++j) cell.add(data[j]);
    cell.set(t);
  }
  for (j = 0; j < m; ++j) wind[j].update(w, t);
};
function cell(measures, counts, countOnly) {
  measures = measures.map(m => compileMeasures(m, m.field));
  const cell = {
    num: 0,
    agg: null,
    store: false,
    count: counts
  };
  if (!countOnly) {
    var n = measures.length,
      a = cell.agg = Array(n),
      i = 0;
    for (; i < n; ++i) a[i] = new measures[i](cell);
  }
  if (cell.store) {
    var store = cell.data = new TupleStore();
  }
  cell.add = function (t) {
    cell.num += 1;
    if (countOnly) return;
    if (store) store.add(t);
    for (let i = 0; i < n; ++i) {
      a[i].add(a[i].get(t), t);
    }
  };
  cell.rem = function (t) {
    cell.num -= 1;
    if (countOnly) return;
    if (store) store.rem(t);
    for (let i = 0; i < n; ++i) {
      a[i].rem(a[i].get(t), t);
    }
  };
  cell.set = function (t) {
    let i, n;

    // consolidate stored values
    if (store) store.values();

    // update tuple properties
    for (i = 0, n = counts.length; i < n; ++i) t[counts[i]] = cell.num;
    if (!countOnly) for (i = 0, n = a.length; i < n; ++i) a[i].set(t);
  };
  cell.init = function () {
    cell.num = 0;
    if (store) store.reset();
    for (let i = 0; i < n; ++i) a[i].init();
  };
  return cell;
}

/**
 * Perform window calculations and write results to the input stream.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator function for sorting tuples within a window.
 * @param {Array<function(object): *>} [params.groupby] - An array of accessors by which to partition tuples into separate windows.
 * @param {Array<string>} params.ops - An array of strings indicating window operations to perform.
 * @param {Array<function(object): *>} [params.fields] - An array of accessors
 *   for data fields to use as inputs to window operations.
 * @param {Array<*>} [params.params] - An array of parameter values for window operations.
 * @param {Array<number>} [params.aggregate_params] - An optional array of parameter values for aggregation operations.
 * @param {Array<string>} [params.as] - An array of output field names for window operations.
 * @param {Array<number>} [params.frame] - Window frame definition as two-element array.
 * @param {boolean} [params.ignorePeers=false] - If true, base window frame boundaries on row
 *   number alone, ignoring peers with identical sort values. If false (default),
 *   the window boundaries will be adjusted to include peer values.
 */
function Window(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, {}, params);
  this._mlen = 0;
  this._mods = [];
}
Window.Definition = {
  'type': 'Window',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'sort',
    'type': 'compare'
  }, {
    'name': 'groupby',
    'type': 'field',
    'array': true
  }, {
    'name': 'ops',
    'type': 'enum',
    'array': true,
    'values': ValidWindowOps.concat(ValidAggregateOps)
  }, {
    'name': 'params',
    'type': 'number',
    'null': true,
    'array': true
  }, {
    'name': 'aggregate_params',
    'type': 'number',
    'null': true,
    'array': true
  }, {
    'name': 'fields',
    'type': 'field',
    'null': true,
    'array': true
  }, {
    'name': 'as',
    'type': 'string',
    'null': true,
    'array': true
  }, {
    'name': 'frame',
    'type': 'number',
    'null': true,
    'array': true,
    'length': 2,
    'default': [null, 0]
  }, {
    'name': 'ignorePeers',
    'type': 'boolean',
    'default': false
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(Window, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    this.stamp = pulse.stamp;
    const mod = _.modified(),
      cmp = (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.stableCompare)(_.sort),
      key = groupkey(_.groupby),
      group = t => this.group(key(t));

    // initialize window state
    let state = this.state;
    if (!state || mod) {
      state = this.state = new WindowState(_);
    }

    // partition input tuples
    if (mod || pulse.modified(state.inputs)) {
      this.value = {};
      pulse.visit(pulse.SOURCE, t => group(t).add(t));
    } else {
      pulse.visit(pulse.REM, t => group(t).remove(t));
      pulse.visit(pulse.ADD, t => group(t).add(t));
    }

    // perform window calculations for each modified partition
    for (let i = 0, n = this._mlen; i < n; ++i) {
      processPartition(this._mods[i], state, cmp, _);
    }
    this._mlen = 0;
    this._mods = [];

    // TODO don't reflow everything?
    return pulse.reflow(mod).modifies(state.outputs);
  },
  group(key) {
    let group = this.value[key];
    if (!group) {
      group = this.value[key] = SortedList(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid);
      group.stamp = -1;
    }
    if (group.stamp < this.stamp) {
      group.stamp = this.stamp;
      this._mods[this._mlen++] = group;
    }
    return group;
  }
});
function processPartition(list, state, cmp, _) {
  const sort = _.sort,
    range = sort && !_.ignorePeers,
    frame = _.frame || [null, 0],
    data = list.data(cmp),
    // use cmp for stable sort
    n = data.length,
    b = range ? (0,d3_array__WEBPACK_IMPORTED_MODULE_9__["default"])(sort) : null,
    w = {
      i0: 0,
      i1: 0,
      p0: 0,
      p1: 0,
      index: 0,
      data: data,
      compare: sort || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(-1)
    };
  state.init();
  for (let i = 0; i < n; ++i) {
    setWindow(w, frame, i, n);
    if (range) adjustRange(w, b);
    state.update(w, data[i]);
  }
}
function setWindow(w, f, i, n) {
  w.p0 = w.i0;
  w.p1 = w.i1;
  w.i0 = f[0] == null ? 0 : Math.max(0, i - Math.abs(f[0]));
  w.i1 = f[1] == null ? n : Math.min(n, i + Math.abs(f[1]) + 1);
  w.index = i;
}

// if frame type is 'range', adjust window for peer values
function adjustRange(w, bisect) {
  const r0 = w.i0,
    r1 = w.i1 - 1,
    c = w.compare,
    d = w.data,
    n = d.length - 1;
  if (r0 > 0 && !c(d[r0], d[r0 - 1])) w.i0 = bisect.left(d, d[r0]);
  if (r1 < n && !c(d[r1], d[r1 + 1])) w.i1 = bisect.right(d, d[r1]);
}




/***/ }),

/***/ "./node_modules/vega-view-transforms/build/vega-view-transforms.module.js":
/*!********************************************************************************!*\
  !*** ./node_modules/vega-view-transforms/build/vega-view-transforms.module.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   bound: () => (/* binding */ Bound),
/* harmony export */   identifier: () => (/* binding */ Identifier),
/* harmony export */   mark: () => (/* binding */ Mark),
/* harmony export */   overlap: () => (/* binding */ Overlap),
/* harmony export */   render: () => (/* binding */ Render),
/* harmony export */   viewlayout: () => (/* binding */ ViewLayout)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");




const Top = 'top';
const Left = 'left';
const Right = 'right';
const Bottom = 'bottom';
const TopLeft = 'top-left';
const TopRight = 'top-right';
const BottomLeft = 'bottom-left';
const BottomRight = 'bottom-right';
const Start = 'start';
const Middle = 'middle';
const End = 'end';
const X = 'x';
const Y = 'y';
const Group = 'group';
const AxisRole = 'axis';
const TitleRole = 'title';
const FrameRole = 'frame';
const ScopeRole = 'scope';
const LegendRole = 'legend';
const RowHeader = 'row-header';
const RowFooter = 'row-footer';
const RowTitle = 'row-title';
const ColHeader = 'column-header';
const ColFooter = 'column-footer';
const ColTitle = 'column-title';
const Padding = 'padding';
const Symbols = 'symbol';
const Fit = 'fit';
const FitX = 'fit-x';
const FitY = 'fit-y';
const Pad = 'pad';
const None = 'none';
const All = 'all';
const Each = 'each';
const Flush = 'flush';
const Column = 'column';
const Row = 'row';

/**
 * Calculate bounding boxes for scenegraph items.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - The scenegraph mark instance to bound.
 */
function Bound(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Bound, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow,
      mark = _.mark,
      type = mark.marktype,
      entry = vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Marks[type],
      bound = entry.bound;
    let markBounds = mark.bounds,
      rebound;
    if (entry.nested) {
      // multi-item marks have a single bounds instance
      if (mark.items.length) view.dirty(mark.items[0]);
      markBounds = boundItem(mark, bound);
      mark.items.forEach(item => {
        item.bounds.clear().union(markBounds);
      });
    } else if (type === Group || _.modified()) {
      // operator parameters modified -> re-bound all items
      // updates group bounds in response to modified group content
      pulse.visit(pulse.MOD, item => view.dirty(item));
      markBounds.clear();
      mark.items.forEach(item => markBounds.union(boundItem(item, bound)));

      // force reflow for axes/legends/titles to propagate any layout changes
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          pulse.reflow();
      }
    } else {
      // incrementally update bounds, re-bound mark as needed
      rebound = pulse.changed(pulse.REM);
      pulse.visit(pulse.ADD, item => {
        markBounds.union(boundItem(item, bound));
      });
      pulse.visit(pulse.MOD, item => {
        rebound = rebound || markBounds.alignsWith(item.bounds);
        view.dirty(item);
        markBounds.union(boundItem(item, bound));
      });
      if (rebound) {
        markBounds.clear();
        mark.items.forEach(item => markBounds.union(item.bounds));
      }
    }

    // ensure mark bounds do not exceed any clipping region
    (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundClip)(mark);
    return pulse.modifies('bounds');
  }
});
function boundItem(item, bound, opt) {
  return bound(item.bounds.clear(), item, opt);
}

const COUNTER_NAME = ':vega_identifier:';

/**
 * Adds a unique identifier to all added tuples.
 * This transform creates a new signal that serves as an id counter.
 * As a result, the id counter is shared across all instances of this
 * transform, generating unique ids across multiple data streams. In
 * addition, this signal value can be included in a snapshot of the
 * dataflow state, enabling correct resumption of id allocation.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {string} params.as - The field name for the generated identifier.
 */
function Identifier(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, 0, params);
}
Identifier.Definition = {
  'type': 'Identifier',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'as',
    'type': 'string',
    'required': true
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Identifier, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const counter = getCounter(pulse.dataflow),
      as = _.as;
    let id = counter.value;
    pulse.visit(pulse.ADD, t => t[as] = t[as] || ++id);
    counter.set(this.value = id);
    return pulse;
  }
});
function getCounter(view) {
  return view._signals[COUNTER_NAME] || (view._signals[COUNTER_NAME] = view.add(0));
}

/**
 * Bind scenegraph items to a scenegraph mark instance.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.markdef - The mark definition for creating the mark.
 *   This is an object of legal scenegraph mark properties which *must* include
 *   the 'marktype' property.
 */
function Mark(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Mark, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    let mark = this.value;

    // acquire mark on first invocation, bind context and group
    if (!mark) {
      mark = pulse.dataflow.scenegraph().mark(_.markdef, lookup$1(_), _.index);
      mark.group.context = _.context;
      if (!_.context.group) _.context.group = mark.group;
      mark.source = this.source; // point to upstream collector
      mark.clip = _.clip;
      mark.interactive = _.interactive;
      this.value = mark;
    }

    // initialize entering items
    const Init = mark.marktype === Group ? vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.GroupItem : vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Item;
    pulse.visit(pulse.ADD, item => Init.call(item, mark));

    // update clipping and/or interactive status
    if (_.modified('clip') || _.modified('interactive')) {
      mark.clip = _.clip;
      mark.interactive = !!_.interactive;
      mark.zdirty = true; // force scenegraph re-eval
      pulse.reflow();
    }

    // bind items array to scenegraph mark
    mark.items = pulse.source;
    return pulse;
  }
});
function lookup$1(_) {
  const g = _.groups,
    p = _.parent;
  return g && g.size === 1 ? g.get(Object.keys(g.object)[0]) : g && p ? g.lookup(p) : null;
}

/**
 * Analyze items for overlap, changing opacity to hide items with
 * overlapping bounding boxes. This transform will preserve at least
 * two items (e.g., first and last) even if overlap persists.
 * @param {object} params - The parameters for this operator.
 * @param {function(*,*): number} [params.sort] - A comparator
 *   function for sorting items.
 * @param {object} [params.method] - The overlap removal method to apply.
 *   One of 'parity' (default, hide every other item until there is no
 *   more overlap) or 'greedy' (sequentially scan and hide and items that
 *   overlap with the last visible item).
 * @param {object} [params.boundScale] - A scale whose range should be used
 *   to bound the items. Items exceeding the bounds of the scale range
 *   will be treated as overlapping. If null or undefined, no bounds check
 *   will be applied.
 * @param {object} [params.boundOrient] - The orientation of the scale
 *   (top, bottom, left, or right) used to bound items. This parameter is
 *   ignored if boundScale is null or undefined.
 * @param {object} [params.boundTolerance] - The tolerance in pixels for
 *   bound inclusion testing (default 1). This specifies by how many pixels
 *   an item's bounds may exceed the scale range bounds and not be culled.
 * @constructor
 */
function Overlap(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
const methods = {
  parity: items => items.filter((item, i) => i % 2 ? item.opacity = 0 : 1),
  greedy: (items, sep) => {
    let a;
    return items.filter((b, i) => !i || !intersect(a.bounds, b.bounds, sep) ? (a = b, 1) : b.opacity = 0);
  }
};

// compute bounding box intersection
// including padding pixels of separation
const intersect = (a, b, sep) => sep > Math.max(b.x1 - a.x2, a.x1 - b.x2, b.y1 - a.y2, a.y1 - b.y2);
const hasOverlap = (items, pad) => {
  for (var i = 1, n = items.length, a = items[0].bounds, b; i < n; a = b, ++i) {
    if (intersect(a, b = items[i].bounds, pad)) return true;
  }
};
const hasBounds = item => {
  const b = item.bounds;
  return b.width() > 1 && b.height() > 1;
};
const boundTest = (scale, orient, tolerance) => {
  var range = scale.range(),
    b = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();
  if (orient === Top || orient === Bottom) {
    b.set(range[0], -Infinity, range[1], +Infinity);
  } else {
    b.set(-Infinity, range[0], +Infinity, range[1]);
  }
  b.expand(tolerance || 1);
  return item => b.encloses(item.bounds);
};

// reset all items to be fully opaque
const reset = source => {
  source.forEach(item => item.opacity = 1);
  return source;
};

// add all tuples to mod, fork pulse if parameters were modified
// fork prevents cross-stream tuple pollution (e.g., pulse from scale)
const reflow = (pulse, _) => pulse.reflow(_.modified()).modifies('opacity');
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Overlap, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const reduce = methods[_.method] || methods.parity,
      sep = _.separation || 0;
    let source = pulse.materialize(pulse.SOURCE).source,
      items,
      test;
    if (!source || !source.length) return;
    if (!_.method) {
      // early exit if method is falsy
      if (_.modified('method')) {
        reset(source);
        pulse = reflow(pulse, _);
      }
      return pulse;
    }

    // skip labels with no content
    source = source.filter(hasBounds);

    // early exit, nothing to do
    if (!source.length) return;
    if (_.sort) {
      source = source.slice().sort(_.sort);
    }
    items = reset(source);
    pulse = reflow(pulse, _);
    if (items.length >= 3 && hasOverlap(items, sep)) {
      do {
        items = reduce(items, sep);
      } while (items.length >= 3 && hasOverlap(items, sep));
      if (items.length < 3 && !(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity) {
        if (items.length > 1) (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(items).opacity = 0;
        (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.peek)(source).opacity = 1;
      }
    }
    if (_.boundScale && _.boundTolerance >= 0) {
      test = boundTest(_.boundScale, _.boundOrient, +_.boundTolerance);
      source.forEach(item => {
        if (!test(item)) item.opacity = 0;
      });
    }

    // re-calculate mark bounds
    const bounds = items[0].mark.bounds.clear();
    source.forEach(item => {
      if (item.opacity) bounds.union(item.bounds);
    });
    return pulse;
  }
});

/**
 * Queue modified scenegraph items for rendering.
 * @constructor
 */
function Render(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Render, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;
    pulse.visit(pulse.ALL, item => view.dirty(item));

    // set z-index dirty flag as needed
    if (pulse.fields && pulse.fields['zindex']) {
      const item = pulse.source && pulse.source[0];
      if (item) item.mark.zdirty = true;
    }
  }
});

const tempBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds();
function set(item, property, value) {
  return item[property] === value ? 0 : (item[property] = value, 1);
}

function isYAxis(mark) {
  var orient = mark.items[0].orient;
  return orient === Left || orient === Right;
}
function axisIndices(datum) {
  let index = +datum.grid;
  return [datum.ticks ? index++ : -1,
  // ticks index
  datum.labels ? index++ : -1,
  // labels index
  index + +datum.domain // title index
  ];
}
function axisLayout(view, axis, width, height) {
  var item = axis.items[0],
    datum = item.datum,
    delta = item.translate != null ? item.translate : 0.5,
    orient = item.orient,
    indices = axisIndices(datum),
    range = item.range,
    offset = item.offset,
    position = item.position,
    minExtent = item.minExtent,
    maxExtent = item.maxExtent,
    title = datum.title && item.items[indices[2]].items[0],
    titlePadding = item.titlePadding,
    bounds = item.bounds,
    dl = title && (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title),
    x = 0,
    y = 0,
    i,
    s;
  tempBounds.clear().union(bounds);
  bounds.clear();
  if ((i = indices[0]) > -1) bounds.union(item.items[i].bounds);
  if ((i = indices[1]) > -1) bounds.union(item.items[i].bounds);

  // position axis group and title
  switch (orient) {
    case Top:
      x = position || 0;
      y = -offset;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.y1));
      bounds.add(0, -s).add(range, 0);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 0, -1, bounds);
      break;
    case Left:
      x = -offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, -bounds.x1));
      bounds.add(-s, 0).add(0, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, -1, bounds);
      break;
    case Right:
      x = width + offset;
      y = position || 0;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.x2));
      bounds.add(0, 0).add(s, range);
      if (title) axisTitleLayout(view, title, s, titlePadding, dl, 1, 1, bounds);
      break;
    case Bottom:
      x = position || 0;
      y = height + offset;
      s = Math.max(minExtent, Math.min(maxExtent, bounds.y2));
      bounds.add(0, 0).add(range, s);
      if (title) axisTitleLayout(view, title, s, titlePadding, 0, 0, 1, bounds);
      break;
    default:
      x = item.x;
      y = item.y;
  }

  // update bounds
  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.translate(x, y), item);
  if (set(item, 'x', x + delta) | set(item, 'y', y + delta)) {
    item.bounds = tempBounds;
    view.dirty(item);
    item.bounds = bounds;
    view.dirty(item);
  }
  return item.mark.bounds.clear().union(bounds);
}
function axisTitleLayout(view, title, offset, pad, dl, isYAxis, sign, bounds) {
  const b = title.bounds;
  if (title.auto) {
    const v = sign * (offset + dl + pad);
    let dx = 0,
      dy = 0;
    view.dirty(title);
    isYAxis ? dx = (title.x || 0) - (title.x = v) : dy = (title.y || 0) - (title.y = v);
    title.mark.bounds.clear().union(b.translate(-dx, -dy));
    view.dirty(title);
  }
  bounds.union(b);
}

// aggregation functions for grid margin determination
const min = (a, b) => Math.floor(Math.min(a, b));
const max = (a, b) => Math.ceil(Math.max(a, b));
function gridLayoutGroups(group) {
  var groups = group.items,
    n = groups.length,
    i = 0,
    mark,
    items;
  const views = {
    marks: [],
    rowheaders: [],
    rowfooters: [],
    colheaders: [],
    colfooters: [],
    rowtitle: null,
    coltitle: null
  };

  // layout axes, gather legends, collect bounds
  for (; i < n; ++i) {
    mark = groups[i];
    items = mark.items;
    if (mark.marktype === Group) {
      switch (mark.role) {
        case AxisRole:
        case LegendRole:
        case TitleRole:
          break;
        case RowHeader:
          views.rowheaders.push(...items);
          break;
        case RowFooter:
          views.rowfooters.push(...items);
          break;
        case ColHeader:
          views.colheaders.push(...items);
          break;
        case ColFooter:
          views.colfooters.push(...items);
          break;
        case RowTitle:
          views.rowtitle = items[0];
          break;
        case ColTitle:
          views.coltitle = items[0];
          break;
        default:
          views.marks.push(...items);
      }
    }
  }
  return views;
}
function bboxFlush(item) {
  return new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, item.width || 0, item.height || 0);
}
function bboxFull(item) {
  const b = item.bounds.clone();
  return b.empty() ? b.set(0, 0, 0, 0) : b.translate(-(item.x || 0), -(item.y || 0));
}
function get(opt, key, d) {
  const v = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isObject)(opt) ? opt[key] : opt;
  return v != null ? v : d !== undefined ? d : 0;
}
function offsetValue(v) {
  return v < 0 ? Math.ceil(-v) : 0;
}
function gridLayout(view, groups, opt) {
  var dirty = !opt.nodirty,
    bbox = opt.bounds === Flush ? bboxFlush : bboxFull,
    bounds = tempBounds.set(0, 0, 0, 0),
    alignCol = get(opt.align, Column),
    alignRow = get(opt.align, Row),
    padCol = get(opt.padding, Column),
    padRow = get(opt.padding, Row),
    ncols = opt.columns || groups.length,
    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
    n = groups.length,
    xOffset = Array(n),
    xExtent = Array(ncols),
    xMax = 0,
    yOffset = Array(n),
    yExtent = Array(nrows),
    yMax = 0,
    dx = Array(n),
    dy = Array(n),
    boxes = Array(n),
    m,
    i,
    c,
    r,
    b,
    g,
    px,
    py,
    x,
    y,
    offset;
  for (i = 0; i < ncols; ++i) xExtent[i] = 0;
  for (i = 0; i < nrows; ++i) yExtent[i] = 0;

  // determine offsets for each group
  for (i = 0; i < n; ++i) {
    g = groups[i];
    b = boxes[i] = bbox(g);
    g.x = g.x || 0;
    dx[i] = 0;
    g.y = g.y || 0;
    dy[i] = 0;
    c = i % ncols;
    r = ~~(i / ncols);
    xMax = Math.max(xMax, px = Math.ceil(b.x2));
    yMax = Math.max(yMax, py = Math.ceil(b.y2));
    xExtent[c] = Math.max(xExtent[c], px);
    yExtent[r] = Math.max(yExtent[r], py);
    xOffset[i] = padCol + offsetValue(b.x1);
    yOffset[i] = padRow + offsetValue(b.y1);
    if (dirty) view.dirty(groups[i]);
  }

  // set initial alignment offsets
  for (i = 0; i < n; ++i) {
    if (i % ncols === 0) xOffset[i] = 0;
    if (i < ncols) yOffset[i] = 0;
  }

  // enforce column alignment constraints
  if (alignCol === Each) {
    for (c = 1; c < ncols; ++c) {
      for (offset = 0, i = c; i < n; i += ncols) {
        if (offset < xOffset[i]) offset = xOffset[i];
      }
      for (i = c; i < n; i += ncols) {
        xOffset[i] = offset + xExtent[c - 1];
      }
    }
  } else if (alignCol === All) {
    for (offset = 0, i = 0; i < n; ++i) {
      if (i % ncols && offset < xOffset[i]) offset = xOffset[i];
    }
    for (i = 0; i < n; ++i) {
      if (i % ncols) xOffset[i] = offset + xMax;
    }
  } else {
    for (alignCol = false, c = 1; c < ncols; ++c) {
      for (i = c; i < n; i += ncols) {
        xOffset[i] += xExtent[c - 1];
      }
    }
  }

  // enforce row alignment constraints
  if (alignRow === Each) {
    for (r = 1; r < nrows; ++r) {
      for (offset = 0, i = r * ncols, m = i + ncols; i < m; ++i) {
        if (offset < yOffset[i]) offset = yOffset[i];
      }
      for (i = r * ncols; i < m; ++i) {
        yOffset[i] = offset + yExtent[r - 1];
      }
    }
  } else if (alignRow === All) {
    for (offset = 0, i = ncols; i < n; ++i) {
      if (offset < yOffset[i]) offset = yOffset[i];
    }
    for (i = ncols; i < n; ++i) {
      yOffset[i] = offset + yMax;
    }
  } else {
    for (alignRow = false, r = 1; r < nrows; ++r) {
      for (i = r * ncols, m = i + ncols; i < m; ++i) {
        yOffset[i] += yExtent[r - 1];
      }
    }
  }

  // perform horizontal grid layout
  for (x = 0, i = 0; i < n; ++i) {
    x = xOffset[i] + (i % ncols ? x : 0);
    dx[i] += x - groups[i].x;
  }

  // perform vertical grid layout
  for (c = 0; c < ncols; ++c) {
    for (y = 0, i = c; i < n; i += ncols) {
      y += yOffset[i];
      dy[i] += y - groups[i].y;
    }
  }

  // perform horizontal centering
  if (alignCol && get(opt.center, Column) && nrows > 1) {
    for (i = 0; i < n; ++i) {
      b = alignCol === All ? xMax : xExtent[i % ncols];
      x = b - boxes[i].x2 - groups[i].x - dx[i];
      if (x > 0) dx[i] += x / 2;
    }
  }

  // perform vertical centering
  if (alignRow && get(opt.center, Row) && ncols !== 1) {
    for (i = 0; i < n; ++i) {
      b = alignRow === All ? yMax : yExtent[~~(i / ncols)];
      y = b - boxes[i].y2 - groups[i].y - dy[i];
      if (y > 0) dy[i] += y / 2;
    }
  }

  // position grid relative to anchor
  for (i = 0; i < n; ++i) {
    bounds.union(boxes[i].translate(dx[i], dy[i]));
  }
  x = get(opt.anchor, X);
  y = get(opt.anchor, Y);
  switch (get(opt.anchor, Column)) {
    case End:
      x -= bounds.width();
      break;
    case Middle:
      x -= bounds.width() / 2;
  }
  switch (get(opt.anchor, Row)) {
    case End:
      y -= bounds.height();
      break;
    case Middle:
      y -= bounds.height() / 2;
  }
  x = Math.round(x);
  y = Math.round(y);

  // update mark positions, bounds, dirty
  bounds.clear();
  for (i = 0; i < n; ++i) {
    groups[i].mark.bounds.clear();
  }
  for (i = 0; i < n; ++i) {
    g = groups[i];
    g.x += dx[i] += x;
    g.y += dy[i] += y;
    bounds.union(g.mark.bounds.union(g.bounds.translate(dx[i], dy[i])));
    if (dirty) view.dirty(g);
  }
  return bounds;
}
function trellisLayout(view, group, opt) {
  var views = gridLayoutGroups(group),
    groups = views.marks,
    bbox = opt.bounds === Flush ? boundFlush : boundFull,
    off = opt.offset,
    ncols = opt.columns || groups.length,
    nrows = ncols <= 0 ? 1 : Math.ceil(groups.length / ncols),
    cells = nrows * ncols,
    x,
    y,
    x2,
    y2,
    anchor,
    band,
    offset;

  // -- initial grid layout
  const bounds = gridLayout(view, groups, opt);
  if (bounds.empty()) bounds.set(0, 0, 0, 0); // empty grid

  // -- layout grid headers and footers --

  // perform row header layout
  if (views.rowheaders) {
    band = get(opt.headerBand, Row, null);
    x = layoutHeaders(view, views.rowheaders, groups, ncols, nrows, -get(off, 'rowHeader'), min, 0, bbox, 'x1', 0, ncols, 1, band);
  }

  // perform column header layout
  if (views.colheaders) {
    band = get(opt.headerBand, Column, null);
    y = layoutHeaders(view, views.colheaders, groups, ncols, ncols, -get(off, 'columnHeader'), min, 1, bbox, 'y1', 0, 1, ncols, band);
  }

  // perform row footer layout
  if (views.rowfooters) {
    band = get(opt.footerBand, Row, null);
    x2 = layoutHeaders(view, views.rowfooters, groups, ncols, nrows, get(off, 'rowFooter'), max, 0, bbox, 'x2', ncols - 1, ncols, 1, band);
  }

  // perform column footer layout
  if (views.colfooters) {
    band = get(opt.footerBand, Column, null);
    y2 = layoutHeaders(view, views.colfooters, groups, ncols, ncols, get(off, 'columnFooter'), max, 1, bbox, 'y2', cells - ncols, 1, ncols, band);
  }

  // perform row title layout
  if (views.rowtitle) {
    anchor = get(opt.titleAnchor, Row);
    offset = get(off, 'rowTitle');
    offset = anchor === End ? x2 + offset : x - offset;
    band = get(opt.titleBand, Row, 0.5);
    layoutTitle(view, views.rowtitle, offset, 0, bounds, band);
  }

  // perform column title layout
  if (views.coltitle) {
    anchor = get(opt.titleAnchor, Column);
    offset = get(off, 'columnTitle');
    offset = anchor === End ? y2 + offset : y - offset;
    band = get(opt.titleBand, Column, 0.5);
    layoutTitle(view, views.coltitle, offset, 1, bounds, band);
  }
}
function boundFlush(item, field) {
  return field === 'x1' ? item.x || 0 : field === 'y1' ? item.y || 0 : field === 'x2' ? (item.x || 0) + (item.width || 0) : field === 'y2' ? (item.y || 0) + (item.height || 0) : undefined;
}
function boundFull(item, field) {
  return item.bounds[field];
}
function layoutHeaders(view, headers, groups, ncols, limit, offset, agg, isX, bound, bf, start, stride, back, band) {
  var n = groups.length,
    init = 0,
    edge = 0,
    i,
    j,
    k,
    m,
    b,
    h,
    g,
    x,
    y;

  // if no groups, early exit and return 0
  if (!n) return init;

  // compute margin
  for (i = start; i < n; i += stride) {
    if (groups[i]) init = agg(init, bound(groups[i], bf));
  }

  // if no headers, return margin calculation
  if (!headers.length) return init;

  // check if number of headers exceeds number of rows or columns
  if (headers.length > limit) {
    view.warn('Grid headers exceed limit: ' + limit);
    headers = headers.slice(0, limit);
  }

  // apply offset
  init += offset;

  // clear mark bounds for all headers
  for (j = 0, m = headers.length; j < m; ++j) {
    view.dirty(headers[j]);
    headers[j].mark.bounds.clear();
  }

  // layout each header
  for (i = start, j = 0, m = headers.length; j < m; ++j, i += stride) {
    h = headers[j];
    b = h.mark.bounds;

    // search for nearest group to align to
    // necessary if table has empty cells
    for (k = i; k >= 0 && (g = groups[k]) == null; k -= back);

    // assign coordinates and update bounds
    if (isX) {
      x = band == null ? g.x : Math.round(g.bounds.x1 + band * g.bounds.width());
      y = init;
    } else {
      x = init;
      y = band == null ? g.y : Math.round(g.bounds.y1 + band * g.bounds.height());
    }
    b.union(h.bounds.translate(x - (h.x || 0), y - (h.y || 0)));
    h.x = x;
    h.y = y;
    view.dirty(h);

    // update current edge of layout bounds
    edge = agg(edge, b[bf]);
  }
  return edge;
}
function layoutTitle(view, g, offset, isX, bounds, band) {
  if (!g) return;
  view.dirty(g);

  // compute title coordinates
  var x = offset,
    y = offset;
  isX ? x = Math.round(bounds.x1 + band * bounds.width()) : y = Math.round(bounds.y1 + band * bounds.height());

  // assign coordinates and update bounds
  g.bounds.translate(x - (g.x || 0), y - (g.y || 0));
  g.mark.bounds.clear().union(g.bounds);
  g.x = x;
  g.y = y;

  // queue title for redraw
  view.dirty(g);
}

// utility for looking up legend layout configuration
function lookup(config, orient) {
  const opt = config[orient] || {};
  return (key, d) => opt[key] != null ? opt[key] : config[key] != null ? config[key] : d;
}

// if legends specify offset directly, use the maximum specified value
function offsets(legends, value) {
  let max = -Infinity;
  legends.forEach(item => {
    if (item.offset != null) max = Math.max(max, item.offset);
  });
  return max > -Infinity ? max : value;
}
function legendParams(g, orient, config, xb, yb, w, h) {
  const _ = lookup(config, orient),
    offset = offsets(g, _('offset', 0)),
    anchor = _('anchor', Start),
    mult = anchor === End ? 1 : anchor === Middle ? 0.5 : 0;
  const p = {
    align: Each,
    bounds: _('bounds', Flush),
    columns: _('direction') === 'vertical' ? 1 : g.length,
    padding: _('margin', 8),
    center: _('center'),
    nodirty: true
  };
  switch (orient) {
    case Left:
      p.anchor = {
        x: Math.floor(xb.x1) - offset,
        column: End,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Right:
      p.anchor = {
        x: Math.ceil(xb.x2) + offset,
        y: mult * (h || xb.height() + 2 * xb.y1),
        row: anchor
      };
      break;
    case Top:
      p.anchor = {
        y: Math.floor(yb.y1) - offset,
        row: End,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case Bottom:
      p.anchor = {
        y: Math.ceil(yb.y2) + offset,
        x: mult * (w || yb.width() + 2 * yb.x1),
        column: anchor
      };
      break;
    case TopLeft:
      p.anchor = {
        x: offset,
        y: offset
      };
      break;
    case TopRight:
      p.anchor = {
        x: w - offset,
        y: offset,
        column: End
      };
      break;
    case BottomLeft:
      p.anchor = {
        x: offset,
        y: h - offset,
        row: End
      };
      break;
    case BottomRight:
      p.anchor = {
        x: w - offset,
        y: h - offset,
        column: End,
        row: End
      };
      break;
  }
  return p;
}
function legendLayout(view, legend) {
  var item = legend.items[0],
    datum = item.datum,
    orient = item.orient,
    bounds = item.bounds,
    x = item.x,
    y = item.y,
    w,
    h;

  // cache current bounds for later comparison
  item._bounds ? item._bounds.clear().union(bounds) : item._bounds = bounds.clone();
  bounds.clear();

  // adjust legend to accommodate padding and title
  legendGroupLayout(view, item, item.items[0].items[0]);

  // aggregate bounds to determine size, and include origin
  bounds = legendBounds(item, bounds);
  w = 2 * item.padding;
  h = 2 * item.padding;
  if (!bounds.empty()) {
    w = Math.ceil(bounds.width() + w);
    h = Math.ceil(bounds.height() + h);
  }
  if (datum.type === Symbols) {
    legendEntryLayout(item.items[0].items[0].items[0].items);
  }
  if (orient !== None) {
    item.x = x = 0;
    item.y = y = 0;
  }
  item.width = w;
  item.height = h;
  (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.boundStroke)(bounds.set(x, y, x + w, y + h), item);
  item.mark.bounds.clear().union(bounds);
  return item;
}
function legendBounds(item, b) {
  // aggregate item bounds
  item.items.forEach(_ => b.union(_.bounds));

  // anchor to legend origin
  b.x1 = item.padding;
  b.y1 = item.padding;
  return b;
}
function legendGroupLayout(view, item, entry) {
  var pad = item.padding,
    ex = pad - entry.x,
    ey = pad - entry.y;
  if (!item.datum.title) {
    if (ex || ey) translate(view, entry, ex, ey);
  } else {
    var title = item.items[1].items[0],
      anchor = title.anchor,
      tpad = item.titlePadding || 0,
      tx = pad - title.x,
      ty = pad - title.y;
    switch (title.orient) {
      case Left:
        ex += Math.ceil(title.bounds.width()) + tpad;
        break;
      case Right:
      case Bottom:
        break;
      default:
        ey += title.bounds.height() + tpad;
    }
    if (ex || ey) translate(view, entry, ex, ey);
    switch (title.orient) {
      case Left:
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;
      case Right:
        tx += legendTitleOffset(item, entry, title, End, 0, 0) + tpad;
        ty += legendTitleOffset(item, entry, title, anchor, 1, 1);
        break;
      case Bottom:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
        ty += legendTitleOffset(item, entry, title, End, -1, 0, 1) + tpad;
        break;
      default:
        tx += legendTitleOffset(item, entry, title, anchor, 0, 0);
    }
    if (tx || ty) translate(view, title, tx, ty);

    // translate legend if title pushes into negative coordinates
    if ((tx = Math.round(title.bounds.x1 - pad)) < 0) {
      translate(view, entry, -tx, 0);
      translate(view, title, -tx, 0);
    }
  }
}
function legendTitleOffset(item, entry, title, anchor, y, lr, noBar) {
  const grad = item.datum.type !== 'symbol',
    vgrad = title.datum.vgrad,
    e = grad && (lr || !vgrad) && !noBar ? entry.items[0] : entry,
    s = e.bounds[y ? 'y2' : 'x2'] - item.padding,
    u = vgrad && lr ? s : 0,
    v = vgrad && lr ? 0 : s,
    o = y <= 0 ? 0 : (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.multiLineOffset)(title);
  return Math.round(anchor === Start ? u : anchor === End ? v - o : 0.5 * (s - o));
}
function translate(view, item, dx, dy) {
  item.x += dx;
  item.y += dy;
  item.bounds.translate(dx, dy);
  item.mark.bounds.translate(dx, dy);
  view.dirty(item);
}
function legendEntryLayout(entries) {
  // get max widths for each column
  const widths = entries.reduce((w, g) => {
    w[g.column] = Math.max(g.bounds.x2 - g.x, w[g.column] || 0);
    return w;
  }, {});

  // set dimensions of legend entry groups
  entries.forEach(g => {
    g.width = widths[g.column];
    g.height = g.bounds.y2 - g.y;
  });
}

function titleLayout(view, mark, width, height, viewBounds) {
  var group = mark.items[0],
    frame = group.frame,
    orient = group.orient,
    anchor = group.anchor,
    offset = group.offset,
    padding = group.padding,
    title = group.items[0].items[0],
    subtitle = group.items[1] && group.items[1].items[0],
    end = orient === Left || orient === Right ? height : width,
    start = 0,
    x = 0,
    y = 0,
    sx = 0,
    sy = 0,
    pos;
  if (frame !== Group) {
    orient === Left ? (start = viewBounds.y2, end = viewBounds.y1) : orient === Right ? (start = viewBounds.y1, end = viewBounds.y2) : (start = viewBounds.x1, end = viewBounds.x2);
  } else if (orient === Left) {
    start = height, end = 0;
  }
  pos = anchor === Start ? start : anchor === End ? end : (start + end) / 2;
  if (subtitle && subtitle.text) {
    // position subtitle
    switch (orient) {
      case Top:
      case Bottom:
        sy = title.bounds.height() + padding;
        break;
      case Left:
        sx = title.bounds.width() + padding;
        break;
      case Right:
        sx = -title.bounds.width() - padding;
        break;
    }
    tempBounds.clear().union(subtitle.bounds);
    tempBounds.translate(sx - (subtitle.x || 0), sy - (subtitle.y || 0));
    if (set(subtitle, 'x', sx) | set(subtitle, 'y', sy)) {
      view.dirty(subtitle);
      subtitle.bounds.clear().union(tempBounds);
      subtitle.mark.bounds.clear().union(tempBounds);
      view.dirty(subtitle);
    }
    tempBounds.clear().union(subtitle.bounds);
  } else {
    tempBounds.clear();
  }
  tempBounds.union(title.bounds);

  // position title group
  switch (orient) {
    case Top:
      x = pos;
      y = viewBounds.y1 - tempBounds.height() - offset;
      break;
    case Left:
      x = viewBounds.x1 - tempBounds.width() - offset;
      y = pos;
      break;
    case Right:
      x = viewBounds.x2 + tempBounds.width() + offset;
      y = pos;
      break;
    case Bottom:
      x = pos;
      y = viewBounds.y2 + offset;
      break;
    default:
      x = group.x;
      y = group.y;
  }
  if (set(group, 'x', x) | set(group, 'y', y)) {
    tempBounds.translate(x, y);
    view.dirty(group);
    group.bounds.clear().union(tempBounds);
    mark.bounds.clear().union(tempBounds);
    view.dirty(group);
  }
  return group.bounds;
}

/**
 * Layout view elements such as axes and legends.
 * Also performs size adjustments.
 * @constructor
 * @param {object} params - The parameters for this operator.
 * @param {object} params.mark - Scenegraph mark of groups to layout.
 */
function ViewLayout(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(ViewLayout, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const view = pulse.dataflow;
    _.mark.items.forEach(group => {
      if (_.layout) trellisLayout(view, group, _.layout);
      layoutGroup(view, group, _);
    });
    return shouldReflow(_.mark.group) ? pulse.reflow() : pulse;
  }
});
function shouldReflow(group) {
  // We typically should reflow if layout is invoked (#2568), as child items
  // may have resized and reflow ensures group bounds are re-calculated.
  // However, legend entries have a special exception to avoid instability.
  // For example, if a selected legend symbol gains a stroke on hover,
  // we don't want to re-position subsequent elements in the legend.
  return group && group.mark.role !== 'legend-entry';
}
function layoutGroup(view, group, _) {
  var items = group.items,
    width = Math.max(0, group.width || 0),
    height = Math.max(0, group.height || 0),
    viewBounds = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_1__.Bounds().set(0, 0, width, height),
    xBounds = viewBounds.clone(),
    yBounds = viewBounds.clone(),
    legends = [],
    title,
    mark,
    orient,
    b,
    i,
    n;

  // layout axes, gather legends, collect bounds
  for (i = 0, n = items.length; i < n; ++i) {
    mark = items[i];
    switch (mark.role) {
      case AxisRole:
        b = isYAxis(mark) ? xBounds : yBounds;
        b.union(axisLayout(view, mark, width, height));
        break;
      case TitleRole:
        title = mark;
        break;
      case LegendRole:
        legends.push(legendLayout(view, mark));
        break;
      case FrameRole:
      case ScopeRole:
      case RowHeader:
      case RowFooter:
      case RowTitle:
      case ColHeader:
      case ColFooter:
      case ColTitle:
        xBounds.union(mark.bounds);
        yBounds.union(mark.bounds);
        break;
      default:
        viewBounds.union(mark.bounds);
    }
  }

  // layout legends, adjust viewBounds
  if (legends.length) {
    // group legends by orient
    const l = {};
    legends.forEach(item => {
      orient = item.orient || Right;
      if (orient !== None) (l[orient] || (l[orient] = [])).push(item);
    });

    // perform grid layout for each orient group
    for (const orient in l) {
      const g = l[orient];
      gridLayout(view, g, legendParams(g, orient, _.legends, xBounds, yBounds, width, height));
    }

    // update view bounds
    legends.forEach(item => {
      const b = item.bounds;
      if (!b.equals(item._bounds)) {
        item.bounds = item._bounds;
        view.dirty(item); // dirty previous location
        item.bounds = b;
        view.dirty(item);
      }
      if (_.autosize && (_.autosize.type === Fit || _.autosize.type === FitX || _.autosize.type === FitY)) {
        // For autosize fit, incorporate the orthogonal dimension only.
        // Legends that overrun the chart area will then be clipped;
        // otherwise the chart area gets reduced to nothing!
        switch (item.orient) {
          case Left:
          case Right:
            viewBounds.add(b.x1, 0).add(b.x2, 0);
            break;
          case Top:
          case Bottom:
            viewBounds.add(0, b.y1).add(0, b.y2);
        }
      } else {
        viewBounds.union(b);
      }
    });
  }

  // combine bounding boxes
  viewBounds.union(xBounds).union(yBounds);

  // layout title, adjust bounds
  if (title) {
    viewBounds.union(titleLayout(view, title, width, height, viewBounds));
  }

  // override aggregated view bounds if content is clipped
  if (group.clip) {
    viewBounds.set(0, 0, group.width || 0, group.height || 0);
  }

  // perform size adjustment
  viewSizeLayout(view, group, viewBounds, _);
}
function viewSizeLayout(view, group, viewBounds, _) {
  const auto = _.autosize || {},
    type = auto.type;
  if (view._autosize < 1 || !type) return;
  let viewWidth = view._width,
    viewHeight = view._height,
    width = Math.max(0, group.width || 0),
    left = Math.max(0, Math.ceil(-viewBounds.x1)),
    height = Math.max(0, group.height || 0),
    top = Math.max(0, Math.ceil(-viewBounds.y1));
  const right = Math.max(0, Math.ceil(viewBounds.x2 - width)),
    bottom = Math.max(0, Math.ceil(viewBounds.y2 - height));
  if (auto.contains === Padding) {
    const padding = view.padding();
    viewWidth -= padding.left + padding.right;
    viewHeight -= padding.top + padding.bottom;
  }
  if (type === None) {
    left = 0;
    top = 0;
    width = viewWidth;
    height = viewHeight;
  } else if (type === Fit) {
    width = Math.max(0, viewWidth - left - right);
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === FitX) {
    width = Math.max(0, viewWidth - left - right);
    viewHeight = height + top + bottom;
  } else if (type === FitY) {
    viewWidth = width + left + right;
    height = Math.max(0, viewHeight - top - bottom);
  } else if (type === Pad) {
    viewWidth = width + left + right;
    viewHeight = height + top + bottom;
  }
  view._resizeView(viewWidth, viewHeight, width, height, [left, top], auto.resize);
}




/***/ }),

/***/ "./node_modules/vega-view/build/vega-view.module.js":
/*!**********************************************************!*\
  !*** ./node_modules/vega-view/build/vega-view.module.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   View: () => (/* binding */ View)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var d3_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! d3-array */ "./node_modules/d3-array/src/ticks.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-functions */ "./node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-runtime */ "./node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var d3_timer__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! d3-timer */ "./node_modules/d3-timer/src/interval.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");









// initialize aria role and label attributes
function initializeAria(view) {
  const el = view.container();
  if (el) {
    el.setAttribute('role', 'graphics-document');
    el.setAttribute('aria-roleDescription', 'visualization');
    ariaLabel(el, view.description());
  }
}

// update aria-label if we have a DOM container element
function ariaLabel(el, desc) {
  if (el) desc == null ? el.removeAttribute('aria-label') : el.setAttribute('aria-label', desc);
}

function background (view) {
  // respond to background signal
  view.add(null, _ => {
    view._background = _.bg;
    view._resize = 1;
    return _.bg;
  }, {
    bg: view._signals.background
  });
}

const Default = 'default';
function cursor (view) {
  // get cursor signal, add to dataflow if needed
  const cursor = view._signals.cursor || (view._signals.cursor = view.add({
    user: Default,
    item: null
  }));

  // evaluate cursor on each pointermove event
  view.on(view.events('view', 'pointermove'), cursor, (_, event) => {
    const value = cursor.value,
      user = value ? (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(value) ? value : value.user : Default,
      item = event.item && event.item.cursor || null;
    return value && user === value.user && item == value.item ? value : {
      user: user,
      item: item
    };
  });

  // when cursor signal updates, set visible cursor
  view.add(null, function (_) {
    let user = _.cursor,
      item = this.value;
    if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(user)) {
      item = user.item;
      user = user.user;
    }
    setCursor(view, user && user !== Default ? user : item || user);
    return item;
  }, {
    cursor: cursor
  });
}
function setCursor(view, cursor) {
  const el = view.globalCursor() ? typeof document !== 'undefined' && document.body : view.container();
  if (el) {
    return cursor == null ? el.style.removeProperty('cursor') : el.style.cursor = cursor;
  }
}

function dataref(view, name) {
  var data = view._runtime.data;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(data, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized data set: ' + name);
  }
  return data[name];
}
function data(name, values) {
  return arguments.length < 2 ? dataref(this, name).values.value : change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy).insert(values));
}
function change(name, changes) {
  if (!(0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isChangeSet)(changes)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Second argument to changes must be a changeset.');
  }
  const dataset = dataref(this, name);
  dataset.modified = true;
  return this.pulse(dataset.input, changes);
}
function insert(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().insert(_));
}
function remove(name, _) {
  return change.call(this, name, (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset)().remove(_));
}

function width(view) {
  var padding = view.padding();
  return Math.max(0, view._viewWidth + padding.left + padding.right);
}
function height(view) {
  var padding = view.padding();
  return Math.max(0, view._viewHeight + padding.top + padding.bottom);
}
function offset(view) {
  var padding = view.padding(),
    origin = view._origin;
  return [padding.left + origin[0], padding.top + origin[1]];
}
function resizeRenderer(view) {
  var origin = offset(view),
    w = width(view),
    h = height(view);
  view._renderer.background(view.background());
  view._renderer.resize(w, h, origin);
  view._handler.origin(origin);
  view._resizeListeners.forEach(handler => {
    try {
      handler(w, h);
    } catch (error) {
      view.error(error);
    }
  });
}

/**
 * Extend an event with additional view-specific methods.
 * Adds a new property ('vega') to an event that provides a number
 * of methods for querying information about the current interaction.
 * The vega object provides the following methods:
 *   view - Returns the backing View instance.
 *   item - Returns the currently active scenegraph item (if any).
 *   group - Returns the currently active scenegraph group (if any).
 *     This method accepts a single string-typed argument indicating the name
 *     of the desired parent group. The scenegraph will be traversed from
 *     the item up towards the root to search for a matching group. If no
 *     argument is provided the enclosing group for the active item is
 *     returned, unless the item it itself a group, in which case it is
 *     returned directly.
 *   xy - Returns a two-element array containing the x and y coordinates for
 *     mouse or touch events. For touch events, this is based on the first
 *     elements in the changedTouches array. This method accepts a single
 *     argument: either an item instance or mark name that should serve as
 *     the reference coordinate system. If no argument is provided the
 *     top-level view coordinate system is assumed.
 *   x - Returns the current x-coordinate, accepts the same arguments as xy.
 *   y - Returns the current y-coordinate, accepts the same arguments as xy.
 * @param {Event} event - The input event to extend.
 * @param {Item} item - The currently active scenegraph item (if any).
 * @return {Event} - The extended input event.
 */
function eventExtend (view, event, item) {
  var r = view._renderer,
    el = r && r.canvas(),
    p,
    e,
    translate;
  if (el) {
    translate = offset(view);
    e = event.changedTouches ? event.changedTouches[0] : event;
    p = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.point)(e, el);
    p[0] -= translate[0];
    p[1] -= translate[1];
  }
  event.dataflow = view;
  event.item = item;
  event.vega = extension(view, item, p);
  return event;
}
function extension(view, item, point) {
  const itemGroup = item ? item.mark.marktype === 'group' ? item : item.mark.group : null;
  function group(name) {
    var g = itemGroup,
      i;
    if (name) for (i = item; i; i = i.mark.group) {
      if (i.mark.name === name) {
        g = i;
        break;
      }
    }
    return g && g.mark && g.mark.interactive ? g : {};
  }
  function xy(item) {
    if (!item) return point;
    if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isString)(item)) item = group(item);
    const p = point.slice();
    while (item) {
      p[0] -= item.x || 0;
      p[1] -= item.y || 0;
      item = item.mark && item.mark.group;
    }
    return p;
  }
  return {
    view: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(view),
    item: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.constant)(item || {}),
    group: group,
    xy: xy,
    x: item => xy(item)[0],
    y: item => xy(item)[1]
  };
}

const VIEW = 'view',
  TIMER = 'timer',
  WINDOW = 'window',
  NO_TRAP = {
    trap: false
  };

/**
 * Initialize event handling configuration.
 * @param {object} config - The configuration settings.
 * @return {object}
 */
function initializeEventConfig(config) {
  const events = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({
    defaults: {}
  }, config);
  const unpack = (obj, keys) => {
    keys.forEach(k => {
      if ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(obj[k])) obj[k] = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet)(obj[k]);
    });
  };
  unpack(events.defaults, ['prevent', 'allow']);
  unpack(events, ['view', 'window', 'selector']);
  return events;
}
function trackEventListener(view, sources, type, handler) {
  view._eventListeners.push({
    type: type,
    sources: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.array)(sources),
    handler: handler
  });
}
function prevent(view, type) {
  var def = view._eventConfig.defaults,
    prevent = def.prevent,
    allow = def.allow;
  return prevent === false || allow === true ? false : prevent === true || allow === false ? true : prevent ? prevent[type] : allow ? !allow[type] : view.preventDefault();
}
function permit(view, key, type) {
  const rule = view._eventConfig && view._eventConfig[key];
  if (rule === false || (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(rule) && !rule[type]) {
    view.warn(`Blocked ${key} ${type} event listener.`);
    return false;
  }
  return true;
}

/**
 * Create a new event stream from an event source.
 * @param {object} source - The event source to monitor.
 * @param {string} type - The event type.
 * @param {function(object): boolean} [filter] - Event filter function.
 * @return {EventStream}
 */
function events(source, type, filter) {
  var view = this,
    s = new vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream(filter),
    send = function (e, item) {
      view.runAsync(null, () => {
        if (source === VIEW && prevent(view, type)) {
          e.preventDefault();
        }
        s.receive(eventExtend(view, e, item));
      });
    },
    sources;
  if (source === TIMER) {
    if (permit(view, 'timer', type)) {
      view.timer(send, type);
    }
  } else if (source === VIEW) {
    if (permit(view, 'view', type)) {
      // send traps errors, so use {trap: false} option
      view.addEventListener(type, send, NO_TRAP);
    }
  } else {
    if (source === WINDOW) {
      if (permit(view, 'window', type) && typeof window !== 'undefined') {
        sources = [window];
      }
    } else if (typeof document !== 'undefined') {
      if (permit(view, 'selector', type)) {
        sources = Array.from(document.querySelectorAll(source));
      }
    }
    if (!sources) {
      view.warn('Can not resolve event source: ' + source);
    } else {
      for (var i = 0, n = sources.length; i < n; ++i) {
        sources[i].addEventListener(type, send);
      }
      trackEventListener(view, sources, type, send);
    }
  }
  return s;
}

function itemFilter(event) {
  return event.item;
}
function markTarget(event) {
  // grab upstream collector feeding the mark operator
  return event.item.mark.source;
}
function invoke(name) {
  return function (_, event) {
    return event.vega.view().changeset().encode(event.item, name);
  };
}
function hover (hoverSet, leaveSet) {
  hoverSet = [hoverSet || 'hover'];
  leaveSet = [leaveSet || 'update', hoverSet[0]];

  // invoke hover set upon pointerover
  this.on(this.events('view', 'pointerover', itemFilter), markTarget, invoke(hoverSet));

  // invoke leave set upon pointerout
  this.on(this.events('view', 'pointerout', itemFilter), markTarget, invoke(leaveSet));
  return this;
}

/**
 * Finalize a View instance that is being removed.
 * Cancel any running timers.
 * Remove all external event listeners.
 * Remove any currently displayed tooltip.
 */
function finalize () {
  var tooltip = this._tooltip,
    timers = this._timers,
    handlers = this._handler.handlers(),
    listeners = this._eventListeners,
    n,
    m,
    e,
    h,
    t;
  n = timers.length;
  while (--n >= 0) {
    timers[n].stop();
  }
  n = listeners.length;
  while (--n >= 0) {
    e = listeners[n];
    m = e.sources.length;
    while (--m >= 0) {
      e.sources[m].removeEventListener(e.type, e.handler);
    }
  }
  if (tooltip) {
    tooltip.call(this, this._handler, null, null, null);
  }

  // turn off all registered handlers
  n = handlers.length;
  while (--n >= 0) {
    t = handlers[n].type;
    h = handlers[n].handler;
    this._handler.off(t, h);
  }
  return this;
}

function element (tag, attr, text) {
  const el = document.createElement(tag);
  for (const key in attr) el.setAttribute(key, attr[key]);
  if (text != null) el.textContent = text;
  return el;
}

const BindClass = 'vega-bind',
  NameClass = 'vega-bind-name',
  RadioClass = 'vega-bind-radio';

/**
 * Bind a signal to an external HTML input element. The resulting two-way
 * binding will propagate input changes to signals, and propagate signal
 * changes to the input element state. If this view instance has no parent
 * element, we assume the view is headless and no bindings are created.
 * @param {Element|string} el - The parent DOM element to which the input
 *   element should be appended as a child. If string-valued, this argument
 *   will be treated as a CSS selector. If null or undefined, the parent
 *   element of this view will be used as the element.
 * @param {object} param - The binding parameters which specify the signal
 *   to bind to, the input element type, and type-specific configuration.
 * @return {View} - This view instance.
 */
function bind (view, el, binding) {
  if (!el) return;
  const param = binding.param;
  let bind = binding.state;
  if (!bind) {
    bind = binding.state = {
      elements: null,
      active: false,
      set: null,
      update: value => {
        if (value != view.signal(param.signal)) {
          view.runAsync(null, () => {
            bind.source = true;
            view.signal(param.signal, value);
          });
        }
      }
    };
    if (param.debounce) {
      bind.update = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce)(param.debounce, bind.update);
    }
  }
  const create = param.input == null && param.element ? target : generate;
  create(bind, el, param, view);
  if (!bind.active) {
    view.on(view._signals[param.signal], null, () => {
      bind.source ? bind.source = false : bind.set(view.signal(param.signal));
    });
    bind.active = true;
  }
  return bind;
}

/**
 * Bind the signal to an external EventTarget.
 */
function target(bind, node, param, view) {
  const type = param.event || 'input';
  const handler = () => bind.update(node.value);

  // initialize signal value to external input value
  view.signal(param.signal, node.value);

  // listen for changes on the element
  node.addEventListener(type, handler);

  // register with view, so we can remove it upon finalization
  trackEventListener(view, node, type, handler);

  // propagate change to element
  bind.set = value => {
    node.value = value;
    node.dispatchEvent(event(type));
  };
}
function event(type) {
  return typeof Event !== 'undefined' ? new Event(type) : {
    type
  };
}

/**
 * Generate an HTML input form element and bind it to a signal.
 */
function generate(bind, el, param, view) {
  const value = view.signal(param.signal);
  const div = element('div', {
    'class': BindClass
  });
  const wrapper = param.input === 'radio' ? div : div.appendChild(element('label'));
  wrapper.appendChild(element('span', {
    'class': NameClass
  }, param.name || param.signal));
  el.appendChild(div);
  let input = form;
  switch (param.input) {
    case 'checkbox':
      input = checkbox;
      break;
    case 'select':
      input = select;
      break;
    case 'radio':
      input = radio;
      break;
    case 'range':
      input = range;
      break;
  }
  input(bind, wrapper, param, value);
}

/**
 * Generates an arbitrary input form element.
 * The input type is controlled via user-provided parameters.
 */
function form(bind, el, param, value) {
  const node = element('input');
  for (const key in param) {
    if (key !== 'signal' && key !== 'element') {
      node.setAttribute(key === 'input' ? 'type' : key, param[key]);
    }
  }
  node.setAttribute('name', param.signal);
  node.value = value;
  el.appendChild(node);
  node.addEventListener('input', () => bind.update(node.value));
  bind.elements = [node];
  bind.set = value => node.value = value;
}

/**
 * Generates a checkbox input element.
 */
function checkbox(bind, el, param, value) {
  const attr = {
    type: 'checkbox',
    name: param.signal
  };
  if (value) attr.checked = true;
  const node = element('input', attr);
  el.appendChild(node);
  node.addEventListener('change', () => bind.update(node.checked));
  bind.elements = [node];
  bind.set = value => node.checked = !!value || null;
}

/**
 * Generates a selection list input element.
 */
function select(bind, el, param, value) {
  const node = element('select', {
      name: param.signal
    }),
    labels = param.labels || [];
  param.options.forEach((option, i) => {
    const attr = {
      value: option
    };
    if (valuesEqual(option, value)) attr.selected = true;
    node.appendChild(element('option', attr, (labels[i] || option) + ''));
  });
  el.appendChild(node);
  node.addEventListener('change', () => {
    bind.update(param.options[node.selectedIndex]);
  });
  bind.elements = [node];
  bind.set = value => {
    for (let i = 0, n = param.options.length; i < n; ++i) {
      if (valuesEqual(param.options[i], value)) {
        node.selectedIndex = i;
        return;
      }
    }
  };
}

/**
 * Generates a radio button group.
 */
function radio(bind, el, param, value) {
  const group = element('span', {
      'class': RadioClass
    }),
    labels = param.labels || [];
  el.appendChild(group);
  bind.elements = param.options.map((option, i) => {
    const attr = {
      type: 'radio',
      name: param.signal,
      value: option
    };
    if (valuesEqual(option, value)) attr.checked = true;
    const input = element('input', attr);
    input.addEventListener('change', () => bind.update(option));
    const label = element('label', {}, (labels[i] || option) + '');
    label.prepend(input);
    group.appendChild(label);
    return input;
  });
  bind.set = value => {
    const nodes = bind.elements,
      n = nodes.length;
    for (let i = 0; i < n; ++i) {
      if (valuesEqual(nodes[i].value, value)) nodes[i].checked = true;
    }
  };
}

/**
 * Generates a slider input element.
 */
function range(bind, el, param, value) {
  value = value !== undefined ? value : (+param.max + +param.min) / 2;
  const max = param.max != null ? param.max : Math.max(100, +value) || 100,
    min = param.min || Math.min(0, max, +value) || 0,
    step = param.step || (0,d3_array__WEBPACK_IMPORTED_MODULE_6__.tickStep)(min, max, 100);
  const node = element('input', {
    type: 'range',
    name: param.signal,
    min: min,
    max: max,
    step: step
  });
  node.value = value;
  const span = element('span', {}, +value);
  el.appendChild(node);
  el.appendChild(span);
  const update = () => {
    span.textContent = node.value;
    bind.update(+node.value);
  };

  // subscribe to both input and change
  node.addEventListener('input', update);
  node.addEventListener('change', update);
  bind.elements = [node];
  bind.set = value => {
    node.value = value;
    span.textContent = value;
  };
}
function valuesEqual(a, b) {
  return a === b || a + '' === b + '';
}

function initializeRenderer (view, r, el, constructor, scaleFactor, opt) {
  r = r || new constructor(view.loader());
  return r.initialize(el, width(view), height(view), offset(view), scaleFactor, opt).background(view.background());
}

function trap (view, fn) {
  return !fn ? null : function () {
    try {
      fn.apply(this, arguments);
    } catch (error) {
      view.error(error);
    }
  };
}

function initializeHandler (view, prevHandler, el, constructor) {
  // instantiate scenegraph handler
  const handler = new constructor(view.loader(), trap(view, view.tooltip())).scene(view.scenegraph().root).initialize(el, offset(view), view);

  // transfer event handlers
  if (prevHandler) {
    prevHandler.handlers().forEach(h => {
      handler.on(h.type, h.handler);
    });
  }
  return handler;
}

function initialize (el, elBind) {
  const view = this,
    type = view._renderType,
    config = view._eventConfig.bind,
    module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type);

  // containing dom element
  el = view._el = el ? lookup(view, el, true) : null;

  // initialize aria attributes
  initializeAria(view);

  // select appropriate renderer & handler
  if (!module) view.error('Unrecognized renderer type: ' + type);
  const Handler = module.handler || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler,
    Renderer = el ? module.renderer : module.headless;

  // initialize renderer and input handler
  view._renderer = !Renderer ? null : initializeRenderer(view, view._renderer, el, Renderer);
  view._handler = initializeHandler(view, view._handler, el, Handler);
  view._redraw = true;

  // initialize signal bindings
  if (el && config !== 'none') {
    elBind = elBind ? view._elBind = lookup(view, elBind, true) : el.appendChild(element('form', {
      'class': 'vega-bindings'
    }));
    view._bind.forEach(_ => {
      if (_.param.element && config !== 'container') {
        _.element = lookup(view, _.param.element, !!_.param.input);
      }
    });
    view._bind.forEach(_ => {
      bind(view, _.element || elBind, _);
    });
  }
  return view;
}
function lookup(view, el, clear) {
  if (typeof el === 'string') {
    if (typeof document !== 'undefined') {
      el = document.querySelector(el);
      if (!el) {
        view.error('Signal bind element not found: ' + el);
        return null;
      }
    } else {
      view.error('DOM document instance not found.');
      return null;
    }
  }
  if (el && clear) {
    try {
      el.textContent = '';
    } catch (e) {
      el = null;
      view.error(e);
    }
  }
  return el;
}

const number = _ => +_ || 0;
const paddingObject = _ => ({
  top: _,
  bottom: _,
  left: _,
  right: _
});
function padding (_) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(_) ? {
    top: number(_.top),
    bottom: number(_.bottom),
    left: number(_.left),
    right: number(_.right)
  } : paddingObject(number(_));
}

/**
 * Render the current scene in a headless fashion.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A Promise that resolves to a renderer.
 */
async function renderHeadless (view, type, scaleFactor, opt) {
  const module = (0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type),
    ctr = module && module.headless;
  if (!ctr) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);
  await view.runAsync();
  return initializeRenderer(view, null, null, ctr, scaleFactor, opt).renderAsync(view._scenegraph.root);
}

/**
 * Produce an image URL for the visualization. Depending on the type
 * parameter, the generated URL contains data for either a PNG or SVG image.
 * The URL can be used (for example) to download images of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @param {string} type - The image type. One of 'svg', 'png' or 'canvas'.
 *   The 'canvas' and 'png' types are synonyms for a PNG image.
 * @return {Promise} - A promise that resolves to an image URL.
 */
async function renderToImageURL (type, scaleFactor) {
  if (type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG && type !== vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.PNG) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized image type: ' + type);
  }
  const r = await renderHeadless(this, type, scaleFactor);
  return type === vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG ? toBlobURL(r.svg(), 'image/svg+xml') : r.canvas().toDataURL('image/png');
}
function toBlobURL(data, mime) {
  const blob = new Blob([data], {
    type: mime
  });
  return window.URL.createObjectURL(blob);
}

/**
 * Produce a Canvas instance containing a rendered visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to a Canvas instance.
 */
async function renderToCanvas (scaleFactor, opt) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas, scaleFactor, opt);
  return r.canvas();
}

/**
 * Produce a rendered SVG string of the visualization.
 * This method is asynchronous, returning a Promise instance.
 * @return {Promise} - A promise that resolves to an SVG string.
 */
async function renderToSVG (scaleFactor) {
  const r = await renderHeadless(this, vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.SVG, scaleFactor);
  return r.svg();
}

function runtime (view, spec, expr) {
  return (0,vega_runtime__WEBPACK_IMPORTED_MODULE_4__.context)(view, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_functions__WEBPACK_IMPORTED_MODULE_3__.functionContext, expr).parse(spec);
}

function scale(name) {
  var scales = this._runtime.scales;
  if (!(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(scales, name)) {
    (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized scale or projection: ' + name);
  }
  return scales[name].value;
}

var Width = 'width',
  Height = 'height',
  Padding = 'padding',
  Skip = {
    skip: true
  };
function viewWidth(view, width) {
  var a = view.autosize(),
    p = view.padding();
  return width - (a && a.contains === Padding ? p.left + p.right : 0);
}
function viewHeight(view, height) {
  var a = view.autosize(),
    p = view.padding();
  return height - (a && a.contains === Padding ? p.top + p.bottom : 0);
}
function initializeResize(view) {
  var s = view._signals,
    w = s[Width],
    h = s[Height],
    p = s[Padding];
  function resetSize() {
    view._autosize = view._resize = 1;
  }

  // respond to width signal
  view._resizeWidth = view.add(null, _ => {
    view._width = _.size;
    view._viewWidth = viewWidth(view, _.size);
    resetSize();
  }, {
    size: w
  });

  // respond to height signal
  view._resizeHeight = view.add(null, _ => {
    view._height = _.size;
    view._viewHeight = viewHeight(view, _.size);
    resetSize();
  }, {
    size: h
  });

  // respond to padding signal
  const resizePadding = view.add(null, resetSize, {
    pad: p
  });

  // set rank to run immediately after source signal
  view._resizeWidth.rank = w.rank + 1;
  view._resizeHeight.rank = h.rank + 1;
  resizePadding.rank = p.rank + 1;
}
function resizeView(viewWidth, viewHeight, width, height, origin, auto) {
  this.runAfter(view => {
    let rerun = 0;

    // reset autosize flag
    view._autosize = 0;

    // width value changed: update signal, skip resize op
    if (view.width() !== width) {
      rerun = 1;
      view.signal(Width, width, Skip); // set width, skip update calc
      view._resizeWidth.skip(true); // skip width resize handler
    }

    // height value changed: update signal, skip resize op
    if (view.height() !== height) {
      rerun = 1;
      view.signal(Height, height, Skip); // set height, skip update calc
      view._resizeHeight.skip(true); // skip height resize handler
    }

    // view width changed: update view property, set resize flag
    if (view._viewWidth !== viewWidth) {
      view._resize = 1;
      view._viewWidth = viewWidth;
    }

    // view height changed: update view property, set resize flag
    if (view._viewHeight !== viewHeight) {
      view._resize = 1;
      view._viewHeight = viewHeight;
    }

    // origin changed: update view property, set resize flag
    if (view._origin[0] !== origin[0] || view._origin[1] !== origin[1]) {
      view._resize = 1;
      view._origin = origin;
    }

    // run dataflow on width/height signal change
    if (rerun) view.run('enter');
    if (auto) view.runAfter(v => v.resize());
  }, false, 1);
}

/**
 * Get the current view state, consisting of signal values and/or data sets.
 * @param {object} [options] - Options flags indicating which state to export.
 *   If unspecified, all signals and data sets will be exported.
 * @param {function(string, Operator):boolean} [options.signals] - Optional
 *   predicate function for testing if a signal should be included in the
 *   exported state. If unspecified, all signals will be included, except for
 *   those named 'parent' or those which refer to a Transform value.
 * @param {function(string, object):boolean} [options.data] - Optional
 *   predicate function for testing if a data set's input should be included
 *   in the exported state. If unspecified, all data sets that have been
 *   explicitly modified will be included.
 * @param {boolean} [options.recurse=true] - Flag indicating if the exported
 *   state should recursively include state from group mark sub-contexts.
 * @return {object} - An object containing the exported state values.
 */
function getState(options) {
  return this._runtime.getState(options || {
    data: dataTest,
    signals: signalTest,
    recurse: true
  });
}
function dataTest(name, data) {
  return data.modified && (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(data.input.value) && !name.startsWith('_:vega:_');
}
function signalTest(name, op) {
  return !(name === 'parent' || op instanceof vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms.proxy);
}

/**
 * Sets the current view state and updates the view by invoking run.
 * @param {object} state - A state object containing signal and/or
 *   data set values, following the format used by the getState method.
 * @return {View} - This view instance.
 */
function setState(state) {
  this.runAsync(null, v => {
    v._trigger = false;
    v._runtime.setState(state);
  }, v => {
    v._trigger = true;
  });
  return this;
}

function timer (callback, delay) {
  function tick(elapsed) {
    callback({
      timestamp: Date.now(),
      elapsed: elapsed
    });
  }
  this._timers.push((0,d3_timer__WEBPACK_IMPORTED_MODULE_7__["default"])(tick, delay));
}

function defaultTooltip (handler, event, item, value) {
  const el = handler.element();
  if (el) el.setAttribute('title', formatTooltip(value));
}
function formatTooltip(value) {
  return value == null ? '' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? formatArray(value) : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? formatObject(value) : value + '';
}
function formatObject(obj) {
  return Object.keys(obj).map(key => {
    const v = obj[key];
    return key + ': ' + ((0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(v) ? formatArray(v) : formatValue(v));
  }).join('\n');
}
function formatArray(value) {
  return '[' + value.map(formatValue).join(', ') + ']';
}
function formatValue(value) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray)(value) ? '[\u2026]' : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && !(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate)(value) ? '{\u2026}' : value;
}

function watchPixelRatio () {
  // based on https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio#monitoring_screen_resolution_or_zoom_level_changes
  if (this.renderer() === 'canvas' && this._renderer._canvas) {
    let remove = null;
    const updatePixelRatio = () => {
      if (remove != null) {
        remove();
      }
      const media = matchMedia(`(resolution: ${window.devicePixelRatio}dppx)`);
      media.addEventListener('change', updatePixelRatio);
      remove = () => {
        media.removeEventListener('change', updatePixelRatio);
      };
      this._renderer._canvas.getContext('2d').pixelRatio = window.devicePixelRatio || 1;
      this._redraw = true;
      this._resize = 1;
      this.resize().runAsync();
    };
    updatePixelRatio();
  }
}

/**
 * Create a new View instance from a Vega dataflow runtime specification.
 * The generated View will not immediately be ready for display. Callers
 * should also invoke the initialize method (e.g., to set the parent
 * DOM element in browser-based deployment) and then invoke the run
 * method to evaluate the dataflow graph. Rendering will automatically
 * be performed upon dataflow runs.
 * @constructor
 * @param {object} spec - The Vega dataflow runtime specification.
 */
function View(spec, options) {
  const view = this;
  options = options || {};
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.call(view);
  if (options.loader) view.loader(options.loader);
  if (options.logger) view.logger(options.logger);
  if (options.logLevel != null) view.logLevel(options.logLevel);
  if (options.locale || spec.locale) {
    const loc = (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, spec.locale, options.locale);
    view.locale((0,vega_format__WEBPACK_IMPORTED_MODULE_5__.locale)(loc.number, loc.time));
  }
  view._el = null;
  view._elBind = null;
  view._renderType = options.renderer || vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.RenderType.Canvas;
  view._scenegraph = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.Scenegraph();
  const root = view._scenegraph.root;

  // initialize renderer, handler and event management
  view._renderer = null;
  view._tooltip = options.tooltip || defaultTooltip, view._redraw = true;
  view._handler = new vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.CanvasHandler().scene(root);
  view._globalCursor = false;
  view._preventDefault = false;
  view._timers = [];
  view._eventListeners = [];
  view._resizeListeners = [];

  // initialize event configuration
  view._eventConfig = initializeEventConfig(spec.eventConfig);
  view.globalCursor(view._eventConfig.globalCursor);

  // initialize dataflow graph
  const ctx = runtime(view, spec, options.expr);
  view._runtime = ctx;
  view._signals = ctx.signals;
  view._bind = (spec.bindings || []).map(_ => ({
    state: null,
    param: (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)({}, _)
  }));

  // initialize scenegraph
  if (ctx.root) ctx.root.set(root);
  root.source = ctx.data.root.input;
  view.pulse(ctx.data.root.input, view.changeset().insert(root.items));

  // initialize view size
  view._width = view.width();
  view._height = view.height();
  view._viewWidth = viewWidth(view, view._width);
  view._viewHeight = viewHeight(view, view._height);
  view._origin = [0, 0];
  view._resize = 0;
  view._autosize = 1;
  initializeResize(view);

  // initialize background color
  background(view);

  // initialize cursor
  cursor(view);

  // initialize view description
  view.description(spec.description);

  // initialize hover proessing, if requested
  if (options.hover) view.hover();

  // initialize DOM container(s) and renderer
  if (options.container) view.initialize(options.container, options.bind);
  if (options.watchPixelRatio) view._watchPixelRatio();
}
function lookupSignal(view, name) {
  return (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty)(view._signals, name) ? view._signals[name] : (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized signal name: ' + (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue)(name));
}
function findOperatorHandler(op, handler) {
  const h = (op._targets || []).filter(op => op._update && op._update.handler === handler);
  return h.length ? h[0] : null;
}
function addOperatorListener(view, name, op, handler) {
  let h = findOperatorHandler(op, handler);
  if (!h) {
    h = trap(view, () => handler(name, op.value));
    h.handler = handler;
    view.on(op, null, h);
  }
  return view;
}
function removeOperatorListener(view, op, handler) {
  const h = findOperatorHandler(op, handler);
  if (h) op._targets.remove(h);
  return view;
}
(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits)(View, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow, {
  // -- DATAFLOW / RENDERING ----

  async evaluate(encode, prerun, postrun) {
    // evaluate dataflow and prerun
    await vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.evaluate.call(this, encode, prerun);

    // render as needed
    if (this._redraw || this._resize) {
      try {
        if (this._renderer) {
          if (this._resize) {
            this._resize = 0;
            resizeRenderer(this);
          }
          await this._renderer.renderAsync(this._scenegraph.root);
        }
        this._redraw = false;
      } catch (e) {
        this.error(e);
      }
    }

    // evaluate postrun
    if (postrun) (0,vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.asyncCallback)(this, postrun);
    return this;
  },
  dirty(item) {
    this._redraw = true;
    this._renderer && this._renderer.dirty(item);
  },
  // -- GET / SET ----

  description(text) {
    if (arguments.length) {
      const desc = text != null ? text + '' : null;
      if (desc !== this._desc) ariaLabel(this._el, this._desc = desc);
      return this;
    }
    return this._desc;
  },
  container() {
    return this._el;
  },
  scenegraph() {
    return this._scenegraph;
  },
  origin() {
    return this._origin.slice();
  },
  signal(name, value, options) {
    const op = lookupSignal(this, name);
    return arguments.length === 1 ? op.value : this.update(op, value, options);
  },
  width(_) {
    return arguments.length ? this.signal('width', _) : this.signal('width');
  },
  height(_) {
    return arguments.length ? this.signal('height', _) : this.signal('height');
  },
  padding(_) {
    return arguments.length ? this.signal('padding', padding(_)) : padding(this.signal('padding'));
  },
  autosize(_) {
    return arguments.length ? this.signal('autosize', _) : this.signal('autosize');
  },
  background(_) {
    return arguments.length ? this.signal('background', _) : this.signal('background');
  },
  renderer(type) {
    if (!arguments.length) return this._renderType;
    if (!(0,vega_scenegraph__WEBPACK_IMPORTED_MODULE_2__.renderModule)(type)) (0,vega_util__WEBPACK_IMPORTED_MODULE_0__.error)('Unrecognized renderer type: ' + type);
    if (type !== this._renderType) {
      this._renderType = type;
      this._resetRenderer();
    }
    return this;
  },
  tooltip(handler) {
    if (!arguments.length) return this._tooltip;
    if (handler !== this._tooltip) {
      this._tooltip = handler;
      this._resetRenderer();
    }
    return this;
  },
  loader(loader) {
    if (!arguments.length) return this._loader;
    if (loader !== this._loader) {
      vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow.prototype.loader.call(this, loader);
      this._resetRenderer();
    }
    return this;
  },
  resize() {
    // set flag to perform autosize
    this._autosize = 1;
    // touch autosize signal to ensure top-level ViewLayout runs
    return this.touch(lookupSignal(this, 'autosize'));
  },
  _resetRenderer() {
    if (this._renderer) {
      this._renderer = null;
      this.initialize(this._el, this._elBind);
    }
  },
  // -- SIZING ----
  _resizeView: resizeView,
  // -- EVENT HANDLING ----

  addEventListener(type, handler, options) {
    let callback = handler;
    if (!(options && options.trap === false)) {
      // wrap callback in error handler
      callback = trap(this, handler);
      callback.raw = handler;
    }
    this._handler.on(type, callback);
    return this;
  },
  removeEventListener(type, handler) {
    var handlers = this._handler.handlers(type),
      i = handlers.length,
      h,
      t;

    // search registered handlers, remove if match found
    while (--i >= 0) {
      t = handlers[i].type;
      h = handlers[i].handler;
      if (type === t && (handler === h || handler === h.raw)) {
        this._handler.off(t, h);
        break;
      }
    }
    return this;
  },
  addResizeListener(handler) {
    const l = this._resizeListeners;
    if (!l.includes(handler)) {
      // add handler if it isn't already registered
      // note: error trapping handled elsewhere, so
      // no need to wrap handlers here
      l.push(handler);
    }
    return this;
  },
  removeResizeListener(handler) {
    var l = this._resizeListeners,
      i = l.indexOf(handler);
    if (i >= 0) {
      l.splice(i, 1);
    }
    return this;
  },
  addSignalListener(name, handler) {
    return addOperatorListener(this, name, lookupSignal(this, name), handler);
  },
  removeSignalListener(name, handler) {
    return removeOperatorListener(this, lookupSignal(this, name), handler);
  },
  addDataListener(name, handler) {
    return addOperatorListener(this, name, dataref(this, name).values, handler);
  },
  removeDataListener(name, handler) {
    return removeOperatorListener(this, dataref(this, name).values, handler);
  },
  globalCursor(_) {
    if (arguments.length) {
      if (this._globalCursor !== !!_) {
        const prev = setCursor(this, null); // clear previous cursor
        this._globalCursor = !!_;
        if (prev) setCursor(this, prev); // swap cursor
      }
      return this;
    } else {
      return this._globalCursor;
    }
  },
  preventDefault(_) {
    if (arguments.length) {
      this._preventDefault = _;
      return this;
    } else {
      return this._preventDefault;
    }
  },
  timer,
  events,
  finalize,
  hover,
  // -- DATA ----
  data,
  change,
  insert,
  remove,
  // -- SCALES --
  scale,
  // -- INITIALIZATION ----
  initialize,
  // -- HEADLESS RENDERING ----
  toImageURL: renderToImageURL,
  toCanvas: renderToCanvas,
  toSVG: renderToSVG,
  // -- SAVE / RESTORE STATE ----
  getState,
  setState,
  // RE-RENDER ON ZOOM
  _watchPixelRatio: watchPixelRatio
});




/***/ }),

/***/ "./node_modules/vega-voronoi/build/vega-voronoi.module.js":
/*!****************************************************************!*\
  !*** ./node_modules/vega-voronoi/build/vega-voronoi.module.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   voronoi: () => (/* binding */ Voronoi)
/* harmony export */ });
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var d3_delaunay__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-delaunay */ "./node_modules/d3-delaunay/src/delaunay.js");




function Voronoi(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform.call(this, null, params);
}
Voronoi.Definition = {
  'type': 'Voronoi',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'x',
    'type': 'field',
    'required': true
  }, {
    'name': 'y',
    'type': 'field',
    'required': true
  }, {
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'extent',
    'type': 'array',
    'array': true,
    'length': 2,
    'default': [[-1e5, -1e5], [1e5, 1e5]],
    'content': {
      'type': 'number',
      'array': true,
      'length': 2
    }
  }, {
    'name': 'as',
    'type': 'string',
    'default': 'path'
  }]
};
const defaultExtent = [-1e5, -1e5, 1e5, 1e5];
(0,vega_util__WEBPACK_IMPORTED_MODULE_1__.inherits)(Voronoi, vega_dataflow__WEBPACK_IMPORTED_MODULE_0__.Transform, {
  transform(_, pulse) {
    const as = _.as || 'path',
      data = pulse.source;

    // nothing to do if no data
    if (!data || !data.length) return pulse;

    // configure and construct voronoi diagram
    let s = _.size;
    s = s ? [0, 0, s[0], s[1]] : (s = _.extent) ? [s[0][0], s[0][1], s[1][0], s[1][1]] : defaultExtent;
    const voronoi = this.value = d3_delaunay__WEBPACK_IMPORTED_MODULE_2__["default"].from(data, _.x, _.y).voronoi(s);

    // map polygons to paths
    for (let i = 0, n = data.length; i < n; ++i) {
      const polygon = voronoi.cellPolygon(i);
      data[i][as] = polygon && !isPoint(polygon) ? toPathString(polygon) : null;
    }
    return pulse.reflow(_.modified()).modifies(as);
  }
});

// suppress duplicated end point vertices
function toPathString(p) {
  const x = p[0][0],
    y = p[0][1];
  let n = p.length - 1;
  for (; p[n][0] === x && p[n][1] === y; --n);
  return 'M' + p.slice(0, n + 1).join('L') + 'Z';
}
function isPoint(p) {
  return p.length === 2 && p[0][0] === p[1][0] && p[0][1] === p[1][1];
}




/***/ }),

/***/ "./node_modules/vega-wordcloud/build/vega-wordcloud.module.js":
/*!********************************************************************!*\
  !*** ./node_modules/vega-wordcloud/build/vega-wordcloud.module.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   wordcloud: () => (/* binding */ Wordcloud)
/* harmony export */ });
/* harmony import */ var vega_canvas__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-canvas */ "./node_modules/vega-canvas/build/vega-canvas.browser.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");






/*
Copyright (c) 2013, Jason Davies.
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.

  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

  * The name Jason Davies may not be used to endorse or promote products
    derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL JASON DAVIES BE LIABLE FOR ANY DIRECT, INDIRECT,
INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/

// Word cloud layout by Jason Davies, https://www.jasondavies.com/wordcloud/
// Algorithm due to Jonathan Feinberg, http://static.mrfeinberg.com/bv_ch03.pdf

var cloudRadians = Math.PI / 180,
  cw = 1 << 11 >> 5,
  ch = 1 << 11;
function cloud () {
  var size = [256, 256],
    text,
    font,
    fontSize,
    fontStyle,
    fontWeight,
    rotate,
    padding,
    spiral = archimedeanSpiral,
    words = [],
    random = Math.random,
    cloud = {};
  cloud.layout = function () {
    var contextAndRatio = getContext((0,vega_canvas__WEBPACK_IMPORTED_MODULE_0__.canvas)()),
      board = zeroArray((size[0] >> 5) * size[1]),
      bounds = null,
      n = words.length,
      i = -1,
      tags = [],
      data = words.map(d => ({
        text: text(d),
        font: font(d),
        style: fontStyle(d),
        weight: fontWeight(d),
        rotate: rotate(d),
        size: ~~(fontSize(d) + 1e-14),
        padding: padding(d),
        xoff: 0,
        yoff: 0,
        x1: 0,
        y1: 0,
        x0: 0,
        y0: 0,
        hasText: false,
        sprite: null,
        datum: d
      })).sort((a, b) => b.size - a.size);
    while (++i < n) {
      var d = data[i];
      d.x = size[0] * (random() + .5) >> 1;
      d.y = size[1] * (random() + .5) >> 1;
      cloudSprite(contextAndRatio, d, data, i);
      if (d.hasText && place(board, d, bounds)) {
        tags.push(d);
        if (bounds) cloudBounds(bounds, d);else bounds = [{
          x: d.x + d.x0,
          y: d.y + d.y0
        }, {
          x: d.x + d.x1,
          y: d.y + d.y1
        }];
        // Temporary hack
        d.x -= size[0] >> 1;
        d.y -= size[1] >> 1;
      }
    }
    return tags;
  };
  function getContext(canvas) {
    canvas.width = canvas.height = 1;
    var ratio = Math.sqrt(canvas.getContext('2d').getImageData(0, 0, 1, 1).data.length >> 2);
    canvas.width = (cw << 5) / ratio;
    canvas.height = ch / ratio;
    var context = canvas.getContext('2d');
    context.fillStyle = context.strokeStyle = 'red';
    context.textAlign = 'center';
    return {
      context: context,
      ratio: ratio
    };
  }
  function place(board, tag, bounds) {
    var startX = tag.x,
      startY = tag.y,
      maxDelta = Math.hypot(size[0], size[1]),
      s = spiral(size),
      dt = random() < .5 ? 1 : -1,
      t = -dt,
      dxdy,
      dx,
      dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta) break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size[0] || tag.y + tag.y1 > size[1]) continue;
      // TODO only check for collisions within current bounds.
      if (!bounds || !cloudCollide(tag, board, size[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite,
            w = tag.width >> 5,
            sw = size[0] >> 5,
            lx = tag.x - (w << 4),
            sx = lx & 0x7f,
            msx = 32 - sx,
            h = tag.y1 - tag.y0,
            x = (tag.y + tag.y0) * sw + (lx >> 5),
            last;
          for (var j = 0; j < h; j++) {
            last = 0;
            for (var i = 0; i <= w; i++) {
              board[x + i] |= last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0);
            }
            x += sw;
          }
          tag.sprite = null;
          return true;
        }
      }
    }
    return false;
  }
  cloud.words = function (_) {
    if (arguments.length) {
      words = _;
      return cloud;
    } else {
      return words;
    }
  };
  cloud.size = function (_) {
    if (arguments.length) {
      size = [+_[0], +_[1]];
      return cloud;
    } else {
      return size;
    }
  };
  cloud.font = function (_) {
    if (arguments.length) {
      font = functor(_);
      return cloud;
    } else {
      return font;
    }
  };
  cloud.fontStyle = function (_) {
    if (arguments.length) {
      fontStyle = functor(_);
      return cloud;
    } else {
      return fontStyle;
    }
  };
  cloud.fontWeight = function (_) {
    if (arguments.length) {
      fontWeight = functor(_);
      return cloud;
    } else {
      return fontWeight;
    }
  };
  cloud.rotate = function (_) {
    if (arguments.length) {
      rotate = functor(_);
      return cloud;
    } else {
      return rotate;
    }
  };
  cloud.text = function (_) {
    if (arguments.length) {
      text = functor(_);
      return cloud;
    } else {
      return text;
    }
  };
  cloud.spiral = function (_) {
    if (arguments.length) {
      spiral = spirals[_] || _;
      return cloud;
    } else {
      return spiral;
    }
  };
  cloud.fontSize = function (_) {
    if (arguments.length) {
      fontSize = functor(_);
      return cloud;
    } else {
      return fontSize;
    }
  };
  cloud.padding = function (_) {
    if (arguments.length) {
      padding = functor(_);
      return cloud;
    } else {
      return padding;
    }
  };
  cloud.random = function (_) {
    if (arguments.length) {
      random = _;
      return cloud;
    } else {
      return random;
    }
  };
  return cloud;
}

// Fetches a monochrome sprite bitmap for the specified text.
// Load in batches for speed.
function cloudSprite(contextAndRatio, d, data, di) {
  if (d.sprite) return;
  var c = contextAndRatio.context,
    ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0,
    y = 0,
    maxh = 0,
    n = data.length,
    w,
    w32,
    h,
    i,
    j;
  --di;
  while (++di < n) {
    d = data[di];
    c.save();
    c.font = d.style + ' ' + d.weight + ' ' + ~~((d.size + 1) / ratio) + 'px ' + d.font;
    w = c.measureText(d.text + 'm').width * ratio;
    h = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians),
        cr = Math.cos(d.rotate * cloudRadians),
        wcr = w * cr,
        wsr = w * sr,
        hcr = h * cr,
        hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 0x1f >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 0x1f >> 5 << 5;
    }
    if (h > maxh) maxh = h;
    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }
    if (y + h >= ch) break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate) c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }
    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data,
    sprite = [];
  while (--di >= 0) {
    d = data[di];
    if (!d.hasText) continue;
    w = d.width;
    w32 = w >> 5;
    h = d.y1 - d.y0;
    // Zero the buffer
    for (i = 0; i < h * w32; i++) sprite[i] = 0;
    x = d.xoff;
    if (x == null) return;
    y = d.yoff;
    var seen = 0,
      seenRow = -1;
    for (j = 0; j < h; j++) {
      for (i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5),
          m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }
      if (seen) seenRow = j;else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}

// Use mask-based collision detection.
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite,
    w = tag.width >> 5,
    lx = tag.x - (w << 4),
    sx = lx & 0x7f,
    msx = 32 - sx,
    h = tag.y1 - tag.y0,
    x = (tag.y + tag.y0) * sw + (lx >> 5),
    last;
  for (var j = 0; j < h; j++) {
    last = 0;
    for (var i = 0; i <= w; i++) {
      if ((last << msx | (i < w ? (last = sprite[j * w + i]) >>> sx : 0)) & board[x + i]) return true;
    }
    x += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  var b0 = bounds[0],
    b1 = bounds[1];
  if (d.x + d.x0 < b0.x) b0.x = d.x + d.x0;
  if (d.y + d.y0 < b0.y) b0.y = d.y + d.y0;
  if (d.x + d.x1 > b1.x) b1.x = d.x + d.x1;
  if (d.y + d.y1 > b1.y) b1.y = d.y + d.y1;
}
function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size) {
  var e = size[0] / size[1];
  return function (t) {
    return [e * (t *= .1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size) {
  var dy = 4,
    dx = dy * size[0] / size[1],
    x = 0,
    y = 0;
  return function (t) {
    var sign = t < 0 ? -1 : 1;
    // See triangular numbers: T_n = n * (n + 1) / 2.
    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;
      case 1:
        y += dy;
        break;
      case 2:
        x -= dx;
        break;
      default:
        y -= dy;
        break;
    }
    return [x, y];
  };
}

// TODO reuse arrays?
function zeroArray(n) {
  var a = [],
    i = -1;
  while (++i < n) a[i] = 0;
  return a;
}
function functor(d) {
  return typeof d === 'function' ? d : function () {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};

const Output = ['x', 'y', 'font', 'fontSize', 'fontStyle', 'fontWeight', 'angle'];
const Params = ['text', 'font', 'rotate', 'fontSize', 'fontStyle', 'fontWeight'];
function Wordcloud(params) {
  vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform.call(this, cloud(), params);
}
Wordcloud.Definition = {
  'type': 'Wordcloud',
  'metadata': {
    'modifies': true
  },
  'params': [{
    'name': 'size',
    'type': 'number',
    'array': true,
    'length': 2
  }, {
    'name': 'font',
    'type': 'string',
    'expr': true,
    'default': 'sans-serif'
  }, {
    'name': 'fontStyle',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontWeight',
    'type': 'string',
    'expr': true,
    'default': 'normal'
  }, {
    'name': 'fontSize',
    'type': 'number',
    'expr': true,
    'default': 14
  }, {
    'name': 'fontSizeRange',
    'type': 'number',
    'array': 'nullable',
    'default': [10, 50]
  }, {
    'name': 'rotate',
    'type': 'number',
    'expr': true,
    'default': 0
  }, {
    'name': 'text',
    'type': 'field'
  }, {
    'name': 'spiral',
    'type': 'string',
    'values': ['archimedean', 'rectangular']
  }, {
    'name': 'padding',
    'type': 'number',
    'expr': true
  }, {
    'name': 'as',
    'type': 'string',
    'array': true,
    'length': 7,
    'default': Output
  }]
};
(0,vega_util__WEBPACK_IMPORTED_MODULE_2__.inherits)(Wordcloud, vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform, {
  transform(_, pulse) {
    if (_.size && !(_.size[0] && _.size[1])) {
      (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.error)('Wordcloud size dimensions must be non-zero.');
    }
    function modp(param) {
      const p = _[param];
      return (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(p) && pulse.modified(p.fields);
    }
    const mod = _.modified();
    if (!(mod || pulse.changed(pulse.ADD_REM) || Params.some(modp))) return;
    const data = pulse.materialize(pulse.SOURCE).source,
      layout = this.value,
      as = _.as || Output;
    let fontSize = _.fontSize || 14,
      range;
    (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.isFunction)(fontSize) ? range = _.fontSizeRange : fontSize = (0,vega_util__WEBPACK_IMPORTED_MODULE_2__.constant)(fontSize);

    // create font size scaling function as needed
    if (range) {
      const fsize = fontSize,
        sizeScale = (0,vega_scale__WEBPACK_IMPORTED_MODULE_3__.scale)('sqrt')().domain((0,vega_util__WEBPACK_IMPORTED_MODULE_2__.extent)(data, fsize)).range(range);
      fontSize = x => sizeScale(fsize(x));
    }
    data.forEach(t => {
      t[as[0]] = NaN;
      t[as[1]] = NaN;
      t[as[3]] = 0;
    });

    // configure layout
    const words = layout.words(data).text(_.text).size(_.size || [500, 500]).padding(_.padding || 1).spiral(_.spiral || 'archimedean').rotate(_.rotate || 0).font(_.font || 'sans-serif').fontStyle(_.fontStyle || 'normal').fontWeight(_.fontWeight || 'normal').fontSize(fontSize).random(vega_statistics__WEBPACK_IMPORTED_MODULE_4__.random).layout();
    const size = layout.size(),
      dx = size[0] >> 1,
      dy = size[1] >> 1,
      n = words.length;
    for (let i = 0, w, t; i < n; ++i) {
      w = words[i];
      t = w.datum;
      t[as[0]] = w.x + dx;
      t[as[1]] = w.y + dy;
      t[as[2]] = w.font;
      t[as[3]] = w.size;
      t[as[4]] = w.style;
      t[as[5]] = w.weight;
      t[as[6]] = w.rotate;
    }
    return pulse.reflow(mod).modifies(as);
  }
});




/***/ }),

/***/ "./node_modules/vega/build/vega.module.js":
/*!************************************************!*\
  !*** ./node_modules/vega/build/vega.module.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Bounds: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Bounds),
/* harmony export */   CanvasHandler: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasHandler),
/* harmony export */   CanvasRenderer: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.CanvasRenderer),
/* harmony export */   DATE: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DATE),
/* harmony export */   DAY: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAY),
/* harmony export */   DAYOFYEAR: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.DAYOFYEAR),
/* harmony export */   Dataflow: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Dataflow),
/* harmony export */   Debug: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Debug),
/* harmony export */   Error: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Error),
/* harmony export */   EventStream: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.EventStream),
/* harmony export */   Gradient: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Gradient),
/* harmony export */   GroupItem: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.GroupItem),
/* harmony export */   HOURS: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.HOURS),
/* harmony export */   Handler: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Handler),
/* harmony export */   HybridHandler: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.HybridHandler),
/* harmony export */   HybridRenderer: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.HybridRenderer),
/* harmony export */   Info: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Info),
/* harmony export */   Item: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Item),
/* harmony export */   MILLISECONDS: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MILLISECONDS),
/* harmony export */   MINUTES: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MINUTES),
/* harmony export */   MONTH: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.MONTH),
/* harmony export */   Marks: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Marks),
/* harmony export */   MultiPulse: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.MultiPulse),
/* harmony export */   None: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.None),
/* harmony export */   Operator: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Operator),
/* harmony export */   Parameters: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Parameters),
/* harmony export */   Pulse: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Pulse),
/* harmony export */   QUARTER: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.QUARTER),
/* harmony export */   RenderType: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.RenderType),
/* harmony export */   Renderer: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Renderer),
/* harmony export */   ResourceLoader: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.ResourceLoader),
/* harmony export */   SECONDS: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.SECONDS),
/* harmony export */   SVGHandler: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGHandler),
/* harmony export */   SVGRenderer: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGRenderer),
/* harmony export */   SVGStringRenderer: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.SVGStringRenderer),
/* harmony export */   Scenegraph: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.Scenegraph),
/* harmony export */   TIME_UNITS: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.TIME_UNITS),
/* harmony export */   Transform: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.Transform),
/* harmony export */   View: () => (/* reexport safe */ vega_view__WEBPACK_IMPORTED_MODULE_19__.View),
/* harmony export */   WEEK: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.WEEK),
/* harmony export */   Warn: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.Warn),
/* harmony export */   YEAR: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.YEAR),
/* harmony export */   accessor: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessor),
/* harmony export */   accessorFields: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorFields),
/* harmony export */   accessorName: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.accessorName),
/* harmony export */   array: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.array),
/* harmony export */   ascending: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.ascending),
/* harmony export */   bandwidthNRD: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bandwidthNRD),
/* harmony export */   bin: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bin),
/* harmony export */   bootstrapCI: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.bootstrapCI),
/* harmony export */   boundClip: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundClip),
/* harmony export */   boundContext: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundContext),
/* harmony export */   boundItem: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundItem),
/* harmony export */   boundMark: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundMark),
/* harmony export */   boundStroke: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.boundStroke),
/* harmony export */   changeset: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.changeset),
/* harmony export */   clampRange: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.clampRange),
/* harmony export */   codegenExpression: () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.codegenExpression),
/* harmony export */   compare: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.compare),
/* harmony export */   constant: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.constant),
/* harmony export */   cumulativeLogNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeLogNormal),
/* harmony export */   cumulativeNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeNormal),
/* harmony export */   cumulativeUniform: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.cumulativeUniform),
/* harmony export */   dayofyear: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.dayofyear),
/* harmony export */   debounce: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.debounce),
/* harmony export */   defaultLocale: () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.defaultLocale),
/* harmony export */   definition: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.definition),
/* harmony export */   densityLogNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityLogNormal),
/* harmony export */   densityNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityNormal),
/* harmony export */   densityUniform: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.densityUniform),
/* harmony export */   domChild: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domChild),
/* harmony export */   domClear: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domClear),
/* harmony export */   domCreate: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domCreate),
/* harmony export */   domFind: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.domFind),
/* harmony export */   dotbin: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.dotbin),
/* harmony export */   error: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.error),
/* harmony export */   expressionFunction: () => (/* reexport safe */ vega_functions__WEBPACK_IMPORTED_MODULE_21__.expressionFunction),
/* harmony export */   extend: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extend),
/* harmony export */   extent: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extent),
/* harmony export */   extentIndex: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.extentIndex),
/* harmony export */   falsy: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.falsy),
/* harmony export */   fastmap: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.fastmap),
/* harmony export */   field: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.field),
/* harmony export */   flush: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.flush),
/* harmony export */   font: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.font),
/* harmony export */   fontFamily: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontFamily),
/* harmony export */   fontSize: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.fontSize),
/* harmony export */   format: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.format),
/* harmony export */   formatLocale: () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.numberFormatDefaultLocale),
/* harmony export */   formats: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.formats),
/* harmony export */   hasOwnProperty: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.hasOwnProperty),
/* harmony export */   id: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.id),
/* harmony export */   identity: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.identity),
/* harmony export */   inferType: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferType),
/* harmony export */   inferTypes: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.inferTypes),
/* harmony export */   ingest: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.ingest),
/* harmony export */   inherits: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inherits),
/* harmony export */   inrange: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.inrange),
/* harmony export */   interpolate: () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolate),
/* harmony export */   interpolateColors: () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateColors),
/* harmony export */   interpolateRange: () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.interpolateRange),
/* harmony export */   intersect: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersect),
/* harmony export */   intersectBoxLine: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectBoxLine),
/* harmony export */   intersectPath: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPath),
/* harmony export */   intersectPoint: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectPoint),
/* harmony export */   intersectRule: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.intersectRule),
/* harmony export */   isArray: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isArray),
/* harmony export */   isBoolean: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isBoolean),
/* harmony export */   isDate: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isDate),
/* harmony export */   isFunction: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isFunction),
/* harmony export */   isIterable: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isIterable),
/* harmony export */   isNumber: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isNumber),
/* harmony export */   isObject: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isObject),
/* harmony export */   isRegExp: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isRegExp),
/* harmony export */   isString: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.isString),
/* harmony export */   isTuple: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.isTuple),
/* harmony export */   key: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.key),
/* harmony export */   lerp: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lerp),
/* harmony export */   lineHeight: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.lineHeight),
/* harmony export */   loader: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.loader),
/* harmony export */   locale: () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.locale),
/* harmony export */   logger: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.logger),
/* harmony export */   lruCache: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.lruCache),
/* harmony export */   markup: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.markup),
/* harmony export */   merge: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.merge),
/* harmony export */   mergeConfig: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.mergeConfig),
/* harmony export */   multiLineOffset: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.multiLineOffset),
/* harmony export */   one: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.one),
/* harmony export */   pad: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.pad),
/* harmony export */   panLinear: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLinear),
/* harmony export */   panLog: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panLog),
/* harmony export */   panPow: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panPow),
/* harmony export */   panSymlog: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.panSymlog),
/* harmony export */   parse: () => (/* reexport safe */ vega_parser__WEBPACK_IMPORTED_MODULE_22__.parse),
/* harmony export */   parseExpression: () => (/* reexport safe */ vega_expression__WEBPACK_IMPORTED_MODULE_24__.parseExpression),
/* harmony export */   parseSelector: () => (/* reexport safe */ vega_event_selector__WEBPACK_IMPORTED_MODULE_25__.parseSelector),
/* harmony export */   path: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.path),
/* harmony export */   pathCurves: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathCurves),
/* harmony export */   pathEqual: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathEqual),
/* harmony export */   pathParse: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathParse),
/* harmony export */   pathRectangle: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRectangle),
/* harmony export */   pathRender: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathRender),
/* harmony export */   pathSymbols: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathSymbols),
/* harmony export */   pathTrail: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.pathTrail),
/* harmony export */   peek: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.peek),
/* harmony export */   point: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.point),
/* harmony export */   projection: () => (/* reexport safe */ vega_projection__WEBPACK_IMPORTED_MODULE_18__.projection),
/* harmony export */   quantileLogNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileLogNormal),
/* harmony export */   quantileNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileNormal),
/* harmony export */   quantileUniform: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantileUniform),
/* harmony export */   quantiles: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quantiles),
/* harmony export */   quantizeInterpolator: () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.quantizeInterpolator),
/* harmony export */   quarter: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.quarter),
/* harmony export */   quartiles: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.quartiles),
/* harmony export */   random: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.random),
/* harmony export */   randomInteger: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomInteger),
/* harmony export */   randomKDE: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomKDE),
/* harmony export */   randomLCG: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLCG),
/* harmony export */   randomLogNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomLogNormal),
/* harmony export */   randomMixture: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomMixture),
/* harmony export */   randomNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomNormal),
/* harmony export */   randomUniform: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.randomUniform),
/* harmony export */   read: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.read),
/* harmony export */   regressionConstant: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionConstant),
/* harmony export */   regressionExp: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionExp),
/* harmony export */   regressionLinear: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLinear),
/* harmony export */   regressionLoess: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLoess),
/* harmony export */   regressionLog: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionLog),
/* harmony export */   regressionPoly: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPoly),
/* harmony export */   regressionPow: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionPow),
/* harmony export */   regressionQuad: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.regressionQuad),
/* harmony export */   renderModule: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.renderModule),
/* harmony export */   repeat: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.repeat),
/* harmony export */   resetDefaultLocale: () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.resetDefaultLocale),
/* harmony export */   resetSVGClipId: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGClipId),
/* harmony export */   resetSVGDefIds: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.resetSVGDefIds),
/* harmony export */   responseType: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.responseType),
/* harmony export */   runtimeContext: () => (/* reexport safe */ vega_runtime__WEBPACK_IMPORTED_MODULE_23__.context),
/* harmony export */   sampleCurve: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleCurve),
/* harmony export */   sampleLogNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleLogNormal),
/* harmony export */   sampleNormal: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleNormal),
/* harmony export */   sampleUniform: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.sampleUniform),
/* harmony export */   scale: () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scale),
/* harmony export */   sceneEqual: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneEqual),
/* harmony export */   sceneFromJSON: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneFromJSON),
/* harmony export */   scenePickVisit: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.scenePickVisit),
/* harmony export */   sceneToJSON: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneToJSON),
/* harmony export */   sceneVisit: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneVisit),
/* harmony export */   sceneZOrder: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.sceneZOrder),
/* harmony export */   scheme: () => (/* reexport safe */ vega_scale__WEBPACK_IMPORTED_MODULE_17__.scheme),
/* harmony export */   serializeXML: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.serializeXML),
/* harmony export */   setHybridRendererOptions: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.setHybridRendererOptions),
/* harmony export */   setRandom: () => (/* reexport safe */ vega_statistics__WEBPACK_IMPORTED_MODULE_13__.setRandom),
/* harmony export */   span: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.span),
/* harmony export */   splitAccessPath: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.splitAccessPath),
/* harmony export */   stringValue: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.stringValue),
/* harmony export */   textMetrics: () => (/* reexport safe */ vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__.textMetrics),
/* harmony export */   timeBin: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeBin),
/* harmony export */   timeFloor: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeFloor),
/* harmony export */   timeFormatLocale: () => (/* reexport safe */ vega_format__WEBPACK_IMPORTED_MODULE_20__.timeFormatDefaultLocale),
/* harmony export */   timeInterval: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeInterval),
/* harmony export */   timeOffset: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeOffset),
/* harmony export */   timeSequence: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeSequence),
/* harmony export */   timeUnitSpecifier: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnitSpecifier),
/* harmony export */   timeUnits: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.timeUnits),
/* harmony export */   toBoolean: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toBoolean),
/* harmony export */   toDate: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toDate),
/* harmony export */   toNumber: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toNumber),
/* harmony export */   toSet: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toSet),
/* harmony export */   toString: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.toString),
/* harmony export */   transform: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transform),
/* harmony export */   transforms: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms),
/* harmony export */   truncate: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truncate),
/* harmony export */   truthy: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.truthy),
/* harmony export */   tupleid: () => (/* reexport safe */ vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.tupleid),
/* harmony export */   typeParsers: () => (/* reexport safe */ vega_loader__WEBPACK_IMPORTED_MODULE_15__.typeParsers),
/* harmony export */   utcFloor: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcFloor),
/* harmony export */   utcInterval: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcInterval),
/* harmony export */   utcOffset: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcOffset),
/* harmony export */   utcSequence: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcSequence),
/* harmony export */   utcdayofyear: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcdayofyear),
/* harmony export */   utcquarter: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.utcquarter),
/* harmony export */   utcweek: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.utcweek),
/* harmony export */   version: () => (/* binding */ version),
/* harmony export */   visitArray: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.visitArray),
/* harmony export */   week: () => (/* reexport safe */ vega_time__WEBPACK_IMPORTED_MODULE_14__.week),
/* harmony export */   writeConfig: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.writeConfig),
/* harmony export */   zero: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zero),
/* harmony export */   zoomLinear: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLinear),
/* harmony export */   zoomLog: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomLog),
/* harmony export */   zoomPow: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomPow),
/* harmony export */   zoomSymlog: () => (/* reexport safe */ vega_util__WEBPACK_IMPORTED_MODULE_0__.zoomSymlog)
/* harmony export */ });
/* harmony import */ var vega_util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vega-util */ "./node_modules/vega-util/build/vega-util.module.js");
/* harmony import */ var vega_dataflow__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vega-dataflow */ "./node_modules/vega-dataflow/build/vega-dataflow.module.js");
/* harmony import */ var vega_transforms__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! vega-transforms */ "./node_modules/vega-transforms/build/vega-transforms.module.js");
/* harmony import */ var vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vega-view-transforms */ "./node_modules/vega-view-transforms/build/vega-view-transforms.module.js");
/* harmony import */ var vega_encode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! vega-encode */ "./node_modules/vega-encode/build/vega-encode.module.js");
/* harmony import */ var vega_geo__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! vega-geo */ "./node_modules/vega-geo/build/vega-geo.module.js");
/* harmony import */ var vega_force__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! vega-force */ "./node_modules/vega-force/build/vega-force.module.js");
/* harmony import */ var vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! vega-hierarchy */ "./node_modules/vega-hierarchy/build/vega-hierarchy.module.js");
/* harmony import */ var vega_label__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! vega-label */ "./node_modules/vega-label/build/vega-label.module.js");
/* harmony import */ var vega_regression__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! vega-regression */ "./node_modules/vega-regression/build/vega-regression.module.js");
/* harmony import */ var vega_voronoi__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! vega-voronoi */ "./node_modules/vega-voronoi/build/vega-voronoi.module.js");
/* harmony import */ var vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! vega-wordcloud */ "./node_modules/vega-wordcloud/build/vega-wordcloud.module.js");
/* harmony import */ var vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! vega-crossfilter */ "./node_modules/vega-crossfilter/build/vega-crossfilter.module.js");
/* harmony import */ var vega_statistics__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! vega-statistics */ "./node_modules/vega-statistics/build/vega-statistics.module.js");
/* harmony import */ var vega_time__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! vega-time */ "./node_modules/vega-time/build/vega-time.module.js");
/* harmony import */ var vega_loader__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! vega-loader */ "./node_modules/vega-loader/build/vega-loader.browser.module.js");
/* harmony import */ var vega_scenegraph__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! vega-scenegraph */ "./node_modules/vega-scenegraph/build/vega-scenegraph.module.js");
/* harmony import */ var vega_scale__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! vega-scale */ "./node_modules/vega-scale/build/vega-scale.module.js");
/* harmony import */ var vega_projection__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! vega-projection */ "./node_modules/vega-projection/build/vega-projection.module.js");
/* harmony import */ var vega_view__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! vega-view */ "./node_modules/vega-view/build/vega-view.module.js");
/* harmony import */ var vega_format__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! vega-format */ "./node_modules/vega-format/build/vega-format.module.js");
/* harmony import */ var vega_functions__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! vega-functions */ "./node_modules/vega-functions/build/vega-functions.module.js");
/* harmony import */ var vega_parser__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! vega-parser */ "./node_modules/vega-parser/build/vega-parser.module.js");
/* harmony import */ var vega_runtime__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! vega-runtime */ "./node_modules/vega-runtime/build/vega-runtime.module.js");
/* harmony import */ var vega_expression__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! vega-expression */ "./node_modules/vega-expression/build/vega-expression.module.js");
/* harmony import */ var vega_event_selector__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! vega-event-selector */ "./node_modules/vega-event-selector/build/vega-event-selector.module.js");





























var version = "5.33.0";

// -- Transforms -----

(0,vega_util__WEBPACK_IMPORTED_MODULE_0__.extend)(vega_dataflow__WEBPACK_IMPORTED_MODULE_1__.transforms, vega_transforms__WEBPACK_IMPORTED_MODULE_2__, vega_view_transforms__WEBPACK_IMPORTED_MODULE_3__, vega_encode__WEBPACK_IMPORTED_MODULE_4__, vega_geo__WEBPACK_IMPORTED_MODULE_5__, vega_force__WEBPACK_IMPORTED_MODULE_6__, vega_label__WEBPACK_IMPORTED_MODULE_8__, vega_hierarchy__WEBPACK_IMPORTED_MODULE_7__, vega_regression__WEBPACK_IMPORTED_MODULE_9__, vega_voronoi__WEBPACK_IMPORTED_MODULE_10__, vega_wordcloud__WEBPACK_IMPORTED_MODULE_11__, vega_crossfilter__WEBPACK_IMPORTED_MODULE_12__);




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfdmVnYV9idWlsZF92ZWdhX21vZHVsZV9qcy5iZWFjNzg1Y2U0NGI4MTk2MWJiMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFPO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7O0FBRU87QUFDUDtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUMvRG1EO0FBQ3VCOztBQUVuRTtBQUNQLHNCQUFzQiw2Q0FBRztBQUN6QiwyQkFBMkIsNkNBQUcseUJBQXlCLDZDQUFHO0FBQzFELFNBQVMsNkNBQUcsVUFBVSw2Q0FBTztBQUM3QjtBQUNBOztBQUVPOztBQUVQO0FBQ0EsMEJBQTBCLDZDQUFHLDZDQUE2Qyw2Q0FBRztBQUM3RTs7QUFFQTtBQUNBLGVBQWUsOENBQUkscUJBQXFCLDZDQUFHLE1BQU0sOENBQUksVUFBVSw2Q0FBRztBQUNsRTs7QUFFQTtBQUNBOztBQUVPLHVDQUF1QywyQ0FBSyxHQUFHLDRDQUFNLEVBQUUsMkNBQUssRUFBRSx3Q0FBRTs7QUFFdkUsNkJBQWUsc0NBQVc7QUFDMUIsU0FBUyxrREFBVTtBQUNuQjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDNUJ1Qzs7QUFFdkMsNkJBQWUsb0NBQVM7QUFDeEIsVUFBVSx5REFBUztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQSwwQ0FBMEMscURBQXFEO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUUwQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3THFDOztBQUUvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsT0FBTztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFNBQVM7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsR0FBRztBQUM3RDtBQUNBO0FBQ0EsNEJBQTRCLGdCQUFnQjtBQUM1QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxNQUFNO0FBQ04sbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFdBQVc7QUFDWCxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxzQkFBc0Isd0RBQVc7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxrQkFBa0IsUUFBUSxZQUFZLFFBQVEsVUFBVSxLQUFLO0FBQzdEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wscUJBQXFCLE1BQU07QUFDM0Isc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnREFBSztBQUNiO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLGdEQUFLOztBQUVuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSwwQkFBMEI7QUFDL0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUFZLHlCQUF5QiwwREFBYztBQUM5RDtBQUNBLG9DQUFvQywwREFBYztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLCtEQUFlLGtCQUFrQixLQUFLLElBQUksWUFBWSxJQUFJLFNBQVM7QUFDNUU7QUFDQTtBQUNBLGdDQUFnQyxXQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxLQUFLLHVCQUF1QixNQUFNO0FBQ3RFO0FBQ0EsU0FBUyxtREFBUTtBQUNqQjtBQUNBLElBQUk7QUFDSjtBQUNBLDhCQUE4QjtBQUM5QixtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7QUFDbEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaURBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxXQUFXLCtDQUFJO0FBQ2YsR0FBRztBQUNIO0FBQ0EsV0FBVywrQ0FBSTtBQUNmLEdBQUc7QUFDSDtBQUNBLFdBQVcsK0NB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSxHQUFHO0FBQ0gsd0JBQXdCO0FBQ3hCLHdEQUF3RCw2Q0FBTTtBQUM5RCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRW1COzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3prQm9HO0FBQ2pFO0FBQ3hCO0FBQ3NDO0FBQzNCO0FBQ0g7QUFDK0k7QUFDL0g7O0FBRXREO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0Isb0RBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixvREFBSztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLHFEQUFXO0FBQy9CLHdCQUF3QixxREFBVzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQiwrQ0FBUTtBQUM3Qjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxvREFBTTtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxvREFBWSxZQUFZLCtDQUFJO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUFVO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSix3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxTQUFTO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyx5REFBYztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxPQUFPLHlEQUFjO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZDQUFNO0FBQzNDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsNkNBQU07QUFDbEQsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLHFEQUFVO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDs7QUFFM0Q7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLDZDQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkRBQTJEO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLG1EQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZLElBQUksS0FBSztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGtE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Q0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxtREFBTTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFlBQVk7QUFDekIsYUFBYSxlQUFlO0FBQzVCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxZQUFZO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsWUFBWTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7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O0FBQ3BCO0FBQ0EsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsU0FBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QixzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELG1EQUFNLDRCQUE0Qjs7QUFFNUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsZ0JBQWdCLGdEQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7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O0FBQ0E7QUFDQSxTQUFTLE9BQU87QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE9BQU87QUFDdkI7QUFDQTtBQUNBLGdCQUFnQixPQUFPO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxPQUFPO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdFQUFlO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFLDREQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsT0FBTztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbURBQU07QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxtREFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLDREQUFXO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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akQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLFlBQVksTUFBTTtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsbURBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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LG1EQUFROztBQUV6QztBQUNBLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdDQUFnQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUU4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3RU87QUFDSztBQUNnQztBQUN2QztBQUNNOztBQUV6QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxtREFBTTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsT0FBTztBQUNqQztBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQzVHO0FBQ2hCO0FBQ3FCO0FBQ1k7QUFDakI7O0FBRXBEOztBQUVBOztBQUVBLGlEQUFNLENBQUMscURBQVUsRUFBRSw0Q0FBRSxFQUFFLGlEQUFHLEVBQUUsd0NBQU0sRUFBRSxxQ0FBRyxFQUFFLHVDQUFLLEVBQUUsdUNBQUssRUFBRSwyQ0FBSSxFQUFFLDRDQUFHLEVBQUUsMENBQU8sRUFBRSw0Q0FBUyxFQUFFLDhDQUFFOztBQUVyRSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9kMy1nZW8tcHJvamVjdGlvbi9zcmMvbWF0aC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvZDMtZ2VvLXByb2plY3Rpb24vc3JjL21vbGx3ZWlkZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9iYm94LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2Jpc2VjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy9mZWF0dXJlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2lkZW50aXR5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL21lcmdlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL21lc2guanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvbmVpZ2hib3JzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3F1YW50aXplLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3JldmVyc2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3RvcG9qc29uLWNsaWVudC9zcmMvc3RpdGNoLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90b3BvanNvbi1jbGllbnQvc3JjL3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdG9wb2pzb24tY2xpZW50L3NyYy91bnRyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1jYW52YXMvYnVpbGQvdmVnYS1jYW52YXMuYnJvd3Nlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtY3Jvc3NmaWx0ZXIvYnVpbGQvdmVnYS1jcm9zc2ZpbHRlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZGF0YWZsb3cvYnVpbGQvdmVnYS1kYXRhZmxvdy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZW5jb2RlL2J1aWxkL3ZlZ2EtZW5jb2RlLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1ldmVudC1zZWxlY3Rvci9idWlsZC92ZWdhLWV2ZW50LXNlbGVjdG9yLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1leHByZXNzaW9uL2J1aWxkL3ZlZ2EtZXhwcmVzc2lvbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9yY2UvYnVpbGQvdmVnYS1mb3JjZS5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtZm9ybWF0L2J1aWxkL3ZlZ2EtZm9ybWF0Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1mdW5jdGlvbnMvYnVpbGQvdmVnYS1mdW5jdGlvbnMubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLWdlby9idWlsZC92ZWdhLWdlby5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtaGllcmFyY2h5L2J1aWxkL3ZlZ2EtaGllcmFyY2h5Lm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1sYWJlbC9idWlsZC92ZWdhLWxhYmVsLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1sb2FkZXIvYnVpbGQvdmVnYS1sb2FkZXIuYnJvd3Nlci5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtcGFyc2VyL2J1aWxkL3ZlZ2EtcGFyc2VyLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1wcm9qZWN0aW9uL2J1aWxkL3ZlZ2EtcHJvamVjdGlvbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EtcmVncmVzc2lvbi9idWlsZC92ZWdhLXJlZ3Jlc3Npb24ubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXJ1bnRpbWUvYnVpbGQvdmVnYS1ydW50aW1lLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1zY2FsZS9idWlsZC92ZWdhLXNjYWxlLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS1zY2VuZWdyYXBoL2J1aWxkL3ZlZ2Etc2NlbmVncmFwaC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etc2VsZWN0aW9ucy9idWlsZC92ZWdhLXNlbGVjdGlvbi5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etc3RhdGlzdGljcy9idWlsZC92ZWdhLXN0YXRpc3RpY3MubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXRpbWUvYnVpbGQvdmVnYS10aW1lLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS10cmFuc2Zvcm1zL2J1aWxkL3ZlZ2EtdHJhbnNmb3Jtcy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etdmlldy10cmFuc2Zvcm1zL2J1aWxkL3ZlZ2Etdmlldy10cmFuc2Zvcm1zLm1vZHVsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdmVnYS12aWV3L2J1aWxkL3ZlZ2Etdmlldy5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2Etdm9yb25vaS9idWlsZC92ZWdhLXZvcm9ub2kubW9kdWxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92ZWdhLXdvcmRjbG91ZC9idWlsZC92ZWdhLXdvcmRjbG91ZC5tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZlZ2EvYnVpbGQvdmVnYS5tb2R1bGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBhYnMgPSBNYXRoLmFicztcbmV4cG9ydCB2YXIgYXRhbiA9IE1hdGguYXRhbjtcbmV4cG9ydCB2YXIgYXRhbjIgPSBNYXRoLmF0YW4yO1xuZXhwb3J0IHZhciBjZWlsID0gTWF0aC5jZWlsO1xuZXhwb3J0IHZhciBjb3MgPSBNYXRoLmNvcztcbmV4cG9ydCB2YXIgZXhwID0gTWF0aC5leHA7XG5leHBvcnQgdmFyIGZsb29yID0gTWF0aC5mbG9vcjtcbmV4cG9ydCB2YXIgbG9nID0gTWF0aC5sb2c7XG5leHBvcnQgdmFyIG1heCA9IE1hdGgubWF4O1xuZXhwb3J0IHZhciBtaW4gPSBNYXRoLm1pbjtcbmV4cG9ydCB2YXIgcG93ID0gTWF0aC5wb3c7XG5leHBvcnQgdmFyIHJvdW5kID0gTWF0aC5yb3VuZDtcbmV4cG9ydCB2YXIgc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7IHJldHVybiB4ID4gMCA/IDEgOiB4IDwgMCA/IC0xIDogMDsgfTtcbmV4cG9ydCB2YXIgc2luID0gTWF0aC5zaW47XG5leHBvcnQgdmFyIHRhbiA9IE1hdGgudGFuO1xuXG5leHBvcnQgdmFyIGVwc2lsb24gPSAxZS02O1xuZXhwb3J0IHZhciBlcHNpbG9uMiA9IDFlLTEyO1xuZXhwb3J0IHZhciBwaSA9IE1hdGguUEk7XG5leHBvcnQgdmFyIGhhbGZQaSA9IHBpIC8gMjtcbmV4cG9ydCB2YXIgcXVhcnRlclBpID0gcGkgLyA0O1xuZXhwb3J0IHZhciBzcXJ0MV8yID0gTWF0aC5TUVJUMV8yO1xuZXhwb3J0IHZhciBzcXJ0MiA9IHNxcnQoMik7XG5leHBvcnQgdmFyIHNxcnRQaSA9IHNxcnQocGkpO1xuZXhwb3J0IHZhciB0YXUgPSBwaSAqIDI7XG5leHBvcnQgdmFyIGRlZ3JlZXMgPSAxODAgLyBwaTtcbmV4cG9ydCB2YXIgcmFkaWFucyA9IHBpIC8gMTgwO1xuXG5leHBvcnQgZnVuY3Rpb24gc2luY2koeCkge1xuICByZXR1cm4geCA/IHggLyBNYXRoLnNpbih4KSA6IDE7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc2luKHgpIHtcbiAgcmV0dXJuIHggPiAxID8gaGFsZlBpIDogeCA8IC0xID8gLWhhbGZQaSA6IE1hdGguYXNpbih4KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFjb3MoeCkge1xuICByZXR1cm4geCA+IDEgPyAwIDogeCA8IC0xID8gcGkgOiBNYXRoLmFjb3MoeCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXJ0KHgpIHtcbiAgcmV0dXJuIHggPiAwID8gTWF0aC5zcXJ0KHgpIDogMDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhbmgoeCkge1xuICB4ID0gZXhwKDIgKiB4KTtcbiAgcmV0dXJuICh4IC0gMSkgLyAoeCArIDEpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2luaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpIC0gZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaCh4KSB7XG4gIHJldHVybiAoZXhwKHgpICsgZXhwKC14KSkgLyAyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXJzaW5oKHgpIHtcbiAgcmV0dXJuIGxvZyh4ICsgc3FydCh4ICogeCArIDEpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFyY29zaCh4KSB7XG4gIHJldHVybiBsb2coeCArIHNxcnQoeCAqIHggLSAxKSk7XG59XG4iLCJpbXBvcnQge2dlb1Byb2plY3Rpb24gYXMgcHJvamVjdGlvbn0gZnJvbSBcImQzLWdlb1wiO1xuaW1wb3J0IHthYnMsIGFzaW4sIGNvcywgZXBzaWxvbiwgaGFsZlBpLCBwaSwgc2luLCBzcXJ0Mn0gZnJvbSBcIi4vbWF0aC5qc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbW9sbHdlaWRlQnJvbWxleVRoZXRhKGNwLCBwaGkpIHtcbiAgdmFyIGNwc2luUGhpID0gY3AgKiBzaW4ocGhpKSwgaSA9IDMwLCBkZWx0YTtcbiAgZG8gcGhpIC09IGRlbHRhID0gKHBoaSArIHNpbihwaGkpIC0gY3BzaW5QaGkpIC8gKDEgKyBjb3MocGhpKSk7XG4gIHdoaWxlIChhYnMoZGVsdGEpID4gZXBzaWxvbiAmJiAtLWkgPiAwKTtcbiAgcmV0dXJuIHBoaSAvIDI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtb2xsd2VpZGVCcm9tbGV5UmF3KGN4LCBjeSwgY3ApIHtcblxuICBmdW5jdGlvbiBmb3J3YXJkKGxhbWJkYSwgcGhpKSB7XG4gICAgcmV0dXJuIFtjeCAqIGxhbWJkYSAqIGNvcyhwaGkgPSBtb2xsd2VpZGVCcm9tbGV5VGhldGEoY3AsIHBoaSkpLCBjeSAqIHNpbihwaGkpXTtcbiAgfVxuXG4gIGZvcndhcmQuaW52ZXJ0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiB5ID0gYXNpbih5IC8gY3kpLCBbeCAvIChjeCAqIGNvcyh5KSksIGFzaW4oKDIgKiB5ICsgc2luKDIgKiB5KSkgLyBjcCldO1xuICB9O1xuXG4gIHJldHVybiBmb3J3YXJkO1xufVxuXG5leHBvcnQgdmFyIG1vbGx3ZWlkZVJhdyA9IG1vbGx3ZWlkZUJyb21sZXlSYXcoc3FydDIgLyBoYWxmUGksIHNxcnQyLCBwaSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gcHJvamVjdGlvbihtb2xsd2VpZGVSYXcpXG4gICAgICAuc2NhbGUoMTY5LjUyOSk7XG59XG4iLCJpbXBvcnQgdHJhbnNmb3JtIGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICB2YXIgdCA9IHRyYW5zZm9ybSh0b3BvbG9neS50cmFuc2Zvcm0pLCBrZXksXG4gICAgICB4MCA9IEluZmluaXR5LCB5MCA9IHgwLCB4MSA9IC14MCwgeTEgPSAteDA7XG5cbiAgZnVuY3Rpb24gYmJveFBvaW50KHApIHtcbiAgICBwID0gdChwKTtcbiAgICBpZiAocFswXSA8IHgwKSB4MCA9IHBbMF07XG4gICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgIGlmIChwWzFdIDwgeTApIHkwID0gcFsxXTtcbiAgICBpZiAocFsxXSA+IHkxKSB5MSA9IHBbMV07XG4gIH1cblxuICBmdW5jdGlvbiBiYm94R2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoby50eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IG8uZ2VvbWV0cmllcy5mb3JFYWNoKGJib3hHZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGJib3hQb2ludChvLmNvb3JkaW5hdGVzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvLmNvb3JkaW5hdGVzLmZvckVhY2goYmJveFBvaW50KTsgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdG9wb2xvZ3kuYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgIHZhciBpID0gLTEsIG4gPSBhcmMubGVuZ3RoLCBwO1xuICAgIHdoaWxlICgrK2kgPCBuKSB7XG4gICAgICBwID0gdChhcmNbaV0sIGkpO1xuICAgICAgaWYgKHBbMF0gPCB4MCkgeDAgPSBwWzBdO1xuICAgICAgaWYgKHBbMF0gPiB4MSkgeDEgPSBwWzBdO1xuICAgICAgaWYgKHBbMV0gPCB5MCkgeTAgPSBwWzFdO1xuICAgICAgaWYgKHBbMV0gPiB5MSkgeTEgPSBwWzFdO1xuICAgIH1cbiAgfSk7XG5cbiAgZm9yIChrZXkgaW4gdG9wb2xvZ3kub2JqZWN0cykge1xuICAgIGJib3hHZW9tZXRyeSh0b3BvbG9neS5vYmplY3RzW2tleV0pO1xuICB9XG5cbiAgcmV0dXJuIFt4MCwgeTAsIHgxLCB5MV07XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbihhLCB4KSB7XG4gIHZhciBsbyA9IDAsIGhpID0gYS5sZW5ndGg7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKGFbbWlkXSA8IHgpIGxvID0gbWlkICsgMTtcbiAgICBlbHNlIGhpID0gbWlkO1xuICB9XG4gIHJldHVybiBsbztcbn1cbiIsImltcG9ydCByZXZlcnNlIGZyb20gXCIuL3JldmVyc2UuanNcIjtcbmltcG9ydCB0cmFuc2Zvcm0gZnJvbSBcIi4vdHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCBvKSB7XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgbyA9IHRvcG9sb2d5Lm9iamVjdHNbb107XG4gIHJldHVybiBvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCJcbiAgICAgID8ge3R5cGU6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIiwgZmVhdHVyZXM6IG8uZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24obykgeyByZXR1cm4gZmVhdHVyZSh0b3BvbG9neSwgbyk7IH0pfVxuICAgICAgOiBmZWF0dXJlKHRvcG9sb2d5LCBvKTtcbn1cblxuZnVuY3Rpb24gZmVhdHVyZSh0b3BvbG9neSwgbykge1xuICB2YXIgaWQgPSBvLmlkLFxuICAgICAgYmJveCA9IG8uYmJveCxcbiAgICAgIHByb3BlcnRpZXMgPSBvLnByb3BlcnRpZXMgPT0gbnVsbCA/IHt9IDogby5wcm9wZXJ0aWVzLFxuICAgICAgZ2VvbWV0cnkgPSBvYmplY3QodG9wb2xvZ3ksIG8pO1xuICByZXR1cm4gaWQgPT0gbnVsbCAmJiBiYm94ID09IG51bGwgPyB7dHlwZTogXCJGZWF0dXJlXCIsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDogYmJveCA9PSBudWxsID8ge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX1cbiAgICAgIDoge3R5cGU6IFwiRmVhdHVyZVwiLCBpZDogaWQsIGJib3g6IGJib3gsIHByb3BlcnRpZXM6IHByb3BlcnRpZXMsIGdlb21ldHJ5OiBnZW9tZXRyeX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBvYmplY3QodG9wb2xvZ3ksIG8pIHtcbiAgdmFyIHRyYW5zZm9ybVBvaW50ID0gdHJhbnNmb3JtKHRvcG9sb2d5LnRyYW5zZm9ybSksXG4gICAgICBhcmNzID0gdG9wb2xvZ3kuYXJjcztcblxuICBmdW5jdGlvbiBhcmMoaSwgcG9pbnRzKSB7XG4gICAgaWYgKHBvaW50cy5sZW5ndGgpIHBvaW50cy5wb3AoKTtcbiAgICBmb3IgKHZhciBhID0gYXJjc1tpIDwgMCA/IH5pIDogaV0sIGsgPSAwLCBuID0gYS5sZW5ndGg7IGsgPCBuOyArK2spIHtcbiAgICAgIHBvaW50cy5wdXNoKHRyYW5zZm9ybVBvaW50KGFba10sIGspKTtcbiAgICB9XG4gICAgaWYgKGkgPCAwKSByZXZlcnNlKHBvaW50cywgbik7XG4gIH1cblxuICBmdW5jdGlvbiBwb2ludChwKSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBvaW50KHApO1xuICB9XG5cbiAgZnVuY3Rpb24gbGluZShhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwLCBuID0gYXJjcy5sZW5ndGg7IGkgPCBuOyArK2kpIGFyYyhhcmNzW2ldLCBwb2ludHMpO1xuICAgIGlmIChwb2ludHMubGVuZ3RoIDwgMikgcG9pbnRzLnB1c2gocG9pbnRzWzBdKTsgLy8gVGhpcyBzaG91bGQgbmV2ZXIgaGFwcGVuIHBlciB0aGUgc3BlY2lmaWNhdGlvbi5cbiAgICByZXR1cm4gcG9pbnRzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmluZyhhcmNzKSB7XG4gICAgdmFyIHBvaW50cyA9IGxpbmUoYXJjcyk7XG4gICAgd2hpbGUgKHBvaW50cy5sZW5ndGggPCA0KSBwb2ludHMucHVzaChwb2ludHNbMF0pOyAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYW4gYXJjIGhhcyBvbmx5IHR3byBwb2ludHMuXG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHBvbHlnb24oYXJjcykge1xuICAgIHJldHVybiBhcmNzLm1hcChyaW5nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICB2YXIgdHlwZSA9IG8udHlwZSwgY29vcmRpbmF0ZXM7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI6IHJldHVybiB7dHlwZTogdHlwZSwgZ2VvbWV0cmllczogby5nZW9tZXRyaWVzLm1hcChnZW9tZXRyeSl9O1xuICAgICAgY2FzZSBcIlBvaW50XCI6IGNvb3JkaW5hdGVzID0gcG9pbnQoby5jb29yZGluYXRlcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjogY29vcmRpbmF0ZXMgPSBvLmNvb3JkaW5hdGVzLm1hcChwb2ludCk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogY29vcmRpbmF0ZXMgPSBsaW5lKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAobGluZSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogY29vcmRpbmF0ZXMgPSBwb2x5Z29uKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBjb29yZGluYXRlcyA9IG8uYXJjcy5tYXAocG9seWdvbik7IGJyZWFrO1xuICAgICAgZGVmYXVsdDogcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB7dHlwZTogdHlwZSwgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzfTtcbiAgfVxuXG4gIHJldHVybiBnZW9tZXRyeShvKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHgpIHtcbiAgcmV0dXJuIHg7XG59XG4iLCJleHBvcnQge2RlZmF1bHQgYXMgYmJveH0gZnJvbSBcIi4vYmJveC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIGZlYXR1cmV9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBtZXNoLCBtZXNoQXJjc30gZnJvbSBcIi4vbWVzaC5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIG1lcmdlLCBtZXJnZUFyY3N9IGZyb20gXCIuL21lcmdlLmpzXCI7XG5leHBvcnQge2RlZmF1bHQgYXMgbmVpZ2hib3JzfSBmcm9tIFwiLi9uZWlnaGJvcnMuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyBxdWFudGl6ZX0gZnJvbSBcIi4vcXVhbnRpemUuanNcIjtcbmV4cG9ydCB7ZGVmYXVsdCBhcyB0cmFuc2Zvcm19IGZyb20gXCIuL3RyYW5zZm9ybS5qc1wiO1xuZXhwb3J0IHtkZWZhdWx0IGFzIHVudHJhbnNmb3JtfSBmcm9tIFwiLi91bnRyYW5zZm9ybS5qc1wiO1xuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmZ1bmN0aW9uIHBsYW5hclJpbmdBcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAtMSwgbiA9IHJpbmcubGVuZ3RoLCBhLCBiID0gcmluZ1tuIC0gMV0sIGFyZWEgPSAwO1xuICB3aGlsZSAoKytpIDwgbikgYSA9IGIsIGIgPSByaW5nW2ldLCBhcmVhICs9IGFbMF0gKiBiWzFdIC0gYVsxXSAqIGJbMF07XG4gIHJldHVybiBNYXRoLmFicyhhcmVhKTsgLy8gTm90ZTogZG91YmxlZCBhcmVhIVxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSkge1xuICByZXR1cm4gb2JqZWN0KHRvcG9sb2d5LCBtZXJnZUFyY3MuYXBwbHkodGhpcywgYXJndW1lbnRzKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZXJnZUFyY3ModG9wb2xvZ3ksIG9iamVjdHMpIHtcbiAgdmFyIHBvbHlnb25zQnlBcmMgPSB7fSxcbiAgICAgIHBvbHlnb25zID0gW10sXG4gICAgICBncm91cHMgPSBbXTtcblxuICBvYmplY3RzLmZvckVhY2goZ2VvbWV0cnkpO1xuXG4gIGZ1bmN0aW9uIGdlb21ldHJ5KG8pIHtcbiAgICBzd2l0Y2ggKG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIlBvbHlnb25cIjogZXh0cmFjdChvLmFyY3MpOyBicmVhaztcbiAgICAgIGNhc2UgXCJNdWx0aVBvbHlnb25cIjogby5hcmNzLmZvckVhY2goZXh0cmFjdCk7IGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QocG9seWdvbikge1xuICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICByaW5nLmZvckVhY2goZnVuY3Rpb24oYXJjKSB7XG4gICAgICAgIChwb2x5Z29uc0J5QXJjW2FyYyA9IGFyYyA8IDAgPyB+YXJjIDogYXJjXSB8fCAocG9seWdvbnNCeUFyY1thcmNdID0gW10pKS5wdXNoKHBvbHlnb24pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcG9seWdvbnMucHVzaChwb2x5Z29uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFyZWEocmluZykge1xuICAgIHJldHVybiBwbGFuYXJSaW5nQXJlYShvYmplY3QodG9wb2xvZ3ksIHt0eXBlOiBcIlBvbHlnb25cIiwgYXJjczogW3JpbmddfSkuY29vcmRpbmF0ZXNbMF0pO1xuICB9XG5cbiAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgaWYgKCFwb2x5Z29uLl8pIHtcbiAgICAgIHZhciBncm91cCA9IFtdLFxuICAgICAgICAgIG5laWdoYm9ycyA9IFtwb2x5Z29uXTtcbiAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICBncm91cHMucHVzaChncm91cCk7XG4gICAgICB3aGlsZSAocG9seWdvbiA9IG5laWdoYm9ycy5wb3AoKSkge1xuICAgICAgICBncm91cC5wdXNoKHBvbHlnb24pO1xuICAgICAgICBwb2x5Z29uLmZvckVhY2goZnVuY3Rpb24ocmluZykge1xuICAgICAgICAgIHJpbmcuZm9yRWFjaChmdW5jdGlvbihhcmMpIHtcbiAgICAgICAgICAgIHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgICAgICAgICAgICBpZiAoIXBvbHlnb24uXykge1xuICAgICAgICAgICAgICAgIHBvbHlnb24uXyA9IDE7XG4gICAgICAgICAgICAgICAgbmVpZ2hib3JzLnB1c2gocG9seWdvbik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHBvbHlnb25zLmZvckVhY2goZnVuY3Rpb24ocG9seWdvbikge1xuICAgIGRlbGV0ZSBwb2x5Z29uLl87XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJNdWx0aVBvbHlnb25cIixcbiAgICBhcmNzOiBncm91cHMubWFwKGZ1bmN0aW9uKHBvbHlnb25zKSB7XG4gICAgICB2YXIgYXJjcyA9IFtdLCBuO1xuXG4gICAgICAvLyBFeHRyYWN0IHRoZSBleHRlcmlvciAodW5pcXVlKSBhcmNzLlxuICAgICAgcG9seWdvbnMuZm9yRWFjaChmdW5jdGlvbihwb2x5Z29uKSB7XG4gICAgICAgIHBvbHlnb24uZm9yRWFjaChmdW5jdGlvbihyaW5nKSB7XG4gICAgICAgICAgcmluZy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykge1xuICAgICAgICAgICAgaWYgKHBvbHlnb25zQnlBcmNbYXJjIDwgMCA/IH5hcmMgOiBhcmNdLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgYXJjcy5wdXNoKGFyYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFN0aXRjaCB0aGUgYXJjcyBpbnRvIG9uZSBvciBtb3JlIHJpbmdzLlxuICAgICAgYXJjcyA9IHN0aXRjaCh0b3BvbG9neSwgYXJjcyk7XG5cbiAgICAgIC8vIElmIG1vcmUgdGhhbiBvbmUgcmluZyBpcyByZXR1cm5lZCxcbiAgICAgIC8vIGF0IG1vc3Qgb25lIG9mIHRoZXNlIHJpbmdzIGNhbiBiZSB0aGUgZXh0ZXJpb3I7XG4gICAgICAvLyBjaG9vc2UgdGhlIG9uZSB3aXRoIHRoZSBncmVhdGVzdCBhYnNvbHV0ZSBhcmVhLlxuICAgICAgaWYgKChuID0gYXJjcy5sZW5ndGgpID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgayA9IGFyZWEoYXJjc1swXSksIGtpLCB0OyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaWYgKChraSA9IGFyZWEoYXJjc1tpXSkpID4gaykge1xuICAgICAgICAgICAgdCA9IGFyY3NbMF0sIGFyY3NbMF0gPSBhcmNzW2ldLCBhcmNzW2ldID0gdCwgayA9IGtpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gYXJjcztcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24oYXJjcykge1xuICAgICAgcmV0dXJuIGFyY3MubGVuZ3RoID4gMDtcbiAgICB9KVxuICB9O1xufVxuIiwiaW1wb3J0IHtvYmplY3R9IGZyb20gXCIuL2ZlYXR1cmUuanNcIjtcbmltcG9ydCBzdGl0Y2ggZnJvbSBcIi4vc3RpdGNoLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5KSB7XG4gIHJldHVybiBvYmplY3QodG9wb2xvZ3ksIG1lc2hBcmNzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVzaEFyY3ModG9wb2xvZ3ksIG9iamVjdCwgZmlsdGVyKSB7XG4gIHZhciBhcmNzLCBpLCBuO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIGFyY3MgPSBleHRyYWN0QXJjcyh0b3BvbG9neSwgb2JqZWN0LCBmaWx0ZXIpO1xuICBlbHNlIGZvciAoaSA9IDAsIGFyY3MgPSBuZXcgQXJyYXkobiA9IHRvcG9sb2d5LmFyY3MubGVuZ3RoKTsgaSA8IG47ICsraSkgYXJjc1tpXSA9IGk7XG4gIHJldHVybiB7dHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgYXJjczogc3RpdGNoKHRvcG9sb2d5LCBhcmNzKX07XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RBcmNzKHRvcG9sb2d5LCBvYmplY3QsIGZpbHRlcikge1xuICB2YXIgYXJjcyA9IFtdLFxuICAgICAgZ2VvbXNCeUFyYyA9IFtdLFxuICAgICAgZ2VvbTtcblxuICBmdW5jdGlvbiBleHRyYWN0MChpKSB7XG4gICAgdmFyIGogPSBpIDwgMCA/IH5pIDogaTtcbiAgICAoZ2VvbXNCeUFyY1tqXSB8fCAoZ2VvbXNCeUFyY1tqXSA9IFtdKSkucHVzaCh7aTogaSwgZzogZ2VvbX0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZXh0cmFjdDEoYXJjcykge1xuICAgIGFyY3MuZm9yRWFjaChleHRyYWN0MCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHRyYWN0MihhcmNzKSB7XG4gICAgYXJjcy5mb3JFYWNoKGV4dHJhY3QxKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dHJhY3QzKGFyY3MpIHtcbiAgICBhcmNzLmZvckVhY2goZXh0cmFjdDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobykge1xuICAgIHN3aXRjaCAoZ2VvbSA9IG8sIG8udHlwZSkge1xuICAgICAgY2FzZSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiOiBvLmdlb21ldHJpZXMuZm9yRWFjaChnZW9tZXRyeSk7IGJyZWFrO1xuICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogZXh0cmFjdDEoby5hcmNzKTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlMaW5lU3RyaW5nXCI6IGNhc2UgXCJQb2x5Z29uXCI6IGV4dHJhY3QyKG8uYXJjcyk7IGJyZWFrO1xuICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiBleHRyYWN0MyhvLmFyY3MpOyBicmVhaztcbiAgICB9XG4gIH1cblxuICBnZW9tZXRyeShvYmplY3QpO1xuXG4gIGdlb21zQnlBcmMuZm9yRWFjaChmaWx0ZXIgPT0gbnVsbFxuICAgICAgPyBmdW5jdGlvbihnZW9tcykgeyBhcmNzLnB1c2goZ2VvbXNbMF0uaSk7IH1cbiAgICAgIDogZnVuY3Rpb24oZ2VvbXMpIHsgaWYgKGZpbHRlcihnZW9tc1swXS5nLCBnZW9tc1tnZW9tcy5sZW5ndGggLSAxXS5nKSkgYXJjcy5wdXNoKGdlb21zWzBdLmkpOyB9KTtcblxuICByZXR1cm4gYXJjcztcbn1cbiIsImltcG9ydCBiaXNlY3QgZnJvbSBcIi4vYmlzZWN0LmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKG9iamVjdHMpIHtcbiAgdmFyIGluZGV4ZXNCeUFyYyA9IHt9LCAvLyBhcmMgaW5kZXggLT4gYXJyYXkgb2Ygb2JqZWN0IGluZGV4ZXNcbiAgICAgIG5laWdoYm9ycyA9IG9iamVjdHMubWFwKGZ1bmN0aW9uKCkgeyByZXR1cm4gW107IH0pO1xuXG4gIGZ1bmN0aW9uIGxpbmUoYXJjcywgaSkge1xuICAgIGFyY3MuZm9yRWFjaChmdW5jdGlvbihhKSB7XG4gICAgICBpZiAoYSA8IDApIGEgPSB+YTtcbiAgICAgIHZhciBvID0gaW5kZXhlc0J5QXJjW2FdO1xuICAgICAgaWYgKG8pIG8ucHVzaChpKTtcbiAgICAgIGVsc2UgaW5kZXhlc0J5QXJjW2FdID0gW2ldO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9seWdvbihhcmNzLCBpKSB7XG4gICAgYXJjcy5mb3JFYWNoKGZ1bmN0aW9uKGFyYykgeyBsaW5lKGFyYywgaSk7IH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VvbWV0cnkobywgaSkge1xuICAgIGlmIChvLnR5cGUgPT09IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIpIG8uZ2VvbWV0cmllcy5mb3JFYWNoKGZ1bmN0aW9uKG8pIHsgZ2VvbWV0cnkobywgaSk7IH0pO1xuICAgIGVsc2UgaWYgKG8udHlwZSBpbiBnZW9tZXRyeVR5cGUpIGdlb21ldHJ5VHlwZVtvLnR5cGVdKG8uYXJjcywgaSk7XG4gIH1cblxuICB2YXIgZ2VvbWV0cnlUeXBlID0ge1xuICAgIExpbmVTdHJpbmc6IGxpbmUsXG4gICAgTXVsdGlMaW5lU3RyaW5nOiBwb2x5Z29uLFxuICAgIFBvbHlnb246IHBvbHlnb24sXG4gICAgTXVsdGlQb2x5Z29uOiBmdW5jdGlvbihhcmNzLCBpKSB7IGFyY3MuZm9yRWFjaChmdW5jdGlvbihhcmMpIHsgcG9seWdvbihhcmMsIGkpOyB9KTsgfVxuICB9O1xuXG4gIG9iamVjdHMuZm9yRWFjaChnZW9tZXRyeSk7XG5cbiAgZm9yICh2YXIgaSBpbiBpbmRleGVzQnlBcmMpIHtcbiAgICBmb3IgKHZhciBpbmRleGVzID0gaW5kZXhlc0J5QXJjW2ldLCBtID0gaW5kZXhlcy5sZW5ndGgsIGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBmb3IgKHZhciBrID0gaiArIDE7IGsgPCBtOyArK2spIHtcbiAgICAgICAgdmFyIGlqID0gaW5kZXhlc1tqXSwgaWsgPSBpbmRleGVzW2tdLCBuO1xuICAgICAgICBpZiAoKG4gPSBuZWlnaGJvcnNbaWpdKVtpID0gYmlzZWN0KG4sIGlrKV0gIT09IGlrKSBuLnNwbGljZShpLCAwLCBpayk7XG4gICAgICAgIGlmICgobiA9IG5laWdoYm9yc1tpa10pW2kgPSBiaXNlY3QobiwgaWopXSAhPT0gaWopIG4uc3BsaWNlKGksIDAsIGlqKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVpZ2hib3JzO1xufVxuIiwiaW1wb3J0IGJib3ggZnJvbSBcIi4vYmJveC5qc1wiO1xuaW1wb3J0IHVudHJhbnNmb3JtIGZyb20gXCIuL3VudHJhbnNmb3JtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKHRvcG9sb2d5LCB0cmFuc2Zvcm0pIHtcbiAgaWYgKHRvcG9sb2d5LnRyYW5zZm9ybSkgdGhyb3cgbmV3IEVycm9yKFwiYWxyZWFkeSBxdWFudGl6ZWRcIik7XG5cbiAgaWYgKCF0cmFuc2Zvcm0gfHwgIXRyYW5zZm9ybS5zY2FsZSkge1xuICAgIGlmICghKChuID0gTWF0aC5mbG9vcih0cmFuc2Zvcm0pKSA+PSAyKSkgdGhyb3cgbmV3IEVycm9yKFwibiBtdXN0IGJlIOKJpTJcIik7XG4gICAgYm94ID0gdG9wb2xvZ3kuYmJveCB8fCBiYm94KHRvcG9sb2d5KTtcbiAgICB2YXIgeDAgPSBib3hbMF0sIHkwID0gYm94WzFdLCB4MSA9IGJveFsyXSwgeTEgPSBib3hbM10sIG47XG4gICAgdHJhbnNmb3JtID0ge3NjYWxlOiBbeDEgLSB4MCA/ICh4MSAtIHgwKSAvIChuIC0gMSkgOiAxLCB5MSAtIHkwID8gKHkxIC0geTApIC8gKG4gLSAxKSA6IDFdLCB0cmFuc2xhdGU6IFt4MCwgeTBdfTtcbiAgfSBlbHNlIHtcbiAgICBib3ggPSB0b3BvbG9neS5iYm94O1xuICB9XG5cbiAgdmFyIHQgPSB1bnRyYW5zZm9ybSh0cmFuc2Zvcm0pLCBib3gsIGtleSwgaW5wdXRzID0gdG9wb2xvZ3kub2JqZWN0cywgb3V0cHV0cyA9IHt9O1xuXG4gIGZ1bmN0aW9uIHF1YW50aXplUG9pbnQocG9pbnQpIHtcbiAgICByZXR1cm4gdChwb2ludCk7XG4gIH1cblxuICBmdW5jdGlvbiBxdWFudGl6ZUdlb21ldHJ5KGlucHV0KSB7XG4gICAgdmFyIG91dHB1dDtcbiAgICBzd2l0Y2ggKGlucHV0LnR5cGUpIHtcbiAgICAgIGNhc2UgXCJHZW9tZXRyeUNvbGxlY3Rpb25cIjogb3V0cHV0ID0ge3R5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsIGdlb21ldHJpZXM6IGlucHV0Lmdlb21ldHJpZXMubWFwKHF1YW50aXplR2VvbWV0cnkpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiUG9pbnRcIjogb3V0cHV0ID0ge3R5cGU6IFwiUG9pbnRcIiwgY29vcmRpbmF0ZXM6IHF1YW50aXplUG9pbnQoaW5wdXQuY29vcmRpbmF0ZXMpfTsgYnJlYWs7XG4gICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOiBvdXRwdXQgPSB7dHlwZTogXCJNdWx0aVBvaW50XCIsIGNvb3JkaW5hdGVzOiBpbnB1dC5jb29yZGluYXRlcy5tYXAocXVhbnRpemVQb2ludCl9OyBicmVhaztcbiAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICB9XG4gICAgaWYgKGlucHV0LmlkICE9IG51bGwpIG91dHB1dC5pZCA9IGlucHV0LmlkO1xuICAgIGlmIChpbnB1dC5iYm94ICE9IG51bGwpIG91dHB1dC5iYm94ID0gaW5wdXQuYmJveDtcbiAgICBpZiAoaW5wdXQucHJvcGVydGllcyAhPSBudWxsKSBvdXRwdXQucHJvcGVydGllcyA9IGlucHV0LnByb3BlcnRpZXM7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHF1YW50aXplQXJjKGlucHV0KSB7XG4gICAgdmFyIGkgPSAwLCBqID0gMSwgbiA9IGlucHV0Lmxlbmd0aCwgcCwgb3V0cHV0ID0gbmV3IEFycmF5KG4pOyAvLyBwZXNzaW1pc3RpY1xuICAgIG91dHB1dFswXSA9IHQoaW5wdXRbMF0sIDApO1xuICAgIHdoaWxlICgrK2kgPCBuKSBpZiAoKHAgPSB0KGlucHV0W2ldLCBpKSlbMF0gfHwgcFsxXSkgb3V0cHV0W2orK10gPSBwOyAvLyBub24tY29pbmNpZGVudCBwb2ludHNcbiAgICBpZiAoaiA9PT0gMSkgb3V0cHV0W2orK10gPSBbMCwgMF07IC8vIGFuIGFyYyBtdXN0IGhhdmUgYXQgbGVhc3QgdHdvIHBvaW50c1xuICAgIG91dHB1dC5sZW5ndGggPSBqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICBmb3IgKGtleSBpbiBpbnB1dHMpIG91dHB1dHNba2V5XSA9IHF1YW50aXplR2VvbWV0cnkoaW5wdXRzW2tleV0pO1xuXG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJUb3BvbG9neVwiLFxuICAgIGJib3g6IGJveCxcbiAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybSxcbiAgICBvYmplY3RzOiBvdXRwdXRzLFxuICAgIGFyY3M6IHRvcG9sb2d5LmFyY3MubWFwKHF1YW50aXplQXJjKVxuICB9O1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oYXJyYXksIG4pIHtcbiAgdmFyIHQsIGogPSBhcnJheS5sZW5ndGgsIGkgPSBqIC0gbjtcbiAgd2hpbGUgKGkgPCAtLWopIHQgPSBhcnJheVtpXSwgYXJyYXlbaSsrXSA9IGFycmF5W2pdLCBhcnJheVtqXSA9IHQ7XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0b3BvbG9neSwgYXJjcykge1xuICB2YXIgc3RpdGNoZWRBcmNzID0ge30sXG4gICAgICBmcmFnbWVudEJ5U3RhcnQgPSB7fSxcbiAgICAgIGZyYWdtZW50QnlFbmQgPSB7fSxcbiAgICAgIGZyYWdtZW50cyA9IFtdLFxuICAgICAgZW1wdHlJbmRleCA9IC0xO1xuXG4gIC8vIFN0aXRjaCBlbXB0eSBhcmNzIGZpcnN0LCBzaW5jZSB0aGV5IG1heSBiZSBzdWJzdW1lZCBieSBvdGhlciBhcmNzLlxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSwgaikge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgdDtcbiAgICBpZiAoYXJjLmxlbmd0aCA8IDMgJiYgIWFyY1sxXVswXSAmJiAhYXJjWzFdWzFdKSB7XG4gICAgICB0ID0gYXJjc1srK2VtcHR5SW5kZXhdLCBhcmNzW2VtcHR5SW5kZXhdID0gaSwgYXJjc1tqXSA9IHQ7XG4gICAgfVxuICB9KTtcblxuICBhcmNzLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgIHZhciBlID0gZW5kcyhpKSxcbiAgICAgICAgc3RhcnQgPSBlWzBdLFxuICAgICAgICBlbmQgPSBlWzFdLFxuICAgICAgICBmLCBnO1xuXG4gICAgaWYgKGYgPSBmcmFnbWVudEJ5RW5kW3N0YXJ0XSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZi5lbmRdO1xuICAgICAgZi5wdXNoKGkpO1xuICAgICAgZi5lbmQgPSBlbmQ7XG4gICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRdKSB7XG4gICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZy5zdGFydF07XG4gICAgICAgIHZhciBmZyA9IGcgPT09IGYgPyBmIDogZi5jb25jYXQoZyk7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmZy5zdGFydCA9IGYuc3RhcnRdID0gZnJhZ21lbnRCeUVuZFtmZy5lbmQgPSBnLmVuZF0gPSBmZztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0gZjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGYgPSBmcmFnbWVudEJ5U3RhcnRbZW5kXSkge1xuICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XTtcbiAgICAgIGYudW5zaGlmdChpKTtcbiAgICAgIGYuc3RhcnQgPSBzdGFydDtcbiAgICAgIGlmIChnID0gZnJhZ21lbnRCeUVuZFtzdGFydF0pIHtcbiAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlFbmRbZy5lbmRdO1xuICAgICAgICB2YXIgZ2YgPSBnID09PSBmID8gZiA6IGcuY29uY2F0KGYpO1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZ2Yuc3RhcnQgPSBnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZ2YuZW5kID0gZi5lbmRdID0gZ2Y7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF0gPSBmcmFnbWVudEJ5RW5kW2YuZW5kXSA9IGY7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGYgPSBbaV07XG4gICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmQgPSBlbmRdID0gZjtcbiAgICB9XG4gIH0pO1xuXG4gIGZ1bmN0aW9uIGVuZHMoaSkge1xuICAgIHZhciBhcmMgPSB0b3BvbG9neS5hcmNzW2kgPCAwID8gfmkgOiBpXSwgcDAgPSBhcmNbMF0sIHAxO1xuICAgIGlmICh0b3BvbG9neS50cmFuc2Zvcm0pIHAxID0gWzAsIDBdLCBhcmMuZm9yRWFjaChmdW5jdGlvbihkcCkgeyBwMVswXSArPSBkcFswXSwgcDFbMV0gKz0gZHBbMV07IH0pO1xuICAgIGVsc2UgcDEgPSBhcmNbYXJjLmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBpIDwgMCA/IFtwMSwgcDBdIDogW3AwLCBwMV07XG4gIH1cblxuICBmdW5jdGlvbiBmbHVzaChmcmFnbWVudEJ5RW5kLCBmcmFnbWVudEJ5U3RhcnQpIHtcbiAgICBmb3IgKHZhciBrIGluIGZyYWdtZW50QnlFbmQpIHtcbiAgICAgIHZhciBmID0gZnJhZ21lbnRCeUVuZFtrXTtcbiAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydF07XG4gICAgICBkZWxldGUgZi5zdGFydDtcbiAgICAgIGRlbGV0ZSBmLmVuZDtcbiAgICAgIGYuZm9yRWFjaChmdW5jdGlvbihpKSB7IHN0aXRjaGVkQXJjc1tpIDwgMCA/IH5pIDogaV0gPSAxOyB9KTtcbiAgICAgIGZyYWdtZW50cy5wdXNoKGYpO1xuICAgIH1cbiAgfVxuXG4gIGZsdXNoKGZyYWdtZW50QnlFbmQsIGZyYWdtZW50QnlTdGFydCk7XG4gIGZsdXNoKGZyYWdtZW50QnlTdGFydCwgZnJhZ21lbnRCeUVuZCk7XG4gIGFyY3MuZm9yRWFjaChmdW5jdGlvbihpKSB7IGlmICghc3RpdGNoZWRBcmNzW2kgPCAwID8gfmkgOiBpXSkgZnJhZ21lbnRzLnB1c2goW2ldKTsgfSk7XG5cbiAgcmV0dXJuIGZyYWdtZW50cztcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsIG4gPSBpbnB1dC5sZW5ndGgsIG91dHB1dCA9IG5ldyBBcnJheShuKTtcbiAgICBvdXRwdXRbMF0gPSAoeDAgKz0gaW5wdXRbMF0pICoga3ggKyBkeDtcbiAgICBvdXRwdXRbMV0gPSAoeTAgKz0gaW5wdXRbMV0pICoga3kgKyBkeTtcbiAgICB3aGlsZSAoaiA8IG4pIG91dHB1dFtqXSA9IGlucHV0W2pdLCArK2o7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcbn1cbiIsImltcG9ydCBpZGVudGl0eSBmcm9tIFwiLi9pZGVudGl0eS5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcbiAgaWYgKHRyYW5zZm9ybSA9PSBudWxsKSByZXR1cm4gaWRlbnRpdHk7XG4gIHZhciB4MCxcbiAgICAgIHkwLFxuICAgICAga3ggPSB0cmFuc2Zvcm0uc2NhbGVbMF0sXG4gICAgICBreSA9IHRyYW5zZm9ybS5zY2FsZVsxXSxcbiAgICAgIGR4ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVswXSxcbiAgICAgIGR5ID0gdHJhbnNmb3JtLnRyYW5zbGF0ZVsxXTtcbiAgcmV0dXJuIGZ1bmN0aW9uKGlucHV0LCBpKSB7XG4gICAgaWYgKCFpKSB4MCA9IHkwID0gMDtcbiAgICB2YXIgaiA9IDIsXG4gICAgICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgICAgIG91dHB1dCA9IG5ldyBBcnJheShuKSxcbiAgICAgICAgeDEgPSBNYXRoLnJvdW5kKChpbnB1dFswXSAtIGR4KSAvIGt4KSxcbiAgICAgICAgeTEgPSBNYXRoLnJvdW5kKChpbnB1dFsxXSAtIGR5KSAvIGt5KTtcbiAgICBvdXRwdXRbMF0gPSB4MSAtIHgwLCB4MCA9IHgxO1xuICAgIG91dHB1dFsxXSA9IHkxIC0geTAsIHkwID0geTE7XG4gICAgd2hpbGUgKGogPCBuKSBvdXRwdXRbal0gPSBpbnB1dFtqXSwgKytqO1xuICAgIHJldHVybiBvdXRwdXQ7XG4gIH07XG59XG4iLCJmdW5jdGlvbiBkb21DYW52YXModywgaCkge1xuICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KSB7XG4gICAgY29uc3QgYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIGlmIChjICYmIGMuZ2V0Q29udGV4dCkge1xuICAgICAgYy53aWR0aCA9IHc7XG4gICAgICBjLmhlaWdodCA9IGg7XG4gICAgICByZXR1cm4gYztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBkb21JbWFnZSA9ICgpID0+IHR5cGVvZiBJbWFnZSAhPT0gJ3VuZGVmaW5lZCcgPyBJbWFnZSA6IG51bGw7XG5cbmV4cG9ydCB7IGRvbUNhbnZhcyBhcyBjYW52YXMsIGRvbUNhbnZhcywgZG9tSW1hZ2UgYXMgaW1hZ2UgfTtcbiIsImltcG9ydCB7IGJpc2VjdExlZnQsIGJpc2VjdFJpZ2h0LCBwZXJtdXRlIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBpbmhlcml0cyB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbmNvbnN0IGFycmF5OCA9IG4gPT4gbmV3IFVpbnQ4QXJyYXkobik7XG5jb25zdCBhcnJheTE2ID0gbiA9PiBuZXcgVWludDE2QXJyYXkobik7XG5jb25zdCBhcnJheTMyID0gbiA9PiBuZXcgVWludDMyQXJyYXkobik7XG5cbi8qKlxuICogTWFpbnRhaW5zIENyb3NzRmlsdGVyIHN0YXRlLlxuICovXG5mdW5jdGlvbiBCaXRtYXBzKCkge1xuICBsZXQgd2lkdGggPSA4LFxuICAgIGRhdGEgPSBbXSxcbiAgICBzZWVuID0gYXJyYXkzMigwKSxcbiAgICBjdXJyID0gYXJyYXkoMCwgd2lkdGgpLFxuICAgIHByZXYgPSBhcnJheSgwLCB3aWR0aCk7XG4gIHJldHVybiB7XG4gICAgZGF0YTogKCkgPT4gZGF0YSxcbiAgICBzZWVuOiAoKSA9PiBzZWVuID0gbGVuZ3RoZW4oc2VlbiwgZGF0YS5sZW5ndGgpLFxuICAgIGFkZChhcnJheSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBkYXRhLmxlbmd0aCwgbiA9IGFycmF5Lmxlbmd0aCwgdDsgaSA8IG47ICsraSkge1xuICAgICAgICB0ID0gYXJyYXlbaV07XG4gICAgICAgIHQuX2luZGV4ID0gaisrO1xuICAgICAgICBkYXRhLnB1c2godCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmUobnVtLCBtYXApIHtcbiAgICAgIC8vIG1hcDogaW5kZXggLT4gYm9vbGVhbiAodHJ1ZSA9PiByZW1vdmUpXG4gICAgICBjb25zdCBuID0gZGF0YS5sZW5ndGgsXG4gICAgICAgIGNvcHkgPSBBcnJheShuIC0gbnVtKSxcbiAgICAgICAgcmVpbmRleCA9IGRhdGE7IC8vIHJldXNlIG9sZCBkYXRhIGFycmF5IGZvciBpbmRleCBtYXBcbiAgICAgIGxldCB0LCBpLCBqO1xuXG4gICAgICAvLyBzZWVrIGZvcndhcmQgdG8gZmlyc3QgcmVtb3ZhbFxuICAgICAgZm9yIChpID0gMDsgIW1hcFtpXSAmJiBpIDwgbjsgKytpKSB7XG4gICAgICAgIGNvcHlbaV0gPSBkYXRhW2ldO1xuICAgICAgICByZWluZGV4W2ldID0gaTtcbiAgICAgIH1cblxuICAgICAgLy8gY29uZGVuc2UgYXJyYXlzXG4gICAgICBmb3IgKGogPSBpOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHQgPSBkYXRhW2ldO1xuICAgICAgICBpZiAoIW1hcFtpXSkge1xuICAgICAgICAgIHJlaW5kZXhbaV0gPSBqO1xuICAgICAgICAgIGN1cnJbal0gPSBjdXJyW2ldO1xuICAgICAgICAgIHByZXZbal0gPSBwcmV2W2ldO1xuICAgICAgICAgIGNvcHlbal0gPSB0O1xuICAgICAgICAgIHQuX2luZGV4ID0gaisrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlaW5kZXhbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyW2ldID0gMDsgLy8gY2xlYXIgdW51c2VkIGJpdHNcbiAgICAgIH1cbiAgICAgIGRhdGEgPSBjb3B5O1xuICAgICAgcmV0dXJuIHJlaW5kZXg7XG4gICAgfSxcbiAgICBzaXplOiAoKSA9PiBkYXRhLmxlbmd0aCxcbiAgICBjdXJyOiAoKSA9PiBjdXJyLFxuICAgIHByZXY6ICgpID0+IHByZXYsXG4gICAgcmVzZXQ6IGsgPT4gcHJldltrXSA9IGN1cnJba10sXG4gICAgYWxsOiAoKSA9PiB3aWR0aCA8IDB4MTAxID8gMHhmZiA6IHdpZHRoIDwgMHgxMDAwMSA/IDB4ZmZmZiA6IDB4ZmZmZmZmZmYsXG4gICAgc2V0KGssIG9uZSkge1xuICAgICAgY3VycltrXSB8PSBvbmU7XG4gICAgfSxcbiAgICBjbGVhcihrLCBvbmUpIHtcbiAgICAgIGN1cnJba10gJj0gfm9uZTtcbiAgICB9LFxuICAgIHJlc2l6ZShuLCBtKSB7XG4gICAgICBjb25zdCBrID0gY3Vyci5sZW5ndGg7XG4gICAgICBpZiAobiA+IGsgfHwgbSA+IHdpZHRoKSB7XG4gICAgICAgIHdpZHRoID0gTWF0aC5tYXgobSwgd2lkdGgpO1xuICAgICAgICBjdXJyID0gYXJyYXkobiwgd2lkdGgsIGN1cnIpO1xuICAgICAgICBwcmV2ID0gYXJyYXkobiwgd2lkdGgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGxlbmd0aGVuKGFycmF5LCBsZW5ndGgsIGNvcHkpIHtcbiAgaWYgKGFycmF5Lmxlbmd0aCA+PSBsZW5ndGgpIHJldHVybiBhcnJheTtcbiAgY29weSA9IGNvcHkgfHwgbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG4gIGNvcHkuc2V0KGFycmF5KTtcbiAgcmV0dXJuIGNvcHk7XG59XG5mdW5jdGlvbiBhcnJheShuLCBtLCBhcnJheSkge1xuICBjb25zdCBjb3B5ID0gKG0gPCAweDEwMSA/IGFycmF5OCA6IG0gPCAweDEwMDAxID8gYXJyYXkxNiA6IGFycmF5MzIpKG4pO1xuICBpZiAoYXJyYXkpIGNvcHkuc2V0KGFycmF5KTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIERpbWVuc2lvbiAoaW5kZXgsIGksIHF1ZXJ5KSB7XG4gIGNvbnN0IGJpdCA9IDEgPDwgaTtcbiAgcmV0dXJuIHtcbiAgICBvbmU6IGJpdCxcbiAgICB6ZXJvOiB+Yml0LFxuICAgIHJhbmdlOiBxdWVyeS5zbGljZSgpLFxuICAgIGJpc2VjdDogaW5kZXguYmlzZWN0LFxuICAgIGluZGV4OiBpbmRleC5pbmRleCxcbiAgICBzaXplOiBpbmRleC5zaXplLFxuICAgIG9uQWRkKGFkZGVkLCBjdXJyKSB7XG4gICAgICBjb25zdCBkaW0gPSB0aGlzLFxuICAgICAgICByYW5nZSA9IGRpbS5iaXNlY3QoZGltLnJhbmdlLCBhZGRlZC52YWx1ZSksXG4gICAgICAgIGlkeCA9IGFkZGVkLmluZGV4LFxuICAgICAgICBsbyA9IHJhbmdlWzBdLFxuICAgICAgICBoaSA9IHJhbmdlWzFdLFxuICAgICAgICBuMSA9IGlkeC5sZW5ndGg7XG4gICAgICBsZXQgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsbzsgKytpKSBjdXJyW2lkeFtpXV0gfD0gYml0O1xuICAgICAgZm9yIChpID0gaGk7IGkgPCBuMTsgKytpKSBjdXJyW2lkeFtpXV0gfD0gYml0O1xuICAgICAgcmV0dXJuIGRpbTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogTWFpbnRhaW5zIGEgbGlzdCBvZiB2YWx1ZXMsIHNvcnRlZCBieSBrZXkuXG4gKi9cbmZ1bmN0aW9uIFNvcnRlZEluZGV4KCkge1xuICBsZXQgaW5kZXggPSBhcnJheTMyKDApLFxuICAgIHZhbHVlID0gW10sXG4gICAgc2l6ZSA9IDA7XG4gIGZ1bmN0aW9uIGluc2VydChrZXksIGRhdGEsIGJhc2UpIHtcbiAgICBpZiAoIWRhdGEubGVuZ3RoKSByZXR1cm4gW107XG4gICAgY29uc3QgbjAgPSBzaXplLFxuICAgICAgbjEgPSBkYXRhLmxlbmd0aCxcbiAgICAgIGFkZGkgPSBhcnJheTMyKG4xKTtcbiAgICBsZXQgYWRkdiA9IEFycmF5KG4xKSxcbiAgICAgIG9sZHYsXG4gICAgICBvbGRpLFxuICAgICAgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbjE7ICsraSkge1xuICAgICAgYWRkdltpXSA9IGtleShkYXRhW2ldKTtcbiAgICAgIGFkZGlbaV0gPSBpO1xuICAgIH1cbiAgICBhZGR2ID0gc29ydChhZGR2LCBhZGRpKTtcbiAgICBpZiAobjApIHtcbiAgICAgIG9sZHYgPSB2YWx1ZTtcbiAgICAgIG9sZGkgPSBpbmRleDtcbiAgICAgIHZhbHVlID0gQXJyYXkobjAgKyBuMSk7XG4gICAgICBpbmRleCA9IGFycmF5MzIobjAgKyBuMSk7XG4gICAgICBtZXJnZShiYXNlLCBvbGR2LCBvbGRpLCBuMCwgYWRkdiwgYWRkaSwgbjEsIHZhbHVlLCBpbmRleCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChiYXNlID4gMCkgZm9yIChpID0gMDsgaSA8IG4xOyArK2kpIHtcbiAgICAgICAgYWRkaVtpXSArPSBiYXNlO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBhZGR2O1xuICAgICAgaW5kZXggPSBhZGRpO1xuICAgIH1cbiAgICBzaXplID0gbjAgKyBuMTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5kZXg6IGFkZGksXG4gICAgICB2YWx1ZTogYWRkdlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlKG51bSwgbWFwKSB7XG4gICAgLy8gbWFwOiBpbmRleCAtPiByZW1vdmVcbiAgICBjb25zdCBuID0gc2l6ZTtcbiAgICBsZXQgaWR4LCBpLCBqO1xuXG4gICAgLy8gc2VlayBmb3J3YXJkIHRvIGZpcnN0IHJlbW92YWxcbiAgICBmb3IgKGkgPSAwOyAhbWFwW2luZGV4W2ldXSAmJiBpIDwgbjsgKytpKTtcblxuICAgIC8vIGNvbmRlbnNlIGluZGV4IGFuZCB2YWx1ZSBhcnJheXNcbiAgICBmb3IgKGogPSBpOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoIW1hcFtpZHggPSBpbmRleFtpXV0pIHtcbiAgICAgICAgaW5kZXhbal0gPSBpZHg7XG4gICAgICAgIHZhbHVlW2pdID0gdmFsdWVbaV07XG4gICAgICAgICsrajtcbiAgICAgIH1cbiAgICB9XG4gICAgc2l6ZSA9IG4gLSBudW07XG4gIH1cbiAgZnVuY3Rpb24gcmVpbmRleChtYXApIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbiA9IHNpemU7IGkgPCBuOyArK2kpIHtcbiAgICAgIGluZGV4W2ldID0gbWFwW2luZGV4W2ldXTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gYmlzZWN0KHJhbmdlLCBhcnJheSkge1xuICAgIGxldCBuO1xuICAgIGlmIChhcnJheSkge1xuICAgICAgbiA9IGFycmF5Lmxlbmd0aDtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJyYXkgPSB2YWx1ZTtcbiAgICAgIG4gPSBzaXplO1xuICAgIH1cbiAgICByZXR1cm4gW2Jpc2VjdExlZnQoYXJyYXksIHJhbmdlWzBdLCAwLCBuKSwgYmlzZWN0UmlnaHQoYXJyYXksIHJhbmdlWzFdLCAwLCBuKV07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBpbnNlcnQ6IGluc2VydCxcbiAgICByZW1vdmU6IHJlbW92ZSxcbiAgICBiaXNlY3Q6IGJpc2VjdCxcbiAgICByZWluZGV4OiByZWluZGV4LFxuICAgIGluZGV4OiAoKSA9PiBpbmRleCxcbiAgICBzaXplOiAoKSA9PiBzaXplXG4gIH07XG59XG5mdW5jdGlvbiBzb3J0KHZhbHVlcywgaW5kZXgpIHtcbiAgdmFsdWVzLnNvcnQuY2FsbChpbmRleCwgKGEsIGIpID0+IHtcbiAgICBjb25zdCB4ID0gdmFsdWVzW2FdLFxuICAgICAgeSA9IHZhbHVlc1tiXTtcbiAgICByZXR1cm4geCA8IHkgPyAtMSA6IHggPiB5ID8gMSA6IDA7XG4gIH0pO1xuICByZXR1cm4gcGVybXV0ZSh2YWx1ZXMsIGluZGV4KTtcbn1cbmZ1bmN0aW9uIG1lcmdlKGJhc2UsIHZhbHVlMCwgaW5kZXgwLCBuMCwgdmFsdWUxLCBpbmRleDEsIG4xLCB2YWx1ZSwgaW5kZXgpIHtcbiAgbGV0IGkwID0gMCxcbiAgICBpMSA9IDAsXG4gICAgaTtcbiAgZm9yIChpID0gMDsgaTAgPCBuMCAmJiBpMSA8IG4xOyArK2kpIHtcbiAgICBpZiAodmFsdWUwW2kwXSA8IHZhbHVlMVtpMV0pIHtcbiAgICAgIHZhbHVlW2ldID0gdmFsdWUwW2kwXTtcbiAgICAgIGluZGV4W2ldID0gaW5kZXgwW2kwKytdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZVtpXSA9IHZhbHVlMVtpMV07XG4gICAgICBpbmRleFtpXSA9IGluZGV4MVtpMSsrXSArIGJhc2U7XG4gICAgfVxuICB9XG4gIGZvciAoOyBpMCA8IG4wOyArK2kwLCArK2kpIHtcbiAgICB2YWx1ZVtpXSA9IHZhbHVlMFtpMF07XG4gICAgaW5kZXhbaV0gPSBpbmRleDBbaTBdO1xuICB9XG4gIGZvciAoOyBpMSA8IG4xOyArK2kxLCArK2kpIHtcbiAgICB2YWx1ZVtpXSA9IHZhbHVlMVtpMV07XG4gICAgaW5kZXhbaV0gPSBpbmRleDFbaTFdICsgYmFzZTtcbiAgfVxufVxuXG4vKipcbiAqIEFuIGluZGV4ZWQgbXVsdGktZGltZW5zaW9uYWwgZmlsdGVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMuZmllbGRzIC0gQW4gYXJyYXkgb2YgZGltZW5zaW9uIGFjY2Vzc29ycyB0byBmaWx0ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMucXVlcnkgLSBBbiBhcnJheSBvZiBwZXItZGltZW5zaW9uIHJhbmdlIHF1ZXJpZXMuXG4gKi9cbmZ1bmN0aW9uIENyb3NzRmlsdGVyKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBCaXRtYXBzKCksIHBhcmFtcyk7XG4gIHRoaXMuX2luZGljZXMgPSBudWxsO1xuICB0aGlzLl9kaW1zID0gbnVsbDtcbn1cbkNyb3NzRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0Nyb3NzRmlsdGVyJyxcbiAgJ21ldGFkYXRhJzoge30sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncXVlcnknLFxuICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWUsXG4gICAgJ2NvbnRlbnQnOiB7XG4gICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAgICdsZW5ndGgnOiAyXG4gICAgfVxuICB9XVxufTtcbmluaGVyaXRzKENyb3NzRmlsdGVyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCF0aGlzLl9kaW1zKSB7XG4gICAgICByZXR1cm4gdGhpcy5pbml0KF8sIHB1bHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGluaXQgPSBfLm1vZGlmaWVkKCdmaWVsZHMnKSB8fCBfLmZpZWxkcy5zb21lKGYgPT4gcHVsc2UubW9kaWZpZWQoZi5maWVsZHMpKTtcbiAgICAgIHJldHVybiBpbml0ID8gdGhpcy5yZWluaXQoXywgcHVsc2UpIDogdGhpcy5ldmFsKF8sIHB1bHNlKTtcbiAgICB9XG4gIH0sXG4gIGluaXQoXywgcHVsc2UpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgIGluZGljZXMgPSB0aGlzLl9pbmRpY2VzID0ge30sXG4gICAgICBkaW1zID0gdGhpcy5fZGltcyA9IFtdLFxuICAgICAgbSA9IHF1ZXJ5Lmxlbmd0aDtcbiAgICBsZXQgaSA9IDAsXG4gICAgICBrZXksXG4gICAgICBpbmRleDtcblxuICAgIC8vIGluc3RhbnRpYXRlIGluZGljZXMgYW5kIGRpbWVuc2lvbnNcbiAgICBmb3IgKDsgaSA8IG07ICsraSkge1xuICAgICAga2V5ID0gZmllbGRzW2ldLmZuYW1lO1xuICAgICAgaW5kZXggPSBpbmRpY2VzW2tleV0gfHwgKGluZGljZXNba2V5XSA9IFNvcnRlZEluZGV4KCkpO1xuICAgICAgZGltcy5wdXNoKERpbWVuc2lvbihpbmRleCwgaSwgcXVlcnlbaV0pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXZhbChfLCBwdWxzZSk7XG4gIH0sXG4gIHJlaW5pdChfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dHB1dCA9IHB1bHNlLm1hdGVyaWFsaXplKCkuZm9yaygpLFxuICAgICAgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICBxdWVyeSA9IF8ucXVlcnksXG4gICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgIGRpbXMgPSB0aGlzLl9kaW1zLFxuICAgICAgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICBwcmV2ID0gYml0cy5wcmV2KCksXG4gICAgICBhbGwgPSBiaXRzLmFsbCgpLFxuICAgICAgb3V0ID0gb3V0cHV0LnJlbSA9IG91dHB1dC5hZGQsXG4gICAgICBtb2QgPSBvdXRwdXQubW9kLFxuICAgICAgbSA9IHF1ZXJ5Lmxlbmd0aCxcbiAgICAgIGFkZHMgPSB7fTtcbiAgICBsZXQgYWRkLCBpbmRleCwga2V5LCBtb2RzLCByZW1NYXAsIG1vZE1hcCwgaSwgbiwgZjtcblxuICAgIC8vIHNldCBwcmV2IHRvIGN1cnJlbnQgc3RhdGVcbiAgICBwcmV2LnNldChjdXJyKTtcblxuICAgIC8vIGlmIHB1bHNlIGhhcyByZW1vdmUgdHVwbGVzLCBwcm9jZXNzIHRoZW0gZmlyc3RcbiAgICBpZiAocHVsc2UucmVtLmxlbmd0aCkge1xuICAgICAgcmVtTWFwID0gdGhpcy5yZW1vdmUoXywgcHVsc2UsIG91dHB1dCk7XG4gICAgfVxuXG4gICAgLy8gaWYgcHVsc2UgaGFzIGFkZGVkIHR1cGxlcywgYWRkIHRoZW0gdG8gc3RhdGVcbiAgICBpZiAocHVsc2UuYWRkLmxlbmd0aCkge1xuICAgICAgYml0cy5hZGQocHVsc2UuYWRkKTtcbiAgICB9XG5cbiAgICAvLyBpZiBwdWxzZSBoYXMgbW9kaWZpZWQgdHVwbGVzLCBjcmVhdGUgYW4gaW5kZXggbWFwXG4gICAgaWYgKHB1bHNlLm1vZC5sZW5ndGgpIHtcbiAgICAgIG1vZE1hcCA9IHt9O1xuICAgICAgZm9yIChtb2RzID0gcHVsc2UubW9kLCBpID0gMCwgbiA9IG1vZHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG1vZE1hcFttb2RzW2ldLl9pbmRleF0gPSAxO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlLWluaXRpYWxpemUgaW5kaWNlcyBhcyBuZWVkZWQsIHVwZGF0ZSBjdXJyIGJpdG1hcFxuICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgIGYgPSBmaWVsZHNbaV07XG4gICAgICBpZiAoIWRpbXNbaV0gfHwgXy5tb2RpZmllZCgnZmllbGRzJywgaSkgfHwgcHVsc2UubW9kaWZpZWQoZi5maWVsZHMpKSB7XG4gICAgICAgIGtleSA9IGYuZm5hbWU7XG4gICAgICAgIGlmICghKGFkZCA9IGFkZHNba2V5XSkpIHtcbiAgICAgICAgICBpbmRpY2VzW2tleV0gPSBpbmRleCA9IFNvcnRlZEluZGV4KCk7XG4gICAgICAgICAgYWRkc1trZXldID0gYWRkID0gaW5kZXguaW5zZXJ0KGYsIHB1bHNlLnNvdXJjZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZGltc1tpXSA9IERpbWVuc2lvbihpbmRleCwgaSwgcXVlcnlbaV0pLm9uQWRkKGFkZCwgY3Vycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gdmlzaXQgZWFjaCB0dXBsZVxuICAgIC8vIGlmIGZpbHRlciBzdGF0ZSBjaGFuZ2VkLCBwdXNoIGluZGV4IHRvIGFkZC9yZW1cbiAgICAvLyBlbHNlIGlmIGluIG1vZCBhbmQgcGFzc2VzIGEgZmlsdGVyLCBwdXNoIGluZGV4IHRvIG1vZFxuICAgIGZvciAoaSA9IDAsIG4gPSBiaXRzLmRhdGEoKS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChyZW1NYXBbaV0pIHtcbiAgICAgICAgLy8gc2tpcCBpZiByZW1vdmVkIHR1cGxlXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChwcmV2W2ldICE9PSBjdXJyW2ldKSB7XG4gICAgICAgIC8vIGFkZCBpZiBzdGF0ZSBjaGFuZ2VkXG4gICAgICAgIG91dC5wdXNoKGkpO1xuICAgICAgfSBlbHNlIGlmIChtb2RNYXBbaV0gJiYgY3VycltpXSAhPT0gYWxsKSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSwgcGFzcyBtb2RzIHRocm91Z2hcbiAgICAgICAgbW9kLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGJpdHMubWFzayA9ICgxIDw8IG0pIC0gMTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuICBldmFsKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gcHVsc2UubWF0ZXJpYWxpemUoKS5mb3JrKCksXG4gICAgICBtID0gdGhpcy5fZGltcy5sZW5ndGg7XG4gICAgbGV0IG1hc2sgPSAwO1xuICAgIGlmIChwdWxzZS5yZW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLnJlbW92ZShfLCBwdWxzZSwgb3V0cHV0KTtcbiAgICAgIG1hc2sgfD0gKDEgPDwgbSkgLSAxO1xuICAgIH1cbiAgICBpZiAoXy5tb2RpZmllZCgncXVlcnknKSAmJiAhXy5tb2RpZmllZCgnZmllbGRzJykpIHtcbiAgICAgIG1hc2sgfD0gdGhpcy51cGRhdGUoXywgcHVsc2UsIG91dHB1dCk7XG4gICAgfVxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICB0aGlzLmluc2VydChfLCBwdWxzZSwgb3V0cHV0KTtcbiAgICAgIG1hc2sgfD0gKDEgPDwgbSkgLSAxO1xuICAgIH1cbiAgICBpZiAocHVsc2UubW9kLmxlbmd0aCkge1xuICAgICAgdGhpcy5tb2RpZnkocHVsc2UsIG91dHB1dCk7XG4gICAgICBtYXNrIHw9ICgxIDw8IG0pIC0gMTtcbiAgICB9XG4gICAgdGhpcy52YWx1ZS5tYXNrID0gbWFzaztcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9LFxuICBpbnNlcnQoXywgcHVsc2UsIG91dHB1dCkge1xuICAgIGNvbnN0IHR1cGxlcyA9IHB1bHNlLmFkZCxcbiAgICAgIGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgYWRkcyA9IHt9LFxuICAgICAgb3V0ID0gb3V0cHV0LmFkZCxcbiAgICAgIG4gPSBiaXRzLnNpemUoKSArIHR1cGxlcy5sZW5ndGgsXG4gICAgICBtID0gZGltcy5sZW5ndGg7XG4gICAgbGV0IGsgPSBiaXRzLnNpemUoKSxcbiAgICAgIGosXG4gICAgICBrZXksXG4gICAgICBhZGQ7XG5cbiAgICAvLyByZXNpemUgYml0bWFwcyBhbmQgYWRkIHR1cGxlcyBhcyBuZWVkZWRcbiAgICBiaXRzLnJlc2l6ZShuLCBtKTtcbiAgICBiaXRzLmFkZCh0dXBsZXMpO1xuICAgIGNvbnN0IGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgIHByZXYgPSBiaXRzLnByZXYoKSxcbiAgICAgIGFsbCA9IGJpdHMuYWxsKCk7XG5cbiAgICAvLyBhZGQgdG8gZGltZW5zaW9uYWwgaW5kaWNlc1xuICAgIGZvciAoaiA9IDA7IGogPCBtOyArK2opIHtcbiAgICAgIGtleSA9IGZpZWxkc1tqXS5mbmFtZTtcbiAgICAgIGFkZCA9IGFkZHNba2V5XSB8fCAoYWRkc1trZXldID0gaW5kaWNlc1trZXldLmluc2VydChmaWVsZHNbal0sIHR1cGxlcywgaykpO1xuICAgICAgZGltc1tqXS5vbkFkZChhZGQsIGN1cnIpO1xuICAgIH1cblxuICAgIC8vIHNldCBwcmV2aW91cyBmaWx0ZXJzLCBvdXRwdXQgaWYgcGFzc2VzIGF0IGxlYXN0IG9uZSBmaWx0ZXJcbiAgICBmb3IgKDsgayA8IG47ICsraykge1xuICAgICAgcHJldltrXSA9IGFsbDtcbiAgICAgIGlmIChjdXJyW2tdICE9PSBhbGwpIG91dC5wdXNoKGspO1xuICAgIH1cbiAgfSxcbiAgbW9kaWZ5KHB1bHNlLCBvdXRwdXQpIHtcbiAgICBjb25zdCBvdXQgPSBvdXRwdXQubW9kLFxuICAgICAgYml0cyA9IHRoaXMudmFsdWUsXG4gICAgICBjdXJyID0gYml0cy5jdXJyKCksXG4gICAgICBhbGwgPSBiaXRzLmFsbCgpLFxuICAgICAgdHVwbGVzID0gcHVsc2UubW9kO1xuICAgIGxldCBpLCBuLCBrO1xuICAgIGZvciAoaSA9IDAsIG4gPSB0dXBsZXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBrID0gdHVwbGVzW2ldLl9pbmRleDtcbiAgICAgIGlmIChjdXJyW2tdICE9PSBhbGwpIG91dC5wdXNoKGspO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlKF8sIHB1bHNlLCBvdXRwdXQpIHtcbiAgICBjb25zdCBpbmRpY2VzID0gdGhpcy5faW5kaWNlcyxcbiAgICAgIGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgYWxsID0gYml0cy5hbGwoKSxcbiAgICAgIG1hcCA9IHt9LFxuICAgICAgb3V0ID0gb3V0cHV0LnJlbSxcbiAgICAgIHR1cGxlcyA9IHB1bHNlLnJlbTtcbiAgICBsZXQgaSwgbiwgaywgZjtcblxuICAgIC8vIHByb2Nlc3MgdHVwbGVzLCBvdXRwdXQgaWYgcGFzc2VzIGF0IGxlYXN0IG9uZSBmaWx0ZXJcbiAgICBmb3IgKGkgPSAwLCBuID0gdHVwbGVzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgayA9IHR1cGxlc1tpXS5faW5kZXg7XG4gICAgICBtYXBba10gPSAxOyAvLyBidWlsZCBpbmRleCBtYXBcbiAgICAgIHByZXZba10gPSBmID0gY3VycltrXTtcbiAgICAgIGN1cnJba10gPSBhbGw7XG4gICAgICBpZiAoZiAhPT0gYWxsKSBvdXQucHVzaChrKTtcbiAgICB9XG5cbiAgICAvLyByZW1vdmUgZnJvbSBkaW1lbnNpb25hbCBpbmRpY2VzXG4gICAgZm9yIChrIGluIGluZGljZXMpIHtcbiAgICAgIGluZGljZXNba10ucmVtb3ZlKG4sIG1hcCk7XG4gICAgfVxuICAgIHRoaXMucmVpbmRleChwdWxzZSwgbiwgbWFwKTtcbiAgICByZXR1cm4gbWFwO1xuICB9LFxuICAvLyByZWluZGV4IGZpbHRlcnMgYW5kIGluZGljZXMgYWZ0ZXIgcHJvcGFnYXRpb24gY29tcGxldGVzXG4gIHJlaW5kZXgocHVsc2UsIG51bSwgbWFwKSB7XG4gICAgY29uc3QgaW5kaWNlcyA9IHRoaXMuX2luZGljZXMsXG4gICAgICBiaXRzID0gdGhpcy52YWx1ZTtcbiAgICBwdWxzZS5ydW5BZnRlcigoKSA9PiB7XG4gICAgICBjb25zdCBpbmRleE1hcCA9IGJpdHMucmVtb3ZlKG51bSwgbWFwKTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGluZGljZXMpIGluZGljZXNba2V5XS5yZWluZGV4KGluZGV4TWFwKTtcbiAgICB9KTtcbiAgfSxcbiAgdXBkYXRlKF8sIHB1bHNlLCBvdXRwdXQpIHtcbiAgICBjb25zdCBkaW1zID0gdGhpcy5fZGltcyxcbiAgICAgIHF1ZXJ5ID0gXy5xdWVyeSxcbiAgICAgIHN0YW1wID0gcHVsc2Uuc3RhbXAsXG4gICAgICBtID0gZGltcy5sZW5ndGg7XG4gICAgbGV0IG1hc2sgPSAwLFxuICAgICAgaSxcbiAgICAgIHE7XG5cbiAgICAvLyBzdXJ2ZXkgaG93IG1hbnkgcXVlcmllcyBoYXZlIGNoYW5nZWRcbiAgICBvdXRwdXQuZmlsdGVycyA9IDA7XG4gICAgZm9yIChxID0gMDsgcSA8IG07ICsrcSkge1xuICAgICAgaWYgKF8ubW9kaWZpZWQoJ3F1ZXJ5JywgcSkpIHtcbiAgICAgICAgaSA9IHE7XG4gICAgICAgICsrbWFzaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1hc2sgPT09IDEpIHtcbiAgICAgIC8vIG9ubHkgb25lIHF1ZXJ5IGNoYW5nZWQsIHVzZSBtb3JlIGVmZmljaWVudCB1cGRhdGVcbiAgICAgIG1hc2sgPSBkaW1zW2ldLm9uZTtcbiAgICAgIHRoaXMuaW5jcmVtZW50T25lKGRpbXNbaV0sIHF1ZXJ5W2ldLCBvdXRwdXQuYWRkLCBvdXRwdXQucmVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbXVsdGlwbGUgcXVlcmllcyBjaGFuZ2VkLCBwZXJmb3JtIGZ1bGwgcmVjb3JkIGtlZXBpbmdcbiAgICAgIGZvciAocSA9IDAsIG1hc2sgPSAwOyBxIDwgbTsgKytxKSB7XG4gICAgICAgIGlmICghXy5tb2RpZmllZCgncXVlcnknLCBxKSkgY29udGludWU7XG4gICAgICAgIG1hc2sgfD0gZGltc1txXS5vbmU7XG4gICAgICAgIHRoaXMuaW5jcmVtZW50QWxsKGRpbXNbcV0sIHF1ZXJ5W3FdLCBzdGFtcCwgb3V0cHV0LmFkZCk7XG4gICAgICAgIG91dHB1dC5yZW0gPSBvdXRwdXQuYWRkOyAvLyBkdXBsaWNhdGUgYWRkL3JlbSBmb3IgZG93bnN0cmVhbSByZXNvbHZlXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBtYXNrO1xuICB9LFxuICBpbmNyZW1lbnRBbGwoZGltLCBxdWVyeSwgc3RhbXAsIG91dCkge1xuICAgIGNvbnN0IGJpdHMgPSB0aGlzLnZhbHVlLFxuICAgICAgc2VlbiA9IGJpdHMuc2VlbigpLFxuICAgICAgY3VyciA9IGJpdHMuY3VycigpLFxuICAgICAgcHJldiA9IGJpdHMucHJldigpLFxuICAgICAgaW5kZXggPSBkaW0uaW5kZXgoKSxcbiAgICAgIG9sZCA9IGRpbS5iaXNlY3QoZGltLnJhbmdlKSxcbiAgICAgIHJhbmdlID0gZGltLmJpc2VjdChxdWVyeSksXG4gICAgICBsbzEgPSByYW5nZVswXSxcbiAgICAgIGhpMSA9IHJhbmdlWzFdLFxuICAgICAgbG8wID0gb2xkWzBdLFxuICAgICAgaGkwID0gb2xkWzFdLFxuICAgICAgb25lID0gZGltLm9uZTtcbiAgICBsZXQgaSwgaiwgaztcblxuICAgIC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGxvIGluZGV4LlxuICAgIGlmIChsbzEgPCBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMSwgaiA9IE1hdGgubWluKGxvMCwgaGkxKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGlmIChzZWVuW2tdICE9PSBzdGFtcCkge1xuICAgICAgICAgIHByZXZba10gPSBjdXJyW2tdO1xuICAgICAgICAgIHNlZW5ba10gPSBzdGFtcDtcbiAgICAgICAgICBvdXQucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGxvMSA+IGxvMCkge1xuICAgICAgZm9yIChpID0gbG8wLCBqID0gTWF0aC5taW4obG8xLCBoaTApOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcbiAgICAgICAgaWYgKHNlZW5ba10gIT09IHN0YW1wKSB7XG4gICAgICAgICAgcHJldltrXSA9IGN1cnJba107XG4gICAgICAgICAgc2VlbltrXSA9IHN0YW1wO1xuICAgICAgICAgIG91dC5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZhc3QgaW5jcmVtZW50YWwgdXBkYXRlIGJhc2VkIG9uIHByZXZpb3VzIGhpIGluZGV4LlxuICAgIGlmIChoaTEgPiBoaTApIHtcbiAgICAgIGZvciAoaSA9IE1hdGgubWF4KGxvMSwgaGkwKSwgaiA9IGhpMTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGlmIChzZWVuW2tdICE9PSBzdGFtcCkge1xuICAgICAgICAgIHByZXZba10gPSBjdXJyW2tdO1xuICAgICAgICAgIHNlZW5ba10gPSBzdGFtcDtcbiAgICAgICAgICBvdXQucHVzaChrKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGhpMSA8IGhpMCkge1xuICAgICAgZm9yIChpID0gTWF0aC5tYXgobG8wLCBoaTEpLCBqID0gaGkwOyBpIDwgajsgKytpKSB7XG4gICAgICAgIGsgPSBpbmRleFtpXTtcbiAgICAgICAgaWYgKHNlZW5ba10gIT09IHN0YW1wKSB7XG4gICAgICAgICAgcHJldltrXSA9IGN1cnJba107XG4gICAgICAgICAgc2VlbltrXSA9IHN0YW1wO1xuICAgICAgICAgIG91dC5wdXNoKGspO1xuICAgICAgICB9XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgfVxuICAgIH1cbiAgICBkaW0ucmFuZ2UgPSBxdWVyeS5zbGljZSgpO1xuICB9LFxuICBpbmNyZW1lbnRPbmUoZGltLCBxdWVyeSwgYWRkLCByZW0pIHtcbiAgICBjb25zdCBiaXRzID0gdGhpcy52YWx1ZSxcbiAgICAgIGN1cnIgPSBiaXRzLmN1cnIoKSxcbiAgICAgIGluZGV4ID0gZGltLmluZGV4KCksXG4gICAgICBvbGQgPSBkaW0uYmlzZWN0KGRpbS5yYW5nZSksXG4gICAgICByYW5nZSA9IGRpbS5iaXNlY3QocXVlcnkpLFxuICAgICAgbG8xID0gcmFuZ2VbMF0sXG4gICAgICBoaTEgPSByYW5nZVsxXSxcbiAgICAgIGxvMCA9IG9sZFswXSxcbiAgICAgIGhpMCA9IG9sZFsxXSxcbiAgICAgIG9uZSA9IGRpbS5vbmU7XG4gICAgbGV0IGksIGosIGs7XG5cbiAgICAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBsbyBpbmRleC5cbiAgICBpZiAobG8xIDwgbG8wKSB7XG4gICAgICBmb3IgKGkgPSBsbzEsIGogPSBNYXRoLm1pbihsbzAsIGhpMSk7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgICAgYWRkLnB1c2goayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsbzEgPiBsbzApIHtcbiAgICAgIGZvciAoaSA9IGxvMCwgaiA9IE1hdGgubWluKGxvMSwgaGkwKTsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICByZW0ucHVzaChrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGYXN0IGluY3JlbWVudGFsIHVwZGF0ZSBiYXNlZCBvbiBwcmV2aW91cyBoaSBpbmRleC5cbiAgICBpZiAoaGkxID4gaGkwKSB7XG4gICAgICBmb3IgKGkgPSBNYXRoLm1heChsbzEsIGhpMCksIGogPSBoaTE7IGkgPCBqOyArK2kpIHtcbiAgICAgICAgayA9IGluZGV4W2ldO1xuICAgICAgICBjdXJyW2tdIF49IG9uZTtcbiAgICAgICAgYWRkLnB1c2goayk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChoaTEgPCBoaTApIHtcbiAgICAgIGZvciAoaSA9IE1hdGgubWF4KGxvMCwgaGkxKSwgaiA9IGhpMDsgaSA8IGo7ICsraSkge1xuICAgICAgICBrID0gaW5kZXhbaV07XG4gICAgICAgIGN1cnJba10gXj0gb25lO1xuICAgICAgICByZW0ucHVzaChrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZGltLnJhbmdlID0gcXVlcnkuc2xpY2UoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogU2VsZWN0aXZlbHkgZmlsdGVycyB0dXBsZXMgYnkgcmVzb2x2aW5nIGFnYWluc3QgYSBmaWx0ZXIgYml0bWFwLlxuICogVXNlZnVsIGZvciBwcm9jZXNzaW5nIHRoZSBvdXRwdXQgb2YgYSBjcm9zcy1maWx0ZXIgdHJhbnNmb3JtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmlnbm9yZSAtIEEgYml0IG1hc2sgaW5kaWNhdGluZyB3aGljaCBmaWx0ZXJzIHRvIGlnbm9yZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMuZmlsdGVyIC0gVGhlIHBlci10dXBsZSBmaWx0ZXIgYml0bWFwcy4gVHlwaWNhbGx5IHRoaXNcbiAqICAgcGFyYW1ldGVyIHZhbHVlIGlzIGEgcmVmZXJlbmNlIHRvIGEge0BsaW5rIENyb3NzRmlsdGVyfSB0cmFuc2Zvcm0uXG4gKi9cbmZ1bmN0aW9uIFJlc29sdmVGaWx0ZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5SZXNvbHZlRmlsdGVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1Jlc29sdmVGaWx0ZXInLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnaWdub3JlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdyZXF1aXJlZCc6IHRydWUsXG4gICAgJ2Rlc2NyaXB0aW9uJzogJ0EgYml0IG1hc2sgaW5kaWNhdGluZyB3aGljaCBmaWx0ZXJzIHRvIGlnbm9yZS4nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWx0ZXInLFxuICAgICd0eXBlJzogJ29iamVjdCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnZGVzY3JpcHRpb24nOiAnUGVyLXR1cGxlIGZpbHRlciBiaXRtYXBzIGZyb20gYSBDcm9zc0ZpbHRlciB0cmFuc2Zvcm0uJ1xuICB9XVxufTtcbmluaGVyaXRzKFJlc29sdmVGaWx0ZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBpZ25vcmUgPSB+KF8uaWdub3JlIHx8IDApLFxuICAgICAgLy8gYml0IG1hc2sgd2hlcmUgemVyb3MgLT4gZGltcyB0byBpZ25vcmVcbiAgICAgIGJpdG1hcCA9IF8uZmlsdGVyLFxuICAgICAgbWFzayA9IGJpdG1hcC5tYXNrO1xuXG4gICAgLy8gZXhpdCBlYXJseSBpZiBubyByZWxldmFudCBmaWx0ZXIgY2hhbmdlc1xuICAgIGlmICgobWFzayAmIGlnbm9yZSkgPT09IDApIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgY29uc3Qgb3V0cHV0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgZGF0YSA9IGJpdG1hcC5kYXRhKCksXG4gICAgICBjdXJyID0gYml0bWFwLmN1cnIoKSxcbiAgICAgIHByZXYgPSBiaXRtYXAucHJldigpLFxuICAgICAgcGFzcyA9IGsgPT4gIShjdXJyW2tdICYgaWdub3JlKSA/IGRhdGFba10gOiBudWxsO1xuXG4gICAgLy8gcHJvcGFnYXRlIGFsbCBtb2QgdHVwbGVzIHRoYXQgcGFzcyB0aGUgZmlsdGVyXG4gICAgb3V0cHV0LmZpbHRlcihvdXRwdXQuTU9ELCBwYXNzKTtcblxuICAgIC8vIGRldGVybWluZSBhZGQgJiByZW0gdHVwbGVzIHZpYSBmaWx0ZXIgZnVuY3Rpb25zXG4gICAgLy8gZm9yIGVmZmljaWVuY3ksIHdlIGRvICpub3QqIHBvcHVsYXRlIG5ldyBhcnJheXMsXG4gICAgLy8gaW5zdGVhZCB3ZSBhZGQgZmlsdGVyIGZ1bmN0aW9ucyBhcHBsaWVkIGRvd25zdHJlYW1cblxuICAgIGlmICghKG1hc2sgJiBtYXNrIC0gMSkpIHtcbiAgICAgIC8vIG9ubHkgb25lIGZpbHRlciBjaGFuZ2VkXG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5BREQsIHBhc3MpO1xuICAgICAgb3V0cHV0LmZpbHRlcihvdXRwdXQuUkVNLCBrID0+IChjdXJyW2tdICYgaWdub3JlKSA9PT0gbWFzayA/IGRhdGFba10gOiBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbXVsdGlwbGUgZmlsdGVycyBjaGFuZ2VkXG4gICAgICBvdXRwdXQuZmlsdGVyKG91dHB1dC5BREQsIGsgPT4ge1xuICAgICAgICBjb25zdCBjID0gY3VycltrXSAmIGlnbm9yZSxcbiAgICAgICAgICBmID0gIWMgJiYgYyBeIHByZXZba10gJiBpZ25vcmU7XG4gICAgICAgIHJldHVybiBmID8gZGF0YVtrXSA6IG51bGw7XG4gICAgICB9KTtcbiAgICAgIG91dHB1dC5maWx0ZXIob3V0cHV0LlJFTSwgayA9PiB7XG4gICAgICAgIGNvbnN0IGMgPSBjdXJyW2tdICYgaWdub3JlLFxuICAgICAgICAgIGYgPSBjICYmICEoYyBeIChjIF4gcHJldltrXSAmIGlnbm9yZSkpO1xuICAgICAgICByZXR1cm4gZiA/IGRhdGFba10gOiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYWRkIGZpbHRlciB0byBzb3VyY2UgZGF0YSBpbiBjYXNlIG9mIHJlZmxvdy4uLlxuICAgIHJldHVybiBvdXRwdXQuZmlsdGVyKG91dHB1dC5TT1VSQ0UsIHQgPT4gcGFzcyh0Ll9pbmRleCkpO1xuICB9XG59KTtcblxuZXhwb3J0IHsgQ3Jvc3NGaWx0ZXIgYXMgY3Jvc3NmaWx0ZXIsIFJlc29sdmVGaWx0ZXIgYXMgcmVzb2x2ZWZpbHRlciB9O1xuIiwiaW1wb3J0IHsgaWRlbnRpdHksIGFycmF5LCBpc0Z1bmN0aW9uLCBjb25zdGFudCwgaXNBcnJheSwgaWQsIGVycm9yLCB0cnV0aHksIGRlYm91bmNlLCBleHRlbmQsIHZpc2l0QXJyYXksIGluaGVyaXRzLCBsb2dnZXIsIEVycm9yLCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyByZWFkLCByZXNwb25zZVR5cGUsIGxvYWRlciB9IGZyb20gJ3ZlZ2EtbG9hZGVyJztcbmltcG9ydCB7IGRlZmF1bHRMb2NhbGUgfSBmcm9tICd2ZWdhLWZvcm1hdCc7XG5cbmZ1bmN0aW9uIFVuaXF1ZUxpc3QoaWRGdW5jKSB7XG4gIGNvbnN0ICQgPSBpZEZ1bmMgfHwgaWRlbnRpdHksXG4gICAgbGlzdCA9IFtdLFxuICAgIGlkcyA9IHt9O1xuICBsaXN0LmFkZCA9IF8gPT4ge1xuICAgIGNvbnN0IGlkID0gJChfKTtcbiAgICBpZiAoIWlkc1tpZF0pIHtcbiAgICAgIGlkc1tpZF0gPSAxO1xuICAgICAgbGlzdC5wdXNoKF8pO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcbiAgbGlzdC5yZW1vdmUgPSBfID0+IHtcbiAgICBjb25zdCBpZCA9ICQoXyk7XG4gICAgaWYgKGlkc1tpZF0pIHtcbiAgICAgIGlkc1tpZF0gPSAwO1xuICAgICAgY29uc3QgaWR4ID0gbGlzdC5pbmRleE9mKF8pO1xuICAgICAgaWYgKGlkeCA+PSAwKSBsaXN0LnNwbGljZShpZHgsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gbGlzdDtcbiAgfTtcbiAgcmV0dXJuIGxpc3Q7XG59XG5cbi8qKlxuICogSW52b2tlIGFuZCBhd2FpdCBhIHBvdGVudGlhbGx5IGFzeW5jIGNhbGxiYWNrIGZ1bmN0aW9uLiBJZlxuICogYW4gZXJyb3Igb2NjdXJzLCB0cmFwIGl0IGFuZCByb3V0ZSB0byBEYXRhZmxvdy5lcnJvci5cbiAqIEBwYXJhbSB7RGF0YWZsb3d9IGRmIC0gVGhlIGRhdGFmbG93IGluc3RhbmNlXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayAtIEEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFuZCB0aGVuIGF3YWl0LiBUaGUgZGF0YWZsb3cgd2lsbCBiZSBwYXNzZWQgYXMgdGhlIHNpbmdsZVxuICogICBhcmd1bWVudCB0byB0aGUgZnVuY3Rpb24uXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGFzeW5jQ2FsbGJhY2sgKGRmLCBjYWxsYmFjaykge1xuICB0cnkge1xuICAgIGF3YWl0IGNhbGxiYWNrKGRmKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGYuZXJyb3IoZXJyKTtcbiAgfVxufVxuXG5jb25zdCBUVVBMRV9JRF9LRVkgPSBTeW1ib2woJ3ZlZ2FfaWQnKTtcbmxldCBUVVBMRV9JRCA9IDE7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGlucHV0IHZhbHVlIGlzIGEgcmVnaXN0ZXJlZCB0dXBsZS5cbiAqIEBwYXJhbSB7Kn0gdCAtIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGlucHV0IGlzIGEgdHVwbGUsIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gaXNUdXBsZSh0KSB7XG4gIHJldHVybiAhISh0ICYmIHR1cGxlaWQodCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGlkIG9mIGEgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBpbnB1dCB0dXBsZS5cbiAqIEByZXR1cm4geyp9IHRoZSB0dXBsZSBpZC5cbiAqL1xuZnVuY3Rpb24gdHVwbGVpZCh0KSB7XG4gIHJldHVybiB0W1RVUExFX0lEX0tFWV07XG59XG5cbi8qKlxuICogU2V0cyB0aGUgaWQgb2YgYSB0dXBsZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSB0IC0gVGhlIGlucHV0IHR1cGxlLlxuICogQHBhcmFtIHsqfSBpZCAtIFRoZSBpZCB2YWx1ZSB0byBzZXQuXG4gKiBAcmV0dXJuIHtvYmplY3R9IHRoZSBpbnB1dCB0dXBsZS5cbiAqL1xuZnVuY3Rpb24gc2V0aWQodCwgaWQpIHtcbiAgdFtUVVBMRV9JRF9LRVldID0gaWQ7XG4gIHJldHVybiB0O1xufVxuXG4vKipcbiAqIEluZ2VzdCBhbiBvYmplY3Qgb3IgdmFsdWUgYXMgYSBkYXRhIHR1cGxlLlxuICogSWYgdGhlIGlucHV0IHZhbHVlIGlzIGFuIG9iamVjdCwgYW4gaWQgZmllbGQgd2lsbCBiZSBhZGRlZCB0byBpdC4gRm9yXG4gKiBlZmZpY2llbmN5LCB0aGUgaW5wdXQgb2JqZWN0IGlzIG1vZGlmaWVkIGRpcmVjdGx5LiBBIGNvcHkgaXMgbm90IG1hZGUuXG4gKiBJZiB0aGUgaW5wdXQgdmFsdWUgaXMgYSBsaXRlcmFsLCBpdCB3aWxsIGJlIHdyYXBwZWQgaW4gYSBuZXcgb2JqZWN0XG4gKiBpbnN0YW5jZSwgd2l0aCB0aGUgdmFsdWUgYWNjZXNzaWJsZSBhcyB0aGUgJ2RhdGEnIHByb3BlcnR5LlxuICogQHBhcmFtIGRhdHVtIC0gVGhlIHZhbHVlIHRvIGluZ2VzdC5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGluZ2VzdGVkIGRhdGEgdHVwbGUuXG4gKi9cbmZ1bmN0aW9uIGluZ2VzdCQxKGRhdHVtKSB7XG4gIGNvbnN0IHQgPSBkYXR1bSA9PT0gT2JqZWN0KGRhdHVtKSA/IGRhdHVtIDoge1xuICAgIGRhdGE6IGRhdHVtXG4gIH07XG4gIHJldHVybiB0dXBsZWlkKHQpID8gdCA6IHNldGlkKHQsIFRVUExFX0lEKyspO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc291cmNlIHR1cGxlLCByZXR1cm4gYSBkZXJpdmVkIGNvcHkuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBzb3VyY2UgdHVwbGUuXG4gKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBkZXJpdmVkIHR1cGxlLlxuICovXG5mdW5jdGlvbiBkZXJpdmUodCkge1xuICByZXR1cm4gcmVkZXJpdmUodCwgaW5nZXN0JDEoe30pKTtcbn1cblxuLyoqXG4gKiBSZWRlcml2ZSBhIGRlcml2ZWQgdHVwbGUgYnkgY29weWluZyB2YWx1ZXMgZnJvbSB0aGUgc291cmNlIHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IHQgLSBUaGUgc291cmNlIHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IGQgLSBUaGUgZGVyaXZlZCB0dXBsZS5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIGRlcml2ZWQgdHVwbGUuXG4gKi9cbmZ1bmN0aW9uIHJlZGVyaXZlKHQsIGQpIHtcbiAgZm9yIChjb25zdCBrIGluIHQpIGRba10gPSB0W2tdO1xuICByZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIGFuIGV4aXN0aW5nIHR1cGxlIHdpdGggYSBuZXcgdHVwbGUuXG4gKiBAcGFyYW0ge29iamVjdH0gdCAtIFRoZSBleGlzdGluZyBkYXRhIHR1cGxlLlxuICogQHBhcmFtIHtvYmplY3R9IGQgLSBUaGUgbmV3IHR1cGxlIHRoYXQgcmVwbGFjZXMgdGhlIG9sZC5cbiAqIEByZXR1cm4ge29iamVjdH0gVGhlIG5ldyB0dXBsZS5cbiAqL1xuZnVuY3Rpb24gcmVwbGFjZSh0LCBkKSB7XG4gIHJldHVybiBzZXRpZChkLCB0dXBsZWlkKHQpKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBhbiBhdWdtZW50ZWQgY29tcGFyYXRvciBmdW5jdGlvbiB0aGF0IHByb3ZpZGVzIHN0YWJsZVxuICogc29ydGluZyBieSB0dXBsZSBpZCB3aGVuIHRoZSBnaXZlbiBjb21wYXJhdG9yIHByb2R1Y2VzIHRpZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjbXAgLSBUaGUgY29tcGFyYXRvciB0byBhdWdtZW50LlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW2ZdIC0gT3B0aW9uYWwgdHVwbGUgYWNjZXNzb3IgZnVuY3Rpb24uXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gQW4gYXVnbWVudGVkIGNvbXBhcmF0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHN0YWJsZUNvbXBhcmUoY21wLCBmKSB7XG4gIHJldHVybiAhY21wID8gbnVsbCA6IGYgPyAoYSwgYikgPT4gY21wKGEsIGIpIHx8IHR1cGxlaWQoZihhKSkgLSB0dXBsZWlkKGYoYikpIDogKGEsIGIpID0+IGNtcChhLCBiKSB8fCB0dXBsZWlkKGEpIC0gdHVwbGVpZChiKTtcbn1cblxuZnVuY3Rpb24gaXNDaGFuZ2VTZXQodikge1xuICByZXR1cm4gdiAmJiB2LmNvbnN0cnVjdG9yID09PSBjaGFuZ2VzZXQ7XG59XG5mdW5jdGlvbiBjaGFuZ2VzZXQoKSB7XG4gIGNvbnN0IGFkZCA9IFtdLFxuICAgIC8vIGluc2VydCB0dXBsZXNcbiAgICByZW0gPSBbXSxcbiAgICAvLyByZW1vdmUgdHVwbGVzXG4gICAgbW9kID0gW10sXG4gICAgLy8gbW9kaWZ5IHR1cGxlc1xuICAgIHJlbXAgPSBbXSxcbiAgICAvLyByZW1vdmUgYnkgcHJlZGljYXRlXG4gICAgbW9kcCA9IFtdOyAvLyBtb2RpZnkgYnkgcHJlZGljYXRlXG4gIGxldCBjbGVhbiA9IG51bGwsXG4gICAgcmVmbG93ID0gZmFsc2U7XG4gIHJldHVybiB7XG4gICAgY29uc3RydWN0b3I6IGNoYW5nZXNldCxcbiAgICBpbnNlcnQodCkge1xuICAgICAgY29uc3QgZCA9IGFycmF5KHQpLFxuICAgICAgICBuID0gZC5sZW5ndGg7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkgYWRkLnB1c2goZFtpXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbW92ZSh0KSB7XG4gICAgICBjb25zdCBhID0gaXNGdW5jdGlvbih0KSA/IHJlbXAgOiByZW0sXG4gICAgICAgIGQgPSBhcnJheSh0KSxcbiAgICAgICAgbiA9IGQubGVuZ3RoO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIGEucHVzaChkW2ldKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgbW9kaWZ5KHQsIGZpZWxkLCB2YWx1ZSkge1xuICAgICAgY29uc3QgbSA9IHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICB2YWx1ZTogY29uc3RhbnQodmFsdWUpXG4gICAgICB9O1xuICAgICAgaWYgKGlzRnVuY3Rpb24odCkpIHtcbiAgICAgICAgbS5maWx0ZXIgPSB0O1xuICAgICAgICBtb2RwLnB1c2gobSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtLnR1cGxlID0gdDtcbiAgICAgICAgbW9kLnB1c2gobSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGVuY29kZSh0LCBzZXQpIHtcbiAgICAgIGlmIChpc0Z1bmN0aW9uKHQpKSBtb2RwLnB1c2goe1xuICAgICAgICBmaWx0ZXI6IHQsXG4gICAgICAgIGZpZWxkOiBzZXRcbiAgICAgIH0pO2Vsc2UgbW9kLnB1c2goe1xuICAgICAgICB0dXBsZTogdCxcbiAgICAgICAgZmllbGQ6IHNldFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGNsZWFuKHZhbHVlKSB7XG4gICAgICBjbGVhbiA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICByZWZsb3coKSB7XG4gICAgICByZWZsb3cgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBwdWxzZShwdWxzZSwgdHVwbGVzKSB7XG4gICAgICBjb25zdCBjdXIgPSB7fSxcbiAgICAgICAgb3V0ID0ge307XG4gICAgICBsZXQgaSwgbiwgbSwgZiwgdCwgaWQ7XG5cbiAgICAgIC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvZiBjdXJyZW50IHR1cGxlc1xuICAgICAgZm9yIChpID0gMCwgbiA9IHR1cGxlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY3VyW3R1cGxlaWQodHVwbGVzW2ldKV0gPSAxO1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIGluZGl2aWR1YWwgdHVwbGVzIHRvIHJlbW92ZVxuICAgICAgZm9yIChpID0gMCwgbiA9IHJlbS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IHJlbVtpXTtcbiAgICAgICAgY3VyW3R1cGxlaWQodCldID0gLTE7XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgcHJlZGljYXRlLWJhc2VkIHJlbW92YWxzXG4gICAgICBmb3IgKGkgPSAwLCBuID0gcmVtcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgZiA9IHJlbXBbaV07XG4gICAgICAgIHR1cGxlcy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGlmIChmKHQpKSBjdXJbdHVwbGVpZCh0KV0gPSAtMTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHByb2Nlc3MgYWxsIGFkZCB0dXBsZXNcbiAgICAgIGZvciAoaSA9IDAsIG4gPSBhZGQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHQgPSBhZGRbaV07XG4gICAgICAgIGlkID0gdHVwbGVpZCh0KTtcbiAgICAgICAgaWYgKGN1cltpZF0pIHtcbiAgICAgICAgICAvLyB0dXBsZSBhbHJlYWR5IHJlc2lkZXMgaW4gZGF0YXNldFxuICAgICAgICAgIC8vIGlmIGZsYWdnZWQgZm9yIGJvdGggYWRkIGFuZCByZW1vdmUsIGNhbmNlbFxuICAgICAgICAgIGN1cltpZF0gPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHR1cGxlIGRvZXMgbm90IHJlc2lkZSBpbiBkYXRhc2V0LCBhZGRcbiAgICAgICAgICBwdWxzZS5hZGQucHVzaChpbmdlc3QkMShhZGRbaV0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwb3B1bGF0ZSBwdWxzZSByZW0gbGlzdFxuICAgICAgZm9yIChpID0gMCwgbiA9IHR1cGxlcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgdCA9IHR1cGxlc1tpXTtcbiAgICAgICAgaWYgKGN1clt0dXBsZWlkKHQpXSA8IDApIHB1bHNlLnJlbS5wdXNoKHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBtb2RpZnkgaGVscGVyIG1ldGhvZFxuICAgICAgZnVuY3Rpb24gbW9kaWZ5KHQsIGYsIHYpIHtcbiAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICB0W2ZdID0gdih0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwdWxzZS5lbmNvZGUgPSBmO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcmVmbG93KSBvdXRbdHVwbGVpZCh0KV0gPSB0O1xuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIGluZGl2aWR1YWwgdHVwbGVzIHRvIG1vZGlmeVxuICAgICAgZm9yIChpID0gMCwgbiA9IG1vZC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbSA9IG1vZFtpXTtcbiAgICAgICAgdCA9IG0udHVwbGU7XG4gICAgICAgIGYgPSBtLmZpZWxkO1xuICAgICAgICBpZCA9IGN1clt0dXBsZWlkKHQpXTtcbiAgICAgICAgaWYgKGlkID4gMCkge1xuICAgICAgICAgIG1vZGlmeSh0LCBmLCBtLnZhbHVlKTtcbiAgICAgICAgICBwdWxzZS5tb2RpZmllcyhmKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwcm9jZXNzIHByZWRpY2F0ZS1iYXNlZCBtb2RpZmljYXRpb25zXG4gICAgICBmb3IgKGkgPSAwLCBuID0gbW9kcC5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgbSA9IG1vZHBbaV07XG4gICAgICAgIGYgPSBtLmZpbHRlcjtcbiAgICAgICAgdHVwbGVzLmZvckVhY2godCA9PiB7XG4gICAgICAgICAgaWYgKGYodCkgJiYgY3VyW3R1cGxlaWQodCldID4gMCkge1xuICAgICAgICAgICAgbW9kaWZ5KHQsIG0uZmllbGQsIG0udmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHB1bHNlLm1vZGlmaWVzKG0uZmllbGQpO1xuICAgICAgfVxuXG4gICAgICAvLyB1cG9uIHJlZmxvdyByZXF1ZXN0LCBwb3B1bGF0ZSBtb2Qgd2l0aCBhbGwgbm9uLXJlbW92ZWQgdHVwbGVzXG4gICAgICAvLyBvdGhlcndpc2UsIHBvcHVsYXRlIG1vZCB3aXRoIG1vZGlmaWVkIHR1cGxlcyBvbmx5XG4gICAgICBpZiAocmVmbG93KSB7XG4gICAgICAgIHB1bHNlLm1vZCA9IHJlbS5sZW5ndGggfHwgcmVtcC5sZW5ndGggPyB0dXBsZXMuZmlsdGVyKHQgPT4gY3VyW3R1cGxlaWQodCldID4gMCkgOiB0dXBsZXMuc2xpY2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaWQgaW4gb3V0KSBwdWxzZS5tb2QucHVzaChvdXRbaWRdKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHB1bHNlIGdhcmJhZ2UgY29sbGVjdGlvbiByZXF1ZXN0XG4gICAgICBpZiAoY2xlYW4gfHwgY2xlYW4gPT0gbnVsbCAmJiAocmVtLmxlbmd0aCB8fCByZW1wLmxlbmd0aCkpIHtcbiAgICAgICAgcHVsc2UuY2xlYW4odHJ1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVsc2U7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBDQUNIRSA9ICdfOm1vZDpfJztcblxuLyoqXG4gKiBIYXNoIHRoYXQgdHJhY2tzIG1vZGlmaWNhdGlvbnMgdG8gYXNzaWduZWQgdmFsdWVzLlxuICogQ2FsbGVycyAqbXVzdCogdXNlIHRoZSBzZXQgbWV0aG9kIHRvIHVwZGF0ZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIFBhcmFtZXRlcnMoKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBDQUNIRSwge1xuICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgIHZhbHVlOiB7fVxuICB9KTtcbn1cblBhcmFtZXRlcnMucHJvdG90eXBlID0ge1xuICAvKipcbiAgICogU2V0IGEgcGFyYW1ldGVyIHZhbHVlLiBJZiB0aGUgcGFyYW1ldGVyIHZhbHVlIGNoYW5nZXMsIHRoZSBwYXJhbWV0ZXJcbiAgICogd2lsbCBiZSByZWNvcmRlZCBhcyBtb2RpZmllZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIFRoZSBpbmRleCBpbnRvIGFuIGFycmF5LXZhbHVlIHBhcmFtZXRlci4gSWdub3JlZCBpZlxuICAgKiAgIHRoZSBhcmd1bWVudCBpcyB1bmRlZmluZWQsIG51bGwgb3IgbGVzcyB0aGFuIHplcm8uXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgcGFyYW1ldGVyIHZhbHVlIHRvIHNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yY2U9ZmFsc2VdIC0gSWYgdHJ1ZSwgcmVjb3JkcyB0aGUgcGFyYW1ldGVyIGFzIG1vZGlmaWVkXG4gICAqICAgZXZlbiBpZiB0aGUgdmFsdWUgaXMgdW5jaGFuZ2VkLlxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJzfSAtIFRoaXMgcGFyYW1ldGVyIG9iamVjdC5cbiAgICovXG4gIHNldChuYW1lLCBpbmRleCwgdmFsdWUsIGZvcmNlKSB7XG4gICAgY29uc3QgbyA9IHRoaXMsXG4gICAgICB2ID0gb1tuYW1lXSxcbiAgICAgIG1vZCA9IG9bQ0FDSEVdO1xuICAgIGlmIChpbmRleCAhPSBudWxsICYmIGluZGV4ID49IDApIHtcbiAgICAgIGlmICh2W2luZGV4XSAhPT0gdmFsdWUgfHwgZm9yY2UpIHtcbiAgICAgICAgdltpbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgbW9kW2luZGV4ICsgJzonICsgbmFtZV0gPSAtMTtcbiAgICAgICAgbW9kW25hbWVdID0gLTE7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh2ICE9PSB2YWx1ZSB8fCBmb3JjZSkge1xuICAgICAgb1tuYW1lXSA9IHZhbHVlO1xuICAgICAgbW9kW25hbWVdID0gaXNBcnJheSh2YWx1ZSkgPyAxICsgdmFsdWUubGVuZ3RoIDogLTE7XG4gICAgfVxuICAgIHJldHVybiBvO1xuICB9LFxuICAvKipcbiAgICogVGVzdHMgaWYgb25lIG9yIG1vcmUgcGFyYW1ldGVycyBoYXMgYmVlbiBtb2RpZmllZC4gSWYgaW52b2tlZCB3aXRoIG5vXG4gICAqIGFyZ3VtZW50cywgcmV0dXJucyB0cnVlIGlmIGFueSBwYXJhbWV0ZXIgdmFsdWUgaGFzIGNoYW5nZWQuIElmIHRoZSBmaXJzdFxuICAgKiBhcmd1bWVudCBpcyBhcnJheSwgcmV0dXJucyB0cnVlcyBpZiBhbnkgcGFyYW1ldGVyIG5hbWUgaW4gdGhlIGFycmF5IGhhc1xuICAgKiBjaGFuZ2VkLiBPdGhlcndpc2UsIHRlc3RzIGlmIHRoZSBnaXZlbiBuYW1lIGFuZCBvcHRpb25hbCBhcnJheSBpbmRleCBoYXNcbiAgICogY2hhbmdlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgcGFyYW1ldGVyIG5hbWUgdG8gdGVzdC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtpbmRleD11bmRlZmluZWRdIC0gVGhlIHBhcmFtZXRlciBhcnJheSBpbmRleCB0byB0ZXN0LlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiBhIHF1ZXJpZWQgcGFyYW1ldGVyIHdhcyBtb2RpZmllZC5cbiAgICovXG4gIG1vZGlmaWVkKG5hbWUsIGluZGV4KSB7XG4gICAgY29uc3QgbW9kID0gdGhpc1tDQUNIRV07XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gbW9kKSB7XG4gICAgICAgIGlmIChtb2Rba10pIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNBcnJheShuYW1lKSkge1xuICAgICAgZm9yIChsZXQgayA9IDA7IGsgPCBuYW1lLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGlmIChtb2RbbmFtZVtrXV0pIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gaW5kZXggIT0gbnVsbCAmJiBpbmRleCA+PSAwID8gaW5kZXggKyAxIDwgbW9kW25hbWVdIHx8ICEhbW9kW2luZGV4ICsgJzonICsgbmFtZV0gOiAhIW1vZFtuYW1lXTtcbiAgfSxcbiAgLyoqXG4gICAqIENsZWFycyB0aGUgbW9kaWZpY2F0aW9uIHJlY29yZHMuIEFmdGVyIGNhbGxpbmcgdGhpcyBtZXRob2QsXG4gICAqIGFsbCBwYXJhbWV0ZXJzIGFyZSBjb25zaWRlcmVkIHVubW9kaWZpZWQuXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzW0NBQ0hFXSA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5sZXQgT1BfSUQgPSAwO1xuY29uc3QgUFVMU0UgPSAncHVsc2UnLFxuICBOT19QQVJBTVMgPSBuZXcgUGFyYW1ldGVycygpO1xuXG4vLyBCb29sZWFuIEZsYWdzXG5jb25zdCBTS0lQJDEgPSAxLFxuICBNT0RJRklFRCA9IDI7XG5cbi8qKlxuICogQW4gT3BlcmF0b3IgaXMgYSBwcm9jZXNzaW5nIG5vZGUgaW4gYSBkYXRhZmxvdyBncmFwaC5cbiAqIEVhY2ggb3BlcmF0b3Igc3RvcmVzIGEgdmFsdWUgYW5kIGFuIG9wdGlvbmFsIHZhbHVlIHVwZGF0ZSBmdW5jdGlvbi5cbiAqIE9wZXJhdG9ycyBjYW4gYWNjZXB0IGEgaGFzaCBvZiBuYW1lZCBwYXJhbWV0ZXJzLiBQYXJhbWV0ZXIgdmFsdWVzIGNhblxuICogZWl0aGVyIGJlIGRpcmVjdCAoSmF2YVNjcmlwdCBsaXRlcmFscywgYXJyYXlzLCBvYmplY3RzKSBvciBpbmRpcmVjdFxuICogKG90aGVyIG9wZXJhdG9ycyB3aG9zZSB2YWx1ZXMgd2lsbCBiZSBwdWxsZWQgZHluYW1pY2FsbHkpLiBPcGVyYXRvcnNcbiAqIGluY2x1ZGVkIGFzIHBhcmFtZXRlcnMgd2lsbCBoYXZlIHRoaXMgb3BlcmF0b3IgYWRkZWQgYXMgYSBkZXBlbmRlbmN5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0geyp9IFtpbml0XSAtIFRoZSBpbml0aWFsIHZhbHVlIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIFB1bHNlKX0gW3VwZGF0ZV0gLSBBbiB1cGRhdGUgZnVuY3Rpb24uIFVwb25cbiAqICAgZXZhbHVhdGlvbiBvZiB0aGlzIG9wZXJhdG9yLCB0aGUgdXBkYXRlIGZ1bmN0aW9uIHdpbGwgYmUgaW52b2tlZCBhbmQgdGhlXG4gKiAgIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWQgYXMgdGhlIG5ldyB2YWx1ZSBvZiB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXNdIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtyZWFjdD10cnVlXSAtIEZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yIHNob3VsZFxuICogICBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdXBzdHJlYW0gb3BlcmF0b3JzIGluY2x1ZGVkIGFzIHBhcmFtZXRlcnMuXG4gKiBAc2VlIHBhcmFtZXRlcnNcbiAqL1xuZnVuY3Rpb24gT3BlcmF0b3IoaW5pdCwgdXBkYXRlLCBwYXJhbXMsIHJlYWN0KSB7XG4gIHRoaXMuaWQgPSArK09QX0lEO1xuICB0aGlzLnZhbHVlID0gaW5pdDtcbiAgdGhpcy5zdGFtcCA9IC0xO1xuICB0aGlzLnJhbmsgPSAtMTtcbiAgdGhpcy5xcmFuayA9IC0xO1xuICB0aGlzLmZsYWdzID0gMDtcbiAgaWYgKHVwZGF0ZSkge1xuICAgIHRoaXMuX3VwZGF0ZSA9IHVwZGF0ZTtcbiAgfVxuICBpZiAocGFyYW1zKSB0aGlzLnBhcmFtZXRlcnMocGFyYW1zLCByZWFjdCk7XG59XG5mdW5jdGlvbiBmbGFnKGJpdCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgY29uc3QgZiA9IHRoaXMuZmxhZ3M7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiAhIShmICYgYml0KTtcbiAgICB0aGlzLmZsYWdzID0gc3RhdGUgPyBmIHwgYml0IDogZiAmIH5iaXQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG59XG5PcGVyYXRvci5wcm90b3R5cGUgPSB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgbGlzdCBvZiB0YXJnZXQgb3BlcmF0b3JzIGRlcGVuZGVudCBvbiB0aGlzIG9wZXJhdG9yLlxuICAgKiBJZiB0aGlzIGxpc3QgZG9lcyBub3QgZXhpc3QsIGl0IGlzIGNyZWF0ZWQgYW5kIHRoZW4gcmV0dXJuZWQuXG4gICAqIEByZXR1cm4ge1VuaXF1ZUxpc3R9XG4gICAqL1xuICB0YXJnZXRzKCkge1xuICAgIHJldHVybiB0aGlzLl90YXJnZXRzIHx8ICh0aGlzLl90YXJnZXRzID0gVW5pcXVlTGlzdChpZCkpO1xuICB9LFxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAqIEByZXR1cm4ge051bWJlcn0gUmV0dXJucyAxIGlmIHRoZSBvcGVyYXRvciB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgKiAgIGFjY29yZGluZyB0byBzdHJpY3QgZXF1YWxpdHksIHJldHVybnMgMCBvdGhlcndpc2UuXG4gICAqL1xuICBzZXQodmFsdWUpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gIH0sXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBvcGVyYXRvciBldmFsdWF0aW9uIHNob3VsZCBiZSBza2lwcGVkIG9uIHRoZSBuZXh0IHB1bHNlLlxuICAgKiBUaGlzIG9wZXJhdG9yIHdpbGwgc3RpbGwgcHJvcGFnYXRlIGluY29taW5nIHB1bHNlcywgYnV0IGl0cyB1cGRhdGUgZnVuY3Rpb25cbiAgICogd2lsbCBub3QgYmUgaW52b2tlZC4gVGhlIHNraXAgZmxhZyBpcyByZXNldCBhZnRlciBldmVyeSBwdWxzZSwgc28gY2FsbGluZ1xuICAgKiB0aGlzIG1ldGhvZCB3aWxsIGFmZmVjdCBwcm9jZXNzaW5nIG9mIHRoZSBuZXh0IHB1bHNlIG9ubHkuXG4gICAqL1xuICBza2lwOiBmbGFnKFNLSVAkMSksXG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCB0aGlzIG9wZXJhdG9yJ3MgdmFsdWUgaGFzIGJlZW4gbW9kaWZpZWQgb24gaXRzIG1vc3QgcmVjZW50XG4gICAqIHB1bHNlLiBOb3JtYWxseSBtb2RpZmljYXRpb24gaXMgY2hlY2tlZCB2aWEgc3RyaWN0IGVxdWFsaXR5OyBob3dldmVyLCBpblxuICAgKiBzb21lIGNhc2VzIGl0IGlzIG1vcmUgZWZmaWNpZW50IHRvIHVwZGF0ZSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgYW4gb2JqZWN0LlxuICAgKiBJbiB0aG9zZSBjYXNlcywgdGhlIG1vZGlmaWVkIGZsYWcgY2FuIGJlIHVzZWQgdG8gdHJpZ2dlciBwcm9wYWdhdGlvbi4gT25jZVxuICAgKiBzZXQsIHRoZSBtb2RpZmljYXRpb24gZmxhZyBwZXJzaXN0cyBhY3Jvc3MgcHVsc2VzIHVudGlsIHVuc2V0LiBUaGUgZmxhZyBjYW5cbiAgICogYmUgdXNlZCB3aXRoIHRoZSBsYXN0IHRpbWVzdGFtcCB0byB0ZXN0IGlmIGEgbW9kaWZpY2F0aW9uIGlzIHJlY2VudC5cbiAgICovXG4gIG1vZGlmaWVkOiBmbGFnKE1PRElGSUVEKSxcbiAgLyoqXG4gICAqIFNldHMgdGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuIFRoZSBwYXJhbWV0ZXIgdmFsdWVzIGFyZSBhbmFseXplZCBmb3JcbiAgICogb3BlcmF0b3IgaW5zdGFuY2VzLiBJZiBmb3VuZCwgdGhpcyBvcGVyYXRvciB3aWxsIGJlIGFkZGVkIGFzIGEgZGVwZW5kZW5jeVxuICAgKiBvZiB0aGUgcGFyYW1ldGVyaXppbmcgb3BlcmF0b3IuIE9wZXJhdG9yIHZhbHVlcyBhcmUgZHluYW1pY2FsbHkgbWFyc2hhbGxlZFxuICAgKiBmcm9tIGVhY2ggb3BlcmF0b3IgcGFyYW1ldGVyIHByaW9yIHRvIGV2YWx1YXRpb24uIElmIGEgcGFyYW1ldGVyIHZhbHVlIGlzXG4gICAqIGFuIGFycmF5LCB0aGUgYXJyYXkgd2lsbCBhbHNvIGJlIHNlYXJjaGVkIGZvciBPcGVyYXRvciBpbnN0YW5jZXMuIEhvd2V2ZXIsXG4gICAqIHRoZSBzZWFyY2ggZG9lcyBub3QgcmVjdXJzZSBpbnRvIHN1Yi1hcnJheXMgb3Igb2JqZWN0IHByb3BlcnRpZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBBIGhhc2ggb2Ygb3BlcmF0b3IgcGFyYW1ldGVycy5cbiAgICogQHBhcmFtIHtib29sZWFufSBbcmVhY3Q9dHJ1ZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiB0aGlzIG9wZXJhdG9yIHNob3VsZFxuICAgKiAgIGF1dG9tYXRpY2FsbHkgdXBkYXRlIChyZWFjdCkgd2hlbiBwYXJhbWV0ZXIgdmFsdWVzIGNoYW5nZS4gSW4gb3RoZXIgd29yZHMsXG4gICAqICAgdGhpcyBmbGFnIGRldGVybWluZXMgaWYgdGhlIG9wZXJhdG9yIHJlZ2lzdGVycyBpdHNlbGYgYXMgYSBsaXN0ZW5lciBvblxuICAgKiAgIGFueSB1cHN0cmVhbSBvcGVyYXRvcnMgaW5jbHVkZWQgaW4gdGhlIHBhcmFtZXRlcnMuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2luaXRvbmx5PWZhbHNlXSAtIEEgZmxhZyBpbmRpY2F0aW5nIGlmIHRoaXMgb3BlcmF0b3JcbiAgICogICBzaG91bGQgY2FsY3VsYXRlIGFuIHVwZGF0ZSBvbmx5IHVwb24gaXRzIGluaXRpYWwgZXZhbHVhdGlvbiwgdGhlblxuICAgKiAgIGRlcmVnaXN0ZXIgZGVwZW5kZW5jaWVzIGFuZCBzdXBwcmVzcyBhbGwgZnV0dXJlIHVwZGF0ZSBpbnZvY2F0aW9ucy5cbiAgICogQHJldHVybiB7T3BlcmF0b3JbXX0gLSBBbiBhcnJheSBvZiB1cHN0cmVhbSBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBwYXJhbWV0ZXJzKHBhcmFtcywgcmVhY3QsIGluaXRvbmx5KSB7XG4gICAgcmVhY3QgPSByZWFjdCAhPT0gZmFsc2U7XG4gICAgY29uc3QgYXJndmFsID0gdGhpcy5fYXJndmFsID0gdGhpcy5fYXJndmFsIHx8IG5ldyBQYXJhbWV0ZXJzKCksXG4gICAgICBhcmdvcHMgPSB0aGlzLl9hcmdvcHMgPSB0aGlzLl9hcmdvcHMgfHwgW10sXG4gICAgICBkZXBzID0gW107XG4gICAgbGV0IG5hbWUsIHZhbHVlLCBuLCBpO1xuICAgIGNvbnN0IGFkZCA9IChuYW1lLCBpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIE9wZXJhdG9yKSB7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gdGhpcykge1xuICAgICAgICAgIGlmIChyZWFjdCkgdmFsdWUudGFyZ2V0cygpLmFkZCh0aGlzKTtcbiAgICAgICAgICBkZXBzLnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGFyZ29wcy5wdXNoKHtcbiAgICAgICAgICBvcDogdmFsdWUsXG4gICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICBpbmRleDogaW5kZXhcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcmd2YWwuc2V0KG5hbWUsIGluZGV4LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmb3IgKG5hbWUgaW4gcGFyYW1zKSB7XG4gICAgICB2YWx1ZSA9IHBhcmFtc1tuYW1lXTtcbiAgICAgIGlmIChuYW1lID09PSBQVUxTRSkge1xuICAgICAgICBhcnJheSh2YWx1ZSkuZm9yRWFjaChvcCA9PiB7XG4gICAgICAgICAgaWYgKCEob3AgaW5zdGFuY2VvZiBPcGVyYXRvcikpIHtcbiAgICAgICAgICAgIGVycm9yKCdQdWxzZSBwYXJhbWV0ZXJzIG11c3QgYmUgb3BlcmF0b3IgaW5zdGFuY2VzLicpO1xuICAgICAgICAgIH0gZWxzZSBpZiAob3AgIT09IHRoaXMpIHtcbiAgICAgICAgICAgIG9wLnRhcmdldHMoKS5hZGQodGhpcyk7XG4gICAgICAgICAgICBkZXBzLnB1c2gob3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc291cmNlID0gdmFsdWU7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGFyZ3ZhbC5zZXQobmFtZSwgLTEsIEFycmF5KG4gPSB2YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkgYWRkKG5hbWUsIGksIHZhbHVlW2ldKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFkZChuYW1lLCAtMSwgdmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm1hcnNoYWxsKCkuY2xlYXIoKTsgLy8gaW5pdGlhbGl6ZSB2YWx1ZXNcbiAgICBpZiAoaW5pdG9ubHkpIGFyZ29wcy5pbml0b25seSA9IHRydWU7XG4gICAgcmV0dXJuIGRlcHM7XG4gIH0sXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgZm9yIG1hcnNoYWxsaW5nIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIFZpc2l0cyBlYWNoIG9wZXJhdG9yIGRlcGVuZGVuY3kgdG8gcHVsbCB0aGUgbGF0ZXN0IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtQYXJhbWV0ZXJzfSBBIFBhcmFtZXRlcnMgb2JqZWN0IHRvIHBhc3MgdG8gdGhlIHVwZGF0ZSBmdW5jdGlvbi5cbiAgICovXG4gIG1hcnNoYWxsKHN0YW1wKSB7XG4gICAgY29uc3QgYXJndmFsID0gdGhpcy5fYXJndmFsIHx8IE5PX1BBUkFNUyxcbiAgICAgIGFyZ29wcyA9IHRoaXMuX2FyZ29wcztcbiAgICBsZXQgaXRlbSwgaSwgb3AsIG1vZDtcbiAgICBpZiAoYXJnb3BzKSB7XG4gICAgICBjb25zdCBuID0gYXJnb3BzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaXRlbSA9IGFyZ29wc1tpXTtcbiAgICAgICAgb3AgPSBpdGVtLm9wO1xuICAgICAgICBtb2QgPSBvcC5tb2RpZmllZCgpICYmIG9wLnN0YW1wID09PSBzdGFtcDtcbiAgICAgICAgYXJndmFsLnNldChpdGVtLm5hbWUsIGl0ZW0uaW5kZXgsIG9wLnZhbHVlLCBtb2QpO1xuICAgICAgfVxuICAgICAgaWYgKGFyZ29wcy5pbml0b25seSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgICAgaXRlbSA9IGFyZ29wc1tpXTtcbiAgICAgICAgICBpdGVtLm9wLnRhcmdldHMoKS5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYXJnb3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdXBkYXRlID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3ZhbDtcbiAgfSxcbiAgLyoqXG4gICAqIERldGFjaCB0aGlzIG9wZXJhdG9yIGZyb20gdGhlIGRhdGFmbG93LlxuICAgKiBVbnJlZ2lzdGVycyBsaXN0ZW5lcnMgb24gdXBzdHJlYW0gZGVwZW5kZW5jaWVzLlxuICAgKi9cbiAgZGV0YWNoKCkge1xuICAgIGNvbnN0IGFyZ29wcyA9IHRoaXMuX2FyZ29wcztcbiAgICBsZXQgaSwgbiwgaXRlbSwgb3A7XG4gICAgaWYgKGFyZ29wcykge1xuICAgICAgZm9yIChpID0gMCwgbiA9IGFyZ29wcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaXRlbSA9IGFyZ29wc1tpXTtcbiAgICAgICAgb3AgPSBpdGVtLm9wO1xuICAgICAgICBpZiAob3AuX3RhcmdldHMpIHtcbiAgICAgICAgICBvcC5fdGFyZ2V0cy5yZW1vdmUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlcyB0byB0aGUgc291cmNlIGFuZCBwdWxzZSBvYmplY3QsXG4gICAgLy8gaWYgcHJlc2VudCwgdG8gcHJldmVudCBtZW1vcnkgbGVha3Mgb2Ygb2xkIGRhdGEuXG4gICAgdGhpcy5wdWxzZSA9IG51bGw7XG4gICAgdGhpcy5zb3VyY2UgPSBudWxsO1xuICB9LFxuICAvKipcbiAgICogRGVsZWdhdGUgbWV0aG9kIHRvIHBlcmZvcm0gb3BlcmF0b3IgcHJvY2Vzc2luZy5cbiAgICogU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBjdXN0b20gcHJvY2Vzc2luZy5cbiAgICogQnkgZGVmYXVsdCwgaXQgbWFyc2hhbGxzIHBhcmFtZXRlcnMgYW5kIGNhbGxzIHRoZSB1cGRhdGUgZnVuY3Rpb25cbiAgICogaWYgdGhhdCBmdW5jdGlvbiBpcyBkZWZpbmVkLiBJZiB0aGUgdXBkYXRlIGZ1bmN0aW9uIGRvZXMgbm90XG4gICAqIGNoYW5nZSB0aGUgb3BlcmF0b3IgdmFsdWUgdGhlbiBTdG9wUHJvcGFnYXRpb24gaXMgcmV0dXJuZWQuXG4gICAqIElmIG5vIHVwZGF0ZSBmdW5jdGlvbiBpcyBkZWZpbmVkLCB0aGlzIG1ldGhvZCBkb2VzIG5vdGhpbmcuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4gVGhlIG91dHB1dCBwdWxzZSBvciBTdG9wUHJvcGFnYXRpb24uIEEgZmFsc3kgcmV0dXJuIHZhbHVlXG4gICAqICAgKGluY2x1ZGluZyB1bmRlZmluZWQpIHdpbGwgbGV0IHRoZSBpbnB1dCBwdWxzZSBwYXNzIHRocm91Z2guXG4gICAqL1xuICBldmFsdWF0ZShwdWxzZSkge1xuICAgIGNvbnN0IHVwZGF0ZSA9IHRoaXMuX3VwZGF0ZTtcbiAgICBpZiAodXBkYXRlKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLm1hcnNoYWxsKHB1bHNlLnN0YW1wKSxcbiAgICAgICAgdiA9IHVwZGF0ZS5jYWxsKHRoaXMsIHBhcmFtcywgcHVsc2UpO1xuICAgICAgcGFyYW1zLmNsZWFyKCk7XG4gICAgICBpZiAodiAhPT0gdGhpcy52YWx1ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gdjtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMubW9kaWZpZWQoKSkge1xuICAgICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIFJ1biB0aGlzIG9wZXJhdG9yIGZvciB0aGUgY3VycmVudCBwdWxzZS4gSWYgdGhpcyBvcGVyYXRvciBoYXMgYWxyZWFkeVxuICAgKiBiZWVuIHJ1biBhdCAob3IgYWZ0ZXIpIHRoZSBwdWxzZSB0aW1lc3RhbXAsIHJldHVybnMgU3RvcFByb3BhZ2F0aW9uLlxuICAgKiBJbnRlcm5hbGx5LCB0aGlzIG1ldGhvZCBjYWxscyB7QGxpbmsgZXZhbHVhdGV9IHRvIHBlcmZvcm0gcHJvY2Vzc2luZy5cbiAgICogSWYge0BsaW5rIGV2YWx1YXRlfSByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIHRoZSBpbnB1dCBwdWxzZSBpcyByZXR1cm5lZC5cbiAgICogVGhpcyBtZXRob2Qgc2hvdWxkIE5PVCBiZSBvdmVycmlkZGVuLCBpbnN0ZWFkIG92ZXJycmlkZSB7QGxpbmsgZXZhbHVhdGV9LlxuICAgKiBAcGFyYW0ge1B1bHNlfSBwdWxzZSAtIHRoZSBjdXJyZW50IGRhdGFmbG93IHB1bHNlLlxuICAgKiBAcmV0dXJuIHRoZSBvdXRwdXQgcHVsc2UgZm9yIHRoaXMgb3BlcmF0b3IgKG9yIFN0b3BQcm9wYWdhdGlvbilcbiAgICovXG4gIHJ1bihwdWxzZSkge1xuICAgIGlmIChwdWxzZS5zdGFtcCA8IHRoaXMuc3RhbXApIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgbGV0IHJ2O1xuICAgIGlmICh0aGlzLnNraXAoKSkge1xuICAgICAgdGhpcy5za2lwKGZhbHNlKTtcbiAgICAgIHJ2ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgcnYgPSB0aGlzLmV2YWx1YXRlKHB1bHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucHVsc2UgPSBydiB8fCBwdWxzZTtcbiAgfVxufTtcblxuLyoqXG4gKiBBZGQgYW4gb3BlcmF0b3IgdG8gdGhlIGRhdGFmbG93IGdyYXBoLiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYVxuICogdmFyaWV0eSBvZiBpbnB1dCBhcmd1bWVudCB0eXBlcy4gVGhlIGJhc2ljIHNpZ25hdHVyZSBzdXBwb3J0cyBhblxuICogaW5pdGlhbCB2YWx1ZSwgdXBkYXRlIGZ1bmN0aW9uIGFuZCBwYXJhbWV0ZXJzLiBJZiB0aGUgZmlyc3QgcGFyYW1ldGVyXG4gKiBpcyBhbiBPcGVyYXRvciBpbnN0YW5jZSwgaXQgd2lsbCBiZSBhZGRlZCBkaXJlY3RseS4gSWYgaXQgaXMgYVxuICogY29uc3RydWN0b3IgZm9yIGFuIE9wZXJhdG9yIHN1YmNsYXNzLCBhIG5ldyBpbnN0YW5jZSB3aWxsIGJlIGluc3RhbnRpYXRlZC5cbiAqIE90aGVyd2lzZSwgaWYgdGhlIGZpcnN0IHBhcmFtZXRlciBpcyBhIGZ1bmN0aW9uIGluc3RhbmNlLCBpdCB3aWxsIGJlIHVzZWRcbiAqIGFzIHRoZSB1cGRhdGUgZnVuY3Rpb24gYW5kIGEgbnVsbCBpbml0aWFsIHZhbHVlIGlzIGFzc3VtZWQuXG4gKiBAcGFyYW0geyp9IGluaXQgLSBPbmUgb2Y6IHRoZSBvcGVyYXRvciB0byBhZGQsIHRoZSBpbml0aWFsIHZhbHVlIG9mXG4gKiAgIHRoZSBvcGVyYXRvciwgYW4gb3BlcmF0b3IgY2xhc3MgdG8gaW5zdGFudGlhdGUsIG9yIGFuIHVwZGF0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFt1cGRhdGVdIC0gVGhlIG9wZXJhdG9yIHVwZGF0ZSBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBvcGVyYXRvciBwYXJhbWV0ZXJzLlxuICogQHBhcmFtIHtib29sZWFufSBbcmVhY3Q9dHJ1ZV0gLSBGbGFnIGluZGljYXRpbmcgaWYgdGhpcyBvcGVyYXRvciBzaG91bGRcbiAqICAgbGlzdGVuIGZvciBjaGFuZ2VzIHRvIHVwc3RyZWFtIG9wZXJhdG9ycyBpbmNsdWRlZCBhcyBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7T3BlcmF0b3J9IC0gVGhlIGFkZGVkIG9wZXJhdG9yLlxuICovXG5mdW5jdGlvbiBhZGQgKGluaXQsIHVwZGF0ZSwgcGFyYW1zLCByZWFjdCkge1xuICBsZXQgc2hpZnQgPSAxLFxuICAgIG9wO1xuICBpZiAoaW5pdCBpbnN0YW5jZW9mIE9wZXJhdG9yKSB7XG4gICAgb3AgPSBpbml0O1xuICB9IGVsc2UgaWYgKGluaXQgJiYgaW5pdC5wcm90b3R5cGUgaW5zdGFuY2VvZiBPcGVyYXRvcikge1xuICAgIG9wID0gbmV3IGluaXQoKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKGluaXQpKSB7XG4gICAgb3AgPSBuZXcgT3BlcmF0b3IobnVsbCwgaW5pdCk7XG4gIH0gZWxzZSB7XG4gICAgc2hpZnQgPSAwO1xuICAgIG9wID0gbmV3IE9wZXJhdG9yKGluaXQsIHVwZGF0ZSk7XG4gIH1cbiAgdGhpcy5yYW5rKG9wKTtcbiAgaWYgKHNoaWZ0KSB7XG4gICAgcmVhY3QgPSBwYXJhbXM7XG4gICAgcGFyYW1zID0gdXBkYXRlO1xuICB9XG4gIGlmIChwYXJhbXMpIHRoaXMuY29ubmVjdChvcCwgb3AucGFyYW1ldGVycyhwYXJhbXMsIHJlYWN0KSk7XG4gIHRoaXMudG91Y2gob3ApO1xuICByZXR1cm4gb3A7XG59XG5cbi8qKlxuICogQ29ubmVjdCBhIHRhcmdldCBvcGVyYXRvciBhcyBhIGRlcGVuZGVudCBvZiBzb3VyY2Ugb3BlcmF0b3JzLlxuICogSWYgbmVjZXNzYXJ5LCB0aGlzIG1ldGhvZCB3aWxsIHJlcmFuayB0aGUgdGFyZ2V0IG9wZXJhdG9yIGFuZCBpdHNcbiAqIGRlcGVuZGVudHMgdG8gZW5zdXJlIHByb3BhZ2F0aW9uIHByb2NlZWRzIGluIGEgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgb3JkZXIuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSB0YXJnZXQgLSBUaGUgdGFyZ2V0IG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxPcGVyYXRvcj59IC0gVGhlIHNvdXJjZSBvcGVyYXRvcnMgdGhhdCBzaG91bGQgcHJvcGFnYXRlXG4gKiAgIHRvIHRoZSB0YXJnZXQgb3BlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIGNvbm5lY3QgKHRhcmdldCwgc291cmNlcykge1xuICBjb25zdCB0YXJnZXRSYW5rID0gdGFyZ2V0LnJhbmssXG4gICAgbiA9IHNvdXJjZXMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmICh0YXJnZXRSYW5rIDwgc291cmNlc1tpXS5yYW5rKSB7XG4gICAgICB0aGlzLnJlcmFuayh0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5sZXQgU1RSRUFNX0lEID0gMDtcblxuLyoqXG4gKiBNb2RlbHMgYW4gZXZlbnQgc3RyZWFtLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCwgbnVtYmVyKTogYm9vbGVhbn0gW2ZpbHRlcl0gLSBGaWx0ZXIgcHJlZGljYXRlLlxuICogICBFdmVudHMgcGFzcyB0aHJvdWdoIHdoZW4gdHJ1dGh5LCBldmVudHMgYXJlIHN1cHByZXNzZWQgd2hlbiBmYWxzeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KTogKn0gW2FwcGx5XSAtIEFwcGxpZWQgdG8gaW5wdXQgZXZlbnRzIHRvIHByb2R1Y2VcbiAqICAgbmV3IGV2ZW50IHZhbHVlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oT2JqZWN0KX0gW3JlY2VpdmVdIC0gRXZlbnQgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIHVwb24gcmVjZWlwdCBvZiBhIG5ldyBldmVudC4gVXNlIHRvIG92ZXJyaWRlIHN0YW5kYXJkIGV2ZW50IHByb2Nlc3NpbmcuXG4gKi9cbmZ1bmN0aW9uIEV2ZW50U3RyZWFtKGZpbHRlciwgYXBwbHksIHJlY2VpdmUpIHtcbiAgdGhpcy5pZCA9ICsrU1RSRUFNX0lEO1xuICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgaWYgKHJlY2VpdmUpIHRoaXMucmVjZWl2ZSA9IHJlY2VpdmU7XG4gIGlmIChmaWx0ZXIpIHRoaXMuX2ZpbHRlciA9IGZpbHRlcjtcbiAgaWYgKGFwcGx5KSB0aGlzLl9hcHBseSA9IGFwcGx5O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZXZlbnQgc3RyZWFtIGluc3RhbmNlIHdpdGggdGhlIHByb3ZpZGVkXG4gKiAob3B0aW9uYWwpIGZpbHRlciwgYXBwbHkgYW5kIHJlY2VpdmUgZnVuY3Rpb25zLlxuICogQHBhcmFtIHtmdW5jdGlvbihPYmplY3QsIG51bWJlcik6IGJvb2xlYW59IFtmaWx0ZXJdIC0gRmlsdGVyIHByZWRpY2F0ZS5cbiAqICAgRXZlbnRzIHBhc3MgdGhyb3VnaCB3aGVuIHRydXRoeSwgZXZlbnRzIGFyZSBzdXBwcmVzc2VkIHdoZW4gZmFsc3kuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKE9iamVjdCk6ICp9IFthcHBseV0gLSBBcHBsaWVkIHRvIGlucHV0IGV2ZW50cyB0byBwcm9kdWNlXG4gKiAgIG5ldyBldmVudCB2YWx1ZXMuXG4gKiBAc2VlIEV2ZW50U3RyZWFtXG4gKi9cbmZ1bmN0aW9uIHN0cmVhbShmaWx0ZXIsIGFwcGx5LCByZWNlaXZlKSB7XG4gIHJldHVybiBuZXcgRXZlbnRTdHJlYW0oZmlsdGVyLCBhcHBseSwgcmVjZWl2ZSk7XG59XG5FdmVudFN0cmVhbS5wcm90b3R5cGUgPSB7XG4gIF9maWx0ZXI6IHRydXRoeSxcbiAgX2FwcGx5OiBpZGVudGl0eSxcbiAgdGFyZ2V0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0cyB8fCAodGhpcy5fdGFyZ2V0cyA9IFVuaXF1ZUxpc3QoaWQpKTtcbiAgfSxcbiAgY29uc3VtZShfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gISF0aGlzLl9jb25zdW1lO1xuICAgIHRoaXMuX2NvbnN1bWUgPSAhIV87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlY2VpdmUoZXZ0KSB7XG4gICAgaWYgKHRoaXMuX2ZpbHRlcihldnQpKSB7XG4gICAgICBjb25zdCB2YWwgPSB0aGlzLnZhbHVlID0gdGhpcy5fYXBwbHkoZXZ0KSxcbiAgICAgICAgdHJnID0gdGhpcy5fdGFyZ2V0cyxcbiAgICAgICAgbiA9IHRyZyA/IHRyZy5sZW5ndGggOiAwO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHRyZ1tpXS5yZWNlaXZlKHZhbCk7XG4gICAgICBpZiAodGhpcy5fY29uc3VtZSkge1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgZmlsdGVyKGZpbHRlcikge1xuICAgIGNvbnN0IHMgPSBzdHJlYW0oZmlsdGVyKTtcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQocyk7XG4gICAgcmV0dXJuIHM7XG4gIH0sXG4gIGFwcGx5KGFwcGx5KSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbShudWxsLCBhcHBseSk7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHMpO1xuICAgIHJldHVybiBzO1xuICB9LFxuICBtZXJnZSgpIHtcbiAgICBjb25zdCBzID0gc3RyZWFtKCk7XG4gICAgdGhpcy50YXJnZXRzKCkuYWRkKHMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgYXJndW1lbnRzW2ldLnRhcmdldHMoKS5hZGQocyk7XG4gICAgfVxuICAgIHJldHVybiBzO1xuICB9LFxuICB0aHJvdHRsZShwYXVzZSkge1xuICAgIGxldCB0ID0gLTE7XG4gICAgcmV0dXJuIHRoaXMuZmlsdGVyKCgpID0+IHtcbiAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICBpZiAobm93IC0gdCA+IHBhdXNlKSB7XG4gICAgICAgIHQgPSBub3c7XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIGRlYm91bmNlKGRlbGF5KSB7XG4gICAgY29uc3QgcyA9IHN0cmVhbSgpO1xuICAgIHRoaXMudGFyZ2V0cygpLmFkZChzdHJlYW0obnVsbCwgbnVsbCwgZGVib3VuY2UoZGVsYXksIGUgPT4ge1xuICAgICAgY29uc3QgZGYgPSBlLmRhdGFmbG93O1xuICAgICAgcy5yZWNlaXZlKGUpO1xuICAgICAgaWYgKGRmICYmIGRmLnJ1bikgZGYucnVuKCk7XG4gICAgfSkpKTtcbiAgICByZXR1cm4gcztcbiAgfSxcbiAgYmV0d2VlbihhLCBiKSB7XG4gICAgbGV0IGFjdGl2ZSA9IGZhbHNlO1xuICAgIGEudGFyZ2V0cygpLmFkZChzdHJlYW0obnVsbCwgbnVsbCwgKCkgPT4gYWN0aXZlID0gdHJ1ZSkpO1xuICAgIGIudGFyZ2V0cygpLmFkZChzdHJlYW0obnVsbCwgbnVsbCwgKCkgPT4gYWN0aXZlID0gZmFsc2UpKTtcbiAgICByZXR1cm4gdGhpcy5maWx0ZXIoKCkgPT4gYWN0aXZlKTtcbiAgfSxcbiAgZGV0YWNoKCkge1xuICAgIC8vIGVuc3VyZXMgY29tcGF0aWJpbGl0eSB3aXRoIG9wZXJhdG9ycyAoIzI3NTMpXG4gICAgLy8gcmVtb3ZlIHJlZmVyZW5jZXMgdG8gb3RoZXIgc3RyZWFtcyBhbmQgZmlsdGVyIGZ1bmN0aW9ucyB0aGF0IG1heVxuICAgIC8vIGJlIGJvdW5kIHRvIHN1YmNvbnRleHRzIHRoYXQgbmVlZCB0byBiZSBnYXJiYWdlIGNvbGxlY3RlZC5cbiAgICB0aGlzLl9maWx0ZXIgPSB0cnV0aHk7XG4gICAgdGhpcy5fdGFyZ2V0cyA9IG51bGw7XG4gIH1cbn07XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV2ZW50IHN0cmVhbSBmcm9tIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIG1vbml0b3IuIFRoZSBpbnB1dCBtdXN0XG4gKiAgc3VwcG9ydCB0aGUgYWRkRXZlbnRMaXN0ZW5lciBtZXRob2QuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBbZmlsdGVyXSAtIEV2ZW50IGZpbHRlciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW2FwcGx5XSAtIEV2ZW50IGFwcGxpY2F0aW9uIGZ1bmN0aW9uLlxuICogICBJZiBwcm92aWRlZCwgdGhpcyBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgYW5kIHRoZSByZXN1bHQgd2lsbCBiZVxuICogICB1c2VkIGFzIHRoZSBkb3duc3RyZWFtIGV2ZW50IHZhbHVlLlxuICogQHJldHVybiB7RXZlbnRTdHJlYW19XG4gKi9cbmZ1bmN0aW9uIGV2ZW50cyAoc291cmNlLCB0eXBlLCBmaWx0ZXIsIGFwcGx5KSB7XG4gIGNvbnN0IGRmID0gdGhpcyxcbiAgICBzID0gc3RyZWFtKGZpbHRlciwgYXBwbHkpLFxuICAgIHNlbmQgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgZS5kYXRhZmxvdyA9IGRmO1xuICAgICAgdHJ5IHtcbiAgICAgICAgcy5yZWNlaXZlKGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgZGYuZXJyb3IoZXJyb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZGYucnVuKCk7XG4gICAgICB9XG4gICAgfTtcbiAgbGV0IHNvdXJjZXM7XG4gIGlmICh0eXBlb2Ygc291cmNlID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgc291cmNlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc291cmNlKTtcbiAgfSBlbHNlIHtcbiAgICBzb3VyY2VzID0gYXJyYXkoc291cmNlKTtcbiAgfVxuICBjb25zdCBuID0gc291cmNlcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgc291cmNlc1tpXS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIHNlbmQpO1xuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBwYXJzZShkYXRhLCBmb3JtYXQpIHtcbiAgY29uc3QgbG9jYWxlID0gdGhpcy5sb2NhbGUoKTtcbiAgcmV0dXJuIHJlYWQoZGF0YSwgZm9ybWF0LCBsb2NhbGUudGltZVBhcnNlLCBsb2NhbGUudXRjUGFyc2UpO1xufVxuXG4vKipcbiAqIEluZ2VzdHMgbmV3IGRhdGEgaW50byB0aGUgZGF0YWZsb3cuIEZpcnN0IHBhcnNlcyB0aGUgZGF0YSB1c2luZyB0aGVcbiAqIHZlZ2EtbG9hZGVyIHJlYWQgbWV0aG9kLCB0aGVuIHB1bHNlcyBhIGNoYW5nZXNldCB0byB0aGUgdGFyZ2V0IG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gdGFyZ2V0IC0gVGhlIE9wZXJhdG9yIHRvIHRhcmdldCB3aXRoIGluZ2VzdGVkIGRhdGEsXG4gKiAgIHR5cGljYWxseSBhIENvbGxlY3QgdHJhbnNmb3JtIGluc3RhbmNlLlxuICogQHBhcmFtIHsqfSBkYXRhIC0gVGhlIGlucHV0IGRhdGEsIHByaW9yIHRvIHBhcnNpbmcuIEZvciBKU09OIHRoaXMgbWF5XG4gKiAgIGJlIGEgc3RyaW5nIG9yIGFuIG9iamVjdC4gRm9yIENTViwgVFNWLCBldGMgc2hvdWxkIGJlIGEgc3RyaW5nLlxuICogQHBhcmFtIHtvYmplY3R9IGZvcm1hdCAtIFRoZSBkYXRhIGZvcm1hdCBkZXNjcmlwdGlvbiBmb3IgcGFyc2luZ1xuICogICBsb2FkZWQgZGF0YS4gVGhpcyBvYmplY3QgaXMgcGFzc2VkIHRvIHRoZSB2ZWdhLWxvYWRlciByZWFkIG1ldGhvZC5cbiAqIEByZXR1cm5zIHtEYXRhZmxvd31cbiAqL1xuZnVuY3Rpb24gaW5nZXN0KHRhcmdldCwgZGF0YSwgZm9ybWF0KSB7XG4gIGRhdGEgPSB0aGlzLnBhcnNlKGRhdGEsIGZvcm1hdCk7XG4gIHJldHVybiB0aGlzLnB1bHNlKHRhcmdldCwgdGhpcy5jaGFuZ2VzZXQoKS5pbnNlcnQoZGF0YSkpO1xufVxuXG4vKipcbiAqIFJlcXVlc3QgZGF0YSBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZSwgcGFyc2UgaXQsIGFuZCByZXR1cm4gYSBQcm9taXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgZnJvbSB3aGljaCB0byBsb2FkIHRoZSBkYXRhLiBUaGlzIHN0cmluZ1xuICogICBpcyBwYXNzZWQgdG8gdGhlIHZlZ2EtbG9hZGVyIGxvYWQgbWV0aG9kLlxuICogQHBhcmFtIHtvYmplY3R9IFtmb3JtYXRdIC0gVGhlIGRhdGEgZm9ybWF0IGRlc2NyaXB0aW9uIGZvciBwYXJzaW5nXG4gKiAgIGxvYWRlZCBkYXRhLiBUaGlzIG9iamVjdCBpcyBwYXNzZWQgdG8gdGhlIHZlZ2EtbG9hZGVyIHJlYWQgbWV0aG9kLlxuICogQHJldHVybiB7UHJvbWlzZX0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdXBvbiBjb21wbGV0aW9uIG9mIHRoZSByZXF1ZXN0LlxuICogICBUaGUgcmVzb2x2ZWQgb2JqZWN0IGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAgLSBkYXRhOiBhbiBhcnJheSBvZiBwYXJzZWQgZGF0YSAob3IgbnVsbCB1cG9uIGVycm9yKVxuICogICAtIHN0YXR1czogYSBjb2RlIGZvciBzdWNjZXNzICgwKSwgbG9hZCBmYWlsICgtMSksIG9yIHBhcnNlIGZhaWwgKC0yKVxuICovXG5hc3luYyBmdW5jdGlvbiByZXF1ZXN0KHVybCwgZm9ybWF0KSB7XG4gIGNvbnN0IGRmID0gdGhpcztcbiAgbGV0IHN0YXR1cyA9IDAsXG4gICAgZGF0YTtcbiAgdHJ5IHtcbiAgICBkYXRhID0gYXdhaXQgZGYubG9hZGVyKCkubG9hZCh1cmwsIHtcbiAgICAgIGNvbnRleHQ6ICdkYXRhZmxvdycsXG4gICAgICByZXNwb25zZTogcmVzcG9uc2VUeXBlKGZvcm1hdCAmJiBmb3JtYXQudHlwZSlcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgZGF0YSA9IGRmLnBhcnNlKGRhdGEsIGZvcm1hdCk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBzdGF0dXMgPSAtMjtcbiAgICAgIGRmLndhcm4oJ0RhdGEgaW5nZXN0aW9uIGZhaWxlZCcsIHVybCwgZXJyKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHN0YXR1cyA9IC0xO1xuICAgIGRmLndhcm4oJ0xvYWRpbmcgZmFpbGVkJywgdXJsLCBlcnIpO1xuICB9XG4gIHJldHVybiB7XG4gICAgZGF0YSxcbiAgICBzdGF0dXNcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZWxvYWQodGFyZ2V0LCB1cmwsIGZvcm1hdCkge1xuICBjb25zdCBkZiA9IHRoaXMsXG4gICAgcGVuZGluZyA9IGRmLl9wZW5kaW5nIHx8IGxvYWRQZW5kaW5nKGRmKTtcbiAgcGVuZGluZy5yZXF1ZXN0cyArPSAxO1xuICBjb25zdCByZXMgPSBhd2FpdCBkZi5yZXF1ZXN0KHVybCwgZm9ybWF0KTtcbiAgZGYucHVsc2UodGFyZ2V0LCBkZi5jaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQocmVzLmRhdGEgfHwgW10pKTtcbiAgcGVuZGluZy5kb25lKCk7XG4gIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBsb2FkUGVuZGluZyhkZikge1xuICBsZXQgYWNjZXB0O1xuICBjb25zdCBwZW5kaW5nID0gbmV3IFByb21pc2UoYSA9PiBhY2NlcHQgPSBhKTtcbiAgcGVuZGluZy5yZXF1ZXN0cyA9IDA7XG4gIHBlbmRpbmcuZG9uZSA9ICgpID0+IHtcbiAgICBpZiAoLS1wZW5kaW5nLnJlcXVlc3RzID09PSAwKSB7XG4gICAgICBkZi5fcGVuZGluZyA9IG51bGw7XG4gICAgICBhY2NlcHQoZGYpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGRmLl9wZW5kaW5nID0gcGVuZGluZztcbn1cblxuY29uc3QgU0tJUCA9IHtcbiAgc2tpcDogdHJ1ZVxufTtcblxuLyoqXG4gKiBQZXJmb3JtIG9wZXJhdG9yIHVwZGF0ZXMgaW4gcmVzcG9uc2UgdG8gZXZlbnRzLiBBcHBsaWVzIGFuXG4gKiB1cGRhdGUgZnVuY3Rpb24gdG8gY29tcHV0ZSBhIG5ldyBvcGVyYXRvciB2YWx1ZS4gSWYgdGhlIHVwZGF0ZSBmdW5jdGlvblxuICogcmV0dXJucyBhIHtAbGluayBDaGFuZ2VTZXR9LCB0aGUgb3BlcmF0b3Igd2lsbCBiZSBwdWxzZWQgd2l0aCB0aG9zZSB0dXBsZVxuICogY2hhbmdlcy4gT3RoZXJ3aXNlLCB0aGUgb3BlcmF0b3IgdmFsdWUgd2lsbCBiZSB1cGRhdGVkIHRvIHRoZSByZXR1cm4gdmFsdWUuXG4gKiBAcGFyYW0ge0V2ZW50U3RyZWFtfE9wZXJhdG9yfSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIHJlYWN0IHRvLlxuICogICBUaGlzIGFyZ3VtZW50IGNhbiBiZSBlaXRoZXIgYW4gRXZlbnRTdHJlYW0gb3IgYW4gT3BlcmF0b3IuXG4gKiBAcGFyYW0ge09wZXJhdG9yfGZ1bmN0aW9uKG9iamVjdCk6T3BlcmF0b3J9IHRhcmdldCAtIFRoZSBvcGVyYXRvciB0byB1cGRhdGUuXG4gKiAgIFRoaXMgYXJndW1lbnQgY2FuIGVpdGhlciBiZSBhbiBPcGVyYXRvciBpbnN0YW5jZSBvciAoaWYgdGhlIHNvdXJjZVxuICogICBhcmd1bWVudCBpcyBhbiBFdmVudFN0cmVhbSksIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIGFuIGV2ZW50IG9iamVjdCBhc1xuICogICBpbnB1dCBhbmQgcmV0dXJucyBhbiBPcGVyYXRvciB0byB0YXJnZXQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKFBhcmFtZXRlcnMsRXZlbnQpOiAqfSBbdXBkYXRlXSAtIE9wdGlvbmFsIHVwZGF0ZSBmdW5jdGlvblxuICogICB0byBjb21wdXRlIHRoZSBuZXcgb3BlcmF0b3IgdmFsdWUsIG9yIGEgbGl0ZXJhbCB2YWx1ZSB0byBzZXQuIFVwZGF0ZVxuICogICBmdW5jdGlvbnMgZXhwZWN0IHRvIHJlY2VpdmUgYSBwYXJhbWV0ZXIgb2JqZWN0IGFuZCBldmVudCBhcyBhcmd1bWVudHMuXG4gKiAgIFRoaXMgZnVuY3Rpb24gY2FuIGVpdGhlciByZXR1cm4gYSBuZXcgb3BlcmF0b3IgdmFsdWUgb3IgKGlmIHRoZSBzb3VyY2VcbiAqICAgYXJndW1lbnQgaXMgYW4gRXZlbnRTdHJlYW0pIGEge0BsaW5rIENoYW5nZVNldH0gaW5zdGFuY2UgdG8gcHVsc2VcbiAqICAgdGhlIHRhcmdldCBvcGVyYXRvciB3aXRoIHR1cGxlIGNoYW5nZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gLSBUaGUgdXBkYXRlIGZ1bmN0aW9uIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gQWRkaXRpb25hbCBvcHRpb25zIGhhc2guIElmIG5vdCBvdmVycmlkZGVuLFxuICogICB1cGRhdGVkIG9wZXJhdG9ycyB3aWxsIGJlIHNraXBwZWQgYnkgZGVmYXVsdC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcF0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZvcmNlXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHJlLWV2YWx1YXRlZCBldmVuIGlmIGl0cyB2YWx1ZSBoYXMgbm90IGNoYW5nZWQuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuZnVuY3Rpb24gb24gKHNvdXJjZSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICBjb25zdCBmbiA9IHNvdXJjZSBpbnN0YW5jZW9mIE9wZXJhdG9yID8gb25PcGVyYXRvciA6IG9uU3RyZWFtO1xuICBmbih0aGlzLCBzb3VyY2UsIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICByZXR1cm4gdGhpcztcbn1cbmZ1bmN0aW9uIG9uU3RyZWFtKGRmLCBzdHJlYW0sIHRhcmdldCwgdXBkYXRlLCBwYXJhbXMsIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0ID0gZXh0ZW5kKHt9LCBvcHRpb25zLCBTS0lQKTtcbiAgbGV0IGZ1bmMsIG9wO1xuICBpZiAoIWlzRnVuY3Rpb24odGFyZ2V0KSkgdGFyZ2V0ID0gY29uc3RhbnQodGFyZ2V0KTtcbiAgaWYgKHVwZGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZnVuYyA9IGUgPT4gZGYudG91Y2godGFyZ2V0KGUpKTtcbiAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHVwZGF0ZSkpIHtcbiAgICBvcCA9IG5ldyBPcGVyYXRvcihudWxsLCB1cGRhdGUsIHBhcmFtcywgZmFsc2UpO1xuICAgIGZ1bmMgPSBlID0+IHtcbiAgICAgIG9wLmV2YWx1YXRlKGUpO1xuICAgICAgY29uc3QgdCA9IHRhcmdldChlKSxcbiAgICAgICAgdiA9IG9wLnZhbHVlO1xuICAgICAgaXNDaGFuZ2VTZXQodikgPyBkZi5wdWxzZSh0LCB2LCBvcHRpb25zKSA6IGRmLnVwZGF0ZSh0LCB2LCBvcHQpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZnVuYyA9IGUgPT4gZGYudXBkYXRlKHRhcmdldChlKSwgdXBkYXRlLCBvcHQpO1xuICB9XG4gIHN0cmVhbS5hcHBseShmdW5jKTtcbn1cbmZ1bmN0aW9uIG9uT3BlcmF0b3IoZGYsIHNvdXJjZSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcywgb3B0aW9ucykge1xuICBpZiAodXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICBzb3VyY2UudGFyZ2V0cygpLmFkZCh0YXJnZXQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwge30sXG4gICAgICBvcCA9IG5ldyBPcGVyYXRvcihudWxsLCB1cGRhdGVyKHRhcmdldCwgdXBkYXRlKSwgcGFyYW1zLCBmYWxzZSk7XG4gICAgb3AubW9kaWZpZWQob3B0LmZvcmNlKTtcbiAgICBvcC5yYW5rID0gc291cmNlLnJhbms7IC8vIGltbWVkaWF0ZWx5IGZvbGxvdyBzb3VyY2VcbiAgICBzb3VyY2UudGFyZ2V0cygpLmFkZChvcCk7IC8vIGFkZCBkZXBlbmRlbmN5XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBvcC5za2lwKHRydWUpOyAvLyBza2lwIGZpcnN0IGludm9jYXRpb25cbiAgICAgIG9wLnZhbHVlID0gdGFyZ2V0LnZhbHVlOyAvLyBpbml0aWFsaXplIHZhbHVlXG4gICAgICBvcC50YXJnZXRzKCkuYWRkKHRhcmdldCk7IC8vIGNoYWluIGRlcGVuZGVuY2llc1xuICAgICAgZGYuY29ubmVjdCh0YXJnZXQsIFtvcF0pOyAvLyByZXJhbmsgYXMgbmVlZGVkLCAjMTY3MlxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gdXBkYXRlcih0YXJnZXQsIHVwZGF0ZSkge1xuICB1cGRhdGUgPSBpc0Z1bmN0aW9uKHVwZGF0ZSkgPyB1cGRhdGUgOiBjb25zdGFudCh1cGRhdGUpO1xuICByZXR1cm4gdGFyZ2V0ID8gZnVuY3Rpb24gKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgdmFsdWUgPSB1cGRhdGUoXywgcHVsc2UpO1xuICAgIGlmICghdGFyZ2V0LnNraXAoKSkge1xuICAgICAgdGFyZ2V0LnNraXAodmFsdWUgIT09IHRoaXMudmFsdWUpLnZhbHVlID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfSA6IHVwZGF0ZTtcbn1cblxuLyoqXG4gKiBBc3NpZ25zIGEgcmFuayB0byBhbiBvcGVyYXRvci4gUmFua3MgYXJlIGFzc2lnbmVkIGluIGluY3JlYXNpbmcgb3JkZXJcbiAqIGJ5IGluY3JlbWVudGluZyBhbiBpbnRlcm5hbCByYW5rIGNvdW50ZXIuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciB0byBhc3NpZ24gYSByYW5rLlxuICovXG5mdW5jdGlvbiByYW5rKG9wKSB7XG4gIG9wLnJhbmsgPSArK3RoaXMuX3Jhbms7XG59XG5cbi8qKlxuICogUmUtcmFua3MgYW4gb3BlcmF0b3IgYW5kIGFsbCBkb3duc3RyZWFtIHRhcmdldCBkZXBlbmRlbmNpZXMuIFRoaXNcbiAqIGlzIG5lY2Vzc2FyeSB3aGVuIHVwc3RyZWFtIGRlcGVuZGVuY2llcyBvZiBoaWdoZXIgcmFuayBhcmUgYWRkZWQgdG9cbiAqIGEgdGFyZ2V0IG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gcmUtcmFuay5cbiAqL1xuZnVuY3Rpb24gcmVyYW5rKG9wKSB7XG4gIGNvbnN0IHF1ZXVlID0gW29wXTtcbiAgbGV0IGN1ciwgbGlzdCwgaTtcbiAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgIHRoaXMucmFuayhjdXIgPSBxdWV1ZS5wb3AoKSk7XG4gICAgaWYgKGxpc3QgPSBjdXIuX3RhcmdldHMpIHtcbiAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoOyAtLWkgPj0gMDspIHtcbiAgICAgICAgcXVldWUucHVzaChjdXIgPSBsaXN0W2ldKTtcbiAgICAgICAgaWYgKGN1ciA9PT0gb3ApIGVycm9yKCdDeWNsZSBkZXRlY3RlZCBpbiBkYXRhZmxvdyBncmFwaC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTZW50aW5lbCB2YWx1ZSBpbmRpY2F0aW5nIHB1bHNlIHByb3BhZ2F0aW9uIHNob3VsZCBzdG9wLlxuICovXG5jb25zdCBTdG9wUHJvcGFnYXRpb24gPSB7fTtcblxuLy8gUHVsc2UgdmlzaXQgdHlwZSBmbGFnc1xuY29uc3QgQUREID0gMSA8PCAwLFxuICBSRU0gPSAxIDw8IDEsXG4gIE1PRCA9IDEgPDwgMixcbiAgQUREX1JFTSA9IEFERCB8IFJFTSxcbiAgQUREX01PRCA9IEFERCB8IE1PRCxcbiAgQUxMID0gQUREIHwgUkVNIHwgTU9ELFxuICBSRUZMT1cgPSAxIDw8IDMsXG4gIFNPVVJDRSA9IDEgPDwgNCxcbiAgTk9fU09VUkNFID0gMSA8PCA1LFxuICBOT19GSUVMRFMgPSAxIDw8IDY7XG5cbi8qKlxuICogQSBQdWxzZSBlbmFibGVzIGludGVyLW9wZXJhdG9yIGNvbW11bmljYXRpb24gZHVyaW5nIGEgcnVuIG9mIHRoZVxuICogZGF0YWZsb3cgZ3JhcGguIEluIGFkZGl0aW9uIHRvIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgYSBwdWxzZSBtYXkgYWxzb1xuICogY29udGFpbiBhIGNoYW5nZS1zZXQgb2YgYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQgZGF0YSB0dXBsZXMsIGFzIHdlbGwgYXNcbiAqIGEgcG9pbnRlciB0byBhIGZ1bGwgYmFja2luZyBkYXRhIHNvdXJjZS4gVHVwbGUgY2hhbmdlIHNldHMgbWF5IG5vdFxuICogYmUgZnVsbHkgbWF0ZXJpYWxpemVkOyBmb3IgZXhhbXBsZSwgdG8gcHJldmVudCBuZWVkbGVzcyBhcnJheSBjcmVhdGlvblxuICogYSBjaGFuZ2Ugc2V0IG1heSBpbmNsdWRlIGxhcmdlciBhcnJheXMgYW5kIGNvcnJlc3BvbmRpbmcgZmlsdGVyIGZ1bmN0aW9ucy5cbiAqIFRoZSBwdWxzZSBwcm92aWRlcyBhIHtAbGluayB2aXNpdH0gbWV0aG9kIHRvIGVuYWJsZSBwcm9wZXIgYW5kIGVmZmljaWVudFxuICogaXRlcmF0aW9uIG92ZXIgcmVxdWVzdGVkIGRhdGEgdHVwbGVzLlxuICpcbiAqIEluIGFkZGl0aW9uLCBlYWNoIHB1bHNlIGNhbiB0cmFjayBtb2RpZmljYXRpb24gZmxhZ3MgZm9yIGRhdGEgdHVwbGUgZmllbGRzLlxuICogUmVzcG9uc2libGUgdHJhbnNmb3JtIG9wZXJhdG9ycyBzaG91bGQgY2FsbCB0aGUge0BsaW5rIG1vZGlmaWVzfSBtZXRob2QgdG9cbiAqIGluZGljYXRlIGNoYW5nZXMgdG8gZGF0YSBmaWVsZHMuIFRoZSB7QGxpbmsgbW9kaWZpZWR9IG1ldGhvZCBlbmFibGVzXG4gKiBxdWVyeWluZyBvZiB0aGlzIG1vZGlmaWNhdGlvbiBzdGF0ZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RGF0YWZsb3d9IGRhdGFmbG93IC0gVGhlIGJhY2tpbmcgZGF0YWZsb3cgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhbXAgLSBUaGUgY3VycmVudCBwcm9wYWdhdGlvbiB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kZV0gLSBBbiBvcHRpb25hbCBlbmNvZGluZyBzZXQgbmFtZSwgd2hpY2ggaXMgdGhlblxuICogICBhY2Nlc3NpYmxlIGFzIFB1bHNlLmVuY29kZS4gT3BlcmF0b3JzIGNhbiByZXNwb25kIHRvIChvciBpZ25vcmUpIHRoaXNcbiAqICAgc2V0dGluZyBhcyBhcHByb3ByaWF0ZS4gVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aFxuICogICB0aGUgRW5jb2RlIHRyYW5zZm9ybSBpbiB0aGUgdmVnYS1lbmNvZGUgbW9kdWxlLlxuICovXG5mdW5jdGlvbiBQdWxzZShkYXRhZmxvdywgc3RhbXAsIGVuY29kZSkge1xuICB0aGlzLmRhdGFmbG93ID0gZGF0YWZsb3c7XG4gIHRoaXMuc3RhbXAgPSBzdGFtcCA9PSBudWxsID8gLTEgOiBzdGFtcDtcbiAgdGhpcy5hZGQgPSBbXTtcbiAgdGhpcy5yZW0gPSBbXTtcbiAgdGhpcy5tb2QgPSBbXTtcbiAgdGhpcy5maWVsZHMgPSBudWxsO1xuICB0aGlzLmVuY29kZSA9IGVuY29kZSB8fCBudWxsO1xufVxuZnVuY3Rpb24gbWF0ZXJpYWxpemUoZGF0YSwgZmlsdGVyKSB7XG4gIGNvbnN0IG91dCA9IFtdO1xuICB2aXNpdEFycmF5KGRhdGEsIGZpbHRlciwgXyA9PiBvdXQucHVzaChfKSk7XG4gIHJldHVybiBvdXQ7XG59XG5mdW5jdGlvbiBmaWx0ZXIocHVsc2UsIGZsYWdzKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBwdWxzZS52aXNpdChmbGFncywgdCA9PiB7XG4gICAgbWFwW3R1cGxlaWQodCldID0gMTtcbiAgfSk7XG4gIHJldHVybiB0ID0+IG1hcFt0dXBsZWlkKHQpXSA/IG51bGwgOiB0O1xufVxuZnVuY3Rpb24gYWRkRmlsdGVyKGEsIGIpIHtcbiAgcmV0dXJuIGEgPyAodCwgaSkgPT4gYSh0LCBpKSAmJiBiKHQsIGkpIDogYjtcbn1cblB1bHNlLnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFNlbnRpbmVsIHZhbHVlIGluZGljYXRpbmcgcHVsc2UgcHJvcGFnYXRpb24gc2hvdWxkIHN0b3AuXG4gICAqL1xuICBTdG9wUHJvcGFnYXRpb24sXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBBREQgKGFkZGVkKSB0dXBsZXMuXG4gICAqL1xuICBBREQsXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBSRU0gKHJlbW92ZWQpIHR1cGxlcy5cbiAgICovXG4gIFJFTSxcbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIE1PRCAobW9kaWZpZWQpIHR1cGxlcy5cbiAgICovXG4gIE1PRCxcbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIEFERCAoYWRkZWQpIGFuZCBSRU0gKHJlbW92ZWQpIHR1cGxlcy5cbiAgICovXG4gIEFERF9SRU0sXG4gIC8qKlxuICAgKiBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBBREQgKGFkZGVkKSBhbmQgTU9EIChtb2RpZmllZCkgdHVwbGVzLlxuICAgKi9cbiAgQUREX01PRCxcbiAgLyoqXG4gICAqIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIEFERCwgUkVNIGFuZCBNT0QgdHVwbGVzLlxuICAgKi9cbiAgQUxMLFxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgYWxsIHR1cGxlcyBpbiBhIGRhdGEgc291cmNlXG4gICAqIGV4Y2VwdCBmb3IgdGhlIEFERCwgUkVNIGFuZCBNT0QgdHVwbGVzLlxuICAgKi9cbiAgUkVGTE9XLFxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgYSAncGFzcy10aHJvdWdoJyB0byBhXG4gICAqIGJhY2tpbmcgZGF0YSBzb3VyY2UsIGlnbm9yaW5nIEFERCwgUkVNIGFuZCBNT0QgdHVwbGVzLlxuICAgKi9cbiAgU09VUkNFLFxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgdGhhdCBzb3VyY2UgZGF0YSBzaG91bGQgYmVcbiAgICogc3VwcHJlc3NlZCB3aGVuIGNyZWF0aW5nIGEgZm9ya2VkIHB1bHNlLlxuICAgKi9cbiAgTk9fU09VUkNFLFxuICAvKipcbiAgICogQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgdGhhdCBmaWVsZCBtb2RpZmljYXRpb25zIHNob3VsZCBiZVxuICAgKiBzdXBwcmVzc2VkIHdoZW4gY3JlYXRpbmcgYSBmb3JrZWQgcHVsc2UuXG4gICAqL1xuICBOT19GSUVMRFMsXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IHB1bHNlIGJhc2VkIG9uIHRoZSB2YWx1ZXMgb2YgdGhpcyBwdWxzZS5cbiAgICogVGhlIGRhdGFmbG93LCB0aW1lIHN0YW1wIGFuZCBmaWVsZCBtb2RpZmljYXRpb24gdmFsdWVzIGFyZSBjb3BpZWQgb3Zlci5cbiAgICogQnkgZGVmYXVsdCwgbmV3IGVtcHR5IEFERCwgUkVNIGFuZCBNT0QgYXJyYXlzIGFyZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZmxhZ3MgLSBJbnRlZ2VyIG9mIGJvb2xlYW4gZmxhZ3MgaW5kaWNhdGluZyB3aGljaCAoaWYgYW55KVxuICAgKiAgIHR1cGxlIGFycmF5cyBzaG91bGQgYmUgY29waWVkIHRvIHRoZSBuZXcgcHVsc2UuIFRoZSBzdXBwb3J0ZWQgZmxhZyB2YWx1ZXNcbiAgICogICBhcmUgQURELCBSRU0gYW5kIE1PRC4gQXJyYXkgcmVmZXJlbmNlcyBhcmUgY29waWVkIGRpcmVjdGx5OiBuZXcgYXJyYXlcbiAgICogICBpbnN0YW5jZXMgYXJlIG5vdCBjcmVhdGVkLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBUaGUgZm9ya2VkIHB1bHNlIGluc3RhbmNlLlxuICAgKiBAc2VlIGluaXRcbiAgICovXG4gIGZvcmsoZmxhZ3MpIHtcbiAgICByZXR1cm4gbmV3IFB1bHNlKHRoaXMuZGF0YWZsb3cpLmluaXQodGhpcywgZmxhZ3MpO1xuICB9LFxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBwdWxzZSB3aXRoIG5ldyBtYXRlcmlhbGl6ZWQgYXJyYXlcbiAgICogaW5zdGFuY2VzIGZvciB0aGUgQURELCBSRU0sIE1PRCwgYW5kIFNPVVJDRSBhcnJheXMuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEByZXR1cm4ge1B1bHNlfSAtIFRoZSBjbG9uZWQgcHVsc2UgaW5zdGFuY2UuXG4gICAqIEBzZWUgaW5pdFxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuZm9yayhBTEwpO1xuICAgIHAuYWRkID0gcC5hZGQuc2xpY2UoKTtcbiAgICBwLnJlbSA9IHAucmVtLnNsaWNlKCk7XG4gICAgcC5tb2QgPSBwLm1vZC5zbGljZSgpO1xuICAgIGlmIChwLnNvdXJjZSkgcC5zb3VyY2UgPSBwLnNvdXJjZS5zbGljZSgpO1xuICAgIHJldHVybiBwLm1hdGVyaWFsaXplKEFMTCB8IFNPVVJDRSk7XG4gIH0sXG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgcHVsc2UgdGhhdCBhZGRzIGFsbCB0dXBsZXMgZnJvbSBhIGJhY2tpbmcgc291cmNlLiBUaGlzIGlzXG4gICAqIHVzZWZ1bCBmb3IgY2FzZXMgd2hlcmUgb3BlcmF0b3JzIGFyZSBhZGRlZCB0byBhIGRhdGFmbG93IGFmdGVyIGFuXG4gICAqIHVwc3RyZWFtIGRhdGEgcGlwZWxpbmUgaGFzIGFscmVhZHkgYmVlbiBwcm9jZXNzZWQsIGVuc3VyaW5nIHRoYXRcbiAgICogbmV3IG9wZXJhdG9ycyBjYW4gb2JzZXJ2ZSBhbGwgdHVwbGVzIHdpdGhpbiBhIHN0cmVhbS5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gQSBwdWxzZSBpbnN0YW5jZSB3aXRoIGFsbCBzb3VyY2UgdHVwbGVzIGluY2x1ZGVkXG4gICAqICAgaW4gdGhlIGFkZCBhcnJheS4gSWYgdGhlIGN1cnJlbnQgcHVsc2UgYWxyZWFkeSBoYXMgYWxsIHNvdXJjZVxuICAgKiAgIHR1cGxlcyBpbiBpdHMgYWRkIGFycmF5LCBpdCBpcyByZXR1cm5lZCBkaXJlY3RseS4gSWYgdGhlIGN1cnJlbnRcbiAgICogICBwdWxzZSBkb2VzIG5vdCBoYXZlIGEgYmFja2luZyBzb3VyY2UsIGl0IGlzIHJldHVybmVkIGRpcmVjdGx5LlxuICAgKi9cbiAgYWRkQWxsKCkge1xuICAgIGxldCBwID0gdGhpcztcbiAgICBjb25zdCByZXVzZSA9ICFwLnNvdXJjZSB8fCBwLmFkZCA9PT0gcC5yZW0gLy8gc3BlY2lhbCBjYXNlIGZvciBpbmRleGVkIHNldCAoZS5nLiwgY3Jvc3NmaWx0ZXIpXG4gICAgfHwgIXAucmVtLmxlbmd0aCAmJiBwLnNvdXJjZS5sZW5ndGggPT09IHAuYWRkLmxlbmd0aDtcbiAgICBpZiAocmV1c2UpIHtcbiAgICAgIHJldHVybiBwO1xuICAgIH0gZWxzZSB7XG4gICAgICBwID0gbmV3IFB1bHNlKHRoaXMuZGF0YWZsb3cpLmluaXQodGhpcyk7XG4gICAgICBwLmFkZCA9IHAuc291cmNlO1xuICAgICAgcC5yZW0gPSBbXTsgLy8gbmV3IG9wZXJhdG9ycyBjYW4gaWdub3JlIHJlbSAjMjc2OVxuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICB9LFxuICAvKipcbiAgICogSW5pdGlhbGl6ZSB0aGlzIHB1bHNlIGJhc2VkIG9uIHRoZSB2YWx1ZXMgb2YgYW5vdGhlciBwdWxzZS4gVGhpcyBtZXRob2RcbiAgICogaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IHtAbGluayBmb3JrfSB0byBpbml0aWFsaXplIGEgbmV3IGZvcmtlZCB0dXBsZS5cbiAgICogVGhlIGRhdGFmbG93LCB0aW1lIHN0YW1wIGFuZCBmaWVsZCBtb2RpZmljYXRpb24gdmFsdWVzIGFyZSBjb3BpZWQgb3Zlci5cbiAgICogQnkgZGVmYXVsdCwgbmV3IGVtcHR5IEFERCwgUkVNIGFuZCBNT0QgYXJyYXlzIGFyZSBjcmVhdGVkLlxuICAgKiBAcGFyYW0ge1B1bHNlfSBzcmMgLSBUaGUgc291cmNlIHB1bHNlIHRvIGNvcHkgZnJvbS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gSW50ZWdlciBvZiBib29sZWFuIGZsYWdzIGluZGljYXRpbmcgd2hpY2ggKGlmIGFueSlcbiAgICogICB0dXBsZSBhcnJheXMgc2hvdWxkIGJlIGNvcGllZCB0byB0aGUgbmV3IHB1bHNlLiBUaGUgc3VwcG9ydGVkIGZsYWcgdmFsdWVzXG4gICAqICAgYXJlIEFERCwgUkVNIGFuZCBNT0QuIEFycmF5IHJlZmVyZW5jZXMgYXJlIGNvcGllZCBkaXJlY3RseTogbmV3IGFycmF5XG4gICAqICAgaW5zdGFuY2VzIGFyZSBub3QgY3JlYXRlZC4gQnkgZGVmYXVsdCwgc291cmNlIGRhdGEgYXJyYXlzIGFyZSBjb3BpZWRcbiAgICogICB0byB0aGUgbmV3IHB1bHNlLiBVc2UgdGhlIE5PX1NPVVJDRSBmbGFnIHRvIGVuZm9yY2UgYSBudWxsIHNvdXJjZS5cbiAgICogQHJldHVybiB7UHVsc2V9IC0gUmV0dXJucyB0aGlzIFB1bHNlIGluc3RhbmNlLlxuICAgKi9cbiAgaW5pdChzcmMsIGZsYWdzKSB7XG4gICAgY29uc3QgcCA9IHRoaXM7XG4gICAgcC5zdGFtcCA9IHNyYy5zdGFtcDtcbiAgICBwLmVuY29kZSA9IHNyYy5lbmNvZGU7XG4gICAgaWYgKHNyYy5maWVsZHMgJiYgIShmbGFncyAmIE5PX0ZJRUxEUykpIHtcbiAgICAgIHAuZmllbGRzID0gc3JjLmZpZWxkcztcbiAgICB9XG4gICAgaWYgKGZsYWdzICYgQUREKSB7XG4gICAgICBwLmFkZEYgPSBzcmMuYWRkRjtcbiAgICAgIHAuYWRkID0gc3JjLmFkZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5hZGRGID0gbnVsbDtcbiAgICAgIHAuYWRkID0gW107XG4gICAgfVxuICAgIGlmIChmbGFncyAmIFJFTSkge1xuICAgICAgcC5yZW1GID0gc3JjLnJlbUY7XG4gICAgICBwLnJlbSA9IHNyYy5yZW07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAucmVtRiA9IG51bGw7XG4gICAgICBwLnJlbSA9IFtdO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MgJiBNT0QpIHtcbiAgICAgIHAubW9kRiA9IHNyYy5tb2RGO1xuICAgICAgcC5tb2QgPSBzcmMubW9kO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLm1vZEYgPSBudWxsO1xuICAgICAgcC5tb2QgPSBbXTtcbiAgICB9XG4gICAgaWYgKGZsYWdzICYgTk9fU09VUkNFKSB7XG4gICAgICBwLnNyY0YgPSBudWxsO1xuICAgICAgcC5zb3VyY2UgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnNyY0YgPSBzcmMuc3JjRjtcbiAgICAgIHAuc291cmNlID0gc3JjLnNvdXJjZTtcbiAgICAgIGlmIChzcmMuY2xlYW5zKSBwLmNsZWFucyA9IHNyYy5jbGVhbnM7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9LFxuICAvKipcbiAgICogU2NoZWR1bGVzIGEgZnVuY3Rpb24gdG8gcnVuIGFmdGVyIHB1bHNlIHByb3BhZ2F0aW9uIGNvbXBsZXRlcy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gZnVuYyAtIFRoZSBmdW5jdGlvbiB0byBydW4uXG4gICAqL1xuICBydW5BZnRlcihmdW5jKSB7XG4gICAgdGhpcy5kYXRhZmxvdy5ydW5BZnRlcihmdW5jKTtcbiAgfSxcbiAgLyoqXG4gICAqIEluZGljYXRlcyBpZiB0dXBsZXMgaGF2ZSBiZWVuIGFkZGVkLCByZW1vdmVkIG9yIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2ZsYWdzXSAtIFRoZSB0dXBsZSB0eXBlcyAoQURELCBSRU0gb3IgTU9EKSB0byBxdWVyeS5cbiAgICogICBEZWZhdWx0cyB0byBBTEwsIHJldHVybmluZyB0cnVlIGlmIGFueSB0dXBsZSB0eXBlIGhhcyBjaGFuZ2VkLlxuICAgKiBAcmV0dXJuIHtib29sZWFufSAtIFJldHVybnMgdHJ1ZSBpZiBvbmUgb3IgbW9yZSBxdWVyaWVkIHR1cGxlIHR5cGVzIGhhdmVcbiAgICogICBjaGFuZ2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBjaGFuZ2VkKGZsYWdzKSB7XG4gICAgY29uc3QgZiA9IGZsYWdzIHx8IEFMTDtcbiAgICByZXR1cm4gZiAmIEFERCAmJiB0aGlzLmFkZC5sZW5ndGggfHwgZiAmIFJFTSAmJiB0aGlzLnJlbS5sZW5ndGggfHwgZiAmIE1PRCAmJiB0aGlzLm1vZC5sZW5ndGg7XG4gIH0sXG4gIC8qKlxuICAgKiBGb3JjZXMgYSBcInJlZmxvd1wiIG9mIHR1cGxlIHZhbHVlcywgc3VjaCB0aGF0IGFsbCB0dXBsZXMgaW4gdGhlIGJhY2tpbmdcbiAgICogc291cmNlIGFyZSBhZGRlZCB0byB0aGUgTU9EIHNldCwgdW5sZXNzIGFscmVhZHkgcHJlc2VudCBpbiB0aGUgQUREIHNldC5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZm9yaz1mYWxzZV0gLSBJZiB0cnVlLCByZXR1cm5zIGEgZm9ya2VkIGNvcHkgb2YgdGhpc1xuICAgKiAgIHB1bHNlLCBhbmQgaW52b2tlcyByZWZsb3cgb24gdGhhdCBkZXJpdmVkIHB1bHNlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBUaGUgcmVmbG93ZWQgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICByZWZsb3coZm9yaykge1xuICAgIGlmIChmb3JrKSByZXR1cm4gdGhpcy5mb3JrKEFMTCkucmVmbG93KCk7XG4gICAgY29uc3QgbGVuID0gdGhpcy5hZGQubGVuZ3RoLFxuICAgICAgc3JjID0gdGhpcy5zb3VyY2UgJiYgdGhpcy5zb3VyY2UubGVuZ3RoO1xuICAgIGlmIChzcmMgJiYgc3JjICE9PSBsZW4pIHtcbiAgICAgIHRoaXMubW9kID0gdGhpcy5zb3VyY2U7XG4gICAgICBpZiAobGVuKSB0aGlzLmZpbHRlcihNT0QsIGZpbHRlcih0aGlzLCBBREQpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBHZXQvc2V0IG1ldGFkYXRhIHRvIHB1bHNlIHJlcXVlc3RpbmcgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAqIHRvIHJlY2xhaW0gY3VycmVudGx5IHVudXNlZCByZXNvdXJjZXMuXG4gICAqL1xuICBjbGVhbih2YWx1ZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmNsZWFucyA9ICEhdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuY2xlYW5zO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIE1hcmtzIG9uZSBvciBtb3JlIGRhdGEgZmllbGQgbmFtZXMgYXMgbW9kaWZpZWQgdG8gYXNzaXN0IGRlcGVuZGVuY3lcbiAgICogdHJhY2tpbmcgYW5kIGluY3JlbWVudGFsIHByb2Nlc3NpbmcgYnkgdHJhbnNmb3JtIG9wZXJhdG9ycy5cbiAgICogQHBhcmFtIHtzdHJpbmd8QXJyYXk8c3RyaW5nPn0gXyAtIFRoZSBmaWVsZChzKSB0byBtYXJrIGFzIG1vZGlmaWVkLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBUaGlzIHB1bHNlIGluc3RhbmNlLlxuICAgKi9cbiAgbW9kaWZpZXMoXykge1xuICAgIGNvbnN0IGhhc2ggPSB0aGlzLmZpZWxkcyB8fCAodGhpcy5maWVsZHMgPSB7fSk7XG4gICAgaWYgKGlzQXJyYXkoXykpIHtcbiAgICAgIF8uZm9yRWFjaChmID0+IGhhc2hbZl0gPSB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaGFzaFtfXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICAvKipcbiAgICogQ2hlY2tzIGlmIG9uZSBvciBtb3JlIGRhdGEgZmllbGRzIGhhdmUgYmVlbiBtb2RpZmllZCBkdXJpbmcgdGhpcyBwdWxzZVxuICAgKiBwcm9wYWdhdGlvbiB0aW1lc3RhbXAuXG4gICAqIEBwYXJhbSB7c3RyaW5nfEFycmF5PHN0cmluZz59IF8gLSBUaGUgZmllbGQocykgdG8gY2hlY2sgZm9yIG1vZGlmaWVkLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IG5vbW9kIC0gSWYgdHJ1ZSwgd2lsbCBjaGVjayB0aGUgbW9kaWZpZWQgZmxhZyBldmVuIGlmXG4gICAqICAgbm8gbW9kIHR1cGxlcyBleGlzdC4gSWYgZmFsc2UgKGRlZmF1bHQpLCBtb2QgdHVwbGVzIG11c3QgYmUgcHJlc2VudC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gLSBSZXR1cm5zIHRydWUgaWYgYW55IG9mIHRoZSBwcm92aWRlZCBmaWVsZHMgaGFzIGJlZW5cbiAgICogICBtYXJrZWQgYXMgbW9kaWZpZWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICovXG4gIG1vZGlmaWVkKF8sIG5vbW9kKSB7XG4gICAgY29uc3QgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgcmV0dXJuICEoKG5vbW9kIHx8IHRoaXMubW9kLmxlbmd0aCkgJiYgZmllbGRzKSA/IGZhbHNlIDogIWFyZ3VtZW50cy5sZW5ndGggPyAhIWZpZWxkcyA6IGlzQXJyYXkoXykgPyBfLnNvbWUoZiA9PiBmaWVsZHNbZl0pIDogZmllbGRzW19dO1xuICB9LFxuICAvKipcbiAgICogQWRkcyBhIGZpbHRlciBmdW5jdGlvbiB0byBvbmUgbW9yZSB0dXBsZSBzZXRzLiBGaWx0ZXJzIGFyZSBhcHBsaWVkIHRvXG4gICAqIGJhY2tpbmcgdHVwbGUgYXJyYXlzLCB0byBkZXRlcm1pbmUgdGhlIGFjdHVhbCBzZXQgb2YgdHVwbGVzIGNvbnNpZGVyZWRcbiAgICogYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQuIFRoZXkgY2FuIGJlIHVzZWQgdG8gZGVsYXkgbWF0ZXJpYWxpemF0aW9uIG9mXG4gICAqIGEgdHVwbGUgc2V0IGluIG9yZGVyIHRvIGF2b2lkIGV4cGVuc2l2ZSBhcnJheSBjb3BpZXMuIEluIGFkZGl0aW9uLCB0aGVcbiAgICogZmlsdGVyIGZ1bmN0aW9ucyBjYW4gc2VydmUgYXMgdmFsdWUgdHJhbnNmb3JtZXJzOiB1bmxpa2Ugc3RhbmRhcmQgcHJlZGljYXRlXG4gICAqIGZ1bmN0aW9uICh3aGljaCByZXR1cm4gYm9vbGVhbiB2YWx1ZXMpLCBQdWxzZSBmaWx0ZXJzIHNob3VsZCByZXR1cm4gdGhlXG4gICAqIGFjdHVhbCB0dXBsZSB2YWx1ZSB0byBwcm9jZXNzLiBJZiBhIHR1cGxlIHNldCBpcyBhbHJlYWR5IGZpbHRlcmVkLCB0aGVcbiAgICogbmV3IGZpbHRlciBmdW5jdGlvbiB3aWxsIGJlIGFwcGVuZGVkIGludG8gYSBjb25qdW50aXZlICgnYW5kJykgcXVlcnkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmbGFncyAtIEZsYWdzIGluZGljYXRpbmcgdGhlIHR1cGxlIHNldChzKSB0byBmaWx0ZXIuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oKik6b2JqZWN0fSBmaWx0ZXIgLSBGaWx0ZXIgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAgICogICB0byB0aGUgdHVwbGUgc2V0IGFycmF5LCBhbmQgc2hvdWxkIHJldHVybiBhIGRhdGEgdHVwbGUgaWYgdGhlIHZhbHVlXG4gICAqICAgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZSB0dXBsZSBzZXQsIGFuZCBmYWxzeSAob3IgbnVsbCkgb3RoZXJ3aXNlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBmaWx0ZXIoZmxhZ3MsIGZpbHRlcikge1xuICAgIGNvbnN0IHAgPSB0aGlzO1xuICAgIGlmIChmbGFncyAmIEFERCkgcC5hZGRGID0gYWRkRmlsdGVyKHAuYWRkRiwgZmlsdGVyKTtcbiAgICBpZiAoZmxhZ3MgJiBSRU0pIHAucmVtRiA9IGFkZEZpbHRlcihwLnJlbUYsIGZpbHRlcik7XG4gICAgaWYgKGZsYWdzICYgTU9EKSBwLm1vZEYgPSBhZGRGaWx0ZXIocC5tb2RGLCBmaWx0ZXIpO1xuICAgIGlmIChmbGFncyAmIFNPVVJDRSkgcC5zcmNGID0gYWRkRmlsdGVyKHAuc3JjRiwgZmlsdGVyKTtcbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgLyoqXG4gICAqIE1hdGVyaWFsaXplIG9uZSBvciBtb3JlIHR1cGxlIHNldHMgaW4gdGhpcyBwdWxzZS4gSWYgdGhlIHR1cGxlIHNldChzKSBoYXZlXG4gICAqIGEgcmVnaXN0ZXJlZCBmaWx0ZXIgZnVuY3Rpb24sIGl0IHdpbGwgYmUgYXBwbGllZCBhbmQgdGhlIHR1cGxlIHNldChzKSB3aWxsXG4gICAqIGJlIHJlcGxhY2VkIHdpdGggbWF0ZXJpYWxpemVkIHR1cGxlIGFycmF5cy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgaW5kaWNhdGluZyB0aGUgdHVwbGUgc2V0KHMpIHRvIG1hdGVyaWFsaXplLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICBtYXRlcmlhbGl6ZShmbGFncykge1xuICAgIGZsYWdzID0gZmxhZ3MgfHwgQUxMO1xuICAgIGNvbnN0IHAgPSB0aGlzO1xuICAgIGlmIChmbGFncyAmIEFERCAmJiBwLmFkZEYpIHtcbiAgICAgIHAuYWRkID0gbWF0ZXJpYWxpemUocC5hZGQsIHAuYWRkRik7XG4gICAgICBwLmFkZEYgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoZmxhZ3MgJiBSRU0gJiYgcC5yZW1GKSB7XG4gICAgICBwLnJlbSA9IG1hdGVyaWFsaXplKHAucmVtLCBwLnJlbUYpO1xuICAgICAgcC5yZW1GID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGZsYWdzICYgTU9EICYmIHAubW9kRikge1xuICAgICAgcC5tb2QgPSBtYXRlcmlhbGl6ZShwLm1vZCwgcC5tb2RGKTtcbiAgICAgIHAubW9kRiA9IG51bGw7XG4gICAgfVxuICAgIGlmIChmbGFncyAmIFNPVVJDRSAmJiBwLnNyY0YpIHtcbiAgICAgIHAuc291cmNlID0gcC5zb3VyY2UuZmlsdGVyKHAuc3JjRik7XG4gICAgICBwLnNyY0YgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgLyoqXG4gICAqIFZpc2l0IG9uZSBvciBtb3JlIHR1cGxlIHNldHMgaW4gdGhpcyBwdWxzZS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZsYWdzIC0gRmxhZ3MgaW5kaWNhdGluZyB0aGUgdHVwbGUgc2V0KHMpIHRvIHZpc2l0LlxuICAgKiAgIExlZ2FsIHZhbHVlcyBhcmUgQURELCBSRU0sIE1PRCBhbmQgU09VUkNFIChpZiBhIGJhY2tpbmcgZGF0YSBzb3VyY2VcbiAgICogICBoYXMgYmVlbiBzZXQpLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6Kn0gLSBWaXNpdG9yIGZ1bmN0aW9uIGludm9rZWQgcGVyLXR1cGxlLlxuICAgKiBAcmV0dXJuIHtQdWxzZX0gLSBSZXR1cm5zIHRoaXMgcHVsc2UgaW5zdGFuY2UuXG4gICAqL1xuICB2aXNpdChmbGFncywgdmlzaXRvcikge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgdiA9IHZpc2l0b3I7XG4gICAgaWYgKGZsYWdzICYgU09VUkNFKSB7XG4gICAgICB2aXNpdEFycmF5KHAuc291cmNlLCBwLnNyY0YsIHYpO1xuICAgICAgcmV0dXJuIHA7XG4gICAgfVxuICAgIGlmIChmbGFncyAmIEFERCkgdmlzaXRBcnJheShwLmFkZCwgcC5hZGRGLCB2KTtcbiAgICBpZiAoZmxhZ3MgJiBSRU0pIHZpc2l0QXJyYXkocC5yZW0sIHAucmVtRiwgdik7XG4gICAgaWYgKGZsYWdzICYgTU9EKSB2aXNpdEFycmF5KHAubW9kLCBwLm1vZEYsIHYpO1xuICAgIGNvbnN0IHNyYyA9IHAuc291cmNlO1xuICAgIGlmIChmbGFncyAmIFJFRkxPVyAmJiBzcmMpIHtcbiAgICAgIGNvbnN0IHN1bSA9IHAuYWRkLmxlbmd0aCArIHAubW9kLmxlbmd0aDtcbiAgICAgIGlmIChzdW0gPT09IHNyYy5sZW5ndGgpIDsgZWxzZSBpZiAoc3VtKSB7XG4gICAgICAgIHZpc2l0QXJyYXkoc3JjLCBmaWx0ZXIocCwgQUREX01PRCksIHYpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgbm8gYWRkL3JlbS9tb2QgdHVwbGVzLCB2aXNpdCBzb3VyY2VcbiAgICAgICAgdmlzaXRBcnJheShzcmMsIHAuc3JjRiwgdik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG59O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYSBzZXQgb2YgbXVsdGlwbGUgcHVsc2VzLiBVc2VkIGFzIGlucHV0IGZvciBvcGVyYXRvcnNcbiAqIHRoYXQgYWNjZXB0IG11bHRpcGxlIHB1bHNlcyBhdCBhIHRpbWUuIENvbnRhaW5lZCBwdWxzZXMgYXJlXG4gKiBhY2Nlc3NpYmxlIHZpYSB0aGUgcHVibGljIFwicHVsc2VzXCIgYXJyYXkgcHJvcGVydHkuIFRoaXMgcHVsc2UgZG9lXG4gKiBub3QgY2FycnkgYWRkZWQsIHJlbW92ZWQgb3IgbW9kaWZpZWQgdHVwbGVzIGRpcmVjdGx5LiBIb3dldmVyLFxuICogdGhlIHZpc2l0IG1ldGhvZCBjYW4gYmUgdXNlZCB0byB0cmF2ZXJzZSBhbGwgc3VjaCB0dXBsZXMgY29udGFpbmVkXG4gKiBpbiBzdWItcHVsc2VzIHdpdGggYSB0aW1lc3RhbXAgbWF0Y2hpbmcgdGhpcyBwYXJlbnQgbXVsdGktcHVsc2UuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RGF0YWZsb3d9IGRhdGFmbG93IC0gVGhlIGJhY2tpbmcgZGF0YWZsb3cgaW5zdGFuY2UuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhbXAgLSBUaGUgdGltZXN0YW1wLlxuICogQHBhcmFtIHtBcnJheTxQdWxzZT59IHB1bHNlcyAtIFRoZSBzdWItcHVsc2VzIGZvciB0aGlzIG11bHRpLXB1bHNlLlxuICovXG5mdW5jdGlvbiBNdWx0aVB1bHNlKGRhdGFmbG93LCBzdGFtcCwgcHVsc2VzLCBlbmNvZGUpIHtcbiAgY29uc3QgcCA9IHRoaXM7XG4gIGxldCBjID0gMDtcbiAgdGhpcy5kYXRhZmxvdyA9IGRhdGFmbG93O1xuICB0aGlzLnN0YW1wID0gc3RhbXA7XG4gIHRoaXMuZmllbGRzID0gbnVsbDtcbiAgdGhpcy5lbmNvZGUgPSBlbmNvZGUgfHwgbnVsbDtcbiAgdGhpcy5wdWxzZXMgPSBwdWxzZXM7XG4gIGZvciAoY29uc3QgcHVsc2Ugb2YgcHVsc2VzKSB7XG4gICAgaWYgKHB1bHNlLnN0YW1wICE9PSBzdGFtcCkgY29udGludWU7XG4gICAgaWYgKHB1bHNlLmZpZWxkcykge1xuICAgICAgY29uc3QgaGFzaCA9IHAuZmllbGRzIHx8IChwLmZpZWxkcyA9IHt9KTtcbiAgICAgIGZvciAoY29uc3QgZiBpbiBwdWxzZS5maWVsZHMpIHtcbiAgICAgICAgaGFzaFtmXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHAuQUREKSkgYyB8PSBwLkFERDtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwLlJFTSkpIGMgfD0gcC5SRU07XG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocC5NT0QpKSBjIHw9IHAuTU9EO1xuICB9XG4gIHRoaXMuY2hhbmdlcyA9IGM7XG59XG5pbmhlcml0cyhNdWx0aVB1bHNlLCBQdWxzZSwge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBwdWxzZSBiYXNlZCBvbiB0aGUgdmFsdWVzIG9mIHRoaXMgcHVsc2UuXG4gICAqIFRoZSBkYXRhZmxvdywgdGltZSBzdGFtcCBhbmQgZmllbGQgbW9kaWZpY2F0aW9uIHZhbHVlcyBhcmUgY29waWVkIG92ZXIuXG4gICAqIEByZXR1cm4ge1B1bHNlfVxuICAgKi9cbiAgZm9yayhmbGFncykge1xuICAgIGNvbnN0IHAgPSBuZXcgUHVsc2UodGhpcy5kYXRhZmxvdykuaW5pdCh0aGlzLCBmbGFncyAmIHRoaXMuTk9fRklFTERTKTtcbiAgICBpZiAoZmxhZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKGZsYWdzICYgcC5BREQpIHRoaXMudmlzaXQocC5BREQsIHQgPT4gcC5hZGQucHVzaCh0KSk7XG4gICAgICBpZiAoZmxhZ3MgJiBwLlJFTSkgdGhpcy52aXNpdChwLlJFTSwgdCA9PiBwLnJlbS5wdXNoKHQpKTtcbiAgICAgIGlmIChmbGFncyAmIHAuTU9EKSB0aGlzLnZpc2l0KHAuTU9ELCB0ID0+IHAubW9kLnB1c2godCkpO1xuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfSxcbiAgY2hhbmdlZChmbGFncykge1xuICAgIHJldHVybiB0aGlzLmNoYW5nZXMgJiBmbGFncztcbiAgfSxcbiAgbW9kaWZpZWQoXykge1xuICAgIGNvbnN0IHAgPSB0aGlzLFxuICAgICAgZmllbGRzID0gcC5maWVsZHM7XG4gICAgcmV0dXJuICEoZmllbGRzICYmIHAuY2hhbmdlcyAmIHAuTU9EKSA/IDAgOiBpc0FycmF5KF8pID8gXy5zb21lKGYgPT4gZmllbGRzW2ZdKSA6IGZpZWxkc1tfXTtcbiAgfSxcbiAgZmlsdGVyKCkge1xuICAgIGVycm9yKCdNdWx0aVB1bHNlIGRvZXMgbm90IHN1cHBvcnQgZmlsdGVyaW5nLicpO1xuICB9LFxuICBtYXRlcmlhbGl6ZSgpIHtcbiAgICBlcnJvcignTXVsdGlQdWxzZSBkb2VzIG5vdCBzdXBwb3J0IG1hdGVyaWFsaXphdGlvbi4nKTtcbiAgfSxcbiAgdmlzaXQoZmxhZ3MsIHZpc2l0b3IpIHtcbiAgICBjb25zdCBwID0gdGhpcyxcbiAgICAgIHB1bHNlcyA9IHAucHVsc2VzLFxuICAgICAgbiA9IHB1bHNlcy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGlmIChmbGFncyAmIHAuU09VUkNFKSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBwdWxzZXNbaV0udmlzaXQoZmxhZ3MsIHZpc2l0b3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpZiAocHVsc2VzW2ldLnN0YW1wID09PSBwLnN0YW1wKSB7XG4gICAgICAgICAgcHVsc2VzW2ldLnZpc2l0KGZsYWdzLCB2aXNpdG9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxufSk7XG5cbi8qIGVzbGludC1kaXNhYmxlIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXMgKi9cblxuLyoqXG4gKiBFdmFsdWF0ZXMgdGhlIGRhdGFmbG93IGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcHVsc2VcbiAqIHByb3BhZ2F0aW9uIGNvbXBsZXRlcy4gVGhpcyBtZXRob2Qgd2lsbCBpbmNyZW1lbnQgdGhlIGN1cnJlbnQgdGltZXN0YW1wXG4gKiBhbmQgcHJvY2VzcyBhbGwgdXBkYXRlZCwgcHVsc2VkIGFuZCB0b3VjaGVkIG9wZXJhdG9ycy4gV2hlbiBpbnZva2VkIGZvclxuICogdGhlIGZpcnN0IHRpbWUsIGFsbCByZWdpc3RlcmVkIG9wZXJhdG9ycyB3aWxsIGJlIHByb2Nlc3NlZC4gVGhpcyBtZXRob2RcbiAqIHNob3VsZCBub3QgYmUgaW52b2tlZCBieSB0aGlyZC1wYXJ0eSBjbGllbnRzLCB1c2Uge0BsaW5rIHJ1bkFzeW5jfSBvclxuICoge0BsaW5rIHJ1bn0gaW5zdGVhZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIFRoZSBuYW1lIG9mIGFuIGVuY29kaW5nIHNldCB0byBpbnZva2UgZHVyaW5nXG4gKiAgIHByb3BhZ2F0aW9uLiBUaGlzIHZhbHVlIGlzIGFkZGVkIHRvIGdlbmVyYXRlZCBQdWxzZSBpbnN0YW5jZXM7XG4gKiAgIG9wZXJhdG9ycyBjYW4gdGhlbiByZXNwb25kIHRvIChvciBpZ25vcmUpIHRoaXMgc2V0dGluZyBhcyBhcHByb3ByaWF0ZS5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgRW5jb2RlIHRyYW5zZm9ybSBpblxuICogICB0aGUgdmVnYS1lbmNvZGUgcGFja2FnZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcmVydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGltbWVkaWF0ZWx5IGJlZm9yZSBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbW1lbmNlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwb3N0cnVuXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBhZnRlciBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbXBsZXRlcy4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogICBhZnRlciB0aG9zZSByZWdpc3RlcmVkIHZpYSB7QGxpbmsgcnVuQWZ0ZXJ9LlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGlzIGRhdGFmbG93IGFmdGVyXG4gKiAgIGV2YWx1YXRpb24gY29tcGxldGVzLlxuICovXG5hc3luYyBmdW5jdGlvbiBldmFsdWF0ZShlbmNvZGUsIHByZXJ1biwgcG9zdHJ1bikge1xuICBjb25zdCBkZiA9IHRoaXMsXG4gICAgYXN5bmMgPSBbXTtcblxuICAvLyBpZiB0aGUgcHVsc2UgdmFsdWUgaXMgc2V0LCB0aGlzIGlzIGEgcmUtZW50cmFudCBjYWxsXG4gIGlmIChkZi5fcHVsc2UpIHJldHVybiByZWVudHJhbnQoZGYpO1xuXG4gIC8vIHdhaXQgZm9yIHBlbmRpbmcgZGF0YXNldHMgdG8gbG9hZFxuICBpZiAoZGYuX3BlbmRpbmcpIGF3YWl0IGRmLl9wZW5kaW5nO1xuXG4gIC8vIGludm9rZSBwcmVydW4gZnVuY3Rpb24sIGlmIHByb3ZpZGVkXG4gIGlmIChwcmVydW4pIGF3YWl0IGFzeW5jQ2FsbGJhY2soZGYsIHByZXJ1bik7XG5cbiAgLy8gZXhpdCBlYXJseSBpZiB0aGVyZSBhcmUgbm8gdXBkYXRlc1xuICBpZiAoIWRmLl90b3VjaGVkLmxlbmd0aCkge1xuICAgIGRmLmRlYnVnKCdEYXRhZmxvdyBpbnZva2VkLCBidXQgbm90aGluZyB0byBkby4nKTtcbiAgICByZXR1cm4gZGY7XG4gIH1cblxuICAvLyBpbmNyZW1lbnQgdGltZXN0YW1wIGNsb2NrXG4gIGNvbnN0IHN0YW1wID0gKytkZi5fY2xvY2s7XG5cbiAgLy8gc2V0IHRoZSBjdXJyZW50IHB1bHNlXG4gIGRmLl9wdWxzZSA9IG5ldyBQdWxzZShkZiwgc3RhbXAsIGVuY29kZSk7XG5cbiAgLy8gaW5pdGlhbGl6ZSBwcmlvcml0eSBxdWV1ZSwgcmVzZXQgdG91Y2hlZCBvcGVyYXRvcnNcbiAgZGYuX3RvdWNoZWQuZm9yRWFjaChvcCA9PiBkZi5fZW5xdWV1ZShvcCwgdHJ1ZSkpO1xuICBkZi5fdG91Y2hlZCA9IFVuaXF1ZUxpc3QoaWQpO1xuICBsZXQgY291bnQgPSAwLFxuICAgIG9wLFxuICAgIG5leHQsXG4gICAgZXJyb3I7XG4gIHRyeSB7XG4gICAgd2hpbGUgKGRmLl9oZWFwLnNpemUoKSA+IDApIHtcbiAgICAgIC8vIGRlcXVldWUgb3BlcmF0b3Igd2l0aCBoaWdoZXN0IHByaW9yaXR5XG4gICAgICBvcCA9IGRmLl9oZWFwLnBvcCgpO1xuXG4gICAgICAvLyByZS1xdWV1ZSBpZiByYW5rIGNoYW5nZWRcbiAgICAgIGlmIChvcC5yYW5rICE9PSBvcC5xcmFuaykge1xuICAgICAgICBkZi5fZW5xdWV1ZShvcCwgdHJ1ZSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBvdGhlcndpc2UsIGV2YWx1YXRlIHRoZSBvcGVyYXRvclxuICAgICAgbmV4dCA9IG9wLnJ1bihkZi5fZ2V0UHVsc2Uob3AsIGVuY29kZSkpO1xuICAgICAgaWYgKG5leHQudGhlbikge1xuICAgICAgICAvLyBhd2FpdCBpZiBvcGVyYXRvciByZXR1cm5zIGEgcHJvbWlzZSBkaXJlY3RseVxuICAgICAgICBuZXh0ID0gYXdhaXQgbmV4dDtcbiAgICAgIH0gZWxzZSBpZiAobmV4dC5hc3luYykge1xuICAgICAgICAvLyBxdWV1ZSBwYXJhbGxlbCBhc3luY2hyb25vdXMgZXhlY3V0aW9uXG4gICAgICAgIGFzeW5jLnB1c2gobmV4dC5hc3luYyk7XG4gICAgICAgIG5leHQgPSBTdG9wUHJvcGFnYXRpb247XG4gICAgICB9XG5cbiAgICAgIC8vIHByb3BhZ2F0ZSBldmFsdWF0aW9uLCBlbnF1ZXVlIGRlcGVuZGVudCBvcGVyYXRvcnNcbiAgICAgIGlmIChuZXh0ICE9PSBTdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgICAgaWYgKG9wLl90YXJnZXRzKSBvcC5fdGFyZ2V0cy5mb3JFYWNoKG9wID0+IGRmLl9lbnF1ZXVlKG9wKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGluY3JlbWVudCB2aXNpdCBjb3VudGVyXG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZGYuX2hlYXAuY2xlYXIoKTtcbiAgICBlcnJvciA9IGVycjtcbiAgfVxuXG4gIC8vIHJlc2V0IHB1bHNlIG1hcFxuICBkZi5faW5wdXQgPSB7fTtcbiAgZGYuX3B1bHNlID0gbnVsbDtcbiAgZGYuZGVidWcoYFB1bHNlICR7c3RhbXB9OiAke2NvdW50fSBvcGVyYXRvcnNgKTtcbiAgaWYgKGVycm9yKSB7XG4gICAgZGYuX3Bvc3RydW4gPSBbXTtcbiAgICBkZi5lcnJvcihlcnJvcik7XG4gIH1cblxuICAvLyBpbnZva2UgY2FsbGJhY2tzIHF1ZXVlZCB2aWEgcnVuQWZ0ZXJcbiAgaWYgKGRmLl9wb3N0cnVuLmxlbmd0aCkge1xuICAgIGNvbnN0IHByID0gZGYuX3Bvc3RydW4uc29ydCgoYSwgYikgPT4gYi5wcmlvcml0eSAtIGEucHJpb3JpdHkpO1xuICAgIGRmLl9wb3N0cnVuID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwci5sZW5ndGg7ICsraSkge1xuICAgICAgYXdhaXQgYXN5bmNDYWxsYmFjayhkZiwgcHJbaV0uY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8vIGludm9rZSBwb3N0cnVuIGZ1bmN0aW9uLCBpZiBwcm92aWRlZFxuICBpZiAocG9zdHJ1bikgYXdhaXQgYXN5bmNDYWxsYmFjayhkZiwgcG9zdHJ1bik7XG5cbiAgLy8gaGFuZGxlIG5vbi1ibG9ja2luZyBhc3luY2hyb25vdXMgY2FsbGJhY2tzXG4gIGlmIChhc3luYy5sZW5ndGgpIHtcbiAgICBQcm9taXNlLmFsbChhc3luYykudGhlbihjYiA9PiBkZi5ydW5Bc3luYyhudWxsLCAoKSA9PiB7XG4gICAgICBjYi5mb3JFYWNoKGYgPT4ge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGYoZGYpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICBkZi5lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KSk7XG4gIH1cbiAgcmV0dXJuIGRmO1xufVxuXG4vKipcbiAqIFF1ZXVlcyBkYXRhZmxvdyBldmFsdWF0aW9uIHRvIHJ1biBvbmNlIGFueSBvdGhlciBxdWV1ZWQgZXZhbHVhdGlvbnMgaGF2ZVxuICogY29tcGxldGVkIGFuZCByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIHF1ZXVlZCBwdWxzZVxuICogcHJvcGFnYXRpb24gY29tcGxldGVzLiBJZiBwcm92aWRlZCwgYSBjYWxsYmFjayBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWRcbiAqIGltbWVkaWF0ZWx5IGJlZm9yZSBldmFsdWF0aW9uIGNvbW1lbmNlcy4gVGhpcyBtZXRob2Qgd2lsbCBlbnN1cmUgYVxuICogc2VwYXJhdGUgZXZhbHVhdGlvbiBpcyBpbnZva2VkIGZvciBlYWNoIHRpbWUgaXQgaXMgY2FsbGVkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtlbmNvZGVdIC0gVGhlIG5hbWUgb2YgYW4gZW5jb2Rpbmcgc2V0IHRvIGludm9rZSBkdXJpbmdcbiAqICAgcHJvcGFnYXRpb24uIFRoaXMgdmFsdWUgaXMgYWRkZWQgdG8gZ2VuZXJhdGVkIFB1bHNlIGluc3RhbmNlcztcbiAqICAgb3BlcmF0b3JzIGNhbiB0aGVuIHJlc3BvbmQgdG8gKG9yIGlnbm9yZSkgdGhpcyBzZXR0aW5nIGFzIGFwcHJvcHJpYXRlLlxuICogICBUaGlzIHBhcmFtZXRlciBjYW4gYmUgdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIHRoZSBFbmNvZGUgdHJhbnNmb3JtIGluXG4gKiAgIHRoZSB2ZWdhLWVuY29kZSBwYWNrYWdlLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3ByZXJ1bl0gLSBBbiBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBpbnZva2VcbiAqICAgaW1tZWRpYXRlbHkgYmVmb3JlIGRhdGFmbG93IGV2YWx1YXRpb24gY29tbWVuY2VzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gW3Bvc3RydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGFmdGVyIGRhdGFmbG93IGV2YWx1YXRpb24gY29tcGxldGVzLiBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkXG4gKiAgIGFmdGVyIHRob3NlIHJlZ2lzdGVyZWQgdmlhIHtAbGluayBydW5BZnRlcn0uXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoaXMgZGF0YWZsb3cgYWZ0ZXJcbiAqICAgZXZhbHVhdGlvbiBjb21wbGV0ZXMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJ1bkFzeW5jKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSB7XG4gIC8vIGF3YWl0IHByZXZpb3VzbHkgcXVldWVkIGZ1bmN0aW9uc1xuICB3aGlsZSAodGhpcy5fcnVubmluZykgYXdhaXQgdGhpcy5fcnVubmluZztcblxuICAvLyBydW4gZGF0YWZsb3csIG1hbmFnZSBydW5uaW5nIHByb21pc2VcbiAgY29uc3QgY2xlYXIgPSAoKSA9PiB0aGlzLl9ydW5uaW5nID0gbnVsbDtcbiAgKHRoaXMuX3J1bm5pbmcgPSB0aGlzLmV2YWx1YXRlKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSkudGhlbihjbGVhciwgY2xlYXIpO1xuICByZXR1cm4gdGhpcy5fcnVubmluZztcbn1cblxuLyoqXG4gKiBSZXF1ZXN0cyBkYXRhZmxvdyBldmFsdWF0aW9uIGFuZCB0aGUgaW1tZWRpYXRlbHkgcmV0dXJucyB0aGlzIGRhdGFmbG93XG4gKiBpbnN0YW5jZS4gSWYgdGhlcmUgYXJlIHBlbmRpbmcgZGF0YSBsb2FkaW5nIG9yIG90aGVyIGFzeW5jaHJvbm91c1xuICogb3BlcmF0aW9ucywgdGhlIGRhdGFmbG93IHdpbGwgZXZhbHVhdGUgYXN5bmNocm9ub3VzbHkgYWZ0ZXIgdGhpcyBtZXRob2RcbiAqIGhhcyBiZWVuIGludm9rZWQuIFRvIHRyYWNrIHdoZW4gZGF0YWZsb3cgZXZhbHVhdGlvbiBjb21wbGV0ZXMsIHVzZSB0aGVcbiAqIHtAbGluayBydW5Bc3luY30gbWV0aG9kIGluc3RlYWQuIFRoaXMgbWV0aG9kIHdpbGwgcmFpc2UgYW4gZXJyb3IgaWZcbiAqIGludm9rZWQgd2hpbGUgdGhlIGRhdGFmbG93IGlzIGFscmVhZHkgaW4gdGhlIG1pZHN0IG9mIGV2YWx1YXRpb24uXG4gKiBAcGFyYW0ge3N0cmluZ30gW2VuY29kZV0gLSBUaGUgbmFtZSBvZiBhbiBlbmNvZGluZyBzZXQgdG8gaW52b2tlIGR1cmluZ1xuICogICBwcm9wYWdhdGlvbi4gVGhpcyB2YWx1ZSBpcyBhZGRlZCB0byBnZW5lcmF0ZWQgUHVsc2UgaW5zdGFuY2VzO1xuICogICBvcGVyYXRvcnMgY2FuIHRoZW4gcmVzcG9uZCB0byAob3IgaWdub3JlKSB0aGlzIHNldHRpbmcgYXMgYXBwcm9wcmlhdGUuXG4gKiAgIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSB1c2VkIGluIGNvbmp1bmN0aW9uIHdpdGggdGhlIEVuY29kZSB0cmFuc2Zvcm0gaW5cbiAqICAgdGhlIHZlZ2EtZW5jb2RlIG1vZHVsZS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwcmVydW5dIC0gQW4gb3B0aW9uYWwgY2FsbGJhY2sgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiAgIGltbWVkaWF0ZWx5IGJlZm9yZSBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbW1lbmNlcy5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IFtwb3N0cnVuXSAtIEFuIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGludm9rZVxuICogICBhZnRlciBkYXRhZmxvdyBldmFsdWF0aW9uIGNvbXBsZXRlcy4gVGhlIGNhbGxiYWNrIHdpbGwgYmUgaW52b2tlZFxuICogICBhZnRlciB0aG9zZSByZWdpc3RlcmVkIHZpYSB7QGxpbmsgcnVuQWZ0ZXJ9LlxuICogQHJldHVybiB7RGF0YWZsb3d9IC0gVGhpcyBkYXRhZmxvdyBpbnN0YW5jZS5cbiAqL1xuZnVuY3Rpb24gcnVuKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSB7XG4gIHJldHVybiB0aGlzLl9wdWxzZSA/IHJlZW50cmFudCh0aGlzKSA6ICh0aGlzLmV2YWx1YXRlKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSwgdGhpcyk7XG59XG5cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciB0aGUgY3VycmVudCBwdWxzZVxuICogcHJvcGFnYXRpb24gY29tcGxldGVzLiBJZiBubyBwcm9wYWdhdGlvbiBpcyBjdXJyZW50bHkgb2NjdXJyaW5nLFxuICogdGhlIGZ1bmN0aW9uIGlzIGludm9rZWQgaW1tZWRpYXRlbHkuIENhbGxiYWNrcyBzY2hlZHVsZWQgdmlhIHJ1bkFmdGVyXG4gKiBhcmUgaW52b2tlZCBpbW1lZGlhdGVseSB1cG9uIGNvbXBsZXRpb24gb2YgdGhlIGN1cnJlbnQgY3ljbGUsIGJlZm9yZVxuICogYW55IHJlcXVlc3QgcXVldWVkIHZpYSBydW5Bc3luYy4gVGhpcyBtZXRob2QgaXMgcHJpbWFyaWx5IGludGVuZGVkIGZvclxuICogaW50ZXJuYWwgdXNlLiBUaGlyZC1wYXJ0eSBjYWxsZXJzIHVzaW5nIHJ1bkFmdGVyIHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAqIHRoYXQgaW52b2tlcyB7QGxpbmsgcnVufSBvciB7QGxpbmsgcnVuQXN5bmN9IHNob3VsZCBub3QgdXNlIHRoaXMgbWV0aG9kLFxuICogYnV0IGluc3RlYWQgdXNlIHtAbGluayBydW5Bc3luY30gd2l0aCBwcmVydW4gb3IgcG9zdHJ1biBhcmd1bWVudHMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFmbG93KX0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gdG8gcnVuLlxuICogICBUaGUgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdpdGggdGhpcyBEYXRhZmxvdyBpbnN0YW5jZSBhcyBpdHNcbiAqICAgc29sZSBhcmd1bWVudC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5xdWV1ZSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgdGhhdCB0aGVcbiAqICAgY2FsbGJhY2sgc2hvdWxkIGJlIHF1ZXVlZCB1cCB0byBydW4gYWZ0ZXIgdGhlIG5leHQgcHJvcGFnYXRpb25cbiAqICAgY3ljbGUsIHN1cHByZXNzaW5nIGltbWVkaWF0ZSBpbnZvY2F0aW9uIHdoZW4gcHJvcGFnYXRpb24gaXMgbm90XG4gKiAgIGN1cnJlbnRseSBvY2N1cnJpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gW3ByaW9yaXR5XSAtIEEgcHJpb3JpdHkgdmFsdWUgdXNlZCB0byBzb3J0IHJlZ2lzdGVyZWRcbiAqICAgY2FsbGJhY2tzIHRvIGRldGVybWluZSBleGVjdXRpb24gb3JkZXIuIFRoaXMgYXJndW1lbnQgaXMgaW50ZW5kZWRcbiAqICAgZm9yIGludGVybmFsIFZlZ2EgdXNlIG9ubHkuXG4gKi9cbmZ1bmN0aW9uIHJ1bkFmdGVyKGNhbGxiYWNrLCBlbnF1ZXVlLCBwcmlvcml0eSkge1xuICBpZiAodGhpcy5fcHVsc2UgfHwgZW5xdWV1ZSkge1xuICAgIC8vIHB1bHNlIHByb3BhZ2F0aW9uIGlzIGN1cnJlbnRseSBydW5uaW5nLCBxdWV1ZSB0byBydW4gYWZ0ZXJcbiAgICB0aGlzLl9wb3N0cnVuLnB1c2goe1xuICAgICAgcHJpb3JpdHk6IHByaW9yaXR5IHx8IDAsXG4gICAgICBjYWxsYmFjazogY2FsbGJhY2tcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBwdWxzZSBwcm9wYWdhdGlvbiBhbHJlYWR5IGNvbXBsZXRlLCBpbnZva2UgaW1tZWRpYXRlbHlcbiAgICB0cnkge1xuICAgICAgY2FsbGJhY2sodGhpcyk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aGlzLmVycm9yKGVycik7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUmFpc2UgYW4gZXJyb3IgZm9yIHJlLWVudHJhbnQgZGF0YWZsb3cgZXZhbHVhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcmVlbnRyYW50KGRmKSB7XG4gIGRmLmVycm9yKCdEYXRhZmxvdyBhbHJlYWR5IHJ1bm5pbmcuIFVzZSBydW5Bc3luYygpIHRvIGNoYWluIGludm9jYXRpb25zLicpO1xuICByZXR1cm4gZGY7XG59XG5cbi8qKlxuICogRW5xdWV1ZSBhbiBvcGVyYXRvciBpbnRvIHRoZSBwcmlvcml0eSBxdWV1ZSBmb3IgZXZhbHVhdGlvbi4gVGhlIG9wZXJhdG9yXG4gKiB3aWxsIGJlIGVucXVldWVkIGlmIGl0IGhhcyBubyByZWdpc3RlcmVkIHB1bHNlIGZvciB0aGUgY3VycmVudCBjeWNsZSwgb3IgaWZcbiAqIHRoZSBmb3JjZSBhcmd1bWVudCBpcyB0cnVlLiBVcG9uIGVucXVldWUsIHRoaXMgbWV0aG9kIGFsc28gc2V0cyB0aGVcbiAqIG9wZXJhdG9yJ3MgcXJhbmsgdG8gdGhlIGN1cnJlbnQgcmFuayB2YWx1ZS5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIGVucXVldWUuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgb3BlcmF0b3Igc2hvdWxkIGJlXG4gKiAgIGZvcmNlYWJseSBhZGRlZCB0byB0aGUgcXVldWUsIGV2ZW4gaWYgaXQgaGFzIGFscmVhZHkgYmVlbiBwcmV2aW91c2x5XG4gKiAgIGVucXVldWVkIGR1cmluZyB0aGUgY3VycmVudCBwdWxzZSBwcm9wYWdhdGlvbi4gVGhpcyBpcyB1c2VmdWwgd2hlbiB0aGVcbiAqICAgZGF0YWZsb3cgZ3JhcGggaXMgZHluYW1pY2FsbHkgbW9kaWZpZWQgYW5kIHRoZSBvcGVyYXRvciByYW5rIGNoYW5nZXMuXG4gKi9cbmZ1bmN0aW9uIGVucXVldWUob3AsIGZvcmNlKSB7XG4gIGNvbnN0IHEgPSBvcC5zdGFtcCA8IHRoaXMuX2Nsb2NrO1xuICBpZiAocSkgb3Auc3RhbXAgPSB0aGlzLl9jbG9jaztcbiAgaWYgKHEgfHwgZm9yY2UpIHtcbiAgICBvcC5xcmFuayA9IG9wLnJhbms7XG4gICAgdGhpcy5faGVhcC5wdXNoKG9wKTtcbiAgfVxufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBjb3JyZWN0IHB1bHNlIGZvciBldmFsdWF0aW5nIGFuIG9wZXJhdG9yLiBJZiB0aGUgb3BlcmF0b3IgaGFzIGFuXG4gKiBleHBsaWNpdCBzb3VyY2Ugb3BlcmF0b3IsIHdlIHdpbGwgdHJ5IHRvIHB1bGwgdGhlIHB1bHNlKHMpIGZyb20gaXQuXG4gKiBJZiB0aGVyZSBpcyBhbiBhcnJheSBvZiBzb3VyY2Ugb3BlcmF0b3JzLCB3ZSBidWlsZCBhIG11bHRpLXB1bHNlLlxuICogT3RoZXJ3aXNlLCB3ZSByZXR1cm4gYSBjdXJyZW50IHB1bHNlIHdpdGggY29ycmVjdCBzb3VyY2UgZGF0YS5cbiAqIElmIHRoZSBwdWxzZSBpcyB0aGUgcHVsc2UgbWFwIGhhcyBhbiBleHBsaWNpdCB0YXJnZXQgc2V0LCB3ZSB1c2UgdGhhdC5cbiAqIEVsc2UgaWYgdGhlIHB1bHNlIG9uIHRoZSB1cHN0cmVhbSBzb3VyY2Ugb3BlcmF0b3IgaXMgY3VycmVudCwgd2UgdXNlIHRoYXQuXG4gKiBFbHNlIHdlIHVzZSB0aGUgcHVsc2UgZnJvbSB0aGUgcHVsc2UgbWFwLCBidXQgY29weSB0aGUgc291cmNlIHR1cGxlIGFycmF5LlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgZm9yIHdoaWNoIHRvIGdldCBhbiBpbnB1dCBwdWxzZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbZW5jb2RlXSAtIEFuIChvcHRpb25hbCkgZW5jb2Rpbmcgc2V0IG5hbWUgd2l0aCB3aGljaCB0b1xuICogICBhbm5vdGF0ZSB0aGUgcmV0dXJuZWQgcHVsc2UuIFNlZSB7QGxpbmsgcnVufSBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0UHVsc2Uob3AsIGVuY29kZSkge1xuICBjb25zdCBzID0gb3Auc291cmNlLFxuICAgIHN0YW1wID0gdGhpcy5fY2xvY2s7XG4gIHJldHVybiBzICYmIGlzQXJyYXkocykgPyBuZXcgTXVsdGlQdWxzZSh0aGlzLCBzdGFtcCwgcy5tYXAoXyA9PiBfLnB1bHNlKSwgZW5jb2RlKSA6IHRoaXMuX2lucHV0W29wLmlkXSB8fCBzaW5nbGVQdWxzZSh0aGlzLl9wdWxzZSwgcyAmJiBzLnB1bHNlKTtcbn1cbmZ1bmN0aW9uIHNpbmdsZVB1bHNlKHAsIHMpIHtcbiAgaWYgKHMgJiYgcy5zdGFtcCA9PT0gcC5zdGFtcCkge1xuICAgIHJldHVybiBzO1xuICB9XG4gIHAgPSBwLmZvcmsoKTtcbiAgaWYgKHMgJiYgcyAhPT0gU3RvcFByb3BhZ2F0aW9uKSB7XG4gICAgcC5zb3VyY2UgPSBzLnNvdXJjZTtcbiAgfVxuICByZXR1cm4gcDtcbn1cblxuY29uc3QgTk9fT1BUID0ge1xuICBza2lwOiBmYWxzZSxcbiAgZm9yY2U6IGZhbHNlXG59O1xuXG4vKipcbiAqIFRvdWNoZXMgYW4gb3BlcmF0b3IsIHNjaGVkdWxpbmcgaXQgdG8gYmUgZXZhbHVhdGVkLiBJZiBpbnZva2VkIG91dHNpZGUgb2ZcbiAqIGEgcHVsc2UgcHJvcGFnYXRpb24sIHRoZSBvcGVyYXRvciB3aWxsIGJlIGV2YWx1YXRlZCB0aGUgbmV4dCB0aW1lIHRoaXNcbiAqIGRhdGFmbG93IGlzIHJ1bi4gSWYgaW52b2tlZCBpbiB0aGUgbWlkc3Qgb2YgcHVsc2UgcHJvcGFnYXRpb24sIHRoZSBvcGVyYXRvclxuICogd2lsbCBiZSBxdWV1ZWQgZm9yIGV2YWx1YXRpb24gaWYgYW5kIG9ubHkgaWYgdGhlIG9wZXJhdG9yIGhhcyBub3QgeWV0IGJlZW5cbiAqIGV2YWx1YXRlZCBvbiB0aGUgY3VycmVudCBwcm9wYWdhdGlvbiB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge09wZXJhdG9yfSBvcCAtIFRoZSBvcGVyYXRvciB0byB0b3VjaC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc10gLSBBZGRpdGlvbmFsIG9wdGlvbnMgaGFzaC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuc2tpcF0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSBza2lwcGVkOiBpdCB3aWxsIG5vdCBiZSBldmFsdWF0ZWQsIGJ1dCBpdHMgZGVwZW5kZW50cyB3aWxsIGJlLlxuICogQHJldHVybiB7RGF0YWZsb3d9XG4gKi9cbmZ1bmN0aW9uIHRvdWNoKG9wLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdCA9IG9wdGlvbnMgfHwgTk9fT1BUO1xuICBpZiAodGhpcy5fcHVsc2UpIHtcbiAgICAvLyBpZiBpbiBtaWRzdCBvZiBwcm9wYWdhdGlvbiwgYWRkIHRvIHByaW9yaXR5IHF1ZXVlXG4gICAgdGhpcy5fZW5xdWV1ZShvcCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlLCBxdWV1ZSBmb3IgbmV4dCBwcm9wYWdhdGlvblxuICAgIHRoaXMuX3RvdWNoZWQuYWRkKG9wKTtcbiAgfVxuICBpZiAob3B0LnNraXApIG9wLnNraXAodHJ1ZSk7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBvcGVyYXRvci5cbiAqIEBwYXJhbSB7T3BlcmF0b3J9IG9wIC0gVGhlIG9wZXJhdG9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgLSBUaGUgdmFsdWUgdG8gc2V0LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5mb3JjZV0gLSBJZiB0cnVlLCB0aGUgb3BlcmF0b3Igd2lsbFxuICogICBiZSByZS1ldmFsdWF0ZWQgZXZlbiBpZiBpdHMgdmFsdWUgaGFzIG5vdCBjaGFuZ2VkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuZnVuY3Rpb24gdXBkYXRlKG9wLCB2YWx1ZSwgb3B0aW9ucykge1xuICBjb25zdCBvcHQgPSBvcHRpb25zIHx8IE5PX09QVDtcbiAgaWYgKG9wLnNldCh2YWx1ZSkgfHwgb3B0LmZvcmNlKSB7XG4gICAgdGhpcy50b3VjaChvcCwgb3B0KTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuLyoqXG4gKiBQdWxzZXMgYW4gb3BlcmF0b3Igd2l0aCBhIGNoYW5nZXNldCBvZiB0dXBsZXMuIElmIGludm9rZWQgb3V0c2lkZSBvZlxuICogYSBwdWxzZSBwcm9wYWdhdGlvbiwgdGhlIHB1bHNlIHdpbGwgYmUgYXBwbGllZCB0aGUgbmV4dCB0aW1lIHRoaXNcbiAqIGRhdGFmbG93IGlzIHJ1bi4gSWYgaW52b2tlZCBpbiB0aGUgbWlkc3Qgb2YgcHVsc2UgcHJvcGFnYXRpb24sIHRoZSBwdWxzZVxuICogd2lsbCBiZSBhZGRlZCB0byB0aGUgc2V0IG9mIGFjdGl2ZSBwdWxzZXMgYW5kIHdpbGwgYmUgYXBwbGllZCBpZiBhbmRcbiAqIG9ubHkgaWYgdGhlIHRhcmdldCBvcGVyYXRvciBoYXMgbm90IHlldCBiZWVuIGV2YWx1YXRlZCBvbiB0aGUgY3VycmVudFxuICogcHJvcGFnYXRpb24gdGltZXN0YW1wLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gb3AgLSBUaGUgb3BlcmF0b3IgdG8gcHVsc2UuXG4gKiBAcGFyYW0ge0NoYW5nZVNldH0gdmFsdWUgLSBUaGUgdHVwbGUgY2hhbmdlc2V0IHRvIGFwcGx5LlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIEFkZGl0aW9uYWwgb3B0aW9ucyBoYXNoLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5za2lwXSAtIElmIHRydWUsIHRoZSBvcGVyYXRvciB3aWxsXG4gKiAgIGJlIHNraXBwZWQ6IGl0IHdpbGwgbm90IGJlIGV2YWx1YXRlZCwgYnV0IGl0cyBkZXBlbmRlbnRzIHdpbGwgYmUuXG4gKiBAcmV0dXJuIHtEYXRhZmxvd31cbiAqL1xuZnVuY3Rpb24gcHVsc2Uob3AsIGNoYW5nZXNldCwgb3B0aW9ucykge1xuICB0aGlzLnRvdWNoKG9wLCBvcHRpb25zIHx8IE5PX09QVCk7XG4gIGNvbnN0IHAgPSBuZXcgUHVsc2UodGhpcywgdGhpcy5fY2xvY2sgKyAodGhpcy5fcHVsc2UgPyAwIDogMSkpLFxuICAgIHQgPSBvcC5wdWxzZSAmJiBvcC5wdWxzZS5zb3VyY2UgfHwgW107XG4gIHAudGFyZ2V0ID0gb3A7XG4gIHRoaXMuX2lucHV0W29wLmlkXSA9IGNoYW5nZXNldC5wdWxzZShwLCB0KTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIEhlYXAoY21wKSB7XG4gIGxldCBub2RlcyA9IFtdO1xuICByZXR1cm4ge1xuICAgIGNsZWFyOiAoKSA9PiBub2RlcyA9IFtdLFxuICAgIHNpemU6ICgpID0+IG5vZGVzLmxlbmd0aCxcbiAgICBwZWVrOiAoKSA9PiBub2Rlc1swXSxcbiAgICBwdXNoOiB4ID0+IHtcbiAgICAgIG5vZGVzLnB1c2goeCk7XG4gICAgICByZXR1cm4gc2lmdGRvd24obm9kZXMsIDAsIG5vZGVzLmxlbmd0aCAtIDEsIGNtcCk7XG4gICAgfSxcbiAgICBwb3A6ICgpID0+IHtcbiAgICAgIGNvbnN0IGxhc3QgPSBub2Rlcy5wb3AoKTtcbiAgICAgIGxldCBpdGVtO1xuICAgICAgaWYgKG5vZGVzLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gbm9kZXNbMF07XG4gICAgICAgIG5vZGVzWzBdID0gbGFzdDtcbiAgICAgICAgc2lmdHVwKG5vZGVzLCAwLCBjbXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbSA9IGxhc3Q7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiBzaWZ0ZG93bihhcnJheSwgc3RhcnQsIGlkeCwgY21wKSB7XG4gIGxldCBwYXJlbnQsIHBpZHg7XG4gIGNvbnN0IGl0ZW0gPSBhcnJheVtpZHhdO1xuICB3aGlsZSAoaWR4ID4gc3RhcnQpIHtcbiAgICBwaWR4ID0gaWR4IC0gMSA+PiAxO1xuICAgIHBhcmVudCA9IGFycmF5W3BpZHhdO1xuICAgIGlmIChjbXAoaXRlbSwgcGFyZW50KSA8IDApIHtcbiAgICAgIGFycmF5W2lkeF0gPSBwYXJlbnQ7XG4gICAgICBpZHggPSBwaWR4O1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhcnJheVtpZHhdID0gaXRlbTtcbn1cbmZ1bmN0aW9uIHNpZnR1cChhcnJheSwgaWR4LCBjbXApIHtcbiAgY29uc3Qgc3RhcnQgPSBpZHgsXG4gICAgZW5kID0gYXJyYXkubGVuZ3RoLFxuICAgIGl0ZW0gPSBhcnJheVtpZHhdO1xuICBsZXQgY2lkeCA9IChpZHggPDwgMSkgKyAxLFxuICAgIHJpZHg7XG4gIHdoaWxlIChjaWR4IDwgZW5kKSB7XG4gICAgcmlkeCA9IGNpZHggKyAxO1xuICAgIGlmIChyaWR4IDwgZW5kICYmIGNtcChhcnJheVtjaWR4XSwgYXJyYXlbcmlkeF0pID49IDApIHtcbiAgICAgIGNpZHggPSByaWR4O1xuICAgIH1cbiAgICBhcnJheVtpZHhdID0gYXJyYXlbY2lkeF07XG4gICAgaWR4ID0gY2lkeDtcbiAgICBjaWR4ID0gKGlkeCA8PCAxKSArIDE7XG4gIH1cbiAgYXJyYXlbaWR4XSA9IGl0ZW07XG4gIHJldHVybiBzaWZ0ZG93bihhcnJheSwgc3RhcnQsIGlkeCwgY21wKTtcbn1cblxuLyoqXG4gKiBBIGRhdGFmbG93IGdyYXBoIGZvciByZWFjdGl2ZSBwcm9jZXNzaW5nIG9mIGRhdGEgc3RyZWFtcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBEYXRhZmxvdygpIHtcbiAgdGhpcy5sb2dnZXIobG9nZ2VyKCkpO1xuICB0aGlzLmxvZ0xldmVsKEVycm9yKTtcbiAgdGhpcy5fY2xvY2sgPSAwO1xuICB0aGlzLl9yYW5rID0gMDtcbiAgdGhpcy5fbG9jYWxlID0gZGVmYXVsdExvY2FsZSgpO1xuICB0cnkge1xuICAgIHRoaXMuX2xvYWRlciA9IGxvYWRlcigpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gZG8gbm90aGluZyBpZiBsb2FkZXIgbW9kdWxlIGlzIHVuYXZhaWxhYmxlXG4gIH1cbiAgdGhpcy5fdG91Y2hlZCA9IFVuaXF1ZUxpc3QoaWQpO1xuICB0aGlzLl9pbnB1dCA9IHt9O1xuICB0aGlzLl9wdWxzZSA9IG51bGw7XG4gIHRoaXMuX2hlYXAgPSBIZWFwKChhLCBiKSA9PiBhLnFyYW5rIC0gYi5xcmFuayk7XG4gIHRoaXMuX3Bvc3RydW4gPSBbXTtcbn1cbmZ1bmN0aW9uIGxvZ01ldGhvZChtZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9nW21ldGhvZF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbkRhdGFmbG93LnByb3RvdHlwZSA9IHtcbiAgLyoqXG4gICAqIFRoZSBjdXJyZW50IHRpbWVzdGFtcCBvZiB0aGlzIGRhdGFmbG93LiBUaGlzIHZhbHVlIHJlZmxlY3RzIHRoZVxuICAgKiB0aW1lc3RhbXAgb2YgdGhlIHByZXZpb3VzIGRhdGFmbG93IHJ1bi4gVGhlIGRhdGFmbG93IGlzIGluaXRpYWxpemVkXG4gICAqIHdpdGggYSBzdGFtcCB2YWx1ZSBvZiAwLiBUaGUgaW5pdGlhbCBydW4gb2YgdGhlIGRhdGFmbG93IHdpbGwgaGF2ZVxuICAgKiBhIHRpbWVzdGFwIG9mIDEsIGFuZCBzbyBvbi4gVGhpcyB2YWx1ZSB3aWxsIG1hdGNoIHRoZVxuICAgKiB7QGxpbmsgUHVsc2Uuc3RhbXB9IHByb3BlcnR5LlxuICAgKiBAcmV0dXJuIHtudW1iZXJ9IC0gVGhlIGN1cnJlbnQgdGltZXN0YW1wIHZhbHVlLlxuICAgKi9cbiAgc3RhbXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Nsb2NrO1xuICB9LFxuICAvKipcbiAgICogR2V0cyBvciBzZXRzIHRoZSBsb2FkZXIgaW5zdGFuY2UgdG8gdXNlIGZvciBkYXRhIGZpbGUgbG9hZGluZy4gQVxuICAgKiBsb2FkZXIgb2JqZWN0IG11c3QgcHJvdmlkZSBhIFwibG9hZFwiIG1ldGhvZCBmb3IgbG9hZGluZyBmaWxlcyBhbmQgYVxuICAgKiBcInNhbml0aXplXCIgbWV0aG9kIGZvciBjaGVja2luZyBVUkwvZmlsZW5hbWUgdmFsaWRpdHkuIEJvdGggbWV0aG9kc1xuICAgKiBzaG91bGQgYWNjZXB0IGEgVVJJIGFuZCBvcHRpb25zIGhhc2ggYXMgYXJndW1lbnRzLCBhbmQgcmV0dXJuIGEgUHJvbWlzZVxuICAgKiB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgZmlsZSBjb250ZW50cyAobG9hZCkgb3IgYSBoYXNoIGNvbnRhaW5pbmdcbiAgICogc2FuaXRpemVkIFVSSSBkYXRhIHdpdGggdGhlIHNhbml0aXplZCB1cmwgYXNzaWduZWQgdG8gdGhlIFwiaHJlZlwiIHByb3BlcnR5XG4gICAqIChzYW5pdGl6ZSkuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBfIC0gVGhlIGxvYWRlciBpbnN0YW5jZSB0byB1c2UuXG4gICAqIEByZXR1cm4ge29iamVjdHxEYXRhZmxvd30gLSBJZiBubyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCByZXR1cm5zXG4gICAqICAgdGhlIGN1cnJlbnQgbG9hZGVyIGluc3RhbmNlLiBPdGhlcndpc2UgcmV0dXJucyB0aGlzIERhdGFmbG93IGluc3RhbmNlLlxuICAgKi9cbiAgbG9hZGVyKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbG9hZGVyID0gXztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9hZGVyO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldHMgb3Igc2V0cyB0aGUgbG9jYWxlIGluc3RhbmNlIHRvIHVzZSBmb3IgZm9ybWF0dGluZyBhbmQgcGFyc2luZ1xuICAgKiBzdHJpbmcgdmFsdWVzLiBUaGUgbG9jYWxlIG9iamVjdCBzaG91bGQgYmUgcHJvdmlkZWQgYnkgdGhlXG4gICAqIHZlZ2EtZm9ybWF0IGxpYnJhcnksIGFuZCBpbmNsdWRlIG1ldGhvZHMgc3VjaCBhcyBmb3JtYXQsIHRpbWVGb3JtYXQsXG4gICAqIHV0Y0Zvcm1hdCwgdGltZVBhcnNlLCBhbmQgdXRjUGFyc2UuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBfIC0gVGhlIGxvY2FsZSBpbnN0YW5jZSB0byB1c2UuXG4gICAqIEByZXR1cm4ge29iamVjdHxEYXRhZmxvd30gLSBJZiBubyBhcmd1bWVudHMgYXJlIHByb3ZpZGVkLCByZXR1cm5zXG4gICAqICAgdGhlIGN1cnJlbnQgbG9jYWxlIGluc3RhbmNlLiBPdGhlcndpc2UgcmV0dXJucyB0aGlzIERhdGFmbG93IGluc3RhbmNlLlxuICAgKi9cbiAgbG9jYWxlKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbG9jYWxlID0gXztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxlO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIEdldCBvciBzZXQgdGhlIGxvZ2dlciBpbnN0YW5jZSB1c2VkIHRvIGxvZyBtZXNzYWdlcy4gSWYgbm8gYXJndW1lbnRzIGFyZVxuICAgKiBwcm92aWRlZCwgcmV0dXJucyB0aGUgY3VycmVudCBsb2dnZXIgaW5zdGFuY2UuIE90aGVyd2lzZSwgc2V0cyB0aGUgbG9nZ2VyXG4gICAqIGFuZCByZXR1cm4gdGhpcyBEYXRhZmxvdyBpbnN0YW5jZS4gUHJvdmlkZWQgbG9nZ2VycyBtdXN0IHN1cHBvcnQgdGhlIGZ1bGxcbiAgICogQVBJIG9mIGxvZ2dlciBvYmplY3RzIGdlbmVyYXRlZCBieSB0aGUgdmVnYS11dGlsIGxvZ2dlciBtZXRob2QuIE5vdGUgdGhhdFxuICAgKiBieSBkZWZhdWx0IHRoZSBsb2cgbGV2ZWwgb2YgdGhlIG5ldyBsb2dnZXIgd2lsbCBiZSB1c2VkOyB1c2UgdGhlIGxvZ0xldmVsXG4gICAqIG1ldGhvZCB0byBhZGp1c3QgdGhlIGxvZyBsZXZlbCBhcyBuZWVkZWQuXG4gICAqL1xuICBsb2dnZXIobG9nZ2VyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX2xvZyA9IGxvZ2dlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fbG9nO1xuICAgIH1cbiAgfSxcbiAgLyoqXG4gICAqIExvZ3MgYW4gZXJyb3IgbWVzc2FnZS4gQnkgZGVmYXVsdCwgbG9nZ2VkIG1lc3NhZ2VzIGFyZSB3cml0dGVuIHRvIGNvbnNvbGVcbiAgICogb3V0cHV0LiBUaGUgbWVzc2FnZSB3aWxsIG9ubHkgYmUgbG9nZ2VkIGlmIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBpcyBoaWdoXG4gICAqIGVub3VnaCB0byBwZXJtaXQgZXJyb3IgbWVzc2FnZXMuXG4gICAqL1xuICBlcnJvcjogbG9nTWV0aG9kKCdlcnJvcicpLFxuICAvKipcbiAgICogTG9ncyBhIHdhcm5pbmcgbWVzc2FnZS4gQnkgZGVmYXVsdCwgbG9nZ2VkIG1lc3NhZ2VzIGFyZSB3cml0dGVuIHRvIGNvbnNvbGVcbiAgICogb3V0cHV0LiBUaGUgbWVzc2FnZSB3aWxsIG9ubHkgYmUgbG9nZ2VkIGlmIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBpcyBoaWdoXG4gICAqIGVub3VnaCB0byBwZXJtaXQgd2FybmluZyBtZXNzYWdlcy5cbiAgICovXG4gIHdhcm46IGxvZ01ldGhvZCgnd2FybicpLFxuICAvKipcbiAgICogTG9ncyBhIGluZm9ybWF0aW9uIG1lc3NhZ2UuIEJ5IGRlZmF1bHQsIGxvZ2dlZCBtZXNzYWdlcyBhcmUgd3JpdHRlbiB0b1xuICAgKiBjb25zb2xlIG91dHB1dC4gVGhlIG1lc3NhZ2Ugd2lsbCBvbmx5IGJlIGxvZ2dlZCBpZiB0aGUgY3VycmVudCBsb2cgbGV2ZWwgaXNcbiAgICogaGlnaCBlbm91Z2ggdG8gcGVybWl0IGluZm9ybWF0aW9uIG1lc3NhZ2VzLlxuICAgKi9cbiAgaW5mbzogbG9nTWV0aG9kKCdpbmZvJyksXG4gIC8qKlxuICAgKiBMb2dzIGEgZGVidWcgbWVzc2FnZS4gQnkgZGVmYXVsdCwgbG9nZ2VkIG1lc3NhZ2VzIGFyZSB3cml0dGVuIHRvIGNvbnNvbGVcbiAgICogb3V0cHV0LiBUaGUgbWVzc2FnZSB3aWxsIG9ubHkgYmUgbG9nZ2VkIGlmIHRoZSBjdXJyZW50IGxvZyBsZXZlbCBpcyBoaWdoXG4gICAqIGVub3VnaCB0byBwZXJtaXQgZGVidWcgbWVzc2FnZXMuXG4gICAqL1xuICBkZWJ1ZzogbG9nTWV0aG9kKCdkZWJ1ZycpLFxuICAvKipcbiAgICogR2V0IG9yIHNldCB0aGUgY3VycmVudCBsb2cgbGV2ZWwuIElmIGFuIGFyZ3VtZW50IGlzIHByb3ZpZGVkLCBpdFxuICAgKiB3aWxsIGJlIHVzZWQgYXMgdGhlIG5ldyBsb2cgbGV2ZWwuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbGV2ZWxdIC0gU2hvdWxkIGJlIG9uZSBvZiBOb25lLCBXYXJuLCBJbmZvXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAqL1xuICBsb2dMZXZlbDogbG9nTWV0aG9kKCdsZXZlbCcpLFxuICAvKipcbiAgICogRW1wdHkgZW50cnkgdGhyZXNob2xkIGZvciBnYXJiYWdlIGNsZWFuaW5nLiBNYXAgZGF0YSBzdHJ1Y3R1cmVzIHdpbGxcbiAgICogcGVyZm9ybSBjbGVhbmluZyBvbmNlIHRoZSBudW1iZXIgb2YgZW1wdHkgZW50cmllcyBleGNlZWRzIHRoaXMgdmFsdWUuXG4gICAqL1xuICBjbGVhblRocmVzaG9sZDogMWU0LFxuICAvLyBPUEVSQVRPUiBSRUdJU1RSQVRJT05cbiAgYWRkLFxuICBjb25uZWN0LFxuICByYW5rLFxuICByZXJhbmssXG4gIC8vIE9QRVJBVE9SIFVQREFURVNcbiAgcHVsc2UsXG4gIHRvdWNoLFxuICB1cGRhdGUsXG4gIGNoYW5nZXNldCxcbiAgLy8gREFUQSBMT0FESU5HXG4gIGluZ2VzdCxcbiAgcGFyc2UsXG4gIHByZWxvYWQsXG4gIHJlcXVlc3QsXG4gIC8vIEVWRU5UIEhBTkRMSU5HXG4gIGV2ZW50cyxcbiAgb24sXG4gIC8vIFBVTFNFIFBST1BBR0FUSU9OXG4gIGV2YWx1YXRlLFxuICBydW4sXG4gIHJ1bkFzeW5jLFxuICBydW5BZnRlcixcbiAgX2VucXVldWU6IGVucXVldWUsXG4gIF9nZXRQdWxzZTogZ2V0UHVsc2Vcbn07XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIG9wZXJhdG9ycyB0aGF0IHByb2Nlc3MgZGF0YSB0dXBsZXMuXG4gKiBTdWJjbGFzc2VzIG11c3QgcHJvdmlkZSBhIHtAbGluayB0cmFuc2Zvcm19IG1ldGhvZCBmb3Igb3BlcmF0b3IgcHJvY2Vzc2luZy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHsqfSBbaW5pdF0gLSBUaGUgaW5pdGlhbCB2YWx1ZSBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtPcGVyYXRvcn0gW3NvdXJjZV0gLSBUaGUgb3BlcmF0b3IgZnJvbSB3aGljaCB0byByZWNlaXZlIHB1bHNlcy5cbiAqL1xuZnVuY3Rpb24gVHJhbnNmb3JtKGluaXQsIHBhcmFtcykge1xuICBPcGVyYXRvci5jYWxsKHRoaXMsIGluaXQsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhUcmFuc2Zvcm0sIE9wZXJhdG9yLCB7XG4gIC8qKlxuICAgKiBPdmVycmlkZXMge0BsaW5rIE9wZXJhdG9yLmV2YWx1YXRlfSBmb3IgdHJhbnNmb3JtIG9wZXJhdG9ycy5cbiAgICogSW50ZXJuYWxseSwgdGhpcyBtZXRob2QgY2FsbHMge0BsaW5rIGV2YWx1YXRlfSB0byBwZXJmb3JtIHByb2Nlc3NpbmcuXG4gICAqIElmIHtAbGluayBldmFsdWF0ZX0gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCB0aGUgaW5wdXQgcHVsc2UgaXMgcmV0dXJuZWQuXG4gICAqIFRoaXMgbWV0aG9kIHNob3VsZCBOT1QgYmUgb3ZlcnJpZGRlbiwgaW5zdGVhZCBvdmVycnJpZGUge0BsaW5rIGV2YWx1YXRlfS5cbiAgICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSB0aGUgY3VycmVudCBkYXRhZmxvdyBwdWxzZS5cbiAgICogQHJldHVybiB0aGUgb3V0cHV0IHB1bHNlIGZvciB0aGlzIG9wZXJhdG9yIChvciBTdG9wUHJvcGFnYXRpb24pXG4gICAqL1xuICBydW4ocHVsc2UpIHtcbiAgICBpZiAocHVsc2Uuc3RhbXAgPCB0aGlzLnN0YW1wKSByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIGxldCBydjtcbiAgICBpZiAodGhpcy5za2lwKCkpIHtcbiAgICAgIHRoaXMuc2tpcChmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJ2ID0gdGhpcy5ldmFsdWF0ZShwdWxzZSk7XG4gICAgfVxuICAgIHJ2ID0gcnYgfHwgcHVsc2U7XG4gICAgaWYgKHJ2LnRoZW4pIHtcbiAgICAgIHJ2ID0gcnYudGhlbihfID0+IHRoaXMucHVsc2UgPSBfKTtcbiAgICB9IGVsc2UgaWYgKHJ2ICE9PSBwdWxzZS5TdG9wUHJvcGFnYXRpb24pIHtcbiAgICAgIHRoaXMucHVsc2UgPSBydjtcbiAgICB9XG4gICAgcmV0dXJuIHJ2O1xuICB9LFxuICAvKipcbiAgICogT3ZlcnJpZGVzIHtAbGluayBPcGVyYXRvci5ldmFsdWF0ZX0gZm9yIHRyYW5zZm9ybSBvcGVyYXRvcnMuXG4gICAqIE1hcnNoYWxscyBwYXJhbWV0ZXIgdmFsdWVzIGFuZCB0aGVuIGludm9rZXMge0BsaW5rIHRyYW5zZm9ybX0uXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gdGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSBUaGUgb3V0cHV0IHB1bHNlIChvciBTdG9wUHJvcGFnYXRpb24pLiBBIGZhbHN5IHJldHVyblxuICAgICAgIHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAqL1xuICBldmFsdWF0ZShwdWxzZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMubWFyc2hhbGwocHVsc2Uuc3RhbXApLFxuICAgICAgb3V0ID0gdGhpcy50cmFuc2Zvcm0ocGFyYW1zLCBwdWxzZSk7XG4gICAgcGFyYW1zLmNsZWFyKCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfSxcbiAgLyoqXG4gICAqIFByb2Nlc3MgaW5jb21pbmcgcHVsc2VzLlxuICAgKiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byBpbXBsZW1lbnQgdHJhbnNmb3Jtcy5cbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJzfSBfIC0gVGhlIG9wZXJhdG9yIHBhcmFtZXRlciB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7UHVsc2V9IHB1bHNlIC0gVGhlIGN1cnJlbnQgZGF0YWZsb3cgcHVsc2UuXG4gICAqIEByZXR1cm4ge1B1bHNlfSBUaGUgb3V0cHV0IHB1bHNlIChvciBTdG9wUHJvcGFnYXRpb24pLiBBIGZhbHN5IHJldHVyblxuICAgKiAgIHZhbHVlIChpbmNsdWRpbmcgdW5kZWZpbmVkKSB3aWxsIGxldCB0aGUgaW5wdXQgcHVsc2UgcGFzcyB0aHJvdWdoLlxuICAgKi9cbiAgdHJhbnNmb3JtKCkge31cbn0pO1xuXG5jb25zdCB0cmFuc2Zvcm1zID0ge307XG5mdW5jdGlvbiBkZWZpbml0aW9uKHR5cGUpIHtcbiAgY29uc3QgdCA9IHRyYW5zZm9ybSh0eXBlKTtcbiAgcmV0dXJuIHQgJiYgdC5EZWZpbml0aW9uIHx8IG51bGw7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm0odHlwZSkge1xuICB0eXBlID0gdHlwZSAmJiB0eXBlLnRvTG93ZXJDYXNlKCk7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0cmFuc2Zvcm1zLCB0eXBlKSA/IHRyYW5zZm9ybXNbdHlwZV0gOiBudWxsO1xufVxuXG5leHBvcnQgeyBEYXRhZmxvdywgRXZlbnRTdHJlYW0sIE11bHRpUHVsc2UsIE9wZXJhdG9yLCBQYXJhbWV0ZXJzLCBQdWxzZSwgVHJhbnNmb3JtLCBVbmlxdWVMaXN0LCBhc3luY0NhbGxiYWNrLCBjaGFuZ2VzZXQsIGRlZmluaXRpb24sIGRlcml2ZSwgaW5nZXN0JDEgYXMgaW5nZXN0LCBpc0NoYW5nZVNldCwgaXNUdXBsZSwgcmVkZXJpdmUsIHJlcGxhY2UsIHN0YWJsZUNvbXBhcmUsIHRyYW5zZm9ybSwgdHJhbnNmb3JtcywgdHVwbGVpZCB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtLCBpbmdlc3QsIHR1cGxlaWQsIHN0YWJsZUNvbXBhcmUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IHRpY2tDb3VudCwgdGlja0Zvcm1hdCwgdmFsaWRUaWNrcywgdGlja1ZhbHVlcywgU3ltYm9sTGVnZW5kLCBsYWJlbEZvcm1hdCwgbGFiZWxWYWx1ZXMsIEdyYWRpZW50TGVnZW5kLCBzY2FsZUZyYWN0aW9uLCBsYWJlbEZyYWN0aW9uLCBzY2FsZSwgU2VxdWVudGlhbCwgTGluZWFyLCBpc0NvbnRpbnVvdXMsIFRpbWUsIFVUQywgT3JkaW5hbCwgc2NhbGVJbXBsaWNpdCwgTG9nLCBTcXJ0LCBQb3csIFN5bWxvZywgaXNMb2dhcml0aG1pYywgQmluT3JkaW5hbCwgaXNJbnRlcnBvbGF0aW5nLCBpbnRlcnBvbGF0ZUNvbG9ycywgaW50ZXJwb2xhdGUsIEJhbmQsIFBvaW50LCBiYW5kU3BhY2UsIHNjaGVtZSwgVGhyZXNob2xkLCBRdWFudGlsZSwgUXVhbnRpemUsIHF1YW50aXplSW50ZXJwb2xhdG9yLCBpbnRlcnBvbGF0ZVJhbmdlLCBEaXZlcmdpbmcgfSBmcm9tICd2ZWdhLXNjYWxlJztcbmltcG9ydCB7IGluaGVyaXRzLCBpc0FycmF5LCBlcnJvciwgZmFzdG1hcCwgZmFsc3ksIGlzRnVuY3Rpb24sIGNvbnN0YW50LCBwZWVrLCBvbmUsIHRvU2V0LCBpc1N0cmluZywgem9vbUxvZywgem9vbVBvdywgem9vbVN5bWxvZywgem9vbUxpbmVhciwgc3RyaW5nVmFsdWUgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgc3VtLCByYW5nZSB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IGludGVycG9sYXRlUm91bmQsIGludGVycG9sYXRlIGFzIGludGVycG9sYXRlJDEgfSBmcm9tICdkMy1pbnRlcnBvbGF0ZSc7XG5cbi8qKlxuICogR2VuZXJhdGVzIGF4aXMgdGlja3MgZm9yIHZpc3VhbGl6aW5nIGEgc3BhdGlhbCBzY2FsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtTY2FsZX0gcGFyYW1zLnNjYWxlIC0gVGhlIHNjYWxlIHRvIGdlbmVyYXRlIHRpY2tzIGZvci5cbiAqIEBwYXJhbSB7Kn0gW3BhcmFtcy5jb3VudD0xMF0gLSBUaGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIHRpY2tzLCBvclxuICogICBkZXNpcmVkIHRpY2sgaW50ZXJ2YWwsIHRvIHVzZS5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IFtwYXJhbXMudmFsdWVzXSAtIFRoZSBleGFjdCB0aWNrIHZhbHVlcyB0byB1c2UuXG4gKiAgIFRoZXNlIG11c3QgYmUgbGVnYWwgZG9tYWluIHZhbHVlcyBmb3IgdGhlIHByb3ZpZGVkIHNjYWxlLlxuICogICBJZiBwcm92aWRlZCwgdGhlIGNvdW50IGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOnN0cmluZ30gW3BhcmFtcy5mb3JtYXRTcGVjaWZpZXJdIC0gQSBmb3JtYXQgc3BlY2lmaWVyXG4gKiAgIHRvIHVzZSBpbiBjb25qdW5jdGlvbiB3aXRoIHNjYWxlLnRpY2tGb3JtYXQuIExlZ2FsIHZhbHVlcyBhcmVcbiAqICAgYW55IHZhbGlkIGQzIDQuMCBmb3JtYXQgc3BlY2lmaWVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqKTpzdHJpbmd9IFtwYXJhbXMuZm9ybWF0XSAtIFRoZSBmb3JtYXQgZnVuY3Rpb24gdG8gdXNlLlxuICogICBJZiBwcm92aWRlZCwgdGhlIGZvcm1hdFNwZWNpZmllciBhcmd1bWVudCBpcyBpZ25vcmVkLlxuICovXG5mdW5jdGlvbiBBeGlzVGlja3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhBeGlzVGlja3MsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICB2YXIgbG9jYWxlID0gcHVsc2UuZGF0YWZsb3cubG9jYWxlKCksXG4gICAgICBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICB0aWNrcyA9IHRoaXMudmFsdWUsXG4gICAgICBzY2FsZSA9IF8uc2NhbGUsXG4gICAgICB0YWxseSA9IF8uY291bnQgPT0gbnVsbCA/IF8udmFsdWVzID8gXy52YWx1ZXMubGVuZ3RoIDogMTAgOiBfLmNvdW50LFxuICAgICAgY291bnQgPSB0aWNrQ291bnQoc2NhbGUsIHRhbGx5LCBfLm1pbnN0ZXApLFxuICAgICAgZm9ybWF0ID0gXy5mb3JtYXQgfHwgdGlja0Zvcm1hdChsb2NhbGUsIHNjYWxlLCBjb3VudCwgXy5mb3JtYXRTcGVjaWZpZXIsIF8uZm9ybWF0VHlwZSwgISFfLnZhbHVlcyksXG4gICAgICB2YWx1ZXMgPSBfLnZhbHVlcyA/IHZhbGlkVGlja3Moc2NhbGUsIF8udmFsdWVzLCBjb3VudCkgOiB0aWNrVmFsdWVzKHNjYWxlLCBjb3VudCk7XG4gICAgaWYgKHRpY2tzKSBvdXQucmVtID0gdGlja3M7XG4gICAgdGlja3MgPSB2YWx1ZXMubWFwKCh2YWx1ZSwgaSkgPT4gaW5nZXN0KHtcbiAgICAgIGluZGV4OiBpIC8gKHZhbHVlcy5sZW5ndGggLSAxIHx8IDEpLFxuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgbGFiZWw6IGZvcm1hdCh2YWx1ZSlcbiAgICB9KSk7XG4gICAgaWYgKF8uZXh0cmEgJiYgdGlja3MubGVuZ3RoKSB7XG4gICAgICAvLyBhZGQgYW4gZXh0cmEgdGljayBwZWdnZWQgdG8gdGhlIGluaXRpYWwgZG9tYWluIHZhbHVlXG4gICAgICAvLyB0aGlzIGlzIHVzZWQgdG8gZ2VuZXJhdGUgYXhlcyB3aXRoICdiaW5uZWQnIGRvbWFpbnNcbiAgICAgIHRpY2tzLnB1c2goaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IC0xLFxuICAgICAgICBleHRyYToge1xuICAgICAgICAgIHZhbHVlOiB0aWNrc1swXS52YWx1ZVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbDogJydcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgb3V0LnNvdXJjZSA9IHRpY2tzO1xuICAgIG91dC5hZGQgPSB0aWNrcztcbiAgICB0aGlzLnZhbHVlID0gdGlja3M7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufSk7XG5cbi8qKlxuICogSm9pbnMgYSBzZXQgb2YgZGF0YSBlbGVtZW50cyBhZ2FpbnN0IGEgc2V0IG9mIHZpc3VhbCBpdGVtcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBvYmplY3R9IFtwYXJhbXMuaXRlbV0gLSBBbiBpdGVtIGdlbmVyYXRvciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW3BhcmFtcy5rZXldIC0gVGhlIGtleSBmaWVsZCBhc3NvY2lhdGluZyBkYXRhIGFuZCB2aXN1YWwgaXRlbXMuXG4gKi9cbmZ1bmN0aW9uIERhdGFKb2luKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuZnVuY3Rpb24gZGVmYXVsdEl0ZW1DcmVhdGUoKSB7XG4gIHJldHVybiBpbmdlc3Qoe30pO1xufVxuZnVuY3Rpb24gbmV3TWFwKGtleSkge1xuICBjb25zdCBtYXAgPSBmYXN0bWFwKCkudGVzdCh0ID0+IHQuZXhpdCk7XG4gIG1hcC5sb29rdXAgPSB0ID0+IG1hcC5nZXQoa2V5KHQpKTtcbiAgcmV0dXJuIG1hcDtcbn1cbmluaGVyaXRzKERhdGFKb2luLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICBpdGVtID0gXy5pdGVtIHx8IGRlZmF1bHRJdGVtQ3JlYXRlLFxuICAgICAga2V5ID0gXy5rZXkgfHwgdHVwbGVpZCxcbiAgICAgIG1hcCA9IHRoaXMudmFsdWU7XG5cbiAgICAvLyBwcmV2ZW50IHRyYW5zaWVudCAoZS5nLiwgaG92ZXIpIHJlcXVlc3RzIGZyb21cbiAgICAvLyBjYXNjYWRpbmcgYWNyb3NzIG1hcmtzIGRlcml2ZWQgZnJvbSBtYXJrc1xuICAgIGlmIChpc0FycmF5KG91dC5lbmNvZGUpKSB7XG4gICAgICBvdXQuZW5jb2RlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKG1hcCAmJiAoXy5tb2RpZmllZCgna2V5JykgfHwgcHVsc2UubW9kaWZpZWQoa2V5KSkpIHtcbiAgICAgIGVycm9yKCdEYXRhSm9pbiBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVkIGtleSBmdW5jdGlvbiBvciBmaWVsZHMuJyk7XG4gICAgfVxuICAgIGlmICghbWFwKSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgdGhpcy52YWx1ZSA9IG1hcCA9IG5ld01hcChrZXkpO1xuICAgIH1cbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgY29uc3QgayA9IGtleSh0KTtcbiAgICAgIGxldCB4ID0gbWFwLmdldChrKTtcbiAgICAgIGlmICh4KSB7XG4gICAgICAgIGlmICh4LmV4aXQpIHtcbiAgICAgICAgICBtYXAuZW1wdHktLTtcbiAgICAgICAgICBvdXQuYWRkLnB1c2goeCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0Lm1vZC5wdXNoKHgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4ID0gaXRlbSh0KTtcbiAgICAgICAgbWFwLnNldChrLCB4KTtcbiAgICAgICAgb3V0LmFkZC5wdXNoKHgpO1xuICAgICAgfVxuICAgICAgeC5kYXR1bSA9IHQ7XG4gICAgICB4LmV4aXQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgY29uc3QgayA9IGtleSh0KSxcbiAgICAgICAgeCA9IG1hcC5nZXQoayk7XG4gICAgICBpZiAoeCkge1xuICAgICAgICB4LmRhdHVtID0gdDtcbiAgICAgICAgb3V0Lm1vZC5wdXNoKHgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBrID0ga2V5KHQpLFxuICAgICAgICB4ID0gbWFwLmdldChrKTtcbiAgICAgIGlmICh0ID09PSB4LmRhdHVtICYmICF4LmV4aXQpIHtcbiAgICAgICAgb3V0LnJlbS5wdXNoKHgpO1xuICAgICAgICB4LmV4aXQgPSB0cnVlO1xuICAgICAgICArK21hcC5lbXB0eTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAocHVsc2UuY2hhbmdlZChwdWxzZS5BRERfTU9EKSkgb3V0Lm1vZGlmaWVzKCdkYXR1bScpO1xuICAgIGlmIChwdWxzZS5jbGVhbigpIHx8IF8uY2xlYW4gJiYgbWFwLmVtcHR5ID4gZGYuY2xlYW5UaHJlc2hvbGQpIHtcbiAgICAgIGRmLnJ1bkFmdGVyKG1hcC5jbGVhbik7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEludm9rZXMgZW5jb2RpbmcgZnVuY3Rpb25zIGZvciB2aXN1YWwgaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyB0byB0aGUgZW5jb2RpbmcgZnVuY3Rpb25zLiBUaGlzXG4gKiAgIHBhcmFtZXRlciBvYmplY3Qgd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0byBhbGwgaW52b2tlZCBlbmNvZGluZyBmdW5jdGlvbnMuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5tb2Q9ZmFsc2VdIC0gRmxhZyBpbmRpY2F0aW5nIGlmIHR1cGxlcyBpbiB0aGUgaW5wdXRcbiAqICAgbW9kIHNldCB0aGF0IGFyZSB1bm1vZGlmaWVkIGJ5IGVuY29kZXJzIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGUgb3V0cHV0LlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtLmVuY29kZXJzIC0gVGhlIGVuY29kaW5nIGZ1bmN0aW9uc1xuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy51cGRhdGVdIC0gVXBkYXRlIGVuY29kaW5nIHNldFxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QsIG9iamVjdCk6IGJvb2xlYW59IFtwYXJhbS5lbmNvZGVycy5lbnRlcl0gLSBFbnRlciBlbmNvZGluZyBzZXRcbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0LCBvYmplY3QpOiBib29sZWFufSBbcGFyYW0uZW5jb2RlcnMuZXhpdF0gLSBFeGl0IGVuY29kaW5nIHNldFxuICovXG5mdW5jdGlvbiBFbmNvZGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhFbmNvZGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BRERfUkVNKSxcbiAgICAgIGZtb2QgPSBfLm1vZCB8fCBmYWxzZSxcbiAgICAgIGVuY29kZXJzID0gXy5lbmNvZGVycyxcbiAgICAgIGVuY29kZSA9IHB1bHNlLmVuY29kZTtcblxuICAgIC8vIGlmIGFuIGFycmF5LCB0aGUgZW5jb2RlIGRpcmVjdGl2ZSBpbmNsdWRlcyBhZGRpdGlvbmFsIHNldHNcbiAgICAvLyB0aGF0IG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciBmb3IgdGhlIHByaW1hcnkgc2V0IHRvIGJlIGludm9rZWRcbiAgICAvLyBlLmcuLCBvbmx5IHJ1biB0aGUgdXBkYXRlIHNldCBpZiB0aGUgaG92ZXIgc2V0IGlzIGRlZmluZWRcbiAgICBpZiAoaXNBcnJheShlbmNvZGUpKSB7XG4gICAgICBpZiAob3V0LmNoYW5nZWQoKSB8fCBlbmNvZGUuZXZlcnkoZSA9PiBlbmNvZGVyc1tlXSkpIHtcbiAgICAgICAgZW5jb2RlID0gZW5jb2RlWzBdO1xuICAgICAgICBvdXQuZW5jb2RlID0gbnVsbDsgLy8gY29uc3VtZSB0YXJnZXRlZCBlbmNvZGUgZGlyZWN0aXZlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIG1hcnNoYWxsIGVuY29kZXIgZnVuY3Rpb25zXG4gICAgdmFyIHJlZW50ZXIgPSBlbmNvZGUgPT09ICdlbnRlcicsXG4gICAgICB1cGRhdGUgPSBlbmNvZGVycy51cGRhdGUgfHwgZmFsc3ksXG4gICAgICBlbnRlciA9IGVuY29kZXJzLmVudGVyIHx8IGZhbHN5LFxuICAgICAgZXhpdCA9IGVuY29kZXJzLmV4aXQgfHwgZmFsc3ksXG4gICAgICBzZXQgPSAoZW5jb2RlICYmICFyZWVudGVyID8gZW5jb2RlcnNbZW5jb2RlXSA6IHVwZGF0ZSkgfHwgZmFsc3k7XG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuQUREKSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgICAgZW50ZXIodCwgXyk7XG4gICAgICAgIHVwZGF0ZSh0LCBfKTtcbiAgICAgIH0pO1xuICAgICAgb3V0Lm1vZGlmaWVzKGVudGVyLm91dHB1dCk7XG4gICAgICBvdXQubW9kaWZpZXModXBkYXRlLm91dHB1dCk7XG4gICAgICBpZiAoc2V0ICE9PSBmYWxzeSAmJiBzZXQgIT09IHVwZGF0ZSkge1xuICAgICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgICAgIHNldCh0LCBfKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG91dC5tb2RpZmllcyhzZXQub3V0cHV0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHB1bHNlLmNoYW5nZWQocHVsc2UuUkVNKSAmJiBleGl0ICE9PSBmYWxzeSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgICAgZXhpdCh0LCBfKTtcbiAgICAgIH0pO1xuICAgICAgb3V0Lm1vZGlmaWVzKGV4aXQub3V0cHV0KTtcbiAgICB9XG4gICAgaWYgKHJlZW50ZXIgfHwgc2V0ICE9PSBmYWxzeSkge1xuICAgICAgY29uc3QgZmxhZyA9IHB1bHNlLk1PRCB8IChfLm1vZGlmaWVkKCkgPyBwdWxzZS5SRUZMT1cgOiAwKTtcbiAgICAgIGlmIChyZWVudGVyKSB7XG4gICAgICAgIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4ge1xuICAgICAgICAgIGNvbnN0IG1vZCA9IGVudGVyKHQsIF8pIHx8IGZtb2Q7XG4gICAgICAgICAgaWYgKHNldCh0LCBfKSB8fCBtb2QpIG91dC5tb2QucHVzaCh0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChvdXQubW9kLmxlbmd0aCkgb3V0Lm1vZGlmaWVzKGVudGVyLm91dHB1dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdWxzZS52aXNpdChmbGFnLCB0ID0+IHtcbiAgICAgICAgICBpZiAoc2V0KHQsIF8pIHx8IGZtb2QpIG91dC5tb2QucHVzaCh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAob3V0Lm1vZC5sZW5ndGgpIG91dC5tb2RpZmllcyhzZXQub3V0cHV0KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dC5jaGFuZ2VkKCkgPyBvdXQgOiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBsZWdlbmQgZW50cmllcyBmb3IgdmlzdWFsaXppbmcgYSBzY2FsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtTY2FsZX0gcGFyYW1zLnNjYWxlIC0gVGhlIHNjYWxlIHRvIGdlbmVyYXRlIGl0ZW1zIGZvci5cbiAqIEBwYXJhbSB7Kn0gW3BhcmFtcy5jb3VudD01XSAtIFRoZSBhcHByb3hpbWF0ZSBudW1iZXIgb2YgaXRlbXMsIG9yXG4gKiAgIGRlc2lyZWQgdGljayBpbnRlcnZhbCwgdG8gdXNlLlxuICogQHBhcmFtIHsqfSBbcGFyYW1zLmxpbWl0XSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvXG4gKiAgIGluY2x1ZGUgaW4gYSBzeW1ib2wgbGVnZW5kLlxuICogQHBhcmFtIHtBcnJheTwqPn0gW3BhcmFtcy52YWx1ZXNdIC0gVGhlIGV4YWN0IHRpY2sgdmFsdWVzIHRvIHVzZS5cbiAqICAgVGhlc2UgbXVzdCBiZSBsZWdhbCBkb21haW4gdmFsdWVzIGZvciB0aGUgcHJvdmlkZWQgc2NhbGUuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgY291bnQgYXJndW1lbnQgaXMgaWdub3JlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmZvcm1hdFNwZWNpZmllcl0gLSBBIGZvcm1hdCBzcGVjaWZpZXJcbiAqICAgdG8gdXNlIGluIGNvbmp1bmN0aW9uIHdpdGggc2NhbGUudGlja0Zvcm1hdC4gTGVnYWwgdmFsdWVzIGFyZVxuICogICBhbnkgdmFsaWQgRDMgZm9ybWF0IHNwZWNpZmllciBzdHJpbmcuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCopOnN0cmluZ30gW3BhcmFtcy5mb3JtYXRdIC0gVGhlIGZvcm1hdCBmdW5jdGlvbiB0byB1c2UuXG4gKiAgIElmIHByb3ZpZGVkLCB0aGUgZm9ybWF0U3BlY2lmaWVyIGFyZ3VtZW50IGlzIGlnbm9yZWQuXG4gKi9cbmZ1bmN0aW9uIExlZ2VuZEVudHJpZXMocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTGVnZW5kRW50cmllcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICE9IG51bGwgJiYgIV8ubW9kaWZpZWQoKSkge1xuICAgICAgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB9XG4gICAgdmFyIGxvY2FsZSA9IHB1bHNlLmRhdGFmbG93LmxvY2FsZSgpLFxuICAgICAgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgaXRlbXMgPSB0aGlzLnZhbHVlLFxuICAgICAgdHlwZSA9IF8udHlwZSB8fCBTeW1ib2xMZWdlbmQsXG4gICAgICBzY2FsZSA9IF8uc2NhbGUsXG4gICAgICBsaW1pdCA9ICtfLmxpbWl0LFxuICAgICAgY291bnQgPSB0aWNrQ291bnQoc2NhbGUsIF8uY291bnQgPT0gbnVsbCA/IDUgOiBfLmNvdW50LCBfLm1pbnN0ZXApLFxuICAgICAgbHNraXAgPSAhIV8udmFsdWVzIHx8IHR5cGUgPT09IFN5bWJvbExlZ2VuZCxcbiAgICAgIGZvcm1hdCA9IF8uZm9ybWF0IHx8IGxhYmVsRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCB0eXBlLCBfLmZvcm1hdFNwZWNpZmllciwgXy5mb3JtYXRUeXBlLCBsc2tpcCksXG4gICAgICB2YWx1ZXMgPSBfLnZhbHVlcyB8fCBsYWJlbFZhbHVlcyhzY2FsZSwgY291bnQpLFxuICAgICAgZG9tYWluLFxuICAgICAgZnJhY3Rpb24sXG4gICAgICBzaXplLFxuICAgICAgb2Zmc2V0LFxuICAgICAgZWxsaXBzaXM7XG4gICAgaWYgKGl0ZW1zKSBvdXQucmVtID0gaXRlbXM7XG4gICAgaWYgKHR5cGUgPT09IFN5bWJvbExlZ2VuZCkge1xuICAgICAgaWYgKGxpbWl0ICYmIHZhbHVlcy5sZW5ndGggPiBsaW1pdCkge1xuICAgICAgICBwdWxzZS5kYXRhZmxvdy53YXJuKCdTeW1ib2wgbGVnZW5kIGNvdW50IGV4Y2VlZHMgbGltaXQsIGZpbHRlcmluZyBpdGVtcy4nKTtcbiAgICAgICAgaXRlbXMgPSB2YWx1ZXMuc2xpY2UoMCwgbGltaXQgLSAxKTtcbiAgICAgICAgZWxsaXBzaXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlbXMgPSB2YWx1ZXM7XG4gICAgICB9XG4gICAgICBpZiAoaXNGdW5jdGlvbihzaXplID0gXy5zaXplKSkge1xuICAgICAgICAvLyBpZiBmaXJzdCB2YWx1ZSBtYXBzIHRvIHNpemUgemVybywgcmVtb3ZlIGZyb20gbGlzdCAodmVnYSM3MTcpXG4gICAgICAgIGlmICghXy52YWx1ZXMgJiYgc2NhbGUoaXRlbXNbMF0pID09PSAwKSB7XG4gICAgICAgICAgaXRlbXMgPSBpdGVtcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjb21wdXRlIHNpemUgb2Zmc2V0IGZvciBsZWdlbmQgZW50cmllc1xuICAgICAgICBvZmZzZXQgPSBpdGVtcy5yZWR1Y2UoKG1heCwgdmFsdWUpID0+IE1hdGgubWF4KG1heCwgc2l6ZSh2YWx1ZSwgXykpLCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBjb25zdGFudChvZmZzZXQgPSBzaXplIHx8IDgpO1xuICAgICAgfVxuICAgICAgaXRlbXMgPSBpdGVtcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4gaW5nZXN0KHtcbiAgICAgICAgaW5kZXg6IGluZGV4LFxuICAgICAgICBsYWJlbDogZm9ybWF0KHZhbHVlLCBpbmRleCwgaXRlbXMpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBzaXplOiBzaXplKHZhbHVlLCBfKVxuICAgICAgfSkpO1xuICAgICAgaWYgKGVsbGlwc2lzKSB7XG4gICAgICAgIGVsbGlwc2lzID0gdmFsdWVzW2l0ZW1zLmxlbmd0aF07XG4gICAgICAgIGl0ZW1zLnB1c2goaW5nZXN0KHtcbiAgICAgICAgICBpbmRleDogaXRlbXMubGVuZ3RoLFxuICAgICAgICAgIGxhYmVsOiBgXFx1MjAyNiR7dmFsdWVzLmxlbmd0aCAtIGl0ZW1zLmxlbmd0aH0gZW50cmllc2AsXG4gICAgICAgICAgdmFsdWU6IGVsbGlwc2lzLFxuICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgIHNpemU6IHNpemUoZWxsaXBzaXMsIF8pXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IEdyYWRpZW50TGVnZW5kKSB7XG4gICAgICBkb21haW4gPSBzY2FsZS5kb21haW4oKSwgZnJhY3Rpb24gPSBzY2FsZUZyYWN0aW9uKHNjYWxlLCBkb21haW5bMF0sIHBlZWsoZG9tYWluKSk7XG5cbiAgICAgIC8vIGlmIGF1dG9tYXRpYyBsYWJlbCBnZW5lcmF0aW9uIHByb2R1Y2VzIDIgb3IgZmV3ZXIgdmFsdWVzLFxuICAgICAgLy8gdXNlIHRoZSBkb21haW4gZW5kIHBvaW50cyBpbnN0ZWFkIChmaXhlcyB2ZWdhL3ZlZ2EjMTM2NClcbiAgICAgIGlmICh2YWx1ZXMubGVuZ3RoIDwgMyAmJiAhXy52YWx1ZXMgJiYgZG9tYWluWzBdICE9PSBwZWVrKGRvbWFpbikpIHtcbiAgICAgICAgdmFsdWVzID0gW2RvbWFpblswXSwgcGVlayhkb21haW4pXTtcbiAgICAgIH1cbiAgICAgIGl0ZW1zID0gdmFsdWVzLm1hcCgodmFsdWUsIGluZGV4KSA9PiBpbmdlc3Qoe1xuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGxhYmVsOiBmb3JtYXQodmFsdWUsIGluZGV4LCB2YWx1ZXMpLFxuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIHBlcmM6IGZyYWN0aW9uKHZhbHVlKVxuICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzaXplID0gdmFsdWVzLmxlbmd0aCAtIDE7XG4gICAgICBmcmFjdGlvbiA9IGxhYmVsRnJhY3Rpb24oc2NhbGUpO1xuICAgICAgaXRlbXMgPSB2YWx1ZXMubWFwKCh2YWx1ZSwgaW5kZXgpID0+IGluZ2VzdCh7XG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgbGFiZWw6IGZvcm1hdCh2YWx1ZSwgaW5kZXgsIHZhbHVlcyksXG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgcGVyYzogaW5kZXggPyBmcmFjdGlvbih2YWx1ZSkgOiAwLFxuICAgICAgICBwZXJjMjogaW5kZXggPT09IHNpemUgPyAxIDogZnJhY3Rpb24odmFsdWVzW2luZGV4ICsgMV0pXG4gICAgICB9KSk7XG4gICAgfVxuICAgIG91dC5zb3VyY2UgPSBpdGVtcztcbiAgICBvdXQuYWRkID0gaXRlbXM7XG4gICAgdGhpcy52YWx1ZSA9IGl0ZW1zO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG5jb25zdCBzb3VyY2VYID0gdCA9PiB0LnNvdXJjZS54O1xuY29uc3Qgc291cmNlWSA9IHQgPT4gdC5zb3VyY2UueTtcbmNvbnN0IHRhcmdldFggPSB0ID0+IHQudGFyZ2V0Lng7XG5jb25zdCB0YXJnZXRZID0gdCA9PiB0LnRhcmdldC55O1xuXG4vKipcbiAqIExheW91dCBwYXRocyBsaW5raW5nIHNvdXJjZSBhbmQgdGFyZ2V0IGVsZW1lbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIExpbmtQYXRoKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbn1cbkxpbmtQYXRoLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0xpbmtQYXRoJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc291cmNlWCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ3NvdXJjZS54J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc291cmNlWScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ3NvdXJjZS55J1xuICB9LCB7XG4gICAgJ25hbWUnOiAndGFyZ2V0WCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ3RhcmdldC54J1xuICB9LCB7XG4gICAgJ25hbWUnOiAndGFyZ2V0WScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ3RhcmdldC55J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnb3JpZW50JyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICd2ZXJ0aWNhbCcsXG4gICAgJ3ZhbHVlcyc6IFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCcsICdyYWRpYWwnXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2hhcGUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdkZWZhdWx0JzogJ2xpbmUnLFxuICAgICd2YWx1ZXMnOiBbJ2xpbmUnLCAnYXJjJywgJ2N1cnZlJywgJ2RpYWdvbmFsJywgJ29ydGhvZ29uYWwnXVxuICB9LCB7XG4gICAgJ25hbWUnOiAncmVxdWlyZScsXG4gICAgJ3R5cGUnOiAnc2lnbmFsJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAncGF0aCdcbiAgfV1cbn07XG5pbmhlcml0cyhMaW5rUGF0aCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBzeCA9IF8uc291cmNlWCB8fCBzb3VyY2VYLFxuICAgICAgc3kgPSBfLnNvdXJjZVkgfHwgc291cmNlWSxcbiAgICAgIHR4ID0gXy50YXJnZXRYIHx8IHRhcmdldFgsXG4gICAgICB0eSA9IF8udGFyZ2V0WSB8fCB0YXJnZXRZLFxuICAgICAgYXMgPSBfLmFzIHx8ICdwYXRoJyxcbiAgICAgIG9yaWVudCA9IF8ub3JpZW50IHx8ICd2ZXJ0aWNhbCcsXG4gICAgICBzaGFwZSA9IF8uc2hhcGUgfHwgJ2xpbmUnLFxuICAgICAgcGF0aCA9IFBhdGhzLmdldChzaGFwZSArICctJyArIG9yaWVudCkgfHwgUGF0aHMuZ2V0KHNoYXBlKTtcbiAgICBpZiAoIXBhdGgpIHtcbiAgICAgIGVycm9yKCdMaW5rUGF0aCB1bnN1cHBvcnRlZCB0eXBlOiAnICsgXy5zaGFwZSArIChfLm9yaWVudCA/ICctJyArIF8ub3JpZW50IDogJycpKTtcbiAgICB9XG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIHRbYXNdID0gcGF0aChzeCh0KSwgc3kodCksIHR4KHQpLCB0eSh0KSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5jb25zdCBsaW5lID0gKHN4LCBzeSwgdHgsIHR5KSA9PiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0wnICsgdHggKyAnLCcgKyB0eTtcbmNvbnN0IGxpbmVSID0gKHNhLCBzciwgdGEsIHRyKSA9PiBsaW5lKHNyICogTWF0aC5jb3Moc2EpLCBzciAqIE1hdGguc2luKHNhKSwgdHIgKiBNYXRoLmNvcyh0YSksIHRyICogTWF0aC5zaW4odGEpKTtcbmNvbnN0IGFyYyA9IChzeCwgc3ksIHR4LCB0eSkgPT4ge1xuICB2YXIgZHggPSB0eCAtIHN4LFxuICAgIGR5ID0gdHkgLSBzeSxcbiAgICByciA9IE1hdGguaHlwb3QoZHgsIGR5KSAvIDIsXG4gICAgcmEgPSAxODAgKiBNYXRoLmF0YW4yKGR5LCBkeCkgLyBNYXRoLlBJO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdBJyArIHJyICsgJywnICsgcnIgKyAnICcgKyByYSArICcgMCAxJyArICcgJyArIHR4ICsgJywnICsgdHk7XG59O1xuY29uc3QgYXJjUiA9IChzYSwgc3IsIHRhLCB0cikgPT4gYXJjKHNyICogTWF0aC5jb3Moc2EpLCBzciAqIE1hdGguc2luKHNhKSwgdHIgKiBNYXRoLmNvcyh0YSksIHRyICogTWF0aC5zaW4odGEpKTtcbmNvbnN0IGN1cnZlID0gKHN4LCBzeSwgdHgsIHR5KSA9PiB7XG4gIGNvbnN0IGR4ID0gdHggLSBzeCxcbiAgICBkeSA9IHR5IC0gc3ksXG4gICAgaXggPSAwLjIgKiAoZHggKyBkeSksXG4gICAgaXkgPSAwLjIgKiAoZHkgLSBkeCk7XG4gIHJldHVybiAnTScgKyBzeCArICcsJyArIHN5ICsgJ0MnICsgKHN4ICsgaXgpICsgJywnICsgKHN5ICsgaXkpICsgJyAnICsgKHR4ICsgaXkpICsgJywnICsgKHR5IC0gaXgpICsgJyAnICsgdHggKyAnLCcgKyB0eTtcbn07XG5jb25zdCBjdXJ2ZVIgPSAoc2EsIHNyLCB0YSwgdHIpID0+IGN1cnZlKHNyICogTWF0aC5jb3Moc2EpLCBzciAqIE1hdGguc2luKHNhKSwgdHIgKiBNYXRoLmNvcyh0YSksIHRyICogTWF0aC5zaW4odGEpKTtcbmNvbnN0IG9ydGhvWCA9IChzeCwgc3ksIHR4LCB0eSkgPT4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdWJyArIHR5ICsgJ0gnICsgdHg7XG5jb25zdCBvcnRob1kgPSAoc3gsIHN5LCB0eCwgdHkpID0+ICdNJyArIHN4ICsgJywnICsgc3kgKyAnSCcgKyB0eCArICdWJyArIHR5O1xuY29uc3Qgb3J0aG9SID0gKHNhLCBzciwgdGEsIHRyKSA9PiB7XG4gIGNvbnN0IHNjID0gTWF0aC5jb3Moc2EpLFxuICAgIHNzID0gTWF0aC5zaW4oc2EpLFxuICAgIHRjID0gTWF0aC5jb3ModGEpLFxuICAgIHRzID0gTWF0aC5zaW4odGEpLFxuICAgIHNmID0gTWF0aC5hYnModGEgLSBzYSkgPiBNYXRoLlBJID8gdGEgPD0gc2EgOiB0YSA+IHNhO1xuICByZXR1cm4gJ00nICsgc3IgKiBzYyArICcsJyArIHNyICogc3MgKyAnQScgKyBzciArICcsJyArIHNyICsgJyAwIDAsJyArIChzZiA/IDEgOiAwKSArICcgJyArIHNyICogdGMgKyAnLCcgKyBzciAqIHRzICsgJ0wnICsgdHIgKiB0YyArICcsJyArIHRyICogdHM7XG59O1xuY29uc3QgZGlhZ29uYWxYID0gKHN4LCBzeSwgdHgsIHR5KSA9PiB7XG4gIGNvbnN0IG0gPSAoc3ggKyB0eCkgLyAyO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdDJyArIG0gKyAnLCcgKyBzeSArICcgJyArIG0gKyAnLCcgKyB0eSArICcgJyArIHR4ICsgJywnICsgdHk7XG59O1xuY29uc3QgZGlhZ29uYWxZID0gKHN4LCBzeSwgdHgsIHR5KSA9PiB7XG4gIGNvbnN0IG0gPSAoc3kgKyB0eSkgLyAyO1xuICByZXR1cm4gJ00nICsgc3ggKyAnLCcgKyBzeSArICdDJyArIHN4ICsgJywnICsgbSArICcgJyArIHR4ICsgJywnICsgbSArICcgJyArIHR4ICsgJywnICsgdHk7XG59O1xuY29uc3QgZGlhZ29uYWxSID0gKHNhLCBzciwgdGEsIHRyKSA9PiB7XG4gIGNvbnN0IHNjID0gTWF0aC5jb3Moc2EpLFxuICAgIHNzID0gTWF0aC5zaW4oc2EpLFxuICAgIHRjID0gTWF0aC5jb3ModGEpLFxuICAgIHRzID0gTWF0aC5zaW4odGEpLFxuICAgIG1yID0gKHNyICsgdHIpIC8gMjtcbiAgcmV0dXJuICdNJyArIHNyICogc2MgKyAnLCcgKyBzciAqIHNzICsgJ0MnICsgbXIgKiBzYyArICcsJyArIG1yICogc3MgKyAnICcgKyBtciAqIHRjICsgJywnICsgbXIgKiB0cyArICcgJyArIHRyICogdGMgKyAnLCcgKyB0ciAqIHRzO1xufTtcbmNvbnN0IFBhdGhzID0gZmFzdG1hcCh7XG4gICdsaW5lJzogbGluZSxcbiAgJ2xpbmUtcmFkaWFsJzogbGluZVIsXG4gICdhcmMnOiBhcmMsXG4gICdhcmMtcmFkaWFsJzogYXJjUixcbiAgJ2N1cnZlJzogY3VydmUsXG4gICdjdXJ2ZS1yYWRpYWwnOiBjdXJ2ZVIsXG4gICdvcnRob2dvbmFsLWhvcml6b250YWwnOiBvcnRob1gsXG4gICdvcnRob2dvbmFsLXZlcnRpY2FsJzogb3J0aG9ZLFxuICAnb3J0aG9nb25hbC1yYWRpYWwnOiBvcnRob1IsXG4gICdkaWFnb25hbC1ob3Jpem9udGFsJzogZGlhZ29uYWxYLFxuICAnZGlhZ29uYWwtdmVydGljYWwnOiBkaWFnb25hbFksXG4gICdkaWFnb25hbC1yYWRpYWwnOiBkaWFnb25hbFJcbn0pO1xuXG4vKipcbiAqIFBpZSBhbmQgZG9udXQgY2hhcnQgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIHBpZSBzZWdtZW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0YXJ0QW5nbGU9MF0gLSBUaGUgc3RhcnQgYW5nbGUgKGluIHJhZGlhbnMpIG9mIHRoZSBsYXlvdXQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5lbmRBbmdsZT0yz4BdIC0gVGhlIGVuZCBhbmdsZSAoaW4gcmFkaWFucykgb2YgdGhlIGxheW91dC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5zb3J0XSAtIEJvb2xlYW4gZmxhZyBmb3Igc29ydGluZyBzZWN0b3JzIGJ5IHZhbHVlLlxuICovXG5mdW5jdGlvbiBQaWUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5QaWUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUGllJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RhcnRBbmdsZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ2VuZEFuZ2xlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogNi4yODMxODUzMDcxNzk1ODZcbiAgfSwge1xuICAgICduYW1lJzogJ3NvcnQnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbJ3N0YXJ0QW5nbGUnLCAnZW5kQW5nbGUnXVxuICB9XVxufTtcbmluaGVyaXRzKFBpZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBhcyA9IF8uYXMgfHwgWydzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJ10sXG4gICAgICBzdGFydEFuZ2xlID0gYXNbMF0sXG4gICAgICBlbmRBbmdsZSA9IGFzWzFdLFxuICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IG9uZSxcbiAgICAgIHN0YXJ0ID0gXy5zdGFydEFuZ2xlIHx8IDAsXG4gICAgICBzdG9wID0gXy5lbmRBbmdsZSAhPSBudWxsID8gXy5lbmRBbmdsZSA6IDIgKiBNYXRoLlBJLFxuICAgICAgZGF0YSA9IHB1bHNlLnNvdXJjZSxcbiAgICAgIHZhbHVlcyA9IGRhdGEubWFwKGZpZWxkKSxcbiAgICAgIG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgYSA9IHN0YXJ0LFxuICAgICAgayA9IChzdG9wIC0gc3RhcnQpIC8gc3VtKHZhbHVlcyksXG4gICAgICBpbmRleCA9IHJhbmdlKG4pLFxuICAgICAgaSxcbiAgICAgIHQsXG4gICAgICB2O1xuICAgIGlmIChfLnNvcnQpIHtcbiAgICAgIGluZGV4LnNvcnQoKGEsIGIpID0+IHZhbHVlc1thXSAtIHZhbHVlc1tiXSk7XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHYgPSB2YWx1ZXNbaW5kZXhbaV1dO1xuICAgICAgdCA9IGRhdGFbaW5kZXhbaV1dO1xuICAgICAgdFtzdGFydEFuZ2xlXSA9IGE7XG4gICAgICB0W2VuZEFuZ2xlXSA9IGEgKz0gdiAqIGs7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZXM7XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhfLm1vZGlmaWVkKCkpLm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbmNvbnN0IERFRkFVTFRfQ09VTlQgPSA1O1xuZnVuY3Rpb24gaW5jbHVkZVplcm8oc2NhbGUpIHtcbiAgY29uc3QgdHlwZSA9IHNjYWxlLnR5cGU7XG4gIHJldHVybiAhc2NhbGUuYmlucyAmJiAodHlwZSA9PT0gTGluZWFyIHx8IHR5cGUgPT09IFBvdyB8fCB0eXBlID09PSBTcXJ0KTtcbn1cbmZ1bmN0aW9uIGluY2x1ZGVQYWQodHlwZSkge1xuICByZXR1cm4gaXNDb250aW51b3VzKHR5cGUpICYmIHR5cGUgIT09IFNlcXVlbnRpYWw7XG59XG5jb25zdCBTS0lQID0gdG9TZXQoWydzZXQnLCAnbW9kaWZpZWQnLCAnY2xlYXInLCAndHlwZScsICdzY2hlbWUnLCAnc2NoZW1lRXh0ZW50JywgJ3NjaGVtZUNvdW50JywgJ2RvbWFpbicsICdkb21haW5NaW4nLCAnZG9tYWluTWlkJywgJ2RvbWFpbk1heCcsICdkb21haW5SYXcnLCAnZG9tYWluSW1wbGljaXQnLCAnbmljZScsICd6ZXJvJywgJ2JpbnMnLCAncmFuZ2UnLCAncmFuZ2VTdGVwJywgJ3JvdW5kJywgJ3JldmVyc2UnLCAnaW50ZXJwb2xhdGUnLCAnaW50ZXJwb2xhdGVHYW1tYSddKTtcblxuLyoqXG4gKiBNYWludGFpbnMgYSBzY2FsZSBmdW5jdGlvbiBtYXBwaW5nIGRhdGEgdmFsdWVzIHRvIHZpc3VhbCBjaGFubmVscy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5mdW5jdGlvbiBTY2FsZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbiAgdGhpcy5tb2RpZmllZCh0cnVlKTsgLy8gYWx3YXlzIHRyZWF0IGFzIG1vZGlmaWVkXG59XG5pbmhlcml0cyhTY2FsZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBkZiA9IHB1bHNlLmRhdGFmbG93LFxuICAgICAgc2NhbGUkMSA9IHRoaXMudmFsdWUsXG4gICAgICBrZXkgPSBzY2FsZUtleShfKTtcbiAgICBpZiAoIXNjYWxlJDEgfHwga2V5ICE9PSBzY2FsZSQxLnR5cGUpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBzY2FsZSQxID0gc2NhbGUoa2V5KSgpO1xuICAgIH1cbiAgICBmb3IgKGtleSBpbiBfKSBpZiAoIVNLSVBba2V5XSkge1xuICAgICAgLy8gcGFkZGluZyBpcyBhIHNjYWxlIHByb3BlcnR5IGZvciBiYW5kL3BvaW50IGJ1dCBub3Qgb3RoZXJzXG4gICAgICBpZiAoa2V5ID09PSAncGFkZGluZycgJiYgaW5jbHVkZVBhZChzY2FsZSQxLnR5cGUpKSBjb250aW51ZTtcbiAgICAgIC8vIGludm9rZSBzY2FsZSBwcm9wZXJ0eSBzZXR0ZXIsIHJhaXNlIHdhcm5pbmcgaWYgbm90IGZvdW5kXG4gICAgICBpc0Z1bmN0aW9uKHNjYWxlJDFba2V5XSkgPyBzY2FsZSQxW2tleV0oX1trZXldKSA6IGRmLndhcm4oJ1Vuc3VwcG9ydGVkIHNjYWxlIHByb3BlcnR5OiAnICsga2V5KTtcbiAgICB9XG4gICAgY29uZmlndXJlUmFuZ2Uoc2NhbGUkMSwgXywgY29uZmlndXJlQmlucyhzY2FsZSQxLCBfLCBjb25maWd1cmVEb21haW4oc2NhbGUkMSwgXywgZGYpKSk7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBzY2FsZUtleShfKSB7XG4gIHZhciB0ID0gXy50eXBlLFxuICAgIGQgPSAnJyxcbiAgICBuO1xuXG4gIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHByZSBWZWdhIDUuXG4gIGlmICh0ID09PSBTZXF1ZW50aWFsKSByZXR1cm4gU2VxdWVudGlhbCArICctJyArIExpbmVhcjtcbiAgaWYgKGlzQ29udGludW91c0NvbG9yKF8pKSB7XG4gICAgbiA9IF8ucmF3RG9tYWluID8gXy5yYXdEb21haW4ubGVuZ3RoIDogXy5kb21haW4gPyBfLmRvbWFpbi5sZW5ndGggKyArKF8uZG9tYWluTWlkICE9IG51bGwpIDogMDtcbiAgICBkID0gbiA9PT0gMiA/IFNlcXVlbnRpYWwgKyAnLScgOiBuID09PSAzID8gRGl2ZXJnaW5nICsgJy0nIDogJyc7XG4gIH1cbiAgcmV0dXJuIChkICsgdCB8fCBMaW5lYXIpLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXNDb2xvcihfKSB7XG4gIGNvbnN0IHQgPSBfLnR5cGU7XG4gIHJldHVybiBpc0NvbnRpbnVvdXModCkgJiYgdCAhPT0gVGltZSAmJiB0ICE9PSBVVEMgJiYgKF8uc2NoZW1lIHx8IF8ucmFuZ2UgJiYgXy5yYW5nZS5sZW5ndGggJiYgXy5yYW5nZS5ldmVyeShpc1N0cmluZykpO1xufVxuZnVuY3Rpb24gY29uZmlndXJlRG9tYWluKHNjYWxlLCBfLCBkZikge1xuICAvLyBjaGVjayByYXcgZG9tYWluLCBpZiBwcm92aWRlZCB1c2UgdGhhdCBhbmQgZXhpdCBlYXJseVxuICBjb25zdCByYXcgPSByYXdEb21haW4oc2NhbGUsIF8uZG9tYWluUmF3LCBkZik7XG4gIGlmIChyYXcgPiAtMSkgcmV0dXJuIHJhdztcbiAgdmFyIGRvbWFpbiA9IF8uZG9tYWluLFxuICAgIHR5cGUgPSBzY2FsZS50eXBlLFxuICAgIHplcm8gPSBfLnplcm8gfHwgXy56ZXJvID09PSB1bmRlZmluZWQgJiYgaW5jbHVkZVplcm8oc2NhbGUpLFxuICAgIG4sXG4gICAgbWlkO1xuICBpZiAoIWRvbWFpbikgcmV0dXJuIDA7XG5cbiAgLy8gYWRqdXN0IGRvbWFpbiBiYXNlZCBvbiB6ZXJvLCBtaW4sIG1heCBzZXR0aW5nc1xuICBpZiAoemVybyB8fCBfLmRvbWFpbk1pbiAhPSBudWxsIHx8IF8uZG9tYWluTWF4ICE9IG51bGwgfHwgXy5kb21haW5NaWQgIT0gbnVsbCkge1xuICAgIG4gPSAoZG9tYWluID0gZG9tYWluLnNsaWNlKCkpLmxlbmd0aCAtIDEgfHwgMTtcbiAgICBpZiAoemVybykge1xuICAgICAgaWYgKGRvbWFpblswXSA+IDApIGRvbWFpblswXSA9IDA7XG4gICAgICBpZiAoZG9tYWluW25dIDwgMCkgZG9tYWluW25dID0gMDtcbiAgICB9XG4gICAgaWYgKF8uZG9tYWluTWluICE9IG51bGwpIGRvbWFpblswXSA9IF8uZG9tYWluTWluO1xuICAgIGlmIChfLmRvbWFpbk1heCAhPSBudWxsKSBkb21haW5bbl0gPSBfLmRvbWFpbk1heDtcbiAgICBpZiAoXy5kb21haW5NaWQgIT0gbnVsbCkge1xuICAgICAgbWlkID0gXy5kb21haW5NaWQ7XG4gICAgICBjb25zdCBpID0gbWlkID4gZG9tYWluW25dID8gbiArIDEgOiBtaWQgPCBkb21haW5bMF0gPyAwIDogbjtcbiAgICAgIGlmIChpICE9PSBuKSBkZi53YXJuKCdTY2FsZSBkb21haW5NaWQgZXhjZWVkcyBkb21haW4gbWluIG9yIG1heC4nLCBtaWQpO1xuICAgICAgZG9tYWluLnNwbGljZShpLCAwLCBtaWQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGFkanVzdCBjb250aW51b3VzIGRvbWFpbiBmb3IgbWluaW11bSBwaXhlbCBwYWRkaW5nXG4gIGlmIChpbmNsdWRlUGFkKHR5cGUpICYmIF8ucGFkZGluZyAmJiBkb21haW5bMF0gIT09IHBlZWsoZG9tYWluKSkge1xuICAgIGRvbWFpbiA9IHBhZERvbWFpbih0eXBlLCBkb21haW4sIF8ucmFuZ2UsIF8ucGFkZGluZywgXy5leHBvbmVudCwgXy5jb25zdGFudCk7XG4gIH1cblxuICAvLyBzZXQgdGhlIHNjYWxlIGRvbWFpblxuICBzY2FsZS5kb21haW4oZG9tYWluQ2hlY2sodHlwZSwgZG9tYWluLCBkZikpO1xuXG4gIC8vIGlmIG9yZGluYWwgc2NhbGUgZG9tYWluIGlzIGRlZmluZWQsIHByZXZlbnQgaW1wbGljaXRcbiAgLy8gZG9tYWluIGNvbnN0cnVjdGlvbiBhcyBzaWRlLWVmZmVjdCBvZiBzY2FsZSBsb29rdXBcbiAgaWYgKHR5cGUgPT09IE9yZGluYWwpIHtcbiAgICBzY2FsZS51bmtub3duKF8uZG9tYWluSW1wbGljaXQgPyBzY2FsZUltcGxpY2l0IDogdW5kZWZpbmVkKTtcbiAgfVxuXG4gIC8vIHBlcmZvcm0gJ25pY2UnIGFkanVzdG1lbnQgYXMgcmVxdWVzdGVkXG4gIGlmIChfLm5pY2UgJiYgc2NhbGUubmljZSkge1xuICAgIHNjYWxlLm5pY2UoXy5uaWNlICE9PSB0cnVlICYmIHRpY2tDb3VudChzY2FsZSwgXy5uaWNlKSB8fCBudWxsKTtcbiAgfVxuXG4gIC8vIHJldHVybiB0aGUgY2FyZGluYWxpdHkgb2YgdGhlIGRvbWFpblxuICByZXR1cm4gZG9tYWluLmxlbmd0aDtcbn1cbmZ1bmN0aW9uIHJhd0RvbWFpbihzY2FsZSwgcmF3LCBkZikge1xuICBpZiAocmF3KSB7XG4gICAgc2NhbGUuZG9tYWluKGRvbWFpbkNoZWNrKHNjYWxlLnR5cGUsIHJhdywgZGYpKTtcbiAgICByZXR1cm4gcmF3Lmxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gLTE7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhZERvbWFpbih0eXBlLCBkb21haW4sIHJhbmdlLCBwYWQsIGV4cG9uZW50LCBjb25zdGFudCkge1xuICB2YXIgc3BhbiA9IE1hdGguYWJzKHBlZWsocmFuZ2UpIC0gcmFuZ2VbMF0pLFxuICAgIGZyYWMgPSBzcGFuIC8gKHNwYW4gLSAyICogcGFkKSxcbiAgICBkID0gdHlwZSA9PT0gTG9nID8gem9vbUxvZyhkb21haW4sIG51bGwsIGZyYWMpIDogdHlwZSA9PT0gU3FydCA/IHpvb21Qb3coZG9tYWluLCBudWxsLCBmcmFjLCAwLjUpIDogdHlwZSA9PT0gUG93ID8gem9vbVBvdyhkb21haW4sIG51bGwsIGZyYWMsIGV4cG9uZW50IHx8IDEpIDogdHlwZSA9PT0gU3ltbG9nID8gem9vbVN5bWxvZyhkb21haW4sIG51bGwsIGZyYWMsIGNvbnN0YW50IHx8IDEpIDogem9vbUxpbmVhcihkb21haW4sIG51bGwsIGZyYWMpO1xuICBkb21haW4gPSBkb21haW4uc2xpY2UoKTtcbiAgZG9tYWluWzBdID0gZFswXTtcbiAgZG9tYWluW2RvbWFpbi5sZW5ndGggLSAxXSA9IGRbMV07XG4gIHJldHVybiBkb21haW47XG59XG5mdW5jdGlvbiBkb21haW5DaGVjayh0eXBlLCBkb21haW4sIGRmKSB7XG4gIGlmIChpc0xvZ2FyaXRobWljKHR5cGUpKSB7XG4gICAgLy8gc3VtIHNpZ25zIG9mIGRvbWFpbiB2YWx1ZXNcbiAgICAvLyBpZiBhbGwgcG9zIG9yIGFsbCBuZWcsIGFicyhzdW0pID09PSBkb21haW4ubGVuZ3RoXG4gICAgdmFyIHMgPSBNYXRoLmFicyhkb21haW4ucmVkdWNlKChzLCB2KSA9PiBzICsgKHYgPCAwID8gLTEgOiB2ID4gMCA/IDEgOiAwKSwgMCkpO1xuICAgIGlmIChzICE9PSBkb21haW4ubGVuZ3RoKSB7XG4gICAgICBkZi53YXJuKCdMb2cgc2NhbGUgZG9tYWluIGluY2x1ZGVzIHplcm86ICcgKyBzdHJpbmdWYWx1ZShkb21haW4pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRvbWFpbjtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZUJpbnMoc2NhbGUsIF8sIGNvdW50KSB7XG4gIGxldCBiaW5zID0gXy5iaW5zO1xuICBpZiAoYmlucyAmJiAhaXNBcnJheShiaW5zKSkge1xuICAgIC8vIGdlbmVyYXRlIGJpbiBib3VuZGFyeSBhcnJheVxuICAgIGNvbnN0IGRvbWFpbiA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgbG8gPSBkb21haW5bMF0sXG4gICAgICBoaSA9IHBlZWsoZG9tYWluKSxcbiAgICAgIHN0ZXAgPSBiaW5zLnN0ZXA7XG4gICAgbGV0IHN0YXJ0ID0gYmlucy5zdGFydCA9PSBudWxsID8gbG8gOiBiaW5zLnN0YXJ0LFxuICAgICAgc3RvcCA9IGJpbnMuc3RvcCA9PSBudWxsID8gaGkgOiBiaW5zLnN0b3A7XG4gICAgaWYgKCFzdGVwKSBlcnJvcignU2NhbGUgYmlucyBwYXJhbWV0ZXIgbWlzc2luZyBzdGVwIHByb3BlcnR5LicpO1xuICAgIGlmIChzdGFydCA8IGxvKSBzdGFydCA9IHN0ZXAgKiBNYXRoLmNlaWwobG8gLyBzdGVwKTtcbiAgICBpZiAoc3RvcCA+IGhpKSBzdG9wID0gc3RlcCAqIE1hdGguZmxvb3IoaGkgLyBzdGVwKTtcbiAgICBiaW5zID0gcmFuZ2Uoc3RhcnQsIHN0b3AgKyBzdGVwIC8gMiwgc3RlcCk7XG4gIH1cbiAgaWYgKGJpbnMpIHtcbiAgICAvLyBhc3NpZ24gYmluIGJvdW5kYXJpZXMgdG8gc2NhbGUgaW5zdGFuY2VcbiAgICBzY2FsZS5iaW5zID0gYmlucztcbiAgfSBlbHNlIGlmIChzY2FsZS5iaW5zKSB7XG4gICAgLy8gbm8gY3VycmVudCBiaW5zLCByZW1vdmUgYmlucyBpZiBwcmV2aW91c2x5IHNldFxuICAgIGRlbGV0ZSBzY2FsZS5iaW5zO1xuICB9XG5cbiAgLy8gc3BlY2lhbCBoYW5kbGluZyBmb3IgYmluLW9yZGluYWwgc2NhbGVzXG4gIGlmIChzY2FsZS50eXBlID09PSBCaW5PcmRpbmFsKSB7XG4gICAgaWYgKCFiaW5zKSB7XG4gICAgICAvLyB0aGUgZG9tYWluIHNwZWNpZmllcyB0aGUgYmluc1xuICAgICAgc2NhbGUuYmlucyA9IHNjYWxlLmRvbWFpbigpO1xuICAgIH0gZWxzZSBpZiAoIV8uZG9tYWluICYmICFfLmRvbWFpblJhdykge1xuICAgICAgLy8gdGhlIGJpbnMgc3BlY2lmeSB0aGUgZG9tYWluXG4gICAgICBzY2FsZS5kb21haW4oYmlucyk7XG4gICAgICBjb3VudCA9IGJpbnMubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIC8vIHJldHVybiBkb21haW4gY2FyZGluYWxpdHlcbiAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gY29uZmlndXJlUmFuZ2Uoc2NhbGUsIF8sIGNvdW50KSB7XG4gIHZhciB0eXBlID0gc2NhbGUudHlwZSxcbiAgICByb3VuZCA9IF8ucm91bmQgfHwgZmFsc2UsXG4gICAgcmFuZ2UgPSBfLnJhbmdlO1xuXG4gIC8vIGlmIHJhbmdlIHN0ZXAgc3BlY2lmaWVkLCBjYWxjdWxhdGUgZnVsbCByYW5nZSBleHRlbnRcbiAgaWYgKF8ucmFuZ2VTdGVwICE9IG51bGwpIHtcbiAgICByYW5nZSA9IGNvbmZpZ3VyZVJhbmdlU3RlcCh0eXBlLCBfLCBjb3VudCk7XG4gIH1cblxuICAvLyBlbHNlIGlmIGEgcmFuZ2Ugc2NoZW1lIGlzIGRlZmluZWQsIHVzZSB0aGF0XG4gIGVsc2UgaWYgKF8uc2NoZW1lKSB7XG4gICAgcmFuZ2UgPSBjb25maWd1cmVTY2hlbWUodHlwZSwgXywgY291bnQpO1xuICAgIGlmIChpc0Z1bmN0aW9uKHJhbmdlKSkge1xuICAgICAgaWYgKHNjYWxlLmludGVycG9sYXRvcikge1xuICAgICAgICByZXR1cm4gc2NhbGUuaW50ZXJwb2xhdG9yKHJhbmdlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKGBTY2FsZSB0eXBlICR7dHlwZX0gZG9lcyBub3Qgc3VwcG9ydCBpbnRlcnBvbGF0aW5nIGNvbG9yIHNjaGVtZXMuYCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gZ2l2ZW4gYSByYW5nZSBhcnJheSBmb3IgYW4gaW50ZXJwb2xhdGluZyBzY2FsZSwgY29udmVydCB0byBpbnRlcnBvbGF0b3JcbiAgaWYgKHJhbmdlICYmIGlzSW50ZXJwb2xhdGluZyh0eXBlKSkge1xuICAgIHJldHVybiBzY2FsZS5pbnRlcnBvbGF0b3IoaW50ZXJwb2xhdGVDb2xvcnMoZmxpcChyYW5nZSwgXy5yZXZlcnNlKSwgXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKSk7XG4gIH1cblxuICAvLyBjb25maWd1cmUgcm91bmRpbmcgLyBpbnRlcnBvbGF0aW9uXG4gIGlmIChyYW5nZSAmJiBfLmludGVycG9sYXRlICYmIHNjYWxlLmludGVycG9sYXRlKSB7XG4gICAgc2NhbGUuaW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUoXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKSk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzY2FsZS5yb3VuZCkpIHtcbiAgICBzY2FsZS5yb3VuZChyb3VuZCk7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihzY2FsZS5yYW5nZVJvdW5kKSkge1xuICAgIHNjYWxlLmludGVycG9sYXRlKHJvdW5kID8gaW50ZXJwb2xhdGVSb3VuZCA6IGludGVycG9sYXRlJDEpO1xuICB9XG4gIGlmIChyYW5nZSkgc2NhbGUucmFuZ2UoZmxpcChyYW5nZSwgXy5yZXZlcnNlKSk7XG59XG5mdW5jdGlvbiBjb25maWd1cmVSYW5nZVN0ZXAodHlwZSwgXywgY291bnQpIHtcbiAgaWYgKHR5cGUgIT09IEJhbmQgJiYgdHlwZSAhPT0gUG9pbnQpIHtcbiAgICBlcnJvcignT25seSBiYW5kIGFuZCBwb2ludCBzY2FsZXMgc3VwcG9ydCByYW5nZVN0ZXAuJyk7XG4gIH1cblxuICAvLyBjYWxjdWxhdGUgZnVsbCByYW5nZSBiYXNlZCBvbiByZXF1ZXN0ZWQgc3RlcCBzaXplIGFuZCBwYWRkaW5nXG4gIHZhciBvdXRlciA9IChfLnBhZGRpbmdPdXRlciAhPSBudWxsID8gXy5wYWRkaW5nT3V0ZXIgOiBfLnBhZGRpbmcpIHx8IDAsXG4gICAgaW5uZXIgPSB0eXBlID09PSBQb2ludCA/IDEgOiAoXy5wYWRkaW5nSW5uZXIgIT0gbnVsbCA/IF8ucGFkZGluZ0lubmVyIDogXy5wYWRkaW5nKSB8fCAwO1xuICByZXR1cm4gWzAsIF8ucmFuZ2VTdGVwICogYmFuZFNwYWNlKGNvdW50LCBpbm5lciwgb3V0ZXIpXTtcbn1cbmZ1bmN0aW9uIGNvbmZpZ3VyZVNjaGVtZSh0eXBlLCBfLCBjb3VudCkge1xuICB2YXIgZXh0ZW50ID0gXy5zY2hlbWVFeHRlbnQsXG4gICAgbmFtZSxcbiAgICBzY2hlbWUkMTtcbiAgaWYgKGlzQXJyYXkoXy5zY2hlbWUpKSB7XG4gICAgc2NoZW1lJDEgPSBpbnRlcnBvbGF0ZUNvbG9ycyhfLnNjaGVtZSwgXy5pbnRlcnBvbGF0ZSwgXy5pbnRlcnBvbGF0ZUdhbW1hKTtcbiAgfSBlbHNlIHtcbiAgICBuYW1lID0gXy5zY2hlbWUudG9Mb3dlckNhc2UoKTtcbiAgICBzY2hlbWUkMSA9IHNjaGVtZShuYW1lKTtcbiAgICBpZiAoIXNjaGVtZSQxKSBlcnJvcihgVW5yZWNvZ25pemVkIHNjaGVtZSBuYW1lOiAke18uc2NoZW1lfWApO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHNpemUgZm9yIHBvdGVudGlhbCBkaXNjcmV0ZSByYW5nZVxuICBjb3VudCA9IHR5cGUgPT09IFRocmVzaG9sZCA/IGNvdW50ICsgMSA6IHR5cGUgPT09IEJpbk9yZGluYWwgPyBjb3VudCAtIDEgOiB0eXBlID09PSBRdWFudGlsZSB8fCB0eXBlID09PSBRdWFudGl6ZSA/ICtfLnNjaGVtZUNvdW50IHx8IERFRkFVTFRfQ09VTlQgOiBjb3VudDtcblxuICAvLyBhZGp1c3QgYW5kL29yIHF1YW50aXplIHNjaGVtZSBhcyBhcHByb3ByaWF0ZVxuICByZXR1cm4gaXNJbnRlcnBvbGF0aW5nKHR5cGUpID8gYWRqdXN0U2NoZW1lKHNjaGVtZSQxLCBleHRlbnQsIF8ucmV2ZXJzZSkgOiBpc0Z1bmN0aW9uKHNjaGVtZSQxKSA/IHF1YW50aXplSW50ZXJwb2xhdG9yKGFkanVzdFNjaGVtZShzY2hlbWUkMSwgZXh0ZW50KSwgY291bnQpIDogdHlwZSA9PT0gT3JkaW5hbCA/IHNjaGVtZSQxIDogc2NoZW1lJDEuc2xpY2UoMCwgY291bnQpO1xufVxuZnVuY3Rpb24gYWRqdXN0U2NoZW1lKHNjaGVtZSwgZXh0ZW50LCByZXZlcnNlKSB7XG4gIHJldHVybiBpc0Z1bmN0aW9uKHNjaGVtZSkgJiYgKGV4dGVudCB8fCByZXZlcnNlKSA/IGludGVycG9sYXRlUmFuZ2Uoc2NoZW1lLCBmbGlwKGV4dGVudCB8fCBbMCwgMV0sIHJldmVyc2UpKSA6IHNjaGVtZTtcbn1cbmZ1bmN0aW9uIGZsaXAoYXJyYXksIHJldmVyc2UpIHtcbiAgcmV0dXJuIHJldmVyc2UgPyBhcnJheS5zbGljZSgpLnJldmVyc2UoKSA6IGFycmF5O1xufVxuXG4vKipcbiAqIFNvcnRzIHNjZW5lZ3JhcGggaXRlbXMgaW4gdGhlIHB1bHNlIHNvdXJjZSBhcnJheS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBIGNvbXBhcmF0b3JcbiAqICAgZnVuY3Rpb24gZm9yIHNvcnRpbmcgdHVwbGVzLlxuICovXG5mdW5jdGlvbiBTb3J0SXRlbXMocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhTb3J0SXRlbXMsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCdzb3J0JykgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5BREQpIHx8IHB1bHNlLm1vZGlmaWVkKF8uc29ydC5maWVsZHMpIHx8IHB1bHNlLm1vZGlmaWVkKCdkYXR1bScpO1xuICAgIGlmIChtb2QpIHB1bHNlLnNvdXJjZS5zb3J0KHN0YWJsZUNvbXBhcmUoXy5zb3J0KSk7XG4gICAgdGhpcy5tb2RpZmllZChtb2QpO1xuICAgIHJldHVybiBwdWxzZTtcbiAgfVxufSk7XG5cbmNvbnN0IFplcm8gPSAnemVybycsXG4gIENlbnRlciA9ICdjZW50ZXInLFxuICBOb3JtYWxpemUgPSAnbm9ybWFsaXplJyxcbiAgRGVmT3V0cHV0ID0gWyd5MCcsICd5MSddO1xuXG4vKipcbiAqIFN0YWNrIGxheW91dCBmb3IgdmlzdWFsaXphdGlvbiBlbGVtZW50cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgdmFsdWUgZmllbGQgdG8gc3RhY2suXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCxvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBIGNvbXBhcmF0b3IgZm9yIHN0YWNrIHNvcnRpbmcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW29mZnNldD0nemVybyddIC0gU3RhY2sgYmFzZWxpbmUgb2Zmc2V0LiBPbmUgb2YgJ3plcm8nLCAnY2VudGVyJywgJ25vcm1hbGl6ZScuXG4gKi9cbmZ1bmN0aW9uIFN0YWNrKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuU3RhY2suRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnU3RhY2snLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ29mZnNldCcsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2RlZmF1bHQnOiBaZXJvLFxuICAgICd2YWx1ZXMnOiBbWmVybywgQ2VudGVyLCBOb3JtYWxpemVdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogRGVmT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoU3RhY2ssIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgYXMgPSBfLmFzIHx8IERlZk91dHB1dCxcbiAgICAgIHkwID0gYXNbMF0sXG4gICAgICB5MSA9IGFzWzFdLFxuICAgICAgc29ydCA9IHN0YWJsZUNvbXBhcmUoXy5zb3J0KSxcbiAgICAgIGZpZWxkID0gXy5maWVsZCB8fCBvbmUsXG4gICAgICBzdGFjayA9IF8ub2Zmc2V0ID09PSBDZW50ZXIgPyBzdGFja0NlbnRlciA6IF8ub2Zmc2V0ID09PSBOb3JtYWxpemUgPyBzdGFja05vcm1hbGl6ZSA6IHN0YWNrWmVybyxcbiAgICAgIGdyb3VwcyxcbiAgICAgIGksXG4gICAgICBuLFxuICAgICAgbWF4O1xuXG4gICAgLy8gcGFydGl0aW9uLCBzdW0sIGFuZCBzb3J0IHRoZSBzdGFjayBncm91cHNcbiAgICBncm91cHMgPSBwYXJ0aXRpb24ocHVsc2Uuc291cmNlLCBfLmdyb3VwYnksIHNvcnQsIGZpZWxkKTtcblxuICAgIC8vIGNvbXB1dGUgc3RhY2sgbGF5b3V0cyBwZXIgZ3JvdXBcbiAgICBmb3IgKGkgPSAwLCBuID0gZ3JvdXBzLmxlbmd0aCwgbWF4ID0gZ3JvdXBzLm1heDsgaSA8IG47ICsraSkge1xuICAgICAgc3RhY2soZ3JvdXBzW2ldLCBtYXgsIGZpZWxkLCB5MCwgeTEpO1xuICAgIH1cbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG59KTtcbmZ1bmN0aW9uIHN0YWNrQ2VudGVyKGdyb3VwLCBtYXgsIGZpZWxkLCB5MCwgeTEpIHtcbiAgdmFyIGxhc3QgPSAobWF4IC0gZ3JvdXAuc3VtKSAvIDIsXG4gICAgbSA9IGdyb3VwLmxlbmd0aCxcbiAgICBqID0gMCxcbiAgICB0O1xuICBmb3IgKDsgaiA8IG07ICsraikge1xuICAgIHQgPSBncm91cFtqXTtcbiAgICB0W3kwXSA9IGxhc3Q7XG4gICAgdFt5MV0gPSBsYXN0ICs9IE1hdGguYWJzKGZpZWxkKHQpKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhY2tOb3JtYWxpemUoZ3JvdXAsIG1heCwgZmllbGQsIHkwLCB5MSkge1xuICB2YXIgc2NhbGUgPSAxIC8gZ3JvdXAuc3VtLFxuICAgIGxhc3QgPSAwLFxuICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgaiA9IDAsXG4gICAgdiA9IDAsXG4gICAgdDtcbiAgZm9yICg7IGogPCBtOyArK2opIHtcbiAgICB0ID0gZ3JvdXBbal07XG4gICAgdFt5MF0gPSBsYXN0O1xuICAgIHRbeTFdID0gbGFzdCA9IHNjYWxlICogKHYgKz0gTWF0aC5hYnMoZmllbGQodCkpKTtcbiAgfVxufVxuZnVuY3Rpb24gc3RhY2taZXJvKGdyb3VwLCBtYXgsIGZpZWxkLCB5MCwgeTEpIHtcbiAgdmFyIGxhc3RQb3MgPSAwLFxuICAgIGxhc3ROZWcgPSAwLFxuICAgIG0gPSBncm91cC5sZW5ndGgsXG4gICAgaiA9IDAsXG4gICAgdixcbiAgICB0O1xuICBmb3IgKDsgaiA8IG07ICsraikge1xuICAgIHQgPSBncm91cFtqXTtcbiAgICB2ID0gK2ZpZWxkKHQpO1xuICAgIGlmICh2IDwgMCkge1xuICAgICAgdFt5MF0gPSBsYXN0TmVnO1xuICAgICAgdFt5MV0gPSBsYXN0TmVnICs9IHY7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRbeTBdID0gbGFzdFBvcztcbiAgICAgIHRbeTFdID0gbGFzdFBvcyArPSB2O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIHNvcnQsIGZpZWxkKSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICBnZXQgPSBmID0+IGYodCksXG4gICAgbWFwLFxuICAgIGksXG4gICAgbixcbiAgICBtLFxuICAgIHQsXG4gICAgayxcbiAgICBnLFxuICAgIHMsXG4gICAgbWF4O1xuXG4gIC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YS5zbGljZSgpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKG1hcCA9IHt9LCBpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ID0gZGF0YVtpXTtcbiAgICAgIGsgPSBncm91cGJ5Lm1hcChnZXQpO1xuICAgICAgZyA9IG1hcFtrXTtcbiAgICAgIGlmICghZykge1xuICAgICAgICBtYXBba10gPSBnID0gW107XG4gICAgICAgIGdyb3Vwcy5wdXNoKGcpO1xuICAgICAgfVxuICAgICAgZy5wdXNoKHQpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNvbXB1dGUgc3VtcyBvZiBncm91cHMsIHNvcnQgZ3JvdXBzIGFzIG5lZWRlZFxuICBmb3IgKGsgPSAwLCBtYXggPSAwLCBtID0gZ3JvdXBzLmxlbmd0aDsgayA8IG07ICsraykge1xuICAgIGcgPSBncm91cHNba107XG4gICAgZm9yIChpID0gMCwgcyA9IDAsIG4gPSBnLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgcyArPSBNYXRoLmFicyhmaWVsZChnW2ldKSk7XG4gICAgfVxuICAgIGcuc3VtID0gcztcbiAgICBpZiAocyA+IG1heCkgbWF4ID0gcztcbiAgICBpZiAoc29ydCkgZy5zb3J0KHNvcnQpO1xuICB9XG4gIGdyb3Vwcy5tYXggPSBtYXg7XG4gIHJldHVybiBncm91cHM7XG59XG5cbmV4cG9ydCB7IEF4aXNUaWNrcyBhcyBheGlzdGlja3MsIERhdGFKb2luIGFzIGRhdGFqb2luLCBFbmNvZGUgYXMgZW5jb2RlLCBMZWdlbmRFbnRyaWVzIGFzIGxlZ2VuZGVudHJpZXMsIExpbmtQYXRoIGFzIGxpbmtwYXRoLCBQaWUgYXMgcGllLCBTY2FsZSBhcyBzY2FsZSwgU29ydEl0ZW1zIGFzIHNvcnRpdGVtcywgU3RhY2sgYXMgc3RhY2sgfTtcbiIsImNvbnN0IFZJRVcgPSAndmlldycsXG4gIExCUkFDSyA9ICdbJyxcbiAgUkJSQUNLID0gJ10nLFxuICBMQlJBQ0UgPSAneycsXG4gIFJCUkFDRSA9ICd9JyxcbiAgQ09MT04gPSAnOicsXG4gIENPTU1BID0gJywnLFxuICBOQU1FID0gJ0AnLFxuICBHVCA9ICc+JyxcbiAgSUxMRUdBTCA9IC9bW1xcXXt9XS8sXG4gIERFRkFVTFRfTUFSS1MgPSB7XG4gICAgJyonOiAxLFxuICAgIGFyYzogMSxcbiAgICBhcmVhOiAxLFxuICAgIGdyb3VwOiAxLFxuICAgIGltYWdlOiAxLFxuICAgIGxpbmU6IDEsXG4gICAgcGF0aDogMSxcbiAgICByZWN0OiAxLFxuICAgIHJ1bGU6IDEsXG4gICAgc2hhcGU6IDEsXG4gICAgc3ltYm9sOiAxLFxuICAgIHRleHQ6IDEsXG4gICAgdHJhaWw6IDFcbiAgfTtcbmxldCBERUZBVUxUX1NPVVJDRSwgTUFSS1M7XG5cbi8qKlxuICogUGFyc2UgYW4gZXZlbnQgc2VsZWN0b3Igc3RyaW5nLlxuICogUmV0dXJucyBhbiBhcnJheSBvZiBldmVudCBzdHJlYW0gZGVmaW5pdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50U2VsZWN0b3IgKHNlbGVjdG9yLCBzb3VyY2UsIG1hcmtzKSB7XG4gIERFRkFVTFRfU09VUkNFID0gc291cmNlIHx8IFZJRVc7XG4gIE1BUktTID0gbWFya3MgfHwgREVGQVVMVF9NQVJLUztcbiAgcmV0dXJuIHBhcnNlTWVyZ2Uoc2VsZWN0b3IudHJpbSgpKS5tYXAocGFyc2VTZWxlY3Rvcik7XG59XG5mdW5jdGlvbiBpc01hcmtUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIE1BUktTW3R5cGVdO1xufVxuZnVuY3Rpb24gZmluZChzLCBpLCBlbmRDaGFyLCBwdXNoQ2hhciwgcG9wQ2hhcikge1xuICBjb25zdCBuID0gcy5sZW5ndGg7XG4gIGxldCBjb3VudCA9IDAsXG4gICAgYztcbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBjID0gc1tpXTtcbiAgICBpZiAoIWNvdW50ICYmIGMgPT09IGVuZENoYXIpIHJldHVybiBpO2Vsc2UgaWYgKHBvcENoYXIgJiYgcG9wQ2hhci5pbmRleE9mKGMpID49IDApIC0tY291bnQ7ZWxzZSBpZiAocHVzaENoYXIgJiYgcHVzaENoYXIuaW5kZXhPZihjKSA+PSAwKSArK2NvdW50O1xuICB9XG4gIHJldHVybiBpO1xufVxuZnVuY3Rpb24gcGFyc2VNZXJnZShzKSB7XG4gIGNvbnN0IG91dHB1dCA9IFtdLFxuICAgIG4gPSBzLmxlbmd0aDtcbiAgbGV0IHN0YXJ0ID0gMCxcbiAgICBpID0gMDtcbiAgd2hpbGUgKGkgPCBuKSB7XG4gICAgaSA9IGZpbmQocywgaSwgQ09NTUEsIExCUkFDSyArIExCUkFDRSwgUkJSQUNLICsgUkJSQUNFKTtcbiAgICBvdXRwdXQucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBzdGFydCA9ICsraTtcbiAgfVxuICBpZiAob3V0cHV0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93ICdFbXB0eSBldmVudCBzZWxlY3RvcjogJyArIHM7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cbmZ1bmN0aW9uIHBhcnNlU2VsZWN0b3Iocykge1xuICByZXR1cm4gc1swXSA9PT0gJ1snID8gcGFyc2VCZXR3ZWVuKHMpIDogcGFyc2VTdHJlYW0ocyk7XG59XG5mdW5jdGlvbiBwYXJzZUJldHdlZW4ocykge1xuICBjb25zdCBuID0gcy5sZW5ndGg7XG4gIGxldCBpID0gMSxcbiAgICBiO1xuICBpID0gZmluZChzLCBpLCBSQlJBQ0ssIExCUkFDSywgUkJSQUNLKTtcbiAgaWYgKGkgPT09IG4pIHtcbiAgICB0aHJvdyAnRW1wdHkgYmV0d2VlbiBzZWxlY3RvcjogJyArIHM7XG4gIH1cbiAgYiA9IHBhcnNlTWVyZ2Uocy5zdWJzdHJpbmcoMSwgaSkpO1xuICBpZiAoYi5sZW5ndGggIT09IDIpIHtcbiAgICB0aHJvdyAnQmV0d2VlbiBzZWxlY3RvciBtdXN0IGhhdmUgdHdvIGVsZW1lbnRzOiAnICsgcztcbiAgfVxuICBzID0gcy5zbGljZShpICsgMSkudHJpbSgpO1xuICBpZiAoc1swXSAhPT0gR1QpIHtcbiAgICB0aHJvdyAnRXhwZWN0ZWQgXFwnPlxcJyBhZnRlciBiZXR3ZWVuIHNlbGVjdG9yOiAnICsgcztcbiAgfVxuICBiID0gYi5tYXAocGFyc2VTZWxlY3Rvcik7XG4gIGNvbnN0IHN0cmVhbSA9IHBhcnNlU2VsZWN0b3Iocy5zbGljZSgxKS50cmltKCkpO1xuICBpZiAoc3RyZWFtLmJldHdlZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgYmV0d2VlbjogYixcbiAgICAgIHN0cmVhbTogc3RyZWFtXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uYmV0d2VlbiA9IGI7XG4gIH1cbiAgcmV0dXJuIHN0cmVhbTtcbn1cbmZ1bmN0aW9uIHBhcnNlU3RyZWFtKHMpIHtcbiAgY29uc3Qgc3RyZWFtID0ge1xuICAgICAgc291cmNlOiBERUZBVUxUX1NPVVJDRVxuICAgIH0sXG4gICAgc291cmNlID0gW107XG4gIGxldCB0aHJvdHRsZSA9IFswLCAwXSxcbiAgICBtYXJrbmFtZSA9IDAsXG4gICAgc3RhcnQgPSAwLFxuICAgIG4gPSBzLmxlbmd0aCxcbiAgICBpID0gMCxcbiAgICBqLFxuICAgIGZpbHRlcjtcblxuICAvLyBleHRyYWN0IHRocm90dGxlIGZyb20gZW5kXG4gIGlmIChzW24gLSAxXSA9PT0gUkJSQUNFKSB7XG4gICAgaSA9IHMubGFzdEluZGV4T2YoTEJSQUNFKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdHRsZSA9IHBhcnNlVGhyb3R0bGUocy5zdWJzdHJpbmcoaSArIDEsIG4gLSAxKSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRocm93ICdJbnZhbGlkIHRocm90dGxlIHNwZWNpZmljYXRpb246ICcgKyBzO1xuICAgICAgfVxuICAgICAgcyA9IHMuc2xpY2UoMCwgaSkudHJpbSgpO1xuICAgICAgbiA9IHMubGVuZ3RoO1xuICAgIH0gZWxzZSB0aHJvdyAnVW5tYXRjaGVkIHJpZ2h0IGJyYWNlOiAnICsgcztcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoIW4pIHRocm93IHM7XG5cbiAgLy8gc2V0IG5hbWUgZmxhZyBiYXNlZCBvbiBmaXJzdCBjaGFyXG4gIGlmIChzWzBdID09PSBOQU1FKSBtYXJrbmFtZSA9ICsraTtcblxuICAvLyBleHRyYWN0IGZpcnN0IHBhcnQgb2YgbXVsdGktcGFydCBzdHJlYW0gc2VsZWN0b3JcbiAgaiA9IGZpbmQocywgaSwgQ09MT04pO1xuICBpZiAoaiA8IG4pIHtcbiAgICBzb3VyY2UucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaikudHJpbSgpKTtcbiAgICBzdGFydCA9IGkgPSArK2o7XG4gIH1cblxuICAvLyBleHRyYWN0IHJlbWFpbmluZyBwYXJ0IG9mIHN0cmVhbSBzZWxlY3RvclxuICBpID0gZmluZChzLCBpLCBMQlJBQ0spO1xuICBpZiAoaSA9PT0gbikge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBuKS50cmltKCkpO1xuICB9IGVsc2Uge1xuICAgIHNvdXJjZS5wdXNoKHMuc3Vic3RyaW5nKHN0YXJ0LCBpKS50cmltKCkpO1xuICAgIGZpbHRlciA9IFtdO1xuICAgIHN0YXJ0ID0gKytpO1xuICAgIGlmIChzdGFydCA9PT0gbikgdGhyb3cgJ1VubWF0Y2hlZCBsZWZ0IGJyYWNrZXQ6ICcgKyBzO1xuICB9XG5cbiAgLy8gZXh0cmFjdCBmaWx0ZXJzXG4gIHdoaWxlIChpIDwgbikge1xuICAgIGkgPSBmaW5kKHMsIGksIFJCUkFDSyk7XG4gICAgaWYgKGkgPT09IG4pIHRocm93ICdVbm1hdGNoZWQgbGVmdCBicmFja2V0OiAnICsgcztcbiAgICBmaWx0ZXIucHVzaChzLnN1YnN0cmluZyhzdGFydCwgaSkudHJpbSgpKTtcbiAgICBpZiAoaSA8IG4gLSAxICYmIHNbKytpXSAhPT0gTEJSQUNLKSB0aHJvdyAnRXhwZWN0ZWQgbGVmdCBicmFja2V0OiAnICsgcztcbiAgICBzdGFydCA9ICsraTtcbiAgfVxuXG4gIC8vIG1hcnNoYWxsIGV2ZW50IHN0cmVhbSBzcGVjaWZpY2F0aW9uXG4gIGlmICghKG4gPSBzb3VyY2UubGVuZ3RoKSB8fCBJTExFR0FMLnRlc3Qoc291cmNlW24gLSAxXSkpIHtcbiAgICB0aHJvdyAnSW52YWxpZCBldmVudCBzZWxlY3RvcjogJyArIHM7XG4gIH1cbiAgaWYgKG4gPiAxKSB7XG4gICAgc3RyZWFtLnR5cGUgPSBzb3VyY2VbMV07XG4gICAgaWYgKG1hcmtuYW1lKSB7XG4gICAgICBzdHJlYW0ubWFya25hbWUgPSBzb3VyY2VbMF0uc2xpY2UoMSk7XG4gICAgfSBlbHNlIGlmIChpc01hcmtUeXBlKHNvdXJjZVswXSkpIHtcbiAgICAgIHN0cmVhbS5tYXJrdHlwZSA9IHNvdXJjZVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyZWFtLnNvdXJjZSA9IHNvdXJjZVswXTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RyZWFtLnR5cGUgPSBzb3VyY2VbMF07XG4gIH1cbiAgaWYgKHN0cmVhbS50eXBlLnNsaWNlKC0xKSA9PT0gJyEnKSB7XG4gICAgc3RyZWFtLmNvbnN1bWUgPSB0cnVlO1xuICAgIHN0cmVhbS50eXBlID0gc3RyZWFtLnR5cGUuc2xpY2UoMCwgLTEpO1xuICB9XG4gIGlmIChmaWx0ZXIgIT0gbnVsbCkgc3RyZWFtLmZpbHRlciA9IGZpbHRlcjtcbiAgaWYgKHRocm90dGxlWzBdKSBzdHJlYW0udGhyb3R0bGUgPSB0aHJvdHRsZVswXTtcbiAgaWYgKHRocm90dGxlWzFdKSBzdHJlYW0uZGVib3VuY2UgPSB0aHJvdHRsZVsxXTtcbiAgcmV0dXJuIHN0cmVhbTtcbn1cbmZ1bmN0aW9uIHBhcnNlVGhyb3R0bGUocykge1xuICBjb25zdCBhID0gcy5zcGxpdChDT01NQSk7XG4gIGlmICghcy5sZW5ndGggfHwgYS5sZW5ndGggPiAyKSB0aHJvdyBzO1xuICByZXR1cm4gYS5tYXAoXyA9PiB7XG4gICAgY29uc3QgeCA9ICtfO1xuICAgIGlmICh4ICE9PSB4KSB0aHJvdyBzO1xuICAgIHJldHVybiB4O1xuICB9KTtcbn1cblxuZXhwb3J0IHsgZXZlbnRTZWxlY3RvciBhcyBwYXJzZVNlbGVjdG9yIH07XG4iLCJpbXBvcnQgeyBlcnJvciwgdG9TZXQsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbmNvbnN0IFJhd0NvZGUgPSAnUmF3Q29kZSc7XG5jb25zdCBMaXRlcmFsID0gJ0xpdGVyYWwnO1xuY29uc3QgUHJvcGVydHkgPSAnUHJvcGVydHknO1xuY29uc3QgSWRlbnRpZmllciA9ICdJZGVudGlmaWVyJztcbmNvbnN0IEFycmF5RXhwcmVzc2lvbiA9ICdBcnJheUV4cHJlc3Npb24nO1xuY29uc3QgQmluYXJ5RXhwcmVzc2lvbiA9ICdCaW5hcnlFeHByZXNzaW9uJztcbmNvbnN0IENhbGxFeHByZXNzaW9uID0gJ0NhbGxFeHByZXNzaW9uJztcbmNvbnN0IENvbmRpdGlvbmFsRXhwcmVzc2lvbiA9ICdDb25kaXRpb25hbEV4cHJlc3Npb24nO1xuY29uc3QgTG9naWNhbEV4cHJlc3Npb24gPSAnTG9naWNhbEV4cHJlc3Npb24nO1xuY29uc3QgTWVtYmVyRXhwcmVzc2lvbiA9ICdNZW1iZXJFeHByZXNzaW9uJztcbmNvbnN0IE9iamVjdEV4cHJlc3Npb24gPSAnT2JqZWN0RXhwcmVzc2lvbic7XG5jb25zdCBVbmFyeUV4cHJlc3Npb24gPSAnVW5hcnlFeHByZXNzaW9uJztcbmZ1bmN0aW9uIEFTVE5vZGUodHlwZSkge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xufVxuQVNUTm9kZS5wcm90b3R5cGUudmlzaXQgPSBmdW5jdGlvbiAodmlzaXRvcikge1xuICBsZXQgYywgaSwgbjtcbiAgaWYgKHZpc2l0b3IodGhpcykpIHJldHVybiAxO1xuICBmb3IgKGMgPSBjaGlsZHJlbih0aGlzKSwgaSA9IDAsIG4gPSBjLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmIChjW2ldLnZpc2l0KHZpc2l0b3IpKSByZXR1cm4gMTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNoaWxkcmVuKG5vZGUpIHtcbiAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICBjYXNlIEFycmF5RXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBub2RlLmVsZW1lbnRzO1xuICAgIGNhc2UgQmluYXJ5RXhwcmVzc2lvbjpcbiAgICBjYXNlIExvZ2ljYWxFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLmxlZnQsIG5vZGUucmlnaHRdO1xuICAgIGNhc2UgQ2FsbEV4cHJlc3Npb246XG4gICAgICByZXR1cm4gW25vZGUuY2FsbGVlXS5jb25jYXQobm9kZS5hcmd1bWVudHMpO1xuICAgIGNhc2UgQ29uZGl0aW9uYWxFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLnRlc3QsIG5vZGUuY29uc2VxdWVudCwgbm9kZS5hbHRlcm5hdGVdO1xuICAgIGNhc2UgTWVtYmVyRXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBbbm9kZS5vYmplY3QsIG5vZGUucHJvcGVydHldO1xuICAgIGNhc2UgT2JqZWN0RXhwcmVzc2lvbjpcbiAgICAgIHJldHVybiBub2RlLnByb3BlcnRpZXM7XG4gICAgY2FzZSBQcm9wZXJ0eTpcbiAgICAgIHJldHVybiBbbm9kZS5rZXksIG5vZGUudmFsdWVdO1xuICAgIGNhc2UgVW5hcnlFeHByZXNzaW9uOlxuICAgICAgcmV0dXJuIFtub2RlLmFyZ3VtZW50XTtcbiAgICBjYXNlIElkZW50aWZpZXI6XG4gICAgY2FzZSBMaXRlcmFsOlxuICAgIGNhc2UgUmF3Q29kZTpcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qXG4gIFRoZSBmb2xsb3dpbmcgZXhwcmVzc2lvbiBwYXJzZXIgaXMgYmFzZWQgb24gRXNwcmltYSAoaHR0cDovL2VzcHJpbWEub3JnLykuXG4gIE9yaWdpbmFsIGhlYWRlciBjb21tZW50IGFuZCBsaWNlbnNlIGZvciBFc3ByaW1hIGlzIGluY2x1ZGVkIGhlcmU6XG5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIEFyaXlhIEhpZGF5YXQgPGFyaXlhLmhpZGF5YXRAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTMgVGhhZGRlZSBUeWwgPHRoYWRkZWUudHlsQGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEzIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIE1hdGhpYXMgQnluZW5zIDxtYXRoaWFzQHFpd2kuYmU+XG4gIENvcHlyaWdodCAoQykgMjAxMiBKb29zdC1XaW0gQm9la2VzdGVpam4gPGpvb3N0LXdpbUBib2VrZXN0ZWlqbi5ubD5cbiAgQ29weXJpZ2h0IChDKSAyMDEyIEtyaXMgS293YWwgPGtyaXMua293YWxAY2l4YXIuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgWXVzdWtlIFN1enVraSA8dXRhdGFuZS50ZWFAZ21haWwuY29tPlxuICBDb3B5cmlnaHQgKEMpIDIwMTIgQXJwYWQgQm9yc29zIDxhcnBhZC5ib3Jzb3NAZ29vZ2xlbWFpbC5jb20+XG4gIENvcHlyaWdodCAoQykgMjAxMSBBcml5YSBIaWRheWF0IDxhcml5YS5oaWRheWF0QGdtYWlsLmNvbT5cblxuICBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAgbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG5cbiAgICAqIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gICAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICAgICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cblxuICBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBDT1BZUklHSFQgSE9MREVSUyBBTkQgQ09OVFJJQlVUT1JTIFwiQVMgSVNcIlxuICBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCA8Q09QWVJJR0hUIEhPTERFUj4gQkUgTElBQkxFIEZPUiBBTllcbiAgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICBMT1NTIE9GIFVTRSwgREFUQSwgT1IgUFJPRklUUzsgT1IgQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkRcbiAgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4qL1xudmFyIFRva2VuTmFtZSwgc291cmNlLCBpbmRleCwgbGVuZ3RoLCBsb29rYWhlYWQ7XG52YXIgVG9rZW5Cb29sZWFuTGl0ZXJhbCA9IDEsXG4gIFRva2VuRU9GID0gMixcbiAgVG9rZW5JZGVudGlmaWVyID0gMyxcbiAgVG9rZW5LZXl3b3JkID0gNCxcbiAgVG9rZW5OdWxsTGl0ZXJhbCA9IDUsXG4gIFRva2VuTnVtZXJpY0xpdGVyYWwgPSA2LFxuICBUb2tlblB1bmN0dWF0b3IgPSA3LFxuICBUb2tlblN0cmluZ0xpdGVyYWwgPSA4LFxuICBUb2tlblJlZ3VsYXJFeHByZXNzaW9uID0gOTtcblRva2VuTmFtZSA9IHt9O1xuVG9rZW5OYW1lW1Rva2VuQm9vbGVhbkxpdGVyYWxdID0gJ0Jvb2xlYW4nO1xuVG9rZW5OYW1lW1Rva2VuRU9GXSA9ICc8ZW5kPic7XG5Ub2tlbk5hbWVbVG9rZW5JZGVudGlmaWVyXSA9ICdJZGVudGlmaWVyJztcblRva2VuTmFtZVtUb2tlbktleXdvcmRdID0gJ0tleXdvcmQnO1xuVG9rZW5OYW1lW1Rva2VuTnVsbExpdGVyYWxdID0gJ051bGwnO1xuVG9rZW5OYW1lW1Rva2VuTnVtZXJpY0xpdGVyYWxdID0gJ051bWVyaWMnO1xuVG9rZW5OYW1lW1Rva2VuUHVuY3R1YXRvcl0gPSAnUHVuY3R1YXRvcic7XG5Ub2tlbk5hbWVbVG9rZW5TdHJpbmdMaXRlcmFsXSA9ICdTdHJpbmcnO1xuVG9rZW5OYW1lW1Rva2VuUmVndWxhckV4cHJlc3Npb25dID0gJ1JlZ3VsYXJFeHByZXNzaW9uJztcbnZhciBTeW50YXhBcnJheUV4cHJlc3Npb24gPSAnQXJyYXlFeHByZXNzaW9uJyxcbiAgU3ludGF4QmluYXJ5RXhwcmVzc2lvbiA9ICdCaW5hcnlFeHByZXNzaW9uJyxcbiAgU3ludGF4Q2FsbEV4cHJlc3Npb24gPSAnQ2FsbEV4cHJlc3Npb24nLFxuICBTeW50YXhDb25kaXRpb25hbEV4cHJlc3Npb24gPSAnQ29uZGl0aW9uYWxFeHByZXNzaW9uJyxcbiAgU3ludGF4SWRlbnRpZmllciA9ICdJZGVudGlmaWVyJyxcbiAgU3ludGF4TGl0ZXJhbCA9ICdMaXRlcmFsJyxcbiAgU3ludGF4TG9naWNhbEV4cHJlc3Npb24gPSAnTG9naWNhbEV4cHJlc3Npb24nLFxuICBTeW50YXhNZW1iZXJFeHByZXNzaW9uID0gJ01lbWJlckV4cHJlc3Npb24nLFxuICBTeW50YXhPYmplY3RFeHByZXNzaW9uID0gJ09iamVjdEV4cHJlc3Npb24nLFxuICBTeW50YXhQcm9wZXJ0eSA9ICdQcm9wZXJ0eScsXG4gIFN5bnRheFVuYXJ5RXhwcmVzc2lvbiA9ICdVbmFyeUV4cHJlc3Npb24nO1xuXG4vLyBFcnJvciBtZXNzYWdlcyBzaG91bGQgYmUgaWRlbnRpY2FsIHRvIFY4LlxudmFyIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4gPSAnVW5leHBlY3RlZCB0b2tlbiAlMCcsXG4gIE1lc3NhZ2VVbmV4cGVjdGVkTnVtYmVyID0gJ1VuZXhwZWN0ZWQgbnVtYmVyJyxcbiAgTWVzc2FnZVVuZXhwZWN0ZWRTdHJpbmcgPSAnVW5leHBlY3RlZCBzdHJpbmcnLFxuICBNZXNzYWdlVW5leHBlY3RlZElkZW50aWZpZXIgPSAnVW5leHBlY3RlZCBpZGVudGlmaWVyJyxcbiAgTWVzc2FnZVVuZXhwZWN0ZWRSZXNlcnZlZCA9ICdVbmV4cGVjdGVkIHJlc2VydmVkIHdvcmQnLFxuICBNZXNzYWdlVW5leHBlY3RlZEVPUyA9ICdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcsXG4gIE1lc3NhZ2VJbnZhbGlkUmVnRXhwID0gJ0ludmFsaWQgcmVndWxhciBleHByZXNzaW9uJyxcbiAgTWVzc2FnZVVudGVybWluYXRlZFJlZ0V4cCA9ICdJbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbjogbWlzc2luZyAvJyxcbiAgTWVzc2FnZVN0cmljdE9jdGFsTGl0ZXJhbCA9ICdPY3RhbCBsaXRlcmFscyBhcmUgbm90IGFsbG93ZWQgaW4gc3RyaWN0IG1vZGUuJyxcbiAgTWVzc2FnZVN0cmljdER1cGxpY2F0ZVByb3BlcnR5ID0gJ0R1cGxpY2F0ZSBkYXRhIHByb3BlcnR5IGluIG9iamVjdCBsaXRlcmFsIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlJztcbnZhciBJTExFR0FMID0gJ0lMTEVHQUwnLFxuICBESVNBQkxFRCA9ICdEaXNhYmxlZC4nO1xuXG4vLyBTZWUgYWxzbyB0b29scy9nZW5lcmF0ZS11bmljb2RlLXJlZ2V4LnB5LlxudmFyIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyU3RhcnQgPSBuZXcgUmVnRXhwKCdbXFxcXHhBQVxcXFx4QjVcXFxceEJBXFxcXHhDMC1cXFxceEQ2XFxcXHhEOC1cXFxceEY2XFxcXHhGOC1cXFxcdTAyQzFcXFxcdTAyQzYtXFxcXHUwMkQxXFxcXHUwMkUwLVxcXFx1MDJFNFxcXFx1MDJFQ1xcXFx1MDJFRVxcXFx1MDM3MC1cXFxcdTAzNzRcXFxcdTAzNzZcXFxcdTAzNzdcXFxcdTAzN0EtXFxcXHUwMzdEXFxcXHUwMzdGXFxcXHUwMzg2XFxcXHUwMzg4LVxcXFx1MDM4QVxcXFx1MDM4Q1xcXFx1MDM4RS1cXFxcdTAzQTFcXFxcdTAzQTMtXFxcXHUwM0Y1XFxcXHUwM0Y3LVxcXFx1MDQ4MVxcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDVEMC1cXFxcdTA1RUFcXFxcdTA1RjAtXFxcXHUwNUYyXFxcXHUwNjIwLVxcXFx1MDY0QVxcXFx1MDY2RVxcXFx1MDY2RlxcXFx1MDY3MS1cXFxcdTA2RDNcXFxcdTA2RDVcXFxcdTA2RTVcXFxcdTA2RTZcXFxcdTA2RUVcXFxcdTA2RUZcXFxcdTA2RkEtXFxcXHUwNkZDXFxcXHUwNkZGXFxcXHUwNzEwXFxcXHUwNzEyLVxcXFx1MDcyRlxcXFx1MDc0RC1cXFxcdTA3QTVcXFxcdTA3QjFcXFxcdTA3Q0EtXFxcXHUwN0VBXFxcXHUwN0Y0XFxcXHUwN0Y1XFxcXHUwN0ZBXFxcXHUwODAwLVxcXFx1MDgxNVxcXFx1MDgxQVxcXFx1MDgyNFxcXFx1MDgyOFxcXFx1MDg0MC1cXFxcdTA4NThcXFxcdTA4QTAtXFxcXHUwOEIyXFxcXHUwOTA0LVxcXFx1MDkzOVxcXFx1MDkzRFxcXFx1MDk1MFxcXFx1MDk1OC1cXFxcdTA5NjFcXFxcdTA5NzEtXFxcXHUwOTgwXFxcXHUwOTg1LVxcXFx1MDk4Q1xcXFx1MDk4RlxcXFx1MDk5MFxcXFx1MDk5My1cXFxcdTA5QThcXFxcdTA5QUEtXFxcXHUwOUIwXFxcXHUwOUIyXFxcXHUwOUI2LVxcXFx1MDlCOVxcXFx1MDlCRFxcXFx1MDlDRVxcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTFcXFxcdTA5RjBcXFxcdTA5RjFcXFxcdTBBMDUtXFxcXHUwQTBBXFxcXHUwQTBGXFxcXHUwQTEwXFxcXHUwQTEzLVxcXFx1MEEyOFxcXFx1MEEyQS1cXFxcdTBBMzBcXFxcdTBBMzJcXFxcdTBBMzNcXFxcdTBBMzVcXFxcdTBBMzZcXFxcdTBBMzhcXFxcdTBBMzlcXFxcdTBBNTktXFxcXHUwQTVDXFxcXHUwQTVFXFxcXHUwQTcyLVxcXFx1MEE3NFxcXFx1MEE4NS1cXFxcdTBBOERcXFxcdTBBOEYtXFxcXHUwQTkxXFxcXHUwQTkzLVxcXFx1MEFBOFxcXFx1MEFBQS1cXFxcdTBBQjBcXFxcdTBBQjJcXFxcdTBBQjNcXFxcdTBBQjUtXFxcXHUwQUI5XFxcXHUwQUJEXFxcXHUwQUQwXFxcXHUwQUUwXFxcXHUwQUUxXFxcXHUwQjA1LVxcXFx1MEIwQ1xcXFx1MEIwRlxcXFx1MEIxMFxcXFx1MEIxMy1cXFxcdTBCMjhcXFxcdTBCMkEtXFxcXHUwQjMwXFxcXHUwQjMyXFxcXHUwQjMzXFxcXHUwQjM1LVxcXFx1MEIzOVxcXFx1MEIzRFxcXFx1MEI1Q1xcXFx1MEI1RFxcXFx1MEI1Ri1cXFxcdTBCNjFcXFxcdTBCNzFcXFxcdTBCODNcXFxcdTBCODUtXFxcXHUwQjhBXFxcXHUwQjhFLVxcXFx1MEI5MFxcXFx1MEI5Mi1cXFxcdTBCOTVcXFxcdTBCOTlcXFxcdTBCOUFcXFxcdTBCOUNcXFxcdTBCOUVcXFxcdTBCOUZcXFxcdTBCQTNcXFxcdTBCQTRcXFxcdTBCQTgtXFxcXHUwQkFBXFxcXHUwQkFFLVxcXFx1MEJCOVxcXFx1MEJEMFxcXFx1MEMwNS1cXFxcdTBDMENcXFxcdTBDMEUtXFxcXHUwQzEwXFxcXHUwQzEyLVxcXFx1MEMyOFxcXFx1MEMyQS1cXFxcdTBDMzlcXFxcdTBDM0RcXFxcdTBDNThcXFxcdTBDNTlcXFxcdTBDNjBcXFxcdTBDNjFcXFxcdTBDODUtXFxcXHUwQzhDXFxcXHUwQzhFLVxcXFx1MEM5MFxcXFx1MEM5Mi1cXFxcdTBDQThcXFxcdTBDQUEtXFxcXHUwQ0IzXFxcXHUwQ0I1LVxcXFx1MENCOVxcXFx1MENCRFxcXFx1MENERVxcXFx1MENFMFxcXFx1MENFMVxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwNS1cXFxcdTBEMENcXFxcdTBEMEUtXFxcXHUwRDEwXFxcXHUwRDEyLVxcXFx1MEQzQVxcXFx1MEQzRFxcXFx1MEQ0RVxcXFx1MEQ2MFxcXFx1MEQ2MVxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRTAxLVxcXFx1MEUzMFxcXFx1MEUzMlxcXFx1MEUzM1xcXFx1MEU0MC1cXFxcdTBFNDZcXFxcdTBFODFcXFxcdTBFODJcXFxcdTBFODRcXFxcdTBFODdcXFxcdTBFODhcXFxcdTBFOEFcXFxcdTBFOERcXFxcdTBFOTQtXFxcXHUwRTk3XFxcXHUwRTk5LVxcXFx1MEU5RlxcXFx1MEVBMS1cXFxcdTBFQTNcXFxcdTBFQTVcXFxcdTBFQTdcXFxcdTBFQUFcXFxcdTBFQUJcXFxcdTBFQUQtXFxcXHUwRUIwXFxcXHUwRUIyXFxcXHUwRUIzXFxcXHUwRUJEXFxcXHUwRUMwLVxcXFx1MEVDNFxcXFx1MEVDNlxcXFx1MEVEQy1cXFxcdTBFREZcXFxcdTBGMDBcXFxcdTBGNDAtXFxcXHUwRjQ3XFxcXHUwRjQ5LVxcXFx1MEY2Q1xcXFx1MEY4OC1cXFxcdTBGOENcXFxcdTEwMDAtXFxcXHUxMDJBXFxcXHUxMDNGXFxcXHUxMDUwLVxcXFx1MTA1NVxcXFx1MTA1QS1cXFxcdTEwNURcXFxcdTEwNjFcXFxcdTEwNjVcXFxcdTEwNjZcXFxcdTEwNkUtXFxcXHUxMDcwXFxcXHUxMDc1LVxcXFx1MTA4MVxcXFx1MTA4RVxcXFx1MTBBMC1cXFxcdTEwQzVcXFxcdTEwQzdcXFxcdTEwQ0RcXFxcdTEwRDAtXFxcXHUxMEZBXFxcXHUxMEZDLVxcXFx1MTI0OFxcXFx1MTI0QS1cXFxcdTEyNERcXFxcdTEyNTAtXFxcXHUxMjU2XFxcXHUxMjU4XFxcXHUxMjVBLVxcXFx1MTI1RFxcXFx1MTI2MC1cXFxcdTEyODhcXFxcdTEyOEEtXFxcXHUxMjhEXFxcXHUxMjkwLVxcXFx1MTJCMFxcXFx1MTJCMi1cXFxcdTEyQjVcXFxcdTEyQjgtXFxcXHUxMkJFXFxcXHUxMkMwXFxcXHUxMkMyLVxcXFx1MTJDNVxcXFx1MTJDOC1cXFxcdTEyRDZcXFxcdTEyRDgtXFxcXHUxMzEwXFxcXHUxMzEyLVxcXFx1MTMxNVxcXFx1MTMxOC1cXFxcdTEzNUFcXFxcdTEzODAtXFxcXHUxMzhGXFxcXHUxM0EwLVxcXFx1MTNGNFxcXFx1MTQwMS1cXFxcdTE2NkNcXFxcdTE2NkYtXFxcXHUxNjdGXFxcXHUxNjgxLVxcXFx1MTY5QVxcXFx1MTZBMC1cXFxcdTE2RUFcXFxcdTE2RUUtXFxcXHUxNkY4XFxcXHUxNzAwLVxcXFx1MTcwQ1xcXFx1MTcwRS1cXFxcdTE3MTFcXFxcdTE3MjAtXFxcXHUxNzMxXFxcXHUxNzQwLVxcXFx1MTc1MVxcXFx1MTc2MC1cXFxcdTE3NkNcXFxcdTE3NkUtXFxcXHUxNzcwXFxcXHUxNzgwLVxcXFx1MTdCM1xcXFx1MTdEN1xcXFx1MTdEQ1xcXFx1MTgyMC1cXFxcdTE4NzdcXFxcdTE4ODAtXFxcXHUxOEE4XFxcXHUxOEFBXFxcXHUxOEIwLVxcXFx1MThGNVxcXFx1MTkwMC1cXFxcdTE5MUVcXFxcdTE5NTAtXFxcXHUxOTZEXFxcXHUxOTcwLVxcXFx1MTk3NFxcXFx1MTk4MC1cXFxcdTE5QUJcXFxcdTE5QzEtXFxcXHUxOUM3XFxcXHUxQTAwLVxcXFx1MUExNlxcXFx1MUEyMC1cXFxcdTFBNTRcXFxcdTFBQTdcXFxcdTFCMDUtXFxcXHUxQjMzXFxcXHUxQjQ1LVxcXFx1MUI0QlxcXFx1MUI4My1cXFxcdTFCQTBcXFxcdTFCQUVcXFxcdTFCQUZcXFxcdTFCQkEtXFxcXHUxQkU1XFxcXHUxQzAwLVxcXFx1MUMyM1xcXFx1MUM0RC1cXFxcdTFDNEZcXFxcdTFDNUEtXFxcXHUxQzdEXFxcXHUxQ0U5LVxcXFx1MUNFQ1xcXFx1MUNFRS1cXFxcdTFDRjFcXFxcdTFDRjVcXFxcdTFDRjZcXFxcdTFEMDAtXFxcXHUxREJGXFxcXHUxRTAwLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjEwMlxcXFx1MjEwN1xcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTVcXFxcdTIxMTktXFxcXHUyMTFEXFxcXHUyMTI0XFxcXHUyMTI2XFxcXHUyMTI4XFxcXHUyMTJBLVxcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzlcXFxcdTIxM0MtXFxcXHUyMTNGXFxcXHUyMTQ1LVxcXFx1MjE0OVxcXFx1MjE0RVxcXFx1MjE2MC1cXFxcdTIxODhcXFxcdTJDMDAtXFxcXHUyQzJFXFxcXHUyQzMwLVxcXFx1MkM1RVxcXFx1MkM2MC1cXFxcdTJDRTRcXFxcdTJDRUItXFxcXHUyQ0VFXFxcXHUyQ0YyXFxcXHUyQ0YzXFxcXHUyRDAwLVxcXFx1MkQyNVxcXFx1MkQyN1xcXFx1MkQyRFxcXFx1MkQzMC1cXFxcdTJENjdcXFxcdTJENkZcXFxcdTJEODAtXFxcXHUyRDk2XFxcXHUyREEwLVxcXFx1MkRBNlxcXFx1MkRBOC1cXFxcdTJEQUVcXFxcdTJEQjAtXFxcXHUyREI2XFxcXHUyREI4LVxcXFx1MkRCRVxcXFx1MkRDMC1cXFxcdTJEQzZcXFxcdTJEQzgtXFxcXHUyRENFXFxcXHUyREQwLVxcXFx1MkRENlxcXFx1MkREOC1cXFxcdTJEREVcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyOVxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MUZcXFxcdUE2MkFcXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZFXFxcXHVBNjdGLVxcXFx1QTY5RFxcXFx1QTZBMC1cXFxcdUE2RUZcXFxcdUE3MTctXFxcXHVBNzFGXFxcXHVBNzIyLVxcXFx1QTc4OFxcXFx1QTc4Qi1cXFxcdUE3OEVcXFxcdUE3OTAtXFxcXHVBN0FEXFxcXHVBN0IwXFxcXHVBN0IxXFxcXHVBN0Y3LVxcXFx1QTgwMVxcXFx1QTgwMy1cXFxcdUE4MDVcXFxcdUE4MDctXFxcXHVBODBBXFxcXHVBODBDLVxcXFx1QTgyMlxcXFx1QTg0MC1cXFxcdUE4NzNcXFxcdUE4ODItXFxcXHVBOEIzXFxcXHVBOEYyLVxcXFx1QThGN1xcXFx1QThGQlxcXFx1QTkwQS1cXFxcdUE5MjVcXFxcdUE5MzAtXFxcXHVBOTQ2XFxcXHVBOTYwLVxcXFx1QTk3Q1xcXFx1QTk4NC1cXFxcdUE5QjJcXFxcdUE5Q0ZcXFxcdUE5RTAtXFxcXHVBOUU0XFxcXHVBOUU2LVxcXFx1QTlFRlxcXFx1QTlGQS1cXFxcdUE5RkVcXFxcdUFBMDAtXFxcXHVBQTI4XFxcXHVBQTQwLVxcXFx1QUE0MlxcXFx1QUE0NC1cXFxcdUFBNEJcXFxcdUFBNjAtXFxcXHVBQTc2XFxcXHVBQTdBXFxcXHVBQTdFLVxcXFx1QUFBRlxcXFx1QUFCMVxcXFx1QUFCNVxcXFx1QUFCNlxcXFx1QUFCOS1cXFxcdUFBQkRcXFxcdUFBQzBcXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFQVxcXFx1QUFGMi1cXFxcdUFBRjRcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVBQjY0XFxcXHVBQjY1XFxcXHVBQkMwLVxcXFx1QUJFMlxcXFx1QUMwMC1cXFxcdUQ3QTNcXFxcdUQ3QjAtXFxcXHVEN0M2XFxcXHVEN0NCLVxcXFx1RDdGQlxcXFx1RjkwMC1cXFxcdUZBNkRcXFxcdUZBNzAtXFxcXHVGQUQ5XFxcXHVGQjAwLVxcXFx1RkIwNlxcXFx1RkIxMy1cXFxcdUZCMTdcXFxcdUZCMURcXFxcdUZCMUYtXFxcXHVGQjI4XFxcXHVGQjJBLVxcXFx1RkIzNlxcXFx1RkIzOC1cXFxcdUZCM0NcXFxcdUZCM0VcXFxcdUZCNDBcXFxcdUZCNDFcXFxcdUZCNDNcXFxcdUZCNDRcXFxcdUZCNDYtXFxcXHVGQkIxXFxcXHVGQkQzLVxcXFx1RkQzRFxcXFx1RkQ1MC1cXFxcdUZEOEZcXFxcdUZEOTItXFxcXHVGREM3XFxcXHVGREYwLVxcXFx1RkRGQlxcXFx1RkU3MC1cXFxcdUZFNzRcXFxcdUZFNzYtXFxcXHVGRUZDXFxcXHVGRjIxLVxcXFx1RkYzQVxcXFx1RkY0MS1cXFxcdUZGNUFcXFxcdUZGNjYtXFxcXHVGRkJFXFxcXHVGRkMyLVxcXFx1RkZDN1xcXFx1RkZDQS1cXFxcdUZGQ0ZcXFxcdUZGRDItXFxcXHVGRkQ3XFxcXHVGRkRBLVxcXFx1RkZEQ10nKSxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLW1pc2xlYWRpbmctY2hhcmFjdGVyLWNsYXNzXG4gIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyUGFydCA9IG5ldyBSZWdFeHAoJ1tcXFxceEFBXFxcXHhCNVxcXFx4QkFcXFxceEMwLVxcXFx4RDZcXFxceEQ4LVxcXFx4RjZcXFxceEY4LVxcXFx1MDJDMVxcXFx1MDJDNi1cXFxcdTAyRDFcXFxcdTAyRTAtXFxcXHUwMkU0XFxcXHUwMkVDXFxcXHUwMkVFXFxcXHUwMzAwLVxcXFx1MDM3NFxcXFx1MDM3NlxcXFx1MDM3N1xcXFx1MDM3QS1cXFxcdTAzN0RcXFxcdTAzN0ZcXFxcdTAzODZcXFxcdTAzODgtXFxcXHUwMzhBXFxcXHUwMzhDXFxcXHUwMzhFLVxcXFx1MDNBMVxcXFx1MDNBMy1cXFxcdTAzRjVcXFxcdTAzRjctXFxcXHUwNDgxXFxcXHUwNDgzLVxcXFx1MDQ4N1xcXFx1MDQ4QS1cXFxcdTA1MkZcXFxcdTA1MzEtXFxcXHUwNTU2XFxcXHUwNTU5XFxcXHUwNTYxLVxcXFx1MDU4N1xcXFx1MDU5MS1cXFxcdTA1QkRcXFxcdTA1QkZcXFxcdTA1QzFcXFxcdTA1QzJcXFxcdTA1QzRcXFxcdTA1QzVcXFxcdTA1QzdcXFxcdTA1RDAtXFxcXHUwNUVBXFxcXHUwNUYwLVxcXFx1MDVGMlxcXFx1MDYxMC1cXFxcdTA2MUFcXFxcdTA2MjAtXFxcXHUwNjY5XFxcXHUwNjZFLVxcXFx1MDZEM1xcXFx1MDZENS1cXFxcdTA2RENcXFxcdTA2REYtXFxcXHUwNkU4XFxcXHUwNkVBLVxcXFx1MDZGQ1xcXFx1MDZGRlxcXFx1MDcxMC1cXFxcdTA3NEFcXFxcdTA3NEQtXFxcXHUwN0IxXFxcXHUwN0MwLVxcXFx1MDdGNVxcXFx1MDdGQVxcXFx1MDgwMC1cXFxcdTA4MkRcXFxcdTA4NDAtXFxcXHUwODVCXFxcXHUwOEEwLVxcXFx1MDhCMlxcXFx1MDhFNC1cXFxcdTA5NjNcXFxcdTA5NjYtXFxcXHUwOTZGXFxcXHUwOTcxLVxcXFx1MDk4M1xcXFx1MDk4NS1cXFxcdTA5OENcXFxcdTA5OEZcXFxcdTA5OTBcXFxcdTA5OTMtXFxcXHUwOUE4XFxcXHUwOUFBLVxcXFx1MDlCMFxcXFx1MDlCMlxcXFx1MDlCNi1cXFxcdTA5QjlcXFxcdTA5QkMtXFxcXHUwOUM0XFxcXHUwOUM3XFxcXHUwOUM4XFxcXHUwOUNCLVxcXFx1MDlDRVxcXFx1MDlEN1xcXFx1MDlEQ1xcXFx1MDlERFxcXFx1MDlERi1cXFxcdTA5RTNcXFxcdTA5RTYtXFxcXHUwOUYxXFxcXHUwQTAxLVxcXFx1MEEwM1xcXFx1MEEwNS1cXFxcdTBBMEFcXFxcdTBBMEZcXFxcdTBBMTBcXFxcdTBBMTMtXFxcXHUwQTI4XFxcXHUwQTJBLVxcXFx1MEEzMFxcXFx1MEEzMlxcXFx1MEEzM1xcXFx1MEEzNVxcXFx1MEEzNlxcXFx1MEEzOFxcXFx1MEEzOVxcXFx1MEEzQ1xcXFx1MEEzRS1cXFxcdTBBNDJcXFxcdTBBNDdcXFxcdTBBNDhcXFxcdTBBNEItXFxcXHUwQTREXFxcXHUwQTUxXFxcXHUwQTU5LVxcXFx1MEE1Q1xcXFx1MEE1RVxcXFx1MEE2Ni1cXFxcdTBBNzVcXFxcdTBBODEtXFxcXHUwQTgzXFxcXHUwQTg1LVxcXFx1MEE4RFxcXFx1MEE4Ri1cXFxcdTBBOTFcXFxcdTBBOTMtXFxcXHUwQUE4XFxcXHUwQUFBLVxcXFx1MEFCMFxcXFx1MEFCMlxcXFx1MEFCM1xcXFx1MEFCNS1cXFxcdTBBQjlcXFxcdTBBQkMtXFxcXHUwQUM1XFxcXHUwQUM3LVxcXFx1MEFDOVxcXFx1MEFDQi1cXFxcdTBBQ0RcXFxcdTBBRDBcXFxcdTBBRTAtXFxcXHUwQUUzXFxcXHUwQUU2LVxcXFx1MEFFRlxcXFx1MEIwMS1cXFxcdTBCMDNcXFxcdTBCMDUtXFxcXHUwQjBDXFxcXHUwQjBGXFxcXHUwQjEwXFxcXHUwQjEzLVxcXFx1MEIyOFxcXFx1MEIyQS1cXFxcdTBCMzBcXFxcdTBCMzJcXFxcdTBCMzNcXFxcdTBCMzUtXFxcXHUwQjM5XFxcXHUwQjNDLVxcXFx1MEI0NFxcXFx1MEI0N1xcXFx1MEI0OFxcXFx1MEI0Qi1cXFxcdTBCNERcXFxcdTBCNTZcXFxcdTBCNTdcXFxcdTBCNUNcXFxcdTBCNURcXFxcdTBCNUYtXFxcXHUwQjYzXFxcXHUwQjY2LVxcXFx1MEI2RlxcXFx1MEI3MVxcXFx1MEI4MlxcXFx1MEI4M1xcXFx1MEI4NS1cXFxcdTBCOEFcXFxcdTBCOEUtXFxcXHUwQjkwXFxcXHUwQjkyLVxcXFx1MEI5NVxcXFx1MEI5OVxcXFx1MEI5QVxcXFx1MEI5Q1xcXFx1MEI5RVxcXFx1MEI5RlxcXFx1MEJBM1xcXFx1MEJBNFxcXFx1MEJBOC1cXFxcdTBCQUFcXFxcdTBCQUUtXFxcXHUwQkI5XFxcXHUwQkJFLVxcXFx1MEJDMlxcXFx1MEJDNi1cXFxcdTBCQzhcXFxcdTBCQ0EtXFxcXHUwQkNEXFxcXHUwQkQwXFxcXHUwQkQ3XFxcXHUwQkU2LVxcXFx1MEJFRlxcXFx1MEMwMC1cXFxcdTBDMDNcXFxcdTBDMDUtXFxcXHUwQzBDXFxcXHUwQzBFLVxcXFx1MEMxMFxcXFx1MEMxMi1cXFxcdTBDMjhcXFxcdTBDMkEtXFxcXHUwQzM5XFxcXHUwQzNELVxcXFx1MEM0NFxcXFx1MEM0Ni1cXFxcdTBDNDhcXFxcdTBDNEEtXFxcXHUwQzREXFxcXHUwQzU1XFxcXHUwQzU2XFxcXHUwQzU4XFxcXHUwQzU5XFxcXHUwQzYwLVxcXFx1MEM2M1xcXFx1MEM2Ni1cXFxcdTBDNkZcXFxcdTBDODEtXFxcXHUwQzgzXFxcXHUwQzg1LVxcXFx1MEM4Q1xcXFx1MEM4RS1cXFxcdTBDOTBcXFxcdTBDOTItXFxcXHUwQ0E4XFxcXHUwQ0FBLVxcXFx1MENCM1xcXFx1MENCNS1cXFxcdTBDQjlcXFxcdTBDQkMtXFxcXHUwQ0M0XFxcXHUwQ0M2LVxcXFx1MENDOFxcXFx1MENDQS1cXFxcdTBDQ0RcXFxcdTBDRDVcXFxcdTBDRDZcXFxcdTBDREVcXFxcdTBDRTAtXFxcXHUwQ0UzXFxcXHUwQ0U2LVxcXFx1MENFRlxcXFx1MENGMVxcXFx1MENGMlxcXFx1MEQwMS1cXFxcdTBEMDNcXFxcdTBEMDUtXFxcXHUwRDBDXFxcXHUwRDBFLVxcXFx1MEQxMFxcXFx1MEQxMi1cXFxcdTBEM0FcXFxcdTBEM0QtXFxcXHUwRDQ0XFxcXHUwRDQ2LVxcXFx1MEQ0OFxcXFx1MEQ0QS1cXFxcdTBENEVcXFxcdTBENTdcXFxcdTBENjAtXFxcXHUwRDYzXFxcXHUwRDY2LVxcXFx1MEQ2RlxcXFx1MEQ3QS1cXFxcdTBEN0ZcXFxcdTBEODJcXFxcdTBEODNcXFxcdTBEODUtXFxcXHUwRDk2XFxcXHUwRDlBLVxcXFx1MERCMVxcXFx1MERCMy1cXFxcdTBEQkJcXFxcdTBEQkRcXFxcdTBEQzAtXFxcXHUwREM2XFxcXHUwRENBXFxcXHUwRENGLVxcXFx1MERENFxcXFx1MERENlxcXFx1MEREOC1cXFxcdTBEREZcXFxcdTBERTYtXFxcXHUwREVGXFxcXHUwREYyXFxcXHUwREYzXFxcXHUwRTAxLVxcXFx1MEUzQVxcXFx1MEU0MC1cXFxcdTBFNEVcXFxcdTBFNTAtXFxcXHUwRTU5XFxcXHUwRTgxXFxcXHUwRTgyXFxcXHUwRTg0XFxcXHUwRTg3XFxcXHUwRTg4XFxcXHUwRThBXFxcXHUwRThEXFxcXHUwRTk0LVxcXFx1MEU5N1xcXFx1MEU5OS1cXFxcdTBFOUZcXFxcdTBFQTEtXFxcXHUwRUEzXFxcXHUwRUE1XFxcXHUwRUE3XFxcXHUwRUFBXFxcXHUwRUFCXFxcXHUwRUFELVxcXFx1MEVCOVxcXFx1MEVCQi1cXFxcdTBFQkRcXFxcdTBFQzAtXFxcXHUwRUM0XFxcXHUwRUM2XFxcXHUwRUM4LVxcXFx1MEVDRFxcXFx1MEVEMC1cXFxcdTBFRDlcXFxcdTBFREMtXFxcXHUwRURGXFxcXHUwRjAwXFxcXHUwRjE4XFxcXHUwRjE5XFxcXHUwRjIwLVxcXFx1MEYyOVxcXFx1MEYzNVxcXFx1MEYzN1xcXFx1MEYzOVxcXFx1MEYzRS1cXFxcdTBGNDdcXFxcdTBGNDktXFxcXHUwRjZDXFxcXHUwRjcxLVxcXFx1MEY4NFxcXFx1MEY4Ni1cXFxcdTBGOTdcXFxcdTBGOTktXFxcXHUwRkJDXFxcXHUwRkM2XFxcXHUxMDAwLVxcXFx1MTA0OVxcXFx1MTA1MC1cXFxcdTEwOURcXFxcdTEwQTAtXFxcXHUxMEM1XFxcXHUxMEM3XFxcXHUxMENEXFxcXHUxMEQwLVxcXFx1MTBGQVxcXFx1MTBGQy1cXFxcdTEyNDhcXFxcdTEyNEEtXFxcXHUxMjREXFxcXHUxMjUwLVxcXFx1MTI1NlxcXFx1MTI1OFxcXFx1MTI1QS1cXFxcdTEyNURcXFxcdTEyNjAtXFxcXHUxMjg4XFxcXHUxMjhBLVxcXFx1MTI4RFxcXFx1MTI5MC1cXFxcdTEyQjBcXFxcdTEyQjItXFxcXHUxMkI1XFxcXHUxMkI4LVxcXFx1MTJCRVxcXFx1MTJDMFxcXFx1MTJDMi1cXFxcdTEyQzVcXFxcdTEyQzgtXFxcXHUxMkQ2XFxcXHUxMkQ4LVxcXFx1MTMxMFxcXFx1MTMxMi1cXFxcdTEzMTVcXFxcdTEzMTgtXFxcXHUxMzVBXFxcXHUxMzVELVxcXFx1MTM1RlxcXFx1MTM4MC1cXFxcdTEzOEZcXFxcdTEzQTAtXFxcXHUxM0Y0XFxcXHUxNDAxLVxcXFx1MTY2Q1xcXFx1MTY2Ri1cXFxcdTE2N0ZcXFxcdTE2ODEtXFxcXHUxNjlBXFxcXHUxNkEwLVxcXFx1MTZFQVxcXFx1MTZFRS1cXFxcdTE2RjhcXFxcdTE3MDAtXFxcXHUxNzBDXFxcXHUxNzBFLVxcXFx1MTcxNFxcXFx1MTcyMC1cXFxcdTE3MzRcXFxcdTE3NDAtXFxcXHUxNzUzXFxcXHUxNzYwLVxcXFx1MTc2Q1xcXFx1MTc2RS1cXFxcdTE3NzBcXFxcdTE3NzJcXFxcdTE3NzNcXFxcdTE3ODAtXFxcXHUxN0QzXFxcXHUxN0Q3XFxcXHUxN0RDXFxcXHUxN0REXFxcXHUxN0UwLVxcXFx1MTdFOVxcXFx1MTgwQi1cXFxcdTE4MERcXFxcdTE4MTAtXFxcXHUxODE5XFxcXHUxODIwLVxcXFx1MTg3N1xcXFx1MTg4MC1cXFxcdTE4QUFcXFxcdTE4QjAtXFxcXHUxOEY1XFxcXHUxOTAwLVxcXFx1MTkxRVxcXFx1MTkyMC1cXFxcdTE5MkJcXFxcdTE5MzAtXFxcXHUxOTNCXFxcXHUxOTQ2LVxcXFx1MTk2RFxcXFx1MTk3MC1cXFxcdTE5NzRcXFxcdTE5ODAtXFxcXHUxOUFCXFxcXHUxOUIwLVxcXFx1MTlDOVxcXFx1MTlEMC1cXFxcdTE5RDlcXFxcdTFBMDAtXFxcXHUxQTFCXFxcXHUxQTIwLVxcXFx1MUE1RVxcXFx1MUE2MC1cXFxcdTFBN0NcXFxcdTFBN0YtXFxcXHUxQTg5XFxcXHUxQTkwLVxcXFx1MUE5OVxcXFx1MUFBN1xcXFx1MUFCMC1cXFxcdTFBQkRcXFxcdTFCMDAtXFxcXHUxQjRCXFxcXHUxQjUwLVxcXFx1MUI1OVxcXFx1MUI2Qi1cXFxcdTFCNzNcXFxcdTFCODAtXFxcXHUxQkYzXFxcXHUxQzAwLVxcXFx1MUMzN1xcXFx1MUM0MC1cXFxcdTFDNDlcXFxcdTFDNEQtXFxcXHUxQzdEXFxcXHUxQ0QwLVxcXFx1MUNEMlxcXFx1MUNENC1cXFxcdTFDRjZcXFxcdTFDRjhcXFxcdTFDRjlcXFxcdTFEMDAtXFxcXHUxREY1XFxcXHUxREZDLVxcXFx1MUYxNVxcXFx1MUYxOC1cXFxcdTFGMURcXFxcdTFGMjAtXFxcXHUxRjQ1XFxcXHUxRjQ4LVxcXFx1MUY0RFxcXFx1MUY1MC1cXFxcdTFGNTdcXFxcdTFGNTlcXFxcdTFGNUJcXFxcdTFGNURcXFxcdTFGNUYtXFxcXHUxRjdEXFxcXHUxRjgwLVxcXFx1MUZCNFxcXFx1MUZCNi1cXFxcdTFGQkNcXFxcdTFGQkVcXFxcdTFGQzItXFxcXHUxRkM0XFxcXHUxRkM2LVxcXFx1MUZDQ1xcXFx1MUZEMC1cXFxcdTFGRDNcXFxcdTFGRDYtXFxcXHUxRkRCXFxcXHUxRkUwLVxcXFx1MUZFQ1xcXFx1MUZGMi1cXFxcdTFGRjRcXFxcdTFGRjYtXFxcXHUxRkZDXFxcXHUyMDBDXFxcXHUyMDBEXFxcXHUyMDNGXFxcXHUyMDQwXFxcXHUyMDU0XFxcXHUyMDcxXFxcXHUyMDdGXFxcXHUyMDkwLVxcXFx1MjA5Q1xcXFx1MjBEMC1cXFxcdTIwRENcXFxcdTIwRTFcXFxcdTIwRTUtXFxcXHUyMEYwXFxcXHUyMTAyXFxcXHUyMTA3XFxcXHUyMTBBLVxcXFx1MjExM1xcXFx1MjExNVxcXFx1MjExOS1cXFxcdTIxMURcXFxcdTIxMjRcXFxcdTIxMjZcXFxcdTIxMjhcXFxcdTIxMkEtXFxcXHUyMTJEXFxcXHUyMTJGLVxcXFx1MjEzOVxcXFx1MjEzQy1cXFxcdTIxM0ZcXFxcdTIxNDUtXFxcXHUyMTQ5XFxcXHUyMTRFXFxcXHUyMTYwLVxcXFx1MjE4OFxcXFx1MkMwMC1cXFxcdTJDMkVcXFxcdTJDMzAtXFxcXHUyQzVFXFxcXHUyQzYwLVxcXFx1MkNFNFxcXFx1MkNFQi1cXFxcdTJDRjNcXFxcdTJEMDAtXFxcXHUyRDI1XFxcXHUyRDI3XFxcXHUyRDJEXFxcXHUyRDMwLVxcXFx1MkQ2N1xcXFx1MkQ2RlxcXFx1MkQ3Ri1cXFxcdTJEOTZcXFxcdTJEQTAtXFxcXHUyREE2XFxcXHUyREE4LVxcXFx1MkRBRVxcXFx1MkRCMC1cXFxcdTJEQjZcXFxcdTJEQjgtXFxcXHUyREJFXFxcXHUyREMwLVxcXFx1MkRDNlxcXFx1MkRDOC1cXFxcdTJEQ0VcXFxcdTJERDAtXFxcXHUyREQ2XFxcXHUyREQ4LVxcXFx1MkRERVxcXFx1MkRFMC1cXFxcdTJERkZcXFxcdTJFMkZcXFxcdTMwMDUtXFxcXHUzMDA3XFxcXHUzMDIxLVxcXFx1MzAyRlxcXFx1MzAzMS1cXFxcdTMwMzVcXFxcdTMwMzgtXFxcXHUzMDNDXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5OVxcXFx1MzA5QVxcXFx1MzA5RC1cXFxcdTMwOUZcXFxcdTMwQTEtXFxcXHUzMEZBXFxcXHUzMEZDLVxcXFx1MzBGRlxcXFx1MzEwNS1cXFxcdTMxMkRcXFxcdTMxMzEtXFxcXHUzMThFXFxcXHUzMUEwLVxcXFx1MzFCQVxcXFx1MzFGMC1cXFxcdTMxRkZcXFxcdTM0MDAtXFxcXHU0REI1XFxcXHU0RTAwLVxcXFx1OUZDQ1xcXFx1QTAwMC1cXFxcdUE0OENcXFxcdUE0RDAtXFxcXHVBNEZEXFxcXHVBNTAwLVxcXFx1QTYwQ1xcXFx1QTYxMC1cXFxcdUE2MkJcXFxcdUE2NDAtXFxcXHVBNjZGXFxcXHVBNjc0LVxcXFx1QTY3RFxcXFx1QTY3Ri1cXFxcdUE2OURcXFxcdUE2OUYtXFxcXHVBNkYxXFxcXHVBNzE3LVxcXFx1QTcxRlxcXFx1QTcyMi1cXFxcdUE3ODhcXFxcdUE3OEItXFxcXHVBNzhFXFxcXHVBNzkwLVxcXFx1QTdBRFxcXFx1QTdCMFxcXFx1QTdCMVxcXFx1QTdGNy1cXFxcdUE4MjdcXFxcdUE4NDAtXFxcXHVBODczXFxcXHVBODgwLVxcXFx1QThDNFxcXFx1QThEMC1cXFxcdUE4RDlcXFxcdUE4RTAtXFxcXHVBOEY3XFxcXHVBOEZCXFxcXHVBOTAwLVxcXFx1QTkyRFxcXFx1QTkzMC1cXFxcdUE5NTNcXFxcdUE5NjAtXFxcXHVBOTdDXFxcXHVBOTgwLVxcXFx1QTlDMFxcXFx1QTlDRi1cXFxcdUE5RDlcXFxcdUE5RTAtXFxcXHVBOUZFXFxcXHVBQTAwLVxcXFx1QUEzNlxcXFx1QUE0MC1cXFxcdUFBNERcXFxcdUFBNTAtXFxcXHVBQTU5XFxcXHVBQTYwLVxcXFx1QUE3NlxcXFx1QUE3QS1cXFxcdUFBQzJcXFxcdUFBREItXFxcXHVBQUREXFxcXHVBQUUwLVxcXFx1QUFFRlxcXFx1QUFGMi1cXFxcdUFBRjZcXFxcdUFCMDEtXFxcXHVBQjA2XFxcXHVBQjA5LVxcXFx1QUIwRVxcXFx1QUIxMS1cXFxcdUFCMTZcXFxcdUFCMjAtXFxcXHVBQjI2XFxcXHVBQjI4LVxcXFx1QUIyRVxcXFx1QUIzMC1cXFxcdUFCNUFcXFxcdUFCNUMtXFxcXHVBQjVGXFxcXHVBQjY0XFxcXHVBQjY1XFxcXHVBQkMwLVxcXFx1QUJFQVxcXFx1QUJFQ1xcXFx1QUJFRFxcXFx1QUJGMC1cXFxcdUFCRjlcXFxcdUFDMDAtXFxcXHVEN0EzXFxcXHVEN0IwLVxcXFx1RDdDNlxcXFx1RDdDQi1cXFxcdUQ3RkJcXFxcdUY5MDAtXFxcXHVGQTZEXFxcXHVGQTcwLVxcXFx1RkFEOVxcXFx1RkIwMC1cXFxcdUZCMDZcXFxcdUZCMTMtXFxcXHVGQjE3XFxcXHVGQjFELVxcXFx1RkIyOFxcXFx1RkIyQS1cXFxcdUZCMzZcXFxcdUZCMzgtXFxcXHVGQjNDXFxcXHVGQjNFXFxcXHVGQjQwXFxcXHVGQjQxXFxcXHVGQjQzXFxcXHVGQjQ0XFxcXHVGQjQ2LVxcXFx1RkJCMVxcXFx1RkJEMy1cXFxcdUZEM0RcXFxcdUZENTAtXFxcXHVGRDhGXFxcXHVGRDkyLVxcXFx1RkRDN1xcXFx1RkRGMC1cXFxcdUZERkJcXFxcdUZFMDAtXFxcXHVGRTBGXFxcXHVGRTIwLVxcXFx1RkUyRFxcXFx1RkUzM1xcXFx1RkUzNFxcXFx1RkU0RC1cXFxcdUZFNEZcXFxcdUZFNzAtXFxcXHVGRTc0XFxcXHVGRTc2LVxcXFx1RkVGQ1xcXFx1RkYxMC1cXFxcdUZGMTlcXFxcdUZGMjEtXFxcXHVGRjNBXFxcXHVGRjNGXFxcXHVGRjQxLVxcXFx1RkY1QVxcXFx1RkY2Ni1cXFxcdUZGQkVcXFxcdUZGQzItXFxcXHVGRkM3XFxcXHVGRkNBLVxcXFx1RkZDRlxcXFx1RkZEMi1cXFxcdUZGRDdcXFxcdUZGREEtXFxcXHVGRkRDXScpO1xuXG4vLyBFbnN1cmUgdGhlIGNvbmRpdGlvbiBpcyB0cnVlLCBvdGhlcndpc2UgdGhyb3cgYW4gZXJyb3IuXG4vLyBUaGlzIGlzIG9ubHkgdG8gaGF2ZSBhIGJldHRlciBjb250cmFjdCBzZW1hbnRpYywgaS5lLiBhbm90aGVyIHNhZmV0eSBuZXRcbi8vIHRvIGNhdGNoIGEgbG9naWMgZXJyb3IuIFRoZSBjb25kaXRpb24gc2hhbGwgYmUgZnVsZmlsbGVkIGluIG5vcm1hbCBjYXNlLlxuLy8gRG8gTk9UIHVzZSB0aGlzIHRvIGVuZm9yY2UgYSBjZXJ0YWluIGNvbmRpdGlvbiBvbiBhbnkgdXNlciBpbnB1dC5cblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbWVzc2FnZSkge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignQVNTRVJUOiAnICsgbWVzc2FnZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGlzRGVjaW1hbERpZ2l0KGNoKSB7XG4gIHJldHVybiBjaCA+PSAweDMwICYmIGNoIDw9IDB4Mzk7IC8vIDAuLjlcbn1cbmZ1bmN0aW9uIGlzSGV4RGlnaXQoY2gpIHtcbiAgcmV0dXJuICcwMTIzNDU2Nzg5YWJjZGVmQUJDREVGJy5pbmNsdWRlcyhjaCk7XG59XG5mdW5jdGlvbiBpc09jdGFsRGlnaXQoY2gpIHtcbiAgcmV0dXJuICcwMTIzNDU2NycuaW5jbHVkZXMoY2gpO1xufVxuXG4vLyA3LjIgV2hpdGUgU3BhY2VcblxuZnVuY3Rpb24gaXNXaGl0ZVNwYWNlKGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyMCB8fCBjaCA9PT0gMHgwOSB8fCBjaCA9PT0gMHgwQiB8fCBjaCA9PT0gMHgwQyB8fCBjaCA9PT0gMHhBMCB8fCBjaCA+PSAweDE2ODAgJiYgWzB4MTY4MCwgMHgxODBFLCAweDIwMDAsIDB4MjAwMSwgMHgyMDAyLCAweDIwMDMsIDB4MjAwNCwgMHgyMDA1LCAweDIwMDYsIDB4MjAwNywgMHgyMDA4LCAweDIwMDksIDB4MjAwQSwgMHgyMDJGLCAweDIwNUYsIDB4MzAwMCwgMHhGRUZGXS5pbmNsdWRlcyhjaCk7XG59XG5cbi8vIDcuMyBMaW5lIFRlcm1pbmF0b3JzXG5cbmZ1bmN0aW9uIGlzTGluZVRlcm1pbmF0b3IoY2gpIHtcbiAgcmV0dXJuIGNoID09PSAweDBBIHx8IGNoID09PSAweDBEIHx8IGNoID09PSAweDIwMjggfHwgY2ggPT09IDB4MjAyOTtcbn1cblxuLy8gNy42IElkZW50aWZpZXIgTmFtZXMgYW5kIElkZW50aWZpZXJzXG5cbmZ1bmN0aW9uIGlzSWRlbnRpZmllclN0YXJ0KGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RiB8fFxuICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHxcbiAgLy8gQS4uWlxuICBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHxcbiAgLy8gYS4uelxuICBjaCA9PT0gMHg1QyB8fFxuICAvLyBcXCAoYmFja3NsYXNoKVxuICBjaCA+PSAweDgwICYmIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKSk7XG59XG5mdW5jdGlvbiBpc0lkZW50aWZpZXJQYXJ0KGNoKSB7XG4gIHJldHVybiBjaCA9PT0gMHgyNCB8fCBjaCA9PT0gMHg1RiB8fFxuICAvLyAkIChkb2xsYXIpIGFuZCBfICh1bmRlcnNjb3JlKVxuICBjaCA+PSAweDQxICYmIGNoIDw9IDB4NUEgfHxcbiAgLy8gQS4uWlxuICBjaCA+PSAweDYxICYmIGNoIDw9IDB4N0EgfHxcbiAgLy8gYS4uelxuICBjaCA+PSAweDMwICYmIGNoIDw9IDB4MzkgfHxcbiAgLy8gMC4uOVxuICBjaCA9PT0gMHg1QyB8fFxuICAvLyBcXCAoYmFja3NsYXNoKVxuICBjaCA+PSAweDgwICYmIFJlZ2V4Tm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpKTtcbn1cblxuLy8gNy42LjEuMSBLZXl3b3Jkc1xuXG5jb25zdCBrZXl3b3JkcyA9IHtcbiAgJ2lmJzogMSxcbiAgJ2luJzogMSxcbiAgJ2RvJzogMSxcbiAgJ3Zhcic6IDEsXG4gICdmb3InOiAxLFxuICAnbmV3JzogMSxcbiAgJ3RyeSc6IDEsXG4gICdsZXQnOiAxLFxuICAndGhpcyc6IDEsXG4gICdlbHNlJzogMSxcbiAgJ2Nhc2UnOiAxLFxuICAndm9pZCc6IDEsXG4gICd3aXRoJzogMSxcbiAgJ2VudW0nOiAxLFxuICAnd2hpbGUnOiAxLFxuICAnYnJlYWsnOiAxLFxuICAnY2F0Y2gnOiAxLFxuICAndGhyb3cnOiAxLFxuICAnY29uc3QnOiAxLFxuICAneWllbGQnOiAxLFxuICAnY2xhc3MnOiAxLFxuICAnc3VwZXInOiAxLFxuICAncmV0dXJuJzogMSxcbiAgJ3R5cGVvZic6IDEsXG4gICdkZWxldGUnOiAxLFxuICAnc3dpdGNoJzogMSxcbiAgJ2V4cG9ydCc6IDEsXG4gICdpbXBvcnQnOiAxLFxuICAncHVibGljJzogMSxcbiAgJ3N0YXRpYyc6IDEsXG4gICdkZWZhdWx0JzogMSxcbiAgJ2ZpbmFsbHknOiAxLFxuICAnZXh0ZW5kcyc6IDEsXG4gICdwYWNrYWdlJzogMSxcbiAgJ3ByaXZhdGUnOiAxLFxuICAnZnVuY3Rpb24nOiAxLFxuICAnY29udGludWUnOiAxLFxuICAnZGVidWdnZXInOiAxLFxuICAnaW50ZXJmYWNlJzogMSxcbiAgJ3Byb3RlY3RlZCc6IDEsXG4gICdpbnN0YW5jZW9mJzogMSxcbiAgJ2ltcGxlbWVudHMnOiAxXG59O1xuZnVuY3Rpb24gc2tpcENvbW1lbnQoKSB7XG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNvbnN0IGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGlmIChpc1doaXRlU3BhY2UoY2gpIHx8IGlzTGluZVRlcm1pbmF0b3IoY2gpKSB7XG4gICAgICArK2luZGV4O1xuICAgIH0gZWxzZSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNjYW5IZXhFc2NhcGUocHJlZml4KSB7XG4gIHZhciBpLFxuICAgIGxlbixcbiAgICBjaCxcbiAgICBjb2RlID0gMDtcbiAgbGVuID0gcHJlZml4ID09PSAndScgPyA0IDogMjtcbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGluZGV4IDwgbGVuZ3RoICYmIGlzSGV4RGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgIGNoID0gc291cmNlW2luZGV4KytdO1xuICAgICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZSk7XG59XG5mdW5jdGlvbiBzY2FuVW5pY29kZUNvZGVQb2ludEVzY2FwZSgpIHtcbiAgdmFyIGNoLCBjb2RlLCBjdTEsIGN1MjtcbiAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICBjb2RlID0gMDtcblxuICAvLyBBdCBsZWFzdCwgb25lIGhleCBkaWdpdCBpcyByZXF1aXJlZC5cbiAgaWYgKGNoID09PSAnfScpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICBpZiAoIWlzSGV4RGlnaXQoY2gpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29kZSA9IGNvZGUgKiAxNiArICcwMTIzNDU2Nzg5YWJjZGVmJy5pbmRleE9mKGNoLnRvTG93ZXJDYXNlKCkpO1xuICB9XG4gIGlmIChjb2RlID4gMHgxMEZGRkYgfHwgY2ggIT09ICd9Jykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG5cbiAgLy8gVVRGLTE2IEVuY29kaW5nXG4gIGlmIChjb2RlIDw9IDB4RkZGRikge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICB9XG4gIGN1MSA9IChjb2RlIC0gMHgxMDAwMCA+PiAxMCkgKyAweEQ4MDA7XG4gIGN1MiA9IChjb2RlIC0gMHgxMDAwMCAmIDEwMjMpICsgMHhEQzAwO1xuICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjdTEsIGN1Mik7XG59XG5mdW5jdGlvbiBnZXRFc2NhcGVkSWRlbnRpZmllcigpIHtcbiAgdmFyIGNoLCBpZDtcbiAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCsrKTtcbiAgaWQgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNoKTtcblxuICAvLyAnXFx1JyAoVSswMDVDLCBVKzAwNzUpIGRlbm90ZXMgYW4gZXNjYXBlZCBjaGFyYWN0ZXIuXG4gIGlmIChjaCA9PT0gMHg1Qykge1xuICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgIT09IDB4NzUpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cbiAgICArK2luZGV4O1xuICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgIGlmICghY2ggfHwgY2ggPT09ICdcXFxcJyB8fCAhaXNJZGVudGlmaWVyU3RhcnQoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgIH1cbiAgICBpZCA9IGNoO1xuICB9XG4gIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgIGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIGlmICghaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2luZGV4O1xuICAgIGlkICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoY2gpO1xuXG4gICAgLy8gJ1xcdScgKFUrMDA1QywgVSswMDc1KSBkZW5vdGVzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgIGlmIChjaCA9PT0gMHg1Qykge1xuICAgICAgaWQgPSBpZC5zdWJzdHIoMCwgaWQubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpICE9PSAweDc1KSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuICAgICAgKytpbmRleDtcbiAgICAgIGNoID0gc2NhbkhleEVzY2FwZSgndScpO1xuICAgICAgaWYgKCFjaCB8fCBjaCA9PT0gJ1xcXFwnIHx8ICFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuICAgICAgaWQgKz0gY2g7XG4gICAgfVxuICB9XG4gIHJldHVybiBpZDtcbn1cbmZ1bmN0aW9uIGdldElkZW50aWZpZXIoKSB7XG4gIHZhciBzdGFydCwgY2g7XG4gIHN0YXJ0ID0gaW5kZXgrKztcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgaWYgKGNoID09PSAweDVDKSB7XG4gICAgICAvLyBCbGFja3NsYXNoIChVKzAwNUMpIG1hcmtzIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlLlxuICAgICAgaW5kZXggPSBzdGFydDtcbiAgICAgIHJldHVybiBnZXRFc2NhcGVkSWRlbnRpZmllcigpO1xuICAgIH1cbiAgICBpZiAoaXNJZGVudGlmaWVyUGFydChjaCkpIHtcbiAgICAgICsraW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBpbmRleCk7XG59XG5mdW5jdGlvbiBzY2FuSWRlbnRpZmllcigpIHtcbiAgdmFyIHN0YXJ0LCBpZCwgdHlwZTtcbiAgc3RhcnQgPSBpbmRleDtcblxuICAvLyBCYWNrc2xhc2ggKFUrMDA1Qykgc3RhcnRzIGFuIGVzY2FwZWQgY2hhcmFjdGVyLlxuICBpZCA9IHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSA9PT0gMHg1QyA/IGdldEVzY2FwZWRJZGVudGlmaWVyKCkgOiBnZXRJZGVudGlmaWVyKCk7XG5cbiAgLy8gVGhlcmUgaXMgbm8ga2V5d29yZCBvciBsaXRlcmFsIHdpdGggb25seSBvbmUgY2hhcmFjdGVyLlxuICAvLyBUaHVzLCBpdCBtdXN0IGJlIGFuIGlkZW50aWZpZXIuXG4gIGlmIChpZC5sZW5ndGggPT09IDEpIHtcbiAgICB0eXBlID0gVG9rZW5JZGVudGlmaWVyO1xuICB9IGVsc2UgaWYgKGtleXdvcmRzLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gICAgdHlwZSA9IFRva2VuS2V5d29yZDtcbiAgfSBlbHNlIGlmIChpZCA9PT0gJ251bGwnKSB7XG4gICAgdHlwZSA9IFRva2VuTnVsbExpdGVyYWw7XG4gIH0gZWxzZSBpZiAoaWQgPT09ICd0cnVlJyB8fCBpZCA9PT0gJ2ZhbHNlJykge1xuICAgIHR5cGUgPSBUb2tlbkJvb2xlYW5MaXRlcmFsO1xuICB9IGVsc2Uge1xuICAgIHR5cGUgPSBUb2tlbklkZW50aWZpZXI7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHZhbHVlOiBpZCxcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBpbmRleFxuICB9O1xufVxuXG4vLyA3LjcgUHVuY3R1YXRvcnNcblxuZnVuY3Rpb24gc2NhblB1bmN0dWF0b3IoKSB7XG4gIHZhciBzdGFydCA9IGluZGV4LFxuICAgIGNvZGUgPSBzb3VyY2UuY2hhckNvZGVBdChpbmRleCksXG4gICAgY29kZTIsXG4gICAgY2gxID0gc291cmNlW2luZGV4XSxcbiAgICBjaDIsXG4gICAgY2gzLFxuICAgIGNoNDtcbiAgc3dpdGNoIChjb2RlKSB7XG4gICAgLy8gQ2hlY2sgZm9yIG1vc3QgY29tbW9uIHNpbmdsZS1jaGFyYWN0ZXIgcHVuY3R1YXRvcnMuXG4gICAgY2FzZSAweDJFOiAvLyAuIGRvdFxuICAgIGNhc2UgMHgyODogLy8gKCBvcGVuIGJyYWNrZXRcbiAgICBjYXNlIDB4Mjk6IC8vICkgY2xvc2UgYnJhY2tldFxuICAgIGNhc2UgMHgzQjogLy8gOyBzZW1pY29sb25cbiAgICBjYXNlIDB4MkM6IC8vICwgY29tbWFcbiAgICBjYXNlIDB4N0I6IC8vIHsgb3BlbiBjdXJseSBicmFjZVxuICAgIGNhc2UgMHg3RDogLy8gfSBjbG9zZSBjdXJseSBicmFjZVxuICAgIGNhc2UgMHg1QjogLy8gW1xuICAgIGNhc2UgMHg1RDogLy8gXVxuICAgIGNhc2UgMHgzQTogLy8gOlxuICAgIGNhc2UgMHgzRjogLy8gP1xuICAgIGNhc2UgMHg3RTpcbiAgICAgIC8vIH5cbiAgICAgICsraW5kZXg7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICAgIHZhbHVlOiBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpLFxuICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgIGVuZDogaW5kZXhcbiAgICAgIH07XG4gICAgZGVmYXVsdDpcbiAgICAgIGNvZGUyID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXggKyAxKTtcblxuICAgICAgLy8gJz0nIChVKzAwM0QpIG1hcmtzIGFuIGFzc2lnbm1lbnQgb3IgY29tcGFyaXNvbiBvcGVyYXRvci5cbiAgICAgIGlmIChjb2RlMiA9PT0gMHgzRCkge1xuICAgICAgICBzd2l0Y2ggKGNvZGUpIHtcbiAgICAgICAgICBjYXNlIDB4MkI6IC8vICtcbiAgICAgICAgICBjYXNlIDB4MkQ6IC8vIC1cbiAgICAgICAgICBjYXNlIDB4MkY6IC8vIC9cbiAgICAgICAgICBjYXNlIDB4M0M6IC8vIDxcbiAgICAgICAgICBjYXNlIDB4M0U6IC8vID5cbiAgICAgICAgICBjYXNlIDB4NUU6IC8vIF5cbiAgICAgICAgICBjYXNlIDB4N0M6IC8vIHxcbiAgICAgICAgICBjYXNlIDB4MjU6IC8vICVcbiAgICAgICAgICBjYXNlIDB4MjY6IC8vICZcbiAgICAgICAgICBjYXNlIDB4MkE6XG4gICAgICAgICAgICAvLyAqXG4gICAgICAgICAgICBpbmRleCArPSAyO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgICAgICAgICB2YWx1ZTogU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKSArIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZTIpLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgY2FzZSAweDIxOiAvLyAhXG4gICAgICAgICAgY2FzZSAweDNEOlxuICAgICAgICAgICAgLy8gPVxuICAgICAgICAgICAgaW5kZXggKz0gMjtcblxuICAgICAgICAgICAgLy8gIT09IGFuZCA9PT1cbiAgICAgICAgICAgIGlmIChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkgPT09IDB4M0QpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIHR5cGU6IFRva2VuUHVuY3R1YXRvcixcbiAgICAgICAgICAgICAgdmFsdWU6IHNvdXJjZS5zbGljZShzdGFydCwgaW5kZXgpLFxuICAgICAgICAgICAgICBzdGFydDogc3RhcnQsXG4gICAgICAgICAgICAgIGVuZDogaW5kZXhcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIC8vIDQtY2hhcmFjdGVyIHB1bmN0dWF0b3I6ID4+Pj1cblxuICBjaDQgPSBzb3VyY2Uuc3Vic3RyKGluZGV4LCA0KTtcbiAgaWYgKGNoNCA9PT0gJz4+Pj0nKSB7XG4gICAgaW5kZXggKz0gNDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoNCxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG5cbiAgLy8gMy1jaGFyYWN0ZXIgcHVuY3R1YXRvcnM6ID09PSAhPT0gPj4+IDw8PSA+Pj1cblxuICBjaDMgPSBjaDQuc3Vic3RyKDAsIDMpO1xuICBpZiAoY2gzID09PSAnPj4+JyB8fCBjaDMgPT09ICc8PD0nIHx8IGNoMyA9PT0gJz4+PScpIHtcbiAgICBpbmRleCArPSAzO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUb2tlblB1bmN0dWF0b3IsXG4gICAgICB2YWx1ZTogY2gzLFxuICAgICAgc3RhcnQ6IHN0YXJ0LFxuICAgICAgZW5kOiBpbmRleFxuICAgIH07XG4gIH1cblxuICAvLyBPdGhlciAyLWNoYXJhY3RlciBwdW5jdHVhdG9yczogKysgLS0gPDwgPj4gJiYgfHxcbiAgY2gyID0gY2gzLnN1YnN0cigwLCAyKTtcbiAgaWYgKGNoMSA9PT0gY2gyWzFdICYmICcrLTw+JnwnLmluY2x1ZGVzKGNoMSkgfHwgY2gyID09PSAnPT4nKSB7XG4gICAgaW5kZXggKz0gMjtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMixcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG4gIGlmIChjaDIgPT09ICcvLycpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuXG4gIC8vIDEtY2hhcmFjdGVyIHB1bmN0dWF0b3JzOiA8ID4gPSAhICsgLSAqICUgJiB8IF4gL1xuXG4gIGlmICgnPD49ISstKiUmfF4vJy5pbmNsdWRlcyhjaDEpKSB7XG4gICAgKytpbmRleDtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogVG9rZW5QdW5jdHVhdG9yLFxuICAgICAgdmFsdWU6IGNoMSxcbiAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG4gIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xufVxuXG4vLyA3LjguMyBOdW1lcmljIExpdGVyYWxzXG5cbmZ1bmN0aW9uIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KSB7XG4gIGxldCBudW1iZXIgPSAnJztcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc0hleERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgfVxuICBpZiAobnVtYmVyLmxlbmd0aCA9PT0gMCkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlbk51bWVyaWNMaXRlcmFsLFxuICAgIHZhbHVlOiBwYXJzZUludCgnMHgnICsgbnVtYmVyLCAxNiksXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjYW5PY3RhbExpdGVyYWwoc3RhcnQpIHtcbiAgbGV0IG51bWJlciA9ICcwJyArIHNvdXJjZVtpbmRleCsrXTtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgaWYgKCFpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpIHx8IGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCBJTExFR0FMKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IFRva2VuTnVtZXJpY0xpdGVyYWwsXG4gICAgdmFsdWU6IHBhcnNlSW50KG51bWJlciwgOCksXG4gICAgb2N0YWw6IHRydWUsXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjYW5OdW1lcmljTGl0ZXJhbCgpIHtcbiAgdmFyIG51bWJlciwgc3RhcnQsIGNoO1xuICBjaCA9IHNvdXJjZVtpbmRleF07XG4gIGFzc2VydChpc0RlY2ltYWxEaWdpdChjaC5jaGFyQ29kZUF0KDApKSB8fCBjaCA9PT0gJy4nLCAnTnVtZXJpYyBsaXRlcmFsIG11c3Qgc3RhcnQgd2l0aCBhIGRlY2ltYWwgZGlnaXQgb3IgYSBkZWNpbWFsIHBvaW50Jyk7XG4gIHN0YXJ0ID0gaW5kZXg7XG4gIG51bWJlciA9ICcnO1xuICBpZiAoY2ggIT09ICcuJykge1xuICAgIG51bWJlciA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICBjaCA9IHNvdXJjZVtpbmRleF07XG5cbiAgICAvLyBIZXggbnVtYmVyIHN0YXJ0cyB3aXRoICcweCcuXG4gICAgLy8gT2N0YWwgbnVtYmVyIHN0YXJ0cyB3aXRoICcwJy5cbiAgICBpZiAobnVtYmVyID09PSAnMCcpIHtcbiAgICAgIGlmIChjaCA9PT0gJ3gnIHx8IGNoID09PSAnWCcpIHtcbiAgICAgICAgKytpbmRleDtcbiAgICAgICAgcmV0dXJuIHNjYW5IZXhMaXRlcmFsKHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGlmIChpc09jdGFsRGlnaXQoY2gpKSB7XG4gICAgICAgIHJldHVybiBzY2FuT2N0YWxMaXRlcmFsKHN0YXJ0KTtcbiAgICAgIH1cblxuICAgICAgLy8gZGVjaW1hbCBudW1iZXIgc3RhcnRzIHdpdGggJzAnIHN1Y2ggYXMgJzA5JyBpcyBpbGxlZ2FsLlxuICAgICAgaWYgKGNoICYmIGlzRGVjaW1hbERpZ2l0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICAgICAgfVxuICAgIH1cbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICB9XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICB3aGlsZSAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICB9XG4gICAgY2ggPSBzb3VyY2VbaW5kZXhdO1xuICB9XG4gIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIGNoID0gc291cmNlW2luZGV4XTtcbiAgICBpZiAoY2ggPT09ICcrJyB8fCBjaCA9PT0gJy0nKSB7XG4gICAgICBudW1iZXIgKz0gc291cmNlW2luZGV4KytdO1xuICAgIH1cbiAgICBpZiAoaXNEZWNpbWFsRGlnaXQoc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpKSkge1xuICAgICAgd2hpbGUgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4KSkpIHtcbiAgICAgICAgbnVtYmVyICs9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfVxuICB9XG4gIGlmIChpc0lkZW50aWZpZXJTdGFydChzb3VyY2UuY2hhckNvZGVBdChpbmRleCkpKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBUb2tlbk51bWVyaWNMaXRlcmFsLFxuICAgIHZhbHVlOiBwYXJzZUZsb2F0KG51bWJlciksXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cblxuLy8gNy44LjQgU3RyaW5nIExpdGVyYWxzXG5cbmZ1bmN0aW9uIHNjYW5TdHJpbmdMaXRlcmFsKCkge1xuICB2YXIgc3RyID0gJycsXG4gICAgcXVvdGUsXG4gICAgc3RhcnQsXG4gICAgY2gsXG4gICAgY29kZSxcbiAgICBvY3RhbCA9IGZhbHNlO1xuICBxdW90ZSA9IHNvdXJjZVtpbmRleF07XG4gIGFzc2VydChxdW90ZSA9PT0gJ1xcJycgfHwgcXVvdGUgPT09ICdcIicsICdTdHJpbmcgbGl0ZXJhbCBtdXN0IHN0YXJ0cyB3aXRoIGEgcXVvdGUnKTtcbiAgc3RhcnQgPSBpbmRleDtcbiAgKytpbmRleDtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgaWYgKGNoID09PSBxdW90ZSkge1xuICAgICAgcXVvdGUgPSAnJztcbiAgICAgIGJyZWFrO1xuICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgICBpZiAoIWNoIHx8ICFpc0xpbmVUZXJtaW5hdG9yKGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICAgIHN3aXRjaCAoY2gpIHtcbiAgICAgICAgICBjYXNlICd1JzpcbiAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGlmIChzb3VyY2VbaW5kZXhdID09PSAneycpIHtcbiAgICAgICAgICAgICAgKytpbmRleDtcbiAgICAgICAgICAgICAgc3RyICs9IHNjYW5Vbmljb2RlQ29kZVBvaW50RXNjYXBlKCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzdHIgKz0gc2NhbkhleEVzY2FwZShjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxuJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3InOlxuICAgICAgICAgICAgc3RyICs9ICdcXHInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICBzdHIgKz0gJ1xcdCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICAgIHN0ciArPSAnXFxiJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgc3RyICs9ICdcXGYnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAndic6XG4gICAgICAgICAgICBzdHIgKz0gJ1xceDBCJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBpZiAoaXNPY3RhbERpZ2l0KGNoKSkge1xuICAgICAgICAgICAgICBjb2RlID0gJzAxMjM0NTY3Jy5pbmRleE9mKGNoKTtcblxuICAgICAgICAgICAgICAvLyBcXDAgaXMgbm90IG9jdGFsIGVzY2FwZSBzZXF1ZW5jZVxuICAgICAgICAgICAgICBpZiAoY29kZSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIG9jdGFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgaXNPY3RhbERpZ2l0KHNvdXJjZVtpbmRleF0pKSB7XG4gICAgICAgICAgICAgICAgb2N0YWwgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuXG4gICAgICAgICAgICAgICAgLy8gMyBkaWdpdHMgYXJlIG9ubHkgYWxsb3dlZCB3aGVuIHN0cmluZyBzdGFydHNcbiAgICAgICAgICAgICAgICAvLyB3aXRoIDAsIDEsIDIsIDNcbiAgICAgICAgICAgICAgICBpZiAoJzAxMjMnLmluY2x1ZGVzKGNoKSAmJiBpbmRleCA8IGxlbmd0aCAmJiBpc09jdGFsRGlnaXQoc291cmNlW2luZGV4XSkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGUgPSBjb2RlICogOCArICcwMTIzNDU2NycuaW5kZXhPZihzb3VyY2VbaW5kZXgrK10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN0ciArPSBjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoY2ggPT09ICdcXHInICYmIHNvdXJjZVtpbmRleF0gPT09ICdcXG4nKSB7XG4gICAgICAgICAgKytpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgYnJlYWs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0ciArPSBjaDtcbiAgICB9XG4gIH1cbiAgaWYgKHF1b3RlICE9PSAnJykge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbmV4cGVjdGVkVG9rZW4sIElMTEVHQUwpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogVG9rZW5TdHJpbmdMaXRlcmFsLFxuICAgIHZhbHVlOiBzdHIsXG4gICAgb2N0YWw6IG9jdGFsLFxuICAgIHN0YXJ0OiBzdGFydCxcbiAgICBlbmQ6IGluZGV4XG4gIH07XG59XG5mdW5jdGlvbiB0ZXN0UmVnRXhwKHBhdHRlcm4sIGZsYWdzKSB7XG4gIGxldCB0bXAgPSBwYXR0ZXJuO1xuICBpZiAoZmxhZ3MuaW5jbHVkZXMoJ3UnKSkge1xuICAgIC8vIFJlcGxhY2UgZWFjaCBhc3RyYWwgc3ltYm9sIGFuZCBldmVyeSBVbmljb2RlIGNvZGUgcG9pbnRcbiAgICAvLyBlc2NhcGUgc2VxdWVuY2Ugd2l0aCBhIHNpbmdsZSBBU0NJSSBzeW1ib2wgdG8gYXZvaWQgdGhyb3dpbmcgb25cbiAgICAvLyByZWd1bGFyIGV4cHJlc3Npb25zIHRoYXQgYXJlIG9ubHkgdmFsaWQgaW4gY29tYmluYXRpb24gd2l0aCB0aGVcbiAgICAvLyBgL3VgIGZsYWcuXG4gICAgLy8gTm90ZTogcmVwbGFjaW5nIHdpdGggdGhlIEFTQ0lJIHN5bWJvbCBgeGAgbWlnaHQgY2F1c2UgZmFsc2VcbiAgICAvLyBuZWdhdGl2ZXMgaW4gdW5saWtlbHkgc2NlbmFyaW9zLiBGb3IgZXhhbXBsZSwgYFtcXHV7NjF9LWJdYCBpcyBhXG4gICAgLy8gcGVyZmVjdGx5IHZhbGlkIHBhdHRlcm4gdGhhdCBpcyBlcXVpdmFsZW50IHRvIGBbYS1iXWAsIGJ1dCBpdFxuICAgIC8vIHdvdWxkIGJlIHJlcGxhY2VkIGJ5IGBbeC1iXWAgd2hpY2ggdGhyb3dzIGFuIGVycm9yLlxuICAgIHRtcCA9IHRtcC5yZXBsYWNlKC9cXFxcdVxceyhbMC05YS1mQS1GXSspXFx9L2csICgkMCwgJDEpID0+IHtcbiAgICAgIGlmIChwYXJzZUludCgkMSwgMTYpIDw9IDB4MTBGRkZGKSB7XG4gICAgICAgIHJldHVybiAneCc7XG4gICAgICB9XG4gICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlSW52YWxpZFJlZ0V4cCk7XG4gICAgfSkucmVwbGFjZSgvW1xcdUQ4MDAtXFx1REJGRl1bXFx1REMwMC1cXHVERkZGXS9nLCAneCcpO1xuICB9XG5cbiAgLy8gRmlyc3QsIGRldGVjdCBpbnZhbGlkIHJlZ3VsYXIgZXhwcmVzc2lvbnMuXG4gIHRyeSB7XG4gICAgbmV3IFJlZ0V4cCh0bXApO1xuICB9IGNhdGNoIChlKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHApO1xuICB9XG5cbiAgLy8gUmV0dXJuIGEgcmVndWxhciBleHByZXNzaW9uIG9iamVjdCBmb3IgdGhpcyBwYXR0ZXJuLWZsYWcgcGFpciwgb3JcbiAgLy8gYG51bGxgIGluIGNhc2UgdGhlIGN1cnJlbnQgZW52aXJvbm1lbnQgZG9lc24ndCBzdXBwb3J0IHRoZSBmbGFncyBpdFxuICAvLyB1c2VzLlxuICB0cnkge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKHBhdHRlcm4sIGZsYWdzKTtcbiAgfSBjYXRjaCAoZXhjZXB0aW9uKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHNjYW5SZWdFeHBCb2R5KCkge1xuICB2YXIgY2gsIHN0ciwgY2xhc3NNYXJrZXIsIHRlcm1pbmF0ZWQsIGJvZHk7XG4gIGNoID0gc291cmNlW2luZGV4XTtcbiAgYXNzZXJ0KGNoID09PSAnLycsICdSZWd1bGFyIGV4cHJlc3Npb24gbGl0ZXJhbCBtdXN0IHN0YXJ0IHdpdGggYSBzbGFzaCcpO1xuICBzdHIgPSBzb3VyY2VbaW5kZXgrK107XG4gIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gIHRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgd2hpbGUgKGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgY2ggPSBzb3VyY2VbaW5kZXgrK107XG4gICAgc3RyICs9IGNoO1xuICAgIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICBjaCA9IHNvdXJjZVtpbmRleCsrXTtcbiAgICAgIC8vIEVDTUEtMjYyIDcuOC41XG4gICAgICBpZiAoaXNMaW5lVGVybWluYXRvcihjaC5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB0aHJvd0Vycm9yKHt9LCBNZXNzYWdlVW50ZXJtaW5hdGVkUmVnRXhwKTtcbiAgICAgIH1cbiAgICAgIHN0ciArPSBjaDtcbiAgICB9IGVsc2UgaWYgKGlzTGluZVRlcm1pbmF0b3IoY2guY2hhckNvZGVBdCgwKSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHApO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NNYXJrZXIpIHtcbiAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgIGNsYXNzTWFya2VyID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaCA9PT0gJy8nKSB7XG4gICAgICAgIHRlcm1pbmF0ZWQgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICBjbGFzc01hcmtlciA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghdGVybWluYXRlZCkge1xuICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VVbnRlcm1pbmF0ZWRSZWdFeHApO1xuICB9XG5cbiAgLy8gRXhjbHVkZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaC5cbiAgYm9keSA9IHN0ci5zdWJzdHIoMSwgc3RyLmxlbmd0aCAtIDIpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiBib2R5LFxuICAgIGxpdGVyYWw6IHN0clxuICB9O1xufVxuZnVuY3Rpb24gc2NhblJlZ0V4cEZsYWdzKCkge1xuICB2YXIgY2gsIHN0ciwgZmxhZ3M7XG4gIHN0ciA9ICcnO1xuICBmbGFncyA9ICcnO1xuICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICBjaCA9IHNvdXJjZVtpbmRleF07XG4gICAgaWYgKCFpc0lkZW50aWZpZXJQYXJ0KGNoLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytpbmRleDtcbiAgICBpZiAoY2ggPT09ICdcXFxcJyAmJiBpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZVVuZXhwZWN0ZWRUb2tlbiwgSUxMRUdBTCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWdzICs9IGNoO1xuICAgICAgc3RyICs9IGNoO1xuICAgIH1cbiAgfVxuICBpZiAoZmxhZ3Muc2VhcmNoKC9bXmdpbXV5XS9nKSA+PSAwKSB7XG4gICAgdGhyb3dFcnJvcih7fSwgTWVzc2FnZUludmFsaWRSZWdFeHAsIGZsYWdzKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHZhbHVlOiBmbGFncyxcbiAgICBsaXRlcmFsOiBzdHJcbiAgfTtcbn1cbmZ1bmN0aW9uIHNjYW5SZWdFeHAoKSB7XG4gIHZhciBzdGFydCwgYm9keSwgZmxhZ3MsIHZhbHVlO1xuICBsb29rYWhlYWQgPSBudWxsO1xuICBza2lwQ29tbWVudCgpO1xuICBzdGFydCA9IGluZGV4O1xuICBib2R5ID0gc2NhblJlZ0V4cEJvZHkoKTtcbiAgZmxhZ3MgPSBzY2FuUmVnRXhwRmxhZ3MoKTtcbiAgdmFsdWUgPSB0ZXN0UmVnRXhwKGJvZHkudmFsdWUsIGZsYWdzLnZhbHVlKTtcbiAgcmV0dXJuIHtcbiAgICBsaXRlcmFsOiBib2R5LmxpdGVyYWwgKyBmbGFncy5saXRlcmFsLFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICByZWdleDoge1xuICAgICAgcGF0dGVybjogYm9keS52YWx1ZSxcbiAgICAgIGZsYWdzOiBmbGFncy52YWx1ZVxuICAgIH0sXG4gICAgc3RhcnQ6IHN0YXJ0LFxuICAgIGVuZDogaW5kZXhcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzSWRlbnRpZmllck5hbWUodG9rZW4pIHtcbiAgcmV0dXJuIHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllciB8fCB0b2tlbi50eXBlID09PSBUb2tlbktleXdvcmQgfHwgdG9rZW4udHlwZSA9PT0gVG9rZW5Cb29sZWFuTGl0ZXJhbCB8fCB0b2tlbi50eXBlID09PSBUb2tlbk51bGxMaXRlcmFsO1xufVxuZnVuY3Rpb24gYWR2YW5jZSgpIHtcbiAgc2tpcENvbW1lbnQoKTtcbiAgaWYgKGluZGV4ID49IGxlbmd0aCkge1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBUb2tlbkVPRixcbiAgICAgIHN0YXJ0OiBpbmRleCxcbiAgICAgIGVuZDogaW5kZXhcbiAgICB9O1xuICB9XG4gIGNvbnN0IGNoID0gc291cmNlLmNoYXJDb2RlQXQoaW5kZXgpO1xuICBpZiAoaXNJZGVudGlmaWVyU3RhcnQoY2gpKSB7XG4gICAgcmV0dXJuIHNjYW5JZGVudGlmaWVyKCk7XG4gIH1cblxuICAvLyBWZXJ5IGNvbW1vbjogKCBhbmQgKSBhbmQgO1xuICBpZiAoY2ggPT09IDB4MjggfHwgY2ggPT09IDB4MjkgfHwgY2ggPT09IDB4M0IpIHtcbiAgICByZXR1cm4gc2NhblB1bmN0dWF0b3IoKTtcbiAgfVxuXG4gIC8vIFN0cmluZyBsaXRlcmFsIHN0YXJ0cyB3aXRoIHNpbmdsZSBxdW90ZSAoVSswMDI3KSBvciBkb3VibGUgcXVvdGUgKFUrMDAyMikuXG4gIGlmIChjaCA9PT0gMHgyNyB8fCBjaCA9PT0gMHgyMikge1xuICAgIHJldHVybiBzY2FuU3RyaW5nTGl0ZXJhbCgpO1xuICB9XG5cbiAgLy8gRG90ICguKSBVKzAwMkUgY2FuIGFsc28gc3RhcnQgYSBmbG9hdGluZy1wb2ludCBudW1iZXIsIGhlbmNlIHRoZSBuZWVkXG4gIC8vIHRvIGNoZWNrIHRoZSBuZXh0IGNoYXJhY3Rlci5cbiAgaWYgKGNoID09PSAweDJFKSB7XG4gICAgaWYgKGlzRGVjaW1hbERpZ2l0KHNvdXJjZS5jaGFyQ29kZUF0KGluZGV4ICsgMSkpKSB7XG4gICAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FuUHVuY3R1YXRvcigpO1xuICB9XG4gIGlmIChpc0RlY2ltYWxEaWdpdChjaCkpIHtcbiAgICByZXR1cm4gc2Nhbk51bWVyaWNMaXRlcmFsKCk7XG4gIH1cbiAgcmV0dXJuIHNjYW5QdW5jdHVhdG9yKCk7XG59XG5mdW5jdGlvbiBsZXgoKSB7XG4gIGNvbnN0IHRva2VuID0gbG9va2FoZWFkO1xuICBpbmRleCA9IHRva2VuLmVuZDtcbiAgbG9va2FoZWFkID0gYWR2YW5jZSgpO1xuICBpbmRleCA9IHRva2VuLmVuZDtcbiAgcmV0dXJuIHRva2VuO1xufVxuZnVuY3Rpb24gcGVlaygpIHtcbiAgY29uc3QgcG9zID0gaW5kZXg7XG4gIGxvb2thaGVhZCA9IGFkdmFuY2UoKTtcbiAgaW5kZXggPSBwb3M7XG59XG5mdW5jdGlvbiBmaW5pc2hBcnJheUV4cHJlc3Npb24oZWxlbWVudHMpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheEFycmF5RXhwcmVzc2lvbik7XG4gIG5vZGUuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUob3BlcmF0b3IgPT09ICd8fCcgfHwgb3BlcmF0b3IgPT09ICcmJicgPyBTeW50YXhMb2dpY2FsRXhwcmVzc2lvbiA6IFN5bnRheEJpbmFyeUV4cHJlc3Npb24pO1xuICBub2RlLm9wZXJhdG9yID0gb3BlcmF0b3I7XG4gIG5vZGUubGVmdCA9IGxlZnQ7XG4gIG5vZGUucmlnaHQgPSByaWdodDtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5pc2hDYWxsRXhwcmVzc2lvbihjYWxsZWUsIGFyZ3MpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheENhbGxFeHByZXNzaW9uKTtcbiAgbm9kZS5jYWxsZWUgPSBjYWxsZWU7XG4gIG5vZGUuYXJndW1lbnRzID0gYXJncztcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24odGVzdCwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKSB7XG4gIGNvbnN0IG5vZGUgPSBuZXcgQVNUTm9kZShTeW50YXhDb25kaXRpb25hbEV4cHJlc3Npb24pO1xuICBub2RlLnRlc3QgPSB0ZXN0O1xuICBub2RlLmNvbnNlcXVlbnQgPSBjb25zZXF1ZW50O1xuICBub2RlLmFsdGVybmF0ZSA9IGFsdGVybmF0ZTtcbiAgcmV0dXJuIG5vZGU7XG59XG5mdW5jdGlvbiBmaW5pc2hJZGVudGlmaWVyKG5hbWUpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheElkZW50aWZpZXIpO1xuICBub2RlLm5hbWUgPSBuYW1lO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaExpdGVyYWwodG9rZW4pIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheExpdGVyYWwpO1xuICBub2RlLnZhbHVlID0gdG9rZW4udmFsdWU7XG4gIG5vZGUucmF3ID0gc291cmNlLnNsaWNlKHRva2VuLnN0YXJ0LCB0b2tlbi5lbmQpO1xuICBpZiAodG9rZW4ucmVnZXgpIHtcbiAgICBpZiAobm9kZS5yYXcgPT09ICcvLycpIHtcbiAgICAgIG5vZGUucmF3ID0gJy8oPzopLyc7XG4gICAgfVxuICAgIG5vZGUucmVnZXggPSB0b2tlbi5yZWdleDtcbiAgfVxuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaE1lbWJlckV4cHJlc3Npb24oYWNjZXNzb3IsIG9iamVjdCwgcHJvcGVydHkpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheE1lbWJlckV4cHJlc3Npb24pO1xuICBub2RlLmNvbXB1dGVkID0gYWNjZXNzb3IgPT09ICdbJztcbiAgbm9kZS5vYmplY3QgPSBvYmplY3Q7XG4gIG5vZGUucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgaWYgKCFub2RlLmNvbXB1dGVkKSBwcm9wZXJ0eS5tZW1iZXIgPSB0cnVlO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcykge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4T2JqZWN0RXhwcmVzc2lvbik7XG4gIG5vZGUucHJvcGVydGllcyA9IHByb3BlcnRpZXM7XG4gIHJldHVybiBub2RlO1xufVxuZnVuY3Rpb24gZmluaXNoUHJvcGVydHkoa2luZCwga2V5LCB2YWx1ZSkge1xuICBjb25zdCBub2RlID0gbmV3IEFTVE5vZGUoU3ludGF4UHJvcGVydHkpO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBub2RlLmtpbmQgPSBraW5kO1xuICByZXR1cm4gbm9kZTtcbn1cbmZ1bmN0aW9uIGZpbmlzaFVuYXJ5RXhwcmVzc2lvbihvcGVyYXRvciwgYXJndW1lbnQpIHtcbiAgY29uc3Qgbm9kZSA9IG5ldyBBU1ROb2RlKFN5bnRheFVuYXJ5RXhwcmVzc2lvbik7XG4gIG5vZGUub3BlcmF0b3IgPSBvcGVyYXRvcjtcbiAgbm9kZS5hcmd1bWVudCA9IGFyZ3VtZW50O1xuICBub2RlLnByZWZpeCA9IHRydWU7XG4gIHJldHVybiBub2RlO1xufVxuXG4vLyBUaHJvdyBhbiBleGNlcHRpb25cblxuZnVuY3Rpb24gdGhyb3dFcnJvcih0b2tlbiwgbWVzc2FnZUZvcm1hdCkge1xuICB2YXIgZXJyb3IsXG4gICAgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMiksXG4gICAgbXNnID0gbWVzc2FnZUZvcm1hdC5yZXBsYWNlKC8lKFxcZCkvZywgKHdob2xlLCBpbmRleCkgPT4ge1xuICAgICAgYXNzZXJ0KGluZGV4IDwgYXJncy5sZW5ndGgsICdNZXNzYWdlIHJlZmVyZW5jZSBtdXN0IGJlIGluIHJhbmdlJyk7XG4gICAgICByZXR1cm4gYXJnc1tpbmRleF07XG4gICAgfSk7XG4gIGVycm9yID0gbmV3IEVycm9yKG1zZyk7XG4gIGVycm9yLmluZGV4ID0gaW5kZXg7XG4gIGVycm9yLmRlc2NyaXB0aW9uID0gbXNnO1xuICB0aHJvdyBlcnJvcjtcbn1cblxuLy8gVGhyb3cgYW4gZXhjZXB0aW9uIGJlY2F1c2Ugb2YgdGhlIHRva2VuLlxuXG5mdW5jdGlvbiB0aHJvd1VuZXhwZWN0ZWQodG9rZW4pIHtcbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuRU9GKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWRFT1MpO1xuICB9XG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlbk51bWVyaWNMaXRlcmFsKSB7XG4gICAgdGhyb3dFcnJvcih0b2tlbiwgTWVzc2FnZVVuZXhwZWN0ZWROdW1iZXIpO1xuICB9XG4gIGlmICh0b2tlbi50eXBlID09PSBUb2tlblN0cmluZ0xpdGVyYWwpIHtcbiAgICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlVW5leHBlY3RlZFN0cmluZyk7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuSWRlbnRpZmllcikge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkSWRlbnRpZmllcik7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuS2V5d29yZCkge1xuICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VVbmV4cGVjdGVkUmVzZXJ2ZWQpO1xuICB9XG5cbiAgLy8gQm9vbGVhbkxpdGVyYWwsIE51bGxMaXRlcmFsLCBvciBQdW5jdHVhdG9yLlxuICB0aHJvd0Vycm9yKHRva2VuLCBNZXNzYWdlVW5leHBlY3RlZFRva2VuLCB0b2tlbi52YWx1ZSk7XG59XG5cbi8vIEV4cGVjdCB0aGUgbmV4dCB0b2tlbiB0byBtYXRjaCB0aGUgc3BlY2lmaWVkIHB1bmN0dWF0b3IuXG4vLyBJZiBub3QsIGFuIGV4Y2VwdGlvbiB3aWxsIGJlIHRocm93bi5cblxuZnVuY3Rpb24gZXhwZWN0KHZhbHVlKSB7XG4gIGNvbnN0IHRva2VuID0gbGV4KCk7XG4gIGlmICh0b2tlbi50eXBlICE9PSBUb2tlblB1bmN0dWF0b3IgfHwgdG9rZW4udmFsdWUgIT09IHZhbHVlKSB7XG4gICAgdGhyb3dVbmV4cGVjdGVkKHRva2VuKTtcbiAgfVxufVxuXG4vLyBSZXR1cm4gdHJ1ZSBpZiB0aGUgbmV4dCB0b2tlbiBtYXRjaGVzIHRoZSBzcGVjaWZpZWQgcHVuY3R1YXRvci5cblxuZnVuY3Rpb24gbWF0Y2godmFsdWUpIHtcbiAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlblB1bmN0dWF0b3IgJiYgbG9va2FoZWFkLnZhbHVlID09PSB2YWx1ZTtcbn1cblxuLy8gUmV0dXJuIHRydWUgaWYgdGhlIG5leHQgdG9rZW4gbWF0Y2hlcyB0aGUgc3BlY2lmaWVkIGtleXdvcmRcblxuZnVuY3Rpb24gbWF0Y2hLZXl3b3JkKGtleXdvcmQpIHtcbiAgcmV0dXJuIGxvb2thaGVhZC50eXBlID09PSBUb2tlbktleXdvcmQgJiYgbG9va2FoZWFkLnZhbHVlID09PSBrZXl3b3JkO1xufVxuXG4vLyAxMS4xLjQgQXJyYXkgSW5pdGlhbGlzZXJcblxuZnVuY3Rpb24gcGFyc2VBcnJheUluaXRpYWxpc2VyKCkge1xuICBjb25zdCBlbGVtZW50cyA9IFtdO1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgZXhwZWN0KCdbJyk7XG4gIHdoaWxlICghbWF0Y2goJ10nKSkge1xuICAgIGlmIChtYXRjaCgnLCcpKSB7XG4gICAgICBsZXgoKTtcbiAgICAgIGVsZW1lbnRzLnB1c2gobnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnRzLnB1c2gocGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSk7XG4gICAgICBpZiAoIW1hdGNoKCddJykpIHtcbiAgICAgICAgZXhwZWN0KCcsJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxleCgpO1xuICByZXR1cm4gZmluaXNoQXJyYXlFeHByZXNzaW9uKGVsZW1lbnRzKTtcbn1cblxuLy8gMTEuMS41IE9iamVjdCBJbml0aWFsaXNlclxuXG5mdW5jdGlvbiBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCkge1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgY29uc3QgdG9rZW4gPSBsZXgoKTtcblxuICAvLyBOb3RlOiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbmx5IGZyb20gcGFyc2VPYmplY3RQcm9wZXJ0eSgpLCB3aGVyZVxuICAvLyBFT0YgYW5kIFB1bmN0dWF0b3IgdG9rZW5zIGFyZSBhbHJlYWR5IGZpbHRlcmVkIG91dC5cblxuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5TdHJpbmdMaXRlcmFsIHx8IHRva2VuLnR5cGUgPT09IFRva2VuTnVtZXJpY0xpdGVyYWwpIHtcbiAgICBpZiAodG9rZW4ub2N0YWwpIHtcbiAgICAgIHRocm93RXJyb3IodG9rZW4sIE1lc3NhZ2VTdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgIH1cbiAgICByZXR1cm4gZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gIH1cbiAgcmV0dXJuIGZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RQcm9wZXJ0eSgpIHtcbiAgdmFyIHRva2VuLCBrZXksIGlkLCB2YWx1ZTtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIHRva2VuID0gbG9va2FoZWFkO1xuICBpZiAodG9rZW4udHlwZSA9PT0gVG9rZW5JZGVudGlmaWVyKSB7XG4gICAgaWQgPSBwYXJzZU9iamVjdFByb3BlcnR5S2V5KCk7XG4gICAgZXhwZWN0KCc6Jyk7XG4gICAgdmFsdWUgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIHJldHVybiBmaW5pc2hQcm9wZXJ0eSgnaW5pdCcsIGlkLCB2YWx1ZSk7XG4gIH1cbiAgaWYgKHRva2VuLnR5cGUgPT09IFRva2VuRU9GIHx8IHRva2VuLnR5cGUgPT09IFRva2VuUHVuY3R1YXRvcikge1xuICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gcGFyc2VPYmplY3RQcm9wZXJ0eUtleSgpO1xuICAgIGV4cGVjdCgnOicpO1xuICAgIHZhbHVlID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICByZXR1cm4gZmluaXNoUHJvcGVydHkoJ2luaXQnLCBrZXksIHZhbHVlKTtcbiAgfVxufVxuZnVuY3Rpb24gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSBbXSxcbiAgICBwcm9wZXJ0eSxcbiAgICBuYW1lLFxuICAgIGtleSxcbiAgICBtYXAgPSB7fSxcbiAgICB0b1N0cmluZyA9IFN0cmluZztcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGV4cGVjdCgneycpO1xuICB3aGlsZSAoIW1hdGNoKCd9JykpIHtcbiAgICBwcm9wZXJ0eSA9IHBhcnNlT2JqZWN0UHJvcGVydHkoKTtcbiAgICBpZiAocHJvcGVydHkua2V5LnR5cGUgPT09IFN5bnRheElkZW50aWZpZXIpIHtcbiAgICAgIG5hbWUgPSBwcm9wZXJ0eS5rZXkubmFtZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmFtZSA9IHRvU3RyaW5nKHByb3BlcnR5LmtleS52YWx1ZSk7XG4gICAgfVxuICAgIGtleSA9ICckJyArIG5hbWU7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGtleSkpIHtcbiAgICAgIHRocm93RXJyb3Ioe30sIE1lc3NhZ2VTdHJpY3REdXBsaWNhdGVQcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1hcFtrZXldID0gdHJ1ZTtcbiAgICB9XG4gICAgcHJvcGVydGllcy5wdXNoKHByb3BlcnR5KTtcbiAgICBpZiAoIW1hdGNoKCd9JykpIHtcbiAgICAgIGV4cGVjdCgnLCcpO1xuICAgIH1cbiAgfVxuICBleHBlY3QoJ30nKTtcbiAgcmV0dXJuIGZpbmlzaE9iamVjdEV4cHJlc3Npb24ocHJvcGVydGllcyk7XG59XG5cbi8vIDExLjEuNiBUaGUgR3JvdXBpbmcgT3BlcmF0b3JcblxuZnVuY3Rpb24gcGFyc2VHcm91cEV4cHJlc3Npb24oKSB7XG4gIGV4cGVjdCgnKCcpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gIGV4cGVjdCgnKScpO1xuICByZXR1cm4gZXhwcjtcbn1cblxuLy8gMTEuMSBQcmltYXJ5IEV4cHJlc3Npb25zXG5cbmNvbnN0IGxlZ2FsS2V5d29yZHMgPSB7XG4gICdpZic6IDFcbn07XG5mdW5jdGlvbiBwYXJzZVByaW1hcnlFeHByZXNzaW9uKCkge1xuICB2YXIgdHlwZSwgdG9rZW4sIGV4cHI7XG4gIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgcmV0dXJuIHBhcnNlR3JvdXBFeHByZXNzaW9uKCk7XG4gIH1cbiAgaWYgKG1hdGNoKCdbJykpIHtcbiAgICByZXR1cm4gcGFyc2VBcnJheUluaXRpYWxpc2VyKCk7XG4gIH1cbiAgaWYgKG1hdGNoKCd7JykpIHtcbiAgICByZXR1cm4gcGFyc2VPYmplY3RJbml0aWFsaXNlcigpO1xuICB9XG4gIHR5cGUgPSBsb29rYWhlYWQudHlwZTtcbiAgaW5kZXggPSBsb29rYWhlYWQuc3RhcnQ7XG4gIGlmICh0eXBlID09PSBUb2tlbklkZW50aWZpZXIgfHwgbGVnYWxLZXl3b3Jkc1tsb29rYWhlYWQudmFsdWVdKSB7XG4gICAgZXhwciA9IGZpbmlzaElkZW50aWZpZXIobGV4KCkudmFsdWUpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuU3RyaW5nTGl0ZXJhbCB8fCB0eXBlID09PSBUb2tlbk51bWVyaWNMaXRlcmFsKSB7XG4gICAgaWYgKGxvb2thaGVhZC5vY3RhbCkge1xuICAgICAgdGhyb3dFcnJvcihsb29rYWhlYWQsIE1lc3NhZ2VTdHJpY3RPY3RhbExpdGVyYWwpO1xuICAgIH1cbiAgICBleHByID0gZmluaXNoTGl0ZXJhbChsZXgoKSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBUb2tlbkJvb2xlYW5MaXRlcmFsKSB7XG4gICAgdG9rZW4gPSBsZXgoKTtcbiAgICB0b2tlbi52YWx1ZSA9IHRva2VuLnZhbHVlID09PSAndHJ1ZSc7XG4gICAgZXhwciA9IGZpbmlzaExpdGVyYWwodG9rZW4pO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IFRva2VuTnVsbExpdGVyYWwpIHtcbiAgICB0b2tlbiA9IGxleCgpO1xuICAgIHRva2VuLnZhbHVlID0gbnVsbDtcbiAgICBleHByID0gZmluaXNoTGl0ZXJhbCh0b2tlbik7XG4gIH0gZWxzZSBpZiAobWF0Y2goJy8nKSB8fCBtYXRjaCgnLz0nKSkge1xuICAgIGV4cHIgPSBmaW5pc2hMaXRlcmFsKHNjYW5SZWdFeHAoKSk7XG4gICAgcGVlaygpO1xuICB9IGVsc2Uge1xuICAgIHRocm93VW5leHBlY3RlZChsZXgoKSk7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59XG5cbi8vIDExLjIgTGVmdC1IYW5kLVNpZGUgRXhwcmVzc2lvbnNcblxuZnVuY3Rpb24gcGFyc2VBcmd1bWVudHMoKSB7XG4gIGNvbnN0IGFyZ3MgPSBbXTtcbiAgZXhwZWN0KCcoJyk7XG4gIGlmICghbWF0Y2goJyknKSkge1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJncy5wdXNoKHBhcnNlQ29uZGl0aW9uYWxFeHByZXNzaW9uKCkpO1xuICAgICAgaWYgKG1hdGNoKCcpJykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBleHBlY3QoJywnKTtcbiAgICB9XG4gIH1cbiAgZXhwZWN0KCcpJyk7XG4gIHJldHVybiBhcmdzO1xufVxuZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZFByb3BlcnR5KCkge1xuICBpbmRleCA9IGxvb2thaGVhZC5zdGFydDtcbiAgY29uc3QgdG9rZW4gPSBsZXgoKTtcbiAgaWYgKCFpc0lkZW50aWZpZXJOYW1lKHRva2VuKSkge1xuICAgIHRocm93VW5leHBlY3RlZCh0b2tlbik7XG4gIH1cbiAgcmV0dXJuIGZpbmlzaElkZW50aWZpZXIodG9rZW4udmFsdWUpO1xufVxuZnVuY3Rpb24gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpIHtcbiAgZXhwZWN0KCcuJyk7XG4gIHJldHVybiBwYXJzZU5vbkNvbXB1dGVkUHJvcGVydHkoKTtcbn1cbmZ1bmN0aW9uIHBhcnNlQ29tcHV0ZWRNZW1iZXIoKSB7XG4gIGV4cGVjdCgnWycpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gIGV4cGVjdCgnXScpO1xuICByZXR1cm4gZXhwcjtcbn1cbmZ1bmN0aW9uIHBhcnNlTGVmdEhhbmRTaWRlRXhwcmVzc2lvbkFsbG93Q2FsbCgpIHtcbiAgdmFyIGV4cHIsIGFyZ3MsIHByb3BlcnR5O1xuICBleHByID0gcGFyc2VQcmltYXJ5RXhwcmVzc2lvbigpO1xuICBmb3IgKDs7KSB7XG4gICAgaWYgKG1hdGNoKCcuJykpIHtcbiAgICAgIHByb3BlcnR5ID0gcGFyc2VOb25Db21wdXRlZE1lbWJlcigpO1xuICAgICAgZXhwciA9IGZpbmlzaE1lbWJlckV4cHJlc3Npb24oJy4nLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCgnKCcpKSB7XG4gICAgICBhcmdzID0gcGFyc2VBcmd1bWVudHMoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hDYWxsRXhwcmVzc2lvbihleHByLCBhcmdzKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoKCdbJykpIHtcbiAgICAgIHByb3BlcnR5ID0gcGFyc2VDb21wdXRlZE1lbWJlcigpO1xuICAgICAgZXhwciA9IGZpbmlzaE1lbWJlckV4cHJlc3Npb24oJ1snLCBleHByLCBwcm9wZXJ0eSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwcjtcbn1cblxuLy8gMTEuMyBQb3N0Zml4IEV4cHJlc3Npb25zXG5cbmZ1bmN0aW9uIHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKSB7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUxlZnRIYW5kU2lkZUV4cHJlc3Npb25BbGxvd0NhbGwoKTtcbiAgaWYgKGxvb2thaGVhZC50eXBlID09PSBUb2tlblB1bmN0dWF0b3IpIHtcbiAgICBpZiAobWF0Y2goJysrJykgfHwgbWF0Y2goJy0tJykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihESVNBQkxFRCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBleHByO1xufVxuXG4vLyAxMS40IFVuYXJ5IE9wZXJhdG9yc1xuXG5mdW5jdGlvbiBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpIHtcbiAgdmFyIHRva2VuLCBleHByO1xuICBpZiAobG9va2FoZWFkLnR5cGUgIT09IFRva2VuUHVuY3R1YXRvciAmJiBsb29rYWhlYWQudHlwZSAhPT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgZXhwciA9IHBhcnNlUG9zdGZpeEV4cHJlc3Npb24oKTtcbiAgfSBlbHNlIGlmIChtYXRjaCgnKysnKSB8fCBtYXRjaCgnLS0nKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihESVNBQkxFRCk7XG4gIH0gZWxzZSBpZiAobWF0Y2goJysnKSB8fCBtYXRjaCgnLScpIHx8IG1hdGNoKCd+JykgfHwgbWF0Y2goJyEnKSkge1xuICAgIHRva2VuID0gbGV4KCk7XG4gICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgZXhwciA9IGZpbmlzaFVuYXJ5RXhwcmVzc2lvbih0b2tlbi52YWx1ZSwgZXhwcik7XG4gIH0gZWxzZSBpZiAobWF0Y2hLZXl3b3JkKCdkZWxldGUnKSB8fCBtYXRjaEtleXdvcmQoJ3ZvaWQnKSB8fCBtYXRjaEtleXdvcmQoJ3R5cGVvZicpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKERJU0FCTEVEKTtcbiAgfSBlbHNlIHtcbiAgICBleHByID0gcGFyc2VQb3N0Zml4RXhwcmVzc2lvbigpO1xuICB9XG4gIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbikge1xuICBsZXQgcHJlYyA9IDA7XG4gIGlmICh0b2tlbi50eXBlICE9PSBUb2tlblB1bmN0dWF0b3IgJiYgdG9rZW4udHlwZSAhPT0gVG9rZW5LZXl3b3JkKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgc3dpdGNoICh0b2tlbi52YWx1ZSkge1xuICAgIGNhc2UgJ3x8JzpcbiAgICAgIHByZWMgPSAxO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnJiYnOlxuICAgICAgcHJlYyA9IDI7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd8JzpcbiAgICAgIHByZWMgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnXic6XG4gICAgICBwcmVjID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyYnOlxuICAgICAgcHJlYyA9IDU7XG4gICAgICBicmVhaztcbiAgICBjYXNlICc9PSc6XG4gICAgY2FzZSAnIT0nOlxuICAgIGNhc2UgJz09PSc6XG4gICAgY2FzZSAnIT09JzpcbiAgICAgIHByZWMgPSA2O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnPCc6XG4gICAgY2FzZSAnPic6XG4gICAgY2FzZSAnPD0nOlxuICAgIGNhc2UgJz49JzpcbiAgICBjYXNlICdpbnN0YW5jZW9mJzpcbiAgICBjYXNlICdpbic6XG4gICAgICBwcmVjID0gNztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJzw8JzpcbiAgICBjYXNlICc+Pic6XG4gICAgY2FzZSAnPj4+JzpcbiAgICAgIHByZWMgPSA4O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnKyc6XG4gICAgY2FzZSAnLSc6XG4gICAgICBwcmVjID0gOTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJyonOlxuICAgIGNhc2UgJy8nOlxuICAgIGNhc2UgJyUnOlxuICAgICAgcHJlYyA9IDExO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHByZWM7XG59XG5cbi8vIDExLjUgTXVsdGlwbGljYXRpdmUgT3BlcmF0b3JzXG4vLyAxMS42IEFkZGl0aXZlIE9wZXJhdG9yc1xuLy8gMTEuNyBCaXR3aXNlIFNoaWZ0IE9wZXJhdG9yc1xuLy8gMTEuOCBSZWxhdGlvbmFsIE9wZXJhdG9yc1xuLy8gMTEuOSBFcXVhbGl0eSBPcGVyYXRvcnNcbi8vIDExLjEwIEJpbmFyeSBCaXR3aXNlIE9wZXJhdG9yc1xuLy8gMTEuMTEgQmluYXJ5IExvZ2ljYWwgT3BlcmF0b3JzXG5cbmZ1bmN0aW9uIHBhcnNlQmluYXJ5RXhwcmVzc2lvbigpIHtcbiAgdmFyIG1hcmtlciwgbWFya2VycywgZXhwciwgdG9rZW4sIHByZWMsIHN0YWNrLCByaWdodCwgb3BlcmF0b3IsIGxlZnQsIGk7XG4gIG1hcmtlciA9IGxvb2thaGVhZDtcbiAgbGVmdCA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gIHRva2VuID0gbG9va2FoZWFkO1xuICBwcmVjID0gYmluYXJ5UHJlY2VkZW5jZSh0b2tlbik7XG4gIGlmIChwcmVjID09PSAwKSB7XG4gICAgcmV0dXJuIGxlZnQ7XG4gIH1cbiAgdG9rZW4ucHJlYyA9IHByZWM7XG4gIGxleCgpO1xuICBtYXJrZXJzID0gW21hcmtlciwgbG9va2FoZWFkXTtcbiAgcmlnaHQgPSBwYXJzZVVuYXJ5RXhwcmVzc2lvbigpO1xuICBzdGFjayA9IFtsZWZ0LCB0b2tlbiwgcmlnaHRdO1xuICB3aGlsZSAoKHByZWMgPSBiaW5hcnlQcmVjZWRlbmNlKGxvb2thaGVhZCkpID4gMCkge1xuICAgIC8vIFJlZHVjZTogbWFrZSBhIGJpbmFyeSBleHByZXNzaW9uIGZyb20gdGhlIHRocmVlIHRvcG1vc3QgZW50cmllcy5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMiAmJiBwcmVjIDw9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDJdLnByZWMpIHtcbiAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICBvcGVyYXRvciA9IHN0YWNrLnBvcCgpLnZhbHVlO1xuICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuICAgICAgbWFya2Vycy5wb3AoKTtcbiAgICAgIGV4cHIgPSBmaW5pc2hCaW5hcnlFeHByZXNzaW9uKG9wZXJhdG9yLCBsZWZ0LCByaWdodCk7XG4gICAgICBzdGFjay5wdXNoKGV4cHIpO1xuICAgIH1cblxuICAgIC8vIFNoaWZ0LlxuICAgIHRva2VuID0gbGV4KCk7XG4gICAgdG9rZW4ucHJlYyA9IHByZWM7XG4gICAgc3RhY2sucHVzaCh0b2tlbik7XG4gICAgbWFya2Vycy5wdXNoKGxvb2thaGVhZCk7XG4gICAgZXhwciA9IHBhcnNlVW5hcnlFeHByZXNzaW9uKCk7XG4gICAgc3RhY2sucHVzaChleHByKTtcbiAgfVxuXG4gIC8vIEZpbmFsIHJlZHVjZSB0byBjbGVhbi11cCB0aGUgc3RhY2suXG4gIGkgPSBzdGFjay5sZW5ndGggLSAxO1xuICBleHByID0gc3RhY2tbaV07XG4gIG1hcmtlcnMucG9wKCk7XG4gIHdoaWxlIChpID4gMSkge1xuICAgIG1hcmtlcnMucG9wKCk7XG4gICAgZXhwciA9IGZpbmlzaEJpbmFyeUV4cHJlc3Npb24oc3RhY2tbaSAtIDFdLnZhbHVlLCBzdGFja1tpIC0gMl0sIGV4cHIpO1xuICAgIGkgLT0gMjtcbiAgfVxuICByZXR1cm4gZXhwcjtcbn1cblxuLy8gMTEuMTIgQ29uZGl0aW9uYWwgT3BlcmF0b3JcblxuZnVuY3Rpb24gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKSB7XG4gIHZhciBleHByLCBjb25zZXF1ZW50LCBhbHRlcm5hdGU7XG4gIGV4cHIgPSBwYXJzZUJpbmFyeUV4cHJlc3Npb24oKTtcbiAgaWYgKG1hdGNoKCc/JykpIHtcbiAgICBsZXgoKTtcbiAgICBjb25zZXF1ZW50ID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgICBleHBlY3QoJzonKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJzZUNvbmRpdGlvbmFsRXhwcmVzc2lvbigpO1xuICAgIGV4cHIgPSBmaW5pc2hDb25kaXRpb25hbEV4cHJlc3Npb24oZXhwciwgY29uc2VxdWVudCwgYWx0ZXJuYXRlKTtcbiAgfVxuICByZXR1cm4gZXhwcjtcbn1cblxuLy8gMTEuMTQgQ29tbWEgT3BlcmF0b3JcblxuZnVuY3Rpb24gcGFyc2VFeHByZXNzaW9uKCkge1xuICBjb25zdCBleHByID0gcGFyc2VDb25kaXRpb25hbEV4cHJlc3Npb24oKTtcbiAgaWYgKG1hdGNoKCcsJykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoRElTQUJMRUQpOyAvLyBubyBzZXF1ZW5jZSBleHByZXNzaW9uc1xuICB9XG4gIHJldHVybiBleHByO1xufVxuZnVuY3Rpb24gcGFyc2VyIChjb2RlKSB7XG4gIHNvdXJjZSA9IGNvZGU7XG4gIGluZGV4ID0gMDtcbiAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcbiAgbG9va2FoZWFkID0gbnVsbDtcbiAgcGVlaygpO1xuICBjb25zdCBleHByID0gcGFyc2VFeHByZXNzaW9uKCk7XG4gIGlmIChsb29rYWhlYWQudHlwZSAhPT0gVG9rZW5FT0YpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0IHRva2VuIGFmdGVyIGV4cHJlc3Npb24uJyk7XG4gIH1cbiAgcmV0dXJuIGV4cHI7XG59XG5cbnZhciBDb25zdGFudHMgPSB7XG4gIE5hTjogJ05hTicsXG4gIEU6ICdNYXRoLkUnLFxuICBMTjI6ICdNYXRoLkxOMicsXG4gIExOMTA6ICdNYXRoLkxOMTAnLFxuICBMT0cyRTogJ01hdGguTE9HMkUnLFxuICBMT0cxMEU6ICdNYXRoLkxPRzEwRScsXG4gIFBJOiAnTWF0aC5QSScsXG4gIFNRUlQxXzI6ICdNYXRoLlNRUlQxXzInLFxuICBTUVJUMjogJ01hdGguU1FSVDInLFxuICBNSU5fVkFMVUU6ICdOdW1iZXIuTUlOX1ZBTFVFJyxcbiAgTUFYX1ZBTFVFOiAnTnVtYmVyLk1BWF9WQUxVRSdcbn07XG5cbmZ1bmN0aW9uIEZ1bmN0aW9ucyAoY29kZWdlbikge1xuICBmdW5jdGlvbiBmbmNhbGwobmFtZSwgYXJncywgY2FzdCwgdHlwZSkge1xuICAgIGxldCBvYmogPSBjb2RlZ2VuKGFyZ3NbMF0pO1xuICAgIGlmIChjYXN0KSB7XG4gICAgICBvYmogPSBjYXN0ICsgJygnICsgb2JqICsgJyknO1xuICAgICAgaWYgKGNhc3QubGFzdEluZGV4T2YoJ25ldyAnLCAwKSA9PT0gMCkgb2JqID0gJygnICsgb2JqICsgJyknO1xuICAgIH1cbiAgICByZXR1cm4gb2JqICsgJy4nICsgbmFtZSArICh0eXBlIDwgMCA/ICcnIDogdHlwZSA9PT0gMCA/ICcoKScgOiAnKCcgKyBhcmdzLnNsaWNlKDEpLm1hcChjb2RlZ2VuKS5qb2luKCcsJykgKyAnKScpO1xuICB9XG4gIGZ1bmN0aW9uIGZuKG5hbWUsIGNhc3QsIHR5cGUpIHtcbiAgICByZXR1cm4gYXJncyA9PiBmbmNhbGwobmFtZSwgYXJncywgY2FzdCwgdHlwZSk7XG4gIH1cbiAgY29uc3QgREFURSA9ICduZXcgRGF0ZScsXG4gICAgU1RSSU5HID0gJ1N0cmluZycsXG4gICAgUkVHRVhQID0gJ1JlZ0V4cCc7XG4gIHJldHVybiB7XG4gICAgLy8gTUFUSCBmdW5jdGlvbnNcbiAgICBpc05hTjogJ051bWJlci5pc05hTicsXG4gICAgaXNGaW5pdGU6ICdOdW1iZXIuaXNGaW5pdGUnLFxuICAgIGFiczogJ01hdGguYWJzJyxcbiAgICBhY29zOiAnTWF0aC5hY29zJyxcbiAgICBhc2luOiAnTWF0aC5hc2luJyxcbiAgICBhdGFuOiAnTWF0aC5hdGFuJyxcbiAgICBhdGFuMjogJ01hdGguYXRhbjInLFxuICAgIGNlaWw6ICdNYXRoLmNlaWwnLFxuICAgIGNvczogJ01hdGguY29zJyxcbiAgICBleHA6ICdNYXRoLmV4cCcsXG4gICAgZmxvb3I6ICdNYXRoLmZsb29yJyxcbiAgICBoeXBvdDogJ01hdGguaHlwb3QnLFxuICAgIGxvZzogJ01hdGgubG9nJyxcbiAgICBtYXg6ICdNYXRoLm1heCcsXG4gICAgbWluOiAnTWF0aC5taW4nLFxuICAgIHBvdzogJ01hdGgucG93JyxcbiAgICByYW5kb206ICdNYXRoLnJhbmRvbScsXG4gICAgcm91bmQ6ICdNYXRoLnJvdW5kJyxcbiAgICBzaW46ICdNYXRoLnNpbicsXG4gICAgc3FydDogJ01hdGguc3FydCcsXG4gICAgdGFuOiAnTWF0aC50YW4nLFxuICAgIGNsYW1wOiBmdW5jdGlvbiAoYXJncykge1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoIDwgMykgZXJyb3IoJ01pc3NpbmcgYXJndW1lbnRzIHRvIGNsYW1wIGZ1bmN0aW9uLicpO1xuICAgICAgaWYgKGFyZ3MubGVuZ3RoID4gMykgZXJyb3IoJ1RvbyBtYW55IGFyZ3VtZW50cyB0byBjbGFtcCBmdW5jdGlvbi4nKTtcbiAgICAgIGNvbnN0IGEgPSBhcmdzLm1hcChjb2RlZ2VuKTtcbiAgICAgIHJldHVybiAnTWF0aC5tYXgoJyArIGFbMV0gKyAnLCBNYXRoLm1pbignICsgYVsyXSArICcsJyArIGFbMF0gKyAnKSknO1xuICAgIH0sXG4gICAgLy8gREFURSBmdW5jdGlvbnNcbiAgICBub3c6ICdEYXRlLm5vdycsXG4gICAgdXRjOiAnRGF0ZS5VVEMnLFxuICAgIGRhdGV0aW1lOiBEQVRFLFxuICAgIGRhdGU6IGZuKCdnZXREYXRlJywgREFURSwgMCksXG4gICAgZGF5OiBmbignZ2V0RGF5JywgREFURSwgMCksXG4gICAgeWVhcjogZm4oJ2dldEZ1bGxZZWFyJywgREFURSwgMCksXG4gICAgbW9udGg6IGZuKCdnZXRNb250aCcsIERBVEUsIDApLFxuICAgIGhvdXJzOiBmbignZ2V0SG91cnMnLCBEQVRFLCAwKSxcbiAgICBtaW51dGVzOiBmbignZ2V0TWludXRlcycsIERBVEUsIDApLFxuICAgIHNlY29uZHM6IGZuKCdnZXRTZWNvbmRzJywgREFURSwgMCksXG4gICAgbWlsbGlzZWNvbmRzOiBmbignZ2V0TWlsbGlzZWNvbmRzJywgREFURSwgMCksXG4gICAgdGltZTogZm4oJ2dldFRpbWUnLCBEQVRFLCAwKSxcbiAgICB0aW1lem9uZW9mZnNldDogZm4oJ2dldFRpbWV6b25lT2Zmc2V0JywgREFURSwgMCksXG4gICAgdXRjZGF0ZTogZm4oJ2dldFVUQ0RhdGUnLCBEQVRFLCAwKSxcbiAgICB1dGNkYXk6IGZuKCdnZXRVVENEYXknLCBEQVRFLCAwKSxcbiAgICB1dGN5ZWFyOiBmbignZ2V0VVRDRnVsbFllYXInLCBEQVRFLCAwKSxcbiAgICB1dGNtb250aDogZm4oJ2dldFVUQ01vbnRoJywgREFURSwgMCksXG4gICAgdXRjaG91cnM6IGZuKCdnZXRVVENIb3VycycsIERBVEUsIDApLFxuICAgIHV0Y21pbnV0ZXM6IGZuKCdnZXRVVENNaW51dGVzJywgREFURSwgMCksXG4gICAgdXRjc2Vjb25kczogZm4oJ2dldFVUQ1NlY29uZHMnLCBEQVRFLCAwKSxcbiAgICB1dGNtaWxsaXNlY29uZHM6IGZuKCdnZXRVVENNaWxsaXNlY29uZHMnLCBEQVRFLCAwKSxcbiAgICAvLyBzZXF1ZW5jZSBmdW5jdGlvbnNcbiAgICBsZW5ndGg6IGZuKCdsZW5ndGgnLCBudWxsLCAtMSksXG4gICAgLy8gU1RSSU5HIGZ1bmN0aW9uc1xuICAgIHBhcnNlRmxvYXQ6ICdwYXJzZUZsb2F0JyxcbiAgICBwYXJzZUludDogJ3BhcnNlSW50JyxcbiAgICB1cHBlcjogZm4oJ3RvVXBwZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICBsb3dlcjogZm4oJ3RvTG93ZXJDYXNlJywgU1RSSU5HLCAwKSxcbiAgICBzdWJzdHJpbmc6IGZuKCdzdWJzdHJpbmcnLCBTVFJJTkcpLFxuICAgIHNwbGl0OiBmbignc3BsaXQnLCBTVFJJTkcpLFxuICAgIHRyaW06IGZuKCd0cmltJywgU1RSSU5HLCAwKSxcbiAgICAvLyBiYXNlNjQgZW5jb2RlL2RlY29kZVxuICAgIGJ0b2E6ICdidG9hJyxcbiAgICBhdG9iOiAnYXRvYicsXG4gICAgLy8gUkVHRVhQIGZ1bmN0aW9uc1xuICAgIHJlZ2V4cDogUkVHRVhQLFxuICAgIHRlc3Q6IGZuKCd0ZXN0JywgUkVHRVhQKSxcbiAgICAvLyBDb250cm9sIEZsb3cgZnVuY3Rpb25zXG4gICAgaWY6IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPCAzKSBlcnJvcignTWlzc2luZyBhcmd1bWVudHMgdG8gaWYgZnVuY3Rpb24uJyk7XG4gICAgICBpZiAoYXJncy5sZW5ndGggPiAzKSBlcnJvcignVG9vIG1hbnkgYXJndW1lbnRzIHRvIGlmIGZ1bmN0aW9uLicpO1xuICAgICAgY29uc3QgYSA9IGFyZ3MubWFwKGNvZGVnZW4pO1xuICAgICAgcmV0dXJuICcoJyArIGFbMF0gKyAnPycgKyBhWzFdICsgJzonICsgYVsyXSArICcpJztcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHN0cmlwUXVvdGVzKHMpIHtcbiAgY29uc3QgbiA9IHMgJiYgcy5sZW5ndGggLSAxO1xuICByZXR1cm4gbiAmJiAoc1swXSA9PT0gJ1wiJyAmJiBzW25dID09PSAnXCInIHx8IHNbMF0gPT09ICdcXCcnICYmIHNbbl0gPT09ICdcXCcnKSA/IHMuc2xpY2UoMSwgLTEpIDogcztcbn1cbmZ1bmN0aW9uIGNvZGVnZW4gKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIGNvbnN0IGFsbG93ZWQgPSBvcHQuYWxsb3dlZCA/IHRvU2V0KG9wdC5hbGxvd2VkKSA6IHt9LFxuICAgIGZvcmJpZGRlbiA9IG9wdC5mb3JiaWRkZW4gPyB0b1NldChvcHQuZm9yYmlkZGVuKSA6IHt9LFxuICAgIGNvbnN0YW50cyA9IG9wdC5jb25zdGFudHMgfHwgQ29uc3RhbnRzLFxuICAgIGZ1bmN0aW9ucyA9IChvcHQuZnVuY3Rpb25zIHx8IEZ1bmN0aW9ucykodmlzaXQpLFxuICAgIGdsb2JhbHZhciA9IG9wdC5nbG9iYWx2YXIsXG4gICAgZmllbGR2YXIgPSBvcHQuZmllbGR2YXIsXG4gICAgb3V0cHV0R2xvYmFsID0gaXNGdW5jdGlvbihnbG9iYWx2YXIpID8gZ2xvYmFsdmFyIDogaWQgPT4gYCR7Z2xvYmFsdmFyfVtcIiR7aWR9XCJdYDtcbiAgbGV0IGdsb2JhbHMgPSB7fSxcbiAgICBmaWVsZHMgPSB7fSxcbiAgICBtZW1iZXJEZXB0aCA9IDA7XG4gIGZ1bmN0aW9uIHZpc2l0KGFzdCkge1xuICAgIGlmIChpc1N0cmluZyhhc3QpKSByZXR1cm4gYXN0O1xuICAgIGNvbnN0IGdlbmVyYXRvciA9IEdlbmVyYXRvcnNbYXN0LnR5cGVdO1xuICAgIGlmIChnZW5lcmF0b3IgPT0gbnVsbCkgZXJyb3IoJ1Vuc3VwcG9ydGVkIHR5cGU6ICcgKyBhc3QudHlwZSk7XG4gICAgcmV0dXJuIGdlbmVyYXRvcihhc3QpO1xuICB9XG4gIGNvbnN0IEdlbmVyYXRvcnMgPSB7XG4gICAgTGl0ZXJhbDogbiA9PiBuLnJhdyxcbiAgICBJZGVudGlmaWVyOiBuID0+IHtcbiAgICAgIGNvbnN0IGlkID0gbi5uYW1lO1xuICAgICAgaWYgKG1lbWJlckRlcHRoID4gMCkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGZvcmJpZGRlbiwgaWQpKSB7XG4gICAgICAgIHJldHVybiBlcnJvcignSWxsZWdhbCBpZGVudGlmaWVyOiAnICsgaWQpO1xuICAgICAgfSBlbHNlIGlmIChoYXNPd25Qcm9wZXJ0eShjb25zdGFudHMsIGlkKSkge1xuICAgICAgICByZXR1cm4gY29uc3RhbnRzW2lkXTtcbiAgICAgIH0gZWxzZSBpZiAoaGFzT3duUHJvcGVydHkoYWxsb3dlZCwgaWQpKSB7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdsb2JhbHNbaWRdID0gMTtcbiAgICAgICAgcmV0dXJuIG91dHB1dEdsb2JhbChpZCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBNZW1iZXJFeHByZXNzaW9uOiBuID0+IHtcbiAgICAgIGNvbnN0IGQgPSAhbi5jb21wdXRlZCxcbiAgICAgICAgbyA9IHZpc2l0KG4ub2JqZWN0KTtcbiAgICAgIGlmIChkKSBtZW1iZXJEZXB0aCArPSAxO1xuICAgICAgY29uc3QgcCA9IHZpc2l0KG4ucHJvcGVydHkpO1xuICAgICAgaWYgKG8gPT09IGZpZWxkdmFyKSB7XG4gICAgICAgIC8vIHN0cmlwIHF1b3RlcyB0byBzYW5pdGl6ZSBmaWVsZCBuYW1lICgjMTY1MylcbiAgICAgICAgZmllbGRzW3N0cmlwUXVvdGVzKHApXSA9IDE7XG4gICAgICB9XG4gICAgICBpZiAoZCkgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgIHJldHVybiBvICsgKGQgPyAnLicgKyBwIDogJ1snICsgcCArICddJyk7XG4gICAgfSxcbiAgICBDYWxsRXhwcmVzc2lvbjogbiA9PiB7XG4gICAgICBpZiAobi5jYWxsZWUudHlwZSAhPT0gJ0lkZW50aWZpZXInKSB7XG4gICAgICAgIGVycm9yKCdJbGxlZ2FsIGNhbGxlZSB0eXBlOiAnICsgbi5jYWxsZWUudHlwZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYWxsZWUgPSBuLmNhbGxlZS5uYW1lLFxuICAgICAgICBhcmdzID0gbi5hcmd1bWVudHMsXG4gICAgICAgIGZuID0gaGFzT3duUHJvcGVydHkoZnVuY3Rpb25zLCBjYWxsZWUpICYmIGZ1bmN0aW9uc1tjYWxsZWVdO1xuICAgICAgaWYgKCFmbikgZXJyb3IoJ1VucmVjb2duaXplZCBmdW5jdGlvbjogJyArIGNhbGxlZSk7XG4gICAgICByZXR1cm4gaXNGdW5jdGlvbihmbikgPyBmbihhcmdzKSA6IGZuICsgJygnICsgYXJncy5tYXAodmlzaXQpLmpvaW4oJywnKSArICcpJztcbiAgICB9LFxuICAgIEFycmF5RXhwcmVzc2lvbjogbiA9PiAnWycgKyBuLmVsZW1lbnRzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJ10nLFxuICAgIEJpbmFyeUV4cHJlc3Npb246IG4gPT4gJygnICsgdmlzaXQobi5sZWZ0KSArICcgJyArIG4ub3BlcmF0b3IgKyAnICcgKyB2aXNpdChuLnJpZ2h0KSArICcpJyxcbiAgICBVbmFyeUV4cHJlc3Npb246IG4gPT4gJygnICsgbi5vcGVyYXRvciArIHZpc2l0KG4uYXJndW1lbnQpICsgJyknLFxuICAgIENvbmRpdGlvbmFsRXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLnRlc3QpICsgJz8nICsgdmlzaXQobi5jb25zZXF1ZW50KSArICc6JyArIHZpc2l0KG4uYWx0ZXJuYXRlKSArICcpJyxcbiAgICBMb2dpY2FsRXhwcmVzc2lvbjogbiA9PiAnKCcgKyB2aXNpdChuLmxlZnQpICsgbi5vcGVyYXRvciArIHZpc2l0KG4ucmlnaHQpICsgJyknLFxuICAgIE9iamVjdEV4cHJlc3Npb246IG4gPT4gJ3snICsgbi5wcm9wZXJ0aWVzLm1hcCh2aXNpdCkuam9pbignLCcpICsgJ30nLFxuICAgIFByb3BlcnR5OiBuID0+IHtcbiAgICAgIG1lbWJlckRlcHRoICs9IDE7XG4gICAgICBjb25zdCBrID0gdmlzaXQobi5rZXkpO1xuICAgICAgbWVtYmVyRGVwdGggLT0gMTtcbiAgICAgIHJldHVybiBrICsgJzonICsgdmlzaXQobi52YWx1ZSk7XG4gICAgfVxuICB9O1xuICBmdW5jdGlvbiBjb2RlZ2VuKGFzdCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGNvZGU6IHZpc2l0KGFzdCksXG4gICAgICBnbG9iYWxzOiBPYmplY3Qua2V5cyhnbG9iYWxzKSxcbiAgICAgIGZpZWxkczogT2JqZWN0LmtleXMoZmllbGRzKVxuICAgIH07XG4gICAgZ2xvYmFscyA9IHt9O1xuICAgIGZpZWxkcyA9IHt9O1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY29kZWdlbi5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gIGNvZGVnZW4uY29uc3RhbnRzID0gY29uc3RhbnRzO1xuICByZXR1cm4gY29kZWdlbjtcbn1cblxuZXhwb3J0IHsgQVNUTm9kZSwgQXJyYXlFeHByZXNzaW9uLCBCaW5hcnlFeHByZXNzaW9uLCBDYWxsRXhwcmVzc2lvbiwgQ29uZGl0aW9uYWxFeHByZXNzaW9uLCBJZGVudGlmaWVyLCBMaXRlcmFsLCBMb2dpY2FsRXhwcmVzc2lvbiwgTWVtYmVyRXhwcmVzc2lvbiwgT2JqZWN0RXhwcmVzc2lvbiwgUHJvcGVydHksIFJhd0NvZGUsIFVuYXJ5RXhwcmVzc2lvbiwgY29kZWdlbiBhcyBjb2RlZ2VuRXhwcmVzc2lvbiwgQ29uc3RhbnRzIGFzIGNvbnN0YW50cywgRnVuY3Rpb25zIGFzIGZ1bmN0aW9ucywgcGFyc2VyIGFzIHBhcnNlRXhwcmVzc2lvbiB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBpbmhlcml0cywgYXJyYXksIGlzRnVuY3Rpb24sIGFjY2Vzc29yRmllbGRzLCBoYXNPd25Qcm9wZXJ0eSwgZXJyb3IgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgZm9yY2VTaW11bGF0aW9uLCBmb3JjZUNlbnRlciwgZm9yY2VDb2xsaWRlLCBmb3JjZU1hbnlCb2R5LCBmb3JjZUxpbmssIGZvcmNlWCwgZm9yY2VZIH0gZnJvbSAnZDMtZm9yY2UnO1xuXG5jb25zdCBGb3JjZU1hcCA9IHtcbiAgY2VudGVyOiBmb3JjZUNlbnRlcixcbiAgY29sbGlkZTogZm9yY2VDb2xsaWRlLFxuICBuYm9keTogZm9yY2VNYW55Qm9keSxcbiAgbGluazogZm9yY2VMaW5rLFxuICB4OiBmb3JjZVgsXG4gIHk6IGZvcmNlWVxufTtcbmNvbnN0IEZvcmNlcyA9ICdmb3JjZXMnLFxuICBGb3JjZVBhcmFtcyA9IFsnYWxwaGEnLCAnYWxwaGFNaW4nLCAnYWxwaGFUYXJnZXQnLCAndmVsb2NpdHlEZWNheScsICdmb3JjZXMnXSxcbiAgRm9yY2VDb25maWcgPSBbJ3N0YXRpYycsICdpdGVyYXRpb25zJ10sXG4gIEZvcmNlT3V0cHV0ID0gWyd4JywgJ3knLCAndngnLCAndnknXTtcblxuLyoqXG4gKiBGb3JjZSBzaW11bGF0aW9uIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxvYmplY3Q+fSBwYXJhbXMuZm9yY2VzIC0gVGhlIGZvcmNlcyB0byBhcHBseS5cbiAqL1xuZnVuY3Rpb24gRm9yY2UocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Gb3JjZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGb3JjZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3N0YXRpYycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncmVzdGFydCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaXRlcmF0aW9ucycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDMwMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWxwaGEnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhbHBoYU1pbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDAuMDAxXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhbHBoYVRhcmdldCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3ZlbG9jaXR5RGVjYXknLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjRcbiAgfSwge1xuICAgICduYW1lJzogJ2ZvcmNlcycsXG4gICAgJ3R5cGUnOiAncGFyYW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3BhcmFtcyc6IFt7XG4gICAgICAna2V5Jzoge1xuICAgICAgICAnZm9yY2UnOiAnY2VudGVyJ1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICd4JyxcbiAgICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICAgJ2RlZmF1bHQnOiAwXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3knLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDBcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ2NvbGxpZGUnXG4gICAgICB9LFxuICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICduYW1lJzogJ3JhZGl1cycsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdleHByJzogdHJ1ZVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC43XG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ2l0ZXJhdGlvbnMnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDFcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ25ib2R5J1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogLTMwLFxuICAgICAgICAnZXhwcic6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAndGhldGEnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDAuOVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdkaXN0YW5jZU1pbicsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICdkaXN0YW5jZU1heCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcidcbiAgICAgIH1dXG4gICAgfSwge1xuICAgICAgJ2tleSc6IHtcbiAgICAgICAgJ2ZvcmNlJzogJ2xpbmsnXG4gICAgICB9LFxuICAgICAgJ3BhcmFtcyc6IFt7XG4gICAgICAgICduYW1lJzogJ2xpbmtzJyxcbiAgICAgICAgJ3R5cGUnOiAnZGF0YSdcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnaWQnLFxuICAgICAgICAndHlwZSc6ICdmaWVsZCdcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnZGlzdGFuY2UnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDMwLFxuICAgICAgICAnZXhwcic6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZXhwcic6IHRydWVcbiAgICAgIH0sIHtcbiAgICAgICAgJ25hbWUnOiAnaXRlcmF0aW9ucycsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMVxuICAgICAgfV1cbiAgICB9LCB7XG4gICAgICAna2V5Jzoge1xuICAgICAgICAnZm9yY2UnOiAneCdcbiAgICAgIH0sXG4gICAgICAncGFyYW1zJzogW3tcbiAgICAgICAgJ25hbWUnOiAnc3RyZW5ndGgnLFxuICAgICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgICAnZGVmYXVsdCc6IDAuMVxuICAgICAgfSwge1xuICAgICAgICAnbmFtZSc6ICd4JyxcbiAgICAgICAgJ3R5cGUnOiAnZmllbGQnXG4gICAgICB9XVxuICAgIH0sIHtcbiAgICAgICdrZXknOiB7XG4gICAgICAgICdmb3JjZSc6ICd5J1xuICAgICAgfSxcbiAgICAgICdwYXJhbXMnOiBbe1xuICAgICAgICAnbmFtZSc6ICdzdHJlbmd0aCcsXG4gICAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAgICdkZWZhdWx0JzogMC4xXG4gICAgICB9LCB7XG4gICAgICAgICduYW1lJzogJ3knLFxuICAgICAgICAndHlwZSc6ICdmaWVsZCdcbiAgICAgIH1dXG4gICAgfV1cbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ21vZGlmeSc6IGZhbHNlLFxuICAgICdkZWZhdWx0JzogRm9yY2VPdXRwdXRcbiAgfV1cbn07XG5pbmhlcml0cyhGb3JjZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBzaW0gPSB0aGlzLnZhbHVlLFxuICAgICAgY2hhbmdlID0gcHVsc2UuY2hhbmdlZChwdWxzZS5BRERfUkVNKSxcbiAgICAgIHBhcmFtcyA9IF8ubW9kaWZpZWQoRm9yY2VQYXJhbXMpLFxuICAgICAgaXRlcnMgPSBfLml0ZXJhdGlvbnMgfHwgMzAwO1xuXG4gICAgLy8gY29uZmlndXJlIHNpbXVsYXRpb25cbiAgICBpZiAoIXNpbSkge1xuICAgICAgdGhpcy52YWx1ZSA9IHNpbSA9IHNpbXVsYXRpb24ocHVsc2Uuc291cmNlLCBfKTtcbiAgICAgIHNpbS5vbigndGljaycsIHJlcnVuKHB1bHNlLmRhdGFmbG93LCB0aGlzKSk7XG4gICAgICBpZiAoIV8uc3RhdGljKSB7XG4gICAgICAgIGNoYW5nZSA9IHRydWU7XG4gICAgICAgIHNpbS50aWNrKCk7IC8vIGVuc3VyZSB3ZSBydW4gb24gaW5pdFxuICAgICAgfVxuICAgICAgcHVsc2UubW9kaWZpZXMoJ2luZGV4Jyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChjaGFuZ2UpIHtcbiAgICAgICAgcHVsc2UubW9kaWZpZXMoJ2luZGV4Jyk7XG4gICAgICAgIHNpbS5ub2RlcyhwdWxzZS5zb3VyY2UpO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmFtcyB8fCBwdWxzZS5jaGFuZ2VkKHB1bHNlLk1PRCkpIHtcbiAgICAgICAgc2V0dXAoc2ltLCBfLCAwLCBwdWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gcnVuIHNpbXVsYXRpb25cbiAgICBpZiAocGFyYW1zIHx8IGNoYW5nZSB8fCBfLm1vZGlmaWVkKEZvcmNlQ29uZmlnKSB8fCBwdWxzZS5jaGFuZ2VkKCkgJiYgXy5yZXN0YXJ0KSB7XG4gICAgICBzaW0uYWxwaGEoTWF0aC5tYXgoc2ltLmFscGhhKCksIF8uYWxwaGEgfHwgMSkpLmFscGhhRGVjYXkoMSAtIE1hdGgucG93KHNpbS5hbHBoYU1pbigpLCAxIC8gaXRlcnMpKTtcbiAgICAgIGlmIChfLnN0YXRpYykge1xuICAgICAgICBmb3IgKHNpbS5zdG9wKCk7IC0taXRlcnMgPj0gMDspIHNpbS50aWNrKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoc2ltLnN0b3BwZWQoKSkgc2ltLnJlc3RhcnQoKTtcbiAgICAgICAgaWYgKCFjaGFuZ2UpIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247IC8vIGRlZmVyIHRvIHNpbSB0aWNrc1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5maW5pc2goXywgcHVsc2UpO1xuICB9LFxuICBmaW5pc2goXywgcHVsc2UpIHtcbiAgICBjb25zdCBkYXRhZmxvdyA9IHB1bHNlLmRhdGFmbG93O1xuXG4gICAgLy8gaW5zcGVjdCBkZXBlbmRlbmNpZXMsIHRvdWNoIGxpbmsgc291cmNlIGRhdGFcbiAgICBmb3IgKGxldCBhcmdzID0gdGhpcy5fYXJnb3BzLCBqID0gMCwgbSA9IGFyZ3MubGVuZ3RoLCBhcmc7IGogPCBtOyArK2opIHtcbiAgICAgIGFyZyA9IGFyZ3Nbal07XG4gICAgICBpZiAoYXJnLm5hbWUgIT09IEZvcmNlcyB8fCBhcmcub3AuX2FyZ3ZhbC5mb3JjZSAhPT0gJ2xpbmsnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgZm9yICh2YXIgb3BzID0gYXJnLm9wLl9hcmdvcHMsIGkgPSAwLCBuID0gb3BzLmxlbmd0aCwgb3A7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKG9wc1tpXS5uYW1lID09PSAnbGlua3MnICYmIChvcCA9IG9wc1tpXS5vcC5zb3VyY2UpKSB7XG4gICAgICAgICAgZGF0YWZsb3cucHVsc2Uob3AsIGRhdGFmbG93LmNoYW5nZXNldCgpLnJlZmxvdygpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlZmxvdyBhbGwgbm9kZXNcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoRm9yY2VPdXRwdXQpO1xuICB9XG59KTtcbmZ1bmN0aW9uIHJlcnVuKGRmLCBvcCkge1xuICByZXR1cm4gKCkgPT4gZGYudG91Y2gob3ApLnJ1bigpO1xufVxuZnVuY3Rpb24gc2ltdWxhdGlvbihub2RlcywgXykge1xuICBjb25zdCBzaW0gPSBmb3JjZVNpbXVsYXRpb24obm9kZXMpLFxuICAgIHN0b3AgPSBzaW0uc3RvcCxcbiAgICByZXN0YXJ0ID0gc2ltLnJlc3RhcnQ7XG4gIGxldCBzdG9wcGVkID0gZmFsc2U7XG4gIHNpbS5zdG9wcGVkID0gKCkgPT4gc3RvcHBlZDtcbiAgc2ltLnJlc3RhcnQgPSAoKSA9PiAoc3RvcHBlZCA9IGZhbHNlLCByZXN0YXJ0KCkpO1xuICBzaW0uc3RvcCA9ICgpID0+IChzdG9wcGVkID0gdHJ1ZSwgc3RvcCgpKTtcbiAgcmV0dXJuIHNldHVwKHNpbSwgXywgdHJ1ZSkub24oJ2VuZCcsICgpID0+IHN0b3BwZWQgPSB0cnVlKTtcbn1cbmZ1bmN0aW9uIHNldHVwKHNpbSwgXywgaW5pdCwgcHVsc2UpIHtcbiAgdmFyIGYgPSBhcnJheShfLmZvcmNlcyksXG4gICAgaSxcbiAgICBuLFxuICAgIHAsXG4gICAgbmFtZTtcbiAgZm9yIChpID0gMCwgbiA9IEZvcmNlUGFyYW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBGb3JjZVBhcmFtc1tpXTtcbiAgICBpZiAocCAhPT0gRm9yY2VzICYmIF8ubW9kaWZpZWQocCkpIHNpbVtwXShfW3BdKTtcbiAgfVxuICBmb3IgKGkgPSAwLCBuID0gZi5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBuYW1lID0gRm9yY2VzICsgaTtcbiAgICBwID0gaW5pdCB8fCBfLm1vZGlmaWVkKEZvcmNlcywgaSkgPyBnZXRGb3JjZShmW2ldKSA6IHB1bHNlICYmIG1vZGlmaWVkKGZbaV0sIHB1bHNlKSA/IHNpbS5mb3JjZShuYW1lKSA6IG51bGw7XG4gICAgaWYgKHApIHNpbS5mb3JjZShuYW1lLCBwKTtcbiAgfVxuICBmb3IgKG4gPSBzaW0ubnVtRm9yY2VzIHx8IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzaW0uZm9yY2UoRm9yY2VzICsgaSwgbnVsbCk7IC8vIHJlbW92ZVxuICB9XG4gIHNpbS5udW1Gb3JjZXMgPSBmLmxlbmd0aDtcbiAgcmV0dXJuIHNpbTtcbn1cbmZ1bmN0aW9uIG1vZGlmaWVkKGYsIHB1bHNlKSB7XG4gIHZhciBrLCB2O1xuICBmb3IgKGsgaW4gZikge1xuICAgIGlmIChpc0Z1bmN0aW9uKHYgPSBmW2tdKSAmJiBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyh2KSkpIHJldHVybiAxO1xuICB9XG4gIHJldHVybiAwO1xufVxuZnVuY3Rpb24gZ2V0Rm9yY2UoXykge1xuICB2YXIgZiwgcDtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShGb3JjZU1hcCwgXy5mb3JjZSkpIHtcbiAgICBlcnJvcignVW5yZWNvZ25pemVkIGZvcmNlOiAnICsgXy5mb3JjZSk7XG4gIH1cbiAgZiA9IEZvcmNlTWFwW18uZm9yY2VdKCk7XG4gIGZvciAocCBpbiBfKSB7XG4gICAgaWYgKGlzRnVuY3Rpb24oZltwXSkpIHNldEZvcmNlUGFyYW0oZltwXSwgX1twXSwgXyk7XG4gIH1cbiAgcmV0dXJuIGY7XG59XG5mdW5jdGlvbiBzZXRGb3JjZVBhcmFtKGYsIHYsIF8pIHtcbiAgZihpc0Z1bmN0aW9uKHYpID8gZCA9PiB2KGQsIF8pIDogdik7XG59XG5cbmV4cG9ydCB7IEZvcmNlIGFzIGZvcmNlIH07XG4iLCJpbXBvcnQgeyB0aWNrU3RlcCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IGZvcm1hdExvY2FsZSwgZm9ybWF0U3BlY2lmaWVyLCBwcmVjaXNpb25GaXhlZCwgcHJlY2lzaW9uUm91bmQsIHByZWNpc2lvblByZWZpeCwgZm9ybWF0LCBmb3JtYXRQcmVmaXggfSBmcm9tICdkMy1mb3JtYXQnO1xuaW1wb3J0IHsgU0VDT05EUywgTUlOVVRFUywgSE9VUlMsIERBVEUsIFdFRUssIE1PTlRILCBRVUFSVEVSLCBZRUFSLCBNSUxMSVNFQ09ORFMsIERBWSwgdGltZUludGVydmFsLCB1dGNJbnRlcnZhbCB9IGZyb20gJ3ZlZ2EtdGltZSc7XG5pbXBvcnQgeyBpc1N0cmluZywgaXNPYmplY3QsIGVycm9yLCBleHRlbmQgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgdGltZUZvcm1hdExvY2FsZSBhcyB0aW1lRm9ybWF0TG9jYWxlJDEsIHRpbWVGb3JtYXQsIHRpbWVQYXJzZSwgdXRjRm9ybWF0LCB1dGNQYXJzZSB9IGZyb20gJ2QzLXRpbWUtZm9ybWF0JztcblxuZnVuY3Rpb24gbWVtb2l6ZSAobWV0aG9kKSB7XG4gIGNvbnN0IGNhY2hlID0ge307XG4gIHJldHVybiBzcGVjID0+IGNhY2hlW3NwZWNdIHx8IChjYWNoZVtzcGVjXSA9IG1ldGhvZChzcGVjKSk7XG59XG5cbmZ1bmN0aW9uIHRyaW1aZXJvZXMobnVtYmVyRm9ybWF0LCBkZWNpbWFsQ2hhcikge1xuICByZXR1cm4geCA9PiB7XG4gICAgY29uc3Qgc3RyID0gbnVtYmVyRm9ybWF0KHgpLFxuICAgICAgZGVjID0gc3RyLmluZGV4T2YoZGVjaW1hbENoYXIpO1xuICAgIGlmIChkZWMgPCAwKSByZXR1cm4gc3RyO1xuICAgIGxldCBpZHggPSByaWdodG1vc3REaWdpdChzdHIsIGRlYyk7XG4gICAgY29uc3QgZW5kID0gaWR4IDwgc3RyLmxlbmd0aCA/IHN0ci5zbGljZShpZHgpIDogJyc7XG4gICAgd2hpbGUgKC0taWR4ID4gZGVjKSBpZiAoc3RyW2lkeF0gIT09ICcwJykge1xuICAgICAgKytpZHg7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHN0ci5zbGljZSgwLCBpZHgpICsgZW5kO1xuICB9O1xufVxuZnVuY3Rpb24gcmlnaHRtb3N0RGlnaXQoc3RyLCBkZWMpIHtcbiAgbGV0IGkgPSBzdHIubGFzdEluZGV4T2YoJ2UnKSxcbiAgICBjO1xuICBpZiAoaSA+IDApIHJldHVybiBpO1xuICBmb3IgKGkgPSBzdHIubGVuZ3RoOyAtLWkgPiBkZWM7KSB7XG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpO1xuICAgIGlmIChjID49IDQ4ICYmIGMgPD0gNTcpIHJldHVybiBpICsgMTsgLy8gaXMgZGlnaXRcbiAgfVxufVxuZnVuY3Rpb24gbnVtYmVyTG9jYWxlKGxvY2FsZSkge1xuICBjb25zdCBmb3JtYXQgPSBtZW1vaXplKGxvY2FsZS5mb3JtYXQpLFxuICAgIGZvcm1hdFByZWZpeCA9IGxvY2FsZS5mb3JtYXRQcmVmaXg7XG4gIHJldHVybiB7XG4gICAgZm9ybWF0LFxuICAgIGZvcm1hdFByZWZpeCxcbiAgICBmb3JtYXRGbG9hdChzcGVjKSB7XG4gICAgICBjb25zdCBzID0gZm9ybWF0U3BlY2lmaWVyKHNwZWMgfHwgJywnKTtcbiAgICAgIGlmIChzLnByZWNpc2lvbiA9PSBudWxsKSB7XG4gICAgICAgIHMucHJlY2lzaW9uID0gMTI7XG4gICAgICAgIHN3aXRjaCAocy50eXBlKSB7XG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICBzLnByZWNpc2lvbiAtPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgICBzLnByZWNpc2lvbiAtPSAxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyaW1aZXJvZXMoZm9ybWF0KHMpLFxuICAgICAgICAvLyBudW1iZXIgZm9ybWF0XG4gICAgICAgIGZvcm1hdCgnLjFmJykoMSlbMV0gLy8gZGVjaW1hbCBwb2ludCBjaGFyYWN0ZXJcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmb3JtYXQocyk7XG4gICAgICB9XG4gICAgfSxcbiAgICBmb3JtYXRTcGFuKHN0YXJ0LCBzdG9wLCBjb3VudCwgc3BlY2lmaWVyKSB7XG4gICAgICBzcGVjaWZpZXIgPSBmb3JtYXRTcGVjaWZpZXIoc3BlY2lmaWVyID09IG51bGwgPyAnLGYnIDogc3BlY2lmaWVyKTtcbiAgICAgIGNvbnN0IHN0ZXAgPSB0aWNrU3RlcChzdGFydCwgc3RvcCwgY291bnQpLFxuICAgICAgICB2YWx1ZSA9IE1hdGgubWF4KE1hdGguYWJzKHN0YXJ0KSwgTWF0aC5hYnMoc3RvcCkpO1xuICAgICAgbGV0IHByZWNpc2lvbjtcbiAgICAgIGlmIChzcGVjaWZpZXIucHJlY2lzaW9uID09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChzcGVjaWZpZXIudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIWlzTmFOKHByZWNpc2lvbiA9IHByZWNpc2lvblByZWZpeChzdGVwLCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0UHJlZml4KHNwZWNpZmllciwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgY2FzZSAnZSc6XG4gICAgICAgICAgY2FzZSAnZyc6XG4gICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgY2FzZSAncic6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uUm91bmQoc3RlcCwgdmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIHNwZWNpZmllci5wcmVjaXNpb24gPSBwcmVjaXNpb24gLSAoc3BlY2lmaWVyLnR5cGUgPT09ICdlJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghaXNOYU4ocHJlY2lzaW9uID0gcHJlY2lzaW9uRml4ZWQoc3RlcCkpKSB7XG4gICAgICAgICAgICAgICAgc3BlY2lmaWVyLnByZWNpc2lvbiA9IHByZWNpc2lvbiAtIChzcGVjaWZpZXIudHlwZSA9PT0gJyUnKSAqIDI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb3JtYXQoc3BlY2lmaWVyKTtcbiAgICB9XG4gIH07XG59XG5sZXQgZGVmYXVsdE51bWJlckxvY2FsZTtcbnJlc2V0TnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuZnVuY3Rpb24gcmVzZXROdW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKCkge1xuICByZXR1cm4gZGVmYXVsdE51bWJlckxvY2FsZSA9IG51bWJlckxvY2FsZSh7XG4gICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgZm9ybWF0UHJlZml4OiBmb3JtYXRQcmVmaXhcbiAgfSk7XG59XG5mdW5jdGlvbiBudW1iZXJGb3JtYXRMb2NhbGUoZGVmaW5pdGlvbikge1xuICByZXR1cm4gbnVtYmVyTG9jYWxlKGZvcm1hdExvY2FsZShkZWZpbml0aW9uKSk7XG59XG5mdW5jdGlvbiBudW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKGRlZmluaXRpb24pIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyBkZWZhdWx0TnVtYmVyTG9jYWxlID0gbnVtYmVyRm9ybWF0TG9jYWxlKGRlZmluaXRpb24pIDogZGVmYXVsdE51bWJlckxvY2FsZTtcbn1cblxuZnVuY3Rpb24gdGltZU11bHRpRm9ybWF0KGZvcm1hdCwgaW50ZXJ2YWwsIHNwZWMpIHtcbiAgc3BlYyA9IHNwZWMgfHwge307XG4gIGlmICghaXNPYmplY3Qoc3BlYykpIHtcbiAgICBlcnJvcihgSW52YWxpZCB0aW1lIG11bHRpLWZvcm1hdCBzcGVjaWZpZXI6ICR7c3BlY31gKTtcbiAgfVxuICBjb25zdCBzZWNvbmQgPSBpbnRlcnZhbChTRUNPTkRTKSxcbiAgICBtaW51dGUgPSBpbnRlcnZhbChNSU5VVEVTKSxcbiAgICBob3VyID0gaW50ZXJ2YWwoSE9VUlMpLFxuICAgIGRheSA9IGludGVydmFsKERBVEUpLFxuICAgIHdlZWsgPSBpbnRlcnZhbChXRUVLKSxcbiAgICBtb250aCA9IGludGVydmFsKE1PTlRIKSxcbiAgICBxdWFydGVyID0gaW50ZXJ2YWwoUVVBUlRFUiksXG4gICAgeWVhciA9IGludGVydmFsKFlFQVIpLFxuICAgIEwgPSBmb3JtYXQoc3BlY1tNSUxMSVNFQ09ORFNdIHx8ICcuJUwnKSxcbiAgICBTID0gZm9ybWF0KHNwZWNbU0VDT05EU10gfHwgJzolUycpLFxuICAgIE0gPSBmb3JtYXQoc3BlY1tNSU5VVEVTXSB8fCAnJUk6JU0nKSxcbiAgICBIID0gZm9ybWF0KHNwZWNbSE9VUlNdIHx8ICclSSAlcCcpLFxuICAgIGQgPSBmb3JtYXQoc3BlY1tEQVRFXSB8fCBzcGVjW0RBWV0gfHwgJyVhICVkJyksXG4gICAgdyA9IGZvcm1hdChzcGVjW1dFRUtdIHx8ICclYiAlZCcpLFxuICAgIG0gPSBmb3JtYXQoc3BlY1tNT05USF0gfHwgJyVCJyksXG4gICAgcSA9IGZvcm1hdChzcGVjW1FVQVJURVJdIHx8ICclQicpLFxuICAgIHkgPSBmb3JtYXQoc3BlY1tZRUFSXSB8fCAnJVknKTtcbiAgcmV0dXJuIGRhdGUgPT4gKHNlY29uZChkYXRlKSA8IGRhdGUgPyBMIDogbWludXRlKGRhdGUpIDwgZGF0ZSA/IFMgOiBob3VyKGRhdGUpIDwgZGF0ZSA/IE0gOiBkYXkoZGF0ZSkgPCBkYXRlID8gSCA6IG1vbnRoKGRhdGUpIDwgZGF0ZSA/IHdlZWsoZGF0ZSkgPCBkYXRlID8gZCA6IHcgOiB5ZWFyKGRhdGUpIDwgZGF0ZSA/IHF1YXJ0ZXIoZGF0ZSkgPCBkYXRlID8gbSA6IHEgOiB5KShkYXRlKTtcbn1cbmZ1bmN0aW9uIHRpbWVMb2NhbGUobG9jYWxlKSB7XG4gIGNvbnN0IHRpbWVGb3JtYXQgPSBtZW1vaXplKGxvY2FsZS5mb3JtYXQpLFxuICAgIHV0Y0Zvcm1hdCA9IG1lbW9pemUobG9jYWxlLnV0Y0Zvcm1hdCk7XG4gIHJldHVybiB7XG4gICAgdGltZUZvcm1hdDogc3BlYyA9PiBpc1N0cmluZyhzcGVjKSA/IHRpbWVGb3JtYXQoc3BlYykgOiB0aW1lTXVsdGlGb3JtYXQodGltZUZvcm1hdCwgdGltZUludGVydmFsLCBzcGVjKSxcbiAgICB1dGNGb3JtYXQ6IHNwZWMgPT4gaXNTdHJpbmcoc3BlYykgPyB1dGNGb3JtYXQoc3BlYykgOiB0aW1lTXVsdGlGb3JtYXQodXRjRm9ybWF0LCB1dGNJbnRlcnZhbCwgc3BlYyksXG4gICAgdGltZVBhcnNlOiBtZW1vaXplKGxvY2FsZS5wYXJzZSksXG4gICAgdXRjUGFyc2U6IG1lbW9pemUobG9jYWxlLnV0Y1BhcnNlKVxuICB9O1xufVxubGV0IGRlZmF1bHRUaW1lTG9jYWxlO1xucmVzZXRUaW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuZnVuY3Rpb24gcmVzZXRUaW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpIHtcbiAgcmV0dXJuIGRlZmF1bHRUaW1lTG9jYWxlID0gdGltZUxvY2FsZSh7XG4gICAgZm9ybWF0OiB0aW1lRm9ybWF0LFxuICAgIHBhcnNlOiB0aW1lUGFyc2UsXG4gICAgdXRjRm9ybWF0OiB1dGNGb3JtYXQsXG4gICAgdXRjUGFyc2U6IHV0Y1BhcnNlXG4gIH0pO1xufVxuZnVuY3Rpb24gdGltZUZvcm1hdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiB0aW1lTG9jYWxlKHRpbWVGb3JtYXRMb2NhbGUkMShkZWZpbml0aW9uKSk7XG59XG5mdW5jdGlvbiB0aW1lRm9ybWF0RGVmYXVsdExvY2FsZShkZWZpbml0aW9uKSB7XG4gIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gZGVmYXVsdFRpbWVMb2NhbGUgPSB0aW1lRm9ybWF0TG9jYWxlKGRlZmluaXRpb24pIDogZGVmYXVsdFRpbWVMb2NhbGU7XG59XG5cbmNvbnN0IGNyZWF0ZUxvY2FsZSA9IChudW1iZXIsIHRpbWUpID0+IGV4dGVuZCh7fSwgbnVtYmVyLCB0aW1lKTtcbmZ1bmN0aW9uIGxvY2FsZShudW1iZXJTcGVjLCB0aW1lU3BlYykge1xuICBjb25zdCBudW1iZXIgPSBudW1iZXJTcGVjID8gbnVtYmVyRm9ybWF0TG9jYWxlKG51bWJlclNwZWMpIDogbnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICBjb25zdCB0aW1lID0gdGltZVNwZWMgPyB0aW1lRm9ybWF0TG9jYWxlKHRpbWVTcGVjKSA6IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHJldHVybiBjcmVhdGVMb2NhbGUobnVtYmVyLCB0aW1lKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRMb2NhbGUobnVtYmVyU3BlYywgdGltZVNwZWMpIHtcbiAgY29uc3QgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGlmIChhcmdzICYmIGFyZ3MgIT09IDIpIHtcbiAgICBlcnJvcignZGVmYXVsdExvY2FsZSBleHBlY3RzIGVpdGhlciB6ZXJvIG9yIHR3byBhcmd1bWVudHMuJyk7XG4gIH1cbiAgcmV0dXJuIGFyZ3MgPyBjcmVhdGVMb2NhbGUobnVtYmVyRm9ybWF0RGVmYXVsdExvY2FsZShudW1iZXJTcGVjKSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUodGltZVNwZWMpKSA6IGNyZWF0ZUxvY2FsZShudW1iZXJGb3JtYXREZWZhdWx0TG9jYWxlKCksIHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCkpO1xufVxuZnVuY3Rpb24gcmVzZXREZWZhdWx0TG9jYWxlKCkge1xuICByZXNldE51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUoKTtcbiAgcmVzZXRUaW1lRm9ybWF0RGVmYXVsdExvY2FsZSgpO1xuICByZXR1cm4gZGVmYXVsdExvY2FsZSgpO1xufVxuXG5leHBvcnQgeyBkZWZhdWx0TG9jYWxlLCBsb2NhbGUsIG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUsIG51bWJlckZvcm1hdExvY2FsZSwgcmVzZXREZWZhdWx0TG9jYWxlLCByZXNldE51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUsIHJlc2V0VGltZUZvcm1hdERlZmF1bHRMb2NhbGUsIHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlLCB0aW1lRm9ybWF0TG9jYWxlIH07XG4iLCJpbXBvcnQgeyB0cnV0aHksIGhhc093blByb3BlcnR5LCBlcnJvciwgc3RyaW5nVmFsdWUsIGlzU3RyaW5nLCBpc0Z1bmN0aW9uLCBleHRlbmQsIGlzQXJyYXksIGlzT2JqZWN0LCBmaWVsZCwgYXNjZW5kaW5nLCBpc1JlZ0V4cCwgcGVlaywgaWRlbnRpdHksIGFycmF5IGFzIGFycmF5JDEsIHpvb21TeW1sb2csIHpvb21Qb3csIHpvb21Mb2csIHpvb21MaW5lYXIsIHBhblN5bWxvZywgcGFuUG93LCBwYW5Mb2csIHBhbkxpbmVhciwgY2xhbXBSYW5nZSwgdXRjcXVhcnRlciwgcXVhcnRlciwgdHJ1bmNhdGUsIGlucmFuZ2UsIHNwYW4sIHBhZCwgbGVycCwgZmx1c2gsIHRvU3RyaW5nLCB0b051bWJlciwgdG9Cb29sZWFuLCBpc051bWJlciwgaXNEYXRlLCBpc0Jvb2xlYW4sIGV4dGVudCwgdG9EYXRlIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IExpdGVyYWwsIGNvZGVnZW5FeHByZXNzaW9uLCBjb25zdGFudHMsIGZ1bmN0aW9ucywgcGFyc2VFeHByZXNzaW9uLCBDYWxsRXhwcmVzc2lvbiB9IGZyb20gJ3ZlZ2EtZXhwcmVzc2lvbic7XG5pbXBvcnQgeyBpc1JlZ2lzdGVyZWRTY2FsZSwgYmFuZFNwYWNlLCBzY2FsZSBhcyBzY2FsZSQxLCBzY2FsZUZyYWN0aW9uIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5pbXBvcnQgeyBnZW9Cb3VuZHMgYXMgZ2VvQm91bmRzJDEsIGdlb0NlbnRyb2lkIGFzIGdlb0NlbnRyb2lkJDEsIGdlb0FyZWEgYXMgZ2VvQXJlYSQxIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB7IHJnYiwgaHNsLCBoY2wsIGxhYiB9IGZyb20gJ2QzLWNvbG9yJztcbmltcG9ydCB7IGlzVHVwbGUgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IEdyYWRpZW50LCBwYXRoUmVuZGVyLCBwYXRoUGFyc2UsIEJvdW5kcywgaW50ZXJzZWN0IGFzIGludGVyc2VjdCQxIH0gZnJvbSAndmVnYS1zY2VuZWdyYXBoJztcbmltcG9ydCB7IHNlbGVjdGlvblZpc2l0b3IsIHNlbGVjdGlvblRlc3QsIHNlbGVjdGlvbklkVGVzdCwgc2VsZWN0aW9uUmVzb2x2ZSwgc2VsZWN0aW9uVHVwbGVzIH0gZnJvbSAndmVnYS1zZWxlY3Rpb25zJztcbmltcG9ydCB7IHNhbXBsZVVuaWZvcm0sIHNhbXBsZUxvZ05vcm1hbCwgc2FtcGxlTm9ybWFsLCBxdWFudGlsZVVuaWZvcm0sIHF1YW50aWxlTG9nTm9ybWFsLCBxdWFudGlsZU5vcm1hbCwgZGVuc2l0eVVuaWZvcm0sIGRlbnNpdHlMb2dOb3JtYWwsIGRlbnNpdHlOb3JtYWwsIGN1bXVsYXRpdmVVbmlmb3JtLCBjdW11bGF0aXZlTG9nTm9ybWFsLCBjdW11bGF0aXZlTm9ybWFsLCByYW5kb20gfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuaW1wb3J0IHsgdXRjZGF5b2Z5ZWFyLCBkYXlvZnllYXIsIHV0Y3dlZWssIHdlZWssIHRpbWVVbml0U3BlY2lmaWVyLCB0aW1lU2VxdWVuY2UsIHRpbWVPZmZzZXQsIHV0Y1NlcXVlbmNlLCB1dGNPZmZzZXQgfSBmcm9tICd2ZWdhLXRpbWUnO1xuaW1wb3J0IHsgcmFuZ2UgYXMgcmFuZ2UkMSB9IGZyb20gJ2QzLWFycmF5JztcblxuZnVuY3Rpb24gZGF0YShuYW1lKSB7XG4gIGNvbnN0IGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXTtcbiAgcmV0dXJuIGRhdGEgPyBkYXRhLnZhbHVlcy52YWx1ZSA6IFtdO1xufVxuZnVuY3Rpb24gaW5kYXRhKG5hbWUsIGZpZWxkLCB2YWx1ZSkge1xuICBjb25zdCBpbmRleCA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdWydpbmRleDonICsgZmllbGRdLFxuICAgIGVudHJ5ID0gaW5kZXggPyBpbmRleC52YWx1ZS5nZXQodmFsdWUpIDogdW5kZWZpbmVkO1xuICByZXR1cm4gZW50cnkgPyBlbnRyeS5jb3VudCA6IGVudHJ5O1xufVxuZnVuY3Rpb24gc2V0ZGF0YShuYW1lLCB0dXBsZXMpIHtcbiAgY29uc3QgZGYgPSB0aGlzLmNvbnRleHQuZGF0YWZsb3csXG4gICAgZGF0YSA9IHRoaXMuY29udGV4dC5kYXRhW25hbWVdLFxuICAgIGlucHV0ID0gZGF0YS5pbnB1dDtcbiAgZGYucHVsc2UoaW5wdXQsIGRmLmNoYW5nZXNldCgpLnJlbW92ZSh0cnV0aHkpLmluc2VydCh0dXBsZXMpKTtcbiAgcmV0dXJuIDE7XG59XG5cbmZ1bmN0aW9uIGVuY29kZSAoaXRlbSwgbmFtZSwgcmV0dmFsKSB7XG4gIGlmIChpdGVtKSB7XG4gICAgY29uc3QgZGYgPSB0aGlzLmNvbnRleHQuZGF0YWZsb3csXG4gICAgICB0YXJnZXQgPSBpdGVtLm1hcmsuc291cmNlO1xuICAgIGRmLnB1bHNlKHRhcmdldCwgZGYuY2hhbmdlc2V0KCkuZW5jb2RlKGl0ZW0sIG5hbWUpKTtcbiAgfVxuICByZXR1cm4gcmV0dmFsICE9PSB1bmRlZmluZWQgPyByZXR2YWwgOiBpdGVtO1xufVxuXG5jb25zdCB3cmFwID0gbWV0aG9kID0+IGZ1bmN0aW9uICh2YWx1ZSwgc3BlYykge1xuICBjb25zdCBsb2NhbGUgPSB0aGlzLmNvbnRleHQuZGF0YWZsb3cubG9jYWxlKCk7XG4gIHJldHVybiB2YWx1ZSA9PT0gbnVsbCA/ICdudWxsJyA6IGxvY2FsZVttZXRob2RdKHNwZWMpKHZhbHVlKTtcbn07XG5jb25zdCBmb3JtYXQgPSB3cmFwKCdmb3JtYXQnKTtcbmNvbnN0IHRpbWVGb3JtYXQgPSB3cmFwKCd0aW1lRm9ybWF0Jyk7XG5jb25zdCB1dGNGb3JtYXQgPSB3cmFwKCd1dGNGb3JtYXQnKTtcbmNvbnN0IHRpbWVQYXJzZSA9IHdyYXAoJ3RpbWVQYXJzZScpO1xuY29uc3QgdXRjUGFyc2UgPSB3cmFwKCd1dGNQYXJzZScpO1xuY29uc3QgZGF0ZU9iaiA9IG5ldyBEYXRlKDIwMDAsIDAsIDEpO1xuZnVuY3Rpb24gdGltZShtb250aCwgZGF5LCBzcGVjaWZpZXIpIHtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG1vbnRoKSB8fCAhTnVtYmVyLmlzSW50ZWdlcihkYXkpKSByZXR1cm4gJyc7XG4gIGRhdGVPYmouc2V0WWVhcigyMDAwKTtcbiAgZGF0ZU9iai5zZXRNb250aChtb250aCk7XG4gIGRhdGVPYmouc2V0RGF0ZShkYXkpO1xuICByZXR1cm4gdGltZUZvcm1hdC5jYWxsKHRoaXMsIGRhdGVPYmosIHNwZWNpZmllcik7XG59XG5mdW5jdGlvbiBtb250aEZvcm1hdChtb250aCkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIG1vbnRoLCAxLCAnJUInKTtcbn1cbmZ1bmN0aW9uIG1vbnRoQWJicmV2Rm9ybWF0KG1vbnRoKSB7XG4gIHJldHVybiB0aW1lLmNhbGwodGhpcywgbW9udGgsIDEsICclYicpO1xufVxuZnVuY3Rpb24gZGF5Rm9ybWF0KGRheSkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIDAsIDIgKyBkYXksICclQScpO1xufVxuZnVuY3Rpb24gZGF5QWJicmV2Rm9ybWF0KGRheSkge1xuICByZXR1cm4gdGltZS5jYWxsKHRoaXMsIDAsIDIgKyBkYXksICclYScpO1xufVxuXG5jb25zdCBEYXRhUHJlZml4ID0gJzonO1xuY29uc3QgSW5kZXhQcmVmaXggPSAnQCc7XG5jb25zdCBTY2FsZVByZWZpeCA9ICclJztcbmNvbnN0IFNpZ25hbFByZWZpeCA9ICckJztcblxuZnVuY3Rpb24gZGF0YVZpc2l0b3IobmFtZSwgYXJncywgc2NvcGUsIHBhcmFtcykge1xuICBpZiAoYXJnc1swXS50eXBlICE9PSBMaXRlcmFsKSB7XG4gICAgZXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IHRvIGRhdGEgZnVuY3Rpb25zIG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC4nKTtcbiAgfVxuICBjb25zdCBkYXRhID0gYXJnc1swXS52YWx1ZSxcbiAgICBkYXRhTmFtZSA9IERhdGFQcmVmaXggKyBkYXRhO1xuICBpZiAoIWhhc093blByb3BlcnR5KGRhdGFOYW1lLCBwYXJhbXMpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcmFtc1tkYXRhTmFtZV0gPSBzY29wZS5nZXREYXRhKGRhdGEpLnR1cGxlc1JlZigpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgLy8gaWYgZGF0YSBzZXQgZG9lcyBub3QgZXhpc3QsIHRoZXJlJ3Mgbm90aGluZyB0byB0cmFja1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gaW5kYXRhVmlzaXRvcihuYW1lLCBhcmdzLCBzY29wZSwgcGFyYW1zKSB7XG4gIGlmIChhcmdzWzBdLnR5cGUgIT09IExpdGVyYWwpIGVycm9yKCdGaXJzdCBhcmd1bWVudCB0byBpbmRhdGEgbXVzdCBiZSBhIHN0cmluZyBsaXRlcmFsLicpO1xuICBpZiAoYXJnc1sxXS50eXBlICE9PSBMaXRlcmFsKSBlcnJvcignU2Vjb25kIGFyZ3VtZW50IHRvIGluZGF0YSBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgIGZpZWxkID0gYXJnc1sxXS52YWx1ZSxcbiAgICBpbmRleE5hbWUgPSBJbmRleFByZWZpeCArIGZpZWxkO1xuICBpZiAoIWhhc093blByb3BlcnR5KGluZGV4TmFtZSwgcGFyYW1zKSkge1xuICAgIHBhcmFtc1tpbmRleE5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS5pbmRhdGFSZWYoc2NvcGUsIGZpZWxkKTtcbiAgfVxufVxuZnVuY3Rpb24gc2NhbGVWaXNpdG9yKG5hbWUsIGFyZ3MsIHNjb3BlLCBwYXJhbXMpIHtcbiAgaWYgKGFyZ3NbMF0udHlwZSA9PT0gTGl0ZXJhbCkge1xuICAgIC8vIGFkZCBzY2FsZSBkZXBlbmRlbmN5XG4gICAgYWRkU2NhbGVEZXBlbmRlbmN5KHNjb3BlLCBwYXJhbXMsIGFyZ3NbMF0udmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIGluZGlyZWN0IHNjYWxlIGxvb2t1cDsgYWRkIGFsbCBzY2FsZXMgYXMgcGFyYW1ldGVyc1xuICAgIGZvciAobmFtZSBpbiBzY29wZS5zY2FsZXMpIHtcbiAgICAgIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGFkZFNjYWxlRGVwZW5kZW5jeShzY29wZSwgcGFyYW1zLCBuYW1lKSB7XG4gIGNvbnN0IHNjYWxlTmFtZSA9IFNjYWxlUHJlZml4ICsgbmFtZTtcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIHNjYWxlTmFtZSkpIHtcbiAgICB0cnkge1xuICAgICAgcGFyYW1zW3NjYWxlTmFtZV0gPSBzY29wZS5zY2FsZVJlZihuYW1lKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIFRPRE86IGVycm9yIGhhbmRsaW5nPyB3YXJuaW5nP1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIG5hbWVPckZ1bmN0aW9uIG11c3QgYmUgYSBzdHJpbmcgb3IgZnVuY3Rpb24gdGhhdCB3YXMgcmVnaXN0ZXJlZC5cbiAqIFJldHVybiB1bmRlZmluZWQgaWYgc2NhbGUgaXMgbm90IHJlY29nbml6ZWQuXG4gKi9cbmZ1bmN0aW9uIGdldFNjYWxlKG5hbWVPckZ1bmN0aW9uLCBjdHgpIHtcbiAgaWYgKGlzU3RyaW5nKG5hbWVPckZ1bmN0aW9uKSkge1xuICAgIGNvbnN0IG1heWJlU2NhbGUgPSBjdHguc2NhbGVzW25hbWVPckZ1bmN0aW9uXTtcbiAgICByZXR1cm4gbWF5YmVTY2FsZSAmJiBpc1JlZ2lzdGVyZWRTY2FsZShtYXliZVNjYWxlLnZhbHVlKSA/IG1heWJlU2NhbGUudmFsdWUgOiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoaXNGdW5jdGlvbihuYW1lT3JGdW5jdGlvbikpIHtcbiAgICByZXR1cm4gaXNSZWdpc3RlcmVkU2NhbGUobmFtZU9yRnVuY3Rpb24pID8gbmFtZU9yRnVuY3Rpb24gOiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGludGVybmFsU2NhbGVGdW5jdGlvbnMoY29kZWdlbiwgZm5jdHgsIHZpc2l0b3JzKSB7XG4gIC8vIGFkZCBoZWxwZXIgbWV0aG9kIHRvIHRoZSAndGhpcycgZXhwcmVzc2lvbiBmdW5jdGlvbiBjb250ZXh0XG4gIGZuY3R4Ll9fYmFuZHdpZHRoID0gcyA9PiBzICYmIHMuYmFuZHdpZHRoID8gcy5iYW5kd2lkdGgoKSA6IDA7XG5cbiAgLy8gcmVnaXN0ZXIgQVNUIHZpc2l0b3JzIGZvciBpbnRlcm5hbCBzY2FsZSBmdW5jdGlvbnNcbiAgdmlzaXRvcnMuX2JhbmR3aWR0aCA9IHNjYWxlVmlzaXRvcjtcbiAgdmlzaXRvcnMuX3JhbmdlID0gc2NhbGVWaXNpdG9yO1xuICB2aXNpdG9ycy5fc2NhbGUgPSBzY2FsZVZpc2l0b3I7XG5cbiAgLy8gcmVzb2x2ZSBzY2FsZSByZWZlcmVuY2UgZGlyZWN0bHkgdG8gdGhlIHNpZ25hbCBoYXNoIGFyZ3VtZW50XG4gIGNvbnN0IHJlZiA9IGFyZyA9PiAnX1snICsgKGFyZy50eXBlID09PSBMaXRlcmFsID8gc3RyaW5nVmFsdWUoU2NhbGVQcmVmaXggKyBhcmcudmFsdWUpIDogc3RyaW5nVmFsdWUoU2NhbGVQcmVmaXgpICsgJysnICsgY29kZWdlbihhcmcpKSArICddJztcblxuICAvLyBkZWZpbmUgYW5kIHJldHVybiBpbnRlcm5hbCBzY2FsZSBmdW5jdGlvbiBjb2RlIGdlbmVyYXRvcnNcbiAgLy8gdGhlc2UgaW50ZXJuYWwgZnVuY3Rpb25zIGFyZSBjYWxsZWQgYnkgbWFyayBlbmNvZGVyc1xuICByZXR1cm4ge1xuICAgIF9iYW5kd2lkdGg6IGFyZ3MgPT4gYHRoaXMuX19iYW5kd2lkdGgoJHtyZWYoYXJnc1swXSl9KWAsXG4gICAgX3JhbmdlOiBhcmdzID0+IGAke3JlZihhcmdzWzBdKX0ucmFuZ2UoKWAsXG4gICAgX3NjYWxlOiBhcmdzID0+IGAke3JlZihhcmdzWzBdKX0oJHtjb2RlZ2VuKGFyZ3NbMV0pfSlgXG4gIH07XG59XG5cbmZ1bmN0aW9uIGdlb01ldGhvZChtZXRob2ROYW1lLCBnbG9iYWxNZXRob2QpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChwcm9qZWN0aW9uLCBnZW9qc29uLCBncm91cCkge1xuICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAvLyBwcm9qZWN0aW9uIGRlZmluZWQsIHVzZSBpdFxuICAgICAgY29uc3QgcCA9IGdldFNjYWxlKHByb2plY3Rpb24sIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgICAgIHJldHVybiBwICYmIHAucGF0aFttZXRob2ROYW1lXShnZW9qc29uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gcHJvamVjdGlvbiB1bmRlZmluZWQsIHVzZSBnbG9iYWwgbWV0aG9kXG4gICAgICByZXR1cm4gZ2xvYmFsTWV0aG9kKGdlb2pzb24pO1xuICAgIH1cbiAgfTtcbn1cbmNvbnN0IGdlb0FyZWEgPSBnZW9NZXRob2QoJ2FyZWEnLCBnZW9BcmVhJDEpO1xuY29uc3QgZ2VvQm91bmRzID0gZ2VvTWV0aG9kKCdib3VuZHMnLCBnZW9Cb3VuZHMkMSk7XG5jb25zdCBnZW9DZW50cm9pZCA9IGdlb01ldGhvZCgnY2VudHJvaWQnLCBnZW9DZW50cm9pZCQxKTtcbmZ1bmN0aW9uIGdlb1NjYWxlKHByb2plY3Rpb24sIGdyb3VwKSB7XG4gIGNvbnN0IHAgPSBnZXRTY2FsZShwcm9qZWN0aW9uLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBwICYmIHAuc2NhbGUoKTtcbn1cblxuZnVuY3Rpb24gaW5TY29wZSAoaXRlbSkge1xuICBjb25zdCBncm91cCA9IHRoaXMuY29udGV4dC5ncm91cDtcbiAgbGV0IHZhbHVlID0gZmFsc2U7XG4gIGlmIChncm91cCkgd2hpbGUgKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSA9PT0gZ3JvdXApIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpdGVtID0gaXRlbS5tYXJrLmdyb3VwO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gbG9nKGRmLCBtZXRob2QsIGFyZ3MpIHtcbiAgdHJ5IHtcbiAgICBkZlttZXRob2RdLmFwcGx5KGRmLCBbJ0VYUFJFU1NJT04nXS5jb25jYXQoW10uc2xpY2UuY2FsbChhcmdzKSkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZi53YXJuKGVycik7XG4gIH1cbiAgcmV0dXJuIGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIHdhcm4oKSB7XG4gIHJldHVybiBsb2codGhpcy5jb250ZXh0LmRhdGFmbG93LCAnd2FybicsIGFyZ3VtZW50cyk7XG59XG5mdW5jdGlvbiBpbmZvKCkge1xuICByZXR1cm4gbG9nKHRoaXMuY29udGV4dC5kYXRhZmxvdywgJ2luZm8nLCBhcmd1bWVudHMpO1xufVxuZnVuY3Rpb24gZGVidWcoKSB7XG4gIHJldHVybiBsb2codGhpcy5jb250ZXh0LmRhdGFmbG93LCAnZGVidWcnLCBhcmd1bWVudHMpO1xufVxuXG4vLyBodHRwczovL3d3dy53My5vcmcvVFIvMjAwOC9SRUMtV0NBRzIwLTIwMDgxMjExLyNyZWxhdGl2ZWx1bWluYW5jZWRlZlxuZnVuY3Rpb24gY2hhbm5lbF9sdW1pbmFuY2VfdmFsdWUoY2hhbm5lbFZhbHVlKSB7XG4gIGNvbnN0IHZhbCA9IGNoYW5uZWxWYWx1ZSAvIDI1NTtcbiAgaWYgKHZhbCA8PSAwLjAzOTI4KSB7XG4gICAgcmV0dXJuIHZhbCAvIDEyLjkyO1xuICB9XG4gIHJldHVybiBNYXRoLnBvdygodmFsICsgMC4wNTUpIC8gMS4wNTUsIDIuNCk7XG59XG5mdW5jdGlvbiBsdW1pbmFuY2UoY29sb3IpIHtcbiAgY29uc3QgYyA9IHJnYihjb2xvciksXG4gICAgciA9IGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGMuciksXG4gICAgZyA9IGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGMuZyksXG4gICAgYiA9IGNoYW5uZWxfbHVtaW5hbmNlX3ZhbHVlKGMuYik7XG4gIHJldHVybiAwLjIxMjYgKiByICsgMC43MTUyICogZyArIDAuMDcyMiAqIGI7XG59XG5cbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDA4L1JFQy1XQ0FHMjAtMjAwODEyMTEvI2NvbnRyYXN0LXJhdGlvZGVmXG5mdW5jdGlvbiBjb250cmFzdChjb2xvcjEsIGNvbG9yMikge1xuICBjb25zdCBsdW0xID0gbHVtaW5hbmNlKGNvbG9yMSksXG4gICAgbHVtMiA9IGx1bWluYW5jZShjb2xvcjIpLFxuICAgIGx1bUwgPSBNYXRoLm1heChsdW0xLCBsdW0yKSxcbiAgICBsdW1EID0gTWF0aC5taW4obHVtMSwgbHVtMik7XG4gIHJldHVybiAobHVtTCArIDAuMDUpIC8gKGx1bUQgKyAwLjA1KTtcbn1cblxuZnVuY3Rpb24gbWVyZ2UgKCkge1xuICBjb25zdCBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICBhcmdzLnVuc2hpZnQoe30pO1xuICByZXR1cm4gZXh0ZW5kKC4uLmFyZ3MpO1xufVxuXG5mdW5jdGlvbiBlcXVhbChhLCBiKSB7XG4gIHJldHVybiBhID09PSBiIHx8IGEgIT09IGEgJiYgYiAhPT0gYiA/IHRydWUgOiBpc0FycmF5KGEpID8gaXNBcnJheShiKSAmJiBhLmxlbmd0aCA9PT0gYi5sZW5ndGggPyBlcXVhbEFycmF5KGEsIGIpIDogZmFsc2UgOiBpc09iamVjdChhKSAmJiBpc09iamVjdChiKSA/IGVxdWFsT2JqZWN0KGEsIGIpIDogZmFsc2U7XG59XG5mdW5jdGlvbiBlcXVhbEFycmF5KGEsIGIpIHtcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGlmICghZXF1YWwoYVtpXSwgYltpXSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGVxdWFsT2JqZWN0KGEsIGIpIHtcbiAgZm9yIChjb25zdCBrZXkgaW4gYSkge1xuICAgIGlmICghZXF1YWwoYVtrZXldLCBiW2tleV0pKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiByZW1vdmVQcmVkaWNhdGUocHJvcHMpIHtcbiAgcmV0dXJuIF8gPT4gZXF1YWxPYmplY3QocHJvcHMsIF8pO1xufVxuZnVuY3Rpb24gbW9kaWZ5IChuYW1lLCBpbnNlcnQsIHJlbW92ZSwgdG9nZ2xlLCBtb2RpZnksIHZhbHVlcykge1xuICBjb25zdCBkZiA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgaW5wdXQgPSBkYXRhLmlucHV0LFxuICAgIHN0YW1wID0gZGYuc3RhbXAoKTtcbiAgbGV0IGNoYW5nZXMgPSBkYXRhLmNoYW5nZXMsXG4gICAgcHJlZGljYXRlLFxuICAgIGtleTtcbiAgaWYgKGRmLl90cmlnZ2VyID09PSBmYWxzZSB8fCAhKGlucHV0LnZhbHVlLmxlbmd0aCB8fCBpbnNlcnQgfHwgdG9nZ2xlKSkge1xuICAgIC8vIG5vdGhpbmcgdG8gZG8hXG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKCFjaGFuZ2VzIHx8IGNoYW5nZXMuc3RhbXAgPCBzdGFtcCkge1xuICAgIGRhdGEuY2hhbmdlcyA9IGNoYW5nZXMgPSBkZi5jaGFuZ2VzZXQoKTtcbiAgICBjaGFuZ2VzLnN0YW1wID0gc3RhbXA7XG4gICAgZGYucnVuQWZ0ZXIoKCkgPT4ge1xuICAgICAgZGF0YS5tb2RpZmllZCA9IHRydWU7XG4gICAgICBkZi5wdWxzZShpbnB1dCwgY2hhbmdlcykucnVuKCk7XG4gICAgfSwgdHJ1ZSwgMSk7XG4gIH1cbiAgaWYgKHJlbW92ZSkge1xuICAgIHByZWRpY2F0ZSA9IHJlbW92ZSA9PT0gdHJ1ZSA/IHRydXRoeSA6IGlzQXJyYXkocmVtb3ZlKSB8fCBpc1R1cGxlKHJlbW92ZSkgPyByZW1vdmUgOiByZW1vdmVQcmVkaWNhdGUocmVtb3ZlKTtcbiAgICBjaGFuZ2VzLnJlbW92ZShwcmVkaWNhdGUpO1xuICB9XG4gIGlmIChpbnNlcnQpIHtcbiAgICBjaGFuZ2VzLmluc2VydChpbnNlcnQpO1xuICB9XG4gIGlmICh0b2dnbGUpIHtcbiAgICBwcmVkaWNhdGUgPSByZW1vdmVQcmVkaWNhdGUodG9nZ2xlKTtcbiAgICBpZiAoaW5wdXQudmFsdWUuc29tZShwcmVkaWNhdGUpKSB7XG4gICAgICBjaGFuZ2VzLnJlbW92ZShwcmVkaWNhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFuZ2VzLmluc2VydCh0b2dnbGUpO1xuICAgIH1cbiAgfVxuICBpZiAobW9kaWZ5KSB7XG4gICAgZm9yIChrZXkgaW4gdmFsdWVzKSB7XG4gICAgICBjaGFuZ2VzLm1vZGlmeShtb2RpZnksIGtleSwgdmFsdWVzW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gcGluY2hEaXN0YW5jZShldmVudCkge1xuICBjb25zdCB0ID0gZXZlbnQudG91Y2hlcyxcbiAgICBkeCA9IHRbMF0uY2xpZW50WCAtIHRbMV0uY2xpZW50WCxcbiAgICBkeSA9IHRbMF0uY2xpZW50WSAtIHRbMV0uY2xpZW50WTtcbiAgcmV0dXJuIE1hdGguaHlwb3QoZHgsIGR5KTtcbn1cbmZ1bmN0aW9uIHBpbmNoQW5nbGUoZXZlbnQpIHtcbiAgY29uc3QgdCA9IGV2ZW50LnRvdWNoZXM7XG4gIHJldHVybiBNYXRoLmF0YW4yKHRbMF0uY2xpZW50WSAtIHRbMV0uY2xpZW50WSwgdFswXS5jbGllbnRYIC0gdFsxXS5jbGllbnRYKTtcbn1cblxuLy8gbWVtb2l6ZSBhY2Nlc3NvciBmdW5jdGlvbnNcbmNvbnN0IGFjY2Vzc29ycyA9IHt9O1xuZnVuY3Rpb24gcGx1Y2sgKGRhdGEsIG5hbWUpIHtcbiAgY29uc3QgYWNjZXNzb3IgPSBhY2Nlc3NvcnNbbmFtZV0gfHwgKGFjY2Vzc29yc1tuYW1lXSA9IGZpZWxkKG5hbWUpKTtcbiAgcmV0dXJuIGlzQXJyYXkoZGF0YSkgPyBkYXRhLm1hcChhY2Nlc3NvcikgOiBhY2Nlc3NvcihkYXRhKTtcbn1cblxuZnVuY3Rpb24gYXJyYXkoc2VxKSB7XG4gIHJldHVybiBpc0FycmF5KHNlcSkgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHNlcSkgPyBzZXEgOiBudWxsO1xufVxuZnVuY3Rpb24gc2VxdWVuY2Uoc2VxKSB7XG4gIHJldHVybiBhcnJheShzZXEpIHx8IChpc1N0cmluZyhzZXEpID8gc2VxIDogbnVsbCk7XG59XG5mdW5jdGlvbiBqb2luKHNlcSkge1xuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cbiAgcmV0dXJuIGFycmF5KHNlcSkuam9pbiguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIGluZGV4b2Yoc2VxKSB7XG4gIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgYXJnc1tfa2V5MiAtIDFdID0gYXJndW1lbnRzW19rZXkyXTtcbiAgfVxuICByZXR1cm4gc2VxdWVuY2Uoc2VxKS5pbmRleE9mKC4uLmFyZ3MpO1xufVxuZnVuY3Rpb24gbGFzdGluZGV4b2Yoc2VxKSB7XG4gIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgYXJnc1tfa2V5MyAtIDFdID0gYXJndW1lbnRzW19rZXkzXTtcbiAgfVxuICByZXR1cm4gc2VxdWVuY2Uoc2VxKS5sYXN0SW5kZXhPZiguLi5hcmdzKTtcbn1cbmZ1bmN0aW9uIHNsaWNlKHNlcSkge1xuICBmb3IgKHZhciBfbGVuNCA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjQgPiAxID8gX2xlbjQgLSAxIDogMCksIF9rZXk0ID0gMTsgX2tleTQgPCBfbGVuNDsgX2tleTQrKykge1xuICAgIGFyZ3NbX2tleTQgLSAxXSA9IGFyZ3VtZW50c1tfa2V5NF07XG4gIH1cbiAgcmV0dXJuIHNlcXVlbmNlKHNlcSkuc2xpY2UoLi4uYXJncyk7XG59XG5mdW5jdGlvbiByZXBsYWNlKHN0ciwgcGF0dGVybiwgcmVwbCkge1xuICBpZiAoaXNGdW5jdGlvbihyZXBsKSkgZXJyb3IoJ0Z1bmN0aW9uIGFyZ3VtZW50IHBhc3NlZCB0byByZXBsYWNlLicpO1xuICBpZiAoIWlzU3RyaW5nKHBhdHRlcm4pICYmICFpc1JlZ0V4cChwYXR0ZXJuKSkgZXJyb3IoJ1BsZWFzZSBwYXNzIGEgc3RyaW5nIG9yIFJlZ0V4cCBhcmd1bWVudCB0byByZXBsYWNlLicpO1xuICByZXR1cm4gU3RyaW5nKHN0cikucmVwbGFjZShwYXR0ZXJuLCByZXBsKTtcbn1cbmZ1bmN0aW9uIHJldmVyc2Uoc2VxKSB7XG4gIHJldHVybiBhcnJheShzZXEpLnNsaWNlKCkucmV2ZXJzZSgpO1xufVxuZnVuY3Rpb24gc29ydChzZXEpIHtcbiAgcmV0dXJuIGFycmF5KHNlcSkuc2xpY2UoKS5zb3J0KGFzY2VuZGluZyk7XG59XG5cbmZ1bmN0aW9uIGJhbmRzcGFjZShjb3VudCwgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIpIHtcbiAgcmV0dXJuIGJhbmRTcGFjZShjb3VudCB8fCAwLCBwYWRkaW5nSW5uZXIgfHwgMCwgcGFkZGluZ091dGVyIHx8IDApO1xufVxuZnVuY3Rpb24gYmFuZHdpZHRoKG5hbWUsIGdyb3VwKSB7XG4gIGNvbnN0IHMgPSBnZXRTY2FsZShuYW1lLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBzICYmIHMuYmFuZHdpZHRoID8gcy5iYW5kd2lkdGgoKSA6IDA7XG59XG5mdW5jdGlvbiBjb3B5KG5hbWUsIGdyb3VwKSB7XG4gIGNvbnN0IHMgPSBnZXRTY2FsZShuYW1lLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBzID8gcy5jb3B5KCkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBkb21haW4obmFtZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgPyBzLmRvbWFpbigpIDogW107XG59XG5mdW5jdGlvbiBpbnZlcnQobmFtZSwgcmFuZ2UsIGdyb3VwKSB7XG4gIGNvbnN0IHMgPSBnZXRTY2FsZShuYW1lLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiAhcyA/IHVuZGVmaW5lZCA6IGlzQXJyYXkocmFuZ2UpID8gKHMuaW52ZXJ0UmFuZ2UgfHwgcy5pbnZlcnQpKHJhbmdlKSA6IChzLmludmVydCB8fCBzLmludmVydEV4dGVudCkocmFuZ2UpO1xufVxuZnVuY3Rpb24gcmFuZ2UobmFtZSwgZ3JvdXApIHtcbiAgY29uc3QgcyA9IGdldFNjYWxlKG5hbWUsIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIHMgJiYgcy5yYW5nZSA/IHMucmFuZ2UoKSA6IFtdO1xufVxuZnVuY3Rpb24gc2NhbGUobmFtZSwgdmFsdWUsIGdyb3VwKSB7XG4gIGNvbnN0IHMgPSBnZXRTY2FsZShuYW1lLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIHJldHVybiBzID8gcyh2YWx1ZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHNjYWxlR3JhZGllbnQgKHNjYWxlLCBwMCwgcDEsIGNvdW50LCBncm91cCkge1xuICBzY2FsZSA9IGdldFNjYWxlKHNjYWxlLCAoZ3JvdXAgfHwgdGhpcykuY29udGV4dCk7XG4gIGNvbnN0IGdyYWRpZW50ID0gR3JhZGllbnQocDAsIHAxKTtcbiAgbGV0IHN0b3BzID0gc2NhbGUuZG9tYWluKCksXG4gICAgbWluID0gc3RvcHNbMF0sXG4gICAgbWF4ID0gcGVlayhzdG9wcyksXG4gICAgZnJhY3Rpb24gPSBpZGVudGl0eTtcbiAgaWYgKCEobWF4IC0gbWluKSkge1xuICAgIC8vIGV4cGFuZCBzY2FsZSBpZiBkb21haW4gaGFzIHplcm8gc3BhbiwgZml4ICMxNDc5XG4gICAgc2NhbGUgPSAoc2NhbGUuaW50ZXJwb2xhdG9yID8gc2NhbGUkMSgnc2VxdWVudGlhbCcpKCkuaW50ZXJwb2xhdG9yKHNjYWxlLmludGVycG9sYXRvcigpKSA6IHNjYWxlJDEoJ2xpbmVhcicpKCkuaW50ZXJwb2xhdGUoc2NhbGUuaW50ZXJwb2xhdGUoKSkucmFuZ2Uoc2NhbGUucmFuZ2UoKSkpLmRvbWFpbihbbWluID0gMCwgbWF4ID0gMV0pO1xuICB9IGVsc2Uge1xuICAgIGZyYWN0aW9uID0gc2NhbGVGcmFjdGlvbihzY2FsZSwgbWluLCBtYXgpO1xuICB9XG4gIGlmIChzY2FsZS50aWNrcykge1xuICAgIHN0b3BzID0gc2NhbGUudGlja3MoK2NvdW50IHx8IDE1KTtcbiAgICBpZiAobWluICE9PSBzdG9wc1swXSkgc3RvcHMudW5zaGlmdChtaW4pO1xuICAgIGlmIChtYXggIT09IHBlZWsoc3RvcHMpKSBzdG9wcy5wdXNoKG1heCk7XG4gIH1cbiAgc3RvcHMuZm9yRWFjaChfID0+IGdyYWRpZW50LnN0b3AoZnJhY3Rpb24oXyksIHNjYWxlKF8pKSk7XG4gIHJldHVybiBncmFkaWVudDtcbn1cblxuZnVuY3Rpb24gZ2VvU2hhcGUocHJvamVjdGlvbiwgZ2VvanNvbiwgZ3JvdXApIHtcbiAgY29uc3QgcCA9IGdldFNjYWxlKHByb2plY3Rpb24sIChncm91cCB8fCB0aGlzKS5jb250ZXh0KTtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgcmV0dXJuIHAgPyBwLnBhdGguY29udGV4dChjb250ZXh0KShnZW9qc29uKSA6ICcnO1xuICB9O1xufVxuZnVuY3Rpb24gcGF0aFNoYXBlKHBhdGgpIHtcbiAgbGV0IHAgPSBudWxsO1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCA/IHBhdGhSZW5kZXIoY29udGV4dCwgcCA9IHAgfHwgcGF0aFBhcnNlKHBhdGgpKSA6IHBhdGg7XG4gIH07XG59XG5cbmNvbnN0IGRhdHVtID0gZCA9PiBkLmRhdGE7XG5mdW5jdGlvbiB0cmVlTm9kZXMobmFtZSwgY29udGV4dCkge1xuICBjb25zdCB0cmVlID0gZGF0YS5jYWxsKGNvbnRleHQsIG5hbWUpO1xuICByZXR1cm4gdHJlZS5yb290ICYmIHRyZWUucm9vdC5sb29rdXAgfHwge307XG59XG5mdW5jdGlvbiB0cmVlUGF0aChuYW1lLCBzb3VyY2UsIHRhcmdldCkge1xuICBjb25zdCBub2RlcyA9IHRyZWVOb2RlcyhuYW1lLCB0aGlzKSxcbiAgICBzID0gbm9kZXNbc291cmNlXSxcbiAgICB0ID0gbm9kZXNbdGFyZ2V0XTtcbiAgcmV0dXJuIHMgJiYgdCA/IHMucGF0aCh0KS5tYXAoZGF0dW0pIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdHJlZUFuY2VzdG9ycyhuYW1lLCBub2RlKSB7XG4gIGNvbnN0IG4gPSB0cmVlTm9kZXMobmFtZSwgdGhpcylbbm9kZV07XG4gIHJldHVybiBuID8gbi5hbmNlc3RvcnMoKS5tYXAoZGF0dW0pIDogdW5kZWZpbmVkO1xufVxuXG5jb25zdCBfd2luZG93ID0gKCkgPT4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93IHx8IG51bGw7XG5mdW5jdGlvbiBzY3JlZW4oKSB7XG4gIGNvbnN0IHcgPSBfd2luZG93KCk7XG4gIHJldHVybiB3ID8gdy5zY3JlZW4gOiB7fTtcbn1cbmZ1bmN0aW9uIHdpbmRvd1NpemUoKSB7XG4gIGNvbnN0IHcgPSBfd2luZG93KCk7XG4gIHJldHVybiB3ID8gW3cuaW5uZXJXaWR0aCwgdy5pbm5lckhlaWdodF0gOiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdO1xufVxuZnVuY3Rpb24gY29udGFpbmVyU2l6ZSgpIHtcbiAgY29uc3QgdmlldyA9IHRoaXMuY29udGV4dC5kYXRhZmxvdyxcbiAgICBlbCA9IHZpZXcuY29udGFpbmVyICYmIHZpZXcuY29udGFpbmVyKCk7XG4gIHJldHVybiBlbCA/IFtlbC5jbGllbnRXaWR0aCwgZWwuY2xpZW50SGVpZ2h0XSA6IFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdCAoYiwgb3B0LCBncm91cCkge1xuICBpZiAoIWIpIHJldHVybiBbXTtcbiAgY29uc3QgW3UsIHZdID0gYixcbiAgICBib3ggPSBuZXcgQm91bmRzKCkuc2V0KHVbMF0sIHVbMV0sIHZbMF0sIHZbMV0pLFxuICAgIHNjZW5lID0gZ3JvdXAgfHwgdGhpcy5jb250ZXh0LmRhdGFmbG93LnNjZW5lZ3JhcGgoKS5yb290O1xuICByZXR1cm4gaW50ZXJzZWN0JDEoc2NlbmUsIGJveCwgZmlsdGVyKG9wdCkpO1xufVxuZnVuY3Rpb24gZmlsdGVyKG9wdCkge1xuICBsZXQgcCA9IG51bGw7XG4gIGlmIChvcHQpIHtcbiAgICBjb25zdCB0eXBlcyA9IGFycmF5JDEob3B0Lm1hcmt0eXBlKSxcbiAgICAgIG5hbWVzID0gYXJyYXkkMShvcHQubWFya25hbWUpO1xuICAgIHAgPSBfID0+ICghdHlwZXMubGVuZ3RoIHx8IHR5cGVzLnNvbWUodCA9PiBfLm1hcmt0eXBlID09PSB0KSkgJiYgKCFuYW1lcy5sZW5ndGggfHwgbmFtZXMuc29tZShzID0+IF8ubmFtZSA9PT0gcykpO1xuICB9XG4gIHJldHVybiBwO1xufVxuXG4vKipcbiAqIEFwcGVuZHMgYSBuZXcgcG9pbnQgdG8gdGhlIGxhc3NvXG4gKlxuICogQHBhcmFtIHsqfSBsYXNzbyB0aGUgbGFzc28gaW4gcGl4ZWwgc3BhY2VcbiAqIEBwYXJhbSB7Kn0geCB0aGUgeCBjb29yZGluYXRlIGluIHBpeGVsIHNwYWNlXG4gKiBAcGFyYW0geyp9IHkgdGhlIHkgY29vcmRpbmF0ZSBpbiBwaXhlbCBzcGFjZVxuICogQHBhcmFtIHsqfSBtaW5EaXN0IHRoZSBtaW5pbXVtIGRpc3RhbmNlLCBpbiBwaXhlbHMsIHRoYXQgdGhlbmV3IHBvaW50IG5lZWRzIHRvIGJlIGFwYXJ0IGZyb20gdGhlIGxhc3QgcG9pbnRcbiAqIEByZXR1cm5zIGEgbmV3IGFycmF5IGNvbnRhaW5pbmcgdGhlIGxhc3NvIHdpdGggdGhlIG5ldyBwb2ludFxuICovXG5mdW5jdGlvbiBsYXNzb0FwcGVuZChsYXNzbywgeCwgeSkge1xuICBsZXQgbWluRGlzdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogNTtcbiAgbGFzc28gPSBhcnJheSQxKGxhc3NvKTtcbiAgY29uc3QgbGFzdCA9IGxhc3NvW2xhc3NvLmxlbmd0aCAtIDFdO1xuXG4gIC8vIEFkZCBwb2ludCB0byBsYXNzbyBpZiBpdHMgdGhlIGZpcnN0IHBvaW50IG9yIGRpc3RhbmNlIHRvIGxhc3QgcG9pbnQgZXhjZWVkIG1pbkRpc3RcbiAgcmV0dXJuIGxhc3QgPT09IHVuZGVmaW5lZCB8fCBNYXRoLmh5cG90KGxhc3RbMF0gLSB4LCBsYXN0WzFdIC0geSkgPiBtaW5EaXN0ID8gWy4uLmxhc3NvLCBbeCwgeV1dIDogbGFzc287XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc3ZnIHBhdGggY29tbWFuZCB3aGljaCBkcmF3cyBhIGxhc3NvXG4gKlxuICogQHBhcmFtIHsqfSBsYXNzbyB0aGUgbGFzc28gaW4gcGl4ZWwgc3BhY2UgaW4gdGhlIGZvcm0gW1t4LHldLCBbeCx5XSwgLi4uXVxuICogQHJldHVybnMgdGhlIHN2ZyBwYXRoIGNvbW1hbmQgdGhhdCBkcmF3cyB0aGUgbGFzc29cbiAqL1xuZnVuY3Rpb24gbGFzc29QYXRoKGxhc3NvKSB7XG4gIHJldHVybiBhcnJheSQxKGxhc3NvKS5yZWR1Y2UoKHN2ZywgX3JlZiwgaSkgPT4ge1xuICAgIGxldCBbeCwgeV0gPSBfcmVmO1xuICAgIHJldHVybiBzdmcgKz0gaSA9PSAwID8gYE0gJHt4fSwke3l9IGAgOiBpID09PSBsYXNzby5sZW5ndGggLSAxID8gJyBaJyA6IGBMICR7eH0sJHt5fSBgO1xuICB9LCAnJyk7XG59XG5cbi8qKlxuICogSW52ZXJ0cyB0aGUgbGFzc28gZnJvbSBwaXhlbCBzcGFjZSB0byBhbiBhcnJheSBvZiB2ZWdhIHNjZW5lZ3JhcGggdHVwbGVzXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIHRoZSBkYXRhc2V0XG4gKiBAcGFyYW0geyp9IHBpeGVsTGFzc28gdGhlIGxhc3NvIGluIHBpeGVsIHNwYWNlLCBbW3gseV0sIFt4LHldLCAuLi5dXG4gKiBAcGFyYW0geyp9IHVuaXQgdGhlIHVuaXQgd2hlcmUgdGhlIGxhc3NvIGlzIGRlZmluZWRcbiAqXG4gKiBAcmV0dXJucyBhbiBhcnJheSBvZiB2ZWdhIHNjZW5lZ3JhcGggdHVwbGVzXG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdExhc3NvKG1hcmtuYW1lLCBwaXhlbExhc3NvLCB1bml0KSB7XG4gIGNvbnN0IHtcbiAgICB4LFxuICAgIHksXG4gICAgbWFya1xuICB9ID0gdW5pdDtcbiAgY29uc3QgYmIgPSBuZXcgQm91bmRzKCkuc2V0KE51bWJlci5NQVhfU0FGRV9JTlRFR0VSLCBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1JTl9TQUZFX0lOVEVHRVIsIE51bWJlci5NSU5fU0FGRV9JTlRFR0VSKTtcblxuICAvLyBHZXQgYm91bmRpbmcgYm94IGFyb3VuZCBsYXNzb1xuICBmb3IgKGNvbnN0IFtweCwgcHldIG9mIHBpeGVsTGFzc28pIHtcbiAgICBpZiAocHggPCBiYi54MSkgYmIueDEgPSBweDtcbiAgICBpZiAocHggPiBiYi54MikgYmIueDIgPSBweDtcbiAgICBpZiAocHkgPCBiYi55MSkgYmIueTEgPSBweTtcbiAgICBpZiAocHkgPiBiYi55MikgYmIueTIgPSBweTtcbiAgfVxuXG4gIC8vIFRyYW5zbGF0ZSBiYiBhZ2FpbnN0IHVuaXQgY29vcmRpbmF0ZXNcbiAgYmIudHJhbnNsYXRlKHgsIHkpO1xuICBjb25zdCBpbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3QoW1tiYi54MSwgYmIueTFdLCBbYmIueDIsIGJiLnkyXV0sIG1hcmtuYW1lLCBtYXJrKTtcblxuICAvLyBDaGVjayBldmVyeSBwb2ludCBhZ2FpbnN0IHRoZSBsYXNzb1xuICByZXR1cm4gaW50ZXJzZWN0aW9uLmZpbHRlcih0dXBsZSA9PiBwb2ludEluUG9seWdvbih0dXBsZS54LCB0dXBsZS55LCBwaXhlbExhc3NvKSk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgYSB0ZXN0IGlmIGEgcG9pbnQgaXMgaW5zaWRlIGEgcG9seWdvbiBiYXNlZCBvbiB0aGUgaWRlYSBmcm9tXG4gKiBodHRwczovL3dyZi5lY3NlLnJwaS5lZHUvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWxcbiAqXG4gKiBUaGlzIG1ldGhvZCB3aWxsIG5vdCBuZWVkIHRoZSBzYW1lIHN0YXJ0L2VuZCBwb2ludCBzaW5jZSBpdCB3cmFwcyBhcm91bmQgdGhlIGVkZ2VzIG9mIHRoZSBhcnJheVxuICpcbiAqIEBwYXJhbSB7Kn0gdGVzdCBhIHBvaW50IHRvIHRlc3QgYWdhaW5zdFxuICogQHBhcmFtIHsqfSBwb2x5Z29uIGEgcG9seWdvbiBpbiB0aGUgZm9ybSBbW3gseV0sIFt4LHldLCAuLi5dXG4gKiBAcmV0dXJucyB0cnVlIGlmIHRoZSBwb2ludCBsaWVzIGluc2lkZSB0aGUgcG9seWdvbiwgZmFsc2Ugb3RoZXJ3aXNlXG4gKi9cbmZ1bmN0aW9uIHBvaW50SW5Qb2x5Z29uKHRlc3R4LCB0ZXN0eSwgcG9seWdvbikge1xuICBsZXQgaW50ZXJzZWN0aW9ucyA9IDA7XG4gIGZvciAobGV0IGkgPSAwLCBqID0gcG9seWdvbi5sZW5ndGggLSAxOyBpIDwgcG9seWdvbi5sZW5ndGg7IGogPSBpKyspIHtcbiAgICBjb25zdCBbcHJldlgsIHByZXZZXSA9IHBvbHlnb25bal07XG4gICAgY29uc3QgW3gsIHldID0gcG9seWdvbltpXTtcblxuICAgIC8vIGNvdW50IGludGVyc2VjdGlvbnNcbiAgICBpZiAoeSA+IHRlc3R5ICE9IHByZXZZID4gdGVzdHkgJiYgdGVzdHggPCAocHJldlggLSB4KSAqICh0ZXN0eSAtIHkpIC8gKHByZXZZIC0geSkgKyB4KSB7XG4gICAgICBpbnRlcnNlY3Rpb25zKys7XG4gICAgfVxuICB9XG5cbiAgLy8gcG9pbnQgaXMgaW4gcG9seWdvbiBpZiBpbnRlcnNlY3Rpb24gY291bnQgaXMgb2RkXG4gIHJldHVybiBpbnRlcnNlY3Rpb25zICYgMTtcbn1cblxuLy8gRXhwcmVzc2lvbiBmdW5jdGlvbiBjb250ZXh0IG9iamVjdFxuY29uc3QgZnVuY3Rpb25Db250ZXh0ID0ge1xuICByYW5kb20oKSB7XG4gICAgcmV0dXJuIHJhbmRvbSgpO1xuICB9LFxuICAvLyBvdmVycmlkZSBkZWZhdWx0XG4gIGN1bXVsYXRpdmVOb3JtYWwsXG4gIGN1bXVsYXRpdmVMb2dOb3JtYWwsXG4gIGN1bXVsYXRpdmVVbmlmb3JtLFxuICBkZW5zaXR5Tm9ybWFsLFxuICBkZW5zaXR5TG9nTm9ybWFsLFxuICBkZW5zaXR5VW5pZm9ybSxcbiAgcXVhbnRpbGVOb3JtYWwsXG4gIHF1YW50aWxlTG9nTm9ybWFsLFxuICBxdWFudGlsZVVuaWZvcm0sXG4gIHNhbXBsZU5vcm1hbCxcbiAgc2FtcGxlTG9nTm9ybWFsLFxuICBzYW1wbGVVbmlmb3JtLFxuICBpc0FycmF5LFxuICBpc0Jvb2xlYW4sXG4gIGlzRGF0ZSxcbiAgaXNEZWZpbmVkKF8pIHtcbiAgICByZXR1cm4gXyAhPT0gdW5kZWZpbmVkO1xuICB9LFxuICBpc051bWJlcixcbiAgaXNPYmplY3QsXG4gIGlzUmVnRXhwLFxuICBpc1N0cmluZyxcbiAgaXNUdXBsZSxcbiAgaXNWYWxpZChfKSB7XG4gICAgcmV0dXJuIF8gIT0gbnVsbCAmJiBfID09PSBfO1xuICB9LFxuICB0b0Jvb2xlYW4sXG4gIHRvRGF0ZShfKSB7XG4gICAgcmV0dXJuIHRvRGF0ZShfKTtcbiAgfSxcbiAgLy8gc3VwcHJlc3MgZXh0cmEgYXJndW1lbnRzXG4gIHRvTnVtYmVyLFxuICB0b1N0cmluZyxcbiAgaW5kZXhvZixcbiAgam9pbixcbiAgbGFzdGluZGV4b2YsXG4gIHJlcGxhY2UsXG4gIHJldmVyc2UsXG4gIHNvcnQsXG4gIHNsaWNlLFxuICBmbHVzaCxcbiAgbGVycCxcbiAgbWVyZ2UsXG4gIHBhZCxcbiAgcGVlayxcbiAgcGx1Y2ssXG4gIHNwYW4sXG4gIGlucmFuZ2UsXG4gIHRydW5jYXRlLFxuICByZ2IsXG4gIGxhYixcbiAgaGNsLFxuICBoc2wsXG4gIGx1bWluYW5jZSxcbiAgY29udHJhc3QsXG4gIHNlcXVlbmNlOiByYW5nZSQxLFxuICBmb3JtYXQsXG4gIHV0Y0Zvcm1hdCxcbiAgdXRjUGFyc2UsXG4gIHV0Y09mZnNldCxcbiAgdXRjU2VxdWVuY2UsXG4gIHRpbWVGb3JtYXQsXG4gIHRpbWVQYXJzZSxcbiAgdGltZU9mZnNldCxcbiAgdGltZVNlcXVlbmNlLFxuICB0aW1lVW5pdFNwZWNpZmllcixcbiAgbW9udGhGb3JtYXQsXG4gIG1vbnRoQWJicmV2Rm9ybWF0LFxuICBkYXlGb3JtYXQsXG4gIGRheUFiYnJldkZvcm1hdCxcbiAgcXVhcnRlcixcbiAgdXRjcXVhcnRlcixcbiAgd2VlayxcbiAgdXRjd2VlayxcbiAgZGF5b2Z5ZWFyLFxuICB1dGNkYXlvZnllYXIsXG4gIHdhcm4sXG4gIGluZm8sXG4gIGRlYnVnLFxuICBleHRlbnQoXykge1xuICAgIHJldHVybiBleHRlbnQoXyk7XG4gIH0sXG4gIC8vIHN1cHByZXNzIGV4dHJhIGFyZ3VtZW50c1xuICBpblNjb3BlLFxuICBpbnRlcnNlY3QsXG4gIGNsYW1wUmFuZ2UsXG4gIHBpbmNoRGlzdGFuY2UsXG4gIHBpbmNoQW5nbGUsXG4gIHNjcmVlbixcbiAgY29udGFpbmVyU2l6ZSxcbiAgd2luZG93U2l6ZSxcbiAgYmFuZHNwYWNlLFxuICBzZXRkYXRhLFxuICBwYXRoU2hhcGUsXG4gIHBhbkxpbmVhcixcbiAgcGFuTG9nLFxuICBwYW5Qb3csXG4gIHBhblN5bWxvZyxcbiAgem9vbUxpbmVhcixcbiAgem9vbUxvZyxcbiAgem9vbVBvdyxcbiAgem9vbVN5bWxvZyxcbiAgZW5jb2RlLFxuICBtb2RpZnksXG4gIGxhc3NvQXBwZW5kLFxuICBsYXNzb1BhdGgsXG4gIGludGVyc2VjdExhc3NvXG59O1xuY29uc3QgZXZlbnRGdW5jdGlvbnMgPSBbJ3ZpZXcnLCAnaXRlbScsICdncm91cCcsICd4eScsICd4JywgJ3knXSxcbiAgLy8gZXZlbnQgZnVuY3Rpb25zXG4gIGV2ZW50UHJlZml4ID0gJ2V2ZW50LnZlZ2EuJyxcbiAgLy8gZXZlbnQgZnVuY3Rpb24gcHJlZml4XG4gIHRoaXNQcmVmaXggPSAndGhpcy4nLFxuICAvLyBmdW5jdGlvbiBjb250ZXh0IHByZWZpeFxuICBhc3RWaXNpdG9ycyA9IHt9OyAvLyBBU1QgdmlzaXRvcnMgZm9yIGRlcGVuZGVuY3kgYW5hbHlzaXNcblxuLy8gZXhwb3J0IGNvZGUgZ2VuZXJhdG9yIHBhcmFtZXRlcnNcbmNvbnN0IGNvZGVnZW5QYXJhbXMgPSB7XG4gIGZvcmJpZGRlbjogWydfJ10sXG4gIGFsbG93ZWQ6IFsnZGF0dW0nLCAnZXZlbnQnLCAnaXRlbSddLFxuICBmaWVsZHZhcjogJ2RhdHVtJyxcbiAgZ2xvYmFsdmFyOiBpZCA9PiBgX1ske3N0cmluZ1ZhbHVlKFNpZ25hbFByZWZpeCArIGlkKX1dYCxcbiAgZnVuY3Rpb25zOiBidWlsZEZ1bmN0aW9ucyxcbiAgY29uc3RhbnRzOiBjb25zdGFudHMsXG4gIHZpc2l0b3JzOiBhc3RWaXNpdG9yc1xufTtcblxuLy8gZXhwb3J0IGNvZGUgZ2VuZXJhdG9yXG5jb25zdCBjb2RlR2VuZXJhdG9yID0gY29kZWdlbkV4cHJlc3Npb24oY29kZWdlblBhcmFtcyk7XG5cbi8vIEJ1aWxkIGV4cHJlc3Npb24gZnVuY3Rpb24gcmVnaXN0cnlcbmZ1bmN0aW9uIGJ1aWxkRnVuY3Rpb25zKGNvZGVnZW4pIHtcbiAgY29uc3QgZm4gPSBmdW5jdGlvbnMoY29kZWdlbik7XG4gIGV2ZW50RnVuY3Rpb25zLmZvckVhY2gobmFtZSA9PiBmbltuYW1lXSA9IGV2ZW50UHJlZml4ICsgbmFtZSk7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBmdW5jdGlvbkNvbnRleHQpIHtcbiAgICBmbltuYW1lXSA9IHRoaXNQcmVmaXggKyBuYW1lO1xuICB9XG4gIGV4dGVuZChmbiwgaW50ZXJuYWxTY2FsZUZ1bmN0aW9ucyhjb2RlZ2VuLCBmdW5jdGlvbkNvbnRleHQsIGFzdFZpc2l0b3JzKSk7XG4gIHJldHVybiBmbjtcbn1cblxuLy8gUmVnaXN0ZXIgYW4gZXhwcmVzc2lvbiBmdW5jdGlvblxuZnVuY3Rpb24gZXhwcmVzc2lvbkZ1bmN0aW9uKG5hbWUsIGZuLCB2aXNpdG9yKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uQ29udGV4dFtuYW1lXTtcbiAgfVxuXG4gIC8vIHJlZ2lzdGVyIHdpdGggdGhlIGZ1bmN0aW9uQ29udGV4dFxuICBmdW5jdGlvbkNvbnRleHRbbmFtZV0gPSBmbjtcblxuICAvLyBpZiB0aGVyZSBpcyBhbiBhc3RWaXNpdG9yIHJlZ2lzdGVyIHRoYXQsIHRvb1xuICBpZiAodmlzaXRvcikgYXN0VmlzaXRvcnNbbmFtZV0gPSB2aXNpdG9yO1xuXG4gIC8vIGlmIHRoZSBjb2RlIGdlbmVyYXRvciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLFxuICAvLyB3ZSBuZWVkIHRvIGFsc28gcmVnaXN0ZXIgdGhlIGZ1bmN0aW9uIHdpdGggaXRcbiAgaWYgKGNvZGVHZW5lcmF0b3IpIGNvZGVHZW5lcmF0b3IuZnVuY3Rpb25zW25hbWVdID0gdGhpc1ByZWZpeCArIG5hbWU7XG4gIHJldHVybiB0aGlzO1xufVxuXG4vLyByZWdpc3RlciBleHByZXNzaW9uIGZ1bmN0aW9ucyB3aXRoIGFzdCB2aXNpdG9yc1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdiYW5kd2lkdGgnLCBiYW5kd2lkdGgsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2NvcHknLCBjb3B5LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdkb21haW4nLCBkb21haW4sIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3JhbmdlJywgcmFuZ2UsIHNjYWxlVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ2ludmVydCcsIGludmVydCwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignc2NhbGUnLCBzY2FsZSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignZ3JhZGllbnQnLCBzY2FsZUdyYWRpZW50LCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9BcmVhJywgZ2VvQXJlYSwgc2NhbGVWaXNpdG9yKTtcbmV4cHJlc3Npb25GdW5jdGlvbignZ2VvQm91bmRzJywgZ2VvQm91bmRzLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9DZW50cm9pZCcsIGdlb0NlbnRyb2lkLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9TaGFwZScsIGdlb1NoYXBlLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdnZW9TY2FsZScsIGdlb1NjYWxlLCBzY2FsZVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdpbmRhdGEnLCBpbmRhdGEsIGluZGF0YVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCdkYXRhJywgZGF0YSwgZGF0YVZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCd0cmVlUGF0aCcsIHRyZWVQYXRoLCBkYXRhVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3RyZWVBbmNlc3RvcnMnLCB0cmVlQW5jZXN0b3JzLCBkYXRhVmlzaXRvcik7XG5cbi8vIHJlZ2lzdGVyIFZlZ2EtTGl0ZSBzZWxlY3Rpb24gZnVuY3Rpb25zXG5leHByZXNzaW9uRnVuY3Rpb24oJ3ZsU2VsZWN0aW9uVGVzdCcsIHNlbGVjdGlvblRlc3QsIHNlbGVjdGlvblZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCd2bFNlbGVjdGlvbklkVGVzdCcsIHNlbGVjdGlvbklkVGVzdCwgc2VsZWN0aW9uVmlzaXRvcik7XG5leHByZXNzaW9uRnVuY3Rpb24oJ3ZsU2VsZWN0aW9uUmVzb2x2ZScsIHNlbGVjdGlvblJlc29sdmUsIHNlbGVjdGlvblZpc2l0b3IpO1xuZXhwcmVzc2lvbkZ1bmN0aW9uKCd2bFNlbGVjdGlvblR1cGxlcycsIHNlbGVjdGlvblR1cGxlcyk7XG5cbmZ1bmN0aW9uIHBhcnNlciAoZXhwciwgc2NvcGUpIHtcbiAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgLy8gcGFyc2UgdGhlIGV4cHJlc3Npb24gdG8gYW4gYWJzdHJhY3Qgc3ludGF4IHRyZWUgKGFzdClcbiAgbGV0IGFzdDtcbiAgdHJ5IHtcbiAgICBleHByID0gaXNTdHJpbmcoZXhwcikgPyBleHByIDogc3RyaW5nVmFsdWUoZXhwcikgKyAnJztcbiAgICBhc3QgPSBwYXJzZUV4cHJlc3Npb24oZXhwcik7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9yKCdFeHByZXNzaW9uIHBhcnNlIGVycm9yOiAnICsgZXhwcik7XG4gIH1cblxuICAvLyBhbmFseXplIGFzdCBmdW5jdGlvbiBjYWxscyBmb3IgZGVwZW5kZW5jaWVzXG4gIGFzdC52aXNpdChub2RlID0+IHtcbiAgICBpZiAobm9kZS50eXBlICE9PSBDYWxsRXhwcmVzc2lvbikgcmV0dXJuO1xuICAgIGNvbnN0IG5hbWUgPSBub2RlLmNhbGxlZS5uYW1lLFxuICAgICAgdmlzaXQgPSBjb2RlZ2VuUGFyYW1zLnZpc2l0b3JzW25hbWVdO1xuICAgIGlmICh2aXNpdCkgdmlzaXQobmFtZSwgbm9kZS5hcmd1bWVudHMsIHNjb3BlLCBwYXJhbXMpO1xuICB9KTtcblxuICAvLyBwZXJmb3JtIGNvZGUgZ2VuZXJhdGlvblxuICBjb25zdCBnZW4gPSBjb2RlR2VuZXJhdG9yKGFzdCk7XG5cbiAgLy8gY29sbGVjdCBzaWduYWwgZGVwZW5kZW5jaWVzXG4gIGdlbi5nbG9iYWxzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3Qgc2lnbmFsTmFtZSA9IFNpZ25hbFByZWZpeCArIG5hbWU7XG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIHNpZ25hbE5hbWUpICYmIHNjb3BlLmdldFNpZ25hbChuYW1lKSkge1xuICAgICAgcGFyYW1zW3NpZ25hbE5hbWVdID0gc2NvcGUuc2lnbmFsUmVmKG5hbWUpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcmV0dXJuIGdlbmVyYXRlZCBleHByZXNzaW9uIGNvZGUgYW5kIGRlcGVuZGVuY2llc1xuICByZXR1cm4ge1xuICAgICRleHByOiBleHRlbmQoe1xuICAgICAgY29kZTogZ2VuLmNvZGVcbiAgICB9LCBzY29wZS5vcHRpb25zLmFzdCA/IHtcbiAgICAgIGFzdFxuICAgIH0gOiBudWxsKSxcbiAgICAkZmllbGRzOiBnZW4uZmllbGRzLFxuICAgICRwYXJhbXM6IHBhcmFtc1xuICB9O1xufVxuXG5leHBvcnQgeyBEYXRhUHJlZml4LCBJbmRleFByZWZpeCwgU2NhbGVQcmVmaXgsIFNpZ25hbFByZWZpeCwgYmFuZHNwYWNlLCBiYW5kd2lkdGgsIGNvZGVHZW5lcmF0b3IsIGNvZGVnZW5QYXJhbXMsIGNvbnRhaW5lclNpemUsIGNvbnRyYXN0LCBjb3B5LCBkYXRhLCBkYXRhVmlzaXRvciwgZGF5QWJicmV2Rm9ybWF0LCBkYXlGb3JtYXQsIGRlYnVnLCBkb21haW4sIGVuY29kZSwgZXhwcmVzc2lvbkZ1bmN0aW9uLCBmb3JtYXQsIGZ1bmN0aW9uQ29udGV4dCwgZ2VvQXJlYSwgZ2VvQm91bmRzLCBnZW9DZW50cm9pZCwgZ2VvU2NhbGUsIGdlb1NoYXBlLCBpblNjb3BlLCBpbmRhdGEsIGluZGF0YVZpc2l0b3IsIGluZGV4b2YsIGluZm8sIGludmVydCwgam9pbiwgbGFzdGluZGV4b2YsIGx1bWluYW5jZSwgbWVyZ2UsIG1vZGlmeSwgbW9udGhBYmJyZXZGb3JtYXQsIG1vbnRoRm9ybWF0LCBwYXJzZXIgYXMgcGFyc2VFeHByZXNzaW9uLCBwYXRoU2hhcGUsIHBpbmNoQW5nbGUsIHBpbmNoRGlzdGFuY2UsIHBsdWNrLCByYW5nZSwgcmVwbGFjZSwgcmV2ZXJzZSwgc2NhbGUsIHNjYWxlR3JhZGllbnQsIHNjYWxlVmlzaXRvciwgc2NyZWVuLCBzZXRkYXRhLCBzbGljZSwgc29ydCwgdGltZUZvcm1hdCwgdGltZVBhcnNlLCB0cmVlQW5jZXN0b3JzLCB0cmVlUGF0aCwgdXRjRm9ybWF0LCB1dGNQYXJzZSwgd2Fybiwgd2luZG93U2l6ZSB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtLCByZWRlcml2ZSwgaW5nZXN0LCByZXBsYWNlIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBlcnJvciwgZXh0ZW50LCBpbmhlcml0cywgaWRlbnRpdHksIGlzQXJyYXksIGlzRnVuY3Rpb24sIGlzTnVtYmVyLCBhcnJheSwgY29uc3RhbnQsIG9uZSwgYWNjZXNzb3JOYW1lLCBhY2Nlc3NvckZpZWxkcywgZmllbGQsIGV4dGVuZCwgdG9TZXQsIHplcm8gfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgdGlja1N0ZXAsIHJhbmdlLCBtYXgsIHN1bSB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCB7IGJhbmR3aWR0aE5SRCB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyBnZXRQcm9qZWN0aW9uUGF0aCwgcHJvamVjdGlvblByb3BlcnRpZXMsIHByb2plY3Rpb24gfSBmcm9tICd2ZWdhLXByb2plY3Rpb24nO1xuaW1wb3J0IHsgZ2VvR3JhdGljdWxlIH0gZnJvbSAnZDMtZ2VvJztcbmltcG9ydCB7IHJnYiB9IGZyb20gJ2QzLWNvbG9yJztcbmltcG9ydCB7IGNhbnZhcyB9IGZyb20gJ3ZlZ2EtY2FudmFzJztcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5jb25zdCBjYXNlcyA9IFtbXSwgW1tbMS4wLCAxLjVdLCBbMC41LCAxLjBdXV0sIFtbWzEuNSwgMS4wXSwgWzEuMCwgMS41XV1dLCBbW1sxLjUsIDEuMF0sIFswLjUsIDEuMF1dXSwgW1tbMS4wLCAwLjVdLCBbMS41LCAxLjBdXV0sIFtbWzEuMCwgMS41XSwgWzAuNSwgMS4wXV0sIFtbMS4wLCAwLjVdLCBbMS41LCAxLjBdXV0sIFtbWzEuMCwgMC41XSwgWzEuMCwgMS41XV1dLCBbW1sxLjAsIDAuNV0sIFswLjUsIDEuMF1dXSwgW1tbMC41LCAxLjBdLCBbMS4wLCAwLjVdXV0sIFtbWzEuMCwgMS41XSwgWzEuMCwgMC41XV1dLCBbW1swLjUsIDEuMF0sIFsxLjAsIDAuNV1dLCBbWzEuNSwgMS4wXSwgWzEuMCwgMS41XV1dLCBbW1sxLjUsIDEuMF0sIFsxLjAsIDAuNV1dXSwgW1tbMC41LCAxLjBdLCBbMS41LCAxLjBdXV0sIFtbWzEuMCwgMS41XSwgWzEuNSwgMS4wXV1dLCBbW1swLjUsIDEuMF0sIFsxLjAsIDEuNV1dXSwgW11dO1xuXG4vLyBJbXBsZW1lbnRhdGlvbiBhZGFwdGVkIGZyb20gZDMvZDMtY29udG91ci4gVGhhbmtzIVxuZnVuY3Rpb24gY29udG91cnMgKCkge1xuICB2YXIgZHggPSAxLFxuICAgIGR5ID0gMSxcbiAgICBzbW9vdGggPSBzbW9vdGhMaW5lYXI7XG4gIGZ1bmN0aW9uIGNvbnRvdXJzKHZhbHVlcywgdHopIHtcbiAgICByZXR1cm4gdHoubWFwKHZhbHVlID0+IGNvbnRvdXIodmFsdWVzLCB2YWx1ZSkpO1xuICB9XG5cbiAgLy8gQWNjdW11bGF0ZSwgc21vb3RoIGNvbnRvdXIgcmluZ3MsIGFzc2lnbiBob2xlcyB0byBleHRlcmlvciByaW5ncy5cbiAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL21ib3N0b2NrL3NoYXBlZmlsZS9ibG9iL3YwLjYuMi9zaHAvcG9seWdvbi5qc1xuICBmdW5jdGlvbiBjb250b3VyKHZhbHVlcywgdmFsdWUpIHtcbiAgICB2YXIgcG9seWdvbnMgPSBbXSxcbiAgICAgIGhvbGVzID0gW107XG4gICAgaXNvcmluZ3ModmFsdWVzLCB2YWx1ZSwgcmluZyA9PiB7XG4gICAgICBzbW9vdGgocmluZywgdmFsdWVzLCB2YWx1ZSk7XG4gICAgICBpZiAoYXJlYShyaW5nKSA+IDApIHBvbHlnb25zLnB1c2goW3JpbmddKTtlbHNlIGhvbGVzLnB1c2gocmluZyk7XG4gICAgfSk7XG4gICAgaG9sZXMuZm9yRWFjaChob2xlID0+IHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBuID0gcG9seWdvbnMubGVuZ3RoLCBwb2x5Z29uOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmIChjb250YWlucygocG9seWdvbiA9IHBvbHlnb25zW2ldKVswXSwgaG9sZSkgIT09IC0xKSB7XG4gICAgICAgICAgcG9seWdvbi5wdXNoKGhvbGUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGNvb3JkaW5hdGVzOiBwb2x5Z29uc1xuICAgIH07XG4gIH1cblxuICAvLyBNYXJjaGluZyBzcXVhcmVzIHdpdGggaXNvbGluZXMgc3RpdGNoZWQgaW50byByaW5ncy5cbiAgLy8gQmFzZWQgb24gaHR0cHM6Ly9naXRodWIuY29tL3RvcG9qc29uL3RvcG9qc29uLWNsaWVudC9ibG9iL3YzLjAuMC9zcmMvc3RpdGNoLmpzXG4gIGZ1bmN0aW9uIGlzb3JpbmdzKHZhbHVlcywgdmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZyYWdtZW50QnlTdGFydCA9IFtdLFxuICAgICAgZnJhZ21lbnRCeUVuZCA9IFtdLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICB0MCxcbiAgICAgIHQxLFxuICAgICAgdDIsXG4gICAgICB0MztcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgdGhlIGZpcnN0IHJvdyAoeSA9IC0xLCB0MiA9IHQzID0gMCkuXG4gICAgeCA9IHkgPSAtMTtcbiAgICB0MSA9IHZhbHVlc1swXSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MSA8PCAxXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgdDAgPSB0MSwgdDEgPSB2YWx1ZXNbeCArIDFdID49IHZhbHVlO1xuICAgICAgY2FzZXNbdDAgfCB0MSA8PCAxXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfVxuICAgIGNhc2VzW3QxIDw8IDBdLmZvckVhY2goc3RpdGNoKTtcblxuICAgIC8vIEdlbmVyYWwgY2FzZSBmb3IgdGhlIGludGVybWVkaWF0ZSByb3dzLlxuICAgIHdoaWxlICgrK3kgPCBkeSAtIDEpIHtcbiAgICAgIHggPSAtMTtcbiAgICAgIHQxID0gdmFsdWVzW3kgKiBkeCArIGR4XSA+PSB2YWx1ZTtcbiAgICAgIHQyID0gdmFsdWVzW3kgKiBkeF0gPj0gdmFsdWU7XG4gICAgICBjYXNlc1t0MSA8PCAxIHwgdDIgPDwgMl0uZm9yRWFjaChzdGl0Y2gpO1xuICAgICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgICB0MCA9IHQxLCB0MSA9IHZhbHVlc1t5ICogZHggKyBkeCArIHggKyAxXSA+PSB2YWx1ZTtcbiAgICAgICAgdDMgPSB0MiwgdDIgPSB2YWx1ZXNbeSAqIGR4ICsgeCArIDFdID49IHZhbHVlO1xuICAgICAgICBjYXNlc1t0MCB8IHQxIDw8IDEgfCB0MiA8PCAyIHwgdDMgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgICAgfVxuICAgICAgY2FzZXNbdDEgfCB0MiA8PCAzXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciB0aGUgbGFzdCByb3cgKHkgPSBkeSAtIDEsIHQwID0gdDEgPSAwKS5cbiAgICB4ID0gLTE7XG4gICAgdDIgPSB2YWx1ZXNbeSAqIGR4XSA+PSB2YWx1ZTtcbiAgICBjYXNlc1t0MiA8PCAyXS5mb3JFYWNoKHN0aXRjaCk7XG4gICAgd2hpbGUgKCsreCA8IGR4IC0gMSkge1xuICAgICAgdDMgPSB0MiwgdDIgPSB2YWx1ZXNbeSAqIGR4ICsgeCArIDFdID49IHZhbHVlO1xuICAgICAgY2FzZXNbdDIgPDwgMiB8IHQzIDw8IDNdLmZvckVhY2goc3RpdGNoKTtcbiAgICB9XG4gICAgY2FzZXNbdDIgPDwgM10uZm9yRWFjaChzdGl0Y2gpO1xuICAgIGZ1bmN0aW9uIHN0aXRjaChsaW5lKSB7XG4gICAgICB2YXIgc3RhcnQgPSBbbGluZVswXVswXSArIHgsIGxpbmVbMF1bMV0gKyB5XSxcbiAgICAgICAgZW5kID0gW2xpbmVbMV1bMF0gKyB4LCBsaW5lWzFdWzFdICsgeV0sXG4gICAgICAgIHN0YXJ0SW5kZXggPSBpbmRleChzdGFydCksXG4gICAgICAgIGVuZEluZGV4ID0gaW5kZXgoZW5kKSxcbiAgICAgICAgZixcbiAgICAgICAgZztcbiAgICAgIGlmIChmID0gZnJhZ21lbnRCeUVuZFtzdGFydEluZGV4XSkge1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlTdGFydFtlbmRJbmRleF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgICAgZGVsZXRlIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XTtcbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xuICAgICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGYucmluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtmLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZy5lbmRdID0ge1xuICAgICAgICAgICAgICBzdGFydDogZi5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBnLmVuZCxcbiAgICAgICAgICAgICAgcmluZzogZi5yaW5nLmNvbmNhdChnLnJpbmcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeUVuZFtmLmVuZF07XG4gICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICBmcmFnbWVudEJ5RW5kW2YuZW5kID0gZW5kSW5kZXhdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmID0gZnJhZ21lbnRCeVN0YXJ0W2VuZEluZGV4XSkge1xuICAgICAgICBpZiAoZyA9IGZyYWdtZW50QnlFbmRbc3RhcnRJbmRleF0pIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICAgIGRlbGV0ZSBmcmFnbWVudEJ5RW5kW2cuZW5kXTtcbiAgICAgICAgICBpZiAoZiA9PT0gZykge1xuICAgICAgICAgICAgZi5yaW5nLnB1c2goZW5kKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGYucmluZyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZyYWdtZW50QnlTdGFydFtnLnN0YXJ0XSA9IGZyYWdtZW50QnlFbmRbZi5lbmRdID0ge1xuICAgICAgICAgICAgICBzdGFydDogZy5zdGFydCxcbiAgICAgICAgICAgICAgZW5kOiBmLmVuZCxcbiAgICAgICAgICAgICAgcmluZzogZy5yaW5nLmNvbmNhdChmLnJpbmcpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgZnJhZ21lbnRCeVN0YXJ0W2Yuc3RhcnRdO1xuICAgICAgICAgIGYucmluZy51bnNoaWZ0KHN0YXJ0KTtcbiAgICAgICAgICBmcmFnbWVudEJ5U3RhcnRbZi5zdGFydCA9IHN0YXJ0SW5kZXhdID0gZjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZnJhZ21lbnRCeVN0YXJ0W3N0YXJ0SW5kZXhdID0gZnJhZ21lbnRCeUVuZFtlbmRJbmRleF0gPSB7XG4gICAgICAgICAgc3RhcnQ6IHN0YXJ0SW5kZXgsXG4gICAgICAgICAgZW5kOiBlbmRJbmRleCxcbiAgICAgICAgICByaW5nOiBbc3RhcnQsIGVuZF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW5kZXgocG9pbnQpIHtcbiAgICByZXR1cm4gcG9pbnRbMF0gKiAyICsgcG9pbnRbMV0gKiAoZHggKyAxKSAqIDQ7XG4gIH1cbiAgZnVuY3Rpb24gc21vb3RoTGluZWFyKHJpbmcsIHZhbHVlcywgdmFsdWUpIHtcbiAgICByaW5nLmZvckVhY2gocG9pbnQgPT4ge1xuICAgICAgdmFyIHggPSBwb2ludFswXSxcbiAgICAgICAgeSA9IHBvaW50WzFdLFxuICAgICAgICB4dCA9IHggfCAwLFxuICAgICAgICB5dCA9IHkgfCAwLFxuICAgICAgICB2MCxcbiAgICAgICAgdjEgPSB2YWx1ZXNbeXQgKiBkeCArIHh0XTtcbiAgICAgIGlmICh4ID4gMCAmJiB4IDwgZHggJiYgeHQgPT09IHgpIHtcbiAgICAgICAgdjAgPSB2YWx1ZXNbeXQgKiBkeCArIHh0IC0gMV07XG4gICAgICAgIHBvaW50WzBdID0geCArICh2YWx1ZSAtIHYwKSAvICh2MSAtIHYwKSAtIDAuNTtcbiAgICAgIH1cbiAgICAgIGlmICh5ID4gMCAmJiB5IDwgZHkgJiYgeXQgPT09IHkpIHtcbiAgICAgICAgdjAgPSB2YWx1ZXNbKHl0IC0gMSkgKiBkeCArIHh0XTtcbiAgICAgICAgcG9pbnRbMV0gPSB5ICsgKHZhbHVlIC0gdjApIC8gKHYxIC0gdjApIC0gMC41O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNvbnRvdXJzLmNvbnRvdXIgPSBjb250b3VyO1xuICBjb250b3Vycy5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICB2YXIgXzAgPSBNYXRoLmZsb29yKF9bMF0pLFxuICAgICAgXzEgPSBNYXRoLmZsb29yKF9bMV0pO1xuICAgIGlmICghKF8wID49IDAgJiYgXzEgPj0gMCkpIGVycm9yKCdpbnZhbGlkIHNpemUnKTtcbiAgICByZXR1cm4gZHggPSBfMCwgZHkgPSBfMSwgY29udG91cnM7XG4gIH07XG4gIGNvbnRvdXJzLnNtb290aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoc21vb3RoID0gXyA/IHNtb290aExpbmVhciA6IG5vb3AsIGNvbnRvdXJzKSA6IHNtb290aCA9PT0gc21vb3RoTGluZWFyO1xuICB9O1xuICByZXR1cm4gY29udG91cnM7XG59XG5mdW5jdGlvbiBhcmVhKHJpbmcpIHtcbiAgdmFyIGkgPSAwLFxuICAgIG4gPSByaW5nLmxlbmd0aCxcbiAgICBhcmVhID0gcmluZ1tuIC0gMV1bMV0gKiByaW5nWzBdWzBdIC0gcmluZ1tuIC0gMV1bMF0gKiByaW5nWzBdWzFdO1xuICB3aGlsZSAoKytpIDwgbikgYXJlYSArPSByaW5nW2kgLSAxXVsxXSAqIHJpbmdbaV1bMF0gLSByaW5nW2kgLSAxXVswXSAqIHJpbmdbaV1bMV07XG4gIHJldHVybiBhcmVhO1xufVxuZnVuY3Rpb24gY29udGFpbnMocmluZywgaG9sZSkge1xuICB2YXIgaSA9IC0xLFxuICAgIG4gPSBob2xlLmxlbmd0aCxcbiAgICBjO1xuICB3aGlsZSAoKytpIDwgbikgaWYgKGMgPSByaW5nQ29udGFpbnMocmluZywgaG9sZVtpXSkpIHJldHVybiBjO1xuICByZXR1cm4gMDtcbn1cbmZ1bmN0aW9uIHJpbmdDb250YWlucyhyaW5nLCBwb2ludCkge1xuICB2YXIgeCA9IHBvaW50WzBdLFxuICAgIHkgPSBwb2ludFsxXSxcbiAgICBjb250YWlucyA9IC0xO1xuICBmb3IgKHZhciBpID0gMCwgbiA9IHJpbmcubGVuZ3RoLCBqID0gbiAtIDE7IGkgPCBuOyBqID0gaSsrKSB7XG4gICAgdmFyIHBpID0gcmluZ1tpXSxcbiAgICAgIHhpID0gcGlbMF0sXG4gICAgICB5aSA9IHBpWzFdLFxuICAgICAgcGogPSByaW5nW2pdLFxuICAgICAgeGogPSBwalswXSxcbiAgICAgIHlqID0gcGpbMV07XG4gICAgaWYgKHNlZ21lbnRDb250YWlucyhwaSwgcGosIHBvaW50KSkgcmV0dXJuIDA7XG4gICAgaWYgKHlpID4geSAhPT0geWogPiB5ICYmIHggPCAoeGogLSB4aSkgKiAoeSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKSBjb250YWlucyA9IC1jb250YWlucztcbiAgfVxuICByZXR1cm4gY29udGFpbnM7XG59XG5mdW5jdGlvbiBzZWdtZW50Q29udGFpbnMoYSwgYiwgYykge1xuICB2YXIgaTtcbiAgcmV0dXJuIGNvbGxpbmVhcihhLCBiLCBjKSAmJiB3aXRoaW4oYVtpID0gKyhhWzBdID09PSBiWzBdKV0sIGNbaV0sIGJbaV0pO1xufVxuZnVuY3Rpb24gY29sbGluZWFyKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChiWzBdIC0gYVswXSkgKiAoY1sxXSAtIGFbMV0pID09PSAoY1swXSAtIGFbMF0pICogKGJbMV0gLSBhWzFdKTtcbn1cbmZ1bmN0aW9uIHdpdGhpbihwLCBxLCByKSB7XG4gIHJldHVybiBwIDw9IHEgJiYgcSA8PSByIHx8IHIgPD0gcSAmJiBxIDw9IHA7XG59XG5cbmZ1bmN0aW9uIHF1YW50aXplIChrLCBuaWNlLCB6ZXJvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgdmFyIGV4ID0gZXh0ZW50KHZhbHVlcyksXG4gICAgICBzdGFydCA9IHplcm8gPyBNYXRoLm1pbihleFswXSwgMCkgOiBleFswXSxcbiAgICAgIHN0b3AgPSBleFsxXSxcbiAgICAgIHNwYW4gPSBzdG9wIC0gc3RhcnQsXG4gICAgICBzdGVwID0gbmljZSA/IHRpY2tTdGVwKHN0YXJ0LCBzdG9wLCBrKSA6IHNwYW4gLyAoayArIDEpO1xuICAgIHJldHVybiByYW5nZShzdGFydCArIHN0ZXAsIHN0b3AsIHN0ZXApO1xuICB9O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGlzb2NvbnRvdXJzIChsZXZlbCBzZXRzKSBiYXNlZCBvbiBpbnB1dCByYXN0ZXIgZ3JpZCBkYXRhLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggcmFzdGVyIGdyaWRcbiAqICAgZGF0YS4gSWYgdW5zcGVjaWZpZWQsIHRoZSB0dXBsZSBpdHNlbGYgaXMgaW50ZXJwcmV0ZWQgYXMgYSByYXN0ZXIgZ3JpZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy50aHJlc2hvbGRzXSAtIENvbnRvdXIgdGhyZXNob2xkIGFycmF5LiBJZlxuICogICBzcGVjaWZpZWQsIHRoZSBsZXZlbHMsIG5pY2UsIHJlc29sdmUsIGFuZCB6ZXJvIHBhcmFtZXRlcnMgYXJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5sZXZlbHNdIC0gVGhlIGRlc2lyZWQgbnVtYmVyIG9mIGNvbnRvdXIgbGV2ZWxzLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLm5pY2VdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlIGNvbnRvdXJcbiAqICAgdGhyZXNob2xkIHZhbHVlcyBzaG91bGQgYmUgYXV0b21hdGljYWxseSBhbGlnbmVkIHRvIFwibmljZVwiXG4gKiAgIGh1bWFuLWZyaWVuZGx5IHZhbHVlcy4gU2V0dGluZyB0aGlzIGZsYWcgbWF5IGNhdXNlIHRoZSBudW1iZXIgb2ZcbiAqICAgdGhyZXNob2xkcyB0byBkZXZpYXRlIGZyb20gdGhlIHNwZWNpZmllZCBsZXZlbHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5yZXNvbHZlXSAtIFRoZSBtZXRob2QgZm9yIHJlc29sdmluZyB0aHJlc2hvbGRzXG4gKiAgIGFjcm9zcyBtdWx0aXBsZSBpbnB1dCBncmlkcy4gSWYgJ2luZGVwZW5kZW50JyAodGhlIGRlZmF1bHQpLCB0aHJlc2hvbGRcbiAqICAgY2FsY3VsYXRpb24gd2lsbCBiZSBwZXJmb3JtZWQgc2VwYXJhdGVseSBmb3IgZWFjaCBncmlkLiBJZiAnc2hhcmVkJywgYVxuICogICBzaW5nbGUgc2V0IG9mIHRocmVzaG9sZCB2YWx1ZXMgd2lsbCBiZSB1c2VkIGZvciBhbGwgaW5wdXQgZ3JpZHMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuemVyb10gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY29udG91clxuICogICB0aHJlc2hvbGQgdmFsdWVzIHNob3VsZCBpbmNsdWRlIHplcm8uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoXSAtIEJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBjb250b3VyXG4gKiAgIHBvbHlnb25zIHNob3VsZCBiZSBzbW9vdGhlZCB1c2luZyBsaW5lYXIgaW50ZXJwb2xhdGlvbi4gVGhlIGRlZmF1bHQgaXNcbiAqICAgdHJ1ZS4gVGhlIHBhcmFtZXRlciBpcyBpZ25vcmVkIHdoZW4gdXNpbmcgZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNjYWxlXSAtIE9wdGlvbmFsIG51bWVyaWNhbCB2YWx1ZSBieSB3aGljaCB0b1xuICogICBzY2FsZSB0aGUgb3V0cHV0IGlzb2NvbnRvdXIgY29vcmRpbmF0ZXMuIFRoaXMgcGFyYW1ldGVyIGNhbiBiZSB1c2VmdWxcbiAqICAgdG8gc2NhbGUgdGhlIGNvbnRvdXJzIHRvIG1hdGNoIGEgZGVzaXJlZCBvdXRwdXQgcmVzb2x1dGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmFzPSdjb250b3VyJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgaXNvY29udG91ciBkYXRhIChkZWZhdWx0ICdjb250b3VyJykuXG4gKi9cbmZ1bmN0aW9uIElzb2NvbnRvdXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Jc29jb250b3VyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0lzb2NvbnRvdXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAndGhyZXNob2xkcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdsZXZlbHMnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ25pY2UnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc29sdmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3NoYXJlZCcsICdpbmRlcGVuZGVudCddLFxuICAgICdkZWZhdWx0JzogJ2luZGVwZW5kZW50J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnemVybycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzbW9vdGgnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2NhbGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0cmFuc2xhdGUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdjb250b3VyJ1xuICB9XVxufTtcbmluaGVyaXRzKElzb2NvbnRvdXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhcHVsc2UuY2hhbmdlZCgpICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICAgIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgfVxuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyksXG4gICAgICBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgIGZpZWxkID0gXy5maWVsZCB8fCBpZGVudGl0eSxcbiAgICAgIGNvbnRvdXIgPSBjb250b3VycygpLnNtb290aChfLnNtb290aCAhPT0gZmFsc2UpLFxuICAgICAgdHogPSBfLnRocmVzaG9sZHMgfHwgbGV2ZWxzKHNvdXJjZSwgZmllbGQsIF8pLFxuICAgICAgYXMgPSBfLmFzID09PSBudWxsID8gbnVsbCA6IF8uYXMgfHwgJ2NvbnRvdXInLFxuICAgICAgdmFsdWVzID0gW107XG4gICAgc291cmNlLmZvckVhY2godCA9PiB7XG4gICAgICBjb25zdCBncmlkID0gZmllbGQodCk7XG5cbiAgICAgIC8vIGdlbmVyYXRlIGNvbnRvdXIgcGF0aHMgaW4gR2VvSlNPTiBmb3JtYXRcbiAgICAgIGNvbnN0IHBhdGhzID0gY29udG91ci5zaXplKFtncmlkLndpZHRoLCBncmlkLmhlaWdodF0pKGdyaWQudmFsdWVzLCBpc0FycmF5KHR6KSA/IHR6IDogdHooZ3JpZC52YWx1ZXMpKTtcblxuICAgICAgLy8gYWRqdXN0IGNvbnRvdXIgcGF0aCBjb29yZGluYXRlcyBhcyBuZWVkZWRcbiAgICAgIHRyYW5zZm9ybVBhdGhzKHBhdGhzLCBncmlkLCB0LCBfKTtcblxuICAgICAgLy8gaW5nZXN0OyBjb3B5IHNvdXJjZSBkYXRhIHByb3BlcnRpZXMgdG8gb3V0cHV0XG4gICAgICBwYXRocy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICB2YWx1ZXMucHVzaChyZWRlcml2ZSh0LCBpbmdlc3QoYXMgIT0gbnVsbCA/IHtcbiAgICAgICAgICBbYXNdOiBwXG4gICAgICAgIH0gOiBwKSkpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZCA9IHZhbHVlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG59KTtcbmZ1bmN0aW9uIGxldmVscyh2YWx1ZXMsIGYsIF8pIHtcbiAgY29uc3QgcSA9IHF1YW50aXplKF8ubGV2ZWxzIHx8IDEwLCBfLm5pY2UsIF8uemVybyAhPT0gZmFsc2UpO1xuICByZXR1cm4gXy5yZXNvbHZlICE9PSAnc2hhcmVkJyA/IHEgOiBxKHZhbHVlcy5tYXAodCA9PiBtYXgoZih0KS52YWx1ZXMpKSk7XG59XG5mdW5jdGlvbiB0cmFuc2Zvcm1QYXRocyhwYXRocywgZ3JpZCwgZGF0dW0sIF8pIHtcbiAgbGV0IHMgPSBfLnNjYWxlIHx8IGdyaWQuc2NhbGUsXG4gICAgdCA9IF8udHJhbnNsYXRlIHx8IGdyaWQudHJhbnNsYXRlO1xuICBpZiAoaXNGdW5jdGlvbihzKSkgcyA9IHMoZGF0dW0sIF8pO1xuICBpZiAoaXNGdW5jdGlvbih0KSkgdCA9IHQoZGF0dW0sIF8pO1xuICBpZiAoKHMgPT09IDEgfHwgcyA9PSBudWxsKSAmJiAhdCkgcmV0dXJuO1xuICBjb25zdCBzeCA9IChpc051bWJlcihzKSA/IHMgOiBzWzBdKSB8fCAxLFxuICAgIHN5ID0gKGlzTnVtYmVyKHMpID8gcyA6IHNbMV0pIHx8IDEsXG4gICAgdHggPSB0ICYmIHRbMF0gfHwgMCxcbiAgICB0eSA9IHQgJiYgdFsxXSB8fCAwO1xuICBwYXRocy5mb3JFYWNoKHRyYW5zZm9ybShncmlkLCBzeCwgc3ksIHR4LCB0eSkpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtKGdyaWQsIHN4LCBzeSwgdHgsIHR5KSB7XG4gIGNvbnN0IHgxID0gZ3JpZC54MSB8fCAwLFxuICAgIHkxID0gZ3JpZC55MSB8fCAwLFxuICAgIGZsaXAgPSBzeCAqIHN5IDwgMDtcbiAgZnVuY3Rpb24gdHJhbnNmb3JtUG9seWdvbihjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUmluZyk7XG4gIH1cbiAgZnVuY3Rpb24gdHJhbnNmb3JtUmluZyhjb29yZGluYXRlcykge1xuICAgIGlmIChmbGlwKSBjb29yZGluYXRlcy5yZXZlcnNlKCk7IC8vIG1haW50YWluIHdpbmRpbmcgb3JkZXJcbiAgICBjb29yZGluYXRlcy5mb3JFYWNoKHRyYW5zZm9ybVBvaW50KTtcbiAgfVxuICBmdW5jdGlvbiB0cmFuc2Zvcm1Qb2ludChjb29yZGluYXRlcykge1xuICAgIGNvb3JkaW5hdGVzWzBdID0gKGNvb3JkaW5hdGVzWzBdIC0geDEpICogc3ggKyB0eDtcbiAgICBjb29yZGluYXRlc1sxXSA9IChjb29yZGluYXRlc1sxXSAtIHkxKSAqIHN5ICsgdHk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIChnZW9tZXRyeSkge1xuICAgIGdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2godHJhbnNmb3JtUG9seWdvbik7XG4gICAgcmV0dXJuIGdlb21ldHJ5O1xuICB9O1xufVxuXG5mdW5jdGlvbiByYWRpdXMoYncsIGRhdGEsIGYpIHtcbiAgY29uc3QgdiA9IGJ3ID49IDAgPyBidyA6IGJhbmR3aWR0aE5SRChkYXRhLCBmKTtcbiAgcmV0dXJuIE1hdGgucm91bmQoKE1hdGguc3FydCg0ICogdiAqIHYgKyAxKSAtIDEpIC8gMik7XG59XG5mdW5jdGlvbiBudW1iZXIoXykge1xuICByZXR1cm4gaXNGdW5jdGlvbihfKSA/IF8gOiBjb25zdGFudCgrXyk7XG59XG5cbi8vIEltcGxlbWVudGF0aW9uIGFkYXB0ZWQgZnJvbSBkMy9kMy1jb250b3VyLiBUaGFua3MhXG5mdW5jdGlvbiBkZW5zaXR5MkQgKCkge1xuICB2YXIgeCA9IGQgPT4gZFswXSxcbiAgICB5ID0gZCA9PiBkWzFdLFxuICAgIHdlaWdodCA9IG9uZSxcbiAgICBiYW5kd2lkdGggPSBbLTEsIC0xXSxcbiAgICBkeCA9IDk2MCxcbiAgICBkeSA9IDUwMCxcbiAgICBrID0gMjsgLy8gbG9nMihjZWxsU2l6ZSlcblxuICBmdW5jdGlvbiBkZW5zaXR5KGRhdGEsIGNvdW50cykge1xuICAgIGNvbnN0IHJ4ID0gcmFkaXVzKGJhbmR3aWR0aFswXSwgZGF0YSwgeCkgPj4gayxcbiAgICAgIC8vIGJsdXIgeC1yYWRpdXNcbiAgICAgIHJ5ID0gcmFkaXVzKGJhbmR3aWR0aFsxXSwgZGF0YSwgeSkgPj4gayxcbiAgICAgIC8vIGJsdXIgeS1yYWRpdXNcbiAgICAgIG94ID0gcnggPyByeCArIDIgOiAwLFxuICAgICAgLy8geC1vZmZzZXQgcGFkZGluZyBmb3IgYmx1clxuICAgICAgb3kgPSByeSA/IHJ5ICsgMiA6IDAsXG4gICAgICAvLyB5LW9mZnNldCBwYWRkaW5nIGZvciBibHVyXG4gICAgICBuID0gMiAqIG94ICsgKGR4ID4+IGspLFxuICAgICAgLy8gZ3JpZCB3aWR0aFxuICAgICAgbSA9IDIgKiBveSArIChkeSA+PiBrKSxcbiAgICAgIC8vIGdyaWQgaGVpZ2h0XG4gICAgICB2YWx1ZXMwID0gbmV3IEZsb2F0MzJBcnJheShuICogbSksXG4gICAgICB2YWx1ZXMxID0gbmV3IEZsb2F0MzJBcnJheShuICogbSk7XG4gICAgbGV0IHZhbHVlcyA9IHZhbHVlczA7XG4gICAgZGF0YS5mb3JFYWNoKGQgPT4ge1xuICAgICAgY29uc3QgeGkgPSBveCArICgreChkKSA+PiBrKSxcbiAgICAgICAgeWkgPSBveSArICgreShkKSA+PiBrKTtcbiAgICAgIGlmICh4aSA+PSAwICYmIHhpIDwgbiAmJiB5aSA+PSAwICYmIHlpIDwgbSkge1xuICAgICAgICB2YWx1ZXMwW3hpICsgeWkgKiBuXSArPSArd2VpZ2h0KGQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmIChyeCA+IDAgJiYgcnkgPiAwKSB7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgICBibHVyWChuLCBtLCB2YWx1ZXMwLCB2YWx1ZXMxLCByeCk7XG4gICAgICBibHVyWShuLCBtLCB2YWx1ZXMxLCB2YWx1ZXMwLCByeSk7XG4gICAgfSBlbHNlIGlmIChyeCA+IDApIHtcbiAgICAgIGJsdXJYKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ4KTtcbiAgICAgIGJsdXJYKG4sIG0sIHZhbHVlczEsIHZhbHVlczAsIHJ4KTtcbiAgICAgIGJsdXJYKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ4KTtcbiAgICAgIHZhbHVlcyA9IHZhbHVlczE7XG4gICAgfSBlbHNlIGlmIChyeSA+IDApIHtcbiAgICAgIGJsdXJZKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ5KTtcbiAgICAgIGJsdXJZKG4sIG0sIHZhbHVlczEsIHZhbHVlczAsIHJ5KTtcbiAgICAgIGJsdXJZKG4sIG0sIHZhbHVlczAsIHZhbHVlczEsIHJ5KTtcbiAgICAgIHZhbHVlcyA9IHZhbHVlczE7XG4gICAgfVxuXG4gICAgLy8gc2NhbGUgZGVuc2l0eSBlc3RpbWF0ZXNcbiAgICAvLyBkZW5zaXR5IGluIHBvaW50cyBwZXIgc3F1YXJlIHBpeGVsIG9yIHByb2JhYmlsaXR5IGRlbnNpdHlcbiAgICBjb25zdCBzID0gY291bnRzID8gTWF0aC5wb3coMiwgLTIgKiBrKSA6IDEgLyBzdW0odmFsdWVzKTtcbiAgICBmb3IgKGxldCBpID0gMCwgc3ogPSBuICogbTsgaSA8IHN6OyArK2kpIHZhbHVlc1tpXSAqPSBzO1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZXM6IHZhbHVlcyxcbiAgICAgIHNjYWxlOiAxIDw8IGssXG4gICAgICB3aWR0aDogbixcbiAgICAgIGhlaWdodDogbSxcbiAgICAgIHgxOiBveCxcbiAgICAgIHkxOiBveSxcbiAgICAgIHgyOiBveCArIChkeCA+PiBrKSxcbiAgICAgIHkyOiBveSArIChkeSA+PiBrKVxuICAgIH07XG4gIH1cbiAgZGVuc2l0eS54ID0gZnVuY3Rpb24gKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/ICh4ID0gbnVtYmVyKF8pLCBkZW5zaXR5KSA6IHg7XG4gIH07XG4gIGRlbnNpdHkueSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAoeSA9IG51bWJlcihfKSwgZGVuc2l0eSkgOiB5O1xuICB9O1xuICBkZW5zaXR5LndlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyAod2VpZ2h0ID0gbnVtYmVyKF8pLCBkZW5zaXR5KSA6IHdlaWdodDtcbiAgfTtcbiAgZGVuc2l0eS5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBbZHgsIGR5XTtcbiAgICB2YXIgXzAgPSArX1swXSxcbiAgICAgIF8xID0gK19bMV07XG4gICAgaWYgKCEoXzAgPj0gMCAmJiBfMSA+PSAwKSkgZXJyb3IoJ2ludmFsaWQgc2l6ZScpO1xuICAgIHJldHVybiBkeCA9IF8wLCBkeSA9IF8xLCBkZW5zaXR5O1xuICB9O1xuICBkZW5zaXR5LmNlbGxTaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiAxIDw8IGs7XG4gICAgaWYgKCEoKF8gPSArXykgPj0gMSkpIGVycm9yKCdpbnZhbGlkIGNlbGwgc2l6ZScpO1xuICAgIGsgPSBNYXRoLmZsb29yKE1hdGgubG9nKF8pIC8gTWF0aC5MTjIpO1xuICAgIHJldHVybiBkZW5zaXR5O1xuICB9O1xuICBkZW5zaXR5LmJhbmR3aWR0aCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gYmFuZHdpZHRoO1xuICAgIF8gPSBhcnJheShfKTtcbiAgICBpZiAoXy5sZW5ndGggPT09IDEpIF8gPSBbK19bMF0sICtfWzBdXTtcbiAgICBpZiAoXy5sZW5ndGggIT09IDIpIGVycm9yKCdpbnZhbGlkIGJhbmR3aWR0aCcpO1xuICAgIHJldHVybiBiYW5kd2lkdGggPSBfLCBkZW5zaXR5O1xuICB9O1xuICByZXR1cm4gZGVuc2l0eTtcbn1cbmZ1bmN0aW9uIGJsdXJYKG4sIG0sIHNvdXJjZSwgdGFyZ2V0LCByKSB7XG4gIGNvbnN0IHcgPSAociA8PCAxKSArIDE7XG4gIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIHNyID0gMDsgaSA8IG4gKyByOyArK2kpIHtcbiAgICAgIGlmIChpIDwgbikge1xuICAgICAgICBzciArPSBzb3VyY2VbaSArIGogKiBuXTtcbiAgICAgIH1cbiAgICAgIGlmIChpID49IHIpIHtcbiAgICAgICAgaWYgKGkgPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZVtpIC0gdyArIGogKiBuXTtcbiAgICAgICAgfVxuICAgICAgICB0YXJnZXRbaSAtIHIgKyBqICogbl0gPSBzciAvIE1hdGgubWluKGkgKyAxLCBuIC0gMSArIHcgLSBpLCB3KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGJsdXJZKG4sIG0sIHNvdXJjZSwgdGFyZ2V0LCByKSB7XG4gIGNvbnN0IHcgPSAociA8PCAxKSArIDE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZm9yIChsZXQgaiA9IDAsIHNyID0gMDsgaiA8IG0gKyByOyArK2opIHtcbiAgICAgIGlmIChqIDwgbSkge1xuICAgICAgICBzciArPSBzb3VyY2VbaSArIGogKiBuXTtcbiAgICAgIH1cbiAgICAgIGlmIChqID49IHIpIHtcbiAgICAgICAgaWYgKGogPj0gdykge1xuICAgICAgICAgIHNyIC09IHNvdXJjZVtpICsgKGogLSB3KSAqIG5dO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldFtpICsgKGogLSByKSAqIG5dID0gc3IgLyBNYXRoLm1pbihqICsgMSwgbSAtIDEgKyB3IC0gaiwgdyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUGVyZm9ybSAyRCBrZXJuZWwtZGVuc2l0eSBlc3RpbWF0aW9uIG9mIHBvaW50IGRhdGEuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcGFyYW1zLnNpemUgLSBUaGUgW3dpZHRoLCBoZWlnaHRdIGV4dGVudCAoaW5cbiAqICAgdW5pdHMgb2YgaW5wdXQgcGl4ZWxzKSBvdmVyIHdoaWNoIHRvIHBlcmZvcm0gZGVuc2l0eSBlc3RpbWF0aW9uLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IHBhcmFtcy54IC0gVGhlIHgtY29vcmRpbmF0ZSBhY2Nlc3Nvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBwYXJhbXMueSAtIFRoZSB5LWNvb3JkaW5hdGUgYWNjZXNzb3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gW3BhcmFtcy53ZWlnaHRdIC0gVGhlIHdlaWdodCBhY2Nlc3Nvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnNcbiAqICAgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmNlbGxTaXplXSAtIENvbnRvdXIgZGVuc2l0eSBjYWxjdWxhdGlvbiBjZWxsIHNpemUuXG4gKiAgIFRoaXMgcGFyYW1ldGVyIGRldGVybWluZXMgdGhlIGxldmVsIG9mIHNwYXRpYWwgYXBwcm94aW1hdGlvbi4gRm9yIGV4YW1wbGUsXG4gKiAgIHRoZSBkZWZhdWx0IHZhbHVlIG9mIDQgbWFwcyB0byAyeCByZWR1Y3Rpb25zIGluIGJvdGggeC0gYW5kIHktIGRpbWVuc2lvbnMuXG4gKiAgIEEgdmFsdWUgb2YgMSB3aWxsIHJlc3VsdCBpbiBhbiBvdXRwdXQgcmFzdGVyIGdyaWQgd2hvc2UgZGltZW5zaW9ucyBleGFjdGx5XG4gKiAgIG1hdGNoZXMgdGhlIHNpemUgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmJhbmR3aWR0aF0gLSBUaGUgS0RFIGtlcm5lbCBiYW5kd2lkdGhzLFxuICogICBpbiBwaXhlbHMuIFRoZSBpbnB1dCBjYW4gYmUgYSB0d28tZWxlbWVudCBhcnJheSBzcGVjaWZ5aW5nIHNlcGFyYXRlXG4gKiAgIHggYW5kIHkgYmFuZHdpZHRocywgb3IgYSBzaW5nbGUtZWxlbWVudCBhcnJheSBzcGVjaWZ5aW5nIGJvdGguIElmIHRoZVxuICogICBiYW5kd2lkdGggaXMgdW5zcGVjaWZpZWQgb3IgbGVzcyB0aGFuIHplcm8sIHRoZSBiYW5kd2lkdGggd2lsbCBiZVxuICogICBhdXRvbWF0aWNhbGx5IGRldGVybWluZWQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuY291bnRzPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgdGhlXG4gKiAgIG91dHB1dCB2YWx1ZXMgc2hvdWxkIGJlIHByb2JhYmlsaXR5IGVzdGltYXRlcyAoZmFsc2UsIGRlZmF1bHQpIG9yXG4gKiAgIHNtb290aGVkIGNvdW50cyAodHJ1ZSkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0nZ3JpZCddIC0gVGhlIG91dHB1dCBmaWVsZCBpbiB3aGljaCB0byBzdG9yZVxuICogICB0aGUgZ2VuZXJhdGVkIHJhc3RlciBncmlkIChkZWZhdWx0ICdncmlkJykuXG4gKi9cbmZ1bmN0aW9uIEtERTJEKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuS0RFMkQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnS0RFMkQnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnd2VpZ2h0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjZWxsU2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFuZHdpZHRoJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50cycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnZ3JpZCdcbiAgfV1cbn07XG5jb25zdCBQQVJBTVMgPSBbJ3gnLCAneScsICd3ZWlnaHQnLCAnc2l6ZScsICdjZWxsU2l6ZScsICdiYW5kd2lkdGgnXTtcbmZ1bmN0aW9uIHBhcmFtcyhvYmosIF8pIHtcbiAgUEFSQU1TLmZvckVhY2gocGFyYW0gPT4gX1twYXJhbV0gIT0gbnVsbCA/IG9ialtwYXJhbV0oX1twYXJhbV0pIDogMCk7XG4gIHJldHVybiBvYmo7XG59XG5pbmhlcml0cyhLREUyRCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFwdWxzZS5jaGFuZ2VkKCkgJiYgIV8ubW9kaWZpZWQoKSkgcmV0dXJuIHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICBncm91cHMgPSBwYXJ0aXRpb24oc291cmNlLCBfLmdyb3VwYnkpLFxuICAgICAgbmFtZXMgPSAoXy5ncm91cGJ5IHx8IFtdKS5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgIGtkZSA9IHBhcmFtcyhkZW5zaXR5MkQoKSwgXyksXG4gICAgICBhcyA9IF8uYXMgfHwgJ2dyaWQnLFxuICAgICAgdmFsdWVzID0gW107XG4gICAgZnVuY3Rpb24gc2V0KHQsIHZhbHMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHRbbmFtZXNbaV1dID0gdmFsc1tpXTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIC8vIGdlbmVyYXRlIGRlbnNpdHkgcmFzdGVyIGdyaWRzXG4gICAgdmFsdWVzID0gZ3JvdXBzLm1hcChnID0+IGluZ2VzdChzZXQoe1xuICAgICAgW2FzXToga2RlKGcsIF8uY291bnRzKVxuICAgIH0sIGcuZGltcykpKTtcbiAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgdGhpcy52YWx1ZSA9IG91dC5zb3VyY2UgPSBvdXQuYWRkID0gdmFsdWVzO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnkpIHtcbiAgdmFyIGdyb3VwcyA9IFtdLFxuICAgIGdldCA9IGYgPT4gZih0KSxcbiAgICBtYXAsXG4gICAgaSxcbiAgICBuLFxuICAgIHQsXG4gICAgayxcbiAgICBnO1xuXG4gIC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIGdyb3Vwc1xuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG4gICAgICBpZiAoIWcpIHtcbiAgICAgICAgbWFwW2tdID0gZyA9IFtdO1xuICAgICAgICBnLmRpbXMgPSBrO1xuICAgICAgICBncm91cHMucHVzaChnKTtcbiAgICAgIH1cbiAgICAgIGcucHVzaCh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZSBjb250b3VycyBiYXNlZCBvbiBrZXJuZWwtZGVuc2l0eSBlc3RpbWF0aW9uIG9mIHBvaW50IGRhdGEuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gcGFyYW1zLnNpemUgLSBUaGUgZGltZW5zaW9ucyBbd2lkdGgsIGhlaWdodF0gb3ZlciB3aGljaCB0byBjb21wdXRlIGNvbnRvdXJzLlxuICogIElmIHRoZSB2YWx1ZXMgcGFyYW1ldGVyIGlzIHByb3ZpZGVkLCB0aGlzIG11c3QgYmUgdGhlIGRpbWVuc2lvbnMgb2YgdGhlIGlucHV0IGRhdGEuXG4gKiAgSWYgZGVuc2l0eSBlc3RpbWF0aW9uIGlzIHBlcmZvcm1lZCwgdGhpcyBpcyB0aGUgb3V0cHV0IHZpZXcgZGltZW5zaW9ucyBpbiBwaXhlbHMuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMudmFsdWVzXSAtIEFuIGFycmF5IG9mIG51bWVyaWMgdmFsdWVzIHJlcHJlc2VudGluZyBhblxuICogIHdpZHRoIHggaGVpZ2h0IGdyaWQgb2YgdmFsdWVzIG92ZXIgd2hpY2ggdG8gY29tcHV0ZSBjb250b3Vycy4gSWYgdW5zcGVjaWZpZWQsIHRoaXNcbiAqICB0cmFuc2Zvcm0gd2lsbCBpbnN0ZWFkIGF0dGVtcHQgdG8gY29tcHV0ZSBjb250b3VycyBmb3IgdGhlIGtlcm5lbCBkZW5zaXR5IGVzdGltYXRlXG4gKiAgdXNpbmcgdmFsdWVzIGRyYXduIGZyb20gZGF0YSB0dXBsZXMgaW4gdGhlIGlucHV0IHB1bHNlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBudW1iZXJ9IFtwYXJhbXMueF0gLSBUaGUgcGl4ZWwgeC1jb29yZGluYXRlIGFjY2Vzc29yIGZvciBkZW5zaXR5IGVzdGltYXRpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IG51bWJlcn0gW3BhcmFtcy55XSAtIFRoZSBwaXhlbCB5LWNvb3JkaW5hdGUgYWNjZXNzb3IgZm9yIGRlbnNpdHkgZXN0aW1hdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogbnVtYmVyfSBbcGFyYW1zLndlaWdodF0gLSBUaGUgZGF0YSBwb2ludCB3ZWlnaHQgYWNjZXNzb3IgZm9yIGRlbnNpdHkgZXN0aW1hdGlvbi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmNlbGxTaXplXSAtIENvbnRvdXIgZGVuc2l0eSBjYWxjdWxhdGlvbiBjZWxsIHNpemUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5iYW5kd2lkdGhdIC0gS2VybmVsIGRlbnNpdHkgZXN0aW1hdGlvbiBiYW5kd2lkdGguXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMudGhyZXNob2xkc10gLSBDb250b3VyIHRocmVzaG9sZCBhcnJheS4gSWZcbiAqICAgdGhpcyBwYXJhbWV0ZXIgaXMgc2V0LCB0aGUgY291bnQgYW5kIG5pY2UgcGFyYW1ldGVycyB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5jb3VudF0gLSBUaGUgZGVzaXJlZCBudW1iZXIgb2YgY29udG91cnMuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMubmljZV0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY29udG91clxuICogICB0aHJlc2hvbGQgdmFsdWVzIHNob3VsZCBiZSBhdXRvbWF0aWNhbGx5IGFsaWduZWQgdG8gXCJuaWNlXCJcbiAqICAgaHVtYW4tZnJpZW5kbHkgdmFsdWVzLiBTZXR0aW5nIHRoaXMgZmxhZyBtYXkgY2F1c2UgdGhlIG51bWJlciBvZlxuICogICB0aHJlc2hvbGRzIHRvIGRldmlhdGUgZnJvbSB0aGUgc3BlY2lmaWVkIGNvdW50LlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLnNtb290aF0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgY29udG91clxuICogICBwb2x5Z29ucyBzaG91bGQgYmUgc21vb3RoZWQgdXNpbmcgbGluZWFyIGludGVycG9sYXRpb24uIFRoZSBkZWZhdWx0IGlzXG4gKiAgIHRydWUuIFRoZSBwYXJhbWV0ZXIgaXMgaWdub3JlZCB3aGVuIHVzaW5nIGRlbnNpdHkgZXN0aW1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gQ29udG91cihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkNvbnRvdXIuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ29udG91cicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdzaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAndmFsdWVzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd3ZWlnaHQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnY2VsbFNpemUnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ2JhbmR3aWR0aCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnY291bnQnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ25pY2UnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3RocmVzaG9sZHMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc21vb3RoJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhDb250b3VyLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKHRoaXMudmFsdWUgJiYgIXB1bHNlLmNoYW5nZWQoKSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICB2YXIgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgY29udG91ciA9IGNvbnRvdXJzKCkuc21vb3RoKF8uc21vb3RoICE9PSBmYWxzZSksXG4gICAgICB2YWx1ZXMgPSBfLnZhbHVlcyxcbiAgICAgIHRocmVzaCA9IF8udGhyZXNob2xkcyB8fCBxdWFudGl6ZShfLmNvdW50IHx8IDEwLCBfLm5pY2UsICEhdmFsdWVzKSxcbiAgICAgIHNpemUgPSBfLnNpemUsXG4gICAgICBncmlkLFxuICAgICAgcG9zdDtcbiAgICBpZiAoIXZhbHVlcykge1xuICAgICAgdmFsdWVzID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2U7XG4gICAgICBncmlkID0gcGFyYW1zKGRlbnNpdHkyRCgpLCBfKSh2YWx1ZXMsIHRydWUpO1xuICAgICAgcG9zdCA9IHRyYW5zZm9ybShncmlkLCBncmlkLnNjYWxlIHx8IDEsIGdyaWQuc2NhbGUgfHwgMSwgMCwgMCk7XG4gICAgICBzaXplID0gW2dyaWQud2lkdGgsIGdyaWQuaGVpZ2h0XTtcbiAgICAgIHZhbHVlcyA9IGdyaWQudmFsdWVzO1xuICAgIH1cbiAgICB0aHJlc2ggPSBpc0FycmF5KHRocmVzaCkgPyB0aHJlc2ggOiB0aHJlc2godmFsdWVzKTtcbiAgICB2YWx1ZXMgPSBjb250b3VyLnNpemUoc2l6ZSkodmFsdWVzLCB0aHJlc2gpO1xuICAgIGlmIChwb3N0KSB2YWx1ZXMuZm9yRWFjaChwb3N0KTtcbiAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgdGhpcy52YWx1ZSA9IG91dC5zb3VyY2UgPSBvdXQuYWRkID0gKHZhbHVlcyB8fCBbXSkubWFwKGluZ2VzdCk7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufSk7XG5cbmNvbnN0IEZlYXR1cmUgPSAnRmVhdHVyZSc7XG5jb25zdCBGZWF0dXJlQ29sbGVjdGlvbiA9ICdGZWF0dXJlQ29sbGVjdGlvbic7XG5jb25zdCBNdWx0aVBvaW50ID0gJ011bHRpUG9pbnQnO1xuXG4vKipcbiAqIENvbnNvbGlkYXRlIGFuIGFycmF5IG9mIFtsb25naXR1ZGUsIGxhdGl0dWRlXSBwb2ludHMgb3IgR2VvSlNPTiBmZWF0dXJlc1xuICogaW50byBhIGNvbWJpbmVkIEdlb0pTT04gb2JqZWN0LiBUaGlzIHRyYW5zZm9ybSBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvclxuICogY29tYmluaW5nIGdlbyBkYXRhIGZvciBhIFByb2plY3Rpb24ncyBmaXQgYXJndW1lbnQuIFRoZSByZXN1bHRpbmcgR2VvSlNPTlxuICogZGF0YSBpcyBhdmFpbGFibGUgYXMgdGhpcyB0cmFuc2Zvcm0ncyB2YWx1ZS4gSW5wdXQgcHVsc2VzIGFyZSB1bmNoYW5nZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZmllbGRzXSAtIEEgdHdvLWVsZW1lbnQgYXJyYXlcbiAqICAgb2YgZmllbGQgYWNjZXNzb3JzIGZvciB0aGUgbG9uZ2l0dWRlIGFuZCBsYXRpdHVkZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5nZW9qc29uIC0gQSBmaWVsZCBhY2Nlc3NvciBmb3JcbiAqICAgcmV0cmlldmluZyBHZW9KU09OIGZlYXR1cmUgZGF0YS5cbiAqL1xuZnVuY3Rpb24gR2VvSlNPTihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkdlb0pTT04uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR2VvSlNPTicsXG4gICdtZXRhZGF0YSc6IHt9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdnZW9qc29uJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfV1cbn07XG5pbmhlcml0cyhHZW9KU09OLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIGZlYXR1cmVzID0gdGhpcy5fZmVhdHVyZXMsXG4gICAgICBwb2ludHMgPSB0aGlzLl9wb2ludHMsXG4gICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgIGxvbiA9IGZpZWxkcyAmJiBmaWVsZHNbMF0sXG4gICAgICBsYXQgPSBmaWVsZHMgJiYgZmllbGRzWzFdLFxuICAgICAgZ2VvanNvbiA9IF8uZ2VvanNvbiB8fCAhZmllbGRzICYmIGlkZW50aXR5LFxuICAgICAgZmxhZyA9IHB1bHNlLkFERCxcbiAgICAgIG1vZDtcbiAgICBtb2QgPSBfLm1vZGlmaWVkKCkgfHwgcHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pIHx8IHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGdlb2pzb24pKSB8fCBsb24gJiYgcHVsc2UubW9kaWZpZWQoYWNjZXNzb3JGaWVsZHMobG9uKSkgfHwgbGF0ICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGxhdCkpO1xuICAgIGlmICghdGhpcy52YWx1ZSB8fCBtb2QpIHtcbiAgICAgIGZsYWcgPSBwdWxzZS5TT1VSQ0U7XG4gICAgICB0aGlzLl9mZWF0dXJlcyA9IGZlYXR1cmVzID0gW107XG4gICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHMgPSBbXTtcbiAgICB9XG4gICAgaWYgKGdlb2pzb24pIHtcbiAgICAgIHB1bHNlLnZpc2l0KGZsYWcsIHQgPT4gZmVhdHVyZXMucHVzaChnZW9qc29uKHQpKSk7XG4gICAgfVxuICAgIGlmIChsb24gJiYgbGF0KSB7XG4gICAgICBwdWxzZS52aXNpdChmbGFnLCB0ID0+IHtcbiAgICAgICAgdmFyIHggPSBsb24odCksXG4gICAgICAgICAgeSA9IGxhdCh0KTtcbiAgICAgICAgaWYgKHggIT0gbnVsbCAmJiB5ICE9IG51bGwgJiYgKHggPSAreCkgPT09IHggJiYgKHkgPSAreSkgPT09IHkpIHtcbiAgICAgICAgICBwb2ludHMucHVzaChbeCwgeV0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGZlYXR1cmVzID0gZmVhdHVyZXMuY29uY2F0KHtcbiAgICAgICAgdHlwZTogRmVhdHVyZSxcbiAgICAgICAgZ2VvbWV0cnk6IHtcbiAgICAgICAgICB0eXBlOiBNdWx0aVBvaW50LFxuICAgICAgICAgIGNvb3JkaW5hdGVzOiBwb2ludHNcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSB7XG4gICAgICB0eXBlOiBGZWF0dXJlQ29sbGVjdGlvbixcbiAgICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICAgIH07XG4gIH1cbn0pO1xuXG4vKipcbiAqIE1hcCBHZW9KU09OIGRhdGEgdG8gYW4gU1ZHIHBhdGggc3RyaW5nLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggR2VvSlNPTiBkYXRhLFxuICogICBvciBudWxsIGlmIHRoZSB0dXBsZSBpdHNlbGYgaXMgYSBHZW9KU09OIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0ncGF0aCddIC0gVGhlIG91dHB1dCBmaWVsZCBpbiB3aGljaCB0byBzdG9yZVxuICogICB0aGUgZ2VuZXJhdGVkIHBhdGggZGF0YSAoZGVmYXVsdCAncGF0aCcpLlxuICovXG5mdW5jdGlvbiBHZW9QYXRoKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuR2VvUGF0aC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9QYXRoJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAncHJvamVjdGlvbicsXG4gICAgJ3R5cGUnOiAncHJvamVjdGlvbidcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3BvaW50UmFkaXVzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAncGF0aCdcbiAgfV1cbn07XG5pbmhlcml0cyhHZW9QYXRoLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdmFyIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKSxcbiAgICAgIHBhdGggPSB0aGlzLnZhbHVlLFxuICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IGlkZW50aXR5LFxuICAgICAgYXMgPSBfLmFzIHx8ICdwYXRoJyxcbiAgICAgIGZsYWcgPSBvdXQuU09VUkNFO1xuICAgIGlmICghcGF0aCB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgcmVzZXQgYW5kIHJlZmxvd1xuICAgICAgdGhpcy52YWx1ZSA9IHBhdGggPSBnZXRQcm9qZWN0aW9uUGF0aChfLnByb2plY3Rpb24pO1xuICAgICAgb3V0Lm1hdGVyaWFsaXplKCkucmVmbG93KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWcgPSBmaWVsZCA9PT0gaWRlbnRpdHkgfHwgcHVsc2UubW9kaWZpZWQoZmllbGQuZmllbGRzKSA/IG91dC5BRERfTU9EIDogb3V0LkFERDtcbiAgICB9XG4gICAgY29uc3QgcHJldiA9IGluaXRQYXRoKHBhdGgsIF8ucG9pbnRSYWRpdXMpO1xuICAgIG91dC52aXNpdChmbGFnLCB0ID0+IHRbYXNdID0gcGF0aChmaWVsZCh0KSkpO1xuICAgIHBhdGgucG9pbnRSYWRpdXMocHJldik7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gaW5pdFBhdGgocGF0aCwgcG9pbnRSYWRpdXMpIHtcbiAgY29uc3QgcHJldiA9IHBhdGgucG9pbnRSYWRpdXMoKTtcbiAgcGF0aC5jb250ZXh0KG51bGwpO1xuICBpZiAocG9pbnRSYWRpdXMgIT0gbnVsbCkge1xuICAgIHBhdGgucG9pbnRSYWRpdXMocG9pbnRSYWRpdXMpO1xuICB9XG4gIHJldHVybiBwcmV2O1xufVxuXG4vKipcbiAqIEdlby1jb2RlIGEgbG9uZ2l0dWRlL2xhdGl0dWRlIHBvaW50IHRvIGFuIHgveSBjb29yZGluYXRlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMuZmllbGRzIC0gQSB0d28tZWxlbWVudCBhcnJheSBvZlxuICogICBmaWVsZCBhY2Nlc3NvcnMgZm9yIHRoZSBsb25naXR1ZGUgYW5kIGxhdGl0dWRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBBIHR3by1lbGVtZW50IGFycmF5IG9mIGZpZWxkIG5hbWVzXG4gKiAgIHVuZGVyIHdoaWNoIHRvIHN0b3JlIHRoZSByZXN1bHQuIERlZmF1bHRzIHRvIFsneCcsJ3knXS5cbiAqL1xuZnVuY3Rpb24gR2VvUG9pbnQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5HZW9Qb2ludC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHZW9Qb2ludCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsneCcsICd5J11cbiAgfV1cbn07XG5pbmhlcml0cyhHZW9Qb2ludCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBwcm9qID0gXy5wcm9qZWN0aW9uLFxuICAgICAgbG9uID0gXy5maWVsZHNbMF0sXG4gICAgICBsYXQgPSBfLmZpZWxkc1sxXSxcbiAgICAgIGFzID0gXy5hcyB8fCBbJ3gnLCAneSddLFxuICAgICAgeCA9IGFzWzBdLFxuICAgICAgeSA9IGFzWzFdLFxuICAgICAgbW9kO1xuICAgIGZ1bmN0aW9uIHNldCh0KSB7XG4gICAgICBjb25zdCB4eSA9IHByb2ooW2xvbih0KSwgbGF0KHQpXSk7XG4gICAgICBpZiAoeHkpIHtcbiAgICAgICAgdFt4XSA9IHh5WzBdO1xuICAgICAgICB0W3ldID0geHlbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0W3hdID0gdW5kZWZpbmVkO1xuICAgICAgICB0W3ldID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXy5tb2RpZmllZCgpKSB7XG4gICAgICAvLyBwYXJhbWV0ZXJzIHVwZGF0ZWQsIHJlZmxvd1xuICAgICAgcHVsc2UgPSBwdWxzZS5tYXRlcmlhbGl6ZSgpLnJlZmxvdyh0cnVlKS52aXNpdChwdWxzZS5TT1VSQ0UsIHNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZCA9IHB1bHNlLm1vZGlmaWVkKGxvbi5maWVsZHMpIHx8IHB1bHNlLm1vZGlmaWVkKGxhdC5maWVsZHMpO1xuICAgICAgcHVsc2UudmlzaXQobW9kID8gcHVsc2UuQUREX01PRCA6IHB1bHNlLkFERCwgc2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHB1bHNlLm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQW5ub3RhdGUgaXRlbXMgd2l0aCBhIGdlb3BhdGggc2hhcGUgZ2VuZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG51bWJlciwgbnVtYmVyKTogKn0gcGFyYW1zLnByb2plY3Rpb24gLSBUaGUgY2FydG9ncmFwaGljXG4gKiAgIHByb2plY3Rpb24gdG8gYXBwbHkuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IFtwYXJhbXMuZmllbGRdIC0gVGhlIGZpZWxkIHdpdGggR2VvSlNPTiBkYXRhLFxuICogICBvciBudWxsIGlmIHRoZSB0dXBsZSBpdHNlbGYgaXMgYSBHZW9KU09OIGZlYXR1cmUuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5hcz0nc2hhcGUnXSAtIFRoZSBvdXRwdXQgZmllbGQgaW4gd2hpY2ggdG8gc3RvcmVcbiAqICAgdGhlIGdlbmVyYXRlZCBwYXRoIGRhdGEgKGRlZmF1bHQgJ3NoYXBlJykuXG4gKi9cbmZ1bmN0aW9uIEdlb1NoYXBlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuR2VvU2hhcGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnR2VvU2hhcGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZSxcbiAgICAnbm9tb2QnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3Byb2plY3Rpb24nLFxuICAgICd0eXBlJzogJ3Byb2plY3Rpb24nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdkZWZhdWx0JzogJ2RhdHVtJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAncG9pbnRSYWRpdXMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdzaGFwZSdcbiAgfV1cbn07XG5pbmhlcml0cyhHZW9TaGFwZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICBzaGFwZSA9IHRoaXMudmFsdWUsXG4gICAgICBhcyA9IF8uYXMgfHwgJ3NoYXBlJyxcbiAgICAgIGZsYWcgPSBvdXQuQUREO1xuICAgIGlmICghc2hhcGUgfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICAvLyBwYXJhbWV0ZXJzIHVwZGF0ZWQsIHJlc2V0IGFuZCByZWZsb3dcbiAgICAgIHRoaXMudmFsdWUgPSBzaGFwZSA9IHNoYXBlR2VuZXJhdG9yKGdldFByb2plY3Rpb25QYXRoKF8ucHJvamVjdGlvbiksIF8uZmllbGQgfHwgZmllbGQoJ2RhdHVtJyksIF8ucG9pbnRSYWRpdXMpO1xuICAgICAgb3V0Lm1hdGVyaWFsaXplKCkucmVmbG93KCk7XG4gICAgICBmbGFnID0gb3V0LlNPVVJDRTtcbiAgICB9XG4gICAgb3V0LnZpc2l0KGZsYWcsIHQgPT4gdFthc10gPSBzaGFwZSk7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gc2hhcGVHZW5lcmF0b3IocGF0aCwgZmllbGQsIHBvaW50UmFkaXVzKSB7XG4gIGNvbnN0IHNoYXBlID0gcG9pbnRSYWRpdXMgPT0gbnVsbCA/IF8gPT4gcGF0aChmaWVsZChfKSkgOiBfID0+IHtcbiAgICB2YXIgcHJldiA9IHBhdGgucG9pbnRSYWRpdXMoKSxcbiAgICAgIHZhbHVlID0gcGF0aC5wb2ludFJhZGl1cyhwb2ludFJhZGl1cykoZmllbGQoXykpO1xuICAgIHBhdGgucG9pbnRSYWRpdXMocHJldik7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuICBzaGFwZS5jb250ZXh0ID0gXyA9PiB7XG4gICAgcGF0aC5jb250ZXh0KF8pO1xuICAgIHJldHVybiBzaGFwZTtcbiAgfTtcbiAgcmV0dXJuIHNoYXBlO1xufVxuXG4vKipcbiAqIEdlb0pTT04gZmVhdHVyZSBnZW5lcmF0b3IgZm9yIGNyZWF0aW5nIGdyYXRpY3VsZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gR3JhdGljdWxlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbiAgdGhpcy5nZW5lcmF0b3IgPSBnZW9HcmF0aWN1bGUoKTtcbn1cbkdyYXRpY3VsZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdHcmF0aWN1bGUnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2NoYW5nZXMnOiB0cnVlLFxuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2NvbnRlbnQnOiB7XG4gICAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAgICdsZW5ndGgnOiAyXG4gICAgfVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50TWFqb3InLFxuICAgICd0eXBlJzogJ2FycmF5JyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdjb250ZW50Jzoge1xuICAgICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAgICdhcnJheSc6IHRydWUsXG4gICAgICAnbGVuZ3RoJzogMlxuICAgIH1cbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudE1pbm9yJyxcbiAgICAndHlwZSc6ICdhcnJheScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnY29udGVudCc6IHtcbiAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAnYXJyYXknOiB0cnVlLFxuICAgICAgJ2xlbmd0aCc6IDJcbiAgICB9XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXBNYWpvcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWzkwLCAzNjBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwTWlub3InLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsxMCwgMTBdXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwcmVjaXNpb24nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAyLjVcbiAgfV1cbn07XG5pbmhlcml0cyhHcmF0aWN1bGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB2YXIgc3JjID0gdGhpcy52YWx1ZSxcbiAgICAgIGdlbiA9IHRoaXMuZ2VuZXJhdG9yLFxuICAgICAgdDtcbiAgICBpZiAoIXNyYy5sZW5ndGggfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICBmb3IgKGNvbnN0IHByb3AgaW4gXykge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihnZW5bcHJvcF0pKSB7XG4gICAgICAgICAgZ2VuW3Byb3BdKF9bcHJvcF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHQgPSBnZW4oKTtcbiAgICBpZiAoc3JjLmxlbmd0aCkge1xuICAgICAgcHVsc2UubW9kLnB1c2gocmVwbGFjZShzcmNbMF0sIHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UuYWRkLnB1c2goaW5nZXN0KHQpKTtcbiAgICB9XG4gICAgc3JjWzBdID0gdDtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFJlbmRlciBhIGhlYXRtYXAgaW1hZ2UgZm9yIGlucHV0IHJhc3RlciBncmlkIGRhdGEuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gW3BhcmFtcy5maWVsZF0gLSBUaGUgZmllbGQgd2l0aCByYXN0ZXIgZ3JpZFxuICogICBkYXRhLiBJZiB1bnNwZWNpZmllZCwgdGhlIHR1cGxlIGl0c2VsZiBpcyBpbnRlcnByZXRlZCBhcyBhIHJhc3RlciBncmlkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY29sb3JdIC0gQSBjb25zdGFudCBjb2xvciB2YWx1ZSBvciBmdW5jdGlvbiBmb3JcbiAqICAgaW5kaXZpZHVhbCBwaXhlbCBjb2xvci4gSWYgYSBmdW5jdGlvbiwgaXQgd2lsbCBiZSBpbnZva2VkIHdpdGggYW4gaW5wdXRcbiAqICAgb2JqZWN0IHRoYXQgaW5jbHVkZXMgJHgsICR5LCAkdmFsdWUsIGFuZCAkbWF4IGZpZWxkcyBmb3IgdGhlIGdyaWQuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5vcGFjaXR5XSAtIEEgY29uc3RhbnQgb3BhY2l0eSB2YWx1ZSBvciBmdW5jdGlvbiBmb3JcbiAqICAgaW5kaXZpZHVhbCBwaXhlbCBvcGFjaXR5LiBJZiBhIGZ1bmN0aW9uLCBpdCB3aWxsIGJlIGludm9rZWQgd2l0aCBhbiBpbnB1dFxuICogICBvYmplY3QgdGhhdCBpbmNsdWRlcyAkeCwgJHksICR2YWx1ZSwgYW5kICRtYXggZmllbGRzIGZvciB0aGUgZ3JpZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLnJlc29sdmVdIC0gVGhlIG1ldGhvZCBmb3IgcmVzb2x2aW5nIG1heGltdW0gdmFsdWVzXG4gKiAgIGFjcm9zcyBtdWx0aXBsZSBpbnB1dCBncmlkcy4gSWYgJ2luZGVwZW5kZW50JyAodGhlIGRlZmF1bHQpLCBtYXhpbXVtXG4gKiAgIGNhbGN1bGF0aW9uIHdpbGwgYmUgcGVyZm9ybWVkIHNlcGFyYXRlbHkgZm9yIGVhY2ggZ3JpZC4gSWYgJ3NoYXJlZCcsXG4gKiAgIGEgc2luZ2xlIGdsb2JhbCBtYXhpbXVtIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGlucHV0IGdyaWRzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuYXM9J2ltYWdlJ10gLSBUaGUgb3V0cHV0IGZpZWxkIGluIHdoaWNoIHRvIHN0b3JlXG4gKiAgIHRoZSBnZW5lcmF0ZWQgYml0bWFwIGNhbnZhcyBpbWFnZXMgKGRlZmF1bHQgJ2ltYWdlJykuXG4gKi9cbmZ1bmN0aW9uIEhlYXRtYXAocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5IZWF0bWFwLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ2hlYXRtYXAnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjb2xvcicsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZXhwcic6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ29wYWNpdHknLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2V4cHInOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyZXNvbHZlJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAndmFsdWVzJzogWydzaGFyZWQnLCAnaW5kZXBlbmRlbnQnXSxcbiAgICAnZGVmYXVsdCc6ICdpbmRlcGVuZGVudCdcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ2ltYWdlJ1xuICB9XVxufTtcbmluaGVyaXRzKEhlYXRtYXAsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAoIXB1bHNlLmNoYW5nZWQoKSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gcHVsc2UuU3RvcFByb3BhZ2F0aW9uO1xuICAgIH1cbiAgICB2YXIgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICBzaGFyZWQgPSBfLnJlc29sdmUgPT09ICdzaGFyZWQnLFxuICAgICAgZmllbGQgPSBfLmZpZWxkIHx8IGlkZW50aXR5LFxuICAgICAgb3BhY2l0eSA9IG9wYWNpdHlfKF8ub3BhY2l0eSwgXyksXG4gICAgICBjb2xvciA9IGNvbG9yXyhfLmNvbG9yLCBfKSxcbiAgICAgIGFzID0gXy5hcyB8fCAnaW1hZ2UnLFxuICAgICAgb2JqID0ge1xuICAgICAgICAkeDogMCxcbiAgICAgICAgJHk6IDAsXG4gICAgICAgICR2YWx1ZTogMCxcbiAgICAgICAgJG1heDogc2hhcmVkID8gbWF4KHNvdXJjZS5tYXAodCA9PiBtYXgoZmllbGQodCkudmFsdWVzKSkpIDogMFxuICAgICAgfTtcbiAgICBzb3VyY2UuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGNvbnN0IHYgPSBmaWVsZCh0KTtcblxuICAgICAgLy8gYnVpbGQgcHJveHkgZGF0YSBvYmplY3RcbiAgICAgIGNvbnN0IG8gPSBleHRlbmQoe30sIHQsIG9iaik7XG4gICAgICAvLyBzZXQgbWF4aW11bSB2YWx1ZSBpZiBub3QgZ2xvYmFsbHkgc2hhcmVkXG4gICAgICBpZiAoIXNoYXJlZCkgby4kbWF4ID0gbWF4KHYudmFsdWVzIHx8IFtdKTtcblxuICAgICAgLy8gZ2VuZXJhdGUgY2FudmFzIGltYWdlXG4gICAgICAvLyBvcHRpbWl6ZSBjb2xvci9vcGFjaXR5IGlmIG5vdCBwaXhlbC1kZXBlbmRlbnRcbiAgICAgIHRbYXNdID0gdG9DYW52YXModiwgbywgY29sb3IuZGVwID8gY29sb3IgOiBjb25zdGFudChjb2xvcihvKSksIG9wYWNpdHkuZGVwID8gb3BhY2l0eSA6IGNvbnN0YW50KG9wYWNpdHkobykpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KHRydWUpLm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbi8vIGdldCBpbWFnZSBjb2xvciBmdW5jdGlvblxuZnVuY3Rpb24gY29sb3JfKGNvbG9yLCBfKSB7XG4gIGxldCBmO1xuICBpZiAoaXNGdW5jdGlvbihjb2xvcikpIHtcbiAgICBmID0gb2JqID0+IHJnYihjb2xvcihvYmosIF8pKTtcbiAgICBmLmRlcCA9IGRlcGVuZGVuY3koY29sb3IpO1xuICB9IGVsc2Uge1xuICAgIC8vIGRlZmF1bHQgdG8gbWlkLWdyZXlcbiAgICBmID0gY29uc3RhbnQocmdiKGNvbG9yIHx8ICcjODg4JykpO1xuICB9XG4gIHJldHVybiBmO1xufVxuXG4vLyBnZXQgaW1hZ2Ugb3BhY2l0eSBmdW5jdGlvblxuZnVuY3Rpb24gb3BhY2l0eV8ob3BhY2l0eSwgXykge1xuICBsZXQgZjtcbiAgaWYgKGlzRnVuY3Rpb24ob3BhY2l0eSkpIHtcbiAgICBmID0gb2JqID0+IG9wYWNpdHkob2JqLCBfKTtcbiAgICBmLmRlcCA9IGRlcGVuZGVuY3kob3BhY2l0eSk7XG4gIH0gZWxzZSBpZiAob3BhY2l0eSkge1xuICAgIGYgPSBjb25zdGFudChvcGFjaXR5KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBkZWZhdWx0IHRvIFswLCBtYXhdIG9wYWNpdHkgZ3JhZGllbnRcbiAgICBmID0gb2JqID0+IG9iai4kdmFsdWUgLyBvYmouJG1heCB8fCAwO1xuICAgIGYuZGVwID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZjtcbn1cblxuLy8gY2hlY2sgaWYgZnVuY3Rpb24gZGVwZW5kcyBvbiBpbmRpdmlkdWFsIHBpeGVsIGRhdGFcbmZ1bmN0aW9uIGRlcGVuZGVuY3koZikge1xuICBpZiAoIWlzRnVuY3Rpb24oZikpIHJldHVybiBmYWxzZTtcbiAgY29uc3Qgc2V0ID0gdG9TZXQoYWNjZXNzb3JGaWVsZHMoZikpO1xuICByZXR1cm4gc2V0LiR4IHx8IHNldC4keSB8fCBzZXQuJHZhbHVlIHx8IHNldC4kbWF4O1xufVxuXG4vLyByZW5kZXIgcmFzdGVyIGdyaWQgdG8gY2FudmFzXG5mdW5jdGlvbiB0b0NhbnZhcyhncmlkLCBvYmosIGNvbG9yLCBvcGFjaXR5KSB7XG4gIGNvbnN0IG4gPSBncmlkLndpZHRoLFxuICAgIG0gPSBncmlkLmhlaWdodCxcbiAgICB4MSA9IGdyaWQueDEgfHwgMCxcbiAgICB5MSA9IGdyaWQueTEgfHwgMCxcbiAgICB4MiA9IGdyaWQueDIgfHwgbixcbiAgICB5MiA9IGdyaWQueTIgfHwgbSxcbiAgICB2YWwgPSBncmlkLnZhbHVlcyxcbiAgICB2YWx1ZSA9IHZhbCA/IGkgPT4gdmFsW2ldIDogemVybyxcbiAgICBjYW4gPSBjYW52YXMoeDIgLSB4MSwgeTIgLSB5MSksXG4gICAgY3R4ID0gY2FuLmdldENvbnRleHQoJzJkJyksXG4gICAgaW1nID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCB4MiAtIHgxLCB5MiAtIHkxKSxcbiAgICBwaXggPSBpbWcuZGF0YTtcbiAgZm9yIChsZXQgaiA9IHkxLCBrID0gMDsgaiA8IHkyOyArK2opIHtcbiAgICBvYmouJHkgPSBqIC0geTE7XG4gICAgZm9yIChsZXQgaSA9IHgxLCByID0gaiAqIG47IGkgPCB4MjsgKytpLCBrICs9IDQpIHtcbiAgICAgIG9iai4keCA9IGkgLSB4MTtcbiAgICAgIG9iai4kdmFsdWUgPSB2YWx1ZShpICsgcik7XG4gICAgICBjb25zdCB2ID0gY29sb3Iob2JqKTtcbiAgICAgIHBpeFtrICsgMF0gPSB2LnI7XG4gICAgICBwaXhbayArIDFdID0gdi5nO1xuICAgICAgcGl4W2sgKyAyXSA9IHYuYjtcbiAgICAgIHBpeFtrICsgM10gPSB+figyNTUgKiBvcGFjaXR5KG9iaikpO1xuICAgIH1cbiAgfVxuICBjdHgucHV0SW1hZ2VEYXRhKGltZywgMCwgMCk7XG4gIHJldHVybiBjYW47XG59XG5cbi8qKlxuICogTWFpbnRhaW5zIGEgY2FydG9ncmFwaGljIHByb2plY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gUHJvamVjdGlvbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbiAgdGhpcy5tb2RpZmllZCh0cnVlKTsgLy8gYWx3YXlzIHRyZWF0IGFzIG1vZGlmaWVkXG59XG5pbmhlcml0cyhQcm9qZWN0aW9uLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgbGV0IHByb2ogPSB0aGlzLnZhbHVlO1xuICAgIGlmICghcHJvaiB8fCBfLm1vZGlmaWVkKCd0eXBlJykpIHtcbiAgICAgIHRoaXMudmFsdWUgPSBwcm9qID0gY3JlYXRlKF8udHlwZSk7XG4gICAgICBwcm9qZWN0aW9uUHJvcGVydGllcy5mb3JFYWNoKHByb3AgPT4ge1xuICAgICAgICBpZiAoX1twcm9wXSAhPSBudWxsKSBzZXQocHJvaiwgcHJvcCwgX1twcm9wXSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvamVjdGlvblByb3BlcnRpZXMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgICAgaWYgKF8ubW9kaWZpZWQocHJvcCkpIHNldChwcm9qLCBwcm9wLCBfW3Byb3BdKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoXy5wb2ludFJhZGl1cyAhPSBudWxsKSBwcm9qLnBhdGgucG9pbnRSYWRpdXMoXy5wb2ludFJhZGl1cyk7XG4gICAgaWYgKF8uZml0KSBmaXQocHJvaiwgXyk7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBmaXQocHJvaiwgXykge1xuICBjb25zdCBkYXRhID0gY29sbGVjdEdlb0pTT04oXy5maXQpO1xuICBfLmV4dGVudCA/IHByb2ouZml0RXh0ZW50KF8uZXh0ZW50LCBkYXRhKSA6IF8uc2l6ZSA/IHByb2ouZml0U2l6ZShfLnNpemUsIGRhdGEpIDogMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlKSB7XG4gIGNvbnN0IGNvbnN0cnVjdG9yID0gcHJvamVjdGlvbigodHlwZSB8fCAnbWVyY2F0b3InKS50b0xvd2VyQ2FzZSgpKTtcbiAgaWYgKCFjb25zdHJ1Y3RvcikgZXJyb3IoJ1VucmVjb2duaXplZCBwcm9qZWN0aW9uIHR5cGU6ICcgKyB0eXBlKTtcbiAgcmV0dXJuIGNvbnN0cnVjdG9yKCk7XG59XG5mdW5jdGlvbiBzZXQocHJvaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNGdW5jdGlvbihwcm9qW2tleV0pKSBwcm9qW2tleV0odmFsdWUpO1xufVxuZnVuY3Rpb24gY29sbGVjdEdlb0pTT04oZGF0YSkge1xuICBkYXRhID0gYXJyYXkoZGF0YSk7XG4gIHJldHVybiBkYXRhLmxlbmd0aCA9PT0gMSA/IGRhdGFbMF0gOiB7XG4gICAgdHlwZTogRmVhdHVyZUNvbGxlY3Rpb24sXG4gICAgZmVhdHVyZXM6IGRhdGEucmVkdWNlKChhLCBmKSA9PiBhLmNvbmNhdChmZWF0dXJpemUoZikpLCBbXSlcbiAgfTtcbn1cbmZ1bmN0aW9uIGZlYXR1cml6ZShmKSB7XG4gIHJldHVybiBmLnR5cGUgPT09IEZlYXR1cmVDb2xsZWN0aW9uID8gZi5mZWF0dXJlcyA6IGFycmF5KGYpLmZpbHRlcihkID0+IGQgIT0gbnVsbCkubWFwKGQgPT4gZC50eXBlID09PSBGZWF0dXJlID8gZCA6IHtcbiAgICB0eXBlOiBGZWF0dXJlLFxuICAgIGdlb21ldHJ5OiBkXG4gIH0pO1xufVxuXG5leHBvcnQgeyBDb250b3VyIGFzIGNvbnRvdXIsIEdlb0pTT04gYXMgZ2VvanNvbiwgR2VvUGF0aCBhcyBnZW9wYXRoLCBHZW9Qb2ludCBhcyBnZW9wb2ludCwgR2VvU2hhcGUgYXMgZ2Vvc2hhcGUsIEdyYXRpY3VsZSBhcyBncmF0aWN1bGUsIEhlYXRtYXAgYXMgaGVhdG1hcCwgSXNvY29udG91ciBhcyBpc29jb250b3VyLCBLREUyRCBhcyBrZGUyZCwgUHJvamVjdGlvbiBhcyBwcm9qZWN0aW9uIH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0sIGlzVHVwbGUsIGluZ2VzdCwgdHVwbGVpZCwgc3RhYmxlQ29tcGFyZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGVycm9yLCBhcnJheSwgb25lLCB0cnV0aHksIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGhpZXJhcmNoeSwgcGFjaywgcGFydGl0aW9uLCBzdHJhdGlmeSwgdHJlZSwgY2x1c3RlciwgdHJlZW1hcCwgdHJlZW1hcEJpbmFyeSwgdHJlZW1hcERpY2UsIHRyZWVtYXBTbGljZSwgdHJlZW1hcFNsaWNlRGljZSwgdHJlZW1hcFNxdWFyaWZ5LCB0cmVlbWFwUmVzcXVhcmlmeSB9IGZyb20gJ2QzLWhpZXJhcmNoeSc7XG5cbi8vIEJ1aWxkIGxvb2t1cCB0YWJsZSBtYXBwaW5nIHR1cGxlIGtleXMgdG8gdHJlZSBub2RlIGluc3RhbmNlc1xuZnVuY3Rpb24gbG9va3VwICh0cmVlLCBrZXksIGZpbHRlcikge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgdHJlZS5lYWNoKG5vZGUgPT4ge1xuICAgIGNvbnN0IHQgPSBub2RlLmRhdGE7XG4gICAgaWYgKGZpbHRlcih0KSkgbWFwW2tleSh0KV0gPSBub2RlO1xuICB9KTtcbiAgdHJlZS5sb29rdXAgPSBtYXA7XG4gIHJldHVybiB0cmVlO1xufVxuXG4vKipcbiAqIE5lc3QgdHVwbGVzIGludG8gYSB0cmVlIHN0cnVjdHVyZSwgZ3JvdXBlZCBieSBrZXkgdmFsdWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMua2V5cyAtIFRoZSBrZXkgZmllbGRzIHRvIG5lc3QgYnksIGluIG9yZGVyLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmdlbmVyYXRlPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWZcbiAqICAgbm9uLWxlYWYgbm9kZXMgZ2VuZXJhdGVkIGJ5IHRoaXMgdHJhbnNmb3JtIHNob3VsZCBiZSBpbmNsdWRlZCBpbiB0aGVcbiAqICAgb3V0cHV0LiBUaGUgZGVmYXVsdCAoZmFsc2UpIGluY2x1ZGVzIG9ubHkgdGhlIGlucHV0IGRhdGEgKGxlYWYgbm9kZXMpXG4gKiAgIGluIHRoZSBkYXRhIHN0cmVhbS5cbiAqL1xuZnVuY3Rpb24gTmVzdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbk5lc3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnTmVzdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZXNvdXJjZSc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2tleXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdnZW5lcmF0ZScsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbidcbiAgfV1cbn07XG5jb25zdCBjaGlsZHJlbiA9IG4gPT4gbi52YWx1ZXM7XG5pbmhlcml0cyhOZXN0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgaWYgKCFwdWxzZS5zb3VyY2UpIHtcbiAgICAgIGVycm9yKCdOZXN0IHRyYW5zZm9ybSByZXF1aXJlcyBhbiB1cHN0cmVhbSBkYXRhIHNvdXJjZS4nKTtcbiAgICB9XG4gICAgdmFyIGdlbiA9IF8uZ2VuZXJhdGUsXG4gICAgICBtb2QgPSBfLm1vZGlmaWVkKCksXG4gICAgICBvdXQgPSBwdWxzZS5jbG9uZSgpLFxuICAgICAgdHJlZSA9IHRoaXMudmFsdWU7XG4gICAgaWYgKCF0cmVlIHx8IG1vZCB8fCBwdWxzZS5jaGFuZ2VkKCkpIHtcbiAgICAgIC8vIGNvbGxlY3Qgbm9kZXMgdG8gcmVtb3ZlXG4gICAgICBpZiAodHJlZSkge1xuICAgICAgICB0cmVlLmVhY2gobm9kZSA9PiB7XG4gICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4gJiYgaXNUdXBsZShub2RlLmRhdGEpKSB7XG4gICAgICAgICAgICBvdXQucmVtLnB1c2gobm9kZS5kYXRhKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBnZW5lcmF0ZSBuZXcgdHJlZSBzdHJ1Y3R1cmVcbiAgICAgIHRoaXMudmFsdWUgPSB0cmVlID0gaGllcmFyY2h5KHtcbiAgICAgICAgdmFsdWVzOiBhcnJheShfLmtleXMpLnJlZHVjZSgobiwgaykgPT4ge1xuICAgICAgICAgIG4ua2V5KGspO1xuICAgICAgICAgIHJldHVybiBuO1xuICAgICAgICB9LCBuZXN0KCkpLmVudHJpZXMob3V0LnNvdXJjZSlcbiAgICAgIH0sIGNoaWxkcmVuKTtcblxuICAgICAgLy8gY29sbGVjdCBub2RlcyB0byBhZGRcbiAgICAgIGlmIChnZW4pIHtcbiAgICAgICAgdHJlZS5lYWNoKG5vZGUgPT4ge1xuICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBub2RlID0gaW5nZXN0KG5vZGUuZGF0YSk7XG4gICAgICAgICAgICBvdXQuYWRkLnB1c2gobm9kZSk7XG4gICAgICAgICAgICBvdXQuc291cmNlLnB1c2gobm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gYnVpbGQgbG9va3VwIHRhYmxlXG4gICAgICBsb29rdXAodHJlZSwgdHVwbGVpZCwgdHVwbGVpZCk7XG4gICAgfVxuICAgIG91dC5zb3VyY2Uucm9vdCA9IHRyZWU7XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufSk7XG5mdW5jdGlvbiBuZXN0KCkge1xuICBjb25zdCBrZXlzID0gW10sXG4gICAgbmVzdCA9IHtcbiAgICAgIGVudHJpZXM6IGFycmF5ID0+IGVudHJpZXMoYXBwbHkoYXJyYXksIDApLCAwKSxcbiAgICAgIGtleTogZCA9PiAoa2V5cy5wdXNoKGQpLCBuZXN0KVxuICAgIH07XG4gIGZ1bmN0aW9uIGFwcGx5KGFycmF5LCBkZXB0aCkge1xuICAgIGlmIChkZXB0aCA+PSBrZXlzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBjb25zdCBuID0gYXJyYXkubGVuZ3RoLFxuICAgICAga2V5ID0ga2V5c1tkZXB0aCsrXSxcbiAgICAgIHZhbHVlc0J5S2V5ID0ge30sXG4gICAgICByZXN1bHQgPSB7fTtcbiAgICBsZXQgaSA9IC0xLFxuICAgICAga2V5VmFsdWUsXG4gICAgICB2YWx1ZSxcbiAgICAgIHZhbHVlcztcbiAgICB3aGlsZSAoKytpIDwgbikge1xuICAgICAga2V5VmFsdWUgPSBrZXkodmFsdWUgPSBhcnJheVtpXSkgKyAnJztcbiAgICAgIGlmICh2YWx1ZXMgPSB2YWx1ZXNCeUtleVtrZXlWYWx1ZV0pIHtcbiAgICAgICAgdmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWVzQnlLZXlba2V5VmFsdWVdID0gW3ZhbHVlXTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrZXlWYWx1ZSBpbiB2YWx1ZXNCeUtleSkge1xuICAgICAgcmVzdWx0W2tleVZhbHVlXSA9IGFwcGx5KHZhbHVlc0J5S2V5W2tleVZhbHVlXSwgZGVwdGgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGZ1bmN0aW9uIGVudHJpZXMobWFwLCBkZXB0aCkge1xuICAgIGlmICgrK2RlcHRoID4ga2V5cy5sZW5ndGgpIHJldHVybiBtYXA7XG4gICAgY29uc3QgYXJyYXkgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBtYXApIHtcbiAgICAgIGFycmF5LnB1c2goe1xuICAgICAgICBrZXksXG4gICAgICAgIHZhbHVlczogZW50cmllcyhtYXBba2V5XSwgZGVwdGgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG4gIHJldHVybiBuZXN0O1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciB0cmVlIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICovXG5mdW5jdGlvbiBIaWVyYXJjaHlMYXlvdXQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5jb25zdCBkZWZhdWx0U2VwYXJhdGlvbiA9IChhLCBiKSA9PiBhLnBhcmVudCA9PT0gYi5wYXJlbnQgPyAxIDogMjtcbmluaGVyaXRzKEhpZXJhcmNoeUxheW91dCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICghcHVsc2Uuc291cmNlIHx8ICFwdWxzZS5zb3VyY2Uucm9vdCkge1xuICAgICAgZXJyb3IodGhpcy5jb25zdHJ1Y3Rvci5uYW1lICsgJyB0cmFuc2Zvcm0gcmVxdWlyZXMgYSBiYWNraW5nIHRyZWUgZGF0YSBzb3VyY2UuJyk7XG4gICAgfVxuICAgIGNvbnN0IGxheW91dCA9IHRoaXMubGF5b3V0KF8ubWV0aG9kKSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzLFxuICAgICAgcm9vdCA9IHB1bHNlLnNvdXJjZS5yb290LFxuICAgICAgYXMgPSBfLmFzIHx8IGZpZWxkcztcbiAgICBpZiAoXy5maWVsZCkgcm9vdC5zdW0oXy5maWVsZCk7ZWxzZSByb290LmNvdW50KCk7XG4gICAgaWYgKF8uc29ydCkgcm9vdC5zb3J0KHN0YWJsZUNvbXBhcmUoXy5zb3J0LCBkID0+IGQuZGF0YSkpO1xuICAgIHNldFBhcmFtcyhsYXlvdXQsIHRoaXMucGFyYW1zLCBfKTtcbiAgICBpZiAobGF5b3V0LnNlcGFyYXRpb24pIHtcbiAgICAgIGxheW91dC5zZXBhcmF0aW9uKF8uc2VwYXJhdGlvbiAhPT0gZmFsc2UgPyBkZWZhdWx0U2VwYXJhdGlvbiA6IG9uZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLnZhbHVlID0gbGF5b3V0KHJvb3QpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgZXJyb3IoZXJyKTtcbiAgICB9XG4gICAgcm9vdC5lYWNoKG5vZGUgPT4gc2V0RmllbGRzKG5vZGUsIGZpZWxkcywgYXMpKTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpLm1vZGlmaWVzKCdsZWFmJyk7XG4gIH1cbn0pO1xuZnVuY3Rpb24gc2V0UGFyYW1zKGxheW91dCwgcGFyYW1zLCBfKSB7XG4gIGZvciAobGV0IHAsIGkgPSAwLCBuID0gcGFyYW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBwYXJhbXNbaV07XG4gICAgaWYgKHAgaW4gXykgbGF5b3V0W3BdKF9bcF0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRGaWVsZHMobm9kZSwgZmllbGRzLCBhcykge1xuICBjb25zdCB0ID0gbm9kZS5kYXRhLFxuICAgIG4gPSBmaWVsZHMubGVuZ3RoIC0gMTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICB0W2FzW2ldXSA9IG5vZGVbZmllbGRzW2ldXTtcbiAgfVxuICB0W2FzW25dXSA9IG5vZGUuY2hpbGRyZW4gPyBub2RlLmNoaWxkcmVuLmxlbmd0aCA6IDA7XG59XG5cbmNvbnN0IE91dHB1dCQzID0gWyd4JywgJ3knLCAncicsICdkZXB0aCcsICdjaGlsZHJlbiddO1xuXG4vKipcbiAqIFBhY2tlZCBjaXJjbGUgdHJlZSBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIHNpemUgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIFBhY2socGFyYW1zKSB7XG4gIEhpZXJhcmNoeUxheW91dC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5QYWNrLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1BhY2snLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3RyZWUnOiB0cnVlLFxuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmcnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyYWRpdXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnZGVmYXVsdCc6IG51bGxcbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogT3V0cHV0JDMubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0JDNcbiAgfV1cbn07XG5pbmhlcml0cyhQYWNrLCBIaWVyYXJjaHlMYXlvdXQsIHtcbiAgbGF5b3V0OiBwYWNrLFxuICBwYXJhbXM6IFsncmFkaXVzJywgJ3NpemUnLCAncGFkZGluZyddLFxuICBmaWVsZHM6IE91dHB1dCQzXG59KTtcblxuY29uc3QgT3V0cHV0JDIgPSBbJ3gwJywgJ3kwJywgJ3gxJywgJ3kxJywgJ2RlcHRoJywgJ2NoaWxkcmVuJ107XG5cbi8qKlxuICogUGFydGl0aW9uIHRyZWUgbGF5b3V0LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBzaXplIG5vZGVzLlxuICovXG5mdW5jdGlvbiBQYXJ0aXRpb24ocGFyYW1zKSB7XG4gIEhpZXJhcmNoeUxheW91dC5jYWxsKHRoaXMsIHBhcmFtcyk7XG59XG5QYXJ0aXRpb24uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUGFydGl0aW9uJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICd0cmVlJzogdHJ1ZSxcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3NvcnQnLFxuICAgICd0eXBlJzogJ2NvbXBhcmUnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncm91bmQnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ3NpemUnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogT3V0cHV0JDIubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0JDJcbiAgfV1cbn07XG5pbmhlcml0cyhQYXJ0aXRpb24sIEhpZXJhcmNoeUxheW91dCwge1xuICBsYXlvdXQ6IHBhcnRpdGlvbixcbiAgcGFyYW1zOiBbJ3NpemUnLCAncm91bmQnLCAncGFkZGluZyddLFxuICBmaWVsZHM6IE91dHB1dCQyXG59KTtcblxuLyoqXG4gKiBTdHJhdGlmeSBhIGNvbGxlY3Rpb24gb2YgdHVwbGVzIGludG8gYSB0cmVlIHN0cnVjdHVyZSBiYXNlZCBvblxuICogaWQgYW5kIHBhcmVudCBpZCBmaWVsZHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmtleSAtIFVuaXF1ZSBrZXkgZmllbGQgZm9yIGVhY2ggdHVwbGUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5wYXJlbnRLZXkgLSBGaWVsZCB3aXRoIGtleSBmb3IgcGFyZW50IHR1cGxlLlxuICovXG5mdW5jdGlvbiBTdHJhdGlmeShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblN0cmF0aWZ5LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ1N0cmF0aWZ5JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICd0cmVlc291cmNlJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYXJlbnRLZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoU3RyYXRpZnksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAoIXB1bHNlLnNvdXJjZSkge1xuICAgICAgZXJyb3IoJ1N0cmF0aWZ5IHRyYW5zZm9ybSByZXF1aXJlcyBhbiB1cHN0cmVhbSBkYXRhIHNvdXJjZS4nKTtcbiAgICB9XG4gICAgbGV0IHRyZWUgPSB0aGlzLnZhbHVlO1xuICAgIGNvbnN0IG1vZCA9IF8ubW9kaWZpZWQoKSxcbiAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLFxuICAgICAgcnVuID0gIXRyZWUgfHwgbW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgcHVsc2UubW9kaWZpZWQoXy5rZXkuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZChfLnBhcmVudEtleS5maWVsZHMpO1xuXG4gICAgLy8gcHJldmVudCB1cHN0cmVhbSBzb3VyY2UgcG9sbHV0aW9uXG4gICAgb3V0LnNvdXJjZSA9IG91dC5zb3VyY2Uuc2xpY2UoKTtcbiAgICBpZiAocnVuKSB7XG4gICAgICB0cmVlID0gb3V0LnNvdXJjZS5sZW5ndGggPyBsb29rdXAoc3RyYXRpZnkoKS5pZChfLmtleSkucGFyZW50SWQoXy5wYXJlbnRLZXkpKG91dC5zb3VyY2UpLCBfLmtleSwgdHJ1dGh5KSA6IGxvb2t1cChzdHJhdGlmeSgpKFt7fV0pLCBfLmtleSwgXy5rZXkpO1xuICAgIH1cbiAgICBvdXQuc291cmNlLnJvb3QgPSB0aGlzLnZhbHVlID0gdHJlZTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59KTtcblxuY29uc3QgTGF5b3V0cyA9IHtcbiAgdGlkeTogdHJlZSxcbiAgY2x1c3RlcjogY2x1c3RlclxufTtcbmNvbnN0IE91dHB1dCQxID0gWyd4JywgJ3knLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcblxuLyoqXG4gKiBUcmVlIGxheW91dC4gRGVwZW5kaW5nIG9uIHRoZSBtZXRob2QgcGFyYW1ldGVyLCBwZXJmb3JtcyBlaXRoZXJcbiAqIFJlaW5nb2xkLVRpbGZvcmQgJ3RpZHknIGxheW91dCBvciBkZW5kcm9ncmFtICdjbHVzdGVyJyBsYXlvdXQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gVHJlZShwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblRyZWUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnVHJlZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICd0aWR5JyxcbiAgICAndmFsdWVzJzogWyd0aWR5JywgJ2NsdXN0ZXInXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdub2RlU2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzZXBhcmF0aW9uJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IE91dHB1dCQxLmxlbmd0aCxcbiAgICAnZGVmYXVsdCc6IE91dHB1dCQxXG4gIH1dXG59O1xuaW5oZXJpdHMoVHJlZSwgSGllcmFyY2h5TGF5b3V0LCB7XG4gIC8qKlxuICAgKiBUcmVlIGxheW91dCBnZW5lcmF0b3IuIFN1cHBvcnRzIGJvdGggJ3RpZHknIGFuZCAnY2x1c3RlcicgbGF5b3V0cy5cbiAgICovXG4gIGxheW91dChtZXRob2QpIHtcbiAgICBjb25zdCBtID0gbWV0aG9kIHx8ICd0aWR5JztcbiAgICBpZiAoaGFzT3duUHJvcGVydHkoTGF5b3V0cywgbSkpIHJldHVybiBMYXlvdXRzW21dKCk7ZWxzZSBlcnJvcignVW5yZWNvZ25pemVkIFRyZWUgbGF5b3V0IG1ldGhvZDogJyArIG0pO1xuICB9LFxuICBwYXJhbXM6IFsnc2l6ZScsICdub2RlU2l6ZSddLFxuICBmaWVsZHM6IE91dHB1dCQxXG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZSB0dXBsZXMgcmVwcmVzZW50aW5nIGxpbmtzIGJldHdlZW4gdHJlZSBub2Rlcy5cbiAqIFRoZSByZXN1bHRpbmcgdHVwbGVzIHdpbGwgY29udGFpbiAnc291cmNlJyBhbmQgJ3RhcmdldCcgZmllbGRzLFxuICogd2hpY2ggcG9pbnQgdG8gcGFyZW50IGFuZCBjaGlsZCBub2RlIHR1cGxlcywgcmVzcGVjdGl2ZWx5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIFRyZWVMaW5rcyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5UcmVlTGlua3MuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnVHJlZUxpbmtzJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICd0cmVlJzogdHJ1ZSxcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFtdXG59O1xuaW5oZXJpdHMoVHJlZUxpbmtzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgbGlua3MgPSB0aGlzLnZhbHVlLFxuICAgICAgdHJlZSA9IHB1bHNlLnNvdXJjZSAmJiBwdWxzZS5zb3VyY2Uucm9vdCxcbiAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgIGx1dCA9IHt9O1xuICAgIGlmICghdHJlZSkgZXJyb3IoJ1RyZWVMaW5rcyB0cmFuc2Zvcm0gcmVxdWlyZXMgYSB0cmVlIGRhdGEgc291cmNlLicpO1xuICAgIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLkFERF9SRU0pKSB7XG4gICAgICAvLyByZW1vdmUgcHJldmlvdXMgbGlua3NcbiAgICAgIG91dC5yZW0gPSBsaW5rcztcblxuICAgICAgLy8gYnVpbGQgbG9va3VwIHRhYmxlIG9mIHZhbGlkIHR1cGxlc1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IGx1dFt0dXBsZWlkKHQpXSA9IDEpO1xuXG4gICAgICAvLyBnZW5lcmF0ZSBsaW5rcyBmb3IgYWxsIGVkZ2VzIGluY2lkZW50IG9uIHZhbGlkIHR1cGxlc1xuICAgICAgdHJlZS5lYWNoKG5vZGUgPT4ge1xuICAgICAgICBjb25zdCB0ID0gbm9kZS5kYXRhLFxuICAgICAgICAgIHAgPSBub2RlLnBhcmVudCAmJiBub2RlLnBhcmVudC5kYXRhO1xuICAgICAgICBpZiAocCAmJiBsdXRbdHVwbGVpZCh0KV0gJiYgbHV0W3R1cGxlaWQocCldKSB7XG4gICAgICAgICAgb3V0LmFkZC5wdXNoKGluZ2VzdCh7XG4gICAgICAgICAgICBzb3VyY2U6IHAsXG4gICAgICAgICAgICB0YXJnZXQ6IHRcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQ7XG4gICAgfSBlbHNlIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLk1PRCkpIHtcbiAgICAgIC8vIGJ1aWxkIGxvb2t1cCB0YWJsZSBvZiBtb2RpZmllZCB0dXBsZXNcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiBsdXRbdHVwbGVpZCh0KV0gPSAxKTtcblxuICAgICAgLy8gZ2F0aGVyIGxpbmtzIGluY2lkZW50IG9uIG1vZGlmaWVkIHR1cGxlc1xuICAgICAgbGlua3MuZm9yRWFjaChsaW5rID0+IHtcbiAgICAgICAgaWYgKGx1dFt0dXBsZWlkKGxpbmsuc291cmNlKV0gfHwgbHV0W3R1cGxlaWQobGluay50YXJnZXQpXSkge1xuICAgICAgICAgIG91dC5tb2QucHVzaChsaW5rKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG5jb25zdCBUaWxlcyA9IHtcbiAgYmluYXJ5OiB0cmVlbWFwQmluYXJ5LFxuICBkaWNlOiB0cmVlbWFwRGljZSxcbiAgc2xpY2U6IHRyZWVtYXBTbGljZSxcbiAgc2xpY2VkaWNlOiB0cmVlbWFwU2xpY2VEaWNlLFxuICBzcXVhcmlmeTogdHJlZW1hcFNxdWFyaWZ5LFxuICByZXNxdWFyaWZ5OiB0cmVlbWFwUmVzcXVhcmlmeVxufTtcbmNvbnN0IE91dHB1dCA9IFsneDAnLCAneTAnLCAneDEnLCAneTEnLCAnZGVwdGgnLCAnY2hpbGRyZW4nXTtcblxuLyoqXG4gKiBUcmVlbWFwIGxheW91dC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgdmFsdWUgZmllbGQgdG8gc2l6ZSBub2Rlcy5cbiAqL1xuZnVuY3Rpb24gVHJlZW1hcChwYXJhbXMpIHtcbiAgSGllcmFyY2h5TGF5b3V0LmNhbGwodGhpcywgcGFyYW1zKTtcbn1cblRyZWVtYXAuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnVHJlZW1hcCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAndHJlZSc6IHRydWUsXG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzb3J0JyxcbiAgICAndHlwZSc6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICdzcXVhcmlmeScsXG4gICAgJ3ZhbHVlcyc6IFsnc3F1YXJpZnknLCAncmVzcXVhcmlmeScsICdiaW5hcnknLCAnZGljZScsICdzbGljZScsICdzbGljZWRpY2UnXVxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdJbm5lcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdPdXRlcicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ3BhZGRpbmdUb3AnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nUmlnaHQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nQm90dG9tJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFkZGluZ0xlZnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyYXRpbycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDEuNjE4MDMzOTg4NzQ5ODk1XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdyb3VuZCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiBPdXRwdXQubGVuZ3RoLFxuICAgICdkZWZhdWx0JzogT3V0cHV0XG4gIH1dXG59O1xuaW5oZXJpdHMoVHJlZW1hcCwgSGllcmFyY2h5TGF5b3V0LCB7XG4gIC8qKlxuICAgKiBUcmVlbWFwIGxheW91dCBnZW5lcmF0b3IuIEFkZHMgJ21ldGhvZCcgYW5kICdyYXRpbycgcGFyYW1ldGVyc1xuICAgKiB0byBjb25maWd1cmUgdGhlIHVuZGVybHlpbmcgdGlsZSBtZXRob2QuXG4gICAqL1xuICBsYXlvdXQoKSB7XG4gICAgY29uc3QgeCA9IHRyZWVtYXAoKTtcbiAgICB4LnJhdGlvID0gXyA9PiB7XG4gICAgICBjb25zdCB0ID0geC50aWxlKCk7XG4gICAgICBpZiAodC5yYXRpbykgeC50aWxlKHQucmF0aW8oXykpO1xuICAgIH07XG4gICAgeC5tZXRob2QgPSBfID0+IHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eShUaWxlcywgXykpIHgudGlsZShUaWxlc1tfXSk7ZWxzZSBlcnJvcignVW5yZWNvZ25pemVkIFRyZWVtYXAgbGF5b3V0IG1ldGhvZDogJyArIF8pO1xuICAgIH07XG4gICAgcmV0dXJuIHg7XG4gIH0sXG4gIHBhcmFtczogWydtZXRob2QnLCAncmF0aW8nLCAnc2l6ZScsICdyb3VuZCcsICdwYWRkaW5nJywgJ3BhZGRpbmdJbm5lcicsICdwYWRkaW5nT3V0ZXInLCAncGFkZGluZ1RvcCcsICdwYWRkaW5nUmlnaHQnLCAncGFkZGluZ0JvdHRvbScsICdwYWRkaW5nTGVmdCddLFxuICBmaWVsZHM6IE91dHB1dFxufSk7XG5cbmV4cG9ydCB7IE5lc3QgYXMgbmVzdCwgUGFjayBhcyBwYWNrLCBQYXJ0aXRpb24gYXMgcGFydGl0aW9uLCBTdHJhdGlmeSBhcyBzdHJhdGlmeSwgVHJlZSBhcyB0cmVlLCBUcmVlTGlua3MgYXMgdHJlZWxpbmtzLCBUcmVlbWFwIGFzIHRyZWVtYXAgfTtcbiIsImltcG9ydCB7IE1hcmtzLCB0ZXh0TWV0cmljcyB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBjYW52YXMgfSBmcm9tICd2ZWdhLWNhbnZhcyc7XG5pbXBvcnQgeyByZWRlcml2ZSwgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBpbmhlcml0cywgZXJyb3IsIGFycmF5LCBpc0Z1bmN0aW9uIH0gZnJvbSAndmVnYS11dGlsJztcblxuLy8gYml0IG1hc2sgZm9yIGdldHRpbmcgZmlyc3QgMiBieXRlcyBvZiBhbHBoYSB2YWx1ZVxuY29uc3QgQUxQSEFfTUFTSyA9IDB4ZmYwMDAwMDA7XG5mdW5jdGlvbiBiYXNlQml0bWFwcygkLCBkYXRhKSB7XG4gIGNvbnN0IGJpdG1hcCA9ICQuYml0bWFwKCk7XG4gIC8vIHdoZW4gdGhlcmUgaXMgbm8gYmFzZSBtYXJrIGJ1dCBkYXRhIHBvaW50cyBhcmUgdG8gYmUgYXZvaWRlZFxuICAoZGF0YSB8fCBbXSkuZm9yRWFjaChkID0+IGJpdG1hcC5zZXQoJChkLmJvdW5kYXJ5WzBdKSwgJChkLmJvdW5kYXJ5WzNdKSkpO1xuICByZXR1cm4gW2JpdG1hcCwgdW5kZWZpbmVkXTtcbn1cbmZ1bmN0aW9uIG1hcmtCaXRtYXBzKCQsIGJhc2VNYXJrLCBhdm9pZE1hcmtzLCBsYWJlbEluc2lkZSwgaXNHcm91cEFyZWEpIHtcbiAgLy8gY3JlYXRlIGNhbnZhc1xuICBjb25zdCB3aWR0aCA9ICQud2lkdGgsXG4gICAgaGVpZ2h0ID0gJC5oZWlnaHQsXG4gICAgYm9yZGVyID0gbGFiZWxJbnNpZGUgfHwgaXNHcm91cEFyZWEsXG4gICAgY29udGV4dCA9IGNhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpLFxuICAgIGJhc2VNYXJrQ29udGV4dCA9IGNhbnZhcyh3aWR0aCwgaGVpZ2h0KS5nZXRDb250ZXh0KCcyZCcpLFxuICAgIHN0cm9rZUNvbnRleHQgPSBib3JkZXIgJiYgY2FudmFzKHdpZHRoLCBoZWlnaHQpLmdldENvbnRleHQoJzJkJyk7XG5cbiAgLy8gcmVuZGVyIGFsbCBtYXJrcyB0byBiZSBhdm9pZGVkIGludG8gY2FudmFzXG4gIGF2b2lkTWFya3MuZm9yRWFjaChpdGVtcyA9PiBkcmF3KGNvbnRleHQsIGl0ZW1zLCBmYWxzZSkpO1xuICBkcmF3KGJhc2VNYXJrQ29udGV4dCwgYmFzZU1hcmssIGZhbHNlKTtcbiAgaWYgKGJvcmRlcikge1xuICAgIGRyYXcoc3Ryb2tlQ29udGV4dCwgYmFzZU1hcmssIHRydWUpO1xuICB9XG5cbiAgLy8gZ2V0IGNhbnZhcyBidWZmZXIsIGNyZWF0ZSBiaXRtYXBzXG4gIGNvbnN0IGJ1ZmZlciA9IGdldEJ1ZmZlcihjb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSxcbiAgICBiYXNlTWFya0J1ZmZlciA9IGdldEJ1ZmZlcihiYXNlTWFya0NvbnRleHQsIHdpZHRoLCBoZWlnaHQpLFxuICAgIHN0cm9rZUJ1ZmZlciA9IGJvcmRlciAmJiBnZXRCdWZmZXIoc3Ryb2tlQ29udGV4dCwgd2lkdGgsIGhlaWdodCksXG4gICAgbGF5ZXIxID0gJC5iaXRtYXAoKSxcbiAgICBsYXllcjIgPSBib3JkZXIgJiYgJC5iaXRtYXAoKTtcblxuICAvLyBwb3B1bGF0ZSBiaXRtYXAgbGF5ZXJzXG4gIGxldCB4LCB5LCB1LCB2LCBpbmRleCwgYWxwaGEsIHN0cm9rZUFscGhhLCBiYXNlTWFya0FscGhhO1xuICBmb3IgKHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICBmb3IgKHggPSAwOyB4IDwgd2lkdGg7ICsreCkge1xuICAgICAgaW5kZXggPSB5ICogd2lkdGggKyB4O1xuICAgICAgYWxwaGEgPSBidWZmZXJbaW5kZXhdICYgQUxQSEFfTUFTSztcbiAgICAgIGJhc2VNYXJrQWxwaGEgPSBiYXNlTWFya0J1ZmZlcltpbmRleF0gJiBBTFBIQV9NQVNLO1xuICAgICAgc3Ryb2tlQWxwaGEgPSBib3JkZXIgJiYgc3Ryb2tlQnVmZmVyW2luZGV4XSAmIEFMUEhBX01BU0s7XG4gICAgICBpZiAoYWxwaGEgfHwgc3Ryb2tlQWxwaGEgfHwgYmFzZU1hcmtBbHBoYSkge1xuICAgICAgICB1ID0gJCh4KTtcbiAgICAgICAgdiA9ICQoeSk7XG4gICAgICAgIGlmICghaXNHcm91cEFyZWEgJiYgKGFscGhhIHx8IGJhc2VNYXJrQWxwaGEpKSBsYXllcjEuc2V0KHUsIHYpOyAvLyB1cGRhdGUgaW50ZXJpb3IgYml0bWFwXG4gICAgICAgIGlmIChib3JkZXIgJiYgKGFscGhhIHx8IHN0cm9rZUFscGhhKSkgbGF5ZXIyLnNldCh1LCB2KTsgLy8gdXBkYXRlIGJvcmRlciBiaXRtYXBcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtsYXllcjEsIGxheWVyMl07XG59XG5mdW5jdGlvbiBnZXRCdWZmZXIoY29udGV4dCwgd2lkdGgsIGhlaWdodCkge1xuICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLmRhdGEuYnVmZmVyKTtcbn1cbmZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbXMsIGludGVyaW9yKSB7XG4gIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm47XG4gIGNvbnN0IHR5cGUgPSBpdGVtc1swXS5tYXJrLm1hcmt0eXBlO1xuICBpZiAodHlwZSA9PT0gJ2dyb3VwJykge1xuICAgIGl0ZW1zLmZvckVhY2goZ3JvdXAgPT4ge1xuICAgICAgZ3JvdXAuaXRlbXMuZm9yRWFjaChtYXJrID0+IGRyYXcoY29udGV4dCwgbWFyay5pdGVtcywgaW50ZXJpb3IpKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBNYXJrc1t0eXBlXS5kcmF3KGNvbnRleHQsIHtcbiAgICAgIGl0ZW1zOiBpbnRlcmlvciA/IGl0ZW1zLm1hcChwcmVwYXJlKSA6IGl0ZW1zXG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQcmVwYXJlIGl0ZW0gYmVmb3JlIGRyYXdpbmcgaW50byBjYW52YXMgKHNldHRpbmcgc3Ryb2tlIGFuZCBvcGFjaXR5KVxuICogQHBhcmFtIHtvYmplY3R9IHNvdXJjZSBpdGVtIHRvIGJlIHByZXBhcmVkXG4gKiBAcmV0dXJucyBwcmVwYXJlZCBpdGVtXG4gKi9cbmZ1bmN0aW9uIHByZXBhcmUoc291cmNlKSB7XG4gIGNvbnN0IGl0ZW0gPSByZWRlcml2ZShzb3VyY2UsIHt9KTtcbiAgaWYgKGl0ZW0uc3Ryb2tlICYmIGl0ZW0uc3Ryb2tlT3BhY2l0eSAhPT0gMCB8fCBpdGVtLmZpbGwgJiYgaXRlbS5maWxsT3BhY2l0eSAhPT0gMCkge1xuICAgIHJldHVybiB7XG4gICAgICAuLi5pdGVtLFxuICAgICAgc3Ryb2tlT3BhY2l0eTogMSxcbiAgICAgIHN0cm9rZTogJyMwMDAnLFxuICAgICAgZmlsbE9wYWNpdHk6IDBcbiAgICB9O1xuICB9XG4gIHJldHVybiBpdGVtO1xufVxuXG5jb25zdCBESVYgPSA1LFxuICAvLyBiaXQgc2hpZnQgZnJvbSB4LCB5IGluZGV4IHRvIGJpdCB2ZWN0b3IgYXJyYXkgaW5kZXhcbiAgTU9EID0gMzEsXG4gIC8vIGJpdCBtYXNrIGZvciBpbmRleCBsb29rdXAgd2l0aGluIGEgYml0IHZlY3RvclxuICBTSVpFID0gMzIsXG4gIC8vIGluZGl2aWR1YWwgYml0IHZlY3RvciBzaXplXG4gIFJJR0hUMCA9IG5ldyBVaW50MzJBcnJheShTSVpFICsgMSksXG4gIC8vIGxlZnQtYW5jaG9yZWQgYml0IHZlY3RvcnMsIGZ1bGwgLT4gMFxuICBSSUdIVDEgPSBuZXcgVWludDMyQXJyYXkoU0laRSArIDEpOyAvLyByaWdodC1hbmNob3JlZCBiaXQgdmVjdG9ycywgMCAtPiBmdWxsXG5cblJJR0hUMVswXSA9IDA7XG5SSUdIVDBbMF0gPSB+UklHSFQxWzBdO1xuZm9yIChsZXQgaSA9IDE7IGkgPD0gU0laRTsgKytpKSB7XG4gIFJJR0hUMVtpXSA9IFJJR0hUMVtpIC0gMV0gPDwgMSB8IDE7XG4gIFJJR0hUMFtpXSA9IH5SSUdIVDFbaV07XG59XG5mdW5jdGlvbiBCaXRtYXAgKHcsIGgpIHtcbiAgY29uc3QgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkofn4oKHcgKiBoICsgU0laRSkgLyBTSVpFKSk7XG4gIGZ1bmN0aW9uIF9zZXQoaW5kZXgsIG1hc2spIHtcbiAgICBhcnJheVtpbmRleF0gfD0gbWFzaztcbiAgfVxuICBmdW5jdGlvbiBfY2xlYXIoaW5kZXgsIG1hc2spIHtcbiAgICBhcnJheVtpbmRleF0gJj0gbWFzaztcbiAgfVxuICByZXR1cm4ge1xuICAgIGFycmF5OiBhcnJheSxcbiAgICBnZXQ6ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHkgKiB3ICsgeDtcbiAgICAgIHJldHVybiBhcnJheVtpbmRleCA+Pj4gRElWXSAmIDEgPDwgKGluZGV4ICYgTU9EKTtcbiAgICB9LFxuICAgIHNldDogKHgsIHkpID0+IHtcbiAgICAgIGNvbnN0IGluZGV4ID0geSAqIHcgKyB4O1xuICAgICAgX3NldChpbmRleCA+Pj4gRElWLCAxIDw8IChpbmRleCAmIE1PRCkpO1xuICAgIH0sXG4gICAgY2xlYXI6ICh4LCB5KSA9PiB7XG4gICAgICBjb25zdCBpbmRleCA9IHkgKiB3ICsgeDtcbiAgICAgIF9jbGVhcihpbmRleCA+Pj4gRElWLCB+KDEgPDwgKGluZGV4ICYgTU9EKSkpO1xuICAgIH0sXG4gICAgZ2V0UmFuZ2U6ICh4LCB5LCB4MiwgeTIpID0+IHtcbiAgICAgIGxldCByID0geTIsXG4gICAgICAgIHN0YXJ0LFxuICAgICAgICBlbmQsXG4gICAgICAgIGluZGV4U3RhcnQsXG4gICAgICAgIGluZGV4RW5kO1xuICAgICAgZm9yICg7IHIgPj0geTsgLS1yKSB7XG4gICAgICAgIHN0YXJ0ID0gciAqIHcgKyB4O1xuICAgICAgICBlbmQgPSByICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcbiAgICAgICAgaWYgKGluZGV4U3RhcnQgPT09IGluZGV4RW5kKSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4U3RhcnRdICYgUklHSFQwW3N0YXJ0ICYgTU9EXSAmIFJJR0hUMVsoZW5kICYgTU9EKSArIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4U3RhcnRdICYgUklHSFQwW3N0YXJ0ICYgTU9EXSkgcmV0dXJuIHRydWU7XG4gICAgICAgICAgaWYgKGFycmF5W2luZGV4RW5kXSAmIFJJR0hUMVsoZW5kICYgTU9EKSArIDFdKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gaW5kZXhTdGFydCArIDE7IGkgPCBpbmRleEVuZDsgKytpKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0pIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgc2V0UmFuZ2U6ICh4LCB5LCB4MiwgeTIpID0+IHtcbiAgICAgIGxldCBzdGFydCwgZW5kLCBpbmRleFN0YXJ0LCBpbmRleEVuZCwgaTtcbiAgICAgIGZvciAoOyB5IDw9IHkyOyArK3kpIHtcbiAgICAgICAgc3RhcnQgPSB5ICogdyArIHg7XG4gICAgICAgIGVuZCA9IHkgKiB3ICsgeDI7XG4gICAgICAgIGluZGV4U3RhcnQgPSBzdGFydCA+Pj4gRElWO1xuICAgICAgICBpbmRleEVuZCA9IGVuZCA+Pj4gRElWO1xuICAgICAgICBpZiAoaW5kZXhTdGFydCA9PT0gaW5kZXhFbmQpIHtcbiAgICAgICAgICBfc2V0KGluZGV4U3RhcnQsIFJJR0hUMFtzdGFydCAmIE1PRF0gJiBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX3NldChpbmRleFN0YXJ0LCBSSUdIVDBbc3RhcnQgJiBNT0RdKTtcbiAgICAgICAgICBfc2V0KGluZGV4RW5kLCBSSUdIVDFbKGVuZCAmIE1PRCkgKyAxXSk7XG4gICAgICAgICAgZm9yIChpID0gaW5kZXhTdGFydCArIDE7IGkgPCBpbmRleEVuZDsgKytpKSBfc2V0KGksIDB4ZmZmZmZmZmYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjbGVhclJhbmdlOiAoeCwgeSwgeDIsIHkyKSA9PiB7XG4gICAgICBsZXQgc3RhcnQsIGVuZCwgaW5kZXhTdGFydCwgaW5kZXhFbmQsIGk7XG4gICAgICBmb3IgKDsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICAgIHN0YXJ0ID0geSAqIHcgKyB4O1xuICAgICAgICBlbmQgPSB5ICogdyArIHgyO1xuICAgICAgICBpbmRleFN0YXJ0ID0gc3RhcnQgPj4+IERJVjtcbiAgICAgICAgaW5kZXhFbmQgPSBlbmQgPj4+IERJVjtcbiAgICAgICAgaWYgKGluZGV4U3RhcnQgPT09IGluZGV4RW5kKSB7XG4gICAgICAgICAgX2NsZWFyKGluZGV4U3RhcnQsIFJJR0hUMVtzdGFydCAmIE1PRF0gfCBSSUdIVDBbKGVuZCAmIE1PRCkgKyAxXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2NsZWFyKGluZGV4U3RhcnQsIFJJR0hUMVtzdGFydCAmIE1PRF0pO1xuICAgICAgICAgIF9jbGVhcihpbmRleEVuZCwgUklHSFQwWyhlbmQgJiBNT0QpICsgMV0pO1xuICAgICAgICAgIGZvciAoaSA9IGluZGV4U3RhcnQgKyAxOyBpIDwgaW5kZXhFbmQ7ICsraSkgX2NsZWFyKGksIDApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBvdXRPZkJvdW5kczogKHgsIHksIHgyLCB5MikgPT4geCA8IDAgfHwgeSA8IDAgfHwgeTIgPj0gaCB8fCB4MiA+PSB3XG4gIH07XG59XG5cbmZ1bmN0aW9uIHNjYWxlciAod2lkdGgsIGhlaWdodCwgcGFkZGluZykge1xuICBjb25zdCByYXRpbyA9IE1hdGgubWF4KDEsIE1hdGguc3FydCh3aWR0aCAqIGhlaWdodCAvIDFlNikpLFxuICAgIHcgPSB+figod2lkdGggKyAyICogcGFkZGluZyArIHJhdGlvKSAvIHJhdGlvKSxcbiAgICBoID0gfn4oKGhlaWdodCArIDIgKiBwYWRkaW5nICsgcmF0aW8pIC8gcmF0aW8pLFxuICAgIHNjYWxlID0gXyA9PiB+figoXyArIHBhZGRpbmcpIC8gcmF0aW8pO1xuICBzY2FsZS5pbnZlcnQgPSBfID0+IF8gKiByYXRpbyAtIHBhZGRpbmc7XG4gIHNjYWxlLmJpdG1hcCA9ICgpID0+IEJpdG1hcCh3LCBoKTtcbiAgc2NhbGUucmF0aW8gPSByYXRpbztcbiAgc2NhbGUucGFkZGluZyA9IHBhZGRpbmc7XG4gIHNjYWxlLndpZHRoID0gd2lkdGg7XG4gIHNjYWxlLmhlaWdodCA9IGhlaWdodDtcbiAgcmV0dXJuIHNjYWxlO1xufVxuXG5mdW5jdGlvbiBwbGFjZUFyZWFMYWJlbE5haXZlICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgIGhlaWdodCA9ICQuaGVpZ2h0O1xuXG4gIC8vIHRyeSB0byBwbGFjZSBhIGxhYmVsIHdpdGhpbiBhbiBpbnB1dCBhcmVhIG1hcmtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgY29uc3QgaXRlbXMgPSBkLmRhdHVtLmRhdHVtLml0ZW1zW21hcmtJbmRleF0uaXRlbXMsXG4gICAgICAvLyBhcmVhIHBvaW50c1xuICAgICAgbiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgIC8vIG51bWJlciBvZiBwb2ludHNcbiAgICAgIHRleHRIZWlnaHQgPSBkLmRhdHVtLmZvbnRTaXplLFxuICAgICAgLy8gbGFiZWwgd2lkdGhcbiAgICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCk7IC8vIGxhYmVsIGhlaWdodFxuXG4gICAgbGV0IG1heEFyZWFXaWR0aCA9IDAsXG4gICAgICB4MSxcbiAgICAgIHgyLFxuICAgICAgeTEsXG4gICAgICB5MixcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgYXJlYVdpZHRoO1xuXG4gICAgLy8gZm9yIGVhY2ggYXJlYSBzYW1wbGUgcG9pbnRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgeDEgPSBpdGVtc1tpXS54O1xuICAgICAgeTEgPSBpdGVtc1tpXS55O1xuICAgICAgeDIgPSBpdGVtc1tpXS54MiA9PT0gdW5kZWZpbmVkID8geDEgOiBpdGVtc1tpXS54MjtcbiAgICAgIHkyID0gaXRlbXNbaV0ueTIgPT09IHVuZGVmaW5lZCA/IHkxIDogaXRlbXNbaV0ueTI7XG4gICAgICB4ID0gKHgxICsgeDIpIC8gMjtcbiAgICAgIHkgPSAoeTEgKyB5MikgLyAyO1xuICAgICAgYXJlYVdpZHRoID0gTWF0aC5hYnMoeDIgLSB4MSArIHkyIC0geTEpO1xuICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGgpIHtcbiAgICAgICAgbWF4QXJlYVdpZHRoID0gYXJlYVdpZHRoO1xuICAgICAgICBkLnggPSB4O1xuICAgICAgICBkLnkgPSB5O1xuICAgICAgfVxuICAgIH1cbiAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICB5ID0gdGV4dEhlaWdodCAvIDI7XG4gICAgeDEgPSBkLnggLSB4O1xuICAgIHgyID0gZC54ICsgeDtcbiAgICB5MSA9IGQueSAtIHk7XG4gICAgeTIgPSBkLnkgKyB5O1xuICAgIGQuYWxpZ24gPSAnY2VudGVyJztcbiAgICBpZiAoeDEgPCAwICYmIHgyIDw9IHdpZHRoKSB7XG4gICAgICBkLmFsaWduID0gJ2xlZnQnO1xuICAgIH0gZWxzZSBpZiAoMCA8PSB4MSAmJiB3aWR0aCA8IHgyKSB7XG4gICAgICBkLmFsaWduID0gJ3JpZ2h0JztcbiAgICB9XG4gICAgZC5iYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgIGlmICh5MSA8IDAgJiYgeTIgPD0gaGVpZ2h0KSB7XG4gICAgICBkLmJhc2VsaW5lID0gJ3RvcCc7XG4gICAgfSBlbHNlIGlmICgwIDw9IHkxICYmIGhlaWdodCA8IHkyKSB7XG4gICAgICBkLmJhc2VsaW5lID0gJ2JvdHRvbSc7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xufVxuXG5mdW5jdGlvbiBvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpIHtcbiAgbGV0IHIgPSB0ZXh0V2lkdGggLyAyO1xuICByZXR1cm4geCAtIHIgPCAwIHx8IHggKyByID4gd2lkdGggfHwgeSAtIChyID0gdGV4dEhlaWdodCAvIDIpIDwgMCB8fCB5ICsgciA+IGhlaWdodDtcbn1cbmZ1bmN0aW9uIGNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIGgsIGJtMCwgYm0xKSB7XG4gIGNvbnN0IHcgPSB0ZXh0V2lkdGggKiBoIC8gKHRleHRIZWlnaHQgKiAyKSxcbiAgICB4MSA9ICQoeCAtIHcpLFxuICAgIHgyID0gJCh4ICsgdyksXG4gICAgeTEgPSAkKHkgLSAoaCA9IGggLyAyKSksXG4gICAgeTIgPSAkKHkgKyBoKTtcbiAgcmV0dXJuIGJtMC5vdXRPZkJvdW5kcyh4MSwgeTEsIHgyLCB5MikgfHwgYm0wLmdldFJhbmdlKHgxLCB5MSwgeDIsIHkyKSB8fCBibTEgJiYgYm0xLmdldFJhbmdlKHgxLCB5MSwgeDIsIHkyKTtcbn1cblxuZnVuY3Rpb24gcGxhY2VBcmVhTGFiZWxSZWR1Y2VkU2VhcmNoICgkLCBiaXRtYXBzLCBhdm9pZEJhc2VNYXJrLCBtYXJrSW5kZXgpIHtcbiAgY29uc3Qgd2lkdGggPSAkLndpZHRoLFxuICAgIGhlaWdodCA9ICQuaGVpZ2h0LFxuICAgIGJtMCA9IGJpdG1hcHNbMF0sXG4gICAgLy8gd2hlcmUgbGFiZWxzIGhhdmUgYmVlbiBwbGFjZWRcbiAgICBibTEgPSBiaXRtYXBzWzFdOyAvLyBhcmVhIG91dGxpbmVzXG5cbiAgZnVuY3Rpb24gdHJ5TGFiZWwoX3gsIF95LCBtYXhTaXplLCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQpIHtcbiAgICBjb25zdCB4ID0gJC5pbnZlcnQoX3gpLFxuICAgICAgeSA9ICQuaW52ZXJ0KF95KTtcbiAgICBsZXQgbG8gPSBtYXhTaXplLFxuICAgICAgaGkgPSBoZWlnaHQsXG4gICAgICBtaWQ7XG4gICAgaWYgKCFvdXRPZkJvdW5kcyh4LCB5LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIHdpZHRoLCBoZWlnaHQpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBsbywgYm0wLCBibTEpICYmICFjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCBibTAsIG51bGwpKSB7XG4gICAgICAvLyBpZiB0aGUgbGFiZWwgZml0cyBhdCB0aGUgY3VycmVudCBzYW1wbGUgcG9pbnQsXG4gICAgICAvLyBwZXJmb3JtIGJpbmFyeSBzZWFyY2ggdG8gZmluZCB0aGUgbGFyZ2VzdCBmb250IHNpemUgdGhhdCBmaXRzXG4gICAgICB3aGlsZSAoaGkgLSBsbyA+PSAxKSB7XG4gICAgICAgIG1pZCA9IChsbyArIGhpKSAvIDI7XG4gICAgICAgIGlmIChjb2xsaXNpb24oJCwgeCwgeSwgdGV4dEhlaWdodCwgdGV4dFdpZHRoLCBtaWQsIGJtMCwgYm0xKSkge1xuICAgICAgICAgIGhpID0gbWlkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvID0gbWlkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBwbGFjZSBsYWJlbCBpZiBjdXJyZW50IGxvd2VyIGJvdW5kIGV4Y2VlZHMgcHJpb3IgbWF4IGZvbnQgc2l6ZVxuICAgICAgaWYgKGxvID4gbWF4U2l6ZSkge1xuICAgICAgICByZXR1cm4gW3gsIHksIGxvLCB0cnVlXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyB0cnkgdG8gcGxhY2UgYSBsYWJlbCB3aXRoaW4gYW4gaW5wdXQgYXJlYSBtYXJrXG4gIHJldHVybiBmdW5jdGlvbiAoZCkge1xuICAgIGNvbnN0IGl0ZW1zID0gZC5kYXR1bS5kYXR1bS5pdGVtc1ttYXJrSW5kZXhdLml0ZW1zLFxuICAgICAgLy8gYXJlYSBwb2ludHNcbiAgICAgIG4gPSBpdGVtcy5sZW5ndGgsXG4gICAgICAvLyBudW1iZXIgb2YgcG9pbnRzXG4gICAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZSxcbiAgICAgIC8vIGxhYmVsIHdpZHRoXG4gICAgICB0ZXh0V2lkdGggPSB0ZXh0TWV0cmljcy53aWR0aChkLmRhdHVtLCBkLmRhdHVtLnRleHQpOyAvLyBsYWJlbCBoZWlnaHRcblxuICAgIGxldCBtYXhTaXplID0gYXZvaWRCYXNlTWFyayA/IHRleHRIZWlnaHQgOiAwLFxuICAgICAgbGFiZWxQbGFjZWQgPSBmYWxzZSxcbiAgICAgIGxhYmVsUGxhY2VkMiA9IGZhbHNlLFxuICAgICAgbWF4QXJlYVdpZHRoID0gMCxcbiAgICAgIHgxLFxuICAgICAgeDIsXG4gICAgICB5MSxcbiAgICAgIHkyLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBfeCxcbiAgICAgIF95LFxuICAgICAgX3gxLFxuICAgICAgX3hNaWQsXG4gICAgICBfeDIsXG4gICAgICBfeTEsXG4gICAgICBfeU1pZCxcbiAgICAgIF95MixcbiAgICAgIGFyZWFXaWR0aCxcbiAgICAgIHJlc3VsdCxcbiAgICAgIHN3YXBUbXA7XG5cbiAgICAvLyBmb3IgZWFjaCBhcmVhIHNhbXBsZSBwb2ludFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICB4MSA9IGl0ZW1zW2ldLng7XG4gICAgICB5MSA9IGl0ZW1zW2ldLnk7XG4gICAgICB4MiA9IGl0ZW1zW2ldLngyID09PSB1bmRlZmluZWQgPyB4MSA6IGl0ZW1zW2ldLngyO1xuICAgICAgeTIgPSBpdGVtc1tpXS55MiA9PT0gdW5kZWZpbmVkID8geTEgOiBpdGVtc1tpXS55MjtcbiAgICAgIGlmICh4MSA+IHgyKSB7XG4gICAgICAgIHN3YXBUbXAgPSB4MTtcbiAgICAgICAgeDEgPSB4MjtcbiAgICAgICAgeDIgPSBzd2FwVG1wO1xuICAgICAgfVxuICAgICAgaWYgKHkxID4geTIpIHtcbiAgICAgICAgc3dhcFRtcCA9IHkxO1xuICAgICAgICB5MSA9IHkyO1xuICAgICAgICB5MiA9IHN3YXBUbXA7XG4gICAgICB9XG4gICAgICBfeDEgPSAkKHgxKTtcbiAgICAgIF94MiA9ICQoeDIpO1xuICAgICAgX3hNaWQgPSB+figoX3gxICsgX3gyKSAvIDIpO1xuICAgICAgX3kxID0gJCh5MSk7XG4gICAgICBfeTIgPSAkKHkyKTtcbiAgICAgIF95TWlkID0gfn4oKF95MSArIF95MikgLyAyKTtcblxuICAgICAgLy8gc2VhcmNoIGFsb25nIHRoZSBsaW5lIGZyb20gbWlkIHBvaW50IGJldHdlZW4gdGhlIDIgYm9yZGVyIHRvIGxvd2VyIGJvcmRlclxuICAgICAgZm9yIChfeCA9IF94TWlkOyBfeCA+PSBfeDE7IC0tX3gpIHtcbiAgICAgICAgZm9yIChfeSA9IF95TWlkOyBfeSA+PSBfeTE7IC0tX3kpIHtcbiAgICAgICAgICByZXN1bHQgPSB0cnlMYWJlbChfeCwgX3ksIG1heFNpemUsIHRleHRXaWR0aCwgdGV4dEhlaWdodCk7XG4gICAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgW2QueCwgZC55LCBtYXhTaXplLCBsYWJlbFBsYWNlZF0gPSByZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHNlYXJjaCBhbG9uZyB0aGUgbGluZSBmcm9tIG1pZCBwb2ludCBiZXR3ZWVuIHRoZSAyIGJvcmRlciB0byB1cHBlciBib3JkZXJcbiAgICAgIGZvciAoX3ggPSBfeE1pZDsgX3ggPD0gX3gyOyArK194KSB7XG4gICAgICAgIGZvciAoX3kgPSBfeU1pZDsgX3kgPD0gX3kyOyArK195KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdHJ5TGFiZWwoX3gsIF95LCBtYXhTaXplLCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQpO1xuICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgIFtkLngsIGQueSwgbWF4U2l6ZSwgbGFiZWxQbGFjZWRdID0gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBwbGFjZSBsYWJlbCBhdCBzbGljZSBjZW50ZXIgaWYgbm90IHBsYWNlZCB0aHJvdWdoIG90aGVyIG1lYW5zXG4gICAgICAvLyBhbmQgaWYgd2UncmUgbm90IGF2b2lkaW5nIG92ZXJsYXAgd2l0aCBvdGhlciBhcmVhc1xuICAgICAgaWYgKCFsYWJlbFBsYWNlZCAmJiAhYXZvaWRCYXNlTWFyaykge1xuICAgICAgICAvLyBvbmUgc3BhbiBpcyB6ZXJvLCBoZW5jZSB3ZSBjYW4gYWRkXG4gICAgICAgIGFyZWFXaWR0aCA9IE1hdGguYWJzKHgyIC0geDEgKyB5MiAtIHkxKTtcbiAgICAgICAgeCA9ICh4MSArIHgyKSAvIDI7XG4gICAgICAgIHkgPSAoeTEgKyB5MikgLyAyO1xuXG4gICAgICAgIC8vIHBsYWNlIGxhYmVsIGlmIGl0IGZpdHMgYW5kIGltcHJvdmVzIHRoZSBtYXggYXJlYSB3aWR0aFxuICAgICAgICBpZiAoYXJlYVdpZHRoID49IG1heEFyZWFXaWR0aCAmJiAhb3V0T2ZCb3VuZHMoeCwgeSwgdGV4dFdpZHRoLCB0ZXh0SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KSAmJiAhY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgYm0wLCBudWxsKSkge1xuICAgICAgICAgIG1heEFyZWFXaWR0aCA9IGFyZWFXaWR0aDtcbiAgICAgICAgICBkLnggPSB4O1xuICAgICAgICAgIGQueSA9IHk7XG4gICAgICAgICAgbGFiZWxQbGFjZWQyID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIHJlY29yZCBjdXJyZW50IGxhYmVsIHBsYWNlbWVudCBpbmZvcm1hdGlvbiwgdXBkYXRlIGxhYmVsIGJpdG1hcFxuICAgIGlmIChsYWJlbFBsYWNlZCB8fCBsYWJlbFBsYWNlZDIpIHtcbiAgICAgIHggPSB0ZXh0V2lkdGggLyAyO1xuICAgICAgeSA9IHRleHRIZWlnaHQgLyAyO1xuICAgICAgYm0wLnNldFJhbmdlKCQoZC54IC0geCksICQoZC55IC0geSksICQoZC54ICsgeCksICQoZC55ICsgeSkpO1xuICAgICAgZC5hbGlnbiA9ICdjZW50ZXInO1xuICAgICAgZC5iYXNlbGluZSA9ICdtaWRkbGUnO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH07XG59XG5cbi8vIHBpeGVsIGRpcmVjdGlvbiBvZmZzZXRzIGZvciBmbG9vZCBmaWxsIHNlYXJjaFxuY29uc3QgWF9ESVIgPSBbLTEsIC0xLCAxLCAxXTtcbmNvbnN0IFlfRElSID0gWy0xLCAxLCAtMSwgMV07XG5mdW5jdGlvbiBwbGFjZUFyZWFMYWJlbEZsb29kRmlsbCAoJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4KSB7XG4gIGNvbnN0IHdpZHRoID0gJC53aWR0aCxcbiAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICBibTAgPSBiaXRtYXBzWzBdLFxuICAgIC8vIHdoZXJlIGxhYmVscyBoYXZlIGJlZW4gcGxhY2VkXG4gICAgYm0xID0gYml0bWFwc1sxXSxcbiAgICAvLyBhcmVhIG91dGxpbmVzXG4gICAgYm0yID0gJC5iaXRtYXAoKTsgLy8gZmxvb2QtZmlsbCB2aXNpdGF0aW9uc1xuXG4gIC8vIHRyeSB0byBwbGFjZSBhIGxhYmVsIHdpdGhpbiBhbiBpbnB1dCBhcmVhIG1hcmtcbiAgcmV0dXJuIGZ1bmN0aW9uIChkKSB7XG4gICAgY29uc3QgaXRlbXMgPSBkLmRhdHVtLmRhdHVtLml0ZW1zW21hcmtJbmRleF0uaXRlbXMsXG4gICAgICAvLyBhcmVhIHBvaW50c1xuICAgICAgbiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgIC8vIG51bWJlciBvZiBwb2ludHNcbiAgICAgIHRleHRIZWlnaHQgPSBkLmRhdHVtLmZvbnRTaXplLFxuICAgICAgLy8gbGFiZWwgd2lkdGhcbiAgICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCksXG4gICAgICAvLyBsYWJlbCBoZWlnaHRcbiAgICAgIHN0YWNrID0gW107IC8vIGZsb29kIGZpbGwgc3RhY2tcblxuICAgIGxldCBtYXhTaXplID0gYXZvaWRCYXNlTWFyayA/IHRleHRIZWlnaHQgOiAwLFxuICAgICAgbGFiZWxQbGFjZWQgPSBmYWxzZSxcbiAgICAgIGxhYmVsUGxhY2VkMiA9IGZhbHNlLFxuICAgICAgbWF4QXJlYVdpZHRoID0gMCxcbiAgICAgIHgxLFxuICAgICAgeDIsXG4gICAgICB5MSxcbiAgICAgIHkyLFxuICAgICAgeCxcbiAgICAgIHksXG4gICAgICBfeCxcbiAgICAgIF95LFxuICAgICAgbG8sXG4gICAgICBoaSxcbiAgICAgIG1pZCxcbiAgICAgIGFyZWFXaWR0aDtcblxuICAgIC8vIGZvciBlYWNoIGFyZWEgc2FtcGxlIHBvaW50XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHgxID0gaXRlbXNbaV0ueDtcbiAgICAgIHkxID0gaXRlbXNbaV0ueTtcbiAgICAgIHgyID0gaXRlbXNbaV0ueDIgPT09IHVuZGVmaW5lZCA/IHgxIDogaXRlbXNbaV0ueDI7XG4gICAgICB5MiA9IGl0ZW1zW2ldLnkyID09PSB1bmRlZmluZWQgPyB5MSA6IGl0ZW1zW2ldLnkyO1xuXG4gICAgICAvLyBhZGQgc2NhbGVkIGNlbnRlciBwb2ludCB0byBzdGFja1xuICAgICAgc3RhY2sucHVzaChbJCgoeDEgKyB4MikgLyAyKSwgJCgoeTEgKyB5MikgLyAyKV0pO1xuXG4gICAgICAvLyBwZXJmb3JtIGZsb29kIGZpbGwsIHZpc2l0IHBvaW50c1xuICAgICAgd2hpbGUgKHN0YWNrLmxlbmd0aCkge1xuICAgICAgICBbX3gsIF95XSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIC8vIGV4aXQgaWYgcG9pbnQgYWxyZWFkeSBtYXJrZWRcbiAgICAgICAgaWYgKGJtMC5nZXQoX3gsIF95KSB8fCBibTEuZ2V0KF94LCBfeSkgfHwgYm0yLmdldChfeCwgX3kpKSBjb250aW51ZTtcblxuICAgICAgICAvLyBtYXJrIHBvaW50IGluIGZsb29kIGZpbGwgYml0bWFwXG4gICAgICAgIC8vIGFkZCBzZWFyY2ggcG9pbnRzIGZvciBhbGwgKGluIGJvdW5kKSBkaXJlY3Rpb25zXG4gICAgICAgIGJtMi5zZXQoX3gsIF95KTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCA0OyArK2opIHtcbiAgICAgICAgICB4ID0gX3ggKyBYX0RJUltqXTtcbiAgICAgICAgICB5ID0gX3kgKyBZX0RJUltqXTtcbiAgICAgICAgICBpZiAoIWJtMi5vdXRPZkJvdW5kcyh4LCB5LCB4LCB5KSkgc3RhY2sucHVzaChbeCwgeV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdW5zY2FsZSBwb2ludCBiYWNrIHRvIHgsIHkgc3BhY2VcbiAgICAgICAgeCA9ICQuaW52ZXJ0KF94KTtcbiAgICAgICAgeSA9ICQuaW52ZXJ0KF95KTtcbiAgICAgICAgbG8gPSBtYXhTaXplO1xuICAgICAgICBoaSA9IGhlaWdodDsgLy8gVE9ETzogbWFrZSB0aGlzIGJvdW5kIHNtYWxsZXJcblxuICAgICAgICBpZiAoIW91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIGxvLCBibTAsIGJtMSkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIGJtMCwgbnVsbCkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbGFiZWwgZml0cyBhdCB0aGUgY3VycmVudCBzYW1wbGUgcG9pbnQsXG4gICAgICAgICAgLy8gcGVyZm9ybSBiaW5hcnkgc2VhcmNoIHRvIGZpbmQgdGhlIGxhcmdlc3QgZm9udCBzaXplIHRoYXQgZml0c1xuICAgICAgICAgIHdoaWxlIChoaSAtIGxvID49IDEpIHtcbiAgICAgICAgICAgIG1pZCA9IChsbyArIGhpKSAvIDI7XG4gICAgICAgICAgICBpZiAoY29sbGlzaW9uKCQsIHgsIHksIHRleHRIZWlnaHQsIHRleHRXaWR0aCwgbWlkLCBibTAsIGJtMSkpIHtcbiAgICAgICAgICAgICAgaGkgPSBtaWQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBsbyA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcGxhY2UgbGFiZWwgaWYgY3VycmVudCBsb3dlciBib3VuZCBleGNlZWRzIHByaW9yIG1heCBmb250IHNpemVcbiAgICAgICAgICBpZiAobG8gPiBtYXhTaXplKSB7XG4gICAgICAgICAgICBkLnggPSB4O1xuICAgICAgICAgICAgZC55ID0geTtcbiAgICAgICAgICAgIG1heFNpemUgPSBsbztcbiAgICAgICAgICAgIGxhYmVsUGxhY2VkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gcGxhY2UgbGFiZWwgYXQgc2xpY2UgY2VudGVyIGlmIG5vdCBwbGFjZWQgdGhyb3VnaCBvdGhlciBtZWFuc1xuICAgICAgLy8gYW5kIGlmIHdlJ3JlIG5vdCBhdm9pZGluZyBvdmVybGFwIHdpdGggb3RoZXIgYXJlYXNcbiAgICAgIGlmICghbGFiZWxQbGFjZWQgJiYgIWF2b2lkQmFzZU1hcmspIHtcbiAgICAgICAgLy8gb25lIHNwYW4gaXMgemVybywgaGVuY2Ugd2UgY2FuIGFkZFxuICAgICAgICBhcmVhV2lkdGggPSBNYXRoLmFicyh4MiAtIHgxICsgeTIgLSB5MSk7XG4gICAgICAgIHggPSAoeDEgKyB4MikgLyAyO1xuICAgICAgICB5ID0gKHkxICsgeTIpIC8gMjtcblxuICAgICAgICAvLyBwbGFjZSBsYWJlbCBpZiBpdCBmaXRzIGFuZCBpbXByb3ZlcyB0aGUgbWF4IGFyZWEgd2lkdGhcbiAgICAgICAgaWYgKGFyZWFXaWR0aCA+PSBtYXhBcmVhV2lkdGggJiYgIW91dE9mQm91bmRzKHgsIHksIHRleHRXaWR0aCwgdGV4dEhlaWdodCwgd2lkdGgsIGhlaWdodCkgJiYgIWNvbGxpc2lvbigkLCB4LCB5LCB0ZXh0SGVpZ2h0LCB0ZXh0V2lkdGgsIHRleHRIZWlnaHQsIGJtMCwgbnVsbCkpIHtcbiAgICAgICAgICBtYXhBcmVhV2lkdGggPSBhcmVhV2lkdGg7XG4gICAgICAgICAgZC54ID0geDtcbiAgICAgICAgICBkLnkgPSB5O1xuICAgICAgICAgIGxhYmVsUGxhY2VkMiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZWNvcmQgY3VycmVudCBsYWJlbCBwbGFjZW1lbnQgaW5mb3JtYXRpb24sIHVwZGF0ZSBsYWJlbCBiaXRtYXBcbiAgICBpZiAobGFiZWxQbGFjZWQgfHwgbGFiZWxQbGFjZWQyKSB7XG4gICAgICB4ID0gdGV4dFdpZHRoIC8gMjtcbiAgICAgIHkgPSB0ZXh0SGVpZ2h0IC8gMjtcbiAgICAgIGJtMC5zZXRSYW5nZSgkKGQueCAtIHgpLCAkKGQueSAtIHkpLCAkKGQueCArIHgpLCAkKGQueSArIHkpKTtcbiAgICAgIGQuYWxpZ24gPSAnY2VudGVyJztcbiAgICAgIGQuYmFzZWxpbmUgPSAnbWlkZGxlJztcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBBbGlnbnMgPSBbJ3JpZ2h0JywgJ2NlbnRlcicsICdsZWZ0J10sXG4gIEJhc2VsaW5lcyA9IFsnYm90dG9tJywgJ21pZGRsZScsICd0b3AnXTtcbmZ1bmN0aW9uIHBsYWNlTWFya0xhYmVsICgkLCBiaXRtYXBzLCBhbmNob3JzLCBvZmZzZXRzKSB7XG4gIGNvbnN0IHdpZHRoID0gJC53aWR0aCxcbiAgICBoZWlnaHQgPSAkLmhlaWdodCxcbiAgICBibTAgPSBiaXRtYXBzWzBdLFxuICAgIGJtMSA9IGJpdG1hcHNbMV0sXG4gICAgbiA9IG9mZnNldHMubGVuZ3RoO1xuICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcbiAgICBjb25zdCBib3VuZGFyeSA9IGQuYm91bmRhcnksXG4gICAgICB0ZXh0SGVpZ2h0ID0gZC5kYXR1bS5mb250U2l6ZTtcblxuICAgIC8vIGNhbiBub3QgYmUgcGxhY2VkIGlmIHRoZSBtYXJrIGlzIG5vdCB2aXNpYmxlIGluIHRoZSBncmFwaCBib3VuZFxuICAgIGlmIChib3VuZGFyeVsyXSA8IDAgfHwgYm91bmRhcnlbNV0gPCAwIHx8IGJvdW5kYXJ5WzBdID4gd2lkdGggfHwgYm91bmRhcnlbM10gPiBoZWlnaHQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHRleHRXaWR0aCA9IGQudGV4dFdpZHRoID8/IDAsXG4gICAgICBkeCxcbiAgICAgIGR5LFxuICAgICAgaXNJbnNpZGUsXG4gICAgICBzaXplRmFjdG9yLFxuICAgICAgaW5zaWRlRmFjdG9yLFxuICAgICAgeDEsXG4gICAgICB4MixcbiAgICAgIHkxLFxuICAgICAgeTIsXG4gICAgICB4YyxcbiAgICAgIHljLFxuICAgICAgX3gxLFxuICAgICAgX3gyLFxuICAgICAgX3kxLFxuICAgICAgX3kyO1xuXG4gICAgLy8gZm9yIGVhY2ggYW5jaG9yIGFuZCBvZmZzZXRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgZHggPSAoYW5jaG9yc1tpXSAmIDB4MykgLSAxO1xuICAgICAgZHkgPSAoYW5jaG9yc1tpXSA+Pj4gMHgyICYgMHgzKSAtIDE7XG4gICAgICBpc0luc2lkZSA9IGR4ID09PSAwICYmIGR5ID09PSAwIHx8IG9mZnNldHNbaV0gPCAwO1xuICAgICAgc2l6ZUZhY3RvciA9IGR4ICYmIGR5ID8gTWF0aC5TUVJUMV8yIDogMTtcbiAgICAgIGluc2lkZUZhY3RvciA9IG9mZnNldHNbaV0gPCAwID8gLTEgOiAxO1xuICAgICAgeDEgPSBib3VuZGFyeVsxICsgZHhdICsgb2Zmc2V0c1tpXSAqIGR4ICogc2l6ZUZhY3RvcjtcbiAgICAgIHljID0gYm91bmRhcnlbNCArIGR5XSArIGluc2lkZUZhY3RvciAqIHRleHRIZWlnaHQgKiBkeSAvIDIgKyBvZmZzZXRzW2ldICogZHkgKiBzaXplRmFjdG9yO1xuICAgICAgeTEgPSB5YyAtIHRleHRIZWlnaHQgLyAyO1xuICAgICAgeTIgPSB5YyArIHRleHRIZWlnaHQgLyAyO1xuICAgICAgX3gxID0gJCh4MSk7XG4gICAgICBfeTEgPSAkKHkxKTtcbiAgICAgIF95MiA9ICQoeTIpO1xuICAgICAgaWYgKCF0ZXh0V2lkdGgpIHtcbiAgICAgICAgLy8gdG8gYXZvaWQgZmluZGluZyB3aWR0aCBvZiB0ZXh0IGxhYmVsLFxuICAgICAgICBpZiAoIXRlc3QoX3gxLCBfeDEsIF95MSwgX3kyLCBibTAsIGJtMSwgeDEsIHgxLCB5MSwgeTIsIGJvdW5kYXJ5LCBpc0luc2lkZSkpIHtcbiAgICAgICAgICAvLyBza2lwIHRoaXMgYW5jaG9yL29mZnNldCBvcHRpb24gaWYgd2UgZmFpbCB0byBwbGFjZSBhIGxhYmVsIHdpdGggMXB4IHdpZHRoXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlLCBmaW5kIHRoZSBsYWJlbCB3aWR0aFxuICAgICAgICAgIHRleHRXaWR0aCA9IHRleHRNZXRyaWNzLndpZHRoKGQuZGF0dW0sIGQuZGF0dW0udGV4dCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHhjID0geDEgKyBpbnNpZGVGYWN0b3IgKiB0ZXh0V2lkdGggKiBkeCAvIDI7XG4gICAgICB4MSA9IHhjIC0gdGV4dFdpZHRoIC8gMjtcbiAgICAgIHgyID0geGMgKyB0ZXh0V2lkdGggLyAyO1xuICAgICAgX3gxID0gJCh4MSk7XG4gICAgICBfeDIgPSAkKHgyKTtcbiAgICAgIGlmICh0ZXN0KF94MSwgX3gyLCBfeTEsIF95MiwgYm0wLCBibTEsIHgxLCB4MiwgeTEsIHkyLCBib3VuZGFyeSwgaXNJbnNpZGUpKSB7XG4gICAgICAgIC8vIHBsYWNlIGxhYmVsIGlmIHRoZSBwb3NpdGlvbiBpcyBwbGFjZWFibGVcbiAgICAgICAgZC54ID0gIWR4ID8geGMgOiBkeCAqIGluc2lkZUZhY3RvciA8IDAgPyB4MiA6IHgxO1xuICAgICAgICBkLnkgPSAhZHkgPyB5YyA6IGR5ICogaW5zaWRlRmFjdG9yIDwgMCA/IHkyIDogeTE7XG4gICAgICAgIGQuYWxpZ24gPSBBbGlnbnNbZHggKiBpbnNpZGVGYWN0b3IgKyAxXTtcbiAgICAgICAgZC5iYXNlbGluZSA9IEJhc2VsaW5lc1tkeSAqIGluc2lkZUZhY3RvciArIDFdO1xuICAgICAgICBibTAuc2V0UmFuZ2UoX3gxLCBfeTEsIF94MiwgX3kyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLy8gVGVzdCBpZiBhIGxhYmVsIHdpdGggdGhlIGdpdmVuIGRpbWVuc2lvbnMgY2FuIGJlIGFkZGVkIHdpdGhvdXQgb3ZlcmxhcFxuZnVuY3Rpb24gdGVzdChfeDEsIF94MiwgX3kxLCBfeTIsIGJtMCwgYm0xLCB4MSwgeDIsIHkxLCB5MiwgYm91bmRhcnksIGlzSW5zaWRlKSB7XG4gIHJldHVybiAhKGJtMC5vdXRPZkJvdW5kcyhfeDEsIF95MSwgX3gyLCBfeTIpIHx8IChpc0luc2lkZSAmJiBibTEgfHwgYm0wKS5nZXRSYW5nZShfeDEsIF95MSwgX3gyLCBfeTIpKTtcbn1cblxuLy8gOC1iaXQgcmVwcmVzZW50YXRpb24gb2YgYW5jaG9yc1xuY29uc3QgVE9QID0gMHgwLFxuICBNSURETEUgPSAweDQsXG4gIEJPVFRPTSA9IDB4OCxcbiAgTEVGVCA9IDB4MCxcbiAgQ0VOVEVSID0gMHgxLFxuICBSSUdIVCA9IDB4MjtcblxuLy8gTWFwcGluZyBmcm9tIHRleHQgYW5jaG9yIHRvIG51bWJlciByZXByZXNlbnRhdGlvblxuY29uc3QgYW5jaG9yQ29kZSA9IHtcbiAgJ3RvcC1sZWZ0JzogVE9QICsgTEVGVCxcbiAgJ3RvcCc6IFRPUCArIENFTlRFUixcbiAgJ3RvcC1yaWdodCc6IFRPUCArIFJJR0hULFxuICAnbGVmdCc6IE1JRERMRSArIExFRlQsXG4gICdtaWRkbGUnOiBNSURETEUgKyBDRU5URVIsXG4gICdyaWdodCc6IE1JRERMRSArIFJJR0hULFxuICAnYm90dG9tLWxlZnQnOiBCT1RUT00gKyBMRUZULFxuICAnYm90dG9tJzogQk9UVE9NICsgQ0VOVEVSLFxuICAnYm90dG9tLXJpZ2h0JzogQk9UVE9NICsgUklHSFRcbn07XG5jb25zdCBwbGFjZUFyZWFMYWJlbCA9IHtcbiAgJ25haXZlJzogcGxhY2VBcmVhTGFiZWxOYWl2ZSxcbiAgJ3JlZHVjZWQtc2VhcmNoJzogcGxhY2VBcmVhTGFiZWxSZWR1Y2VkU2VhcmNoLFxuICAnZmxvb2RmaWxsJzogcGxhY2VBcmVhTGFiZWxGbG9vZEZpbGxcbn07XG5mdW5jdGlvbiBsYWJlbExheW91dCAodGV4dHMsIHNpemUsIGNvbXBhcmUsIG9mZnNldCwgYW5jaG9yLCBhdm9pZE1hcmtzLCBhdm9pZEJhc2VNYXJrLCBsaW5lQW5jaG9yLCBtYXJrSW5kZXgsIHBhZGRpbmcsIG1ldGhvZCkge1xuICAvLyBlYXJseSBleGl0IGZvciBlbXB0eSBkYXRhXG4gIGlmICghdGV4dHMubGVuZ3RoKSByZXR1cm4gdGV4dHM7XG4gIGNvbnN0IHBvc2l0aW9ucyA9IE1hdGgubWF4KG9mZnNldC5sZW5ndGgsIGFuY2hvci5sZW5ndGgpLFxuICAgIG9mZnNldHMgPSBnZXRPZmZzZXRzKG9mZnNldCwgcG9zaXRpb25zKSxcbiAgICBhbmNob3JzID0gZ2V0QW5jaG9ycyhhbmNob3IsIHBvc2l0aW9ucyksXG4gICAgbWFya3R5cGUgPSBtYXJrVHlwZSh0ZXh0c1swXS5kYXR1bSksXG4gICAgZ3JvdXB0eXBlID0gbWFya3R5cGUgPT09ICdncm91cCcgJiYgdGV4dHNbMF0uZGF0dW0uaXRlbXNbbWFya0luZGV4XS5tYXJrdHlwZSxcbiAgICBpc0dyb3VwQXJlYSA9IGdyb3VwdHlwZSA9PT0gJ2FyZWEnLFxuICAgIGJvdW5kYXJ5ID0gbWFya0JvdW5kYXJ5KG1hcmt0eXBlLCBncm91cHR5cGUsIGxpbmVBbmNob3IsIG1hcmtJbmRleCksXG4gICAgaW5mUGFkZGluZyA9IHBhZGRpbmcgPT09IG51bGwgfHwgcGFkZGluZyA9PT0gSW5maW5pdHksXG4gICAgaXNOYWl2ZUdyb3VwQXJlYSA9IGlzR3JvdXBBcmVhICYmIG1ldGhvZCA9PT0gJ25haXZlJztcbiAgbGV0IG1heFRleHRXaWR0aCA9IC0xLFxuICAgIG1heFRleHRIZWlnaHQgPSAtMTtcblxuICAvLyBwcmVwYXJlIHRleHQgbWFyayBkYXRhIGZvciBwbGFjaW5nXG4gIGNvbnN0IGRhdGEgPSB0ZXh0cy5tYXAoZCA9PiB7XG4gICAgY29uc3QgdGV4dFdpZHRoID0gaW5mUGFkZGluZyA/IHRleHRNZXRyaWNzLndpZHRoKGQsIGQudGV4dCkgOiB1bmRlZmluZWQ7XG4gICAgbWF4VGV4dFdpZHRoID0gTWF0aC5tYXgobWF4VGV4dFdpZHRoLCB0ZXh0V2lkdGgpO1xuICAgIG1heFRleHRIZWlnaHQgPSBNYXRoLm1heChtYXhUZXh0SGVpZ2h0LCBkLmZvbnRTaXplKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGF0dW06IGQsXG4gICAgICBvcGFjaXR5OiAwLFxuICAgICAgeDogdW5kZWZpbmVkLFxuICAgICAgeTogdW5kZWZpbmVkLFxuICAgICAgYWxpZ246IHVuZGVmaW5lZCxcbiAgICAgIGJhc2VsaW5lOiB1bmRlZmluZWQsXG4gICAgICBib3VuZGFyeTogYm91bmRhcnkoZCksXG4gICAgICB0ZXh0V2lkdGhcbiAgICB9O1xuICB9KTtcbiAgcGFkZGluZyA9IHBhZGRpbmcgPT09IG51bGwgfHwgcGFkZGluZyA9PT0gSW5maW5pdHkgPyBNYXRoLm1heChtYXhUZXh0V2lkdGgsIG1heFRleHRIZWlnaHQpICsgTWF0aC5tYXgoLi4ub2Zmc2V0KSA6IHBhZGRpbmc7XG4gIGNvbnN0ICQgPSBzY2FsZXIoc2l6ZVswXSwgc2l6ZVsxXSwgcGFkZGluZyk7XG4gIGxldCBiaXRtYXBzO1xuICBpZiAoIWlzTmFpdmVHcm91cEFyZWEpIHtcbiAgICAvLyBzb3J0IGxhYmVscyBpbiBwcmlvcml0eSBvcmRlciwgaWYgY29tcGFyYXRvciBpcyBwcm92aWRlZFxuICAgIGlmIChjb21wYXJlKSB7XG4gICAgICBkYXRhLnNvcnQoKGEsIGIpID0+IGNvbXBhcmUoYS5kYXR1bSwgYi5kYXR1bSkpO1xuICAgIH1cblxuICAgIC8vIGZsYWcgaW5kaWNhdGluZyBpZiBsYWJlbCBjYW4gYmUgcGxhY2VkIGluc2lkZSBpdHMgYmFzZSBtYXJrXG4gICAgbGV0IGxhYmVsSW5zaWRlID0gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbmNob3JzLmxlbmd0aCAmJiAhbGFiZWxJbnNpZGU7ICsraSkge1xuICAgICAgLy8gbGFiZWwgaW5zaWRlIGlmIGFuY2hvciBpcyBhdCBjZW50ZXJcbiAgICAgIC8vIGxhYmVsIGluc2lkZSBpZiBvZmZzZXQgdG8gYmUgaW5zaWRlIHRoZSBtYXJrIGJvdW5kXG4gICAgICBsYWJlbEluc2lkZSA9IGFuY2hvcnNbaV0gPT09IDB4NSB8fCBvZmZzZXRzW2ldIDwgMDtcbiAgICB9XG5cbiAgICAvLyBleHRyYWN0IGRhdGEgaW5mb3JtYXRpb24gZnJvbSBiYXNlIG1hcmsgd2hlbiBiYXNlIG1hcmsgaXMgdG8gYmUgYXZvaWRlZFxuICAgIC8vIGJhc2UgbWFyayBpcyBpbXBsaWNpdGx5IGF2b2lkZWQgaWYgaXQgaXMgYSBncm91cCBhcmVhXG4gICAgY29uc3QgYmFzZU1hcmsgPSAobWFya3R5cGUgJiYgYXZvaWRCYXNlTWFyayB8fCBpc0dyb3VwQXJlYSkgJiYgdGV4dHMubWFwKGQgPT4gZC5kYXR1bSk7XG5cbiAgICAvLyBnZW5lcmF0ZSBiaXRtYXBzIGZvciBsYXlvdXQgY2FsY3VsYXRpb25cbiAgICBiaXRtYXBzID0gYXZvaWRNYXJrcy5sZW5ndGggfHwgYmFzZU1hcmsgPyBtYXJrQml0bWFwcygkLCBiYXNlTWFyayB8fCBbXSwgYXZvaWRNYXJrcywgbGFiZWxJbnNpZGUsIGlzR3JvdXBBcmVhKSA6IGJhc2VCaXRtYXBzKCQsIGF2b2lkQmFzZU1hcmsgJiYgZGF0YSk7XG4gIH1cblxuICAvLyBnZW5lcmF0ZSBsYWJlbCBwbGFjZW1lbnQgZnVuY3Rpb25cbiAgY29uc3QgcGxhY2UgPSBpc0dyb3VwQXJlYSA/IHBsYWNlQXJlYUxhYmVsW21ldGhvZF0oJCwgYml0bWFwcywgYXZvaWRCYXNlTWFyaywgbWFya0luZGV4KSA6IHBsYWNlTWFya0xhYmVsKCQsIGJpdG1hcHMsIGFuY2hvcnMsIG9mZnNldHMpO1xuXG4gIC8vIHBsYWNlIGFsbCBsYWJlbHNcbiAgZGF0YS5mb3JFYWNoKGQgPT4gZC5vcGFjaXR5ID0gK3BsYWNlKGQpKTtcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBnZXRPZmZzZXRzKF8sIGNvdW50KSB7XG4gIGNvbnN0IG9mZnNldHMgPSBuZXcgRmxvYXQ2NEFycmF5KGNvdW50KSxcbiAgICBuID0gXy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBvZmZzZXRzW2ldID0gX1tpXSB8fCAwO1xuICBmb3IgKGxldCBpID0gbjsgaSA8IGNvdW50OyArK2kpIG9mZnNldHNbaV0gPSBvZmZzZXRzW24gLSAxXTtcbiAgcmV0dXJuIG9mZnNldHM7XG59XG5mdW5jdGlvbiBnZXRBbmNob3JzKF8sIGNvdW50KSB7XG4gIGNvbnN0IGFuY2hvcnMgPSBuZXcgSW50OEFycmF5KGNvdW50KSxcbiAgICBuID0gXy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhbmNob3JzW2ldIHw9IGFuY2hvckNvZGVbX1tpXV07XG4gIGZvciAobGV0IGkgPSBuOyBpIDwgY291bnQ7ICsraSkgYW5jaG9yc1tpXSA9IGFuY2hvcnNbbiAtIDFdO1xuICByZXR1cm4gYW5jaG9ycztcbn1cbmZ1bmN0aW9uIG1hcmtUeXBlKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0gJiYgaXRlbS5tYXJrICYmIGl0ZW0ubWFyay5tYXJrdHlwZTtcbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZ1bmN0aW9uIGZvciBmdW5jdGlvbiBmb3IgZ2V0dGluZyBiYXNlIG1hcmsgYm91bmRhcnksIGRlcGVuZGluZ1xuICogb24gbWFyayBhbmQgZ3JvdXAgdHlwZS4gV2hlbiBtYXJrIHR5cGUgaXMgdW5kZWZpbmVkLCBsaW5lIG9yIGFyZWE6IGJvdW5kYXJ5XG4gKiBpcyB0aGUgY29vcmRpbmF0ZSBvZiBlYWNoIGRhdGEgcG9pbnQuIFdoZW4gYmFzZSBtYXJrIGlzIGdyb3VwZWQgbGluZSxcbiAqIGJvdW5kYXJ5IGlzIGVpdGhlciBhdCB0aGUgc3RhcnQgb3IgZW5kIG9mIHRoZSBsaW5lIGRlcGVuZGluZyBvbiB0aGVcbiAqIHZhbHVlIG9mIGxpbmVBbmNob3IuIE90aGVyd2lzZSwgdXNlIGJvdW5kcyBvZiBiYXNlIG1hcmsuXG4gKi9cbmZ1bmN0aW9uIG1hcmtCb3VuZGFyeShtYXJrdHlwZSwgZ3JvdXB0eXBlLCBsaW5lQW5jaG9yLCBtYXJrSW5kZXgpIHtcbiAgY29uc3QgeHkgPSBkID0+IFtkLngsIGQueCwgZC54LCBkLnksIGQueSwgZC55XTtcbiAgaWYgKCFtYXJrdHlwZSkge1xuICAgIHJldHVybiB4eTsgLy8gbm8gcmVhY3RpdmUgZ2VvbWV0cnlcbiAgfSBlbHNlIGlmIChtYXJrdHlwZSA9PT0gJ2xpbmUnIHx8IG1hcmt0eXBlID09PSAnYXJlYScpIHtcbiAgICByZXR1cm4gZCA9PiB4eShkLmRhdHVtKTtcbiAgfSBlbHNlIGlmIChncm91cHR5cGUgPT09ICdsaW5lJykge1xuICAgIHJldHVybiBkID0+IHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gZC5kYXR1bS5pdGVtc1ttYXJrSW5kZXhdLml0ZW1zO1xuICAgICAgcmV0dXJuIHh5KGl0ZW1zLmxlbmd0aCA/IGl0ZW1zW2xpbmVBbmNob3IgPT09ICdzdGFydCcgPyAwIDogaXRlbXMubGVuZ3RoIC0gMV0gOiB7XG4gICAgICAgIHg6IE5hTixcbiAgICAgICAgeTogTmFOXG4gICAgICB9KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBkID0+IHtcbiAgICAgIGNvbnN0IGIgPSBkLmRhdHVtLmJvdW5kcztcbiAgICAgIHJldHVybiBbYi54MSwgKGIueDEgKyBiLngyKSAvIDIsIGIueDIsIGIueTEsIChiLnkxICsgYi55MikgLyAyLCBiLnkyXTtcbiAgICB9O1xuICB9XG59XG5cbmNvbnN0IE91dHB1dCA9IFsneCcsICd5JywgJ29wYWNpdHknLCAnYWxpZ24nLCAnYmFzZWxpbmUnXTtcbmNvbnN0IEFuY2hvcnMgPSBbJ3RvcC1sZWZ0JywgJ2xlZnQnLCAnYm90dG9tLWxlZnQnLCAndG9wJywgJ2JvdHRvbScsICd0b3AtcmlnaHQnLCAncmlnaHQnLCAnYm90dG9tLXJpZ2h0J107XG5cbi8qKlxuICogQ29tcHV0ZSB0ZXh0IGxhYmVsIGxheW91dCB0byBhbm5vdGF0ZSBtYXJrcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBwYXJhbXMuc2l6ZSAtIFRoZSBzaXplIG9mIHRoZSBsYXlvdXQsIHByb3ZpZGVkIGFzIGEgW3dpZHRoLCBoZWlnaHRdIGFycmF5LlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBbiBvcHRpb25hbFxuICogICBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIGxhYmVsIGRhdGEgaW4gcHJpb3JpdHkgb3JkZXIuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYW5jaG9yXSAtIExhYmVsIGFuY2hvciBwb2ludHMgcmVsYXRpdmUgdG8gdGhlIGJhc2UgbWFyayBib3VuZGluZyBib3guXG4gKiAgIFRoZSBhdmFpbGFibGUgb3B0aW9ucyBhcmUgJ3RvcC1sZWZ0JywgJ2xlZnQnLCAnYm90dG9tLWxlZnQnLCAndG9wJyxcbiAqICAgJ2JvdHRvbScsICd0b3AtcmlnaHQnLCAncmlnaHQnLCAnYm90dG9tLXJpZ2h0JywgJ21pZGRsZScuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMub2Zmc2V0XSAtIExhYmVsIG9mZnNldHMgKGluIHBpeGVscykgZnJvbSB0aGUgYmFzZSBtYXJrIGJvdW5kaW5nIGJveC5cbiAqICAgVGhpcyBwYXJhbWV0ZXIgaXMgcGFyYWxsZWwgdG8gdGhlIGxpc3Qgb2YgYW5jaG9yIHBvaW50cy5cbiAqIEBwYXJhbSB7bnVtYmVyIHwgbnVsbH0gW3BhcmFtcy5wYWRkaW5nPTBdIC0gVGhlIGFtb3VudCAoaW4gcGl4ZWxzKSB0aGF0IGEgbGFiZWwgbWF5IGV4Y2VlZCB0aGUgbGF5b3V0IHNpemUuXG4gKiAgIElmIHRoaXMgcGFyYW1ldGVyIGlzIG51bGwsIGEgbGFiZWwgbWF5IGV4Y2VlZCB0aGUgbGF5b3V0IHNpemUgd2l0aG91dCBhbnkgYm91bmRhcnkuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5saW5lQW5jaG9yPSdlbmQnXSAtIEZvciBncm91cCBsaW5lIG1hcmsgbGFiZWxzIG9ubHksIGluZGljYXRlcyB0aGUgYW5jaG9yXG4gKiAgIHBvc2l0aW9uIGZvciBsYWJlbHMuIE9uZSBvZiAnc3RhcnQnIG9yICdlbmQnLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubWFya0luZGV4PTBdIC0gRm9yIGdyb3VwIG1hcmsgbGFiZWxzIG9ubHksIGFuIGluZGV4IGluZGljYXRpbmdcbiAqICAgd2hpY2ggbWFyayB3aXRoaW4gdGhlIGdyb3VwIHNob3VsZCBiZSBsYWJlbGVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmF2b2lkTWFya3NdIC0gQSBsaXN0IG9mIGFkZGl0aW9uYWwgbWFyayBuYW1lcyBmb3Igd2hpY2ggdGhlIGxhYmVsXG4gKiAgIGxheW91dCBzaG91bGQgYXZvaWQgb3ZlcmxhcC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5hdm9pZEJhc2VNYXJrPXRydWVdIC0gQm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgbGFiZWxzIHNob3VsZCBhdm9pZFxuICogICBvdmVybGFwIHdpdGggdGhlIHVuZGVybHlpbmcgYmFzZSBtYXJrIGJlaW5nIGxhYmVsZWQuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5tZXRob2Q9J25haXZlJ10gLSBGb3IgYXJlYSBtYWtlIGxhYmVscyBvbmx5LCBhIG1ldGhvZCBmb3JcbiAqICAgcGxhY2UgbGFiZWxzLiBPbmUgb2YgJ25haXZlJywgJ3JlZHVjZWQtc2VhcmNoJywgb3IgJ2Zsb29kZmlsbCcuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gVGhlIG91dHB1dCBmaWVsZHMgd3JpdHRlbiBieSB0aGUgdHJhbnNmb3JtLlxuICogICBUaGUgZGVmYXVsdCBpcyBbJ3gnLCAneScsICdvcGFjaXR5JywgJ2FsaWduJywgJ2Jhc2VsaW5lJ10uXG4gKi9cbmZ1bmN0aW9uIExhYmVsKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuTGFiZWwuRGVmaW5pdGlvbiA9IHtcbiAgdHlwZTogJ0xhYmVsJyxcbiAgbWV0YWRhdGE6IHtcbiAgICBtb2RpZmllczogdHJ1ZVxuICB9LFxuICBwYXJhbXM6IFt7XG4gICAgbmFtZTogJ3NpemUnLFxuICAgIHR5cGU6ICdudW1iZXInLFxuICAgIGFycmF5OiB0cnVlLFxuICAgIGxlbmd0aDogMixcbiAgICByZXF1aXJlZDogdHJ1ZVxuICB9LCB7XG4gICAgbmFtZTogJ3NvcnQnLFxuICAgIHR5cGU6ICdjb21wYXJlJ1xuICB9LCB7XG4gICAgbmFtZTogJ2FuY2hvcicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgYXJyYXk6IHRydWUsXG4gICAgZGVmYXVsdDogQW5jaG9yc1xuICB9LCB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgYXJyYXk6IHRydWUsXG4gICAgZGVmYXVsdDogWzFdXG4gIH0sIHtcbiAgICBuYW1lOiAncGFkZGluZycsXG4gICAgdHlwZTogJ251bWJlcicsXG4gICAgZGVmYXVsdDogMCxcbiAgICBudWxsOiB0cnVlXG4gIH0sIHtcbiAgICBuYW1lOiAnbGluZUFuY2hvcicsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgdmFsdWVzOiBbJ3N0YXJ0JywgJ2VuZCddLFxuICAgIGRlZmF1bHQ6ICdlbmQnXG4gIH0sIHtcbiAgICBuYW1lOiAnbWFya0luZGV4JyxcbiAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICBuYW1lOiAnYXZvaWRCYXNlTWFyaycsXG4gICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgIGRlZmF1bHQ6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICdhdm9pZE1hcmtzJyxcbiAgICB0eXBlOiAnZGF0YScsXG4gICAgYXJyYXk6IHRydWVcbiAgfSwge1xuICAgIG5hbWU6ICdtZXRob2QnLFxuICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgIGRlZmF1bHQ6ICduYWl2ZSdcbiAgfSwge1xuICAgIG5hbWU6ICdhcycsXG4gICAgdHlwZTogJ3N0cmluZycsXG4gICAgYXJyYXk6IHRydWUsXG4gICAgbGVuZ3RoOiBPdXRwdXQubGVuZ3RoLFxuICAgIGRlZmF1bHQ6IE91dHB1dFxuICB9XVxufTtcbmluaGVyaXRzKExhYmVsLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgZnVuY3Rpb24gbW9kcChwYXJhbSkge1xuICAgICAgY29uc3QgcCA9IF9bcGFyYW1dO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ocCkgJiYgcHVsc2UubW9kaWZpZWQocC5maWVsZHMpO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCk7XG4gICAgaWYgKCEobW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgbW9kcCgnc29ydCcpKSkgcmV0dXJuO1xuICAgIGlmICghXy5zaXplIHx8IF8uc2l6ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgIGVycm9yKCdTaXplIHBhcmFtZXRlciBzaG91bGQgYmUgc3BlY2lmaWVkIGFzIGEgW3dpZHRoLCBoZWlnaHRdIGFycmF5LicpO1xuICAgIH1cbiAgICBjb25zdCBhcyA9IF8uYXMgfHwgT3V0cHV0O1xuXG4gICAgLy8gcnVuIGxhYmVsIGxheW91dFxuICAgIGxhYmVsTGF5b3V0KHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlIHx8IFtdLCBfLnNpemUsIF8uc29ydCwgYXJyYXkoXy5vZmZzZXQgPT0gbnVsbCA/IDEgOiBfLm9mZnNldCksIGFycmF5KF8uYW5jaG9yIHx8IEFuY2hvcnMpLCBfLmF2b2lkTWFya3MgfHwgW10sIF8uYXZvaWRCYXNlTWFyayAhPT0gZmFsc2UsIF8ubGluZUFuY2hvciB8fCAnZW5kJywgXy5tYXJrSW5kZXggfHwgMCwgXy5wYWRkaW5nID09PSB1bmRlZmluZWQgPyAwIDogXy5wYWRkaW5nLCBfLm1ldGhvZCB8fCAnbmFpdmUnKS5mb3JFYWNoKGwgPT4ge1xuICAgICAgLy8gd3JpdGUgbGF5b3V0IHJlc3VsdHMgdG8gZGF0YSBzdHJlYW1cbiAgICAgIGNvbnN0IHQgPSBsLmRhdHVtO1xuICAgICAgdFthc1swXV0gPSBsLng7XG4gICAgICB0W2FzWzFdXSA9IGwueTtcbiAgICAgIHRbYXNbMl1dID0gbC5vcGFjaXR5O1xuICAgICAgdFthc1szXV0gPSBsLmFsaWduO1xuICAgICAgdFthc1s0XV0gPSBsLmJhc2VsaW5lO1xuICAgIH0pO1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyhhcyk7XG4gIH1cbn0pO1xuXG5leHBvcnQgeyBMYWJlbCBhcyBsYWJlbCB9O1xuIiwiaW1wb3J0IHsgZXh0ZW5kLCBlcnJvciwgc3RyaW5nVmFsdWUsIGlzRnVuY3Rpb24sIHRvQm9vbGVhbiwgdG9OdW1iZXIsIHRvRGF0ZSwgdG9TdHJpbmcsIGlkZW50aXR5LCBmaWVsZCwgaXNPYmplY3QsIGlzQXJyYXksIGlzSXRlcmFibGUsIGhhc093blByb3BlcnR5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGRzdkZvcm1hdCB9IGZyb20gJ2QzLWRzdic7XG5pbXBvcnQgeyBmZWF0dXJlLCBtZXNoIH0gZnJvbSAndG9wb2pzb24tY2xpZW50JztcbmltcG9ydCB7IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuXG4vLyBNYXRjaGVzIGFic29sdXRlIFVSTHMgd2l0aCBvcHRpb25hbCBwcm90b2NvbFxuLy8gICBodHRwczovLy4uLiAgICBmaWxlOi8vLi4uICAgIC8vLi4uXG5jb25zdCBwcm90b2NvbF9yZSA9IC9eKGRhdGE6fChbQS1aYS16XSs6KT9cXC9cXC8pLztcblxuLy8gTWF0Y2hlcyBhbGxvd2VkIFVSSXMuIEZyb20gaHR0cHM6Ly9naXRodWIuY29tL2N1cmU1My9ET01QdXJpZnkvYmxvYi9tYXN0ZXIvc3JjL3JlZ2V4cC5qcyB3aXRoIGFkZGVkIGZpbGU6Ly9cbmNvbnN0IGFsbG93ZWRfcmUgPSAvXig/Oig/Oig/OmZ8aHQpdHBzP3xtYWlsdG98dGVsfGNhbGx0b3xjaWR8eG1wcHxmaWxlfGRhdGEpOnxbXmEtel18W2EteisuXFwtXSsoPzpbXmEteisuXFwtOl18JCkpL2k7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdXNlbGVzcy1lc2NhcGVcbmNvbnN0IHdoaXRlc3BhY2VfcmUgPSAvW1xcdTAwMDAtXFx1MDAyMFxcdTAwQTBcXHUxNjgwXFx1MTgwRVxcdTIwMDAtXFx1MjAyOVxcdTIwNWZcXHUzMDAwXS9nOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnRyb2wtcmVnZXhcblxuLy8gU3BlY2lhbCB0cmVhdG1lbnQgaW4gbm9kZS5qcyBmb3IgdGhlIGZpbGU6IHByb3RvY29sXG5jb25zdCBmaWxlUHJvdG9jb2wgPSAnZmlsZTovLyc7XG5cbi8qKlxuICogRmFjdG9yeSBmb3IgYSBsb2FkZXIgY29uc3RydWN0b3IgdGhhdCBwcm92aWRlcyBtZXRob2RzIGZvciByZXF1ZXN0aW5nXG4gKiBmaWxlcyBmcm9tIGVpdGhlciB0aGUgbmV0d29yayBvciBkaXNrLCBhbmQgZm9yIHNhbml0aXppbmcgcmVxdWVzdCBVUklzLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gZmV0Y2ggLSBUaGUgRmV0Y2ggQVBJIGZvciBIVFRQIG5ldHdvcmsgcmVxdWVzdHMuXG4gKiAgIElmIG51bGwgb3IgdW5kZWZpbmVkLCBIVFRQIGxvYWRpbmcgd2lsbCBiZSBkaXNhYmxlZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmcyAtIFRoZSBmaWxlIHN5c3RlbSBpbnRlcmZhY2UgZm9yIGZpbGUgbG9hZGluZy5cbiAqICAgSWYgbnVsbCBvciB1bmRlZmluZWQsIGxvY2FsIGZpbGUgbG9hZGluZyB3aWxsIGJlIGRpc2FibGVkLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEEgbG9hZGVyIGNvbnN0cnVjdG9yIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiAgIHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGRlZmF1bHQgbG9hZGluZyBvcHRpb25zIHRvIHVzZS5cbiAqICAgcmV0dXJuIHtvYmplY3R9IC0gQSBuZXcgbG9hZGVyIGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBsb2FkZXJGYWN0b3J5IChmZXRjaCwgZnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPT4gKHtcbiAgICBvcHRpb25zOiBvcHRpb25zIHx8IHt9LFxuICAgIHNhbml0aXplOiBzYW5pdGl6ZSxcbiAgICBsb2FkOiBsb2FkLFxuICAgIGZpbGVBY2Nlc3M6IGZhbHNlLFxuICAgIGZpbGU6IGZpbGVMb2FkZXIoZnMpLFxuICAgIGh0dHA6IGh0dHBMb2FkZXIoZmV0Y2gpXG4gIH0pO1xufVxuXG4vKipcbiAqIExvYWQgYW4gZXh0ZXJuYWwgcmVzb3VyY2UsIHR5cGljYWxseSBlaXRoZXIgZnJvbSB0aGUgd2ViIG9yIGZyb20gdGhlIGxvY2FsXG4gKiBmaWxlc3lzdGVtLiBUaGlzIGZ1bmN0aW9uIHVzZXMge0BsaW5rIHNhbml0aXplfSB0byBmaXJzdCBzYW5pdGl6ZSB0aGUgdXJpLFxuICogdGhlbiBjYWxscyBlaXRoZXIge0BsaW5rIGh0dHB9IChmb3Igd2ViIHJlcXVlc3RzKSBvciB7QGxpbmsgZmlsZX0gKGZvclxuICogZmlsZXN5c3RlbSBsb2FkaW5nKS5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgcmVzb3VyY2UgaW5kaWNhdG9yIChlLmcuLCBVUkwgb3IgZmlsZW5hbWUpLlxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIGxvYWRpbmcgb3B0aW9ucy4gVGhlc2Ugb3B0aW9ucyB3aWxsXG4gKiAgIG92ZXJyaWRlIGFueSBleGlzdGluZyBkZWZhdWx0IG9wdGlvbnMuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBsb2FkZWQgY29udGVudC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gbG9hZCh1cmksIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0ID0gYXdhaXQgdGhpcy5zYW5pdGl6ZSh1cmksIG9wdGlvbnMpLFxuICAgIHVybCA9IG9wdC5ocmVmO1xuICByZXR1cm4gb3B0LmxvY2FsRmlsZSA/IHRoaXMuZmlsZSh1cmwpIDogdGhpcy5odHRwKHVybCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogVVJJIHNhbml0aXplciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgdXJpICh1cmwgb3IgZmlsZW5hbWUpIHRvIGNoZWNrLlxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIGhhc2guXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIG9iamVjdCBjb250YWluaW5nXG4gKiAgc2FuaXRpemVkIHVyaSBkYXRhLCBvciByZWplY3RzIGl0IHRoZSBpbnB1dCB1cmkgaXMgZGVlbWVkIGludmFsaWQuXG4gKiAgVGhlIHByb3BlcnRpZXMgb2YgdGhlIHJlc29sdmVkIG9iamVjdCBhcmUgYXNzdW1lZCB0byBiZVxuICogIHZhbGlkIGF0dHJpYnV0ZXMgZm9yIGFuIEhUTUwgJ2EnIHRhZy4gVGhlIHNhbml0aXplZCB1cmkgKm11c3QqIGJlXG4gKiAgcHJvdmlkZWQgYnkgdGhlICdocmVmJyBwcm9wZXJ0eSBvZiB0aGUgcmV0dXJuZWQgb2JqZWN0LlxuICovXG5hc3luYyBmdW5jdGlvbiBzYW5pdGl6ZSh1cmksIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IGV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgY29uc3QgZmlsZUFjY2VzcyA9IHRoaXMuZmlsZUFjY2VzcyxcbiAgICByZXN1bHQgPSB7XG4gICAgICBocmVmOiBudWxsXG4gICAgfTtcbiAgbGV0IGlzRmlsZSwgbG9hZEZpbGUsIGJhc2U7XG4gIGNvbnN0IGlzQWxsb3dlZCA9IGFsbG93ZWRfcmUudGVzdCh1cmkucmVwbGFjZSh3aGl0ZXNwYWNlX3JlLCAnJykpO1xuICBpZiAodXJpID09IG51bGwgfHwgdHlwZW9mIHVyaSAhPT0gJ3N0cmluZycgfHwgIWlzQWxsb3dlZCkge1xuICAgIGVycm9yKCdTYW5pdGl6ZSBmYWlsdXJlLCBpbnZhbGlkIFVSSTogJyArIHN0cmluZ1ZhbHVlKHVyaSkpO1xuICB9XG4gIGNvbnN0IGhhc1Byb3RvY29sID0gcHJvdG9jb2xfcmUudGVzdCh1cmkpO1xuXG4gIC8vIGlmIHJlbGF0aXZlIHVybCAobm8gcHJvdG9jb2wvaG9zdCksIHByZXBlbmQgYmFzZVVSTFxuICBpZiAoKGJhc2UgPSBvcHRpb25zLmJhc2VVUkwpICYmICFoYXNQcm90b2NvbCkge1xuICAgIC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgc2xhc2ggYmV0d2VlbiB0aGUgYmFzZVVSTCAoZS5nLiBob3N0bmFtZSkgYW5kIHVybFxuICAgIGlmICghdXJpLnN0YXJ0c1dpdGgoJy8nKSAmJiAhYmFzZS5lbmRzV2l0aCgnLycpKSB7XG4gICAgICB1cmkgPSAnLycgKyB1cmk7XG4gICAgfVxuICAgIHVyaSA9IGJhc2UgKyB1cmk7XG4gIH1cblxuICAvLyBzaG91bGQgd2UgbG9hZCBmcm9tIGZpbGUgc3lzdGVtP1xuICBsb2FkRmlsZSA9IChpc0ZpbGUgPSB1cmkuc3RhcnRzV2l0aChmaWxlUHJvdG9jb2wpKSB8fCBvcHRpb25zLm1vZGUgPT09ICdmaWxlJyB8fCBvcHRpb25zLm1vZGUgIT09ICdodHRwJyAmJiAhaGFzUHJvdG9jb2wgJiYgZmlsZUFjY2VzcztcbiAgaWYgKGlzRmlsZSkge1xuICAgIC8vIHN0cmlwIGZpbGUgcHJvdG9jb2xcbiAgICB1cmkgPSB1cmkuc2xpY2UoZmlsZVByb3RvY29sLmxlbmd0aCk7XG4gIH0gZWxzZSBpZiAodXJpLnN0YXJ0c1dpdGgoJy8vJykpIHtcbiAgICBpZiAob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgPT09ICdmaWxlJykge1xuICAgICAgLy8gaWYgaXMgZmlsZSwgc3RyaXAgcHJvdG9jb2wgYW5kIHNldCBsb2FkRmlsZSBmbGFnXG4gICAgICB1cmkgPSB1cmkuc2xpY2UoMik7XG4gICAgICBsb2FkRmlsZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHJlbGF0aXZlIHByb3RvY29sIChzdGFydHMgd2l0aCAnLy8nKSwgcHJlcGVuZCBkZWZhdWx0IHByb3RvY29sXG4gICAgICB1cmkgPSAob3B0aW9ucy5kZWZhdWx0UHJvdG9jb2wgfHwgJ2h0dHAnKSArICc6JyArIHVyaTtcbiAgICB9XG4gIH1cblxuICAvLyBzZXQgbm9uLWVudW1lcmFibGUgbW9kZSBmbGFnIHRvIGluZGljYXRlIGxvY2FsIGZpbGUgbG9hZFxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCAnbG9jYWxGaWxlJywge1xuICAgIHZhbHVlOiAhIWxvYWRGaWxlXG4gIH0pO1xuXG4gIC8vIHNldCB1cmlcbiAgcmVzdWx0LmhyZWYgPSB1cmk7XG5cbiAgLy8gc2V0IGRlZmF1bHQgcmVzdWx0IHRhcmdldCwgaWYgc3BlY2lmaWVkXG4gIGlmIChvcHRpb25zLnRhcmdldCkge1xuICAgIHJlc3VsdC50YXJnZXQgPSBvcHRpb25zLnRhcmdldCArICcnO1xuICB9XG5cbiAgLy8gc2V0IGRlZmF1bHQgcmVzdWx0IHJlbCwgaWYgc3BlY2lmaWVkICgjMTU0MilcbiAgaWYgKG9wdGlvbnMucmVsKSB7XG4gICAgcmVzdWx0LnJlbCA9IG9wdGlvbnMucmVsICsgJyc7XG4gIH1cblxuICAvLyBwcm92aWRlIGNvbnRyb2wgb3ZlciBjcm9zcy1vcmlnaW4gaW1hZ2UgaGFuZGxpbmcgKCMyMjM4KVxuICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0NPUlNfZW5hYmxlZF9pbWFnZVxuICBpZiAob3B0aW9ucy5jb250ZXh0ID09PSAnaW1hZ2UnICYmIG9wdGlvbnMuY3Jvc3NPcmlnaW4pIHtcbiAgICByZXN1bHQuY3Jvc3NPcmlnaW4gPSBvcHRpb25zLmNyb3NzT3JpZ2luICsgJyc7XG4gIH1cblxuICAvLyByZXR1cm5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBGaWxlIHN5c3RlbSBsb2FkZXIgZmFjdG9yeS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBmcyAtIFRoZSBmaWxlIHN5c3RlbSBpbnRlcmZhY2UuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gLSBBIGZpbGUgbG9hZGVyIHdpdGggdGhlIGZvbGxvd2luZyBzaWduYXR1cmU6XG4gKiAgIHBhcmFtIHtzdHJpbmd9IGZpbGVuYW1lIC0gVGhlIGZpbGUgc3lzdGVtIHBhdGggdG8gbG9hZC5cbiAqICAgcGFyYW0ge3N0cmluZ30gZmlsZW5hbWUgLSBUaGUgZmlsZSBzeXN0ZW0gcGF0aCB0byBsb2FkLlxuICogICByZXR1cm4ge1Byb21pc2V9IEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSBmaWxlIGNvbnRlbnRzLlxuICovXG5mdW5jdGlvbiBmaWxlTG9hZGVyKGZzKSB7XG4gIHJldHVybiBmcyA/IGZpbGVuYW1lID0+IG5ldyBQcm9taXNlKChhY2NlcHQsIHJlamVjdCkgPT4ge1xuICAgIGZzLnJlYWRGaWxlKGZpbGVuYW1lLCAoZXJyb3IsIGRhdGEpID0+IHtcbiAgICAgIGlmIChlcnJvcikgcmVqZWN0KGVycm9yKTtlbHNlIGFjY2VwdChkYXRhKTtcbiAgICB9KTtcbiAgfSkgOiBmaWxlUmVqZWN0O1xufVxuXG4vKipcbiAqIERlZmF1bHQgZmlsZSBzeXN0ZW0gbG9hZGVyIHRoYXQgc2ltcGx5IHJlamVjdHMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZpbGVSZWplY3QoKSB7XG4gIGVycm9yKCdObyBmaWxlIHN5c3RlbSBhY2Nlc3MuJyk7XG59XG5cbi8qKlxuICogSFRUUCByZXF1ZXN0IGhhbmRsZXIgZmFjdG9yeS5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZldGNoIC0gVGhlIEZldGNoIEFQSSBtZXRob2QuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn0gLSBBbiBodHRwIGxvYWRlciB3aXRoIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICogICBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgdXJsIHRvIHJlcXVlc3QuXG4gKiAgIHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBBbiBvcHRpb25zIGhhc2guXG4gKiAgIHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUgZmlsZSBjb250ZW50cy5cbiAqL1xuZnVuY3Rpb24gaHR0cExvYWRlcihmZXRjaCkge1xuICByZXR1cm4gZmV0Y2ggPyBhc3luYyBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3B0ID0gZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMuaHR0cCwgb3B0aW9ucyksXG4gICAgICB0eXBlID0gb3B0aW9ucyAmJiBvcHRpb25zLnJlc3BvbnNlLFxuICAgICAgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIG9wdCk7XG4gICAgcmV0dXJuICFyZXNwb25zZS5vayA/IGVycm9yKHJlc3BvbnNlLnN0YXR1cyArICcnICsgcmVzcG9uc2Uuc3RhdHVzVGV4dCkgOiBpc0Z1bmN0aW9uKHJlc3BvbnNlW3R5cGVdKSA/IHJlc3BvbnNlW3R5cGVdKCkgOiByZXNwb25zZS50ZXh0KCk7XG4gIH0gOiBodHRwUmVqZWN0O1xufVxuXG4vKipcbiAqIERlZmF1bHQgaHR0cCByZXF1ZXN0IGhhbmRsZXIgdGhhdCBzaW1wbHkgcmVqZWN0cy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gaHR0cFJlamVjdCgpIHtcbiAgZXJyb3IoJ05vIEhUVFAgZmV0Y2ggbWV0aG9kIGF2YWlsYWJsZS4nKTtcbn1cblxuY29uc3QgaXNWYWxpZCA9IF8gPT4gXyAhPSBudWxsICYmIF8gPT09IF87XG5jb25zdCBpc0Jvb2xlYW4gPSBfID0+IF8gPT09ICd0cnVlJyB8fCBfID09PSAnZmFsc2UnIHx8IF8gPT09IHRydWUgfHwgXyA9PT0gZmFsc2U7XG5jb25zdCBpc0RhdGUgPSBfID0+ICFOdW1iZXIuaXNOYU4oRGF0ZS5wYXJzZShfKSk7XG5jb25zdCBpc051bWJlciA9IF8gPT4gIU51bWJlci5pc05hTigrXykgJiYgIShfIGluc3RhbmNlb2YgRGF0ZSk7XG5jb25zdCBpc0ludGVnZXIgPSBfID0+IGlzTnVtYmVyKF8pICYmIE51bWJlci5pc0ludGVnZXIoK18pO1xuY29uc3QgdHlwZVBhcnNlcnMgPSB7XG4gIGJvb2xlYW46IHRvQm9vbGVhbixcbiAgaW50ZWdlcjogdG9OdW1iZXIsXG4gIG51bWJlcjogdG9OdW1iZXIsXG4gIGRhdGU6IHRvRGF0ZSxcbiAgc3RyaW5nOiB0b1N0cmluZyxcbiAgdW5rbm93bjogaWRlbnRpdHlcbn07XG5jb25zdCB0eXBlVGVzdHMgPSBbaXNCb29sZWFuLCBpc0ludGVnZXIsIGlzTnVtYmVyLCBpc0RhdGVdO1xuY29uc3QgdHlwZUxpc3QgPSBbJ2Jvb2xlYW4nLCAnaW50ZWdlcicsICdudW1iZXInLCAnZGF0ZSddO1xuZnVuY3Rpb24gaW5mZXJUeXBlKHZhbHVlcywgZmllbGQpIHtcbiAgaWYgKCF2YWx1ZXMgfHwgIXZhbHVlcy5sZW5ndGgpIHJldHVybiAndW5rbm93bic7XG4gIGNvbnN0IG4gPSB2YWx1ZXMubGVuZ3RoLFxuICAgIG0gPSB0eXBlVGVzdHMubGVuZ3RoLFxuICAgIGEgPSB0eXBlVGVzdHMubWFwKChfLCBpKSA9PiBpICsgMSk7XG4gIGZvciAobGV0IGkgPSAwLCB0ID0gMCwgaiwgdmFsdWU7IGkgPCBuOyArK2kpIHtcbiAgICB2YWx1ZSA9IGZpZWxkID8gdmFsdWVzW2ldW2ZpZWxkXSA6IHZhbHVlc1tpXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBpZiAoYVtqXSAmJiBpc1ZhbGlkKHZhbHVlKSAmJiAhdHlwZVRlc3RzW2pdKHZhbHVlKSkge1xuICAgICAgICBhW2pdID0gMDtcbiAgICAgICAgKyt0O1xuICAgICAgICBpZiAodCA9PT0gdHlwZVRlc3RzLmxlbmd0aCkgcmV0dXJuICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHlwZUxpc3RbYS5yZWR1Y2UoKHUsIHYpID0+IHUgPT09IDAgPyB2IDogdSwgMCkgLSAxXTtcbn1cbmZ1bmN0aW9uIGluZmVyVHlwZXMoZGF0YSwgZmllbGRzKSB7XG4gIHJldHVybiBmaWVsZHMucmVkdWNlKCh0eXBlcywgZmllbGQpID0+IHtcbiAgICB0eXBlc1tmaWVsZF0gPSBpbmZlclR5cGUoZGF0YSwgZmllbGQpO1xuICAgIHJldHVybiB0eXBlcztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBkZWxpbWl0ZWRGb3JtYXQoZGVsaW1pdGVyKSB7XG4gIGNvbnN0IHBhcnNlID0gZnVuY3Rpb24gKGRhdGEsIGZvcm1hdCkge1xuICAgIGNvbnN0IGRlbGltID0ge1xuICAgICAgZGVsaW1pdGVyOiBkZWxpbWl0ZXJcbiAgICB9O1xuICAgIHJldHVybiBkc3YoZGF0YSwgZm9ybWF0ID8gZXh0ZW5kKGZvcm1hdCwgZGVsaW0pIDogZGVsaW0pO1xuICB9O1xuICBwYXJzZS5yZXNwb25zZVR5cGUgPSAndGV4dCc7XG4gIHJldHVybiBwYXJzZTtcbn1cbmZ1bmN0aW9uIGRzdihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKGZvcm1hdC5oZWFkZXIpIHtcbiAgICBkYXRhID0gZm9ybWF0LmhlYWRlci5tYXAoc3RyaW5nVmFsdWUpLmpvaW4oZm9ybWF0LmRlbGltaXRlcikgKyAnXFxuJyArIGRhdGE7XG4gIH1cbiAgcmV0dXJuIGRzdkZvcm1hdChmb3JtYXQuZGVsaW1pdGVyKS5wYXJzZShkYXRhICsgJycpO1xufVxuZHN2LnJlc3BvbnNlVHlwZSA9ICd0ZXh0JztcblxuZnVuY3Rpb24gaXNCdWZmZXIoXykge1xuICByZXR1cm4gdHlwZW9mIEJ1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0Z1bmN0aW9uKEJ1ZmZlci5pc0J1ZmZlcikgPyBCdWZmZXIuaXNCdWZmZXIoXykgOiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGpzb24oZGF0YSwgZm9ybWF0KSB7XG4gIGNvbnN0IHByb3AgPSBmb3JtYXQgJiYgZm9ybWF0LnByb3BlcnR5ID8gZmllbGQoZm9ybWF0LnByb3BlcnR5KSA6IGlkZW50aXR5O1xuICByZXR1cm4gaXNPYmplY3QoZGF0YSkgJiYgIWlzQnVmZmVyKGRhdGEpID8gcGFyc2VKU09OKHByb3AoZGF0YSksIGZvcm1hdCkgOiBwcm9wKEpTT04ucGFyc2UoZGF0YSkpO1xufVxuanNvbi5yZXNwb25zZVR5cGUgPSAnanNvbic7XG5mdW5jdGlvbiBwYXJzZUpTT04oZGF0YSwgZm9ybWF0KSB7XG4gIGlmICghaXNBcnJheShkYXRhKSAmJiBpc0l0ZXJhYmxlKGRhdGEpKSB7XG4gICAgZGF0YSA9IFsuLi5kYXRhXTtcbiAgfVxuICByZXR1cm4gZm9ybWF0ICYmIGZvcm1hdC5jb3B5ID8gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSkgOiBkYXRhO1xufVxuXG5jb25zdCBmaWx0ZXJzID0ge1xuICBpbnRlcmlvcjogKGEsIGIpID0+IGEgIT09IGIsXG4gIGV4dGVyaW9yOiAoYSwgYikgPT4gYSA9PT0gYlxufTtcbmZ1bmN0aW9uIHRvcG9qc29uKGRhdGEsIGZvcm1hdCkge1xuICBsZXQgbWV0aG9kLCBvYmplY3QsIHByb3BlcnR5LCBmaWx0ZXI7XG4gIGRhdGEgPSBqc29uKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LmZlYXR1cmUpIHtcbiAgICBtZXRob2QgPSBmZWF0dXJlO1xuICAgIHByb3BlcnR5ID0gZm9ybWF0LmZlYXR1cmU7XG4gIH0gZWxzZSBpZiAoZm9ybWF0ICYmIGZvcm1hdC5tZXNoKSB7XG4gICAgbWV0aG9kID0gbWVzaDtcbiAgICBwcm9wZXJ0eSA9IGZvcm1hdC5tZXNoO1xuICAgIGZpbHRlciA9IGZpbHRlcnNbZm9ybWF0LmZpbHRlcl07XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ01pc3NpbmcgVG9wb0pTT04gZmVhdHVyZSBvciBtZXNoIHBhcmFtZXRlci4nKTtcbiAgfVxuICBvYmplY3QgPSAob2JqZWN0ID0gZGF0YS5vYmplY3RzW3Byb3BlcnR5XSkgPyBtZXRob2QoZGF0YSwgb2JqZWN0LCBmaWx0ZXIpIDogZXJyb3IoJ0ludmFsaWQgVG9wb0pTT04gb2JqZWN0OiAnICsgcHJvcGVydHkpO1xuICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5mZWF0dXJlcyB8fCBbb2JqZWN0XTtcbn1cbnRvcG9qc29uLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcblxuY29uc3QgZm9ybWF0ID0ge1xuICBkc3Y6IGRzdixcbiAgY3N2OiBkZWxpbWl0ZWRGb3JtYXQoJywnKSxcbiAgdHN2OiBkZWxpbWl0ZWRGb3JtYXQoJ1xcdCcpLFxuICBqc29uOiBqc29uLFxuICB0b3BvanNvbjogdG9wb2pzb25cbn07XG5mdW5jdGlvbiBmb3JtYXRzKG5hbWUsIHJlYWRlcikge1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBmb3JtYXRbbmFtZV0gPSByZWFkZXI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGhhc093blByb3BlcnR5KGZvcm1hdCwgbmFtZSkgPyBmb3JtYXRbbmFtZV0gOiBudWxsO1xuICB9XG59XG5mdW5jdGlvbiByZXNwb25zZVR5cGUodHlwZSkge1xuICBjb25zdCBmID0gZm9ybWF0cyh0eXBlKTtcbiAgcmV0dXJuIGYgJiYgZi5yZXNwb25zZVR5cGUgfHwgJ3RleHQnO1xufVxuXG5mdW5jdGlvbiByZWFkIChkYXRhLCBzY2hlbWEsIHRpbWVQYXJzZXIsIHV0Y1BhcnNlcikge1xuICBzY2hlbWEgPSBzY2hlbWEgfHwge307XG4gIGNvbnN0IHJlYWRlciA9IGZvcm1hdHMoc2NoZW1hLnR5cGUgfHwgJ2pzb24nKTtcbiAgaWYgKCFyZWFkZXIpIGVycm9yKCdVbmtub3duIGRhdGEgZm9ybWF0IHR5cGU6ICcgKyBzY2hlbWEudHlwZSk7XG4gIGRhdGEgPSByZWFkZXIoZGF0YSwgc2NoZW1hKTtcbiAgaWYgKHNjaGVtYS5wYXJzZSkgcGFyc2UoZGF0YSwgc2NoZW1hLnBhcnNlLCB0aW1lUGFyc2VyLCB1dGNQYXJzZXIpO1xuICBpZiAoaGFzT3duUHJvcGVydHkoZGF0YSwgJ2NvbHVtbnMnKSkgZGVsZXRlIGRhdGEuY29sdW1ucztcbiAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBwYXJzZShkYXRhLCB0eXBlcywgdGltZVBhcnNlciwgdXRjUGFyc2VyKSB7XG4gIGlmICghZGF0YS5sZW5ndGgpIHJldHVybjsgLy8gZWFybHkgZXhpdCBmb3IgZW1wdHkgZGF0YVxuXG4gIGNvbnN0IGxvY2FsZSA9IHRpbWVGb3JtYXREZWZhdWx0TG9jYWxlKCk7XG4gIHRpbWVQYXJzZXIgPSB0aW1lUGFyc2VyIHx8IGxvY2FsZS50aW1lUGFyc2U7XG4gIHV0Y1BhcnNlciA9IHV0Y1BhcnNlciB8fCBsb2NhbGUudXRjUGFyc2U7XG4gIGxldCBmaWVsZHMgPSBkYXRhLmNvbHVtbnMgfHwgT2JqZWN0LmtleXMoZGF0YVswXSksXG4gICAgZGF0dW0sXG4gICAgZmllbGQsXG4gICAgaSxcbiAgICBqLFxuICAgIG4sXG4gICAgbTtcbiAgaWYgKHR5cGVzID09PSAnYXV0bycpIHR5cGVzID0gaW5mZXJUeXBlcyhkYXRhLCBmaWVsZHMpO1xuICBmaWVsZHMgPSBPYmplY3Qua2V5cyh0eXBlcyk7XG4gIGNvbnN0IHBhcnNlcnMgPSBmaWVsZHMubWFwKGZpZWxkID0+IHtcbiAgICBjb25zdCB0eXBlID0gdHlwZXNbZmllbGRdO1xuICAgIGxldCBwYXJ0cywgcGF0dGVybjtcbiAgICBpZiAodHlwZSAmJiAodHlwZS5zdGFydHNXaXRoKCdkYXRlOicpIHx8IHR5cGUuc3RhcnRzV2l0aCgndXRjOicpKSkge1xuICAgICAgcGFydHMgPSB0eXBlLnNwbGl0KC86KC4rKT8vLCAyKTsgLy8gc3BsaXQgb24gZmlyc3QgOlxuICAgICAgcGF0dGVybiA9IHBhcnRzWzFdO1xuICAgICAgaWYgKHBhdHRlcm5bMF0gPT09ICdcXCcnICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGggLSAxXSA9PT0gJ1xcJycgfHwgcGF0dGVyblswXSA9PT0gJ1wiJyAmJiBwYXR0ZXJuW3BhdHRlcm4ubGVuZ3RoIC0gMV0gPT09ICdcIicpIHtcbiAgICAgICAgcGF0dGVybiA9IHBhdHRlcm4uc2xpY2UoMSwgLTEpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyc2UgPSBwYXJ0c1swXSA9PT0gJ3V0YycgPyB1dGNQYXJzZXIgOiB0aW1lUGFyc2VyO1xuICAgICAgcmV0dXJuIHBhcnNlKHBhdHRlcm4pO1xuICAgIH1cbiAgICBpZiAoIXR5cGVQYXJzZXJzW3R5cGVdKSB7XG4gICAgICB0aHJvdyBFcnJvcignSWxsZWdhbCBmb3JtYXQgcGF0dGVybjogJyArIGZpZWxkICsgJzonICsgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiB0eXBlUGFyc2Vyc1t0eXBlXTtcbiAgfSk7XG4gIGZvciAoaSA9IDAsIG4gPSBkYXRhLmxlbmd0aCwgbSA9IGZpZWxkcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBkYXR1bSA9IGRhdGFbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgZmllbGQgPSBmaWVsZHNbal07XG4gICAgICBkYXR1bVtmaWVsZF0gPSBwYXJzZXJzW2pdKGRhdHVtW2ZpZWxkXSk7XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGxvYWRlciA9IGxvYWRlckZhY3RvcnkodHlwZW9mIGZldGNoICE9PSAndW5kZWZpbmVkJyAmJiBmZXRjaCxcbi8vIHVzZSBidWlsdC1pbiBmZXRjaCBBUElcbm51bGwgLy8gbm8gZmlsZSBzeXN0ZW0gYWNjZXNzXG4pO1xuXG5leHBvcnQgeyBmb3JtYXQsIGZvcm1hdHMsIGluZmVyVHlwZSwgaW5mZXJUeXBlcywgbG9hZGVyLCByZWFkLCByZXNwb25zZVR5cGUsIHR5cGVQYXJzZXJzIH07XG4iLCJpbXBvcnQgeyBpc09iamVjdCwgZXh0ZW5kLCBoYXNPd25Qcm9wZXJ0eSwgaXNBcnJheSwgYXJyYXksIHN0cmluZ1ZhbHVlLCBwZWVrLCBpc1N0cmluZywgZXJyb3IsIHNwbGl0QWNjZXNzUGF0aCwgbWVyZ2VDb25maWcgfSBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAndmVnYS1mdW5jdGlvbnMnO1xuaW1wb3J0IHsgcGFyc2VTZWxlY3RvciB9IGZyb20gJ3ZlZ2EtZXZlbnQtc2VsZWN0b3InO1xuaW1wb3J0IHsgaXNWYWxpZFNjYWxlVHlwZSwgaXNEaXNjcmV0ZSwgaXNRdWFudGlsZSwgaXNDb250aW51b3VzLCBpc0Rpc2NyZXRpemluZyB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuaW1wb3J0IHsgZGVmaW5pdGlvbiBhcyBkZWZpbml0aW9uJDEgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcblxuZnVuY3Rpb24gcGFyc2VBdXRvc2l6ZSAoc3BlYykge1xuICByZXR1cm4gaXNPYmplY3Qoc3BlYykgPyBzcGVjIDoge1xuICAgIHR5cGU6IHNwZWMgfHwgJ3BhZCdcbiAgfTtcbn1cblxuY29uc3QgbnVtYmVyID0gXyA9PiArXyB8fCAwO1xuY29uc3QgcGFkZGluZ09iamVjdCA9IF8gPT4gKHtcbiAgdG9wOiBfLFxuICBib3R0b206IF8sXG4gIGxlZnQ6IF8sXG4gIHJpZ2h0OiBfXG59KTtcbmZ1bmN0aW9uIHBhcnNlUGFkZGluZyAoc3BlYykge1xuICByZXR1cm4gIWlzT2JqZWN0KHNwZWMpID8gcGFkZGluZ09iamVjdChudW1iZXIoc3BlYykpIDogc3BlYy5zaWduYWwgPyBzcGVjIDoge1xuICAgIHRvcDogbnVtYmVyKHNwZWMudG9wKSxcbiAgICBib3R0b206IG51bWJlcihzcGVjLmJvdHRvbSksXG4gICAgbGVmdDogbnVtYmVyKHNwZWMubGVmdCksXG4gICAgcmlnaHQ6IG51bWJlcihzcGVjLnJpZ2h0KVxuICB9O1xufVxuXG5jb25zdCBlbmNvZGVyID0gXyA9PiBpc09iamVjdChfKSAmJiAhaXNBcnJheShfKSA/IGV4dGVuZCh7fSwgXykgOiB7XG4gIHZhbHVlOiBfXG59O1xuZnVuY3Rpb24gYWRkRW5jb2RlKG9iamVjdCwgbmFtZSwgdmFsdWUsIHNldCkge1xuICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgIGNvbnN0IGlzRW5jb2RlciA9IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNBcnJheSh2YWx1ZSkgfHwgaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUubGVuZ3RoICYmIGlzT2JqZWN0KHZhbHVlWzBdKTtcblxuICAgIC8vIEFsd2F5cyBhc3NpZ24gc2lnbmFsIHRvIHVwZGF0ZSwgZXZlbiBpZiB0aGUgc2lnbmFsIGlzIGZyb20gdGhlIGVudGVyIGJsb2NrXG4gICAgaWYgKGlzRW5jb2Rlcikge1xuICAgICAgb2JqZWN0LnVwZGF0ZVtuYW1lXSA9IHZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmplY3Rbc2V0IHx8ICdlbnRlciddW25hbWVdID0ge1xuICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiAxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAwO1xuICB9XG59XG5mdW5jdGlvbiBhZGRFbmNvZGVycyhvYmplY3QsIGVudGVyLCB1cGRhdGUpIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIGVudGVyKSB7XG4gICAgYWRkRW5jb2RlKG9iamVjdCwgbmFtZSwgZW50ZXJbbmFtZV0pO1xuICB9XG4gIGZvciAoY29uc3QgbmFtZSBpbiB1cGRhdGUpIHtcbiAgICBhZGRFbmNvZGUob2JqZWN0LCBuYW1lLCB1cGRhdGVbbmFtZV0sICd1cGRhdGUnKTtcbiAgfVxufVxuZnVuY3Rpb24gZXh0ZW5kRW5jb2RlKGVuY29kZSwgZXh0cmEsIHNraXApIHtcbiAgZm9yIChjb25zdCBuYW1lIGluIGV4dHJhKSB7XG4gICAgaWYgKHNraXAgJiYgaGFzT3duUHJvcGVydHkoc2tpcCwgbmFtZSkpIGNvbnRpbnVlO1xuICAgIGVuY29kZVtuYW1lXSA9IGV4dGVuZChlbmNvZGVbbmFtZV0gfHwge30sIGV4dHJhW25hbWVdKTtcbiAgfVxuICByZXR1cm4gZW5jb2RlO1xufVxuZnVuY3Rpb24gaGFzKGtleSwgZW5jb2RlKSB7XG4gIHJldHVybiBlbmNvZGUgJiYgKGVuY29kZS5lbnRlciAmJiBlbmNvZGUuZW50ZXJba2V5XSB8fCBlbmNvZGUudXBkYXRlICYmIGVuY29kZS51cGRhdGVba2V5XSk7XG59XG5cbmNvbnN0IE1hcmtSb2xlID0gJ21hcmsnO1xuY29uc3QgRnJhbWVSb2xlID0gJ2ZyYW1lJztcbmNvbnN0IFNjb3BlUm9sZSA9ICdzY29wZSc7XG5jb25zdCBBeGlzUm9sZSA9ICdheGlzJztcbmNvbnN0IEF4aXNEb21haW5Sb2xlID0gJ2F4aXMtZG9tYWluJztcbmNvbnN0IEF4aXNHcmlkUm9sZSA9ICdheGlzLWdyaWQnO1xuY29uc3QgQXhpc0xhYmVsUm9sZSA9ICdheGlzLWxhYmVsJztcbmNvbnN0IEF4aXNUaWNrUm9sZSA9ICdheGlzLXRpY2snO1xuY29uc3QgQXhpc1RpdGxlUm9sZSA9ICdheGlzLXRpdGxlJztcbmNvbnN0IExlZ2VuZFJvbGUgPSAnbGVnZW5kJztcbmNvbnN0IExlZ2VuZEJhbmRSb2xlID0gJ2xlZ2VuZC1iYW5kJztcbmNvbnN0IExlZ2VuZEVudHJ5Um9sZSA9ICdsZWdlbmQtZW50cnknO1xuY29uc3QgTGVnZW5kR3JhZGllbnRSb2xlID0gJ2xlZ2VuZC1ncmFkaWVudCc7XG5jb25zdCBMZWdlbmRMYWJlbFJvbGUgPSAnbGVnZW5kLWxhYmVsJztcbmNvbnN0IExlZ2VuZFN5bWJvbFJvbGUgPSAnbGVnZW5kLXN5bWJvbCc7XG5jb25zdCBMZWdlbmRUaXRsZVJvbGUgPSAnbGVnZW5kLXRpdGxlJztcbmNvbnN0IFRpdGxlUm9sZSA9ICd0aXRsZSc7XG5jb25zdCBUaXRsZVRleHRSb2xlID0gJ3RpdGxlLXRleHQnO1xuY29uc3QgVGl0bGVTdWJ0aXRsZVJvbGUgPSAndGl0bGUtc3VidGl0bGUnO1xuXG5mdW5jdGlvbiBhcHBseURlZmF1bHRzIChlbmNvZGUsIHR5cGUsIHJvbGUsIHN0eWxlLCBjb25maWcpIHtcbiAgY29uc3QgZGVmYXVsdHMgPSB7fSxcbiAgICBlbnRlciA9IHt9O1xuICBsZXQgdXBkYXRlLCBrZXksIHNraXAsIHByb3BzO1xuXG4gIC8vIGlmIHRleHQgbWFyaywgYXBwbHkgZ2xvYmFsIGxpbmVCcmVhayBzZXR0aW5ncyAoIzIzNzApXG4gIGtleSA9ICdsaW5lQnJlYWsnO1xuICBpZiAodHlwZSA9PT0gJ3RleHQnICYmIGNvbmZpZ1trZXldICE9IG51bGwgJiYgIWhhcyhrZXksIGVuY29kZSkpIHtcbiAgICBhcHBseURlZmF1bHQoZGVmYXVsdHMsIGtleSwgY29uZmlnW2tleV0pO1xuICB9XG5cbiAgLy8gaWdub3JlIGxlZ2VuZCBhbmQgYXhpcyByb2xlc1xuICBpZiAocm9sZSA9PSAnbGVnZW5kJyB8fCBTdHJpbmcocm9sZSkuc3RhcnRzV2l0aCgnYXhpcycpKSB7XG4gICAgcm9sZSA9IG51bGw7XG4gIH1cblxuICAvLyByZXNvbHZlIG1hcmsgY29uZmlnXG4gIHByb3BzID0gcm9sZSA9PT0gRnJhbWVSb2xlID8gY29uZmlnLmdyb3VwIDogcm9sZSA9PT0gTWFya1JvbGUgPyBleHRlbmQoe30sIGNvbmZpZy5tYXJrLCBjb25maWdbdHlwZV0pIDogbnVsbDtcbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICAvLyBkbyBub3QgYXBwbHkgZGVmYXVsdHMgaWYgcmVsZXZhbnQgZmllbGRzIGFyZSBkZWZpbmVkXG4gICAgc2tpcCA9IGhhcyhrZXksIGVuY29kZSkgfHwgKGtleSA9PT0gJ2ZpbGwnIHx8IGtleSA9PT0gJ3N0cm9rZScpICYmIChoYXMoJ2ZpbGwnLCBlbmNvZGUpIHx8IGhhcygnc3Ryb2tlJywgZW5jb2RlKSk7XG4gICAgaWYgKCFza2lwKSBhcHBseURlZmF1bHQoZGVmYXVsdHMsIGtleSwgcHJvcHNba2V5XSk7XG4gIH1cblxuICAvLyByZXNvbHZlIHN0eWxlcywgYXBwbHkgd2l0aCBpbmNyZWFzaW5nIHByZWNlZGVuY2VcbiAgYXJyYXkoc3R5bGUpLmZvckVhY2gobmFtZSA9PiB7XG4gICAgY29uc3QgcHJvcHMgPSBjb25maWcuc3R5bGUgJiYgY29uZmlnLnN0eWxlW25hbWVdO1xuICAgIGZvciAoY29uc3Qga2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIWhhcyhrZXksIGVuY29kZSkpIHtcbiAgICAgICAgYXBwbHlEZWZhdWx0KGRlZmF1bHRzLCBrZXksIHByb3BzW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIGVuY29kZSA9IGV4dGVuZCh7fSwgZW5jb2RlKTsgLy8gZGVmZW5zaXZlIGNvcHlcbiAgZm9yIChrZXkgaW4gZGVmYXVsdHMpIHtcbiAgICBwcm9wcyA9IGRlZmF1bHRzW2tleV07XG4gICAgaWYgKHByb3BzLnNpZ25hbCkge1xuICAgICAgKHVwZGF0ZSA9IHVwZGF0ZSB8fCB7fSlba2V5XSA9IHByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbnRlcltrZXldID0gcHJvcHM7XG4gICAgfVxuICB9XG4gIGVuY29kZS5lbnRlciA9IGV4dGVuZChlbnRlciwgZW5jb2RlLmVudGVyKTtcbiAgaWYgKHVwZGF0ZSkgZW5jb2RlLnVwZGF0ZSA9IGV4dGVuZCh1cGRhdGUsIGVuY29kZS51cGRhdGUpO1xuICByZXR1cm4gZW5jb2RlO1xufVxuZnVuY3Rpb24gYXBwbHlEZWZhdWx0KGRlZmF1bHRzLCBrZXksIHZhbHVlKSB7XG4gIGRlZmF1bHRzW2tleV0gPSB2YWx1ZSAmJiB2YWx1ZS5zaWduYWwgPyB7XG4gICAgc2lnbmFsOiB2YWx1ZS5zaWduYWxcbiAgfSA6IHtcbiAgICB2YWx1ZTogdmFsdWVcbiAgfTtcbn1cblxuY29uc3Qgc2NhbGVSZWYgPSBzY2FsZSA9PiBpc1N0cmluZyhzY2FsZSkgPyBzdHJpbmdWYWx1ZShzY2FsZSkgOiBzY2FsZS5zaWduYWwgPyBgKCR7c2NhbGUuc2lnbmFsfSlgIDogZmllbGQoc2NhbGUpO1xuZnVuY3Rpb24gZW50cnkkMShlbmMpIHtcbiAgaWYgKGVuYy5ncmFkaWVudCAhPSBudWxsKSB7XG4gICAgcmV0dXJuIGdyYWRpZW50KGVuYyk7XG4gIH1cbiAgbGV0IHZhbHVlID0gZW5jLnNpZ25hbCA/IGAoJHtlbmMuc2lnbmFsfSlgIDogZW5jLmNvbG9yID8gY29sb3IoZW5jLmNvbG9yKSA6IGVuYy5maWVsZCAhPSBudWxsID8gZmllbGQoZW5jLmZpZWxkKSA6IGVuYy52YWx1ZSAhPT0gdW5kZWZpbmVkID8gc3RyaW5nVmFsdWUoZW5jLnZhbHVlKSA6IHVuZGVmaW5lZDtcbiAgaWYgKGVuYy5zY2FsZSAhPSBudWxsKSB7XG4gICAgdmFsdWUgPSBzY2FsZShlbmMsIHZhbHVlKTtcbiAgfVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gbnVsbDtcbiAgfVxuICBpZiAoZW5jLmV4cG9uZW50ICE9IG51bGwpIHtcbiAgICB2YWx1ZSA9IGBwb3coJHt2YWx1ZX0sJHtwcm9wZXJ0eShlbmMuZXhwb25lbnQpfSlgO1xuICB9XG4gIGlmIChlbmMubXVsdCAhPSBudWxsKSB7XG4gICAgdmFsdWUgKz0gYCoke3Byb3BlcnR5KGVuYy5tdWx0KX1gO1xuICB9XG4gIGlmIChlbmMub2Zmc2V0ICE9IG51bGwpIHtcbiAgICB2YWx1ZSArPSBgKyR7cHJvcGVydHkoZW5jLm9mZnNldCl9YDtcbiAgfVxuICBpZiAoZW5jLnJvdW5kKSB7XG4gICAgdmFsdWUgPSBgcm91bmQoJHt2YWx1ZX0pYDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBfY29sb3IgPSAodHlwZSwgeCwgeSwgeikgPT4gYCgke3R5cGV9KCR7W3gsIHksIHpdLm1hcChlbnRyeSQxKS5qb2luKCcsJyl9KSsnJylgO1xuZnVuY3Rpb24gY29sb3IoZW5jKSB7XG4gIHJldHVybiBlbmMuYyA/IF9jb2xvcignaGNsJywgZW5jLmgsIGVuYy5jLCBlbmMubCkgOiBlbmMuaCB8fCBlbmMucyA/IF9jb2xvcignaHNsJywgZW5jLmgsIGVuYy5zLCBlbmMubCkgOiBlbmMubCB8fCBlbmMuYSA/IF9jb2xvcignbGFiJywgZW5jLmwsIGVuYy5hLCBlbmMuYikgOiBlbmMuciB8fCBlbmMuZyB8fCBlbmMuYiA/IF9jb2xvcigncmdiJywgZW5jLnIsIGVuYy5nLCBlbmMuYikgOiBudWxsO1xufVxuZnVuY3Rpb24gZ3JhZGllbnQoZW5jKSB7XG4gIC8vIG1hcCB1bmRlZmluZWQgdG8gbnVsbDsgZXhwcmVzc2lvbiBsYW5nIGRvZXMgbm90IGFsbG93IHVuZGVmaW5lZFxuICBjb25zdCBhcmdzID0gW2VuYy5zdGFydCwgZW5jLnN0b3AsIGVuYy5jb3VudF0ubWFwKF8gPT4gXyA9PSBudWxsID8gbnVsbCA6IHN0cmluZ1ZhbHVlKF8pKTtcblxuICAvLyB0cmltIG51bGwgaW5wdXRzIGZyb20gdGhlIGVuZFxuICB3aGlsZSAoYXJncy5sZW5ndGggJiYgcGVlayhhcmdzKSA9PSBudWxsKSBhcmdzLnBvcCgpO1xuICBhcmdzLnVuc2hpZnQoc2NhbGVSZWYoZW5jLmdyYWRpZW50KSk7XG4gIHJldHVybiBgZ3JhZGllbnQoJHthcmdzLmpvaW4oJywnKX0pYDtcbn1cbmZ1bmN0aW9uIHByb3BlcnR5KHByb3BlcnR5KSB7XG4gIHJldHVybiBpc09iamVjdChwcm9wZXJ0eSkgPyAnKCcgKyBlbnRyeSQxKHByb3BlcnR5KSArICcpJyA6IHByb3BlcnR5O1xufVxuZnVuY3Rpb24gZmllbGQocmVmKSB7XG4gIHJldHVybiByZXNvbHZlRmllbGQoaXNPYmplY3QocmVmKSA/IHJlZiA6IHtcbiAgICBkYXR1bTogcmVmXG4gIH0pO1xufVxuZnVuY3Rpb24gcmVzb2x2ZUZpZWxkKHJlZikge1xuICBsZXQgb2JqZWN0LCBsZXZlbCwgZmllbGQ7XG4gIGlmIChyZWYuc2lnbmFsKSB7XG4gICAgb2JqZWN0ID0gJ2RhdHVtJztcbiAgICBmaWVsZCA9IHJlZi5zaWduYWw7XG4gIH0gZWxzZSBpZiAocmVmLmdyb3VwIHx8IHJlZi5wYXJlbnQpIHtcbiAgICBsZXZlbCA9IE1hdGgubWF4KDEsIHJlZi5sZXZlbCB8fCAxKTtcbiAgICBvYmplY3QgPSAnaXRlbSc7XG4gICAgd2hpbGUgKGxldmVsLS0gPiAwKSB7XG4gICAgICBvYmplY3QgKz0gJy5tYXJrLmdyb3VwJztcbiAgICB9XG4gICAgaWYgKHJlZi5wYXJlbnQpIHtcbiAgICAgIGZpZWxkID0gcmVmLnBhcmVudDtcbiAgICAgIG9iamVjdCArPSAnLmRhdHVtJztcbiAgICB9IGVsc2Uge1xuICAgICAgZmllbGQgPSByZWYuZ3JvdXA7XG4gICAgfVxuICB9IGVsc2UgaWYgKHJlZi5kYXR1bSkge1xuICAgIG9iamVjdCA9ICdkYXR1bSc7XG4gICAgZmllbGQgPSByZWYuZGF0dW07XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgZmllbGQgcmVmZXJlbmNlOiAnICsgc3RyaW5nVmFsdWUocmVmKSk7XG4gIH1cbiAgaWYgKCFyZWYuc2lnbmFsKSB7XG4gICAgZmllbGQgPSBpc1N0cmluZyhmaWVsZCkgPyBzcGxpdEFjY2Vzc1BhdGgoZmllbGQpLm1hcChzdHJpbmdWYWx1ZSkuam9pbignXVsnKSA6IHJlc29sdmVGaWVsZChmaWVsZCk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdCArICdbJyArIGZpZWxkICsgJ10nO1xufVxuZnVuY3Rpb24gc2NhbGUoZW5jLCB2YWx1ZSkge1xuICBjb25zdCBzY2FsZSA9IHNjYWxlUmVmKGVuYy5zY2FsZSk7XG4gIGlmIChlbmMucmFuZ2UgIT0gbnVsbCkge1xuICAgIC8vIHB1bGwgdmFsdWUgZnJvbSBzY2FsZSByYW5nZVxuICAgIHZhbHVlID0gYGxlcnAoX3JhbmdlKCR7c2NhbGV9KSwgJHsrZW5jLnJhbmdlfSlgO1xuICB9IGVsc2Uge1xuICAgIC8vIHJ1biB2YWx1ZSB0aHJvdWdoIHNjYWxlIGFuZC9vciBwdWxsIHNjYWxlIGJhbmR3aWR0aFxuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB2YWx1ZSA9IGBfc2NhbGUoJHtzY2FsZX0sICR7dmFsdWV9KWA7XG4gICAgaWYgKGVuYy5iYW5kKSB7XG4gICAgICB2YWx1ZSA9ICh2YWx1ZSA/IHZhbHVlICsgJysnIDogJycpICsgYF9iYW5kd2lkdGgoJHtzY2FsZX0pYCArICgrZW5jLmJhbmQgPT09IDEgPyAnJyA6ICcqJyArIHByb3BlcnR5KGVuYy5iYW5kKSk7XG4gICAgICBpZiAoZW5jLmV4dHJhKSB7XG4gICAgICAgIC8vIGluY2x1ZGUgbG9naWMgdG8gaGFuZGxlIGV4dHJhbmVvdXMgZWxlbWVudHNcbiAgICAgICAgdmFsdWUgPSBgKGRhdHVtLmV4dHJhID8gX3NjYWxlKCR7c2NhbGV9LCBkYXR1bS5leHRyYS52YWx1ZSkgOiAke3ZhbHVlfSlgO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsdWUgPT0gbnVsbCkgdmFsdWUgPSAnMCc7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiBydWxlIChlbmMpIHtcbiAgbGV0IGNvZGUgPSAnJztcbiAgZW5jLmZvckVhY2gocnVsZSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBlbnRyeSQxKHJ1bGUpO1xuICAgIGNvZGUgKz0gcnVsZS50ZXN0ID8gYCgke3J1bGUudGVzdH0pPyR7dmFsdWV9OmAgOiB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gaWYgbm8gZWxzZSBjbGF1c2UsIHRlcm1pbmF0ZSB3aXRoIG51bGwgKCMxMzY2KVxuICBpZiAocGVlayhjb2RlKSA9PT0gJzonKSB7XG4gICAgY29kZSArPSAnbnVsbCc7XG4gIH1cbiAgcmV0dXJuIGNvZGU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlRW5jb2RlIChlbmNvZGUsIHR5cGUsIHJvbGUsIHN0eWxlLCBzY29wZSwgcGFyYW1zKSB7XG4gIGNvbnN0IGVuYyA9IHt9O1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gIHBhcmFtcy5lbmNvZGVycyA9IHtcbiAgICAkZW5jb2RlOiBlbmNcbiAgfTtcbiAgZW5jb2RlID0gYXBwbHlEZWZhdWx0cyhlbmNvZGUsIHR5cGUsIHJvbGUsIHN0eWxlLCBzY29wZS5jb25maWcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBlbmNvZGUpIHtcbiAgICBlbmNba2V5XSA9IHBhcnNlQmxvY2soZW5jb2RlW2tleV0sIHR5cGUsIHBhcmFtcywgc2NvcGUpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBwYXJzZUJsb2NrKGJsb2NrLCBtYXJrdHlwZSwgcGFyYW1zLCBzY29wZSkge1xuICBjb25zdCBjaGFubmVscyA9IHt9LFxuICAgIGZpZWxkcyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYmxvY2spIHtcbiAgICBpZiAoYmxvY2tbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgLy8gc2tpcCBhbnkgbnVsbCBlbnRyaWVzXG4gICAgICBjaGFubmVsc1tuYW1lXSA9IHBhcnNlJDEoZXhwcihibG9ja1tuYW1lXSksIHNjb3BlLCBwYXJhbXMsIGZpZWxkcyk7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgJGV4cHI6IHtcbiAgICAgIG1hcmt0eXBlLFxuICAgICAgY2hhbm5lbHNcbiAgICB9LFxuICAgICRmaWVsZHM6IE9iamVjdC5rZXlzKGZpZWxkcyksXG4gICAgJG91dHB1dDogT2JqZWN0LmtleXMoYmxvY2spXG4gIH07XG59XG5mdW5jdGlvbiBleHByKGVuYykge1xuICByZXR1cm4gaXNBcnJheShlbmMpID8gcnVsZShlbmMpIDogZW50cnkkMShlbmMpO1xufVxuZnVuY3Rpb24gcGFyc2UkMShjb2RlLCBzY29wZSwgcGFyYW1zLCBmaWVsZHMpIHtcbiAgY29uc3QgZXhwciA9IHBhcnNlRXhwcmVzc2lvbihjb2RlLCBzY29wZSk7XG4gIGV4cHIuJGZpZWxkcy5mb3JFYWNoKG5hbWUgPT4gZmllbGRzW25hbWVdID0gMSk7XG4gIGV4dGVuZChwYXJhbXMsIGV4cHIuJHBhcmFtcyk7XG4gIHJldHVybiBleHByLiRleHByO1xufVxuXG5jb25zdCBPVVRFUiA9ICdvdXRlcicsXG4gIE9VVEVSX0lOVkFMSUQgPSBbJ3ZhbHVlJywgJ3VwZGF0ZScsICdpbml0JywgJ3JlYWN0JywgJ2JpbmQnXTtcbmZ1bmN0aW9uIG91dGVyRXJyb3IocHJlZml4LCBuYW1lKSB7XG4gIGVycm9yKHByZWZpeCArICcgZm9yIFwib3V0ZXJcIiBwdXNoOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xufVxuZnVuY3Rpb24gcGFyc2VTaWduYWwgKHNpZ25hbCwgc2NvcGUpIHtcbiAgY29uc3QgbmFtZSA9IHNpZ25hbC5uYW1lO1xuICBpZiAoc2lnbmFsLnB1c2ggPT09IE9VVEVSKSB7XG4gICAgLy8gc2lnbmFsIG11c3QgYWxyZWFkeSBiZSBkZWZpbmVkLCByYWlzZSBlcnJvciBpZiBub3RcbiAgICBpZiAoIXNjb3BlLnNpZ25hbHNbbmFtZV0pIG91dGVyRXJyb3IoJ05vIHByaW9yIHNpZ25hbCBkZWZpbml0aW9uJywgbmFtZSk7XG4gICAgLy8gc2lnbmFsIHB1c2ggbXVzdCBub3QgdXNlIHByb3BlcnRpZXMgcmVzZXJ2ZWQgZm9yIHN0YW5kYXJkIGRlZmluaXRpb25cbiAgICBPVVRFUl9JTlZBTElELmZvckVhY2gocHJvcCA9PiB7XG4gICAgICBpZiAoc2lnbmFsW3Byb3BdICE9PSB1bmRlZmluZWQpIG91dGVyRXJyb3IoJ0ludmFsaWQgcHJvcGVydHkgJywgcHJvcCk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZGVmaW5lIGEgbmV3IHNpZ25hbCBpbiB0aGUgY3VycmVudCBzY29wZVxuICAgIGNvbnN0IG9wID0gc2NvcGUuYWRkU2lnbmFsKG5hbWUsIHNpZ25hbC52YWx1ZSk7XG4gICAgaWYgKHNpZ25hbC5yZWFjdCA9PT0gZmFsc2UpIG9wLnJlYWN0ID0gZmFsc2U7XG4gICAgaWYgKHNpZ25hbC5iaW5kKSBzY29wZS5hZGRCaW5kaW5nKG5hbWUsIHNpZ25hbC5iaW5kKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBFbnRyeSh0eXBlLCB2YWx1ZSwgcGFyYW1zLCBwYXJlbnQpIHtcbiAgdGhpcy5pZCA9IC0xO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICBpZiAocGFyZW50KSB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn1cbmZ1bmN0aW9uIGVudHJ5KHR5cGUsIHZhbHVlLCBwYXJhbXMsIHBhcmVudCkge1xuICByZXR1cm4gbmV3IEVudHJ5KHR5cGUsIHZhbHVlLCBwYXJhbXMsIHBhcmVudCk7XG59XG5mdW5jdGlvbiBvcGVyYXRvcih2YWx1ZSwgcGFyYW1zKSB7XG4gIHJldHVybiBlbnRyeSgnb3BlcmF0b3InLCB2YWx1ZSwgcGFyYW1zKTtcbn1cblxuLy8gLS0tLS1cblxuZnVuY3Rpb24gcmVmKG9wKSB7XG4gIGNvbnN0IHJlZiA9IHtcbiAgICAkcmVmOiBvcC5pZFxuICB9O1xuICAvLyBpZiBvcGVyYXRvciBub3QgeWV0IHJlZ2lzdGVyZWQsIGNhY2hlIHJlZiB0byByZXNvbHZlIGxhdGVyXG4gIGlmIChvcC5pZCA8IDApIChvcC5yZWZzID0gb3AucmVmcyB8fCBbXSkucHVzaChyZWYpO1xuICByZXR1cm4gcmVmO1xufVxuZnVuY3Rpb24gZmllbGRSZWYkMShmaWVsZCwgbmFtZSkge1xuICByZXR1cm4gbmFtZSA/IHtcbiAgICAkZmllbGQ6IGZpZWxkLFxuICAgICRuYW1lOiBuYW1lXG4gIH0gOiB7XG4gICAgJGZpZWxkOiBmaWVsZFxuICB9O1xufVxuY29uc3Qga2V5RmllbGRSZWYgPSBmaWVsZFJlZiQxKCdrZXknKTtcbmZ1bmN0aW9uIGNvbXBhcmVSZWYoZmllbGRzLCBvcmRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkY29tcGFyZTogZmllbGRzLFxuICAgICRvcmRlcjogb3JkZXJzXG4gIH07XG59XG5mdW5jdGlvbiBrZXlSZWYoZmllbGRzLCBmbGF0KSB7XG4gIGNvbnN0IHJlZiA9IHtcbiAgICAka2V5OiBmaWVsZHNcbiAgfTtcbiAgaWYgKGZsYXQpIHJlZi4kZmxhdCA9IHRydWU7XG4gIHJldHVybiByZWY7XG59XG5cbi8vIC0tLS0tXG5cbmNvbnN0IEFzY2VuZGluZyA9ICdhc2NlbmRpbmcnO1xuY29uc3QgRGVzY2VuZGluZyA9ICdkZXNjZW5kaW5nJztcbmZ1bmN0aW9uIHNvcnRLZXkoc29ydCkge1xuICByZXR1cm4gIWlzT2JqZWN0KHNvcnQpID8gJycgOiAoc29ydC5vcmRlciA9PT0gRGVzY2VuZGluZyA/ICctJyA6ICcrJykgKyBhZ2dyRmllbGQoc29ydC5vcCwgc29ydC5maWVsZCk7XG59XG5mdW5jdGlvbiBhZ2dyRmllbGQob3AsIGZpZWxkKSB7XG4gIHJldHVybiAob3AgJiYgb3Auc2lnbmFsID8gJyQnICsgb3Auc2lnbmFsIDogb3AgfHwgJycpICsgKG9wICYmIGZpZWxkID8gJ18nIDogJycpICsgKGZpZWxkICYmIGZpZWxkLnNpZ25hbCA/ICckJyArIGZpZWxkLnNpZ25hbCA6IGZpZWxkIHx8ICcnKTtcbn1cblxuLy8gLS0tLS1cblxuY29uc3QgU2NvcGUkMSA9ICdzY29wZSc7XG5jb25zdCBWaWV3ID0gJ3ZpZXcnO1xuZnVuY3Rpb24gaXNTaWduYWwoXykge1xuICByZXR1cm4gXyAmJiBfLnNpZ25hbDtcbn1cbmZ1bmN0aW9uIGlzRXhwciQxKF8pIHtcbiAgcmV0dXJuIF8gJiYgXy5leHByO1xufVxuZnVuY3Rpb24gaGFzU2lnbmFsKF8pIHtcbiAgaWYgKGlzU2lnbmFsKF8pKSByZXR1cm4gdHJ1ZTtcbiAgaWYgKGlzT2JqZWN0KF8pKSBmb3IgKGNvbnN0IGtleSBpbiBfKSB7XG4gICAgaWYgKGhhc1NpZ25hbChfW2tleV0pKSByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiB2YWx1ZShzcGVjVmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4gc3BlY1ZhbHVlICE9IG51bGwgPyBzcGVjVmFsdWUgOiBkZWZhdWx0VmFsdWU7XG59XG5mdW5jdGlvbiBkZXJlZih2KSB7XG4gIHJldHVybiB2ICYmIHYuc2lnbmFsIHx8IHY7XG59XG5cbmNvbnN0IFRpbWVyID0gJ3RpbWVyJztcbmZ1bmN0aW9uIHBhcnNlU3RyZWFtKHN0cmVhbSwgc2NvcGUpIHtcbiAgY29uc3QgbWV0aG9kID0gc3RyZWFtLm1lcmdlID8gbWVyZ2VTdHJlYW0gOiBzdHJlYW0uc3RyZWFtID8gbmVzdGVkU3RyZWFtIDogc3RyZWFtLnR5cGUgPyBldmVudFN0cmVhbSA6IGVycm9yKCdJbnZhbGlkIHN0cmVhbSBzcGVjaWZpY2F0aW9uOiAnICsgc3RyaW5nVmFsdWUoc3RyZWFtKSk7XG4gIHJldHVybiBtZXRob2Qoc3RyZWFtLCBzY29wZSk7XG59XG5mdW5jdGlvbiBldmVudFNvdXJjZShzb3VyY2UpIHtcbiAgcmV0dXJuIHNvdXJjZSA9PT0gU2NvcGUkMSA/IFZpZXcgOiBzb3VyY2UgfHwgVmlldztcbn1cbmZ1bmN0aW9uIG1lcmdlU3RyZWFtKHN0cmVhbSwgc2NvcGUpIHtcbiAgY29uc3QgbGlzdCA9IHN0cmVhbS5tZXJnZS5tYXAocyA9PiBwYXJzZVN0cmVhbShzLCBzY29wZSkpLFxuICAgIGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgICBtZXJnZTogbGlzdFxuICAgIH0sIHN0cmVhbSwgc2NvcGUpO1xuICByZXR1cm4gc2NvcGUuYWRkU3RyZWFtKGVudHJ5KS5pZDtcbn1cbmZ1bmN0aW9uIG5lc3RlZFN0cmVhbShzdHJlYW0sIHNjb3BlKSB7XG4gIGNvbnN0IGlkID0gcGFyc2VTdHJlYW0oc3RyZWFtLnN0cmVhbSwgc2NvcGUpLFxuICAgIGVudHJ5ID0gc3RyZWFtUGFyYW1ldGVycyh7XG4gICAgICBzdHJlYW06IGlkXG4gICAgfSwgc3RyZWFtLCBzY29wZSk7XG4gIHJldHVybiBzY29wZS5hZGRTdHJlYW0oZW50cnkpLmlkO1xufVxuZnVuY3Rpb24gZXZlbnRTdHJlYW0oc3RyZWFtLCBzY29wZSkge1xuICBsZXQgaWQ7XG4gIGlmIChzdHJlYW0udHlwZSA9PT0gVGltZXIpIHtcbiAgICBpZCA9IHNjb3BlLmV2ZW50KFRpbWVyLCBzdHJlYW0udGhyb3R0bGUpO1xuICAgIHN0cmVhbSA9IHtcbiAgICAgIGJldHdlZW46IHN0cmVhbS5iZXR3ZWVuLFxuICAgICAgZmlsdGVyOiBzdHJlYW0uZmlsdGVyXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICBpZCA9IHNjb3BlLmV2ZW50KGV2ZW50U291cmNlKHN0cmVhbS5zb3VyY2UpLCBzdHJlYW0udHlwZSk7XG4gIH1cbiAgY29uc3QgZW50cnkgPSBzdHJlYW1QYXJhbWV0ZXJzKHtcbiAgICBzdHJlYW06IGlkXG4gIH0sIHN0cmVhbSwgc2NvcGUpO1xuICByZXR1cm4gT2JqZWN0LmtleXMoZW50cnkpLmxlbmd0aCA9PT0gMSA/IGlkIDogc2NvcGUuYWRkU3RyZWFtKGVudHJ5KS5pZDtcbn1cbmZ1bmN0aW9uIHN0cmVhbVBhcmFtZXRlcnMoZW50cnksIHN0cmVhbSwgc2NvcGUpIHtcbiAgbGV0IHBhcmFtID0gc3RyZWFtLmJldHdlZW47XG4gIGlmIChwYXJhbSkge1xuICAgIGlmIChwYXJhbS5sZW5ndGggIT09IDIpIHtcbiAgICAgIGVycm9yKCdTdHJlYW0gXCJiZXR3ZWVuXCIgcGFyYW1ldGVyIG11c3QgaGF2ZSAyIGVudHJpZXM6ICcgKyBzdHJpbmdWYWx1ZShzdHJlYW0pKTtcbiAgICB9XG4gICAgZW50cnkuYmV0d2VlbiA9IFtwYXJzZVN0cmVhbShwYXJhbVswXSwgc2NvcGUpLCBwYXJzZVN0cmVhbShwYXJhbVsxXSwgc2NvcGUpXTtcbiAgfVxuICBwYXJhbSA9IHN0cmVhbS5maWx0ZXIgPyBbXS5jb25jYXQoc3RyZWFtLmZpbHRlcikgOiBbXTtcbiAgaWYgKHN0cmVhbS5tYXJrdHlwZSB8fCBzdHJlYW0ubWFya25hbWUgfHwgc3RyZWFtLm1hcmtyb2xlKSB7XG4gICAgLy8gYWRkIGZpbHRlciBmb3IgbWFyayB0eXBlLCBuYW1lIGFuZC9vciByb2xlXG4gICAgcGFyYW0ucHVzaChmaWx0ZXJNYXJrKHN0cmVhbS5tYXJrdHlwZSwgc3RyZWFtLm1hcmtuYW1lLCBzdHJlYW0ubWFya3JvbGUpKTtcbiAgfVxuICBpZiAoc3RyZWFtLnNvdXJjZSA9PT0gU2NvcGUkMSkge1xuICAgIC8vIGFkZCBmaWx0ZXIgdG8gbGltaXQgZXZlbnRzIGZyb20gc3ViLXNjb3BlIG9ubHlcbiAgICBwYXJhbS5wdXNoKCdpblNjb3BlKGV2ZW50Lml0ZW0pJyk7XG4gIH1cbiAgaWYgKHBhcmFtLmxlbmd0aCkge1xuICAgIGVudHJ5LmZpbHRlciA9IHBhcnNlRXhwcmVzc2lvbignKCcgKyBwYXJhbS5qb2luKCcpJiYoJykgKyAnKScsIHNjb3BlKS4kZXhwcjtcbiAgfVxuICBpZiAoKHBhcmFtID0gc3RyZWFtLnRocm90dGxlKSAhPSBudWxsKSB7XG4gICAgZW50cnkudGhyb3R0bGUgPSArcGFyYW07XG4gIH1cbiAgaWYgKChwYXJhbSA9IHN0cmVhbS5kZWJvdW5jZSkgIT0gbnVsbCkge1xuICAgIGVudHJ5LmRlYm91bmNlID0gK3BhcmFtO1xuICB9XG4gIGlmIChzdHJlYW0uY29uc3VtZSkge1xuICAgIGVudHJ5LmNvbnN1bWUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBlbnRyeTtcbn1cbmZ1bmN0aW9uIGZpbHRlck1hcmsodHlwZSwgbmFtZSwgcm9sZSkge1xuICBjb25zdCBpdGVtID0gJ2V2ZW50Lml0ZW0nO1xuICByZXR1cm4gaXRlbSArICh0eXBlICYmIHR5cGUgIT09ICcqJyA/ICcmJicgKyBpdGVtICsgJy5tYXJrLm1hcmt0eXBlPT09XFwnJyArIHR5cGUgKyAnXFwnJyA6ICcnKSArIChyb2xlID8gJyYmJyArIGl0ZW0gKyAnLm1hcmsucm9sZT09PVxcJycgKyByb2xlICsgJ1xcJycgOiAnJykgKyAobmFtZSA/ICcmJicgKyBpdGVtICsgJy5tYXJrLm5hbWU9PT1cXCcnICsgbmFtZSArICdcXCcnIDogJycpO1xufVxuXG4vLyBieXBhc3MgZXhwcmVzc2lvbiBwYXJzZXIgZm9yIGludGVybmFsIG9wZXJhdG9yIHJlZmVyZW5jZXNcbmNvbnN0IE9QX1ZBTFVFX0VYUFIgPSB7XG4gIGNvZGU6ICdfLiR2YWx1ZScsXG4gIGFzdDoge1xuICAgIHR5cGU6ICdJZGVudGlmaWVyJyxcbiAgICB2YWx1ZTogJ3ZhbHVlJ1xuICB9XG59O1xuZnVuY3Rpb24gcGFyc2VVcGRhdGUgKHNwZWMsIHNjb3BlLCB0YXJnZXQpIHtcbiAgY29uc3QgZW5jb2RlID0gc3BlYy5lbmNvZGUsXG4gICAgZW50cnkgPSB7XG4gICAgICB0YXJnZXQ6IHRhcmdldFxuICAgIH07XG4gIGxldCBldmVudHMgPSBzcGVjLmV2ZW50cyxcbiAgICB1cGRhdGUgPSBzcGVjLnVwZGF0ZSxcbiAgICBzb3VyY2VzID0gW107XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXJyb3IoJ1NpZ25hbCB1cGRhdGUgbWlzc2luZyBldmVudHMgc3BlY2lmaWNhdGlvbi4nKTtcbiAgfVxuXG4gIC8vIGludGVycHJldCBhcyBhbiBldmVudCBzZWxlY3RvciBzdHJpbmdcbiAgaWYgKGlzU3RyaW5nKGV2ZW50cykpIHtcbiAgICBldmVudHMgPSBwYXJzZVNlbGVjdG9yKGV2ZW50cywgc2NvcGUuaXNTdWJzY29wZSgpID8gU2NvcGUkMSA6IFZpZXcpO1xuICB9XG5cbiAgLy8gc2VwYXJhdGUgZXZlbnQgc3RyZWFtcyBmcm9tIHNpZ25hbCB1cGRhdGVzXG4gIGV2ZW50cyA9IGFycmF5KGV2ZW50cykuZmlsdGVyKHMgPT4gcy5zaWduYWwgfHwgcy5zY2FsZSA/IChzb3VyY2VzLnB1c2gocyksIDApIDogMSk7XG5cbiAgLy8gbWVyZ2UgaW50ZXJuYWwgb3BlcmF0b3IgbGlzdGVuZXJzXG4gIGlmIChzb3VyY2VzLmxlbmd0aCA+IDEpIHtcbiAgICBzb3VyY2VzID0gW21lcmdlU291cmNlcyhzb3VyY2VzKV07XG4gIH1cblxuICAvLyBtZXJnZSBldmVudCBzdHJlYW1zLCBpbmNsdWRlIGFzIHNvdXJjZVxuICBpZiAoZXZlbnRzLmxlbmd0aCkge1xuICAgIHNvdXJjZXMucHVzaChldmVudHMubGVuZ3RoID4gMSA/IHtcbiAgICAgIG1lcmdlOiBldmVudHNcbiAgICB9IDogZXZlbnRzWzBdKTtcbiAgfVxuICBpZiAoZW5jb2RlICE9IG51bGwpIHtcbiAgICBpZiAodXBkYXRlKSBlcnJvcignU2lnbmFsIGVuY29kZSBhbmQgdXBkYXRlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUuJyk7XG4gICAgdXBkYXRlID0gJ2VuY29kZShpdGVtKCksJyArIHN0cmluZ1ZhbHVlKGVuY29kZSkgKyAnKSc7XG4gIH1cblxuICAvLyByZXNvbHZlIHVwZGF0ZSB2YWx1ZVxuICBlbnRyeS51cGRhdGUgPSBpc1N0cmluZyh1cGRhdGUpID8gcGFyc2VFeHByZXNzaW9uKHVwZGF0ZSwgc2NvcGUpIDogdXBkYXRlLmV4cHIgIT0gbnVsbCA/IHBhcnNlRXhwcmVzc2lvbih1cGRhdGUuZXhwciwgc2NvcGUpIDogdXBkYXRlLnZhbHVlICE9IG51bGwgPyB1cGRhdGUudmFsdWUgOiB1cGRhdGUuc2lnbmFsICE9IG51bGwgPyB7XG4gICAgJGV4cHI6IE9QX1ZBTFVFX0VYUFIsXG4gICAgJHBhcmFtczoge1xuICAgICAgJHZhbHVlOiBzY29wZS5zaWduYWxSZWYodXBkYXRlLnNpZ25hbClcbiAgICB9XG4gIH0gOiBlcnJvcignSW52YWxpZCBzaWduYWwgdXBkYXRlIHNwZWNpZmljYXRpb24uJyk7XG4gIGlmIChzcGVjLmZvcmNlKSB7XG4gICAgZW50cnkub3B0aW9ucyA9IHtcbiAgICAgIGZvcmNlOiB0cnVlXG4gICAgfTtcbiAgfVxuICBzb3VyY2VzLmZvckVhY2goc291cmNlID0+IHNjb3BlLmFkZFVwZGF0ZShleHRlbmQoc3RyZWFtU291cmNlKHNvdXJjZSwgc2NvcGUpLCBlbnRyeSkpKTtcbn1cbmZ1bmN0aW9uIHN0cmVhbVNvdXJjZShzdHJlYW0sIHNjb3BlKSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzdHJlYW0uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKHN0cmVhbS5zaWduYWwpIDogc3RyZWFtLnNjYWxlID8gc2NvcGUuc2NhbGVSZWYoc3RyZWFtLnNjYWxlKSA6IHBhcnNlU3RyZWFtKHN0cmVhbSwgc2NvcGUpXG4gIH07XG59XG5mdW5jdGlvbiBtZXJnZVNvdXJjZXMoc291cmNlcykge1xuICByZXR1cm4ge1xuICAgIHNpZ25hbDogJ1snICsgc291cmNlcy5tYXAocyA9PiBzLnNjYWxlID8gJ3NjYWxlKFwiJyArIHMuc2NhbGUgKyAnXCIpJyA6IHMuc2lnbmFsKSArICddJ1xuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVNpZ25hbFVwZGF0ZXMgKHNpZ25hbCwgc2NvcGUpIHtcbiAgY29uc3Qgb3AgPSBzY29wZS5nZXRTaWduYWwoc2lnbmFsLm5hbWUpO1xuICBsZXQgZXhwciA9IHNpZ25hbC51cGRhdGU7XG4gIGlmIChzaWduYWwuaW5pdCkge1xuICAgIGlmIChleHByKSB7XG4gICAgICBlcnJvcignU2lnbmFscyBjYW4gbm90IGluY2x1ZGUgYm90aCBpbml0IGFuZCB1cGRhdGUgZXhwcmVzc2lvbnMuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4cHIgPSBzaWduYWwuaW5pdDtcbiAgICAgIG9wLmluaXRvbmx5ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKGV4cHIpIHtcbiAgICBleHByID0gcGFyc2VFeHByZXNzaW9uKGV4cHIsIHNjb3BlKTtcbiAgICBvcC51cGRhdGUgPSBleHByLiRleHByO1xuICAgIG9wLnBhcmFtcyA9IGV4cHIuJHBhcmFtcztcbiAgfVxuICBpZiAoc2lnbmFsLm9uKSB7XG4gICAgc2lnbmFsLm9uLmZvckVhY2goXyA9PiBwYXJzZVVwZGF0ZShfLCBzY29wZSwgb3AuaWQpKTtcbiAgfVxufVxuXG5jb25zdCB0cmFuc2Zvcm0gPSBuYW1lID0+IChwYXJhbXMsIHZhbHVlLCBwYXJlbnQpID0+IGVudHJ5KG5hbWUsIHZhbHVlLCBwYXJhbXMgfHwgdW5kZWZpbmVkLCBwYXJlbnQpO1xuY29uc3QgQWdncmVnYXRlID0gdHJhbnNmb3JtKCdhZ2dyZWdhdGUnKTtcbmNvbnN0IEF4aXNUaWNrcyA9IHRyYW5zZm9ybSgnYXhpc3RpY2tzJyk7XG5jb25zdCBCb3VuZCA9IHRyYW5zZm9ybSgnYm91bmQnKTtcbmNvbnN0IENvbGxlY3QgPSB0cmFuc2Zvcm0oJ2NvbGxlY3QnKTtcbmNvbnN0IENvbXBhcmUgPSB0cmFuc2Zvcm0oJ2NvbXBhcmUnKTtcbmNvbnN0IERhdGFKb2luID0gdHJhbnNmb3JtKCdkYXRham9pbicpO1xuY29uc3QgRW5jb2RlID0gdHJhbnNmb3JtKCdlbmNvZGUnKTtcbmNvbnN0IEV4cHJlc3Npb24gPSB0cmFuc2Zvcm0oJ2V4cHJlc3Npb24nKTtcbmNvbnN0IEZhY2V0ID0gdHJhbnNmb3JtKCdmYWNldCcpO1xuY29uc3QgRmllbGQgPSB0cmFuc2Zvcm0oJ2ZpZWxkJyk7XG5jb25zdCBLZXkgPSB0cmFuc2Zvcm0oJ2tleScpO1xuY29uc3QgTGVnZW5kRW50cmllcyA9IHRyYW5zZm9ybSgnbGVnZW5kZW50cmllcycpO1xuY29uc3QgTG9hZCA9IHRyYW5zZm9ybSgnbG9hZCcpO1xuY29uc3QgTWFyayA9IHRyYW5zZm9ybSgnbWFyaycpO1xuY29uc3QgTXVsdGlFeHRlbnQgPSB0cmFuc2Zvcm0oJ211bHRpZXh0ZW50Jyk7XG5jb25zdCBNdWx0aVZhbHVlcyA9IHRyYW5zZm9ybSgnbXVsdGl2YWx1ZXMnKTtcbmNvbnN0IE92ZXJsYXAgPSB0cmFuc2Zvcm0oJ292ZXJsYXAnKTtcbmNvbnN0IFBhcmFtcyA9IHRyYW5zZm9ybSgncGFyYW1zJyk7XG5jb25zdCBQcmVGYWNldCA9IHRyYW5zZm9ybSgncHJlZmFjZXQnKTtcbmNvbnN0IFByb2plY3Rpb24gPSB0cmFuc2Zvcm0oJ3Byb2plY3Rpb24nKTtcbmNvbnN0IFByb3h5ID0gdHJhbnNmb3JtKCdwcm94eScpO1xuY29uc3QgUmVsYXkgPSB0cmFuc2Zvcm0oJ3JlbGF5Jyk7XG5jb25zdCBSZW5kZXIgPSB0cmFuc2Zvcm0oJ3JlbmRlcicpO1xuY29uc3QgU2NhbGUgPSB0cmFuc2Zvcm0oJ3NjYWxlJyk7XG5jb25zdCBTaWV2ZSA9IHRyYW5zZm9ybSgnc2lldmUnKTtcbmNvbnN0IFNvcnRJdGVtcyA9IHRyYW5zZm9ybSgnc29ydGl0ZW1zJyk7XG5jb25zdCBWaWV3TGF5b3V0ID0gdHJhbnNmb3JtKCd2aWV3bGF5b3V0Jyk7XG5jb25zdCBWYWx1ZXMgPSB0cmFuc2Zvcm0oJ3ZhbHVlcycpO1xuXG5sZXQgRklFTERfUkVGX0lEID0gMDtcbmNvbnN0IE1VTFRJRE9NQUlOX1NPUlRfT1BTID0ge1xuICBtaW46ICdtaW4nLFxuICBtYXg6ICdtYXgnLFxuICBjb3VudDogJ3N1bSdcbn07XG5mdW5jdGlvbiBpbml0U2NhbGUoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgdHlwZSA9IHNwZWMudHlwZSB8fCAnbGluZWFyJztcbiAgaWYgKCFpc1ZhbGlkU2NhbGVUeXBlKHR5cGUpKSB7XG4gICAgZXJyb3IoJ1VucmVjb2duaXplZCBzY2FsZSB0eXBlOiAnICsgc3RyaW5nVmFsdWUodHlwZSkpO1xuICB9XG4gIHNjb3BlLmFkZFNjYWxlKHNwZWMubmFtZSwge1xuICAgIHR5cGUsXG4gICAgZG9tYWluOiB1bmRlZmluZWRcbiAgfSk7XG59XG5mdW5jdGlvbiBwYXJzZVNjYWxlKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IHBhcmFtcyA9IHNjb3BlLmdldFNjYWxlKHNwZWMubmFtZSkucGFyYW1zO1xuICBsZXQga2V5O1xuICBwYXJhbXMuZG9tYWluID0gcGFyc2VTY2FsZURvbWFpbihzcGVjLmRvbWFpbiwgc3BlYywgc2NvcGUpO1xuICBpZiAoc3BlYy5yYW5nZSAhPSBudWxsKSB7XG4gICAgcGFyYW1zLnJhbmdlID0gcGFyc2VTY2FsZVJhbmdlKHNwZWMsIHNjb3BlLCBwYXJhbXMpO1xuICB9XG4gIGlmIChzcGVjLmludGVycG9sYXRlICE9IG51bGwpIHtcbiAgICBwYXJzZVNjYWxlSW50ZXJwb2xhdGUoc3BlYy5pbnRlcnBvbGF0ZSwgcGFyYW1zKTtcbiAgfVxuICBpZiAoc3BlYy5uaWNlICE9IG51bGwpIHtcbiAgICBwYXJhbXMubmljZSA9IHBhcnNlU2NhbGVOaWNlKHNwZWMubmljZSwgc2NvcGUpO1xuICB9XG4gIGlmIChzcGVjLmJpbnMgIT0gbnVsbCkge1xuICAgIHBhcmFtcy5iaW5zID0gcGFyc2VTY2FsZUJpbnMoc3BlYy5iaW5zLCBzY29wZSk7XG4gIH1cbiAgZm9yIChrZXkgaW4gc3BlYykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIGtleSkgfHwga2V5ID09PSAnbmFtZScpIGNvbnRpbnVlO1xuICAgIHBhcmFtc1trZXldID0gcGFyc2VMaXRlcmFsKHNwZWNba2V5XSwgc2NvcGUpO1xuICB9XG59XG5mdW5jdGlvbiBwYXJzZUxpdGVyYWwodiwgc2NvcGUpIHtcbiAgcmV0dXJuICFpc09iamVjdCh2KSA/IHYgOiB2LnNpZ25hbCA/IHNjb3BlLnNpZ25hbFJlZih2LnNpZ25hbCkgOiBlcnJvcignVW5zdXBwb3J0ZWQgb2JqZWN0OiAnICsgc3RyaW5nVmFsdWUodikpO1xufVxuZnVuY3Rpb24gcGFyc2VBcnJheSh2LCBzY29wZSkge1xuICByZXR1cm4gdi5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYodi5zaWduYWwpIDogdi5tYXAodiA9PiBwYXJzZUxpdGVyYWwodiwgc2NvcGUpKTtcbn1cbmZ1bmN0aW9uIGRhdGFMb29rdXBFcnJvcihuYW1lKSB7XG4gIGVycm9yKCdDYW4gbm90IGZpbmQgZGF0YSBzZXQ6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG59XG5cbi8vIC0tIFNDQUxFIERPTUFJTiAtLS0tXG5cbmZ1bmN0aW9uIHBhcnNlU2NhbGVEb21haW4oZG9tYWluLCBzcGVjLCBzY29wZSkge1xuICBpZiAoIWRvbWFpbikge1xuICAgIGlmIChzcGVjLmRvbWFpbk1pbiAhPSBudWxsIHx8IHNwZWMuZG9tYWluTWF4ICE9IG51bGwpIHtcbiAgICAgIGVycm9yKCdObyBzY2FsZSBkb21haW4gZGVmaW5lZCBmb3IgZG9tYWluTWluL2RvbWFpbk1heCB0byBvdmVycmlkZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuOyAvLyBkZWZhdWx0IGRvbWFpblxuICB9XG4gIHJldHVybiBkb21haW4uc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKGRvbWFpbi5zaWduYWwpIDogKGlzQXJyYXkoZG9tYWluKSA/IGV4cGxpY2l0RG9tYWluIDogZG9tYWluLmZpZWxkcyA/IG11bHRpcGxlRG9tYWluIDogc2luZ3VsYXJEb21haW4pKGRvbWFpbiwgc3BlYywgc2NvcGUpO1xufVxuZnVuY3Rpb24gZXhwbGljaXREb21haW4oZG9tYWluLCBzcGVjLCBzY29wZSkge1xuICByZXR1cm4gZG9tYWluLm1hcCh2ID0+IHBhcnNlTGl0ZXJhbCh2LCBzY29wZSkpO1xufVxuZnVuY3Rpb24gc2luZ3VsYXJEb21haW4oZG9tYWluLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCBkYXRhID0gc2NvcGUuZ2V0RGF0YShkb21haW4uZGF0YSk7XG4gIGlmICghZGF0YSkgZGF0YUxvb2t1cEVycm9yKGRvbWFpbi5kYXRhKTtcbiAgcmV0dXJuIGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IGRhdGEudmFsdWVzUmVmKHNjb3BlLCBkb21haW4uZmllbGQsIHBhcnNlU29ydChkb21haW4uc29ydCwgZmFsc2UpKSA6IGlzUXVhbnRpbGUoc3BlYy50eXBlKSA/IGRhdGEuZG9tYWluUmVmKHNjb3BlLCBkb21haW4uZmllbGQpIDogZGF0YS5leHRlbnRSZWYoc2NvcGUsIGRvbWFpbi5maWVsZCk7XG59XG5mdW5jdGlvbiBtdWx0aXBsZURvbWFpbihkb21haW4sIHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGRhdGEgPSBkb21haW4uZGF0YSxcbiAgICBmaWVsZHMgPSBkb21haW4uZmllbGRzLnJlZHVjZSgoZG9tLCBkKSA9PiB7XG4gICAgICBkID0gaXNTdHJpbmcoZCkgPyB7XG4gICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIGZpZWxkOiBkXG4gICAgICB9IDogaXNBcnJheShkKSB8fCBkLnNpZ25hbCA/IGZpZWxkUmVmKGQsIHNjb3BlKSA6IGQ7XG4gICAgICBkb20ucHVzaChkKTtcbiAgICAgIHJldHVybiBkb207XG4gICAgfSwgW10pO1xuICByZXR1cm4gKGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IG9yZGluYWxNdWx0aXBsZURvbWFpbiA6IGlzUXVhbnRpbGUoc3BlYy50eXBlKSA/IHF1YW50aWxlTXVsdGlwbGVEb21haW4gOiBudW1lcmljTXVsdGlwbGVEb21haW4pKGRvbWFpbiwgc2NvcGUsIGZpZWxkcyk7XG59XG5mdW5jdGlvbiBmaWVsZFJlZihkYXRhLCBzY29wZSkge1xuICBjb25zdCBuYW1lID0gJ186dmVnYTpfJyArIEZJRUxEX1JFRl9JRCsrLFxuICAgIGNvbGwgPSBDb2xsZWN0KHt9KTtcbiAgaWYgKGlzQXJyYXkoZGF0YSkpIHtcbiAgICBjb2xsLnZhbHVlID0ge1xuICAgICAgJGluZ2VzdDogZGF0YVxuICAgIH07XG4gIH0gZWxzZSBpZiAoZGF0YS5zaWduYWwpIHtcbiAgICBjb25zdCBjb2RlID0gJ3NldGRhdGEoJyArIHN0cmluZ1ZhbHVlKG5hbWUpICsgJywnICsgZGF0YS5zaWduYWwgKyAnKSc7XG4gICAgY29sbC5wYXJhbXMuaW5wdXQgPSBzY29wZS5zaWduYWxSZWYoY29kZSk7XG4gIH1cbiAgc2NvcGUuYWRkRGF0YVBpcGVsaW5lKG5hbWUsIFtjb2xsLCBTaWV2ZSh7fSldKTtcbiAgcmV0dXJuIHtcbiAgICBkYXRhOiBuYW1lLFxuICAgIGZpZWxkOiAnZGF0YSdcbiAgfTtcbn1cbmZ1bmN0aW9uIG9yZGluYWxNdWx0aXBsZURvbWFpbihkb21haW4sIHNjb3BlLCBmaWVsZHMpIHtcbiAgY29uc3Qgc29ydCA9IHBhcnNlU29ydChkb21haW4uc29ydCwgdHJ1ZSk7XG4gIGxldCBhLCB2O1xuXG4gIC8vIGdldCB2YWx1ZSBjb3VudHMgZm9yIGVhY2ggZG9tYWluIGZpZWxkXG4gIGNvbnN0IGNvdW50cyA9IGZpZWxkcy5tYXAoZiA9PiB7XG4gICAgY29uc3QgZGF0YSA9IHNjb3BlLmdldERhdGEoZi5kYXRhKTtcbiAgICBpZiAoIWRhdGEpIGRhdGFMb29rdXBFcnJvcihmLmRhdGEpO1xuICAgIHJldHVybiBkYXRhLmNvdW50c1JlZihzY29wZSwgZi5maWVsZCwgc29ydCk7XG4gIH0pO1xuXG4gIC8vIGFnZ3JlZ2F0ZSB0aGUgcmVzdWx0cyBmcm9tIGVhY2ggZG9tYWluIGZpZWxkXG4gIGNvbnN0IHAgPSB7XG4gICAgZ3JvdXBieToga2V5RmllbGRSZWYsXG4gICAgcHVsc2U6IGNvdW50c1xuICB9O1xuICBpZiAoc29ydCkge1xuICAgIGEgPSBzb3J0Lm9wIHx8ICdjb3VudCc7XG4gICAgdiA9IHNvcnQuZmllbGQgPyBhZ2dyRmllbGQoYSwgc29ydC5maWVsZCkgOiAnY291bnQnO1xuICAgIHAub3BzID0gW01VTFRJRE9NQUlOX1NPUlRfT1BTW2FdXTtcbiAgICBwLmZpZWxkcyA9IFtzY29wZS5maWVsZFJlZih2KV07XG4gICAgcC5hcyA9IFt2XTtcbiAgfVxuICBhID0gc2NvcGUuYWRkKEFnZ3JlZ2F0ZShwKSk7XG5cbiAgLy8gY29sbGVjdCBhZ2dyZWdhdGUgb3V0cHV0XG4gIGNvbnN0IGMgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgcHVsc2U6IHJlZihhKVxuICB9KSk7XG5cbiAgLy8gZXh0cmFjdCB2YWx1ZXMgZm9yIGNvbWJpbmVkIGRvbWFpblxuICB2ID0gc2NvcGUuYWRkKFZhbHVlcyh7XG4gICAgZmllbGQ6IGtleUZpZWxkUmVmLFxuICAgIHNvcnQ6IHNjb3BlLnNvcnRSZWYoc29ydCksXG4gICAgcHVsc2U6IHJlZihjKVxuICB9KSk7XG4gIHJldHVybiByZWYodik7XG59XG5mdW5jdGlvbiBwYXJzZVNvcnQoc29ydCwgbXVsdGlkb21haW4pIHtcbiAgaWYgKHNvcnQpIHtcbiAgICBpZiAoIXNvcnQuZmllbGQgJiYgIXNvcnQub3ApIHtcbiAgICAgIGlmIChpc09iamVjdChzb3J0KSkgc29ydC5maWVsZCA9ICdrZXknO2Vsc2Ugc29ydCA9IHtcbiAgICAgICAgZmllbGQ6ICdrZXknXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoIXNvcnQuZmllbGQgJiYgc29ydC5vcCAhPT0gJ2NvdW50Jykge1xuICAgICAgZXJyb3IoJ05vIGZpZWxkIHByb3ZpZGVkIGZvciBzb3J0IGFnZ3JlZ2F0ZSBvcDogJyArIHNvcnQub3ApO1xuICAgIH0gZWxzZSBpZiAobXVsdGlkb21haW4gJiYgc29ydC5maWVsZCkge1xuICAgICAgaWYgKHNvcnQub3AgJiYgIU1VTFRJRE9NQUlOX1NPUlRfT1BTW3NvcnQub3BdKSB7XG4gICAgICAgIGVycm9yKCdNdWx0aXBsZSBkb21haW4gc2NhbGVzIGNhbiBub3QgYmUgc29ydGVkIHVzaW5nICcgKyBzb3J0Lm9wKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNvcnQ7XG59XG5mdW5jdGlvbiBxdWFudGlsZU11bHRpcGxlRG9tYWluKGRvbWFpbiwgc2NvcGUsIGZpZWxkcykge1xuICAvLyBnZXQgdmFsdWUgYXJyYXlzIGZvciBlYWNoIGRvbWFpbiBmaWVsZFxuICBjb25zdCB2YWx1ZXMgPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBzY29wZS5nZXREYXRhKGYuZGF0YSk7XG4gICAgaWYgKCFkYXRhKSBkYXRhTG9va3VwRXJyb3IoZi5kYXRhKTtcbiAgICByZXR1cm4gZGF0YS5kb21haW5SZWYoc2NvcGUsIGYuZmllbGQpO1xuICB9KTtcblxuICAvLyBjb21iaW5lIHZhbHVlIGFycmF5c1xuICByZXR1cm4gcmVmKHNjb3BlLmFkZChNdWx0aVZhbHVlcyh7XG4gICAgdmFsdWVzOiB2YWx1ZXNcbiAgfSkpKTtcbn1cbmZ1bmN0aW9uIG51bWVyaWNNdWx0aXBsZURvbWFpbihkb21haW4sIHNjb3BlLCBmaWVsZHMpIHtcbiAgLy8gZ2V0IGV4dGVudHMgZm9yIGVhY2ggZG9tYWluIGZpZWxkXG4gIGNvbnN0IGV4dGVudHMgPSBmaWVsZHMubWFwKGYgPT4ge1xuICAgIGNvbnN0IGRhdGEgPSBzY29wZS5nZXREYXRhKGYuZGF0YSk7XG4gICAgaWYgKCFkYXRhKSBkYXRhTG9va3VwRXJyb3IoZi5kYXRhKTtcbiAgICByZXR1cm4gZGF0YS5leHRlbnRSZWYoc2NvcGUsIGYuZmllbGQpO1xuICB9KTtcblxuICAvLyBjb21iaW5lIGV4dGVudHNcbiAgcmV0dXJuIHJlZihzY29wZS5hZGQoTXVsdGlFeHRlbnQoe1xuICAgIGV4dGVudHM6IGV4dGVudHNcbiAgfSkpKTtcbn1cblxuLy8gLS0gU0NBTEUgQklOUyAtLS0tLVxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlQmlucyh2LCBzY29wZSkge1xuICByZXR1cm4gdi5zaWduYWwgfHwgaXNBcnJheSh2KSA/IHBhcnNlQXJyYXkodiwgc2NvcGUpIDogc2NvcGUub2JqZWN0UHJvcGVydHkodik7XG59XG5cbi8vIC0tIFNDQUxFIE5JQ0UgLS0tLS1cblxuZnVuY3Rpb24gcGFyc2VTY2FsZU5pY2UobmljZSwgc2NvcGUpIHtcbiAgcmV0dXJuIG5pY2Uuc2lnbmFsID8gc2NvcGUuc2lnbmFsUmVmKG5pY2Uuc2lnbmFsKSA6IGlzT2JqZWN0KG5pY2UpID8ge1xuICAgIGludGVydmFsOiBwYXJzZUxpdGVyYWwobmljZS5pbnRlcnZhbCksXG4gICAgc3RlcDogcGFyc2VMaXRlcmFsKG5pY2Uuc3RlcClcbiAgfSA6IHBhcnNlTGl0ZXJhbChuaWNlKTtcbn1cblxuLy8gLS0gU0NBTEUgSU5URVJQT0xBVElPTiAtLS0tLVxuXG5mdW5jdGlvbiBwYXJzZVNjYWxlSW50ZXJwb2xhdGUoaW50ZXJwb2xhdGUsIHBhcmFtcykge1xuICBwYXJhbXMuaW50ZXJwb2xhdGUgPSBwYXJzZUxpdGVyYWwoaW50ZXJwb2xhdGUudHlwZSB8fCBpbnRlcnBvbGF0ZSk7XG4gIGlmIChpbnRlcnBvbGF0ZS5nYW1tYSAhPSBudWxsKSB7XG4gICAgcGFyYW1zLmludGVycG9sYXRlR2FtbWEgPSBwYXJzZUxpdGVyYWwoaW50ZXJwb2xhdGUuZ2FtbWEpO1xuICB9XG59XG5cbi8vIC0tIFNDQUxFIFJBTkdFIC0tLS0tXG5cbmZ1bmN0aW9uIHBhcnNlU2NhbGVSYW5nZShzcGVjLCBzY29wZSwgcGFyYW1zKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNjb3BlLmNvbmZpZy5yYW5nZTtcbiAgbGV0IHJhbmdlID0gc3BlYy5yYW5nZTtcbiAgaWYgKHJhbmdlLnNpZ25hbCkge1xuICAgIHJldHVybiBzY29wZS5zaWduYWxSZWYocmFuZ2Uuc2lnbmFsKTtcbiAgfSBlbHNlIGlmIChpc1N0cmluZyhyYW5nZSkpIHtcbiAgICBpZiAoY29uZmlnICYmIGhhc093blByb3BlcnR5KGNvbmZpZywgcmFuZ2UpKSB7XG4gICAgICBzcGVjID0gZXh0ZW5kKHt9LCBzcGVjLCB7XG4gICAgICAgIHJhbmdlOiBjb25maWdbcmFuZ2VdXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBwYXJzZVNjYWxlUmFuZ2Uoc3BlYywgc2NvcGUsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmIChyYW5nZSA9PT0gJ3dpZHRoJykge1xuICAgICAgcmFuZ2UgPSBbMCwge1xuICAgICAgICBzaWduYWw6ICd3aWR0aCdcbiAgICAgIH1dO1xuICAgIH0gZWxzZSBpZiAocmFuZ2UgPT09ICdoZWlnaHQnKSB7XG4gICAgICByYW5nZSA9IGlzRGlzY3JldGUoc3BlYy50eXBlKSA/IFswLCB7XG4gICAgICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgICAgIH1dIDogW3tcbiAgICAgICAgc2lnbmFsOiAnaGVpZ2h0J1xuICAgICAgfSwgMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgcmFuZ2UgdmFsdWU6ICcgKyBzdHJpbmdWYWx1ZShyYW5nZSkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChyYW5nZS5zY2hlbWUpIHtcbiAgICBwYXJhbXMuc2NoZW1lID0gaXNBcnJheShyYW5nZS5zY2hlbWUpID8gcGFyc2VBcnJheShyYW5nZS5zY2hlbWUsIHNjb3BlKSA6IHBhcnNlTGl0ZXJhbChyYW5nZS5zY2hlbWUsIHNjb3BlKTtcbiAgICBpZiAocmFuZ2UuZXh0ZW50KSBwYXJhbXMuc2NoZW1lRXh0ZW50ID0gcGFyc2VBcnJheShyYW5nZS5leHRlbnQsIHNjb3BlKTtcbiAgICBpZiAocmFuZ2UuY291bnQpIHBhcmFtcy5zY2hlbWVDb3VudCA9IHBhcnNlTGl0ZXJhbChyYW5nZS5jb3VudCwgc2NvcGUpO1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChyYW5nZS5zdGVwKSB7XG4gICAgcGFyYW1zLnJhbmdlU3RlcCA9IHBhcnNlTGl0ZXJhbChyYW5nZS5zdGVwLCBzY29wZSk7XG4gICAgcmV0dXJuO1xuICB9IGVsc2UgaWYgKGlzRGlzY3JldGUoc3BlYy50eXBlKSAmJiAhaXNBcnJheShyYW5nZSkpIHtcbiAgICByZXR1cm4gcGFyc2VTY2FsZURvbWFpbihyYW5nZSwgc3BlYywgc2NvcGUpO1xuICB9IGVsc2UgaWYgKCFpc0FycmF5KHJhbmdlKSkge1xuICAgIGVycm9yKCdVbnN1cHBvcnRlZCByYW5nZSB0eXBlOiAnICsgc3RyaW5nVmFsdWUocmFuZ2UpKTtcbiAgfVxuICByZXR1cm4gcmFuZ2UubWFwKHYgPT4gKGlzQXJyYXkodikgPyBwYXJzZUFycmF5IDogcGFyc2VMaXRlcmFsKSh2LCBzY29wZSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZVByb2plY3Rpb24gKHByb2osIHNjb3BlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNjb3BlLmNvbmZpZy5wcm9qZWN0aW9uIHx8IHt9LFxuICAgIHBhcmFtcyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gcHJvaikge1xuICAgIGlmIChuYW1lID09PSAnbmFtZScpIGNvbnRpbnVlO1xuICAgIHBhcmFtc1tuYW1lXSA9IHBhcnNlUGFyYW1ldGVyJDEocHJvaltuYW1lXSwgbmFtZSwgc2NvcGUpO1xuICB9XG5cbiAgLy8gYXBwbHkgcHJvamVjdGlvbiBkZWZhdWx0cyBmcm9tIGNvbmZpZ1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gY29uZmlnKSB7XG4gICAgaWYgKHBhcmFtc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICBwYXJhbXNbbmFtZV0gPSBwYXJzZVBhcmFtZXRlciQxKGNvbmZpZ1tuYW1lXSwgbmFtZSwgc2NvcGUpO1xuICAgIH1cbiAgfVxuICBzY29wZS5hZGRQcm9qZWN0aW9uKHByb2oubmFtZSwgcGFyYW1zKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVyJDEoXywgbmFtZSwgc2NvcGUpIHtcbiAgcmV0dXJuIGlzQXJyYXkoXykgPyBfLm1hcChfID0+IHBhcnNlUGFyYW1ldGVyJDEoXywgbmFtZSwgc2NvcGUpKSA6ICFpc09iamVjdChfKSA/IF8gOiBfLnNpZ25hbCA/IHNjb3BlLnNpZ25hbFJlZihfLnNpZ25hbCkgOiBuYW1lID09PSAnZml0JyA/IF8gOiBlcnJvcignVW5zdXBwb3J0ZWQgcGFyYW1ldGVyIG9iamVjdDogJyArIHN0cmluZ1ZhbHVlKF8pKTtcbn1cblxuY29uc3QgVG9wID0gJ3RvcCc7XG5jb25zdCBMZWZ0ID0gJ2xlZnQnO1xuY29uc3QgUmlnaHQgPSAncmlnaHQnO1xuY29uc3QgQm90dG9tID0gJ2JvdHRvbSc7XG5jb25zdCBDZW50ZXIgPSAnY2VudGVyJztcbmNvbnN0IFZlcnRpY2FsID0gJ3ZlcnRpY2FsJztcbmNvbnN0IFN0YXJ0ID0gJ3N0YXJ0JztcbmNvbnN0IE1pZGRsZSA9ICdtaWRkbGUnO1xuY29uc3QgRW5kID0gJ2VuZCc7XG5jb25zdCBJbmRleCA9ICdpbmRleCc7XG5jb25zdCBMYWJlbCA9ICdsYWJlbCc7XG5jb25zdCBPZmZzZXQgPSAnb2Zmc2V0JztcbmNvbnN0IFBlcmMgPSAncGVyYyc7XG5jb25zdCBQZXJjMiA9ICdwZXJjMic7XG5jb25zdCBWYWx1ZSA9ICd2YWx1ZSc7XG5jb25zdCBHdWlkZUxhYmVsU3R5bGUgPSAnZ3VpZGUtbGFiZWwnO1xuY29uc3QgR3VpZGVUaXRsZVN0eWxlID0gJ2d1aWRlLXRpdGxlJztcbmNvbnN0IEdyb3VwVGl0bGVTdHlsZSA9ICdncm91cC10aXRsZSc7XG5jb25zdCBHcm91cFN1YnRpdGxlU3R5bGUgPSAnZ3JvdXAtc3VidGl0bGUnO1xuXG4vKiogQWxsIHZhbHVlcyBvZiBMZWdlbmRUeXBlICovXG5jb25zdCBTeW1ib2xzID0gJ3N5bWJvbCc7XG5jb25zdCBHcmFkaWVudCA9ICdncmFkaWVudCc7XG5jb25zdCBEaXNjcmV0ZSA9ICdkaXNjcmV0ZSc7XG5jb25zdCBTaXplID0gJ3NpemUnO1xuY29uc3QgU2hhcGUgPSAnc2hhcGUnO1xuY29uc3QgRmlsbCA9ICdmaWxsJztcbmNvbnN0IFN0cm9rZSA9ICdzdHJva2UnO1xuY29uc3QgU3Ryb2tlV2lkdGggPSAnc3Ryb2tlV2lkdGgnO1xuY29uc3QgU3Ryb2tlRGFzaCA9ICdzdHJva2VEYXNoJztcbmNvbnN0IE9wYWNpdHkgPSAnb3BhY2l0eSc7XG5cbi8vIEVuY29kaW5nIGNoYW5uZWxzIHN1cHBvcnRlZCBieSBsZWdlbmRzXG4vLyBJbiBwcmlvcml0eSBvcmRlciBvZiAnY2Fub25pY2FsJyBzY2FsZVxuY29uc3QgTGVnZW5kU2NhbGVzID0gW1NpemUsIFNoYXBlLCBGaWxsLCBTdHJva2UsIFN0cm9rZVdpZHRoLCBTdHJva2VEYXNoLCBPcGFjaXR5XTtcbmNvbnN0IFNraXAgPSB7XG4gIG5hbWU6IDEsXG4gIHN0eWxlOiAxLFxuICBpbnRlcmFjdGl2ZTogMVxufTtcbmNvbnN0IHplcm8gPSB7XG4gIHZhbHVlOiAwXG59O1xuY29uc3Qgb25lID0ge1xuICB2YWx1ZTogMVxufTtcblxuY29uc3QgR3JvdXBNYXJrID0gJ2dyb3VwJztcbmNvbnN0IFJlY3RNYXJrID0gJ3JlY3QnO1xuY29uc3QgUnVsZU1hcmsgPSAncnVsZSc7XG5jb25zdCBTeW1ib2xNYXJrID0gJ3N5bWJvbCc7XG5jb25zdCBUZXh0TWFyayA9ICd0ZXh0JztcblxuZnVuY3Rpb24gZ3VpZGVHcm91cCAobWFyaykge1xuICBtYXJrLnR5cGUgPSBHcm91cE1hcms7XG4gIG1hcmsuaW50ZXJhY3RpdmUgPSBtYXJrLmludGVyYWN0aXZlIHx8IGZhbHNlO1xuICByZXR1cm4gbWFyaztcbn1cblxuZnVuY3Rpb24gbG9va3VwKHNwZWMsIGNvbmZpZykge1xuICBjb25zdCBfID0gKG5hbWUsIGRmbHQpID0+IHZhbHVlKHNwZWNbbmFtZV0sIHZhbHVlKGNvbmZpZ1tuYW1lXSwgZGZsdCkpO1xuICBfLmlzVmVydGljYWwgPSBzID0+IFZlcnRpY2FsID09PSB2YWx1ZShzcGVjLmRpcmVjdGlvbiwgY29uZmlnLmRpcmVjdGlvbiB8fCAocyA/IGNvbmZpZy5zeW1ib2xEaXJlY3Rpb24gOiBjb25maWcuZ3JhZGllbnREaXJlY3Rpb24pKTtcbiAgXy5ncmFkaWVudExlbmd0aCA9ICgpID0+IHZhbHVlKHNwZWMuZ3JhZGllbnRMZW5ndGgsIGNvbmZpZy5ncmFkaWVudExlbmd0aCB8fCBjb25maWcuZ3JhZGllbnRXaWR0aCk7XG4gIF8uZ3JhZGllbnRUaGlja25lc3MgPSAoKSA9PiB2YWx1ZShzcGVjLmdyYWRpZW50VGhpY2tuZXNzLCBjb25maWcuZ3JhZGllbnRUaGlja25lc3MgfHwgY29uZmlnLmdyYWRpZW50SGVpZ2h0KTtcbiAgXy5lbnRyeUNvbHVtbnMgPSAoKSA9PiB2YWx1ZShzcGVjLmNvbHVtbnMsIHZhbHVlKGNvbmZpZy5jb2x1bW5zLCArXy5pc1ZlcnRpY2FsKHRydWUpKSk7XG4gIHJldHVybiBfO1xufVxuZnVuY3Rpb24gZ2V0RW5jb2RpbmcobmFtZSwgZW5jb2RlKSB7XG4gIGNvbnN0IHYgPSBlbmNvZGUgJiYgKGVuY29kZS51cGRhdGUgJiYgZW5jb2RlLnVwZGF0ZVtuYW1lXSB8fCBlbmNvZGUuZW50ZXIgJiYgZW5jb2RlLmVudGVyW25hbWVdKTtcbiAgcmV0dXJuIHYgJiYgdi5zaWduYWwgPyB2IDogdiA/IHYudmFsdWUgOiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0U3R5bGUobmFtZSwgc2NvcGUsIHN0eWxlKSB7XG4gIGNvbnN0IHMgPSBzY29wZS5jb25maWcuc3R5bGVbc3R5bGVdO1xuICByZXR1cm4gcyAmJiBzW25hbWVdO1xufVxuZnVuY3Rpb24gYW5jaG9yRXhwcihzLCBlLCBtKSB7XG4gIHJldHVybiBgaXRlbS5hbmNob3IgPT09ICcke1N0YXJ0fScgPyAke3N9IDogaXRlbS5hbmNob3IgPT09ICcke0VuZH0nID8gJHtlfSA6ICR7bX1gO1xufVxuY29uc3QgYWxpZ25FeHByJDEgPSBhbmNob3JFeHByKHN0cmluZ1ZhbHVlKExlZnQpLCBzdHJpbmdWYWx1ZShSaWdodCksIHN0cmluZ1ZhbHVlKENlbnRlcikpO1xuZnVuY3Rpb24gdGlja0JhbmQoXykge1xuICBjb25zdCB2ID0gXygndGlja0JhbmQnKTtcbiAgbGV0IG9mZnNldCA9IF8oJ3RpY2tPZmZzZXQnKSxcbiAgICBiYW5kLFxuICAgIGV4dHJhO1xuICBpZiAoIXYpIHtcbiAgICAvLyBpZiBubyB0aWNrIGJhbmQgZW50cnksIGZhbGwgYmFjayBvbiBvdGhlciBwcm9wZXJ0aWVzXG4gICAgYmFuZCA9IF8oJ2JhbmRQb3NpdGlvbicpO1xuICAgIGV4dHJhID0gXygndGlja0V4dHJhJyk7XG4gIH0gZWxzZSBpZiAodi5zaWduYWwpIHtcbiAgICAvLyBpZiBzaWduYWwsIGF1Z21lbnQgY29kZSB0byBpbnRlcnByZXQgdmFsdWVzXG4gICAgYmFuZCA9IHtcbiAgICAgIHNpZ25hbDogYCgke3Yuc2lnbmFsfSkgPT09ICdleHRlbnQnID8gMSA6IDAuNWBcbiAgICB9O1xuICAgIGV4dHJhID0ge1xuICAgICAgc2lnbmFsOiBgKCR7di5zaWduYWx9KSA9PT0gJ2V4dGVudCdgXG4gICAgfTtcbiAgICBpZiAoIWlzT2JqZWN0KG9mZnNldCkpIHtcbiAgICAgIG9mZnNldCA9IHtcbiAgICAgICAgc2lnbmFsOiBgKCR7di5zaWduYWx9KSA9PT0gJ2V4dGVudCcgPyAwIDogJHtvZmZzZXR9YFxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodiA9PT0gJ2V4dGVudCcpIHtcbiAgICAvLyBpZiBjb25zdGFudCwgc2ltcGx5IHNldCB2YWx1ZXNcbiAgICBiYW5kID0gMTtcbiAgICBleHRyYSA9IHRydWU7XG4gICAgb2Zmc2V0ID0gMDtcbiAgfSBlbHNlIHtcbiAgICBiYW5kID0gMC41O1xuICAgIGV4dHJhID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBleHRyYSxcbiAgICBiYW5kLFxuICAgIG9mZnNldFxuICB9O1xufVxuZnVuY3Rpb24gZXh0ZW5kT2Zmc2V0KHZhbHVlLCBvZmZzZXQpIHtcbiAgcmV0dXJuICFvZmZzZXQgPyB2YWx1ZSA6ICF2YWx1ZSA/IG9mZnNldCA6ICFpc09iamVjdCh2YWx1ZSkgPyB7XG4gICAgdmFsdWUsXG4gICAgb2Zmc2V0XG4gIH0gOiBPYmplY3QuYXNzaWduKHt9LCB2YWx1ZSwge1xuICAgIG9mZnNldDogZXh0ZW5kT2Zmc2V0KHZhbHVlLm9mZnNldCwgb2Zmc2V0KVxuICB9KTtcbn1cblxuZnVuY3Rpb24gZ3VpZGVNYXJrIChtYXJrLCBleHRyYXMpIHtcbiAgaWYgKGV4dHJhcykge1xuICAgIG1hcmsubmFtZSA9IGV4dHJhcy5uYW1lO1xuICAgIG1hcmsuc3R5bGUgPSBleHRyYXMuc3R5bGUgfHwgbWFyay5zdHlsZTtcbiAgICBtYXJrLmludGVyYWN0aXZlID0gISFleHRyYXMuaW50ZXJhY3RpdmU7XG4gICAgbWFyay5lbmNvZGUgPSBleHRlbmRFbmNvZGUobWFyay5lbmNvZGUsIGV4dHJhcywgU2tpcCk7XG4gIH0gZWxzZSB7XG4gICAgbWFyay5pbnRlcmFjdGl2ZSA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBtYXJrO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRHcmFkaWVudCAoc3BlYywgc2NhbGUsIGNvbmZpZywgdXNlckVuY29kZSkge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgdmVydGljYWwgPSBfLmlzVmVydGljYWwoKSxcbiAgICB0aGlja25lc3MgPSBfLmdyYWRpZW50VGhpY2tuZXNzKCksXG4gICAgbGVuZ3RoID0gXy5ncmFkaWVudExlbmd0aCgpO1xuICBsZXQgZW50ZXIsIHN0YXJ0LCBzdG9wLCB3aWR0aCwgaGVpZ2h0O1xuICBpZiAodmVydGljYWwpIHtcbiAgICBzdGFydCA9IFswLCAxXTtcbiAgICBzdG9wID0gWzAsIDBdO1xuICAgIHdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGhlaWdodCA9IGxlbmd0aDtcbiAgfSBlbHNlIHtcbiAgICBzdGFydCA9IFswLCAwXTtcbiAgICBzdG9wID0gWzEsIDBdO1xuICAgIHdpZHRoID0gbGVuZ3RoO1xuICAgIGhlaWdodCA9IHRoaWNrbmVzcztcbiAgfVxuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IHplcm8sXG4gICAgICB5OiB6ZXJvLFxuICAgICAgd2lkdGg6IGVuY29kZXIod2lkdGgpLFxuICAgICAgaGVpZ2h0OiBlbmNvZGVyKGhlaWdodClcbiAgICB9LFxuICAgIHVwZGF0ZTogZXh0ZW5kKHt9LCBlbnRlciwge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgZmlsbDoge1xuICAgICAgICBncmFkaWVudDogc2NhbGUsXG4gICAgICAgIHN0YXJ0OiBzdGFydCxcbiAgICAgICAgc3RvcDogc3RvcFxuICAgICAgfVxuICAgIH0pLFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygnZ3JhZGllbnRTdHJva2VDb2xvcicpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdncmFkaWVudFN0cm9rZVdpZHRoJylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIG9wYWNpdHk6IF8oJ2dyYWRpZW50T3BhY2l0eScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBSZWN0TWFyayxcbiAgICByb2xlOiBMZWdlbmRHcmFkaWVudFJvbGUsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBsZWdlbmRHcmFkaWVudERpc2NyZXRlIChzcGVjLCBzY2FsZSwgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICB2ZXJ0aWNhbCA9IF8uaXNWZXJ0aWNhbCgpLFxuICAgIHRoaWNrbmVzcyA9IF8uZ3JhZGllbnRUaGlja25lc3MoKSxcbiAgICBsZW5ndGggPSBfLmdyYWRpZW50TGVuZ3RoKCk7XG4gIGxldCB1LFxuICAgIHYsXG4gICAgdXUsXG4gICAgdnYsXG4gICAgYWRqdXN0ID0gJyc7XG4gIHZlcnRpY2FsID8gKHUgPSAneScsIHV1ID0gJ3kyJywgdiA9ICd4JywgdnYgPSAnd2lkdGgnLCBhZGp1c3QgPSAnMS0nKSA6ICh1ID0gJ3gnLCB1dSA9ICd4MicsIHYgPSAneScsIHZ2ID0gJ2hlaWdodCcpO1xuICBjb25zdCBlbnRlciA9IHtcbiAgICBvcGFjaXR5OiB6ZXJvLFxuICAgIGZpbGw6IHtcbiAgICAgIHNjYWxlOiBzY2FsZSxcbiAgICAgIGZpZWxkOiBWYWx1ZVxuICAgIH1cbiAgfTtcbiAgZW50ZXJbdV0gPSB7XG4gICAgc2lnbmFsOiBhZGp1c3QgKyAnZGF0dW0uJyArIFBlcmMsXG4gICAgbXVsdDogbGVuZ3RoXG4gIH07XG4gIGVudGVyW3ZdID0gemVybztcbiAgZW50ZXJbdXVdID0ge1xuICAgIHNpZ25hbDogYWRqdXN0ICsgJ2RhdHVtLicgKyBQZXJjMixcbiAgICBtdWx0OiBsZW5ndGhcbiAgfTtcbiAgZW50ZXJbdnZdID0gZW5jb2Rlcih0aGlja25lc3MpO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyLFxuICAgIHVwZGF0ZTogZXh0ZW5kKHt9LCBlbnRlciwge1xuICAgICAgb3BhY2l0eTogb25lXG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdncmFkaWVudFN0cm9rZUNvbG9yJyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ2dyYWRpZW50U3Ryb2tlV2lkdGgnKVxuICB9LCB7XG4gICAgLy8gdXBkYXRlXG4gICAgb3BhY2l0eTogXygnZ3JhZGllbnRPcGFjaXR5JylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJlY3RNYXJrLFxuICAgIHJvbGU6IExlZ2VuZEJhbmRSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmNvbnN0IGFsaWduRXhwciA9IGBkYXR1bS4ke1BlcmN9PD0wP1wiJHtMZWZ0fVwiOmRhdHVtLiR7UGVyY30+PTE/XCIke1JpZ2h0fVwiOlwiJHtDZW50ZXJ9XCJgLFxuICBiYXNlbGluZUV4cHIgPSBgZGF0dW0uJHtQZXJjfTw9MD9cIiR7Qm90dG9tfVwiOmRhdHVtLiR7UGVyY30+PTE/XCIke1RvcH1cIjpcIiR7TWlkZGxlfVwiYDtcbmZ1bmN0aW9uIGxlZ2VuZEdyYWRpZW50TGFiZWxzIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgIHZlcnRpY2FsID0gXy5pc1ZlcnRpY2FsKCksXG4gICAgdGhpY2tuZXNzID0gZW5jb2RlcihfLmdyYWRpZW50VGhpY2tuZXNzKCkpLFxuICAgIGxlbmd0aCA9IF8uZ3JhZGllbnRMZW5ndGgoKTtcbiAgbGV0IG92ZXJsYXAgPSBfKCdsYWJlbE92ZXJsYXAnKSxcbiAgICBlbnRlcixcbiAgICB1cGRhdGUsXG4gICAgdSxcbiAgICB2LFxuICAgIGFkanVzdCA9ICcnO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGZpZWxkOiBMYWJlbFxuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdsYWJlbEZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogdmFsdWUoc3BlYy5sYWJlbExpbWl0LCBjb25maWcuZ3JhZGllbnRMYWJlbExpbWl0KVxuICB9KTtcbiAgaWYgKHZlcnRpY2FsKSB7XG4gICAgZW50ZXIuYWxpZ24gPSB7XG4gICAgICB2YWx1ZTogJ2xlZnQnXG4gICAgfTtcbiAgICBlbnRlci5iYXNlbGluZSA9IHVwZGF0ZS5iYXNlbGluZSA9IHtcbiAgICAgIHNpZ25hbDogYmFzZWxpbmVFeHByXG4gICAgfTtcbiAgICB1ID0gJ3knO1xuICAgIHYgPSAneCc7XG4gICAgYWRqdXN0ID0gJzEtJztcbiAgfSBlbHNlIHtcbiAgICBlbnRlci5hbGlnbiA9IHVwZGF0ZS5hbGlnbiA9IHtcbiAgICAgIHNpZ25hbDogYWxpZ25FeHByXG4gICAgfTtcbiAgICBlbnRlci5iYXNlbGluZSA9IHtcbiAgICAgIHZhbHVlOiAndG9wJ1xuICAgIH07XG4gICAgdSA9ICd4JztcbiAgICB2ID0gJ3knO1xuICB9XG4gIGVudGVyW3VdID0gdXBkYXRlW3VdID0ge1xuICAgIHNpZ25hbDogYWRqdXN0ICsgJ2RhdHVtLicgKyBQZXJjLFxuICAgIG11bHQ6IGxlbmd0aFxuICB9O1xuICBlbnRlclt2XSA9IHVwZGF0ZVt2XSA9IHRoaWNrbmVzcztcbiAgdGhpY2tuZXNzLm9mZnNldCA9IHZhbHVlKHNwZWMubGFiZWxPZmZzZXQsIGNvbmZpZy5ncmFkaWVudExhYmVsT2Zmc2V0KSB8fCAwO1xuICBvdmVybGFwID0gb3ZlcmxhcCA/IHtcbiAgICBzZXBhcmF0aW9uOiBfKCdsYWJlbFNlcGFyYXRpb24nKSxcbiAgICBtZXRob2Q6IG92ZXJsYXAsXG4gICAgb3JkZXI6ICdkYXR1bS4nICsgSW5kZXhcbiAgfSA6IHVuZGVmaW5lZDtcblxuICAvLyB0eXBlLCByb2xlLCBzdHlsZSwga2V5LCBkYXRhUmVmLCBlbmNvZGUsIGV4dHJhc1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBMZWdlbmRMYWJlbFJvbGUsXG4gICAgc3R5bGU6IEd1aWRlTGFiZWxTdHlsZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlLFxuICAgIG92ZXJsYXBcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbi8vIHVzZXJFbmNvZGUgaXMgdG9wLWxldmVsLCBpbmNsdWRlcyBlbnRyaWVzLCBzeW1ib2xzLCBsYWJlbHNcbmZ1bmN0aW9uIGxlZ2VuZFN5bWJvbEdyb3VwcyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBjb2x1bW5zKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICBlbnRyaWVzID0gdXNlckVuY29kZS5lbnRyaWVzLFxuICAgIGludGVyYWN0aXZlID0gISEoZW50cmllcyAmJiBlbnRyaWVzLmludGVyYWN0aXZlKSxcbiAgICBuYW1lID0gZW50cmllcyA/IGVudHJpZXMubmFtZSA6IHVuZGVmaW5lZCxcbiAgICBoZWlnaHQgPSBfKCdjbGlwSGVpZ2h0JyksXG4gICAgc3ltYm9sT2Zmc2V0ID0gXygnc3ltYm9sT2Zmc2V0JyksXG4gICAgdmFsdWVSZWYgPSB7XG4gICAgICBkYXRhOiAndmFsdWUnXG4gICAgfSxcbiAgICB4U2lnbmFsID0gYCgke2NvbHVtbnN9KSA/IGRhdHVtLiR7T2Zmc2V0fSA6IGRhdHVtLiR7U2l6ZX1gLFxuICAgIHlFbmNvZGUgPSBoZWlnaHQgPyBlbmNvZGVyKGhlaWdodCkgOiB7XG4gICAgICBmaWVsZDogU2l6ZVxuICAgIH0sXG4gICAgaW5kZXggPSBgZGF0dW0uJHtJbmRleH1gLFxuICAgIG5jb2xzID0gYG1heCgxLCAke2NvbHVtbnN9KWA7XG4gIGxldCBlbmNvZGUsIGVudGVyLCB1cGRhdGUsIG5yb3dzLCBzb3J0O1xuICB5RW5jb2RlLm11bHQgPSAwLjU7XG5cbiAgLy8gLS0gTEVHRU5EIFNZTUJPTFMgLS1cbiAgZW5jb2RlID0ge1xuICAgIGVudGVyOiBlbnRlciA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm8sXG4gICAgICB4OiB7XG4gICAgICAgIHNpZ25hbDogeFNpZ25hbCxcbiAgICAgICAgbXVsdDogMC41LFxuICAgICAgICBvZmZzZXQ6IHN5bWJvbE9mZnNldFxuICAgICAgfSxcbiAgICAgIHk6IHlFbmNvZGVcbiAgICB9LFxuICAgIHVwZGF0ZTogdXBkYXRlID0ge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgeDogZW50ZXIueCxcbiAgICAgIHk6IGVudGVyLnlcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGxldCBiYXNlRmlsbCA9IG51bGwsXG4gICAgYmFzZVN0cm9rZSA9IG51bGw7XG4gIGlmICghc3BlYy5maWxsKSB7XG4gICAgYmFzZUZpbGwgPSBjb25maWcuc3ltYm9sQmFzZUZpbGxDb2xvcjtcbiAgICBiYXNlU3Ryb2tlID0gY29uZmlnLnN5bWJvbEJhc2VTdHJva2VDb2xvcjtcbiAgfVxuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBmaWxsOiBfKCdzeW1ib2xGaWxsQ29sb3InLCBiYXNlRmlsbCksXG4gICAgc2hhcGU6IF8oJ3N5bWJvbFR5cGUnKSxcbiAgICBzaXplOiBfKCdzeW1ib2xTaXplJyksXG4gICAgc3Ryb2tlOiBfKCdzeW1ib2xTdHJva2VDb2xvcicsIGJhc2VTdHJva2UpLFxuICAgIHN0cm9rZURhc2g6IF8oJ3N5bWJvbERhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCdzeW1ib2xEYXNoT2Zmc2V0JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ3N5bWJvbFN0cm9rZVdpZHRoJylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIG9wYWNpdHk6IF8oJ3N5bWJvbE9wYWNpdHknKVxuICB9KTtcbiAgTGVnZW5kU2NhbGVzLmZvckVhY2goc2NhbGUgPT4ge1xuICAgIGlmIChzcGVjW3NjYWxlXSkge1xuICAgICAgdXBkYXRlW3NjYWxlXSA9IGVudGVyW3NjYWxlXSA9IHtcbiAgICAgICAgc2NhbGU6IHNwZWNbc2NhbGVdLFxuICAgICAgICBmaWVsZDogVmFsdWVcbiAgICAgIH07XG4gICAgfVxuICB9KTtcbiAgY29uc3Qgc3ltYm9scyA9IGd1aWRlTWFyayh7XG4gICAgdHlwZTogU3ltYm9sTWFyayxcbiAgICByb2xlOiBMZWdlbmRTeW1ib2xSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogdmFsdWVSZWYsXG4gICAgY2xpcDogaGVpZ2h0ID8gdHJ1ZSA6IHVuZGVmaW5lZCxcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZS5zeW1ib2xzKTtcblxuICAvLyAtLSBMRUdFTkQgTEFCRUxTIC0tXG4gIGNvbnN0IGxhYmVsT2Zmc2V0ID0gZW5jb2RlcihzeW1ib2xPZmZzZXQpO1xuICBsYWJlbE9mZnNldC5vZmZzZXQgPSBfKCdsYWJlbE9mZnNldCcpO1xuICBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IHtcbiAgICAgICAgc2lnbmFsOiB4U2lnbmFsLFxuICAgICAgICBvZmZzZXQ6IGxhYmVsT2Zmc2V0XG4gICAgICB9LFxuICAgICAgeTogeUVuY29kZVxuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGZpZWxkOiBMYWJlbFxuICAgICAgfSxcbiAgICAgIHg6IGVudGVyLngsXG4gICAgICB5OiBlbnRlci55XG4gICAgfSxcbiAgICBleGl0OiB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBhbGlnbjogXygnbGFiZWxBbGlnbicpLFxuICAgIGJhc2VsaW5lOiBfKCdsYWJlbEJhc2VsaW5lJyksXG4gICAgZmlsbDogXygnbGFiZWxDb2xvcicpLFxuICAgIGZpbGxPcGFjaXR5OiBfKCdsYWJlbE9wYWNpdHknKSxcbiAgICBmb250OiBfKCdsYWJlbEZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnbGFiZWxGb250U2l6ZScpLFxuICAgIGZvbnRTdHlsZTogXygnbGFiZWxGb250U3R5bGUnKSxcbiAgICBmb250V2VpZ2h0OiBfKCdsYWJlbEZvbnRXZWlnaHQnKSxcbiAgICBsaW1pdDogXygnbGFiZWxMaW1pdCcpXG4gIH0pO1xuICBjb25zdCBsYWJlbHMgPSBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IExlZ2VuZExhYmVsUm9sZSxcbiAgICBzdHlsZTogR3VpZGVMYWJlbFN0eWxlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogdmFsdWVSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUubGFiZWxzKTtcblxuICAvLyAtLSBMRUdFTkQgRU5UUlkgR1JPVVBTIC0tXG4gIGVuY29kZSA9IHtcbiAgICBlbnRlcjoge1xuICAgICAgbm9Cb3VuZDoge1xuICAgICAgICB2YWx1ZTogIWhlaWdodFxuICAgICAgfSxcbiAgICAgIC8vIGlnbm9yZSB3aWR0aC9oZWlnaHQgaW4gYm91bmRzIGNhbGNcbiAgICAgIHdpZHRoOiB6ZXJvLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQgPyBlbmNvZGVyKGhlaWdodCkgOiB6ZXJvLFxuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICByb3c6IHtcbiAgICAgICAgc2lnbmFsOiBudWxsXG4gICAgICB9LFxuICAgICAgY29sdW1uOiB7XG4gICAgICAgIHNpZ25hbDogbnVsbFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBhbm5vdGF0ZSBhbmQgc29ydCBncm91cHMgdG8gZW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmdcbiAgaWYgKF8uaXNWZXJ0aWNhbCh0cnVlKSkge1xuICAgIG5yb3dzID0gYGNlaWwoaXRlbS5tYXJrLml0ZW1zLmxlbmd0aCAvICR7bmNvbHN9KWA7XG4gICAgdXBkYXRlLnJvdy5zaWduYWwgPSBgJHtpbmRleH0lJHtucm93c31gO1xuICAgIHVwZGF0ZS5jb2x1bW4uc2lnbmFsID0gYGZsb29yKCR7aW5kZXh9IC8gJHtucm93c30pYDtcbiAgICBzb3J0ID0ge1xuICAgICAgZmllbGQ6IFsncm93JywgaW5kZXhdXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGUucm93LnNpZ25hbCA9IGBmbG9vcigke2luZGV4fSAvICR7bmNvbHN9KWA7XG4gICAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgJHtpbmRleH0gJSAke25jb2xzfWA7XG4gICAgc29ydCA9IHtcbiAgICAgIGZpZWxkOiBpbmRleFxuICAgIH07XG4gIH1cbiAgLy8gaGFuZGxlIHplcm8gY29sdW1uIGNhc2UgKGltcGxpZXMgaW5maW5pdGUgY29sdW1ucylcbiAgdXBkYXRlLmNvbHVtbi5zaWduYWwgPSBgKCR7Y29sdW1uc30pPyR7dXBkYXRlLmNvbHVtbi5zaWduYWx9OiR7aW5kZXh9YDtcblxuICAvLyBmYWNldCBsZWdlbmQgZW50cmllcyBpbnRvIHN1Yi1ncm91cHNcbiAgZGF0YVJlZiA9IHtcbiAgICBmYWNldDoge1xuICAgICAgZGF0YTogZGF0YVJlZixcbiAgICAgIG5hbWU6ICd2YWx1ZScsXG4gICAgICBncm91cGJ5OiBJbmRleFxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGd1aWRlR3JvdXAoe1xuICAgIHJvbGU6IFNjb3BlUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGVuY29kZSwgZW50cmllcywgU2tpcCksXG4gICAgbWFya3M6IFtzeW1ib2xzLCBsYWJlbHNdLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc29ydFxuICB9KTtcbn1cbmZ1bmN0aW9uIGxlZ2VuZFN5bWJvbExheW91dChzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpO1xuXG4gIC8vIGxheW91dCBwYXJhbWV0ZXJzIGZvciBsZWdlbmQgZW50cmllc1xuICByZXR1cm4ge1xuICAgIGFsaWduOiBfKCdncmlkQWxpZ24nKSxcbiAgICBjb2x1bW5zOiBfLmVudHJ5Q29sdW1ucygpLFxuICAgIGNlbnRlcjoge1xuICAgICAgcm93OiB0cnVlLFxuICAgICAgY29sdW1uOiBmYWxzZVxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgcm93OiBfKCdyb3dQYWRkaW5nJyksXG4gICAgICBjb2x1bW46IF8oJ2NvbHVtblBhZGRpbmcnKVxuICAgIH1cbiAgfTtcbn1cblxuLy8gZXhwcmVzc2lvbiBsb2dpYyBmb3IgYWxpZ24sIGFuY2hvciwgYW5nbGUsIGFuZCBiYXNlbGluZSBjYWxjdWxhdGlvblxuY29uc3QgaXNMID0gJ2l0ZW0ub3JpZW50ID09PSBcImxlZnRcIicsXG4gIGlzUiA9ICdpdGVtLm9yaWVudCA9PT0gXCJyaWdodFwiJyxcbiAgaXNMUiA9IGAoJHtpc0x9IHx8ICR7aXNSfSlgLFxuICBpc1ZHID0gYGRhdHVtLnZncmFkICYmICR7aXNMUn1gLFxuICBiYXNlbGluZSA9IGFuY2hvckV4cHIoJ1widG9wXCInLCAnXCJib3R0b21cIicsICdcIm1pZGRsZVwiJyksXG4gIGFsaWduRmxpcCA9IGFuY2hvckV4cHIoJ1wicmlnaHRcIicsICdcImxlZnRcIicsICdcImNlbnRlclwiJyksXG4gIGV4cHJBbGlnbiA9IGBkYXR1bS52Z3JhZCAmJiAke2lzUn0gPyAoJHthbGlnbkZsaXB9KSA6ICgke2lzTFJ9ICYmICEoZGF0dW0udmdyYWQgJiYgJHtpc0x9KSkgPyBcImxlZnRcIiA6ICR7YWxpZ25FeHByJDF9YCxcbiAgZXhwckFuY2hvciA9IGBpdGVtLl9hbmNob3IgfHwgKCR7aXNMUn0gPyBcIm1pZGRsZVwiIDogXCJzdGFydFwiKWAsXG4gIGV4cHJBbmdsZSA9IGAke2lzVkd9ID8gKCR7aXNMfSA/IC05MCA6IDkwKSA6IDBgLFxuICBleHByQmFzZWxpbmUgPSBgJHtpc0xSfSA/IChkYXR1bS52Z3JhZCA/ICgke2lzUn0gPyBcImJvdHRvbVwiIDogXCJ0b3BcIikgOiAke2Jhc2VsaW5lfSkgOiBcInRvcFwiYDtcbmZ1bmN0aW9uIGxlZ2VuZFRpdGxlIChzcGVjLCBjb25maWcsIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9LFxuICAgIHVwZGF0ZToge1xuICAgICAgb3BhY2l0eTogb25lLFxuICAgICAgeDoge1xuICAgICAgICBmaWVsZDoge1xuICAgICAgICAgIGdyb3VwOiAncGFkZGluZydcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHk6IHtcbiAgICAgICAgZmllbGQ6IHtcbiAgICAgICAgICBncm91cDogJ3BhZGRpbmcnXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygndGl0bGVPcmllbnQnKSxcbiAgICBfYW5jaG9yOiBfKCd0aXRsZUFuY2hvcicpLFxuICAgIGFuY2hvcjoge1xuICAgICAgc2lnbmFsOiBleHByQW5jaG9yXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgc2lnbmFsOiBleHByQW5nbGVcbiAgICB9LFxuICAgIGFsaWduOiB7XG4gICAgICBzaWduYWw6IGV4cHJBbGlnblxuICAgIH0sXG4gICAgYmFzZWxpbmU6IHtcbiAgICAgIHNpZ25hbDogZXhwckJhc2VsaW5lXG4gICAgfSxcbiAgICB0ZXh0OiBzcGVjLnRpdGxlLFxuICAgIGZpbGw6IF8oJ3RpdGxlQ29sb3InKSxcbiAgICBmaWxsT3BhY2l0eTogXygndGl0bGVPcGFjaXR5JyksXG4gICAgZm9udDogXygndGl0bGVGb250JyksXG4gICAgZm9udFNpemU6IF8oJ3RpdGxlRm9udFNpemUnKSxcbiAgICBmb250U3R5bGU6IF8oJ3RpdGxlRm9udFN0eWxlJyksXG4gICAgZm9udFdlaWdodDogXygndGl0bGVGb250V2VpZ2h0JyksXG4gICAgbGltaXQ6IF8oJ3RpdGxlTGltaXQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCd0aXRsZUxpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgLy8gcmVxdWlyZSB1cGRhdGVcbiAgICBhbGlnbjogXygndGl0bGVBbGlnbicpLFxuICAgIGJhc2VsaW5lOiBfKCd0aXRsZUJhc2VsaW5lJylcbiAgfSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IExlZ2VuZFRpdGxlUm9sZSxcbiAgICBzdHlsZTogR3VpZGVUaXRsZVN0eWxlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuXG5mdW5jdGlvbiBjbGlwIChjbGlwLCBzY29wZSkge1xuICBsZXQgZXhwcjtcbiAgaWYgKGlzT2JqZWN0KGNsaXApKSB7XG4gICAgaWYgKGNsaXAuc2lnbmFsKSB7XG4gICAgICBleHByID0gY2xpcC5zaWduYWw7XG4gICAgfSBlbHNlIGlmIChjbGlwLnBhdGgpIHtcbiAgICAgIGV4cHIgPSAncGF0aFNoYXBlKCcgKyBwYXJhbShjbGlwLnBhdGgpICsgJyknO1xuICAgIH0gZWxzZSBpZiAoY2xpcC5zcGhlcmUpIHtcbiAgICAgIGV4cHIgPSAnZ2VvU2hhcGUoJyArIHBhcmFtKGNsaXAuc3BoZXJlKSArICcsIHt0eXBlOiBcIlNwaGVyZVwifSknO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZXhwciA/IHNjb3BlLnNpZ25hbFJlZihleHByKSA6ICEhY2xpcDtcbn1cbmZ1bmN0aW9uIHBhcmFtKHZhbHVlKSB7XG4gIHJldHVybiBpc09iamVjdCh2YWx1ZSkgJiYgdmFsdWUuc2lnbmFsID8gdmFsdWUuc2lnbmFsIDogc3RyaW5nVmFsdWUodmFsdWUpO1xufVxuXG5mdW5jdGlvbiBnZXRSb2xlIChzcGVjKSB7XG4gIGNvbnN0IHJvbGUgPSBzcGVjLnJvbGUgfHwgJyc7XG4gIHJldHVybiByb2xlLnN0YXJ0c1dpdGgoJ2F4aXMnKSB8fCByb2xlLnN0YXJ0c1dpdGgoJ2xlZ2VuZCcpIHx8IHJvbGUuc3RhcnRzV2l0aCgndGl0bGUnKSA/IHJvbGUgOiBzcGVjLnR5cGUgPT09IEdyb3VwTWFyayA/IFNjb3BlUm9sZSA6IHJvbGUgfHwgTWFya1JvbGU7XG59XG5cbmZ1bmN0aW9uIGRlZmluaXRpb24gKHNwZWMpIHtcbiAgcmV0dXJuIHtcbiAgICBtYXJrdHlwZTogc3BlYy50eXBlLFxuICAgIG5hbWU6IHNwZWMubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgcm9sZTogc3BlYy5yb2xlIHx8IGdldFJvbGUoc3BlYyksXG4gICAgemluZGV4OiArc3BlYy56aW5kZXggfHwgdW5kZWZpbmVkLFxuICAgIGFyaWE6IHNwZWMuYXJpYSxcbiAgICBkZXNjcmlwdGlvbjogc3BlYy5kZXNjcmlwdGlvblxuICB9O1xufVxuXG5mdW5jdGlvbiBpbnRlcmFjdGl2ZSAoc3BlYywgc2NvcGUpIHtcbiAgcmV0dXJuIHNwZWMgJiYgc3BlYy5zaWduYWwgPyBzY29wZS5zaWduYWxSZWYoc3BlYy5zaWduYWwpIDogc3BlYyA9PT0gZmFsc2UgPyBmYWxzZSA6IHRydWU7XG59XG5cbi8qKlxuICogUGFyc2UgYSBkYXRhIHRyYW5zZm9ybSBzcGVjaWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSAoc3BlYywgc2NvcGUpIHtcbiAgY29uc3QgZGVmID0gZGVmaW5pdGlvbiQxKHNwZWMudHlwZSk7XG4gIGlmICghZGVmKSBlcnJvcignVW5yZWNvZ25pemVkIHRyYW5zZm9ybSB0eXBlOiAnICsgc3RyaW5nVmFsdWUoc3BlYy50eXBlKSk7XG4gIGNvbnN0IHQgPSBlbnRyeShkZWYudHlwZS50b0xvd2VyQ2FzZSgpLCBudWxsLCBwYXJzZVBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkpO1xuICBpZiAoc3BlYy5zaWduYWwpIHNjb3BlLmFkZFNpZ25hbChzcGVjLnNpZ25hbCwgc2NvcGUucHJveHkodCkpO1xuICB0Lm1ldGFkYXRhID0gZGVmLm1ldGFkYXRhIHx8IHt9O1xuICByZXR1cm4gdDtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbGwgcGFyYW1ldGVycyBvZiBhIGRhdGEgdHJhbnNmb3JtLlxuICovXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCBwYXJhbXMgPSB7fSxcbiAgICBuID0gZGVmLnBhcmFtcy5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgcGRlZiA9IGRlZi5wYXJhbXNbaV07XG4gICAgcGFyYW1zW3BkZWYubmFtZV0gPSBwYXJzZVBhcmFtZXRlcihwZGVmLCBzcGVjLCBzY29wZSk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGRhdGEgdHJhbnNmb3JtIHBhcmFtZXRlci5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXJhbWV0ZXIoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCB0eXBlID0gZGVmLnR5cGUsXG4gICAgdmFsdWUgPSBzcGVjW2RlZi5uYW1lXTtcbiAgaWYgKHR5cGUgPT09ICdpbmRleCcpIHtcbiAgICByZXR1cm4gcGFyc2VJbmRleFBhcmFtZXRlcihkZWYsIHNwZWMsIHNjb3BlKTtcbiAgfSBlbHNlIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKGRlZi5yZXF1aXJlZCkge1xuICAgICAgZXJyb3IoJ01pc3NpbmcgcmVxdWlyZWQgJyArIHN0cmluZ1ZhbHVlKHNwZWMudHlwZSkgKyAnIHBhcmFtZXRlcjogJyArIHN0cmluZ1ZhbHVlKGRlZi5uYW1lKSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncGFyYW0nKSB7XG4gICAgcmV0dXJuIHBhcnNlU3ViUGFyYW1ldGVycyhkZWYsIHNwZWMsIHNjb3BlKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAncHJvamVjdGlvbicpIHtcbiAgICByZXR1cm4gc2NvcGUucHJvamVjdGlvblJlZihzcGVjW2RlZi5uYW1lXSk7XG4gIH1cbiAgcmV0dXJuIGRlZi5hcnJheSAmJiAhaXNTaWduYWwodmFsdWUpID8gdmFsdWUubWFwKHYgPT4gcGFyYW1ldGVyVmFsdWUoZGVmLCB2LCBzY29wZSkpIDogcGFyYW1ldGVyVmFsdWUoZGVmLCB2YWx1ZSwgc2NvcGUpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgc2luZ2xlIHBhcmFtZXRlciB2YWx1ZS5cbiAqL1xuZnVuY3Rpb24gcGFyYW1ldGVyVmFsdWUoZGVmLCB2YWx1ZSwgc2NvcGUpIHtcbiAgY29uc3QgdHlwZSA9IGRlZi50eXBlO1xuICBpZiAoaXNTaWduYWwodmFsdWUpKSB7XG4gICAgcmV0dXJuIGlzRXhwcih0eXBlKSA/IGVycm9yKCdFeHByZXNzaW9uIHJlZmVyZW5jZXMgY2FuIG5vdCBiZSBzaWduYWxzLicpIDogaXNGaWVsZCh0eXBlKSA/IHNjb3BlLmZpZWxkUmVmKHZhbHVlKSA6IGlzQ29tcGFyZSh0eXBlKSA/IHNjb3BlLmNvbXBhcmVSZWYodmFsdWUpIDogc2NvcGUuc2lnbmFsUmVmKHZhbHVlLnNpZ25hbCk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwciA9IGRlZi5leHByIHx8IGlzRmllbGQodHlwZSk7XG4gICAgcmV0dXJuIGV4cHIgJiYgb3V0ZXJFeHByKHZhbHVlKSA/IHNjb3BlLmV4cHJSZWYodmFsdWUuZXhwciwgdmFsdWUuYXMpIDogZXhwciAmJiBvdXRlckZpZWxkKHZhbHVlKSA/IGZpZWxkUmVmJDEodmFsdWUuZmllbGQsIHZhbHVlLmFzKSA6IGlzRXhwcih0eXBlKSA/IHBhcnNlRXhwcmVzc2lvbih2YWx1ZSwgc2NvcGUpIDogaXNEYXRhKHR5cGUpID8gcmVmKHNjb3BlLmdldERhdGEodmFsdWUpLnZhbHVlcykgOiBpc0ZpZWxkKHR5cGUpID8gZmllbGRSZWYkMSh2YWx1ZSkgOiBpc0NvbXBhcmUodHlwZSkgPyBzY29wZS5jb21wYXJlUmVmKHZhbHVlKSA6IHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogUGFyc2UgcGFyYW1ldGVyIGZvciBhY2Nlc3NpbmcgYW4gaW5kZXggb2YgYW5vdGhlciBkYXRhIHNldC5cbiAqL1xuZnVuY3Rpb24gcGFyc2VJbmRleFBhcmFtZXRlcihkZWYsIHNwZWMsIHNjb3BlKSB7XG4gIGlmICghaXNTdHJpbmcoc3BlYy5mcm9tKSkge1xuICAgIGVycm9yKCdMb29rdXAgXCJmcm9tXCIgcGFyYW1ldGVyIG11c3QgYmUgYSBzdHJpbmcgbGl0ZXJhbC4nKTtcbiAgfVxuICByZXR1cm4gc2NvcGUuZ2V0RGF0YShzcGVjLmZyb20pLmxvb2t1cFJlZihzY29wZSwgc3BlYy5rZXkpO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgcGFyYW1ldGVyIHRoYXQgY29udGFpbnMgb25lIG9yIG1vcmUgc3ViLXBhcmFtZXRlciBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBwYXJzZVN1YlBhcmFtZXRlcnMoZGVmLCBzcGVjLCBzY29wZSkge1xuICBjb25zdCB2YWx1ZSA9IHNwZWNbZGVmLm5hbWVdO1xuICBpZiAoZGVmLmFycmF5KSB7XG4gICAgaWYgKCFpc0FycmF5KHZhbHVlKSkge1xuICAgICAgLy8gc2lnbmFscyBub3QgYWxsb3dlZCFcbiAgICAgIGVycm9yKCdFeHBlY3RlZCBhbiBhcnJheSBvZiBzdWItcGFyYW1ldGVycy4gSW5zdGVhZDogJyArIHN0cmluZ1ZhbHVlKHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZS5tYXAodiA9PiBwYXJzZVN1YlBhcmFtZXRlcihkZWYsIHYsIHNjb3BlKSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHBhcnNlU3ViUGFyYW1ldGVyKGRlZiwgdmFsdWUsIHNjb3BlKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc3ViLXBhcmFtZXRlciBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3ViUGFyYW1ldGVyKGRlZiwgdmFsdWUsIHNjb3BlKSB7XG4gIGNvbnN0IG4gPSBkZWYucGFyYW1zLmxlbmd0aDtcbiAgbGV0IHBkZWY7XG5cbiAgLy8gbG9vcCBvdmVyIGRlZnMgdG8gZmluZCBtYXRjaGluZyBrZXlcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBwZGVmID0gZGVmLnBhcmFtc1tpXTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcGRlZi5rZXkpIHtcbiAgICAgIGlmIChwZGVmLmtleVtrXSAhPT0gdmFsdWVba10pIHtcbiAgICAgICAgcGRlZiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocGRlZikgYnJlYWs7XG4gIH1cbiAgLy8gcmFpc2UgZXJyb3IgaWYgbWF0Y2hpbmcga2V5IG5vdCBmb3VuZFxuICBpZiAoIXBkZWYpIGVycm9yKCdVbnN1cHBvcnRlZCBwYXJhbWV0ZXI6ICcgKyBzdHJpbmdWYWx1ZSh2YWx1ZSkpO1xuXG4gIC8vIHBhcnNlIHBhcmFtcywgY3JlYXRlIFBhcmFtcyB0cmFuc2Zvcm0sIHJldHVybiByZWZcbiAgY29uc3QgcGFyYW1zID0gZXh0ZW5kKHBhcnNlUGFyYW1ldGVycyhwZGVmLCB2YWx1ZSwgc2NvcGUpLCBwZGVmLmtleSk7XG4gIHJldHVybiByZWYoc2NvcGUuYWRkKFBhcmFtcyhwYXJhbXMpKSk7XG59XG5cbi8vIC0tIFV0aWxpdGllcyAtLS0tLVxuXG5jb25zdCBvdXRlckV4cHIgPSBfID0+IF8gJiYgXy5leHByO1xuY29uc3Qgb3V0ZXJGaWVsZCA9IF8gPT4gXyAmJiBfLmZpZWxkO1xuY29uc3QgaXNEYXRhID0gXyA9PiBfID09PSAnZGF0YSc7XG5jb25zdCBpc0V4cHIgPSBfID0+IF8gPT09ICdleHByJztcbmNvbnN0IGlzRmllbGQgPSBfID0+IF8gPT09ICdmaWVsZCc7XG5jb25zdCBpc0NvbXBhcmUgPSBfID0+IF8gPT09ICdjb21wYXJlJztcblxuZnVuY3Rpb24gcGFyc2VEYXRhJDEgKGZyb20sIGdyb3VwLCBzY29wZSkge1xuICBsZXQgZmFjZXQsIGtleSwgb3AsIGRhdGFSZWYsIHBhcmVudDtcblxuICAvLyBpZiBubyBzb3VyY2UgZGF0YSwgZ2VuZXJhdGUgc2luZ2xldG9uIGRhdHVtXG4gIGlmICghZnJvbSkge1xuICAgIGRhdGFSZWYgPSByZWYoc2NvcGUuYWRkKENvbGxlY3QobnVsbCwgW3t9XSkpKTtcbiAgfVxuXG4gIC8vIGlmIGZhY2V0ZWQsIHByb2Nlc3MgZmFjZXQgc3BlY2lmaWNhdGlvblxuICBlbHNlIGlmIChmYWNldCA9IGZyb20uZmFjZXQpIHtcbiAgICBpZiAoIWdyb3VwKSBlcnJvcignT25seSBncm91cCBtYXJrcyBjYW4gYmUgZmFjZXRlZC4nKTtcblxuICAgIC8vIHVzZSBwcmUtZmFjZXRlZCBzb3VyY2UgZGF0YSwgaWYgYXZhaWxhYmxlXG4gICAgaWYgKGZhY2V0LmZpZWxkICE9IG51bGwpIHtcbiAgICAgIGRhdGFSZWYgPSBwYXJlbnQgPSBnZXREYXRhUmVmKGZhY2V0LCBzY29wZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGdlbmVyYXRlIGZhY2V0IGFnZ3JlZ2F0ZXMgaWYgbm8gZGlyZWN0IGRhdGEgc3BlY2lmaWNhdGlvblxuICAgICAgaWYgKCFmcm9tLmRhdGEpIHtcbiAgICAgICAgb3AgPSBwYXJzZVRyYW5zZm9ybShleHRlbmQoe1xuICAgICAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgICAgIGdyb3VwYnk6IGFycmF5KGZhY2V0Lmdyb3VwYnkpXG4gICAgICAgIH0sIGZhY2V0LmFnZ3JlZ2F0ZSksIHNjb3BlKTtcbiAgICAgICAgb3AucGFyYW1zLmtleSA9IHNjb3BlLmtleVJlZihmYWNldC5ncm91cGJ5KTtcbiAgICAgICAgb3AucGFyYW1zLnB1bHNlID0gZ2V0RGF0YVJlZihmYWNldCwgc2NvcGUpO1xuICAgICAgICBkYXRhUmVmID0gcGFyZW50ID0gcmVmKHNjb3BlLmFkZChvcCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyZW50ID0gcmVmKHNjb3BlLmdldERhdGEoZnJvbS5kYXRhKS5hZ2dyZWdhdGUpO1xuICAgICAgfVxuICAgICAga2V5ID0gc2NvcGUua2V5UmVmKGZhY2V0Lmdyb3VwYnksIHRydWUpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIG5vdCB5ZXQgZGVmaW5lZCwgZ2V0IHNvdXJjZSBkYXRhIHJlZmVyZW5jZVxuICBpZiAoIWRhdGFSZWYpIHtcbiAgICBkYXRhUmVmID0gZ2V0RGF0YVJlZihmcm9tLCBzY29wZSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGtleSxcbiAgICBwdWxzZTogZGF0YVJlZixcbiAgICBwYXJlbnQ6IHBhcmVudFxuICB9O1xufVxuZnVuY3Rpb24gZ2V0RGF0YVJlZihmcm9tLCBzY29wZSkge1xuICByZXR1cm4gZnJvbS4kcmVmID8gZnJvbSA6IGZyb20uZGF0YSAmJiBmcm9tLmRhdGEuJHJlZiA/IGZyb20uZGF0YSA6IHJlZihzY29wZS5nZXREYXRhKGZyb20uZGF0YSkub3V0cHV0KTtcbn1cblxuZnVuY3Rpb24gRGF0YVNjb3BlKHNjb3BlLCBpbnB1dCwgb3V0cHV0LCB2YWx1ZXMsIGFnZ3IpIHtcbiAgdGhpcy5zY29wZSA9IHNjb3BlOyAvLyBwYXJlbnQgc2NvcGUgb2JqZWN0XG4gIHRoaXMuaW5wdXQgPSBpbnB1dDsgLy8gZmlyc3Qgb3BlcmF0b3IgaW4gcGlwZWxpbmUgKHR1cGxlIGlucHV0KVxuICB0aGlzLm91dHB1dCA9IG91dHB1dDsgLy8gbGFzdCBvcGVyYXRvciBpbiBwaXBlbGluZSAodHVwbGUgb3V0cHV0KVxuICB0aGlzLnZhbHVlcyA9IHZhbHVlczsgLy8gb3BlcmF0b3IgZm9yIGFjY2Vzc2luZyB0dXBsZXMgKGJ1dCBub3QgdHVwbGUgZmxvdylcblxuICAvLyBsYXN0IGFnZ3JlZ2F0ZSBpbiB0cmFuc2Zvcm0gcGlwZWxpbmVcbiAgdGhpcy5hZ2dyZWdhdGUgPSBhZ2dyO1xuXG4gIC8vIGxvb2t1cCB0YWJsZSBvZiBmaWVsZCBpbmRpY2VzXG4gIHRoaXMuaW5kZXggPSB7fTtcbn1cbkRhdGFTY29wZS5mcm9tRW50cmllcyA9IGZ1bmN0aW9uIChzY29wZSwgZW50cmllcykge1xuICBjb25zdCBuID0gZW50cmllcy5sZW5ndGgsXG4gICAgdmFsdWVzID0gZW50cmllc1tuIC0gMV0sXG4gICAgb3V0cHV0ID0gZW50cmllc1tuIC0gMl07XG4gIGxldCBpbnB1dCA9IGVudHJpZXNbMF0sXG4gICAgYWdnciA9IG51bGwsXG4gICAgaSA9IDE7XG4gIGlmIChpbnB1dCAmJiBpbnB1dC50eXBlID09PSAnbG9hZCcpIHtcbiAgICBpbnB1dCA9IGVudHJpZXNbMV07XG4gIH1cblxuICAvLyBhZGQgb3BlcmF0b3IgZW50cmllcyB0byB0aGlzIHNjb3BlLCB3aXJlIHVwIHB1bHNlIGNoYWluXG4gIHNjb3BlLmFkZChlbnRyaWVzWzBdKTtcbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBlbnRyaWVzW2ldLnBhcmFtcy5wdWxzZSA9IHJlZihlbnRyaWVzW2kgLSAxXSk7XG4gICAgc2NvcGUuYWRkKGVudHJpZXNbaV0pO1xuICAgIGlmIChlbnRyaWVzW2ldLnR5cGUgPT09ICdhZ2dyZWdhdGUnKSBhZ2dyID0gZW50cmllc1tpXTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGFTY29wZShzY29wZSwgaW5wdXQsIG91dHB1dCwgdmFsdWVzLCBhZ2dyKTtcbn07XG5mdW5jdGlvbiBmaWVsZEtleShmaWVsZCkge1xuICByZXR1cm4gaXNTdHJpbmcoZmllbGQpID8gZmllbGQgOiBudWxsO1xufVxuZnVuY3Rpb24gYWRkU29ydEZpZWxkKHNjb3BlLCBwLCBzb3J0KSB7XG4gIGNvbnN0IGFzID0gYWdnckZpZWxkKHNvcnQub3AsIHNvcnQuZmllbGQpO1xuICBsZXQgcztcbiAgaWYgKHAub3BzKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBwLmFzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKHAuYXNbaV0gPT09IGFzKSByZXR1cm47XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAub3BzID0gWydjb3VudCddO1xuICAgIHAuZmllbGRzID0gW251bGxdO1xuICAgIHAuYXMgPSBbJ2NvdW50J107XG4gIH1cbiAgaWYgKHNvcnQub3ApIHtcbiAgICBwLm9wcy5wdXNoKChzID0gc29ydC5vcC5zaWduYWwpID8gc2NvcGUuc2lnbmFsUmVmKHMpIDogc29ydC5vcCk7XG4gICAgcC5maWVsZHMucHVzaChzY29wZS5maWVsZFJlZihzb3J0LmZpZWxkKSk7XG4gICAgcC5hcy5wdXNoKGFzKTtcbiAgfVxufVxuZnVuY3Rpb24gY2FjaGUoc2NvcGUsIGRzLCBuYW1lLCBvcHR5cGUsIGZpZWxkLCBjb3VudHMsIGluZGV4KSB7XG4gIGNvbnN0IGNhY2hlID0gZHNbbmFtZV0gfHwgKGRzW25hbWVdID0ge30pLFxuICAgIHNvcnQgPSBzb3J0S2V5KGNvdW50cyk7XG4gIGxldCBrID0gZmllbGRLZXkoZmllbGQpLFxuICAgIHYsXG4gICAgb3A7XG4gIGlmIChrICE9IG51bGwpIHtcbiAgICBzY29wZSA9IGRzLnNjb3BlO1xuICAgIGsgPSBrICsgKHNvcnQgPyAnfCcgKyBzb3J0IDogJycpO1xuICAgIHYgPSBjYWNoZVtrXTtcbiAgfVxuICBpZiAoIXYpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBjb3VudHMgPyB7XG4gICAgICBmaWVsZDoga2V5RmllbGRSZWYsXG4gICAgICBwdWxzZTogZHMuY291bnRzUmVmKHNjb3BlLCBmaWVsZCwgY291bnRzKVxuICAgIH0gOiB7XG4gICAgICBmaWVsZDogc2NvcGUuZmllbGRSZWYoZmllbGQpLFxuICAgICAgcHVsc2U6IHJlZihkcy5vdXRwdXQpXG4gICAgfTtcbiAgICBpZiAoc29ydCkgcGFyYW1zLnNvcnQgPSBzY29wZS5zb3J0UmVmKGNvdW50cyk7XG4gICAgb3AgPSBzY29wZS5hZGQoZW50cnkob3B0eXBlLCB1bmRlZmluZWQsIHBhcmFtcykpO1xuICAgIGlmIChpbmRleCkgZHMuaW5kZXhbZmllbGRdID0gb3A7XG4gICAgdiA9IHJlZihvcCk7XG4gICAgaWYgKGsgIT0gbnVsbCkgY2FjaGVba10gPSB2O1xuICB9XG4gIHJldHVybiB2O1xufVxuRGF0YVNjb3BlLnByb3RvdHlwZSA9IHtcbiAgY291bnRzUmVmKHNjb3BlLCBmaWVsZCwgc29ydCkge1xuICAgIGNvbnN0IGRzID0gdGhpcyxcbiAgICAgIGNhY2hlID0gZHMuY291bnRzIHx8IChkcy5jb3VudHMgPSB7fSksXG4gICAgICBrID0gZmllbGRLZXkoZmllbGQpO1xuICAgIGxldCB2LCBhLCBwO1xuICAgIGlmIChrICE9IG51bGwpIHtcbiAgICAgIHNjb3BlID0gZHMuc2NvcGU7XG4gICAgICB2ID0gY2FjaGVba107XG4gICAgfVxuICAgIGlmICghdikge1xuICAgICAgcCA9IHtcbiAgICAgICAgZ3JvdXBieTogc2NvcGUuZmllbGRSZWYoZmllbGQsICdrZXknKSxcbiAgICAgICAgcHVsc2U6IHJlZihkcy5vdXRwdXQpXG4gICAgICB9O1xuICAgICAgaWYgKHNvcnQgJiYgc29ydC5maWVsZCkgYWRkU29ydEZpZWxkKHNjb3BlLCBwLCBzb3J0KTtcbiAgICAgIGEgPSBzY29wZS5hZGQoQWdncmVnYXRlKHApKTtcbiAgICAgIHYgPSBzY29wZS5hZGQoQ29sbGVjdCh7XG4gICAgICAgIHB1bHNlOiByZWYoYSlcbiAgICAgIH0pKTtcbiAgICAgIHYgPSB7XG4gICAgICAgIGFnZzogYSxcbiAgICAgICAgcmVmOiByZWYodilcbiAgICAgIH07XG4gICAgICBpZiAoayAhPSBudWxsKSBjYWNoZVtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChzb3J0ICYmIHNvcnQuZmllbGQpIHtcbiAgICAgIGFkZFNvcnRGaWVsZChzY29wZSwgdi5hZ2cucGFyYW1zLCBzb3J0KTtcbiAgICB9XG4gICAgcmV0dXJuIHYucmVmO1xuICB9LFxuICB0dXBsZXNSZWYoKSB7XG4gICAgcmV0dXJuIHJlZih0aGlzLnZhbHVlcyk7XG4gIH0sXG4gIGV4dGVudFJlZihzY29wZSwgZmllbGQpIHtcbiAgICByZXR1cm4gY2FjaGUoc2NvcGUsIHRoaXMsICdleHRlbnQnLCAnZXh0ZW50JywgZmllbGQsIGZhbHNlKTtcbiAgfSxcbiAgZG9tYWluUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2RvbWFpbicsICd2YWx1ZXMnLCBmaWVsZCwgZmFsc2UpO1xuICB9LFxuICB2YWx1ZXNSZWYoc2NvcGUsIGZpZWxkLCBzb3J0KSB7XG4gICAgcmV0dXJuIGNhY2hlKHNjb3BlLCB0aGlzLCAndmFscycsICd2YWx1ZXMnLCBmaWVsZCwgc29ydCB8fCB0cnVlKTtcbiAgfSxcbiAgbG9va3VwUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2xvb2t1cCcsICd0dXBsZWluZGV4JywgZmllbGQsIGZhbHNlKTtcbiAgfSxcbiAgaW5kYXRhUmVmKHNjb3BlLCBmaWVsZCkge1xuICAgIHJldHVybiBjYWNoZShzY29wZSwgdGhpcywgJ2luZGF0YScsICd0dXBsZWluZGV4JywgZmllbGQsIHRydWUsIHRydWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZUZhY2V0IChzcGVjLCBzY29wZSwgZ3JvdXApIHtcbiAgY29uc3QgZmFjZXQgPSBzcGVjLmZyb20uZmFjZXQsXG4gICAgbmFtZSA9IGZhY2V0Lm5hbWUsXG4gICAgZGF0YSA9IGdldERhdGFSZWYoZmFjZXQsIHNjb3BlKTtcbiAgbGV0IG9wO1xuICBpZiAoIWZhY2V0Lm5hbWUpIHtcbiAgICBlcnJvcignRmFjZXQgbXVzdCBoYXZlIGEgbmFtZTogJyArIHN0cmluZ1ZhbHVlKGZhY2V0KSk7XG4gIH1cbiAgaWYgKCFmYWNldC5kYXRhKSB7XG4gICAgZXJyb3IoJ0ZhY2V0IG11c3QgcmVmZXJlbmNlIGEgZGF0YSBzZXQ6ICcgKyBzdHJpbmdWYWx1ZShmYWNldCkpO1xuICB9XG4gIGlmIChmYWNldC5maWVsZCkge1xuICAgIG9wID0gc2NvcGUuYWRkKFByZUZhY2V0KHtcbiAgICAgIGZpZWxkOiBzY29wZS5maWVsZFJlZihmYWNldC5maWVsZCksXG4gICAgICBwdWxzZTogZGF0YVxuICAgIH0pKTtcbiAgfSBlbHNlIGlmIChmYWNldC5ncm91cGJ5KSB7XG4gICAgb3AgPSBzY29wZS5hZGQoRmFjZXQoe1xuICAgICAga2V5OiBzY29wZS5rZXlSZWYoZmFjZXQuZ3JvdXBieSksXG4gICAgICBncm91cDogcmVmKHNjb3BlLnByb3h5KGdyb3VwLnBhcmVudCkpLFxuICAgICAgcHVsc2U6IGRhdGFcbiAgICB9KSk7XG4gIH0gZWxzZSB7XG4gICAgZXJyb3IoJ0ZhY2V0IG11c3Qgc3BlY2lmeSBncm91cGJ5IG9yIGZpZWxkOiAnICsgc3RyaW5nVmFsdWUoZmFjZXQpKTtcbiAgfVxuXG4gIC8vIGluaXRpYWxpemUgZmFjZXQgc3Vic2NvcGVcbiAgY29uc3Qgc3Vic2NvcGUgPSBzY29wZS5mb3JrKCksXG4gICAgc291cmNlID0gc3Vic2NvcGUuYWRkKENvbGxlY3QoKSksXG4gICAgdmFsdWVzID0gc3Vic2NvcGUuYWRkKFNpZXZlKHtcbiAgICAgIHB1bHNlOiByZWYoc291cmNlKVxuICAgIH0pKTtcbiAgc3Vic2NvcGUuYWRkRGF0YShuYW1lLCBuZXcgRGF0YVNjb3BlKHN1YnNjb3BlLCBzb3VyY2UsIHNvdXJjZSwgdmFsdWVzKSk7XG4gIHN1YnNjb3BlLmFkZFNpZ25hbCgncGFyZW50JywgbnVsbCk7XG5cbiAgLy8gcGFyc2UgZmFjZXRlZCBzdWJmbG93XG4gIG9wLnBhcmFtcy5zdWJmbG93ID0ge1xuICAgICRzdWJmbG93OiBzdWJzY29wZS5wYXJzZShzcGVjKS50b1J1bnRpbWUoKVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVN1YmZsb3cgKHNwZWMsIHNjb3BlLCBpbnB1dCkge1xuICBjb25zdCBvcCA9IHNjb3BlLmFkZChQcmVGYWNldCh7XG4gICAgICBwdWxzZTogaW5wdXQucHVsc2VcbiAgICB9KSksXG4gICAgc3Vic2NvcGUgPSBzY29wZS5mb3JrKCk7XG4gIHN1YnNjb3BlLmFkZChTaWV2ZSgpKTtcbiAgc3Vic2NvcGUuYWRkU2lnbmFsKCdwYXJlbnQnLCBudWxsKTtcblxuICAvLyBwYXJzZSBncm91cCBtYXJrIHN1YmZsb3dcbiAgb3AucGFyYW1zLnN1YmZsb3cgPSB7XG4gICAgJHN1YmZsb3c6IHN1YnNjb3BlLnBhcnNlKHNwZWMpLnRvUnVudGltZSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlVHJpZ2dlciAoc3BlYywgc2NvcGUsIG5hbWUpIHtcbiAgY29uc3QgcmVtb3ZlID0gc3BlYy5yZW1vdmUsXG4gICAgaW5zZXJ0ID0gc3BlYy5pbnNlcnQsXG4gICAgdG9nZ2xlID0gc3BlYy50b2dnbGUsXG4gICAgbW9kaWZ5ID0gc3BlYy5tb2RpZnksXG4gICAgdmFsdWVzID0gc3BlYy52YWx1ZXMsXG4gICAgb3AgPSBzY29wZS5hZGQob3BlcmF0b3IoKSk7XG4gIGNvbnN0IHVwZGF0ZSA9ICdpZignICsgc3BlYy50cmlnZ2VyICsgJyxtb2RpZnkoXCInICsgbmFtZSArICdcIiwnICsgW2luc2VydCwgcmVtb3ZlLCB0b2dnbGUsIG1vZGlmeSwgdmFsdWVzXS5tYXAoXyA9PiBfID09IG51bGwgPyAnbnVsbCcgOiBfKS5qb2luKCcsJykgKyAnKSwwKSc7XG4gIGNvbnN0IGV4cHIgPSBwYXJzZUV4cHJlc3Npb24odXBkYXRlLCBzY29wZSk7XG4gIG9wLnVwZGF0ZSA9IGV4cHIuJGV4cHI7XG4gIG9wLnBhcmFtcyA9IGV4cHIuJHBhcmFtcztcbn1cblxuZnVuY3Rpb24gcGFyc2VNYXJrIChzcGVjLCBzY29wZSkge1xuICBjb25zdCByb2xlID0gZ2V0Um9sZShzcGVjKSxcbiAgICBncm91cCA9IHNwZWMudHlwZSA9PT0gR3JvdXBNYXJrLFxuICAgIGZhY2V0ID0gc3BlYy5mcm9tICYmIHNwZWMuZnJvbS5mYWNldCxcbiAgICBvdmVybGFwID0gc3BlYy5vdmVybGFwO1xuICBsZXQgbGF5b3V0ID0gc3BlYy5sYXlvdXQgfHwgcm9sZSA9PT0gU2NvcGVSb2xlIHx8IHJvbGUgPT09IEZyYW1lUm9sZSxcbiAgICBvcHMsXG4gICAgb3AsXG4gICAgc3RvcmUsXG4gICAgZW5jLFxuICAgIG5hbWUsXG4gICAgbGF5b3V0UmVmLFxuICAgIGJvdW5kUmVmO1xuICBjb25zdCBuZXN0ZWQgPSByb2xlID09PSBNYXJrUm9sZSB8fCBsYXlvdXQgfHwgZmFjZXQ7XG5cbiAgLy8gcmVzb2x2ZSBpbnB1dCBkYXRhXG4gIGNvbnN0IGlucHV0ID0gcGFyc2VEYXRhJDEoc3BlYy5mcm9tLCBncm91cCwgc2NvcGUpO1xuXG4gIC8vIGRhdGEgam9pbiB0byBtYXAgdHVwbGVzIHRvIHZpc3VhbCBpdGVtc1xuICBvcCA9IHNjb3BlLmFkZChEYXRhSm9pbih7XG4gICAga2V5OiBpbnB1dC5rZXkgfHwgKHNwZWMua2V5ID8gZmllbGRSZWYkMShzcGVjLmtleSkgOiB1bmRlZmluZWQpLFxuICAgIHB1bHNlOiBpbnB1dC5wdWxzZSxcbiAgICBjbGVhbjogIWdyb3VwXG4gIH0pKTtcbiAgY29uc3Qgam9pblJlZiA9IHJlZihvcCk7XG5cbiAgLy8gY29sbGVjdCB2aXN1YWwgaXRlbXNcbiAgb3AgPSBzdG9yZSA9IHNjb3BlLmFkZChDb2xsZWN0KHtcbiAgICBwdWxzZTogam9pblJlZlxuICB9KSk7XG5cbiAgLy8gY29ubmVjdCB2aXN1YWwgaXRlbXMgdG8gc2NlbmVncmFwaFxuICBvcCA9IHNjb3BlLmFkZChNYXJrKHtcbiAgICBtYXJrZGVmOiBkZWZpbml0aW9uKHNwZWMpLFxuICAgIGludGVyYWN0aXZlOiBpbnRlcmFjdGl2ZShzcGVjLmludGVyYWN0aXZlLCBzY29wZSksXG4gICAgY2xpcDogY2xpcChzcGVjLmNsaXAsIHNjb3BlKSxcbiAgICBjb250ZXh0OiB7XG4gICAgICAkY29udGV4dDogdHJ1ZVxuICAgIH0sXG4gICAgZ3JvdXBzOiBzY29wZS5sb29rdXAoKSxcbiAgICBwYXJlbnQ6IHNjb3BlLnNpZ25hbHMucGFyZW50ID8gc2NvcGUuc2lnbmFsUmVmKCdwYXJlbnQnKSA6IG51bGwsXG4gICAgaW5kZXg6IHNjb3BlLm1hcmtwYXRoKCksXG4gICAgcHVsc2U6IHJlZihvcClcbiAgfSkpO1xuICBjb25zdCBtYXJrUmVmID0gcmVmKG9wKTtcblxuICAvLyBhZGQgdmlzdWFsIGVuY29kZXJzXG4gIG9wID0gZW5jID0gc2NvcGUuYWRkKEVuY29kZShwYXJzZUVuY29kZShzcGVjLmVuY29kZSwgc3BlYy50eXBlLCByb2xlLCBzcGVjLnN0eWxlLCBzY29wZSwge1xuICAgIG1vZDogZmFsc2UsXG4gICAgcHVsc2U6IG1hcmtSZWZcbiAgfSkpKTtcblxuICAvLyBtb25pdG9yIHBhcmVudCBtYXJrcyB0byBwcm9wYWdhdGUgY2hhbmdlc1xuICBvcC5wYXJhbXMucGFyZW50ID0gc2NvcGUuZW5jb2RlKCk7XG5cbiAgLy8gYWRkIHBvc3QtZW5jb2RpbmcgdHJhbnNmb3JtcywgaWYgZGVmaW5lZFxuICBpZiAoc3BlYy50cmFuc2Zvcm0pIHtcbiAgICBzcGVjLnRyYW5zZm9ybS5mb3JFYWNoKF8gPT4ge1xuICAgICAgY29uc3QgdHggPSBwYXJzZVRyYW5zZm9ybShfLCBzY29wZSksXG4gICAgICAgIG1kID0gdHgubWV0YWRhdGE7XG4gICAgICBpZiAobWQuZ2VuZXJhdGVzIHx8IG1kLmNoYW5nZXMpIHtcbiAgICAgICAgZXJyb3IoJ01hcmsgdHJhbnNmb3JtcyBzaG91bGQgbm90IGdlbmVyYXRlIG5ldyBkYXRhLicpO1xuICAgICAgfVxuICAgICAgaWYgKCFtZC5ub21vZCkgZW5jLnBhcmFtcy5tb2QgPSB0cnVlOyAvLyB1cGRhdGUgZW5jb2RlIG1vZCBoYW5kbGluZ1xuICAgICAgdHgucGFyYW1zLnB1bHNlID0gcmVmKG9wKTtcbiAgICAgIHNjb3BlLmFkZChvcCA9IHR4KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIGlmIGl0ZW0gc29ydCBzcGVjaWZpZWQsIHBlcmZvcm0gcG9zdC1lbmNvZGluZ1xuICBpZiAoc3BlYy5zb3J0KSB7XG4gICAgb3AgPSBzY29wZS5hZGQoU29ydEl0ZW1zKHtcbiAgICAgIHNvcnQ6IHNjb3BlLmNvbXBhcmVSZWYoc3BlYy5zb3J0KSxcbiAgICAgIHB1bHNlOiByZWYob3ApXG4gICAgfSkpO1xuICB9XG4gIGNvbnN0IGVuY29kZVJlZiA9IHJlZihvcCk7XG5cbiAgLy8gYWRkIHZpZXcgbGF5b3V0IG9wZXJhdG9yIGlmIG5lZWRlZFxuICBpZiAoZmFjZXQgfHwgbGF5b3V0KSB7XG4gICAgbGF5b3V0ID0gc2NvcGUuYWRkKFZpZXdMYXlvdXQoe1xuICAgICAgbGF5b3V0OiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLmxheW91dCksXG4gICAgICBsZWdlbmRzOiBzY29wZS5sZWdlbmRzLFxuICAgICAgbWFyazogbWFya1JlZixcbiAgICAgIHB1bHNlOiBlbmNvZGVSZWZcbiAgICB9KSk7XG4gICAgbGF5b3V0UmVmID0gcmVmKGxheW91dCk7XG4gIH1cblxuICAvLyBjb21wdXRlIGJvdW5kaW5nIGJveGVzXG4gIGNvbnN0IGJvdW5kID0gc2NvcGUuYWRkKEJvdW5kKHtcbiAgICBtYXJrOiBtYXJrUmVmLFxuICAgIHB1bHNlOiBsYXlvdXRSZWYgfHwgZW5jb2RlUmVmXG4gIH0pKTtcbiAgYm91bmRSZWYgPSByZWYoYm91bmQpO1xuXG4gIC8vIGlmIGdyb3VwIG1hcmssIHJlY3Vyc2UgdG8gcGFyc2UgbmVzdGVkIGNvbnRlbnRcbiAgaWYgKGdyb3VwKSB7XG4gICAgLy8ganVnZ2xlIGxheW91dCAmIGJvdW5kcyB0byBlbnN1cmUgdGhleSBydW4gKmFmdGVyKiBhbnkgZmFjZXRpbmcgdHJhbnNmb3Jtc1xuICAgIGlmIChuZXN0ZWQpIHtcbiAgICAgIG9wcyA9IHNjb3BlLm9wZXJhdG9ycztcbiAgICAgIG9wcy5wb3AoKTtcbiAgICAgIGlmIChsYXlvdXQpIG9wcy5wb3AoKTtcbiAgICB9XG4gICAgc2NvcGUucHVzaFN0YXRlKGVuY29kZVJlZiwgbGF5b3V0UmVmIHx8IGJvdW5kUmVmLCBqb2luUmVmKTtcbiAgICBmYWNldCA/IHBhcnNlRmFjZXQoc3BlYywgc2NvcGUsIGlucHV0KSAvLyBleHBsaWNpdCBmYWNldFxuICAgIDogbmVzdGVkID8gcGFyc2VTdWJmbG93KHNwZWMsIHNjb3BlLCBpbnB1dCkgLy8gc3RhbmRhcmQgbWFyayBncm91cFxuICAgIDogc2NvcGUucGFyc2Uoc3BlYyk7IC8vIGd1aWRlIGdyb3VwLCB3ZSBjYW4gYXZvaWQgbmVzdGVkIHNjb3Blc1xuICAgIHNjb3BlLnBvcFN0YXRlKCk7XG4gICAgaWYgKG5lc3RlZCkge1xuICAgICAgaWYgKGxheW91dCkgb3BzLnB1c2gobGF5b3V0KTtcbiAgICAgIG9wcy5wdXNoKGJvdW5kKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiByZXF1ZXN0ZWQsIGFkZCBvdmVybGFwIHJlbW92YWwgdHJhbnNmb3JtXG4gIGlmIChvdmVybGFwKSB7XG4gICAgYm91bmRSZWYgPSBwYXJzZU92ZXJsYXAob3ZlcmxhcCwgYm91bmRSZWYsIHNjb3BlKTtcbiAgfVxuXG4gIC8vIHJlbmRlciAvIHNpZXZlIGl0ZW1zXG4gIGNvbnN0IHJlbmRlciA9IHNjb3BlLmFkZChSZW5kZXIoe1xuICAgICAgcHVsc2U6IGJvdW5kUmVmXG4gICAgfSkpLFxuICAgIHNpZXZlID0gc2NvcGUuYWRkKFNpZXZlKHtcbiAgICAgIHB1bHNlOiByZWYocmVuZGVyKVxuICAgIH0sIHVuZGVmaW5lZCwgc2NvcGUucGFyZW50KCkpKTtcblxuICAvLyBpZiBtYXJrIGlzIG5hbWVkLCBtYWtlIGFjY2Vzc2libGUgYXMgcmVhY3RpdmUgZ2VvbWV0cnlcbiAgLy8gYWRkIHRyaWdnZXIgdXBkYXRlcyBpZiBkZWZpbmVkXG4gIGlmIChzcGVjLm5hbWUgIT0gbnVsbCkge1xuICAgIG5hbWUgPSBzcGVjLm5hbWU7XG4gICAgc2NvcGUuYWRkRGF0YShuYW1lLCBuZXcgRGF0YVNjb3BlKHNjb3BlLCBzdG9yZSwgcmVuZGVyLCBzaWV2ZSkpO1xuICAgIGlmIChzcGVjLm9uKSBzcGVjLm9uLmZvckVhY2gob24gPT4ge1xuICAgICAgaWYgKG9uLmluc2VydCB8fCBvbi5yZW1vdmUgfHwgb24udG9nZ2xlKSB7XG4gICAgICAgIGVycm9yKCdNYXJrcyBvbmx5IHN1cHBvcnQgbW9kaWZ5IHRyaWdnZXJzLicpO1xuICAgICAgfVxuICAgICAgcGFyc2VUcmlnZ2VyKG9uLCBzY29wZSwgbmFtZSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHBhcnNlT3ZlcmxhcChvdmVybGFwLCBzb3VyY2UsIHNjb3BlKSB7XG4gIGNvbnN0IG1ldGhvZCA9IG92ZXJsYXAubWV0aG9kLFxuICAgIGJvdW5kID0gb3ZlcmxhcC5ib3VuZCxcbiAgICBzZXAgPSBvdmVybGFwLnNlcGFyYXRpb247XG4gIGNvbnN0IHBhcmFtcyA9IHtcbiAgICBzZXBhcmF0aW9uOiBpc1NpZ25hbChzZXApID8gc2NvcGUuc2lnbmFsUmVmKHNlcC5zaWduYWwpIDogc2VwLFxuICAgIG1ldGhvZDogaXNTaWduYWwobWV0aG9kKSA/IHNjb3BlLnNpZ25hbFJlZihtZXRob2Quc2lnbmFsKSA6IG1ldGhvZCxcbiAgICBwdWxzZTogc291cmNlXG4gIH07XG4gIGlmIChvdmVybGFwLm9yZGVyKSB7XG4gICAgcGFyYW1zLnNvcnQgPSBzY29wZS5jb21wYXJlUmVmKHtcbiAgICAgIGZpZWxkOiBvdmVybGFwLm9yZGVyXG4gICAgfSk7XG4gIH1cbiAgaWYgKGJvdW5kKSB7XG4gICAgY29uc3QgdG9sID0gYm91bmQudG9sZXJhbmNlO1xuICAgIHBhcmFtcy5ib3VuZFRvbGVyYW5jZSA9IGlzU2lnbmFsKHRvbCkgPyBzY29wZS5zaWduYWxSZWYodG9sLnNpZ25hbCkgOiArdG9sO1xuICAgIHBhcmFtcy5ib3VuZFNjYWxlID0gc2NvcGUuc2NhbGVSZWYoYm91bmQuc2NhbGUpO1xuICAgIHBhcmFtcy5ib3VuZE9yaWVudCA9IGJvdW5kLm9yaWVudDtcbiAgfVxuICByZXR1cm4gcmVmKHNjb3BlLmFkZChPdmVybGFwKHBhcmFtcykpKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VMZWdlbmQgKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IHNjb3BlLmNvbmZpZy5sZWdlbmQsXG4gICAgZW5jb2RlID0gc3BlYy5lbmNvZGUgfHwge30sXG4gICAgXyA9IGxvb2t1cChzcGVjLCBjb25maWcpLFxuICAgIGxlZ2VuZEVuY29kZSA9IGVuY29kZS5sZWdlbmQgfHwge30sXG4gICAgbmFtZSA9IGxlZ2VuZEVuY29kZS5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICBpbnRlcmFjdGl2ZSA9IGxlZ2VuZEVuY29kZS5pbnRlcmFjdGl2ZSxcbiAgICBzdHlsZSA9IGxlZ2VuZEVuY29kZS5zdHlsZSxcbiAgICBzY2FsZXMgPSB7fTtcbiAgbGV0IHNjYWxlID0gMCxcbiAgICBlbnRyeUxheW91dCxcbiAgICBwYXJhbXMsXG4gICAgY2hpbGRyZW47XG5cbiAgLy8gcmVzb2x2ZSBzY2FsZXMgYW5kICdjYW5vbmljYWwnIHNjYWxlIG5hbWVcbiAgTGVnZW5kU2NhbGVzLmZvckVhY2gocyA9PiBzcGVjW3NdID8gKHNjYWxlc1tzXSA9IHNwZWNbc10sIHNjYWxlID0gc2NhbGUgfHwgc3BlY1tzXSkgOiAwKTtcbiAgaWYgKCFzY2FsZSkgZXJyb3IoJ01pc3NpbmcgdmFsaWQgc2NhbGUgZm9yIGxlZ2VuZC4nKTtcblxuICAvLyByZXNvbHZlIGxlZ2VuZCB0eXBlIChzeW1ib2wsIGdyYWRpZW50LCBvciBkaXNjcmV0ZSBncmFkaWVudClcbiAgY29uc3QgdHlwZSA9IGxlZ2VuZFR5cGUoc3BlYywgc2NvcGUuc2NhbGVUeXBlKHNjYWxlKSk7XG5cbiAgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGxlZ2VuZCBncm91cFxuICBjb25zdCBkYXR1bSA9IHtcbiAgICB0aXRsZTogc3BlYy50aXRsZSAhPSBudWxsLFxuICAgIHNjYWxlczogc2NhbGVzLFxuICAgIHR5cGU6IHR5cGUsXG4gICAgdmdyYWQ6IHR5cGUgIT09ICdzeW1ib2wnICYmIF8uaXNWZXJ0aWNhbCgpXG4gIH07XG4gIGNvbnN0IGRhdGFSZWYgPSByZWYoc2NvcGUuYWRkKENvbGxlY3QobnVsbCwgW2RhdHVtXSkpKTtcblxuICAvLyBlbmNvZGluZyBwcm9wZXJ0aWVzIGZvciBsZWdlbmQgZW50cnkgc3ViLWdyb3VwXG4gIGNvbnN0IGVudHJ5RW5jb2RlID0ge1xuICAgIGVudGVyOiB7XG4gICAgICB4OiB7XG4gICAgICAgIHZhbHVlOiAwXG4gICAgICB9LFxuICAgICAgeToge1xuICAgICAgICB2YWx1ZTogMFxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvLyBkYXRhIHNvdXJjZSBmb3IgbGVnZW5kIHZhbHVlc1xuICBjb25zdCBlbnRyeVJlZiA9IHJlZihzY29wZS5hZGQoTGVnZW5kRW50cmllcyhwYXJhbXMgPSB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzY2FsZTogc2NvcGUuc2NhbGVSZWYoc2NhbGUpLFxuICAgIGNvdW50OiBzY29wZS5vYmplY3RQcm9wZXJ0eShfKCd0aWNrQ291bnQnKSksXG4gICAgbGltaXQ6IHNjb3BlLnByb3BlcnR5KF8oJ3N5bWJvbExpbWl0JykpLFxuICAgIHZhbHVlczogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy52YWx1ZXMpLFxuICAgIG1pbnN0ZXA6IHNjb3BlLnByb3BlcnR5KHNwZWMudGlja01pblN0ZXApLFxuICAgIGZvcm1hdFR5cGU6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0VHlwZSksXG4gICAgZm9ybWF0U3BlY2lmaWVyOiBzY29wZS5wcm9wZXJ0eShzcGVjLmZvcm1hdClcbiAgfSkpKTtcblxuICAvLyBjb250aW51b3VzIGdyYWRpZW50IGxlZ2VuZFxuICBpZiAodHlwZSA9PT0gR3JhZGllbnQpIHtcbiAgICBjaGlsZHJlbiA9IFtsZWdlbmRHcmFkaWVudChzcGVjLCBzY2FsZSwgY29uZmlnLCBlbmNvZGUuZ3JhZGllbnQpLCBsZWdlbmRHcmFkaWVudExhYmVscyhzcGVjLCBjb25maWcsIGVuY29kZS5sYWJlbHMsIGVudHJ5UmVmKV07XG4gICAgLy8gYWRqdXN0IGRlZmF1bHQgdGljayBjb3VudCBiYXNlZCBvbiB0aGUgZ3JhZGllbnQgbGVuZ3RoXG4gICAgcGFyYW1zLmNvdW50ID0gcGFyYW1zLmNvdW50IHx8IHNjb3BlLnNpZ25hbFJlZihgbWF4KDIsMipmbG9vcigoJHtkZXJlZihfLmdyYWRpZW50TGVuZ3RoKCkpfSkvMTAwKSlgKTtcbiAgfVxuXG4gIC8vIGRpc2NyZXRlIGdyYWRpZW50IGxlZ2VuZFxuICBlbHNlIGlmICh0eXBlID09PSBEaXNjcmV0ZSkge1xuICAgIGNoaWxkcmVuID0gW2xlZ2VuZEdyYWRpZW50RGlzY3JldGUoc3BlYywgc2NhbGUsIGNvbmZpZywgZW5jb2RlLmdyYWRpZW50LCBlbnRyeVJlZiksIGxlZ2VuZEdyYWRpZW50TGFiZWxzKHNwZWMsIGNvbmZpZywgZW5jb2RlLmxhYmVscywgZW50cnlSZWYpXTtcbiAgfVxuXG4gIC8vIHN5bWJvbCBsZWdlbmRcbiAgZWxzZSB7XG4gICAgLy8gZGV0ZXJtaW5lIGxlZ2VuZCBzeW1ib2wgZ3JvdXAgbGF5b3V0XG4gICAgZW50cnlMYXlvdXQgPSBsZWdlbmRTeW1ib2xMYXlvdXQoc3BlYywgY29uZmlnKTtcbiAgICBjaGlsZHJlbiA9IFtsZWdlbmRTeW1ib2xHcm91cHMoc3BlYywgY29uZmlnLCBlbmNvZGUsIGVudHJ5UmVmLCBkZXJlZihlbnRyeUxheW91dC5jb2x1bW5zKSldO1xuICAgIC8vIHBhc3Mgc3ltYm9sIHNpemUgaW5mb3JtYXRpb24gdG8gbGVnZW5kIGVudHJ5IGdlbmVyYXRvclxuICAgIHBhcmFtcy5zaXplID0gc2l6ZUV4cHJlc3Npb24oc3BlYywgc2NvcGUsIGNoaWxkcmVuWzBdLm1hcmtzKTtcbiAgfVxuXG4gIC8vIGdlbmVyYXRlIGxlZ2VuZCBtYXJrc1xuICBjaGlsZHJlbiA9IFtndWlkZUdyb3VwKHtcbiAgICByb2xlOiBMZWdlbmRFbnRyeVJvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGVudHJ5RW5jb2RlLFxuICAgIG1hcmtzOiBjaGlsZHJlbixcbiAgICBsYXlvdXQ6IGVudHJ5TGF5b3V0LFxuICAgIGludGVyYWN0aXZlXG4gIH0pXTtcblxuICAvLyBpbmNsdWRlIGxlZ2VuZCB0aXRsZSBpZiBkZWZpbmVkXG4gIGlmIChkYXR1bS50aXRsZSkge1xuICAgIGNoaWxkcmVuLnB1c2gobGVnZW5kVGl0bGUoc3BlYywgY29uZmlnLCBlbmNvZGUudGl0bGUsIGRhdGFSZWYpKTtcbiAgfVxuXG4gIC8vIHBhcnNlIGxlZ2VuZCBzcGVjaWZpY2F0aW9uXG4gIHJldHVybiBwYXJzZU1hcmsoZ3VpZGVHcm91cCh7XG4gICAgcm9sZTogTGVnZW5kUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZXh0ZW5kRW5jb2RlKGJ1aWxkTGVnZW5kRW5jb2RlKF8sIHNwZWMsIGNvbmZpZyksIGxlZ2VuZEVuY29kZSwgU2tpcCksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGxlZ2VuZFR5cGUoc3BlYywgc2NhbGVUeXBlKSB7XG4gIGxldCB0eXBlID0gc3BlYy50eXBlIHx8IFN5bWJvbHM7XG4gIGlmICghc3BlYy50eXBlICYmIHNjYWxlQ291bnQoc3BlYykgPT09IDEgJiYgKHNwZWMuZmlsbCB8fCBzcGVjLnN0cm9rZSkpIHtcbiAgICB0eXBlID0gaXNDb250aW51b3VzKHNjYWxlVHlwZSkgPyBHcmFkaWVudCA6IGlzRGlzY3JldGl6aW5nKHNjYWxlVHlwZSkgPyBEaXNjcmV0ZSA6IFN5bWJvbHM7XG4gIH1cbiAgcmV0dXJuIHR5cGUgIT09IEdyYWRpZW50ID8gdHlwZSA6IGlzRGlzY3JldGl6aW5nKHNjYWxlVHlwZSkgPyBEaXNjcmV0ZSA6IEdyYWRpZW50O1xufVxuZnVuY3Rpb24gc2NhbGVDb3VudChzcGVjKSB7XG4gIHJldHVybiBMZWdlbmRTY2FsZXMucmVkdWNlKChjb3VudCwgdHlwZSkgPT4gY291bnQgKyAoc3BlY1t0eXBlXSA/IDEgOiAwKSwgMCk7XG59XG5mdW5jdGlvbiBidWlsZExlZ2VuZEVuY29kZShfLCBzcGVjLCBjb25maWcpIHtcbiAgY29uc3QgZW5jb2RlID0ge1xuICAgIGVudGVyOiB7fSxcbiAgICB1cGRhdGU6IHt9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIG9yaWVudDogXygnb3JpZW50JyksXG4gICAgb2Zmc2V0OiBfKCdvZmZzZXQnKSxcbiAgICBwYWRkaW5nOiBfKCdwYWRkaW5nJyksXG4gICAgdGl0bGVQYWRkaW5nOiBfKCd0aXRsZVBhZGRpbmcnKSxcbiAgICBjb3JuZXJSYWRpdXM6IF8oJ2Nvcm5lclJhZGl1cycpLFxuICAgIGZpbGw6IF8oJ2ZpbGxDb2xvcicpLFxuICAgIHN0cm9rZTogXygnc3Ryb2tlQ29sb3InKSxcbiAgICBzdHJva2VXaWR0aDogY29uZmlnLnN0cm9rZVdpZHRoLFxuICAgIHN0cm9rZURhc2g6IGNvbmZpZy5zdHJva2VEYXNoLFxuICAgIHg6IF8oJ2xlZ2VuZFgnKSxcbiAgICB5OiBfKCdsZWdlbmRZJyksXG4gICAgLy8gYWNjZXNzaWJpbGl0eSBzdXBwb3J0XG4gICAgZm9ybWF0OiBzcGVjLmZvcm1hdCxcbiAgICBmb3JtYXRUeXBlOiBzcGVjLmZvcm1hdFR5cGVcbiAgfSk7XG4gIHJldHVybiBlbmNvZGU7XG59XG5mdW5jdGlvbiBzaXplRXhwcmVzc2lvbihzcGVjLCBzY29wZSwgbWFya3MpIHtcbiAgY29uc3Qgc2l6ZSA9IGRlcmVmKGdldENoYW5uZWwoJ3NpemUnLCBzcGVjLCBtYXJrcykpLFxuICAgIHN0cm9rZVdpZHRoID0gZGVyZWYoZ2V0Q2hhbm5lbCgnc3Ryb2tlV2lkdGgnLCBzcGVjLCBtYXJrcykpLFxuICAgIGZvbnRTaXplID0gZGVyZWYoZ2V0Rm9udFNpemUobWFya3NbMV0uZW5jb2RlLCBzY29wZSwgR3VpZGVMYWJlbFN0eWxlKSk7XG4gIHJldHVybiBwYXJzZUV4cHJlc3Npb24oYG1heChjZWlsKHNxcnQoJHtzaXplfSkrJHtzdHJva2VXaWR0aH0pLCR7Zm9udFNpemV9KWAsIHNjb3BlKTtcbn1cbmZ1bmN0aW9uIGdldENoYW5uZWwobmFtZSwgc3BlYywgbWFya3MpIHtcbiAgcmV0dXJuIHNwZWNbbmFtZV0gPyBgc2NhbGUoXCIke3NwZWNbbmFtZV19XCIsZGF0dW0pYCA6IGdldEVuY29kaW5nKG5hbWUsIG1hcmtzWzBdLmVuY29kZSk7XG59XG5mdW5jdGlvbiBnZXRGb250U2l6ZShlbmNvZGUsIHNjb3BlLCBzdHlsZSkge1xuICByZXR1cm4gZ2V0RW5jb2RpbmcoJ2ZvbnRTaXplJywgZW5jb2RlKSB8fCBnZXRTdHlsZSgnZm9udFNpemUnLCBzY29wZSwgc3R5bGUpO1xufVxuXG5jb25zdCBhbmdsZUV4cHIgPSBgaXRlbS5vcmllbnQ9PT1cIiR7TGVmdH1cIj8tOTA6aXRlbS5vcmllbnQ9PT1cIiR7UmlnaHR9XCI/OTA6MGA7XG5mdW5jdGlvbiBwYXJzZVRpdGxlIChzcGVjLCBzY29wZSkge1xuICBzcGVjID0gaXNTdHJpbmcoc3BlYykgPyB7XG4gICAgdGV4dDogc3BlY1xuICB9IDogc3BlYztcbiAgY29uc3QgXyA9IGxvb2t1cChzcGVjLCBzY29wZS5jb25maWcudGl0bGUpLFxuICAgIGVuY29kZSA9IHNwZWMuZW5jb2RlIHx8IHt9LFxuICAgIHVzZXJFbmNvZGUgPSBlbmNvZGUuZ3JvdXAgfHwge30sXG4gICAgbmFtZSA9IHVzZXJFbmNvZGUubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgaW50ZXJhY3RpdmUgPSB1c2VyRW5jb2RlLmludGVyYWN0aXZlLFxuICAgIHN0eWxlID0gdXNlckVuY29kZS5zdHlsZSxcbiAgICBjaGlsZHJlbiA9IFtdO1xuXG4gIC8vIHNpbmdsZS1lbGVtZW50IGRhdGEgc291cmNlIGZvciBncm91cCB0aXRsZVxuICBjb25zdCBkYXR1bSA9IHt9LFxuICAgIGRhdGFSZWYgPSByZWYoc2NvcGUuYWRkKENvbGxlY3QobnVsbCwgW2RhdHVtXSkpKTtcblxuICAvLyBpbmNsdWRlIHRpdGxlIHRleHRcbiAgY2hpbGRyZW4ucHVzaChidWlsZFRpdGxlKHNwZWMsIF8sIHRpdGxlRW5jb2RlKHNwZWMpLCBkYXRhUmVmKSk7XG5cbiAgLy8gaW5jbHVkZSBzdWJ0aXRsZSB0ZXh0XG4gIGlmIChzcGVjLnN1YnRpdGxlKSB7XG4gICAgY2hpbGRyZW4ucHVzaChidWlsZFN1YlRpdGxlKHNwZWMsIF8sIGVuY29kZS5zdWJ0aXRsZSwgZGF0YVJlZikpO1xuICB9XG5cbiAgLy8gcGFyc2UgdGl0bGUgc3BlY2lmaWNhdGlvblxuICByZXR1cm4gcGFyc2VNYXJrKGd1aWRlR3JvdXAoe1xuICAgIHJvbGU6IFRpdGxlUm9sZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZTogZ3JvdXBFbmNvZGUoXywgdXNlckVuY29kZSksXG4gICAgbWFya3M6IGNoaWxkcmVuLFxuICAgIGFyaWE6IF8oJ2FyaWEnKSxcbiAgICBkZXNjcmlwdGlvbjogXygnZGVzY3JpcHRpb24nKSxcbiAgICB6aW5kZXg6IF8oJ3ppbmRleCcpLFxuICAgIG5hbWUsXG4gICAgaW50ZXJhY3RpdmUsXG4gICAgc3R5bGVcbiAgfSksIHNjb3BlKTtcbn1cblxuLy8gcHJvdmlkZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGl0bGUgY3VzdG9tIGVuY29kZTtcbi8vIHRoZSB0b3AtbGV2ZWwgZW5jb2RlIGJsb2NrIGhhcyBiZWVuICpkZXByZWNhdGVkKi5cbmZ1bmN0aW9uIHRpdGxlRW5jb2RlKHNwZWMpIHtcbiAgY29uc3QgZW5jb2RlID0gc3BlYy5lbmNvZGU7XG4gIHJldHVybiBlbmNvZGUgJiYgZW5jb2RlLnRpdGxlIHx8IGV4dGVuZCh7XG4gICAgbmFtZTogc3BlYy5uYW1lLFxuICAgIGludGVyYWN0aXZlOiBzcGVjLmludGVyYWN0aXZlLFxuICAgIHN0eWxlOiBzcGVjLnN0eWxlXG4gIH0sIGVuY29kZSk7XG59XG5mdW5jdGlvbiBncm91cEVuY29kZShfLCB1c2VyRW5jb2RlKSB7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjoge30sXG4gICAgdXBkYXRlOiB7fVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBvcmllbnQ6IF8oJ29yaWVudCcpLFxuICAgIGFuY2hvcjogXygnYW5jaG9yJyksXG4gICAgYWxpZ246IHtcbiAgICAgIHNpZ25hbDogYWxpZ25FeHByJDFcbiAgICB9LFxuICAgIGFuZ2xlOiB7XG4gICAgICBzaWduYWw6IGFuZ2xlRXhwclxuICAgIH0sXG4gICAgbGltaXQ6IF8oJ2xpbWl0JyksXG4gICAgZnJhbWU6IF8oJ2ZyYW1lJyksXG4gICAgb2Zmc2V0OiBfKCdvZmZzZXQnKSB8fCAwLFxuICAgIHBhZGRpbmc6IF8oJ3N1YnRpdGxlUGFkZGluZycpXG4gIH0pO1xuICByZXR1cm4gZXh0ZW5kRW5jb2RlKGVuY29kZSwgdXNlckVuY29kZSwgU2tpcCk7XG59XG5mdW5jdGlvbiBidWlsZFRpdGxlKHNwZWMsIF8sIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgemVybyA9IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB0ZXh0ID0gc3BlYy50ZXh0LFxuICAgIGVuY29kZSA9IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIG9wYWNpdHk6IHplcm9cbiAgICAgIH0sXG4gICAgICB1cGRhdGU6IHtcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIHZhbHVlOiAxXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBleGl0OiB7XG4gICAgICAgIG9wYWNpdHk6IHplcm9cbiAgICAgIH1cbiAgICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICB0ZXh0OiB0ZXh0LFxuICAgIGFsaWduOiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAuYWxpZ24nXG4gICAgfSxcbiAgICBhbmdsZToge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmFuZ2xlJ1xuICAgIH0sXG4gICAgbGltaXQ6IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5saW1pdCdcbiAgICB9LFxuICAgIGJhc2VsaW5lOiAndG9wJyxcbiAgICBkeDogXygnZHgnKSxcbiAgICBkeTogXygnZHknKSxcbiAgICBmaWxsOiBfKCdjb2xvcicpLFxuICAgIGZvbnQ6IF8oJ2ZvbnQnKSxcbiAgICBmb250U2l6ZTogXygnZm9udFNpemUnKSxcbiAgICBmb250U3R5bGU6IF8oJ2ZvbnRTdHlsZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ2ZvbnRXZWlnaHQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCdsaW5lSGVpZ2h0JylcbiAgfSwge1xuICAgIC8vIHVwZGF0ZVxuICAgIGFsaWduOiBfKCdhbGlnbicpLFxuICAgIGFuZ2xlOiBfKCdhbmdsZScpLFxuICAgIGJhc2VsaW5lOiBfKCdiYXNlbGluZScpXG4gIH0pO1xuICByZXR1cm4gZ3VpZGVNYXJrKHtcbiAgICB0eXBlOiBUZXh0TWFyayxcbiAgICByb2xlOiBUaXRsZVRleHRSb2xlLFxuICAgIHN0eWxlOiBHcm91cFRpdGxlU3R5bGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5mdW5jdGlvbiBidWlsZFN1YlRpdGxlKHNwZWMsIF8sIHVzZXJFbmNvZGUsIGRhdGFSZWYpIHtcbiAgY29uc3QgemVybyA9IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB0ZXh0ID0gc3BlYy5zdWJ0aXRsZSxcbiAgICBlbmNvZGUgPSB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgICB9LFxuICAgICAgdXBkYXRlOiB7XG4gICAgICAgIG9wYWNpdHk6IHtcbiAgICAgICAgICB2YWx1ZTogMVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZXhpdDoge1xuICAgICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgICB9XG4gICAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgdGV4dDogdGV4dCxcbiAgICBhbGlnbjoge1xuICAgICAgc2lnbmFsOiAnaXRlbS5tYXJrLmdyb3VwLmFsaWduJ1xuICAgIH0sXG4gICAgYW5nbGU6IHtcbiAgICAgIHNpZ25hbDogJ2l0ZW0ubWFyay5ncm91cC5hbmdsZSdcbiAgICB9LFxuICAgIGxpbWl0OiB7XG4gICAgICBzaWduYWw6ICdpdGVtLm1hcmsuZ3JvdXAubGltaXQnXG4gICAgfSxcbiAgICBiYXNlbGluZTogJ3RvcCcsXG4gICAgZHg6IF8oJ2R4JyksXG4gICAgZHk6IF8oJ2R5JyksXG4gICAgZmlsbDogXygnc3VidGl0bGVDb2xvcicpLFxuICAgIGZvbnQ6IF8oJ3N1YnRpdGxlRm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCdzdWJ0aXRsZUZvbnRTaXplJyksXG4gICAgZm9udFN0eWxlOiBfKCdzdWJ0aXRsZUZvbnRTdHlsZScpLFxuICAgIGZvbnRXZWlnaHQ6IF8oJ3N1YnRpdGxlRm9udFdlaWdodCcpLFxuICAgIGxpbmVIZWlnaHQ6IF8oJ3N1YnRpdGxlTGluZUhlaWdodCcpXG4gIH0sIHtcbiAgICAvLyB1cGRhdGVcbiAgICBhbGlnbjogXygnYWxpZ24nKSxcbiAgICBhbmdsZTogXygnYW5nbGUnKSxcbiAgICBiYXNlbGluZTogXygnYmFzZWxpbmUnKVxuICB9KTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogVGV4dE1hcmssXG4gICAgcm9sZTogVGl0bGVTdWJ0aXRsZVJvbGUsXG4gICAgc3R5bGU6IEdyb3VwU3VidGl0bGVTdHlsZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRhKGRhdGEsIHNjb3BlKSB7XG4gIGNvbnN0IHRyYW5zZm9ybXMgPSBbXTtcbiAgaWYgKGRhdGEudHJhbnNmb3JtKSB7XG4gICAgZGF0YS50cmFuc2Zvcm0uZm9yRWFjaCh0eCA9PiB7XG4gICAgICB0cmFuc2Zvcm1zLnB1c2gocGFyc2VUcmFuc2Zvcm0odHgsIHNjb3BlKSk7XG4gICAgfSk7XG4gIH1cbiAgaWYgKGRhdGEub24pIHtcbiAgICBkYXRhLm9uLmZvckVhY2gob24gPT4ge1xuICAgICAgcGFyc2VUcmlnZ2VyKG9uLCBzY29wZSwgZGF0YS5uYW1lKTtcbiAgICB9KTtcbiAgfVxuICBzY29wZS5hZGREYXRhUGlwZWxpbmUoZGF0YS5uYW1lLCBhbmFseXplKGRhdGEsIHNjb3BlLCB0cmFuc2Zvcm1zKSk7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBhIGRhdGEgcGlwZWxpbmUsIGFkZCBuZWVkZWQgb3BlcmF0b3JzLlxuICovXG5mdW5jdGlvbiBhbmFseXplKGRhdGEsIHNjb3BlLCBvcHMpIHtcbiAgY29uc3Qgb3V0cHV0ID0gW107XG4gIGxldCBzb3VyY2UgPSBudWxsLFxuICAgIG1vZGlmeSA9IGZhbHNlLFxuICAgIGdlbmVyYXRlID0gZmFsc2UsXG4gICAgdXBzdHJlYW0sXG4gICAgaSxcbiAgICBuLFxuICAgIHQsXG4gICAgbTtcbiAgaWYgKGRhdGEudmFsdWVzKSB7XG4gICAgLy8gaGFyZC13aXJlZCBpbnB1dCBkYXRhIHNldFxuICAgIGlmIChpc1NpZ25hbChkYXRhLnZhbHVlcykgfHwgaGFzU2lnbmFsKGRhdGEuZm9ybWF0KSkge1xuICAgICAgLy8gaWYgZWl0aGVyIHZhbHVlcyBpcyBzaWduYWwgb3IgZm9ybWF0IGhhcyBzaWduYWwsIHVzZSBkeW5hbWljIGxvYWRlclxuICAgICAgb3V0cHV0LnB1c2gobG9hZChzY29wZSwgZGF0YSkpO1xuICAgICAgb3V0cHV0LnB1c2goc291cmNlID0gY29sbGVjdCgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb3RoZXJ3aXNlLCBpbmdlc3QgdXBvbiBkYXRhZmxvdyBpbml0XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KHtcbiAgICAgICAgJGluZ2VzdDogZGF0YS52YWx1ZXMsXG4gICAgICAgICRmb3JtYXQ6IGRhdGEuZm9ybWF0XG4gICAgICB9KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEudXJsKSB7XG4gICAgLy8gbG9hZCBkYXRhIGZyb20gZXh0ZXJuYWwgc291cmNlXG4gICAgaWYgKGhhc1NpZ25hbChkYXRhLnVybCkgfHwgaGFzU2lnbmFsKGRhdGEuZm9ybWF0KSkge1xuICAgICAgLy8gaWYgZWl0aGVyIHVybCBvciBmb3JtYXQgaGFzIHNpZ25hbCwgdXNlIGR5bmFtaWMgbG9hZGVyXG4gICAgICBvdXRwdXQucHVzaChsb2FkKHNjb3BlLCBkYXRhKSk7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBvdGhlcndpc2UsIHJlcXVlc3QgbG9hZCB1cG9uIGRhdGFmbG93IGluaXRcbiAgICAgIG91dHB1dC5wdXNoKHNvdXJjZSA9IGNvbGxlY3Qoe1xuICAgICAgICAkcmVxdWVzdDogZGF0YS51cmwsXG4gICAgICAgICRmb3JtYXQ6IGRhdGEuZm9ybWF0XG4gICAgICB9KSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEuc291cmNlKSB7XG4gICAgLy8gZGVyaXZlcyBmcm9tIG9uZSBvciBtb3JlIG90aGVyIGRhdGEgc2V0c1xuICAgIHNvdXJjZSA9IHVwc3RyZWFtID0gYXJyYXkoZGF0YS5zb3VyY2UpLm1hcChkID0+IHJlZihzY29wZS5nZXREYXRhKGQpLm91dHB1dCkpO1xuICAgIG91dHB1dC5wdXNoKG51bGwpOyAvLyBwb3B1bGF0ZSBsYXRlclxuICB9XG5cbiAgLy8gc2NhbiBkYXRhIHRyYW5zZm9ybXMsIGFkZCBjb2xsZWN0b3JzIGFzIG5lZWRlZFxuICBmb3IgKGkgPSAwLCBuID0gb3BzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHQgPSBvcHNbaV07XG4gICAgbSA9IHQubWV0YWRhdGE7XG4gICAgaWYgKCFzb3VyY2UgJiYgIW0uc291cmNlKSB7XG4gICAgICBvdXRwdXQucHVzaChzb3VyY2UgPSBjb2xsZWN0KCkpO1xuICAgIH1cbiAgICBvdXRwdXQucHVzaCh0KTtcbiAgICBpZiAobS5nZW5lcmF0ZXMpIGdlbmVyYXRlID0gdHJ1ZTtcbiAgICBpZiAobS5tb2RpZmllcyAmJiAhZ2VuZXJhdGUpIG1vZGlmeSA9IHRydWU7XG4gICAgaWYgKG0uc291cmNlKSBzb3VyY2UgPSB0O2Vsc2UgaWYgKG0uY2hhbmdlcykgc291cmNlID0gbnVsbDtcbiAgfVxuICBpZiAodXBzdHJlYW0pIHtcbiAgICBuID0gdXBzdHJlYW0ubGVuZ3RoIC0gMTtcbiAgICBvdXRwdXRbMF0gPSBSZWxheSh7XG4gICAgICBkZXJpdmU6IG1vZGlmeSxcbiAgICAgIHB1bHNlOiBuID8gdXBzdHJlYW0gOiB1cHN0cmVhbVswXVxuICAgIH0pO1xuICAgIGlmIChtb2RpZnkgfHwgbikge1xuICAgICAgLy8gY29sbGVjdCBkZXJpdmVkIGFuZCBtdWx0aS1wdWxzZSB0dXBsZXNcbiAgICAgIG91dHB1dC5zcGxpY2UoMSwgMCwgY29sbGVjdCgpKTtcbiAgICB9XG4gIH1cbiAgaWYgKCFzb3VyY2UpIG91dHB1dC5wdXNoKGNvbGxlY3QoKSk7XG4gIG91dHB1dC5wdXNoKFNpZXZlKHt9KSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBjb2xsZWN0KHZhbHVlcykge1xuICBjb25zdCBzID0gQ29sbGVjdCh7fSwgdmFsdWVzKTtcbiAgcy5tZXRhZGF0YSA9IHtcbiAgICBzb3VyY2U6IHRydWVcbiAgfTtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBsb2FkKHNjb3BlLCBkYXRhKSB7XG4gIHJldHVybiBMb2FkKHtcbiAgICB1cmw6IGRhdGEudXJsID8gc2NvcGUucHJvcGVydHkoZGF0YS51cmwpIDogdW5kZWZpbmVkLFxuICAgIGFzeW5jOiBkYXRhLmFzeW5jID8gc2NvcGUucHJvcGVydHkoZGF0YS5hc3luYykgOiB1bmRlZmluZWQsXG4gICAgdmFsdWVzOiBkYXRhLnZhbHVlcyA/IHNjb3BlLnByb3BlcnR5KGRhdGEudmFsdWVzKSA6IHVuZGVmaW5lZCxcbiAgICBmb3JtYXQ6IHNjb3BlLm9iamVjdFByb3BlcnR5KGRhdGEuZm9ybWF0KVxuICB9KTtcbn1cblxuY29uc3QgaXNYID0gb3JpZW50ID0+IG9yaWVudCA9PT0gQm90dG9tIHx8IG9yaWVudCA9PT0gVG9wO1xuXG4vLyBnZXQgc2lnbiBjb2VmZmljaWVudCBiYXNlZCBvbiBheGlzIG9yaWVudFxuY29uc3QgZ2V0U2lnbiA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZkxlZnRUb3BFeHByKG9yaWVudC5zaWduYWwsIGEsIGIpIDogb3JpZW50ID09PSBMZWZ0IHx8IG9yaWVudCA9PT0gVG9wID8gYSA6IGI7XG5cbi8vIGNvbmRpdGlvbiBvbiBheGlzIHgtZGlyZWN0aW9uXG5jb25zdCBpZlggPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZYRW5jKG9yaWVudC5zaWduYWwsIGEsIGIpIDogaXNYKG9yaWVudCkgPyBhIDogYjtcblxuLy8gY29uZGl0aW9uIG9uIGF4aXMgeS1kaXJlY3Rpb25cbmNvbnN0IGlmWSA9IChvcmllbnQsIGEsIGIpID0+IGlzU2lnbmFsKG9yaWVudCkgPyBpZllFbmMob3JpZW50LnNpZ25hbCwgYSwgYikgOiBpc1gob3JpZW50KSA/IGIgOiBhO1xuY29uc3QgaWZUb3AgPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZUb3BFeHByKG9yaWVudC5zaWduYWwsIGEsIGIpIDogb3JpZW50ID09PSBUb3AgPyB7XG4gIHZhbHVlOiBhXG59IDoge1xuICB2YWx1ZTogYlxufTtcbmNvbnN0IGlmUmlnaHQgPSAob3JpZW50LCBhLCBiKSA9PiBpc1NpZ25hbChvcmllbnQpID8gaWZSaWdodEV4cHIob3JpZW50LnNpZ25hbCwgYSwgYikgOiBvcmllbnQgPT09IFJpZ2h0ID8ge1xuICB2YWx1ZTogYVxufSA6IHtcbiAgdmFsdWU6IGJcbn07XG5jb25zdCBpZlhFbmMgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFbmMoYCR7JG9yaWVudH0gPT09ICcke1RvcH0nIHx8ICR7JG9yaWVudH0gPT09ICcke0JvdHRvbX0nYCwgYSwgYik7XG5jb25zdCBpZllFbmMgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFbmMoYCR7JG9yaWVudH0gIT09ICcke1RvcH0nICYmICR7JG9yaWVudH0gIT09ICcke0JvdHRvbX0nYCwgYSwgYik7XG5jb25zdCBpZkxlZnRUb3BFeHByID0gKCRvcmllbnQsIGEsIGIpID0+IGlmRXhwcihgJHskb3JpZW50fSA9PT0gJyR7TGVmdH0nIHx8ICR7JG9yaWVudH0gPT09ICcke1RvcH0nYCwgYSwgYik7XG5jb25zdCBpZlRvcEV4cHIgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFeHByKGAkeyRvcmllbnR9ID09PSAnJHtUb3B9J2AsIGEsIGIpO1xuY29uc3QgaWZSaWdodEV4cHIgPSAoJG9yaWVudCwgYSwgYikgPT4gaWZFeHByKGAkeyRvcmllbnR9ID09PSAnJHtSaWdodH0nYCwgYSwgYik7XG5jb25zdCBpZkVuYyA9ICh0ZXN0LCBhLCBiKSA9PiB7XG4gIC8vIGVuc3VyZSBpbnB1dHMgYXJlIGVuY29kZXIgb2JqZWN0cyAob3IgbnVsbClcbiAgYSA9IGEgIT0gbnVsbCA/IGVuY29kZXIoYSkgOiBhO1xuICBiID0gYiAhPSBudWxsID8gZW5jb2RlcihiKSA6IGI7XG4gIGlmIChpc1NpbXBsZShhKSAmJiBpc1NpbXBsZShiKSkge1xuICAgIC8vIGlmIHBvc3NpYmxlIGdlbmVyYXRlIHNpbXBsZSBzaWduYWwgZXhwcmVzc2lvblxuICAgIGEgPSBhID8gYS5zaWduYWwgfHwgc3RyaW5nVmFsdWUoYS52YWx1ZSkgOiBudWxsO1xuICAgIGIgPSBiID8gYi5zaWduYWwgfHwgc3RyaW5nVmFsdWUoYi52YWx1ZSkgOiBudWxsO1xuICAgIHJldHVybiB7XG4gICAgICBzaWduYWw6IGAke3Rlc3R9ID8gKCR7YX0pIDogKCR7Yn0pYFxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gb3RoZXJ3aXNlIGdlbmVyYXRlIHJ1bGUgc2V0XG4gICAgcmV0dXJuIFtleHRlbmQoe1xuICAgICAgdGVzdFxuICAgIH0sIGEpXS5jb25jYXQoYiB8fCBbXSk7XG4gIH1cbn07XG5jb25zdCBpc1NpbXBsZSA9IGVuYyA9PiBlbmMgPT0gbnVsbCB8fCBPYmplY3Qua2V5cyhlbmMpLmxlbmd0aCA9PT0gMTtcbmNvbnN0IGlmRXhwciA9ICh0ZXN0LCBhLCBiKSA9PiAoe1xuICBzaWduYWw6IGAke3Rlc3R9ID8gKCR7dG9FeHByKGEpfSkgOiAoJHt0b0V4cHIoYil9KWBcbn0pO1xuY29uc3QgaWZPcmllbnQgPSAoJG9yaWVudCwgdCwgYiwgbCwgcikgPT4gKHtcbiAgc2lnbmFsOiAobCAhPSBudWxsID8gYCR7JG9yaWVudH0gPT09ICcke0xlZnR9JyA/ICgke3RvRXhwcihsKX0pIDogYCA6ICcnKSArIChiICE9IG51bGwgPyBgJHskb3JpZW50fSA9PT0gJyR7Qm90dG9tfScgPyAoJHt0b0V4cHIoYil9KSA6IGAgOiAnJykgKyAociAhPSBudWxsID8gYCR7JG9yaWVudH0gPT09ICcke1JpZ2h0fScgPyAoJHt0b0V4cHIocil9KSA6IGAgOiAnJykgKyAodCAhPSBudWxsID8gYCR7JG9yaWVudH0gPT09ICcke1RvcH0nID8gKCR7dG9FeHByKHQpfSkgOiBgIDogJycpICsgJyhudWxsKSdcbn0pO1xuY29uc3QgdG9FeHByID0gdiA9PiBpc1NpZ25hbCh2KSA/IHYuc2lnbmFsIDogdiA9PSBudWxsID8gbnVsbCA6IHN0cmluZ1ZhbHVlKHYpO1xuY29uc3QgbXVsdCA9IChzaWduLCB2YWx1ZSkgPT4gdmFsdWUgPT09IDAgPyAwIDogaXNTaWduYWwoc2lnbikgPyB7XG4gIHNpZ25hbDogYCgke3NpZ24uc2lnbmFsfSkgKiAke3ZhbHVlfWBcbn0gOiB7XG4gIHZhbHVlOiBzaWduICogdmFsdWVcbn07XG5jb25zdCBwYXRjaCA9ICh2YWx1ZSwgYmFzZSkgPT4ge1xuICBjb25zdCBzID0gdmFsdWUuc2lnbmFsO1xuICByZXR1cm4gcyAmJiBzLmVuZHNXaXRoKCcobnVsbCknKSA/IHtcbiAgICBzaWduYWw6IHMuc2xpY2UoMCwgLTYpICsgYmFzZS5zaWduYWxcbiAgfSA6IHZhbHVlO1xufTtcblxuZnVuY3Rpb24gZmFsbGJhY2socHJvcCwgY29uZmlnLCBheGlzQ29uZmlnLCBzdHlsZSkge1xuICBsZXQgc3R5bGVQcm9wO1xuICBpZiAoY29uZmlnICYmIGhhc093blByb3BlcnR5KGNvbmZpZywgcHJvcCkpIHtcbiAgICByZXR1cm4gY29uZmlnW3Byb3BdO1xuICB9IGVsc2UgaWYgKGhhc093blByb3BlcnR5KGF4aXNDb25maWcsIHByb3ApKSB7XG4gICAgcmV0dXJuIGF4aXNDb25maWdbcHJvcF07XG4gIH0gZWxzZSBpZiAocHJvcC5zdGFydHNXaXRoKCd0aXRsZScpKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICBjYXNlICd0aXRsZUNvbG9yJzpcbiAgICAgICAgc3R5bGVQcm9wID0gJ2ZpbGwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3RpdGxlRm9udCc6XG4gICAgICBjYXNlICd0aXRsZUZvbnRTaXplJzpcbiAgICAgIGNhc2UgJ3RpdGxlRm9udFdlaWdodCc6XG4gICAgICAgIHN0eWxlUHJvcCA9IHByb3BbNV0udG9Mb3dlckNhc2UoKSArIHByb3Auc2xpY2UoNik7XG4gICAgfVxuICAgIHJldHVybiBzdHlsZVtHdWlkZVRpdGxlU3R5bGVdW3N0eWxlUHJvcF07XG4gIH0gZWxzZSBpZiAocHJvcC5zdGFydHNXaXRoKCdsYWJlbCcpKSB7XG4gICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICBjYXNlICdsYWJlbENvbG9yJzpcbiAgICAgICAgc3R5bGVQcm9wID0gJ2ZpbGwnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xhYmVsRm9udCc6XG4gICAgICBjYXNlICdsYWJlbEZvbnRTaXplJzpcbiAgICAgICAgc3R5bGVQcm9wID0gcHJvcFs1XS50b0xvd2VyQ2FzZSgpICsgcHJvcC5zbGljZSg2KTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlW0d1aWRlTGFiZWxTdHlsZV1bc3R5bGVQcm9wXTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGtleXMob2JqZWN0cykge1xuICBjb25zdCBtYXAgPSB7fTtcbiAgZm9yIChjb25zdCBvYmogb2Ygb2JqZWN0cykge1xuICAgIGlmICghb2JqKSBjb250aW51ZTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIG1hcFtrZXldID0gMTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmtleXMobWFwKTtcbn1cbmZ1bmN0aW9uIGF4aXNDb25maWcgKHNwZWMsIHNjb3BlKSB7XG4gIHZhciBjb25maWcgPSBzY29wZS5jb25maWcsXG4gICAgc3R5bGUgPSBjb25maWcuc3R5bGUsXG4gICAgYXhpcyA9IGNvbmZpZy5heGlzLFxuICAgIGJhbmQgPSBzY29wZS5zY2FsZVR5cGUoc3BlYy5zY2FsZSkgPT09ICdiYW5kJyAmJiBjb25maWcuYXhpc0JhbmQsXG4gICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgeHksXG4gICAgb3IsXG4gICAga2V5O1xuICBpZiAoaXNTaWduYWwob3JpZW50KSkge1xuICAgIGNvbnN0IHh5S2V5cyA9IGtleXMoW2NvbmZpZy5heGlzWCwgY29uZmlnLmF4aXNZXSksXG4gICAgICBvcmllbnRLZXlzID0ga2V5cyhbY29uZmlnLmF4aXNUb3AsIGNvbmZpZy5heGlzQm90dG9tLCBjb25maWcuYXhpc0xlZnQsIGNvbmZpZy5heGlzUmlnaHRdKTtcbiAgICB4eSA9IHt9O1xuICAgIGZvciAoa2V5IG9mIHh5S2V5cykge1xuICAgICAgeHlba2V5XSA9IGlmWChvcmllbnQsIGZhbGxiYWNrKGtleSwgY29uZmlnLmF4aXNYLCBheGlzLCBzdHlsZSksIGZhbGxiYWNrKGtleSwgY29uZmlnLmF4aXNZLCBheGlzLCBzdHlsZSkpO1xuICAgIH1cbiAgICBvciA9IHt9O1xuICAgIGZvciAoa2V5IG9mIG9yaWVudEtleXMpIHtcbiAgICAgIG9yW2tleV0gPSBpZk9yaWVudChvcmllbnQuc2lnbmFsLCBmYWxsYmFjayhrZXksIGNvbmZpZy5heGlzVG9wLCBheGlzLCBzdHlsZSksIGZhbGxiYWNrKGtleSwgY29uZmlnLmF4aXNCb3R0b20sIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc0xlZnQsIGF4aXMsIHN0eWxlKSwgZmFsbGJhY2soa2V5LCBjb25maWcuYXhpc1JpZ2h0LCBheGlzLCBzdHlsZSkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB4eSA9IG9yaWVudCA9PT0gVG9wIHx8IG9yaWVudCA9PT0gQm90dG9tID8gY29uZmlnLmF4aXNYIDogY29uZmlnLmF4aXNZO1xuICAgIG9yID0gY29uZmlnWydheGlzJyArIG9yaWVudFswXS50b1VwcGVyQ2FzZSgpICsgb3JpZW50LnNsaWNlKDEpXTtcbiAgfVxuICBjb25zdCByZXN1bHQgPSB4eSB8fCBvciB8fCBiYW5kID8gZXh0ZW5kKHt9LCBheGlzLCB4eSwgb3IsIGJhbmQpIDogYXhpcztcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gYXhpc0RvbWFpbiAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICBvcmllbnQgPSBzcGVjLm9yaWVudDtcbiAgbGV0IGVudGVyLCB1cGRhdGU7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgc3Ryb2tlOiBfKCdkb21haW5Db2xvcicpLFxuICAgIHN0cm9rZUNhcDogXygnZG9tYWluQ2FwJyksXG4gICAgc3Ryb2tlRGFzaDogXygnZG9tYWluRGFzaCcpLFxuICAgIHN0cm9rZURhc2hPZmZzZXQ6IF8oJ2RvbWFpbkRhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VXaWR0aDogXygnZG9tYWluV2lkdGgnKSxcbiAgICBzdHJva2VPcGFjaXR5OiBfKCdkb21haW5PcGFjaXR5JylcbiAgfSk7XG4gIGNvbnN0IHBvczAgPSBwb3NpdGlvbihzcGVjLCAwKTtcbiAgY29uc3QgcG9zMSA9IHBvc2l0aW9uKHNwZWMsIDEpO1xuICBlbnRlci54ID0gdXBkYXRlLnggPSBpZlgob3JpZW50LCBwb3MwLCB6ZXJvKTtcbiAgZW50ZXIueDIgPSB1cGRhdGUueDIgPSBpZlgob3JpZW50LCBwb3MxKTtcbiAgZW50ZXIueSA9IHVwZGF0ZS55ID0gaWZZKG9yaWVudCwgcG9zMCwgemVybyk7XG4gIGVudGVyLnkyID0gdXBkYXRlLnkyID0gaWZZKG9yaWVudCwgcG9zMSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJ1bGVNYXJrLFxuICAgIHJvbGU6IEF4aXNEb21haW5Sb2xlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuZnVuY3Rpb24gcG9zaXRpb24oc3BlYywgcG9zKSB7XG4gIHJldHVybiB7XG4gICAgc2NhbGU6IHNwZWMuc2NhbGUsXG4gICAgcmFuZ2U6IHBvc1xuICB9O1xufVxuXG5mdW5jdGlvbiBheGlzR3JpZCAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICB2c2NhbGUgPSBzcGVjLmdyaWRTY2FsZSxcbiAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIDEsIC0xKSxcbiAgICBvZmZzZXQgPSBvZmZzZXRWYWx1ZShzcGVjLm9mZnNldCwgc2lnbik7XG4gIGxldCBlbnRlciwgZXhpdCwgdXBkYXRlO1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IGVudGVyID0ge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmVcbiAgICB9LFxuICAgIGV4aXQ6IGV4aXQgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBzdHJva2U6IF8oJ2dyaWRDb2xvcicpLFxuICAgIHN0cm9rZUNhcDogXygnZ3JpZENhcCcpLFxuICAgIHN0cm9rZURhc2g6IF8oJ2dyaWREYXNoJyksXG4gICAgc3Ryb2tlRGFzaE9mZnNldDogXygnZ3JpZERhc2hPZmZzZXQnKSxcbiAgICBzdHJva2VPcGFjaXR5OiBfKCdncmlkT3BhY2l0eScpLFxuICAgIHN0cm9rZVdpZHRoOiBfKCdncmlkV2lkdGgnKVxuICB9KTtcbiAgY29uc3QgdGlja1BvcyA9IHtcbiAgICBzY2FsZTogc3BlYy5zY2FsZSxcbiAgICBmaWVsZDogVmFsdWUsXG4gICAgYmFuZDogYmFuZC5iYW5kLFxuICAgIGV4dHJhOiBiYW5kLmV4dHJhLFxuICAgIG9mZnNldDogYmFuZC5vZmZzZXQsXG4gICAgcm91bmQ6IF8oJ3RpY2tSb3VuZCcpXG4gIH07XG4gIGNvbnN0IHN6ID0gaWZYKG9yaWVudCwge1xuICAgIHNpZ25hbDogJ2hlaWdodCdcbiAgfSwge1xuICAgIHNpZ25hbDogJ3dpZHRoJ1xuICB9KTtcbiAgY29uc3QgZ3JpZFN0YXJ0ID0gdnNjYWxlID8ge1xuICAgIHNjYWxlOiB2c2NhbGUsXG4gICAgcmFuZ2U6IDAsXG4gICAgbXVsdDogc2lnbixcbiAgICBvZmZzZXQ6IG9mZnNldFxuICB9IDoge1xuICAgIHZhbHVlOiAwLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH07XG4gIGNvbnN0IGdyaWRFbmQgPSB2c2NhbGUgPyB7XG4gICAgc2NhbGU6IHZzY2FsZSxcbiAgICByYW5nZTogMSxcbiAgICBtdWx0OiBzaWduLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH0gOiBleHRlbmQoc3osIHtcbiAgICBtdWx0OiBzaWduLFxuICAgIG9mZnNldDogb2Zmc2V0XG4gIH0pO1xuICBlbnRlci54ID0gdXBkYXRlLnggPSBpZlgob3JpZW50LCB0aWNrUG9zLCBncmlkU3RhcnQpO1xuICBlbnRlci55ID0gdXBkYXRlLnkgPSBpZlkob3JpZW50LCB0aWNrUG9zLCBncmlkU3RhcnQpO1xuICBlbnRlci54MiA9IHVwZGF0ZS54MiA9IGlmWShvcmllbnQsIGdyaWRFbmQpO1xuICBlbnRlci55MiA9IHVwZGF0ZS55MiA9IGlmWChvcmllbnQsIGdyaWRFbmQpO1xuICBleGl0LnggPSBpZlgob3JpZW50LCB0aWNrUG9zKTtcbiAgZXhpdC55ID0gaWZZKG9yaWVudCwgdGlja1Bvcyk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFJ1bGVNYXJrLFxuICAgIHJvbGU6IEF4aXNHcmlkUm9sZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlXG4gIH0sIHVzZXJFbmNvZGUpO1xufVxuZnVuY3Rpb24gb2Zmc2V0VmFsdWUob2Zmc2V0LCBzaWduKSB7XG4gIGlmIChzaWduID09PSAxKSA7IGVsc2UgaWYgKCFpc09iamVjdChvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gaXNTaWduYWwoc2lnbikgPyB7XG4gICAgICBzaWduYWw6IGAoJHtzaWduLnNpZ25hbH0pICogKCR7b2Zmc2V0IHx8IDB9KWBcbiAgICB9IDogc2lnbiAqIChvZmZzZXQgfHwgMCk7XG4gIH0gZWxzZSB7XG4gICAgbGV0IGVudHJ5ID0gb2Zmc2V0ID0gZXh0ZW5kKHt9LCBvZmZzZXQpO1xuICAgIHdoaWxlIChlbnRyeS5tdWx0ICE9IG51bGwpIHtcbiAgICAgIGlmICghaXNPYmplY3QoZW50cnkubXVsdCkpIHtcbiAgICAgICAgZW50cnkubXVsdCA9IGlzU2lnbmFsKHNpZ24pIC8vIG5vIG9mZnNldCBpZiBzaWduID09PSAxXG4gICAgICAgID8ge1xuICAgICAgICAgIHNpZ25hbDogYCgke2VudHJ5Lm11bHR9KSAqICgke3NpZ24uc2lnbmFsfSlgXG4gICAgICAgIH0gOiBlbnRyeS5tdWx0ICogc2lnbjtcbiAgICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVudHJ5ID0gZW50cnkubXVsdCA9IGV4dGVuZCh7fSwgZW50cnkubXVsdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVudHJ5Lm11bHQgPSBzaWduO1xuICB9XG4gIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaWNrcyAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmLCBzaXplLCBiYW5kKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIC0xLCAxKTtcbiAgbGV0IGVudGVyLCBleGl0LCB1cGRhdGU7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvXG4gICAgfSxcbiAgICB1cGRhdGU6IHVwZGF0ZSA9IHtcbiAgICAgIG9wYWNpdHk6IG9uZVxuICAgIH0sXG4gICAgZXhpdDogZXhpdCA9IHtcbiAgICAgIG9wYWNpdHk6IHplcm9cbiAgICB9XG4gIH07XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIHN0cm9rZTogXygndGlja0NvbG9yJyksXG4gICAgc3Ryb2tlQ2FwOiBfKCd0aWNrQ2FwJyksXG4gICAgc3Ryb2tlRGFzaDogXygndGlja0Rhc2gnKSxcbiAgICBzdHJva2VEYXNoT2Zmc2V0OiBfKCd0aWNrRGFzaE9mZnNldCcpLFxuICAgIHN0cm9rZU9wYWNpdHk6IF8oJ3RpY2tPcGFjaXR5JyksXG4gICAgc3Ryb2tlV2lkdGg6IF8oJ3RpY2tXaWR0aCcpXG4gIH0pO1xuICBjb25zdCB0aWNrU2l6ZSA9IGVuY29kZXIoc2l6ZSk7XG4gIHRpY2tTaXplLm11bHQgPSBzaWduO1xuICBjb25zdCB0aWNrUG9zID0ge1xuICAgIHNjYWxlOiBzcGVjLnNjYWxlLFxuICAgIGZpZWxkOiBWYWx1ZSxcbiAgICBiYW5kOiBiYW5kLmJhbmQsXG4gICAgZXh0cmE6IGJhbmQuZXh0cmEsXG4gICAgb2Zmc2V0OiBiYW5kLm9mZnNldCxcbiAgICByb3VuZDogXygndGlja1JvdW5kJylcbiAgfTtcbiAgdXBkYXRlLnkgPSBlbnRlci55ID0gaWZYKG9yaWVudCwgemVybywgdGlja1Bvcyk7XG4gIHVwZGF0ZS55MiA9IGVudGVyLnkyID0gaWZYKG9yaWVudCwgdGlja1NpemUpO1xuICBleGl0LnggPSBpZlgob3JpZW50LCB0aWNrUG9zKTtcbiAgdXBkYXRlLnggPSBlbnRlci54ID0gaWZZKG9yaWVudCwgemVybywgdGlja1Bvcyk7XG4gIHVwZGF0ZS54MiA9IGVudGVyLngyID0gaWZZKG9yaWVudCwgdGlja1NpemUpO1xuICBleGl0LnkgPSBpZlkob3JpZW50LCB0aWNrUG9zKTtcbiAgcmV0dXJuIGd1aWRlTWFyayh7XG4gICAgdHlwZTogUnVsZU1hcmssXG4gICAgcm9sZTogQXhpc1RpY2tSb2xlLFxuICAgIGtleTogVmFsdWUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGVcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGZsdXNoRXhwcihzY2FsZSwgdGhyZXNob2xkLCBhLCBiLCBjKSB7XG4gIHJldHVybiB7XG4gICAgc2lnbmFsOiAnZmx1c2gocmFuZ2UoXCInICsgc2NhbGUgKyAnXCIpLCAnICsgJ3NjYWxlKFwiJyArIHNjYWxlICsgJ1wiLCBkYXR1bS52YWx1ZSksICcgKyB0aHJlc2hvbGQgKyAnLCcgKyBhICsgJywnICsgYiArICcsJyArIGMgKyAnKSdcbiAgfTtcbn1cbmZ1bmN0aW9uIGF4aXNMYWJlbHMgKHNwZWMsIGNvbmZpZywgdXNlckVuY29kZSwgZGF0YVJlZiwgc2l6ZSwgYmFuZCkge1xuICBjb25zdCBfID0gbG9va3VwKHNwZWMsIGNvbmZpZyksXG4gICAgb3JpZW50ID0gc3BlYy5vcmllbnQsXG4gICAgc2NhbGUgPSBzcGVjLnNjYWxlLFxuICAgIHNpZ24gPSBnZXRTaWduKG9yaWVudCwgLTEsIDEpLFxuICAgIGZsdXNoID0gZGVyZWYoXygnbGFiZWxGbHVzaCcpKSxcbiAgICBmbHVzaE9mZnNldCA9IGRlcmVmKF8oJ2xhYmVsRmx1c2hPZmZzZXQnKSksXG4gICAgbGFiZWxBbGlnbiA9IF8oJ2xhYmVsQWxpZ24nKSxcbiAgICBsYWJlbEJhc2VsaW5lID0gXygnbGFiZWxCYXNlbGluZScpO1xuICBsZXQgZmx1c2hPbiA9IGZsdXNoID09PSAwIHx8ICEhZmx1c2gsXG4gICAgdXBkYXRlO1xuICBjb25zdCB0aWNrU2l6ZSA9IGVuY29kZXIoc2l6ZSk7XG4gIHRpY2tTaXplLm11bHQgPSBzaWduO1xuICB0aWNrU2l6ZS5vZmZzZXQgPSBlbmNvZGVyKF8oJ2xhYmVsUGFkZGluZycpIHx8IDApO1xuICB0aWNrU2l6ZS5vZmZzZXQubXVsdCA9IHNpZ247XG4gIGNvbnN0IHRpY2tQb3MgPSB7XG4gICAgc2NhbGU6IHNjYWxlLFxuICAgIGZpZWxkOiBWYWx1ZSxcbiAgICBiYW5kOiAwLjUsXG4gICAgb2Zmc2V0OiBleHRlbmRPZmZzZXQoYmFuZC5vZmZzZXQsIF8oJ2xhYmVsT2Zmc2V0JykpXG4gIH07XG4gIGNvbnN0IGFsaWduID0gaWZYKG9yaWVudCwgZmx1c2hPbiA/IGZsdXNoRXhwcihzY2FsZSwgZmx1c2gsICdcImxlZnRcIicsICdcInJpZ2h0XCInLCAnXCJjZW50ZXJcIicpIDoge1xuICAgIHZhbHVlOiAnY2VudGVyJ1xuICB9LCBpZlJpZ2h0KG9yaWVudCwgJ2xlZnQnLCAncmlnaHQnKSk7XG4gIGNvbnN0IGJhc2VsaW5lID0gaWZYKG9yaWVudCwgaWZUb3Aob3JpZW50LCAnYm90dG9tJywgJ3RvcCcpLCBmbHVzaE9uID8gZmx1c2hFeHByKHNjYWxlLCBmbHVzaCwgJ1widG9wXCInLCAnXCJib3R0b21cIicsICdcIm1pZGRsZVwiJykgOiB7XG4gICAgdmFsdWU6ICdtaWRkbGUnXG4gIH0pO1xuICBjb25zdCBvZmZzZXRFeHByID0gZmx1c2hFeHByKHNjYWxlLCBmbHVzaCwgYC0oJHtmbHVzaE9mZnNldH0pYCwgZmx1c2hPZmZzZXQsIDApO1xuICBmbHVzaE9uID0gZmx1c2hPbiAmJiBmbHVzaE9mZnNldDtcbiAgY29uc3QgZW50ZXIgPSB7XG4gICAgb3BhY2l0eTogemVybyxcbiAgICB4OiBpZlgob3JpZW50LCB0aWNrUG9zLCB0aWNrU2l6ZSksXG4gICAgeTogaWZZKG9yaWVudCwgdGlja1BvcywgdGlja1NpemUpXG4gIH07XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIsXG4gICAgdXBkYXRlOiB1cGRhdGUgPSB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiB7XG4gICAgICAgIGZpZWxkOiBMYWJlbFxuICAgICAgfSxcbiAgICAgIHg6IGVudGVyLngsXG4gICAgICB5OiBlbnRlci55LFxuICAgICAgYWxpZ24sXG4gICAgICBiYXNlbGluZVxuICAgIH0sXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVybyxcbiAgICAgIHg6IGVudGVyLngsXG4gICAgICB5OiBlbnRlci55XG4gICAgfVxuICB9O1xuICBhZGRFbmNvZGVycyhlbmNvZGUsIHtcbiAgICBkeDogIWxhYmVsQWxpZ24gJiYgZmx1c2hPbiA/IGlmWChvcmllbnQsIG9mZnNldEV4cHIpIDogbnVsbCxcbiAgICBkeTogIWxhYmVsQmFzZWxpbmUgJiYgZmx1c2hPbiA/IGlmWShvcmllbnQsIG9mZnNldEV4cHIpIDogbnVsbFxuICB9KTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgYW5nbGU6IF8oJ2xhYmVsQW5nbGUnKSxcbiAgICBmaWxsOiBfKCdsYWJlbENvbG9yJyksXG4gICAgZmlsbE9wYWNpdHk6IF8oJ2xhYmVsT3BhY2l0eScpLFxuICAgIGZvbnQ6IF8oJ2xhYmVsRm9udCcpLFxuICAgIGZvbnRTaXplOiBfKCdsYWJlbEZvbnRTaXplJyksXG4gICAgZm9udFdlaWdodDogXygnbGFiZWxGb250V2VpZ2h0JyksXG4gICAgZm9udFN0eWxlOiBfKCdsYWJlbEZvbnRTdHlsZScpLFxuICAgIGxpbWl0OiBfKCdsYWJlbExpbWl0JyksXG4gICAgbGluZUhlaWdodDogXygnbGFiZWxMaW5lSGVpZ2h0JylcbiAgfSwge1xuICAgIGFsaWduOiBsYWJlbEFsaWduLFxuICAgIGJhc2VsaW5lOiBsYWJlbEJhc2VsaW5lXG4gIH0pO1xuICBjb25zdCBib3VuZCA9IF8oJ2xhYmVsQm91bmQnKTtcbiAgbGV0IG92ZXJsYXAgPSBfKCdsYWJlbE92ZXJsYXAnKTtcblxuICAvLyBpZiBvdmVybGFwIG1ldGhvZCBvciBib3VuZCBkZWZpbmVkLCByZXF1ZXN0IGxhYmVsIG92ZXJsYXAgcmVtb3ZhbFxuICBvdmVybGFwID0gb3ZlcmxhcCB8fCBib3VuZCA/IHtcbiAgICBzZXBhcmF0aW9uOiBfKCdsYWJlbFNlcGFyYXRpb24nKSxcbiAgICBtZXRob2Q6IG92ZXJsYXAsXG4gICAgb3JkZXI6ICdkYXR1bS5pbmRleCcsXG4gICAgYm91bmQ6IGJvdW5kID8ge1xuICAgICAgc2NhbGUsXG4gICAgICBvcmllbnQsXG4gICAgICB0b2xlcmFuY2U6IGJvdW5kXG4gICAgfSA6IG51bGxcbiAgfSA6IHVuZGVmaW5lZDtcbiAgaWYgKHVwZGF0ZS5hbGlnbiAhPT0gYWxpZ24pIHtcbiAgICB1cGRhdGUuYWxpZ24gPSBwYXRjaCh1cGRhdGUuYWxpZ24sIGFsaWduKTtcbiAgfVxuICBpZiAodXBkYXRlLmJhc2VsaW5lICE9PSBiYXNlbGluZSkge1xuICAgIHVwZGF0ZS5iYXNlbGluZSA9IHBhdGNoKHVwZGF0ZS5iYXNlbGluZSwgYmFzZWxpbmUpO1xuICB9XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IEF4aXNMYWJlbFJvbGUsXG4gICAgc3R5bGU6IEd1aWRlTGFiZWxTdHlsZSxcbiAgICBrZXk6IFZhbHVlLFxuICAgIGZyb206IGRhdGFSZWYsXG4gICAgZW5jb2RlLFxuICAgIG92ZXJsYXBcbiAgfSwgdXNlckVuY29kZSk7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaXRsZSAoc3BlYywgY29uZmlnLCB1c2VyRW5jb2RlLCBkYXRhUmVmKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICBvcmllbnQgPSBzcGVjLm9yaWVudCxcbiAgICBzaWduID0gZ2V0U2lnbihvcmllbnQsIC0xLCAxKTtcbiAgbGV0IGVudGVyLCB1cGRhdGU7XG4gIGNvbnN0IGVuY29kZSA9IHtcbiAgICBlbnRlcjogZW50ZXIgPSB7XG4gICAgICBvcGFjaXR5OiB6ZXJvLFxuICAgICAgYW5jaG9yOiBlbmNvZGVyKF8oJ3RpdGxlQW5jaG9yJywgbnVsbCkpLFxuICAgICAgYWxpZ246IHtcbiAgICAgICAgc2lnbmFsOiBhbGlnbkV4cHIkMVxuICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlOiB1cGRhdGUgPSBleHRlbmQoe30sIGVudGVyLCB7XG4gICAgICBvcGFjaXR5OiBvbmUsXG4gICAgICB0ZXh0OiBlbmNvZGVyKHNwZWMudGl0bGUpXG4gICAgfSksXG4gICAgZXhpdDoge1xuICAgICAgb3BhY2l0eTogemVyb1xuICAgIH1cbiAgfTtcbiAgY29uc3QgdGl0bGVQb3MgPSB7XG4gICAgc2lnbmFsOiBgbGVycChyYW5nZShcIiR7c3BlYy5zY2FsZX1cIiksICR7YW5jaG9yRXhwcigwLCAxLCAwLjUpfSlgXG4gIH07XG4gIHVwZGF0ZS54ID0gaWZYKG9yaWVudCwgdGl0bGVQb3MpO1xuICB1cGRhdGUueSA9IGlmWShvcmllbnQsIHRpdGxlUG9zKTtcbiAgZW50ZXIuYW5nbGUgPSBpZlgob3JpZW50LCB6ZXJvLCBtdWx0KHNpZ24sIDkwKSk7XG4gIGVudGVyLmJhc2VsaW5lID0gaWZYKG9yaWVudCwgaWZUb3Aob3JpZW50LCBCb3R0b20sIFRvcCksIHtcbiAgICB2YWx1ZTogQm90dG9tXG4gIH0pO1xuICB1cGRhdGUuYW5nbGUgPSBlbnRlci5hbmdsZTtcbiAgdXBkYXRlLmJhc2VsaW5lID0gZW50ZXIuYmFzZWxpbmU7XG4gIGFkZEVuY29kZXJzKGVuY29kZSwge1xuICAgIGZpbGw6IF8oJ3RpdGxlQ29sb3InKSxcbiAgICBmaWxsT3BhY2l0eTogXygndGl0bGVPcGFjaXR5JyksXG4gICAgZm9udDogXygndGl0bGVGb250JyksXG4gICAgZm9udFNpemU6IF8oJ3RpdGxlRm9udFNpemUnKSxcbiAgICBmb250U3R5bGU6IF8oJ3RpdGxlRm9udFN0eWxlJyksXG4gICAgZm9udFdlaWdodDogXygndGl0bGVGb250V2VpZ2h0JyksXG4gICAgbGltaXQ6IF8oJ3RpdGxlTGltaXQnKSxcbiAgICBsaW5lSGVpZ2h0OiBfKCd0aXRsZUxpbmVIZWlnaHQnKVxuICB9LCB7XG4gICAgLy8gcmVxdWlyZSB1cGRhdGVcbiAgICBhbGlnbjogXygndGl0bGVBbGlnbicpLFxuICAgIGFuZ2xlOiBfKCd0aXRsZUFuZ2xlJyksXG4gICAgYmFzZWxpbmU6IF8oJ3RpdGxlQmFzZWxpbmUnKVxuICB9KTtcbiAgYXV0b0xheW91dChfLCBvcmllbnQsIGVuY29kZSwgdXNlckVuY29kZSk7XG4gIGVuY29kZS51cGRhdGUuYWxpZ24gPSBwYXRjaChlbmNvZGUudXBkYXRlLmFsaWduLCBlbnRlci5hbGlnbik7XG4gIGVuY29kZS51cGRhdGUuYW5nbGUgPSBwYXRjaChlbmNvZGUudXBkYXRlLmFuZ2xlLCBlbnRlci5hbmdsZSk7XG4gIGVuY29kZS51cGRhdGUuYmFzZWxpbmUgPSBwYXRjaChlbmNvZGUudXBkYXRlLmJhc2VsaW5lLCBlbnRlci5iYXNlbGluZSk7XG4gIHJldHVybiBndWlkZU1hcmsoe1xuICAgIHR5cGU6IFRleHRNYXJrLFxuICAgIHJvbGU6IEF4aXNUaXRsZVJvbGUsXG4gICAgc3R5bGU6IEd1aWRlVGl0bGVTdHlsZSxcbiAgICBmcm9tOiBkYXRhUmVmLFxuICAgIGVuY29kZVxuICB9LCB1c2VyRW5jb2RlKTtcbn1cbmZ1bmN0aW9uIGF1dG9MYXlvdXQoXywgb3JpZW50LCBlbmNvZGUsIHVzZXJFbmNvZGUpIHtcbiAgY29uc3QgYXV0byA9ICh2YWx1ZSwgZGltKSA9PiB2YWx1ZSAhPSBudWxsID8gKGVuY29kZS51cGRhdGVbZGltXSA9IHBhdGNoKGVuY29kZXIodmFsdWUpLCBlbmNvZGUudXBkYXRlW2RpbV0pLCBmYWxzZSkgOiAhaGFzKGRpbSwgdXNlckVuY29kZSkgPyB0cnVlIDogZmFsc2U7XG4gIGNvbnN0IGF1dG9ZID0gYXV0byhfKCd0aXRsZVgnKSwgJ3gnKSxcbiAgICBhdXRvWCA9IGF1dG8oXygndGl0bGVZJyksICd5Jyk7XG4gIGVuY29kZS5lbnRlci5hdXRvID0gYXV0b1ggPT09IGF1dG9ZID8gZW5jb2RlcihhdXRvWCkgOiBpZlgob3JpZW50LCBlbmNvZGVyKGF1dG9YKSwgZW5jb2RlcihhdXRvWSkpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUF4aXMgKHNwZWMsIHNjb3BlKSB7XG4gIGNvbnN0IGNvbmZpZyA9IGF4aXNDb25maWcoc3BlYywgc2NvcGUpLFxuICAgIGVuY29kZSA9IHNwZWMuZW5jb2RlIHx8IHt9LFxuICAgIGF4aXNFbmNvZGUgPSBlbmNvZGUuYXhpcyB8fCB7fSxcbiAgICBuYW1lID0gYXhpc0VuY29kZS5uYW1lIHx8IHVuZGVmaW5lZCxcbiAgICBpbnRlcmFjdGl2ZSA9IGF4aXNFbmNvZGUuaW50ZXJhY3RpdmUsXG4gICAgc3R5bGUgPSBheGlzRW5jb2RlLnN0eWxlLFxuICAgIF8gPSBsb29rdXAoc3BlYywgY29uZmlnKSxcbiAgICBiYW5kID0gdGlja0JhbmQoXyk7XG5cbiAgLy8gc2luZ2xlLWVsZW1lbnQgZGF0YSBzb3VyY2UgZm9yIGF4aXMgZ3JvdXBcbiAgY29uc3QgZGF0dW0gPSB7XG4gICAgc2NhbGU6IHNwZWMuc2NhbGUsXG4gICAgdGlja3M6ICEhXygndGlja3MnKSxcbiAgICBsYWJlbHM6ICEhXygnbGFiZWxzJyksXG4gICAgZ3JpZDogISFfKCdncmlkJyksXG4gICAgZG9tYWluOiAhIV8oJ2RvbWFpbicpLFxuICAgIHRpdGxlOiBzcGVjLnRpdGxlICE9IG51bGxcbiAgfTtcbiAgY29uc3QgZGF0YVJlZiA9IHJlZihzY29wZS5hZGQoQ29sbGVjdCh7fSwgW2RhdHVtXSkpKTtcblxuICAvLyBkYXRhIHNvdXJjZSBmb3IgYXhpcyB0aWNrc1xuICBjb25zdCB0aWNrc1JlZiA9IHJlZihzY29wZS5hZGQoQXhpc1RpY2tzKHtcbiAgICBzY2FsZTogc2NvcGUuc2NhbGVSZWYoc3BlYy5zY2FsZSksXG4gICAgZXh0cmE6IHNjb3BlLnByb3BlcnR5KGJhbmQuZXh0cmEpLFxuICAgIGNvdW50OiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLnRpY2tDb3VudCksXG4gICAgdmFsdWVzOiBzY29wZS5vYmplY3RQcm9wZXJ0eShzcGVjLnZhbHVlcyksXG4gICAgbWluc3RlcDogc2NvcGUucHJvcGVydHkoc3BlYy50aWNrTWluU3RlcCksXG4gICAgZm9ybWF0VHlwZTogc2NvcGUucHJvcGVydHkoc3BlYy5mb3JtYXRUeXBlKSxcbiAgICBmb3JtYXRTcGVjaWZpZXI6IHNjb3BlLnByb3BlcnR5KHNwZWMuZm9ybWF0KVxuICB9KSkpO1xuXG4gIC8vIGdlbmVyYXRlIGF4aXMgbWFya3NcbiAgY29uc3QgY2hpbGRyZW4gPSBbXTtcbiAgbGV0IHNpemU7XG5cbiAgLy8gaW5jbHVkZSBheGlzIGdyaWRsaW5lcyBpZiByZXF1ZXN0ZWRcbiAgaWYgKGRhdHVtLmdyaWQpIHtcbiAgICBjaGlsZHJlbi5wdXNoKGF4aXNHcmlkKHNwZWMsIGNvbmZpZywgZW5jb2RlLmdyaWQsIHRpY2tzUmVmLCBiYW5kKSk7XG4gIH1cblxuICAvLyBpbmNsdWRlIGF4aXMgdGlja3MgaWYgcmVxdWVzdGVkXG4gIGlmIChkYXR1bS50aWNrcykge1xuICAgIHNpemUgPSBfKCd0aWNrU2l6ZScpO1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc1RpY2tzKHNwZWMsIGNvbmZpZywgZW5jb2RlLnRpY2tzLCB0aWNrc1JlZiwgc2l6ZSwgYmFuZCkpO1xuICB9XG5cbiAgLy8gaW5jbHVkZSBheGlzIGxhYmVscyBpZiByZXF1ZXN0ZWRcbiAgaWYgKGRhdHVtLmxhYmVscykge1xuICAgIHNpemUgPSBkYXR1bS50aWNrcyA/IHNpemUgOiAwO1xuICAgIGNoaWxkcmVuLnB1c2goYXhpc0xhYmVscyhzcGVjLCBjb25maWcsIGVuY29kZS5sYWJlbHMsIHRpY2tzUmVmLCBzaXplLCBiYW5kKSk7XG4gIH1cblxuICAvLyBpbmNsdWRlIGF4aXMgZG9tYWluIHBhdGggaWYgcmVxdWVzdGVkXG4gIGlmIChkYXR1bS5kb21haW4pIHtcbiAgICBjaGlsZHJlbi5wdXNoKGF4aXNEb21haW4oc3BlYywgY29uZmlnLCBlbmNvZGUuZG9tYWluLCBkYXRhUmVmKSk7XG4gIH1cblxuICAvLyBpbmNsdWRlIGF4aXMgdGl0bGUgaWYgZGVmaW5lZFxuICBpZiAoZGF0dW0udGl0bGUpIHtcbiAgICBjaGlsZHJlbi5wdXNoKGF4aXNUaXRsZShzcGVjLCBjb25maWcsIGVuY29kZS50aXRsZSwgZGF0YVJlZikpO1xuICB9XG5cbiAgLy8gcGFyc2UgYXhpcyBzcGVjaWZpY2F0aW9uXG4gIHJldHVybiBwYXJzZU1hcmsoZ3VpZGVHcm91cCh7XG4gICAgcm9sZTogQXhpc1JvbGUsXG4gICAgZnJvbTogZGF0YVJlZixcbiAgICBlbmNvZGU6IGV4dGVuZEVuY29kZShidWlsZEF4aXNFbmNvZGUoXywgc3BlYyksIGF4aXNFbmNvZGUsIFNraXApLFxuICAgIG1hcmtzOiBjaGlsZHJlbixcbiAgICBhcmlhOiBfKCdhcmlhJyksXG4gICAgZGVzY3JpcHRpb246IF8oJ2Rlc2NyaXB0aW9uJyksXG4gICAgemluZGV4OiBfKCd6aW5kZXgnKSxcbiAgICBuYW1lLFxuICAgIGludGVyYWN0aXZlLFxuICAgIHN0eWxlXG4gIH0pLCBzY29wZSk7XG59XG5mdW5jdGlvbiBidWlsZEF4aXNFbmNvZGUoXywgc3BlYykge1xuICBjb25zdCBlbmNvZGUgPSB7XG4gICAgZW50ZXI6IHt9LFxuICAgIHVwZGF0ZToge31cbiAgfTtcbiAgYWRkRW5jb2RlcnMoZW5jb2RlLCB7XG4gICAgb3JpZW50OiBfKCdvcmllbnQnKSxcbiAgICBvZmZzZXQ6IF8oJ29mZnNldCcpIHx8IDAsXG4gICAgcG9zaXRpb246IHZhbHVlKHNwZWMucG9zaXRpb24sIDApLFxuICAgIHRpdGxlUGFkZGluZzogXygndGl0bGVQYWRkaW5nJyksXG4gICAgbWluRXh0ZW50OiBfKCdtaW5FeHRlbnQnKSxcbiAgICBtYXhFeHRlbnQ6IF8oJ21heEV4dGVudCcpLFxuICAgIHJhbmdlOiB7XG4gICAgICBzaWduYWw6IGBhYnMoc3BhbihyYW5nZShcIiR7c3BlYy5zY2FsZX1cIikpKWBcbiAgICB9LFxuICAgIHRyYW5zbGF0ZTogXygndHJhbnNsYXRlJyksXG4gICAgLy8gYWNjZXNzaWJpbGl0eSBzdXBwb3J0XG4gICAgZm9ybWF0OiBzcGVjLmZvcm1hdCxcbiAgICBmb3JtYXRUeXBlOiBzcGVjLmZvcm1hdFR5cGVcbiAgfSk7XG4gIHJldHVybiBlbmNvZGU7XG59XG5cbmZ1bmN0aW9uIHBhcnNlU2NvcGUgKHNwZWMsIHNjb3BlLCBwcmVwcm9jZXNzZWQpIHtcbiAgY29uc3Qgc2lnbmFscyA9IGFycmF5KHNwZWMuc2lnbmFscyksXG4gICAgc2NhbGVzID0gYXJyYXkoc3BlYy5zY2FsZXMpO1xuXG4gIC8vIHBhcnNlIHNpZ25hbCBkZWZpbml0aW9ucywgaWYgbm90IGFscmVhZHkgcHJlcHJvY2Vzc2VkXG4gIGlmICghcHJlcHJvY2Vzc2VkKSBzaWduYWxzLmZvckVhY2goXyA9PiBwYXJzZVNpZ25hbChfLCBzY29wZSkpO1xuXG4gIC8vIHBhcnNlIGNhcnRvZ3JhcGhpYyBwcm9qZWN0aW9uIGRlZmluaXRpb25zXG4gIGFycmF5KHNwZWMucHJvamVjdGlvbnMpLmZvckVhY2goXyA9PiBwYXJzZVByb2plY3Rpb24oXywgc2NvcGUpKTtcblxuICAvLyBpbml0aWFsaXplIHNjYWxlIHJlZmVyZW5jZXNcbiAgc2NhbGVzLmZvckVhY2goXyA9PiBpbml0U2NhbGUoXywgc2NvcGUpKTtcblxuICAvLyBwYXJzZSBkYXRhIHNvdXJjZXNcbiAgYXJyYXkoc3BlYy5kYXRhKS5mb3JFYWNoKF8gPT4gcGFyc2VEYXRhKF8sIHNjb3BlKSk7XG5cbiAgLy8gcGFyc2Ugc2NhbGUgZGVmaW5pdGlvbnNcbiAgc2NhbGVzLmZvckVhY2goXyA9PiBwYXJzZVNjYWxlKF8sIHNjb3BlKSk7XG5cbiAgLy8gcGFyc2Ugc2lnbmFsIHVwZGF0ZXNcbiAgKHByZXByb2Nlc3NlZCB8fCBzaWduYWxzKS5mb3JFYWNoKF8gPT4gcGFyc2VTaWduYWxVcGRhdGVzKF8sIHNjb3BlKSk7XG5cbiAgLy8gcGFyc2UgYXhpcyBkZWZpbml0aW9uc1xuICBhcnJheShzcGVjLmF4ZXMpLmZvckVhY2goXyA9PiBwYXJzZUF4aXMoXywgc2NvcGUpKTtcblxuICAvLyBwYXJzZSBtYXJrIGRlZmluaXRpb25zXG4gIGFycmF5KHNwZWMubWFya3MpLmZvckVhY2goXyA9PiBwYXJzZU1hcmsoXywgc2NvcGUpKTtcblxuICAvLyBwYXJzZSBsZWdlbmQgZGVmaW5pdGlvbnNcbiAgYXJyYXkoc3BlYy5sZWdlbmRzKS5mb3JFYWNoKF8gPT4gcGFyc2VMZWdlbmQoXywgc2NvcGUpKTtcblxuICAvLyBwYXJzZSB0aXRsZSwgaWYgZGVmaW5lZFxuICBpZiAoc3BlYy50aXRsZSkgcGFyc2VUaXRsZShzcGVjLnRpdGxlLCBzY29wZSk7XG5cbiAgLy8gcGFyc2UgY29sbGVjdGVkIGxhbWJkYSAoYW5vbnltb3VzKSBleHByZXNzaW9uc1xuICBzY29wZS5wYXJzZUxhbWJkYXMoKTtcbiAgcmV0dXJuIHNjb3BlO1xufVxuXG5jb25zdCByb290RW5jb2RlID0gc3BlYyA9PiBleHRlbmRFbmNvZGUoe1xuICBlbnRlcjoge1xuICAgIHg6IHtcbiAgICAgIHZhbHVlOiAwXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICB2YWx1ZTogMFxuICAgIH1cbiAgfSxcbiAgdXBkYXRlOiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIHNpZ25hbDogJ3dpZHRoJ1xuICAgIH0sXG4gICAgaGVpZ2h0OiB7XG4gICAgICBzaWduYWw6ICdoZWlnaHQnXG4gICAgfVxuICB9XG59LCBzcGVjKTtcbmZ1bmN0aW9uIHBhcnNlVmlldyhzcGVjLCBzY29wZSkge1xuICBjb25zdCBjb25maWcgPSBzY29wZS5jb25maWc7XG5cbiAgLy8gYWRkIHNjZW5lZ3JhcGggcm9vdFxuICBjb25zdCByb290ID0gcmVmKHNjb3BlLnJvb3QgPSBzY29wZS5hZGQob3BlcmF0b3IoKSkpO1xuXG4gIC8vIHBhcnNlIHRvcC1sZXZlbCBzaWduYWwgZGVmaW5pdGlvbnNcbiAgY29uc3Qgc2lnbmFscyA9IGNvbGxlY3RTaWduYWxzKHNwZWMsIGNvbmZpZyk7XG4gIHNpZ25hbHMuZm9yRWFjaChfID0+IHBhcnNlU2lnbmFsKF8sIHNjb3BlKSk7XG5cbiAgLy8gYXNzaWduIGRlc2NyaXB0aW9uLCBldmVudCwgbGVnZW5kLCBhbmQgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgc2NvcGUuZGVzY3JpcHRpb24gPSBzcGVjLmRlc2NyaXB0aW9uIHx8IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgc2NvcGUuZXZlbnRDb25maWcgPSBjb25maWcuZXZlbnRzO1xuICBzY29wZS5sZWdlbmRzID0gc2NvcGUub2JqZWN0UHJvcGVydHkoY29uZmlnLmxlZ2VuZCAmJiBjb25maWcubGVnZW5kLmxheW91dCk7XG4gIHNjb3BlLmxvY2FsZSA9IGNvbmZpZy5sb2NhbGU7XG5cbiAgLy8gc3RvcmUgcm9vdCBncm91cCBpdGVtXG4gIGNvbnN0IGlucHV0ID0gc2NvcGUuYWRkKENvbGxlY3QoKSk7XG5cbiAgLy8gZW5jb2RlIHJvb3QgZ3JvdXAgaXRlbVxuICBjb25zdCBlbmNvZGUgPSBzY29wZS5hZGQoRW5jb2RlKHBhcnNlRW5jb2RlKHJvb3RFbmNvZGUoc3BlYy5lbmNvZGUpLCBHcm91cE1hcmssIEZyYW1lUm9sZSwgc3BlYy5zdHlsZSwgc2NvcGUsIHtcbiAgICBwdWxzZTogcmVmKGlucHV0KVxuICB9KSkpO1xuXG4gIC8vIHBlcmZvcm0gdmlldyBsYXlvdXRcbiAgY29uc3QgcGFyZW50ID0gc2NvcGUuYWRkKFZpZXdMYXlvdXQoe1xuICAgIGxheW91dDogc2NvcGUub2JqZWN0UHJvcGVydHkoc3BlYy5sYXlvdXQpLFxuICAgIGxlZ2VuZHM6IHNjb3BlLmxlZ2VuZHMsXG4gICAgYXV0b3NpemU6IHNjb3BlLnNpZ25hbFJlZignYXV0b3NpemUnKSxcbiAgICBtYXJrOiByb290LFxuICAgIHB1bHNlOiByZWYoZW5jb2RlKVxuICB9KSk7XG4gIHNjb3BlLm9wZXJhdG9ycy5wb3AoKTtcblxuICAvLyBwYXJzZSByZW1haW5kZXIgb2Ygc3BlY2lmaWNhdGlvblxuICBzY29wZS5wdXNoU3RhdGUocmVmKGVuY29kZSksIHJlZihwYXJlbnQpLCBudWxsKTtcbiAgcGFyc2VTY29wZShzcGVjLCBzY29wZSwgc2lnbmFscyk7XG4gIHNjb3BlLm9wZXJhdG9ycy5wdXNoKHBhcmVudCk7XG5cbiAgLy8gYm91bmQgLyByZW5kZXIgLyBzaWV2ZSByb290IGl0ZW1cbiAgbGV0IG9wID0gc2NvcGUuYWRkKEJvdW5kKHtcbiAgICBtYXJrOiByb290LFxuICAgIHB1bHNlOiByZWYocGFyZW50KVxuICB9KSk7XG4gIG9wID0gc2NvcGUuYWRkKFJlbmRlcih7XG4gICAgcHVsc2U6IHJlZihvcClcbiAgfSkpO1xuICBvcCA9IHNjb3BlLmFkZChTaWV2ZSh7XG4gICAgcHVsc2U6IHJlZihvcClcbiAgfSkpO1xuXG4gIC8vIHRyYWNrIG1ldGFkYXRhIGZvciByb290IGl0ZW1cbiAgc2NvcGUuYWRkRGF0YSgncm9vdCcsIG5ldyBEYXRhU2NvcGUoc2NvcGUsIGlucHV0LCBpbnB1dCwgb3ApKTtcbiAgcmV0dXJuIHNjb3BlO1xufVxuZnVuY3Rpb24gc2lnbmFsT2JqZWN0KG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAmJiB2YWx1ZS5zaWduYWwgPyB7XG4gICAgbmFtZSxcbiAgICB1cGRhdGU6IHZhbHVlLnNpZ25hbFxuICB9IDoge1xuICAgIG5hbWUsXG4gICAgdmFsdWVcbiAgfTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IHRvcC1sZXZlbCBzaWduYWxzLCBtZXJnaW5nIHZhbHVlcyBhcyBuZWVkZWQuIFNpZ25hbHNcbiAqIGRlZmluZWQgaW4gdGhlIGNvbmZpZyBzaWduYWxzIGFycmF5cyBhcmUgYWRkZWQgb25seSBpZiB0aGF0XG4gKiBzaWduYWwgaXMgbm90IGV4cGxpY2l0bHkgZGVmaW5lZCBpbiB0aGUgc3BlY2lmaWNhdGlvbi5cbiAqIEJ1aWx0LWluIHNpZ25hbHMgKGF1dG9zaXplLCBiYWNrZ3JvdW5kLCBwYWRkaW5nLCB3aWR0aCwgaGVpZ2h0KVxuICogcmVjZWl2ZSBzcGVjaWFsIHRyZWF0bWVudC4gVGhleSBhcmUgaW5pdGlhbGl6ZWQgdXNpbmcgdGhlXG4gKiB0b3AtbGV2ZWwgc3BlYyBwcm9wZXJ0eSwgb3IsIGlmIHVuZGVmaW5lZCBpbiB0aGUgc3BlYywgdXNpbmdcbiAqIHRoZSBjb3JyZXNwb25kaW5nIHRvcC1sZXZlbCBjb25maWcgcHJvcGVydHkuIElmIHRoaXMgcHJvcGVydHlcbiAqIGlzIGEgc2lnbmFsIHJlZmVyZW5jZSBvYmplY3QsIHRoZSBzaWduYWwgZXhwcmVzc2lvbiBtYXBzIHRvIHRoZVxuICogc2lnbmFsICd1cGRhdGUnIHByb3BlcnR5LiBJZiB0aGUgc3BlYydzIHRvcC1sZXZlbCBzaWduYWwgYXJyYXlcbiAqIGNvbnRhaW5zIGFuIGVudHJ5IHRoYXQgbWF0Y2hlcyBhIGJ1aWx0LWluIHNpZ25hbCwgdGhhdCBlbnRyeVxuICogd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGUgYnVpbHQtaW4gc3BlY2lmaWNhdGlvbiwgcG90ZW50aWFsbHlcbiAqIG92ZXJ3cml0aW5nIGV4aXN0aW5nICd2YWx1ZScgb3IgJ3VwZGF0ZScgcHJvcGVydGllcy5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdFNpZ25hbHMoc3BlYywgY29uZmlnKSB7XG4gIGNvbnN0IF8gPSBuYW1lID0+IHZhbHVlKHNwZWNbbmFtZV0sIGNvbmZpZ1tuYW1lXSksXG4gICAgc2lnbmFscyA9IFtzaWduYWxPYmplY3QoJ2JhY2tncm91bmQnLCBfKCdiYWNrZ3JvdW5kJykpLCBzaWduYWxPYmplY3QoJ2F1dG9zaXplJywgcGFyc2VBdXRvc2l6ZShfKCdhdXRvc2l6ZScpKSksIHNpZ25hbE9iamVjdCgncGFkZGluZycsIHBhcnNlUGFkZGluZyhfKCdwYWRkaW5nJykpKSwgc2lnbmFsT2JqZWN0KCd3aWR0aCcsIF8oJ3dpZHRoJykgfHwgMCksIHNpZ25hbE9iamVjdCgnaGVpZ2h0JywgXygnaGVpZ2h0JykgfHwgMCldLFxuICAgIHByZSA9IHNpZ25hbHMucmVkdWNlKChwLCBzKSA9PiAocFtzLm5hbWVdID0gcywgcCksIHt9KSxcbiAgICBtYXAgPSB7fTtcblxuICAvLyBhZGQgc3BlYyBzaWduYWwgYXJyYXlcbiAgYXJyYXkoc3BlYy5zaWduYWxzKS5mb3JFYWNoKHMgPT4ge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShwcmUsIHMubmFtZSkpIHtcbiAgICAgIC8vIG1lcmdlIGlmIGJ1aWx0LWluIHNpZ25hbFxuICAgICAgcyA9IGV4dGVuZChwcmVbcy5uYW1lXSwgcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBhZGQgdG8gc2lnbmFsIGxpc3RcbiAgICAgIHNpZ25hbHMucHVzaChzKTtcbiAgICB9XG4gICAgbWFwW3MubmFtZV0gPSBzO1xuICB9KTtcblxuICAvLyBhZGQgY29uZmlnIHNpZ25hbCBhcnJheVxuICBhcnJheShjb25maWcuc2lnbmFscykuZm9yRWFjaChzID0+IHtcbiAgICBpZiAoIWhhc093blByb3BlcnR5KG1hcCwgcy5uYW1lKSAmJiAhaGFzT3duUHJvcGVydHkocHJlLCBzLm5hbWUpKSB7XG4gICAgICAvLyBhZGQgdG8gc2lnbmFsIGxpc3QgaWYgbm90IGFscmVhZHkgZGVmaW5lZFxuICAgICAgc2lnbmFscy5wdXNoKHMpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzaWduYWxzO1xufVxuXG5mdW5jdGlvbiBTY29wZShjb25maWcsIG9wdGlvbnMpIHtcbiAgdGhpcy5jb25maWcgPSBjb25maWcgfHwge307XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHRoaXMuYmluZGluZ3MgPSBbXTtcbiAgdGhpcy5maWVsZCA9IHt9O1xuICB0aGlzLnNpZ25hbHMgPSB7fTtcbiAgdGhpcy5sYW1iZGFzID0ge307XG4gIHRoaXMuc2NhbGVzID0ge307XG4gIHRoaXMuZXZlbnRzID0ge307XG4gIHRoaXMuZGF0YSA9IHt9O1xuICB0aGlzLnN0cmVhbXMgPSBbXTtcbiAgdGhpcy51cGRhdGVzID0gW107XG4gIHRoaXMub3BlcmF0b3JzID0gW107XG4gIHRoaXMuZXZlbnRDb25maWcgPSBudWxsO1xuICB0aGlzLmxvY2FsZSA9IG51bGw7XG4gIHRoaXMuX2lkID0gMDtcbiAgdGhpcy5fc3ViaWQgPSAwO1xuICB0aGlzLl9uZXh0c3ViID0gWzBdO1xuICB0aGlzLl9wYXJlbnQgPSBbXTtcbiAgdGhpcy5fZW5jb2RlID0gW107XG4gIHRoaXMuX2xvb2t1cCA9IFtdO1xuICB0aGlzLl9tYXJrcGF0aCA9IFtdO1xufVxuZnVuY3Rpb24gU3Vic2NvcGUoc2NvcGUpIHtcbiAgdGhpcy5jb25maWcgPSBzY29wZS5jb25maWc7XG4gIHRoaXMub3B0aW9ucyA9IHNjb3BlLm9wdGlvbnM7XG4gIHRoaXMubGVnZW5kcyA9IHNjb3BlLmxlZ2VuZHM7XG4gIHRoaXMuZmllbGQgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmZpZWxkKTtcbiAgdGhpcy5zaWduYWxzID0gT2JqZWN0LmNyZWF0ZShzY29wZS5zaWduYWxzKTtcbiAgdGhpcy5sYW1iZGFzID0gT2JqZWN0LmNyZWF0ZShzY29wZS5sYW1iZGFzKTtcbiAgdGhpcy5zY2FsZXMgPSBPYmplY3QuY3JlYXRlKHNjb3BlLnNjYWxlcyk7XG4gIHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShzY29wZS5ldmVudHMpO1xuICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKHNjb3BlLmRhdGEpO1xuICB0aGlzLnN0cmVhbXMgPSBbXTtcbiAgdGhpcy51cGRhdGVzID0gW107XG4gIHRoaXMub3BlcmF0b3JzID0gW107XG4gIHRoaXMuX2lkID0gMDtcbiAgdGhpcy5fc3ViaWQgPSArK3Njb3BlLl9uZXh0c3ViWzBdO1xuICB0aGlzLl9uZXh0c3ViID0gc2NvcGUuX25leHRzdWI7XG4gIHRoaXMuX3BhcmVudCA9IHNjb3BlLl9wYXJlbnQuc2xpY2UoKTtcbiAgdGhpcy5fZW5jb2RlID0gc2NvcGUuX2VuY29kZS5zbGljZSgpO1xuICB0aGlzLl9sb29rdXAgPSBzY29wZS5fbG9va3VwLnNsaWNlKCk7XG4gIHRoaXMuX21hcmtwYXRoID0gc2NvcGUuX21hcmtwYXRoO1xufVxuU2NvcGUucHJvdG90eXBlID0gU3Vic2NvcGUucHJvdG90eXBlID0ge1xuICBwYXJzZShzcGVjKSB7XG4gICAgcmV0dXJuIHBhcnNlU2NvcGUoc3BlYywgdGhpcyk7XG4gIH0sXG4gIGZvcmsoKSB7XG4gICAgcmV0dXJuIG5ldyBTdWJzY29wZSh0aGlzKTtcbiAgfSxcbiAgaXNTdWJzY29wZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ViaWQgPiAwO1xuICB9LFxuICB0b1J1bnRpbWUoKSB7XG4gICAgdGhpcy5maW5pc2goKTtcbiAgICByZXR1cm4ge1xuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBvcGVyYXRvcnM6IHRoaXMub3BlcmF0b3JzLFxuICAgICAgc3RyZWFtczogdGhpcy5zdHJlYW1zLFxuICAgICAgdXBkYXRlczogdGhpcy51cGRhdGVzLFxuICAgICAgYmluZGluZ3M6IHRoaXMuYmluZGluZ3MsXG4gICAgICBldmVudENvbmZpZzogdGhpcy5ldmVudENvbmZpZyxcbiAgICAgIGxvY2FsZTogdGhpcy5sb2NhbGVcbiAgICB9O1xuICB9LFxuICBpZCgpIHtcbiAgICByZXR1cm4gKHRoaXMuX3N1YmlkID8gdGhpcy5fc3ViaWQgKyAnOicgOiAwKSArIHRoaXMuX2lkKys7XG4gIH0sXG4gIGFkZChvcCkge1xuICAgIHRoaXMub3BlcmF0b3JzLnB1c2gob3ApO1xuICAgIG9wLmlkID0gdGhpcy5pZCgpO1xuICAgIC8vIGlmIHByZS1yZWdpc3RyYXRpb24gcmVmZXJlbmNlcyBleGlzdCwgcmVzb2x2ZSB0aGVtIG5vd1xuICAgIGlmIChvcC5yZWZzKSB7XG4gICAgICBvcC5yZWZzLmZvckVhY2gocmVmID0+IHtcbiAgICAgICAgcmVmLiRyZWYgPSBvcC5pZDtcbiAgICAgIH0pO1xuICAgICAgb3AucmVmcyA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBvcDtcbiAgfSxcbiAgcHJveHkob3ApIHtcbiAgICBjb25zdCB2cmVmID0gb3AgaW5zdGFuY2VvZiBFbnRyeSA/IHJlZihvcCkgOiBvcDtcbiAgICByZXR1cm4gdGhpcy5hZGQoUHJveHkoe1xuICAgICAgdmFsdWU6IHZyZWZcbiAgICB9KSk7XG4gIH0sXG4gIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLnN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgIHN0cmVhbS5pZCA9IHRoaXMuaWQoKTtcbiAgICByZXR1cm4gc3RyZWFtO1xuICB9LFxuICBhZGRVcGRhdGUodXBkYXRlKSB7XG4gICAgdGhpcy51cGRhdGVzLnB1c2godXBkYXRlKTtcbiAgICByZXR1cm4gdXBkYXRlO1xuICB9LFxuICAvLyBBcHBseSBtZXRhZGF0YVxuICBmaW5pc2goKSB7XG4gICAgbGV0IG5hbWUsIGRzO1xuXG4gICAgLy8gYW5ub3RhdGUgcm9vdFxuICAgIGlmICh0aGlzLnJvb3QpIHRoaXMucm9vdC5yb290ID0gdHJ1ZTtcblxuICAgIC8vIGFubm90YXRlIHNpZ25hbHNcbiAgICBmb3IgKG5hbWUgaW4gdGhpcy5zaWduYWxzKSB7XG4gICAgICB0aGlzLnNpZ25hbHNbbmFtZV0uc2lnbmFsID0gbmFtZTtcbiAgICB9XG5cbiAgICAvLyBhbm5vdGF0ZSBzY2FsZXNcbiAgICBmb3IgKG5hbWUgaW4gdGhpcy5zY2FsZXMpIHtcbiAgICAgIHRoaXMuc2NhbGVzW25hbWVdLnNjYWxlID0gbmFtZTtcbiAgICB9XG5cbiAgICAvLyBhbm5vdGF0ZSBkYXRhIHNldHNcbiAgICBmdW5jdGlvbiBhbm5vdGF0ZShvcCwgbmFtZSwgdHlwZSkge1xuICAgICAgbGV0IGRhdGEsIGxpc3Q7XG4gICAgICBpZiAob3ApIHtcbiAgICAgICAgZGF0YSA9IG9wLmRhdGEgfHwgKG9wLmRhdGEgPSB7fSk7XG4gICAgICAgIGxpc3QgPSBkYXRhW25hbWVdIHx8IChkYXRhW25hbWVdID0gW10pO1xuICAgICAgICBsaXN0LnB1c2godHlwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAobmFtZSBpbiB0aGlzLmRhdGEpIHtcbiAgICAgIGRzID0gdGhpcy5kYXRhW25hbWVdO1xuICAgICAgYW5ub3RhdGUoZHMuaW5wdXQsIG5hbWUsICdpbnB1dCcpO1xuICAgICAgYW5ub3RhdGUoZHMub3V0cHV0LCBuYW1lLCAnb3V0cHV0Jyk7XG4gICAgICBhbm5vdGF0ZShkcy52YWx1ZXMsIG5hbWUsICd2YWx1ZXMnKTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgaW4gZHMuaW5kZXgpIHtcbiAgICAgICAgYW5ub3RhdGUoZHMuaW5kZXhbZmllbGRdLCBuYW1lLCAnaW5kZXg6JyArIGZpZWxkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIC8vIC0tLS1cblxuICBwdXNoU3RhdGUoZW5jb2RlLCBwYXJlbnQsIGxvb2t1cCkge1xuICAgIHRoaXMuX2VuY29kZS5wdXNoKHJlZih0aGlzLmFkZChTaWV2ZSh7XG4gICAgICBwdWxzZTogZW5jb2RlXG4gICAgfSkpKSk7XG4gICAgdGhpcy5fcGFyZW50LnB1c2gocGFyZW50KTtcbiAgICB0aGlzLl9sb29rdXAucHVzaChsb29rdXAgPyByZWYodGhpcy5wcm94eShsb29rdXApKSA6IG51bGwpO1xuICAgIHRoaXMuX21hcmtwYXRoLnB1c2goLTEpO1xuICB9LFxuICBwb3BTdGF0ZSgpIHtcbiAgICB0aGlzLl9lbmNvZGUucG9wKCk7XG4gICAgdGhpcy5fcGFyZW50LnBvcCgpO1xuICAgIHRoaXMuX2xvb2t1cC5wb3AoKTtcbiAgICB0aGlzLl9tYXJrcGF0aC5wb3AoKTtcbiAgfSxcbiAgcGFyZW50KCkge1xuICAgIHJldHVybiBwZWVrKHRoaXMuX3BhcmVudCk7XG4gIH0sXG4gIGVuY29kZSgpIHtcbiAgICByZXR1cm4gcGVlayh0aGlzLl9lbmNvZGUpO1xuICB9LFxuICBsb29rdXAoKSB7XG4gICAgcmV0dXJuIHBlZWsodGhpcy5fbG9va3VwKTtcbiAgfSxcbiAgbWFya3BhdGgoKSB7XG4gICAgY29uc3QgcCA9IHRoaXMuX21hcmtwYXRoO1xuICAgIHJldHVybiArK3BbcC5sZW5ndGggLSAxXTtcbiAgfSxcbiAgLy8gLS0tLVxuXG4gIGZpZWxkUmVmKGZpZWxkLCBuYW1lKSB7XG4gICAgaWYgKGlzU3RyaW5nKGZpZWxkKSkgcmV0dXJuIGZpZWxkUmVmJDEoZmllbGQsIG5hbWUpO1xuICAgIGlmICghZmllbGQuc2lnbmFsKSB7XG4gICAgICBlcnJvcignVW5zdXBwb3J0ZWQgZmllbGQgcmVmZXJlbmNlOiAnICsgc3RyaW5nVmFsdWUoZmllbGQpKTtcbiAgICB9XG4gICAgY29uc3QgcyA9IGZpZWxkLnNpZ25hbDtcbiAgICBsZXQgZiA9IHRoaXMuZmllbGRbc107XG4gICAgaWYgKCFmKSB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgIG5hbWU6IHRoaXMuc2lnbmFsUmVmKHMpXG4gICAgICB9O1xuICAgICAgaWYgKG5hbWUpIHBhcmFtcy5hcyA9IG5hbWU7XG4gICAgICB0aGlzLmZpZWxkW3NdID0gZiA9IHJlZih0aGlzLmFkZChGaWVsZChwYXJhbXMpKSk7XG4gICAgfVxuICAgIHJldHVybiBmO1xuICB9LFxuICBjb21wYXJlUmVmKGNtcCkge1xuICAgIGxldCBzaWduYWwgPSBmYWxzZTtcbiAgICBjb25zdCBjaGVjayA9IF8gPT4gaXNTaWduYWwoXykgPyAoc2lnbmFsID0gdHJ1ZSwgdGhpcy5zaWduYWxSZWYoXy5zaWduYWwpKSA6IGlzRXhwciQxKF8pID8gKHNpZ25hbCA9IHRydWUsIHRoaXMuZXhwclJlZihfLmV4cHIpKSA6IF87XG4gICAgY29uc3QgZmllbGRzID0gYXJyYXkoY21wLmZpZWxkKS5tYXAoY2hlY2spLFxuICAgICAgb3JkZXJzID0gYXJyYXkoY21wLm9yZGVyKS5tYXAoY2hlY2spO1xuICAgIHJldHVybiBzaWduYWwgPyByZWYodGhpcy5hZGQoQ29tcGFyZSh7XG4gICAgICBmaWVsZHM6IGZpZWxkcyxcbiAgICAgIG9yZGVyczogb3JkZXJzXG4gICAgfSkpKSA6IGNvbXBhcmVSZWYoZmllbGRzLCBvcmRlcnMpO1xuICB9LFxuICBrZXlSZWYoZmllbGRzLCBmbGF0KSB7XG4gICAgbGV0IHNpZ25hbCA9IGZhbHNlO1xuICAgIGNvbnN0IGNoZWNrID0gXyA9PiBpc1NpZ25hbChfKSA/IChzaWduYWwgPSB0cnVlLCByZWYoc2lnW18uc2lnbmFsXSkpIDogXztcbiAgICBjb25zdCBzaWcgPSB0aGlzLnNpZ25hbHM7XG4gICAgZmllbGRzID0gYXJyYXkoZmllbGRzKS5tYXAoY2hlY2spO1xuICAgIHJldHVybiBzaWduYWwgPyByZWYodGhpcy5hZGQoS2V5KHtcbiAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgZmxhdDogZmxhdFxuICAgIH0pKSkgOiBrZXlSZWYoZmllbGRzLCBmbGF0KTtcbiAgfSxcbiAgc29ydFJlZihzb3J0KSB7XG4gICAgaWYgKCFzb3J0KSByZXR1cm4gc29ydDtcblxuICAgIC8vIGluY2x1ZGluZyBpZCBlbnN1cmVzIHN0YWJsZSBzb3J0aW5nXG4gICAgY29uc3QgYSA9IGFnZ3JGaWVsZChzb3J0Lm9wLCBzb3J0LmZpZWxkKSxcbiAgICAgIG8gPSBzb3J0Lm9yZGVyIHx8IEFzY2VuZGluZztcbiAgICByZXR1cm4gby5zaWduYWwgPyByZWYodGhpcy5hZGQoQ29tcGFyZSh7XG4gICAgICBmaWVsZHM6IGEsXG4gICAgICBvcmRlcnM6IHRoaXMuc2lnbmFsUmVmKG8uc2lnbmFsKVxuICAgIH0pKSkgOiBjb21wYXJlUmVmKGEsIG8pO1xuICB9LFxuICAvLyAtLS0tXG5cbiAgZXZlbnQoc291cmNlLCB0eXBlKSB7XG4gICAgY29uc3Qga2V5ID0gc291cmNlICsgJzonICsgdHlwZTtcbiAgICBpZiAoIXRoaXMuZXZlbnRzW2tleV0pIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5pZCgpO1xuICAgICAgdGhpcy5zdHJlYW1zLnB1c2goe1xuICAgICAgICBpZDogaWQsXG4gICAgICAgIHNvdXJjZTogc291cmNlLFxuICAgICAgICB0eXBlOiB0eXBlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZXZlbnRzW2tleV0gPSBpZDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZXZlbnRzW2tleV07XG4gIH0sXG4gIC8vIC0tLS1cblxuICBoYXNPd25TaWduYWwobmFtZSkge1xuICAgIHJldHVybiBoYXNPd25Qcm9wZXJ0eSh0aGlzLnNpZ25hbHMsIG5hbWUpO1xuICB9LFxuICBhZGRTaWduYWwobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5oYXNPd25TaWduYWwobmFtZSkpIHtcbiAgICAgIGVycm9yKCdEdXBsaWNhdGUgc2lnbmFsIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuICAgIGNvbnN0IG9wID0gdmFsdWUgaW5zdGFuY2VvZiBFbnRyeSA/IHZhbHVlIDogdGhpcy5hZGQob3BlcmF0b3IodmFsdWUpKTtcbiAgICByZXR1cm4gdGhpcy5zaWduYWxzW25hbWVdID0gb3A7XG4gIH0sXG4gIGdldFNpZ25hbChuYW1lKSB7XG4gICAgaWYgKCF0aGlzLnNpZ25hbHNbbmFtZV0pIHtcbiAgICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2lnbmFsIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNpZ25hbHNbbmFtZV07XG4gIH0sXG4gIHNpZ25hbFJlZihzKSB7XG4gICAgaWYgKHRoaXMuc2lnbmFsc1tzXSkge1xuICAgICAgcmV0dXJuIHJlZih0aGlzLnNpZ25hbHNbc10pO1xuICAgIH0gZWxzZSBpZiAoIWhhc093blByb3BlcnR5KHRoaXMubGFtYmRhcywgcykpIHtcbiAgICAgIHRoaXMubGFtYmRhc1tzXSA9IHRoaXMuYWRkKG9wZXJhdG9yKG51bGwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZih0aGlzLmxhbWJkYXNbc10pO1xuICB9LFxuICBwYXJzZUxhbWJkYXMoKSB7XG4gICAgY29uc3QgY29kZSA9IE9iamVjdC5rZXlzKHRoaXMubGFtYmRhcyk7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBjb2RlLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgcyA9IGNvZGVbaV0sXG4gICAgICAgIGUgPSBwYXJzZUV4cHJlc3Npb24ocywgdGhpcyksXG4gICAgICAgIG9wID0gdGhpcy5sYW1iZGFzW3NdO1xuICAgICAgb3AucGFyYW1zID0gZS4kcGFyYW1zO1xuICAgICAgb3AudXBkYXRlID0gZS4kZXhwcjtcbiAgICB9XG4gIH0sXG4gIHByb3BlcnR5KHNwZWMpIHtcbiAgICByZXR1cm4gc3BlYyAmJiBzcGVjLnNpZ25hbCA/IHRoaXMuc2lnbmFsUmVmKHNwZWMuc2lnbmFsKSA6IHNwZWM7XG4gIH0sXG4gIG9iamVjdFByb3BlcnR5KHNwZWMpIHtcbiAgICByZXR1cm4gIXNwZWMgfHwgIWlzT2JqZWN0KHNwZWMpID8gc3BlYyA6IHRoaXMuc2lnbmFsUmVmKHNwZWMuc2lnbmFsIHx8IHByb3BlcnR5TGFtYmRhKHNwZWMpKTtcbiAgfSxcbiAgZXhwclJlZihjb2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgZXhwcjogcGFyc2VFeHByZXNzaW9uKGNvZGUsIHRoaXMpXG4gICAgfTtcbiAgICBpZiAobmFtZSkgcGFyYW1zLmV4cHIuJG5hbWUgPSBuYW1lO1xuICAgIHJldHVybiByZWYodGhpcy5hZGQoRXhwcmVzc2lvbihwYXJhbXMpKSk7XG4gIH0sXG4gIGFkZEJpbmRpbmcobmFtZSwgYmluZCkge1xuICAgIGlmICghdGhpcy5iaW5kaW5ncykge1xuICAgICAgZXJyb3IoJ05lc3RlZCBzaWduYWxzIGRvIG5vdCBzdXBwb3J0IGJpbmRpbmc6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuICAgIHRoaXMuYmluZGluZ3MucHVzaChleHRlbmQoe1xuICAgICAgc2lnbmFsOiBuYW1lXG4gICAgfSwgYmluZCkpO1xuICB9LFxuICAvLyAtLS0tXG5cbiAgYWRkU2NhbGVQcm9qKG5hbWUsIHRyYW5zZm9ybSkge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh0aGlzLnNjYWxlcywgbmFtZSkpIHtcbiAgICAgIGVycm9yKCdEdXBsaWNhdGUgc2NhbGUgb3IgcHJvamVjdGlvbiBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cbiAgICB0aGlzLnNjYWxlc1tuYW1lXSA9IHRoaXMuYWRkKHRyYW5zZm9ybSk7XG4gIH0sXG4gIGFkZFNjYWxlKG5hbWUsIHBhcmFtcykge1xuICAgIHRoaXMuYWRkU2NhbGVQcm9qKG5hbWUsIFNjYWxlKHBhcmFtcykpO1xuICB9LFxuICBhZGRQcm9qZWN0aW9uKG5hbWUsIHBhcmFtcykge1xuICAgIHRoaXMuYWRkU2NhbGVQcm9qKG5hbWUsIFByb2plY3Rpb24ocGFyYW1zKSk7XG4gIH0sXG4gIGdldFNjYWxlKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuc2NhbGVzW25hbWVdKSB7XG4gICAgICBlcnJvcignVW5yZWNvZ25pemVkIHNjYWxlIG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnNjYWxlc1tuYW1lXTtcbiAgfSxcbiAgc2NhbGVSZWYobmFtZSkge1xuICAgIHJldHVybiByZWYodGhpcy5nZXRTY2FsZShuYW1lKSk7XG4gIH0sXG4gIHNjYWxlVHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2NhbGUobmFtZSkucGFyYW1zLnR5cGU7XG4gIH0sXG4gIHByb2plY3Rpb25SZWYobmFtZSkge1xuICAgIHJldHVybiB0aGlzLnNjYWxlUmVmKG5hbWUpO1xuICB9LFxuICBwcm9qZWN0aW9uVHlwZShuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NhbGVUeXBlKG5hbWUpO1xuICB9LFxuICAvLyAtLS0tXG5cbiAgYWRkRGF0YShuYW1lLCBkYXRhU2NvcGUpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkodGhpcy5kYXRhLCBuYW1lKSkge1xuICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhW25hbWVdID0gZGF0YVNjb3BlO1xuICB9LFxuICBnZXREYXRhKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuZGF0YVtuYW1lXSkge1xuICAgICAgZXJyb3IoJ1VuZGVmaW5lZCBkYXRhIHNldCBuYW1lOiAnICsgc3RyaW5nVmFsdWUobmFtZSkpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5kYXRhW25hbWVdO1xuICB9LFxuICBhZGREYXRhUGlwZWxpbmUobmFtZSwgZW50cmllcykge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh0aGlzLmRhdGEsIG5hbWUpKSB7XG4gICAgICBlcnJvcignRHVwbGljYXRlIGRhdGEgc2V0IG5hbWU6ICcgKyBzdHJpbmdWYWx1ZShuYW1lKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFkZERhdGEobmFtZSwgRGF0YVNjb3BlLmZyb21FbnRyaWVzKHRoaXMsIGVudHJpZXMpKTtcbiAgfVxufTtcbmZ1bmN0aW9uIHByb3BlcnR5TGFtYmRhKHNwZWMpIHtcbiAgcmV0dXJuIChpc0FycmF5KHNwZWMpID8gYXJyYXlMYW1iZGEgOiBvYmplY3RMYW1iZGEpKHNwZWMpO1xufVxuZnVuY3Rpb24gYXJyYXlMYW1iZGEoYXJyYXkpIHtcbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aDtcbiAgbGV0IGNvZGUgPSAnWyc7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgY29uc3QgdmFsdWUgPSBhcnJheVtpXTtcbiAgICBjb2RlICs9IChpID4gMCA/ICcsJyA6ICcnKSArIChpc09iamVjdCh2YWx1ZSkgPyB2YWx1ZS5zaWduYWwgfHwgcHJvcGVydHlMYW1iZGEodmFsdWUpIDogc3RyaW5nVmFsdWUodmFsdWUpKTtcbiAgfVxuICByZXR1cm4gY29kZSArICddJztcbn1cbmZ1bmN0aW9uIG9iamVjdExhbWJkYShvYmopIHtcbiAgbGV0IGNvZGUgPSAneycsXG4gICAgaSA9IDAsXG4gICAga2V5LFxuICAgIHZhbHVlO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICB2YWx1ZSA9IG9ialtrZXldO1xuICAgIGNvZGUgKz0gKCsraSA+IDEgPyAnLCcgOiAnJykgKyBzdHJpbmdWYWx1ZShrZXkpICsgJzonICsgKGlzT2JqZWN0KHZhbHVlKSA/IHZhbHVlLnNpZ25hbCB8fCBwcm9wZXJ0eUxhbWJkYSh2YWx1ZSkgOiBzdHJpbmdWYWx1ZSh2YWx1ZSkpO1xuICB9XG4gIHJldHVybiBjb2RlICsgJ30nO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkIGNvbmZpZ3VyYXRpb24gZGVmYXVsdHMgZm9yIFZlZ2Egc3BlY2lmaWNhdGlvbiBwYXJzaW5nLlxuICogVXNlcnMgY2FuIHByb3ZpZGUgdGhlaXIgb3duIChzdWItKXNldCBvZiB0aGVzZSBkZWZhdWx0IHZhbHVlc1xuICogYnkgcGFzc2luZyBpbiBhIGNvbmZpZyBvYmplY3QgdG8gdGhlIHRvcC1sZXZlbCBwYXJzZSBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHRzICgpIHtcbiAgY29uc3QgZGVmYXVsdEZvbnQgPSAnc2Fucy1zZXJpZicsXG4gICAgZGVmYXVsdFN5bWJvbFNpemUgPSAzMCxcbiAgICBkZWZhdWx0U3Ryb2tlV2lkdGggPSAyLFxuICAgIGRlZmF1bHRDb2xvciA9ICcjNGM3OGE4JyxcbiAgICBibGFjayA9ICcjMDAwJyxcbiAgICBncmF5ID0gJyM4ODgnLFxuICAgIGxpZ2h0R3JheSA9ICcjZGRkJztcbiAgcmV0dXJuIHtcbiAgICAvLyBkZWZhdWx0IHZpc3VhbGl6YXRpb24gZGVzY3JpcHRpb25cbiAgICBkZXNjcmlwdGlvbjogJ1ZlZ2EgdmlzdWFsaXphdGlvbicsXG4gICAgLy8gZGVmYXVsdCBwYWRkaW5nIGFyb3VuZCB2aXN1YWxpemF0aW9uXG4gICAgcGFkZGluZzogMCxcbiAgICAvLyBkZWZhdWx0IGZvciBhdXRvbWF0aWMgc2l6aW5nOyBvcHRpb25zOiAnbm9uZScsICdwYWQnLCAnZml0J1xuICAgIC8vIG9yIHByb3ZpZGUgYW4gb2JqZWN0IChlLmcuLCB7J3R5cGUnOiAncGFkJywgJ3Jlc2l6ZSc6IHRydWV9KVxuICAgIGF1dG9zaXplOiAncGFkJyxcbiAgICAvLyBkZWZhdWx0IHZpZXcgYmFja2dyb3VuZCBjb2xvclxuICAgIC8vIGNvdmVycyB0aGUgZW50aXJlIHZpZXcgY29tcG9uZW50XG4gICAgYmFja2dyb3VuZDogbnVsbCxcbiAgICAvLyBkZWZhdWx0IGV2ZW50IGhhbmRsaW5nIGNvbmZpZ3VyYXRpb25cbiAgICAvLyBwcmV2ZW50RGVmYXVsdCBmb3Igdmlldy1zb3VyY2VkIGV2ZW50IHR5cGVzIGV4Y2VwdCAnd2hlZWwnXG4gICAgZXZlbnRzOiB7XG4gICAgICBkZWZhdWx0czoge1xuICAgICAgICBhbGxvdzogWyd3aGVlbCddXG4gICAgICB9XG4gICAgfSxcbiAgICAvLyBkZWZhdWx0cyBmb3IgdG9wLWxldmVsIGdyb3VwIG1hcmtzXG4gICAgLy8gYWNjZXB0cyBtYXJrIHByb3BlcnRpZXMgKGZpbGwsIHN0cm9rZSwgZXRjKVxuICAgIC8vIGNvdmVycyB0aGUgZGF0YSByZWN0YW5nbGUgd2l0aGluIGdyb3VwIHdpZHRoL2hlaWdodFxuICAgIGdyb3VwOiBudWxsLFxuICAgIC8vIGRlZmF1bHRzIGZvciBiYXNpYyBtYXJrIHR5cGVzXG4gICAgLy8gZWFjaCBzdWJzZXQgYWNjZXB0cyBtYXJrIHByb3BlcnRpZXMgKGZpbGwsIHN0cm9rZSwgZXRjKVxuICAgIG1hcms6IG51bGwsXG4gICAgYXJjOiB7XG4gICAgICBmaWxsOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIGFyZWE6IHtcbiAgICAgIGZpbGw6IGRlZmF1bHRDb2xvclxuICAgIH0sXG4gICAgaW1hZ2U6IG51bGwsXG4gICAgbGluZToge1xuICAgICAgc3Ryb2tlOiBkZWZhdWx0Q29sb3IsXG4gICAgICBzdHJva2VXaWR0aDogZGVmYXVsdFN0cm9rZVdpZHRoXG4gICAgfSxcbiAgICBwYXRoOiB7XG4gICAgICBzdHJva2U6IGRlZmF1bHRDb2xvclxuICAgIH0sXG4gICAgcmVjdDoge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yXG4gICAgfSxcbiAgICBydWxlOiB7XG4gICAgICBzdHJva2U6IGJsYWNrXG4gICAgfSxcbiAgICBzaGFwZToge1xuICAgICAgc3Ryb2tlOiBkZWZhdWx0Q29sb3JcbiAgICB9LFxuICAgIHN5bWJvbDoge1xuICAgICAgZmlsbDogZGVmYXVsdENvbG9yLFxuICAgICAgc2l6ZTogNjRcbiAgICB9LFxuICAgIHRleHQ6IHtcbiAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICBmb250U2l6ZTogMTFcbiAgICB9LFxuICAgIHRyYWlsOiB7XG4gICAgICBmaWxsOiBkZWZhdWx0Q29sb3IsXG4gICAgICBzaXplOiBkZWZhdWx0U3Ryb2tlV2lkdGhcbiAgICB9LFxuICAgIC8vIHN0eWxlIGRlZmluaXRpb25zXG4gICAgc3R5bGU6IHtcbiAgICAgIC8vIGF4aXMgJiBsZWdlbmQgbGFiZWxzXG4gICAgICAnZ3VpZGUtbGFiZWwnOiB7XG4gICAgICAgIGZpbGw6IGJsYWNrLFxuICAgICAgICBmb250OiBkZWZhdWx0Rm9udCxcbiAgICAgICAgZm9udFNpemU6IDEwXG4gICAgICB9LFxuICAgICAgLy8gYXhpcyAmIGxlZ2VuZCB0aXRsZXNcbiAgICAgICdndWlkZS10aXRsZSc6IHtcbiAgICAgICAgZmlsbDogYmxhY2ssXG4gICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICBmb250U2l6ZTogMTEsXG4gICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJ1xuICAgICAgfSxcbiAgICAgIC8vIGhlYWRlcnMsIGluY2x1ZGluZyBjaGFydCB0aXRsZVxuICAgICAgJ2dyb3VwLXRpdGxlJzoge1xuICAgICAgICBmaWxsOiBibGFjayxcbiAgICAgICAgZm9udDogZGVmYXVsdEZvbnQsXG4gICAgICAgIGZvbnRTaXplOiAxMyxcbiAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnXG4gICAgICB9LFxuICAgICAgLy8gY2hhcnQgc3VidGl0bGVcbiAgICAgICdncm91cC1zdWJ0aXRsZSc6IHtcbiAgICAgICAgZmlsbDogYmxhY2ssXG4gICAgICAgIGZvbnQ6IGRlZmF1bHRGb250LFxuICAgICAgICBmb250U2l6ZTogMTJcbiAgICAgIH0sXG4gICAgICAvLyBkZWZhdWx0cyBmb3Igc3R5bGVkIHBvaW50IG1hcmtzIGluIFZlZ2EtTGl0ZVxuICAgICAgcG9pbnQ6IHtcbiAgICAgICAgc2l6ZTogZGVmYXVsdFN5bWJvbFNpemUsXG4gICAgICAgIHN0cm9rZVdpZHRoOiBkZWZhdWx0U3Ryb2tlV2lkdGgsXG4gICAgICAgIHNoYXBlOiAnY2lyY2xlJ1xuICAgICAgfSxcbiAgICAgIGNpcmNsZToge1xuICAgICAgICBzaXplOiBkZWZhdWx0U3ltYm9sU2l6ZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGRlZmF1bHRTdHJva2VXaWR0aFxuICAgICAgfSxcbiAgICAgIHNxdWFyZToge1xuICAgICAgICBzaXplOiBkZWZhdWx0U3ltYm9sU2l6ZSxcbiAgICAgICAgc3Ryb2tlV2lkdGg6IGRlZmF1bHRTdHJva2VXaWR0aCxcbiAgICAgICAgc2hhcGU6ICdzcXVhcmUnXG4gICAgICB9LFxuICAgICAgLy8gZGVmYXVsdHMgZm9yIHN0eWxlZCBncm91cCBtYXJrcyBpbiBWZWdhLUxpdGVcbiAgICAgIGNlbGw6IHtcbiAgICAgICAgZmlsbDogJ3RyYW5zcGFyZW50JyxcbiAgICAgICAgc3Ryb2tlOiBsaWdodEdyYXlcbiAgICAgIH0sXG4gICAgICB2aWV3OiB7XG4gICAgICAgIGZpbGw6ICd0cmFuc3BhcmVudCdcbiAgICAgIH1cbiAgICB9LFxuICAgIC8vIGRlZmF1bHRzIGZvciB0aXRsZVxuICAgIHRpdGxlOiB7XG4gICAgICBvcmllbnQ6ICd0b3AnLFxuICAgICAgYW5jaG9yOiAnbWlkZGxlJyxcbiAgICAgIG9mZnNldDogNCxcbiAgICAgIHN1YnRpdGxlUGFkZGluZzogM1xuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIGF4ZXNcbiAgICBheGlzOiB7XG4gICAgICBtaW5FeHRlbnQ6IDAsXG4gICAgICBtYXhFeHRlbnQ6IDIwMCxcbiAgICAgIGJhbmRQb3NpdGlvbjogMC41LFxuICAgICAgZG9tYWluOiB0cnVlLFxuICAgICAgZG9tYWluV2lkdGg6IDEsXG4gICAgICBkb21haW5Db2xvcjogZ3JheSxcbiAgICAgIGdyaWQ6IGZhbHNlLFxuICAgICAgZ3JpZFdpZHRoOiAxLFxuICAgICAgZ3JpZENvbG9yOiBsaWdodEdyYXksXG4gICAgICBsYWJlbHM6IHRydWUsXG4gICAgICBsYWJlbEFuZ2xlOiAwLFxuICAgICAgbGFiZWxMaW1pdDogMTgwLFxuICAgICAgbGFiZWxPZmZzZXQ6IDAsXG4gICAgICBsYWJlbFBhZGRpbmc6IDIsXG4gICAgICB0aWNrczogdHJ1ZSxcbiAgICAgIHRpY2tDb2xvcjogZ3JheSxcbiAgICAgIHRpY2tPZmZzZXQ6IDAsXG4gICAgICB0aWNrUm91bmQ6IHRydWUsXG4gICAgICB0aWNrU2l6ZTogNSxcbiAgICAgIHRpY2tXaWR0aDogMSxcbiAgICAgIHRpdGxlUGFkZGluZzogNFxuICAgIH0sXG4gICAgLy8gY29ycmVjdGlvbiBmb3IgY2VudGVyaW5nIGJpYXNcbiAgICBheGlzQmFuZDoge1xuICAgICAgdGlja09mZnNldDogLTAuNVxuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIGNhcnRvZ3JhcGhpYyBwcm9qZWN0aW9uXG4gICAgcHJvamVjdGlvbjoge1xuICAgICAgdHlwZTogJ21lcmNhdG9yJ1xuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIGxlZ2VuZHNcbiAgICBsZWdlbmQ6IHtcbiAgICAgIG9yaWVudDogJ3JpZ2h0JyxcbiAgICAgIHBhZGRpbmc6IDAsXG4gICAgICBncmlkQWxpZ246ICdlYWNoJyxcbiAgICAgIGNvbHVtblBhZGRpbmc6IDEwLFxuICAgICAgcm93UGFkZGluZzogMixcbiAgICAgIHN5bWJvbERpcmVjdGlvbjogJ3ZlcnRpY2FsJyxcbiAgICAgIGdyYWRpZW50RGlyZWN0aW9uOiAndmVydGljYWwnLFxuICAgICAgZ3JhZGllbnRMZW5ndGg6IDIwMCxcbiAgICAgIGdyYWRpZW50VGhpY2tuZXNzOiAxNixcbiAgICAgIGdyYWRpZW50U3Ryb2tlQ29sb3I6IGxpZ2h0R3JheSxcbiAgICAgIGdyYWRpZW50U3Ryb2tlV2lkdGg6IDAsXG4gICAgICBncmFkaWVudExhYmVsT2Zmc2V0OiAyLFxuICAgICAgbGFiZWxBbGlnbjogJ2xlZnQnLFxuICAgICAgbGFiZWxCYXNlbGluZTogJ21pZGRsZScsXG4gICAgICBsYWJlbExpbWl0OiAxNjAsXG4gICAgICBsYWJlbE9mZnNldDogNCxcbiAgICAgIGxhYmVsT3ZlcmxhcDogdHJ1ZSxcbiAgICAgIHN5bWJvbExpbWl0OiAzMCxcbiAgICAgIHN5bWJvbFR5cGU6ICdjaXJjbGUnLFxuICAgICAgc3ltYm9sU2l6ZTogMTAwLFxuICAgICAgc3ltYm9sT2Zmc2V0OiAwLFxuICAgICAgc3ltYm9sU3Ryb2tlV2lkdGg6IDEuNSxcbiAgICAgIHN5bWJvbEJhc2VGaWxsQ29sb3I6ICd0cmFuc3BhcmVudCcsXG4gICAgICBzeW1ib2xCYXNlU3Ryb2tlQ29sb3I6IGdyYXksXG4gICAgICB0aXRsZUxpbWl0OiAxODAsXG4gICAgICB0aXRsZU9yaWVudDogJ3RvcCcsXG4gICAgICB0aXRsZVBhZGRpbmc6IDUsXG4gICAgICBsYXlvdXQ6IHtcbiAgICAgICAgb2Zmc2V0OiAxOCxcbiAgICAgICAgZGlyZWN0aW9uOiAnaG9yaXpvbnRhbCcsXG4gICAgICAgIGxlZnQ6IHtcbiAgICAgICAgICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCdcbiAgICAgICAgfSxcbiAgICAgICAgcmlnaHQ6IHtcbiAgICAgICAgICBkaXJlY3Rpb246ICd2ZXJ0aWNhbCdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gZGVmYXVsdHMgZm9yIHNjYWxlIHJhbmdlc1xuICAgIHJhbmdlOiB7XG4gICAgICBjYXRlZ29yeToge1xuICAgICAgICBzY2hlbWU6ICd0YWJsZWF1MTAnXG4gICAgICB9LFxuICAgICAgb3JkaW5hbDoge1xuICAgICAgICBzY2hlbWU6ICdibHVlcydcbiAgICAgIH0sXG4gICAgICBoZWF0bWFwOiB7XG4gICAgICAgIHNjaGVtZTogJ3llbGxvd2dyZWVuYmx1ZSdcbiAgICAgIH0sXG4gICAgICByYW1wOiB7XG4gICAgICAgIHNjaGVtZTogJ2JsdWVzJ1xuICAgICAgfSxcbiAgICAgIGRpdmVyZ2luZzoge1xuICAgICAgICBzY2hlbWU6ICdibHVlb3JhbmdlJyxcbiAgICAgICAgZXh0ZW50OiBbMSwgMF1cbiAgICAgIH0sXG4gICAgICBzeW1ib2w6IFsnY2lyY2xlJywgJ3NxdWFyZScsICd0cmlhbmdsZS11cCcsICdjcm9zcycsICdkaWFtb25kJywgJ3RyaWFuZ2xlLXJpZ2h0JywgJ3RyaWFuZ2xlLWRvd24nLCAndHJpYW5nbGUtbGVmdCddXG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZSAoc3BlYywgY29uZmlnLCBvcHRpb25zKSB7XG4gIGlmICghaXNPYmplY3Qoc3BlYykpIHtcbiAgICBlcnJvcignSW5wdXQgVmVnYSBzcGVjaWZpY2F0aW9uIG11c3QgYmUgYW4gb2JqZWN0LicpO1xuICB9XG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKGRlZmF1bHRzKCksIGNvbmZpZywgc3BlYy5jb25maWcpO1xuICByZXR1cm4gcGFyc2VWaWV3KHNwZWMsIG5ldyBTY29wZShjb25maWcsIG9wdGlvbnMpKS50b1J1bnRpbWUoKTtcbn1cblxuZXhwb3J0IHsgQXhpc0RvbWFpblJvbGUsIEF4aXNHcmlkUm9sZSwgQXhpc0xhYmVsUm9sZSwgQXhpc1JvbGUsIEF4aXNUaWNrUm9sZSwgQXhpc1RpdGxlUm9sZSwgRGF0YVNjb3BlLCBGcmFtZVJvbGUsIExlZ2VuZEVudHJ5Um9sZSwgTGVnZW5kTGFiZWxSb2xlLCBMZWdlbmRSb2xlLCBMZWdlbmRTeW1ib2xSb2xlLCBMZWdlbmRUaXRsZVJvbGUsIE1hcmtSb2xlLCBTY29wZSwgU2NvcGVSb2xlLCBkZWZhdWx0cyBhcyBjb25maWcsIHBhcnNlLCBwYXJzZVNpZ25hbCBhcyBzaWduYWwsIHBhcnNlU2lnbmFsVXBkYXRlcyBhcyBzaWduYWxVcGRhdGVzLCBwYXJzZVN0cmVhbSBhcyBzdHJlYW0gfTtcbiIsImltcG9ydCB7IGdlb1BhdGgsIGdlb0FsYmVycywgZ2VvQWxiZXJzVXNhLCBnZW9BemltdXRoYWxFcXVhbEFyZWEsIGdlb0F6aW11dGhhbEVxdWlkaXN0YW50LCBnZW9Db25pY0NvbmZvcm1hbCwgZ2VvQ29uaWNFcXVhbEFyZWEsIGdlb0NvbmljRXF1aWRpc3RhbnQsIGdlb0VxdWFsRWFydGgsIGdlb0VxdWlyZWN0YW5ndWxhciwgZ2VvR25vbW9uaWMsIGdlb0lkZW50aXR5LCBnZW9NZXJjYXRvciwgZ2VvTmF0dXJhbEVhcnRoMSwgZ2VvT3J0aG9ncmFwaGljLCBnZW9TdGVyZW9ncmFwaGljLCBnZW9UcmFuc3ZlcnNlTWVyY2F0b3IgfSBmcm9tICdkMy1nZW8nO1xuaW1wb3J0IHsgZ2VvTW9sbHdlaWRlIH0gZnJvbSAnZDMtZ2VvLXByb2plY3Rpb24nO1xuaW1wb3J0IHsgcmVnaXN0ZXJTY2FsZSB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuXG5jb25zdCBkZWZhdWx0UGF0aCA9IGdlb1BhdGgoKTtcbmNvbnN0IHByb2plY3Rpb25Qcm9wZXJ0aWVzID0gW1xuLy8gc3RhbmRhcmQgcHJvcGVydGllcyBpbiBkMy1nZW9cbidjbGlwQW5nbGUnLCAnY2xpcEV4dGVudCcsICdzY2FsZScsICd0cmFuc2xhdGUnLCAnY2VudGVyJywgJ3JvdGF0ZScsICdwYXJhbGxlbHMnLCAncHJlY2lzaW9uJywgJ3JlZmxlY3RYJywgJ3JlZmxlY3RZJyxcbi8vIGV4dGVuZGVkIHByb3BlcnRpZXMgaW4gZDMtZ2VvLXByb2plY3Rpb25zXG4nY29lZmZpY2llbnQnLCAnZGlzdGFuY2UnLCAnZnJhY3Rpb24nLCAnbG9iZXMnLCAncGFyYWxsZWwnLCAncmFkaXVzJywgJ3JhdGlvJywgJ3NwYWNpbmcnLCAndGlsdCddO1xuXG4vKipcbiAqIEF1Z21lbnQgcHJvamVjdGlvbnMgd2l0aCB0aGVpciB0eXBlIGFuZCBhIGNvcHkgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBjcmVhdGUodHlwZSwgY29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHByb2plY3Rpb24oKSB7XG4gICAgY29uc3QgcCA9IGNvbnN0cnVjdG9yKCk7XG4gICAgcC50eXBlID0gdHlwZTtcbiAgICBwLnBhdGggPSBnZW9QYXRoKCkucHJvamVjdGlvbihwKTtcbiAgICBwLmNvcHkgPSBwLmNvcHkgfHwgZnVuY3Rpb24gKCkge1xuICAgICAgY29uc3QgYyA9IHByb2plY3Rpb24oKTtcbiAgICAgIHByb2plY3Rpb25Qcm9wZXJ0aWVzLmZvckVhY2gocHJvcCA9PiB7XG4gICAgICAgIGlmIChwW3Byb3BdKSBjW3Byb3BdKHBbcHJvcF0oKSk7XG4gICAgICB9KTtcbiAgICAgIGMucGF0aC5wb2ludFJhZGl1cyhwLnBhdGgucG9pbnRSYWRpdXMoKSk7XG4gICAgICByZXR1cm4gYztcbiAgICB9O1xuICAgIHJldHVybiByZWdpc3RlclNjYWxlKHApO1xuICB9O1xufVxuZnVuY3Rpb24gcHJvamVjdGlvbih0eXBlLCBwcm9qKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Byb2plY3Rpb24gdHlwZSBtdXN0IGJlIGEgbmFtZSBzdHJpbmcuJyk7XG4gIH1cbiAgdHlwZSA9IHR5cGUudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgcHJvamVjdGlvbnNbdHlwZV0gPSBjcmVhdGUodHlwZSwgcHJvaik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHByb2plY3Rpb25zW3R5cGVdIHx8IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFByb2plY3Rpb25QYXRoKHByb2opIHtcbiAgcmV0dXJuIHByb2ogJiYgcHJvai5wYXRoIHx8IGRlZmF1bHRQYXRoO1xufVxuY29uc3QgcHJvamVjdGlvbnMgPSB7XG4gIC8vIGJhc2UgZDMtZ2VvIHByb2plY3Rpb24gdHlwZXNcbiAgYWxiZXJzOiBnZW9BbGJlcnMsXG4gIGFsYmVyc3VzYTogZ2VvQWxiZXJzVXNhLFxuICBhemltdXRoYWxlcXVhbGFyZWE6IGdlb0F6aW11dGhhbEVxdWFsQXJlYSxcbiAgYXppbXV0aGFsZXF1aWRpc3RhbnQ6IGdlb0F6aW11dGhhbEVxdWlkaXN0YW50LFxuICBjb25pY2NvbmZvcm1hbDogZ2VvQ29uaWNDb25mb3JtYWwsXG4gIGNvbmljZXF1YWxhcmVhOiBnZW9Db25pY0VxdWFsQXJlYSxcbiAgY29uaWNlcXVpZGlzdGFudDogZ2VvQ29uaWNFcXVpZGlzdGFudCxcbiAgZXF1YWxFYXJ0aDogZ2VvRXF1YWxFYXJ0aCxcbiAgZXF1aXJlY3Rhbmd1bGFyOiBnZW9FcXVpcmVjdGFuZ3VsYXIsXG4gIGdub21vbmljOiBnZW9Hbm9tb25pYyxcbiAgaWRlbnRpdHk6IGdlb0lkZW50aXR5LFxuICBtZXJjYXRvcjogZ2VvTWVyY2F0b3IsXG4gIG1vbGx3ZWlkZTogZ2VvTW9sbHdlaWRlLFxuICBuYXR1cmFsRWFydGgxOiBnZW9OYXR1cmFsRWFydGgxLFxuICBvcnRob2dyYXBoaWM6IGdlb09ydGhvZ3JhcGhpYyxcbiAgc3RlcmVvZ3JhcGhpYzogZ2VvU3RlcmVvZ3JhcGhpYyxcbiAgdHJhbnN2ZXJzZW1lcmNhdG9yOiBnZW9UcmFuc3ZlcnNlTWVyY2F0b3Jcbn07XG5mb3IgKGNvbnN0IGtleSBpbiBwcm9qZWN0aW9ucykge1xuICBwcm9qZWN0aW9uKGtleSwgcHJvamVjdGlvbnNba2V5XSk7XG59XG5cbmV4cG9ydCB7IGdldFByb2plY3Rpb25QYXRoLCBwcm9qZWN0aW9uLCBwcm9qZWN0aW9uUHJvcGVydGllcyB9O1xuIiwiaW1wb3J0IHsgcmVncmVzc2lvbkxvZXNzLCBzYW1wbGVDdXJ2ZSwgcmVncmVzc2lvbkNvbnN0YW50LCByZWdyZXNzaW9uTGluZWFyLCByZWdyZXNzaW9uTG9nLCByZWdyZXNzaW9uRXhwLCByZWdyZXNzaW9uUG93LCByZWdyZXNzaW9uUXVhZCwgcmVncmVzc2lvblBvbHkgfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuaW1wb3J0IHsgVHJhbnNmb3JtLCBpbmdlc3QgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzLCBhY2Nlc3Nvck5hbWUsIGhhc093blByb3BlcnR5LCBlcnJvciwgZXh0ZW50IH0gZnJvbSAndmVnYS11dGlsJztcblxuZnVuY3Rpb24gcGFydGl0aW9uIChkYXRhLCBncm91cGJ5KSB7XG4gIHZhciBncm91cHMgPSBbXSxcbiAgICBnZXQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgcmV0dXJuIGYodCk7XG4gICAgfSxcbiAgICBtYXAsXG4gICAgaSxcbiAgICBuLFxuICAgIHQsXG4gICAgayxcbiAgICBnO1xuXG4gIC8vIHBhcnRpdGlvbiBkYXRhIHBvaW50cyBpbnRvIHN0YWNrIGdyb3Vwc1xuICBpZiAoZ3JvdXBieSA9PSBudWxsKSB7XG4gICAgZ3JvdXBzLnB1c2goZGF0YSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG4gICAgICBpZiAoIWcpIHtcbiAgICAgICAgbWFwW2tdID0gZyA9IFtdO1xuICAgICAgICBnLmRpbXMgPSBrO1xuICAgICAgICBncm91cHMucHVzaChnKTtcbiAgICAgIH1cbiAgICAgIGcucHVzaCh0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGdyb3Vwcztcbn1cblxuLyoqXG4gKiBDb21wdXRlIGxvY2FsbHktd2VpZ2h0ZWQgcmVncmVzc2lvbiBmaXRzIGZvciBvbmUgb3IgbW9yZSBkYXRhIGdyb3Vwcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMueCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgcHJlZGljdG9yIGRhdGEgZmllbGQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy55IC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBwcmVkaWN0ZWQgZGF0YSBmaWVsZC5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmJhbmR3aWR0aD0wLjNdIC0gVGhlIGxvZXNzIGJhbmR3aWR0aC5cbiAqL1xuZnVuY3Rpb24gTG9lc3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Mb2Vzcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdMb2VzcycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICd4JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAneScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYW5kd2lkdGgnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwLjNcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhMb2VzcywgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihzb3VyY2UsIF8uZ3JvdXBieSksXG4gICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIG0gPSBuYW1lcy5sZW5ndGgsXG4gICAgICAgIGFzID0gXy5hcyB8fCBbYWNjZXNzb3JOYW1lKF8ueCksIGFjY2Vzc29yTmFtZShfLnkpXSxcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICBncm91cHMuZm9yRWFjaChnID0+IHtcbiAgICAgICAgcmVncmVzc2lvbkxvZXNzKGcsIF8ueCwgXy55LCBfLmJhbmR3aWR0aCB8fCAwLjMpLmZvckVhY2gocCA9PiB7XG4gICAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICAgICAgICB0W25hbWVzW2ldXSA9IGcuZGltc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdFthc1swXV0gPSBwWzBdO1xuICAgICAgICAgIHRbYXNbMV1dID0gcFsxXTtcbiAgICAgICAgICB2YWx1ZXMucHVzaChpbmdlc3QodCkpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgICAgdGhpcy52YWx1ZSA9IG91dC5hZGQgPSBvdXQuc291cmNlID0gdmFsdWVzO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9XG59KTtcblxuY29uc3QgTWV0aG9kcyA9IHtcbiAgY29uc3RhbnQ6IHJlZ3Jlc3Npb25Db25zdGFudCxcbiAgbGluZWFyOiByZWdyZXNzaW9uTGluZWFyLFxuICBsb2c6IHJlZ3Jlc3Npb25Mb2csXG4gIGV4cDogcmVncmVzc2lvbkV4cCxcbiAgcG93OiByZWdyZXNzaW9uUG93LFxuICBxdWFkOiByZWdyZXNzaW9uUXVhZCxcbiAgcG9seTogcmVncmVzc2lvblBvbHlcbn07XG5jb25zdCBkZWdyZWVzT2ZGcmVlZG9tID0gKG1ldGhvZCwgb3JkZXIpID0+IG1ldGhvZCA9PT0gJ3BvbHknID8gb3JkZXIgOiBtZXRob2QgPT09ICdxdWFkJyA/IDIgOiAxO1xuXG4vKipcbiAqIENvbXB1dGUgcmVncmVzc2lvbiBmaXRzIGZvciBvbmUgb3IgbW9yZSBkYXRhIGdyb3Vwcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMueCAtIEFuIGFjY2Vzc29yIGZvciB0aGUgcHJlZGljdG9yIGRhdGEgZmllbGQuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy55IC0gQW4gYWNjZXNzb3IgZm9yIHRoZSBwcmVkaWN0ZWQgZGF0YSBmaWVsZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLm1ldGhvZD0nbGluZWFyJ10gLSBUaGUgcmVncmVzc2lvbiBtZXRob2QgdG8gYXBwbHkuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtwYXJhbXMuZXh0ZW50XSAtIFRoZSBkb21haW4gZXh0ZW50IG92ZXIgd2hpY2ggdG8gcGxvdCB0aGUgcmVncmVzc2lvbiBsaW5lLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMub3JkZXI9M10gLSBUaGUgcG9seW5vbWlhbCBvcmRlci4gT25seSBhcHBsaWVzIHRvIHRoZSAncG9seScgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBSZWdyZXNzaW9uKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuUmVncmVzc2lvbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdSZWdyZXNzaW9uJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3gnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ21ldGhvZCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdsaW5lYXInLFxuICAgICd2YWx1ZXMnOiBPYmplY3Qua2V5cyhNZXRob2RzKVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3JkZXInLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAzXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMlxuICB9LCB7XG4gICAgJ25hbWUnOiAncGFyYW1zJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IGZhbHNlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoUmVncmVzc2lvbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgICBpZiAoIXRoaXMudmFsdWUgfHwgcHVsc2UuY2hhbmdlZCgpIHx8IF8ubW9kaWZpZWQoKSkge1xuICAgICAgY29uc3Qgc291cmNlID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsXG4gICAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbihzb3VyY2UsIF8uZ3JvdXBieSksXG4gICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIG1ldGhvZCA9IF8ubWV0aG9kIHx8ICdsaW5lYXInLFxuICAgICAgICBvcmRlciA9IF8ub3JkZXIgPT0gbnVsbCA/IDMgOiBfLm9yZGVyLFxuICAgICAgICBkb2YgPSBkZWdyZWVzT2ZGcmVlZG9tKG1ldGhvZCwgb3JkZXIpLFxuICAgICAgICBhcyA9IF8uYXMgfHwgW2FjY2Vzc29yTmFtZShfLngpLCBhY2Nlc3Nvck5hbWUoXy55KV0sXG4gICAgICAgIGZpdCA9IE1ldGhvZHNbbWV0aG9kXSxcbiAgICAgICAgdmFsdWVzID0gW107XG4gICAgICBsZXQgZG9tYWluID0gXy5leHRlbnQ7XG4gICAgICBpZiAoIWhhc093blByb3BlcnR5KE1ldGhvZHMsIG1ldGhvZCkpIHtcbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcmVncmVzc2lvbiBtZXRob2Q6ICcgKyBtZXRob2QpO1xuICAgICAgfVxuICAgICAgaWYgKGRvbWFpbiAhPSBudWxsKSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdsb2cnICYmIGRvbWFpblswXSA8PSAwKSB7XG4gICAgICAgICAgcHVsc2UuZGF0YWZsb3cud2FybignSWdub3JpbmcgZXh0ZW50IHdpdGggdmFsdWVzIDw9IDAgZm9yIGxvZyByZWdyZXNzaW9uLicpO1xuICAgICAgICAgIGRvbWFpbiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGdyb3Vwcy5mb3JFYWNoKGcgPT4ge1xuICAgICAgICBjb25zdCBuID0gZy5sZW5ndGg7XG4gICAgICAgIGlmIChuIDw9IGRvZikge1xuICAgICAgICAgIHB1bHNlLmRhdGFmbG93Lndhcm4oJ1NraXBwaW5nIHJlZ3Jlc3Npb24gd2l0aCBtb3JlIHBhcmFtZXRlcnMgdGhhbiBkYXRhIHBvaW50cy4nKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbW9kZWwgPSBmaXQoZywgXy54LCBfLnksIG9yZGVyKTtcbiAgICAgICAgaWYgKF8ucGFyYW1zKSB7XG4gICAgICAgICAgLy8gaWYgcGFyYW1ldGVyIHZlY3RvcnMgcmVxdWVzdGVkIHJldHVybiB0aG9zZVxuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh7XG4gICAgICAgICAgICBrZXlzOiBnLmRpbXMsXG4gICAgICAgICAgICBjb2VmOiBtb2RlbC5jb2VmLFxuICAgICAgICAgICAgclNxdWFyZWQ6IG1vZGVsLnJTcXVhcmVkXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb20gPSBkb21haW4gfHwgZXh0ZW50KGcsIF8ueCksXG4gICAgICAgICAgYWRkID0gcCA9PiB7XG4gICAgICAgICAgICBjb25zdCB0ID0ge307XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIHRbbmFtZXNbaV1dID0gZy5kaW1zW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdFthc1swXV0gPSBwWzBdO1xuICAgICAgICAgICAgdFthc1sxXV0gPSBwWzFdO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgICAgICB9O1xuICAgICAgICBpZiAobWV0aG9kID09PSAnbGluZWFyJyB8fCBtZXRob2QgPT09ICdjb25zdGFudCcpIHtcbiAgICAgICAgICAvLyBmb3IgbGluZWFyIG9yIGNvbnN0YW50IHJlZ3Jlc3Npb24gd2Ugb25seSBuZWVkIHRoZSBlbmQgcG9pbnRzXG4gICAgICAgICAgZG9tLmZvckVhY2goeCA9PiBhZGQoW3gsIG1vZGVsLnByZWRpY3QoeCldKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIHJldHVybiB0cmVuZCBsaW5lIHNhbXBsZSBwb2ludHNcbiAgICAgICAgICBzYW1wbGVDdXJ2ZShtb2RlbC5wcmVkaWN0LCBkb20sIDI1LCAyMDApLmZvckVhY2goYWRkKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG5leHBvcnQgeyBMb2VzcyBhcyBsb2VzcywgUmVncmVzc2lvbiBhcyByZWdyZXNzaW9uIH07XG4iLCJpbXBvcnQgeyB0b1NldCwgc3RyaW5nVmFsdWUsIGVycm9yLCBpc0FycmF5LCBpc09iamVjdCwgaGFzT3duUHJvcGVydHksIGFjY2Vzc29yLCBrZXksIGZpZWxkLCBhcnJheSwgY29tcGFyZSwgdHJ1dGh5IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHR1cGxlaWQgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcblxuLyoqXG4gKiBQYXJzZSBhIHNlcmlhbGl6ZWQgZGF0YWZsb3cgc3BlY2lmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKHNwZWMpIHtcbiAgY29uc3QgY3R4ID0gdGhpcyxcbiAgICBvcGVyYXRvcnMgPSBzcGVjLm9wZXJhdG9ycyB8fCBbXTtcblxuICAvLyBwYXJzZSBiYWNrZ3JvdW5kXG4gIGlmIChzcGVjLmJhY2tncm91bmQpIHtcbiAgICBjdHguYmFja2dyb3VuZCA9IHNwZWMuYmFja2dyb3VuZDtcbiAgfVxuXG4gIC8vIHBhcnNlIGV2ZW50IGNvbmZpZ3VyYXRpb25cbiAgaWYgKHNwZWMuZXZlbnRDb25maWcpIHtcbiAgICBjdHguZXZlbnRDb25maWcgPSBzcGVjLmV2ZW50Q29uZmlnO1xuICB9XG5cbiAgLy8gcGFyc2UgbG9jYWxlIGNvbmZpZ3VyYXRpb25cbiAgaWYgKHNwZWMubG9jYWxlKSB7XG4gICAgY3R4LmxvY2FsZSA9IHNwZWMubG9jYWxlO1xuICB9XG5cbiAgLy8gcGFyc2Ugb3BlcmF0b3JzXG4gIG9wZXJhdG9ycy5mb3JFYWNoKGVudHJ5ID0+IGN0eC5wYXJzZU9wZXJhdG9yKGVudHJ5KSk7XG5cbiAgLy8gcGFyc2Ugb3BlcmF0b3IgcGFyYW1ldGVyc1xuICBvcGVyYXRvcnMuZm9yRWFjaChlbnRyeSA9PiBjdHgucGFyc2VPcGVyYXRvclBhcmFtZXRlcnMoZW50cnkpKTtcblxuICAvLyBwYXJzZSBzdHJlYW1zXG4gIChzcGVjLnN0cmVhbXMgfHwgW10pLmZvckVhY2goZW50cnkgPT4gY3R4LnBhcnNlU3RyZWFtKGVudHJ5KSk7XG5cbiAgLy8gcGFyc2UgdXBkYXRlc1xuICAoc3BlYy51cGRhdGVzIHx8IFtdKS5mb3JFYWNoKGVudHJ5ID0+IGN0eC5wYXJzZVVwZGF0ZShlbnRyeSkpO1xuICByZXR1cm4gY3R4LnJlc29sdmUoKTtcbn1cblxuY29uc3QgU2tpcCA9IHRvU2V0KFsncnVsZSddKSxcbiAgU3dhcCA9IHRvU2V0KFsnZ3JvdXAnLCAnaW1hZ2UnLCAncmVjdCddKTtcbmZ1bmN0aW9uIGFkanVzdFNwYXRpYWwoZW5jb2RlLCBtYXJrdHlwZSkge1xuICBsZXQgY29kZSA9ICcnO1xuICBpZiAoU2tpcFttYXJrdHlwZV0pIHJldHVybiBjb2RlO1xuICBpZiAoZW5jb2RlLngyKSB7XG4gICAgaWYgKGVuY29kZS54KSB7XG4gICAgICBpZiAoU3dhcFttYXJrdHlwZV0pIHtcbiAgICAgICAgY29kZSArPSAnaWYoby54Pm8ueDIpJD1vLngsby54PW8ueDIsby54Mj0kOyc7XG4gICAgICB9XG4gICAgICBjb2RlICs9ICdvLndpZHRoPW8ueDItby54Oyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvZGUgKz0gJ28ueD1vLngyLShvLndpZHRofHwwKTsnO1xuICAgIH1cbiAgfVxuICBpZiAoZW5jb2RlLnhjKSB7XG4gICAgY29kZSArPSAnby54PW8ueGMtKG8ud2lkdGh8fDApLzI7JztcbiAgfVxuICBpZiAoZW5jb2RlLnkyKSB7XG4gICAgaWYgKGVuY29kZS55KSB7XG4gICAgICBpZiAoU3dhcFttYXJrdHlwZV0pIHtcbiAgICAgICAgY29kZSArPSAnaWYoby55Pm8ueTIpJD1vLnksby55PW8ueTIsby55Mj0kOyc7XG4gICAgICB9XG4gICAgICBjb2RlICs9ICdvLmhlaWdodD1vLnkyLW8ueTsnO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb2RlICs9ICdvLnk9by55Mi0oby5oZWlnaHR8fDApOyc7XG4gICAgfVxuICB9XG4gIGlmIChlbmNvZGUueWMpIHtcbiAgICBjb2RlICs9ICdvLnk9by55Yy0oby5oZWlnaHR8fDApLzI7JztcbiAgfVxuICByZXR1cm4gY29kZTtcbn1cbmZ1bmN0aW9uIGNhbm9uaWNhbFR5cGUodHlwZSkge1xuICByZXR1cm4gKHR5cGUgKyAnJykudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIGlzT3BlcmF0b3IodHlwZSkge1xuICByZXR1cm4gY2Fub25pY2FsVHlwZSh0eXBlKSA9PT0gJ29wZXJhdG9yJztcbn1cbmZ1bmN0aW9uIGlzQ29sbGVjdCh0eXBlKSB7XG4gIHJldHVybiBjYW5vbmljYWxUeXBlKHR5cGUpID09PSAnY29sbGVjdCc7XG59XG5cbmZ1bmN0aW9uIGV4cHJlc3Npb24oY3R4LCBhcmdzLCBjb2RlKSB7XG4gIC8vIHdyYXAgY29kZSBpbiByZXR1cm4gc3RhdGVtZW50IGlmIGV4cHJlc3Npb24gZG9lcyBub3QgdGVybWluYXRlXG4gIGlmICghY29kZS5lbmRzV2l0aCgnOycpKSB7XG4gICAgY29kZSA9ICdyZXR1cm4oJyArIGNvZGUgKyAnKTsnO1xuICB9XG4gIGNvbnN0IGZuID0gRnVuY3Rpb24oLi4uYXJncy5jb25jYXQoY29kZSkpO1xuICByZXR1cm4gY3R4ICYmIGN0eC5mdW5jdGlvbnMgPyBmbi5iaW5kKGN0eC5mdW5jdGlvbnMpIDogZm47XG59XG5cbi8vIGdlbmVyYXRlIGNvZGUgZm9yIGNvbXBhcmluZyBhIHNpbmdsZSBmaWVsZFxuZnVuY3Rpb24gX2NvbXBhcmUodSwgdiwgbHQsIGd0KSB7XG4gIHJldHVybiBgKCh1ID0gJHt1fSkgPCAodiA9ICR7dn0pIHx8IHUgPT0gbnVsbCkgJiYgdiAhPSBudWxsID8gJHtsdH1cbiAgOiAodSA+IHYgfHwgdiA9PSBudWxsKSAmJiB1ICE9IG51bGwgPyAke2d0fVxuICA6ICgodiA9IHYgaW5zdGFuY2VvZiBEYXRlID8gK3YgOiB2KSwgKHUgPSB1IGluc3RhbmNlb2YgRGF0ZSA/ICt1IDogdSkpICE9PSB1ICYmIHYgPT09IHYgPyAke2x0fVxuICA6IHYgIT09IHYgJiYgdSA9PT0gdSA/ICR7Z3R9IDogYDtcbn1cbnZhciBleHByZXNzaW9uQ29kZWdlbiA9IHtcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gdXNlZCB0byB1cGRhdGUgYW4gb3BlcmF0b3IgdmFsdWUuXG4gICAqL1xuICBvcGVyYXRvcjogKGN0eCwgZXhwcikgPT4gZXhwcmVzc2lvbihjdHgsIFsnXyddLCBleHByLmNvZGUpLFxuICAvKipcbiAgICogUGFyc2UgYW4gZXhwcmVzc2lvbiBwcm92aWRlZCBhcyBhbiBvcGVyYXRvciBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqL1xuICBwYXJhbWV0ZXI6IChjdHgsIGV4cHIpID0+IGV4cHJlc3Npb24oY3R4LCBbJ2RhdHVtJywgJ18nXSwgZXhwci5jb2RlKSxcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gYXBwbGllZCB0byBhbiBldmVudCBzdHJlYW0uXG4gICAqL1xuICBldmVudDogKGN0eCwgZXhwcikgPT4gZXhwcmVzc2lvbihjdHgsIFsnZXZlbnQnXSwgZXhwci5jb2RlKSxcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gdXNlZCB0byBoYW5kbGUgYW4gZXZlbnQtZHJpdmVuIG9wZXJhdG9yIHVwZGF0ZS5cbiAgICovXG4gIGhhbmRsZXI6IChjdHgsIGV4cHIpID0+IHtcbiAgICBjb25zdCBjb2RlID0gYHZhciBkYXR1bT1ldmVudC5pdGVtJiZldmVudC5pdGVtLmRhdHVtO3JldHVybiAke2V4cHIuY29kZX07YDtcbiAgICByZXR1cm4gZXhwcmVzc2lvbihjdHgsIFsnXycsICdldmVudCddLCBjb2RlKTtcbiAgfSxcbiAgLyoqXG4gICAqIFBhcnNlIGFuIGV4cHJlc3Npb24gdGhhdCBwZXJmb3JtcyB2aXN1YWwgZW5jb2RpbmcuXG4gICAqL1xuICBlbmNvZGU6IChjdHgsIGVuY29kZSkgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcmt0eXBlLFxuICAgICAgY2hhbm5lbHNcbiAgICB9ID0gZW5jb2RlO1xuICAgIGxldCBjb2RlID0gJ3ZhciBvPWl0ZW0sZGF0dW09by5kYXR1bSxtPTAsJDsnO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBjaGFubmVscykge1xuICAgICAgY29uc3QgbyA9ICdvWycgKyBzdHJpbmdWYWx1ZShuYW1lKSArICddJztcbiAgICAgIGNvZGUgKz0gYCQ9JHtjaGFubmVsc1tuYW1lXS5jb2RlfTtpZigke299IT09JCkke299PSQsbT0xO2A7XG4gICAgfVxuICAgIGNvZGUgKz0gYWRqdXN0U3BhdGlhbChjaGFubmVscywgbWFya3R5cGUpO1xuICAgIGNvZGUgKz0gJ3JldHVybiBtOyc7XG4gICAgcmV0dXJuIGV4cHJlc3Npb24oY3R4LCBbJ2l0ZW0nLCAnXyddLCBjb2RlKTtcbiAgfSxcbiAgLyoqXG4gICAqIE9wdGltaXplZCBjb2RlIGdlbmVyYXRvcnMgZm9yIGFjY2VzcyBhbmQgY29tcGFyaXNvbi5cbiAgICovXG4gIGNvZGVnZW46IHtcbiAgICBnZXQocGF0aCkge1xuICAgICAgY29uc3QgcmVmID0gYFske3BhdGgubWFwKHN0cmluZ1ZhbHVlKS5qb2luKCddWycpfV1gO1xuICAgICAgY29uc3QgZ2V0ID0gRnVuY3Rpb24oJ18nLCBgcmV0dXJuIF8ke3JlZn07YCk7XG4gICAgICBnZXQucGF0aCA9IHJlZjtcbiAgICAgIHJldHVybiBnZXQ7XG4gICAgfSxcbiAgICBjb21wYXJhdG9yKGZpZWxkcywgb3JkZXJzKSB7XG4gICAgICBsZXQgdDtcbiAgICAgIGNvbnN0IG1hcCA9IChmLCBpKSA9PiB7XG4gICAgICAgIGNvbnN0IG8gPSBvcmRlcnNbaV07XG4gICAgICAgIGxldCB1LCB2O1xuICAgICAgICBpZiAoZi5wYXRoKSB7XG4gICAgICAgICAgdSA9IGBhJHtmLnBhdGh9YDtcbiAgICAgICAgICB2ID0gYGIke2YucGF0aH1gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICh0ID0gdCB8fCB7fSlbJ2YnICsgaV0gPSBmO1xuICAgICAgICAgIHUgPSBgdGhpcy5mJHtpfShhKWA7XG4gICAgICAgICAgdiA9IGB0aGlzLmYke2l9KGIpYDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2NvbXBhcmUodSwgdiwgLW8sIG8pO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGZuID0gRnVuY3Rpb24oJ2EnLCAnYicsICd2YXIgdSwgdjsgcmV0dXJuICcgKyBmaWVsZHMubWFwKG1hcCkuam9pbignJykgKyAnMDsnKTtcbiAgICAgIHJldHVybiB0ID8gZm4uYmluZCh0KSA6IGZuO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gKiBQYXJzZSBhIGRhdGFmbG93IG9wZXJhdG9yLlxuICovXG5mdW5jdGlvbiBwYXJzZU9wZXJhdG9yKHNwZWMpIHtcbiAgY29uc3QgY3R4ID0gdGhpcztcbiAgaWYgKGlzT3BlcmF0b3Ioc3BlYy50eXBlKSB8fCAhc3BlYy50eXBlKSB7XG4gICAgY3R4Lm9wZXJhdG9yKHNwZWMsIHNwZWMudXBkYXRlID8gY3R4Lm9wZXJhdG9yRXhwcmVzc2lvbihzcGVjLnVwZGF0ZSkgOiBudWxsKTtcbiAgfSBlbHNlIHtcbiAgICBjdHgudHJhbnNmb3JtKHNwZWMsIHNwZWMudHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhbmQgYXNzaWduIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlT3BlcmF0b3JQYXJhbWV0ZXJzKHNwZWMpIHtcbiAgY29uc3QgY3R4ID0gdGhpcztcbiAgaWYgKHNwZWMucGFyYW1zKSB7XG4gICAgY29uc3Qgb3AgPSBjdHguZ2V0KHNwZWMuaWQpO1xuICAgIGlmICghb3ApIGVycm9yKCdJbnZhbGlkIG9wZXJhdG9yIGlkOiAnICsgc3BlYy5pZCk7XG4gICAgY3R4LmRhdGFmbG93LmNvbm5lY3Qob3AsIG9wLnBhcmFtZXRlcnMoY3R4LnBhcnNlUGFyYW1ldGVycyhzcGVjLnBhcmFtcyksIHNwZWMucmVhY3QsIHNwZWMuaW5pdG9ubHkpKTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGEgc2V0IG9mIG9wZXJhdG9yIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlUGFyYW1ldGVycyhzcGVjLCBwYXJhbXMpIHtcbiAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICBjb25zdCBjdHggPSB0aGlzO1xuICBmb3IgKGNvbnN0IGtleSBpbiBzcGVjKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzcGVjW2tleV07XG4gICAgcGFyYW1zW2tleV0gPSBpc0FycmF5KHZhbHVlKSA/IHZhbHVlLm1hcCh2ID0+IHBhcnNlUGFyYW1ldGVyKHYsIGN0eCwgcGFyYW1zKSkgOiBwYXJzZVBhcmFtZXRlcih2YWx1ZSwgY3R4LCBwYXJhbXMpO1xuICB9XG4gIHJldHVybiBwYXJhbXM7XG59XG5cbi8qKlxuICogUGFyc2UgYSBzaW5nbGUgcGFyYW1ldGVyLlxuICovXG5mdW5jdGlvbiBwYXJzZVBhcmFtZXRlcihzcGVjLCBjdHgsIHBhcmFtcykge1xuICBpZiAoIXNwZWMgfHwgIWlzT2JqZWN0KHNwZWMpKSByZXR1cm4gc3BlYztcbiAgZm9yIChsZXQgaSA9IDAsIG4gPSBQQVJTRVJTLmxlbmd0aCwgcDsgaSA8IG47ICsraSkge1xuICAgIHAgPSBQQVJTRVJTW2ldO1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eShzcGVjLCBwLmtleSkpIHtcbiAgICAgIHJldHVybiBwLnBhcnNlKHNwZWMsIGN0eCwgcGFyYW1zKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNwZWM7XG59XG5cbi8qKiBSZWZlcmVuY2UgcGFyc2Vycy4gKi9cbnZhciBQQVJTRVJTID0gW3tcbiAga2V5OiAnJHJlZicsXG4gIHBhcnNlOiBnZXRPcGVyYXRvclxufSwge1xuICBrZXk6ICcka2V5JyxcbiAgcGFyc2U6IGdldEtleVxufSwge1xuICBrZXk6ICckZXhwcicsXG4gIHBhcnNlOiBnZXRFeHByZXNzaW9uXG59LCB7XG4gIGtleTogJyRmaWVsZCcsXG4gIHBhcnNlOiBnZXRGaWVsZFxufSwge1xuICBrZXk6ICckZW5jb2RlJyxcbiAgcGFyc2U6IGdldEVuY29kZVxufSwge1xuICBrZXk6ICckY29tcGFyZScsXG4gIHBhcnNlOiBnZXRDb21wYXJlXG59LCB7XG4gIGtleTogJyRjb250ZXh0JyxcbiAgcGFyc2U6IGdldENvbnRleHRcbn0sIHtcbiAga2V5OiAnJHN1YmZsb3cnLFxuICBwYXJzZTogZ2V0U3ViZmxvd1xufSwge1xuICBrZXk6ICckdHVwbGVpZCcsXG4gIHBhcnNlOiBnZXRUdXBsZUlkXG59XTtcblxuLyoqXG4gKiBSZXNvbHZlIGFuIG9wZXJhdG9yIHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0T3BlcmF0b3IoXywgY3R4KSB7XG4gIHJldHVybiBjdHguZ2V0KF8uJHJlZikgfHwgZXJyb3IoJ09wZXJhdG9yIG5vdCBkZWZpbmVkOiAnICsgXy4kcmVmKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGV4cHJlc3Npb24gcmVmZXJlbmNlLlxuICovXG5mdW5jdGlvbiBnZXRFeHByZXNzaW9uKF8sIGN0eCwgcGFyYW1zKSB7XG4gIGlmIChfLiRwYXJhbXMpIHtcbiAgICAvLyBwYXJzZSBleHByZXNzaW9uIHBhcmFtZXRlcnNcbiAgICBjdHgucGFyc2VQYXJhbWV0ZXJzKF8uJHBhcmFtcywgcGFyYW1zKTtcbiAgfVxuICBjb25zdCBrID0gJ2U6JyArIF8uJGV4cHIuY29kZTtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0gYWNjZXNzb3IoY3R4LnBhcmFtZXRlckV4cHJlc3Npb24oXy4kZXhwciksIF8uJGZpZWxkcykpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSBrZXkgYWNjZXNzb3IgcmVmZXJlbmNlLlxuICovXG5mdW5jdGlvbiBnZXRLZXkoXywgY3R4KSB7XG4gIGNvbnN0IGsgPSAnazonICsgXy4ka2V5ICsgJ18nICsgISFfLiRmbGF0O1xuICByZXR1cm4gY3R4LmZuW2tdIHx8IChjdHguZm5ba10gPSBrZXkoXy4ka2V5LCBfLiRmbGF0LCBjdHguZXhwci5jb2RlZ2VuKSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIGZpZWxkIGFjY2Vzc29yIHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGQoXywgY3R4KSB7XG4gIGlmICghXy4kZmllbGQpIHJldHVybiBudWxsO1xuICBjb25zdCBrID0gJ2Y6JyArIF8uJGZpZWxkICsgJ18nICsgXy4kbmFtZTtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0gZmllbGQoXy4kZmllbGQsIF8uJG5hbWUsIGN0eC5leHByLmNvZGVnZW4pKTtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgY29tcGFyYXRvciBmdW5jdGlvbiByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBhcmUoXywgY3R4KSB7XG4gIC8vIEFzIG9mIFZlZ2EgNS41LjMsICR0dXBsZWlkIHNvcnQgaXMgbm8gbG9uZ2VyIHVzZWQuXG4gIC8vIEtlZXAgaGVyZSBmb3Igbm93IGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgY29uc3QgayA9ICdjOicgKyBfLiRjb21wYXJlICsgJ18nICsgXy4kb3JkZXIsXG4gICAgYyA9IGFycmF5KF8uJGNvbXBhcmUpLm1hcChfID0+IF8gJiYgXy4kdHVwbGVpZCA/IHR1cGxlaWQgOiBfKTtcbiAgcmV0dXJuIGN0eC5mbltrXSB8fCAoY3R4LmZuW2tdID0gY29tcGFyZShjLCBfLiRvcmRlciwgY3R4LmV4cHIuY29kZWdlbikpO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYW4gZW5jb2RlIG9wZXJhdG9yIHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0RW5jb2RlKF8sIGN0eCkge1xuICBjb25zdCBzcGVjID0gXy4kZW5jb2RlLFxuICAgIGVuY29kZSA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gc3BlYykge1xuICAgIGNvbnN0IGVuYyA9IHNwZWNbbmFtZV07XG4gICAgZW5jb2RlW25hbWVdID0gYWNjZXNzb3IoY3R4LmVuY29kZUV4cHJlc3Npb24oZW5jLiRleHByKSwgZW5jLiRmaWVsZHMpO1xuICAgIGVuY29kZVtuYW1lXS5vdXRwdXQgPSBlbmMuJG91dHB1dDtcbiAgfVxuICByZXR1cm4gZW5jb2RlO1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSBjb250ZXh0IHJlZmVyZW5jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dChfLCBjdHgpIHtcbiAgcmV0dXJuIGN0eDtcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGEgcmVjdXJzaXZlIHN1YmZsb3cgc3BlY2lmaWNhdGlvbi5cbiAqL1xuZnVuY3Rpb24gZ2V0U3ViZmxvdyhfLCBjdHgpIHtcbiAgY29uc3Qgc3BlYyA9IF8uJHN1YmZsb3c7XG4gIHJldHVybiBmdW5jdGlvbiAoZGF0YWZsb3csIGtleSwgcGFyZW50KSB7XG4gICAgY29uc3Qgc3ViY3R4ID0gY3R4LmZvcmsoKS5wYXJzZShzcGVjKSxcbiAgICAgIG9wID0gc3ViY3R4LmdldChzcGVjLm9wZXJhdG9yc1swXS5pZCksXG4gICAgICBwID0gc3ViY3R4LnNpZ25hbHMucGFyZW50O1xuICAgIGlmIChwKSBwLnNldChwYXJlbnQpO1xuICAgIG9wLmRldGFjaFN1YmZsb3cgPSAoKSA9PiBjdHguZGV0YWNoKHN1YmN0eCk7XG4gICAgcmV0dXJuIG9wO1xuICB9O1xufVxuXG4vKipcbiAqIFJlc29sdmUgYSB0dXBsZSBpZCByZWZlcmVuY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFR1cGxlSWQoKSB7XG4gIHJldHVybiB0dXBsZWlkO1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIGV2ZW50IHN0cmVhbSBzcGVjaWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBwYXJzZVN0cmVhbSAoc3BlYykge1xuICB2YXIgY3R4ID0gdGhpcyxcbiAgICBmaWx0ZXIgPSBzcGVjLmZpbHRlciAhPSBudWxsID8gY3R4LmV2ZW50RXhwcmVzc2lvbihzcGVjLmZpbHRlcikgOiB1bmRlZmluZWQsXG4gICAgc3RyZWFtID0gc3BlYy5zdHJlYW0gIT0gbnVsbCA/IGN0eC5nZXQoc3BlYy5zdHJlYW0pIDogdW5kZWZpbmVkLFxuICAgIGFyZ3M7XG4gIGlmIChzcGVjLnNvdXJjZSkge1xuICAgIHN0cmVhbSA9IGN0eC5ldmVudHMoc3BlYy5zb3VyY2UsIHNwZWMudHlwZSwgZmlsdGVyKTtcbiAgfSBlbHNlIGlmIChzcGVjLm1lcmdlKSB7XG4gICAgYXJncyA9IHNwZWMubWVyZ2UubWFwKF8gPT4gY3R4LmdldChfKSk7XG4gICAgc3RyZWFtID0gYXJnc1swXS5tZXJnZS5hcHBseShhcmdzWzBdLCBhcmdzLnNsaWNlKDEpKTtcbiAgfVxuICBpZiAoc3BlYy5iZXR3ZWVuKSB7XG4gICAgYXJncyA9IHNwZWMuYmV0d2Vlbi5tYXAoXyA9PiBjdHguZ2V0KF8pKTtcbiAgICBzdHJlYW0gPSBzdHJlYW0uYmV0d2VlbihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgfVxuICBpZiAoc3BlYy5maWx0ZXIpIHtcbiAgICBzdHJlYW0gPSBzdHJlYW0uZmlsdGVyKGZpbHRlcik7XG4gIH1cbiAgaWYgKHNwZWMudGhyb3R0bGUgIT0gbnVsbCkge1xuICAgIHN0cmVhbSA9IHN0cmVhbS50aHJvdHRsZSgrc3BlYy50aHJvdHRsZSk7XG4gIH1cbiAgaWYgKHNwZWMuZGVib3VuY2UgIT0gbnVsbCkge1xuICAgIHN0cmVhbSA9IHN0cmVhbS5kZWJvdW5jZSgrc3BlYy5kZWJvdW5jZSk7XG4gIH1cbiAgaWYgKHN0cmVhbSA9PSBudWxsKSB7XG4gICAgZXJyb3IoJ0ludmFsaWQgc3RyZWFtIGRlZmluaXRpb246ICcgKyBKU09OLnN0cmluZ2lmeShzcGVjKSk7XG4gIH1cbiAgaWYgKHNwZWMuY29uc3VtZSkgc3RyZWFtLmNvbnN1bWUodHJ1ZSk7XG4gIGN0eC5zdHJlYW0oc3BlYywgc3RyZWFtKTtcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBldmVudC1kcml2ZW4gb3BlcmF0b3IgdXBkYXRlLlxuICovXG5mdW5jdGlvbiBwYXJzZVVwZGF0ZSAoc3BlYykge1xuICB2YXIgY3R4ID0gdGhpcyxcbiAgICBzcmNpZCA9IGlzT2JqZWN0KHNyY2lkID0gc3BlYy5zb3VyY2UpID8gc3JjaWQuJHJlZiA6IHNyY2lkLFxuICAgIHNvdXJjZSA9IGN0eC5nZXQoc3JjaWQpLFxuICAgIHRhcmdldCA9IG51bGwsXG4gICAgdXBkYXRlID0gc3BlYy51cGRhdGUsXG4gICAgcGFyYW1zID0gdW5kZWZpbmVkO1xuICBpZiAoIXNvdXJjZSkgZXJyb3IoJ1NvdXJjZSBub3QgZGVmaW5lZDogJyArIHNwZWMuc291cmNlKTtcbiAgdGFyZ2V0ID0gc3BlYy50YXJnZXQgJiYgc3BlYy50YXJnZXQuJGV4cHIgPyBjdHguZXZlbnRFeHByZXNzaW9uKHNwZWMudGFyZ2V0LiRleHByKSA6IGN0eC5nZXQoc3BlYy50YXJnZXQpO1xuICBpZiAodXBkYXRlICYmIHVwZGF0ZS4kZXhwcikge1xuICAgIGlmICh1cGRhdGUuJHBhcmFtcykge1xuICAgICAgcGFyYW1zID0gY3R4LnBhcnNlUGFyYW1ldGVycyh1cGRhdGUuJHBhcmFtcyk7XG4gICAgfVxuICAgIHVwZGF0ZSA9IGN0eC5oYW5kbGVyRXhwcmVzc2lvbih1cGRhdGUuJGV4cHIpO1xuICB9XG4gIGN0eC51cGRhdGUoc3BlYywgc291cmNlLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zKTtcbn1cblxuY29uc3QgU0tJUCA9IHtcbiAgc2tpcDogdHJ1ZVxufTtcbmZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgdmFyIGN0eCA9IHRoaXMsXG4gICAgc3RhdGUgPSB7fTtcbiAgaWYgKG9wdGlvbnMuc2lnbmFscykge1xuICAgIHZhciBzaWduYWxzID0gc3RhdGUuc2lnbmFscyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGN0eC5zaWduYWxzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICBjb25zdCBvcCA9IGN0eC5zaWduYWxzW2tleV07XG4gICAgICBpZiAob3B0aW9ucy5zaWduYWxzKGtleSwgb3ApKSB7XG4gICAgICAgIHNpZ25hbHNba2V5XSA9IG9wLnZhbHVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGlmIChvcHRpb25zLmRhdGEpIHtcbiAgICB2YXIgZGF0YSA9IHN0YXRlLmRhdGEgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhjdHguZGF0YSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgY29uc3QgZGF0YXNldCA9IGN0eC5kYXRhW2tleV07XG4gICAgICBpZiAob3B0aW9ucy5kYXRhKGtleSwgZGF0YXNldCkpIHtcbiAgICAgICAgZGF0YVtrZXldID0gZGF0YXNldC5pbnB1dC52YWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBpZiAoY3R4LnN1YmNvbnRleHQgJiYgb3B0aW9ucy5yZWN1cnNlICE9PSBmYWxzZSkge1xuICAgIHN0YXRlLnN1YmNvbnRleHQgPSBjdHguc3ViY29udGV4dC5tYXAoY3R4ID0+IGN0eC5nZXRTdGF0ZShvcHRpb25zKSk7XG4gIH1cbiAgcmV0dXJuIHN0YXRlO1xufVxuZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgdmFyIGN0eCA9IHRoaXMsXG4gICAgZGYgPSBjdHguZGF0YWZsb3csXG4gICAgZGF0YSA9IHN0YXRlLmRhdGEsXG4gICAgc2lnbmFscyA9IHN0YXRlLnNpZ25hbHM7XG4gIE9iamVjdC5rZXlzKHNpZ25hbHMgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICBkZi51cGRhdGUoY3R4LnNpZ25hbHNba2V5XSwgc2lnbmFsc1trZXldLCBTS0lQKTtcbiAgfSk7XG4gIE9iamVjdC5rZXlzKGRhdGEgfHwge30pLmZvckVhY2goa2V5ID0+IHtcbiAgICBkZi5wdWxzZShjdHguZGF0YVtrZXldLmlucHV0LCBkZi5jaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQoZGF0YVtrZXldKSk7XG4gIH0pO1xuICAoc3RhdGUuc3ViY29udGV4dCB8fCBbXSkuZm9yRWFjaCgoc3Vic3RhdGUsIGkpID0+IHtcbiAgICBjb25zdCBzdWJjdHggPSBjdHguc3ViY29udGV4dFtpXTtcbiAgICBpZiAoc3ViY3R4KSBzdWJjdHguc2V0U3RhdGUoc3Vic3RhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb250ZXh0IG9iamVjdHMgc3RvcmUgdGhlIGN1cnJlbnQgcGFyc2Ugc3RhdGUuXG4gKiBFbmFibGVzIGxvb2t1cCBvZiBwYXJzZWQgb3BlcmF0b3JzLCBldmVudCBzdHJlYW1zLCBhY2Nlc3NvcnMsIGV0Yy5cbiAqIFByb3ZpZGVzIGEgJ2ZvcmsnIG1ldGhvZCBmb3IgY3JlYXRpbmcgY2hpbGQgY29udGV4dHMgZm9yIHN1YmZsb3dzLlxuICovXG5mdW5jdGlvbiBjb250ZXh0IChkZiwgdHJhbnNmb3JtcywgZnVuY3Rpb25zLCBleHByKSB7XG4gIHJldHVybiBuZXcgQ29udGV4dChkZiwgdHJhbnNmb3JtcywgZnVuY3Rpb25zLCBleHByKTtcbn1cbmZ1bmN0aW9uIENvbnRleHQoZGYsIHRyYW5zZm9ybXMsIGZ1bmN0aW9ucywgZXhwcikge1xuICB0aGlzLmRhdGFmbG93ID0gZGY7XG4gIHRoaXMudHJhbnNmb3JtcyA9IHRyYW5zZm9ybXM7XG4gIHRoaXMuZXZlbnRzID0gZGYuZXZlbnRzLmJpbmQoZGYpO1xuICB0aGlzLmV4cHIgPSBleHByIHx8IGV4cHJlc3Npb25Db2RlZ2VuLCB0aGlzLnNpZ25hbHMgPSB7fTtcbiAgdGhpcy5zY2FsZXMgPSB7fTtcbiAgdGhpcy5ub2RlcyA9IHt9O1xuICB0aGlzLmRhdGEgPSB7fTtcbiAgdGhpcy5mbiA9IHt9O1xuICBpZiAoZnVuY3Rpb25zKSB7XG4gICAgdGhpcy5mdW5jdGlvbnMgPSBPYmplY3QuY3JlYXRlKGZ1bmN0aW9ucyk7XG4gICAgdGhpcy5mdW5jdGlvbnMuY29udGV4dCA9IHRoaXM7XG4gIH1cbn1cbmZ1bmN0aW9uIFN1YmNvbnRleHQoY3R4KSB7XG4gIHRoaXMuZGF0YWZsb3cgPSBjdHguZGF0YWZsb3c7XG4gIHRoaXMudHJhbnNmb3JtcyA9IGN0eC50cmFuc2Zvcm1zO1xuICB0aGlzLmV2ZW50cyA9IGN0eC5ldmVudHM7XG4gIHRoaXMuZXhwciA9IGN0eC5leHByO1xuICB0aGlzLnNpZ25hbHMgPSBPYmplY3QuY3JlYXRlKGN0eC5zaWduYWxzKTtcbiAgdGhpcy5zY2FsZXMgPSBPYmplY3QuY3JlYXRlKGN0eC5zY2FsZXMpO1xuICB0aGlzLm5vZGVzID0gT2JqZWN0LmNyZWF0ZShjdHgubm9kZXMpO1xuICB0aGlzLmRhdGEgPSBPYmplY3QuY3JlYXRlKGN0eC5kYXRhKTtcbiAgdGhpcy5mbiA9IE9iamVjdC5jcmVhdGUoY3R4LmZuKTtcbiAgaWYgKGN0eC5mdW5jdGlvbnMpIHtcbiAgICB0aGlzLmZ1bmN0aW9ucyA9IE9iamVjdC5jcmVhdGUoY3R4LmZ1bmN0aW9ucyk7XG4gICAgdGhpcy5mdW5jdGlvbnMuY29udGV4dCA9IHRoaXM7XG4gIH1cbn1cbkNvbnRleHQucHJvdG90eXBlID0gU3ViY29udGV4dC5wcm90b3R5cGUgPSB7XG4gIGZvcmsoKSB7XG4gICAgY29uc3QgY3R4ID0gbmV3IFN1YmNvbnRleHQodGhpcyk7XG4gICAgKHRoaXMuc3ViY29udGV4dCB8fCAodGhpcy5zdWJjb250ZXh0ID0gW10pKS5wdXNoKGN0eCk7XG4gICAgcmV0dXJuIGN0eDtcbiAgfSxcbiAgZGV0YWNoKGN0eCkge1xuICAgIHRoaXMuc3ViY29udGV4dCA9IHRoaXMuc3ViY29udGV4dC5maWx0ZXIoYyA9PiBjICE9PSBjdHgpO1xuXG4gICAgLy8gZGlzY29ubmVjdCBhbGwgbm9kZXMgaW4gdGhlIHN1YmNvbnRleHRcbiAgICAvLyB3aXBlIG91dCB0YXJnZXRzIGZpcnN0IGZvciBiZXR0ZXIgZWZmaWNpZW5jeVxuICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhjdHgubm9kZXMpO1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIGN0eC5ub2Rlc1trZXldLl90YXJnZXRzID0gbnVsbDtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSBjdHgubm9kZXNba2V5XS5kZXRhY2goKTtcbiAgICBjdHgubm9kZXMgPSBudWxsO1xuICB9LFxuICBnZXQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5ub2Rlc1tpZF07XG4gIH0sXG4gIHNldChpZCwgbm9kZSkge1xuICAgIHJldHVybiB0aGlzLm5vZGVzW2lkXSA9IG5vZGU7XG4gIH0sXG4gIGFkZChzcGVjLCBvcCkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMsXG4gICAgICBkZiA9IGN0eC5kYXRhZmxvdyxcbiAgICAgIGRhdGEgPSBzcGVjLnZhbHVlO1xuICAgIGN0eC5zZXQoc3BlYy5pZCwgb3ApO1xuICAgIGlmIChpc0NvbGxlY3Qoc3BlYy50eXBlKSAmJiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YS4kaW5nZXN0KSB7XG4gICAgICAgIGRmLmluZ2VzdChvcCwgZGF0YS4kaW5nZXN0LCBkYXRhLiRmb3JtYXQpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLiRyZXF1ZXN0KSB7XG4gICAgICAgIGRmLnByZWxvYWQob3AsIGRhdGEuJHJlcXVlc3QsIGRhdGEuJGZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZi5wdWxzZShvcCwgZGYuY2hhbmdlc2V0KCkuaW5zZXJ0KGRhdGEpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNwZWMucm9vdCkge1xuICAgICAgY3R4LnJvb3QgPSBvcDtcbiAgICB9XG4gICAgaWYgKHNwZWMucGFyZW50KSB7XG4gICAgICBsZXQgcCA9IGN0eC5nZXQoc3BlYy5wYXJlbnQuJHJlZik7XG4gICAgICBpZiAocCkge1xuICAgICAgICBkZi5jb25uZWN0KHAsIFtvcF0pO1xuICAgICAgICBvcC50YXJnZXRzKCkuYWRkKHApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKGN0eC51bnJlc29sdmVkID0gY3R4LnVucmVzb2x2ZWQgfHwgW10pLnB1c2goKCkgPT4ge1xuICAgICAgICAgIHAgPSBjdHguZ2V0KHNwZWMucGFyZW50LiRyZWYpO1xuICAgICAgICAgIGRmLmNvbm5lY3QocCwgW29wXSk7XG4gICAgICAgICAgb3AudGFyZ2V0cygpLmFkZChwKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChzcGVjLnNpZ25hbCkge1xuICAgICAgY3R4LnNpZ25hbHNbc3BlYy5zaWduYWxdID0gb3A7XG4gICAgfVxuICAgIGlmIChzcGVjLnNjYWxlKSB7XG4gICAgICBjdHguc2NhbGVzW3NwZWMuc2NhbGVdID0gb3A7XG4gICAgfVxuICAgIGlmIChzcGVjLmRhdGEpIHtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBzcGVjLmRhdGEpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IGN0eC5kYXRhW25hbWVdIHx8IChjdHguZGF0YVtuYW1lXSA9IHt9KTtcbiAgICAgICAgc3BlYy5kYXRhW25hbWVdLmZvckVhY2gocm9sZSA9PiBkYXRhW3JvbGVdID0gb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgcmVzb2x2ZSgpIHtcbiAgICAodGhpcy51bnJlc29sdmVkIHx8IFtdKS5mb3JFYWNoKGZuID0+IGZuKCkpO1xuICAgIGRlbGV0ZSB0aGlzLnVucmVzb2x2ZWQ7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIG9wZXJhdG9yKHNwZWMsIHVwZGF0ZSkge1xuICAgIHRoaXMuYWRkKHNwZWMsIHRoaXMuZGF0YWZsb3cuYWRkKHNwZWMudmFsdWUsIHVwZGF0ZSkpO1xuICB9LFxuICB0cmFuc2Zvcm0oc3BlYywgdHlwZSkge1xuICAgIHRoaXMuYWRkKHNwZWMsIHRoaXMuZGF0YWZsb3cuYWRkKHRoaXMudHJhbnNmb3Jtc1tjYW5vbmljYWxUeXBlKHR5cGUpXSkpO1xuICB9LFxuICBzdHJlYW0oc3BlYywgc3RyZWFtKSB7XG4gICAgdGhpcy5zZXQoc3BlYy5pZCwgc3RyZWFtKTtcbiAgfSxcbiAgdXBkYXRlKHNwZWMsIHN0cmVhbSwgdGFyZ2V0LCB1cGRhdGUsIHBhcmFtcykge1xuICAgIHRoaXMuZGF0YWZsb3cub24oc3RyZWFtLCB0YXJnZXQsIHVwZGF0ZSwgcGFyYW1zLCBzcGVjLm9wdGlvbnMpO1xuICB9LFxuICAvLyBleHByZXNzaW9uIHBhcnNpbmdcbiAgb3BlcmF0b3JFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLm9wZXJhdG9yKHRoaXMsIGV4cHIpO1xuICB9LFxuICBwYXJhbWV0ZXJFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLnBhcmFtZXRlcih0aGlzLCBleHByKTtcbiAgfSxcbiAgZXZlbnRFeHByZXNzaW9uKGV4cHIpIHtcbiAgICByZXR1cm4gdGhpcy5leHByLmV2ZW50KHRoaXMsIGV4cHIpO1xuICB9LFxuICBoYW5kbGVyRXhwcmVzc2lvbihleHByKSB7XG4gICAgcmV0dXJuIHRoaXMuZXhwci5oYW5kbGVyKHRoaXMsIGV4cHIpO1xuICB9LFxuICBlbmNvZGVFeHByZXNzaW9uKGVuY29kZSkge1xuICAgIHJldHVybiB0aGlzLmV4cHIuZW5jb2RlKHRoaXMsIGVuY29kZSk7XG4gIH0sXG4gIC8vIHBhcnNlIG1ldGhvZHNcbiAgcGFyc2UsXG4gIHBhcnNlT3BlcmF0b3IsXG4gIHBhcnNlT3BlcmF0b3JQYXJhbWV0ZXJzLFxuICBwYXJzZVBhcmFtZXRlcnMsXG4gIHBhcnNlU3RyZWFtLFxuICBwYXJzZVVwZGF0ZSxcbiAgLy8gc3RhdGUgbWV0aG9kc1xuICBnZXRTdGF0ZSxcbiAgc2V0U3RhdGVcbn07XG5cbmV4cG9ydCB7IGNvbnRleHQgfTtcbiIsImltcG9ydCB7IHRvTnVtYmVyLCBwZWVrLCB0b1NldCwgYXJyYXksIGNvbnN0YW50LCBpc0FycmF5LCBpc051bWJlciwgc3BhbiwgaXNPYmplY3QsIGlzU3RyaW5nLCBlcnJvciB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBiaXNlY3RSaWdodCwgcmFuZ2UsIGJpc2VjdCB9IGZyb20gJ2QzLWFycmF5JztcbmltcG9ydCAqIGFzICQgZnJvbSAnZDMtc2NhbGUnO1xuaW1wb3J0IHsgc2NhbGVPcmRpbmFsLCB0aWNrRm9ybWF0IGFzIHRpY2tGb3JtYXQkMSB9IGZyb20gJ2QzLXNjYWxlJztcbmV4cG9ydCB7IHNjYWxlSW1wbGljaXQgfSBmcm9tICdkMy1zY2FsZSc7XG5pbXBvcnQgKiBhcyAkJDEgZnJvbSAnZDMtaW50ZXJwb2xhdGUnO1xuaW1wb3J0IHsgc2NoZW1lQWNjZW50LCBzY2hlbWVDYXRlZ29yeTEwLCBzY2hlbWVEYXJrMiwgc2NoZW1lT2JzZXJ2YWJsZTEwLCBzY2hlbWVQYWlyZWQsIHNjaGVtZVBhc3RlbDEsIHNjaGVtZVBhc3RlbDIsIHNjaGVtZVNldDEsIHNjaGVtZVNldDIsIHNjaGVtZVNldDMgfSBmcm9tICdkMy1zY2FsZS1jaHJvbWF0aWMnO1xuaW1wb3J0IHsgdGltZUludGVydmFsLCB1dGNJbnRlcnZhbCB9IGZyb20gJ3ZlZ2EtdGltZSc7XG5cbmZ1bmN0aW9uIGJhbmRTcGFjZSAoY291bnQsIHBhZGRpbmdJbm5lciwgcGFkZGluZ091dGVyKSB7XG4gIGNvbnN0IHNwYWNlID0gY291bnQgLSBwYWRkaW5nSW5uZXIgKyBwYWRkaW5nT3V0ZXIgKiAyO1xuICByZXR1cm4gY291bnQgPyBzcGFjZSA+IDAgPyBzcGFjZSA6IDEgOiAwO1xufVxuXG5jb25zdCBJZGVudGl0eSA9ICdpZGVudGl0eSc7XG5jb25zdCBMaW5lYXIgPSAnbGluZWFyJztcbmNvbnN0IExvZyA9ICdsb2cnO1xuY29uc3QgUG93ID0gJ3Bvdyc7XG5jb25zdCBTcXJ0ID0gJ3NxcnQnO1xuY29uc3QgU3ltbG9nID0gJ3N5bWxvZyc7XG5jb25zdCBUaW1lID0gJ3RpbWUnO1xuY29uc3QgVVRDID0gJ3V0Yyc7XG5jb25zdCBTZXF1ZW50aWFsID0gJ3NlcXVlbnRpYWwnO1xuY29uc3QgRGl2ZXJnaW5nID0gJ2RpdmVyZ2luZyc7XG5jb25zdCBRdWFudGlsZSA9ICdxdWFudGlsZSc7XG5jb25zdCBRdWFudGl6ZSA9ICdxdWFudGl6ZSc7XG5jb25zdCBUaHJlc2hvbGQgPSAndGhyZXNob2xkJztcbmNvbnN0IE9yZGluYWwgPSAnb3JkaW5hbCc7XG5jb25zdCBQb2ludCA9ICdwb2ludCc7XG5jb25zdCBCYW5kID0gJ2JhbmQnO1xuY29uc3QgQmluT3JkaW5hbCA9ICdiaW4tb3JkaW5hbCc7XG5cbi8vIGNhdGVnb3JpZXNcbmNvbnN0IENvbnRpbnVvdXMgPSAnY29udGludW91cyc7XG5jb25zdCBEaXNjcmV0ZSA9ICdkaXNjcmV0ZSc7XG5jb25zdCBEaXNjcmV0aXppbmcgPSAnZGlzY3JldGl6aW5nJztcbmNvbnN0IEludGVycG9sYXRpbmcgPSAnaW50ZXJwb2xhdGluZyc7XG5jb25zdCBUZW1wb3JhbCA9ICd0ZW1wb3JhbCc7XG5cbmZ1bmN0aW9uIGludmVydFJhbmdlIChzY2FsZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKF8pIHtcbiAgICBsZXQgbG8gPSBfWzBdLFxuICAgICAgaGkgPSBfWzFdLFxuICAgICAgdDtcbiAgICBpZiAoaGkgPCBsbykge1xuICAgICAgdCA9IGxvO1xuICAgICAgbG8gPSBoaTtcbiAgICAgIGhpID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIFtzY2FsZS5pbnZlcnQobG8pLCBzY2FsZS5pbnZlcnQoaGkpXTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52ZXJ0UmFuZ2VFeHRlbnQgKHNjYWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoXykge1xuICAgIGNvbnN0IHJhbmdlID0gc2NhbGUucmFuZ2UoKTtcbiAgICBsZXQgbG8gPSBfWzBdLFxuICAgICAgaGkgPSBfWzFdLFxuICAgICAgbWluID0gLTEsXG4gICAgICBtYXgsXG4gICAgICB0LFxuICAgICAgaSxcbiAgICAgIG47XG4gICAgaWYgKGhpIDwgbG8pIHtcbiAgICAgIHQgPSBsbztcbiAgICAgIGxvID0gaGk7XG4gICAgICBoaSA9IHQ7XG4gICAgfVxuICAgIGZvciAoaSA9IDAsIG4gPSByYW5nZS5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChyYW5nZVtpXSA+PSBsbyAmJiByYW5nZVtpXSA8PSBoaSkge1xuICAgICAgICBpZiAobWluIDwgMCkgbWluID0gaTtcbiAgICAgICAgbWF4ID0gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1pbiA8IDApIHJldHVybiB1bmRlZmluZWQ7XG4gICAgbG8gPSBzY2FsZS5pbnZlcnRFeHRlbnQocmFuZ2VbbWluXSk7XG4gICAgaGkgPSBzY2FsZS5pbnZlcnRFeHRlbnQocmFuZ2VbbWF4XSk7XG4gICAgcmV0dXJuIFtsb1swXSA9PT0gdW5kZWZpbmVkID8gbG9bMV0gOiBsb1swXSwgaGlbMV0gPT09IHVuZGVmaW5lZCA/IGhpWzBdIDogaGlbMV1dO1xuICB9O1xufVxuXG5mdW5jdGlvbiBiYW5kKCkge1xuICBjb25zdCBzY2FsZSA9IHNjYWxlT3JkaW5hbCgpLnVua25vd24odW5kZWZpbmVkKSxcbiAgICBkb21haW4gPSBzY2FsZS5kb21haW4sXG4gICAgb3JkaW5hbFJhbmdlID0gc2NhbGUucmFuZ2U7XG4gIGxldCByYW5nZSQxID0gWzAsIDFdLFxuICAgIHN0ZXAsXG4gICAgYmFuZHdpZHRoLFxuICAgIHJvdW5kID0gZmFsc2UsXG4gICAgcGFkZGluZ0lubmVyID0gMCxcbiAgICBwYWRkaW5nT3V0ZXIgPSAwLFxuICAgIGFsaWduID0gMC41O1xuICBkZWxldGUgc2NhbGUudW5rbm93bjtcbiAgZnVuY3Rpb24gcmVzY2FsZSgpIHtcbiAgICBjb25zdCBuID0gZG9tYWluKCkubGVuZ3RoLFxuICAgICAgcmV2ZXJzZSA9IHJhbmdlJDFbMV0gPCByYW5nZSQxWzBdLFxuICAgICAgc3RvcCA9IHJhbmdlJDFbMSAtIHJldmVyc2VdLFxuICAgICAgc3BhY2UgPSBiYW5kU3BhY2UobiwgcGFkZGluZ0lubmVyLCBwYWRkaW5nT3V0ZXIpO1xuICAgIGxldCBzdGFydCA9IHJhbmdlJDFbcmV2ZXJzZSAtIDBdO1xuICAgIHN0ZXAgPSAoc3RvcCAtIHN0YXJ0KSAvIChzcGFjZSB8fCAxKTtcbiAgICBpZiAocm91bmQpIHtcbiAgICAgIHN0ZXAgPSBNYXRoLmZsb29yKHN0ZXApO1xuICAgIH1cbiAgICBzdGFydCArPSAoc3RvcCAtIHN0YXJ0IC0gc3RlcCAqIChuIC0gcGFkZGluZ0lubmVyKSkgKiBhbGlnbjtcbiAgICBiYW5kd2lkdGggPSBzdGVwICogKDEgLSBwYWRkaW5nSW5uZXIpO1xuICAgIGlmIChyb3VuZCkge1xuICAgICAgc3RhcnQgPSBNYXRoLnJvdW5kKHN0YXJ0KTtcbiAgICAgIGJhbmR3aWR0aCA9IE1hdGgucm91bmQoYmFuZHdpZHRoKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gcmFuZ2UobikubWFwKGkgPT4gc3RhcnQgKyBzdGVwICogaSk7XG4gICAgcmV0dXJuIG9yZGluYWxSYW5nZShyZXZlcnNlID8gdmFsdWVzLnJldmVyc2UoKSA6IHZhbHVlcyk7XG4gIH1cbiAgc2NhbGUuZG9tYWluID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgZG9tYWluKF8pO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRvbWFpbigpO1xuICAgIH1cbiAgfTtcbiAgc2NhbGUucmFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByYW5nZSQxID0gWytfWzBdLCArX1sxXV07XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmFuZ2UkMS5zbGljZSgpO1xuICAgIH1cbiAgfTtcbiAgc2NhbGUucmFuZ2VSb3VuZCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgcmFuZ2UkMSA9IFsrX1swXSwgK19bMV1dO1xuICAgIHJvdW5kID0gdHJ1ZTtcbiAgICByZXR1cm4gcmVzY2FsZSgpO1xuICB9O1xuICBzY2FsZS5iYW5kd2lkdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJhbmR3aWR0aDtcbiAgfTtcbiAgc2NhbGUuc3RlcCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RlcDtcbiAgfTtcbiAgc2NhbGUucm91bmQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByb3VuZCA9ICEhXztcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3VuZDtcbiAgICB9XG4gIH07XG4gIHNjYWxlLnBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBwYWRkaW5nT3V0ZXIgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCBfKSk7XG4gICAgICBwYWRkaW5nSW5uZXIgPSBwYWRkaW5nT3V0ZXI7XG4gICAgICByZXR1cm4gcmVzY2FsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcGFkZGluZ0lubmVyO1xuICAgIH1cbiAgfTtcbiAgc2NhbGUucGFkZGluZ0lubmVyID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgcGFkZGluZ0lubmVyID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZGRpbmdJbm5lcjtcbiAgICB9XG4gIH07XG4gIHNjYWxlLnBhZGRpbmdPdXRlciA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHBhZGRpbmdPdXRlciA9IE1hdGgubWF4KDAsIE1hdGgubWluKDEsIF8pKTtcbiAgICAgIHJldHVybiByZXNjYWxlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwYWRkaW5nT3V0ZXI7XG4gICAgfVxuICB9O1xuICBzY2FsZS5hbGlnbiA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGFsaWduID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMSwgXykpO1xuICAgICAgcmV0dXJuIHJlc2NhbGUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFsaWduO1xuICAgIH1cbiAgfTtcbiAgc2NhbGUuaW52ZXJ0UmFuZ2UgPSBmdW5jdGlvbiAoXykge1xuICAgIC8vIGJhaWwgaWYgcmFuZ2UgaGFzIG51bGwgb3IgdW5kZWZpbmVkIHZhbHVlc1xuICAgIGlmIChfWzBdID09IG51bGwgfHwgX1sxXSA9PSBudWxsKSByZXR1cm47XG4gICAgY29uc3QgcmV2ZXJzZSA9IHJhbmdlJDFbMV0gPCByYW5nZSQxWzBdLFxuICAgICAgdmFsdWVzID0gcmV2ZXJzZSA/IG9yZGluYWxSYW5nZSgpLnJldmVyc2UoKSA6IG9yZGluYWxSYW5nZSgpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgIGxldCBsbyA9ICtfWzBdLFxuICAgICAgaGkgPSArX1sxXSxcbiAgICAgIGEsXG4gICAgICBiLFxuICAgICAgdDtcblxuICAgIC8vIGJhaWwgaWYgZWl0aGVyIHJhbmdlIGVuZHBvaW50IGlzIGludmFsaWRcbiAgICBpZiAobG8gIT09IGxvIHx8IGhpICE9PSBoaSkgcmV0dXJuO1xuXG4gICAgLy8gb3JkZXIgcmFuZ2UgaW5wdXRzLCBiYWlsIGlmIG91dHNpZGUgb2Ygc2NhbGUgcmFuZ2VcbiAgICBpZiAoaGkgPCBsbykge1xuICAgICAgdCA9IGxvO1xuICAgICAgbG8gPSBoaTtcbiAgICAgIGhpID0gdDtcbiAgICB9XG4gICAgaWYgKGhpIDwgdmFsdWVzWzBdIHx8IGxvID4gcmFuZ2UkMVsxIC0gcmV2ZXJzZV0pIHJldHVybjtcblxuICAgIC8vIGJpbmFyeSBzZWFyY2ggdG8gaW5kZXggaW50byBzY2FsZSByYW5nZVxuICAgIGEgPSBNYXRoLm1heCgwLCBiaXNlY3RSaWdodCh2YWx1ZXMsIGxvKSAtIDEpO1xuICAgIGIgPSBsbyA9PT0gaGkgPyBhIDogYmlzZWN0UmlnaHQodmFsdWVzLCBoaSkgLSAxO1xuXG4gICAgLy8gaW5jcmVtZW50IGluZGV4IGEgaWYgbG8gaXMgd2l0aGluIHBhZGRpbmcgZ2FwXG4gICAgaWYgKGxvIC0gdmFsdWVzW2FdID4gYmFuZHdpZHRoICsgMWUtMTApICsrYTtcbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgLy8gbWFwICsgc3dhcFxuICAgICAgdCA9IGE7XG4gICAgICBhID0gbiAtIGI7XG4gICAgICBiID0gbiAtIHQ7XG4gICAgfVxuICAgIHJldHVybiBhID4gYiA/IHVuZGVmaW5lZCA6IGRvbWFpbigpLnNsaWNlKGEsIGIgKyAxKTtcbiAgfTtcbiAgc2NhbGUuaW52ZXJ0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBjb25zdCB2YWx1ZSA9IHNjYWxlLmludmVydFJhbmdlKFtfLCBfXSk7XG4gICAgcmV0dXJuIHZhbHVlID8gdmFsdWVbMF0gOiB2YWx1ZTtcbiAgfTtcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYmFuZCgpLmRvbWFpbihkb21haW4oKSkucmFuZ2UocmFuZ2UkMSkucm91bmQocm91bmQpLnBhZGRpbmdJbm5lcihwYWRkaW5nSW5uZXIpLnBhZGRpbmdPdXRlcihwYWRkaW5nT3V0ZXIpLmFsaWduKGFsaWduKTtcbiAgfTtcbiAgcmV0dXJuIHJlc2NhbGUoKTtcbn1cbmZ1bmN0aW9uIHBvaW50aXNoKHNjYWxlKSB7XG4gIGNvbnN0IGNvcHkgPSBzY2FsZS5jb3B5O1xuICBzY2FsZS5wYWRkaW5nID0gc2NhbGUucGFkZGluZ091dGVyO1xuICBkZWxldGUgc2NhbGUucGFkZGluZ0lubmVyO1xuICBzY2FsZS5jb3B5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwb2ludGlzaChjb3B5KCkpO1xuICB9O1xuICByZXR1cm4gc2NhbGU7XG59XG5mdW5jdGlvbiBwb2ludCgpIHtcbiAgcmV0dXJuIHBvaW50aXNoKGJhbmQoKS5wYWRkaW5nSW5uZXIoMSkpO1xufVxuXG52YXIgbWFwID0gQXJyYXkucHJvdG90eXBlLm1hcDtcbmZ1bmN0aW9uIG51bWJlcnMoXykge1xuICByZXR1cm4gbWFwLmNhbGwoXywgdG9OdW1iZXIpO1xufVxuXG5jb25zdCBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcblxuZnVuY3Rpb24gc2NhbGVCaW5PcmRpbmFsKCkge1xuICBsZXQgZG9tYWluID0gW10sXG4gICAgcmFuZ2UgPSBbXTtcbiAgZnVuY3Rpb24gc2NhbGUoeCkge1xuICAgIHJldHVybiB4ID09IG51bGwgfHwgeCAhPT0geCA/IHVuZGVmaW5lZCA6IHJhbmdlWyhiaXNlY3QoZG9tYWluLCB4KSAtIDEpICUgcmFuZ2UubGVuZ3RoXTtcbiAgfVxuICBzY2FsZS5kb21haW4gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkb21haW4gPSBudW1iZXJzKF8pO1xuICAgICAgcmV0dXJuIHNjYWxlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZG9tYWluLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuICBzY2FsZS5yYW5nZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJhbmdlID0gc2xpY2UuY2FsbChfKTtcbiAgICAgIHJldHVybiBzY2FsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJhbmdlLnNsaWNlKCk7XG4gICAgfVxuICB9O1xuICBzY2FsZS50aWNrRm9ybWF0ID0gZnVuY3Rpb24gKGNvdW50LCBzcGVjaWZpZXIpIHtcbiAgICByZXR1cm4gdGlja0Zvcm1hdCQxKGRvbWFpblswXSwgcGVlayhkb21haW4pLCBjb3VudCA9PSBudWxsID8gMTAgOiBjb3VudCwgc3BlY2lmaWVyKTtcbiAgfTtcbiAgc2NhbGUuY29weSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2NhbGVCaW5PcmRpbmFsKCkuZG9tYWluKHNjYWxlLmRvbWFpbigpKS5yYW5nZShzY2FsZS5yYW5nZSgpKTtcbiAgfTtcbiAgcmV0dXJuIHNjYWxlO1xufVxuXG4vKiogUHJpdmF0ZSBzY2FsZSByZWdpc3RyeTogc2hvdWxkIG5vdCBiZSBleHBvcnRlZCAqL1xuY29uc3Qgc2NhbGVzID0gbmV3IE1hcCgpO1xuY29uc3QgVkVHQV9TQ0FMRSA9IFN5bWJvbCgndmVnYV9zY2FsZScpO1xuZnVuY3Rpb24gcmVnaXN0ZXJTY2FsZShzY2FsZSkge1xuICBzY2FsZVtWRUdBX1NDQUxFXSA9IHRydWU7XG4gIHJldHVybiBzY2FsZTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiBvYmplY3Qgd2FzIGNyZWF0ZWQgYnkgYSBjb25zdHJ1Y3RvciBmcm9tIHRoZSB2ZWdhLXNjYWxlIGBzY2FsZWAgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGlzUmVnaXN0ZXJlZFNjYWxlKHNjYWxlKSB7XG4gIHJldHVybiBzY2FsZSAmJiBzY2FsZVtWRUdBX1NDQUxFXSA9PT0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBBdWdtZW50IHNjYWxlcyB3aXRoIHRoZWlyIHR5cGUgYW5kIG5lZWRlZCBpbnZlcnNlIG1ldGhvZHMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZSh0eXBlLCBjb25zdHJ1Y3RvciwgbWV0YWRhdGEpIHtcbiAgY29uc3QgY3RyID0gZnVuY3Rpb24gc2NhbGUoKSB7XG4gICAgY29uc3QgcyA9IGNvbnN0cnVjdG9yKCk7XG4gICAgaWYgKCFzLmludmVydFJhbmdlKSB7XG4gICAgICBzLmludmVydFJhbmdlID0gcy5pbnZlcnQgPyBpbnZlcnRSYW5nZShzKSA6IHMuaW52ZXJ0RXh0ZW50ID8gaW52ZXJ0UmFuZ2VFeHRlbnQocykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHMudHlwZSA9IHR5cGU7XG4gICAgcmV0dXJuIHJlZ2lzdGVyU2NhbGUocyk7XG4gIH07XG4gIGN0ci5tZXRhZGF0YSA9IHRvU2V0KGFycmF5KG1ldGFkYXRhKSk7XG4gIHJldHVybiBjdHI7XG59XG5cbi8qKlxuICogUmVnaXN0cnkgZnVuY3Rpb24gZm9yIGFkZGluZyBhbmQgYWNjZXNzaW5nIHNjYWxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9ucy5cbiAqIFRoZSAqdHlwZSogYXJndW1lbnQgaXMgYSBTdHJpbmcgaW5kaWNhdGluZyB0aGUgbmFtZSBvZiB0aGUgc2NhbGUgdHlwZS5cbiAqXG4gKiBJZiB0aGUgKnNjYWxlKiBhcmd1bWVudCBpcyBub3Qgc3BlY2lmaWVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBtYXRjaGluZyBzY2FsZSBjb25zdHJ1Y3RvciBpbiB0aGUgcmVnaXN0cnksIG9yIGBudWxsYCBpZiBub3QgZm91bmQuXG4gKiBJZiB0aGUgKnNjYWxlKiBhcmd1bWVudCBpcyBwcm92aWRlZCwgaXQgbXVzdCBiZSBhIHNjYWxlIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIHRvIGFkZCB0byB0aGUgcmVnaXN0cnkgdW5kZXIgdGhlIGdpdmVuICp0eXBlKiBuYW1lLlxuICogVGhlICptZXRhZGF0YSogYXJndW1lbnQgcHJvdmlkZXMgYWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0byBndWlkZSBhcHByb3ByaWF0ZSB1c2Ugb2Ygc2NhbGVzIHdpdGhpbiBWZWdhLlxuICpcbiAqICAqbWV0YWRhdGEqIGNhbiBiZSBlaXRoZXIgYSBzdHJpbmcgb3Igc3RyaW5nIGFycmF5LiBUaGUgdmFsaWQgc3RyaW5nIHZhbHVlcyBhcmU6XG4gKiAtIGBcImNvbnRpbnVvdXNcImAgLSB0aGUgc2NhbGUgaXMgZGVmaW5lZCBvdmVyIGEgY29udGludW91cy12YWx1ZWQgZG9tYWluLlxuICogLSBgXCJkaXNjcmV0ZVwiYCAtIHRoZSBzY2FsZSBpcyBkZWZpbmVkIG92ZXIgYSBkaXNjcmV0ZSBkb21haW4gYW5kIHJhbmdlLlxuICogLSBgXCJkaXNjcmV0aXppbmdcImAgLSB0aGUgc2NhbGUgZGlzY3JldGl6ZXMgYSBjb250aW51b3VzIGRvbWFpbiB0byBhIGRpc2NyZXRlIHJhbmdlLlxuICogLSBgXCJpbnRlcnBvbGF0aW5nXCJgIC0gdGhlIHNjYWxlIHJhbmdlIGlzIGRlZmluZWQgdXNpbmcgYSBjb2xvciBpbnRlcnBvbGF0b3IuXG4gKiAtIGBcImxvZ1wiYCAtIHRoZSBzY2FsZSBwZXJmb3JtcyBhIGxvZ2FyaXRobWljIHRyYW5zZm9ybSBvZiB0aGUgY29udGludW91cyBkb21haW4uXG4gKiAtIGBcInRlbXBvcmFsXCJgIC0gdGhlIHNjYWxlIGRvbWFpbiBpcyBkZWZpbmVkIG92ZXIgZGF0ZS10aW1lIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2NhbGUodHlwZSwgc2NhbGUsIG1ldGFkYXRhKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgIHNjYWxlcy5zZXQodHlwZSwgY3JlYXRlKHR5cGUsIHNjYWxlLCBtZXRhZGF0YSkpO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpc1ZhbGlkU2NhbGVUeXBlKHR5cGUpID8gc2NhbGVzLmdldCh0eXBlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vLyBpZGVudGl0eSBzY2FsZVxuc2NhbGUoSWRlbnRpdHksICQuc2NhbGVJZGVudGl0eSk7XG5cbi8vIGNvbnRpbnVvdXMgc2NhbGVzXG5zY2FsZShMaW5lYXIsICQuc2NhbGVMaW5lYXIsIENvbnRpbnVvdXMpO1xuc2NhbGUoTG9nLCAkLnNjYWxlTG9nLCBbQ29udGludW91cywgTG9nXSk7XG5zY2FsZShQb3csICQuc2NhbGVQb3csIENvbnRpbnVvdXMpO1xuc2NhbGUoU3FydCwgJC5zY2FsZVNxcnQsIENvbnRpbnVvdXMpO1xuc2NhbGUoU3ltbG9nLCAkLnNjYWxlU3ltbG9nLCBDb250aW51b3VzKTtcbnNjYWxlKFRpbWUsICQuc2NhbGVUaW1lLCBbQ29udGludW91cywgVGVtcG9yYWxdKTtcbnNjYWxlKFVUQywgJC5zY2FsZVV0YywgW0NvbnRpbnVvdXMsIFRlbXBvcmFsXSk7XG5cbi8vIHNlcXVlbnRpYWwgc2NhbGVzXG5zY2FsZShTZXF1ZW50aWFsLCAkLnNjYWxlU2VxdWVudGlhbCwgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTsgLy8gYmFja3dhcmRzIGNvbXBhdFxuc2NhbGUoYCR7U2VxdWVudGlhbH0tJHtMaW5lYXJ9YCwgJC5zY2FsZVNlcXVlbnRpYWwsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShgJHtTZXF1ZW50aWFsfS0ke0xvZ31gLCAkLnNjYWxlU2VxdWVudGlhbExvZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmcsIExvZ10pO1xuc2NhbGUoYCR7U2VxdWVudGlhbH0tJHtQb3d9YCwgJC5zY2FsZVNlcXVlbnRpYWxQb3csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShgJHtTZXF1ZW50aWFsfS0ke1NxcnR9YCwgJC5zY2FsZVNlcXVlbnRpYWxTcXJ0LCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoYCR7U2VxdWVudGlhbH0tJHtTeW1sb2d9YCwgJC5zY2FsZVNlcXVlbnRpYWxTeW1sb2csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5cbi8vIGRpdmVyZ2luZyBzY2FsZXNcbnNjYWxlKGAke0RpdmVyZ2luZ30tJHtMaW5lYXJ9YCwgJC5zY2FsZURpdmVyZ2luZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmddKTtcbnNjYWxlKGAke0RpdmVyZ2luZ30tJHtMb2d9YCwgJC5zY2FsZURpdmVyZ2luZ0xvZywgW0NvbnRpbnVvdXMsIEludGVycG9sYXRpbmcsIExvZ10pO1xuc2NhbGUoYCR7RGl2ZXJnaW5nfS0ke1Bvd31gLCAkLnNjYWxlRGl2ZXJnaW5nUG93LCBbQ29udGludW91cywgSW50ZXJwb2xhdGluZ10pO1xuc2NhbGUoYCR7RGl2ZXJnaW5nfS0ke1NxcnR9YCwgJC5zY2FsZURpdmVyZ2luZ1NxcnQsIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5zY2FsZShgJHtEaXZlcmdpbmd9LSR7U3ltbG9nfWAsICQuc2NhbGVEaXZlcmdpbmdTeW1sb2csIFtDb250aW51b3VzLCBJbnRlcnBvbGF0aW5nXSk7XG5cbi8vIGRpc2NyZXRpemluZyBzY2FsZXNcbnNjYWxlKFF1YW50aWxlLCAkLnNjYWxlUXVhbnRpbGUsIFtEaXNjcmV0aXppbmcsIFF1YW50aWxlXSk7XG5zY2FsZShRdWFudGl6ZSwgJC5zY2FsZVF1YW50aXplLCBEaXNjcmV0aXppbmcpO1xuc2NhbGUoVGhyZXNob2xkLCAkLnNjYWxlVGhyZXNob2xkLCBEaXNjcmV0aXppbmcpO1xuXG4vLyBkaXNjcmV0ZSBzY2FsZXNcbnNjYWxlKEJpbk9yZGluYWwsIHNjYWxlQmluT3JkaW5hbCwgW0Rpc2NyZXRlLCBEaXNjcmV0aXppbmddKTtcbnNjYWxlKE9yZGluYWwsICQuc2NhbGVPcmRpbmFsLCBEaXNjcmV0ZSk7XG5zY2FsZShCYW5kLCBiYW5kLCBEaXNjcmV0ZSk7XG5zY2FsZShQb2ludCwgcG9pbnQsIERpc2NyZXRlKTtcbmZ1bmN0aW9uIGlzVmFsaWRTY2FsZVR5cGUodHlwZSkge1xuICByZXR1cm4gc2NhbGVzLmhhcyh0eXBlKTtcbn1cbmZ1bmN0aW9uIGhhc1R5cGUoa2V5LCB0eXBlKSB7XG4gIGNvbnN0IHMgPSBzY2FsZXMuZ2V0KGtleSk7XG4gIHJldHVybiBzICYmIHMubWV0YWRhdGFbdHlwZV07XG59XG5mdW5jdGlvbiBpc0NvbnRpbnVvdXMoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgQ29udGludW91cyk7XG59XG5mdW5jdGlvbiBpc0Rpc2NyZXRlKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIERpc2NyZXRlKTtcbn1cbmZ1bmN0aW9uIGlzRGlzY3JldGl6aW5nKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIERpc2NyZXRpemluZyk7XG59XG5mdW5jdGlvbiBpc0xvZ2FyaXRobWljKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIExvZyk7XG59XG5mdW5jdGlvbiBpc1RlbXBvcmFsKGtleSkge1xuICByZXR1cm4gaGFzVHlwZShrZXksIFRlbXBvcmFsKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZXJwb2xhdGluZyhrZXkpIHtcbiAgcmV0dXJuIGhhc1R5cGUoa2V5LCBJbnRlcnBvbGF0aW5nKTtcbn1cbmZ1bmN0aW9uIGlzUXVhbnRpbGUoa2V5KSB7XG4gIHJldHVybiBoYXNUeXBlKGtleSwgUXVhbnRpbGUpO1xufVxuXG5jb25zdCBzY2FsZVByb3BzID0gWydjbGFtcCcsICdiYXNlJywgJ2NvbnN0YW50JywgJ2V4cG9uZW50J107XG5mdW5jdGlvbiBpbnRlcnBvbGF0ZVJhbmdlKGludGVycG9sYXRvciwgcmFuZ2UpIHtcbiAgY29uc3Qgc3RhcnQgPSByYW5nZVswXSxcbiAgICBzcGFuID0gcGVlayhyYW5nZSkgLSBzdGFydDtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRvcihzdGFydCArIGkgKiBzcGFuKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlQ29sb3JzKGNvbG9ycywgdHlwZSwgZ2FtbWEpIHtcbiAgcmV0dXJuICQkMS5waWVjZXdpc2UoaW50ZXJwb2xhdGUodHlwZSB8fCAncmdiJywgZ2FtbWEpLCBjb2xvcnMpO1xufVxuZnVuY3Rpb24gcXVhbnRpemVJbnRlcnBvbGF0b3IoaW50ZXJwb2xhdG9yLCBjb3VudCkge1xuICBjb25zdCBzYW1wbGVzID0gbmV3IEFycmF5KGNvdW50KSxcbiAgICBuID0gY291bnQgKyAxO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50Oykgc2FtcGxlc1tpXSA9IGludGVycG9sYXRvcigrK2kgLyBuKTtcbiAgcmV0dXJuIHNhbXBsZXM7XG59XG5mdW5jdGlvbiBzY2FsZUNvcHkoc2NhbGUpIHtcbiAgY29uc3QgdCA9IHNjYWxlLnR5cGUsXG4gICAgcyA9IHNjYWxlLmNvcHkoKTtcbiAgcy50eXBlID0gdDtcbiAgcmV0dXJuIHM7XG59XG5mdW5jdGlvbiBzY2FsZUZyYWN0aW9uKHNjYWxlJDEsIG1pbiwgbWF4KSB7XG4gIGNvbnN0IGRlbHRhID0gbWF4IC0gbWluO1xuICBsZXQgaSwgdCwgcztcbiAgaWYgKCFkZWx0YSB8fCAhTnVtYmVyLmlzRmluaXRlKGRlbHRhKSkge1xuICAgIHJldHVybiBjb25zdGFudCgwLjUpO1xuICB9IGVsc2Uge1xuICAgIGkgPSAodCA9IHNjYWxlJDEudHlwZSkuaW5kZXhPZignLScpO1xuICAgIHQgPSBpIDwgMCA/IHQgOiB0LnNsaWNlKGkgKyAxKTtcbiAgICBzID0gc2NhbGUodCkoKS5kb21haW4oW21pbiwgbWF4XSkucmFuZ2UoWzAsIDFdKTtcbiAgICBzY2FsZVByb3BzLmZvckVhY2gobSA9PiBzY2FsZSQxW21dID8gc1ttXShzY2FsZSQxW21dKCkpIDogMCk7XG4gICAgcmV0dXJuIHM7XG4gIH1cbn1cbmZ1bmN0aW9uIGludGVycG9sYXRlKHR5cGUsIGdhbW1hKSB7XG4gIGNvbnN0IGludGVycCA9ICQkMVttZXRob2QodHlwZSldO1xuICByZXR1cm4gZ2FtbWEgIT0gbnVsbCAmJiBpbnRlcnAgJiYgaW50ZXJwLmdhbW1hID8gaW50ZXJwLmdhbW1hKGdhbW1hKSA6IGludGVycDtcbn1cbmZ1bmN0aW9uIG1ldGhvZCh0eXBlKSB7XG4gIHJldHVybiAnaW50ZXJwb2xhdGUnICsgdHlwZS50b0xvd2VyQ2FzZSgpLnNwbGl0KCctJykubWFwKHMgPT4gc1swXS50b1VwcGVyQ2FzZSgpICsgcy5zbGljZSgxKSkuam9pbignJyk7XG59XG5cbmNvbnN0IGNvbnRpbnVvdXMgPSB7XG4gIGJsdWVzOiAnY2ZlMWYyYmVkOGVjYThjZWU1OGZjMWRlNzRiMmQ3NWJhM2NmNDU5MmM2MzE4MWJkMjA2ZmIyMTI1Y2E0MGE0YTkwJyxcbiAgZ3JlZW5zOiAnZDNlZWNkYzBlNmJhYWJkZGE1OTRkMzkxN2JjNzdkNjBiYTZjNDZhYjVlMzI5YTUxMjA4OTQzMGU3NzM1MDM2NDI5JyxcbiAgZ3JleXM6ICdlMmUyZTJkNGQ0ZDRjNGM0YzRiMWIxYjE5ZDlkOWQ4ODg4ODg3NTc1NzU2MjYyNjI0ZDRkNGQzNTM1MzUxZTFlMWUnLFxuICBvcmFuZ2VzOiAnZmRkOGIzZmRjOTk4ZmRiODdiZmRhNTVlZmM5MjQ0Zjg3ZjJjZjA2YjE4ZTQ1ODBiZDE0OTA0YjkzZDAyOWYzMzAzJyxcbiAgcHVycGxlczogJ2UyZTFlZmQ0ZDRlOGM0YzVlMGI0YjNkNmEzYTBjYzkyOGVjMzgyN2NiOTc1NjZhZTY4NGVhMjVjMzY5NjUwMWY4YycsXG4gIHJlZHM6ICdmZGM5YjRmY2I0OWFmYzllODBmYzg3NjdmYTcwNTFmNjU3M2ZlYzNmMmZkYzJhMjVjODFiMWRiMjEyMTg5NzBiMTMnLFxuICBibHVlR3JlZW46ICdkNWVmZWRjMWU4ZTBhN2RkZDE4YmQyYmU3MGM2YTk1OGJhOTE0NGFkNzczMTljNWQyMDg5NDYwZTc3MzYwMzY0MjknLFxuICBibHVlUHVycGxlOiAnY2NkZGVjYmFkMGU0YThjMmRkOWFiMGQ0OTE5Y2M5OGQ4NWJlOGI2ZGIyOGE1NWE2ODczYzk5ODIyMjg3NzMwZjcxJyxcbiAgZ3JlZW5CbHVlOiAnZDNlZWNlYzVlOGMzYjFlMWJiOWJkOGJiODJjZWMyNjljMmNhNTFiMmNkM2M5ZmM3Mjg4YWJkMTY3NWIxMGI2MGExJyxcbiAgb3JhbmdlUmVkOiAnZmRkY2FmZmRjZjliZmRjMThhZmRhZDc3ZmI5NTYyZjY3ZDUzZWU2NTQ1ZTI0OTMyZDMyZDFlYmYxMzBkYTcwNDAzJyxcbiAgcHVycGxlQmx1ZTogJ2RiZGFlYmM4Y2VlNGIxYzNkZTk3YjdkODdiYWNkMTViOWZjOTNhOTBjMDFlN2ZiNzBiNzBhYjA1NjE5OTA0NTI4MScsXG4gIHB1cnBsZUJsdWVHcmVlbjogJ2RiZDhlYWM4Y2VlNGIwYzNkZTkzYjdkODcyYWNkMTU0OWZjODM4OTJiYjFjODhhMzA5N2Y4NzAyNzM2YjAxNjM1MycsXG4gIHB1cnBsZVJlZDogJ2RjYzllMmQzYjNkN2NlOWVjY2QxODZjMGRhNmJiMmUxNGRhMGUyMzE4OWQ5MWU2ZmM2MTE1OWFiMDc0OThmMDIzYScsXG4gIHJlZFB1cnBsZTogJ2ZjY2ZjY2ZjYmVjMGZhYTliOGY5OGZhZmY1NzFhNWVjNTM5ZGRiMzY5NWM0MWI4YWE5MDg4MDhkMDE3OTcwMDE3NCcsXG4gIHllbGxvd0dyZWVuOiAnZTRmNGFjZDFlY2EwYjllMjk0OWVkNjg4ODBjOTdjNjJiYjZlNDdhYTVlMzI5NzUwMjA4MzQ0MGU3MjNiMDM2MDM0JyxcbiAgeWVsbG93T3JhbmdlQnJvd246ICdmZWVhYTFmZWRkODRmZWNjNjNmZWI3NDZmY2EwMzFmNjg5MjFlYjcyMTVkYjVlMGJjNTRjMDVhYjNkMDM4ZjMyMDQnLFxuICB5ZWxsb3dPcmFuZ2VSZWQ6ICdmZWUwODdmZWQxNmZmZWJkNTlmZWE4NDlmZDkwM2VmYzczMzVmOTUyMmJlZTM0MjNkZTFiMjBjYTBiMjJhZjAyMjUnLFxuICBibHVlT3JhbmdlOiAnMTM0Yjg1MmY3OGIzNWRhMmNiOWRjYWUxZDJlNWVmZjJmMGViZmNlMGJhZmJiZjc0ZTg5MzJmYzU2OTBkOTk0YTA3JyxcbiAgYnJvd25CbHVlR3JlZW46ICc3MDQxMDhhMDY1MWFjNzk1NDhlM2M3OGFmM2U2YzZlZWYxZWFjOWU5ZTQ4ZWQxYzc0ZGE3OWUxODdhNzIwMjUxNDcnLFxuICBwdXJwbGVHcmVlbjogJzViMTY2NzgzNDc5MmE2N2ZiNmM5YWVkM2U2ZDZlOGVmZjBlZmQ5ZWZkNWFlZGRhOTcxYmI3NTM2OGU0OTBlNWUyOScsXG4gIHB1cnBsZU9yYW5nZTogJzQxMTQ2OTY2NDc5NjhmODNiN2I5YjRkNmRhZGJlYmYzZWVlYWZjZTBiYWZiYmY3NGU4OTMyZmM1NjkwZDk5NGEwNycsXG4gIHJlZEJsdWU6ICc4YzBkMjViZjM2M2FkZjc0NWVmNGFlOTFmYmRiYzlmMmVmZWVkMmU1ZWY5ZGNhZTE1ZGEyY2IyZjc4YjMxMzRiODUnLFxuICByZWRHcmV5OiAnOGMwZDI1YmYzNjNhZGY3NDVlZjRhZTkxZmNkY2NiZmFmNGYxZTJlMmUyYzBjMGMwOTY5Njk2NjQ2NDY0MzQzNDM0JyxcbiAgeWVsbG93R3JlZW5CbHVlOiAnZWZmOWJkZGJmMWI0YmRlNWI1OTRkNWI5NjljNWJlNDViNGMyMmM5ZWMwMjE4MmI4MjE2M2FhMjM0NzljMWMzMTg1JyxcbiAgcmVkWWVsbG93Qmx1ZTogJ2E1MDAyNmQ0MzIyY2YxNmU0M2ZjYWM2NGZlZGQ5MGZhZjhjMWRjZjFlY2FiZDZlODc1YWJkMDRhNzRiNDMxMzY5NScsXG4gIHJlZFllbGxvd0dyZWVuOiAnYTUwMDI2ZDQzMjJjZjE2ZTQzZmNhYzYzZmVkZDhkZjlmN2FlZDdlZThlYTRkODZlNjRiYzYxMjI5NjRmMDA2ODM3JyxcbiAgcGlua1llbGxvd0dyZWVuOiAnOGUwMTUyYzAyNjdlZGQ3MmFkZjBiM2Q2ZmFkZGVkZjVmM2VmZTFmMmNhYjZkZTg3ODBiYjQ3NGY5MTI1Mjc2NDE5JyxcbiAgc3BlY3RyYWw6ICc5ZTAxNDJkMTNjNGJmMDcwNGFmY2FjNjNmZWRkOGRmYmY4YjBlMGYzYTFhOWRkYTI2OWJkYTk0Mjg4YjU1ZTRmYTInLFxuICB2aXJpZGlzOiAnNDQwMTU0NDcwZTYxNDgxYTZjNDgyNTc1NDcyZjdkNDQzYTgzNDE0NDg3M2Q0ZThhMzk1NjhjMzU2MDhkMzE2ODhlMmQ3MDhlMmE3ODhlMjc4MThlMjM4ODhlMjE5MThkMWY5ODhiMWZhMDg4MjJhODg0MmFiMDdmMzViNzc5NDNiZjcxNTRjNTY4NjZjYzVkN2FkMTUxOGZkNzQ0YTVkYjM2YmNkZjI3ZDJlMjFiZTllNTFhZmRlNzI1JyxcbiAgbWFnbWE6ICcwMDAwMDQwNDA0MTMwYjA5MjQxNTBlMzcyMDExNGIyYzExNjAzYjBmNzA0YTEwNzk1NzE1N2U2NTFhODA3MjFmODE3ZjI0ODI4YzI5ODE5YTJlODBhODMyN2RiNjM3N2FjNDNjNzVkMTQyNmZkZTQ5NjhlOTU0NjJmMTYwNWRmNzZmNWNmYTdmNWVmYzhmNjVmZTlmNmRmZWFmNzhmZWJmODRmZWNlOTFmZGRlYTBmY2VkYWZmY2ZkYmYnLFxuICBpbmZlcm5vOiAnMDAwMDA0MDQwMzEzMGMwODI2MTcwYzNiMjQwYzRmMzMwYTVmNDIwYTY4NTAwZDZjNWQxMjZlNmIxNzZlNzgxYzZkODYyMTZiOTMyNjY3YTEyYjYyYWUzMDVjYmIzNzU1YzczZTRjZDI0NjQ0ZGQ1MTNhZTY1YzMwZWQ2OTI1ZjM3NzFhZjg4NTBmZmI5NTA2ZmNhNTBhZmNiNTE5ZmFjNjJkZjZkNjQ1ZjJlNjYxZjNmNDg0ZmNmZmE0JyxcbiAgcGxhc21hOiAnMGQwODg3MjMwNjkwMzMwNTk3NDIwMzlkNTAwMmEyNWQwMWE2NmEwMGE4NzgwMWE4ODQwNWE3OTAwZGE0OWMxNzllYTcyMTk4YjEyYTkwYmEzNDg4YzMzZDgwY2I0Nzc5ZDM1MTcxZGE1YTY5ZTE2NDYyZTc2ZTViZWQ3OTUzZjI4MzRjZjY4ZjQ0ZmE5YTNkZmNhNjM2ZmRiMzJmZmVjMDI5ZmNjZTI1ZjlkYzI0ZjVlYTI3ZjBmOTIxJyxcbiAgY2l2aWRpczogJzAwMjA1MTAwMjM1ODAwMjY1ZDAwMjk2MTAxMmI2NTA0MmU2NzA4MzE2OTBkMzQ2YjExMzY2YzE2Mzk2ZDFjM2M2ZTIxM2Y2ZTI2NDI2ZTJjNDU2ZTMxNDc2ZTM3NGE2ZTNjNGQ2ZTQyNTA2ZTQ3NTM2ZDRjNTY2ZDUxNTg2ZTU1NWI2ZTVhNWU2ZTVlNjE2ZTYyNjQ2ZjY2Njc2ZjZhNmE3MDZlNmQ3MTcyNzA3MTc1NzM3Mjc5NzY3MzdjNzk3NDdmN2M3NTgyN2Y3NTg2ODI3Njg5ODU3NzhjODg3NzkwOGI3ODkzOGU3ODk2OTE3ODlhOTQ3ODllOTc3OGExOWI3OGE1OWU3N2E5YTE3N2FlYTU3NWIyYTg3NGI2YWI3M2JiYWY3MWMwYjI2ZmM1YjY2ZGM5Yjk2YWNlYmQ2OGQzYzA2NWQ4YzQ2MmRkYzg1ZmUyY2I1Y2U3Y2Y1OGViZDM1NWYwZDY1MmYzZGE0ZmY3ZGU0Y2ZhZTI0OWZjZTY0NycsXG4gIHJhaW5ib3c6ICc2ZTQwYWE4ODNlYjFhNDNkYjNiZjNjYWZkODNmYTRlZTQzOTVmZTRiODNmZjU3NmVmZjY2NTlmZjc4NDdmZjhjMzhmM2ExMzBlMmI3MmZjZmNjMzZiZWUwNDRhZmYwNWI4ZmY0NTc2ZmY2NWI1MmY2NjczYWYyNzgyOGVhOGQxZGRmYTMxOWQwYjgxY2JlY2IyM2FiZDgyZjk2ZTAzZDgyZTE0YzZlZGI1YTVkZDA2NjRkYmY2ZTQwYWEnLFxuICBzaW5lYm93OiAnZmY0MDQwZmM1ODJhZjQ3MjE4ZTc4ZDBiZDVhNzAzYmZiZjAwYTdkNTAzOGRlNzBiNzJmNDE4NThmYzJhNDBmZjQwMmFmYzU4MThmNDcyMGJlNzhkMDNkNWE3MDBiZmJmMDNhN2Q1MGI4ZGU3MTg3MmY0MmE1OGZjNDA0MGZmNTgyYWZjNzIxOGY0OGQwYmU3YTcwM2Q1YmYwMGJmZDUwM2E3ZTcwYjhkZjQxODcyZmMyYTU4ZmY0MDQwJyxcbiAgdHVyYm86ICcyMzE3MWIzMjIwNGEzZTJhNzE0NTM0OTM0OTNlYWU0YjQ5YzU0YTUzZDc0ODVlZTQ0NTY5ZWU0MDc0ZjUzYzdmZjgzNzhhZjkzMjk1ZjcyZTlmZjQyYmE5ZWYyOGIzZTkyNmJjZTEyNWM1ZDkyNWNkY2YyN2Q1YzYyOWRjYmMyZGUzYjIzMmU5YTczOGVlOWQzZmYzOTM0N2Y2ODk1MGY5ODA1YWZjNzc2NWZkNmU3MGZlNjY3Y2ZkNWU4OGZjNTc5NWZiNTFhMWY4NGJhZGY1NDViOWYxNDBjNWVjM2NkMGU2MzdkYWUwMzRlNGQ5MzFlY2QxMmVmNGM5MmJmYWMwMjlmZmI2MjZmZmFkMjRmZmEyMjNmZjk4MjFmZjhkMWZmZjgyMWRmZjc3MWNmZDZjMWFmNzYxMThmMDU2MTZlODRiMTRkZjQxMTFkNTM4MGZjYjJmMGRjMDI2MGFiNjFmMDdhYzE4MDVhMzEzMDI5YjBmMDA5NTBjMDA5MTBiMDAnLFxuICBicm93bnM6ICdlZWRiYmRlY2NhOTZlOWI5N2FlNGE4NjVkYzk4NTZkMTg5NTRjNzc4NGNjMDY3M2ZiODU1MzZhZDQ0MzM5ZjM2MzInLFxuICB0ZWFsQmx1ZXM6ICdiY2U0ZDg5ZGQzZDE4MWMzY2I2NWIzYzI0NWEyYjkzNjhmYWUzNDdkYTAzMDZhOTMyYzU5ODUnLFxuICB0ZWFsczogJ2JiZGZkZmEyZDRkNThhYzljOTc1YmNiYjYxYjBhZjRkYTVhNDM3OTk5ODJiOGI4YzFlN2Y3ZjEyNzI3MzAwNjY2NycsXG4gIHdhcm1HcmV5czogJ2RjZDRkMGNlYzVjMWMwYjhiNGIzYWFhN2E1OWM5OTk4OTA4YzhiODI3ZjdlNzY3MzcyNjg2NjY2NWM1YTU5NTA0ZScsXG4gIGdvbGRHcmVlbjogJ2Y0ZDE2NmQ1Y2E2MGI2YzM1Yzk4YmI1OTdjYjI1NzYwYTY1NjRiOWM1MzNmOGY0ZjMzODM0YTI1Nzc0MDE0NmMzNicsXG4gIGdvbGRPcmFuZ2U6ICdmNGQxNjZmOGJlNWNmOGFhNGNmNTk4M2JmMzg1MmFlZjcwMWJlMjYyMWZkNjUzMjJjNTQ5MjNiMTQyMjM5ZTNhMjYnLFxuICBnb2xkUmVkOiAnZjRkMTY2ZjZiZTU5ZjlhYTUxZmM5NjRlZjY4MzRiZWU3MzRhZTU2MjQ5ZGI1MjQ3Y2Y0MjQ0YzQzMTQxYjcxZDNlJyxcbiAgbGlnaHRHcmV5UmVkOiAnZWZlOWU2ZTFkYWQ3ZDVjYmM4YzhiZGI5YmJhZWE5Y2Q5NjdkZGM3YjQzZTE1ZjE5ZGY0MDExZGMwMDBiJyxcbiAgbGlnaHRHcmV5VGVhbDogJ2U0ZWFlYWQ2ZGNkZGM4Y2VkMmI3YzJjN2E2YjRiYzY0YjBiZjIyYTZjMzIyOTVjMTFmODViZTE4NzZiYycsXG4gIGxpZ2h0TXVsdGk6ICdlMGYxZjJjNGU5ZDBiMGRlOWZkMGUxODFmNmUwNzJmNmMwNTNmMzk5M2VmNzc0NDBlZjRhM2MnLFxuICBsaWdodE9yYW5nZTogJ2YyZTdkYWY3ZDViYWY5YzQ5OWZhYjE4NGZhOWM3M2Y2ODk2N2VmNzg2MGU4NjQ1YmRlNTE1YmQ0M2Q1YicsXG4gIGxpZ2h0VGVhbEJsdWU6ICdlM2U5ZTBjMGRjY2Y5YWNlY2E3YWJmYzg1OWFmYzAzODlmYjkzMjhkYWQyZjdjYTAyNzZiOTUyNTU5ODgnLFxuICBkYXJrQmx1ZTogJzMyMzIzMjJkNDY2ODFhNWM5MzAwNzRhZjAwOGNiZjA1YTdjZTI1YzBkZDM4ZGFlZDUwZjNmYWZmZmZmZicsXG4gIGRhcmtHb2xkOiAnM2MzYzNjNTg0YjM3NzI1ZTM0OGM3NjMxYWU4YjJiY2ZhNDI0ZWNjMzFlZjlkZTMwZmZmMTg0ZmZmZmZmJyxcbiAgZGFya0dyZWVuOiAnM2EzYTNhMjE1NzQ4MDA2ZjRkMDQ4OTQyNDg5ZTQyNzZiMzQwYTZjNjNkZDJkODM2ZmZlYjJjZmZmZmFhJyxcbiAgZGFya011bHRpOiAnMzczNzM3MWY1Mjg3MTk3ZDhjMjlhODY5OTVjZTNmZmZlODAwZmZmZmZmJyxcbiAgZGFya1JlZDogJzM0MzQzNDcwMzYzMzllM2MzOGNjNDAzN2U3NWQxZWVjODYyMGVlYWIyOWYwY2UzMmZmZWIyYydcbn07XG5jb25zdCBkaXNjcmV0ZSA9IHtcbiAgYWNjZW50OiBzY2hlbWVBY2NlbnQsXG4gIGNhdGVnb3J5MTA6IHNjaGVtZUNhdGVnb3J5MTAsXG4gIGNhdGVnb3J5MjA6ICcxZjc3YjRhZWM3ZThmZjdmMGVmZmJiNzgyY2EwMmM5OGRmOGFkNjI3MjhmZjk4OTY5NDY3YmRjNWIwZDU4YzU2NGJjNDljOTRlMzc3YzJmN2I2ZDI3ZjdmN2ZjN2M3YzdiY2JkMjJkYmRiOGQxN2JlY2Y5ZWRhZTUnLFxuICBjYXRlZ29yeTIwYjogJzM5M2I3OTUyNTRhMzZiNmVjZjljOWVkZTYzNzkzOThjYTI1MmI1Y2Y2YmNlZGI5YzhjNmQzMWJkOWUzOWU3YmE1MmU3Y2I5NDg0M2MzOWFkNDk0YWQ2NjE2YmU3OTY5YzdiNDE3M2E1NTE5NGNlNmRiZGRlOWVkNicsXG4gIGNhdGVnb3J5MjBjOiAnMzE4MmJkNmJhZWQ2OWVjYWUxYzZkYmVmZTY1NTBkZmQ4ZDNjZmRhZTZiZmRkMGEyMzFhMzU0NzRjNDc2YTFkOTliYzdlOWMwNzU2YmIxOWU5YWM4YmNiZGRjZGFkYWViNjM2MzYzOTY5Njk2YmRiZGJkZDlkOWQ5JyxcbiAgZGFyazI6IHNjaGVtZURhcmsyLFxuICBvYnNlcnZhYmxlMTA6IHNjaGVtZU9ic2VydmFibGUxMCxcbiAgcGFpcmVkOiBzY2hlbWVQYWlyZWQsXG4gIHBhc3RlbDE6IHNjaGVtZVBhc3RlbDEsXG4gIHBhc3RlbDI6IHNjaGVtZVBhc3RlbDIsXG4gIHNldDE6IHNjaGVtZVNldDEsXG4gIHNldDI6IHNjaGVtZVNldDIsXG4gIHNldDM6IHNjaGVtZVNldDMsXG4gIHRhYmxlYXUxMDogJzRjNzhhOGY1ODUxOGU0NTc1NjcyYjdiMjU0YTI0YmVlY2EzYmIyNzlhMmZmOWRhNjlkNzU1ZGJhYjBhYycsXG4gIHRhYmxlYXUyMDogJzRjNzhhODllY2FlOWY1ODUxOGZmYmY3OTU0YTI0Yjg4ZDI3YWI3OWEyMGYyY2Y1YjQzOTg5NDgzYmNiNmU0NTc1NmZmOWQ5ODc5NzA2ZWJhYjBhY2Q2NzE5NWZjYmZkMmIyNzlhMmQ2YTVjOTllNzY1ZmQ4YjVhNSdcbn07XG5cbmZ1bmN0aW9uIGNvbG9ycyhwYWxldHRlKSB7XG4gIGlmIChpc0FycmF5KHBhbGV0dGUpKSByZXR1cm4gcGFsZXR0ZTtcbiAgY29uc3QgbiA9IHBhbGV0dGUubGVuZ3RoIC8gNiB8IDAsXG4gICAgYyA9IG5ldyBBcnJheShuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOykge1xuICAgIGNbaV0gPSAnIycgKyBwYWxldHRlLnNsaWNlKGkgKiA2LCArK2kgKiA2KTtcbiAgfVxuICByZXR1cm4gYztcbn1cbmZ1bmN0aW9uIGFwcGx5KF8sIGYpIHtcbiAgZm9yIChjb25zdCBrIGluIF8pIHNjaGVtZShrLCBmKF9ba10pKTtcbn1cbmNvbnN0IHNjaGVtZXMgPSB7fTtcbmFwcGx5KGRpc2NyZXRlLCBjb2xvcnMpO1xuYXBwbHkoY29udGludW91cywgXyA9PiBpbnRlcnBvbGF0ZUNvbG9ycyhjb2xvcnMoXykpKTtcbmZ1bmN0aW9uIHNjaGVtZShuYW1lLCBzY2hlbWUpIHtcbiAgbmFtZSA9IG5hbWUgJiYgbmFtZS50b0xvd2VyQ2FzZSgpO1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBzY2hlbWVzW25hbWVdID0gc2NoZW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlbWVzW25hbWVdO1xuICB9XG59XG5cbmNvbnN0IFN5bWJvbExlZ2VuZCA9ICdzeW1ib2wnO1xuY29uc3QgRGlzY3JldGVMZWdlbmQgPSAnZGlzY3JldGUnO1xuY29uc3QgR3JhZGllbnRMZWdlbmQgPSAnZ3JhZGllbnQnO1xuXG5jb25zdCBkZWZhdWx0Rm9ybWF0dGVyID0gdmFsdWUgPT4gaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5tYXAodiA9PiBTdHJpbmcodikpIDogU3RyaW5nKHZhbHVlKTtcbmNvbnN0IGFzY2VuZGluZyA9IChhLCBiKSA9PiBhWzFdIC0gYlsxXTtcbmNvbnN0IGRlc2NlbmRpbmcgPSAoYSwgYikgPT4gYlsxXSAtIGFbMV07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSB0aWNrIGNvdW50IG9yIGludGVydmFsIGZ1bmN0aW9uLlxuICogQHBhcmFtIHtTY2FsZX0gc2NhbGUgLSBUaGUgc2NhbGUgZm9yIHdoaWNoIHRvIGdlbmVyYXRlIHRpY2sgdmFsdWVzLlxuICogQHBhcmFtIHsqfSBjb3VudCAtIFRoZSBkZXNpcmVkIHRpY2sgY291bnQgb3IgaW50ZXJ2YWwgc3BlY2lmaWVyLlxuICogQHBhcmFtIHtudW1iZXJ9IG1pblN0ZXAgLSBUaGUgZGVzaXJlZCBtaW5pbXVtIHN0ZXAgYmV0d2VlbiB0aWNrIHZhbHVlcy5cbiAqIEByZXR1cm4geyp9IC0gVGhlIHRpY2sgY291bnQgb3IgaW50ZXJ2YWwgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIHRpY2tDb3VudChzY2FsZSwgY291bnQsIG1pblN0ZXApIHtcbiAgbGV0IHN0ZXA7XG4gIGlmIChpc051bWJlcihjb3VudCkpIHtcbiAgICBpZiAoc2NhbGUuYmlucykge1xuICAgICAgY291bnQgPSBNYXRoLm1heChjb3VudCwgc2NhbGUuYmlucy5sZW5ndGgpO1xuICAgIH1cbiAgICBpZiAobWluU3RlcCAhPSBudWxsKSB7XG4gICAgICBjb3VudCA9IE1hdGgubWluKGNvdW50LCBNYXRoLmZsb29yKHNwYW4oc2NhbGUuZG9tYWluKCkpIC8gbWluU3RlcCB8fCAxKSArIDEpO1xuICAgIH1cbiAgfVxuICBpZiAoaXNPYmplY3QoY291bnQpKSB7XG4gICAgc3RlcCA9IGNvdW50LnN0ZXA7XG4gICAgY291bnQgPSBjb3VudC5pbnRlcnZhbDtcbiAgfVxuICBpZiAoaXNTdHJpbmcoY291bnQpKSB7XG4gICAgY291bnQgPSBzY2FsZS50eXBlID09PSBUaW1lID8gdGltZUludGVydmFsKGNvdW50KSA6IHNjYWxlLnR5cGUgPT0gVVRDID8gdXRjSW50ZXJ2YWwoY291bnQpIDogZXJyb3IoJ09ubHkgdGltZSBhbmQgdXRjIHNjYWxlcyBhY2NlcHQgaW50ZXJ2YWwgc3RyaW5ncy4nKTtcbiAgICBpZiAoc3RlcCkgY291bnQgPSBjb3VudC5ldmVyeShzdGVwKTtcbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG5cbi8qKlxuICogRmlsdGVyIGEgc2V0IG9mIGNhbmRpZGF0ZSB0aWNrIHZhbHVlcywgZW5zdXJpbmcgdGhhdCBvbmx5IHRpY2sgdmFsdWVzXG4gKiB0aGF0IGxpZSB3aXRoaW4gdGhlIHNjYWxlIHJhbmdlIGFyZSBpbmNsdWRlZC5cbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlIC0gVGhlIHNjYWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IHRpY2tzIC0gVGhlIGNhbmRpZGF0ZSB0aWNrIHZhbHVlcy5cbiAqIEBwYXJhbSB7Kn0gY291bnQgLSBUaGUgdGljayBjb3VudCBvciBpbnRlcnZhbCBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0FycmF5PCo+fSAtIFRoZSBmaWx0ZXJlZCB0aWNrIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gdmFsaWRUaWNrcyhzY2FsZSwgdGlja3MsIGNvdW50KSB7XG4gIGxldCByYW5nZSA9IHNjYWxlLnJhbmdlKCksXG4gICAgbG8gPSByYW5nZVswXSxcbiAgICBoaSA9IHBlZWsocmFuZ2UpLFxuICAgIGNtcCA9IGFzY2VuZGluZztcbiAgaWYgKGxvID4gaGkpIHtcbiAgICByYW5nZSA9IGhpO1xuICAgIGhpID0gbG87XG4gICAgbG8gPSByYW5nZTtcbiAgICBjbXAgPSBkZXNjZW5kaW5nO1xuICB9XG4gIGxvID0gTWF0aC5mbG9vcihsbyk7XG4gIGhpID0gTWF0aC5jZWlsKGhpKTtcblxuICAvLyBmaWx0ZXIgdGlja3MgdG8gdmFsaWQgdmFsdWVzIHdpdGhpbiB0aGUgcmFuZ2VcbiAgLy8gYWRkaXRpb25hbGx5IHNvcnQgdGlja3MgaW4gcmFuZ2Ugb3JkZXIgKCMyNTc5KVxuICB0aWNrcyA9IHRpY2tzLm1hcCh2ID0+IFt2LCBzY2FsZSh2KV0pLmZpbHRlcihfID0+IGxvIDw9IF9bMV0gJiYgX1sxXSA8PSBoaSkuc29ydChjbXApLm1hcChfID0+IF9bMF0pO1xuICBpZiAoY291bnQgPiAwICYmIHRpY2tzLmxlbmd0aCA+IDEpIHtcbiAgICBjb25zdCBlbmRwb2ludHMgPSBbdGlja3NbMF0sIHBlZWsodGlja3MpXTtcbiAgICB3aGlsZSAodGlja3MubGVuZ3RoID4gY291bnQgJiYgdGlja3MubGVuZ3RoID49IDMpIHtcbiAgICAgIHRpY2tzID0gdGlja3MuZmlsdGVyKChfLCBpKSA9PiAhKGkgJSAyKSk7XG4gICAgfVxuICAgIGlmICh0aWNrcy5sZW5ndGggPCAzKSB7XG4gICAgICB0aWNrcyA9IGVuZHBvaW50cztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRpY2tzO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIHRpY2sgdmFsdWVzIGZvciB0aGUgZ2l2ZW4gc2NhbGUgYW5kIGFwcHJveGltYXRlIHRpY2sgY291bnQgb3JcbiAqIGludGVydmFsIHZhbHVlLiBJZiB0aGUgc2NhbGUgaGFzIGEgJ3RpY2tzJyBtZXRob2QsIGl0IHdpbGwgYmUgdXNlZCB0b1xuICogZ2VuZXJhdGUgdGhlIHRpY2tzLCB3aXRoIHRoZSBjb3VudCBhcmd1bWVudCBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuIElmIHRoZVxuICogc2NhbGUgbGFja3MgYSAndGlja3MnIG1ldGhvZCwgdGhlIGZ1bGwgc2NhbGUgZG9tYWluIHdpbGwgYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0ge1NjYWxlfSBzY2FsZSAtIFRoZSBzY2FsZSBmb3Igd2hpY2ggdG8gZ2VuZXJhdGUgdGljayB2YWx1ZXMuXG4gKiBAcGFyYW0geyp9IFtjb3VudF0gLSBUaGUgYXBwcm94aW1hdGUgbnVtYmVyIG9mIGRlc2lyZWQgdGlja3MuXG4gKiBAcmV0dXJuIHtBcnJheTwqPn0gLSBUaGUgZ2VuZXJhdGVkIHRpY2sgdmFsdWVzLlxuICovXG5mdW5jdGlvbiB0aWNrVmFsdWVzKHNjYWxlLCBjb3VudCkge1xuICByZXR1cm4gc2NhbGUuYmlucyA/IHZhbGlkVGlja3Moc2NhbGUsIHNjYWxlLmJpbnMsIGNvdW50KSA6IHNjYWxlLnRpY2tzID8gc2NhbGUudGlja3MoY291bnQpIDogc2NhbGUuZG9tYWluKCk7XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBsYWJlbCBmb3JtYXQgZnVuY3Rpb24gZm9yIGEgc2NhbGUuIElmIHRoZSBzY2FsZSBoYXMgYVxuICogJ3RpY2tGb3JtYXQnIG1ldGhvZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoZSBmb3JtYXR0ZXIsIHdpdGggdGhlXG4gKiBjb3VudCBhbmQgc3BlY2lmaWVyIGFyZ3VtZW50cyBwYXNzZWQgYXMgcGFyYW1ldGVycy4gSWYgdGhlIHNjYWxlIGxhY2tzIGFcbiAqICd0aWNrRm9ybWF0JyBtZXRob2QsIHRoZSByZXR1cm5lZCBmb3JtYXR0ZXIgcGVyZm9ybXMgc2ltcGxlIHN0cmluZyBjb2VyY2lvbi5cbiAqIElmIHRoZSBpbnB1dCBzY2FsZSBpcyBhIGxvZ2FyaXRobWljIHNjYWxlIGFuZCB0aGUgZm9ybWF0IHNwZWNpZmllciBkb2VzIG5vdFxuICogaW5kaWNhdGUgYSBkZXNpcmVkIGRlY2ltYWwgcHJlY2lzaW9uLCBhIHNwZWNpYWwgdmFyaWFibGUgcHJlY2lzaW9uIGZvcm1hdHRlclxuICogdGhhdCBhdXRvbWF0aWNhbGx5IHRyaW1zIHRyYWlsaW5nIHplcm9lcyB3aWxsIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7U2NhbGV9IHNjYWxlIC0gVGhlIHNjYWxlIGZvciB3aGljaCB0byBnZW5lcmF0ZSB0aGUgbGFiZWwgZm9ybWF0dGVyLlxuICogQHBhcmFtIHsqfSBbY291bnRdIC0gVGhlIGFwcHJveGltYXRlIG51bWJlciBvZiBkZXNpcmVkIHRpY2tzLlxuICogQHBhcmFtIHtzdHJpbmd9IFtzcGVjaWZpZXJdIC0gVGhlIGZvcm1hdCBzcGVjaWZpZXIuIE11c3QgYmUgYSBsZWdhbCBkM1xuICogICBzcGVjaWZpZXIgc3RyaW5nIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL2QzL2QzLWZvcm1hdCNmb3JtYXRTcGVjaWZpZXIpIG9yXG4gKiAgIHRpbWUgbXVsdGktZm9ybWF0IHNwZWNpZmllciBvYmplY3QuXG4gKiBAcmV0dXJuIHtmdW5jdGlvbigqKTpzdHJpbmd9IC0gVGhlIGdlbmVyYXRlZCBsYWJlbCBmb3JtYXR0ZXIuXG4gKi9cbmZ1bmN0aW9uIHRpY2tGb3JtYXQobG9jYWxlLCBzY2FsZSwgY291bnQsIHNwZWNpZmllciwgZm9ybWF0VHlwZSwgbm9Ta2lwKSB7XG4gIGNvbnN0IHR5cGUgPSBzY2FsZS50eXBlO1xuICBsZXQgZm9ybWF0ID0gZGVmYXVsdEZvcm1hdHRlcjtcbiAgaWYgKHR5cGUgPT09IFRpbWUgfHwgZm9ybWF0VHlwZSA9PT0gVGltZSkge1xuICAgIGZvcm1hdCA9IGxvY2FsZS50aW1lRm9ybWF0KHNwZWNpZmllcik7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gVVRDIHx8IGZvcm1hdFR5cGUgPT09IFVUQykge1xuICAgIGZvcm1hdCA9IGxvY2FsZS51dGNGb3JtYXQoc3BlY2lmaWVyKTtcbiAgfSBlbHNlIGlmIChpc0xvZ2FyaXRobWljKHR5cGUpKSB7XG4gICAgY29uc3QgdmFyZm10ID0gbG9jYWxlLmZvcm1hdEZsb2F0KHNwZWNpZmllcik7XG4gICAgaWYgKG5vU2tpcCB8fCBzY2FsZS5iaW5zKSB7XG4gICAgICBmb3JtYXQgPSB2YXJmbXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0aWNrTG9nKHNjYWxlLCBjb3VudCwgZmFsc2UpO1xuICAgICAgZm9ybWF0ID0gXyA9PiB0ZXN0KF8pID8gdmFyZm10KF8pIDogJyc7XG4gICAgfVxuICB9IGVsc2UgaWYgKHNjYWxlLnRpY2tGb3JtYXQpIHtcbiAgICAvLyBpZiBkMyBzY2FsZSBoYXMgdGlja0Zvcm1hdCwgaXQgbXVzdCBiZSBjb250aW51b3VzXG4gICAgY29uc3QgZCA9IHNjYWxlLmRvbWFpbigpO1xuICAgIGZvcm1hdCA9IGxvY2FsZS5mb3JtYXRTcGFuKGRbMF0sIGRbZC5sZW5ndGggLSAxXSwgY291bnQsIHNwZWNpZmllcik7XG4gIH0gZWxzZSBpZiAoc3BlY2lmaWVyKSB7XG4gICAgZm9ybWF0ID0gbG9jYWxlLmZvcm1hdChzcGVjaWZpZXIpO1xuICB9XG4gIHJldHVybiBmb3JtYXQ7XG59XG5mdW5jdGlvbiB0aWNrTG9nKHNjYWxlLCBjb3VudCwgdmFsdWVzKSB7XG4gIGNvbnN0IHRpY2tzID0gdGlja1ZhbHVlcyhzY2FsZSwgY291bnQpLFxuICAgIGJhc2UgPSBzY2FsZS5iYXNlKCksXG4gICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgIGsgPSBNYXRoLm1heCgxLCBiYXNlICogY291bnQgLyB0aWNrcy5sZW5ndGgpO1xuXG4gIC8vIGFwcGx5IGQzLXNjYWxlJ3MgbG9nIGZvcm1hdCBmaWx0ZXIgY3JpdGVyaWFcbiAgY29uc3QgdGVzdCA9IGQgPT4ge1xuICAgIGxldCBpID0gZCAvIE1hdGgucG93KGJhc2UsIE1hdGgucm91bmQoTWF0aC5sb2coZCkgLyBsb2diKSk7XG4gICAgaWYgKGkgKiBiYXNlIDwgYmFzZSAtIDAuNSkgaSAqPSBiYXNlO1xuICAgIHJldHVybiBpIDw9IGs7XG4gIH07XG4gIHJldHVybiB2YWx1ZXMgPyB0aWNrcy5maWx0ZXIodGVzdCkgOiB0ZXN0O1xufVxuXG5jb25zdCBzeW1ib2xzID0ge1xuICBbUXVhbnRpbGVdOiAncXVhbnRpbGVzJyxcbiAgW1F1YW50aXplXTogJ3RocmVzaG9sZHMnLFxuICBbVGhyZXNob2xkXTogJ2RvbWFpbidcbn07XG5jb25zdCBmb3JtYXRzID0ge1xuICBbUXVhbnRpbGVdOiAncXVhbnRpbGVzJyxcbiAgW1F1YW50aXplXTogJ2RvbWFpbidcbn07XG5mdW5jdGlvbiBsYWJlbFZhbHVlcyhzY2FsZSwgY291bnQpIHtcbiAgcmV0dXJuIHNjYWxlLmJpbnMgPyBiaW5WYWx1ZXMoc2NhbGUuYmlucykgOiBzY2FsZS50eXBlID09PSBMb2cgPyB0aWNrTG9nKHNjYWxlLCBjb3VudCwgdHJ1ZSkgOiBzeW1ib2xzW3NjYWxlLnR5cGVdID8gdGhyZXNob2xkVmFsdWVzKHNjYWxlW3N5bWJvbHNbc2NhbGUudHlwZV1dKCkpIDogdGlja1ZhbHVlcyhzY2FsZSwgY291bnQpO1xufVxuZnVuY3Rpb24gdGhyZXNob2xkRm9ybWF0KGxvY2FsZSwgc2NhbGUsIHNwZWNpZmllcikge1xuICBjb25zdCBfID0gc2NhbGVbZm9ybWF0c1tzY2FsZS50eXBlXV0oKSxcbiAgICBuID0gXy5sZW5ndGg7XG4gIGxldCBkID0gbiA+IDEgPyBfWzFdIC0gX1swXSA6IF9bMF0sXG4gICAgaTtcbiAgZm9yIChpID0gMTsgaSA8IG47ICsraSkge1xuICAgIGQgPSBNYXRoLm1pbihkLCBfW2ldIC0gX1tpIC0gMV0pO1xuICB9XG5cbiAgLy8gdGlja0NvdW50ID0gMyB0aWNrcyB0aW1lcyAxMCBmb3IgaW5jcmVhc2VkIHJlc29sdXRpb25cbiAgcmV0dXJuIGxvY2FsZS5mb3JtYXRTcGFuKDAsIGQsIDMgKiAxMCwgc3BlY2lmaWVyKTtcbn1cbmZ1bmN0aW9uIHRocmVzaG9sZFZhbHVlcyh0aHJlc2hvbGRzKSB7XG4gIGNvbnN0IHZhbHVlcyA9IFstSW5maW5pdHldLmNvbmNhdCh0aHJlc2hvbGRzKTtcbiAgdmFsdWVzLm1heCA9ICtJbmZpbml0eTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cbmZ1bmN0aW9uIGJpblZhbHVlcyhiaW5zKSB7XG4gIGNvbnN0IHZhbHVlcyA9IGJpbnMuc2xpY2UoMCwgLTEpO1xuICB2YWx1ZXMubWF4ID0gcGVlayhiaW5zKTtcbiAgcmV0dXJuIHZhbHVlcztcbn1cbmNvbnN0IGlzRGlzY3JldGVSYW5nZSA9IHNjYWxlID0+IHN5bWJvbHNbc2NhbGUudHlwZV0gfHwgc2NhbGUuYmlucztcbmZ1bmN0aW9uIGxhYmVsRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCB0eXBlLCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUsIG5vU2tpcCkge1xuICBjb25zdCBmb3JtYXQgPSBmb3JtYXRzW3NjYWxlLnR5cGVdICYmIGZvcm1hdFR5cGUgIT09IFRpbWUgJiYgZm9ybWF0VHlwZSAhPT0gVVRDID8gdGhyZXNob2xkRm9ybWF0KGxvY2FsZSwgc2NhbGUsIHNwZWNpZmllcikgOiB0aWNrRm9ybWF0KGxvY2FsZSwgc2NhbGUsIGNvdW50LCBzcGVjaWZpZXIsIGZvcm1hdFR5cGUsIG5vU2tpcCk7XG4gIHJldHVybiB0eXBlID09PSBTeW1ib2xMZWdlbmQgJiYgaXNEaXNjcmV0ZVJhbmdlKHNjYWxlKSA/IGZvcm1hdFJhbmdlKGZvcm1hdCkgOiB0eXBlID09PSBEaXNjcmV0ZUxlZ2VuZCA/IGZvcm1hdERpc2NyZXRlKGZvcm1hdCkgOiBmb3JtYXRQb2ludChmb3JtYXQpO1xufVxuY29uc3QgZm9ybWF0UmFuZ2UgPSBmb3JtYXQgPT4gKHZhbHVlLCBpbmRleCwgYXJyYXkpID0+IHtcbiAgY29uc3QgbGltaXQgPSBnZXQoYXJyYXlbaW5kZXggKyAxXSwgZ2V0KGFycmF5Lm1heCwgK0luZmluaXR5KSksXG4gICAgbG8gPSBmb3JtYXRWYWx1ZSh2YWx1ZSwgZm9ybWF0KSxcbiAgICBoaSA9IGZvcm1hdFZhbHVlKGxpbWl0LCBmb3JtYXQpO1xuICByZXR1cm4gbG8gJiYgaGkgPyBsbyArICcgXFx1MjAxMyAnICsgaGkgOiBoaSA/ICc8ICcgKyBoaSA6ICdcXHUyMjY1ICcgKyBsbztcbn07XG5jb25zdCBnZXQgPSAodmFsdWUsIGRmbHQpID0+IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IGRmbHQ7XG5jb25zdCBmb3JtYXREaXNjcmV0ZSA9IGZvcm1hdCA9PiAodmFsdWUsIGluZGV4KSA9PiBpbmRleCA/IGZvcm1hdCh2YWx1ZSkgOiBudWxsO1xuY29uc3QgZm9ybWF0UG9pbnQgPSBmb3JtYXQgPT4gdmFsdWUgPT4gZm9ybWF0KHZhbHVlKTtcbmNvbnN0IGZvcm1hdFZhbHVlID0gKHZhbHVlLCBmb3JtYXQpID0+IE51bWJlci5pc0Zpbml0ZSh2YWx1ZSkgPyBmb3JtYXQodmFsdWUpIDogbnVsbDtcbmZ1bmN0aW9uIGxhYmVsRnJhY3Rpb24oc2NhbGUpIHtcbiAgY29uc3QgZG9tYWluID0gc2NhbGUuZG9tYWluKCksXG4gICAgY291bnQgPSBkb21haW4ubGVuZ3RoIC0gMTtcbiAgbGV0IGxvID0gK2RvbWFpblswXSxcbiAgICBoaSA9ICtwZWVrKGRvbWFpbiksXG4gICAgc3BhbiA9IGhpIC0gbG87XG4gIGlmIChzY2FsZS50eXBlID09PSBUaHJlc2hvbGQpIHtcbiAgICBjb25zdCBhZGp1c3QgPSBjb3VudCA/IHNwYW4gLyBjb3VudCA6IDAuMTtcbiAgICBsbyAtPSBhZGp1c3Q7XG4gICAgaGkgKz0gYWRqdXN0O1xuICAgIHNwYW4gPSBoaSAtIGxvO1xuICB9XG4gIHJldHVybiB2YWx1ZSA9PiAodmFsdWUgLSBsbykgLyBzcGFuO1xufVxuXG5mdW5jdGlvbiBmb3JtYXQobG9jYWxlLCBzY2FsZSwgc3BlY2lmaWVyLCBmb3JtYXRUeXBlKSB7XG4gIGNvbnN0IHR5cGUgPSBmb3JtYXRUeXBlIHx8IHNjYWxlLnR5cGU7XG5cbiAgLy8gcmVwbGFjZSBhYmJyZXZpYXRlZCB0aW1lIHNwZWNpZmllcnMgdG8gaW1wcm92ZSBzY3JlZW4gcmVhZGVyIGV4cGVyaWVuY2VcbiAgaWYgKGlzU3RyaW5nKHNwZWNpZmllcikgJiYgaXNUZW1wb3JhbCh0eXBlKSkge1xuICAgIHNwZWNpZmllciA9IHNwZWNpZmllci5yZXBsYWNlKC8lYS9nLCAnJUEnKS5yZXBsYWNlKC8lYi9nLCAnJUInKTtcbiAgfVxuICByZXR1cm4gIXNwZWNpZmllciAmJiB0eXBlID09PSBUaW1lID8gbG9jYWxlLnRpbWVGb3JtYXQoJyVBLCAlZCAlQiAlWSwgJVgnKSA6ICFzcGVjaWZpZXIgJiYgdHlwZSA9PT0gVVRDID8gbG9jYWxlLnV0Y0Zvcm1hdCgnJUEsICVkICVCICVZLCAlWCBVVEMnKSA6IGxhYmVsRm9ybWF0KGxvY2FsZSwgc2NhbGUsIDUsIG51bGwsIHNwZWNpZmllciwgZm9ybWF0VHlwZSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBkb21haW5DYXB0aW9uKGxvY2FsZSwgc2NhbGUsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIGNvbnN0IG1heCA9IE1hdGgubWF4KDMsIG9wdC5tYXhsZW4gfHwgNyksXG4gICAgZm10ID0gZm9ybWF0KGxvY2FsZSwgc2NhbGUsIG9wdC5mb3JtYXQsIG9wdC5mb3JtYXRUeXBlKTtcblxuICAvLyBpZiBzY2FsZSBicmVha3MgZG9tYWluIGludG8gYmlucywgZGVzY3JpYmUgYm91bmRhcmllc1xuICBpZiAoaXNEaXNjcmV0aXppbmcoc2NhbGUudHlwZSkpIHtcbiAgICBjb25zdCB2ID0gbGFiZWxWYWx1ZXMoc2NhbGUpLnNsaWNlKDEpLm1hcChmbXQpLFxuICAgICAgbiA9IHYubGVuZ3RoO1xuICAgIHJldHVybiBgJHtufSBib3VuZGFyJHtuID09PSAxID8gJ3knIDogJ2llcyd9OiAke3Yuam9pbignLCAnKX1gO1xuICB9XG5cbiAgLy8gaWYgc2NhbGUgZG9tYWluIGlzIGRpc2NyZXRlLCBsaXN0IHZhbHVlc1xuICBlbHNlIGlmIChpc0Rpc2NyZXRlKHNjYWxlLnR5cGUpKSB7XG4gICAgY29uc3QgZCA9IHNjYWxlLmRvbWFpbigpLFxuICAgICAgbiA9IGQubGVuZ3RoLFxuICAgICAgdiA9IG4gPiBtYXggPyBkLnNsaWNlKDAsIG1heCAtIDIpLm1hcChmbXQpLmpvaW4oJywgJykgKyAnLCBlbmRpbmcgd2l0aCAnICsgZC5zbGljZSgtMSkubWFwKGZtdCkgOiBkLm1hcChmbXQpLmpvaW4oJywgJyk7XG4gICAgcmV0dXJuIGAke259IHZhbHVlJHtuID09PSAxID8gJycgOiAncyd9OiAke3Z9YDtcbiAgfVxuXG4gIC8vIGlmIHNjYWxlIGRvbWFpbiBpcyBjb250aW51b3VzLCBkZXNjcmliZSB2YWx1ZSByYW5nZVxuICBlbHNlIHtcbiAgICBjb25zdCBkID0gc2NhbGUuZG9tYWluKCk7XG4gICAgcmV0dXJuIGB2YWx1ZXMgZnJvbSAke2ZtdChkWzBdKX0gdG8gJHtmbXQocGVlayhkKSl9YDtcbiAgfVxufVxuXG5leHBvcnQgeyBCYW5kLCBCaW5PcmRpbmFsLCBEaXNjcmV0ZUxlZ2VuZCwgRGl2ZXJnaW5nLCBHcmFkaWVudExlZ2VuZCwgSWRlbnRpdHksIExpbmVhciwgTG9nLCBPcmRpbmFsLCBQb2ludCwgUG93LCBRdWFudGlsZSwgUXVhbnRpemUsIFNlcXVlbnRpYWwsIFNxcnQsIFN5bWJvbExlZ2VuZCwgU3ltbG9nLCBUaHJlc2hvbGQsIFRpbWUsIFVUQywgYmFuZFNwYWNlLCBkb21haW5DYXB0aW9uLCBpbnRlcnBvbGF0ZSwgaW50ZXJwb2xhdGVDb2xvcnMsIGludGVycG9sYXRlUmFuZ2UsIGlzQ29udGludW91cywgaXNEaXNjcmV0ZSwgaXNEaXNjcmV0aXppbmcsIGlzSW50ZXJwb2xhdGluZywgaXNMb2dhcml0aG1pYywgaXNRdWFudGlsZSwgaXNSZWdpc3RlcmVkU2NhbGUsIGlzVGVtcG9yYWwsIGlzVmFsaWRTY2FsZVR5cGUsIGxhYmVsRm9ybWF0LCBsYWJlbEZyYWN0aW9uLCBsYWJlbFZhbHVlcywgcXVhbnRpemVJbnRlcnBvbGF0b3IsIHJlZ2lzdGVyU2NhbGUsIHNjYWxlLCBzY2FsZUNvcHksIHNjYWxlRnJhY3Rpb24sIHNjaGVtZSwgdGlja0NvdW50LCB0aWNrRm9ybWF0LCB0aWNrVmFsdWVzLCB2YWxpZFRpY2tzIH07XG4iLCJpbXBvcnQgeyBoYXNPd25Qcm9wZXJ0eSwgaXNGdW5jdGlvbiwgaW5oZXJpdHMsIHRydXRoeSwgbHJ1Q2FjaGUsIGlzQXJyYXksIGVycm9yLCB0b1NldCwgYXJyYXksIHBlZWssIGV4dGVuZCwgaXNOdW1iZXIsIGlzT2JqZWN0IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IGN1cnZlQmFzaXMsIGN1cnZlQmFzaXNDbG9zZWQsIGN1cnZlQmFzaXNPcGVuLCBjdXJ2ZUJ1bmRsZSwgY3VydmVDYXJkaW5hbCwgY3VydmVDYXJkaW5hbE9wZW4sIGN1cnZlQ2FyZGluYWxDbG9zZWQsIGN1cnZlQ2F0bXVsbFJvbSwgY3VydmVDYXRtdWxsUm9tQ2xvc2VkLCBjdXJ2ZUNhdG11bGxSb21PcGVuLCBjdXJ2ZUxpbmVhciwgY3VydmVMaW5lYXJDbG9zZWQsIGN1cnZlTW9ub3RvbmVZLCBjdXJ2ZU1vbm90b25lWCwgY3VydmVOYXR1cmFsLCBjdXJ2ZVN0ZXAsIGN1cnZlU3RlcEFmdGVyLCBjdXJ2ZVN0ZXBCZWZvcmUsIGFyYyBhcyBhcmMkMiwgYXJlYSBhcyBhcmVhJDIsIGxpbmUgYXMgbGluZSQyLCBzeW1ib2wgYXMgc3ltYm9sJDIgfSBmcm9tICdkMy1zaGFwZSc7XG5pbXBvcnQgeyBwYXRoIGFzIHBhdGgkMyB9IGZyb20gJ2QzLXBhdGgnO1xuZXhwb3J0IHsgcGF0aCB9IGZyb20gJ2QzLXBhdGgnO1xuaW1wb3J0IHsgaW1hZ2UgYXMgaW1hZ2UkMSwgY2FudmFzIH0gZnJvbSAndmVnYS1jYW52YXMnO1xuaW1wb3J0IHsgbG9hZGVyIH0gZnJvbSAndmVnYS1sb2FkZXInO1xuaW1wb3J0IHsgaXNEaXNjcmV0ZSwgZG9tYWluQ2FwdGlvbiB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuXG5sZXQgZ3JhZGllbnRfaWQgPSAwO1xuZnVuY3Rpb24gcmVzZXRTVkdHcmFkaWVudElkKCkge1xuICBncmFkaWVudF9pZCA9IDA7XG59XG5jb25zdCBwYXR0ZXJuUHJlZml4ID0gJ3BfJztcbmZ1bmN0aW9uIGlzR3JhZGllbnQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLmdyYWRpZW50O1xufVxuZnVuY3Rpb24gZ3JhZGllbnRSZWYoZywgZGVmcywgYmFzZSkge1xuICBjb25zdCB0eXBlID0gZy5ncmFkaWVudDtcbiAgbGV0IGlkID0gZy5pZCxcbiAgICBwcmVmaXggPSB0eXBlID09PSAncmFkaWFsJyA/IHBhdHRlcm5QcmVmaXggOiAnJztcblxuICAvLyBjaGVjayBpZCwgYXNzaWduIGRlZmF1bHQgdmFsdWVzIGFzIG5lZWRlZFxuICBpZiAoIWlkKSB7XG4gICAgaWQgPSBnLmlkID0gJ2dyYWRpZW50XycgKyBncmFkaWVudF9pZCsrO1xuICAgIGlmICh0eXBlID09PSAncmFkaWFsJykge1xuICAgICAgZy54MSA9IGdldChnLngxLCAwLjUpO1xuICAgICAgZy55MSA9IGdldChnLnkxLCAwLjUpO1xuICAgICAgZy5yMSA9IGdldChnLnIxLCAwKTtcbiAgICAgIGcueDIgPSBnZXQoZy54MiwgMC41KTtcbiAgICAgIGcueTIgPSBnZXQoZy55MiwgMC41KTtcbiAgICAgIGcucjIgPSBnZXQoZy5yMiwgMC41KTtcbiAgICAgIHByZWZpeCA9IHBhdHRlcm5QcmVmaXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGcueDEgPSBnZXQoZy54MSwgMCk7XG4gICAgICBnLnkxID0gZ2V0KGcueTEsIDApO1xuICAgICAgZy54MiA9IGdldChnLngyLCAxKTtcbiAgICAgIGcueTIgPSBnZXQoZy55MiwgMCk7XG4gICAgfVxuICB9XG5cbiAgLy8gcmVnaXN0ZXIgZGVmaW5pdGlvblxuICBkZWZzW2lkXSA9IGc7XG5cbiAgLy8gcmV0dXJuIHVybCByZWZlcmVuY2VcbiAgcmV0dXJuICd1cmwoJyArIChiYXNlIHx8ICcnKSArICcjJyArIHByZWZpeCArIGlkICsgJyknO1xufVxuZnVuY3Rpb24gZ2V0KHZhbCwgZGVmKSB7XG4gIHJldHVybiB2YWwgIT0gbnVsbCA/IHZhbCA6IGRlZjtcbn1cbmZ1bmN0aW9uIEdyYWRpZW50IChwMCwgcDEpIHtcbiAgdmFyIHN0b3BzID0gW10sXG4gICAgZ3JhZGllbnQ7XG4gIHJldHVybiBncmFkaWVudCA9IHtcbiAgICBncmFkaWVudDogJ2xpbmVhcicsXG4gICAgeDE6IHAwID8gcDBbMF0gOiAwLFxuICAgIHkxOiBwMCA/IHAwWzFdIDogMCxcbiAgICB4MjogcDEgPyBwMVswXSA6IDEsXG4gICAgeTI6IHAxID8gcDFbMV0gOiAwLFxuICAgIHN0b3BzOiBzdG9wcyxcbiAgICBzdG9wOiBmdW5jdGlvbiAob2Zmc2V0LCBjb2xvcikge1xuICAgICAgc3RvcHMucHVzaCh7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICBjb2xvcjogY29sb3JcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGdyYWRpZW50O1xuICAgIH1cbiAgfTtcbn1cblxuY29uc3QgbG9va3VwID0ge1xuICAnYmFzaXMnOiB7XG4gICAgY3VydmU6IGN1cnZlQmFzaXNcbiAgfSxcbiAgJ2Jhc2lzLWNsb3NlZCc6IHtcbiAgICBjdXJ2ZTogY3VydmVCYXNpc0Nsb3NlZFxuICB9LFxuICAnYmFzaXMtb3Blbic6IHtcbiAgICBjdXJ2ZTogY3VydmVCYXNpc09wZW5cbiAgfSxcbiAgJ2J1bmRsZSc6IHtcbiAgICBjdXJ2ZTogY3VydmVCdW5kbGUsXG4gICAgdGVuc2lvbjogJ2JldGEnLFxuICAgIHZhbHVlOiAwLjg1XG4gIH0sXG4gICdjYXJkaW5hbCc6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXJkaW5hbCxcbiAgICB0ZW5zaW9uOiAndGVuc2lvbicsXG4gICAgdmFsdWU6IDBcbiAgfSxcbiAgJ2NhcmRpbmFsLW9wZW4nOiB7XG4gICAgY3VydmU6IGN1cnZlQ2FyZGluYWxPcGVuLFxuICAgIHRlbnNpb246ICd0ZW5zaW9uJyxcbiAgICB2YWx1ZTogMFxuICB9LFxuICAnY2FyZGluYWwtY2xvc2VkJzoge1xuICAgIGN1cnZlOiBjdXJ2ZUNhcmRpbmFsQ2xvc2VkLFxuICAgIHRlbnNpb246ICd0ZW5zaW9uJyxcbiAgICB2YWx1ZTogMFxuICB9LFxuICAnY2F0bXVsbC1yb20nOiB7XG4gICAgY3VydmU6IGN1cnZlQ2F0bXVsbFJvbSxcbiAgICB0ZW5zaW9uOiAnYWxwaGEnLFxuICAgIHZhbHVlOiAwLjVcbiAgfSxcbiAgJ2NhdG11bGwtcm9tLWNsb3NlZCc6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXRtdWxsUm9tQ2xvc2VkLFxuICAgIHRlbnNpb246ICdhbHBoYScsXG4gICAgdmFsdWU6IDAuNVxuICB9LFxuICAnY2F0bXVsbC1yb20tb3Blbic6IHtcbiAgICBjdXJ2ZTogY3VydmVDYXRtdWxsUm9tT3BlbixcbiAgICB0ZW5zaW9uOiAnYWxwaGEnLFxuICAgIHZhbHVlOiAwLjVcbiAgfSxcbiAgJ2xpbmVhcic6IHtcbiAgICBjdXJ2ZTogY3VydmVMaW5lYXJcbiAgfSxcbiAgJ2xpbmVhci1jbG9zZWQnOiB7XG4gICAgY3VydmU6IGN1cnZlTGluZWFyQ2xvc2VkXG4gIH0sXG4gICdtb25vdG9uZSc6IHtcbiAgICBob3Jpem9udGFsOiBjdXJ2ZU1vbm90b25lWSxcbiAgICB2ZXJ0aWNhbDogY3VydmVNb25vdG9uZVhcbiAgfSxcbiAgJ25hdHVyYWwnOiB7XG4gICAgY3VydmU6IGN1cnZlTmF0dXJhbFxuICB9LFxuICAnc3RlcCc6IHtcbiAgICBjdXJ2ZTogY3VydmVTdGVwXG4gIH0sXG4gICdzdGVwLWFmdGVyJzoge1xuICAgIGN1cnZlOiBjdXJ2ZVN0ZXBBZnRlclxuICB9LFxuICAnc3RlcC1iZWZvcmUnOiB7XG4gICAgY3VydmU6IGN1cnZlU3RlcEJlZm9yZVxuICB9XG59O1xuZnVuY3Rpb24gY3VydmVzKHR5cGUsIG9yaWVudGF0aW9uLCB0ZW5zaW9uKSB7XG4gIHZhciBlbnRyeSA9IGhhc093blByb3BlcnR5KGxvb2t1cCwgdHlwZSkgJiYgbG9va3VwW3R5cGVdLFxuICAgIGN1cnZlID0gbnVsbDtcbiAgaWYgKGVudHJ5KSB7XG4gICAgY3VydmUgPSBlbnRyeS5jdXJ2ZSB8fCBlbnRyeVtvcmllbnRhdGlvbiB8fCAndmVydGljYWwnXTtcbiAgICBpZiAoZW50cnkudGVuc2lvbiAmJiB0ZW5zaW9uICE9IG51bGwpIHtcbiAgICAgIGN1cnZlID0gY3VydmVbZW50cnkudGVuc2lvbl0odGVuc2lvbik7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXJ2ZTtcbn1cblxuY29uc3QgcGFyYW1Db3VudHMgPSB7XG4gIG06IDIsXG4gIGw6IDIsXG4gIGg6IDEsXG4gIHY6IDEsXG4gIHo6IDAsXG4gIGM6IDYsXG4gIHM6IDQsXG4gIHE6IDQsXG4gIHQ6IDIsXG4gIGE6IDdcbn07XG5jb25zdCBjb21tYW5kUGF0dGVybiA9IC9bbWxodnpjc3F0YV0oW15tbGh2emNzcXRhXSt8JCkvZ2k7XG5jb25zdCBudW1iZXJQYXR0ZXJuID0gL15bKy1dPygoWzAtOV0qXFwuWzAtOV0rKXwoWzAtOV0rXFwuKXwoWzAtOV0rKSkoW2VFXVsrLV0/WzAtOV0rKT8vO1xuY29uc3Qgc3BhY2VQYXR0ZXJuID0gL14oKFxccyssP1xccyopfCgsXFxzKikpLztcbmNvbnN0IGZsYWdQYXR0ZXJuID0gL15bMDFdLztcbmZ1bmN0aW9uIHBhcnNlKHBhdGgpIHtcbiAgY29uc3QgY29tbWFuZHMgPSBbXTtcbiAgY29uc3QgbWF0Y2hlcyA9IHBhdGgubWF0Y2goY29tbWFuZFBhdHRlcm4pIHx8IFtdO1xuICBtYXRjaGVzLmZvckVhY2goc3RyID0+IHtcbiAgICBsZXQgY21kID0gc3RyWzBdO1xuICAgIGNvbnN0IHR5cGUgPSBjbWQudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIHBhcnNlIHBhcmFtZXRlcnNcbiAgICBjb25zdCBwYXJhbUNvdW50ID0gcGFyYW1Db3VudHNbdHlwZV07XG4gICAgY29uc3QgcGFyYW1zID0gcGFyc2VQYXJhbXModHlwZSwgcGFyYW1Db3VudCwgc3RyLnNsaWNlKDEpLnRyaW0oKSk7XG4gICAgY29uc3QgY291bnQgPSBwYXJhbXMubGVuZ3RoO1xuXG4gICAgLy8gZXJyb3IgY2hlY2tpbmcgYmFzZWQgb24gcGFyYW1ldGVyIGNvdW50XG4gICAgaWYgKGNvdW50IDwgcGFyYW1Db3VudCB8fCBjb3VudCAmJiBjb3VudCAlIHBhcmFtQ291bnQgIT09IDApIHtcbiAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFNWRyBwYXRoLCBpbmNvcnJlY3QgcGFyYW1ldGVyIGNvdW50Jyk7XG4gICAgfVxuXG4gICAgLy8gcmVnaXN0ZXIgdGhlIGNvbW1hbmRcbiAgICBjb21tYW5kcy5wdXNoKFtjbWQsIC4uLnBhcmFtcy5zbGljZSgwLCBwYXJhbUNvdW50KV0pO1xuXG4gICAgLy8gZXhpdCBub3cgaWYgd2UncmUgZG9uZSwgYWxzbyBoYW5kbGVzIHplcm8tcGFyYW0gJ3onXG4gICAgaWYgKGNvdW50ID09PSBwYXJhbUNvdW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIGltcGxpY2l0IGxpbmUtdG9cbiAgICBpZiAodHlwZSA9PT0gJ20nKSB7XG4gICAgICBjbWQgPSBjbWQgPT09ICdNJyA/ICdMJyA6ICdsJztcbiAgICB9XG5cbiAgICAvLyByZXBlYXQgY29tbWFuZCB3aGVuIGdpdmVuIGV4dGVuZGVkIHBhcmFtIGxpc3RcbiAgICBmb3IgKGxldCBpID0gcGFyYW1Db3VudDsgaSA8IGNvdW50OyBpICs9IHBhcmFtQ291bnQpIHtcbiAgICAgIGNvbW1hbmRzLnB1c2goW2NtZCwgLi4ucGFyYW1zLnNsaWNlKGksIGkgKyBwYXJhbUNvdW50KV0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBjb21tYW5kcztcbn1cbmZ1bmN0aW9uIHBhcnNlUGFyYW1zKHR5cGUsIHBhcmFtQ291bnQsIHNlZ21lbnQpIHtcbiAgY29uc3QgcGFyYW1zID0gW107XG4gIGZvciAobGV0IGluZGV4ID0gMDsgcGFyYW1Db3VudCAmJiBpbmRleCA8IHNlZ21lbnQubGVuZ3RoOykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1Db3VudDsgKytpKSB7XG4gICAgICBjb25zdCBwYXR0ZXJuID0gdHlwZSA9PT0gJ2EnICYmIChpID09PSAzIHx8IGkgPT09IDQpID8gZmxhZ1BhdHRlcm4gOiBudW1iZXJQYXR0ZXJuO1xuICAgICAgY29uc3QgbWF0Y2ggPSBzZWdtZW50LnNsaWNlKGluZGV4KS5tYXRjaChwYXR0ZXJuKTtcbiAgICAgIGlmIChtYXRjaCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBTVkcgcGF0aCwgaW5jb3JyZWN0IHBhcmFtZXRlciB0eXBlJyk7XG4gICAgICB9XG4gICAgICBpbmRleCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICBwYXJhbXMucHVzaCgrbWF0Y2hbMF0pO1xuICAgICAgY29uc3Qgd3MgPSBzZWdtZW50LnNsaWNlKGluZGV4KS5tYXRjaChzcGFjZVBhdHRlcm4pO1xuICAgICAgaWYgKHdzICE9PSBudWxsKSB7XG4gICAgICAgIGluZGV4ICs9IHdzWzBdLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuY29uc3QgRGVnVG9SYWQgPSBNYXRoLlBJIC8gMTgwO1xuY29uc3QgRXBzaWxvbiA9IDFlLTE0O1xuY29uc3QgSGFsZlBpID0gTWF0aC5QSSAvIDI7XG5jb25zdCBUYXUgPSBNYXRoLlBJICogMjtcbmNvbnN0IEhhbGZTcXJ0MyA9IE1hdGguc3FydCgzKSAvIDI7XG5cbnZhciBzZWdtZW50Q2FjaGUgPSB7fTtcbnZhciBiZXppZXJDYWNoZSA9IHt9O1xudmFyIGpvaW4gPSBbXS5qb2luO1xuXG4vLyBDb3BpZWQgZnJvbSBJbmtzY2FwZSBzdmd0b3BkZiwgdGhhbmtzIVxuZnVuY3Rpb24gc2VnbWVudHMoeCwgeSwgcngsIHJ5LCBsYXJnZSwgc3dlZXAsIHJvdGF0ZVgsIG94LCBveSkge1xuICBjb25zdCBrZXkgPSBqb2luLmNhbGwoYXJndW1lbnRzKTtcbiAgaWYgKHNlZ21lbnRDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIHNlZ21lbnRDYWNoZVtrZXldO1xuICB9XG4gIGNvbnN0IHRoID0gcm90YXRlWCAqIERlZ1RvUmFkO1xuICBjb25zdCBzaW5fdGggPSBNYXRoLnNpbih0aCk7XG4gIGNvbnN0IGNvc190aCA9IE1hdGguY29zKHRoKTtcbiAgcnggPSBNYXRoLmFicyhyeCk7XG4gIHJ5ID0gTWF0aC5hYnMocnkpO1xuICBjb25zdCBweCA9IGNvc190aCAqIChveCAtIHgpICogMC41ICsgc2luX3RoICogKG95IC0geSkgKiAwLjU7XG4gIGNvbnN0IHB5ID0gY29zX3RoICogKG95IC0geSkgKiAwLjUgLSBzaW5fdGggKiAob3ggLSB4KSAqIDAuNTtcbiAgbGV0IHBsID0gcHggKiBweCAvIChyeCAqIHJ4KSArIHB5ICogcHkgLyAocnkgKiByeSk7XG4gIGlmIChwbCA+IDEpIHtcbiAgICBwbCA9IE1hdGguc3FydChwbCk7XG4gICAgcnggKj0gcGw7XG4gICAgcnkgKj0gcGw7XG4gIH1cbiAgY29uc3QgYTAwID0gY29zX3RoIC8gcng7XG4gIGNvbnN0IGEwMSA9IHNpbl90aCAvIHJ4O1xuICBjb25zdCBhMTAgPSAtc2luX3RoIC8gcnk7XG4gIGNvbnN0IGExMSA9IGNvc190aCAvIHJ5O1xuICBjb25zdCB4MCA9IGEwMCAqIG94ICsgYTAxICogb3k7XG4gIGNvbnN0IHkwID0gYTEwICogb3ggKyBhMTEgKiBveTtcbiAgY29uc3QgeDEgPSBhMDAgKiB4ICsgYTAxICogeTtcbiAgY29uc3QgeTEgPSBhMTAgKiB4ICsgYTExICogeTtcbiAgY29uc3QgZCA9ICh4MSAtIHgwKSAqICh4MSAtIHgwKSArICh5MSAtIHkwKSAqICh5MSAtIHkwKTtcbiAgbGV0IHNmYWN0b3Jfc3EgPSAxIC8gZCAtIDAuMjU7XG4gIGlmIChzZmFjdG9yX3NxIDwgMCkgc2ZhY3Rvcl9zcSA9IDA7XG4gIGxldCBzZmFjdG9yID0gTWF0aC5zcXJ0KHNmYWN0b3Jfc3EpO1xuICBpZiAoc3dlZXAgPT0gbGFyZ2UpIHNmYWN0b3IgPSAtc2ZhY3RvcjtcbiAgY29uc3QgeGMgPSAwLjUgKiAoeDAgKyB4MSkgLSBzZmFjdG9yICogKHkxIC0geTApO1xuICBjb25zdCB5YyA9IDAuNSAqICh5MCArIHkxKSArIHNmYWN0b3IgKiAoeDEgLSB4MCk7XG4gIGNvbnN0IHRoMCA9IE1hdGguYXRhbjIoeTAgLSB5YywgeDAgLSB4Yyk7XG4gIGNvbnN0IHRoMSA9IE1hdGguYXRhbjIoeTEgLSB5YywgeDEgLSB4Yyk7XG4gIGxldCB0aF9hcmMgPSB0aDEgLSB0aDA7XG4gIGlmICh0aF9hcmMgPCAwICYmIHN3ZWVwID09PSAxKSB7XG4gICAgdGhfYXJjICs9IFRhdTtcbiAgfSBlbHNlIGlmICh0aF9hcmMgPiAwICYmIHN3ZWVwID09PSAwKSB7XG4gICAgdGhfYXJjIC09IFRhdTtcbiAgfVxuICBjb25zdCBzZWdzID0gTWF0aC5jZWlsKE1hdGguYWJzKHRoX2FyYyAvIChIYWxmUGkgKyAwLjAwMSkpKTtcbiAgY29uc3QgcmVzdWx0ID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VnczsgKytpKSB7XG4gICAgY29uc3QgdGgyID0gdGgwICsgaSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgY29uc3QgdGgzID0gdGgwICsgKGkgKyAxKSAqIHRoX2FyYyAvIHNlZ3M7XG4gICAgcmVzdWx0W2ldID0gW3hjLCB5YywgdGgyLCB0aDMsIHJ4LCByeSwgc2luX3RoLCBjb3NfdGhdO1xuICB9XG4gIHJldHVybiBzZWdtZW50Q2FjaGVba2V5XSA9IHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGJlemllcihwYXJhbXMpIHtcbiAgY29uc3Qga2V5ID0gam9pbi5jYWxsKHBhcmFtcyk7XG4gIGlmIChiZXppZXJDYWNoZVtrZXldKSB7XG4gICAgcmV0dXJuIGJlemllckNhY2hlW2tleV07XG4gIH1cbiAgdmFyIGN4ID0gcGFyYW1zWzBdLFxuICAgIGN5ID0gcGFyYW1zWzFdLFxuICAgIHRoMCA9IHBhcmFtc1syXSxcbiAgICB0aDEgPSBwYXJhbXNbM10sXG4gICAgcnggPSBwYXJhbXNbNF0sXG4gICAgcnkgPSBwYXJhbXNbNV0sXG4gICAgc2luX3RoID0gcGFyYW1zWzZdLFxuICAgIGNvc190aCA9IHBhcmFtc1s3XTtcbiAgY29uc3QgYTAwID0gY29zX3RoICogcng7XG4gIGNvbnN0IGEwMSA9IC1zaW5fdGggKiByeTtcbiAgY29uc3QgYTEwID0gc2luX3RoICogcng7XG4gIGNvbnN0IGExMSA9IGNvc190aCAqIHJ5O1xuICBjb25zdCBjb3NfdGgwID0gTWF0aC5jb3ModGgwKTtcbiAgY29uc3Qgc2luX3RoMCA9IE1hdGguc2luKHRoMCk7XG4gIGNvbnN0IGNvc190aDEgPSBNYXRoLmNvcyh0aDEpO1xuICBjb25zdCBzaW5fdGgxID0gTWF0aC5zaW4odGgxKTtcbiAgY29uc3QgdGhfaGFsZiA9IDAuNSAqICh0aDEgLSB0aDApO1xuICBjb25zdCBzaW5fdGhfaDIgPSBNYXRoLnNpbih0aF9oYWxmICogMC41KTtcbiAgY29uc3QgdCA9IDggLyAzICogc2luX3RoX2gyICogc2luX3RoX2gyIC8gTWF0aC5zaW4odGhfaGFsZik7XG4gIGNvbnN0IHgxID0gY3ggKyBjb3NfdGgwIC0gdCAqIHNpbl90aDA7XG4gIGNvbnN0IHkxID0gY3kgKyBzaW5fdGgwICsgdCAqIGNvc190aDA7XG4gIGNvbnN0IHgzID0gY3ggKyBjb3NfdGgxO1xuICBjb25zdCB5MyA9IGN5ICsgc2luX3RoMTtcbiAgY29uc3QgeDIgPSB4MyArIHQgKiBzaW5fdGgxO1xuICBjb25zdCB5MiA9IHkzIC0gdCAqIGNvc190aDE7XG4gIHJldHVybiBiZXppZXJDYWNoZVtrZXldID0gW2EwMCAqIHgxICsgYTAxICogeTEsIGExMCAqIHgxICsgYTExICogeTEsIGEwMCAqIHgyICsgYTAxICogeTIsIGExMCAqIHgyICsgYTExICogeTIsIGEwMCAqIHgzICsgYTAxICogeTMsIGExMCAqIHgzICsgYTExICogeTNdO1xufVxuXG5jb25zdCB0ZW1wID0gWydsJywgMCwgMCwgMCwgMCwgMCwgMCwgMF07XG5mdW5jdGlvbiBzY2FsZSQxKGN1cnJlbnQsIHNYLCBzWSkge1xuICBjb25zdCBjID0gdGVtcFswXSA9IGN1cnJlbnRbMF07XG4gIGlmIChjID09PSAnYScgfHwgYyA9PT0gJ0EnKSB7XG4gICAgdGVtcFsxXSA9IHNYICogY3VycmVudFsxXTtcbiAgICB0ZW1wWzJdID0gc1kgKiBjdXJyZW50WzJdO1xuICAgIHRlbXBbM10gPSBjdXJyZW50WzNdO1xuICAgIHRlbXBbNF0gPSBjdXJyZW50WzRdO1xuICAgIHRlbXBbNV0gPSBjdXJyZW50WzVdO1xuICAgIHRlbXBbNl0gPSBzWCAqIGN1cnJlbnRbNl07XG4gICAgdGVtcFs3XSA9IHNZICogY3VycmVudFs3XTtcbiAgfSBlbHNlIGlmIChjID09PSAnaCcgfHwgYyA9PT0gJ0gnKSB7XG4gICAgdGVtcFsxXSA9IHNYICogY3VycmVudFsxXTtcbiAgfSBlbHNlIGlmIChjID09PSAndicgfHwgYyA9PT0gJ1YnKSB7XG4gICAgdGVtcFsxXSA9IHNZICogY3VycmVudFsxXTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBpID0gMSwgbiA9IGN1cnJlbnQubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB0ZW1wW2ldID0gKGkgJSAyID09IDEgPyBzWCA6IHNZKSAqIGN1cnJlbnRbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiB0ZW1wO1xufVxuZnVuY3Rpb24gcGF0aFJlbmRlciAoY29udGV4dCwgcGF0aCwgbCwgdCwgc1gsIHNZKSB7XG4gIHZhciBjdXJyZW50LFxuICAgIC8vIGN1cnJlbnQgaW5zdHJ1Y3Rpb25cbiAgICBwcmV2aW91cyA9IG51bGwsXG4gICAgeCA9IDAsXG4gICAgLy8gY3VycmVudCB4XG4gICAgeSA9IDAsXG4gICAgLy8gY3VycmVudCB5XG4gICAgY29udHJvbFggPSAwLFxuICAgIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB4XG4gICAgY29udHJvbFkgPSAwLFxuICAgIC8vIGN1cnJlbnQgY29udHJvbCBwb2ludCB5XG4gICAgdGVtcFgsXG4gICAgdGVtcFksXG4gICAgdGVtcENvbnRyb2xYLFxuICAgIHRlbXBDb250cm9sWSxcbiAgICBhbmNob3JYID0gMCxcbiAgICBhbmNob3JZID0gMDtcbiAgaWYgKGwgPT0gbnVsbCkgbCA9IDA7XG4gIGlmICh0ID09IG51bGwpIHQgPSAwO1xuICBpZiAoc1ggPT0gbnVsbCkgc1ggPSAxO1xuICBpZiAoc1kgPT0gbnVsbCkgc1kgPSBzWDtcbiAgaWYgKGNvbnRleHQuYmVnaW5QYXRoKSBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGN1cnJlbnQgPSBwYXRoW2ldO1xuICAgIGlmIChzWCAhPT0gMSB8fCBzWSAhPT0gMSkge1xuICAgICAgY3VycmVudCA9IHNjYWxlJDEoY3VycmVudCwgc1gsIHNZKTtcbiAgICB9XG4gICAgc3dpdGNoIChjdXJyZW50WzBdKSB7XG4gICAgICAvLyBmaXJzdCBsZXR0ZXJcblxuICAgICAgY2FzZSAnbCc6XG4gICAgICAgIC8vIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnTCc6XG4gICAgICAgIC8vIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIHkgPSBjdXJyZW50WzJdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2gnOlxuICAgICAgICAvLyBob3Jpem9udGFsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ0gnOlxuICAgICAgICAvLyBob3Jpem9udGFsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndic6XG4gICAgICAgIC8vIHZlcnRpY2FsIGxpbmV0bywgcmVsYXRpdmVcbiAgICAgICAgeSArPSBjdXJyZW50WzFdO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4ICsgbCwgeSArIHQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAvLyB2ZXJpY2FsIGxpbmV0bywgYWJzb2x1dGVcbiAgICAgICAgeSA9IGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRleHQubGluZVRvKHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbSc6XG4gICAgICAgIC8vIG1vdmVUbywgcmVsYXRpdmVcbiAgICAgICAgeCArPSBjdXJyZW50WzFdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbMl07XG4gICAgICAgIGFuY2hvclggPSB4O1xuICAgICAgICBhbmNob3JZID0geTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdNJzpcbiAgICAgICAgLy8gbW92ZVRvLCBhYnNvbHV0ZVxuICAgICAgICB4ID0gY3VycmVudFsxXTtcbiAgICAgICAgeSA9IGN1cnJlbnRbMl07XG4gICAgICAgIGFuY2hvclggPSB4O1xuICAgICAgICBhbmNob3JZID0geTtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCArIGwsIHkgKyB0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdjJzpcbiAgICAgICAgLy8gYmV6aWVyQ3VydmVUbywgcmVsYXRpdmVcbiAgICAgICAgdGVtcFggPSB4ICsgY3VycmVudFs1XTtcbiAgICAgICAgdGVtcFkgPSB5ICsgY3VycmVudFs2XTtcbiAgICAgICAgY29udHJvbFggPSB4ICsgY3VycmVudFszXTtcbiAgICAgICAgY29udHJvbFkgPSB5ICsgY3VycmVudFs0XTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHggKyBjdXJyZW50WzFdICsgbCxcbiAgICAgICAgLy8geDFcbiAgICAgICAgeSArIGN1cnJlbnRbMl0gKyB0LFxuICAgICAgICAvLyB5MVxuICAgICAgICBjb250cm9sWCArIGwsXG4gICAgICAgIC8vIHgyXG4gICAgICAgIGNvbnRyb2xZICsgdCxcbiAgICAgICAgLy8geTJcbiAgICAgICAgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdDJzpcbiAgICAgICAgLy8gYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgeCA9IGN1cnJlbnRbNV07XG4gICAgICAgIHkgPSBjdXJyZW50WzZdO1xuICAgICAgICBjb250cm9sWCA9IGN1cnJlbnRbM107XG4gICAgICAgIGNvbnRyb2xZID0gY3VycmVudFs0XTtcbiAgICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKGN1cnJlbnRbMV0gKyBsLCBjdXJyZW50WzJdICsgdCwgY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHggKyBsLCB5ICsgdCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAncyc6XG4gICAgICAgIC8vIHNob3J0aGFuZCBjdWJpYyBiZXppZXJDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHggKyBjdXJyZW50WzFdICsgbCwgeSArIGN1cnJlbnRbMl0gKyB0LCB0ZW1wWCArIGwsIHRlbXBZICsgdCk7XG5cbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZlxuICAgICAgICAvLyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIHggPSB0ZW1wWDtcbiAgICAgICAgeSA9IHRlbXBZO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ1MnOlxuICAgICAgICAvLyBzaG9ydGhhbmQgY3ViaWMgYmV6aWVyQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIGN1cnJlbnRbMV0gKyBsLCBjdXJyZW50WzJdICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgLy8gc2V0IGNvbnRyb2wgcG9pbnQgdG8gMm5kIG9uZSBvZiB0aGlzIGNvbW1hbmRcbiAgICAgICAgLy8gdGhlIGZpcnN0IGNvbnRyb2wgcG9pbnQgaXMgYXNzdW1lZCB0byBiZSB0aGUgcmVmbGVjdGlvbiBvZlxuICAgICAgICAvLyB0aGUgc2Vjb25kIGNvbnRyb2wgcG9pbnQgb24gdGhlIHByZXZpb3VzIGNvbW1hbmQgcmVsYXRpdmVcbiAgICAgICAgLy8gdG8gdGhlIGN1cnJlbnQgcG9pbnQuXG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3EnOlxuICAgICAgICAvLyBxdWFkcmF0aWNDdXJ2ZVRvLCByZWxhdGl2ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbM107XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbNF07XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjb250cm9sWCArIGwsIGNvbnRyb2xZICsgdCwgdGVtcFggKyBsLCB0ZW1wWSArIHQpO1xuICAgICAgICB4ID0gdGVtcFg7XG4gICAgICAgIHkgPSB0ZW1wWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdRJzpcbiAgICAgICAgLy8gcXVhZHJhdGljQ3VydmVUbywgYWJzb2x1dGVcbiAgICAgICAgdGVtcFggPSBjdXJyZW50WzNdO1xuICAgICAgICB0ZW1wWSA9IGN1cnJlbnRbNF07XG4gICAgICAgIGNvbnRleHQucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50WzFdICsgbCwgY3VycmVudFsyXSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0gY3VycmVudFsxXTtcbiAgICAgICAgY29udHJvbFkgPSBjdXJyZW50WzJdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAvLyBzaG9ydGhhbmQgcXVhZHJhdGljQ3VydmVUbywgcmVsYXRpdmVcblxuICAgICAgICAvLyB0cmFuc2Zvcm0gdG8gYWJzb2x1dGUgeCx5XG4gICAgICAgIHRlbXBYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIHRlbXBZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGlmIChwcmV2aW91c1swXS5tYXRjaCgvW1FxVHRdLykgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyBwcmV2aW91cyBjb21tYW5kIG9yIGlmIHRoZSBwcmV2aW91cyBjb21tYW5kIHdhcyBub3QgYSBRLCBxLCBUIG9yIHQsXG4gICAgICAgICAgLy8gYXNzdW1lIHRoZSBjb250cm9sIHBvaW50IGlzIGNvaW5jaWRlbnQgd2l0aCB0aGUgY3VycmVudCBwb2ludFxuICAgICAgICAgIGNvbnRyb2xYID0geDtcbiAgICAgICAgICBjb250cm9sWSA9IHk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJldmlvdXNbMF0gPT09ICd0Jykge1xuICAgICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzIGZvciB0XG4gICAgICAgICAgY29udHJvbFggPSAyICogeCAtIHRlbXBDb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gdGVtcENvbnRyb2xZO1xuICAgICAgICB9IGVsc2UgaWYgKHByZXZpb3VzWzBdID09PSAncScpIHtcbiAgICAgICAgICAvLyBjYWxjdWxhdGUgcmVmbGVjdGlvbiBvZiBwcmV2aW91cyBjb250cm9sIHBvaW50cyBmb3IgcVxuICAgICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgICBjb250cm9sWSA9IDIgKiB5IC0gY29udHJvbFk7XG4gICAgICAgIH1cbiAgICAgICAgdGVtcENvbnRyb2xYID0gY29udHJvbFg7XG4gICAgICAgIHRlbXBDb250cm9sWSA9IGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGNvbnRyb2xYID0geCArIGN1cnJlbnRbMV07XG4gICAgICAgIGNvbnRyb2xZID0geSArIGN1cnJlbnRbMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnVCc6XG4gICAgICAgIHRlbXBYID0gY3VycmVudFsxXTtcbiAgICAgICAgdGVtcFkgPSBjdXJyZW50WzJdO1xuXG4gICAgICAgIC8vIGNhbGN1bGF0ZSByZWZsZWN0aW9uIG9mIHByZXZpb3VzIGNvbnRyb2wgcG9pbnRzXG4gICAgICAgIGNvbnRyb2xYID0gMiAqIHggLSBjb250cm9sWDtcbiAgICAgICAgY29udHJvbFkgPSAyICogeSAtIGNvbnRyb2xZO1xuICAgICAgICBjb250ZXh0LnF1YWRyYXRpY0N1cnZlVG8oY29udHJvbFggKyBsLCBjb250cm9sWSArIHQsIHRlbXBYICsgbCwgdGVtcFkgKyB0KTtcbiAgICAgICAgeCA9IHRlbXBYO1xuICAgICAgICB5ID0gdGVtcFk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYSc6XG4gICAgICAgIGRyYXdBcmMoY29udGV4dCwgeCArIGwsIHkgKyB0LCBbY3VycmVudFsxXSwgY3VycmVudFsyXSwgY3VycmVudFszXSwgY3VycmVudFs0XSwgY3VycmVudFs1XSwgY3VycmVudFs2XSArIHggKyBsLCBjdXJyZW50WzddICsgeSArIHRdKTtcbiAgICAgICAgeCArPSBjdXJyZW50WzZdO1xuICAgICAgICB5ICs9IGN1cnJlbnRbN107XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnQSc6XG4gICAgICAgIGRyYXdBcmMoY29udGV4dCwgeCArIGwsIHkgKyB0LCBbY3VycmVudFsxXSwgY3VycmVudFsyXSwgY3VycmVudFszXSwgY3VycmVudFs0XSwgY3VycmVudFs1XSwgY3VycmVudFs2XSArIGwsIGN1cnJlbnRbN10gKyB0XSk7XG4gICAgICAgIHggPSBjdXJyZW50WzZdO1xuICAgICAgICB5ID0gY3VycmVudFs3XTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd6JzpcbiAgICAgIGNhc2UgJ1onOlxuICAgICAgICB4ID0gYW5jaG9yWDtcbiAgICAgICAgeSA9IGFuY2hvclk7XG4gICAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwcmV2aW91cyA9IGN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdBcmMoY29udGV4dCwgeCwgeSwgY29vcmRzKSB7XG4gIGNvbnN0IHNlZyA9IHNlZ21lbnRzKGNvb3Jkc1s1XSxcbiAgLy8gZW5kIHhcbiAgY29vcmRzWzZdLFxuICAvLyBlbmQgeVxuICBjb29yZHNbMF0sXG4gIC8vIHJhZGl1cyB4XG4gIGNvb3Jkc1sxXSxcbiAgLy8gcmFkaXVzIHlcbiAgY29vcmRzWzNdLFxuICAvLyBsYXJnZSBmbGFnXG4gIGNvb3Jkc1s0XSxcbiAgLy8gc3dlZXAgZmxhZ1xuICBjb29yZHNbMl0sXG4gIC8vIHJvdGF0aW9uXG4gIHgsIHkpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHNlZy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IGJleiA9IGJlemllcihzZWdbaV0pO1xuICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyhiZXpbMF0sIGJlelsxXSwgYmV6WzJdLCBiZXpbM10sIGJlels0XSwgYmV6WzVdKTtcbiAgfVxufVxuXG5jb25zdCBUYW4zMCA9IDAuNTc3MzUwMjY5MTg5NjI1NztcbmNvbnN0IGJ1aWx0aW5zID0ge1xuICAnY2lyY2xlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICBjb25zdCByID0gTWF0aC5zcXJ0KHNpemUpIC8gMjtcbiAgICAgIGNvbnRleHQubW92ZVRvKHIsIDApO1xuICAgICAgY29udGV4dC5hcmMoMCwgMCwgciwgMCwgVGF1KTtcbiAgICB9XG4gIH0sXG4gICdjcm9zcyc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICBzID0gciAvIDIuNTtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1yLCAtcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIHMpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCAtcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCAtcyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhzLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbygtcywgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXMsIC1zKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAnZGlhbW9uZCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgY29uc3QgciA9IE1hdGguc3FydChzaXplKSAvIDI7XG4gICAgICBjb250ZXh0Lm1vdmVUbygtciwgMCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygwLCAtcik7XG4gICAgICBjb250ZXh0LmxpbmVUbyhyLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKDAsIHIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICdzcXVhcmUnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIHZhciB3ID0gTWF0aC5zcXJ0KHNpemUpLFxuICAgICAgICB4ID0gLXcgLyAyO1xuICAgICAgY29udGV4dC5yZWN0KHgsIHgsIHcsIHcpO1xuICAgIH1cbiAgfSxcbiAgJ2Fycm93Jzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgIHMgPSByIC8gNyxcbiAgICAgICAgdCA9IHIgLyAyLjUsXG4gICAgICAgIHYgPSByIC8gODtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1zLCByKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHMsIHIpO1xuICAgICAgY29udGV4dC5saW5lVG8ocywgLXYpO1xuICAgICAgY29udGV4dC5saW5lVG8odCwgLXYpO1xuICAgICAgY29udGV4dC5saW5lVG8oMCwgLXIpO1xuICAgICAgY29udGV4dC5saW5lVG8oLXQsIC12KTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1zLCAtdik7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3dlZGdlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgIGggPSBIYWxmU3FydDMgKiByLFxuICAgICAgICBvID0gaCAtIHIgKiBUYW4zMCxcbiAgICAgICAgYiA9IHIgLyA0O1xuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgLWggLSBvKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1iLCBoIC0gbyk7XG4gICAgICBjb250ZXh0LmxpbmVUbyhiLCBoIC0gbyk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgfSxcbiAgJ3RyaWFuZ2xlJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgIGggPSBIYWxmU3FydDMgKiByLFxuICAgICAgICBvID0gaCAtIHIgKiBUYW4zMDtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1oIC0gbyk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgaCAtIG8pO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgaCAtIG8pO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS11cCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKDAsIC1oKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1yLCBoKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHIsIGgpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS1kb3duJzoge1xuICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICB2YXIgciA9IE1hdGguc3FydChzaXplKSAvIDIsXG4gICAgICAgIGggPSBIYWxmU3FydDMgKiByO1xuICAgICAgY29udGV4dC5tb3ZlVG8oMCwgaCk7XG4gICAgICBjb250ZXh0LmxpbmVUbygtciwgLWgpO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgLWgpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICd0cmlhbmdsZS1yaWdodCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKGgsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8oLWgsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKC1oLCByKTtcbiAgICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgfVxuICB9LFxuICAndHJpYW5nbGUtbGVmdCc6IHtcbiAgICBkcmF3OiBmdW5jdGlvbiAoY29udGV4dCwgc2l6ZSkge1xuICAgICAgdmFyIHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyLFxuICAgICAgICBoID0gSGFsZlNxcnQzICogcjtcbiAgICAgIGNvbnRleHQubW92ZVRvKC1oLCAwKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGgsIC1yKTtcbiAgICAgIGNvbnRleHQubGluZVRvKGgsIHIpO1xuICAgICAgY29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9XG4gIH0sXG4gICdzdHJva2UnOiB7XG4gICAgZHJhdzogZnVuY3Rpb24gKGNvbnRleHQsIHNpemUpIHtcbiAgICAgIGNvbnN0IHIgPSBNYXRoLnNxcnQoc2l6ZSkgLyAyO1xuICAgICAgY29udGV4dC5tb3ZlVG8oLXIsIDApO1xuICAgICAgY29udGV4dC5saW5lVG8ociwgMCk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gc3ltYm9scyhfKSB7XG4gIHJldHVybiBoYXNPd25Qcm9wZXJ0eShidWlsdGlucywgXykgPyBidWlsdGluc1tfXSA6IGN1c3RvbVN5bWJvbChfKTtcbn1cbnZhciBjdXN0b20gPSB7fTtcbmZ1bmN0aW9uIGN1c3RvbVN5bWJvbChwYXRoKSB7XG4gIGlmICghaGFzT3duUHJvcGVydHkoY3VzdG9tLCBwYXRoKSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlKHBhdGgpO1xuICAgIGN1c3RvbVtwYXRoXSA9IHtcbiAgICAgIGRyYXc6IGZ1bmN0aW9uIChjb250ZXh0LCBzaXplKSB7XG4gICAgICAgIHBhdGhSZW5kZXIoY29udGV4dCwgcGFyc2VkLCAwLCAwLCBNYXRoLnNxcnQoc2l6ZSkgLyAyKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG4gIHJldHVybiBjdXN0b21bcGF0aF07XG59XG5cbi8vIFNlZSBodHRwOi8vc3BlbmNlcm1vcnRlbnNlbi5jb20vYXJ0aWNsZXMvYmV6aWVyLWNpcmNsZS9cbmNvbnN0IEMgPSAwLjQ0ODA4NDk3NTUwNjsgLy8gQyA9IDEgLSBjXG5cbmZ1bmN0aW9uIHJlY3RhbmdsZVgoZCkge1xuICByZXR1cm4gZC54O1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlWShkKSB7XG4gIHJldHVybiBkLnk7XG59XG5mdW5jdGlvbiByZWN0YW5nbGVXaWR0aChkKSB7XG4gIHJldHVybiBkLndpZHRoO1xufVxuZnVuY3Rpb24gcmVjdGFuZ2xlSGVpZ2h0KGQpIHtcbiAgcmV0dXJuIGQuaGVpZ2h0O1xufVxuZnVuY3Rpb24gbnVtYmVyKF8pIHtcbiAgcmV0dXJuIHR5cGVvZiBfID09PSAnZnVuY3Rpb24nID8gXyA6ICgpID0+ICtfO1xufVxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcbn1cbmZ1bmN0aW9uIHZnX3JlY3QgKCkge1xuICB2YXIgeCA9IHJlY3RhbmdsZVgsXG4gICAgeSA9IHJlY3RhbmdsZVksXG4gICAgd2lkdGggPSByZWN0YW5nbGVXaWR0aCxcbiAgICBoZWlnaHQgPSByZWN0YW5nbGVIZWlnaHQsXG4gICAgY3JUTCA9IG51bWJlcigwKSxcbiAgICBjclRSID0gY3JUTCxcbiAgICBjckJMID0gY3JUTCxcbiAgICBjckJSID0gY3JUTCxcbiAgICBjb250ZXh0ID0gbnVsbDtcbiAgZnVuY3Rpb24gcmVjdGFuZ2xlKF8sIHgwLCB5MCkge1xuICAgIHZhciBidWZmZXIsXG4gICAgICB4MSA9IHgwICE9IG51bGwgPyB4MCA6ICt4LmNhbGwodGhpcywgXyksXG4gICAgICB5MSA9IHkwICE9IG51bGwgPyB5MCA6ICt5LmNhbGwodGhpcywgXyksXG4gICAgICB3ID0gK3dpZHRoLmNhbGwodGhpcywgXyksXG4gICAgICBoID0gK2hlaWdodC5jYWxsKHRoaXMsIF8pLFxuICAgICAgcyA9IE1hdGgubWluKHcsIGgpIC8gMixcbiAgICAgIHRsID0gY2xhbXAoK2NyVEwuY2FsbCh0aGlzLCBfKSwgMCwgcyksXG4gICAgICB0ciA9IGNsYW1wKCtjclRSLmNhbGwodGhpcywgXyksIDAsIHMpLFxuICAgICAgYmwgPSBjbGFtcCgrY3JCTC5jYWxsKHRoaXMsIF8pLCAwLCBzKSxcbiAgICAgIGJyID0gY2xhbXAoK2NyQlIuY2FsbCh0aGlzLCBfKSwgMCwgcyk7XG4gICAgaWYgKCFjb250ZXh0KSBjb250ZXh0ID0gYnVmZmVyID0gcGF0aCQzKCk7XG4gICAgaWYgKHRsIDw9IDAgJiYgdHIgPD0gMCAmJiBibCA8PSAwICYmIGJyIDw9IDApIHtcbiAgICAgIGNvbnRleHQucmVjdCh4MSwgeTEsIHcsIGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgeDIgPSB4MSArIHcsXG4gICAgICAgIHkyID0geTEgKyBoO1xuICAgICAgY29udGV4dC5tb3ZlVG8oeDEgKyB0bCwgeTEpO1xuICAgICAgY29udGV4dC5saW5lVG8oeDIgLSB0ciwgeTEpO1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgyIC0gQyAqIHRyLCB5MSwgeDIsIHkxICsgQyAqIHRyLCB4MiwgeTEgKyB0cik7XG4gICAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIgLSBicik7XG4gICAgICBjb250ZXh0LmJlemllckN1cnZlVG8oeDIsIHkyIC0gQyAqIGJyLCB4MiAtIEMgKiBiciwgeTIsIHgyIC0gYnIsIHkyKTtcbiAgICAgIGNvbnRleHQubGluZVRvKHgxICsgYmwsIHkyKTtcbiAgICAgIGNvbnRleHQuYmV6aWVyQ3VydmVUbyh4MSArIEMgKiBibCwgeTIsIHgxLCB5MiAtIEMgKiBibCwgeDEsIHkyIC0gYmwpO1xuICAgICAgY29udGV4dC5saW5lVG8oeDEsIHkxICsgdGwpO1xuICAgICAgY29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSArIEMgKiB0bCwgeDEgKyBDICogdGwsIHkxLCB4MSArIHRsLCB5MSk7XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH1cbiAgICBpZiAoYnVmZmVyKSB7XG4gICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICAgIHJldHVybiBidWZmZXIgKyAnJyB8fCBudWxsO1xuICAgIH1cbiAgfVxuICByZWN0YW5nbGUueCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHggPSBudW1iZXIoXyk7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH07XG4gIHJlY3RhbmdsZS55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeSA9IG51bWJlcihfKTtcbiAgICAgIHJldHVybiByZWN0YW5nbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfTtcbiAgcmVjdGFuZ2xlLndpZHRoID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgd2lkdGggPSBudW1iZXIoXyk7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd2lkdGg7XG4gICAgfVxuICB9O1xuICByZWN0YW5nbGUuaGVpZ2h0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaGVpZ2h0ID0gbnVtYmVyKF8pO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGhlaWdodDtcbiAgICB9XG4gIH07XG4gIHJlY3RhbmdsZS5jb3JuZXJSYWRpdXMgPSBmdW5jdGlvbiAodGwsIHRyLCBiciwgYmwpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY3JUTCA9IG51bWJlcih0bCk7XG4gICAgICBjclRSID0gdHIgIT0gbnVsbCA/IG51bWJlcih0cikgOiBjclRMO1xuICAgICAgY3JCUiA9IGJyICE9IG51bGwgPyBudW1iZXIoYnIpIDogY3JUTDtcbiAgICAgIGNyQkwgPSBibCAhPSBudWxsID8gbnVtYmVyKGJsKSA6IGNyVFI7XG4gICAgICByZXR1cm4gcmVjdGFuZ2xlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY3JUTDtcbiAgICB9XG4gIH07XG4gIHJlY3RhbmdsZS5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgY29udGV4dCA9IF8gPT0gbnVsbCA/IG51bGwgOiBfO1xuICAgICAgcmV0dXJuIHJlY3RhbmdsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGNvbnRleHQ7XG4gICAgfVxuICB9O1xuICByZXR1cm4gcmVjdGFuZ2xlO1xufVxuXG5mdW5jdGlvbiB2Z190cmFpbCAoKSB7XG4gIHZhciB4LFxuICAgIHksXG4gICAgc2l6ZSxcbiAgICBkZWZpbmVkLFxuICAgIGNvbnRleHQgPSBudWxsLFxuICAgIHJlYWR5LFxuICAgIHgxLFxuICAgIHkxLFxuICAgIHIxO1xuICBmdW5jdGlvbiBwb2ludCh4MiwgeTIsIHcyKSB7XG4gICAgY29uc3QgcjIgPSB3MiAvIDI7XG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICB2YXIgdXggPSB5MSAtIHkyLFxuICAgICAgICB1eSA9IHgyIC0geDE7XG4gICAgICBpZiAodXggfHwgdXkpIHtcbiAgICAgICAgLy8gZ2V0IG5vcm1hbCB2ZWN0b3JcbiAgICAgICAgdmFyIHVkID0gTWF0aC5oeXBvdCh1eCwgdXkpLFxuICAgICAgICAgIHJ4ID0gKHV4IC89IHVkKSAqIHIxLFxuICAgICAgICAgIHJ5ID0gKHV5IC89IHVkKSAqIHIxLFxuICAgICAgICAgIHQgPSBNYXRoLmF0YW4yKHV5LCB1eCk7XG5cbiAgICAgICAgLy8gZHJhdyBzZWdtZW50XG4gICAgICAgIGNvbnRleHQubW92ZVRvKHgxIC0gcngsIHkxIC0gcnkpO1xuICAgICAgICBjb250ZXh0LmxpbmVUbyh4MiAtIHV4ICogcjIsIHkyIC0gdXkgKiByMik7XG4gICAgICAgIGNvbnRleHQuYXJjKHgyLCB5MiwgcjIsIHQgLSBNYXRoLlBJLCB0KTtcbiAgICAgICAgY29udGV4dC5saW5lVG8oeDEgKyByeCwgeTEgKyByeSk7XG4gICAgICAgIGNvbnRleHQuYXJjKHgxLCB5MSwgcjEsIHQsIHQgKyBNYXRoLlBJKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQuYXJjKHgyLCB5MiwgcjIsIDAsIFRhdSk7XG4gICAgICB9XG4gICAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWFkeSA9IDE7XG4gICAgfVxuICAgIHgxID0geDI7XG4gICAgeTEgPSB5MjtcbiAgICByMSA9IHIyO1xuICB9XG4gIGZ1bmN0aW9uIHRyYWlsKGRhdGEpIHtcbiAgICB2YXIgaSxcbiAgICAgIG4gPSBkYXRhLmxlbmd0aCxcbiAgICAgIGQsXG4gICAgICBkZWZpbmVkMCA9IGZhbHNlLFxuICAgICAgYnVmZmVyO1xuICAgIGlmIChjb250ZXh0ID09IG51bGwpIGNvbnRleHQgPSBidWZmZXIgPSBwYXRoJDMoKTtcbiAgICBmb3IgKGkgPSAwOyBpIDw9IG47ICsraSkge1xuICAgICAgaWYgKCEoaSA8IG4gJiYgZGVmaW5lZChkID0gZGF0YVtpXSwgaSwgZGF0YSkpID09PSBkZWZpbmVkMCkge1xuICAgICAgICBpZiAoZGVmaW5lZDAgPSAhZGVmaW5lZDApIHJlYWR5ID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChkZWZpbmVkMCkgcG9pbnQoK3goZCwgaSwgZGF0YSksICt5KGQsIGksIGRhdGEpLCArc2l6ZShkLCBpLCBkYXRhKSk7XG4gICAgfVxuICAgIGlmIChidWZmZXIpIHtcbiAgICAgIGNvbnRleHQgPSBudWxsO1xuICAgICAgcmV0dXJuIGJ1ZmZlciArICcnIHx8IG51bGw7XG4gICAgfVxuICB9XG4gIHRyYWlsLnggPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICB4ID0gXztcbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHg7XG4gICAgfVxuICB9O1xuICB0cmFpbC55ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgeSA9IF87XG4gICAgICByZXR1cm4gdHJhaWw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB5O1xuICAgIH1cbiAgfTtcbiAgdHJhaWwuc2l6ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNpemUgPSBfO1xuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH07XG4gIHRyYWlsLmRlZmluZWQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBkZWZpbmVkID0gXztcbiAgICAgIHJldHVybiB0cmFpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRlZmluZWQ7XG4gICAgfVxuICB9O1xuICB0cmFpbC5jb250ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgaWYgKF8gPT0gbnVsbCkge1xuICAgICAgICBjb250ZXh0ID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRleHQgPSBfO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWlsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gIH07XG4gIHJldHVybiB0cmFpbDtcbn1cblxuZnVuY3Rpb24gdmFsdWUkMShhLCBiKSB7XG4gIHJldHVybiBhICE9IG51bGwgPyBhIDogYjtcbn1cbmNvbnN0IHggPSBpdGVtID0+IGl0ZW0ueCB8fCAwLFxuICB5ID0gaXRlbSA9PiBpdGVtLnkgfHwgMCxcbiAgdyA9IGl0ZW0gPT4gaXRlbS53aWR0aCB8fCAwLFxuICBoID0gaXRlbSA9PiBpdGVtLmhlaWdodCB8fCAwLFxuICB4dyA9IGl0ZW0gPT4gKGl0ZW0ueCB8fCAwKSArIChpdGVtLndpZHRoIHx8IDApLFxuICB5aCA9IGl0ZW0gPT4gKGl0ZW0ueSB8fCAwKSArIChpdGVtLmhlaWdodCB8fCAwKSxcbiAgc2EgPSBpdGVtID0+IGl0ZW0uc3RhcnRBbmdsZSB8fCAwLFxuICBlYSA9IGl0ZW0gPT4gaXRlbS5lbmRBbmdsZSB8fCAwLFxuICBwYSA9IGl0ZW0gPT4gaXRlbS5wYWRBbmdsZSB8fCAwLFxuICBpciA9IGl0ZW0gPT4gaXRlbS5pbm5lclJhZGl1cyB8fCAwLFxuICBvciA9IGl0ZW0gPT4gaXRlbS5vdXRlclJhZGl1cyB8fCAwLFxuICBjciA9IGl0ZW0gPT4gaXRlbS5jb3JuZXJSYWRpdXMgfHwgMCxcbiAgdGwgPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5jb3JuZXJSYWRpdXNUb3BMZWZ0LCBpdGVtLmNvcm5lclJhZGl1cykgfHwgMCxcbiAgdHIgPSBpdGVtID0+IHZhbHVlJDEoaXRlbS5jb3JuZXJSYWRpdXNUb3BSaWdodCwgaXRlbS5jb3JuZXJSYWRpdXMpIHx8IDAsXG4gIGJyID0gaXRlbSA9PiB2YWx1ZSQxKGl0ZW0uY29ybmVyUmFkaXVzQm90dG9tUmlnaHQsIGl0ZW0uY29ybmVyUmFkaXVzKSB8fCAwLFxuICBibCA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLmNvcm5lclJhZGl1c0JvdHRvbUxlZnQsIGl0ZW0uY29ybmVyUmFkaXVzKSB8fCAwLFxuICBzeiA9IGl0ZW0gPT4gdmFsdWUkMShpdGVtLnNpemUsIDY0KSxcbiAgdHMgPSBpdGVtID0+IGl0ZW0uc2l6ZSB8fCAxLFxuICBkZWYgPSBpdGVtID0+ICEoaXRlbS5kZWZpbmVkID09PSBmYWxzZSksXG4gIHR5cGUgPSBpdGVtID0+IHN5bWJvbHMoaXRlbS5zaGFwZSB8fCAnY2lyY2xlJyk7XG5jb25zdCBhcmNTaGFwZSA9IGFyYyQyKCkuc3RhcnRBbmdsZShzYSkuZW5kQW5nbGUoZWEpLnBhZEFuZ2xlKHBhKS5pbm5lclJhZGl1cyhpcikub3V0ZXJSYWRpdXMob3IpLmNvcm5lclJhZGl1cyhjciksXG4gIGFyZWF2U2hhcGUgPSBhcmVhJDIoKS54KHgpLnkxKHkpLnkwKHloKS5kZWZpbmVkKGRlZiksXG4gIGFyZWFoU2hhcGUgPSBhcmVhJDIoKS55KHkpLngxKHgpLngwKHh3KS5kZWZpbmVkKGRlZiksXG4gIGxpbmVTaGFwZSA9IGxpbmUkMigpLngoeCkueSh5KS5kZWZpbmVkKGRlZiksXG4gIHJlY3RTaGFwZSA9IHZnX3JlY3QoKS54KHgpLnkoeSkud2lkdGgodykuaGVpZ2h0KGgpLmNvcm5lclJhZGl1cyh0bCwgdHIsIGJyLCBibCksXG4gIHN5bWJvbFNoYXBlID0gc3ltYm9sJDIoKS50eXBlKHR5cGUpLnNpemUoc3opLFxuICB0cmFpbFNoYXBlID0gdmdfdHJhaWwoKS54KHgpLnkoeSkuZGVmaW5lZChkZWYpLnNpemUodHMpO1xuZnVuY3Rpb24gaGFzQ29ybmVyUmFkaXVzKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0uY29ybmVyUmFkaXVzIHx8IGl0ZW0uY29ybmVyUmFkaXVzVG9wTGVmdCB8fCBpdGVtLmNvcm5lclJhZGl1c1RvcFJpZ2h0IHx8IGl0ZW0uY29ybmVyUmFkaXVzQm90dG9tUmlnaHQgfHwgaXRlbS5jb3JuZXJSYWRpdXNCb3R0b21MZWZ0O1xufVxuZnVuY3Rpb24gYXJjJDEoY29udGV4dCwgaXRlbSkge1xuICByZXR1cm4gYXJjU2hhcGUuY29udGV4dChjb250ZXh0KShpdGVtKTtcbn1cbmZ1bmN0aW9uIGFyZWEkMShjb250ZXh0LCBpdGVtcykge1xuICBjb25zdCBpdGVtID0gaXRlbXNbMF0sXG4gICAgaW50ZXJwID0gaXRlbS5pbnRlcnBvbGF0ZSB8fCAnbGluZWFyJztcbiAgcmV0dXJuIChpdGVtLm9yaWVudCA9PT0gJ2hvcml6b250YWwnID8gYXJlYWhTaGFwZSA6IGFyZWF2U2hhcGUpLmN1cnZlKGN1cnZlcyhpbnRlcnAsIGl0ZW0ub3JpZW50LCBpdGVtLnRlbnNpb24pKS5jb250ZXh0KGNvbnRleHQpKGl0ZW1zKTtcbn1cbmZ1bmN0aW9uIGxpbmUkMShjb250ZXh0LCBpdGVtcykge1xuICBjb25zdCBpdGVtID0gaXRlbXNbMF0sXG4gICAgaW50ZXJwID0gaXRlbS5pbnRlcnBvbGF0ZSB8fCAnbGluZWFyJztcbiAgcmV0dXJuIGxpbmVTaGFwZS5jdXJ2ZShjdXJ2ZXMoaW50ZXJwLCBpdGVtLm9yaWVudCwgaXRlbS50ZW5zaW9uKSkuY29udGV4dChjb250ZXh0KShpdGVtcyk7XG59XG5mdW5jdGlvbiByZWN0YW5nbGUoY29udGV4dCwgaXRlbSwgeCwgeSkge1xuICByZXR1cm4gcmVjdFNoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbSwgeCwgeSk7XG59XG5mdW5jdGlvbiBzaGFwZSQxKGNvbnRleHQsIGl0ZW0pIHtcbiAgcmV0dXJuIChpdGVtLm1hcmsuc2hhcGUgfHwgaXRlbS5zaGFwZSkuY29udGV4dChjb250ZXh0KShpdGVtKTtcbn1cbmZ1bmN0aW9uIHN5bWJvbCQxKGNvbnRleHQsIGl0ZW0pIHtcbiAgcmV0dXJuIHN5bWJvbFNoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbSk7XG59XG5mdW5jdGlvbiB0cmFpbCQxKGNvbnRleHQsIGl0ZW1zKSB7XG4gIHJldHVybiB0cmFpbFNoYXBlLmNvbnRleHQoY29udGV4dCkoaXRlbXMpO1xufVxuXG52YXIgY2xpcF9pZCA9IDE7XG5mdW5jdGlvbiByZXNldFNWR0NsaXBJZCgpIHtcbiAgY2xpcF9pZCA9IDE7XG59XG5mdW5jdGlvbiBjbGlwJDEgKHJlbmRlcmVyLCBpdGVtLCBzaXplKSB7XG4gIHZhciBjbGlwID0gaXRlbS5jbGlwLFxuICAgIGRlZnMgPSByZW5kZXJlci5fZGVmcyxcbiAgICBpZCA9IGl0ZW0uY2xpcF9pZCB8fCAoaXRlbS5jbGlwX2lkID0gJ2NsaXAnICsgY2xpcF9pZCsrKSxcbiAgICBjID0gZGVmcy5jbGlwcGluZ1tpZF0gfHwgKGRlZnMuY2xpcHBpbmdbaWRdID0ge1xuICAgICAgaWQ6IGlkXG4gICAgfSk7XG4gIGlmIChpc0Z1bmN0aW9uKGNsaXApKSB7XG4gICAgYy5wYXRoID0gY2xpcChudWxsKTtcbiAgfSBlbHNlIGlmIChoYXNDb3JuZXJSYWRpdXMoc2l6ZSkpIHtcbiAgICBjLnBhdGggPSByZWN0YW5nbGUobnVsbCwgc2l6ZSwgMCwgMCk7XG4gIH0gZWxzZSB7XG4gICAgYy53aWR0aCA9IHNpemUud2lkdGggfHwgMDtcbiAgICBjLmhlaWdodCA9IHNpemUuaGVpZ2h0IHx8IDA7XG4gIH1cbiAgcmV0dXJuICd1cmwoIycgKyBpZCArICcpJztcbn1cblxuZnVuY3Rpb24gQm91bmRzKGIpIHtcbiAgdGhpcy5jbGVhcigpO1xuICBpZiAoYikgdGhpcy51bmlvbihiKTtcbn1cbkJvdW5kcy5wcm90b3R5cGUgPSB7XG4gIGNsb25lKCkge1xuICAgIHJldHVybiBuZXcgQm91bmRzKHRoaXMpO1xuICB9LFxuICBjbGVhcigpIHtcbiAgICB0aGlzLngxID0gK051bWJlci5NQVhfVkFMVUU7XG4gICAgdGhpcy55MSA9ICtOdW1iZXIuTUFYX1ZBTFVFO1xuICAgIHRoaXMueDIgPSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgICB0aGlzLnkyID0gLU51bWJlci5NQVhfVkFMVUU7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVtcHR5KCkge1xuICAgIHJldHVybiB0aGlzLngxID09PSArTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLnkxID09PSArTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLngyID09PSAtTnVtYmVyLk1BWF9WQUxVRSAmJiB0aGlzLnkyID09PSAtTnVtYmVyLk1BWF9WQUxVRTtcbiAgfSxcbiAgZXF1YWxzKGIpIHtcbiAgICByZXR1cm4gdGhpcy54MSA9PT0gYi54MSAmJiB0aGlzLnkxID09PSBiLnkxICYmIHRoaXMueDIgPT09IGIueDIgJiYgdGhpcy55MiA9PT0gYi55MjtcbiAgfSxcbiAgc2V0KHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgaWYgKHgyIDwgeDEpIHtcbiAgICAgIHRoaXMueDIgPSB4MTtcbiAgICAgIHRoaXMueDEgPSB4MjtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy54MSA9IHgxO1xuICAgICAgdGhpcy54MiA9IHgyO1xuICAgIH1cbiAgICBpZiAoeTIgPCB5MSkge1xuICAgICAgdGhpcy55MiA9IHkxO1xuICAgICAgdGhpcy55MSA9IHkyO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnkxID0geTE7XG4gICAgICB0aGlzLnkyID0geTI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGQoeCwgeSkge1xuICAgIGlmICh4IDwgdGhpcy54MSkgdGhpcy54MSA9IHg7XG4gICAgaWYgKHkgPCB0aGlzLnkxKSB0aGlzLnkxID0geTtcbiAgICBpZiAoeCA+IHRoaXMueDIpIHRoaXMueDIgPSB4O1xuICAgIGlmICh5ID4gdGhpcy55MikgdGhpcy55MiA9IHk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGV4cGFuZChkKSB7XG4gICAgdGhpcy54MSAtPSBkO1xuICAgIHRoaXMueTEgLT0gZDtcbiAgICB0aGlzLngyICs9IGQ7XG4gICAgdGhpcy55MiArPSBkO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByb3VuZCgpIHtcbiAgICB0aGlzLngxID0gTWF0aC5mbG9vcih0aGlzLngxKTtcbiAgICB0aGlzLnkxID0gTWF0aC5mbG9vcih0aGlzLnkxKTtcbiAgICB0aGlzLngyID0gTWF0aC5jZWlsKHRoaXMueDIpO1xuICAgIHRoaXMueTIgPSBNYXRoLmNlaWwodGhpcy55Mik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNjYWxlKHMpIHtcbiAgICB0aGlzLngxICo9IHM7XG4gICAgdGhpcy55MSAqPSBzO1xuICAgIHRoaXMueDIgKj0gcztcbiAgICB0aGlzLnkyICo9IHM7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHRyYW5zbGF0ZShkeCwgZHkpIHtcbiAgICB0aGlzLngxICs9IGR4O1xuICAgIHRoaXMueDIgKz0gZHg7XG4gICAgdGhpcy55MSArPSBkeTtcbiAgICB0aGlzLnkyICs9IGR5O1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByb3RhdGUoYW5nbGUsIHgsIHkpIHtcbiAgICBjb25zdCBwID0gdGhpcy5yb3RhdGVkUG9pbnRzKGFuZ2xlLCB4LCB5KTtcbiAgICByZXR1cm4gdGhpcy5jbGVhcigpLmFkZChwWzBdLCBwWzFdKS5hZGQocFsyXSwgcFszXSkuYWRkKHBbNF0sIHBbNV0pLmFkZChwWzZdLCBwWzddKTtcbiAgfSxcbiAgcm90YXRlZFBvaW50cyhhbmdsZSwgeCwgeSkge1xuICAgIHZhciB7XG4gICAgICAgIHgxLFxuICAgICAgICB5MSxcbiAgICAgICAgeDIsXG4gICAgICAgIHkyXG4gICAgICB9ID0gdGhpcyxcbiAgICAgIGNvcyA9IE1hdGguY29zKGFuZ2xlKSxcbiAgICAgIHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcbiAgICAgIGN4ID0geCAtIHggKiBjb3MgKyB5ICogc2luLFxuICAgICAgY3kgPSB5IC0geCAqIHNpbiAtIHkgKiBjb3M7XG4gICAgcmV0dXJuIFtjb3MgKiB4MSAtIHNpbiAqIHkxICsgY3gsIHNpbiAqIHgxICsgY29zICogeTEgKyBjeSwgY29zICogeDEgLSBzaW4gKiB5MiArIGN4LCBzaW4gKiB4MSArIGNvcyAqIHkyICsgY3ksIGNvcyAqIHgyIC0gc2luICogeTEgKyBjeCwgc2luICogeDIgKyBjb3MgKiB5MSArIGN5LCBjb3MgKiB4MiAtIHNpbiAqIHkyICsgY3gsIHNpbiAqIHgyICsgY29zICogeTIgKyBjeV07XG4gIH0sXG4gIHVuaW9uKGIpIHtcbiAgICBpZiAoYi54MSA8IHRoaXMueDEpIHRoaXMueDEgPSBiLngxO1xuICAgIGlmIChiLnkxIDwgdGhpcy55MSkgdGhpcy55MSA9IGIueTE7XG4gICAgaWYgKGIueDIgPiB0aGlzLngyKSB0aGlzLngyID0gYi54MjtcbiAgICBpZiAoYi55MiA+IHRoaXMueTIpIHRoaXMueTIgPSBiLnkyO1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBpbnRlcnNlY3QoYikge1xuICAgIGlmIChiLngxID4gdGhpcy54MSkgdGhpcy54MSA9IGIueDE7XG4gICAgaWYgKGIueTEgPiB0aGlzLnkxKSB0aGlzLnkxID0gYi55MTtcbiAgICBpZiAoYi54MiA8IHRoaXMueDIpIHRoaXMueDIgPSBiLngyO1xuICAgIGlmIChiLnkyIDwgdGhpcy55MikgdGhpcy55MiA9IGIueTI7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGVuY2xvc2VzKGIpIHtcbiAgICByZXR1cm4gYiAmJiB0aGlzLngxIDw9IGIueDEgJiYgdGhpcy54MiA+PSBiLngyICYmIHRoaXMueTEgPD0gYi55MSAmJiB0aGlzLnkyID49IGIueTI7XG4gIH0sXG4gIGFsaWduc1dpdGgoYikge1xuICAgIHJldHVybiBiICYmICh0aGlzLngxID09IGIueDEgfHwgdGhpcy54MiA9PSBiLngyIHx8IHRoaXMueTEgPT0gYi55MSB8fCB0aGlzLnkyID09IGIueTIpO1xuICB9LFxuICBpbnRlcnNlY3RzKGIpIHtcbiAgICByZXR1cm4gYiAmJiAhKHRoaXMueDIgPCBiLngxIHx8IHRoaXMueDEgPiBiLngyIHx8IHRoaXMueTIgPCBiLnkxIHx8IHRoaXMueTEgPiBiLnkyKTtcbiAgfSxcbiAgY29udGFpbnMoeCwgeSkge1xuICAgIHJldHVybiAhKHggPCB0aGlzLngxIHx8IHggPiB0aGlzLngyIHx8IHkgPCB0aGlzLnkxIHx8IHkgPiB0aGlzLnkyKTtcbiAgfSxcbiAgd2lkdGgoKSB7XG4gICAgcmV0dXJuIHRoaXMueDIgLSB0aGlzLngxO1xuICB9LFxuICBoZWlnaHQoKSB7XG4gICAgcmV0dXJuIHRoaXMueTIgLSB0aGlzLnkxO1xuICB9XG59O1xuXG5mdW5jdGlvbiBJdGVtKG1hcmspIHtcbiAgdGhpcy5tYXJrID0gbWFyaztcbiAgdGhpcy5ib3VuZHMgPSB0aGlzLmJvdW5kcyB8fCBuZXcgQm91bmRzKCk7XG59XG5cbmZ1bmN0aW9uIEdyb3VwSXRlbShtYXJrKSB7XG4gIEl0ZW0uY2FsbCh0aGlzLCBtYXJrKTtcbiAgdGhpcy5pdGVtcyA9IHRoaXMuaXRlbXMgfHwgW107XG59XG5pbmhlcml0cyhHcm91cEl0ZW0sIEl0ZW0pO1xuXG5jbGFzcyBSZXNvdXJjZUxvYWRlciB7XG4gIGNvbnN0cnVjdG9yKGN1c3RvbUxvYWRlcikge1xuICAgIHRoaXMuX3BlbmRpbmcgPSAwO1xuICAgIHRoaXMuX2xvYWRlciA9IGN1c3RvbUxvYWRlciB8fCBsb2FkZXIoKTtcbiAgfVxuICBwZW5kaW5nKCkge1xuICAgIHJldHVybiB0aGlzLl9wZW5kaW5nO1xuICB9XG4gIHNhbml0aXplVVJMKHVyaSkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXM7XG4gICAgaW5jcmVtZW50KGxvYWRlcik7XG4gICAgcmV0dXJuIGxvYWRlci5fbG9hZGVyLnNhbml0aXplKHVyaSwge1xuICAgICAgY29udGV4dDogJ2hyZWYnXG4gICAgfSkudGhlbihvcHQgPT4ge1xuICAgICAgZGVjcmVtZW50KGxvYWRlcik7XG4gICAgICByZXR1cm4gb3B0O1xuICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgIGRlY3JlbWVudChsb2FkZXIpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSk7XG4gIH1cbiAgbG9hZEltYWdlKHVyaSkge1xuICAgIGNvbnN0IGxvYWRlciA9IHRoaXMsXG4gICAgICBJbWFnZSA9IGltYWdlJDEoKTtcbiAgICBpbmNyZW1lbnQobG9hZGVyKTtcbiAgICByZXR1cm4gbG9hZGVyLl9sb2FkZXIuc2FuaXRpemUodXJpLCB7XG4gICAgICBjb250ZXh0OiAnaW1hZ2UnXG4gICAgfSkudGhlbihvcHQgPT4ge1xuICAgICAgY29uc3QgdXJsID0gb3B0LmhyZWY7XG4gICAgICBpZiAoIXVybCB8fCAhSW1hZ2UpIHRocm93IHtcbiAgICAgICAgdXJsOiB1cmxcbiAgICAgIH07XG4gICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcblxuICAgICAgLy8gc2V0IGNyb3NzT3JpZ2luIG9ubHkgaWYgY29ycyBpcyBkZWZpbmVkOyBlbXB0eSBzdHJpbmcgc2V0cyBhbm9ueW1vdXMgbW9kZVxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxJbWFnZUVsZW1lbnQvY3Jvc3NPcmlnaW5cbiAgICAgIGNvbnN0IGNvcnMgPSBoYXNPd25Qcm9wZXJ0eShvcHQsICdjcm9zc09yaWdpbicpID8gb3B0LmNyb3NzT3JpZ2luIDogJ2Fub255bW91cyc7XG4gICAgICBpZiAoY29ycyAhPSBudWxsKSBpbWcuY3Jvc3NPcmlnaW4gPSBjb3JzO1xuXG4gICAgICAvLyBhdHRlbXB0IHRvIGxvYWQgaW1hZ2UgcmVzb3VyY2VcbiAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiBkZWNyZW1lbnQobG9hZGVyKTtcbiAgICAgIGltZy5vbmVycm9yID0gKCkgPT4gZGVjcmVtZW50KGxvYWRlcik7XG4gICAgICBpbWcuc3JjID0gdXJsO1xuICAgICAgcmV0dXJuIGltZztcbiAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgIGRlY3JlbWVudChsb2FkZXIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY29tcGxldGU6IGZhbHNlLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICBzcmM6IGUgJiYgZS51cmwgfHwgJydcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmVhZHkoKSB7XG4gICAgY29uc3QgbG9hZGVyID0gdGhpcztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYWNjZXB0ID0+IHtcbiAgICAgIGZ1bmN0aW9uIHBvbGwodmFsdWUpIHtcbiAgICAgICAgaWYgKCFsb2FkZXIucGVuZGluZygpKSBhY2NlcHQodmFsdWUpO2Vsc2Ugc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcG9sbCh0cnVlKTtcbiAgICAgICAgfSwgMTApO1xuICAgICAgfVxuICAgICAgcG9sbChmYWxzZSk7XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGluY3JlbWVudChsb2FkZXIpIHtcbiAgbG9hZGVyLl9wZW5kaW5nICs9IDE7XG59XG5mdW5jdGlvbiBkZWNyZW1lbnQobG9hZGVyKSB7XG4gIGxvYWRlci5fcGVuZGluZyAtPSAxO1xufVxuXG5mdW5jdGlvbiBib3VuZFN0cm9rZSAoYm91bmRzLCBpdGVtLCBtaXRlcikge1xuICBpZiAoaXRlbS5zdHJva2UgJiYgaXRlbS5vcGFjaXR5ICE9PSAwICYmIGl0ZW0uc3Ryb2tlT3BhY2l0eSAhPT0gMCkge1xuICAgIGNvbnN0IHN3ID0gaXRlbS5zdHJva2VXaWR0aCAhPSBudWxsID8gK2l0ZW0uc3Ryb2tlV2lkdGggOiAxO1xuICAgIGJvdW5kcy5leHBhbmQoc3cgKyAobWl0ZXIgPyBtaXRlckFkanVzdG1lbnQoaXRlbSwgc3cpIDogMCkpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5mdW5jdGlvbiBtaXRlckFkanVzdG1lbnQoaXRlbSwgc3Ryb2tlV2lkdGgpIHtcbiAgLy8gVE9ETzogbW9yZSBzb3BoaXN0aWNhdGVkIGFkanVzdG1lbnQ/IE9yIG1pdGVyIHN1cHBvcnQgaW4gYm91bmRDb250ZXh0P1xuICByZXR1cm4gaXRlbS5zdHJva2VKb2luICYmIGl0ZW0uc3Ryb2tlSm9pbiAhPT0gJ21pdGVyJyA/IDAgOiBzdHJva2VXaWR0aDtcbn1cblxuY29uc3QgY2lyY2xlVGhyZXNob2xkID0gVGF1IC0gMWUtODtcbmxldCBib3VuZHMsIGx4LCBseSwgcm90LCBtYSwgbWIsIG1jLCBtZDtcbmNvbnN0IGFkZCA9ICh4LCB5KSA9PiBib3VuZHMuYWRkKHgsIHkpO1xuY29uc3QgYWRkTCA9ICh4LCB5KSA9PiBhZGQobHggPSB4LCBseSA9IHkpO1xuY29uc3QgYWRkWCA9IHggPT4gYWRkKHgsIGJvdW5kcy55MSk7XG5jb25zdCBhZGRZID0geSA9PiBhZGQoYm91bmRzLngxLCB5KTtcbmNvbnN0IHB4ID0gKHgsIHkpID0+IG1hICogeCArIG1jICogeTtcbmNvbnN0IHB5ID0gKHgsIHkpID0+IG1iICogeCArIG1kICogeTtcbmNvbnN0IGFkZHAgPSAoeCwgeSkgPT4gYWRkKHB4KHgsIHkpLCBweSh4LCB5KSk7XG5jb25zdCBhZGRwTCA9ICh4LCB5KSA9PiBhZGRMKHB4KHgsIHkpLCBweSh4LCB5KSk7XG5mdW5jdGlvbiBib3VuZENvbnRleHQgKF8sIGRlZykge1xuICBib3VuZHMgPSBfO1xuICBpZiAoZGVnKSB7XG4gICAgcm90ID0gZGVnICogRGVnVG9SYWQ7XG4gICAgbWEgPSBtZCA9IE1hdGguY29zKHJvdCk7XG4gICAgbWIgPSBNYXRoLnNpbihyb3QpO1xuICAgIG1jID0gLW1iO1xuICB9IGVsc2Uge1xuICAgIG1hID0gbWQgPSAxO1xuICAgIHJvdCA9IG1iID0gbWMgPSAwO1xuICB9XG4gIHJldHVybiBjb250ZXh0JDE7XG59XG5jb25zdCBjb250ZXh0JDEgPSB7XG4gIGJlZ2luUGF0aCgpIHt9LFxuICBjbG9zZVBhdGgoKSB7fSxcbiAgbW92ZVRvOiBhZGRwTCxcbiAgbGluZVRvOiBhZGRwTCxcbiAgcmVjdCh4LCB5LCB3LCBoKSB7XG4gICAgaWYgKHJvdCkge1xuICAgICAgYWRkcCh4ICsgdywgeSk7XG4gICAgICBhZGRwKHggKyB3LCB5ICsgaCk7XG4gICAgICBhZGRwKHgsIHkgKyBoKTtcbiAgICAgIGFkZHBMKHgsIHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGQoeCArIHcsIHkgKyBoKTtcbiAgICAgIGFkZEwoeCwgeSk7XG4gICAgfVxuICB9LFxuICBxdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY29uc3QgcHgxID0gcHgoeDEsIHkxKSxcbiAgICAgIHB5MSA9IHB5KHgxLCB5MSksXG4gICAgICBweDIgPSBweCh4MiwgeTIpLFxuICAgICAgcHkyID0gcHkoeDIsIHkyKTtcbiAgICBxdWFkRXh0cmVtYShseCwgcHgxLCBweDIsIGFkZFgpO1xuICAgIHF1YWRFeHRyZW1hKGx5LCBweTEsIHB5MiwgYWRkWSk7XG4gICAgYWRkTChweDIsIHB5Mik7XG4gIH0sXG4gIGJlemllckN1cnZlVG8oeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGNvbnN0IHB4MSA9IHB4KHgxLCB5MSksXG4gICAgICBweTEgPSBweSh4MSwgeTEpLFxuICAgICAgcHgyID0gcHgoeDIsIHkyKSxcbiAgICAgIHB5MiA9IHB5KHgyLCB5MiksXG4gICAgICBweDMgPSBweCh4MywgeTMpLFxuICAgICAgcHkzID0gcHkoeDMsIHkzKTtcbiAgICBjdWJpY0V4dHJlbWEobHgsIHB4MSwgcHgyLCBweDMsIGFkZFgpO1xuICAgIGN1YmljRXh0cmVtYShseSwgcHkxLCBweTIsIHB5MywgYWRkWSk7XG4gICAgYWRkTChweDMsIHB5Myk7XG4gIH0sXG4gIGFyYyhjeCwgY3ksIHIsIHNhLCBlYSwgY2N3KSB7XG4gICAgc2EgKz0gcm90O1xuICAgIGVhICs9IHJvdDtcblxuICAgIC8vIHN0b3JlIGxhc3QgcG9pbnQgb24gcGF0aFxuICAgIGx4ID0gciAqIE1hdGguY29zKGVhKSArIGN4O1xuICAgIGx5ID0gciAqIE1hdGguc2luKGVhKSArIGN5O1xuICAgIGlmIChNYXRoLmFicyhlYSAtIHNhKSA+IGNpcmNsZVRocmVzaG9sZCkge1xuICAgICAgLy8gdHJlYXQgYXMgZnVsbCBjaXJjbGVcbiAgICAgIGFkZChjeCAtIHIsIGN5IC0gcik7XG4gICAgICBhZGQoY3ggKyByLCBjeSArIHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB1cGRhdGUgPSBhID0+IGFkZChyICogTWF0aC5jb3MoYSkgKyBjeCwgciAqIE1hdGguc2luKGEpICsgY3kpO1xuICAgICAgbGV0IHMsIGk7XG5cbiAgICAgIC8vIHNhbXBsZSBlbmQgcG9pbnRzXG4gICAgICB1cGRhdGUoc2EpO1xuICAgICAgdXBkYXRlKGVhKTtcblxuICAgICAgLy8gc2FtcGxlIGludGVyaW9yIHBvaW50cyBhbGlnbmVkIHdpdGggOTAgZGVncmVlc1xuICAgICAgaWYgKGVhICE9PSBzYSkge1xuICAgICAgICBzYSA9IHNhICUgVGF1O1xuICAgICAgICBpZiAoc2EgPCAwKSBzYSArPSBUYXU7XG4gICAgICAgIGVhID0gZWEgJSBUYXU7XG4gICAgICAgIGlmIChlYSA8IDApIGVhICs9IFRhdTtcbiAgICAgICAgaWYgKGVhIDwgc2EpIHtcbiAgICAgICAgICBjY3cgPSAhY2N3OyAvLyBmbGlwIGRpcmVjdGlvblxuICAgICAgICAgIHMgPSBzYTtcbiAgICAgICAgICBzYSA9IGVhO1xuICAgICAgICAgIGVhID0gczsgLy8gc3dhcCBlbmQtcG9pbnRzXG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNjdykge1xuICAgICAgICAgIGVhIC09IFRhdTtcbiAgICAgICAgICBzID0gc2EgLSBzYSAlIEhhbGZQaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNCAmJiBzID4gZWE7ICsraSwgcyAtPSBIYWxmUGkpIHVwZGF0ZShzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzID0gc2EgLSBzYSAlIEhhbGZQaSArIEhhbGZQaTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNCAmJiBzIDwgZWE7ICsraSwgcyA9IHMgKyBIYWxmUGkpIHVwZGF0ZShzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcbmZ1bmN0aW9uIHF1YWRFeHRyZW1hKHgwLCB4MSwgeDIsIGNiKSB7XG4gIGNvbnN0IHQgPSAoeDAgLSB4MSkgLyAoeDAgKyB4MiAtIDIgKiB4MSk7XG4gIGlmICgwIDwgdCAmJiB0IDwgMSkgY2IoeDAgKyAoeDEgLSB4MCkgKiB0KTtcbn1cbmZ1bmN0aW9uIGN1YmljRXh0cmVtYSh4MCwgeDEsIHgyLCB4MywgY2IpIHtcbiAgY29uc3QgYSA9IHgzIC0geDAgKyAzICogeDEgLSAzICogeDIsXG4gICAgYiA9IHgwICsgeDIgLSAyICogeDEsXG4gICAgYyA9IHgwIC0geDE7XG4gIGxldCB0MCA9IDAsXG4gICAgdDEgPSAwLFxuICAgIHI7XG5cbiAgLy8gc29sdmUgZm9yIHBhcmFtZXRlciB0XG4gIGlmIChNYXRoLmFicyhhKSA+IEVwc2lsb24pIHtcbiAgICAvLyBxdWFkcmF0aWMgZXF1YXRpb25cbiAgICByID0gYiAqIGIgKyBjICogYTtcbiAgICBpZiAociA+PSAwKSB7XG4gICAgICByID0gTWF0aC5zcXJ0KHIpO1xuICAgICAgdDAgPSAoLWIgKyByKSAvIGE7XG4gICAgICB0MSA9ICgtYiAtIHIpIC8gYTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gbGluZWFyIGVxdWF0aW9uXG4gICAgdDAgPSAwLjUgKiBjIC8gYjtcbiAgfVxuXG4gIC8vIGNhbGN1bGF0ZSBwb3NpdGlvblxuICBpZiAoMCA8IHQwICYmIHQwIDwgMSkgY2IoY3ViaWModDAsIHgwLCB4MSwgeDIsIHgzKSk7XG4gIGlmICgwIDwgdDEgJiYgdDEgPCAxKSBjYihjdWJpYyh0MSwgeDAsIHgxLCB4MiwgeDMpKTtcbn1cbmZ1bmN0aW9uIGN1YmljKHQsIHgwLCB4MSwgeDIsIHgzKSB7XG4gIGNvbnN0IHMgPSAxIC0gdCxcbiAgICBzMiA9IHMgKiBzLFxuICAgIHQyID0gdCAqIHQ7XG4gIHJldHVybiBzMiAqIHMgKiB4MCArIDMgKiBzMiAqIHQgKiB4MSArIDMgKiBzICogdDIgKiB4MiArIHQyICogdCAqIHgzO1xufVxuXG52YXIgY29udGV4dCA9IChjb250ZXh0ID0gY2FudmFzKDEsIDEpKSA/IGNvbnRleHQuZ2V0Q29udGV4dCgnMmQnKSA6IG51bGw7XG5cbmNvbnN0IGIgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBpbnRlcnNlY3RQYXRoKGRyYXcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChpdGVtLCBicnVzaCkge1xuICAgIC8vIHJlbHkgb24gKGluYWNjdXJhdGUpIGJvdW5kcyBpbnRlcnNlY3Rpb24gaWYgbm8gY29udGV4dFxuICAgIGlmICghY29udGV4dCkgcmV0dXJuIHRydWU7XG5cbiAgICAvLyBhZGQgcGF0aCB0byBvZmZzY3JlZW4gZ3JhcGhpY3MgY29udGV4dFxuICAgIGRyYXcoY29udGV4dCwgaXRlbSk7XG5cbiAgICAvLyBnZXQgYm91bmRzIGludGVyc2VjdGlvbiByZWdpb25cbiAgICBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpLmludGVyc2VjdChicnVzaCkucm91bmQoKTtcbiAgICBjb25zdCB7XG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MlxuICAgIH0gPSBiO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGludGVyc2VjdGlvbiByZWdpb25cbiAgICAvLyBwZXJmb3JtIGZpbmUgZ3JhaW5lZCBpbmNsdXNpb24gdGVzdFxuICAgIGZvciAobGV0IHkgPSB5MTsgeSA8PSB5MjsgKyt5KSB7XG4gICAgICBmb3IgKGxldCB4ID0geDE7IHggPD0geDI7ICsreCkge1xuICAgICAgICBpZiAoY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBmYWxzZSBpZiBubyBoaXRzIGluIGludGVyc2VjdGlvbiByZWdpb25cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RQb2ludChpdGVtLCBib3gpIHtcbiAgcmV0dXJuIGJveC5jb250YWlucyhpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0UmVjdChpdGVtLCBib3gpIHtcbiAgY29uc3QgeCA9IGl0ZW0ueCB8fCAwLFxuICAgIHkgPSBpdGVtLnkgfHwgMCxcbiAgICB3ID0gaXRlbS53aWR0aCB8fCAwLFxuICAgIGggPSBpdGVtLmhlaWdodCB8fCAwO1xuICByZXR1cm4gYm94LmludGVyc2VjdHMoYi5zZXQoeCwgeSwgeCArIHcsIHkgKyBoKSk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RSdWxlKGl0ZW0sIGJveCkge1xuICBjb25zdCB4ID0gaXRlbS54IHx8IDAsXG4gICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgIHgyID0gaXRlbS54MiAhPSBudWxsID8gaXRlbS54MiA6IHgsXG4gICAgeTIgPSBpdGVtLnkyICE9IG51bGwgPyBpdGVtLnkyIDogeTtcbiAgcmV0dXJuIGludGVyc2VjdEJveExpbmUoYm94LCB4LCB5LCB4MiwgeTIpO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0Qm94TGluZShib3gsIHgsIHksIHUsIHYpIHtcbiAgY29uc3Qge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICB9ID0gYm94LFxuICAgIGR4ID0gdSAtIHgsXG4gICAgZHkgPSB2IC0geTtcbiAgbGV0IHQwID0gMCxcbiAgICB0MSA9IDEsXG4gICAgcCxcbiAgICBxLFxuICAgIHIsXG4gICAgZTtcbiAgZm9yIChlID0gMDsgZSA8IDQ7ICsrZSkge1xuICAgIGlmIChlID09PSAwKSB7XG4gICAgICBwID0gLWR4O1xuICAgICAgcSA9IC0oeDEgLSB4KTtcbiAgICB9XG4gICAgaWYgKGUgPT09IDEpIHtcbiAgICAgIHAgPSBkeDtcbiAgICAgIHEgPSB4MiAtIHg7XG4gICAgfVxuICAgIGlmIChlID09PSAyKSB7XG4gICAgICBwID0gLWR5O1xuICAgICAgcSA9IC0oeTEgLSB5KTtcbiAgICB9XG4gICAgaWYgKGUgPT09IDMpIHtcbiAgICAgIHAgPSBkeTtcbiAgICAgIHEgPSB5MiAtIHk7XG4gICAgfVxuICAgIGlmIChNYXRoLmFicyhwKSA8IDFlLTEwICYmIHEgPCAwKSByZXR1cm4gZmFsc2U7XG4gICAgciA9IHEgLyBwO1xuICAgIGlmIChwIDwgMCkge1xuICAgICAgaWYgKHIgPiB0MSkgcmV0dXJuIGZhbHNlO2Vsc2UgaWYgKHIgPiB0MCkgdDAgPSByO1xuICAgIH0gZWxzZSBpZiAocCA+IDApIHtcbiAgICAgIGlmIChyIDwgdDApIHJldHVybiBmYWxzZTtlbHNlIGlmIChyIDwgdDEpIHQxID0gcjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGJsZW5kIChjb250ZXh0LCBpdGVtKSB7XG4gIGNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gaXRlbS5ibGVuZCB8fCAnc291cmNlLW92ZXInO1xufVxuXG5mdW5jdGlvbiB2YWx1ZSAodmFsdWUsIGRmbHQpIHtcbiAgcmV0dXJuIHZhbHVlID09IG51bGwgPyBkZmx0IDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIGFkZFN0b3BzKGdyYWRpZW50LCBzdG9wcykge1xuICBjb25zdCBuID0gc3RvcHMubGVuZ3RoO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGdyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wc1tpXS5vZmZzZXQsIHN0b3BzW2ldLmNvbG9yKTtcbiAgfVxuICByZXR1cm4gZ3JhZGllbnQ7XG59XG5mdW5jdGlvbiBncmFkaWVudCAoY29udGV4dCwgc3BlYywgYm91bmRzKSB7XG4gIGNvbnN0IHcgPSBib3VuZHMud2lkdGgoKSxcbiAgICBoID0gYm91bmRzLmhlaWdodCgpO1xuICBsZXQgZ3JhZGllbnQ7XG4gIGlmIChzcGVjLmdyYWRpZW50ID09PSAncmFkaWFsJykge1xuICAgIGdyYWRpZW50ID0gY29udGV4dC5jcmVhdGVSYWRpYWxHcmFkaWVudChib3VuZHMueDEgKyB2YWx1ZShzcGVjLngxLCAwLjUpICogdywgYm91bmRzLnkxICsgdmFsdWUoc3BlYy55MSwgMC41KSAqIGgsIE1hdGgubWF4KHcsIGgpICogdmFsdWUoc3BlYy5yMSwgMCksIGJvdW5kcy54MSArIHZhbHVlKHNwZWMueDIsIDAuNSkgKiB3LCBib3VuZHMueTEgKyB2YWx1ZShzcGVjLnkyLCAwLjUpICogaCwgTWF0aC5tYXgodywgaCkgKiB2YWx1ZShzcGVjLnIyLCAwLjUpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsaW5lYXIgZ3JhZGllbnRcbiAgICBjb25zdCB4MSA9IHZhbHVlKHNwZWMueDEsIDApLFxuICAgICAgeTEgPSB2YWx1ZShzcGVjLnkxLCAwKSxcbiAgICAgIHgyID0gdmFsdWUoc3BlYy54MiwgMSksXG4gICAgICB5MiA9IHZhbHVlKHNwZWMueTIsIDApO1xuICAgIGlmICh4MSA9PT0geDIgfHwgeTEgPT09IHkyIHx8IHcgPT09IGgpIHtcbiAgICAgIC8vIGF4aXMgYWxpZ25lZDogdXNlIG5vcm1hbCBncmFkaWVudFxuICAgICAgZ3JhZGllbnQgPSBjb250ZXh0LmNyZWF0ZUxpbmVhckdyYWRpZW50KGJvdW5kcy54MSArIHgxICogdywgYm91bmRzLnkxICsgeTEgKiBoLCBib3VuZHMueDEgKyB4MiAqIHcsIGJvdW5kcy55MSArIHkyICogaCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG5vdCBheGlzIGFsaWduZWQ6IHJlbmRlciBncmFkaWVudCBpbnRvIGEgcGF0dGVybiAoIzIzNjUpXG4gICAgICAvLyB0aGlzIGFsbG93cyB1cyB0byB1c2Ugbm9ybWFsaXplZCBib3VuZGluZyBib3ggY29vcmRpbmF0ZXNcbiAgICAgIGNvbnN0IGltYWdlID0gY2FudmFzKE1hdGguY2VpbCh3KSwgTWF0aC5jZWlsKGgpKSxcbiAgICAgICAgaWN0eCA9IGltYWdlLmdldENvbnRleHQoJzJkJyk7XG4gICAgICBpY3R4LnNjYWxlKHcsIGgpO1xuICAgICAgaWN0eC5maWxsU3R5bGUgPSBhZGRTdG9wcyhpY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHgxLCB5MSwgeDIsIHkyKSwgc3BlYy5zdG9wcyk7XG4gICAgICBpY3R4LmZpbGxSZWN0KDAsIDAsIHcsIGgpO1xuICAgICAgcmV0dXJuIGNvbnRleHQuY3JlYXRlUGF0dGVybihpbWFnZSwgJ25vLXJlcGVhdCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYWRkU3RvcHMoZ3JhZGllbnQsIHNwZWMuc3RvcHMpO1xufVxuXG5mdW5jdGlvbiBjb2xvciAoY29udGV4dCwgaXRlbSwgdmFsdWUpIHtcbiAgcmV0dXJuIGlzR3JhZGllbnQodmFsdWUpID8gZ3JhZGllbnQoY29udGV4dCwgdmFsdWUsIGl0ZW0uYm91bmRzKSA6IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBmaWxsIChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSB7XG4gIG9wYWNpdHkgKj0gaXRlbS5maWxsT3BhY2l0eSA9PSBudWxsID8gMSA6IGl0ZW0uZmlsbE9wYWNpdHk7XG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY29sb3IoY29udGV4dCwgaXRlbSwgaXRlbS5maWxsKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxudmFyIEVtcHR5ID0gW107XG5mdW5jdGlvbiBzdHJva2UgKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpIHtcbiAgdmFyIGx3ID0gKGx3ID0gaXRlbS5zdHJva2VXaWR0aCkgIT0gbnVsbCA/IGx3IDogMTtcbiAgaWYgKGx3IDw9IDApIHJldHVybiBmYWxzZTtcbiAgb3BhY2l0eSAqPSBpdGVtLnN0cm9rZU9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLnN0cm9rZU9wYWNpdHk7XG4gIGlmIChvcGFjaXR5ID4gMCkge1xuICAgIGNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuICAgIGNvbnRleHQuc3Ryb2tlU3R5bGUgPSBjb2xvcihjb250ZXh0LCBpdGVtLCBpdGVtLnN0cm9rZSk7XG4gICAgY29udGV4dC5saW5lV2lkdGggPSBsdztcbiAgICBjb250ZXh0LmxpbmVDYXAgPSBpdGVtLnN0cm9rZUNhcCB8fCAnYnV0dCc7XG4gICAgY29udGV4dC5saW5lSm9pbiA9IGl0ZW0uc3Ryb2tlSm9pbiB8fCAnbWl0ZXInO1xuICAgIGNvbnRleHQubWl0ZXJMaW1pdCA9IGl0ZW0uc3Ryb2tlTWl0ZXJMaW1pdCB8fCAxMDtcbiAgICBpZiAoY29udGV4dC5zZXRMaW5lRGFzaCkge1xuICAgICAgY29udGV4dC5zZXRMaW5lRGFzaChpdGVtLnN0cm9rZURhc2ggfHwgRW1wdHkpO1xuICAgICAgY29udGV4dC5saW5lRGFzaE9mZnNldCA9IGl0ZW0uc3Ryb2tlRGFzaE9mZnNldCB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIHJldHVybiBhLnppbmRleCAtIGIuemluZGV4IHx8IGEuaW5kZXggLSBiLmluZGV4O1xufVxuZnVuY3Rpb24gem9yZGVyKHNjZW5lKSB7XG4gIGlmICghc2NlbmUuemRpcnR5KSByZXR1cm4gc2NlbmUueml0ZW1zO1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICBvdXRwdXQgPSBbXSxcbiAgICBpdGVtLFxuICAgIGksXG4gICAgbjtcbiAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIGl0ZW0gPSBpdGVtc1tpXTtcbiAgICBpdGVtLmluZGV4ID0gaTtcbiAgICBpZiAoaXRlbS56aW5kZXgpIG91dHB1dC5wdXNoKGl0ZW0pO1xuICB9XG4gIHNjZW5lLnpkaXJ0eSA9IGZhbHNlO1xuICByZXR1cm4gc2NlbmUueml0ZW1zID0gb3V0cHV0LnNvcnQoY29tcGFyZSk7XG59XG5mdW5jdGlvbiB2aXNpdChzY2VuZSwgdmlzaXRvcikge1xuICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICBpLFxuICAgIG47XG4gIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkgcmV0dXJuO1xuICBjb25zdCB6aXRlbXMgPSB6b3JkZXIoc2NlbmUpO1xuICBpZiAoeml0ZW1zICYmIHppdGVtcy5sZW5ndGgpIHtcbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoIWl0ZW1zW2ldLnppbmRleCkgdmlzaXRvcihpdGVtc1tpXSk7XG4gICAgfVxuICAgIGl0ZW1zID0geml0ZW1zO1xuICB9XG4gIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICB2aXNpdG9yKGl0ZW1zW2ldKTtcbiAgfVxufVxuZnVuY3Rpb24gcGlja1Zpc2l0KHNjZW5lLCB2aXNpdG9yKSB7XG4gIHZhciBpdGVtcyA9IHNjZW5lLml0ZW1zLFxuICAgIGhpdCxcbiAgICBpO1xuICBpZiAoIWl0ZW1zIHx8ICFpdGVtcy5sZW5ndGgpIHJldHVybiBudWxsO1xuICBjb25zdCB6aXRlbXMgPSB6b3JkZXIoc2NlbmUpO1xuICBpZiAoeml0ZW1zICYmIHppdGVtcy5sZW5ndGgpIGl0ZW1zID0geml0ZW1zO1xuICBmb3IgKGkgPSBpdGVtcy5sZW5ndGg7IC0taSA+PSAwOykge1xuICAgIGlmIChoaXQgPSB2aXNpdG9yKGl0ZW1zW2ldKSkgcmV0dXJuIGhpdDtcbiAgfVxuICBpZiAoaXRlbXMgPT09IHppdGVtcykge1xuICAgIGZvciAoaXRlbXMgPSBzY2VuZS5pdGVtcywgaSA9IGl0ZW1zLmxlbmd0aDsgLS1pID49IDA7KSB7XG4gICAgICBpZiAoIWl0ZW1zW2ldLnppbmRleCkge1xuICAgICAgICBpZiAoaGl0ID0gdmlzaXRvcihpdGVtc1tpXSkpIHJldHVybiBoaXQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBkcmF3QWxsKHBhdGgpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gICAgdmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgICAgaWYgKCFib3VuZHMgfHwgYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpKSB7XG4gICAgICAgIGRyYXdQYXRoKHBhdGgsIGNvbnRleHQsIGl0ZW0sIGl0ZW0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gZHJhd09uZShwYXRoKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoY29udGV4dCwgc2NlbmUsIGJvdW5kcykge1xuICAgIGlmIChzY2VuZS5pdGVtcy5sZW5ndGggJiYgKCFib3VuZHMgfHwgYm91bmRzLmludGVyc2VjdHMoc2NlbmUuYm91bmRzKSkpIHtcbiAgICAgIGRyYXdQYXRoKHBhdGgsIGNvbnRleHQsIHNjZW5lLml0ZW1zWzBdLCBzY2VuZS5pdGVtcyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gZHJhd1BhdGgocGF0aCwgY29udGV4dCwgaXRlbSwgaXRlbXMpIHtcbiAgdmFyIG9wYWNpdHkgPSBpdGVtLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLm9wYWNpdHk7XG4gIGlmIChvcGFjaXR5ID09PSAwKSByZXR1cm47XG4gIGlmIChwYXRoKGNvbnRleHQsIGl0ZW1zKSkgcmV0dXJuO1xuICBibGVuZChjb250ZXh0LCBpdGVtKTtcbiAgaWYgKGl0ZW0uZmlsbCAmJiBmaWxsKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgY29udGV4dC5maWxsKCk7XG4gIH1cbiAgaWYgKGl0ZW0uc3Ryb2tlICYmIHN0cm9rZShjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGljayQxKHRlc3QpIHtcbiAgdGVzdCA9IHRlc3QgfHwgdHJ1dGh5O1xuICByZXR1cm4gZnVuY3Rpb24gKGNvbnRleHQsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICB4ICo9IGNvbnRleHQucGl4ZWxSYXRpbztcbiAgICB5ICo9IGNvbnRleHQucGl4ZWxSYXRpbztcbiAgICByZXR1cm4gcGlja1Zpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICAgIGNvbnN0IGIgPSBpdGVtLmJvdW5kcztcbiAgICAgIC8vIGZpcnN0IGhpdCB0ZXN0IGFnYWluc3QgYm91bmRpbmcgYm94XG4gICAgICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpIHx8ICFiKSByZXR1cm47XG4gICAgICAvLyBpZiBpbiBib3VuZGluZyBib3gsIHBlcmZvcm0gbW9yZSBjYXJlZnVsIHRlc3RcbiAgICAgIGlmICh0ZXN0KGNvbnRleHQsIGl0ZW0sIHgsIHksIGd4LCBneSkpIHJldHVybiBpdGVtO1xuICAgIH0pO1xuICB9O1xufVxuZnVuY3Rpb24gaGl0UGF0aChwYXRoLCBmaWxsZWQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChjb250ZXh0LCBvLCB4LCB5KSB7XG4gICAgdmFyIGl0ZW0gPSBBcnJheS5pc0FycmF5KG8pID8gb1swXSA6IG8sXG4gICAgICBmaWxsID0gZmlsbGVkID09IG51bGwgPyBpdGVtLmZpbGwgOiBmaWxsZWQsXG4gICAgICBzdHJva2UgPSBpdGVtLnN0cm9rZSAmJiBjb250ZXh0LmlzUG9pbnRJblN0cm9rZSxcbiAgICAgIGx3LFxuICAgICAgbGM7XG4gICAgaWYgKHN0cm9rZSkge1xuICAgICAgbHcgPSBpdGVtLnN0cm9rZVdpZHRoO1xuICAgICAgbGMgPSBpdGVtLnN0cm9rZUNhcDtcbiAgICAgIGNvbnRleHQubGluZVdpZHRoID0gbHcgIT0gbnVsbCA/IGx3IDogMTtcbiAgICAgIGNvbnRleHQubGluZUNhcCA9IGxjICE9IG51bGwgPyBsYyA6ICdidXR0JztcbiAgICB9XG4gICAgcmV0dXJuIHBhdGgoY29udGV4dCwgbykgPyBmYWxzZSA6IGZpbGwgJiYgY29udGV4dC5pc1BvaW50SW5QYXRoKHgsIHkpIHx8IHN0cm9rZSAmJiBjb250ZXh0LmlzUG9pbnRJblN0cm9rZSh4LCB5KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHBpY2tQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIHBpY2skMShoaXRQYXRoKHBhdGgpKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNsYXRlKHgsIHkpIHtcbiAgcmV0dXJuICd0cmFuc2xhdGUoJyArIHggKyAnLCcgKyB5ICsgJyknO1xufVxuZnVuY3Rpb24gcm90YXRlKGEpIHtcbiAgcmV0dXJuICdyb3RhdGUoJyArIGEgKyAnKSc7XG59XG5mdW5jdGlvbiBzY2FsZShzY2FsZVgsIHNjYWxlWSkge1xuICByZXR1cm4gJ3NjYWxlKCcgKyBzY2FsZVggKyAnLCcgKyBzY2FsZVkgKyAnKSc7XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVJdGVtKGl0ZW0pIHtcbiAgcmV0dXJuIHRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xufVxuZnVuY3Rpb24gcm90YXRlSXRlbShpdGVtKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKSArIChpdGVtLmFuZ2xlID8gJyAnICsgcm90YXRlKGl0ZW0uYW5nbGUpIDogJycpO1xufVxuZnVuY3Rpb24gdHJhbnNmb3JtSXRlbShpdGVtKSB7XG4gIHJldHVybiB0cmFuc2xhdGUoaXRlbS54IHx8IDAsIGl0ZW0ueSB8fCAwKSArIChpdGVtLmFuZ2xlID8gJyAnICsgcm90YXRlKGl0ZW0uYW5nbGUpIDogJycpICsgKGl0ZW0uc2NhbGVYIHx8IGl0ZW0uc2NhbGVZID8gJyAnICsgc2NhbGUoaXRlbS5zY2FsZVggfHwgMSwgaXRlbS5zY2FsZVkgfHwgMSkgOiAnJyk7XG59XG5cbmZ1bmN0aW9uIG1hcmtJdGVtUGF0aCAodHlwZSwgc2hhcGUsIGlzZWN0KSB7XG4gIGZ1bmN0aW9uIGF0dHIoZW1pdCwgaXRlbSkge1xuICAgIGVtaXQoJ3RyYW5zZm9ybScsIHJvdGF0ZUl0ZW0oaXRlbSkpO1xuICAgIGVtaXQoJ2QnLCBzaGFwZShudWxsLCBpdGVtKSk7XG4gIH1cbiAgZnVuY3Rpb24gYm91bmQoYm91bmRzLCBpdGVtKSB7XG4gICAgc2hhcGUoYm91bmRDb250ZXh0KGJvdW5kcywgaXRlbS5hbmdsZSksIGl0ZW0pO1xuICAgIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMsIGl0ZW0pLnRyYW5zbGF0ZShpdGVtLnggfHwgMCwgaXRlbS55IHx8IDApO1xuICB9XG4gIGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbSkge1xuICAgIHZhciB4ID0gaXRlbS54IHx8IDAsXG4gICAgICB5ID0gaXRlbS55IHx8IDAsXG4gICAgICBhID0gaXRlbS5hbmdsZSB8fCAwO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgIGlmIChhKSBjb250ZXh0LnJvdGF0ZShhICo9IERlZ1RvUmFkKTtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHNoYXBlKGNvbnRleHQsIGl0ZW0pO1xuICAgIGlmIChhKSBjb250ZXh0LnJvdGF0ZSgtYSk7XG4gICAgY29udGV4dC50cmFuc2xhdGUoLXgsIC15KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgdGFnOiAncGF0aCcsXG4gICAgbmVzdGVkOiBmYWxzZSxcbiAgICBhdHRyOiBhdHRyLFxuICAgIGJvdW5kOiBib3VuZCxcbiAgICBkcmF3OiBkcmF3QWxsKGRyYXcpLFxuICAgIHBpY2s6IHBpY2tQYXRoKGRyYXcpLFxuICAgIGlzZWN0OiBpc2VjdCB8fCBpbnRlcnNlY3RQYXRoKGRyYXcpXG4gIH07XG59XG5cbnZhciBhcmMgPSBtYXJrSXRlbVBhdGgoJ2FyYycsIGFyYyQxKTtcblxuZnVuY3Rpb24gcGlja0FyZWEoYSwgcCkge1xuICB2YXIgdiA9IGFbMF0ub3JpZW50ID09PSAnaG9yaXpvbnRhbCcgPyBwWzFdIDogcFswXSxcbiAgICB6ID0gYVswXS5vcmllbnQgPT09ICdob3Jpem9udGFsJyA/ICd5JyA6ICd4JyxcbiAgICBpID0gYS5sZW5ndGgsXG4gICAgbWluID0gK0luZmluaXR5LFxuICAgIGhpdCxcbiAgICBkO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAoYVtpXS5kZWZpbmVkID09PSBmYWxzZSkgY29udGludWU7XG4gICAgZCA9IE1hdGguYWJzKGFbaV1bel0gLSB2KTtcbiAgICBpZiAoZCA8IG1pbikge1xuICAgICAgbWluID0gZDtcbiAgICAgIGhpdCA9IGFbaV07XG4gICAgfVxuICB9XG4gIHJldHVybiBoaXQ7XG59XG5mdW5jdGlvbiBwaWNrTGluZShhLCBwKSB7XG4gIHZhciB0ID0gTWF0aC5wb3coYVswXS5zdHJva2VXaWR0aCB8fCAxLCAyKSxcbiAgICBpID0gYS5sZW5ndGgsXG4gICAgZHgsXG4gICAgZHksXG4gICAgZGQ7XG4gIHdoaWxlICgtLWkgPj0gMCkge1xuICAgIGlmIChhW2ldLmRlZmluZWQgPT09IGZhbHNlKSBjb250aW51ZTtcbiAgICBkeCA9IGFbaV0ueCAtIHBbMF07XG4gICAgZHkgPSBhW2ldLnkgLSBwWzFdO1xuICAgIGRkID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgaWYgKGRkIDwgdCkgcmV0dXJuIGFbaV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwaWNrVHJhaWwoYSwgcCkge1xuICB2YXIgaSA9IGEubGVuZ3RoLFxuICAgIGR4LFxuICAgIGR5LFxuICAgIGRkO1xuICB3aGlsZSAoLS1pID49IDApIHtcbiAgICBpZiAoYVtpXS5kZWZpbmVkID09PSBmYWxzZSkgY29udGludWU7XG4gICAgZHggPSBhW2ldLnggLSBwWzBdO1xuICAgIGR5ID0gYVtpXS55IC0gcFsxXTtcbiAgICBkZCA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIGR4ID0gYVtpXS5zaXplIHx8IDE7XG4gICAgaWYgKGRkIDwgZHggKiBkeCkgcmV0dXJuIGFbaV07XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1hcmtNdWx0aUl0ZW1QYXRoICh0eXBlLCBzaGFwZSwgdGlwKSB7XG4gIGZ1bmN0aW9uIGF0dHIoZW1pdCwgaXRlbSkge1xuICAgIHZhciBpdGVtcyA9IGl0ZW0ubWFyay5pdGVtcztcbiAgICBpZiAoaXRlbXMubGVuZ3RoKSBlbWl0KCdkJywgc2hhcGUobnVsbCwgaXRlbXMpKTtcbiAgfVxuICBmdW5jdGlvbiBib3VuZChib3VuZHMsIG1hcmspIHtcbiAgICB2YXIgaXRlbXMgPSBtYXJrLml0ZW1zO1xuICAgIGlmIChpdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBib3VuZHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNoYXBlKGJvdW5kQ29udGV4dChib3VuZHMpLCBpdGVtcyk7XG4gICAgICByZXR1cm4gYm91bmRTdHJva2UoYm91bmRzLCBpdGVtc1swXSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGRyYXcoY29udGV4dCwgaXRlbXMpIHtcbiAgICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIHNoYXBlKGNvbnRleHQsIGl0ZW1zKTtcbiAgfVxuICBjb25zdCBoaXQgPSBoaXRQYXRoKGRyYXcpO1xuICBmdW5jdGlvbiBwaWNrKGNvbnRleHQsIHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICB2YXIgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICAgIGIgPSBzY2VuZS5ib3VuZHM7XG4gICAgaWYgKCFpdGVtcyB8fCAhaXRlbXMubGVuZ3RoIHx8IGIgJiYgIWIuY29udGFpbnMoZ3gsIGd5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHggKj0gY29udGV4dC5waXhlbFJhdGlvO1xuICAgIHkgKj0gY29udGV4dC5waXhlbFJhdGlvO1xuICAgIHJldHVybiBoaXQoY29udGV4dCwgaXRlbXMsIHgsIHkpID8gaXRlbXNbMF0gOiBudWxsO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0YWc6ICdwYXRoJyxcbiAgICBuZXN0ZWQ6IHRydWUsXG4gICAgYXR0cjogYXR0cixcbiAgICBib3VuZDogYm91bmQsXG4gICAgZHJhdzogZHJhd09uZShkcmF3KSxcbiAgICBwaWNrOiBwaWNrLFxuICAgIGlzZWN0OiBpbnRlcnNlY3RQb2ludCxcbiAgICB0aXA6IHRpcFxuICB9O1xufVxuXG52YXIgYXJlYSA9IG1hcmtNdWx0aUl0ZW1QYXRoKCdhcmVhJywgYXJlYSQxLCBwaWNrQXJlYSk7XG5cbmZ1bmN0aW9uIGNsaXAgKGNvbnRleHQsIHNjZW5lKSB7XG4gIHZhciBjbGlwID0gc2NlbmUuY2xpcDtcbiAgY29udGV4dC5zYXZlKCk7XG4gIGlmIChpc0Z1bmN0aW9uKGNsaXApKSB7XG4gICAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICBjbGlwKGNvbnRleHQpO1xuICAgIGNvbnRleHQuY2xpcCgpO1xuICB9IGVsc2Uge1xuICAgIGNsaXBHcm91cChjb250ZXh0LCBzY2VuZS5ncm91cCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsaXBHcm91cChjb250ZXh0LCBncm91cCkge1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICBoYXNDb3JuZXJSYWRpdXMoZ3JvdXApID8gcmVjdGFuZ2xlKGNvbnRleHQsIGdyb3VwLCAwLCAwKSA6IGNvbnRleHQucmVjdCgwLCAwLCBncm91cC53aWR0aCB8fCAwLCBncm91cC5oZWlnaHQgfHwgMCk7XG4gIGNvbnRleHQuY2xpcCgpO1xufVxuXG5mdW5jdGlvbiBvZmZzZXQkMShpdGVtKSB7XG4gIGNvbnN0IHN3ID0gdmFsdWUoaXRlbS5zdHJva2VXaWR0aCwgMSk7XG4gIHJldHVybiBpdGVtLnN0cm9rZU9mZnNldCAhPSBudWxsID8gaXRlbS5zdHJva2VPZmZzZXQgOiBpdGVtLnN0cm9rZSAmJiBzdyA+IDAuNSAmJiBzdyA8IDEuNSA/IDAuNSAtIE1hdGguYWJzKHN3IC0gMSkgOiAwO1xufVxuZnVuY3Rpb24gYXR0ciQ1KGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlSXRlbShpdGVtKSk7XG59XG5mdW5jdGlvbiBlbWl0UmVjdGFuZ2xlKGVtaXQsIGl0ZW0pIHtcbiAgY29uc3Qgb2ZmID0gb2Zmc2V0JDEoaXRlbSk7XG4gIGVtaXQoJ2QnLCByZWN0YW5nbGUobnVsbCwgaXRlbSwgb2ZmLCBvZmYpKTtcbn1cbmZ1bmN0aW9uIGJhY2tncm91bmQoZW1pdCwgaXRlbSkge1xuICBlbWl0KCdjbGFzcycsICdiYWNrZ3JvdW5kJyk7XG4gIGVtaXQoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XG4gIGVtaXRSZWN0YW5nbGUoZW1pdCwgaXRlbSk7XG59XG5mdW5jdGlvbiBmb3JlZ3JvdW5kKGVtaXQsIGl0ZW0pIHtcbiAgZW1pdCgnY2xhc3MnLCAnZm9yZWdyb3VuZCcpO1xuICBlbWl0KCdhcmlhLWhpZGRlbicsIHRydWUpO1xuICBpZiAoaXRlbS5zdHJva2VGb3JlZ3JvdW5kKSB7XG4gICAgZW1pdFJlY3RhbmdsZShlbWl0LCBpdGVtKTtcbiAgfSBlbHNlIHtcbiAgICBlbWl0KCdkJywgJycpO1xuICB9XG59XG5mdW5jdGlvbiBjb250ZW50KGVtaXQsIGl0ZW0sIHJlbmRlcmVyKSB7XG4gIGNvbnN0IHVybCA9IGl0ZW0uY2xpcCA/IGNsaXAkMShyZW5kZXJlciwgaXRlbSwgaXRlbSkgOiBudWxsO1xuICBlbWl0KCdjbGlwLXBhdGgnLCB1cmwpO1xufVxuZnVuY3Rpb24gYm91bmQkNShib3VuZHMsIGdyb3VwKSB7XG4gIGlmICghZ3JvdXAuY2xpcCAmJiBncm91cC5pdGVtcykge1xuICAgIGNvbnN0IGl0ZW1zID0gZ3JvdXAuaXRlbXMsXG4gICAgICBtID0gaXRlbXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICBib3VuZHMudW5pb24oaXRlbXNbal0uYm91bmRzKTtcbiAgICB9XG4gIH1cbiAgaWYgKChncm91cC5jbGlwIHx8IGdyb3VwLndpZHRoIHx8IGdyb3VwLmhlaWdodCkgJiYgIWdyb3VwLm5vQm91bmQpIHtcbiAgICBib3VuZHMuYWRkKDAsIDApLmFkZChncm91cC53aWR0aCB8fCAwLCBncm91cC5oZWlnaHQgfHwgMCk7XG4gIH1cbiAgYm91bmRTdHJva2UoYm91bmRzLCBncm91cCk7XG4gIHJldHVybiBib3VuZHMudHJhbnNsYXRlKGdyb3VwLnggfHwgMCwgZ3JvdXAueSB8fCAwKTtcbn1cbmZ1bmN0aW9uIHJlY3RhbmdsZVBhdGgoY29udGV4dCwgZ3JvdXAsIHgsIHkpIHtcbiAgY29uc3Qgb2ZmID0gb2Zmc2V0JDEoZ3JvdXApO1xuICBjb250ZXh0LmJlZ2luUGF0aCgpO1xuICByZWN0YW5nbGUoY29udGV4dCwgZ3JvdXAsICh4IHx8IDApICsgb2ZmLCAoeSB8fCAwKSArIG9mZik7XG59XG5jb25zdCBoaXRCYWNrZ3JvdW5kID0gaGl0UGF0aChyZWN0YW5nbGVQYXRoKTtcbmNvbnN0IGhpdEZvcmVncm91bmQgPSBoaXRQYXRoKHJlY3RhbmdsZVBhdGgsIGZhbHNlKTtcbmNvbnN0IGhpdENvcm5lciA9IGhpdFBhdGgocmVjdGFuZ2xlUGF0aCwgdHJ1ZSk7XG5mdW5jdGlvbiBkcmF3JDQoY29udGV4dCwgc2NlbmUsIGJvdW5kcywgbWFya1R5cGVzKSB7XG4gIHZpc2l0KHNjZW5lLCBncm91cCA9PiB7XG4gICAgY29uc3QgZ3ggPSBncm91cC54IHx8IDAsXG4gICAgICBneSA9IGdyb3VwLnkgfHwgMCxcbiAgICAgIGZvcmUgPSBncm91cC5zdHJva2VGb3JlZ3JvdW5kLFxuICAgICAgb3BhY2l0eSA9IGdyb3VwLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBncm91cC5vcGFjaXR5O1xuXG4gICAgLy8gZHJhdyBncm91cCBiYWNrZ3JvdW5kXG4gICAgaWYgKChncm91cC5zdHJva2UgfHwgZ3JvdXAuZmlsbCkgJiYgb3BhY2l0eSkge1xuICAgICAgcmVjdGFuZ2xlUGF0aChjb250ZXh0LCBncm91cCwgZ3gsIGd5KTtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGdyb3VwKTtcbiAgICAgIGlmIChncm91cC5maWxsICYmIGZpbGwoY29udGV4dCwgZ3JvdXAsIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKGdyb3VwLnN0cm9rZSAmJiAhZm9yZSAmJiBzdHJva2UoY29udGV4dCwgZ3JvdXAsIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gc2V0dXAgZ3JhcGhpY3MgY29udGV4dCwgc2V0IGNsaXAgYW5kIGJvdW5kc1xuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgaWYgKGdyb3VwLmNsaXApIGNsaXBHcm91cChjb250ZXh0LCBncm91cCk7XG4gICAgaWYgKGJvdW5kcykgYm91bmRzLnRyYW5zbGF0ZSgtZ3gsIC1neSk7XG5cbiAgICAvLyBkcmF3IGdyb3VwIGNvbnRlbnRzXG4gICAgdmlzaXQoZ3JvdXAsIGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0ubWFya3R5cGUgPT09ICdncm91cCcgfHwgbWFya1R5cGVzID09IG51bGwgfHwgbWFya1R5cGVzLmluY2x1ZGVzKGl0ZW0ubWFya3R5cGUpKSB7XG4gICAgICAgIHRoaXMuZHJhdyhjb250ZXh0LCBpdGVtLCBib3VuZHMsIG1hcmtUeXBlcyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZXN0b3JlIGdyYXBoaWNzIGNvbnRleHRcbiAgICBpZiAoYm91bmRzKSBib3VuZHMudHJhbnNsYXRlKGd4LCBneSk7XG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG5cbiAgICAvLyBkcmF3IGdyb3VwIGZvcmVncm91bmRcbiAgICBpZiAoZm9yZSAmJiBncm91cC5zdHJva2UgJiYgb3BhY2l0eSkge1xuICAgICAgcmVjdGFuZ2xlUGF0aChjb250ZXh0LCBncm91cCwgZ3gsIGd5KTtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGdyb3VwKTtcbiAgICAgIGlmIChzdHJva2UoY29udGV4dCwgZ3JvdXAsIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHBpY2soY29udGV4dCwgc2NlbmUsIHgsIHksIGd4LCBneSkge1xuICBpZiAoc2NlbmUuYm91bmRzICYmICFzY2VuZS5ib3VuZHMuY29udGFpbnMoZ3gsIGd5KSB8fCAhc2NlbmUuaXRlbXMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjeCA9IHggKiBjb250ZXh0LnBpeGVsUmF0aW8sXG4gICAgY3kgPSB5ICogY29udGV4dC5waXhlbFJhdGlvO1xuICByZXR1cm4gcGlja1Zpc2l0KHNjZW5lLCBncm91cCA9PiB7XG4gICAgbGV0IGhpdCwgZHgsIGR5O1xuXG4gICAgLy8gZmlyc3QgaGl0IHRlc3QgYm91bmRpbmcgYm94XG4gICAgY29uc3QgYiA9IGdyb3VwLmJvdW5kcztcbiAgICBpZiAoYiAmJiAhYi5jb250YWlucyhneCwgZ3kpKSByZXR1cm47XG5cbiAgICAvLyBwYXNzZWQgYm91bmRzIGNoZWNrLCB0ZXN0IHJlY3Rhbmd1bGFyIGNsaXBcbiAgICBkeCA9IGdyb3VwLnggfHwgMDtcbiAgICBkeSA9IGdyb3VwLnkgfHwgMDtcbiAgICBjb25zdCBkdyA9IGR4ICsgKGdyb3VwLndpZHRoIHx8IDApLFxuICAgICAgZGggPSBkeSArIChncm91cC5oZWlnaHQgfHwgMCksXG4gICAgICBjID0gZ3JvdXAuY2xpcDtcbiAgICBpZiAoYyAmJiAoZ3ggPCBkeCB8fCBneCA+IGR3IHx8IGd5IDwgZHkgfHwgZ3kgPiBkaCkpIHJldHVybjtcblxuICAgIC8vIGFkanVzdCBjb29yZGluYXRlIHN5c3RlbVxuICAgIGNvbnRleHQuc2F2ZSgpO1xuICAgIGNvbnRleHQudHJhbnNsYXRlKGR4LCBkeSk7XG4gICAgZHggPSBneCAtIGR4O1xuICAgIGR5ID0gZ3kgLSBkeTtcblxuICAgIC8vIHRlc3QgYmFja2dyb3VuZCBmb3Igcm91bmRlZCBjb3JuZXIgY2xpcFxuICAgIGlmIChjICYmIGhhc0Nvcm5lclJhZGl1cyhncm91cCkgJiYgIWhpdENvcm5lcihjb250ZXh0LCBncm91cCwgY3gsIGN5KSkge1xuICAgICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZm9yZSA9IGdyb3VwLnN0cm9rZUZvcmVncm91bmQsXG4gICAgICBpeCA9IHNjZW5lLmludGVyYWN0aXZlICE9PSBmYWxzZTtcblxuICAgIC8vIGhpdCB0ZXN0IGFnYWluc3QgZ3JvdXAgZm9yZWdyb3VuZFxuICAgIGlmIChpeCAmJiBmb3JlICYmIGdyb3VwLnN0cm9rZSAmJiBoaXRGb3JlZ3JvdW5kKGNvbnRleHQsIGdyb3VwLCBjeCwgY3kpKSB7XG4gICAgICBjb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiBncm91cDtcbiAgICB9XG5cbiAgICAvLyBoaXQgdGVzdCBhZ2FpbnN0IGNvbnRhaW5lZCBtYXJrc1xuICAgIGhpdCA9IHBpY2tWaXNpdChncm91cCwgbWFyayA9PiBwaWNrTWFyayhtYXJrLCBkeCwgZHkpID8gdGhpcy5waWNrKG1hcmssIHgsIHksIGR4LCBkeSkgOiBudWxsKTtcblxuICAgIC8vIGhpdCB0ZXN0IGFnYWluc3QgZ3JvdXAgYmFja2dyb3VuZFxuICAgIGlmICghaGl0ICYmIGl4ICYmIChncm91cC5maWxsIHx8ICFmb3JlICYmIGdyb3VwLnN0cm9rZSkgJiYgaGl0QmFja2dyb3VuZChjb250ZXh0LCBncm91cCwgY3gsIGN5KSkge1xuICAgICAgaGl0ID0gZ3JvdXA7XG4gICAgfVxuXG4gICAgLy8gcmVzdG9yZSBzdGF0ZSBhbmQgcmV0dXJuXG4gICAgY29udGV4dC5yZXN0b3JlKCk7XG4gICAgcmV0dXJuIGhpdCB8fCBudWxsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHBpY2tNYXJrKG1hcmssIHgsIHkpIHtcbiAgcmV0dXJuIChtYXJrLmludGVyYWN0aXZlICE9PSBmYWxzZSB8fCBtYXJrLm1hcmt0eXBlID09PSAnZ3JvdXAnKSAmJiBtYXJrLmJvdW5kcyAmJiBtYXJrLmJvdW5kcy5jb250YWlucyh4LCB5KTtcbn1cbnZhciBncm91cCA9IHtcbiAgdHlwZTogJ2dyb3VwJyxcbiAgdGFnOiAnZycsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkNSxcbiAgYm91bmQ6IGJvdW5kJDUsXG4gIGRyYXc6IGRyYXckNCxcbiAgcGljazogcGljayxcbiAgaXNlY3Q6IGludGVyc2VjdFJlY3QsXG4gIGNvbnRlbnQ6IGNvbnRlbnQsXG4gIGJhY2tncm91bmQ6IGJhY2tncm91bmQsXG4gIGZvcmVncm91bmQ6IGZvcmVncm91bmRcbn07XG5cbnZhciBtZXRhZGF0YSA9IHtcbiAgJ3htbG5zJzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgJ3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICAndmVyc2lvbic6ICcxLjEnXG59O1xuXG5mdW5jdGlvbiBnZXRJbWFnZShpdGVtLCByZW5kZXJlcikge1xuICB2YXIgaW1hZ2UgPSBpdGVtLmltYWdlO1xuICBpZiAoIWltYWdlIHx8IGl0ZW0udXJsICYmIGl0ZW0udXJsICE9PSBpbWFnZS51cmwpIHtcbiAgICBpbWFnZSA9IHtcbiAgICAgIGNvbXBsZXRlOiBmYWxzZSxcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwXG4gICAgfTtcbiAgICByZW5kZXJlci5sb2FkSW1hZ2UoaXRlbS51cmwpLnRoZW4oaW1hZ2UgPT4ge1xuICAgICAgaXRlbS5pbWFnZSA9IGltYWdlO1xuICAgICAgaXRlbS5pbWFnZS51cmwgPSBpdGVtLnVybDtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaW1hZ2U7XG59XG5mdW5jdGlvbiBpbWFnZVdpZHRoKGl0ZW0sIGltYWdlKSB7XG4gIHJldHVybiBpdGVtLndpZHRoICE9IG51bGwgPyBpdGVtLndpZHRoIDogIWltYWdlIHx8ICFpbWFnZS53aWR0aCA/IDAgOiBpdGVtLmFzcGVjdCAhPT0gZmFsc2UgJiYgaXRlbS5oZWlnaHQgPyBpdGVtLmhlaWdodCAqIGltYWdlLndpZHRoIC8gaW1hZ2UuaGVpZ2h0IDogaW1hZ2Uud2lkdGg7XG59XG5mdW5jdGlvbiBpbWFnZUhlaWdodChpdGVtLCBpbWFnZSkge1xuICByZXR1cm4gaXRlbS5oZWlnaHQgIT0gbnVsbCA/IGl0ZW0uaGVpZ2h0IDogIWltYWdlIHx8ICFpbWFnZS5oZWlnaHQgPyAwIDogaXRlbS5hc3BlY3QgIT09IGZhbHNlICYmIGl0ZW0ud2lkdGggPyBpdGVtLndpZHRoICogaW1hZ2UuaGVpZ2h0IC8gaW1hZ2Uud2lkdGggOiBpbWFnZS5oZWlnaHQ7XG59XG5mdW5jdGlvbiBpbWFnZVhPZmZzZXQoYWxpZ24sIHcpIHtcbiAgcmV0dXJuIGFsaWduID09PSAnY2VudGVyJyA/IHcgLyAyIDogYWxpZ24gPT09ICdyaWdodCcgPyB3IDogMDtcbn1cbmZ1bmN0aW9uIGltYWdlWU9mZnNldChiYXNlbGluZSwgaCkge1xuICByZXR1cm4gYmFzZWxpbmUgPT09ICdtaWRkbGUnID8gaCAvIDIgOiBiYXNlbGluZSA9PT0gJ2JvdHRvbScgPyBoIDogMDtcbn1cbmZ1bmN0aW9uIGF0dHIkNChlbWl0LCBpdGVtLCByZW5kZXJlcikge1xuICBjb25zdCBpbWcgPSBnZXRJbWFnZShpdGVtLCByZW5kZXJlciksXG4gICAgdyA9IGltYWdlV2lkdGgoaXRlbSwgaW1nKSxcbiAgICBoID0gaW1hZ2VIZWlnaHQoaXRlbSwgaW1nKSxcbiAgICB4ID0gKGl0ZW0ueCB8fCAwKSAtIGltYWdlWE9mZnNldChpdGVtLmFsaWduLCB3KSxcbiAgICB5ID0gKGl0ZW0ueSB8fCAwKSAtIGltYWdlWU9mZnNldChpdGVtLmJhc2VsaW5lLCBoKSxcbiAgICBpID0gIWltZy5zcmMgJiYgaW1nLnRvRGF0YVVSTCA/IGltZy50b0RhdGFVUkwoKSA6IGltZy5zcmMgfHwgJyc7XG4gIGVtaXQoJ2hyZWYnLCBpLCBtZXRhZGF0YVsneG1sbnM6eGxpbmsnXSwgJ3hsaW5rOmhyZWYnKTtcbiAgZW1pdCgndHJhbnNmb3JtJywgdHJhbnNsYXRlKHgsIHkpKTtcbiAgZW1pdCgnd2lkdGgnLCB3KTtcbiAgZW1pdCgnaGVpZ2h0JywgaCk7XG4gIGVtaXQoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nLCBpdGVtLmFzcGVjdCA9PT0gZmFsc2UgPyAnbm9uZScgOiAneE1pZFlNaWQnKTtcbn1cbmZ1bmN0aW9uIGJvdW5kJDQoYm91bmRzLCBpdGVtKSB7XG4gIGNvbnN0IGltZyA9IGl0ZW0uaW1hZ2UsXG4gICAgdyA9IGltYWdlV2lkdGgoaXRlbSwgaW1nKSxcbiAgICBoID0gaW1hZ2VIZWlnaHQoaXRlbSwgaW1nKSxcbiAgICB4ID0gKGl0ZW0ueCB8fCAwKSAtIGltYWdlWE9mZnNldChpdGVtLmFsaWduLCB3KSxcbiAgICB5ID0gKGl0ZW0ueSB8fCAwKSAtIGltYWdlWU9mZnNldChpdGVtLmJhc2VsaW5lLCBoKTtcbiAgcmV0dXJuIGJvdW5kcy5zZXQoeCwgeSwgeCArIHcsIHkgKyBoKTtcbn1cbmZ1bmN0aW9uIGRyYXckMyhjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpIHJldHVybjsgLy8gYm91bmRzIGNoZWNrXG5cbiAgICBjb25zdCBpbWcgPSBnZXRJbWFnZShpdGVtLCB0aGlzKTtcbiAgICBsZXQgdyA9IGltYWdlV2lkdGgoaXRlbSwgaW1nKTtcbiAgICBsZXQgaCA9IGltYWdlSGVpZ2h0KGl0ZW0sIGltZyk7XG4gICAgaWYgKHcgPT09IDAgfHwgaCA9PT0gMCkgcmV0dXJuOyAvLyBlYXJseSBleGl0XG5cbiAgICBsZXQgeCA9IChpdGVtLnggfHwgMCkgLSBpbWFnZVhPZmZzZXQoaXRlbS5hbGlnbiwgdyksXG4gICAgICB5ID0gKGl0ZW0ueSB8fCAwKSAtIGltYWdlWU9mZnNldChpdGVtLmJhc2VsaW5lLCBoKSxcbiAgICAgIG9wYWNpdHksXG4gICAgICBhcjAsXG4gICAgICBhcjEsXG4gICAgICB0O1xuICAgIGlmIChpdGVtLmFzcGVjdCAhPT0gZmFsc2UpIHtcbiAgICAgIGFyMCA9IGltZy53aWR0aCAvIGltZy5oZWlnaHQ7XG4gICAgICBhcjEgPSBpdGVtLndpZHRoIC8gaXRlbS5oZWlnaHQ7XG4gICAgICBpZiAoYXIwID09PSBhcjAgJiYgYXIxID09PSBhcjEgJiYgYXIwICE9PSBhcjEpIHtcbiAgICAgICAgaWYgKGFyMSA8IGFyMCkge1xuICAgICAgICAgIHQgPSB3IC8gYXIwO1xuICAgICAgICAgIHkgKz0gKGggLSB0KSAvIDI7XG4gICAgICAgICAgaCA9IHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdCA9IGggKiBhcjA7XG4gICAgICAgICAgeCArPSAodyAtIHQpIC8gMjtcbiAgICAgICAgICB3ID0gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW1nLmNvbXBsZXRlIHx8IGltZy50b0RhdGFVUkwpIHtcbiAgICAgIGJsZW5kKGNvbnRleHQsIGl0ZW0pO1xuICAgICAgY29udGV4dC5nbG9iYWxBbHBoYSA9IChvcGFjaXR5ID0gaXRlbS5vcGFjaXR5KSAhPSBudWxsID8gb3BhY2l0eSA6IDE7XG4gICAgICBjb250ZXh0LmltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGl0ZW0uc21vb3RoICE9PSBmYWxzZTtcbiAgICAgIGNvbnRleHQuZHJhd0ltYWdlKGltZywgeCwgeSwgdywgaCk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBpbWFnZSA9IHtcbiAgdHlwZTogJ2ltYWdlJyxcbiAgdGFnOiAnaW1hZ2UnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDQsXG4gIGJvdW5kOiBib3VuZCQ0LFxuICBkcmF3OiBkcmF3JDMsXG4gIHBpY2s6IHBpY2skMSgpLFxuICBpc2VjdDogdHJ1dGh5LFxuICAvLyBib3VuZHMgY2hlY2sgaXMgc3VmZmljaWVudFxuICBnZXQ6IGdldEltYWdlLFxuICB4T2Zmc2V0OiBpbWFnZVhPZmZzZXQsXG4gIHlPZmZzZXQ6IGltYWdlWU9mZnNldFxufTtcblxudmFyIGxpbmUgPSBtYXJrTXVsdGlJdGVtUGF0aCgnbGluZScsIGxpbmUkMSwgcGlja0xpbmUpO1xuXG5mdW5jdGlvbiBhdHRyJDMoZW1pdCwgaXRlbSkge1xuICB2YXIgc3ggPSBpdGVtLnNjYWxlWCB8fCAxLFxuICAgIHN5ID0gaXRlbS5zY2FsZVkgfHwgMTtcbiAgaWYgKHN4ICE9PSAxIHx8IHN5ICE9PSAxKSB7XG4gICAgZW1pdCgndmVjdG9yLWVmZmVjdCcsICdub24tc2NhbGluZy1zdHJva2UnKTtcbiAgfVxuICBlbWl0KCd0cmFuc2Zvcm0nLCB0cmFuc2Zvcm1JdGVtKGl0ZW0pKTtcbiAgZW1pdCgnZCcsIGl0ZW0ucGF0aCk7XG59XG5mdW5jdGlvbiBwYXRoJDEoY29udGV4dCwgaXRlbSkge1xuICB2YXIgcGF0aCA9IGl0ZW0ucGF0aDtcbiAgaWYgKHBhdGggPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gIHZhciB4ID0gaXRlbS54IHx8IDAsXG4gICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgIHN4ID0gaXRlbS5zY2FsZVggfHwgMSxcbiAgICBzeSA9IGl0ZW0uc2NhbGVZIHx8IDEsXG4gICAgYSA9IChpdGVtLmFuZ2xlIHx8IDApICogRGVnVG9SYWQsXG4gICAgY2FjaGUgPSBpdGVtLnBhdGhDYWNoZTtcbiAgaWYgKCFjYWNoZSB8fCBjYWNoZS5wYXRoICE9PSBwYXRoKSB7XG4gICAgKGl0ZW0ucGF0aENhY2hlID0gY2FjaGUgPSBwYXJzZShwYXRoKSkucGF0aCA9IHBhdGg7XG4gIH1cbiAgaWYgKGEgJiYgY29udGV4dC5yb3RhdGUgJiYgY29udGV4dC50cmFuc2xhdGUpIHtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSh4LCB5KTtcbiAgICBjb250ZXh0LnJvdGF0ZShhKTtcbiAgICBwYXRoUmVuZGVyKGNvbnRleHQsIGNhY2hlLCAwLCAwLCBzeCwgc3kpO1xuICAgIGNvbnRleHQucm90YXRlKC1hKTtcbiAgICBjb250ZXh0LnRyYW5zbGF0ZSgteCwgLXkpO1xuICB9IGVsc2Uge1xuICAgIHBhdGhSZW5kZXIoY29udGV4dCwgY2FjaGUsIHgsIHksIHN4LCBzeSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGJvdW5kJDMoYm91bmRzLCBpdGVtKSB7XG4gIHJldHVybiBwYXRoJDEoYm91bmRDb250ZXh0KGJvdW5kcywgaXRlbS5hbmdsZSksIGl0ZW0pID8gYm91bmRzLnNldCgwLCAwLCAwLCAwKSA6IGJvdW5kU3Ryb2tlKGJvdW5kcywgaXRlbSwgdHJ1ZSk7XG59XG52YXIgcGF0aCQyID0ge1xuICB0eXBlOiAncGF0aCcsXG4gIHRhZzogJ3BhdGgnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyJDMsXG4gIGJvdW5kOiBib3VuZCQzLFxuICBkcmF3OiBkcmF3QWxsKHBhdGgkMSksXG4gIHBpY2s6IHBpY2tQYXRoKHBhdGgkMSksXG4gIGlzZWN0OiBpbnRlcnNlY3RQYXRoKHBhdGgkMSlcbn07XG5cbmZ1bmN0aW9uIGF0dHIkMihlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ2QnLCByZWN0YW5nbGUobnVsbCwgaXRlbSkpO1xufVxuZnVuY3Rpb24gYm91bmQkMihib3VuZHMsIGl0ZW0pIHtcbiAgdmFyIHgsIHk7XG4gIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMuc2V0KHggPSBpdGVtLnggfHwgMCwgeSA9IGl0ZW0ueSB8fCAwLCB4ICsgaXRlbS53aWR0aCB8fCAwLCB5ICsgaXRlbS5oZWlnaHQgfHwgMCksIGl0ZW0pO1xufVxuZnVuY3Rpb24gZHJhdyQyKGNvbnRleHQsIGl0ZW0pIHtcbiAgY29udGV4dC5iZWdpblBhdGgoKTtcbiAgcmVjdGFuZ2xlKGNvbnRleHQsIGl0ZW0pO1xufVxudmFyIHJlY3QgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgdGFnOiAncGF0aCcsXG4gIG5lc3RlZDogZmFsc2UsXG4gIGF0dHI6IGF0dHIkMixcbiAgYm91bmQ6IGJvdW5kJDIsXG4gIGRyYXc6IGRyYXdBbGwoZHJhdyQyKSxcbiAgcGljazogcGlja1BhdGgoZHJhdyQyKSxcbiAgaXNlY3Q6IGludGVyc2VjdFJlY3Rcbn07XG5cbmZ1bmN0aW9uIGF0dHIkMShlbWl0LCBpdGVtKSB7XG4gIGVtaXQoJ3RyYW5zZm9ybScsIHRyYW5zbGF0ZUl0ZW0oaXRlbSkpO1xuICBlbWl0KCd4MicsIGl0ZW0ueDIgIT0gbnVsbCA/IGl0ZW0ueDIgLSAoaXRlbS54IHx8IDApIDogMCk7XG4gIGVtaXQoJ3kyJywgaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiAtIChpdGVtLnkgfHwgMCkgOiAwKTtcbn1cbmZ1bmN0aW9uIGJvdW5kJDEoYm91bmRzLCBpdGVtKSB7XG4gIHZhciB4MSwgeTE7XG4gIHJldHVybiBib3VuZFN0cm9rZShib3VuZHMuc2V0KHgxID0gaXRlbS54IHx8IDAsIHkxID0gaXRlbS55IHx8IDAsIGl0ZW0ueDIgIT0gbnVsbCA/IGl0ZW0ueDIgOiB4MSwgaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiA6IHkxKSwgaXRlbSk7XG59XG5mdW5jdGlvbiBwYXRoKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpIHtcbiAgdmFyIHgxLCB5MSwgeDIsIHkyO1xuICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgeDEgPSBpdGVtLnggfHwgMDtcbiAgICB5MSA9IGl0ZW0ueSB8fCAwO1xuICAgIHgyID0gaXRlbS54MiAhPSBudWxsID8gaXRlbS54MiA6IHgxO1xuICAgIHkyID0gaXRlbS55MiAhPSBudWxsID8gaXRlbS55MiA6IHkxO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5tb3ZlVG8oeDEsIHkxKTtcbiAgICBjb250ZXh0LmxpbmVUbyh4MiwgeTIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGRyYXckMShjb250ZXh0LCBzY2VuZSwgYm91bmRzKSB7XG4gIHZpc2l0KHNjZW5lLCBpdGVtID0+IHtcbiAgICBpZiAoYm91bmRzICYmICFib3VuZHMuaW50ZXJzZWN0cyhpdGVtLmJvdW5kcykpIHJldHVybjsgLy8gYm91bmRzIGNoZWNrXG4gICAgdmFyIG9wYWNpdHkgPSBpdGVtLm9wYWNpdHkgPT0gbnVsbCA/IDEgOiBpdGVtLm9wYWNpdHk7XG4gICAgaWYgKG9wYWNpdHkgJiYgcGF0aChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgYmxlbmQoY29udGV4dCwgaXRlbSk7XG4gICAgICBjb250ZXh0LnN0cm9rZSgpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBoaXQkMShjb250ZXh0LCBpdGVtLCB4LCB5KSB7XG4gIGlmICghY29udGV4dC5pc1BvaW50SW5TdHJva2UpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHBhdGgoY29udGV4dCwgaXRlbSwgMSkgJiYgY29udGV4dC5pc1BvaW50SW5TdHJva2UoeCwgeSk7XG59XG52YXIgcnVsZSA9IHtcbiAgdHlwZTogJ3J1bGUnLFxuICB0YWc6ICdsaW5lJyxcbiAgbmVzdGVkOiBmYWxzZSxcbiAgYXR0cjogYXR0ciQxLFxuICBib3VuZDogYm91bmQkMSxcbiAgZHJhdzogZHJhdyQxLFxuICBwaWNrOiBwaWNrJDEoaGl0JDEpLFxuICBpc2VjdDogaW50ZXJzZWN0UnVsZVxufTtcblxudmFyIHNoYXBlID0gbWFya0l0ZW1QYXRoKCdzaGFwZScsIHNoYXBlJDEpO1xuXG52YXIgc3ltYm9sID0gbWFya0l0ZW1QYXRoKCdzeW1ib2wnLCBzeW1ib2wkMSwgaW50ZXJzZWN0UG9pbnQpO1xuXG4vLyBtZW1vaXplIHRleHQgd2lkdGggbWVhc3VyZW1lbnRcbmNvbnN0IHdpZHRoQ2FjaGUgPSBscnVDYWNoZSgpO1xudmFyIHRleHRNZXRyaWNzID0ge1xuICBoZWlnaHQ6IGZvbnRTaXplLFxuICBtZWFzdXJlV2lkdGg6IG1lYXN1cmVXaWR0aCxcbiAgZXN0aW1hdGVXaWR0aDogZXN0aW1hdGVXaWR0aCxcbiAgd2lkdGg6IGVzdGltYXRlV2lkdGgsXG4gIGNhbnZhczogdXNlQ2FudmFzXG59O1xudXNlQ2FudmFzKHRydWUpO1xuZnVuY3Rpb24gdXNlQ2FudmFzKHVzZSkge1xuICB0ZXh0TWV0cmljcy53aWR0aCA9IHVzZSAmJiBjb250ZXh0ID8gbWVhc3VyZVdpZHRoIDogZXN0aW1hdGVXaWR0aDtcbn1cblxuLy8gbWFrZSBzaW1wbGUgZXN0aW1hdGUgaWYgbm8gY2FudmFzIGlzIGF2YWlsYWJsZVxuZnVuY3Rpb24gZXN0aW1hdGVXaWR0aChpdGVtLCB0ZXh0KSB7XG4gIHJldHVybiBfZXN0aW1hdGVXaWR0aCh0ZXh0VmFsdWUoaXRlbSwgdGV4dCksIGZvbnRTaXplKGl0ZW0pKTtcbn1cbmZ1bmN0aW9uIF9lc3RpbWF0ZVdpZHRoKHRleHQsIGN1cnJlbnRGb250SGVpZ2h0KSB7XG4gIHJldHVybiB+figwLjggKiB0ZXh0Lmxlbmd0aCAqIGN1cnJlbnRGb250SGVpZ2h0KTtcbn1cblxuLy8gbWVhc3VyZSB0ZXh0IHdpZHRoIGlmIGNhbnZhcyBpcyBhdmFpbGFibGVcbmZ1bmN0aW9uIG1lYXN1cmVXaWR0aChpdGVtLCB0ZXh0KSB7XG4gIHJldHVybiBmb250U2l6ZShpdGVtKSA8PSAwIHx8ICEodGV4dCA9IHRleHRWYWx1ZShpdGVtLCB0ZXh0KSkgPyAwIDogX21lYXN1cmVXaWR0aCh0ZXh0LCBmb250KGl0ZW0pKTtcbn1cbmZ1bmN0aW9uIF9tZWFzdXJlV2lkdGgodGV4dCwgY3VycmVudEZvbnQpIHtcbiAgY29uc3Qga2V5ID0gYCgke2N1cnJlbnRGb250fSkgJHt0ZXh0fWA7XG4gIGxldCB3aWR0aCA9IHdpZHRoQ2FjaGUuZ2V0KGtleSk7XG4gIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY29udGV4dC5mb250ID0gY3VycmVudEZvbnQ7XG4gICAgd2lkdGggPSBjb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgIHdpZHRoQ2FjaGUuc2V0KGtleSwgd2lkdGgpO1xuICB9XG4gIHJldHVybiB3aWR0aDtcbn1cbmZ1bmN0aW9uIGZvbnRTaXplKGl0ZW0pIHtcbiAgcmV0dXJuIGl0ZW0uZm9udFNpemUgIT0gbnVsbCA/ICtpdGVtLmZvbnRTaXplIHx8IDAgOiAxMTtcbn1cbmZ1bmN0aW9uIGxpbmVIZWlnaHQoaXRlbSkge1xuICByZXR1cm4gaXRlbS5saW5lSGVpZ2h0ICE9IG51bGwgPyBpdGVtLmxpbmVIZWlnaHQgOiBmb250U2l6ZShpdGVtKSArIDI7XG59XG5mdW5jdGlvbiBsaW5lQXJyYXkoXykge1xuICByZXR1cm4gaXNBcnJheShfKSA/IF8ubGVuZ3RoID4gMSA/IF8gOiBfWzBdIDogXztcbn1cbmZ1bmN0aW9uIHRleHRMaW5lcyhpdGVtKSB7XG4gIHJldHVybiBsaW5lQXJyYXkoaXRlbS5saW5lQnJlYWsgJiYgaXRlbS50ZXh0ICYmICFpc0FycmF5KGl0ZW0udGV4dCkgPyBpdGVtLnRleHQuc3BsaXQoaXRlbS5saW5lQnJlYWspIDogaXRlbS50ZXh0KTtcbn1cbmZ1bmN0aW9uIG11bHRpTGluZU9mZnNldChpdGVtKSB7XG4gIGNvbnN0IHRsID0gdGV4dExpbmVzKGl0ZW0pO1xuICByZXR1cm4gKGlzQXJyYXkodGwpID8gdGwubGVuZ3RoIC0gMSA6IDApICogbGluZUhlaWdodChpdGVtKTtcbn1cbmZ1bmN0aW9uIHRleHRWYWx1ZShpdGVtLCBsaW5lKSB7XG4gIGNvbnN0IHRleHQgPSBsaW5lID09IG51bGwgPyAnJyA6IChsaW5lICsgJycpLnRyaW0oKTtcbiAgcmV0dXJuIGl0ZW0ubGltaXQgPiAwICYmIHRleHQubGVuZ3RoID8gdHJ1bmNhdGUoaXRlbSwgdGV4dCkgOiB0ZXh0O1xufVxuZnVuY3Rpb24gd2lkdGhHZXR0ZXIoaXRlbSkge1xuICBpZiAodGV4dE1ldHJpY3Mud2lkdGggPT09IG1lYXN1cmVXaWR0aCkge1xuICAgIC8vIHdlIGFyZSB1c2luZyBjYW52YXNcbiAgICBjb25zdCBjdXJyZW50Rm9udCA9IGZvbnQoaXRlbSk7XG4gICAgcmV0dXJuIHRleHQgPT4gX21lYXN1cmVXaWR0aCh0ZXh0LCBjdXJyZW50Rm9udCk7XG4gIH0gZWxzZSBpZiAodGV4dE1ldHJpY3Mud2lkdGggPT09IGVzdGltYXRlV2lkdGgpIHtcbiAgICAvLyB3ZSBhcmUgcmVseWluZyBvbiBlc3RpbWF0ZXNcbiAgICBjb25zdCBjdXJyZW50Rm9udEhlaWdodCA9IGZvbnRTaXplKGl0ZW0pO1xuICAgIHJldHVybiB0ZXh0ID0+IF9lc3RpbWF0ZVdpZHRoKHRleHQsIGN1cnJlbnRGb250SGVpZ2h0KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBVc2VyIGRlZmluZWQgdGV4dE1ldHJpY3Mud2lkdGggZnVuY3Rpb24gaW4gdXNlIChlLmcuIHZsLWNvbnZlcnQpXG4gICAgcmV0dXJuIHRleHQgPT4gdGV4dE1ldHJpY3Mud2lkdGgoaXRlbSwgdGV4dCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHRydW5jYXRlKGl0ZW0sIHRleHQpIHtcbiAgdmFyIGxpbWl0ID0gK2l0ZW0ubGltaXQsXG4gICAgd2lkdGggPSB3aWR0aEdldHRlcihpdGVtKTtcbiAgaWYgKHdpZHRoKHRleHQpIDwgbGltaXQpIHJldHVybiB0ZXh0O1xuICB2YXIgZWxsaXBzaXMgPSBpdGVtLmVsbGlwc2lzIHx8ICdcXHUyMDI2JyxcbiAgICBydGwgPSBpdGVtLmRpciA9PT0gJ3J0bCcsXG4gICAgbG8gPSAwLFxuICAgIGhpID0gdGV4dC5sZW5ndGgsXG4gICAgbWlkO1xuICBsaW1pdCAtPSB3aWR0aChlbGxpcHNpcyk7XG4gIGlmIChydGwpIHtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICAgIGlmICh3aWR0aCh0ZXh0LnNsaWNlKG1pZCkpID4gbGltaXQpIGxvID0gbWlkICsgMTtlbHNlIGhpID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gZWxsaXBzaXMgKyB0ZXh0LnNsaWNlKGxvKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobG8gPCBoaSkge1xuICAgICAgbWlkID0gMSArIChsbyArIGhpID4+PiAxKTtcbiAgICAgIGlmICh3aWR0aCh0ZXh0LnNsaWNlKDAsIG1pZCkpIDwgbGltaXQpIGxvID0gbWlkO2Vsc2UgaGkgPSBtaWQgLSAxO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dC5zbGljZSgwLCBsbykgKyBlbGxpcHNpcztcbiAgfVxufVxuZnVuY3Rpb24gZm9udEZhbWlseShpdGVtLCBxdW90ZSkge1xuICB2YXIgZm9udCA9IGl0ZW0uZm9udDtcbiAgcmV0dXJuIChxdW90ZSAmJiBmb250ID8gU3RyaW5nKGZvbnQpLnJlcGxhY2UoL1wiL2csICdcXCcnKSA6IGZvbnQpIHx8ICdzYW5zLXNlcmlmJztcbn1cbmZ1bmN0aW9uIGZvbnQoaXRlbSwgcXVvdGUpIHtcbiAgcmV0dXJuICcnICsgKGl0ZW0uZm9udFN0eWxlID8gaXRlbS5mb250U3R5bGUgKyAnICcgOiAnJykgKyAoaXRlbS5mb250VmFyaWFudCA/IGl0ZW0uZm9udFZhcmlhbnQgKyAnICcgOiAnJykgKyAoaXRlbS5mb250V2VpZ2h0ID8gaXRlbS5mb250V2VpZ2h0ICsgJyAnIDogJycpICsgZm9udFNpemUoaXRlbSkgKyAncHggJyArIGZvbnRGYW1pbHkoaXRlbSwgcXVvdGUpO1xufVxuZnVuY3Rpb24gb2Zmc2V0KGl0ZW0pIHtcbiAgLy8gcGVyZm9ybSBvdXIgb3duIGZvbnQgYmFzZWxpbmUgY2FsY3VsYXRpb25cbiAgLy8gd2h5PyBub3QgYWxsIGJyb3dzZXJzIHN1cHBvcnQgU1ZHIDEuMSAnYWxpZ25tZW50LWJhc2VsaW5lJyA6KFxuICAvLyB0aGlzIGFsc28gZW5zdXJlcyBjb25zaXN0ZW50IGxheW91dCBhY3Jvc3MgcmVuZGVyZXJzXG4gIHZhciBiYXNlbGluZSA9IGl0ZW0uYmFzZWxpbmUsXG4gICAgaCA9IGZvbnRTaXplKGl0ZW0pO1xuICByZXR1cm4gTWF0aC5yb3VuZChiYXNlbGluZSA9PT0gJ3RvcCcgPyAwLjc5ICogaCA6IGJhc2VsaW5lID09PSAnbWlkZGxlJyA/IDAuMzAgKiBoIDogYmFzZWxpbmUgPT09ICdib3R0b20nID8gLTAuMjEgKiBoIDogYmFzZWxpbmUgPT09ICdsaW5lLXRvcCcgPyAwLjI5ICogaCArIDAuNSAqIGxpbmVIZWlnaHQoaXRlbSkgOiBiYXNlbGluZSA9PT0gJ2xpbmUtYm90dG9tJyA/IDAuMjkgKiBoIC0gMC41ICogbGluZUhlaWdodChpdGVtKSA6IDApO1xufVxuXG5jb25zdCB0ZXh0QWxpZ24gPSB7XG4gICdsZWZ0JzogJ3N0YXJ0JyxcbiAgJ2NlbnRlcic6ICdtaWRkbGUnLFxuICAncmlnaHQnOiAnZW5kJ1xufTtcbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBhbmNob3JQb2ludChpdGVtKSB7XG4gIHZhciB4ID0gaXRlbS54IHx8IDAsXG4gICAgeSA9IGl0ZW0ueSB8fCAwLFxuICAgIHIgPSBpdGVtLnJhZGl1cyB8fCAwLFxuICAgIHQ7XG4gIGlmIChyKSB7XG4gICAgdCA9IChpdGVtLnRoZXRhIHx8IDApIC0gSGFsZlBpO1xuICAgIHggKz0gciAqIE1hdGguY29zKHQpO1xuICAgIHkgKz0gciAqIE1hdGguc2luKHQpO1xuICB9XG4gIHRlbXBCb3VuZHMueDEgPSB4O1xuICB0ZW1wQm91bmRzLnkxID0geTtcbiAgcmV0dXJuIHRlbXBCb3VuZHM7XG59XG5mdW5jdGlvbiBhdHRyKGVtaXQsIGl0ZW0pIHtcbiAgdmFyIGR4ID0gaXRlbS5keCB8fCAwLFxuICAgIGR5ID0gKGl0ZW0uZHkgfHwgMCkgKyBvZmZzZXQoaXRlbSksXG4gICAgcCA9IGFuY2hvclBvaW50KGl0ZW0pLFxuICAgIHggPSBwLngxLFxuICAgIHkgPSBwLnkxLFxuICAgIGEgPSBpdGVtLmFuZ2xlIHx8IDAsXG4gICAgdDtcbiAgZW1pdCgndGV4dC1hbmNob3InLCB0ZXh0QWxpZ25baXRlbS5hbGlnbl0gfHwgJ3N0YXJ0Jyk7XG4gIGlmIChhKSB7XG4gICAgdCA9IHRyYW5zbGF0ZSh4LCB5KSArICcgJyArIHJvdGF0ZShhKTtcbiAgICBpZiAoZHggfHwgZHkpIHQgKz0gJyAnICsgdHJhbnNsYXRlKGR4LCBkeSk7XG4gIH0gZWxzZSB7XG4gICAgdCA9IHRyYW5zbGF0ZSh4ICsgZHgsIHkgKyBkeSk7XG4gIH1cbiAgZW1pdCgndHJhbnNmb3JtJywgdCk7XG59XG5mdW5jdGlvbiBib3VuZChib3VuZHMsIGl0ZW0sIG1vZGUpIHtcbiAgdmFyIGggPSB0ZXh0TWV0cmljcy5oZWlnaHQoaXRlbSksXG4gICAgYSA9IGl0ZW0uYWxpZ24sXG4gICAgcCA9IGFuY2hvclBvaW50KGl0ZW0pLFxuICAgIHggPSBwLngxLFxuICAgIHkgPSBwLnkxLFxuICAgIGR4ID0gaXRlbS5keCB8fCAwLFxuICAgIGR5ID0gKGl0ZW0uZHkgfHwgMCkgKyBvZmZzZXQoaXRlbSkgLSBNYXRoLnJvdW5kKDAuOCAqIGgpLFxuICAgIC8vIHVzZSA0LzUgb2Zmc2V0XG4gICAgdGwgPSB0ZXh0TGluZXMoaXRlbSksXG4gICAgdztcblxuICAvLyBnZXQgZGltZW5zaW9uc1xuICBpZiAoaXNBcnJheSh0bCkpIHtcbiAgICAvLyBtdWx0aS1saW5lIHRleHRcbiAgICBoICs9IGxpbmVIZWlnaHQoaXRlbSkgKiAodGwubGVuZ3RoIC0gMSk7XG4gICAgdyA9IHRsLnJlZHVjZSgodywgdCkgPT4gTWF0aC5tYXgodywgdGV4dE1ldHJpY3Mud2lkdGgoaXRlbSwgdCkpLCAwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBzaW5nbGUtbGluZSB0ZXh0XG4gICAgdyA9IHRleHRNZXRyaWNzLndpZHRoKGl0ZW0sIHRsKTtcbiAgfVxuXG4gIC8vIGhvcml6b250YWwgYWxpZ25tZW50XG4gIGlmIChhID09PSAnY2VudGVyJykge1xuICAgIGR4IC09IHcgLyAyO1xuICB9IGVsc2UgaWYgKGEgPT09ICdyaWdodCcpIHtcbiAgICBkeCAtPSB3O1xuICB9IGVsc2UgO1xuICBib3VuZHMuc2V0KGR4ICs9IHgsIGR5ICs9IHksIGR4ICsgdywgZHkgKyBoKTtcbiAgaWYgKGl0ZW0uYW5nbGUgJiYgIW1vZGUpIHtcbiAgICBib3VuZHMucm90YXRlKGl0ZW0uYW5nbGUgKiBEZWdUb1JhZCwgeCwgeSk7XG4gIH0gZWxzZSBpZiAobW9kZSA9PT0gMikge1xuICAgIHJldHVybiBib3VuZHMucm90YXRlZFBvaW50cyhpdGVtLmFuZ2xlICogRGVnVG9SYWQsIHgsIHkpO1xuICB9XG4gIHJldHVybiBib3VuZHM7XG59XG5mdW5jdGlvbiBkcmF3KGNvbnRleHQsIHNjZW5lLCBib3VuZHMpIHtcbiAgdmlzaXQoc2NlbmUsIGl0ZW0gPT4ge1xuICAgIHZhciBvcGFjaXR5ID0gaXRlbS5vcGFjaXR5ID09IG51bGwgPyAxIDogaXRlbS5vcGFjaXR5LFxuICAgICAgcCxcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgaSxcbiAgICAgIGxoLFxuICAgICAgdGwsXG4gICAgICBzdHI7XG4gICAgaWYgKGJvdW5kcyAmJiAhYm91bmRzLmludGVyc2VjdHMoaXRlbS5ib3VuZHMpIHx8XG4gICAgLy8gYm91bmRzIGNoZWNrXG4gICAgb3BhY2l0eSA9PT0gMCB8fCBpdGVtLmZvbnRTaXplIDw9IDAgfHwgaXRlbS50ZXh0ID09IG51bGwgfHwgaXRlbS50ZXh0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIGNvbnRleHQuZm9udCA9IGZvbnQoaXRlbSk7XG4gICAgY29udGV4dC50ZXh0QWxpZ24gPSBpdGVtLmFsaWduIHx8ICdsZWZ0JztcbiAgICBwID0gYW5jaG9yUG9pbnQoaXRlbSk7XG4gICAgeCA9IHAueDEsIHkgPSBwLnkxO1xuICAgIGlmIChpdGVtLmFuZ2xlKSB7XG4gICAgICBjb250ZXh0LnNhdmUoKTtcbiAgICAgIGNvbnRleHQudHJhbnNsYXRlKHgsIHkpO1xuICAgICAgY29udGV4dC5yb3RhdGUoaXRlbS5hbmdsZSAqIERlZ1RvUmFkKTtcbiAgICAgIHggPSB5ID0gMDsgLy8gcmVzZXQgeCwgeVxuICAgIH1cbiAgICB4ICs9IGl0ZW0uZHggfHwgMDtcbiAgICB5ICs9IChpdGVtLmR5IHx8IDApICsgb2Zmc2V0KGl0ZW0pO1xuICAgIHRsID0gdGV4dExpbmVzKGl0ZW0pO1xuICAgIGJsZW5kKGNvbnRleHQsIGl0ZW0pO1xuICAgIGlmIChpc0FycmF5KHRsKSkge1xuICAgICAgbGggPSBsaW5lSGVpZ2h0KGl0ZW0pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHN0ciA9IHRleHRWYWx1ZShpdGVtLCB0bFtpXSk7XG4gICAgICAgIGlmIChpdGVtLmZpbGwgJiYgZmlsbChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgICAgIGNvbnRleHQuZmlsbFRleHQoc3RyLCB4LCB5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICAgICAgY29udGV4dC5zdHJva2VUZXh0KHN0ciwgeCwgeSk7XG4gICAgICAgIH1cbiAgICAgICAgeSArPSBsaDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgc3RyID0gdGV4dFZhbHVlKGl0ZW0sIHRsKTtcbiAgICAgIGlmIChpdGVtLmZpbGwgJiYgZmlsbChjb250ZXh0LCBpdGVtLCBvcGFjaXR5KSkge1xuICAgICAgICBjb250ZXh0LmZpbGxUZXh0KHN0ciwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbS5zdHJva2UgJiYgc3Ryb2tlKGNvbnRleHQsIGl0ZW0sIG9wYWNpdHkpKSB7XG4gICAgICAgIGNvbnRleHQuc3Ryb2tlVGV4dChzdHIsIHgsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXRlbS5hbmdsZSkgY29udGV4dC5yZXN0b3JlKCk7XG4gIH0pO1xufVxuZnVuY3Rpb24gaGl0KGNvbnRleHQsIGl0ZW0sIHgsIHksIGd4LCBneSkge1xuICBpZiAoaXRlbS5mb250U2l6ZSA8PSAwKSByZXR1cm4gZmFsc2U7XG4gIGlmICghaXRlbS5hbmdsZSkgcmV0dXJuIHRydWU7IC8vIGJvdW5kcyBzdWZmaWNpZW50IGlmIG5vIHJvdGF0aW9uXG5cbiAgLy8gcHJvamVjdCBwb2ludCBpbnRvIHNwYWNlIG9mIHVucm90YXRlZCBib3VuZHNcbiAgdmFyIHAgPSBhbmNob3JQb2ludChpdGVtKSxcbiAgICBheCA9IHAueDEsXG4gICAgYXkgPSBwLnkxLFxuICAgIGIgPSBib3VuZCh0ZW1wQm91bmRzLCBpdGVtLCAxKSxcbiAgICBhID0gLWl0ZW0uYW5nbGUgKiBEZWdUb1JhZCxcbiAgICBjb3MgPSBNYXRoLmNvcyhhKSxcbiAgICBzaW4gPSBNYXRoLnNpbihhKSxcbiAgICBweCA9IGNvcyAqIGd4IC0gc2luICogZ3kgKyAoYXggLSBjb3MgKiBheCArIHNpbiAqIGF5KSxcbiAgICBweSA9IHNpbiAqIGd4ICsgY29zICogZ3kgKyAoYXkgLSBzaW4gKiBheCAtIGNvcyAqIGF5KTtcbiAgcmV0dXJuIGIuY29udGFpbnMocHgsIHB5KTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdFRleHQoaXRlbSwgYm94KSB7XG4gIGNvbnN0IHAgPSBib3VuZCh0ZW1wQm91bmRzLCBpdGVtLCAyKTtcbiAgcmV0dXJuIGludGVyc2VjdEJveExpbmUoYm94LCBwWzBdLCBwWzFdLCBwWzJdLCBwWzNdKSB8fCBpbnRlcnNlY3RCb3hMaW5lKGJveCwgcFswXSwgcFsxXSwgcFs0XSwgcFs1XSkgfHwgaW50ZXJzZWN0Qm94TGluZShib3gsIHBbNF0sIHBbNV0sIHBbNl0sIHBbN10pIHx8IGludGVyc2VjdEJveExpbmUoYm94LCBwWzJdLCBwWzNdLCBwWzZdLCBwWzddKTtcbn1cbnZhciB0ZXh0ID0ge1xuICB0eXBlOiAndGV4dCcsXG4gIHRhZzogJ3RleHQnLFxuICBuZXN0ZWQ6IGZhbHNlLFxuICBhdHRyOiBhdHRyLFxuICBib3VuZDogYm91bmQsXG4gIGRyYXc6IGRyYXcsXG4gIHBpY2s6IHBpY2skMShoaXQpLFxuICBpc2VjdDogaW50ZXJzZWN0VGV4dFxufTtcblxudmFyIHRyYWlsID0gbWFya011bHRpSXRlbVBhdGgoJ3RyYWlsJywgdHJhaWwkMSwgcGlja1RyYWlsKTtcblxudmFyIE1hcmtzID0ge1xuICBhcmM6IGFyYyxcbiAgYXJlYTogYXJlYSxcbiAgZ3JvdXA6IGdyb3VwLFxuICBpbWFnZTogaW1hZ2UsXG4gIGxpbmU6IGxpbmUsXG4gIHBhdGg6IHBhdGgkMixcbiAgcmVjdDogcmVjdCxcbiAgcnVsZTogcnVsZSxcbiAgc2hhcGU6IHNoYXBlLFxuICBzeW1ib2w6IHN5bWJvbCxcbiAgdGV4dDogdGV4dCxcbiAgdHJhaWw6IHRyYWlsXG59O1xuXG5mdW5jdGlvbiBib3VuZEl0ZW0gKGl0ZW0sIGZ1bmMsIG9wdCkge1xuICB2YXIgdHlwZSA9IE1hcmtzW2l0ZW0ubWFyay5tYXJrdHlwZV0sXG4gICAgYm91bmQgPSBmdW5jIHx8IHR5cGUuYm91bmQ7XG4gIGlmICh0eXBlLm5lc3RlZCkgaXRlbSA9IGl0ZW0ubWFyaztcbiAgcmV0dXJuIGJvdW5kKGl0ZW0uYm91bmRzIHx8IChpdGVtLmJvdW5kcyA9IG5ldyBCb3VuZHMoKSksIGl0ZW0sIG9wdCk7XG59XG5cbnZhciBEVU1NWSA9IHtcbiAgbWFyazogbnVsbFxufTtcbmZ1bmN0aW9uIGJvdW5kTWFyayAobWFyaywgYm91bmRzLCBvcHQpIHtcbiAgdmFyIHR5cGUgPSBNYXJrc1ttYXJrLm1hcmt0eXBlXSxcbiAgICBib3VuZCA9IHR5cGUuYm91bmQsXG4gICAgaXRlbXMgPSBtYXJrLml0ZW1zLFxuICAgIGhhc0l0ZW1zID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoLFxuICAgIGksXG4gICAgbixcbiAgICBpdGVtLFxuICAgIGI7XG4gIGlmICh0eXBlLm5lc3RlZCkge1xuICAgIGlmIChoYXNJdGVtcykge1xuICAgICAgaXRlbSA9IGl0ZW1zWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBubyBpdGVtcywgZmFrZSBpdFxuICAgICAgRFVNTVkubWFyayA9IG1hcms7XG4gICAgICBpdGVtID0gRFVNTVk7XG4gICAgfVxuICAgIGIgPSBib3VuZEl0ZW0oaXRlbSwgYm91bmQsIG9wdCk7XG4gICAgYm91bmRzID0gYm91bmRzICYmIGJvdW5kcy51bmlvbihiKSB8fCBiO1xuICAgIHJldHVybiBib3VuZHM7XG4gIH1cbiAgYm91bmRzID0gYm91bmRzIHx8IG1hcmsuYm91bmRzICYmIG1hcmsuYm91bmRzLmNsZWFyKCkgfHwgbmV3IEJvdW5kcygpO1xuICBpZiAoaGFzSXRlbXMpIHtcbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBib3VuZHMudW5pb24oYm91bmRJdGVtKGl0ZW1zW2ldLCBib3VuZCwgb3B0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtYXJrLmJvdW5kcyA9IGJvdW5kcztcbn1cblxuY29uc3Qga2V5cyA9IFsnbWFya3R5cGUnLCAnbmFtZScsICdyb2xlJywgJ2ludGVyYWN0aXZlJywgJ2NsaXAnLCAnaXRlbXMnLCAnemluZGV4JywgJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnLCAnYWxpZ24nLCAnYmFzZWxpbmUnLFxuLy8gbGF5b3V0XG4nZmlsbCcsICdmaWxsT3BhY2l0eScsICdvcGFjaXR5JywgJ2JsZW5kJyxcbi8vIGZpbGxcbidzdHJva2UnLCAnc3Ryb2tlT3BhY2l0eScsICdzdHJva2VXaWR0aCcsICdzdHJva2VDYXAnLFxuLy8gc3Ryb2tlXG4nc3Ryb2tlRGFzaCcsICdzdHJva2VEYXNoT2Zmc2V0Jyxcbi8vIHN0cm9rZSBkYXNoXG4nc3Ryb2tlRm9yZWdyb3VuZCcsICdzdHJva2VPZmZzZXQnLFxuLy8gZ3JvdXBcbidzdGFydEFuZ2xlJywgJ2VuZEFuZ2xlJywgJ2lubmVyUmFkaXVzJywgJ291dGVyUmFkaXVzJyxcbi8vIGFyY1xuJ2Nvcm5lclJhZGl1cycsICdwYWRBbmdsZScsXG4vLyBhcmMsIHJlY3Rcbidjb3JuZXJSYWRpdXNUb3BMZWZ0JywgJ2Nvcm5lclJhZGl1c1RvcFJpZ2h0Jyxcbi8vIHJlY3QsIGdyb3VwXG4nY29ybmVyUmFkaXVzQm90dG9tTGVmdCcsICdjb3JuZXJSYWRpdXNCb3R0b21SaWdodCcsICdpbnRlcnBvbGF0ZScsICd0ZW5zaW9uJywgJ29yaWVudCcsICdkZWZpbmVkJyxcbi8vIGFyZWEsIGxpbmVcbid1cmwnLCAnYXNwZWN0JywgJ3Ntb290aCcsXG4vLyBpbWFnZVxuJ3BhdGgnLCAnc2NhbGVYJywgJ3NjYWxlWScsXG4vLyBwYXRoXG4neDInLCAneTInLFxuLy8gcnVsZVxuJ3NpemUnLCAnc2hhcGUnLFxuLy8gc3ltYm9sXG4ndGV4dCcsICdhbmdsZScsICd0aGV0YScsICdyYWRpdXMnLCAnZGlyJywgJ2R4JywgJ2R5Jyxcbi8vIHRleHRcbidlbGxpcHNpcycsICdsaW1pdCcsICdsaW5lQnJlYWsnLCAnbGluZUhlaWdodCcsICdmb250JywgJ2ZvbnRTaXplJywgJ2ZvbnRXZWlnaHQnLCAnZm9udFN0eWxlJywgJ2ZvbnRWYXJpYW50Jyxcbi8vIGZvbnRcbidkZXNjcmlwdGlvbicsICdhcmlhJywgJ2FyaWFSb2xlJywgJ2FyaWFSb2xlRGVzY3JpcHRpb24nIC8vIGFyaWFcbl07XG5mdW5jdGlvbiBzY2VuZVRvSlNPTihzY2VuZSwgaW5kZW50KSB7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShzY2VuZSwga2V5cywgaW5kZW50KTtcbn1cbmZ1bmN0aW9uIHNjZW5lRnJvbUpTT04oanNvbikge1xuICBjb25zdCBzY2VuZSA9IHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uO1xuICByZXR1cm4gaW5pdGlhbGl6ZShzY2VuZSk7XG59XG5mdW5jdGlvbiBpbml0aWFsaXplKHNjZW5lKSB7XG4gIHZhciB0eXBlID0gc2NlbmUubWFya3R5cGUsXG4gICAgaXRlbXMgPSBzY2VuZS5pdGVtcyxcbiAgICBwYXJlbnQsXG4gICAgaSxcbiAgICBuO1xuICBpZiAoaXRlbXMpIHtcbiAgICBmb3IgKGkgPSAwLCBuID0gaXRlbXMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBwYXJlbnQgPSB0eXBlID8gJ21hcmsnIDogJ2dyb3VwJztcbiAgICAgIGl0ZW1zW2ldW3BhcmVudF0gPSBzY2VuZTtcbiAgICAgIGlmIChpdGVtc1tpXS56aW5kZXgpIGl0ZW1zW2ldW3BhcmVudF0uemRpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmICgnZ3JvdXAnID09PSAodHlwZSB8fCBwYXJlbnQpKSBpbml0aWFsaXplKGl0ZW1zW2ldKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGUpIGJvdW5kTWFyayhzY2VuZSk7XG4gIHJldHVybiBzY2VuZTtcbn1cblxuY2xhc3MgU2NlbmVncmFwaCB7XG4gIGNvbnN0cnVjdG9yKHNjZW5lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMucm9vdCA9IHNjZW5lRnJvbUpTT04oc2NlbmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnJvb3QgPSBjcmVhdGVNYXJrKHtcbiAgICAgICAgbWFya3R5cGU6ICdncm91cCcsXG4gICAgICAgIG5hbWU6ICdyb290JyxcbiAgICAgICAgcm9sZTogJ2ZyYW1lJ1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb3QuaXRlbXMgPSBbbmV3IEdyb3VwSXRlbSh0aGlzLnJvb3QpXTtcbiAgICB9XG4gIH1cbiAgdG9KU09OKGluZGVudCkge1xuICAgIHJldHVybiBzY2VuZVRvSlNPTih0aGlzLnJvb3QsIGluZGVudCB8fCAwKTtcbiAgfVxuICBtYXJrKG1hcmtkZWYsIGdyb3VwLCBpbmRleCkge1xuICAgIGdyb3VwID0gZ3JvdXAgfHwgdGhpcy5yb290Lml0ZW1zWzBdO1xuICAgIGNvbnN0IG1hcmsgPSBjcmVhdGVNYXJrKG1hcmtkZWYsIGdyb3VwKTtcbiAgICBncm91cC5pdGVtc1tpbmRleF0gPSBtYXJrO1xuICAgIGlmIChtYXJrLnppbmRleCkgbWFyay5ncm91cC56ZGlydHkgPSB0cnVlO1xuICAgIHJldHVybiBtYXJrO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVNYXJrKGRlZiwgZ3JvdXApIHtcbiAgY29uc3QgbWFyayA9IHtcbiAgICBib3VuZHM6IG5ldyBCb3VuZHMoKSxcbiAgICBjbGlwOiAhIWRlZi5jbGlwLFxuICAgIGdyb3VwOiBncm91cCxcbiAgICBpbnRlcmFjdGl2ZTogZGVmLmludGVyYWN0aXZlID09PSBmYWxzZSA/IGZhbHNlIDogdHJ1ZSxcbiAgICBpdGVtczogW10sXG4gICAgbWFya3R5cGU6IGRlZi5tYXJrdHlwZSxcbiAgICBuYW1lOiBkZWYubmFtZSB8fCB1bmRlZmluZWQsXG4gICAgcm9sZTogZGVmLnJvbGUgfHwgdW5kZWZpbmVkLFxuICAgIHppbmRleDogZGVmLnppbmRleCB8fCAwXG4gIH07XG5cbiAgLy8gYWRkIGFjY2Vzc2liaWxpdHkgcHJvcGVydGllcyBpZiBkZWZpbmVkXG4gIGlmIChkZWYuYXJpYSAhPSBudWxsKSB7XG4gICAgbWFyay5hcmlhID0gZGVmLmFyaWE7XG4gIH1cbiAgaWYgKGRlZi5kZXNjcmlwdGlvbikge1xuICAgIG1hcmsuZGVzY3JpcHRpb24gPSBkZWYuZGVzY3JpcHRpb247XG4gIH1cbiAgcmV0dXJuIG1hcms7XG59XG5cbi8vIGNyZWF0ZSBhIG5ldyBET00gZWxlbWVudFxuZnVuY3Rpb24gZG9tQ3JlYXRlKGRvYywgdGFnLCBucykge1xuICBpZiAoIWRvYyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpIHtcbiAgICBkb2MgPSBkb2N1bWVudDtcbiAgfVxuICByZXR1cm4gZG9jID8gbnMgPyBkb2MuY3JlYXRlRWxlbWVudE5TKG5zLCB0YWcpIDogZG9jLmNyZWF0ZUVsZW1lbnQodGFnKSA6IG51bGw7XG59XG5cbi8vIGZpbmQgZmlyc3QgY2hpbGQgZWxlbWVudCB3aXRoIG1hdGNoaW5nIHRhZ1xuZnVuY3Rpb24gZG9tRmluZChlbCwgdGFnKSB7XG4gIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICB2YXIgbm9kZXMgPSBlbC5jaGlsZE5vZGVzLFxuICAgIGkgPSAwLFxuICAgIG4gPSBub2Rlcy5sZW5ndGg7XG4gIGZvciAoOyBpIDwgbjsgKytpKSBpZiAobm9kZXNbaV0udGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcpIHtcbiAgICByZXR1cm4gbm9kZXNbaV07XG4gIH1cbn1cblxuLy8gcmV0cmlldmUgY2hpbGQgZWxlbWVudCBhdCBnaXZlbiBpbmRleFxuLy8gY3JlYXRlICYgaW5zZXJ0IGlmIGRvZXNuJ3QgZXhpc3Qgb3IgaWYgdGFncyBkbyBub3QgbWF0Y2hcbmZ1bmN0aW9uIGRvbUNoaWxkKGVsLCBpbmRleCwgdGFnLCBucykge1xuICB2YXIgYSA9IGVsLmNoaWxkTm9kZXNbaW5kZXhdLFxuICAgIGI7XG4gIGlmICghYSB8fCBhLnRhZ05hbWUudG9Mb3dlckNhc2UoKSAhPT0gdGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBiID0gYSB8fCBudWxsO1xuICAgIGEgPSBkb21DcmVhdGUoZWwub3duZXJEb2N1bWVudCwgdGFnLCBucyk7XG4gICAgZWwuaW5zZXJ0QmVmb3JlKGEsIGIpO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG4vLyByZW1vdmUgYWxsIGNoaWxkIGVsZW1lbnRzIGF0IG9yIGFib3ZlIHRoZSBnaXZlbiBpbmRleFxuZnVuY3Rpb24gZG9tQ2xlYXIoZWwsIGluZGV4KSB7XG4gIHZhciBub2RlcyA9IGVsLmNoaWxkTm9kZXMsXG4gICAgY3VyciA9IG5vZGVzLmxlbmd0aDtcbiAgd2hpbGUgKGN1cnIgPiBpbmRleCkgZWwucmVtb3ZlQ2hpbGQobm9kZXNbLS1jdXJyXSk7XG4gIHJldHVybiBlbDtcbn1cblxuLy8gZ2VuZXJhdGUgY3NzIGNsYXNzIG5hbWUgZm9yIG1hcmtcbmZ1bmN0aW9uIGNzc0NsYXNzKG1hcmspIHtcbiAgcmV0dXJuICdtYXJrLScgKyBtYXJrLm1hcmt0eXBlICsgKG1hcmsucm9sZSA/ICcgcm9sZS0nICsgbWFyay5yb2xlIDogJycpICsgKG1hcmsubmFtZSA/ICcgJyArIG1hcmsubmFtZSA6ICcnKTtcbn1cblxuZnVuY3Rpb24gcG9pbnQgKGV2ZW50LCBlbCkge1xuICBjb25zdCByZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHJldHVybiBbZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdCAtIChlbC5jbGllbnRMZWZ0IHx8IDApLCBldmVudC5jbGllbnRZIC0gcmVjdC50b3AgLSAoZWwuY2xpZW50VG9wIHx8IDApXTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUl0ZW0gKGl0ZW0sIGV2ZW50LCBlbCwgb3JpZ2luKSB7XG4gIHZhciBtYXJrID0gaXRlbSAmJiBpdGVtLm1hcmssXG4gICAgbWRlZixcbiAgICBwO1xuICBpZiAobWFyayAmJiAobWRlZiA9IE1hcmtzW21hcmsubWFya3R5cGVdKS50aXApIHtcbiAgICBwID0gcG9pbnQoZXZlbnQsIGVsKTtcbiAgICBwWzBdIC09IG9yaWdpblswXTtcbiAgICBwWzFdIC09IG9yaWdpblsxXTtcbiAgICB3aGlsZSAoaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkge1xuICAgICAgcFswXSAtPSBpdGVtLnggfHwgMDtcbiAgICAgIHBbMV0gLT0gaXRlbS55IHx8IDA7XG4gICAgfVxuICAgIGl0ZW0gPSBtZGVmLnRpcChtYXJrLml0ZW1zLCBwKTtcbiAgfVxuICByZXR1cm4gaXRlbTtcbn1cblxuY2xhc3MgSGFuZGxlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgSGFuZGxlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtjdXN0b21Mb2FkZXJdIC0gT3B0aW9uYWwgbG9hZGVyIGluc3RhbmNlIGZvclxuICAgKiAgIGhyZWYgVVJMIHNhbml0aXphdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgYSBzdGFuZGFyZCBsb2FkZXJcbiAgICogICBpbnN0YW5jZSB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gW2N1c3RvbVRvb2x0aXBdIC0gT3B0aW9uYWwgdG9vbHRpcCBoYW5kbGVyXG4gICAqICAgZnVuY3Rpb24gZm9yIGN1c3RvbSB0b29sdGlwIGRpc3BsYXkuXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgY29uc3RydWN0b3IoY3VzdG9tTG9hZGVyLCBjdXN0b21Ub29sdGlwKSB7XG4gICAgdGhpcy5fYWN0aXZlID0gbnVsbDtcbiAgICB0aGlzLl9oYW5kbGVycyA9IHt9O1xuICAgIHRoaXMuX2xvYWRlciA9IGN1c3RvbUxvYWRlciB8fCBsb2FkZXIoKTtcbiAgICB0aGlzLl90b29sdGlwID0gY3VzdG9tVG9vbHRpcCB8fCBkZWZhdWx0VG9vbHRpcDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplIGEgbmV3IEhhbmRsZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudCBmb3IgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3JpZ2luIC0gVGhlIG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtvYmplY3R9IFtvYmpdIC0gT3B0aW9uYWwgY29udGV4dCBvYmplY3QgdGhhdCBzaG91bGQgc2VydmUgYXNcbiAgICogICB0aGUgXCJ0aGlzXCIgY29udGV4dCBmb3IgZXZlbnQgY2FsbGJhY2tzLlxuICAgKiBAcmV0dXJuIHtIYW5kbGVyfSAtIFRoaXMgaGFuZGxlciBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemUoZWwsIG9yaWdpbiwgb2JqKSB7XG4gICAgdGhpcy5fZWwgPSBlbDtcbiAgICB0aGlzLl9vYmogPSBvYmogfHwgbnVsbDtcbiAgICByZXR1cm4gdGhpcy5vcmlnaW4ob3JpZ2luKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgdmlzdWFsaXphdGlvbi5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudC5cbiAgICovXG4gIGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjZW5lIGVsZW1lbnQgKGUuZy4sIGNhbnZhcyBvciBTVkcpIG9mIHRoZSB2aXN1YWxpemF0aW9uXG4gICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBpZiB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IHRoZSBzY2VuZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBzY2VuZSAoZS5nLiwgY2FudmFzIG9yIFNWRykgZWxlbWVudC5cbiAgICovXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWwgJiYgdGhpcy5fZWwuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgLyBzZXQgdGhlIG9yaWdpbiBjb29yZGluYXRlcyBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAgICovXG4gIG9yaWdpbihvcmlnaW4pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fb3JpZ2luID0gb3JpZ2luIHx8IFswLCAwXTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fb3JpZ2luLnNsaWNlKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCAvIHNldCB0aGUgc2NlbmVncmFwaCByb290LlxuICAgKi9cbiAgc2NlbmUoc2NlbmUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9zY2VuZTtcbiAgICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBldmVudCBoYW5kbGVyLiBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZC5cbiAgICovXG4gIG9uKC8qdHlwZSwgaGFuZGxlciovKSB7fVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgaGFuZGxlci4gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QuXG4gICAqL1xuICBvZmYoLyp0eXBlLCBoYW5kbGVyKi8pIHt9XG5cbiAgLyoqXG4gICAqIFV0aWxpdHkgbWV0aG9kIGZvciBmaW5kaW5nIHRoZSBhcnJheSBpbmRleCBvZiBhbiBldmVudCBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge0FycmF5fSBoIC0gQW4gYXJyYXkgb2YgcmVnaXN0ZXJlZCBldmVudCBoYW5kbGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgZXZlbnQgdHlwZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gaGFuZGxlciAtIFRoZSBldmVudCBoYW5kbGVyIGluc3RhbmNlIHRvIGZpbmQuXG4gICAqIEByZXR1cm4ge251bWJlcn0gLSBUaGUgaGFuZGxlcidzIGFycmF5IGluZGV4IG9yIC0xIGlmIG5vdCByZWdpc3RlcmVkLlxuICAgKi9cbiAgX2hhbmRsZXJJbmRleChoLCB0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChsZXQgaSA9IGggPyBoLmxlbmd0aCA6IDA7IC0taSA+PSAwOykge1xuICAgICAgaWYgKGhbaV0udHlwZSA9PT0gdHlwZSAmJiAoIWhhbmRsZXIgfHwgaFtpXS5oYW5kbGVyID09PSBoYW5kbGVyKSkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gYXJyYXkgd2l0aCByZWdpc3RlcmVkIGV2ZW50IGhhbmRsZXJzLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3R5cGVdIC0gVGhlIGV2ZW50IHR5cGUgdG8gcXVlcnkuIEFueSBhbm5vdGF0aW9uc1xuICAgKiAgIGFyZSBpZ25vcmVkOyBmb3IgZXhhbXBsZSwgZm9yIHRoZSBhcmd1bWVudCBcImNsaWNrLmZvb1wiLCBcIi5mb29cIiB3aWxsXG4gICAqICAgYmUgaWdub3JlZCBhbmQgdGhlIG1ldGhvZCByZXR1cm5zIGFsbCBcImNsaWNrXCIgaGFuZGxlcnMuIElmIHR5cGUgaXNcbiAgICogICBudWxsIG9yIHVuc3BlY2lmaWVkLCB0aGlzIG1ldGhvZCByZXR1cm5zIGhhbmRsZXJzIGZvciBhbGwgdHlwZXMuXG4gICAqIEByZXR1cm4ge0FycmF5fSAtIEEgbmV3IGFycmF5IGNvbnRhaW5pbmcgYWxsIHJlZ2lzdGVyZWQgZXZlbnQgaGFuZGxlcnMuXG4gICAqL1xuICBoYW5kbGVycyh0eXBlKSB7XG4gICAgY29uc3QgaCA9IHRoaXMuX2hhbmRsZXJzLFxuICAgICAgYSA9IFtdO1xuICAgIGlmICh0eXBlKSB7XG4gICAgICBhLnB1c2goLi4uaFt0aGlzLmV2ZW50TmFtZSh0eXBlKV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IGsgaW4gaCkge1xuICAgICAgICBhLnB1c2goLi4uaFtrXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhO1xuICB9XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbiBldmVudCBuYW1lIHN0cmluZyB0byByZXR1cm4gdGhlIHNwZWNpZmljIGV2ZW50IHR5cGUuXG4gICAqIEZvciBleGFtcGxlLCBnaXZlbiBcImNsaWNrLmZvb1wiIHJldHVybnMgXCJjbGlja1wiXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGlucHV0IGV2ZW50IHR5cGUgc3RyaW5nLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IC0gQSBzdHJpbmcgd2l0aCB0aGUgZXZlbnQgdHlwZSBvbmx5LlxuICAgKi9cbiAgZXZlbnROYW1lKG5hbWUpIHtcbiAgICBjb25zdCBpID0gbmFtZS5pbmRleE9mKCcuJyk7XG4gICAgcmV0dXJuIGkgPCAwID8gbmFtZSA6IG5hbWUuc2xpY2UoMCwgaSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIGh5cGVybGluayBuYXZpZ2F0aW9uIGluIHJlc3BvbnNlIHRvIGFuIGl0ZW0uaHJlZiB2YWx1ZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdHJpZ2dlcmluZyBoeXBlcmxpbmsgbmF2aWdhdGlvbi5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIHNjZW5lZ3JhcGggaXRlbS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhyZWYgLSBUaGUgVVJMIHRvIG5hdmlnYXRlIHRvLlxuICAgKi9cbiAgaGFuZGxlSHJlZihldmVudCwgaXRlbSwgaHJlZikge1xuICAgIHRoaXMuX2xvYWRlci5zYW5pdGl6ZShocmVmLCB7XG4gICAgICBjb250ZXh0OiAnaHJlZidcbiAgICB9KS50aGVuKG9wdCA9PiB7XG4gICAgICBjb25zdCBlID0gbmV3IE1vdXNlRXZlbnQoZXZlbnQudHlwZSwgZXZlbnQpLFxuICAgICAgICBhID0gZG9tQ3JlYXRlKG51bGwsICdhJyk7XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gb3B0KSBhLnNldEF0dHJpYnV0ZShuYW1lLCBvcHRbbmFtZV0pO1xuICAgICAgYS5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH0pLmNhdGNoKCgpID0+IHt9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgdG9vbHRpcCBkaXNwbGF5IGluIHJlc3BvbnNlIHRvIGFuIGl0ZW0udG9vbHRpcCB2YWx1ZS5cbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgdHJpZ2dlcmluZyB0b29sdGlwIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBzY2VuZWdyYXBoIGl0ZW0uXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdyAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgd2hldGhlclxuICAgKiAgIHRvIHNob3cgb3IgaGlkZSBhIHRvb2x0aXAgZm9yIHRoZSBnaXZlbiBpdGVtLlxuICAgKi9cbiAgaGFuZGxlVG9vbHRpcChldmVudCwgaXRlbSwgc2hvdykge1xuICAgIGlmIChpdGVtICYmIGl0ZW0udG9vbHRpcCAhPSBudWxsKSB7XG4gICAgICBpdGVtID0gcmVzb2x2ZUl0ZW0oaXRlbSwgZXZlbnQsIHRoaXMuY2FudmFzKCksIHRoaXMuX29yaWdpbik7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNob3cgJiYgaXRlbSAmJiBpdGVtLnRvb2x0aXAgfHwgbnVsbDtcbiAgICAgIHRoaXMuX3Rvb2x0aXAuY2FsbCh0aGlzLl9vYmosIHRoaXMsIGV2ZW50LCBpdGVtLCB2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNpemUgb2YgYSBzY2VuZWdyYXBoIGl0ZW0gYW5kIGl0cyBwb3NpdGlvbiByZWxhdGl2ZVxuICAgKiB0byB0aGUgdmlld3BvcnQuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBzY2VuZWdyYXBoIGl0ZW0uXG4gICAqIEByZXR1cm4ge29iamVjdH0gLSBBIGJvdW5kaW5nIGJveCBvYmplY3QgKGNvbXBhdGlibGUgd2l0aCB0aGVcbiAgICogICBET01SZWN0IHR5cGUpIGNvbnNpc3Rpbmcgb2YgeCwgeSwgd2lkdGgsIGhlaWdoLCB0b3AsIGxlZnQsXG4gICAqICAgcmlnaHQsIGFuZCBib3R0b20gcHJvcGVydGllcy5cbiAgICovXG4gIGdldEl0ZW1Cb3VuZGluZ0NsaWVudFJlY3QoaXRlbSkge1xuICAgIGNvbnN0IGVsID0gdGhpcy5jYW52YXMoKTtcbiAgICBpZiAoIWVsKSByZXR1cm47XG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgb3JpZ2luID0gdGhpcy5fb3JpZ2luLFxuICAgICAgYm91bmRzID0gaXRlbS5ib3VuZHMsXG4gICAgICB3aWR0aCA9IGJvdW5kcy53aWR0aCgpLFxuICAgICAgaGVpZ2h0ID0gYm91bmRzLmhlaWdodCgpO1xuICAgIGxldCB4ID0gYm91bmRzLngxICsgb3JpZ2luWzBdICsgcmVjdC5sZWZ0LFxuICAgICAgeSA9IGJvdW5kcy55MSArIG9yaWdpblsxXSArIHJlY3QudG9wO1xuXG4gICAgLy8gdHJhbnNsYXRlIGNvb3JkaW5hdGUgZm9yIGVhY2ggcGFyZW50IGdyb3VwXG4gICAgd2hpbGUgKGl0ZW0ubWFyayAmJiAoaXRlbSA9IGl0ZW0ubWFyay5ncm91cCkpIHtcbiAgICAgIHggKz0gaXRlbS54IHx8IDA7XG4gICAgICB5ICs9IGl0ZW0ueSB8fCAwO1xuICAgIH1cblxuICAgIC8vIHJldHVybiBET01SZWN0LWNvbXBhdGlibGUgYm91bmRpbmcgYm94XG4gICAgcmV0dXJuIHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICBsZWZ0OiB4LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgIGJvdHRvbTogeSArIGhlaWdodFxuICAgIH07XG4gIH1cbn1cblxuLy8gVGhlIGRlZmF1bHQgdG9vbHRpcCBkaXNwbGF5IGhhbmRsZXIuXG4vLyBTZXRzIHRoZSBIVE1MIHRpdGxlIGF0dHJpYnV0ZSBvbiB0aGUgdmlzdWFsaXphdGlvbiBjb250YWluZXIuXG5mdW5jdGlvbiBkZWZhdWx0VG9vbHRpcChoYW5kbGVyLCBldmVudCwgaXRlbSwgdmFsdWUpIHtcbiAgaGFuZGxlci5lbGVtZW50KCkuc2V0QXR0cmlidXRlKCd0aXRsZScsIHZhbHVlIHx8ICcnKTtcbn1cblxuY2xhc3MgUmVuZGVyZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IFJlbmRlcmVyIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge29iamVjdH0gW2xvYWRlcl0gLSBPcHRpb25hbCBsb2FkZXIgaW5zdGFuY2UgZm9yXG4gICAqICAgaW1hZ2UgYW5kIGhyZWYgVVJMIHNhbml0aXphdGlvbi4gSWYgbm90IHNwZWNpZmllZCwgYVxuICAgKiAgIHN0YW5kYXJkIGxvYWRlciBpbnN0YW5jZSB3aWxsIGJlIGdlbmVyYXRlZC5cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2FkZXIpIHtcbiAgICB0aGlzLl9lbCA9IG51bGw7XG4gICAgdGhpcy5fYmdjb2xvciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVyID0gbmV3IFJlc291cmNlTG9hZGVyKGxvYWRlcik7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBSZW5kZXJlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbCAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50IGZvciB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVGYWN0b3I9MV0gLSBPcHRpb25hbCBzY2FsZUZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseVxuICAgKiAgIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGRldGVybWluZSB0aGUgZmluYWwgcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7UmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemUoZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICB0aGlzLl9lbCA9IGVsO1xuICAgIHJldHVybiB0aGlzLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYXJlbnQgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgdmlzdWFsaXphdGlvbi5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudC5cbiAgICovXG4gIGVsZW1lbnQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2VsO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjZW5lIGVsZW1lbnQgKGUuZy4sIGNhbnZhcyBvciBTVkcpIG9mIHRoZSB2aXN1YWxpemF0aW9uXG4gICAqIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBpZiB0aGUgZmlyc3QgY2hpbGQgaXMgbm90IHRoZSBzY2VuZSBlbGVtZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSAtIFRoZSBzY2VuZSAoZS5nLiwgY2FudmFzIG9yIFNWRykgZWxlbWVudC5cbiAgICovXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZWwgJiYgdGhpcy5fZWwuZmlyc3RDaGlsZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgLyBzZXQgdGhlIGJhY2tncm91bmQgY29sb3IuXG4gICAqL1xuICBiYWNrZ3JvdW5kKGJnY29sb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2JnY29sb3I7XG4gICAgdGhpcy5fYmdjb2xvciA9IGJnY29sb3I7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVzaXplIHRoZSBkaXNwbGF5LlxuICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSBUaGUgbmV3IGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBuZXcgY29vcmRpbmF0ZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgbmV3IG9yaWdpbiBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiAgIFRoZSBjb29yZGluYXRlIHN5c3RlbSB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdGhpcyBwb2ludC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzY2FsZUZhY3Rvcj0xXSAtIE9wdGlvbmFsIHNjYWxlRmFjdG9yIGJ5IHdoaWNoIHRvIG11bHRpcGx5XG4gICAqICAgdGhlIHdpZHRoIGFuZCBoZWlnaHQgdG8gZGV0ZXJtaW5lIHRoZSBmaW5hbCBwaXhlbCBzaXplLlxuICAgKiBAcmV0dXJuIHtSZW5kZXJlcn0gLSBUaGlzIHJlbmRlcmVyIGluc3RhbmNlO1xuICAgKi9cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuX2hlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLl9vcmlnaW4gPSBvcmlnaW4gfHwgWzAsIDBdO1xuICAgIHRoaXMuX3NjYWxlID0gc2NhbGVGYWN0b3IgfHwgMTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXBvcnQgYSBkaXJ0eSBpdGVtIHdob3NlIGJvdW5kcyBzaG91bGQgYmUgcmVkcmF3bi5cbiAgICogVGhpcyBiYXNlIGNsYXNzIG1ldGhvZCBkb2VzIG5vdGhpbmcuIFN1YmNsYXNzZXMgdGhhdCBwZXJmb3JtXG4gICAqIGluY3JlbWVudGFsIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBkaXJ0eSBpdGVtIHdob3NlIGJvdW5kcyBzaG91bGQgYmUgcmVkcmF3bi5cbiAgICovXG4gIGRpcnR5KC8qaXRlbSovKSB7fVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgYW4gaW5wdXQgc2NlbmVncmFwaCwgcG90ZW50aWFsbHkgd2l0aCBhIHNldCBvZiBkaXJ0eSBpdGVtcy5cbiAgICogVGhpcyBtZXRob2Qgd2lsbCBwZXJmb3JtIGFuIGltbWVkaWF0ZSByZW5kZXJpbmcgd2l0aCBhdmFpbGFibGUgcmVzb3VyY2VzLlxuICAgKiBUaGUgcmVuZGVyZXIgbWF5IGFsc28gbmVlZCB0byBwZXJmb3JtIGltYWdlIGxvYWRpbmcgdG8gcGVyZm9ybSBhIGNvbXBsZXRlXG4gICAqIHJlbmRlci4gVGhpcyBwcm9jZXNzIGNhbiBsZWFkIHRvIGFzeW5jaHJvbm91cyByZS1yZW5kZXJpbmcgb2YgdGhlIHNjZW5lXG4gICAqIGFmdGVyIHRoaXMgbWV0aG9kIHJldHVybnMuIFRvIHJlY2VpdmUgbm90aWZpY2F0aW9uIHdoZW4gcmVuZGVyaW5nIGlzXG4gICAqIGNvbXBsZXRlLCB1c2UgdGhlIHJlbmRlckFzeW5jIG1ldGhvZCBpbnN0ZWFkLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG1hcmtUeXBlcyAtIEFycmF5IG9mIHRoZSBtYXJrIHR5cGVzIHRvIHJlbmRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdW5kZWZpbmVkLCByZW5kZXIgYWxsIG1hcmsgdHlwZXNcbiAgICogQHJldHVybiB7UmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIHJlbmRlcihzY2VuZSwgbWFya1R5cGVzKSB7XG4gICAgY29uc3QgciA9IHRoaXM7XG5cbiAgICAvLyBiaW5kIGFyZ3VtZW50cyBpbnRvIGEgcmVuZGVyIGNhbGwsIGFuZCBjYWNoZSBpdFxuICAgIC8vIHRoaXMgZnVuY3Rpb24gbWF5IGJlIHN1YnNlcXVlbnRseSBjYWxsZWQgZm9yIGFzeW5jIHJlZHJhd1xuICAgIHIuX2NhbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByLl9yZW5kZXIoc2NlbmUsIG1hcmtUeXBlcyk7XG4gICAgfTtcblxuICAgIC8vIGludm9rZSB0aGUgcmVuZGVyZXJcbiAgICByLl9jYWxsKCk7XG5cbiAgICAvLyBjbGVhciB0aGUgY2FjaGVkIGNhbGwgZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIC8vIGFzeW5jIHJlZHJhd3Mgd2lsbCBzdGFzaCB0aGVpciBvd24gY29weVxuICAgIHIuX2NhbGwgPSBudWxsO1xuICAgIHJldHVybiByO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlbmRlcmluZyBtZXRob2QuIFJlbmRlcmVyIHN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXNcbiAgICogbWV0aG9kIHRvIGFjdHVhbGx5IHBlcmZvcm0gcmVuZGVyaW5nLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG1hcmtUeXBlcyAtIEFycmF5IG9mIHRoZSBtYXJrIHR5cGVzIHRvIHJlbmRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdW5kZWZpbmVkLCByZW5kZXIgYWxsIG1hcmsgdHlwZXNcbiAgICovXG4gIF9yZW5kZXIoLypzY2VuZSwgbWFya1R5cGVzKi9cbiAgKSB7XG4gICAgLy8gc3ViY2xhc3NlcyB0byBvdmVycmlkZVxuICB9XG5cbiAgLyoqXG4gICAqIEFzeW5jaHJvbm91cyByZW5kZXJpbmcgbWV0aG9kLiBTaW1pbGFyIHRvIHJlbmRlciwgYnV0IHJldHVybnMgYSBQcm9taXNlXG4gICAqIHRoYXQgcmVzb2x2ZXMgd2hlbiBhbGwgcmVuZGVyaW5nIGlzIGNvbXBsZXRlZC4gU29tZXRpbWVzIGEgcmVuZGVyZXIgbXVzdFxuICAgKiBwZXJmb3JtIGltYWdlIGxvYWRpbmcgdG8gZ2V0IGEgY29tcGxldGUgcmVuZGVyaW5nLiBUaGUgcmV0dXJuZWRcbiAgICogUHJvbWlzZSB3aWxsIG5vdCByZXNvbHZlIHVudGlsIHRoaXMgcHJvY2VzcyBjb21wbGV0ZXMuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtBcnJheX0gbWFya1R5cGVzIC0gQXJyYXkgb2YgdGhlIG1hcmsgdHlwZXMgdG8gcmVuZGVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB1bmRlZmluZWQsIHJlbmRlciBhbGwgbWFyayB0eXBlc1xuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gcmVuZGVyaW5nIGlzIGNvbXBsZXRlLlxuICAgKi9cbiAgcmVuZGVyQXN5bmMoc2NlbmUsIG1hcmtUeXBlcykge1xuICAgIGNvbnN0IHIgPSB0aGlzLnJlbmRlcihzY2VuZSwgbWFya1R5cGVzKTtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHkgPyB0aGlzLl9yZWFkeS50aGVuKCgpID0+IHIpIDogUHJvbWlzZS5yZXNvbHZlKHIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCBmb3IgYXN5bmNocm9ub3VzIHJlc291cmNlIGxvYWRpbmcuXG4gICAqIFByb3hpZXMgbWV0aG9kIGNhbGxzIHRvIHRoZSBJbWFnZUxvYWRlciwgYW5kIHRyYWNrcyBsb2FkaW5nXG4gICAqIHByb2dyZXNzIHRvIGludm9rZSBhIHJlLXJlbmRlciBvbmNlIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kIC0gVGhlIG1ldGhvZCBuYW1lIHRvIGludm9rZSBvbiB0aGUgSW1hZ2VMb2FkZXIuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgVVJJIGZvciB0aGUgcmVxdWVzdGVkIHJlc291cmNlLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UuXG4gICAqL1xuICBfbG9hZChtZXRob2QsIHVyaSkge1xuICAgIHZhciByID0gdGhpcyxcbiAgICAgIHAgPSByLl9sb2FkZXJbbWV0aG9kXSh1cmkpO1xuICAgIGlmICghci5fcmVhZHkpIHtcbiAgICAgIC8vIHJlLXJlbmRlciB0aGUgc2NlbmUgd2hlbiBsb2FkaW5nIGNvbXBsZXRlc1xuICAgICAgY29uc3QgY2FsbCA9IHIuX2NhbGw7XG4gICAgICByLl9yZWFkeSA9IHIuX2xvYWRlci5yZWFkeSgpLnRoZW4ocmVkcmF3ID0+IHtcbiAgICAgICAgaWYgKHJlZHJhdykgY2FsbCgpO1xuICAgICAgICByLl9yZWFkeSA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH1cblxuICAvKipcbiAgICogU2FuaXRpemUgYSBVUkwgdG8gaW5jbHVkZSBhcyBhIGh5cGVybGluayBpbiB0aGUgcmVuZGVyZWQgc2NlbmUuXG4gICAqIFRoaXMgbWV0aG9kIHByb3hpZXMgYSBjYWxsIHRvIEltYWdlTG9hZGVyLnNhbml0aXplVVJMLCBidXQgYWxzbyB0cmFja3NcbiAgICogaW1hZ2UgbG9hZGluZyBwcm9ncmVzcyBhbmQgaW52b2tlcyBhIHJlLXJlbmRlciBvbmNlIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJpIC0gVGhlIFVSSSBzdHJpbmcgdG8gc2FuaXRpemUuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIHNhbml0aXplZCBVUkwuXG4gICAqL1xuICBzYW5pdGl6ZVVSTCh1cmkpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCgnc2FuaXRpemVVUkwnLCB1cmkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcXVlc3RzIGFuIGltYWdlIHRvIGluY2x1ZGUgaW4gdGhlIHJlbmRlcmVkIHNjZW5lLlxuICAgKiBUaGlzIG1ldGhvZCBwcm94aWVzIGEgY2FsbCB0byBJbWFnZUxvYWRlci5sb2FkSW1hZ2UsIGJ1dCBhbHNvIHRyYWNrc1xuICAgKiBpbWFnZSBsb2FkaW5nIHByb2dyZXNzIGFuZCBpbnZva2VzIGEgcmUtcmVuZGVyIG9uY2UgY29tcGxldGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmkgLSBUaGUgVVJJIHN0cmluZyBvZiB0aGUgaW1hZ2UuXG4gICAqIEByZXR1cm4ge1Byb21pc2V9IC0gQSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxvYWRlZCBJbWFnZS5cbiAgICovXG4gIGxvYWRJbWFnZSh1cmkpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9hZCgnbG9hZEltYWdlJywgdXJpKTtcbiAgfVxufVxuXG5jb25zdCBLZXlEb3duRXZlbnQgPSAna2V5ZG93bic7XG5jb25zdCBLZXlQcmVzc0V2ZW50ID0gJ2tleXByZXNzJztcbmNvbnN0IEtleVVwRXZlbnQgPSAna2V5dXAnO1xuY29uc3QgRHJhZ0VudGVyRXZlbnQgPSAnZHJhZ2VudGVyJztcbmNvbnN0IERyYWdMZWF2ZUV2ZW50ID0gJ2RyYWdsZWF2ZSc7XG5jb25zdCBEcmFnT3ZlckV2ZW50ID0gJ2RyYWdvdmVyJztcbmNvbnN0IFBvaW50ZXJEb3duRXZlbnQgPSAncG9pbnRlcmRvd24nO1xuY29uc3QgUG9pbnRlclVwRXZlbnQgPSAncG9pbnRlcnVwJztcbmNvbnN0IFBvaW50ZXJNb3ZlRXZlbnQgPSAncG9pbnRlcm1vdmUnO1xuY29uc3QgUG9pbnRlck91dEV2ZW50ID0gJ3BvaW50ZXJvdXQnO1xuY29uc3QgUG9pbnRlck92ZXJFdmVudCA9ICdwb2ludGVyb3Zlcic7XG5jb25zdCBNb3VzZURvd25FdmVudCA9ICdtb3VzZWRvd24nO1xuY29uc3QgTW91c2VVcEV2ZW50ID0gJ21vdXNldXAnO1xuY29uc3QgTW91c2VNb3ZlRXZlbnQgPSAnbW91c2Vtb3ZlJztcbmNvbnN0IE1vdXNlT3V0RXZlbnQgPSAnbW91c2VvdXQnO1xuY29uc3QgTW91c2VPdmVyRXZlbnQgPSAnbW91c2VvdmVyJztcbmNvbnN0IENsaWNrRXZlbnQgPSAnY2xpY2snO1xuY29uc3QgRG91YmxlQ2xpY2tFdmVudCA9ICdkYmxjbGljayc7XG5jb25zdCBXaGVlbEV2ZW50ID0gJ3doZWVsJztcbmNvbnN0IE1vdXNlV2hlZWxFdmVudCA9ICdtb3VzZXdoZWVsJztcbmNvbnN0IFRvdWNoU3RhcnRFdmVudCA9ICd0b3VjaHN0YXJ0JztcbmNvbnN0IFRvdWNoTW92ZUV2ZW50ID0gJ3RvdWNobW92ZSc7XG5jb25zdCBUb3VjaEVuZEV2ZW50ID0gJ3RvdWNoZW5kJztcbmNvbnN0IEV2ZW50cyA9IFtLZXlEb3duRXZlbnQsIEtleVByZXNzRXZlbnQsIEtleVVwRXZlbnQsIERyYWdFbnRlckV2ZW50LCBEcmFnTGVhdmVFdmVudCwgRHJhZ092ZXJFdmVudCwgUG9pbnRlckRvd25FdmVudCwgUG9pbnRlclVwRXZlbnQsIFBvaW50ZXJNb3ZlRXZlbnQsIFBvaW50ZXJPdXRFdmVudCwgUG9pbnRlck92ZXJFdmVudCwgTW91c2VEb3duRXZlbnQsIE1vdXNlVXBFdmVudCwgTW91c2VNb3ZlRXZlbnQsIE1vdXNlT3V0RXZlbnQsIE1vdXNlT3ZlckV2ZW50LCBDbGlja0V2ZW50LCBEb3VibGVDbGlja0V2ZW50LCBXaGVlbEV2ZW50LCBNb3VzZVdoZWVsRXZlbnQsIFRvdWNoU3RhcnRFdmVudCwgVG91Y2hNb3ZlRXZlbnQsIFRvdWNoRW5kRXZlbnRdO1xuY29uc3QgVG9vbHRpcFNob3dFdmVudCA9IFBvaW50ZXJNb3ZlRXZlbnQ7XG5jb25zdCBUb29sdGlwSGlkZUV2ZW50ID0gTW91c2VPdXRFdmVudDtcbmNvbnN0IEhyZWZFdmVudCA9IENsaWNrRXZlbnQ7XG5cbmNsYXNzIENhbnZhc0hhbmRsZXIgZXh0ZW5kcyBIYW5kbGVyIHtcbiAgY29uc3RydWN0b3IobG9hZGVyLCB0b29sdGlwKSB7XG4gICAgc3VwZXIobG9hZGVyLCB0b29sdGlwKTtcbiAgICB0aGlzLl9kb3duID0gbnVsbDtcbiAgICB0aGlzLl90b3VjaCA9IG51bGw7XG4gICAgdGhpcy5fZmlyc3QgPSB0cnVlO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gICAgLy8gc3VwcG9ydGVkIGV2ZW50c1xuICAgIHRoaXMuZXZlbnRzID0gRXZlbnRzO1xuICAgIHRoaXMucG9pbnRlcm1vdmUgPSBtb3ZlKFtQb2ludGVyTW92ZUV2ZW50LCBNb3VzZU1vdmVFdmVudF0sIFtQb2ludGVyT3ZlckV2ZW50LCBNb3VzZU92ZXJFdmVudF0sIFtQb2ludGVyT3V0RXZlbnQsIE1vdXNlT3V0RXZlbnRdKTtcbiAgICB0aGlzLmRyYWdvdmVyID0gbW92ZShbRHJhZ092ZXJFdmVudF0sIFtEcmFnRW50ZXJFdmVudF0sIFtEcmFnTGVhdmVFdmVudF0pLCB0aGlzLnBvaW50ZXJvdXQgPSBpbmFjdGl2ZShbUG9pbnRlck91dEV2ZW50LCBNb3VzZU91dEV2ZW50XSk7XG4gICAgdGhpcy5kcmFnbGVhdmUgPSBpbmFjdGl2ZShbRHJhZ0xlYXZlRXZlbnRdKTtcbiAgfVxuICBpbml0aWFsaXplKGVsLCBvcmlnaW4sIG9iaikge1xuICAgIHRoaXMuX2NhbnZhcyA9IGVsICYmIGRvbUZpbmQoZWwsICdjYW52YXMnKTtcblxuICAgIC8vIGFkZCBtaW5pbWFsIGV2ZW50cyByZXF1aXJlZCBmb3IgcHJvcGVyIHN0YXRlIG1hbmFnZW1lbnRcbiAgICBbQ2xpY2tFdmVudCwgTW91c2VEb3duRXZlbnQsIFBvaW50ZXJEb3duRXZlbnQsIFBvaW50ZXJNb3ZlRXZlbnQsIFBvaW50ZXJPdXRFdmVudCwgRHJhZ0xlYXZlRXZlbnRdLmZvckVhY2godHlwZSA9PiBldmVudExpc3RlbmVyQ2hlY2sodGhpcywgdHlwZSkpO1xuICAgIHJldHVybiBzdXBlci5pbml0aWFsaXplKGVsLCBvcmlnaW4sIG9iaik7XG4gIH1cblxuICAvLyByZXR1cm4gdGhlIGJhY2tpbmcgY2FudmFzIGluc3RhbmNlXG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzO1xuICB9XG5cbiAgLy8gcmV0cmlldmUgdGhlIGN1cnJlbnQgY2FudmFzIGNvbnRleHRcbiAgY29udGV4dCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gIH1cblxuICAvLyB0byBrZWVwIG9sZCB2ZXJzaW9ucyBvZiBmaXJlZm94IGhhcHB5XG4gIERPTU1vdXNlU2Nyb2xsKGV2dCkge1xuICAgIHRoaXMuZmlyZShNb3VzZVdoZWVsRXZlbnQsIGV2dCk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZ0KSB7XG4gICAgdGhpcy5fZG93biA9IHRoaXMuX2FjdGl2ZTtcbiAgICB0aGlzLmZpcmUoUG9pbnRlckRvd25FdmVudCwgZXZ0KTtcbiAgfVxuICBtb3VzZWRvd24oZXZ0KSB7XG4gICAgdGhpcy5fZG93biA9IHRoaXMuX2FjdGl2ZTtcbiAgICB0aGlzLmZpcmUoTW91c2VEb3duRXZlbnQsIGV2dCk7XG4gIH1cbiAgY2xpY2soZXZ0KSB7XG4gICAgaWYgKHRoaXMuX2Rvd24gPT09IHRoaXMuX2FjdGl2ZSkge1xuICAgICAgdGhpcy5maXJlKENsaWNrRXZlbnQsIGV2dCk7XG4gICAgICB0aGlzLl9kb3duID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgdG91Y2hzdGFydChldnQpIHtcbiAgICB0aGlzLl90b3VjaCA9IHRoaXMucGlja0V2ZW50KGV2dC5jaGFuZ2VkVG91Y2hlc1swXSk7XG4gICAgaWYgKHRoaXMuX2ZpcnN0KSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0aGlzLl90b3VjaDtcbiAgICAgIHRoaXMuX2ZpcnN0ID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuZmlyZShUb3VjaFN0YXJ0RXZlbnQsIGV2dCwgdHJ1ZSk7XG4gIH1cbiAgdG91Y2htb3ZlKGV2dCkge1xuICAgIHRoaXMuZmlyZShUb3VjaE1vdmVFdmVudCwgZXZ0LCB0cnVlKTtcbiAgfVxuICB0b3VjaGVuZChldnQpIHtcbiAgICB0aGlzLmZpcmUoVG91Y2hFbmRFdmVudCwgZXZ0LCB0cnVlKTtcbiAgICB0aGlzLl90b3VjaCA9IG51bGw7XG4gIH1cblxuICAvLyBmaXJlIGFuIGV2ZW50XG4gIGZpcmUodHlwZSwgZXZ0LCB0b3VjaCkge1xuICAgIGNvbnN0IGEgPSB0b3VjaCA/IHRoaXMuX3RvdWNoIDogdGhpcy5fYWN0aXZlLFxuICAgICAgaCA9IHRoaXMuX2hhbmRsZXJzW3R5cGVdO1xuXG4gICAgLy8gc2V0IGV2ZW50IHR5cGUgcmVsYXRpdmUgdG8gc2NlbmVncmFwaCBpdGVtc1xuICAgIGV2dC52ZWdhVHlwZSA9IHR5cGU7XG5cbiAgICAvLyBoYW5kbGUgaHlwZXJsaW5rcyBhbmQgdG9vbHRpcHMgZmlyc3RcbiAgICBpZiAodHlwZSA9PT0gSHJlZkV2ZW50ICYmIGEgJiYgYS5ocmVmKSB7XG4gICAgICB0aGlzLmhhbmRsZUhyZWYoZXZ0LCBhLCBhLmhyZWYpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gVG9vbHRpcFNob3dFdmVudCB8fCB0eXBlID09PSBUb29sdGlwSGlkZUV2ZW50KSB7XG4gICAgICB0aGlzLmhhbmRsZVRvb2x0aXAoZXZ0LCBhLCB0eXBlICE9PSBUb29sdGlwSGlkZUV2ZW50KTtcbiAgICB9XG5cbiAgICAvLyBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgaGFuZGxlcnNcbiAgICBpZiAoaCkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGgubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgaFtpXS5oYW5kbGVyLmNhbGwodGhpcy5fb2JqLCBldnQsIGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGFkZCBhbiBldmVudCBoYW5kbGVyXG4gIG9uKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnMsXG4gICAgICBpID0gdGhpcy5faGFuZGxlckluZGV4KGhbbmFtZV0sIHR5cGUsIGhhbmRsZXIpO1xuICAgIGlmIChpIDwgMCkge1xuICAgICAgZXZlbnRMaXN0ZW5lckNoZWNrKHRoaXMsIHR5cGUpO1xuICAgICAgKGhbbmFtZV0gfHwgKGhbbmFtZV0gPSBbXSkpLnB1c2goe1xuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBoYW5kbGVyOiBoYW5kbGVyXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyByZW1vdmUgYW4gZXZlbnQgaGFuZGxlclxuICBvZmYodHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVyc1tuYW1lXSxcbiAgICAgIGkgPSB0aGlzLl9oYW5kbGVySW5kZXgoaCwgdHlwZSwgaGFuZGxlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgaC5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIHBpY2tFdmVudChldnQpIHtcbiAgICBjb25zdCBwID0gcG9pbnQoZXZ0LCB0aGlzLl9jYW52YXMpLFxuICAgICAgbyA9IHRoaXMuX29yaWdpbjtcbiAgICByZXR1cm4gdGhpcy5waWNrKHRoaXMuX3NjZW5lLCBwWzBdLCBwWzFdLCBwWzBdIC0gb1swXSwgcFsxXSAtIG9bMV0pO1xuICB9XG5cbiAgLy8gZmluZCB0aGUgc2NlbmVncmFwaCBpdGVtIGF0IHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb25cbiAgLy8geCwgeSAtLSB0aGUgYWJzb2x1dGUgeCwgeSBwb2ludGVyIGNvb3JkaW5hdGVzIG9uIHRoZSBjYW52YXMgZWxlbWVudFxuICAvLyBneCwgZ3kgLS0gdGhlIHJlbGF0aXZlIGNvb3JkaW5hdGVzIHdpdGhpbiB0aGUgY3VycmVudCBncm91cFxuICBwaWNrKHNjZW5lLCB4LCB5LCBneCwgZ3kpIHtcbiAgICBjb25zdCBnID0gdGhpcy5jb250ZXh0KCksXG4gICAgICBtYXJrID0gTWFya3Nbc2NlbmUubWFya3R5cGVdO1xuICAgIHJldHVybiBtYXJrLnBpY2suY2FsbCh0aGlzLCBnLCBzY2VuZSwgeCwgeSwgZ3gsIGd5KTtcbiAgfVxufVxuY29uc3QgZXZlbnRCdW5kbGUgPSB0eXBlID0+IHR5cGUgPT09IFRvdWNoU3RhcnRFdmVudCB8fCB0eXBlID09PSBUb3VjaE1vdmVFdmVudCB8fCB0eXBlID09PSBUb3VjaEVuZEV2ZW50ID8gW1RvdWNoU3RhcnRFdmVudCwgVG91Y2hNb3ZlRXZlbnQsIFRvdWNoRW5kRXZlbnRdIDogW3R5cGVdO1xuXG4vLyBsYXppbHkgYWRkIGxpc3RlbmVycyB0byB0aGUgY2FudmFzIGFzIG5lZWRlZFxuZnVuY3Rpb24gZXZlbnRMaXN0ZW5lckNoZWNrKGhhbmRsZXIsIHR5cGUpIHtcbiAgZXZlbnRCdW5kbGUodHlwZSkuZm9yRWFjaChfID0+IGFkZEV2ZW50TGlzdGVuZXIoaGFuZGxlciwgXykpO1xufVxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihoYW5kbGVyLCB0eXBlKSB7XG4gIGNvbnN0IGNhbnZhcyA9IGhhbmRsZXIuY2FudmFzKCk7XG4gIGlmIChjYW52YXMgJiYgIWhhbmRsZXIuX2V2ZW50c1t0eXBlXSkge1xuICAgIGhhbmRsZXIuX2V2ZW50c1t0eXBlXSA9IDE7XG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlclt0eXBlXSA/IGV2dCA9PiBoYW5kbGVyW3R5cGVdKGV2dCkgOiBldnQgPT4gaGFuZGxlci5maXJlKHR5cGUsIGV2dCkpO1xuICB9XG59XG5mdW5jdGlvbiBmaXJlQWxsKGhhbmRsZXIsIHR5cGVzLCBldmVudCkge1xuICB0eXBlcy5mb3JFYWNoKHR5cGUgPT4gaGFuZGxlci5maXJlKHR5cGUsIGV2ZW50KSk7XG59XG5mdW5jdGlvbiBtb3ZlKG1vdmVFdmVudHMsIG92ZXJFdmVudHMsIG91dEV2ZW50cykge1xuICByZXR1cm4gZnVuY3Rpb24gKGV2dCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLl9hY3RpdmUsXG4gICAgICBwID0gdGhpcy5waWNrRXZlbnQoZXZ0KTtcbiAgICBpZiAocCA9PT0gYSkge1xuICAgICAgLy8gYWN0aXZlIGl0ZW0gYW5kIHBpY2tlZCBpdGVtIGFyZSB0aGUgc2FtZVxuICAgICAgZmlyZUFsbCh0aGlzLCBtb3ZlRXZlbnRzLCBldnQpOyAvLyBmaXJlIG1vdmVcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWN0aXZlIGl0ZW0gYW5kIHBpY2tlZCBpdGVtIGFyZSBkaWZmZXJlbnRcbiAgICAgIGlmICghYSB8fCAhYS5leGl0KSB7XG4gICAgICAgIC8vIGZpcmUgb3V0IGZvciBwcmlvciBhY3RpdmUgaXRlbVxuICAgICAgICAvLyBzdXBwcmVzcyBpZiBhY3RpdmUgaXRlbSB3YXMgcmVtb3ZlZCBmcm9tIHNjZW5lXG4gICAgICAgIGZpcmVBbGwodGhpcywgb3V0RXZlbnRzLCBldnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fYWN0aXZlID0gcDsgLy8gc2V0IG5ldyBhY3RpdmUgaXRlbVxuICAgICAgZmlyZUFsbCh0aGlzLCBvdmVyRXZlbnRzLCBldnQpOyAvLyBmaXJlIG92ZXIgZm9yIG5ldyBhY3RpdmUgaXRlbVxuICAgICAgZmlyZUFsbCh0aGlzLCBtb3ZlRXZlbnRzLCBldnQpOyAvLyBmaXJlIG1vdmUgZm9yIG5ldyBhY3RpdmUgaXRlbVxuICAgIH1cbiAgfTtcbn1cbmZ1bmN0aW9uIGluYWN0aXZlKHR5cGVzKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgZmlyZUFsbCh0aGlzLCB0eXBlcywgZXZ0KTtcbiAgICB0aGlzLl9hY3RpdmUgPSBudWxsO1xuICB9O1xufVxuXG5mdW5jdGlvbiBkZXZpY2VQaXhlbFJhdGlvKCkge1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxIDogMTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZSAoY2FudmFzLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yLCBvcHQpIHtcbiAgY29uc3QgaW5ET00gPSB0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnROb2RlICE9IG51bGwsXG4gICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuICAgIHJhdGlvID0gaW5ET00gPyBkZXZpY2VQaXhlbFJhdGlvKCkgOiBzY2FsZUZhY3RvcjtcbiAgY2FudmFzLndpZHRoID0gd2lkdGggKiByYXRpbztcbiAgY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHJhdGlvO1xuICBmb3IgKGNvbnN0IGtleSBpbiBvcHQpIHtcbiAgICBjb250ZXh0W2tleV0gPSBvcHRba2V5XTtcbiAgfVxuICBpZiAoaW5ET00gJiYgcmF0aW8gIT09IDEpIHtcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gIH1cbiAgY29udGV4dC5waXhlbFJhdGlvID0gcmF0aW87XG4gIGNvbnRleHQuc2V0VHJhbnNmb3JtKHJhdGlvLCAwLCAwLCByYXRpbywgcmF0aW8gKiBvcmlnaW5bMF0sIHJhdGlvICogb3JpZ2luWzFdKTtcbiAgcmV0dXJuIGNhbnZhcztcbn1cblxuY2xhc3MgQ2FudmFzUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKGxvYWRlcikge1xuICAgIHN1cGVyKGxvYWRlcik7XG4gICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgIHRoaXMuX3JlZHJhdyA9IGZhbHNlO1xuICAgIHRoaXMuX2RpcnR5ID0gbmV3IEJvdW5kcygpO1xuICAgIHRoaXMuX3RlbXBiID0gbmV3IEJvdW5kcygpO1xuICB9XG4gIGluaXRpYWxpemUoZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IsIG9wdGlvbnMpIHtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl9jYW52YXMgPSB0aGlzLl9vcHRpb25zLmV4dGVybmFsQ29udGV4dCA/IG51bGwgOiBjYW52YXMoMSwgMSwgdGhpcy5fb3B0aW9ucy50eXBlKTsgLy8gaW5zdGFudGlhdGUgYSBzbWFsbCBjYW52YXNcblxuICAgIGlmIChlbCAmJiB0aGlzLl9jYW52YXMpIHtcbiAgICAgIGRvbUNsZWFyKGVsLCAwKS5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuICAgICAgdGhpcy5fY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnbWFya3MnKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIG1ldGhvZCB3aWxsIGludm9rZSByZXNpemUgdG8gc2l6ZSB0aGUgY2FudmFzIGFwcHJvcHJpYXRlbHlcbiAgICByZXR1cm4gc3VwZXIuaW5pdGlhbGl6ZShlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gIH1cbiAgcmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICBzdXBlci5yZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgLy8gY29uZmlndXJlIGNhbnZhcyBzaXplIGFuZCB0cmFuc2Zvcm1cbiAgICAgIHJlc2l6ZSh0aGlzLl9jYW52YXMsIHRoaXMuX3dpZHRoLCB0aGlzLl9oZWlnaHQsIHRoaXMuX29yaWdpbiwgdGhpcy5fc2NhbGUsIHRoaXMuX29wdGlvbnMuY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4dGVybmFsIGNvbnRleHQgbmVlZHMgdG8gYmUgc2NhbGVkIGFuZCBwb3NpdGlvbmVkIHRvIG9yaWdpblxuICAgICAgY29uc3QgY3R4ID0gdGhpcy5fb3B0aW9ucy5leHRlcm5hbENvbnRleHQ7XG4gICAgICBpZiAoIWN0eCkgZXJyb3IoJ0NhbnZhc1JlbmRlcmVyIGlzIG1pc3NpbmcgYSB2YWxpZCBjYW52YXMgb3IgY29udGV4dCcpO1xuICAgICAgY3R4LnNjYWxlKHRoaXMuX3NjYWxlLCB0aGlzLl9zY2FsZSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHRoaXMuX29yaWdpblswXSwgdGhpcy5fb3JpZ2luWzFdKTtcbiAgICB9XG4gICAgdGhpcy5fcmVkcmF3ID0gdHJ1ZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhbnZhcztcbiAgfVxuICBjb250ZXh0KCkge1xuICAgIHJldHVybiB0aGlzLl9vcHRpb25zLmV4dGVybmFsQ29udGV4dCB8fCAodGhpcy5fY2FudmFzID8gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJykgOiBudWxsKTtcbiAgfVxuICBkaXJ0eShpdGVtKSB7XG4gICAgY29uc3QgYiA9IHRoaXMuX3RlbXBiLmNsZWFyKCkudW5pb24oaXRlbS5ib3VuZHMpO1xuICAgIGxldCBnID0gaXRlbS5tYXJrLmdyb3VwO1xuICAgIHdoaWxlIChnKSB7XG4gICAgICBiLnRyYW5zbGF0ZShnLnggfHwgMCwgZy55IHx8IDApO1xuICAgICAgZyA9IGcubWFyay5ncm91cDtcbiAgICB9XG4gICAgdGhpcy5fZGlydHkudW5pb24oYik7XG4gIH1cbiAgX3JlbmRlcihzY2VuZSwgbWFya1R5cGVzKSB7XG4gICAgY29uc3QgZyA9IHRoaXMuY29udGV4dCgpLFxuICAgICAgbyA9IHRoaXMuX29yaWdpbixcbiAgICAgIHcgPSB0aGlzLl93aWR0aCxcbiAgICAgIGggPSB0aGlzLl9oZWlnaHQsXG4gICAgICBkYiA9IHRoaXMuX2RpcnR5LFxuICAgICAgdmIgPSB2aWV3Qm91bmRzKG8sIHcsIGgpO1xuXG4gICAgLy8gc2V0dXBcbiAgICBnLnNhdmUoKTtcbiAgICBjb25zdCBiID0gdGhpcy5fcmVkcmF3IHx8IGRiLmVtcHR5KCkgPyAodGhpcy5fcmVkcmF3ID0gZmFsc2UsIHZiLmV4cGFuZCgxKSkgOiBjbGlwVG9Cb3VuZHMoZywgdmIuaW50ZXJzZWN0KGRiKSwgbyk7XG4gICAgdGhpcy5jbGVhcigtb1swXSwgLW9bMV0sIHcsIGgpO1xuXG4gICAgLy8gcmVuZGVyXG4gICAgdGhpcy5kcmF3KGcsIHNjZW5lLCBiLCBtYXJrVHlwZXMpO1xuXG4gICAgLy8gdGFrZWRvd25cbiAgICBnLnJlc3RvcmUoKTtcbiAgICBkYi5jbGVhcigpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGRyYXcoY3R4LCBzY2VuZSwgYm91bmRzLCBtYXJrVHlwZXMpIHtcbiAgICBpZiAoc2NlbmUubWFya3R5cGUgIT09ICdncm91cCcgJiYgbWFya1R5cGVzICE9IG51bGwgJiYgIW1hcmtUeXBlcy5pbmNsdWRlcyhzY2VuZS5tYXJrdHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbWFyayA9IE1hcmtzW3NjZW5lLm1hcmt0eXBlXTtcbiAgICBpZiAoc2NlbmUuY2xpcCkgY2xpcChjdHgsIHNjZW5lKTtcbiAgICBtYXJrLmRyYXcuY2FsbCh0aGlzLCBjdHgsIHNjZW5lLCBib3VuZHMsIG1hcmtUeXBlcyk7XG4gICAgaWYgKHNjZW5lLmNsaXApIGN0eC5yZXN0b3JlKCk7XG4gIH1cbiAgY2xlYXIoeCwgeSwgdywgaCkge1xuICAgIGNvbnN0IG9wdCA9IHRoaXMuX29wdGlvbnMsXG4gICAgICBnID0gdGhpcy5jb250ZXh0KCk7XG4gICAgaWYgKG9wdC50eXBlICE9PSAncGRmJyAmJiAhb3B0LmV4dGVybmFsQ29udGV4dCkge1xuICAgICAgLy8gY2FsbGluZyBjbGVhciByZWN0IHZvaWRzIHZlY3RvciBvdXRwdXQgaW4gcGRmIG1vZGVcbiAgICAgIC8vIGFuZCBjb3VsZCByZW1vdmUgZXh0ZXJuYWwgY29udGV4dCBjb250ZW50ICgjMjYxNSlcbiAgICAgIGcuY2xlYXJSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fYmdjb2xvciAhPSBudWxsKSB7XG4gICAgICBnLmZpbGxTdHlsZSA9IHRoaXMuX2JnY29sb3I7XG4gICAgICBnLmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICAgIH1cbiAgfVxufVxuY29uc3Qgdmlld0JvdW5kcyA9IChvcmlnaW4sIHdpZHRoLCBoZWlnaHQpID0+IG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCkudHJhbnNsYXRlKC1vcmlnaW5bMF0sIC1vcmlnaW5bMV0pO1xuZnVuY3Rpb24gY2xpcFRvQm91bmRzKGcsIGIsIG9yaWdpbikge1xuICAvLyBleHBhbmQgYm91bmRzIGJ5IDEgcGl4ZWwsIHRoZW4gcm91bmQgdG8gcGl4ZWwgYm91bmRhcmllc1xuICBiLmV4cGFuZCgxKS5yb3VuZCgpO1xuXG4gIC8vIGFsaWduIHRvIGJhc2UgcGl4ZWwgZ3JpZCBpbiBjYXNlIG9mIG5vbi1pbnRlZ2VyIHNjYWxpbmcgKCMyNDI1KVxuICBpZiAoZy5waXhlbFJhdGlvICUgMSkge1xuICAgIGIuc2NhbGUoZy5waXhlbFJhdGlvKS5yb3VuZCgpLnNjYWxlKDEgLyBnLnBpeGVsUmF0aW8pO1xuICB9XG5cbiAgLy8gdG8gYXZvaWQgYXJ0aWZhY3RzIHRyYW5zbGF0ZSBpZiBvcmlnaW4gaGFzIGZyYWN0aW9uYWwgcGl4ZWxzXG4gIGIudHJhbnNsYXRlKC0ob3JpZ2luWzBdICUgMSksIC0ob3JpZ2luWzFdICUgMSkpO1xuXG4gIC8vIHNldCBjbGlwIHBhdGhcbiAgZy5iZWdpblBhdGgoKTtcbiAgZy5yZWN0KGIueDEsIGIueTEsIGIud2lkdGgoKSwgYi5oZWlnaHQoKSk7XG4gIGcuY2xpcCgpO1xuICByZXR1cm4gYjtcbn1cblxuY2xhc3MgU1ZHSGFuZGxlciBleHRlbmRzIEhhbmRsZXIge1xuICBjb25zdHJ1Y3Rvcihsb2FkZXIsIHRvb2x0aXApIHtcbiAgICBzdXBlcihsb2FkZXIsIHRvb2x0aXApO1xuICAgIGNvbnN0IGggPSB0aGlzO1xuICAgIGguX2hyZWZIYW5kbGVyID0gbGlzdGVuZXIoaCwgKGV2dCwgaXRlbSkgPT4ge1xuICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5ocmVmKSBoLmhhbmRsZUhyZWYoZXZ0LCBpdGVtLCBpdGVtLmhyZWYpO1xuICAgIH0pO1xuICAgIGguX3Rvb2x0aXBIYW5kbGVyID0gbGlzdGVuZXIoaCwgKGV2dCwgaXRlbSkgPT4ge1xuICAgICAgaC5oYW5kbGVUb29sdGlwKGV2dCwgaXRlbSwgZXZ0LnR5cGUgIT09IFRvb2x0aXBIaWRlRXZlbnQpO1xuICAgIH0pO1xuICB9XG4gIGluaXRpYWxpemUoZWwsIG9yaWdpbiwgb2JqKSB7XG4gICAgbGV0IHN2ZyA9IHRoaXMuX3N2ZztcbiAgICBpZiAoc3ZnKSB7XG4gICAgICBzdmcucmVtb3ZlRXZlbnRMaXN0ZW5lcihIcmVmRXZlbnQsIHRoaXMuX2hyZWZIYW5kbGVyKTtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKFRvb2x0aXBTaG93RXZlbnQsIHRoaXMuX3Rvb2x0aXBIYW5kbGVyKTtcbiAgICAgIHN2Zy5yZW1vdmVFdmVudExpc3RlbmVyKFRvb2x0aXBIaWRlRXZlbnQsIHRoaXMuX3Rvb2x0aXBIYW5kbGVyKTtcbiAgICB9XG4gICAgdGhpcy5fc3ZnID0gc3ZnID0gZWwgJiYgZG9tRmluZChlbCwgJ3N2ZycpO1xuICAgIGlmIChzdmcpIHtcbiAgICAgIHN2Zy5hZGRFdmVudExpc3RlbmVyKEhyZWZFdmVudCwgdGhpcy5faHJlZkhhbmRsZXIpO1xuICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoVG9vbHRpcFNob3dFdmVudCwgdGhpcy5fdG9vbHRpcEhhbmRsZXIpO1xuICAgICAgc3ZnLmFkZEV2ZW50TGlzdGVuZXIoVG9vbHRpcEhpZGVFdmVudCwgdGhpcy5fdG9vbHRpcEhhbmRsZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuaW5pdGlhbGl6ZShlbCwgb3JpZ2luLCBvYmopO1xuICB9XG4gIGNhbnZhcygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3ZnO1xuICB9XG5cbiAgLy8gYWRkIGFuIGV2ZW50IGhhbmRsZXJcbiAgb24odHlwZSwgaGFuZGxlcikge1xuICAgIGNvbnN0IG5hbWUgPSB0aGlzLmV2ZW50TmFtZSh0eXBlKSxcbiAgICAgIGggPSB0aGlzLl9oYW5kbGVycyxcbiAgICAgIGkgPSB0aGlzLl9oYW5kbGVySW5kZXgoaFtuYW1lXSwgdHlwZSwgaGFuZGxlcik7XG4gICAgaWYgKGkgPCAwKSB7XG4gICAgICBjb25zdCB4ID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICBoYW5kbGVyLFxuICAgICAgICBsaXN0ZW5lcjogbGlzdGVuZXIodGhpcywgaGFuZGxlcilcbiAgICAgIH07XG4gICAgICAoaFtuYW1lXSB8fCAoaFtuYW1lXSA9IFtdKSkucHVzaCh4KTtcbiAgICAgIGlmICh0aGlzLl9zdmcpIHtcbiAgICAgICAgdGhpcy5fc3ZnLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgeC5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gcmVtb3ZlIGFuIGV2ZW50IGhhbmRsZXJcbiAgb2ZmKHR5cGUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBuYW1lID0gdGhpcy5ldmVudE5hbWUodHlwZSksXG4gICAgICBoID0gdGhpcy5faGFuZGxlcnNbbmFtZV0sXG4gICAgICBpID0gdGhpcy5faGFuZGxlckluZGV4KGgsIHR5cGUsIGhhbmRsZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIGlmICh0aGlzLl9zdmcpIHtcbiAgICAgICAgdGhpcy5fc3ZnLnJlbW92ZUV2ZW50TGlzdGVuZXIobmFtZSwgaFtpXS5saXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBoLnNwbGljZShpLCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbn1cblxuLy8gd3JhcCBhbiBldmVudCBsaXN0ZW5lciBmb3IgdGhlIFNWRyBET01cbmNvbnN0IGxpc3RlbmVyID0gKGNvbnRleHQsIGhhbmRsZXIpID0+IGV2dCA9PiB7XG4gIGxldCBpdGVtID0gZXZ0LnRhcmdldC5fX2RhdGFfXztcbiAgaXRlbSA9IEFycmF5LmlzQXJyYXkoaXRlbSkgPyBpdGVtWzBdIDogaXRlbTtcbiAgZXZ0LnZlZ2FUeXBlID0gZXZ0LnR5cGU7XG4gIGhhbmRsZXIuY2FsbChjb250ZXh0Ll9vYmosIGV2dCwgaXRlbSk7XG59O1xuXG5jb25zdCBBUklBX0hJRERFTiA9ICdhcmlhLWhpZGRlbic7XG5jb25zdCBBUklBX0xBQkVMID0gJ2FyaWEtbGFiZWwnO1xuY29uc3QgQVJJQV9ST0xFID0gJ3JvbGUnO1xuY29uc3QgQVJJQV9ST0xFREVTQ1JJUFRJT04gPSAnYXJpYS1yb2xlZGVzY3JpcHRpb24nO1xuY29uc3QgR1JBUEhJQ1NfT0JKRUNUID0gJ2dyYXBoaWNzLW9iamVjdCc7XG5jb25zdCBHUkFQSElDU19TWU1CT0wgPSAnZ3JhcGhpY3Mtc3ltYm9sJztcbmNvbnN0IGJ1bmRsZSA9IChyb2xlLCByb2xlZGVzYywgbGFiZWwpID0+ICh7XG4gIFtBUklBX1JPTEVdOiByb2xlLFxuICBbQVJJQV9ST0xFREVTQ1JJUFRJT05dOiByb2xlZGVzYyxcbiAgW0FSSUFfTEFCRUxdOiBsYWJlbCB8fCB1bmRlZmluZWRcbn0pO1xuXG4vLyB0aGVzZSByb2xlcyBhcmUgY292ZXJlZCBieSByZWxhdGVkIHJvbGVzXG4vLyB3ZSBjYW4gaWdub3JlIHRoZW0sIG5vIG5lZWQgdG8gZ2VuZXJhdGUgYXR0cmlidXRlc1xuY29uc3QgQXJpYUlnbm9yZSA9IHRvU2V0KFsnYXhpcy1kb21haW4nLCAnYXhpcy1ncmlkJywgJ2F4aXMtbGFiZWwnLCAnYXhpcy10aWNrJywgJ2F4aXMtdGl0bGUnLCAnbGVnZW5kLWJhbmQnLCAnbGVnZW5kLWVudHJ5JywgJ2xlZ2VuZC1ncmFkaWVudCcsICdsZWdlbmQtbGFiZWwnLCAnbGVnZW5kLXRpdGxlJywgJ2xlZ2VuZC1zeW1ib2wnLCAndGl0bGUnXSk7XG5cbi8vIGFyaWEgYXR0cmlidXRlIGdlbmVyYXRvcnMgZm9yIGd1aWRlIHJvbGVzXG5jb25zdCBBcmlhR3VpZGVzID0ge1xuICAnYXhpcyc6IHtcbiAgICBkZXNjOiAnYXhpcycsXG4gICAgY2FwdGlvbjogYXhpc0NhcHRpb25cbiAgfSxcbiAgJ2xlZ2VuZCc6IHtcbiAgICBkZXNjOiAnbGVnZW5kJyxcbiAgICBjYXB0aW9uOiBsZWdlbmRDYXB0aW9uXG4gIH0sXG4gICd0aXRsZS10ZXh0Jzoge1xuICAgIGRlc2M6ICd0aXRsZScsXG4gICAgY2FwdGlvbjogaXRlbSA9PiBgVGl0bGUgdGV4dCAnJHt0aXRsZUNhcHRpb24oaXRlbSl9J2BcbiAgfSxcbiAgJ3RpdGxlLXN1YnRpdGxlJzoge1xuICAgIGRlc2M6ICdzdWJ0aXRsZScsXG4gICAgY2FwdGlvbjogaXRlbSA9PiBgU3VidGl0bGUgdGV4dCAnJHt0aXRsZUNhcHRpb24oaXRlbSl9J2BcbiAgfVxufTtcblxuLy8gYXJpYSBwcm9wZXJ0aWVzIGdlbmVyYXRlZCBmb3IgbWFyayBpdGVtIGVuY29kaW5nIGNoYW5uZWxzXG5jb25zdCBBcmlhRW5jb2RlID0ge1xuICBhcmlhUm9sZTogQVJJQV9ST0xFLFxuICBhcmlhUm9sZURlc2NyaXB0aW9uOiBBUklBX1JPTEVERVNDUklQVElPTixcbiAgZGVzY3JpcHRpb246IEFSSUFfTEFCRUxcbn07XG5mdW5jdGlvbiBhcmlhSXRlbUF0dHJpYnV0ZXMoZW1pdCwgaXRlbSkge1xuICBjb25zdCBoaWRlID0gaXRlbS5hcmlhID09PSBmYWxzZTtcbiAgZW1pdChBUklBX0hJRERFTiwgaGlkZSB8fCB1bmRlZmluZWQpO1xuICBpZiAoaGlkZSB8fCBpdGVtLmRlc2NyaXB0aW9uID09IG51bGwpIHtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gQXJpYUVuY29kZSkge1xuICAgICAgZW1pdChBcmlhRW5jb2RlW3Byb3BdLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCB0eXBlID0gaXRlbS5tYXJrLm1hcmt0eXBlO1xuICAgIGVtaXQoQVJJQV9MQUJFTCwgaXRlbS5kZXNjcmlwdGlvbik7XG4gICAgZW1pdChBUklBX1JPTEUsIGl0ZW0uYXJpYVJvbGUgfHwgKHR5cGUgPT09ICdncm91cCcgPyBHUkFQSElDU19PQkpFQ1QgOiBHUkFQSElDU19TWU1CT0wpKTtcbiAgICBlbWl0KEFSSUFfUk9MRURFU0NSSVBUSU9OLCBpdGVtLmFyaWFSb2xlRGVzY3JpcHRpb24gfHwgYCR7dHlwZX0gbWFya2ApO1xuICB9XG59XG5mdW5jdGlvbiBhcmlhTWFya0F0dHJpYnV0ZXMobWFyaykge1xuICByZXR1cm4gbWFyay5hcmlhID09PSBmYWxzZSA/IHtcbiAgICBbQVJJQV9ISURERU5dOiB0cnVlXG4gIH0gOiBBcmlhSWdub3JlW21hcmsucm9sZV0gPyBudWxsIDogQXJpYUd1aWRlc1ttYXJrLnJvbGVdID8gYXJpYUd1aWRlKG1hcmssIEFyaWFHdWlkZXNbbWFyay5yb2xlXSkgOiBhcmlhTWFyayhtYXJrKTtcbn1cbmZ1bmN0aW9uIGFyaWFNYXJrKG1hcmspIHtcbiAgY29uc3QgdHlwZSA9IG1hcmsubWFya3R5cGU7XG4gIGNvbnN0IHJlY3Vyc2UgPSB0eXBlID09PSAnZ3JvdXAnIHx8IHR5cGUgPT09ICd0ZXh0JyB8fCBtYXJrLml0ZW1zLnNvbWUoXyA9PiBfLmRlc2NyaXB0aW9uICE9IG51bGwgJiYgXy5hcmlhICE9PSBmYWxzZSk7XG4gIHJldHVybiBidW5kbGUocmVjdXJzZSA/IEdSQVBISUNTX09CSkVDVCA6IEdSQVBISUNTX1NZTUJPTCwgYCR7dHlwZX0gbWFyayBjb250YWluZXJgLCBtYXJrLmRlc2NyaXB0aW9uKTtcbn1cbmZ1bmN0aW9uIGFyaWFHdWlkZShtYXJrLCBvcHQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBpdGVtID0gbWFyay5pdGVtc1swXSxcbiAgICAgIGNhcHRpb24gPSBvcHQuY2FwdGlvbiB8fCAoKCkgPT4gJycpO1xuICAgIHJldHVybiBidW5kbGUob3B0LnJvbGUgfHwgR1JBUEhJQ1NfU1lNQk9MLCBvcHQuZGVzYywgaXRlbS5kZXNjcmlwdGlvbiB8fCBjYXB0aW9uKGl0ZW0pKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHRpdGxlQ2FwdGlvbihpdGVtKSB7XG4gIHJldHVybiBhcnJheShpdGVtLnRleHQpLmpvaW4oJyAnKTtcbn1cbmZ1bmN0aW9uIGF4aXNDYXB0aW9uKGl0ZW0pIHtcbiAgY29uc3QgZGF0dW0gPSBpdGVtLmRhdHVtLFxuICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50LFxuICAgIHRpdGxlID0gZGF0dW0udGl0bGUgPyBleHRyYWN0VGl0bGUoaXRlbSkgOiBudWxsLFxuICAgIGN0eCA9IGl0ZW0uY29udGV4dCxcbiAgICBzY2FsZSA9IGN0eC5zY2FsZXNbZGF0dW0uc2NhbGVdLnZhbHVlLFxuICAgIGxvY2FsZSA9IGN0eC5kYXRhZmxvdy5sb2NhbGUoKSxcbiAgICB0eXBlID0gc2NhbGUudHlwZSxcbiAgICB4eSA9IG9yaWVudCA9PT0gJ2xlZnQnIHx8IG9yaWVudCA9PT0gJ3JpZ2h0JyA/ICdZJyA6ICdYJztcbiAgcmV0dXJuIGAke3h5fS1heGlzYCArICh0aXRsZSA/IGAgdGl0bGVkICcke3RpdGxlfSdgIDogJycpICsgYCBmb3IgYSAke2lzRGlzY3JldGUodHlwZSkgPyAnZGlzY3JldGUnIDogdHlwZX0gc2NhbGVgICsgYCB3aXRoICR7ZG9tYWluQ2FwdGlvbihsb2NhbGUsIHNjYWxlLCBpdGVtKX1gO1xufVxuZnVuY3Rpb24gbGVnZW5kQ2FwdGlvbihpdGVtKSB7XG4gIGNvbnN0IGRhdHVtID0gaXRlbS5kYXR1bSxcbiAgICB0aXRsZSA9IGRhdHVtLnRpdGxlID8gZXh0cmFjdFRpdGxlKGl0ZW0pIDogbnVsbCxcbiAgICB0eXBlID0gYCR7ZGF0dW0udHlwZSB8fCAnJ30gbGVnZW5kYC50cmltKCksXG4gICAgc2NhbGVzID0gZGF0dW0uc2NhbGVzLFxuICAgIHByb3BzID0gT2JqZWN0LmtleXMoc2NhbGVzKSxcbiAgICBjdHggPSBpdGVtLmNvbnRleHQsXG4gICAgc2NhbGUgPSBjdHguc2NhbGVzW3NjYWxlc1twcm9wc1swXV1dLnZhbHVlLFxuICAgIGxvY2FsZSA9IGN0eC5kYXRhZmxvdy5sb2NhbGUoKTtcbiAgcmV0dXJuIGNhcGl0YWxpemUodHlwZSkgKyAodGl0bGUgPyBgIHRpdGxlZCAnJHt0aXRsZX0nYCA6ICcnKSArIGAgZm9yICR7Y2hhbm5lbENhcHRpb24ocHJvcHMpfWAgKyBgIHdpdGggJHtkb21haW5DYXB0aW9uKGxvY2FsZSwgc2NhbGUsIGl0ZW0pfWA7XG59XG5mdW5jdGlvbiBleHRyYWN0VGl0bGUoaXRlbSkge1xuICB0cnkge1xuICAgIHJldHVybiBhcnJheShwZWVrKGl0ZW0uaXRlbXMpLml0ZW1zWzBdLnRleHQpLmpvaW4oJyAnKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNoYW5uZWxDYXB0aW9uKHByb3BzKSB7XG4gIHByb3BzID0gcHJvcHMubWFwKHAgPT4gcCArIChwID09PSAnZmlsbCcgfHwgcCA9PT0gJ3N0cm9rZScgPyAnIGNvbG9yJyA6ICcnKSk7XG4gIHJldHVybiBwcm9wcy5sZW5ndGggPCAyID8gcHJvcHNbMF0gOiBwcm9wcy5zbGljZSgwLCAtMSkuam9pbignLCAnKSArICcgYW5kICcgKyBwZWVrKHByb3BzKTtcbn1cbmZ1bmN0aW9uIGNhcGl0YWxpemUocykge1xuICByZXR1cm4gcy5sZW5ndGggPyBzWzBdLnRvVXBwZXJDYXNlKCkgKyBzLnNsaWNlKDEpIDogcztcbn1cblxuY29uc3QgaW5uZXJUZXh0ID0gdmFsID0+ICh2YWwgKyAnJykucmVwbGFjZSgvJi9nLCAnJmFtcDsnKS5yZXBsYWNlKC88L2csICcmbHQ7JykucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xuY29uc3QgYXR0clRleHQgPSB2YWwgPT4gaW5uZXJUZXh0KHZhbCkucmVwbGFjZSgvXCIvZywgJyZxdW90OycpLnJlcGxhY2UoL1xcdC9nLCAnJiN4OTsnKS5yZXBsYWNlKC9cXG4vZywgJyYjeEE7JykucmVwbGFjZSgvXFxyL2csICcmI3hEOycpO1xuZnVuY3Rpb24gbWFya3VwKCkge1xuICBsZXQgYnVmID0gJycsXG4gICAgb3V0ZXIgPSAnJyxcbiAgICBpbm5lciA9ICcnO1xuICBjb25zdCBzdGFjayA9IFtdLFxuICAgIGNsZWFyID0gKCkgPT4gb3V0ZXIgPSBpbm5lciA9ICcnLFxuICAgIHB1c2ggPSB0YWcgPT4ge1xuICAgICAgaWYgKG91dGVyKSB7XG4gICAgICAgIGJ1ZiArPSBgJHtvdXRlcn0+JHtpbm5lcn1gO1xuICAgICAgICBjbGVhcigpO1xuICAgICAgfVxuICAgICAgc3RhY2sucHVzaCh0YWcpO1xuICAgIH0sXG4gICAgYXR0ciA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwpIG91dGVyICs9IGAgJHtuYW1lfT1cIiR7YXR0clRleHQodmFsdWUpfVwiYDtcbiAgICAgIHJldHVybiBtO1xuICAgIH0sXG4gICAgbSA9IHtcbiAgICAgIG9wZW4odGFnKSB7XG4gICAgICAgIHB1c2godGFnKTtcbiAgICAgICAgb3V0ZXIgPSAnPCcgKyB0YWc7XG4gICAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhdHRycyA9IG5ldyBBcnJheShfbGVuID4gMSA/IF9sZW4gLSAxIDogMCksIF9rZXkgPSAxOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICAgICAgYXR0cnNbX2tleSAtIDFdID0gYXJndW1lbnRzW19rZXldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgc2V0IG9mIGF0dHJzKSB7XG4gICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc2V0KSBhdHRyKGtleSwgc2V0W2tleV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBjb25zdCB0YWcgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKG91dGVyKSB7XG4gICAgICAgICAgYnVmICs9IG91dGVyICsgKGlubmVyID8gYD4ke2lubmVyfTwvJHt0YWd9PmAgOiAnLz4nKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gYDwvJHt0YWd9PmA7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXIoKTtcbiAgICAgICAgcmV0dXJuIG07XG4gICAgICB9LFxuICAgICAgYXR0cixcbiAgICAgIHRleHQ6IHQgPT4gKGlubmVyICs9IGlubmVyVGV4dCh0KSwgbSksXG4gICAgICB0b1N0cmluZzogKCkgPT4gYnVmXG4gICAgfTtcbiAgcmV0dXJuIG07XG59XG5jb25zdCBzZXJpYWxpemVYTUwgPSBub2RlID0+IF9zZXJpYWxpemUobWFya3VwKCksIG5vZGUpICsgJyc7XG5mdW5jdGlvbiBfc2VyaWFsaXplKG0sIG5vZGUpIHtcbiAgbS5vcGVuKG5vZGUudGFnTmFtZSk7XG4gIGlmIChub2RlLmhhc0F0dHJpYnV0ZXMoKSkge1xuICAgIGNvbnN0IGF0dHJzID0gbm9kZS5hdHRyaWJ1dGVzLFxuICAgICAgbiA9IGF0dHJzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgbS5hdHRyKGF0dHJzW2ldLm5hbWUsIGF0dHJzW2ldLnZhbHVlKTtcbiAgICB9XG4gIH1cbiAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgY29uc3QgY2hpbGRyZW4gPSBub2RlLmNoaWxkTm9kZXM7XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgY2hpbGQubm9kZVR5cGUgPT09IDMgLy8gdGV4dCBub2RlXG4gICAgICA/IG0udGV4dChjaGlsZC5ub2RlVmFsdWUpIDogX3NlcmlhbGl6ZShtLCBjaGlsZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtLmNsb3NlKCk7XG59XG5cbmNvbnN0IHN0eWxlc0F0dHIgPSB7XG4gIGZpbGw6ICdmaWxsJyxcbiAgZmlsbE9wYWNpdHk6ICdmaWxsLW9wYWNpdHknLFxuICBzdHJva2U6ICdzdHJva2UnLFxuICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICBzdHJva2VXaWR0aDogJ3N0cm9rZS13aWR0aCcsXG4gIHN0cm9rZUNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgc3Ryb2tlSm9pbjogJ3N0cm9rZS1saW5lam9pbicsXG4gIHN0cm9rZURhc2g6ICdzdHJva2UtZGFzaGFycmF5JyxcbiAgc3Ryb2tlRGFzaE9mZnNldDogJ3N0cm9rZS1kYXNob2Zmc2V0JyxcbiAgc3Ryb2tlTWl0ZXJMaW1pdDogJ3N0cm9rZS1taXRlcmxpbWl0JyxcbiAgb3BhY2l0eTogJ29wYWNpdHknXG59O1xuY29uc3Qgc3R5bGVzQ3NzID0ge1xuICBibGVuZDogJ21peC1ibGVuZC1tb2RlJ1xufTtcblxuLy8gZW5zdXJlIG1pdGVyIGxpbWl0IGRlZmF1bHQgaXMgY29uc2lzdGVudCB3aXRoIGNhbnZhcyAoIzI0OTgpXG5jb25zdCByb290QXR0cmlidXRlcyA9IHtcbiAgJ2ZpbGwnOiAnbm9uZScsXG4gICdzdHJva2UtbWl0ZXJsaW1pdCc6IDEwXG59O1xuXG5jb25zdCBSb290SW5kZXggPSAwLFxuICB4bWxucyA9ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zLycsXG4gIHN2Z25zID0gbWV0YWRhdGEueG1sbnM7XG5jbGFzcyBTVkdSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IobG9hZGVyKSB7XG4gICAgc3VwZXIobG9hZGVyKTtcbiAgICB0aGlzLl9kaXJ0eUlEID0gMDtcbiAgICB0aGlzLl9kaXJ0eSA9IFtdO1xuICAgIHRoaXMuX3N2ZyA9IG51bGw7XG4gICAgdGhpcy5fcm9vdCA9IG51bGw7XG4gICAgdGhpcy5fZGVmcyA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhbGl6ZSBhIG5ldyBTVkdSZW5kZXJlciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBlbCAtIFRoZSBjb250YWluaW5nIERPTSBlbGVtZW50IGZvciB0aGUgZGlzcGxheS5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gVGhlIGNvb3JkaW5hdGUgd2lkdGggb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIFRoZSBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBvcmlnaW4gb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogICBUaGUgY29vcmRpbmF0ZSBzeXN0ZW0gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRoaXMgcG9pbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2NhbGVGYWN0b3I9MV0gLSBPcHRpb25hbCBzY2FsZUZhY3RvciBieSB3aGljaCB0byBtdWx0aXBseVxuICAgKiAgIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IHRvIGRldGVybWluZSB0aGUgZmluYWwgcGl4ZWwgc2l6ZS5cbiAgICogQHJldHVybiB7U1ZHUmVuZGVyZXJ9IC0gVGhpcyByZW5kZXJlciBpbnN0YW5jZS5cbiAgICovXG4gIGluaXRpYWxpemUoZWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpIHtcbiAgICAvLyBjcmVhdGUgdGhlIHN2ZyBkZWZpbml0aW9ucyBjYWNoZVxuICAgIHRoaXMuX2RlZnMgPSB7fTtcbiAgICB0aGlzLl9jbGVhckRlZnMoKTtcbiAgICBpZiAoZWwpIHtcbiAgICAgIHRoaXMuX3N2ZyA9IGRvbUNoaWxkKGVsLCAwLCAnc3ZnJywgc3ZnbnMpO1xuICAgICAgdGhpcy5fc3ZnLnNldEF0dHJpYnV0ZU5TKHhtbG5zLCAneG1sbnMnLCBzdmducyk7XG4gICAgICB0aGlzLl9zdmcuc2V0QXR0cmlidXRlTlMoeG1sbnMsICd4bWxuczp4bGluaycsIG1ldGFkYXRhWyd4bWxuczp4bGluayddKTtcbiAgICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ3ZlcnNpb24nLCBtZXRhZGF0YVsndmVyc2lvbiddKTtcbiAgICAgIHRoaXMuX3N2Zy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ21hcmtzJyk7XG4gICAgICBkb21DbGVhcihlbCwgMSk7XG5cbiAgICAgIC8vIHNldCB0aGUgc3ZnIHJvb3QgZ3JvdXBcbiAgICAgIHRoaXMuX3Jvb3QgPSBkb21DaGlsZCh0aGlzLl9zdmcsIFJvb3RJbmRleCwgJ2cnLCBzdmducyk7XG4gICAgICBzZXRBdHRyaWJ1dGVzKHRoaXMuX3Jvb3QsIHJvb3RBdHRyaWJ1dGVzKTtcblxuICAgICAgLy8gZW5zdXJlIG5vIGFkZGl0aW9uYWwgY2hpbGQgZWxlbWVudHNcbiAgICAgIGRvbUNsZWFyKHRoaXMuX3N2ZywgUm9vdEluZGV4ICsgMSk7XG4gICAgfVxuXG4gICAgLy8gc2V0IGJhY2tncm91bmQgY29sb3IgaWYgZGVmaW5lZFxuICAgIHRoaXMuYmFja2dyb3VuZCh0aGlzLl9iZ2NvbG9yKTtcbiAgICByZXR1cm4gc3VwZXIuaW5pdGlhbGl6ZShlbCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gIH1cblxuICAvKipcbiAgICogR2V0IC8gc2V0IHRoZSBiYWNrZ3JvdW5kIGNvbG9yLlxuICAgKi9cbiAgYmFja2dyb3VuZChiZ2NvbG9yKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggJiYgdGhpcy5fc3ZnKSB7XG4gICAgICB0aGlzLl9zdmcuc3R5bGUuc2V0UHJvcGVydHkoJ2JhY2tncm91bmQtY29sb3InLCBiZ2NvbG9yKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmJhY2tncm91bmQoLi4uYXJndW1lbnRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgY29vcmRpbmF0ZSB3aWR0aCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBuZXcgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge1NWR1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2U7XG4gICAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgICBpZiAodGhpcy5fc3ZnKSB7XG4gICAgICBzZXRBdHRyaWJ1dGVzKHRoaXMuX3N2Zywge1xuICAgICAgICB3aWR0aDogdGhpcy5fd2lkdGggKiB0aGlzLl9zY2FsZSxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQgKiB0aGlzLl9zY2FsZSxcbiAgICAgICAgdmlld0JveDogYDAgMCAke3RoaXMuX3dpZHRofSAke3RoaXMuX2hlaWdodH1gXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3Jvb3Quc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCBgdHJhbnNsYXRlKCR7dGhpcy5fb3JpZ2lufSlgKTtcbiAgICB9XG4gICAgdGhpcy5fZGlydHkgPSBbXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBTVkcgZWxlbWVudCBvZiB0aGUgdmlzdWFsaXphdGlvbi5cbiAgICogQHJldHVybiB7RE9NRWxlbWVudH0gLSBUaGUgU1ZHIGVsZW1lbnQuXG4gICAqL1xuICBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3N2ZztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIFNWRyB0ZXh0IHN0cmluZyBmb3IgdGhlIHJlbmRlcmVkIGNvbnRlbnQsXG4gICAqIG9yIG51bGwgaWYgdGhpcyByZW5kZXJlciBpcyBjdXJyZW50bHkgaGVhZGxlc3MuXG4gICAqL1xuICBzdmcoKSB7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgYmcgPSB0aGlzLl9iZ2NvbG9yO1xuICAgIGlmICghc3ZnKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgbm9kZTtcbiAgICBpZiAoYmcpIHtcbiAgICAgIHN2Zy5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICBub2RlID0gZG9tQ2hpbGQoc3ZnLCBSb290SW5kZXgsICdyZWN0Jywgc3ZnbnMpO1xuICAgICAgc2V0QXR0cmlidXRlcyhub2RlLCB7XG4gICAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQsXG4gICAgICAgIGZpbGw6IGJnXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHNlcmlhbGl6ZVhNTChzdmcpO1xuICAgIGlmIChiZykge1xuICAgICAgc3ZnLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgdGhpcy5fc3ZnLnN0eWxlLnNldFByb3BlcnR5KCdiYWNrZ3JvdW5kLWNvbG9yJywgYmcpO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCByZW5kZXJpbmcgbWV0aG9kLlxuICAgKiBAcGFyYW0ge29iamVjdH0gc2NlbmUgLSBUaGUgcm9vdCBtYXJrIG9mIGEgc2NlbmVncmFwaCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7QXJyYXl9IG1hcmtUeXBlcyAtIEFycmF5IG9mIHRoZSBtYXJrIHR5cGVzIHRvIHJlbmRlci5cbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgSWYgdW5kZWZpbmVkLCByZW5kZXIgYWxsIG1hcmsgdHlwZXNcbiAgICovXG4gIF9yZW5kZXIoc2NlbmUsIG1hcmtUeXBlcykge1xuICAgIC8vIHBlcmZvcm0gc3BvdCB1cGRhdGVzIGFuZCByZS1yZW5kZXIgbWFya3VwXG4gICAgaWYgKHRoaXMuX2RpcnR5Q2hlY2soKSkge1xuICAgICAgaWYgKHRoaXMuX2RpcnR5QWxsKSB0aGlzLl9jbGVhckRlZnMoKTtcbiAgICAgIHRoaXMubWFyayh0aGlzLl9yb290LCBzY2VuZSwgdW5kZWZpbmVkLCBtYXJrVHlwZXMpO1xuICAgICAgZG9tQ2xlYXIodGhpcy5fcm9vdCwgMSk7XG4gICAgfVxuICAgIHRoaXMuZGVmcygpO1xuICAgIHRoaXMuX2RpcnR5ID0gW107XG4gICAgKyt0aGlzLl9kaXJ0eUlEO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gLS0gTWFuYWdlIHJlbmRlcmluZyBvZiBpdGVtcyBtYXJrZWQgYXMgZGlydHkgLS1cblxuICAvKipcbiAgICogRmxhZyBhIG1hcmsgaXRlbSBhcyBkaXJ0eS5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIGRpcnR5KGl0ZW0pIHtcbiAgICBpZiAoaXRlbS5kaXJ0eSAhPT0gdGhpcy5fZGlydHlJRCkge1xuICAgICAgaXRlbS5kaXJ0eSA9IHRoaXMuX2RpcnR5SUQ7XG4gICAgICB0aGlzLl9kaXJ0eS5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIG1hcmsgaXRlbSBpcyBjb25zaWRlcmVkIGRpcnR5LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgaXNEaXJ0eShpdGVtKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RpcnR5QWxsIHx8ICFpdGVtLl9zdmcgfHwgIWl0ZW0uX3N2Zy5vd25lclNWR0VsZW1lbnQgfHwgaXRlbS5kaXJ0eSA9PT0gdGhpcy5fZGlydHlJRDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gY2hlY2sgZGlydHkgc3RhdHVzIGFuZCwgaWYgcG9zc2libGUsXG4gICAqIG1ha2UgdGFyZ2V0dGVkIHVwZGF0ZXMgd2l0aG91dCBhIGZ1bGwgcmVuZGVyaW5nIHBhc3MuXG4gICAqL1xuICBfZGlydHlDaGVjaygpIHtcbiAgICB0aGlzLl9kaXJ0eUFsbCA9IHRydWU7XG4gICAgY29uc3QgaXRlbXMgPSB0aGlzLl9kaXJ0eTtcbiAgICBpZiAoIWl0ZW1zLmxlbmd0aCB8fCAhdGhpcy5fZGlydHlJRCkgcmV0dXJuIHRydWU7XG4gICAgY29uc3QgaWQgPSArK3RoaXMuX2RpcnR5SUQ7XG4gICAgbGV0IGl0ZW0sIG1hcmssIHR5cGUsIG1kZWYsIGksIG4sIG87XG4gICAgZm9yIChpID0gMCwgbiA9IGl0ZW1zLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgaXRlbSA9IGl0ZW1zW2ldO1xuICAgICAgbWFyayA9IGl0ZW0ubWFyaztcbiAgICAgIGlmIChtYXJrLm1hcmt0eXBlICE9PSB0eXBlKSB7XG4gICAgICAgIC8vIG1lbW9pemUgbWFyayBpbnN0YW5jZSBsb29rdXBcbiAgICAgICAgdHlwZSA9IG1hcmsubWFya3R5cGU7XG4gICAgICAgIG1kZWYgPSBNYXJrc1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrLnpkaXJ0eSAmJiBtYXJrLmRpcnR5ICE9PSBpZCkge1xuICAgICAgICB0aGlzLl9kaXJ0eUFsbCA9IGZhbHNlO1xuICAgICAgICBkaXJ0eVBhcmVudHMoaXRlbSwgaWQpO1xuICAgICAgICBtYXJrLml0ZW1zLmZvckVhY2goaSA9PiB7XG4gICAgICAgICAgaS5kaXJ0eSA9IGlkO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXJrLnpkaXJ0eSkgY29udGludWU7IC8vIGhhbmRsZSBpbiBzdGFuZGFyZCBkcmF3aW5nIHBhc3NcblxuICAgICAgaWYgKGl0ZW0uZXhpdCkge1xuICAgICAgICAvLyBFWElUXG4gICAgICAgIGlmIChtZGVmLm5lc3RlZCAmJiBtYXJrLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIC8vIGlmIG5lc3RlZCBtYXJrIHdpdGggcmVtYWluaW5nIHBvaW50cywgdXBkYXRlIGluc3RlYWRcbiAgICAgICAgICBvID0gbWFyay5pdGVtc1swXTtcbiAgICAgICAgICBpZiAoby5fc3ZnKSB0aGlzLl91cGRhdGUobWRlZiwgby5fc3ZnLCBvKTtcbiAgICAgICAgfSBlbHNlIGlmIChpdGVtLl9zdmcpIHtcbiAgICAgICAgICAvLyBvdGhlcndpc2UgcmVtb3ZlIGZyb20gRE9NXG4gICAgICAgICAgbyA9IGl0ZW0uX3N2Zy5wYXJlbnROb2RlO1xuICAgICAgICAgIGlmIChvKSBvLnJlbW92ZUNoaWxkKGl0ZW0uX3N2Zyk7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5fc3ZnID0gbnVsbDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpdGVtID0gbWRlZi5uZXN0ZWQgPyBtYXJrLml0ZW1zWzBdIDogaXRlbTtcbiAgICAgIGlmIChpdGVtLl91cGRhdGUgPT09IGlkKSBjb250aW51ZTsgLy8gYWxyZWFkeSB2aXNpdGVkXG5cbiAgICAgIGlmICghaXRlbS5fc3ZnIHx8ICFpdGVtLl9zdmcub3duZXJTVkdFbGVtZW50KSB7XG4gICAgICAgIC8vIEVOVEVSXG4gICAgICAgIHRoaXMuX2RpcnR5QWxsID0gZmFsc2U7XG4gICAgICAgIGRpcnR5UGFyZW50cyhpdGVtLCBpZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJTi1QTEFDRSBVUERBVEVcbiAgICAgICAgdGhpcy5fdXBkYXRlKG1kZWYsIGl0ZW0uX3N2ZywgaXRlbSk7XG4gICAgICB9XG4gICAgICBpdGVtLl91cGRhdGUgPSBpZDtcbiAgICB9XG4gICAgcmV0dXJuICF0aGlzLl9kaXJ0eUFsbDtcbiAgfVxuXG4gIC8vIC0tIENvbnN0cnVjdCAmIG1haW50YWluIHNjZW5lZ3JhcGggdG8gU1ZHIG1hcHBpbmcgLS0tXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHNldCBvZiBtYXJrIGl0ZW1zLlxuICAgKiBAcGFyYW0ge1NWR0VsZW1lbnR9IGVsIC0gVGhlIHBhcmVudCBlbGVtZW50IGluIHRoZSBTVkcgdHJlZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIG1hcmsgcGFyZW50IHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBwcmV2IC0gVGhlIHByZXZpb3VzIHNpYmxpbmcgaW4gdGhlIFNWRyB0cmVlLlxuICAgKiBAcGFyYW0ge0FycmF5fSBtYXJrVHlwZXMgLSBBcnJheSBvZiB0aGUgbWFyayB0eXBlcyB0byByZW5kZXIuXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgIElmIHVuZGVmaW5lZCwgcmVuZGVyIGFsbCBtYXJrIHR5cGVzXG4gICAqL1xuICBtYXJrKGVsLCBzY2VuZSwgcHJldiwgbWFya1R5cGVzKSB7XG4gICAgaWYgKCF0aGlzLmlzRGlydHkoc2NlbmUpKSB7XG4gICAgICByZXR1cm4gc2NlbmUuX3N2ZztcbiAgICB9XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5fc3ZnLFxuICAgICAgbWFya1R5cGUgPSBzY2VuZS5tYXJrdHlwZSxcbiAgICAgIG1kZWYgPSBNYXJrc1ttYXJrVHlwZV0sXG4gICAgICBldmVudHMgPSBzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsLFxuICAgICAgaXNHcm91cCA9IG1kZWYudGFnID09PSAnZyc7XG4gICAgY29uc3QgcGFyZW50ID0gYmluZChzY2VuZSwgZWwsIHByZXYsICdnJywgc3ZnKTtcbiAgICBpZiAobWFya1R5cGUgIT09ICdncm91cCcgJiYgbWFya1R5cGVzICE9IG51bGwgJiYgIW1hcmtUeXBlcy5pbmNsdWRlcyhtYXJrVHlwZSkpIHtcbiAgICAgIGRvbUNsZWFyKHBhcmVudCwgMCk7XG4gICAgICByZXR1cm4gc2NlbmUuX3N2ZztcbiAgICB9XG4gICAgcGFyZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjc3NDbGFzcyhzY2VuZSkpO1xuXG4gICAgLy8gYXBwbHkgYXJpYSBhdHRyaWJ1dGVzIHRvIHBhcmVudCBjb250YWluZXIgZWxlbWVudFxuICAgIGNvbnN0IGFyaWEgPSBhcmlhTWFya0F0dHJpYnV0ZXMoc2NlbmUpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGFyaWEpIHNldEF0dHJpYnV0ZShwYXJlbnQsIGtleSwgYXJpYVtrZXldKTtcbiAgICBpZiAoIWlzR3JvdXApIHtcbiAgICAgIHNldEF0dHJpYnV0ZShwYXJlbnQsICdwb2ludGVyLWV2ZW50cycsIGV2ZW50cyk7XG4gICAgfVxuICAgIHNldEF0dHJpYnV0ZShwYXJlbnQsICdjbGlwLXBhdGgnLCBzY2VuZS5jbGlwID8gY2xpcCQxKHRoaXMsIHNjZW5lLCBzY2VuZS5ncm91cCkgOiBudWxsKTtcbiAgICBsZXQgc2libGluZyA9IG51bGwsXG4gICAgICBpID0gMDtcbiAgICBjb25zdCBwcm9jZXNzID0gaXRlbSA9PiB7XG4gICAgICBjb25zdCBkaXJ0eSA9IHRoaXMuaXNEaXJ0eShpdGVtKSxcbiAgICAgICAgbm9kZSA9IGJpbmQoaXRlbSwgcGFyZW50LCBzaWJsaW5nLCBtZGVmLnRhZywgc3ZnKTtcbiAgICAgIGlmIChkaXJ0eSkge1xuICAgICAgICB0aGlzLl91cGRhdGUobWRlZiwgbm9kZSwgaXRlbSk7XG4gICAgICAgIGlmIChpc0dyb3VwKSByZWN1cnNlKHRoaXMsIG5vZGUsIGl0ZW0sIG1hcmtUeXBlcyk7XG4gICAgICB9XG4gICAgICBzaWJsaW5nID0gbm9kZTtcbiAgICAgICsraTtcbiAgICB9O1xuICAgIGlmIChtZGVmLm5lc3RlZCkge1xuICAgICAgaWYgKHNjZW5lLml0ZW1zLmxlbmd0aCkgcHJvY2VzcyhzY2VuZS5pdGVtc1swXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZpc2l0KHNjZW5lLCBwcm9jZXNzKTtcbiAgICB9XG4gICAgZG9tQ2xlYXIocGFyZW50LCBpKTtcbiAgICByZXR1cm4gcGFyZW50O1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgYXR0cmlidXRlcyBvZiBhbiBTVkcgZWxlbWVudCBmb3IgYSBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtZGVmIC0gVGhlIG1hcmsgZGVmaW5pdGlvbiBvYmplY3RcbiAgICogQHBhcmFtIHtTVkdFbGVtZW50fSBlbCAtIFRoZSBTVkcgZWxlbWVudC5cbiAgICogQHBhcmFtIHtJdGVtfSBpdGVtIC0gVGhlIG1hcmsgaXRlbS5cbiAgICovXG4gIF91cGRhdGUobWRlZiwgZWwsIGl0ZW0pIHtcbiAgICAvLyBzZXQgZG9tIGVsZW1lbnQgYW5kIHZhbHVlcyBjYWNoZVxuICAgIC8vIHByb3ZpZGVzIGFjY2VzcyB0byBlbWl0IG1ldGhvZFxuICAgIGVsZW1lbnQgPSBlbDtcbiAgICB2YWx1ZXMgPSBlbC5fX3ZhbHVlc19fO1xuXG4gICAgLy8gYXBwbHkgYXJpYS1zcGVjaWZpYyBwcm9wZXJ0aWVzXG4gICAgYXJpYUl0ZW1BdHRyaWJ1dGVzKGVtaXQsIGl0ZW0pO1xuXG4gICAgLy8gYXBwbHkgc3ZnIGF0dHJpYnV0ZXNcbiAgICBtZGVmLmF0dHIoZW1pdCwgaXRlbSwgdGhpcyk7XG5cbiAgICAvLyBzb21lIG1hcmtzIG5lZWQgc3BlY2lhbCB0cmVhdG1lbnRcbiAgICBjb25zdCBleHRyYSA9IG1hcmtfZXh0cmFzW21kZWYudHlwZV07XG4gICAgaWYgKGV4dHJhKSBleHRyYS5jYWxsKHRoaXMsIG1kZWYsIGVsLCBpdGVtKTtcblxuICAgIC8vIGFwcGx5IHN2ZyBzdHlsZSBhdHRyaWJ1dGVzXG4gICAgLy8gbm90ZTogZWxlbWVudCBzdGF0ZSBtYXkgaGF2ZSBiZWVuIG1vZGlmaWVkIGJ5ICdleHRyYScgbWV0aG9kXG4gICAgaWYgKGVsZW1lbnQpIHRoaXMuc3R5bGUoZWxlbWVudCwgaXRlbSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSBwcmVzZW50YXRpb24gYXR0cmlidXRlcyBvZiBhbiBTVkcgZWxlbWVudCBmb3IgYSBtYXJrIGl0ZW0uXG4gICAqIEBwYXJhbSB7U1ZHRWxlbWVudH0gZWwgLSBUaGUgU1ZHIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7SXRlbX0gaXRlbSAtIFRoZSBtYXJrIGl0ZW0uXG4gICAqL1xuICBzdHlsZShlbCwgaXRlbSkge1xuICAgIGlmIChpdGVtID09IG51bGwpIHJldHVybjtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc3R5bGVzQXR0cikge1xuICAgICAgbGV0IHZhbHVlID0gcHJvcCA9PT0gJ2ZvbnQnID8gZm9udEZhbWlseShpdGVtKSA6IGl0ZW1bcHJvcF07XG4gICAgICBpZiAodmFsdWUgPT09IHZhbHVlc1twcm9wXSkgY29udGludWU7XG4gICAgICBjb25zdCBuYW1lID0gc3R5bGVzQXR0cltwcm9wXTtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc0dyYWRpZW50KHZhbHVlKSkge1xuICAgICAgICAgIHZhbHVlID0gZ3JhZGllbnRSZWYodmFsdWUsIHRoaXMuX2RlZnMuZ3JhZGllbnQsIGhyZWYoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlICsgJycpO1xuICAgICAgfVxuICAgICAgdmFsdWVzW3Byb3BdID0gdmFsdWU7XG4gICAgfVxuICAgIGZvciAoY29uc3QgcHJvcCBpbiBzdHlsZXNDc3MpIHtcbiAgICAgIHNldFN0eWxlKGVsLCBzdHlsZXNDc3NbcHJvcF0sIGl0ZW1bcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW5kZXIgU1ZHIGRlZnMsIGFzIG5lZWRlZC5cbiAgICogTXVzdCBiZSBjYWxsZWQgKmFmdGVyKiBtYXJrcyBoYXZlIGJlZW4gcHJvY2Vzc2VkIHRvIGVuc3VyZSB0aGVcbiAgICogY29sbGVjdGVkIHN0YXRlIGlzIGN1cnJlbnQgYW5kIGFjY3VyYXRlLlxuICAgKi9cbiAgZGVmcygpIHtcbiAgICBjb25zdCBzdmcgPSB0aGlzLl9zdmcsXG4gICAgICBkZWZzID0gdGhpcy5fZGVmcztcbiAgICBsZXQgZWwgPSBkZWZzLmVsLFxuICAgICAgaW5kZXggPSAwO1xuICAgIGZvciAoY29uc3QgaWQgaW4gZGVmcy5ncmFkaWVudCkge1xuICAgICAgaWYgKCFlbCkgZGVmcy5lbCA9IGVsID0gZG9tQ2hpbGQoc3ZnLCBSb290SW5kZXggKyAxLCAnZGVmcycsIHN2Z25zKTtcbiAgICAgIGluZGV4ID0gdXBkYXRlR3JhZGllbnQoZWwsIGRlZnMuZ3JhZGllbnRbaWRdLCBpbmRleCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWQgaW4gZGVmcy5jbGlwcGluZykge1xuICAgICAgaWYgKCFlbCkgZGVmcy5lbCA9IGVsID0gZG9tQ2hpbGQoc3ZnLCBSb290SW5kZXggKyAxLCAnZGVmcycsIHN2Z25zKTtcbiAgICAgIGluZGV4ID0gdXBkYXRlQ2xpcHBpbmcoZWwsIGRlZnMuY2xpcHBpbmdbaWRdLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLy8gY2xlYW4tdXBcbiAgICBpZiAoZWwpIHtcbiAgICAgIGluZGV4ID09PSAwID8gKHN2Zy5yZW1vdmVDaGlsZChlbCksIGRlZnMuZWwgPSBudWxsKSA6IGRvbUNsZWFyKGVsLCBpbmRleCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGRlZnMgY2FjaGVzLlxuICAgKi9cbiAgX2NsZWFyRGVmcygpIHtcbiAgICBjb25zdCBkZWYgPSB0aGlzLl9kZWZzO1xuICAgIGRlZi5ncmFkaWVudCA9IHt9O1xuICAgIGRlZi5jbGlwcGluZyA9IHt9O1xuICB9XG59XG5cbi8vIG1hcmsgYW5jZXN0b3IgY2hhaW4gd2l0aCBhIGRpcnR5IGlkXG5mdW5jdGlvbiBkaXJ0eVBhcmVudHMoaXRlbSwgaWQpIHtcbiAgZm9yICg7IGl0ZW0gJiYgaXRlbS5kaXJ0eSAhPT0gaWQ7IGl0ZW0gPSBpdGVtLm1hcmsuZ3JvdXApIHtcbiAgICBpdGVtLmRpcnR5ID0gaWQ7XG4gICAgaWYgKGl0ZW0ubWFyayAmJiBpdGVtLm1hcmsuZGlydHkgIT09IGlkKSB7XG4gICAgICBpdGVtLm1hcmsuZGlydHkgPSBpZDtcbiAgICB9IGVsc2UgcmV0dXJuO1xuICB9XG59XG5cbi8vIHVwZGF0ZSBncmFkaWVudCBkZWZpbml0aW9uc1xuZnVuY3Rpb24gdXBkYXRlR3JhZGllbnQoZWwsIGdyYWQsIGluZGV4KSB7XG4gIGxldCBpLCBuLCBzdG9wO1xuICBpZiAoZ3JhZC5ncmFkaWVudCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAvLyBTVkcgcmFkaWFsIGdyYWRpZW50cyBhdXRvbWF0aWNhbGx5IHRyYW5zZm9ybSB0byBub3JtYWxpemVkIGJib3hcbiAgICAvLyBjb29yZGluYXRlcywgaW4gYSB3YXkgdGhhdCBpcyBjdW1iZXJzb21lIHRvIHJlcGxpY2F0ZSBpbiBjYW52YXMuXG4gICAgLy8gV2Ugd3JhcCB0aGUgcmFkaWFsIGdyYWRpZW50IGluIGEgcGF0dGVybiBlbGVtZW50LCBhbGxvd2luZyB1cyB0b1xuICAgIC8vIG1haW50YWluIGEgY2lyY3VsYXIgZ3JhZGllbnQgdGhhdCBtYXRjaGVzIHdoYXQgY2FudmFzIHByb3ZpZGVzLlxuICAgIGxldCBwdCA9IGRvbUNoaWxkKGVsLCBpbmRleCsrLCAncGF0dGVybicsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKHB0LCB7XG4gICAgICBpZDogcGF0dGVyblByZWZpeCArIGdyYWQuaWQsXG4gICAgICB2aWV3Qm94OiAnMCwwLDEsMScsXG4gICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgc2xpY2UnXG4gICAgfSk7XG4gICAgcHQgPSBkb21DaGlsZChwdCwgMCwgJ3JlY3QnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhwdCwge1xuICAgICAgd2lkdGg6IDEsXG4gICAgICBoZWlnaHQ6IDEsXG4gICAgICBmaWxsOiBgdXJsKCR7aHJlZigpfSMke2dyYWQuaWR9KWBcbiAgICB9KTtcbiAgICBlbCA9IGRvbUNoaWxkKGVsLCBpbmRleCsrLCAncmFkaWFsR3JhZGllbnQnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhlbCwge1xuICAgICAgaWQ6IGdyYWQuaWQsXG4gICAgICBmeDogZ3JhZC54MSxcbiAgICAgIGZ5OiBncmFkLnkxLFxuICAgICAgZnI6IGdyYWQucjEsXG4gICAgICBjeDogZ3JhZC54MixcbiAgICAgIGN5OiBncmFkLnkyLFxuICAgICAgcjogZ3JhZC5yMlxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGVsID0gZG9tQ2hpbGQoZWwsIGluZGV4KyssICdsaW5lYXJHcmFkaWVudCcsIHN2Z25zKTtcbiAgICBzZXRBdHRyaWJ1dGVzKGVsLCB7XG4gICAgICBpZDogZ3JhZC5pZCxcbiAgICAgIHgxOiBncmFkLngxLFxuICAgICAgeDI6IGdyYWQueDIsXG4gICAgICB5MTogZ3JhZC55MSxcbiAgICAgIHkyOiBncmFkLnkyXG4gICAgfSk7XG4gIH1cbiAgZm9yIChpID0gMCwgbiA9IGdyYWQuc3RvcHMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgc3RvcCA9IGRvbUNoaWxkKGVsLCBpLCAnc3RvcCcsIHN2Z25zKTtcbiAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgZ3JhZC5zdG9wc1tpXS5vZmZzZXQpO1xuICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgZ3JhZC5zdG9wc1tpXS5jb2xvcik7XG4gIH1cbiAgZG9tQ2xlYXIoZWwsIGkpO1xuICByZXR1cm4gaW5kZXg7XG59XG5cbi8vIHVwZGF0ZSBjbGlwcGluZyBwYXRoIGRlZmluaXRpb25zXG5mdW5jdGlvbiB1cGRhdGVDbGlwcGluZyhlbCwgY2xpcCwgaW5kZXgpIHtcbiAgbGV0IG1hc2s7XG4gIGVsID0gZG9tQ2hpbGQoZWwsIGluZGV4LCAnY2xpcFBhdGgnLCBzdmducyk7XG4gIGVsLnNldEF0dHJpYnV0ZSgnaWQnLCBjbGlwLmlkKTtcbiAgaWYgKGNsaXAucGF0aCkge1xuICAgIG1hc2sgPSBkb21DaGlsZChlbCwgMCwgJ3BhdGgnLCBzdmducyk7XG4gICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2QnLCBjbGlwLnBhdGgpO1xuICB9IGVsc2Uge1xuICAgIG1hc2sgPSBkb21DaGlsZChlbCwgMCwgJ3JlY3QnLCBzdmducyk7XG4gICAgc2V0QXR0cmlidXRlcyhtYXNrLCB7XG4gICAgICB4OiAwLFxuICAgICAgeTogMCxcbiAgICAgIHdpZHRoOiBjbGlwLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjbGlwLmhlaWdodFxuICAgIH0pO1xuICB9XG4gIGRvbUNsZWFyKGVsLCAxKTtcbiAgcmV0dXJuIGluZGV4ICsgMTtcbn1cblxuLy8gUmVjdXJzaXZlbHkgcHJvY2VzcyBncm91cCBjb250ZW50cy5cbmZ1bmN0aW9uIHJlY3Vyc2UocmVuZGVyZXIsIGVsLCBncm91cCwgbWFya1R5cGVzKSB7XG4gIC8vIGNoaWxkICdnJyBlbGVtZW50IGlzIHNlY29uZCB0byBsYXN0IGFtb25nIGNoaWxkcmVuIChwYXRoLCBnLCBwYXRoKVxuICAvLyBvdGhlciBjaGlsZHJlbiBoZXJlIGFyZSBmb3JlZ3JvdW5kIGFuZCBiYWNrZ3JvdW5kIHBhdGggZWxlbWVudHNcbiAgZWwgPSBlbC5sYXN0Q2hpbGQucHJldmlvdXNTaWJsaW5nO1xuICBsZXQgcHJldixcbiAgICBpZHggPSAwO1xuICB2aXNpdChncm91cCwgaXRlbSA9PiB7XG4gICAgcHJldiA9IHJlbmRlcmVyLm1hcmsoZWwsIGl0ZW0sIHByZXYsIG1hcmtUeXBlcyk7XG4gICAgKytpZHg7XG4gIH0pO1xuXG4gIC8vIHJlbW92ZSBhbnkgZXh0cmFuZW91cyBET00gZWxlbWVudHNcbiAgZG9tQ2xlYXIoZWwsIDEgKyBpZHgpO1xufVxuXG4vLyBCaW5kIGEgc2NlbmVncmFwaCBpdGVtIHRvIGFuIFNWRyBET00gZWxlbWVudC5cbi8vIENyZWF0ZSBuZXcgU1ZHIGVsZW1lbnRzIGFzIG5lZWRlZC5cbmZ1bmN0aW9uIGJpbmQoaXRlbSwgZWwsIHNpYmxpbmcsIHRhZywgc3ZnKSB7XG4gIGxldCBub2RlID0gaXRlbS5fc3ZnLFxuICAgIGRvYztcblxuICAvLyBjcmVhdGUgYSBuZXcgZG9tIG5vZGUgaWYgbmVlZGVkXG4gIGlmICghbm9kZSkge1xuICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gICAgbm9kZSA9IGRvbUNyZWF0ZShkb2MsIHRhZywgc3ZnbnMpO1xuICAgIGl0ZW0uX3N2ZyA9IG5vZGU7XG4gICAgaWYgKGl0ZW0ubWFyaykge1xuICAgICAgbm9kZS5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICBub2RlLl9fdmFsdWVzX18gPSB7XG4gICAgICAgIGZpbGw6ICdkZWZhdWx0J1xuICAgICAgfTtcblxuICAgICAgLy8gaWYgZ3JvdXAsIGNyZWF0ZSBiYWNrZ3JvdW5kLCBjb250ZW50LCBhbmQgZm9yZWdyb3VuZCBlbGVtZW50c1xuICAgICAgaWYgKHRhZyA9PT0gJ2cnKSB7XG4gICAgICAgIGNvbnN0IGJnID0gZG9tQ3JlYXRlKGRvYywgJ3BhdGgnLCBzdmducyk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoYmcpO1xuICAgICAgICBiZy5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICAgIGNvbnN0IGNnID0gZG9tQ3JlYXRlKGRvYywgJ2cnLCBzdmducyk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2cpO1xuICAgICAgICBjZy5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICAgIGNvbnN0IGZnID0gZG9tQ3JlYXRlKGRvYywgJ3BhdGgnLCBzdmducyk7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZmcpO1xuICAgICAgICBmZy5fX2RhdGFfXyA9IGl0ZW07XG4gICAgICAgIGZnLl9fdmFsdWVzX18gPSB7XG4gICAgICAgICAgZmlsbDogJ2RlZmF1bHQnXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gKHJlLSlpbnNlcnQgaWYgKGEpIG5vdCBjb250YWluZWQgaW4gU1ZHIG9yIChiKSBzaWJsaW5nIG9yZGVyIGhhcyBjaGFuZ2VkXG4gIGlmIChub2RlLm93bmVyU1ZHRWxlbWVudCAhPT0gc3ZnIHx8IHNpYmxpbmdDaGVjayhub2RlLCBzaWJsaW5nKSkge1xuICAgIGVsLmluc2VydEJlZm9yZShub2RlLCBzaWJsaW5nID8gc2libGluZy5uZXh0U2libGluZyA6IGVsLmZpcnN0Q2hpbGQpO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vLyBjaGVjayBpZiB0d28gbm9kZXMgYXJlIG9yZGVyZWQgc2libGluZ3NcbmZ1bmN0aW9uIHNpYmxpbmdDaGVjayhub2RlLCBzaWJsaW5nKSB7XG4gIHJldHVybiBub2RlLnBhcmVudE5vZGUgJiYgbm9kZS5wYXJlbnROb2RlLmNoaWxkTm9kZXMubGVuZ3RoID4gMSAmJiBub2RlLnByZXZpb3VzU2libGluZyAhPSBzaWJsaW5nOyAvLyB0cmVhdCBudWxsL3VuZGVmaW5lZCB0aGUgc2FtZVxufVxuXG4vLyAtLSBTZXQgYXR0cmlidXRlcyAmIHN0eWxlcyBvbiBTVkcgZWxlbWVudHMgLS0tXG5cbmxldCBlbGVtZW50ID0gbnVsbCxcbiAgLy8gdGVtcCB2YXIgZm9yIGN1cnJlbnQgU1ZHIGVsZW1lbnRcbiAgdmFsdWVzID0gbnVsbDsgLy8gdGVtcCB2YXIgZm9yIGN1cnJlbnQgdmFsdWVzIGhhc2hcblxuLy8gRXh0cmEgY29uZmlndXJhdGlvbiBmb3IgY2VydGFpbiBtYXJrIHR5cGVzXG5jb25zdCBtYXJrX2V4dHJhcyA9IHtcbiAgZ3JvdXAobWRlZiwgZWwsIGl0ZW0pIHtcbiAgICBjb25zdCBmZyA9IGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzJdO1xuICAgIHZhbHVlcyA9IGZnLl9fdmFsdWVzX187XG4gICAgbWRlZi5mb3JlZ3JvdW5kKGVtaXQsIGl0ZW0sIHRoaXMpO1xuICAgIHZhbHVlcyA9IGVsLl9fdmFsdWVzX187IC8vIHVzZSBwYXJlbnQncyB2YWx1ZXMgaGFzaFxuICAgIGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzFdO1xuICAgIG1kZWYuY29udGVudChlbWl0LCBpdGVtLCB0aGlzKTtcbiAgICBjb25zdCBiZyA9IGVsZW1lbnQgPSBlbC5jaGlsZE5vZGVzWzBdO1xuICAgIG1kZWYuYmFja2dyb3VuZChlbWl0LCBpdGVtLCB0aGlzKTtcbiAgICBjb25zdCB2YWx1ZSA9IGl0ZW0ubWFyay5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UgPyAnbm9uZScgOiBudWxsO1xuICAgIGlmICh2YWx1ZSAhPT0gdmFsdWVzLmV2ZW50cykge1xuICAgICAgc2V0QXR0cmlidXRlKGZnLCAncG9pbnRlci1ldmVudHMnLCB2YWx1ZSk7XG4gICAgICBzZXRBdHRyaWJ1dGUoYmcsICdwb2ludGVyLWV2ZW50cycsIHZhbHVlKTtcbiAgICAgIHZhbHVlcy5ldmVudHMgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGl0ZW0uc3Ryb2tlRm9yZWdyb3VuZCAmJiBpdGVtLnN0cm9rZSkge1xuICAgICAgY29uc3QgZmlsbCA9IGl0ZW0uZmlsbDtcbiAgICAgIHNldEF0dHJpYnV0ZShmZywgJ2Rpc3BsYXknLCBudWxsKTtcblxuICAgICAgLy8gc2V0IHN0eWxlIG9mIGJhY2tncm91bmRcbiAgICAgIHRoaXMuc3R5bGUoYmcsIGl0ZW0pO1xuICAgICAgc2V0QXR0cmlidXRlKGJnLCAnc3Ryb2tlJywgbnVsbCk7XG5cbiAgICAgIC8vIHNldCBzdHlsZSBvZiBmb3JlZ3JvdW5kXG4gICAgICBpZiAoZmlsbCkgaXRlbS5maWxsID0gbnVsbDtcbiAgICAgIHZhbHVlcyA9IGZnLl9fdmFsdWVzX187XG4gICAgICB0aGlzLnN0eWxlKGZnLCBpdGVtKTtcbiAgICAgIGlmIChmaWxsKSBpdGVtLmZpbGwgPSBmaWxsO1xuXG4gICAgICAvLyBsZWF2ZSBlbGVtZW50IG51bGwgdG8gcHJldmVudCBkb3duc3RyZWFtIHN0eWxpbmdcbiAgICAgIGVsZW1lbnQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBlbnN1cmUgZm9yZWdyb3VuZCBpcyBpZ25vcmVkXG4gICAgICBzZXRBdHRyaWJ1dGUoZmcsICdkaXNwbGF5JywgJ25vbmUnKTtcbiAgICB9XG4gIH0sXG4gIGltYWdlKG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgaWYgKGl0ZW0uc21vb3RoID09PSBmYWxzZSkge1xuICAgICAgc2V0U3R5bGUoZWwsICdpbWFnZS1yZW5kZXJpbmcnLCAnb3B0aW1pemVTcGVlZCcpO1xuICAgICAgc2V0U3R5bGUoZWwsICdpbWFnZS1yZW5kZXJpbmcnLCAncGl4ZWxhdGVkJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0eWxlKGVsLCAnaW1hZ2UtcmVuZGVyaW5nJywgbnVsbCk7XG4gICAgfVxuICB9LFxuICB0ZXh0KG1kZWYsIGVsLCBpdGVtKSB7XG4gICAgY29uc3QgdGwgPSB0ZXh0TGluZXMoaXRlbSk7XG4gICAgbGV0IGtleSwgdmFsdWUsIGRvYywgbGg7XG4gICAgaWYgKGlzQXJyYXkodGwpKSB7XG4gICAgICAvLyBtdWx0aS1saW5lIHRleHRcbiAgICAgIHZhbHVlID0gdGwubWFwKF8gPT4gdGV4dFZhbHVlKGl0ZW0sIF8pKTtcbiAgICAgIGtleSA9IHZhbHVlLmpvaW4oJ1xcbicpOyAvLyBjb250ZW50IGNhY2hlIGtleVxuXG4gICAgICBpZiAoa2V5ICE9PSB2YWx1ZXMudGV4dCkge1xuICAgICAgICBkb21DbGVhcihlbCwgMCk7XG4gICAgICAgIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQ7XG4gICAgICAgIGxoID0gbGluZUhlaWdodChpdGVtKTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaCgodCwgaSkgPT4ge1xuICAgICAgICAgIGNvbnN0IHRzID0gZG9tQ3JlYXRlKGRvYywgJ3RzcGFuJywgc3ZnbnMpO1xuICAgICAgICAgIHRzLl9fZGF0YV9fID0gaXRlbTsgLy8gZGF0YSBiaW5kaW5nXG4gICAgICAgICAgdHMudGV4dENvbnRlbnQgPSB0O1xuICAgICAgICAgIGlmIChpKSB7XG4gICAgICAgICAgICB0cy5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgICAgICAgIHRzLnNldEF0dHJpYnV0ZSgnZHknLCBsaCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKHRzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhbHVlcy50ZXh0ID0ga2V5O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzaW5nbGUtbGluZSB0ZXh0XG4gICAgICB2YWx1ZSA9IHRleHRWYWx1ZShpdGVtLCB0bCk7XG4gICAgICBpZiAodmFsdWUgIT09IHZhbHVlcy50ZXh0KSB7XG4gICAgICAgIGVsLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgIHZhbHVlcy50ZXh0ID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtZmFtaWx5JywgZm9udEZhbWlseShpdGVtKSk7XG4gICAgc2V0QXR0cmlidXRlKGVsLCAnZm9udC1zaXplJywgZm9udFNpemUoaXRlbSkgKyAncHgnKTtcbiAgICBzZXRBdHRyaWJ1dGUoZWwsICdmb250LXN0eWxlJywgaXRlbS5mb250U3R5bGUpO1xuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtdmFyaWFudCcsIGl0ZW0uZm9udFZhcmlhbnQpO1xuICAgIHNldEF0dHJpYnV0ZShlbCwgJ2ZvbnQtd2VpZ2h0JywgaXRlbS5mb250V2VpZ2h0KTtcbiAgfVxufTtcbmZ1bmN0aW9uIGVtaXQobmFtZSwgdmFsdWUsIG5zKSB7XG4gIC8vIGVhcmx5IGV4aXQgaWYgdmFsdWUgaXMgdW5jaGFuZ2VkXG4gIGlmICh2YWx1ZSA9PT0gdmFsdWVzW25hbWVdKSByZXR1cm47XG5cbiAgLy8gdXNlIGFwcHJvcHJpYXRlIG1ldGhvZCBnaXZlbiBuYW1lc3BhY2UgKG5zKVxuICBpZiAobnMpIHtcbiAgICBzZXRBdHRyaWJ1dGVOUyhlbGVtZW50LCBuYW1lLCB2YWx1ZSwgbnMpO1xuICB9IGVsc2Uge1xuICAgIHNldEF0dHJpYnV0ZShlbGVtZW50LCBuYW1lLCB2YWx1ZSk7XG4gIH1cblxuICAvLyBub3RlIGN1cnJlbnQgdmFsdWUgZm9yIGZ1dHVyZSBjb21wYXJpc29uXG4gIHZhbHVlc1tuYW1lXSA9IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0U3R5bGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPT0gdmFsdWVzW25hbWVdKSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgIGVsLnN0eWxlLnJlbW92ZVByb3BlcnR5KG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbC5zdHlsZS5zZXRQcm9wZXJ0eShuYW1lLCB2YWx1ZSArICcnKTtcbiAgICB9XG4gICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMoZWwsIGF0dHJzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGF0dHJzKSB7XG4gICAgc2V0QXR0cmlidXRlKGVsLCBrZXksIGF0dHJzW2tleV0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGUoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gaWYgdmFsdWUgaXMgcHJvdmlkZWQsIHVwZGF0ZSBET00gYXR0cmlidXRlXG4gICAgZWwuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHJlbW92ZSBET00gYXR0cmlidXRlXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVOUyhlbCwgbmFtZSwgdmFsdWUsIG5zKSB7XG4gIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgLy8gaWYgdmFsdWUgaXMgcHJvdmlkZWQsIHVwZGF0ZSBET00gYXR0cmlidXRlXG4gICAgZWwuc2V0QXR0cmlidXRlTlMobnMsIG5hbWUsIHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHJlbW92ZSBET00gYXR0cmlidXRlXG4gICAgZWwucmVtb3ZlQXR0cmlidXRlTlMobnMsIG5hbWUpO1xuICB9XG59XG5mdW5jdGlvbiBocmVmKCkge1xuICBsZXQgbG9jO1xuICByZXR1cm4gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IChsb2MgPSB3aW5kb3cubG9jYXRpb24pLmhhc2ggPyBsb2MuaHJlZi5zbGljZSgwLCAtbG9jLmhhc2gubGVuZ3RoKSA6IGxvYy5ocmVmO1xufVxuXG5jbGFzcyBTVkdTdHJpbmdSZW5kZXJlciBleHRlbmRzIFJlbmRlcmVyIHtcbiAgY29uc3RydWN0b3IobG9hZGVyKSB7XG4gICAgc3VwZXIobG9hZGVyKTtcbiAgICB0aGlzLl90ZXh0ID0gbnVsbDtcbiAgICB0aGlzLl9kZWZzID0ge1xuICAgICAgZ3JhZGllbnQ6IHt9LFxuICAgICAgY2xpcHBpbmc6IHt9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSByZW5kZXJlZCBTVkcgdGV4dCBzdHJpbmcsXG4gICAqIG9yIG51bGwgaWYgcmVuZGVyaW5nIGhhcyBub3QgeWV0IG9jY3VycmVkLlxuICAgKi9cbiAgc3ZnKCkge1xuICAgIHJldHVybiB0aGlzLl90ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlbmRlcmluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICovXG4gIF9yZW5kZXIoc2NlbmUpIHtcbiAgICBjb25zdCBtID0gbWFya3VwKCk7XG5cbiAgICAvLyBzdmcgdGFnXG4gICAgbS5vcGVuKCdzdmcnLCBleHRlbmQoe30sIG1ldGFkYXRhLCB7XG4gICAgICBjbGFzczogJ21hcmtzJyxcbiAgICAgIHdpZHRoOiB0aGlzLl93aWR0aCAqIHRoaXMuX3NjYWxlLFxuICAgICAgaGVpZ2h0OiB0aGlzLl9oZWlnaHQgKiB0aGlzLl9zY2FsZSxcbiAgICAgIHZpZXdCb3g6IGAwIDAgJHt0aGlzLl93aWR0aH0gJHt0aGlzLl9oZWlnaHR9YFxuICAgIH0pKTtcblxuICAgIC8vIGJhY2tncm91bmQsIGlmIGRlZmluZWRcbiAgICBjb25zdCBiZyA9IHRoaXMuX2JnY29sb3I7XG4gICAgaWYgKGJnICYmIGJnICE9PSAndHJhbnNwYXJlbnQnICYmIGJnICE9PSAnbm9uZScpIHtcbiAgICAgIG0ub3BlbigncmVjdCcsIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuX3dpZHRoLFxuICAgICAgICBoZWlnaHQ6IHRoaXMuX2hlaWdodCxcbiAgICAgICAgZmlsbDogYmdcbiAgICAgIH0pLmNsb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gcm9vdCBjb250ZW50IGdyb3VwXG4gICAgbS5vcGVuKCdnJywgcm9vdEF0dHJpYnV0ZXMsIHtcbiAgICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgnICsgdGhpcy5fb3JpZ2luICsgJyknXG4gICAgfSk7XG4gICAgdGhpcy5tYXJrKG0sIHNjZW5lKTtcbiAgICBtLmNsb3NlKCk7IC8vIDwvZz5cblxuICAgIC8vIGRlZnNcbiAgICB0aGlzLmRlZnMobSk7XG5cbiAgICAvLyBnZXQgU1ZHIHRleHQgc3RyaW5nXG4gICAgdGhpcy5fdGV4dCA9IG0uY2xvc2UoKSArICcnO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIHNldCBvZiBtYXJrIGl0ZW1zLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbSAtIFRoZSBtYXJrdXAgY29udGV4dC5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIG1hcmsgcGFyZW50IHRvIHJlbmRlci5cbiAgICovXG4gIG1hcmsobSwgc2NlbmUpIHtcbiAgICBjb25zdCBtZGVmID0gTWFya3Nbc2NlbmUubWFya3R5cGVdLFxuICAgICAgdGFnID0gbWRlZi50YWcsXG4gICAgICBhdHRyTGlzdCA9IFthcmlhSXRlbUF0dHJpYnV0ZXMsIG1kZWYuYXR0cl07XG5cbiAgICAvLyByZW5kZXIgb3BlbmluZyBncm91cCB0YWdcbiAgICBtLm9wZW4oJ2cnLCB7XG4gICAgICAnY2xhc3MnOiBjc3NDbGFzcyhzY2VuZSksXG4gICAgICAnY2xpcC1wYXRoJzogc2NlbmUuY2xpcCA/IGNsaXAkMSh0aGlzLCBzY2VuZSwgc2NlbmUuZ3JvdXApIDogbnVsbFxuICAgIH0sIGFyaWFNYXJrQXR0cmlidXRlcyhzY2VuZSksIHtcbiAgICAgICdwb2ludGVyLWV2ZW50cyc6IHRhZyAhPT0gJ2cnICYmIHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSA/ICdub25lJyA6IG51bGxcbiAgICB9KTtcblxuICAgIC8vIHJlbmRlciBjb250YWluZWQgZWxlbWVudHNcbiAgICBjb25zdCBwcm9jZXNzID0gaXRlbSA9PiB7XG4gICAgICBjb25zdCBocmVmID0gdGhpcy5ocmVmKGl0ZW0pO1xuICAgICAgaWYgKGhyZWYpIG0ub3BlbignYScsIGhyZWYpO1xuICAgICAgbS5vcGVuKHRhZywgdGhpcy5hdHRyKHNjZW5lLCBpdGVtLCBhdHRyTGlzdCwgdGFnICE9PSAnZycgPyB0YWcgOiBudWxsKSk7XG4gICAgICBpZiAodGFnID09PSAndGV4dCcpIHtcbiAgICAgICAgY29uc3QgdGwgPSB0ZXh0TGluZXMoaXRlbSk7XG4gICAgICAgIGlmIChpc0FycmF5KHRsKSkge1xuICAgICAgICAgIC8vIG11bHRpLWxpbmUgdGV4dFxuICAgICAgICAgIGNvbnN0IGF0dHJzID0ge1xuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIGR5OiBsaW5lSGVpZ2h0KGl0ZW0pXG4gICAgICAgICAgfTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBtLm9wZW4oJ3RzcGFuJywgaSA/IGF0dHJzIDogbnVsbCkudGV4dCh0ZXh0VmFsdWUoaXRlbSwgdGxbaV0pKS5jbG9zZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBzaW5nbGUtbGluZSB0ZXh0XG4gICAgICAgICAgbS50ZXh0KHRleHRWYWx1ZShpdGVtLCB0bCkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2cnKSB7XG4gICAgICAgIGNvbnN0IGZvcmUgPSBpdGVtLnN0cm9rZUZvcmVncm91bmQsXG4gICAgICAgICAgZmlsbCA9IGl0ZW0uZmlsbCxcbiAgICAgICAgICBzdHJva2UgPSBpdGVtLnN0cm9rZTtcbiAgICAgICAgaWYgKGZvcmUgJiYgc3Ryb2tlKSB7XG4gICAgICAgICAgaXRlbS5zdHJva2UgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG0ub3BlbigncGF0aCcsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgbWRlZi5iYWNrZ3JvdW5kLCAnYmdyZWN0JykpLmNsb3NlKCk7XG5cbiAgICAgICAgLy8gcmVjdXJzZSBmb3IgZ3JvdXAgY29udGVudFxuICAgICAgICBtLm9wZW4oJ2cnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIG1kZWYuY29udGVudCkpO1xuICAgICAgICB2aXNpdChpdGVtLCBzY2VuZSA9PiB0aGlzLm1hcmsobSwgc2NlbmUpKTtcbiAgICAgICAgbS5jbG9zZSgpO1xuICAgICAgICBpZiAoZm9yZSAmJiBzdHJva2UpIHtcbiAgICAgICAgICBpZiAoZmlsbCkgaXRlbS5maWxsID0gbnVsbDtcbiAgICAgICAgICBpdGVtLnN0cm9rZSA9IHN0cm9rZTtcbiAgICAgICAgICBtLm9wZW4oJ3BhdGgnLCB0aGlzLmF0dHIoc2NlbmUsIGl0ZW0sIG1kZWYuZm9yZWdyb3VuZCwgJ2JncmVjdCcpKS5jbG9zZSgpO1xuICAgICAgICAgIGlmIChmaWxsKSBpdGVtLmZpbGwgPSBmaWxsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0ub3BlbigncGF0aCcsIHRoaXMuYXR0cihzY2VuZSwgaXRlbSwgbWRlZi5mb3JlZ3JvdW5kLCAnYmdmb3JlJykpLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG0uY2xvc2UoKTsgLy8gPC90YWc+XG4gICAgICBpZiAoaHJlZikgbS5jbG9zZSgpOyAvLyA8L2E+XG4gICAgfTtcbiAgICBpZiAobWRlZi5uZXN0ZWQpIHtcbiAgICAgIGlmIChzY2VuZS5pdGVtcyAmJiBzY2VuZS5pdGVtcy5sZW5ndGgpIHByb2Nlc3Moc2NlbmUuaXRlbXNbMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aXNpdChzY2VuZSwgcHJvY2Vzcyk7XG4gICAgfVxuXG4gICAgLy8gcmVuZGVyIGNsb3NpbmcgZ3JvdXAgdGFnXG4gICAgcmV0dXJuIG0uY2xvc2UoKTsgLy8gPC9nPlxuICB9XG5cbiAgLyoqXG4gICAqIEdldCBocmVmIGF0dHJpYnV0ZXMgZm9yIGEgaHlwZXJsaW5rZWQgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgaHJlZihpdGVtKSB7XG4gICAgY29uc3QgaHJlZiA9IGl0ZW0uaHJlZjtcbiAgICBsZXQgYXR0cjtcbiAgICBpZiAoaHJlZikge1xuICAgICAgaWYgKGF0dHIgPSB0aGlzLl9ocmVmcyAmJiB0aGlzLl9ocmVmc1tocmVmXSkge1xuICAgICAgICByZXR1cm4gYXR0cjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2FuaXRpemVVUkwoaHJlZikudGhlbihhdHRyID0+IHtcbiAgICAgICAgICAvLyByZXdyaXRlIHRvIHVzZSB4bGluayBuYW1lc3BhY2VcbiAgICAgICAgICBhdHRyWyd4bGluazpocmVmJ10gPSBhdHRyLmhyZWY7XG4gICAgICAgICAgYXR0ci5ocmVmID0gbnVsbDtcbiAgICAgICAgICAodGhpcy5faHJlZnMgfHwgKHRoaXMuX2hyZWZzID0ge30pKVtocmVmXSA9IGF0dHI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYW4gb2JqZWN0IG9mIFNWRyBhdHRyaWJ1dGVzIGZvciBhIG1hcmsgaXRlbS5cbiAgICogQHBhcmFtIHtvYmplY3R9IHNjZW5lIC0gVGhlIG1hcmsgcGFyZW50LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKiBAcGFyYW0ge2FycmF5fGZ1bmN0aW9ufSBhdHRycyAtIE9uZSBvciBtb3JlIGF0dHJpYnV0ZSBlbWl0dGVycy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyAtIFRoZSB0YWcgYmVpbmcgcmVuZGVyZWQuXG4gICAqL1xuICBhdHRyKHNjZW5lLCBpdGVtLCBhdHRycywgdGFnKSB7XG4gICAgY29uc3Qgb2JqZWN0ID0ge30sXG4gICAgICBlbWl0ID0gKG5hbWUsIHZhbHVlLCBucywgcHJlZml4ZWQpID0+IHtcbiAgICAgICAgb2JqZWN0W3ByZWZpeGVkIHx8IG5hbWVdID0gdmFsdWU7XG4gICAgICB9O1xuXG4gICAgLy8gYXBwbHkgbWFyayBzcGVjaWZpYyBhdHRyaWJ1dGVzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXR0cnMpKSB7XG4gICAgICBhdHRycy5mb3JFYWNoKGZuID0+IGZuKGVtaXQsIGl0ZW0sIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXR0cnMoZW1pdCwgaXRlbSwgdGhpcyk7XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgc3R5bGUgYXR0cmlidXRlc1xuICAgIGlmICh0YWcpIHtcbiAgICAgIHN0eWxlKG9iamVjdCwgaXRlbSwgc2NlbmUsIHRhZywgdGhpcy5fZGVmcyk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVyIFNWRyBkZWZzLCBhcyBuZWVkZWQuXG4gICAqIE11c3QgYmUgY2FsbGVkICphZnRlciogbWFya3MgaGF2ZSBiZWVuIHByb2Nlc3NlZCB0byBlbnN1cmUgdGhlXG4gICAqIGNvbGxlY3RlZCBzdGF0ZSBpcyBjdXJyZW50IGFuZCBhY2N1cmF0ZS5cbiAgICogQHBhcmFtIHtvYmplY3R9IG0gLSBUaGUgbWFya3VwIGNvbnRleHQuXG4gICAqL1xuICBkZWZzKG0pIHtcbiAgICBjb25zdCBncmFkaWVudCA9IHRoaXMuX2RlZnMuZ3JhZGllbnQsXG4gICAgICBjbGlwcGluZyA9IHRoaXMuX2RlZnMuY2xpcHBpbmcsXG4gICAgICBjb3VudCA9IE9iamVjdC5rZXlzKGdyYWRpZW50KS5sZW5ndGggKyBPYmplY3Qua2V5cyhjbGlwcGluZykubGVuZ3RoO1xuICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuOyAvLyBub3RoaW5nIHRvIGRvXG5cbiAgICBtLm9wZW4oJ2RlZnMnKTtcbiAgICBmb3IgKGNvbnN0IGlkIGluIGdyYWRpZW50KSB7XG4gICAgICBjb25zdCBkZWYgPSBncmFkaWVudFtpZF0sXG4gICAgICAgIHN0b3BzID0gZGVmLnN0b3BzO1xuICAgICAgaWYgKGRlZi5ncmFkaWVudCA9PT0gJ3JhZGlhbCcpIHtcbiAgICAgICAgLy8gU1ZHIHJhZGlhbCBncmFkaWVudHMgYXV0b21hdGljYWxseSB0cmFuc2Zvcm0gdG8gbm9ybWFsaXplZCBiYm94XG4gICAgICAgIC8vIGNvb3JkaW5hdGVzLCBpbiBhIHdheSB0aGF0IGlzIGN1bWJlcnNvbWUgdG8gcmVwbGljYXRlIGluIGNhbnZhcy5cbiAgICAgICAgLy8gV2Ugd3JhcCB0aGUgcmFkaWFsIGdyYWRpZW50IGluIGEgcGF0dGVybiBlbGVtZW50LCBhbGxvd2luZyB1cyB0b1xuICAgICAgICAvLyBtYWludGFpbiBhIGNpcmN1bGFyIGdyYWRpZW50IHRoYXQgbWF0Y2hlcyB3aGF0IGNhbnZhcyBwcm92aWRlcy5cblxuICAgICAgICBtLm9wZW4oJ3BhdHRlcm4nLCB7XG4gICAgICAgICAgaWQ6IHBhdHRlcm5QcmVmaXggKyBpZCxcbiAgICAgICAgICB2aWV3Qm94OiAnMCwwLDEsMScsXG4gICAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICAgICAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAneE1pZFlNaWQgc2xpY2UnXG4gICAgICAgIH0pO1xuICAgICAgICBtLm9wZW4oJ3JlY3QnLCB7XG4gICAgICAgICAgd2lkdGg6ICcxJyxcbiAgICAgICAgICBoZWlnaHQ6ICcxJyxcbiAgICAgICAgICBmaWxsOiAndXJsKCMnICsgaWQgKyAnKSdcbiAgICAgICAgfSkuY2xvc2UoKTtcbiAgICAgICAgbS5jbG9zZSgpOyAvLyA8L3BhdHRlcm4+XG5cbiAgICAgICAgbS5vcGVuKCdyYWRpYWxHcmFkaWVudCcsIHtcbiAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgZng6IGRlZi54MSxcbiAgICAgICAgICBmeTogZGVmLnkxLFxuICAgICAgICAgIGZyOiBkZWYucjEsXG4gICAgICAgICAgY3g6IGRlZi54MixcbiAgICAgICAgICBjeTogZGVmLnkyLFxuICAgICAgICAgIHI6IGRlZi5yMlxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG0ub3BlbignbGluZWFyR3JhZGllbnQnLCB7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHgxOiBkZWYueDEsXG4gICAgICAgICAgeDI6IGRlZi54MixcbiAgICAgICAgICB5MTogZGVmLnkxLFxuICAgICAgICAgIHkyOiBkZWYueTJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0b3BzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG0ub3Blbignc3RvcCcsIHtcbiAgICAgICAgICBvZmZzZXQ6IHN0b3BzW2ldLm9mZnNldCxcbiAgICAgICAgICAnc3RvcC1jb2xvcic6IHN0b3BzW2ldLmNvbG9yXG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICBtLmNsb3NlKCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgaWQgaW4gY2xpcHBpbmcpIHtcbiAgICAgIGNvbnN0IGRlZiA9IGNsaXBwaW5nW2lkXTtcbiAgICAgIG0ub3BlbignY2xpcFBhdGgnLCB7XG4gICAgICAgIGlkOiBpZFxuICAgICAgfSk7XG4gICAgICBpZiAoZGVmLnBhdGgpIHtcbiAgICAgICAgbS5vcGVuKCdwYXRoJywge1xuICAgICAgICAgIGQ6IGRlZi5wYXRoXG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtLm9wZW4oJ3JlY3QnLCB7XG4gICAgICAgICAgeDogMCxcbiAgICAgICAgICB5OiAwLFxuICAgICAgICAgIHdpZHRoOiBkZWYud2lkdGgsXG4gICAgICAgICAgaGVpZ2h0OiBkZWYuaGVpZ2h0XG4gICAgICAgIH0pLmNsb3NlKCk7XG4gICAgICB9XG4gICAgICBtLmNsb3NlKCk7XG4gICAgfVxuICAgIG0uY2xvc2UoKTtcbiAgfVxufVxuXG4vLyBIZWxwZXIgZnVuY3Rpb24gZm9yIGF0dHIgZm9yIHN0eWxlIHByZXNlbnRhdGlvbiBhdHRyaWJ1dGVzXG5mdW5jdGlvbiBzdHlsZShzLCBpdGVtLCBzY2VuZSwgdGFnLCBkZWZzKSB7XG4gIGxldCBzdHlsZUxpc3Q7XG4gIGlmIChpdGVtID09IG51bGwpIHJldHVybiBzO1xuICBpZiAodGFnID09PSAnYmdyZWN0JyAmJiBzY2VuZS5pbnRlcmFjdGl2ZSA9PT0gZmFsc2UpIHtcbiAgICBzWydwb2ludGVyLWV2ZW50cyddID0gJ25vbmUnO1xuICB9XG4gIGlmICh0YWcgPT09ICdiZ2ZvcmUnKSB7XG4gICAgaWYgKHNjZW5lLmludGVyYWN0aXZlID09PSBmYWxzZSkge1xuICAgICAgc1sncG9pbnRlci1ldmVudHMnXSA9ICdub25lJztcbiAgICB9XG4gICAgcy5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIGlmIChpdGVtLmZpbGwgIT09IG51bGwpIHJldHVybiBzO1xuICB9XG4gIGlmICh0YWcgPT09ICdpbWFnZScgJiYgaXRlbS5zbW9vdGggPT09IGZhbHNlKSB7XG4gICAgc3R5bGVMaXN0ID0gWydpbWFnZS1yZW5kZXJpbmc6IG9wdGltaXplU3BlZWQ7JywgJ2ltYWdlLXJlbmRlcmluZzogcGl4ZWxhdGVkOyddO1xuICB9XG4gIGlmICh0YWcgPT09ICd0ZXh0Jykge1xuICAgIHNbJ2ZvbnQtZmFtaWx5J10gPSBmb250RmFtaWx5KGl0ZW0pO1xuICAgIHNbJ2ZvbnQtc2l6ZSddID0gZm9udFNpemUoaXRlbSkgKyAncHgnO1xuICAgIHNbJ2ZvbnQtc3R5bGUnXSA9IGl0ZW0uZm9udFN0eWxlO1xuICAgIHNbJ2ZvbnQtdmFyaWFudCddID0gaXRlbS5mb250VmFyaWFudDtcbiAgICBzWydmb250LXdlaWdodCddID0gaXRlbS5mb250V2VpZ2h0O1xuICB9XG4gIGZvciAoY29uc3QgcHJvcCBpbiBzdHlsZXNBdHRyKSB7XG4gICAgbGV0IHZhbHVlID0gaXRlbVtwcm9wXTtcbiAgICBjb25zdCBuYW1lID0gc3R5bGVzQXR0cltwcm9wXTtcbiAgICBpZiAodmFsdWUgPT09ICd0cmFuc3BhcmVudCcgJiYgKG5hbWUgPT09ICdmaWxsJyB8fCBuYW1lID09PSAnc3Ryb2tlJykpIDsgZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaWYgKGlzR3JhZGllbnQodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gZ3JhZGllbnRSZWYodmFsdWUsIGRlZnMuZ3JhZGllbnQsICcnKTtcbiAgICAgIH1cbiAgICAgIHNbbmFtZV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZm9yIChjb25zdCBwcm9wIGluIHN0eWxlc0Nzcykge1xuICAgIGNvbnN0IHZhbHVlID0gaXRlbVtwcm9wXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgc3R5bGVMaXN0ID0gc3R5bGVMaXN0IHx8IFtdO1xuICAgICAgc3R5bGVMaXN0LnB1c2goYCR7c3R5bGVzQ3NzW3Byb3BdfTogJHt2YWx1ZX07YCk7XG4gICAgfVxuICB9XG4gIGlmIChzdHlsZUxpc3QpIHtcbiAgICBzLnN0eWxlID0gc3R5bGVMaXN0LmpvaW4oJyAnKTtcbiAgfVxuICByZXR1cm4gcztcbn1cblxuLyoqXG4gKiBAdHlwZWRlZiB7T2JqZWN0fSBIeWJyaWRSZW5kZXJlck9wdGlvbnNcbiAqXG4gKiBAcHJvcGVydHkge3N0cmluZ1tdfSBbc3ZnTWFya1R5cGVzPVsndGV4dCddXSAtIEFuIGFycmF5IG9mIFNWRyBtYXJrIHR5cGVzIHRvIHJlbmRlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbiB0aGUgU1ZHIGxheWVyLiBBbGwgb3RoZXIgbWFyayB0eXBlc1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWxsIGJlIHJlbmRlcmVkIGluIHRoZSBDYW52YXMgbGF5ZXIuXG4gKiBAcHJvcGVydHkge2Jvb2xlYW59IFtzdmdPblRvcD10cnVlXSAtIEZsYWcgdG8gZGV0ZXJtaW5lIGlmIFNWRyBzaG91bGQgYmUgcmVuZGVyZWQgb24gdG9wLlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVidWc9ZmFsc2VdIC0gRmxhZyB0byBlbmFibGUgb3IgZGlzYWJsZSBkZWJ1Z2dpbmcgbW9kZS4gV2hlbiB0cnVlLFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRvcCBsYXllciB3aWxsIGJlIHN0YWNrZWQgYmVsb3cgdGhlIGJvdHRvbSBsYXllclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0aGVyIHRoYW4gb3ZlcmxhaWQgb24gdG9wLlxuICovXG5cbi8qKiBAdHlwZSB7SHlicmlkUmVuZGVyZXJPcHRpb25zfSAqL1xuY29uc3QgT1BUUyA9IHtcbiAgc3ZnTWFya1R5cGVzOiBbJ3RleHQnXSxcbiAgc3ZnT25Ub3A6IHRydWUsXG4gIGRlYnVnOiBmYWxzZVxufTtcblxuLyoqXG4gKiBDb25maWd1cmUgdGhlIEh5YnJpZFJlbmRlcmVyXG4gKlxuICogQHBhcmFtIHtIeWJyaWRSZW5kZXJlck9wdGlvbnN9IG9wdGlvbnMgLSBIeWJyaWRSZW5kZXJlciBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldEh5YnJpZFJlbmRlcmVyT3B0aW9ucyhvcHRpb25zKSB7XG4gIE9QVFNbJ3N2Z01hcmtUeXBlcyddID0gb3B0aW9ucy5zdmdNYXJrVHlwZXMgPz8gWyd0ZXh0J107XG4gIE9QVFNbJ3N2Z09uVG9wJ10gPSBvcHRpb25zLnN2Z09uVG9wID8/IHRydWU7XG4gIE9QVFNbJ2RlYnVnJ10gPSBvcHRpb25zLmRlYnVnID8/IGZhbHNlO1xufVxuY2xhc3MgSHlicmlkUmVuZGVyZXIgZXh0ZW5kcyBSZW5kZXJlciB7XG4gIGNvbnN0cnVjdG9yKGxvYWRlcikge1xuICAgIHN1cGVyKGxvYWRlcik7XG4gICAgdGhpcy5fc3ZnUmVuZGVyZXIgPSBuZXcgU1ZHUmVuZGVyZXIobG9hZGVyKTtcbiAgICB0aGlzLl9jYW52YXNSZW5kZXJlciA9IG5ldyBDYW52YXNSZW5kZXJlcihsb2FkZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgYSBuZXcgSHlicmlkUmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gZWwgLSBUaGUgY29udGFpbmluZyBET00gZWxlbWVudCBmb3IgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBjb29yZGluYXRlIHdpZHRoIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoZWlnaHQgLSBUaGUgY29vcmRpbmF0ZSBoZWlnaHQgb2YgdGhlIGRpc3BsYXksIGluIHBpeGVscy5cbiAgICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBvcmlnaW4gLSBUaGUgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge0h5YnJpZFJlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2UuXG4gICAqL1xuICBpbml0aWFsaXplKGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKSB7XG4gICAgdGhpcy5fcm9vdF9lbCA9IGRvbUNoaWxkKGVsLCAwLCAnZGl2Jyk7XG4gICAgY29uc3QgYm90dG9tRWwgPSBkb21DaGlsZCh0aGlzLl9yb290X2VsLCAwLCAnZGl2Jyk7XG4gICAgY29uc3QgdG9wRWwgPSBkb21DaGlsZCh0aGlzLl9yb290X2VsLCAxLCAnZGl2Jyk7XG4gICAgdGhpcy5fcm9vdF9lbC5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG5cbiAgICAvLyBTZXQgcG9zaXRpb24gYWJzb2x1dGUgdG8gb3ZlcmxheSBzdmcgb24gdG9wIG9mIGNhbnZhc1xuICAgIGlmICghT1BUUy5kZWJ1Zykge1xuICAgICAgYm90dG9tRWwuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgdG9wRWwuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgdG9wRWwuc3R5bGUudG9wID0gJzAnO1xuICAgICAgdG9wRWwuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgIHRvcEVsLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRvcEVsLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIH1cbiAgICB0aGlzLl9zdmdFbCA9IE9QVFMuc3ZnT25Ub3AgPyB0b3BFbCA6IGJvdHRvbUVsO1xuICAgIHRoaXMuX2NhbnZhc0VsID0gT1BUUy5zdmdPblRvcCA/IGJvdHRvbUVsIDogdG9wRWw7XG5cbiAgICAvLyBwb2ludGVyLWV2ZW50cyB0byBub25lIG9uIFNWRyBsYXllciBzbyB0aGF0IGNhbnZhcyBnZXRzIGFsbCBldmVudHNcbiAgICB0aGlzLl9zdmdFbC5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIHRoaXMuX2NhbnZhc1JlbmRlcmVyLmluaXRpYWxpemUodGhpcy5fY2FudmFzRWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuICAgIHRoaXMuX3N2Z1JlbmRlcmVyLmluaXRpYWxpemUodGhpcy5fc3ZnRWwsIHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuICAgIHJldHVybiBzdXBlci5pbml0aWFsaXplKGVsLCB3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGbGFnIGEgbWFyayBpdGVtIGFzIGRpcnR5LlxuICAgKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgbWFyayBpdGVtLlxuICAgKi9cbiAgZGlydHkoaXRlbSkge1xuICAgIGlmIChPUFRTLnN2Z01hcmtUeXBlcy5pbmNsdWRlcyhpdGVtLm1hcmsubWFya3R5cGUpKSB7XG4gICAgICB0aGlzLl9zdmdSZW5kZXJlci5kaXJ0eShpdGVtKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fY2FudmFzUmVuZGVyZXIuZGlydHkoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIHJlbmRlcmluZyBtZXRob2QuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzY2VuZSAtIFRoZSByb290IG1hcmsgb2YgYSBzY2VuZWdyYXBoIHRvIHJlbmRlci5cbiAgICogQHBhcmFtIHtBcnJheX0gbWFya1R5cGVzIC0gQXJyYXkgb2YgdGhlIG1hcmsgdHlwZXMgdG8gcmVuZGVyLlxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICBJZiB1bmRlZmluZWQsIHJlbmRlciBhbGwgbWFyayB0eXBlc1xuICAgKi9cbiAgX3JlbmRlcihzY2VuZSwgbWFya1R5cGVzKSB7XG4gICAgY29uc3QgYWxsTWFya1R5cGVzID0gbWFya1R5cGVzID8/IFsnYXJjJywgJ2FyZWEnLCAnaW1hZ2UnLCAnbGluZScsICdwYXRoJywgJ3JlY3QnLCAncnVsZScsICdzaGFwZScsICdzeW1ib2wnLCAndGV4dCcsICd0cmFpbCddO1xuICAgIGNvbnN0IGNhbnZhc01hcmtUeXBlcyA9IGFsbE1hcmtUeXBlcy5maWx0ZXIobSA9PiAhT1BUUy5zdmdNYXJrVHlwZXMuaW5jbHVkZXMobSkpO1xuICAgIHRoaXMuX3N2Z1JlbmRlcmVyLnJlbmRlcihzY2VuZSwgT1BUUy5zdmdNYXJrVHlwZXMpO1xuICAgIHRoaXMuX2NhbnZhc1JlbmRlcmVyLnJlbmRlcihzY2VuZSwgY2FudmFzTWFya1R5cGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNpemUgdGhlIGRpc3BsYXkuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3aWR0aCAtIFRoZSBuZXcgY29vcmRpbmF0ZSB3aWR0aCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gVGhlIG5ldyBjb29yZGluYXRlIGhlaWdodCBvZiB0aGUgZGlzcGxheSwgaW4gcGl4ZWxzLlxuICAgKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9yaWdpbiAtIFRoZSBuZXcgb3JpZ2luIG9mIHRoZSBkaXNwbGF5LCBpbiBwaXhlbHMuXG4gICAqICAgVGhlIGNvb3JkaW5hdGUgc3lzdGVtIHdpbGwgYmUgdHJhbnNsYXRlZCB0byB0aGlzIHBvaW50LlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NjYWxlRmFjdG9yPTFdIC0gT3B0aW9uYWwgc2NhbGVGYWN0b3IgYnkgd2hpY2ggdG8gbXVsdGlwbHlcbiAgICogICB0aGUgd2lkdGggYW5kIGhlaWdodCB0byBkZXRlcm1pbmUgdGhlIGZpbmFsIHBpeGVsIHNpemUuXG4gICAqIEByZXR1cm4ge1NWR1JlbmRlcmVyfSAtIFRoaXMgcmVuZGVyZXIgaW5zdGFuY2U7XG4gICAqL1xuICByZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcikge1xuICAgIHN1cGVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBvcmlnaW4sIHNjYWxlRmFjdG9yKTtcbiAgICB0aGlzLl9zdmdSZW5kZXJlci5yZXNpemUod2lkdGgsIGhlaWdodCwgb3JpZ2luLCBzY2FsZUZhY3Rvcik7XG4gICAgdGhpcy5fY2FudmFzUmVuZGVyZXIucmVzaXplKHdpZHRoLCBoZWlnaHQsIG9yaWdpbiwgc2NhbGVGYWN0b3IpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIGJhY2tncm91bmQoYmdjb2xvcikge1xuICAgIC8vIFByb3BhZ2F0ZSBiYWNrZ3JvdW5kIGNvbG9yIHRvIGxvd2VyIGNhbnZhcyByZW5kZXJlclxuICAgIGlmIChPUFRTLnN2Z09uVG9wKSB7XG4gICAgICB0aGlzLl9jYW52YXNSZW5kZXJlci5iYWNrZ3JvdW5kKGJnY29sb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zdmdSZW5kZXJlci5iYWNrZ3JvdW5kKGJnY29sb3IpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuXG5jbGFzcyBIeWJyaWRIYW5kbGVyIGV4dGVuZHMgQ2FudmFzSGFuZGxlciB7XG4gIGNvbnN0cnVjdG9yKGxvYWRlciwgdG9vbHRpcCkge1xuICAgIHN1cGVyKGxvYWRlciwgdG9vbHRpcCk7XG4gIH1cbiAgaW5pdGlhbGl6ZShlbCwgb3JpZ2luLCBvYmopIHtcbiAgICBjb25zdCBjYW52YXMgPSBkb21DaGlsZChkb21DaGlsZChlbCwgMCwgJ2RpdicpLCBPUFRTLnN2Z09uVG9wID8gMCA6IDEsICdkaXYnKTtcbiAgICByZXR1cm4gc3VwZXIuaW5pdGlhbGl6ZShjYW52YXMsIG9yaWdpbiwgb2JqKTtcbiAgfVxufVxuXG5jb25zdCBDYW52YXMgPSAnY2FudmFzJztcbmNvbnN0IEh5YnJpZCA9ICdoeWJyaWQnO1xuY29uc3QgUE5HID0gJ3BuZyc7XG5jb25zdCBTVkcgPSAnc3ZnJztcbmNvbnN0IE5vbmUgPSAnbm9uZSc7XG5jb25zdCBSZW5kZXJUeXBlID0ge1xuICBDYW52YXM6IENhbnZhcyxcbiAgUE5HOiBQTkcsXG4gIFNWRzogU1ZHLFxuICBIeWJyaWQ6IEh5YnJpZCxcbiAgTm9uZTogTm9uZVxufTtcbmNvbnN0IG1vZHVsZXMgPSB7fTtcbm1vZHVsZXNbQ2FudmFzXSA9IG1vZHVsZXNbUE5HXSA9IHtcbiAgcmVuZGVyZXI6IENhbnZhc1JlbmRlcmVyLFxuICBoZWFkbGVzczogQ2FudmFzUmVuZGVyZXIsXG4gIGhhbmRsZXI6IENhbnZhc0hhbmRsZXJcbn07XG5tb2R1bGVzW1NWR10gPSB7XG4gIHJlbmRlcmVyOiBTVkdSZW5kZXJlcixcbiAgaGVhZGxlc3M6IFNWR1N0cmluZ1JlbmRlcmVyLFxuICBoYW5kbGVyOiBTVkdIYW5kbGVyXG59O1xubW9kdWxlc1tIeWJyaWRdID0ge1xuICByZW5kZXJlcjogSHlicmlkUmVuZGVyZXIsXG4gIGhlYWRsZXNzOiBIeWJyaWRSZW5kZXJlcixcbiAgaGFuZGxlcjogSHlicmlkSGFuZGxlclxufTtcbm1vZHVsZXNbTm9uZV0gPSB7fTtcbmZ1bmN0aW9uIHJlbmRlck1vZHVsZShuYW1lLCBfKSB7XG4gIG5hbWUgPSBTdHJpbmcobmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgbW9kdWxlc1tuYW1lXSA9IF87XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG1vZHVsZXNbbmFtZV07XG4gIH1cbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0KHNjZW5lLCBib3VuZHMsIGZpbHRlcikge1xuICBjb25zdCBoaXRzID0gW10sXG4gICAgLy8gaW50ZXJzZWN0aW9uIHJlc3VsdHNcbiAgICBib3ggPSBuZXcgQm91bmRzKCkudW5pb24oYm91bmRzKSxcbiAgICAvLyBkZWZlbnNpdmUgY29weVxuICAgIHR5cGUgPSBzY2VuZS5tYXJrdHlwZTtcbiAgcmV0dXJuIHR5cGUgPyBpbnRlcnNlY3RNYXJrKHNjZW5lLCBib3gsIGZpbHRlciwgaGl0cykgOiB0eXBlID09PSAnZ3JvdXAnID8gaW50ZXJzZWN0R3JvdXAoc2NlbmUsIGJveCwgZmlsdGVyLCBoaXRzKSA6IGVycm9yKCdJbnRlcnNlY3Qgc2NlbmUgbXVzdCBiZSBtYXJrIG5vZGUgb3IgZ3JvdXAgaXRlbS4nKTtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdE1hcmsobWFyaywgYm94LCBmaWx0ZXIsIGhpdHMpIHtcbiAgaWYgKHZpc2l0TWFyayhtYXJrLCBib3gsIGZpbHRlcikpIHtcbiAgICBjb25zdCBpdGVtcyA9IG1hcmsuaXRlbXMsXG4gICAgICB0eXBlID0gbWFyay5tYXJrdHlwZSxcbiAgICAgIG4gPSBpdGVtcy5sZW5ndGg7XG4gICAgbGV0IGkgPSAwO1xuICAgIGlmICh0eXBlID09PSAnZ3JvdXAnKSB7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICBpbnRlcnNlY3RHcm91cChpdGVtc1tpXSwgYm94LCBmaWx0ZXIsIGhpdHMpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGNvbnN0IHRlc3QgPSBNYXJrc1t0eXBlXS5pc2VjdDsgaSA8IG47ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gaXRlbXNbaV07XG4gICAgICAgIGlmIChpbnRlcnNlY3RJdGVtKGl0ZW0sIGJveCwgdGVzdCkpIGhpdHMucHVzaChpdGVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhpdHM7XG59XG5mdW5jdGlvbiB2aXNpdE1hcmsobWFyaywgYm94LCBmaWx0ZXIpIHtcbiAgLy8gcHJvY2VzcyBpZiBib3VuZHMgaW50ZXJzZWN0IGFuZCBpZlxuICAvLyAoMSkgbWFyayBpcyBhIGdyb3VwIG1hcmsgKHNvIHdlIG11c3QgcmVjdXJzZSksIG9yXG4gIC8vICgyKSBtYXJrIGlzIGludGVyYWN0aXZlIGFuZCBwYXNzZXMgZmlsdGVyXG4gIHJldHVybiBtYXJrLmJvdW5kcyAmJiBib3guaW50ZXJzZWN0cyhtYXJrLmJvdW5kcykgJiYgKG1hcmsubWFya3R5cGUgPT09ICdncm91cCcgfHwgbWFyay5pbnRlcmFjdGl2ZSAhPT0gZmFsc2UgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKG1hcmspKSk7XG59XG5mdW5jdGlvbiBpbnRlcnNlY3RHcm91cChncm91cCwgYm94LCBmaWx0ZXIsIGhpdHMpIHtcbiAgLy8gdGVzdCBpbnRlcnNlY3QgYWdhaW5zdCBncm91cFxuICAvLyBza2lwIGdyb3VwcyBieSBkZWZhdWx0IHVubGVzcyBmaWx0ZXIgc2F5cyBvdGhlcndpc2VcbiAgaWYgKGZpbHRlciAmJiBmaWx0ZXIoZ3JvdXAubWFyaykgJiYgaW50ZXJzZWN0SXRlbShncm91cCwgYm94LCBNYXJrcy5ncm91cC5pc2VjdCkpIHtcbiAgICBoaXRzLnB1c2goZ3JvdXApO1xuICB9XG5cbiAgLy8gcmVjdXJzaXZlbHkgdGVzdCBjaGlsZHJlbiBtYXJrc1xuICAvLyB0cmFuc2xhdGUgYm94IHRvIGdyb3VwIGNvb3JkaW5hdGUgc3BhY2VcbiAgY29uc3QgbWFya3MgPSBncm91cC5pdGVtcyxcbiAgICBuID0gbWFya3MgJiYgbWFya3MubGVuZ3RoO1xuICBpZiAobikge1xuICAgIGNvbnN0IHggPSBncm91cC54IHx8IDAsXG4gICAgICB5ID0gZ3JvdXAueSB8fCAwO1xuICAgIGJveC50cmFuc2xhdGUoLXgsIC15KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaW50ZXJzZWN0TWFyayhtYXJrc1tpXSwgYm94LCBmaWx0ZXIsIGhpdHMpO1xuICAgIH1cbiAgICBib3gudHJhbnNsYXRlKHgsIHkpO1xuICB9XG4gIHJldHVybiBoaXRzO1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0SXRlbShpdGVtLCBib3gsIHRlc3QpIHtcbiAgLy8gdGVzdCBib3VuZHMgZW5jbG9zdXJlLCBib3VuZHMgaW50ZXJzZWN0aW9uLCB0aGVuIGRldGFpbGVkIHRlc3RcbiAgY29uc3QgYm91bmRzID0gaXRlbS5ib3VuZHM7XG4gIHJldHVybiBib3guZW5jbG9zZXMoYm91bmRzKSB8fCBib3guaW50ZXJzZWN0cyhib3VuZHMpICYmIHRlc3QoaXRlbSwgYm94KTtcbn1cblxuY29uc3QgY2xpcEJvdW5kcyA9IG5ldyBCb3VuZHMoKTtcbmZ1bmN0aW9uIGJvdW5kQ2xpcCAobWFyaykge1xuICBjb25zdCBjbGlwID0gbWFyay5jbGlwO1xuICBpZiAoaXNGdW5jdGlvbihjbGlwKSkge1xuICAgIGNsaXAoYm91bmRDb250ZXh0KGNsaXBCb3VuZHMuY2xlYXIoKSkpO1xuICB9IGVsc2UgaWYgKGNsaXApIHtcbiAgICBjbGlwQm91bmRzLnNldCgwLCAwLCBtYXJrLmdyb3VwLndpZHRoLCBtYXJrLmdyb3VwLmhlaWdodCk7XG4gIH0gZWxzZSByZXR1cm47XG4gIG1hcmsuYm91bmRzLmludGVyc2VjdChjbGlwQm91bmRzKTtcbn1cblxuY29uc3QgVE9MRVJBTkNFID0gMWUtOTtcbmZ1bmN0aW9uIHNjZW5lRXF1YWwoYSwgYiwga2V5KSB7XG4gIHJldHVybiBhID09PSBiID8gdHJ1ZSA6IGtleSA9PT0gJ3BhdGgnID8gcGF0aEVxdWFsKGEsIGIpIDogYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUgPyArYSA9PT0gK2IgOiBpc051bWJlcihhKSAmJiBpc051bWJlcihiKSA/IE1hdGguYWJzKGEgLSBiKSA8PSBUT0xFUkFOQ0UgOiAhYSB8fCAhYiB8fCAhaXNPYmplY3QoYSkgJiYgIWlzT2JqZWN0KGIpID8gYSA9PSBiIDogb2JqZWN0RXF1YWwoYSwgYik7XG59XG5mdW5jdGlvbiBwYXRoRXF1YWwoYSwgYikge1xuICByZXR1cm4gc2NlbmVFcXVhbChwYXJzZShhKSwgcGFyc2UoYikpO1xufVxuZnVuY3Rpb24gb2JqZWN0RXF1YWwoYSwgYikge1xuICB2YXIga2EgPSBPYmplY3Qua2V5cyhhKSxcbiAgICBrYiA9IE9iamVjdC5rZXlzKGIpLFxuICAgIGtleSxcbiAgICBpO1xuICBpZiAoa2EubGVuZ3RoICE9PSBrYi5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAga2Euc29ydCgpO1xuICBrYi5zb3J0KCk7XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZm9yIChpID0ga2EubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBrZXkgPSBrYVtpXTtcbiAgICBpZiAoIXNjZW5lRXF1YWwoYVtrZXldLCBiW2tleV0sIGtleSkpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHlwZW9mIGEgPT09IHR5cGVvZiBiO1xufVxuXG5mdW5jdGlvbiByZXNldFNWR0RlZklkcygpIHtcbiAgcmVzZXRTVkdDbGlwSWQoKTtcbiAgcmVzZXRTVkdHcmFkaWVudElkKCk7XG59XG5cbmV4cG9ydCB7IEJvdW5kcywgQ2FudmFzSGFuZGxlciwgQ2FudmFzUmVuZGVyZXIsIEdyYWRpZW50LCBHcm91cEl0ZW0sIEhhbmRsZXIsIEh5YnJpZEhhbmRsZXIsIEh5YnJpZFJlbmRlcmVyLCBJdGVtLCBNYXJrcywgUmVuZGVyVHlwZSwgUmVuZGVyZXIsIFJlc291cmNlTG9hZGVyLCBTVkdIYW5kbGVyLCBTVkdSZW5kZXJlciwgU1ZHU3RyaW5nUmVuZGVyZXIsIFNjZW5lZ3JhcGgsIGJvdW5kQ2xpcCwgYm91bmRDb250ZXh0LCBib3VuZEl0ZW0sIGJvdW5kTWFyaywgYm91bmRTdHJva2UsIGRvbUNoaWxkLCBkb21DbGVhciwgZG9tQ3JlYXRlLCBkb21GaW5kLCBmb250LCBmb250RmFtaWx5LCBmb250U2l6ZSwgaW50ZXJzZWN0LCBpbnRlcnNlY3RCb3hMaW5lLCBpbnRlcnNlY3RQYXRoLCBpbnRlcnNlY3RQb2ludCwgaW50ZXJzZWN0UnVsZSwgbGluZUhlaWdodCwgbWFya3VwLCBtdWx0aUxpbmVPZmZzZXQsIGN1cnZlcyBhcyBwYXRoQ3VydmVzLCBwYXRoRXF1YWwsIHBhcnNlIGFzIHBhdGhQYXJzZSwgdmdfcmVjdCBhcyBwYXRoUmVjdGFuZ2xlLCBwYXRoUmVuZGVyLCBzeW1ib2xzIGFzIHBhdGhTeW1ib2xzLCB2Z190cmFpbCBhcyBwYXRoVHJhaWwsIHBvaW50LCByZW5kZXJNb2R1bGUsIHJlc2V0U1ZHQ2xpcElkLCByZXNldFNWR0RlZklkcywgc2NlbmVFcXVhbCwgc2NlbmVGcm9tSlNPTiwgcGlja1Zpc2l0IGFzIHNjZW5lUGlja1Zpc2l0LCBzY2VuZVRvSlNPTiwgdmlzaXQgYXMgc2NlbmVWaXNpdCwgem9yZGVyIGFzIHNjZW5lWk9yZGVyLCBzZXJpYWxpemVYTUwsIHNldEh5YnJpZFJlbmRlcmVyT3B0aW9ucywgdGV4dE1ldHJpY3MgfTtcbiIsImltcG9ydCB7IGJpc2VjdG9yLCB1bmlvbiwgaW50ZXJzZWN0aW9uIH0gZnJvbSAnZDMtYXJyYXknO1xuaW1wb3J0IHsgZmllbGQsIGlzRGF0ZSwgdG9OdW1iZXIsIGlzQXJyYXksIGlucmFuZ2UsIGV4dGVuZCwgYXJyYXksIGVycm9yLCBwZWVrLCBoYXNPd25Qcm9wZXJ0eSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBMaXRlcmFsIH0gZnJvbSAndmVnYS1leHByZXNzaW9uJztcblxuLy8gUmVnaXN0ZXJzIHZlZ2EtdXRpbCBmaWVsZCBhY2Nlc3NvcnMgdG8gcHJvdGVjdCBhZ2FpbnN0IFhTUyBhdHRhY2tzXG5jb25zdCBTRUxFQ1RJT05fR0VUVEVSID0gU3ltYm9sKCd2ZWdhX3NlbGVjdGlvbl9nZXR0ZXInKTtcbmZ1bmN0aW9uIGdldHRlcihmKSB7XG4gIGlmICghZi5nZXR0ZXIgfHwgIWYuZ2V0dGVyW1NFTEVDVElPTl9HRVRURVJdKSB7XG4gICAgZi5nZXR0ZXIgPSBmaWVsZChmLmZpZWxkKTtcbiAgICBmLmdldHRlcltTRUxFQ1RJT05fR0VUVEVSXSA9IHRydWU7XG4gIH1cbiAgcmV0dXJuIGYuZ2V0dGVyO1xufVxuY29uc3QgSW50ZXJzZWN0ID0gJ2ludGVyc2VjdCc7XG5jb25zdCBVbmlvbiA9ICd1bmlvbic7XG5jb25zdCBWbE11bHRpID0gJ3ZsTXVsdGknO1xuY29uc3QgVmxQb2ludCA9ICd2bFBvaW50JztcbmNvbnN0IE9yID0gJ29yJztcbmNvbnN0IEFuZCA9ICdhbmQnO1xuY29uc3QgU2VsZWN0aW9uSWQgPSAnX3Znc2lkXyc7XG5jb25zdCAkc2VsZWN0aW9uSWQgPSBmaWVsZChTZWxlY3Rpb25JZCk7XG5cbmNvbnN0IFRZUEVfRU5VTSA9ICdFJyxcbiAgVFlQRV9SQU5HRV9JTkMgPSAnUicsXG4gIFRZUEVfUkFOR0VfRVhDID0gJ1ItRScsXG4gIFRZUEVfUkFOR0VfTEUgPSAnUi1MRScsXG4gIFRZUEVfUkFOR0VfUkUgPSAnUi1SRScsXG4gIFRZUEVfUFJFRF9MVCA9ICdFLUxUJyxcbiAgVFlQRV9QUkVEX0xURSA9ICdFLUxURScsXG4gIFRZUEVfUFJFRF9HVCA9ICdFLUdUJyxcbiAgVFlQRV9QUkVEX0dURSA9ICdFLUdURScsXG4gIFRZUEVfUFJFRF9WQUxJRCA9ICdFLVZBTElEJyxcbiAgVFlQRV9QUkVEX09ORV9PRiA9ICdFLU9ORScsXG4gIFVOSVRfSU5ERVggPSAnaW5kZXg6dW5pdCc7XG5cbi8vIFRPRE86IHJldmlzaXQgZGF0ZSBjb2VyY2lvbj9cbmZ1bmN0aW9uIHRlc3RQb2ludChkYXR1bSwgZW50cnkpIHtcbiAgdmFyIGZpZWxkcyA9IGVudHJ5LmZpZWxkcyxcbiAgICB2YWx1ZXMgPSBlbnRyeS52YWx1ZXMsXG4gICAgbiA9IGZpZWxkcy5sZW5ndGgsXG4gICAgaSA9IDAsXG4gICAgZHZhbCxcbiAgICBmO1xuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIGYgPSBmaWVsZHNbaV07XG4gICAgZHZhbCA9IGdldHRlcihmKShkYXR1bSk7XG4gICAgaWYgKGlzRGF0ZShkdmFsKSkgZHZhbCA9IHRvTnVtYmVyKGR2YWwpO1xuICAgIGlmIChpc0RhdGUodmFsdWVzW2ldKSkgdmFsdWVzW2ldID0gdG9OdW1iZXIodmFsdWVzW2ldKTtcbiAgICBpZiAoaXNBcnJheSh2YWx1ZXNbaV0pICYmIGlzRGF0ZSh2YWx1ZXNbaV1bMF0pKSB2YWx1ZXNbaV0gPSB2YWx1ZXNbaV0ubWFwKHRvTnVtYmVyKTtcbiAgICBpZiAoZi50eXBlID09PSBUWVBFX0VOVU0pIHtcbiAgICAgIC8vIEVudW1lcmF0ZWQgZmllbGRzIGNhbiBlaXRoZXIgc3BlY2lmeSBpbmRpdmlkdWFsIHZhbHVlcyAoc2luZ2xlL211bHRpIHNlbGVjdGlvbnMpXG4gICAgICAvLyBvciBhbiBhcnJheSBvZiB2YWx1ZXMgKGludGVydmFsIHNlbGVjdGlvbnMpLlxuICAgICAgaWYgKGlzQXJyYXkodmFsdWVzW2ldKSA/ICF2YWx1ZXNbaV0uaW5jbHVkZXMoZHZhbCkgOiBkdmFsICE9PSB2YWx1ZXNbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0lOQykge1xuICAgICAgICBpZiAoIWlucmFuZ2UoZHZhbCwgdmFsdWVzW2ldKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUkFOR0VfUkUpIHtcbiAgICAgICAgLy8gRGlzY3JldGUgc2VsZWN0aW9uIG9mIGJpbnMgdGVzdCB3aXRoaW4gdGhlIHJhbmdlIFtiaW5fc3RhcnQsIGJpbl9lbmQpLlxuICAgICAgICBpZiAoIWlucmFuZ2UoZHZhbCwgdmFsdWVzW2ldLCB0cnVlLCBmYWxzZSkpIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSBUWVBFX1JBTkdFX0VYQykge1xuICAgICAgICAvLyAnUi1FJy8nUi1MRScgaW5jbHVkZWQgZm9yIGNvbXBsZXRlbmVzcy5cbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgZmFsc2UsIGZhbHNlKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUkFOR0VfTEUpIHtcbiAgICAgICAgaWYgKCFpbnJhbmdlKGR2YWwsIHZhbHVlc1tpXSwgZmFsc2UsIHRydWUpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gVFlQRV9QUkVEX0xUKSB7XG4gICAgICAgIGlmIChkdmFsID49IHZhbHVlc1tpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUFJFRF9MVEUpIHtcbiAgICAgICAgaWYgKGR2YWwgPiB2YWx1ZXNbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSBpZiAoZi50eXBlID09PSBUWVBFX1BSRURfR1QpIHtcbiAgICAgICAgaWYgKGR2YWwgPD0gdmFsdWVzW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGYudHlwZSA9PT0gVFlQRV9QUkVEX0dURSkge1xuICAgICAgICBpZiAoZHZhbCA8IHZhbHVlc1tpXSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUFJFRF9WQUxJRCkge1xuICAgICAgICBpZiAoZHZhbCA9PT0gbnVsbCB8fCBpc05hTihkdmFsKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChmLnR5cGUgPT09IFRZUEVfUFJFRF9PTkVfT0YpIHtcbiAgICAgICAgaWYgKHZhbHVlc1tpXS5pbmRleE9mKGR2YWwpID09PSAtMSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBUZXN0cyBpZiBhIHR1cGxlIGlzIGNvbnRhaW5lZCB3aXRoaW4gYW4gaW50ZXJhY3RpdmUgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgZGF0YSBzZXQgcmVwcmVzZW50aW5nIHRoZSBzZWxlY3Rpb24uXG4gKiAgVHVwbGVzIGluIHRoZSBkYXRhc2V0IGFyZSBvZiB0aGUgZm9ybVxuICogIHt1bml0OiBzdHJpbmcsIGZpZWxkczogYXJyYXk8ZmllbGRkZWY+LCB2YWx1ZXM6IGFycmF5PCo+fS5cbiAqICBGaWVsZGRlZiBpcyBvZiB0aGUgZm9ybVxuICogIHtmaWVsZDogc3RyaW5nLCBjaGFubmVsOiBzdHJpbmcsIHR5cGU6ICdFJyB8ICdSJ30gd2hlcmVcbiAqICAndHlwZScgaWRlbnRpZmllcyB3aGV0aGVyIHR1cGxlcyBpbiB0aGUgZGF0YXNldCBlbnVtZXJhdGVcbiAqICB2YWx1ZXMgZm9yIHRoZSBmaWVsZCwgb3Igc3BlY2lmeSBhIGNvbnRpbnVvdXMgcmFuZ2UuXG4gKiBAcGFyYW0ge29iamVjdH0gZGF0dW0gLSBUaGUgdHVwbGUgdG8gdGVzdCBmb3IgaW5jbHVzaW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IG9wIC0gVGhlIHNldCBvcGVyYXRpb24gZm9yIGNvbWJpbmluZyBzZWxlY3Rpb25zLlxuICogICBPbmUgb2YgJ2ludGVyc2VjdCcgb3IgJ3VuaW9uJyAoZGVmYXVsdCkuXG4gKiBAcmV0dXJuIHtib29sZWFufSAtIFRydWUgaWYgdGhlIGRhdHVtIGlzIGluIHRoZSBzZWxlY3Rpb24sIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0aW9uVGVzdChuYW1lLCBkYXR1bSwgb3ApIHtcbiAgdmFyIGRhdGEgPSB0aGlzLmNvbnRleHQuZGF0YVtuYW1lXSxcbiAgICBlbnRyaWVzID0gZGF0YSA/IGRhdGEudmFsdWVzLnZhbHVlIDogW10sXG4gICAgdW5pdElkeCA9IGRhdGEgPyBkYXRhW1VOSVRfSU5ERVhdICYmIGRhdGFbVU5JVF9JTkRFWF0udmFsdWUgOiB1bmRlZmluZWQsXG4gICAgaW50ZXJzZWN0ID0gb3AgPT09IEludGVyc2VjdCxcbiAgICBuID0gZW50cmllcy5sZW5ndGgsXG4gICAgaSA9IDAsXG4gICAgZW50cnksXG4gICAgbWlzcyxcbiAgICBjb3VudCxcbiAgICB1bml0LFxuICAgIGI7XG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgIGlmICh1bml0SWR4ICYmIGludGVyc2VjdCkge1xuICAgICAgLy8gbXVsdGkgc2VsZWN0aW9ucyB1bmlvbiB3aXRoaW4gdGhlIHNhbWUgdW5pdCBhbmQgaW50ZXJzZWN0IGFjcm9zcyB1bml0cy5cbiAgICAgIG1pc3MgPSBtaXNzIHx8IHt9O1xuICAgICAgY291bnQgPSBtaXNzW3VuaXQgPSBlbnRyeS51bml0XSB8fCAwO1xuXG4gICAgICAvLyBpZiB3ZSd2ZSBhbHJlYWR5IG1hdGNoZWQgdGhpcyB1bml0LCBza2lwLlxuICAgICAgaWYgKGNvdW50ID09PSAtMSkgY29udGludWU7XG4gICAgICBiID0gdGVzdFBvaW50KGRhdHVtLCBlbnRyeSk7XG4gICAgICBtaXNzW3VuaXRdID0gYiA/IC0xIDogKytjb3VudDtcblxuICAgICAgLy8gaWYgd2UgbWF0Y2ggYW5kIHRoZXJlIGFyZSBubyBvdGhlciB1bml0cyByZXR1cm4gdHJ1ZVxuICAgICAgLy8gaWYgd2UndmUgbWlzc2VkIGFnYWluc3QgYWxsIHR1cGxlcyBpbiB0aGlzIHVuaXQgcmV0dXJuIGZhbHNlXG4gICAgICBpZiAoYiAmJiB1bml0SWR4LnNpemUgPT09IDEpIHJldHVybiB0cnVlO1xuICAgICAgaWYgKCFiICYmIGNvdW50ID09PSB1bml0SWR4LmdldCh1bml0KS5jb3VudCkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGVzdFBvaW50KGRhdHVtLCBlbnRyeSk7XG5cbiAgICAgIC8vIGlmIHdlIGZpbmQgYSBtaXNzIGFuZCB3ZSBkbyByZXF1aXJlIGludGVyc2VjdGlvbiByZXR1cm4gZmFsc2VcbiAgICAgIC8vIGlmIHdlIGZpbmQgYSBtYXRjaCBhbmQgd2UgZG9uJ3QgcmVxdWlyZSBpbnRlcnNlY3Rpb24gcmV0dXJuIHRydWVcbiAgICAgIGlmIChpbnRlcnNlY3QgXiBiKSByZXR1cm4gYjtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBpbnRlcnNlY3RpbmcgYW5kIHdlIG1hZGUgaXQgaGVyZSwgdGhlbiB3ZSBzYXcgbm8gbWlzc2VzXG4gIC8vIGlmIG5vdCBpbnRlcnNlY3RpbmcsIHRoZW4gd2Ugc2F3IG5vIG1hdGNoZXNcbiAgLy8gaWYgbm8gYWN0aXZlIHNlbGVjdGlvbnMsIHJldHVybiBmYWxzZVxuICByZXR1cm4gbiAmJiBpbnRlcnNlY3Q7XG59XG5jb25zdCBiaXNlY3QgPSBiaXNlY3Rvcigkc2VsZWN0aW9uSWQpLFxuICBiaXNlY3RMZWZ0ID0gYmlzZWN0LmxlZnQsXG4gIGJpc2VjdFJpZ2h0ID0gYmlzZWN0LnJpZ2h0O1xuZnVuY3Rpb24gc2VsZWN0aW9uSWRUZXN0KG5hbWUsIGRhdHVtLCBvcCkge1xuICBjb25zdCBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgZW50cmllcyA9IGRhdGEgPyBkYXRhLnZhbHVlcy52YWx1ZSA6IFtdLFxuICAgIHVuaXRJZHggPSBkYXRhID8gZGF0YVtVTklUX0lOREVYXSAmJiBkYXRhW1VOSVRfSU5ERVhdLnZhbHVlIDogdW5kZWZpbmVkLFxuICAgIGludGVyc2VjdCA9IG9wID09PSBJbnRlcnNlY3QsXG4gICAgdmFsdWUgPSAkc2VsZWN0aW9uSWQoZGF0dW0pLFxuICAgIGluZGV4ID0gYmlzZWN0TGVmdChlbnRyaWVzLCB2YWx1ZSk7XG4gIGlmIChpbmRleCA9PT0gZW50cmllcy5sZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgaWYgKCRzZWxlY3Rpb25JZChlbnRyaWVzW2luZGV4XSkgIT09IHZhbHVlKSByZXR1cm4gZmFsc2U7XG4gIGlmICh1bml0SWR4ICYmIGludGVyc2VjdCkge1xuICAgIGlmICh1bml0SWR4LnNpemUgPT09IDEpIHJldHVybiB0cnVlO1xuICAgIGlmIChiaXNlY3RSaWdodChlbnRyaWVzLCB2YWx1ZSkgLSBpbmRleCA8IHVuaXRJZHguc2l6ZSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIE1hcHMgYW4gYXJyYXkgb2Ygc2NlbmUgZ3JhcGggaXRlbXMgdG8gYW4gYXJyYXkgb2Ygc2VsZWN0aW9uIHR1cGxlcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lICAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0IHJlcHJlc2VudGluZyB0aGUgc2VsZWN0aW9uLlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2UgIC0gVGhlIGJhc2Ugb2JqZWN0IHRoYXQgZ2VuZXJhdGVkIHR1cGxlcyBleHRlbmQuXG4gKlxuICogQHJldHVybnMge2FycmF5fSBBbiBhcnJheSBvZiBzZWxlY3Rpb24gZW50cmllcyBmb3IgdGhlIGdpdmVuIHVuaXQuXG4gKi9cbmZ1bmN0aW9uIHNlbGVjdGlvblR1cGxlcyhhcnJheSwgYmFzZSkge1xuICByZXR1cm4gYXJyYXkubWFwKHggPT4gZXh0ZW5kKGJhc2UuZmllbGRzID8ge1xuICAgIHZhbHVlczogYmFzZS5maWVsZHMubWFwKGYgPT4gZ2V0dGVyKGYpKHguZGF0dW0pKVxuICB9IDoge1xuICAgIFtTZWxlY3Rpb25JZF06ICRzZWxlY3Rpb25JZCh4LmRhdHVtKVxuICB9LCBiYXNlKSk7XG59XG5cbi8qKlxuICogUmVzb2x2ZXMgc2VsZWN0aW9uIGZvciB1c2UgYXMgYSBzY2FsZSBkb21haW4gb3IgcmVhZHMgdmlhIHRoZSBBUEkuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBkYXRhc2V0IHJlcHJlc2VudGluZyB0aGUgc2VsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wPSd1bmlvbiddIC0gVGhlIHNldCBvcGVyYXRpb24gZm9yIGNvbWJpbmluZyBzZWxlY3Rpb25zLlxuICogICAgICAgICAgICAgICAgIE9uZSBvZiAnaW50ZXJzZWN0JyBvciAndW5pb24nIChkZWZhdWx0KS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNNdWx0aSAtIElkZW50aWZpZXMgYSBcIm11bHRpXCIgc2VsZWN0aW9uIHRvIHBlcmZvcm0gbW9yZVxuICogICAgICAgICAgICAgICAgIGV4cGVuc2l2ZSByZXNvbHV0aW9uIGNvbXB1dGF0aW9uLlxuICogQHBhcmFtIHtib29sZWFufSB2bDUgLSBXaXRoIFZlZ2EtTGl0ZSB2NSwgXCJtdWx0aVwiIHNlbGVjdGlvbnMgYXJlIG5vdyBjYWxsZWQgXCJwb2ludFwiXG4gKiAgICAgICAgICAgICAgICAgc2VsZWN0aW9ucywgYW5kIHRodXMgdGhlIHJlc29sdmVkIHR1cGxlIHNob3VsZCByZWZsZWN0IHRoaXMgbmFtZS5cbiAqICAgICAgICAgICAgICAgICBUaGlzIHBhcmFtZXRlciBhbGxvd3MgdXMgdG8gcmVmbGVjdCB0aGlzIGNoYW5nZSB3aXRob3V0IHRyaWdnZXJpbmdcbiAqICAgICAgICAgICAgICAgICBhIG1ham9yIHZlcnNpb24gYnVtcCBmb3IgVmVnYS5cbiAqIEByZXR1cm5zIHtvYmplY3R9IEFuIG9iamVjdCBvZiBzZWxlY3RlZCBmaWVsZHMgYW5kIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0aW9uUmVzb2x2ZShuYW1lLCBvcCwgaXNNdWx0aSwgdmw1KSB7XG4gIHZhciBkYXRhID0gdGhpcy5jb250ZXh0LmRhdGFbbmFtZV0sXG4gICAgZW50cmllcyA9IGRhdGEgPyBkYXRhLnZhbHVlcy52YWx1ZSA6IFtdLFxuICAgIHJlc29sdmVkID0ge30sXG4gICAgbXVsdGlSZXMgPSB7fSxcbiAgICB0eXBlcyA9IHt9LFxuICAgIGVudHJ5LFxuICAgIGZpZWxkcyxcbiAgICB2YWx1ZXMsXG4gICAgdW5pdCxcbiAgICBmaWVsZCxcbiAgICB2YWx1ZSxcbiAgICByZXMsXG4gICAgcmVzVW5pdCxcbiAgICB0eXBlLFxuICAgIHVuaW9uLFxuICAgIG4gPSBlbnRyaWVzLmxlbmd0aCxcbiAgICBpID0gMCxcbiAgICBqLFxuICAgIG07XG5cbiAgLy8gRmlyc3QgdW5pb24gYWxsIGVudHJpZXMgd2l0aGluIHRoZSBzYW1lIHVuaXQuXG4gIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgZW50cnkgPSBlbnRyaWVzW2ldO1xuICAgIHVuaXQgPSBlbnRyeS51bml0O1xuICAgIGZpZWxkcyA9IGVudHJ5LmZpZWxkcztcbiAgICB2YWx1ZXMgPSBlbnRyeS52YWx1ZXM7XG4gICAgaWYgKGZpZWxkcyAmJiB2YWx1ZXMpIHtcbiAgICAgIC8vIEludGVudGlvbmFsIHNlbGVjdGlvbiBzdG9yZXNcbiAgICAgIGZvciAoaiA9IDAsIG0gPSBmaWVsZHMubGVuZ3RoOyBqIDwgbTsgKytqKSB7XG4gICAgICAgIGZpZWxkID0gZmllbGRzW2pdO1xuICAgICAgICByZXMgPSByZXNvbHZlZFtmaWVsZC5maWVsZF0gfHwgKHJlc29sdmVkW2ZpZWxkLmZpZWxkXSA9IHt9KTtcbiAgICAgICAgcmVzVW5pdCA9IHJlc1t1bml0XSB8fCAocmVzW3VuaXRdID0gW10pO1xuICAgICAgICB0eXBlc1tmaWVsZC5maWVsZF0gPSB0eXBlID0gZmllbGQudHlwZS5jaGFyQXQoMCk7XG4gICAgICAgIHVuaW9uID0gb3BzW2Ake3R5cGV9X3VuaW9uYF07XG4gICAgICAgIHJlc1t1bml0XSA9IHVuaW9uKHJlc1VuaXQsIGFycmF5KHZhbHVlc1tqXSkpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgc2FtZSBtdWx0aS1zZWxlY3Rpb24gaXMgcmVwZWF0ZWQgb3ZlciB2aWV3cyBhbmQgcHJvamVjdGVkIG92ZXJcbiAgICAgIC8vIGFuIGVuY29kaW5nLCBpdCBtYXkgb3BlcmF0ZSBvdmVyIGRpZmZlcmVudCBmaWVsZHMgbWFraW5nIGl0IGVzcGVjaWFsbHlcbiAgICAgIC8vIHRyaWNreSB0byByZWxpYWJseSByZXNvbHZlIGl0LiBBdCBiZXN0LCB3ZSBjYW4gZGUtZHVwZSBpZGVudGljYWwgZW50cmllc1xuICAgICAgLy8gYnV0IGRvaW5nIHNvIG1heSBiZSBtb3JlIGNvbXB1dGF0aW9uYWxseSBleHBlbnNpdmUgdGhhbiBpdCBpcyB3b3J0aC5cbiAgICAgIC8vIEluc3RlYWQsIGZvciBub3csIHdlIHNpbXBseSB0cmFuc2Zvcm0gb3VyIHN0b3JlIHJlcHJlc2VudGF0aW9uIGludG9cbiAgICAgIC8vIGEgbW9yZSBodW1hbi1mcmllbmRseSBvbmUuXG4gICAgICBpZiAoaXNNdWx0aSkge1xuICAgICAgICByZXNVbml0ID0gbXVsdGlSZXNbdW5pdF0gfHwgKG11bHRpUmVzW3VuaXRdID0gW10pO1xuICAgICAgICByZXNVbml0LnB1c2goYXJyYXkodmFsdWVzKS5yZWR1Y2UoKG9iaiwgY3VyciwgaikgPT4gKG9ialtmaWVsZHNbal0uZmllbGRdID0gY3Vyciwgb2JqKSwge30pKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU2hvcnQgY2lyY3VpdCBleHRlbnNpb25hbCBzZWxlY3Rpb25JZCBzdG9yZXMgd2hpY2ggaG9sZCBzb3J0ZWQgSURzIHVuaXF1ZSB0byBlYWNoIHVuaXQuXG4gICAgICBmaWVsZCA9IFNlbGVjdGlvbklkO1xuICAgICAgdmFsdWUgPSAkc2VsZWN0aW9uSWQoZW50cnkpO1xuICAgICAgcmVzID0gcmVzb2x2ZWRbZmllbGRdIHx8IChyZXNvbHZlZFtmaWVsZF0gPSB7fSk7XG4gICAgICByZXNVbml0ID0gcmVzW3VuaXRdIHx8IChyZXNbdW5pdF0gPSBbXSk7XG4gICAgICByZXNVbml0LnB1c2godmFsdWUpO1xuICAgICAgaWYgKGlzTXVsdGkpIHtcbiAgICAgICAgcmVzVW5pdCA9IG11bHRpUmVzW3VuaXRdIHx8IChtdWx0aVJlc1t1bml0XSA9IFtdKTtcbiAgICAgICAgcmVzVW5pdC5wdXNoKHtcbiAgICAgICAgICBbU2VsZWN0aW9uSWRdOiB2YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBUaGVuIHJlc29sdmUgZmllbGRzIGFjcm9zcyB1bml0cyBhcyBwZXIgdGhlIG9wLlxuICBvcCA9IG9wIHx8IFVuaW9uO1xuICBpZiAocmVzb2x2ZWRbU2VsZWN0aW9uSWRdKSB7XG4gICAgcmVzb2x2ZWRbU2VsZWN0aW9uSWRdID0gb3BzW2Ake1NlbGVjdGlvbklkfV8ke29wfWBdKC4uLk9iamVjdC52YWx1ZXMocmVzb2x2ZWRbU2VsZWN0aW9uSWRdKSk7XG4gIH0gZWxzZSB7XG4gICAgT2JqZWN0LmtleXMocmVzb2x2ZWQpLmZvckVhY2goZmllbGQgPT4ge1xuICAgICAgcmVzb2x2ZWRbZmllbGRdID0gT2JqZWN0LmtleXMocmVzb2x2ZWRbZmllbGRdKS5tYXAodW5pdCA9PiByZXNvbHZlZFtmaWVsZF1bdW5pdF0pLnJlZHVjZSgoYWNjLCBjdXJyKSA9PiBhY2MgPT09IHVuZGVmaW5lZCA/IGN1cnIgOiBvcHNbYCR7dHlwZXNbZmllbGRdfV8ke29wfWBdKGFjYywgY3VycikpO1xuICAgIH0pO1xuICB9XG4gIGVudHJpZXMgPSBPYmplY3Qua2V5cyhtdWx0aVJlcyk7XG4gIGlmIChpc011bHRpICYmIGVudHJpZXMubGVuZ3RoKSB7XG4gICAgY29uc3Qga2V5ID0gdmw1ID8gVmxQb2ludCA6IFZsTXVsdGk7XG4gICAgcmVzb2x2ZWRba2V5XSA9IG9wID09PSBVbmlvbiA/IHtcbiAgICAgIFtPcl06IGVudHJpZXMucmVkdWNlKChhY2MsIGspID0+IChhY2MucHVzaCguLi5tdWx0aVJlc1trXSksIGFjYyksIFtdKVxuICAgIH0gOiB7XG4gICAgICBbQW5kXTogZW50cmllcy5tYXAoayA9PiAoe1xuICAgICAgICBbT3JdOiBtdWx0aVJlc1trXVxuICAgICAgfSkpXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzb2x2ZWQ7XG59XG52YXIgb3BzID0ge1xuICBbYCR7U2VsZWN0aW9uSWR9X3VuaW9uYF06IHVuaW9uLFxuICBbYCR7U2VsZWN0aW9uSWR9X2ludGVyc2VjdGBdOiBpbnRlcnNlY3Rpb24sXG4gIEVfdW5pb246IGZ1bmN0aW9uIChiYXNlLCB2YWx1ZSkge1xuICAgIGlmICghYmFzZS5sZW5ndGgpIHJldHVybiB2YWx1ZTtcbiAgICB2YXIgaSA9IDAsXG4gICAgICBuID0gdmFsdWUubGVuZ3RoO1xuICAgIGZvciAoOyBpIDwgbjsgKytpKSBpZiAoIWJhc2UuaW5jbHVkZXModmFsdWVbaV0pKSBiYXNlLnB1c2godmFsdWVbaV0pO1xuICAgIHJldHVybiBiYXNlO1xuICB9LFxuICBFX2ludGVyc2VjdDogZnVuY3Rpb24gKGJhc2UsIHZhbHVlKSB7XG4gICAgcmV0dXJuICFiYXNlLmxlbmd0aCA/IHZhbHVlIDogYmFzZS5maWx0ZXIodiA9PiB2YWx1ZS5pbmNsdWRlcyh2KSk7XG4gIH0sXG4gIFJfdW5pb246IGZ1bmN0aW9uIChiYXNlLCB2YWx1ZSkge1xuICAgIHZhciBsbyA9IHRvTnVtYmVyKHZhbHVlWzBdKSxcbiAgICAgIGhpID0gdG9OdW1iZXIodmFsdWVbMV0pO1xuICAgIGlmIChsbyA+IGhpKSB7XG4gICAgICBsbyA9IHZhbHVlWzFdO1xuICAgICAgaGkgPSB2YWx1ZVswXTtcbiAgICB9XG4gICAgaWYgKCFiYXNlLmxlbmd0aCkgcmV0dXJuIFtsbywgaGldO1xuICAgIGlmIChiYXNlWzBdID4gbG8pIGJhc2VbMF0gPSBsbztcbiAgICBpZiAoYmFzZVsxXSA8IGhpKSBiYXNlWzFdID0gaGk7XG4gICAgcmV0dXJuIGJhc2U7XG4gIH0sXG4gIFJfaW50ZXJzZWN0OiBmdW5jdGlvbiAoYmFzZSwgdmFsdWUpIHtcbiAgICB2YXIgbG8gPSB0b051bWJlcih2YWx1ZVswXSksXG4gICAgICBoaSA9IHRvTnVtYmVyKHZhbHVlWzFdKTtcbiAgICBpZiAobG8gPiBoaSkge1xuICAgICAgbG8gPSB2YWx1ZVsxXTtcbiAgICAgIGhpID0gdmFsdWVbMF07XG4gICAgfVxuICAgIGlmICghYmFzZS5sZW5ndGgpIHJldHVybiBbbG8sIGhpXTtcbiAgICBpZiAoaGkgPCBiYXNlWzBdIHx8IGJhc2VbMV0gPCBsbykge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoYmFzZVswXSA8IGxvKSBiYXNlWzBdID0gbG87XG4gICAgICBpZiAoYmFzZVsxXSA+IGhpKSBiYXNlWzFdID0gaGk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG59O1xuXG5jb25zdCBEYXRhUHJlZml4ID0gJzonLFxuICBJbmRleFByZWZpeCA9ICdAJztcbmZ1bmN0aW9uIHNlbGVjdGlvblZpc2l0b3IobmFtZSwgYXJncywgc2NvcGUsIHBhcmFtcykge1xuICBpZiAoYXJnc1swXS50eXBlICE9PSBMaXRlcmFsKSBlcnJvcignRmlyc3QgYXJndW1lbnQgdG8gc2VsZWN0aW9uIGZ1bmN0aW9ucyBtdXN0IGJlIGEgc3RyaW5nIGxpdGVyYWwuJyk7XG4gIGNvbnN0IGRhdGEgPSBhcmdzWzBdLnZhbHVlLFxuICAgIG9wID0gYXJncy5sZW5ndGggPj0gMiAmJiBwZWVrKGFyZ3MpLnZhbHVlLFxuICAgIGZpZWxkID0gJ3VuaXQnLFxuICAgIGluZGV4TmFtZSA9IEluZGV4UHJlZml4ICsgZmllbGQsXG4gICAgZGF0YU5hbWUgPSBEYXRhUHJlZml4ICsgZGF0YTtcblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmIChvcCA9PT0gSW50ZXJzZWN0ICYmICFoYXNPd25Qcm9wZXJ0eShwYXJhbXMsIGluZGV4TmFtZSkpIHtcbiAgICBwYXJhbXNbaW5kZXhOYW1lXSA9IHNjb3BlLmdldERhdGEoZGF0YSkuaW5kYXRhUmVmKHNjb3BlLCBmaWVsZCk7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvdG90eXBlLWJ1aWx0aW5zXG4gIGlmICghaGFzT3duUHJvcGVydHkocGFyYW1zLCBkYXRhTmFtZSkpIHtcbiAgICBwYXJhbXNbZGF0YU5hbWVdID0gc2NvcGUuZ2V0RGF0YShkYXRhKS50dXBsZXNSZWYoKTtcbiAgfVxufVxuXG5leHBvcnQgeyBzZWxlY3Rpb25JZFRlc3QsIHNlbGVjdGlvblJlc29sdmUsIHNlbGVjdGlvblRlc3QsIHNlbGVjdGlvblR1cGxlcywgc2VsZWN0aW9uVmlzaXRvciB9O1xuIiwiaW1wb3J0IHsgYXNjZW5kaW5nLCBxdWFudGlsZVNvcnRlZCwgZGV2aWF0aW9uLCBxdWFudGlsZSwgbWVkaWFuIH0gZnJvbSAnZDMtYXJyYXknO1xuXG5mdW5jdGlvbiogbnVtYmVycyAodmFsdWVzLCB2YWx1ZW9mKSB7XG4gIGlmICh2YWx1ZW9mID09IG51bGwpIHtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgIHZhbHVlID0gdmFsdWVvZih2YWx1ZSwgKytpbmRleCwgdmFsdWVzKTtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiAodmFsdWUgPSArdmFsdWUpID49IHZhbHVlKSB7XG4gICAgICAgIHlpZWxkIHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBxdWFudGlsZXMgKGFycmF5LCBwLCBmKSB7XG4gIGNvbnN0IHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnMoYXJyYXksIGYpKTtcblxuICAvLyBkb24ndCBkZXBlbmQgb24gcmV0dXJuIHZhbHVlIGZyb20gdHlwZWQgYXJyYXkgc29ydCBjYWxsXG4gIC8vIHByb3RlY3RzIGFnYWluc3QgdW5kZWZpbmVkIHNvcnQgcmVzdWx0cyBpbiBTYWZhcmkgKHZlZ2EvdmVnYS1saXRlIzQ5NjQpXG4gIHZhbHVlcy5zb3J0KGFzY2VuZGluZyk7XG4gIHJldHVybiBwLm1hcChfID0+IHF1YW50aWxlU29ydGVkKHZhbHVlcywgXykpO1xufVxuXG5mdW5jdGlvbiBxdWFydGlsZXMgKGFycmF5LCBmKSB7XG4gIHJldHVybiBxdWFudGlsZXMoYXJyYXksIFswLjI1LCAwLjUwLCAwLjc1XSwgZik7XG59XG5cbi8vIFNjb3R0LCBELiBXLiAoMTk5MikgTXVsdGl2YXJpYXRlIERlbnNpdHkgRXN0aW1hdGlvbjpcbi8vIFRoZW9yeSwgUHJhY3RpY2UsIGFuZCBWaXN1YWxpemF0aW9uLiBXaWxleS5cbmZ1bmN0aW9uIGVzdGltYXRlQmFuZHdpZHRoIChhcnJheSwgZikge1xuICBjb25zdCBuID0gYXJyYXkubGVuZ3RoLFxuICAgIGQgPSBkZXZpYXRpb24oYXJyYXksIGYpLFxuICAgIHEgPSBxdWFydGlsZXMoYXJyYXksIGYpLFxuICAgIGggPSAocVsyXSAtIHFbMF0pIC8gMS4zNCxcbiAgICB2ID0gTWF0aC5taW4oZCwgaCkgfHwgZCB8fCBNYXRoLmFicyhxWzBdKSB8fCAxO1xuICByZXR1cm4gMS4wNiAqIHYgKiBNYXRoLnBvdyhuLCAtMC4yKTtcbn1cblxuZnVuY3Rpb24gYmluIChfKSB7XG4gIC8vIGRldGVybWluZSByYW5nZVxuICBjb25zdCBtYXhiID0gXy5tYXhiaW5zIHx8IDIwLFxuICAgIGJhc2UgPSBfLmJhc2UgfHwgMTAsXG4gICAgbG9nYiA9IE1hdGgubG9nKGJhc2UpLFxuICAgIGRpdiA9IF8uZGl2aWRlIHx8IFs1LCAyXTtcbiAgbGV0IG1pbiA9IF8uZXh0ZW50WzBdLFxuICAgIG1heCA9IF8uZXh0ZW50WzFdLFxuICAgIHN0ZXAsXG4gICAgbGV2ZWwsXG4gICAgbWluc3RlcCxcbiAgICB2LFxuICAgIGksXG4gICAgbjtcbiAgY29uc3Qgc3BhbiA9IF8uc3BhbiB8fCBtYXggLSBtaW4gfHwgTWF0aC5hYnMobWluKSB8fCAxO1xuICBpZiAoXy5zdGVwKSB7XG4gICAgLy8gaWYgc3RlcCBzaXplIGlzIGV4cGxpY2l0bHkgZ2l2ZW4sIHVzZSB0aGF0XG4gICAgc3RlcCA9IF8uc3RlcDtcbiAgfSBlbHNlIGlmIChfLnN0ZXBzKSB7XG4gICAgLy8gaWYgcHJvdmlkZWQsIGxpbWl0IGNob2ljZSB0byBhY2NlcHRhYmxlIHN0ZXAgc2l6ZXNcbiAgICB2ID0gc3BhbiAvIG1heGI7XG4gICAgZm9yIChpID0gMCwgbiA9IF8uc3RlcHMubGVuZ3RoOyBpIDwgbiAmJiBfLnN0ZXBzW2ldIDwgdjsgKytpKTtcbiAgICBzdGVwID0gXy5zdGVwc1tNYXRoLm1heCgwLCBpIC0gMSldO1xuICB9IGVsc2Uge1xuICAgIC8vIGVsc2UgdXNlIHNwYW4gdG8gZGV0ZXJtaW5lIHN0ZXAgc2l6ZVxuICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYik7XG4gICAgbWluc3RlcCA9IF8ubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChtaW5zdGVwLCBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbCkpO1xuXG4gICAgLy8gaW5jcmVhc2Ugc3RlcCBzaXplIGlmIHRvbyBtYW55IGJpbnNcbiAgICB3aGlsZSAoTWF0aC5jZWlsKHNwYW4gLyBzdGVwKSA+IG1heGIpIHtcbiAgICAgIHN0ZXAgKj0gYmFzZTtcbiAgICB9XG5cbiAgICAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuICAgIGZvciAoaSA9IDAsIG4gPSBkaXYubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnN0ZXAgJiYgc3BhbiAvIHYgPD0gbWF4Yikgc3RlcCA9IHY7XG4gICAgfVxuICB9XG5cbiAgLy8gdXBkYXRlIHByZWNpc2lvbiwgbWluIGFuZCBtYXhcbiAgdiA9IE1hdGgubG9nKHN0ZXApO1xuICBjb25zdCBwcmVjaXNpb24gPSB2ID49IDAgPyAwIDogfn4oLXYgLyBsb2diKSArIDEsXG4gICAgZXBzID0gTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBpZiAoXy5uaWNlIHx8IF8ubmljZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdiA9IE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwO1xuICAgIG1pbiA9IG1pbiA8IHYgPyB2IC0gc3RlcCA6IHY7XG4gICAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcbiAgfVxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogbWF4ID09PSBtaW4gPyBtaW4gKyBzdGVwIDogbWF4LFxuICAgIHN0ZXA6IHN0ZXBcbiAgfTtcbn1cblxudmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuZnVuY3Rpb24gc2V0UmFuZG9tKHIpIHtcbiAgcmFuZG9tID0gcjtcbn1cblxuZnVuY3Rpb24gYm9vdHN0cmFwQ0kgKGFycmF5LCBzYW1wbGVzLCBhbHBoYSwgZikge1xuICBpZiAoIWFycmF5Lmxlbmd0aCkgcmV0dXJuIFt1bmRlZmluZWQsIHVuZGVmaW5lZF07XG4gIGNvbnN0IHZhbHVlcyA9IEZsb2F0NjRBcnJheS5mcm9tKG51bWJlcnMoYXJyYXksIGYpKSxcbiAgICBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICBtID0gc2FtcGxlcztcbiAgbGV0IGEsIGksIGosIG11O1xuICBmb3IgKGogPSAwLCBtdSA9IEFycmF5KG0pOyBqIDwgbTsgKytqKSB7XG4gICAgZm9yIChhID0gMCwgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGEgKz0gdmFsdWVzW35+KHJhbmRvbSgpICogbildO1xuICAgIH1cbiAgICBtdVtqXSA9IGEgLyBuO1xuICB9XG4gIG11LnNvcnQoYXNjZW5kaW5nKTtcbiAgcmV0dXJuIFtxdWFudGlsZShtdSwgYWxwaGEgLyAyKSwgcXVhbnRpbGUobXUsIDEgLSBhbHBoYSAvIDIpXTtcbn1cblxuLy8gRG90IGRlbnNpdHkgYmlubmluZyBmb3IgZG90IHBsb3QgY29uc3RydWN0aW9uLlxuLy8gQmFzZWQgb24gTGVsYW5kIFdpbGtpbnNvbiwgRG90IFBsb3RzLCBUaGUgQW1lcmljYW4gU3RhdGlzdGljaWFuLCAxOTk5LlxuLy8gaHR0cHM6Ly93d3cuY3MudWljLmVkdS9+d2lsa2luc29uL1B1YmxpY2F0aW9ucy9kb3RwbG90cy5wZGZcbmZ1bmN0aW9uIGRvdGJpbiAoYXJyYXksIHN0ZXAsIHNtb290aCwgZikge1xuICBmID0gZiB8fCAoXyA9PiBfKTtcbiAgY29uc3QgbiA9IGFycmF5Lmxlbmd0aCxcbiAgICB2ID0gbmV3IEZsb2F0NjRBcnJheShuKTtcbiAgbGV0IGkgPSAwLFxuICAgIGogPSAxLFxuICAgIGEgPSBmKGFycmF5WzBdKSxcbiAgICBiID0gYSxcbiAgICB3ID0gYSArIHN0ZXAsXG4gICAgeDtcbiAgZm9yICg7IGogPCBuOyArK2opIHtcbiAgICB4ID0gZihhcnJheVtqXSk7XG4gICAgaWYgKHggPj0gdykge1xuICAgICAgYiA9IChhICsgYikgLyAyO1xuICAgICAgZm9yICg7IGkgPCBqOyArK2kpIHZbaV0gPSBiO1xuICAgICAgdyA9IHggKyBzdGVwO1xuICAgICAgYSA9IHg7XG4gICAgfVxuICAgIGIgPSB4O1xuICB9XG4gIGIgPSAoYSArIGIpIC8gMjtcbiAgZm9yICg7IGkgPCBqOyArK2kpIHZbaV0gPSBiO1xuICByZXR1cm4gc21vb3RoID8gc21vb3RoaW5nKHYsIHN0ZXAgKyBzdGVwIC8gNCkgOiB2O1xufVxuXG4vLyBwZXJmb3JtIHNtb290aGluZyB0byByZWR1Y2UgdmFyaWFuY2Vcbi8vIHN3YXAgcG9pbnRzIGJldHdlZW4gXCJhZGphY2VudFwiIHN0YWNrc1xuLy8gV2lsa2luc29uIGRlZmluZXMgYWRqYWNlbnQgYXMgd2l0aGluIHN0ZXAvNCB1bml0c1xuZnVuY3Rpb24gc21vb3RoaW5nKHYsIHRocmVzaCkge1xuICBjb25zdCBuID0gdi5sZW5ndGg7XG4gIGxldCBhID0gMCxcbiAgICBiID0gMSxcbiAgICBjLFxuICAgIGQ7XG5cbiAgLy8gZ2V0IGxlZnQgc3RhY2tcbiAgd2hpbGUgKHZbYV0gPT09IHZbYl0pICsrYjtcbiAgd2hpbGUgKGIgPCBuKSB7XG4gICAgLy8gZ2V0IHJpZ2h0IHN0YWNrXG4gICAgYyA9IGIgKyAxO1xuICAgIHdoaWxlICh2W2JdID09PSB2W2NdKSArK2M7XG5cbiAgICAvLyBhcmUgc3RhY2tzIGFkamFjZW50P1xuICAgIC8vIGlmIHNvLCBjb21wYXJlIHNpemVzIGFuZCBzd2FwIGFzIG5lZWRlZFxuICAgIGlmICh2W2JdIC0gdltiIC0gMV0gPCB0aHJlc2gpIHtcbiAgICAgIGQgPSBiICsgKGEgKyBjIC0gYiAtIGIgPj4gMSk7XG4gICAgICB3aGlsZSAoZCA8IGIpIHZbZCsrXSA9IHZbYl07XG4gICAgICB3aGlsZSAoZCA+IGIpIHZbZC0tXSA9IHZbYV07XG4gICAgfVxuXG4gICAgLy8gdXBkYXRlIGxlZnQgc3RhY2sgaW5kaWNlc1xuICAgIGEgPSBiO1xuICAgIGIgPSBjO1xuICB9XG4gIHJldHVybiB2O1xufVxuXG5mdW5jdGlvbiBsY2cgKHNlZWQpIHtcbiAgLy8gUmFuZG9tIG51bWJlcnMgdXNpbmcgYSBMaW5lYXIgQ29uZ3J1ZW50aWFsIEdlbmVyYXRvciB3aXRoIHNlZWQgdmFsdWVcbiAgLy8gVXNlcyBnbGliYyB2YWx1ZXMgZnJvbSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MaW5lYXJfY29uZ3J1ZW50aWFsX2dlbmVyYXRvclxuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHNlZWQgPSAoMTEwMzUxNTI0NSAqIHNlZWQgKyAxMjM0NSkgJSAyMTQ3NDgzNjQ3O1xuICAgIHJldHVybiBzZWVkIC8gMjE0NzQ4MzY0NztcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW50ZWdlciAobWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgbGV0IGEsIGIsIGQ7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWluKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIGEgPSBfIHx8IDA7XG4gICAgICAgIGQgPSBiIC0gYTtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBiID0gXyB8fCAwO1xuICAgICAgICBkID0gYiAtIGE7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfSxcbiAgICBzYW1wbGUoKSB7XG4gICAgICByZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIHJhbmRvbSgpKTtcbiAgICB9LFxuICAgIHBkZih4KSB7XG4gICAgICByZXR1cm4geCA9PT0gTWF0aC5mbG9vcih4KSAmJiB4ID49IGEgJiYgeCA8IGIgPyAxIC8gZCA6IDA7XG4gICAgfSxcbiAgICBjZGYoeCkge1xuICAgICAgY29uc3QgdiA9IE1hdGguZmxvb3IoeCk7XG4gICAgICByZXR1cm4gdiA8IGEgPyAwIDogdiA+PSBiID8gMSA6ICh2IC0gYSArIDEpIC8gZDtcbiAgICB9LFxuICAgIGljZGYocCkge1xuICAgICAgcmV0dXJuIHAgPj0gMCAmJiBwIDw9IDEgPyBhIC0gMSArIE1hdGguZmxvb3IocCAqIGQpIDogTmFOO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGRpc3QubWluKG1pbikubWF4KG1heCk7XG59XG5cbmNvbnN0IFNRUlQyUEkgPSBNYXRoLnNxcnQoMiAqIE1hdGguUEkpO1xuY29uc3QgU1FSVDIgPSBNYXRoLlNRUlQyO1xuXG5sZXQgbmV4dFNhbXBsZSA9IE5hTjtcbmZ1bmN0aW9uIHNhbXBsZU5vcm1hbChtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIGxldCB4ID0gMCxcbiAgICB5ID0gMCxcbiAgICByZHMsXG4gICAgYztcbiAgaWYgKG5leHRTYW1wbGUgPT09IG5leHRTYW1wbGUpIHtcbiAgICB4ID0gbmV4dFNhbXBsZTtcbiAgICBuZXh0U2FtcGxlID0gTmFOO1xuICB9IGVsc2Uge1xuICAgIGRvIHtcbiAgICAgIHggPSByYW5kb20oKSAqIDIgLSAxO1xuICAgICAgeSA9IHJhbmRvbSgpICogMiAtIDE7XG4gICAgICByZHMgPSB4ICogeCArIHkgKiB5O1xuICAgIH0gd2hpbGUgKHJkcyA9PT0gMCB8fCByZHMgPiAxKTtcbiAgICBjID0gTWF0aC5zcXJ0KC0yICogTWF0aC5sb2cocmRzKSAvIHJkcyk7IC8vIEJveC1NdWxsZXIgdHJhbnNmb3JtXG4gICAgeCAqPSBjO1xuICAgIG5leHRTYW1wbGUgPSB5ICogYztcbiAgfVxuICByZXR1cm4gbWVhbiArIHggKiBzdGRldjtcbn1cbmZ1bmN0aW9uIGRlbnNpdHlOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgY29uc3QgeiA9ICh2YWx1ZSAtIChtZWFuIHx8IDApKSAvIHN0ZGV2O1xuICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIHogKiB6KSAvIChzdGRldiAqIFNRUlQyUEkpO1xufVxuXG4vLyBBcHByb3hpbWF0aW9uIGZyb20gV2VzdCAoMjAwOSlcbi8vIEJldHRlciBBcHByb3hpbWF0aW9ucyB0byBDdW11bGF0aXZlIE5vcm1hbCBGdW5jdGlvbnNcbmZ1bmN0aW9uIGN1bXVsYXRpdmVOb3JtYWwodmFsdWUsIG1lYW4sIHN0ZGV2KSB7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgY29uc3QgeiA9ICh2YWx1ZSAtIG1lYW4pIC8gc3RkZXYsXG4gICAgWiA9IE1hdGguYWJzKHopO1xuICBsZXQgY2Q7XG4gIGlmIChaID4gMzcpIHtcbiAgICBjZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgZXhwID0gTWF0aC5leHAoLVogKiBaIC8gMik7XG4gICAgbGV0IHN1bTtcbiAgICBpZiAoWiA8IDcuMDcxMDY3ODExODY1NDcpIHtcbiAgICAgIHN1bSA9IDMuNTI2MjQ5NjU5OTg5MTFlLTAyICogWiArIDAuNzAwMzgzMDY0NDQzNjg4O1xuICAgICAgc3VtID0gc3VtICogWiArIDYuMzczOTYyMjAzNTMxNjU7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMzMuOTEyODY2MDc4MzgzO1xuICAgICAgc3VtID0gc3VtICogWiArIDExMi4wNzkyOTE0OTc4NzE7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgMjIxLjIxMzU5NjE2OTkzMTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyAyMjAuMjA2ODY3OTEyMzc2O1xuICAgICAgY2QgPSBleHAgKiBzdW07XG4gICAgICBzdW0gPSA4LjgzODgzNDc2NDgzMTg0ZS0wMiAqIFogKyAxLjc1NTY2NzE2MzE4MjY0O1xuICAgICAgc3VtID0gc3VtICogWiArIDE2LjA2NDE3NzU3OTIwNztcbiAgICAgIHN1bSA9IHN1bSAqIFogKyA4Ni43ODA3MzIyMDI5NDYxO1xuICAgICAgc3VtID0gc3VtICogWiArIDI5Ni41NjQyNDg3Nzk2NzQ7XG4gICAgICBzdW0gPSBzdW0gKiBaICsgNjM3LjMzMzYzMzM3ODgzMTtcbiAgICAgIHN1bSA9IHN1bSAqIFogKyA3OTMuODI2NTEyNTE5OTQ4O1xuICAgICAgc3VtID0gc3VtICogWiArIDQ0MC40MTM3MzU4MjQ3NTI7XG4gICAgICBjZCA9IGNkIC8gc3VtO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdW0gPSBaICsgMC42NTtcbiAgICAgIHN1bSA9IFogKyA0IC8gc3VtO1xuICAgICAgc3VtID0gWiArIDMgLyBzdW07XG4gICAgICBzdW0gPSBaICsgMiAvIHN1bTtcbiAgICAgIHN1bSA9IFogKyAxIC8gc3VtO1xuICAgICAgY2QgPSBleHAgLyBzdW0gLyAyLjUwNjYyODI3NDYzMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHogPiAwID8gMSAtIGNkIDogY2Q7XG59XG5cbi8vIEFwcHJveGltYXRpb24gb2YgUHJvYml0IGZ1bmN0aW9uIHVzaW5nIGludmVyc2UgZXJyb3IgZnVuY3Rpb24uXG5mdW5jdGlvbiBxdWFudGlsZU5vcm1hbChwLCBtZWFuLCBzdGRldikge1xuICBpZiAocCA8IDAgfHwgcCA+IDEpIHJldHVybiBOYU47XG4gIHJldHVybiAobWVhbiB8fCAwKSArIChzdGRldiA9PSBudWxsID8gMSA6IHN0ZGV2KSAqIFNRUlQyICogZXJmaW52KDIgKiBwIC0gMSk7XG59XG5cbi8vIEFwcHJveGltYXRlIGludmVyc2UgZXJyb3IgZnVuY3Rpb24uIEltcGxlbWVudGF0aW9uIGZyb20gXCJBcHByb3hpbWF0aW5nXG4vLyB0aGUgZXJmaW52IGZ1bmN0aW9uXCIgYnkgTWlrZSBHaWxlcywgR1BVIENvbXB1dGluZyBHZW1zLCB2b2x1bWUgMiwgMjAxMC5cbi8vIFBvcnRlZCBmcm9tIEFwYWNoZSBDb21tb25zIE1hdGgsIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuZnVuY3Rpb24gZXJmaW52KHgpIHtcbiAgLy8gYmV3YXJlIHRoYXQgdGhlIGxvZ2FyaXRobSBhcmd1bWVudCBtdXN0IGJlXG4gIC8vIGNvbW1wdXRlZCBhcyAoMS4wIC0geCkgKiAoMS4wICsgeCksXG4gIC8vIGl0IG11c3QgTk9UIGJlIHNpbXBsaWZpZWQgYXMgMS4wIC0geCAqIHggYXMgdGhpc1xuICAvLyB3b3VsZCBpbmR1Y2Ugcm91bmRpbmcgZXJyb3JzIG5lYXIgdGhlIGJvdW5kYXJpZXMgKy8tMVxuICBsZXQgdyA9IC1NYXRoLmxvZygoMSAtIHgpICogKDEgKyB4KSksXG4gICAgcDtcbiAgaWYgKHcgPCA2LjI1KSB7XG4gICAgdyAtPSAzLjEyNTtcbiAgICBwID0gLTMuNjQ0NDEyMDY0MDE3ODE5Njk5NmUtMjE7XG4gICAgcCA9IC0xLjY4NTA1OTEzODE4MjAxNjU4OWUtMTkgKyBwICogdztcbiAgICBwID0gMS4yODU4NDgwNzE1MjU2NDAwMTY3ZS0xOCArIHAgKiB3O1xuICAgIHAgPSAxLjExNTc4Nzc2NzgwMjUxODA5NmUtMTcgKyBwICogdztcbiAgICBwID0gLTEuMzMzMTcxNjYyODU0NjIwOTA2ZS0xNiArIHAgKiB3O1xuICAgIHAgPSAyLjA5NzI3Njc4NzU5Njg1NjE2MzdlLTE3ICsgcCAqIHc7XG4gICAgcCA9IDYuNjM3NjM4MTM0MzU4MzIzODMyNWUtMTUgKyBwICogdztcbiAgICBwID0gLTQuMDU0NTY2MjcyOTc1MjA2ODYzOWUtMTQgKyBwICogdztcbiAgICBwID0gLTguMTUxOTM0MTk3NjA1NDcyMTUyMmUtMTQgKyBwICogdztcbiAgICBwID0gMi42MzM1MDkzMTUzMDgyMzIyOTc3ZS0xMiArIHAgKiB3O1xuICAgIHAgPSAtMS4yOTc1MTMzMjUzNDUzNTMyNDk4ZS0xMSArIHAgKiB3O1xuICAgIHAgPSAtNS40MTU0MTIwNTQyOTQ2Mjc5MzE3ZS0xMSArIHAgKiB3O1xuICAgIHAgPSAxLjA1MTIxMjI3MzMyMTUzMjI4NWUtMDkgKyBwICogdztcbiAgICBwID0gLTQuMTEyNjMzOTgwMzQ2OTgzNjk3NmUtMDkgKyBwICogdztcbiAgICBwID0gLTIuOTA3MDM2OTk1Nzg4MjAwNTA4NmUtMDggKyBwICogdztcbiAgICBwID0gNC4yMzQ3ODc3ODI3OTMyNDAzNTE4ZS0wNyArIHAgKiB3O1xuICAgIHAgPSAtMS4zNjU0NjkyMDAwODM0Njc4NjQ1ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtMS4zODgyNTIzMzYyNzg2NDY4NzE5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAwLjAwMDE4NjczNDIwODAzNDA1NzEzNTIgKyBwICogdztcbiAgICBwID0gLTAuMDAwNzQwNzAyNTM0MTY2MjY2OTc1MTIgKyBwICogdztcbiAgICBwID0gLTAuMDA2MDMzNjcwODcxNDMwMTQ5MDUzMyArIHAgKiB3O1xuICAgIHAgPSAwLjI0MDE1ODE4MjQyNTU4OTYxNjkzICsgcCAqIHc7XG4gICAgcCA9IDEuNjUzNjU0NTYyNjgzMTAyNzM1NiArIHAgKiB3O1xuICB9IGVsc2UgaWYgKHcgPCAxNi4wKSB7XG4gICAgdyA9IE1hdGguc3FydCh3KSAtIDMuMjU7XG4gICAgcCA9IDIuMjEzNzM3NjkyMTc3NTc4NzA0OWUtMDk7XG4gICAgcCA9IDkuMDc1NjU2MTkzODg4NTM5MDk3OWUtMDggKyBwICogdztcbiAgICBwID0gLTIuNzUxNzQwNjI5NzA2NDU0NTQyOGUtMDcgKyBwICogdztcbiAgICBwID0gMS44MjM5NjI5MjE0Mzg5MjI3NzU1ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAxLjUwMjc0MDM5Njg5MDk4Mjc2MjdlLTA2ICsgcCAqIHc7XG4gICAgcCA9IC00LjAxMzg2NzUyNjk4MTU0NTk2OWUtMDYgKyBwICogdztcbiAgICBwID0gMi45MjM0NDQ5MDg5OTU1NDQ2MDQ0ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAxLjI0NzUzMDQ0ODE2NzE3Nzg3MjNlLTA1ICsgcCAqIHc7XG4gICAgcCA9IC00LjczMTgyMjkwMDkwNTU3MzM5ODFlLTA1ICsgcCAqIHc7XG4gICAgcCA9IDYuODI4NDg1MTQ1OTU3MzE3NTQ0OGUtMDUgKyBwICogdztcbiAgICBwID0gMi40MDMxMTEwMzg3MDk3ODkzOTk5ZS0wNSArIHAgKiB3O1xuICAgIHAgPSAtMC4wMDAzNTUwMzc1MjAzNjI4NDc0Nzk2ICsgcCAqIHc7XG4gICAgcCA9IDAuMDAwOTUzMjg5Mzc5NzM3MzgwNDk3MDMgKyBwICogdztcbiAgICBwID0gLTAuMDAxNjg4Mjc1NTU2MDIzNTA0NzMxMyArIHAgKiB3O1xuICAgIHAgPSAwLjAwMjQ5MTQ0MjA5NjEwNzg1MDgwNjYgKyBwICogdztcbiAgICBwID0gLTAuMDAzNzUxMjA4NTA3NTY5MjQxMjEwNyArIHAgKiB3O1xuICAgIHAgPSAwLjAwNTM3MDkxNDU1MzU5MDA2MzYxNyArIHAgKiB3O1xuICAgIHAgPSAxLjAwNTI1ODk2NzY5NDE1OTIzMzQgKyBwICogdztcbiAgICBwID0gMy4wODM4ODU2MTA0OTIyMjA3NjM1ICsgcCAqIHc7XG4gIH0gZWxzZSBpZiAoTnVtYmVyLmlzRmluaXRlKHcpKSB7XG4gICAgdyA9IE1hdGguc3FydCh3KSAtIDUuMDtcbiAgICBwID0gLTIuNzEwOTkyMDYxNjQzODU3MzI0M2UtMTE7XG4gICAgcCA9IC0yLjU1NTY0MTgxNjk5NjUyNTIwNTVlLTEwICsgcCAqIHc7XG4gICAgcCA9IDEuNTA3NjU3MjY5MzUwMDU0ODA4M2UtMDkgKyBwICogdztcbiAgICBwID0gLTMuNzg5NDY1NDQwMTI2NzM2OTkzN2UtMDkgKyBwICogdztcbiAgICBwID0gNy42MTU3MDEyMDgwNzgzMzkzODA0ZS0wOSArIHAgKiB3O1xuICAgIHAgPSAtMS40OTYwMDI2NjI3MTQ5MjQwNDc4ZS0wOCArIHAgKiB3O1xuICAgIHAgPSAyLjkxNDc5NTM0NTA5MDEwODA4MjZlLTA4ICsgcCAqIHc7XG4gICAgcCA9IC02Ljc3MTE5OTc3NTg0NTIzMzk0OThlLTA4ICsgcCAqIHc7XG4gICAgcCA9IDIuMjkwMDQ4MjIyODAyNjY1NDcxN2UtMDcgKyBwICogdztcbiAgICBwID0gLTkuOTI5ODI3Mjk0MjMxNzAwMjUzOWUtMDcgKyBwICogdztcbiAgICBwID0gNC41MjYwNjI1OTcyMjMxNTM3MDM5ZS0wNiArIHAgKiB3O1xuICAgIHAgPSAtMS45NjgxNzc4MTA1NTMxNjcwNTY3ZS0wNSArIHAgKiB3O1xuICAgIHAgPSA3LjU5OTUyNzcwMzAwMTc3NjExMzllLTA1ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDIxNTAzMDExOTMwMDQ0NDc3MzQ3ICsgcCAqIHc7XG4gICAgcCA9IC0wLjAwMDEzODcxOTMxODMzNjIzMTIyMDI2ICsgcCAqIHc7XG4gICAgcCA9IDEuMDEwMzAwNDY0ODY0NTM0Mzk3NyArIHAgKiB3O1xuICAgIHAgPSA0Ljg0OTkwNjQwMTQwODU4NDQyMjEgKyBwICogdztcbiAgfSBlbHNlIHtcbiAgICBwID0gSW5maW5pdHk7XG4gIH1cbiAgcmV0dXJuIHAgKiB4O1xufVxuZnVuY3Rpb24gZ2F1c3NpYW4gKG1lYW4sIHN0ZGV2KSB7XG4gIGxldCBtdSwgc2lnbWE7XG4gIGNvbnN0IGRpc3QgPSB7XG4gICAgbWVhbihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBtdSA9IF8gfHwgMDtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbXU7XG4gICAgICB9XG4gICAgfSxcbiAgICBzdGRldihfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBzaWdtYSA9IF8gPT0gbnVsbCA/IDEgOiBfO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzaWdtYTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHNhbXBsZTogKCkgPT4gc2FtcGxlTm9ybWFsKG11LCBzaWdtYSksXG4gICAgcGRmOiB2YWx1ZSA9PiBkZW5zaXR5Tm9ybWFsKHZhbHVlLCBtdSwgc2lnbWEpLFxuICAgIGNkZjogdmFsdWUgPT4gY3VtdWxhdGl2ZU5vcm1hbCh2YWx1ZSwgbXUsIHNpZ21hKSxcbiAgICBpY2RmOiBwID0+IHF1YW50aWxlTm9ybWFsKHAsIG11LCBzaWdtYSlcbiAgfTtcbiAgcmV0dXJuIGRpc3QubWVhbihtZWFuKS5zdGRldihzdGRldik7XG59XG5cbmZ1bmN0aW9uIGtkZSAoc3VwcG9ydCwgYmFuZHdpZHRoKSB7XG4gIGNvbnN0IGtlcm5lbCA9IGdhdXNzaWFuKCk7XG4gIGxldCBuID0gMDtcbiAgY29uc3QgZGlzdCA9IHtcbiAgICBkYXRhKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHN1cHBvcnQgPSBfO1xuICAgICAgICBuID0gXyA/IF8ubGVuZ3RoIDogMDtcbiAgICAgICAgcmV0dXJuIGRpc3QuYmFuZHdpZHRoKGJhbmR3aWR0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc3VwcG9ydDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGJhbmR3aWR0aChfKSB7XG4gICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiBiYW5kd2lkdGg7XG4gICAgICBiYW5kd2lkdGggPSBfO1xuICAgICAgaWYgKCFiYW5kd2lkdGggJiYgc3VwcG9ydCkgYmFuZHdpZHRoID0gZXN0aW1hdGVCYW5kd2lkdGgoc3VwcG9ydCk7XG4gICAgICByZXR1cm4gZGlzdDtcbiAgICB9LFxuICAgIHNhbXBsZSgpIHtcbiAgICAgIHJldHVybiBzdXBwb3J0W35+KHJhbmRvbSgpICogbildICsgYmFuZHdpZHRoICoga2VybmVsLnNhbXBsZSgpO1xuICAgIH0sXG4gICAgcGRmKHgpIHtcbiAgICAgIGxldCB5ID0gMCxcbiAgICAgICAgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgICB5ICs9IGtlcm5lbC5wZGYoKHggLSBzdXBwb3J0W2ldKSAvIGJhbmR3aWR0aCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geSAvIGJhbmR3aWR0aCAvIG47XG4gICAgfSxcbiAgICBjZGYoeCkge1xuICAgICAgbGV0IHkgPSAwLFxuICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIHkgKz0ga2VybmVsLmNkZigoeCAtIHN1cHBvcnRbaV0pIC8gYmFuZHdpZHRoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB5IC8gbjtcbiAgICB9LFxuICAgIGljZGYoKSB7XG4gICAgICB0aHJvdyBFcnJvcignS0RFIGljZGYgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBkaXN0LmRhdGEoc3VwcG9ydCk7XG59XG5cbmZ1bmN0aW9uIHNhbXBsZUxvZ05vcm1hbChtZWFuLCBzdGRldikge1xuICBtZWFuID0gbWVhbiB8fCAwO1xuICBzdGRldiA9IHN0ZGV2ID09IG51bGwgPyAxIDogc3RkZXY7XG4gIHJldHVybiBNYXRoLmV4cChtZWFuICsgc2FtcGxlTm9ybWFsKCkgKiBzdGRldik7XG59XG5mdW5jdGlvbiBkZW5zaXR5TG9nTm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICBpZiAodmFsdWUgPD0gMCkgcmV0dXJuIDA7XG4gIG1lYW4gPSBtZWFuIHx8IDA7XG4gIHN0ZGV2ID0gc3RkZXYgPT0gbnVsbCA/IDEgOiBzdGRldjtcbiAgY29uc3QgeiA9IChNYXRoLmxvZyh2YWx1ZSkgLSBtZWFuKSAvIHN0ZGV2O1xuICByZXR1cm4gTWF0aC5leHAoLTAuNSAqIHogKiB6KSAvIChzdGRldiAqIFNRUlQyUEkgKiB2YWx1ZSk7XG59XG5mdW5jdGlvbiBjdW11bGF0aXZlTG9nTm9ybWFsKHZhbHVlLCBtZWFuLCBzdGRldikge1xuICByZXR1cm4gY3VtdWxhdGl2ZU5vcm1hbChNYXRoLmxvZyh2YWx1ZSksIG1lYW4sIHN0ZGV2KTtcbn1cbmZ1bmN0aW9uIHF1YW50aWxlTG9nTm9ybWFsKHAsIG1lYW4sIHN0ZGV2KSB7XG4gIHJldHVybiBNYXRoLmV4cChxdWFudGlsZU5vcm1hbChwLCBtZWFuLCBzdGRldikpO1xufVxuZnVuY3Rpb24gbG9nbm9ybWFsIChtZWFuLCBzdGRldikge1xuICBsZXQgbXUsIHNpZ21hO1xuICBjb25zdCBkaXN0ID0ge1xuICAgIG1lYW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgbXUgPSBfIHx8IDA7XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG11O1xuICAgICAgfVxuICAgIH0sXG4gICAgc3RkZXYoXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgc2lnbWEgPSBfID09IG51bGwgPyAxIDogXztcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gc2lnbWE7XG4gICAgICB9XG4gICAgfSxcbiAgICBzYW1wbGU6ICgpID0+IHNhbXBsZUxvZ05vcm1hbChtdSwgc2lnbWEpLFxuICAgIHBkZjogdmFsdWUgPT4gZGVuc2l0eUxvZ05vcm1hbCh2YWx1ZSwgbXUsIHNpZ21hKSxcbiAgICBjZGY6IHZhbHVlID0+IGN1bXVsYXRpdmVMb2dOb3JtYWwodmFsdWUsIG11LCBzaWdtYSksXG4gICAgaWNkZjogcCA9PiBxdWFudGlsZUxvZ05vcm1hbChwLCBtdSwgc2lnbWEpXG4gIH07XG4gIHJldHVybiBkaXN0Lm1lYW4obWVhbikuc3RkZXYoc3RkZXYpO1xufVxuXG5mdW5jdGlvbiBtaXh0dXJlIChkaXN0cywgd2VpZ2h0cykge1xuICBsZXQgbSA9IDAsXG4gICAgdztcbiAgZnVuY3Rpb24gbm9ybWFsaXplKHgpIHtcbiAgICBjb25zdCB3ID0gW107XG4gICAgbGV0IHN1bSA9IDAsXG4gICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtOyArK2kpIHtcbiAgICAgIHN1bSArPSB3W2ldID0geFtpXSA9PSBudWxsID8gMSA6ICt4W2ldO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgICB3W2ldIC89IHN1bTtcbiAgICB9XG4gICAgcmV0dXJuIHc7XG4gIH1cbiAgY29uc3QgZGlzdCA9IHtcbiAgICB3ZWlnaHRzKF8pIHtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHcgPSBub3JtYWxpemUod2VpZ2h0cyA9IF8gfHwgW10pO1xuICAgICAgICByZXR1cm4gZGlzdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3ZWlnaHRzO1xuICAgIH0sXG4gICAgZGlzdHJpYnV0aW9ucyhfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoXykge1xuICAgICAgICAgIG0gPSBfLmxlbmd0aDtcbiAgICAgICAgICBkaXN0cyA9IF87XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbSA9IDA7XG4gICAgICAgICAgZGlzdHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlzdC53ZWlnaHRzKHdlaWdodHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpc3RzO1xuICAgIH0sXG4gICAgc2FtcGxlKCkge1xuICAgICAgY29uc3QgciA9IHJhbmRvbSgpO1xuICAgICAgbGV0IGQgPSBkaXN0c1ttIC0gMV0sXG4gICAgICAgIHYgPSB3WzBdLFxuICAgICAgICBpID0gMDtcblxuICAgICAgLy8gZmlyc3Qgc2VsZWN0IGRpc3RyaWJ1dGlvblxuICAgICAgZm9yICg7IGkgPCBtIC0gMTsgdiArPSB3WysraV0pIHtcbiAgICAgICAgaWYgKHIgPCB2KSB7XG4gICAgICAgICAgZCA9IGRpc3RzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyB0aGVuIHNhbXBsZSBmcm9tIGl0XG4gICAgICByZXR1cm4gZC5zYW1wbGUoKTtcbiAgICB9LFxuICAgIHBkZih4KSB7XG4gICAgICBsZXQgcCA9IDAsXG4gICAgICAgIGkgPSAwO1xuICAgICAgZm9yICg7IGkgPCBtOyArK2kpIHtcbiAgICAgICAgcCArPSB3W2ldICogZGlzdHNbaV0ucGRmKHgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHA7XG4gICAgfSxcbiAgICBjZGYoeCkge1xuICAgICAgbGV0IHAgPSAwLFxuICAgICAgICBpID0gMDtcbiAgICAgIGZvciAoOyBpIDwgbTsgKytpKSB7XG4gICAgICAgIHAgKz0gd1tpXSAqIGRpc3RzW2ldLmNkZih4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH0sXG4gICAgaWNkZigpIHtcbiAgICAgIHRocm93IEVycm9yKCdNaXh0dXJlIGljZGYgbm90IHN1cHBvcnRlZC4nKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiBkaXN0LmRpc3RyaWJ1dGlvbnMoZGlzdHMpLndlaWdodHMod2VpZ2h0cyk7XG59XG5cbmZ1bmN0aW9uIHNhbXBsZVVuaWZvcm0obWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluID09IG51bGwgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgcmV0dXJuIG1pbiArIChtYXggLSBtaW4pICogcmFuZG9tKCk7XG59XG5mdW5jdGlvbiBkZW5zaXR5VW5pZm9ybSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluID09IG51bGwgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgcmV0dXJuIHZhbHVlID49IG1pbiAmJiB2YWx1ZSA8PSBtYXggPyAxIC8gKG1heCAtIG1pbikgOiAwO1xufVxuZnVuY3Rpb24gY3VtdWxhdGl2ZVVuaWZvcm0odmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmIChtYXggPT0gbnVsbCkge1xuICAgIG1heCA9IG1pbiA9PSBudWxsID8gMSA6IG1pbjtcbiAgICBtaW4gPSAwO1xuICB9XG4gIHJldHVybiB2YWx1ZSA8IG1pbiA/IDAgOiB2YWx1ZSA+IG1heCA/IDEgOiAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG59XG5mdW5jdGlvbiBxdWFudGlsZVVuaWZvcm0ocCwgbWluLCBtYXgpIHtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluID09IG51bGwgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgcmV0dXJuIHAgPj0gMCAmJiBwIDw9IDEgPyBtaW4gKyBwICogKG1heCAtIG1pbikgOiBOYU47XG59XG5mdW5jdGlvbiB1bmlmb3JtIChtaW4sIG1heCkge1xuICBsZXQgYSwgYjtcbiAgY29uc3QgZGlzdCA9IHtcbiAgICBtaW4oXykge1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgYSA9IF8gfHwgMDtcbiAgICAgICAgcmV0dXJuIGRpc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1heChfKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgICBiID0gXyA9PSBudWxsID8gMSA6IF87XG4gICAgICAgIHJldHVybiBkaXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgfSxcbiAgICBzYW1wbGU6ICgpID0+IHNhbXBsZVVuaWZvcm0oYSwgYiksXG4gICAgcGRmOiB2YWx1ZSA9PiBkZW5zaXR5VW5pZm9ybSh2YWx1ZSwgYSwgYiksXG4gICAgY2RmOiB2YWx1ZSA9PiBjdW11bGF0aXZlVW5pZm9ybSh2YWx1ZSwgYSwgYiksXG4gICAgaWNkZjogcCA9PiBxdWFudGlsZVVuaWZvcm0ocCwgYSwgYilcbiAgfTtcbiAgaWYgKG1heCA9PSBudWxsKSB7XG4gICAgbWF4ID0gbWluID09IG51bGwgPyAxIDogbWluO1xuICAgIG1pbiA9IDA7XG4gIH1cbiAgcmV0dXJuIGRpc3QubWluKG1pbikubWF4KG1heCk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0YW50IChkYXRhLCB4LCB5KSB7XG4gIGxldCBtZWFuID0gMCxcbiAgICBuID0gMDtcbiAgZm9yIChjb25zdCBkIG9mIGRhdGEpIHtcbiAgICBjb25zdCB2YWwgPSB5KGQpO1xuICAgIGlmICh4KGQpID09IG51bGwgfHwgdmFsID09IG51bGwgfHwgaXNOYU4odmFsKSkgY29udGludWU7XG4gICAgbWVhbiArPSAodmFsIC0gbWVhbikgLyArK247XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBbbWVhbl0sXG4gICAgcHJlZGljdDogKCkgPT4gbWVhbixcbiAgICByU3F1YXJlZDogMFxuICB9O1xufVxuXG4vLyBPcmRpbmFyeSBMZWFzdCBTcXVhcmVzXG5mdW5jdGlvbiBvbHMgKHVYLCB1WSwgdVhZLCB1WDIpIHtcbiAgY29uc3QgZGVsdGEgPSB1WDIgLSB1WCAqIHVYLFxuICAgIHNsb3BlID0gTWF0aC5hYnMoZGVsdGEpIDwgMWUtMjQgPyAwIDogKHVYWSAtIHVYICogdVkpIC8gZGVsdGEsXG4gICAgaW50ZXJjZXB0ID0gdVkgLSBzbG9wZSAqIHVYO1xuICByZXR1cm4gW2ludGVyY2VwdCwgc2xvcGVdO1xufVxuXG5mdW5jdGlvbiBwb2ludHMoZGF0YSwgeCwgeSwgc29ydCkge1xuICBkYXRhID0gZGF0YS5maWx0ZXIoZCA9PiB7XG4gICAgbGV0IHUgPSB4KGQpLFxuICAgICAgdiA9IHkoZCk7XG4gICAgcmV0dXJuIHUgIT0gbnVsbCAmJiAodSA9ICt1KSA+PSB1ICYmIHYgIT0gbnVsbCAmJiAodiA9ICt2KSA+PSB2O1xuICB9KTtcbiAgaWYgKHNvcnQpIHtcbiAgICBkYXRhLnNvcnQoKGEsIGIpID0+IHgoYSkgLSB4KGIpKTtcbiAgfVxuICBjb25zdCBuID0gZGF0YS5sZW5ndGgsXG4gICAgWCA9IG5ldyBGbG9hdDY0QXJyYXkobiksXG4gICAgWSA9IG5ldyBGbG9hdDY0QXJyYXkobik7XG5cbiAgLy8gZXh0cmFjdCB2YWx1ZXMsIGNhbGN1bGF0ZSBtZWFuc1xuICBsZXQgaSA9IDAsXG4gICAgdXggPSAwLFxuICAgIHV5ID0gMCxcbiAgICB4dixcbiAgICB5dixcbiAgICBkO1xuICBmb3IgKGQgb2YgZGF0YSkge1xuICAgIFhbaV0gPSB4diA9ICt4KGQpO1xuICAgIFlbaV0gPSB5diA9ICt5KGQpO1xuICAgICsraTtcbiAgICB1eCArPSAoeHYgLSB1eCkgLyBpO1xuICAgIHV5ICs9ICh5diAtIHV5KSAvIGk7XG4gIH1cblxuICAvLyBtZWFuIGNlbnRlciB0aGUgZGF0YVxuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgWFtpXSAtPSB1eDtcbiAgICBZW2ldIC09IHV5O1xuICB9XG4gIHJldHVybiBbWCwgWSwgdXgsIHV5XTtcbn1cbmZ1bmN0aW9uIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIGNhbGxiYWNrKSB7XG4gIGxldCBpID0gLTEsXG4gICAgdSxcbiAgICB2O1xuICBmb3IgKGNvbnN0IGQgb2YgZGF0YSkge1xuICAgIHUgPSB4KGQpO1xuICAgIHYgPSB5KGQpO1xuICAgIGlmICh1ICE9IG51bGwgJiYgKHUgPSArdSkgPj0gdSAmJiB2ICE9IG51bGwgJiYgKHYgPSArdikgPj0gdikge1xuICAgICAgY2FsbGJhY2sodSwgdiwgKytpKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gQWRhcHRlZCBmcm9tIGQzLXJlZ3Jlc3Npb24gYnkgSGFycnkgU3RldmVuc1xuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL0hhcnJ5U3RldmVucy9kMy1yZWdyZXNzaW9uL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbmZ1bmN0aW9uIHJTcXVhcmVkIChkYXRhLCB4LCB5LCB1WSwgcHJlZGljdCkge1xuICBsZXQgU1NFID0gMCxcbiAgICBTU1QgPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgY29uc3Qgc3NlID0gZHkgLSBwcmVkaWN0KGR4KSxcbiAgICAgIHNzdCA9IGR5IC0gdVk7XG4gICAgU1NFICs9IHNzZSAqIHNzZTtcbiAgICBTU1QgKz0gc3N0ICogc3N0O1xuICB9KTtcbiAgcmV0dXJuIDEgLSBTU0UgLyBTU1Q7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBkMy1yZWdyZXNzaW9uIGJ5IEhhcnJ5IFN0ZXZlbnNcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5mdW5jdGlvbiBsaW5lYXIgKGRhdGEsIHgsIHkpIHtcbiAgbGV0IFggPSAwLFxuICAgIFkgPSAwLFxuICAgIFhZID0gMCxcbiAgICBYMiA9IDAsXG4gICAgbiA9IDA7XG4gIHZpc2l0UG9pbnRzKGRhdGEsIHgsIHksIChkeCwgZHkpID0+IHtcbiAgICArK247XG4gICAgWCArPSAoZHggLSBYKSAvIG47XG4gICAgWSArPSAoZHkgLSBZKSAvIG47XG4gICAgWFkgKz0gKGR4ICogZHkgLSBYWSkgLyBuO1xuICAgIFgyICs9IChkeCAqIGR4IC0gWDIpIC8gbjtcbiAgfSk7XG4gIGNvbnN0IGNvZWYgPSBvbHMoWCwgWSwgWFksIFgyKSxcbiAgICBwcmVkaWN0ID0geCA9PiBjb2VmWzBdICsgY29lZlsxXSAqIHg7XG4gIHJldHVybiB7XG4gICAgY29lZjogY29lZixcbiAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgIHJTcXVhcmVkOiByU3F1YXJlZChkYXRhLCB4LCB5LCBZLCBwcmVkaWN0KVxuICB9O1xufVxuXG4vLyBBZGFwdGVkIGZyb20gZDMtcmVncmVzc2lvbiBieSBIYXJyeSBTdGV2ZW5zXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vSGFycnlTdGV2ZW5zL2QzLXJlZ3Jlc3Npb24vYmxvYi9tYXN0ZXIvTElDRU5TRVxuZnVuY3Rpb24gbG9nIChkYXRhLCB4LCB5KSB7XG4gIGxldCBYID0gMCxcbiAgICBZID0gMCxcbiAgICBYWSA9IDAsXG4gICAgWDIgPSAwLFxuICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgKytuO1xuICAgIGR4ID0gTWF0aC5sb2coZHgpO1xuICAgIFggKz0gKGR4IC0gWCkgLyBuO1xuICAgIFkgKz0gKGR5IC0gWSkgLyBuO1xuICAgIFhZICs9IChkeCAqIGR5IC0gWFkpIC8gbjtcbiAgICBYMiArPSAoZHggKiBkeCAtIFgyKSAvIG47XG4gIH0pO1xuICBjb25zdCBjb2VmID0gb2xzKFgsIFksIFhZLCBYMiksXG4gICAgcHJlZGljdCA9IHggPT4gY29lZlswXSArIGNvZWZbMV0gKiBNYXRoLmxvZyh4KTtcbiAgcmV0dXJuIHtcbiAgICBjb2VmOiBjb2VmLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIFksIHByZWRpY3QpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGV4cCAoZGF0YSwgeCwgeSkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KTtcbiAgbGV0IFlMID0gMCxcbiAgICBYWSA9IDAsXG4gICAgWFlMID0gMCxcbiAgICBYMlkgPSAwLFxuICAgIG4gPSAwLFxuICAgIGR4LFxuICAgIGx5LFxuICAgIHh5O1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoXywgZHkpID0+IHtcbiAgICBkeCA9IHh2W24rK107XG4gICAgbHkgPSBNYXRoLmxvZyhkeSk7XG4gICAgeHkgPSBkeCAqIGR5O1xuICAgIFlMICs9IChkeSAqIGx5IC0gWUwpIC8gbjtcbiAgICBYWSArPSAoeHkgLSBYWSkgLyBuO1xuICAgIFhZTCArPSAoeHkgKiBseSAtIFhZTCkgLyBuO1xuICAgIFgyWSArPSAoZHggKiB4eSAtIFgyWSkgLyBuO1xuICB9KTtcbiAgY29uc3QgW2MwLCBjMV0gPSBvbHMoWFkgLyB1eSwgWUwgLyB1eSwgWFlMIC8gdXksIFgyWSAvIHV5KSxcbiAgICBwcmVkaWN0ID0geCA9PiBNYXRoLmV4cChjMCArIGMxICogKHggLSB1eCkpO1xuICByZXR1cm4ge1xuICAgIGNvZWY6IFtNYXRoLmV4cChjMCAtIGMxICogdXgpLCBjMV0sXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgdXksIHByZWRpY3QpXG4gIH07XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBkMy1yZWdyZXNzaW9uIGJ5IEhhcnJ5IFN0ZXZlbnNcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9IYXJyeVN0ZXZlbnMvZDMtcmVncmVzc2lvbi9ibG9iL21hc3Rlci9MSUNFTlNFXG5mdW5jdGlvbiBwb3cgKGRhdGEsIHgsIHkpIHtcbiAgbGV0IFggPSAwLFxuICAgIFkgPSAwLFxuICAgIFhZID0gMCxcbiAgICBYMiA9IDAsXG4gICAgWVMgPSAwLFxuICAgIG4gPSAwO1xuICB2aXNpdFBvaW50cyhkYXRhLCB4LCB5LCAoZHgsIGR5KSA9PiB7XG4gICAgY29uc3QgbHggPSBNYXRoLmxvZyhkeCksXG4gICAgICBseSA9IE1hdGgubG9nKGR5KTtcbiAgICArK247XG4gICAgWCArPSAobHggLSBYKSAvIG47XG4gICAgWSArPSAobHkgLSBZKSAvIG47XG4gICAgWFkgKz0gKGx4ICogbHkgLSBYWSkgLyBuO1xuICAgIFgyICs9IChseCAqIGx4IC0gWDIpIC8gbjtcbiAgICBZUyArPSAoZHkgLSBZUykgLyBuO1xuICB9KTtcbiAgY29uc3QgY29lZiA9IG9scyhYLCBZLCBYWSwgWDIpLFxuICAgIHByZWRpY3QgPSB4ID0+IGNvZWZbMF0gKiBNYXRoLnBvdyh4LCBjb2VmWzFdKTtcbiAgY29lZlswXSA9IE1hdGguZXhwKGNvZWZbMF0pO1xuICByZXR1cm4ge1xuICAgIGNvZWY6IGNvZWYsXG4gICAgcHJlZGljdDogcHJlZGljdCxcbiAgICByU3F1YXJlZDogclNxdWFyZWQoZGF0YSwgeCwgeSwgWVMsIHByZWRpY3QpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHF1YWQgKGRhdGEsIHgsIHkpIHtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5KSxcbiAgICBuID0geHYubGVuZ3RoO1xuICBsZXQgWDIgPSAwLFxuICAgIFgzID0gMCxcbiAgICBYNCA9IDAsXG4gICAgWFkgPSAwLFxuICAgIFgyWSA9IDAsXG4gICAgaSxcbiAgICBkeCxcbiAgICBkeSxcbiAgICB4MjtcbiAgZm9yIChpID0gMDsgaSA8IG47KSB7XG4gICAgZHggPSB4dltpXTtcbiAgICBkeSA9IHl2W2krK107XG4gICAgeDIgPSBkeCAqIGR4O1xuICAgIFgyICs9ICh4MiAtIFgyKSAvIGk7XG4gICAgWDMgKz0gKHgyICogZHggLSBYMykgLyBpO1xuICAgIFg0ICs9ICh4MiAqIHgyIC0gWDQpIC8gaTtcbiAgICBYWSArPSAoZHggKiBkeSAtIFhZKSAvIGk7XG4gICAgWDJZICs9ICh4MiAqIGR5IC0gWDJZKSAvIGk7XG4gIH1cbiAgY29uc3QgWDJYMiA9IFg0IC0gWDIgKiBYMixcbiAgICBkID0gWDIgKiBYMlgyIC0gWDMgKiBYMyxcbiAgICBhID0gKFgyWSAqIFgyIC0gWFkgKiBYMykgLyBkLFxuICAgIGIgPSAoWFkgKiBYMlgyIC0gWDJZICogWDMpIC8gZCxcbiAgICBjID0gLWEgKiBYMixcbiAgICBwcmVkaWN0ID0geCA9PiB7XG4gICAgICB4ID0geCAtIHV4O1xuICAgICAgcmV0dXJuIGEgKiB4ICogeCArIGIgKiB4ICsgYyArIHV5O1xuICAgIH07XG5cbiAgLy8gdHJhbnNmb3JtIGNvZWZmaWNpZW50cyBiYWNrIGZyb20gbWVhbi1jZW50ZXJlZCBzcGFjZVxuICByZXR1cm4ge1xuICAgIGNvZWY6IFtjIC0gYiAqIHV4ICsgYSAqIHV4ICogdXggKyB1eSwgYiAtIDIgKiBhICogdXgsIGFdLFxuICAgIHByZWRpY3Q6IHByZWRpY3QsXG4gICAgclNxdWFyZWQ6IHJTcXVhcmVkKGRhdGEsIHgsIHksIHV5LCBwcmVkaWN0KVxuICB9O1xufVxuXG4vLyBBZGFwdGVkIGZyb20gZDMtcmVncmVzc2lvbiBieSBIYXJyeSBTdGV2ZW5zXG4vLyBMaWNlbnNlOiBodHRwczovL2dpdGh1Yi5jb20vSGFycnlTdGV2ZW5zL2QzLXJlZ3Jlc3Npb24vYmxvYi9tYXN0ZXIvTElDRU5TRVxuLy8gLi4uIHdoaWNoIHdhcyBhZGFwdGVkIGZyb20gcmVncmVzc2lvbi1qcyBieSBUb20gQWxleGFuZGVyXG4vLyBTb3VyY2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9Ub20tQWxleGFuZGVyL3JlZ3Jlc3Npb24tanMvYmxvYi9tYXN0ZXIvc3JjL3JlZ3Jlc3Npb24uanMjTDI0NlxuLy8gTGljZW5zZTogaHR0cHM6Ly9naXRodWIuY29tL1RvbS1BbGV4YW5kZXIvcmVncmVzc2lvbi1qcy9ibG9iL21hc3Rlci9MSUNFTlNFXG5mdW5jdGlvbiBwb2x5IChkYXRhLCB4LCB5LCBvcmRlcikge1xuICAvLyB1c2UgbW9yZSBlZmZpY2llbnQgbWV0aG9kcyBmb3IgbG93ZXIgb3JkZXJzXG4gIGlmIChvcmRlciA9PT0gMCkgcmV0dXJuIGNvbnN0YW50KGRhdGEsIHgsIHkpO1xuICBpZiAob3JkZXIgPT09IDEpIHJldHVybiBsaW5lYXIoZGF0YSwgeCwgeSk7XG4gIGlmIChvcmRlciA9PT0gMikgcmV0dXJuIHF1YWQoZGF0YSwgeCwgeSk7XG4gIGNvbnN0IFt4diwgeXYsIHV4LCB1eV0gPSBwb2ludHMoZGF0YSwgeCwgeSksXG4gICAgbiA9IHh2Lmxlbmd0aCxcbiAgICBsaHMgPSBbXSxcbiAgICByaHMgPSBbXSxcbiAgICBrID0gb3JkZXIgKyAxO1xuICBsZXQgaSwgaiwgbCwgdiwgYztcbiAgZm9yIChpID0gMDsgaSA8IGs7ICsraSkge1xuICAgIGZvciAobCA9IDAsIHYgPSAwOyBsIDwgbjsgKytsKSB7XG4gICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpKSAqIHl2W2xdO1xuICAgIH1cbiAgICBsaHMucHVzaCh2KTtcbiAgICBjID0gbmV3IEZsb2F0NjRBcnJheShrKTtcbiAgICBmb3IgKGogPSAwOyBqIDwgazsgKytqKSB7XG4gICAgICBmb3IgKGwgPSAwLCB2ID0gMDsgbCA8IG47ICsrbCkge1xuICAgICAgICB2ICs9IE1hdGgucG93KHh2W2xdLCBpICsgaik7XG4gICAgICB9XG4gICAgICBjW2pdID0gdjtcbiAgICB9XG4gICAgcmhzLnB1c2goYyk7XG4gIH1cbiAgcmhzLnB1c2gobGhzKTtcbiAgY29uc3QgY29lZiA9IGdhdXNzaWFuRWxpbWluYXRpb24ocmhzKSxcbiAgICBwcmVkaWN0ID0geCA9PiB7XG4gICAgICB4IC09IHV4O1xuICAgICAgbGV0IHkgPSB1eSArIGNvZWZbMF0gKyBjb2VmWzFdICogeCArIGNvZWZbMl0gKiB4ICogeDtcbiAgICAgIGZvciAoaSA9IDM7IGkgPCBrOyArK2kpIHkgKz0gY29lZltpXSAqIE1hdGgucG93KHgsIGkpO1xuICAgICAgcmV0dXJuIHk7XG4gICAgfTtcbiAgcmV0dXJuIHtcbiAgICBjb2VmOiB1bmNlbnRlcihrLCBjb2VmLCAtdXgsIHV5KSxcbiAgICBwcmVkaWN0OiBwcmVkaWN0LFxuICAgIHJTcXVhcmVkOiByU3F1YXJlZChkYXRhLCB4LCB5LCB1eSwgcHJlZGljdClcbiAgfTtcbn1cbmZ1bmN0aW9uIHVuY2VudGVyKGssIGEsIHgsIHkpIHtcbiAgY29uc3QgeiA9IEFycmF5KGspO1xuICBsZXQgaSwgaiwgdiwgYztcblxuICAvLyBpbml0aWFsaXplIHRvIHplcm9cbiAgZm9yIChpID0gMDsgaSA8IGs7ICsraSkgeltpXSA9IDA7XG5cbiAgLy8gcG9seW5vbWlhbCBleHBhbnNpb25cbiAgZm9yIChpID0gayAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgdiA9IGFbaV07XG4gICAgYyA9IDE7XG4gICAgeltpXSArPSB2O1xuICAgIGZvciAoaiA9IDE7IGogPD0gaTsgKytqKSB7XG4gICAgICBjICo9IChpICsgMSAtIGopIC8gajsgLy8gYmlub21pYWwgY29lZmZpY2VudFxuICAgICAgeltpIC0gal0gKz0gdiAqIE1hdGgucG93KHgsIGopICogYztcbiAgICB9XG4gIH1cblxuICAvLyBiaWFzIHRlcm1cbiAgelswXSArPSB5O1xuICByZXR1cm4gejtcbn1cblxuLy8gR2l2ZW4gYW4gYXJyYXkgZm9yIGEgdHdvLWRpbWVuc2lvbmFsIG1hdHJpeCBhbmQgdGhlIHBvbHlub21pYWwgb3JkZXIsXG4vLyBzb2x2ZSBBICogeCA9IGIgdXNpbmcgR2F1c3NpYW4gZWxpbWluYXRpb24uXG5mdW5jdGlvbiBnYXVzc2lhbkVsaW1pbmF0aW9uKG1hdHJpeCkge1xuICBjb25zdCBuID0gbWF0cml4Lmxlbmd0aCAtIDEsXG4gICAgY29lZiA9IFtdO1xuICBsZXQgaSwgaiwgaywgciwgdDtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHIgPSBpOyAvLyBtYXggcm93XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBuOyArK2opIHtcbiAgICAgIGlmIChNYXRoLmFicyhtYXRyaXhbaV1bal0pID4gTWF0aC5hYnMobWF0cml4W2ldW3JdKSkge1xuICAgICAgICByID0gajtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChrID0gaTsgayA8IG4gKyAxOyArK2spIHtcbiAgICAgIHQgPSBtYXRyaXhba11baV07XG4gICAgICBtYXRyaXhba11baV0gPSBtYXRyaXhba11bcl07XG4gICAgICBtYXRyaXhba11bcl0gPSB0O1xuICAgIH1cbiAgICBmb3IgKGogPSBpICsgMTsgaiA8IG47ICsraikge1xuICAgICAgZm9yIChrID0gbjsgayA+PSBpOyBrLS0pIHtcbiAgICAgICAgbWF0cml4W2tdW2pdIC09IG1hdHJpeFtrXVtpXSAqIG1hdHJpeFtpXVtqXSAvIG1hdHJpeFtpXVtpXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChqID0gbiAtIDE7IGogPj0gMDsgLS1qKSB7XG4gICAgdCA9IDA7XG4gICAgZm9yIChrID0gaiArIDE7IGsgPCBuOyArK2spIHtcbiAgICAgIHQgKz0gbWF0cml4W2tdW2pdICogY29lZltrXTtcbiAgICB9XG4gICAgY29lZltqXSA9IChtYXRyaXhbbl1bal0gLSB0KSAvIG1hdHJpeFtqXVtqXTtcbiAgfVxuICByZXR1cm4gY29lZjtcbn1cblxuY29uc3QgbWF4aXRlcnMgPSAyLFxuICBlcHNpbG9uID0gMWUtMTI7XG5cbi8vIEFkYXB0ZWQgZnJvbSBzY2llbmNlLmpzIGJ5IEphc29uIERhdmllc1xuLy8gU291cmNlOiBodHRwczovL2dpdGh1Yi5jb20vamFzb25kYXZpZXMvc2NpZW5jZS5qcy9ibG9iL21hc3Rlci9zcmMvc3RhdHMvbG9lc3MuanNcbi8vIExpY2Vuc2U6IGh0dHBzOi8vZ2l0aHViLmNvbS9qYXNvbmRhdmllcy9zY2llbmNlLmpzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbmZ1bmN0aW9uIGxvZXNzIChkYXRhLCB4LCB5LCBiYW5kd2lkdGgpIHtcbiAgY29uc3QgW3h2LCB5diwgdXgsIHV5XSA9IHBvaW50cyhkYXRhLCB4LCB5LCB0cnVlKSxcbiAgICBuID0geHYubGVuZ3RoLFxuICAgIGJ3ID0gTWF0aC5tYXgoMiwgfn4oYmFuZHdpZHRoICogbikpLFxuICAgIC8vICMgbmVhcmVzdCBuZWlnaGJvcnNcbiAgICB5aGF0ID0gbmV3IEZsb2F0NjRBcnJheShuKSxcbiAgICByZXNpZHVhbHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLFxuICAgIHJvYnVzdFdlaWdodHMgPSBuZXcgRmxvYXQ2NEFycmF5KG4pLmZpbGwoMSk7XG4gIGZvciAobGV0IGl0ZXIgPSAtMTsgKytpdGVyIDw9IG1heGl0ZXJzOykge1xuICAgIGNvbnN0IGludGVydmFsID0gWzAsIGJ3IC0gMV07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGR4ID0geHZbaV0sXG4gICAgICAgIGkwID0gaW50ZXJ2YWxbMF0sXG4gICAgICAgIGkxID0gaW50ZXJ2YWxbMV0sXG4gICAgICAgIGVkZ2UgPSBkeCAtIHh2W2kwXSA+IHh2W2kxXSAtIGR4ID8gaTAgOiBpMTtcbiAgICAgIGxldCBXID0gMCxcbiAgICAgICAgWCA9IDAsXG4gICAgICAgIFkgPSAwLFxuICAgICAgICBYWSA9IDAsXG4gICAgICAgIFgyID0gMDtcbiAgICAgIGNvbnN0IGRlbm9tID0gMSAvIE1hdGguYWJzKHh2W2VkZ2VdIC0gZHggfHwgMSk7IC8vIGF2b2lkIHNpbmd1bGFyaXR5IVxuXG4gICAgICBmb3IgKGxldCBrID0gaTA7IGsgPD0gaTE7ICsraykge1xuICAgICAgICBjb25zdCB4ayA9IHh2W2tdLFxuICAgICAgICAgIHlrID0geXZba10sXG4gICAgICAgICAgdyA9IHRyaWN1YmUoTWF0aC5hYnMoZHggLSB4aykgKiBkZW5vbSkgKiByb2J1c3RXZWlnaHRzW2tdLFxuICAgICAgICAgIHhrdyA9IHhrICogdztcbiAgICAgICAgVyArPSB3O1xuICAgICAgICBYICs9IHhrdztcbiAgICAgICAgWSArPSB5ayAqIHc7XG4gICAgICAgIFhZICs9IHlrICogeGt3O1xuICAgICAgICBYMiArPSB4ayAqIHhrdztcbiAgICAgIH1cblxuICAgICAgLy8gbGluZWFyIHJlZ3Jlc3Npb24gZml0XG4gICAgICBjb25zdCBbYSwgYl0gPSBvbHMoWCAvIFcsIFkgLyBXLCBYWSAvIFcsIFgyIC8gVyk7XG4gICAgICB5aGF0W2ldID0gYSArIGIgKiBkeDtcbiAgICAgIHJlc2lkdWFsc1tpXSA9IE1hdGguYWJzKHl2W2ldIC0geWhhdFtpXSk7XG4gICAgICB1cGRhdGVJbnRlcnZhbCh4diwgaSArIDEsIGludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKGl0ZXIgPT09IG1heGl0ZXJzKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgbWVkaWFuUmVzaWR1YWwgPSBtZWRpYW4ocmVzaWR1YWxzKTtcbiAgICBpZiAoTWF0aC5hYnMobWVkaWFuUmVzaWR1YWwpIDwgZXBzaWxvbikgYnJlYWs7XG4gICAgZm9yIChsZXQgaSA9IDAsIGFyZywgdzsgaSA8IG47ICsraSkge1xuICAgICAgYXJnID0gcmVzaWR1YWxzW2ldIC8gKDYgKiBtZWRpYW5SZXNpZHVhbCk7XG4gICAgICAvLyBkZWZhdWx0IHRvIGVwc2lsb24gKHJhdGhlciB0aGFuIHplcm8pIGZvciBsYXJnZSBkZXZpYXRpb25zXG4gICAgICAvLyBrZWVwaW5nIHdlaWdodHMgdGlueSBidXQgbm9uLXplcm8gcHJldmVudHMgc2luZ3VsYXJpdGVzXG4gICAgICByb2J1c3RXZWlnaHRzW2ldID0gYXJnID49IDEgPyBlcHNpbG9uIDogKHcgPSAxIC0gYXJnICogYXJnKSAqIHc7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXRwdXQoeHYsIHloYXQsIHV4LCB1eSk7XG59XG5cbi8vIHdlaWdodGluZyBrZXJuZWwgZm9yIGxvY2FsIHJlZ3Jlc3Npb25cbmZ1bmN0aW9uIHRyaWN1YmUoeCkge1xuICByZXR1cm4gKHggPSAxIC0geCAqIHggKiB4KSAqIHggKiB4O1xufVxuXG4vLyBhZHZhbmNlIHNsaWRpbmcgd2luZG93IGludGVydmFsIG9mIG5lYXJlc3QgbmVpZ2hib3JzXG5mdW5jdGlvbiB1cGRhdGVJbnRlcnZhbCh4diwgaSwgaW50ZXJ2YWwpIHtcbiAgY29uc3QgdmFsID0geHZbaV07XG4gIGxldCBsZWZ0ID0gaW50ZXJ2YWxbMF0sXG4gICAgcmlnaHQgPSBpbnRlcnZhbFsxXSArIDE7XG4gIGlmIChyaWdodCA+PSB4di5sZW5ndGgpIHJldHVybjtcblxuICAvLyBzdGVwIHJpZ2h0IGlmIGRpc3RhbmNlIHRvIG5ldyByaWdodCBlZGdlIGlzIDw9IGRpc3RhbmNlIHRvIG9sZCBsZWZ0IGVkZ2VcbiAgLy8gc3RlcCB3aGVuIGRpc3RhbmNlIGlzIGVxdWFsIHRvIGVuc3VyZSBtb3ZlbWVudCBvdmVyIGR1cGxpY2F0ZSB4IHZhbHVlc1xuICB3aGlsZSAoaSA+IGxlZnQgJiYgeHZbcmlnaHRdIC0gdmFsIDw9IHZhbCAtIHh2W2xlZnRdKSB7XG4gICAgaW50ZXJ2YWxbMF0gPSArK2xlZnQ7XG4gICAgaW50ZXJ2YWxbMV0gPSByaWdodDtcbiAgICArK3JpZ2h0O1xuICB9XG59XG5cbi8vIGdlbmVyYXRlIHNtb290aGVkIG91dHB1dCBwb2ludHNcbi8vIGF2ZXJhZ2UgcG9pbnRzIHdpdGggcmVwZWF0ZWQgeCB2YWx1ZXNcbmZ1bmN0aW9uIG91dHB1dCh4diwgeWhhdCwgdXgsIHV5KSB7XG4gIGNvbnN0IG4gPSB4di5sZW5ndGgsXG4gICAgb3V0ID0gW107XG4gIGxldCBpID0gMCxcbiAgICBjbnQgPSAwLFxuICAgIHByZXYgPSBbXSxcbiAgICB2O1xuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIHYgPSB4dltpXSArIHV4O1xuICAgIGlmIChwcmV2WzBdID09PSB2KSB7XG4gICAgICAvLyBhdmVyYWdlIG91dHB1dCB2YWx1ZXMgdmlhIG9ubGluZSB1cGRhdGVcbiAgICAgIHByZXZbMV0gKz0gKHloYXRbaV0gLSBwcmV2WzFdKSAvICsrY250O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhZGQgbmV3IG91dHB1dCBwb2ludFxuICAgICAgY250ID0gMDtcbiAgICAgIHByZXZbMV0gKz0gdXk7XG4gICAgICBwcmV2ID0gW3YsIHloYXRbaV1dO1xuICAgICAgb3V0LnB1c2gocHJldik7XG4gICAgfVxuICB9XG4gIHByZXZbMV0gKz0gdXk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIHN1YmRpdmlkZSB1cCB0byBhY2N1cmFjeSBvZiAwLjUgZGVncmVlc1xuY29uc3QgTUlOX1JBRElBTlMgPSAwLjUgKiBNYXRoLlBJIC8gMTgwO1xuXG4vLyBBZGFwdGl2ZWx5IHNhbXBsZSBhbiBpbnRlcnBvbGF0ZWQgZnVuY3Rpb24gb3ZlciBhIGRvbWFpbiBleHRlbnRcbmZ1bmN0aW9uIHNhbXBsZUN1cnZlIChmLCBleHRlbnQsIG1pblN0ZXBzLCBtYXhTdGVwcykge1xuICBtaW5TdGVwcyA9IG1pblN0ZXBzIHx8IDI1O1xuICBtYXhTdGVwcyA9IE1hdGgubWF4KG1pblN0ZXBzLCBtYXhTdGVwcyB8fCAyMDApO1xuICBjb25zdCBwb2ludCA9IHggPT4gW3gsIGYoeCldLFxuICAgIG1pblggPSBleHRlbnRbMF0sXG4gICAgbWF4WCA9IGV4dGVudFsxXSxcbiAgICBzcGFuID0gbWF4WCAtIG1pblgsXG4gICAgc3RvcCA9IHNwYW4gLyBtYXhTdGVwcyxcbiAgICBwcmV2ID0gW3BvaW50KG1pblgpXSxcbiAgICBuZXh0ID0gW107XG4gIGlmIChtaW5TdGVwcyA9PT0gbWF4U3RlcHMpIHtcbiAgICAvLyBubyBhZGFwdGF0aW9uLCBzYW1wbGUgdW5pZm9ybSBncmlkIGRpcmVjdGx5IGFuZCByZXR1cm5cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1heFN0ZXBzOyArK2kpIHtcbiAgICAgIHByZXYucHVzaChwb2ludChtaW5YICsgaSAvIG1pblN0ZXBzICogc3BhbikpO1xuICAgIH1cbiAgICBwcmV2LnB1c2gocG9pbnQobWF4WCkpO1xuICAgIHJldHVybiBwcmV2O1xuICB9IGVsc2Uge1xuICAgIC8vIHNhbXBsZSBtaW5pbXVtIHBvaW50cyBvbiB1bmlmb3JtIGdyaWRcbiAgICAvLyB0aGVuIG1vdmUgb24gdG8gcGVyZm9ybSBhZGFwdGl2ZSByZWZpbmVtZW50XG4gICAgbmV4dC5wdXNoKHBvaW50KG1heFgpKTtcbiAgICBmb3IgKGxldCBpID0gbWluU3RlcHM7IC0taSA+IDA7KSB7XG4gICAgICBuZXh0LnB1c2gocG9pbnQobWluWCArIGkgLyBtaW5TdGVwcyAqIHNwYW4pKTtcbiAgICB9XG4gIH1cbiAgbGV0IHAwID0gcHJldlswXTtcbiAgbGV0IHAxID0gbmV4dFtuZXh0Lmxlbmd0aCAtIDFdO1xuICBjb25zdCBzeCA9IDEgLyBzcGFuO1xuICBjb25zdCBzeSA9IHNjYWxlWShwMFsxXSwgbmV4dCk7XG4gIHdoaWxlIChwMSkge1xuICAgIC8vIG1pZHBvaW50IGZvciBwb3RlbnRpYWwgY3VydmUgc3ViZGl2aXNpb25cbiAgICBjb25zdCBwbSA9IHBvaW50KChwMFswXSArIHAxWzBdKSAvIDIpO1xuICAgIGNvbnN0IGR4ID0gcG1bMF0gLSBwMFswXSA+PSBzdG9wO1xuICAgIGlmIChkeCAmJiBhbmdsZURlbHRhKHAwLCBwbSwgcDEsIHN4LCBzeSkgPiBNSU5fUkFESUFOUykge1xuICAgICAgLy8gbWF4aW11bSByZXNvbHV0aW9uIGhhcyBub3QgeWV0IGJlZW4gbWV0LCBhbmRcbiAgICAgIC8vIHN1YmRpdmlzaW9uIG1pZHBvaW50IGlzIHN1ZmZpY2llbnRseSBkaWZmZXJlbnQgZnJvbSBlbmRwb2ludFxuICAgICAgLy8gc2F2ZSBzdWJkaXZpc2lvbiwgcHVzaCBtaWRwb2ludCBvbnRvIHRoZSB2aXNpdGF0aW9uIHN0YWNrXG4gICAgICBuZXh0LnB1c2gocG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBzdWJkaXZpc2lvbiBtaWRwb2ludCBzdWZmaWNpZW50bHkgc2ltaWxhciB0byBlbmRwb2ludFxuICAgICAgLy8gc2tpcCBzdWJkaXZpc2lvbiwgc3RvcmUgZW5kcG9pbnQsIG1vdmUgdG8gbmV4dCBwb2ludCBvbiB0aGUgc3RhY2tcbiAgICAgIHAwID0gcDE7XG4gICAgICBwcmV2LnB1c2gocDEpO1xuICAgICAgbmV4dC5wb3AoKTtcbiAgICB9XG4gICAgcDEgPSBuZXh0W25leHQubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIHByZXY7XG59XG5mdW5jdGlvbiBzY2FsZVkoaW5pdCwgcG9pbnRzKSB7XG4gIGxldCB5bWluID0gaW5pdDtcbiAgbGV0IHltYXggPSBpbml0O1xuICBjb25zdCBuID0gcG9pbnRzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBjb25zdCB5ID0gcG9pbnRzW2ldWzFdO1xuICAgIGlmICh5IDwgeW1pbikgeW1pbiA9IHk7XG4gICAgaWYgKHkgPiB5bWF4KSB5bWF4ID0geTtcbiAgfVxuICByZXR1cm4gMSAvICh5bWF4IC0geW1pbik7XG59XG5mdW5jdGlvbiBhbmdsZURlbHRhKHAsIHEsIHIsIHN4LCBzeSkge1xuICBjb25zdCBhMCA9IE1hdGguYXRhbjIoc3kgKiAoclsxXSAtIHBbMV0pLCBzeCAqIChyWzBdIC0gcFswXSkpLFxuICAgIGExID0gTWF0aC5hdGFuMihzeSAqIChxWzFdIC0gcFsxXSksIHN4ICogKHFbMF0gLSBwWzBdKSk7XG4gIHJldHVybiBNYXRoLmFicyhhMCAtIGExKTtcbn1cblxuZXhwb3J0IHsgZXN0aW1hdGVCYW5kd2lkdGggYXMgYmFuZHdpZHRoTlJELCBiaW4sIGJvb3RzdHJhcENJLCBjdW11bGF0aXZlTG9nTm9ybWFsLCBjdW11bGF0aXZlTm9ybWFsLCBjdW11bGF0aXZlVW5pZm9ybSwgZGVuc2l0eUxvZ05vcm1hbCwgZGVuc2l0eU5vcm1hbCwgZGVuc2l0eVVuaWZvcm0sIGRvdGJpbiwgcXVhbnRpbGVMb2dOb3JtYWwsIHF1YW50aWxlTm9ybWFsLCBxdWFudGlsZVVuaWZvcm0sIHF1YW50aWxlcywgcXVhcnRpbGVzLCByYW5kb20sIGludGVnZXIgYXMgcmFuZG9tSW50ZWdlciwga2RlIGFzIHJhbmRvbUtERSwgbGNnIGFzIHJhbmRvbUxDRywgbG9nbm9ybWFsIGFzIHJhbmRvbUxvZ05vcm1hbCwgbWl4dHVyZSBhcyByYW5kb21NaXh0dXJlLCBnYXVzc2lhbiBhcyByYW5kb21Ob3JtYWwsIHVuaWZvcm0gYXMgcmFuZG9tVW5pZm9ybSwgY29uc3RhbnQgYXMgcmVncmVzc2lvbkNvbnN0YW50LCBleHAgYXMgcmVncmVzc2lvbkV4cCwgbGluZWFyIGFzIHJlZ3Jlc3Npb25MaW5lYXIsIGxvZXNzIGFzIHJlZ3Jlc3Npb25Mb2VzcywgbG9nIGFzIHJlZ3Jlc3Npb25Mb2csIHBvbHkgYXMgcmVncmVzc2lvblBvbHksIHBvdyBhcyByZWdyZXNzaW9uUG93LCBxdWFkIGFzIHJlZ3Jlc3Npb25RdWFkLCBzYW1wbGVDdXJ2ZSwgc2FtcGxlTG9nTm9ybWFsLCBzYW1wbGVOb3JtYWwsIHNhbXBsZVVuaWZvcm0sIHNldFJhbmRvbSB9O1xuIiwiaW1wb3J0IHsgYXJyYXksIGVycm9yLCBoYXNPd25Qcm9wZXJ0eSwgZXh0ZW5kLCBwZWVrLCB0b1NldCwgY29uc3RhbnQsIHplcm8sIG9uZSwgc3BhbiB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyB0aW1lRGF5LCB0aW1lV2VlaywgdXRjRGF5LCB1dGNXZWVrLCB0aW1lWWVhciwgdGltZU1vbnRoLCB0aW1lSG91ciwgdGltZU1pbnV0ZSwgdGltZVNlY29uZCwgdGltZU1pbGxpc2Vjb25kLCB1dGNZZWFyLCB1dGNNb250aCwgdXRjSG91ciwgdXRjTWludXRlLCB1dGNTZWNvbmQsIHV0Y01pbGxpc2Vjb25kIH0gZnJvbSAnZDMtdGltZSc7XG5pbXBvcnQgeyBiaXNlY3RvciwgdGlja1N0ZXAgfSBmcm9tICdkMy1hcnJheSc7XG5cbmNvbnN0IFlFQVIgPSAneWVhcic7XG5jb25zdCBRVUFSVEVSID0gJ3F1YXJ0ZXInO1xuY29uc3QgTU9OVEggPSAnbW9udGgnO1xuY29uc3QgV0VFSyA9ICd3ZWVrJztcbmNvbnN0IERBVEUgPSAnZGF0ZSc7XG5jb25zdCBEQVkgPSAnZGF5JztcbmNvbnN0IERBWU9GWUVBUiA9ICdkYXlvZnllYXInO1xuY29uc3QgSE9VUlMgPSAnaG91cnMnO1xuY29uc3QgTUlOVVRFUyA9ICdtaW51dGVzJztcbmNvbnN0IFNFQ09ORFMgPSAnc2Vjb25kcyc7XG5jb25zdCBNSUxMSVNFQ09ORFMgPSAnbWlsbGlzZWNvbmRzJztcbmNvbnN0IFRJTUVfVU5JVFMgPSBbWUVBUiwgUVVBUlRFUiwgTU9OVEgsIFdFRUssIERBVEUsIERBWSwgREFZT0ZZRUFSLCBIT1VSUywgTUlOVVRFUywgU0VDT05EUywgTUlMTElTRUNPTkRTXTtcbmNvbnN0IFVOSVRTID0gVElNRV9VTklUUy5yZWR1Y2UoKG8sIHUsIGkpID0+IChvW3VdID0gMSArIGksIG8pLCB7fSk7XG5mdW5jdGlvbiB0aW1lVW5pdHModW5pdHMpIHtcbiAgY29uc3QgdSA9IGFycmF5KHVuaXRzKS5zbGljZSgpLFxuICAgIG0gPSB7fTtcblxuICAvLyBjaGVjayB2YWxpZGl0eVxuICBpZiAoIXUubGVuZ3RoKSBlcnJvcignTWlzc2luZyB0aW1lIHVuaXQuJyk7XG4gIHUuZm9yRWFjaCh1bml0ID0+IHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkoVU5JVFMsIHVuaXQpKSB7XG4gICAgICBtW3VuaXRdID0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoYEludmFsaWQgdGltZSB1bml0OiAke3VuaXR9LmApO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG51bVR5cGVzID0gKG1bV0VFS10gfHwgbVtEQVldID8gMSA6IDApICsgKG1bUVVBUlRFUl0gfHwgbVtNT05USF0gfHwgbVtEQVRFXSA/IDEgOiAwKSArIChtW0RBWU9GWUVBUl0gPyAxIDogMCk7XG4gIGlmIChudW1UeXBlcyA+IDEpIHtcbiAgICBlcnJvcihgSW5jb21wYXRpYmxlIHRpbWUgdW5pdHM6ICR7dW5pdHN9YCk7XG4gIH1cblxuICAvLyBlbnN1cmUgcHJvcGVyIHNvcnQgb3JkZXJcbiAgdS5zb3J0KChhLCBiKSA9PiBVTklUU1thXSAtIFVOSVRTW2JdKTtcbiAgcmV0dXJuIHU7XG59XG5jb25zdCBkZWZhdWx0U3BlY2lmaWVycyA9IHtcbiAgW1lFQVJdOiAnJVkgJyxcbiAgW1FVQVJURVJdOiAnUSVxICcsXG4gIFtNT05USF06ICclYiAnLFxuICBbREFURV06ICclZCAnLFxuICBbV0VFS106ICdXJVUgJyxcbiAgW0RBWV06ICclYSAnLFxuICBbREFZT0ZZRUFSXTogJyVqICcsXG4gIFtIT1VSU106ICclSDowMCcsXG4gIFtNSU5VVEVTXTogJzAwOiVNJyxcbiAgW1NFQ09ORFNdOiAnOiVTJyxcbiAgW01JTExJU0VDT05EU106ICcuJUwnLFxuICBbYCR7WUVBUn0tJHtNT05USH1gXTogJyVZLSVtICcsXG4gIFtgJHtZRUFSfS0ke01PTlRIfS0ke0RBVEV9YF06ICclWS0lbS0lZCAnLFxuICBbYCR7SE9VUlN9LSR7TUlOVVRFU31gXTogJyVIOiVNJ1xufTtcbmZ1bmN0aW9uIHRpbWVVbml0U3BlY2lmaWVyKHVuaXRzLCBzcGVjaWZpZXJzKSB7XG4gIGNvbnN0IHMgPSBleHRlbmQoe30sIGRlZmF1bHRTcGVjaWZpZXJzLCBzcGVjaWZpZXJzKSxcbiAgICB1ID0gdGltZVVuaXRzKHVuaXRzKSxcbiAgICBuID0gdS5sZW5ndGg7XG4gIGxldCBmbXQgPSAnJyxcbiAgICBzdGFydCA9IDAsXG4gICAgZW5kLFxuICAgIGtleTtcbiAgZm9yIChzdGFydCA9IDA7IHN0YXJ0IDwgbjspIHtcbiAgICBmb3IgKGVuZCA9IHUubGVuZ3RoOyBlbmQgPiBzdGFydDsgLS1lbmQpIHtcbiAgICAgIGtleSA9IHUuc2xpY2Uoc3RhcnQsIGVuZCkuam9pbignLScpO1xuICAgICAgaWYgKHNba2V5XSAhPSBudWxsKSB7XG4gICAgICAgIGZtdCArPSBzW2tleV07XG4gICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZtdC50cmltKCk7XG59XG5cbmNvbnN0IHQwID0gbmV3IERhdGUoKTtcbmZ1bmN0aW9uIGxvY2FsWWVhcih5KSB7XG4gIHQwLnNldEZ1bGxZZWFyKHkpO1xuICB0MC5zZXRNb250aCgwKTtcbiAgdDAuc2V0RGF0ZSgxKTtcbiAgdDAuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiB0MDtcbn1cbmZ1bmN0aW9uIGRheW9meWVhcihkKSB7XG4gIHJldHVybiBsb2NhbERheU9mWWVhcihuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiB3ZWVrKGQpIHtcbiAgcmV0dXJuIGxvY2FsV2Vla051bShuZXcgRGF0ZShkKSk7XG59XG5mdW5jdGlvbiBsb2NhbERheU9mWWVhcihkKSB7XG4gIHJldHVybiB0aW1lRGF5LmNvdW50KGxvY2FsWWVhcihkLmdldEZ1bGxZZWFyKCkpIC0gMSwgZCk7XG59XG5mdW5jdGlvbiBsb2NhbFdlZWtOdW0oZCkge1xuICByZXR1cm4gdGltZVdlZWsuY291bnQobG9jYWxZZWFyKGQuZ2V0RnVsbFllYXIoKSkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIGxvY2FsRmlyc3QoeSkge1xuICByZXR1cm4gbG9jYWxZZWFyKHkpLmdldERheSgpO1xufVxuZnVuY3Rpb24gbG9jYWxEYXRlKHksIG0sIGQsIEgsIE0sIFMsIEwpIHtcbiAgaWYgKDAgPD0geSAmJiB5IDwgMTAwKSB7XG4gICAgY29uc3QgZGF0ZSA9IG5ldyBEYXRlKC0xLCBtLCBkLCBILCBNLCBTLCBMKTtcbiAgICBkYXRlLnNldEZ1bGxZZWFyKHkpO1xuICAgIHJldHVybiBkYXRlO1xuICB9XG4gIHJldHVybiBuZXcgRGF0ZSh5LCBtLCBkLCBILCBNLCBTLCBMKTtcbn1cbmZ1bmN0aW9uIHV0Y2RheW9meWVhcihkKSB7XG4gIHJldHVybiB1dGNEYXlPZlllYXIobmV3IERhdGUoZCkpO1xufVxuZnVuY3Rpb24gdXRjd2VlayhkKSB7XG4gIHJldHVybiB1dGNXZWVrTnVtKG5ldyBEYXRlKGQpKTtcbn1cbmZ1bmN0aW9uIHV0Y0RheU9mWWVhcihkKSB7XG4gIGNvbnN0IHkgPSBEYXRlLlVUQyhkLmdldFVUQ0Z1bGxZZWFyKCksIDAsIDEpO1xuICByZXR1cm4gdXRjRGF5LmNvdW50KHkgLSAxLCBkKTtcbn1cbmZ1bmN0aW9uIHV0Y1dlZWtOdW0oZCkge1xuICBjb25zdCB5ID0gRGF0ZS5VVEMoZC5nZXRVVENGdWxsWWVhcigpLCAwLCAxKTtcbiAgcmV0dXJuIHV0Y1dlZWsuY291bnQoeSAtIDEsIGQpO1xufVxuZnVuY3Rpb24gdXRjRmlyc3QoeSkge1xuICB0MC5zZXRUaW1lKERhdGUuVVRDKHksIDAsIDEpKTtcbiAgcmV0dXJuIHQwLmdldFVUQ0RheSgpO1xufVxuZnVuY3Rpb24gdXRjRGF0ZSh5LCBtLCBkLCBILCBNLCBTLCBMKSB7XG4gIGlmICgwIDw9IHkgJiYgeSA8IDEwMCkge1xuICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShEYXRlLlVUQygtMSwgbSwgZCwgSCwgTSwgUywgTCkpO1xuICAgIGRhdGUuc2V0VVRDRnVsbFllYXIoZC55KTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxuICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoeSwgbSwgZCwgSCwgTSwgUywgTCkpO1xufVxuXG5mdW5jdGlvbiBmbG9vcih1bml0cywgc3RlcCwgZ2V0LCBpbnYsIG5ld0RhdGUpIHtcbiAgY29uc3QgcyA9IHN0ZXAgfHwgMSxcbiAgICBiID0gcGVlayh1bml0cyksXG4gICAgXyA9ICh1bml0LCBwLCBrZXkpID0+IHtcbiAgICAgIGtleSA9IGtleSB8fCB1bml0O1xuICAgICAgcmV0dXJuIGdldFVuaXQoZ2V0W2tleV0sIGludltrZXldLCB1bml0ID09PSBiICYmIHMsIHApO1xuICAgIH07XG4gIGNvbnN0IHQgPSBuZXcgRGF0ZSgpLFxuICAgIHUgPSB0b1NldCh1bml0cyksXG4gICAgeSA9IHVbWUVBUl0gPyBfKFlFQVIpIDogY29uc3RhbnQoMjAxMiksXG4gICAgbSA9IHVbTU9OVEhdID8gXyhNT05USCkgOiB1W1FVQVJURVJdID8gXyhRVUFSVEVSKSA6IHplcm8sXG4gICAgZCA9IHVbV0VFS10gJiYgdVtEQVldID8gXyhEQVksIDEsIFdFRUsgKyBEQVkpIDogdVtXRUVLXSA/IF8oV0VFSywgMSkgOiB1W0RBWV0gPyBfKERBWSwgMSkgOiB1W0RBVEVdID8gXyhEQVRFLCAxKSA6IHVbREFZT0ZZRUFSXSA/IF8oREFZT0ZZRUFSLCAxKSA6IG9uZSxcbiAgICBIID0gdVtIT1VSU10gPyBfKEhPVVJTKSA6IHplcm8sXG4gICAgTSA9IHVbTUlOVVRFU10gPyBfKE1JTlVURVMpIDogemVybyxcbiAgICBTID0gdVtTRUNPTkRTXSA/IF8oU0VDT05EUykgOiB6ZXJvLFxuICAgIEwgPSB1W01JTExJU0VDT05EU10gPyBfKE1JTExJU0VDT05EUykgOiB6ZXJvO1xuICByZXR1cm4gZnVuY3Rpb24gKHYpIHtcbiAgICB0LnNldFRpbWUoK3YpO1xuICAgIGNvbnN0IHllYXIgPSB5KHQpO1xuICAgIHJldHVybiBuZXdEYXRlKHllYXIsIG0odCksIGQodCwgeWVhciksIEgodCksIE0odCksIFModCksIEwodCkpO1xuICB9O1xufVxuZnVuY3Rpb24gZ2V0VW5pdChmLCBpbnYsIHN0ZXAsIHBoYXNlKSB7XG4gIGNvbnN0IHUgPSBzdGVwIDw9IDEgPyBmIDogcGhhc2UgPyAoZCwgeSkgPT4gcGhhc2UgKyBzdGVwICogTWF0aC5mbG9vcigoZihkLCB5KSAtIHBoYXNlKSAvIHN0ZXApIDogKGQsIHkpID0+IHN0ZXAgKiBNYXRoLmZsb29yKGYoZCwgeSkgLyBzdGVwKTtcbiAgcmV0dXJuIGludiA/IChkLCB5KSA9PiBpbnYodShkLCB5KSwgeSkgOiB1O1xufVxuXG4vLyByZXR1cm5zIHRoZSBkYXkgb2YgdGhlIHllYXIgYmFzZWQgb24gd2VlayBudW1iZXIsIGRheSBvZiB3ZWVrLFxuLy8gYW5kIHRoZSBkYXkgb2YgdGhlIHdlZWsgZm9yIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHllYXJcbmZ1bmN0aW9uIHdlZWtkYXkod2VlaywgZGF5LCBmaXJzdERheSkge1xuICByZXR1cm4gZGF5ICsgd2VlayAqIDcgLSAoZmlyc3REYXkgKyA2KSAlIDc7XG59XG5cbi8vIC0tIExPQ0FMIFRJTUUgLS1cblxuY29uc3QgbG9jYWxHZXQgPSB7XG4gIFtZRUFSXTogZCA9PiBkLmdldEZ1bGxZZWFyKCksXG4gIFtRVUFSVEVSXTogZCA9PiBNYXRoLmZsb29yKGQuZ2V0TW9udGgoKSAvIDMpLFxuICBbTU9OVEhdOiBkID0+IGQuZ2V0TW9udGgoKSxcbiAgW0RBVEVdOiBkID0+IGQuZ2V0RGF0ZSgpLFxuICBbSE9VUlNdOiBkID0+IGQuZ2V0SG91cnMoKSxcbiAgW01JTlVURVNdOiBkID0+IGQuZ2V0TWludXRlcygpLFxuICBbU0VDT05EU106IGQgPT4gZC5nZXRTZWNvbmRzKCksXG4gIFtNSUxMSVNFQ09ORFNdOiBkID0+IGQuZ2V0TWlsbGlzZWNvbmRzKCksXG4gIFtEQVlPRllFQVJdOiBkID0+IGxvY2FsRGF5T2ZZZWFyKGQpLFxuICBbV0VFS106IGQgPT4gbG9jYWxXZWVrTnVtKGQpLFxuICBbV0VFSyArIERBWV06IChkLCB5KSA9PiB3ZWVrZGF5KGxvY2FsV2Vla051bShkKSwgZC5nZXREYXkoKSwgbG9jYWxGaXJzdCh5KSksXG4gIFtEQVldOiAoZCwgeSkgPT4gd2Vla2RheSgxLCBkLmdldERheSgpLCBsb2NhbEZpcnN0KHkpKVxufTtcbmNvbnN0IGxvY2FsSW52ID0ge1xuICBbUVVBUlRFUl06IHEgPT4gMyAqIHEsXG4gIFtXRUVLXTogKHcsIHkpID0+IHdlZWtkYXkodywgMCwgbG9jYWxGaXJzdCh5KSlcbn07XG5mdW5jdGlvbiB0aW1lRmxvb3IodW5pdHMsIHN0ZXApIHtcbiAgcmV0dXJuIGZsb29yKHVuaXRzLCBzdGVwIHx8IDEsIGxvY2FsR2V0LCBsb2NhbEludiwgbG9jYWxEYXRlKTtcbn1cblxuLy8gLS0gVVRDIFRJTUUgLS1cblxuY29uc3QgdXRjR2V0ID0ge1xuICBbWUVBUl06IGQgPT4gZC5nZXRVVENGdWxsWWVhcigpLFxuICBbUVVBUlRFUl06IGQgPT4gTWF0aC5mbG9vcihkLmdldFVUQ01vbnRoKCkgLyAzKSxcbiAgW01PTlRIXTogZCA9PiBkLmdldFVUQ01vbnRoKCksXG4gIFtEQVRFXTogZCA9PiBkLmdldFVUQ0RhdGUoKSxcbiAgW0hPVVJTXTogZCA9PiBkLmdldFVUQ0hvdXJzKCksXG4gIFtNSU5VVEVTXTogZCA9PiBkLmdldFVUQ01pbnV0ZXMoKSxcbiAgW1NFQ09ORFNdOiBkID0+IGQuZ2V0VVRDU2Vjb25kcygpLFxuICBbTUlMTElTRUNPTkRTXTogZCA9PiBkLmdldFVUQ01pbGxpc2Vjb25kcygpLFxuICBbREFZT0ZZRUFSXTogZCA9PiB1dGNEYXlPZlllYXIoZCksXG4gIFtXRUVLXTogZCA9PiB1dGNXZWVrTnVtKGQpLFxuICBbREFZXTogKGQsIHkpID0+IHdlZWtkYXkoMSwgZC5nZXRVVENEYXkoKSwgdXRjRmlyc3QoeSkpLFxuICBbV0VFSyArIERBWV06IChkLCB5KSA9PiB3ZWVrZGF5KHV0Y1dlZWtOdW0oZCksIGQuZ2V0VVRDRGF5KCksIHV0Y0ZpcnN0KHkpKVxufTtcbmNvbnN0IHV0Y0ludiA9IHtcbiAgW1FVQVJURVJdOiBxID0+IDMgKiBxLFxuICBbV0VFS106ICh3LCB5KSA9PiB3ZWVrZGF5KHcsIDAsIHV0Y0ZpcnN0KHkpKVxufTtcbmZ1bmN0aW9uIHV0Y0Zsb29yKHVuaXRzLCBzdGVwKSB7XG4gIHJldHVybiBmbG9vcih1bml0cywgc3RlcCB8fCAxLCB1dGNHZXQsIHV0Y0ludiwgdXRjRGF0ZSk7XG59XG5cbmNvbnN0IHRpbWVJbnRlcnZhbHMgPSB7XG4gIFtZRUFSXTogdGltZVllYXIsXG4gIFtRVUFSVEVSXTogdGltZU1vbnRoLmV2ZXJ5KDMpLFxuICBbTU9OVEhdOiB0aW1lTW9udGgsXG4gIFtXRUVLXTogdGltZVdlZWssXG4gIFtEQVRFXTogdGltZURheSxcbiAgW0RBWV06IHRpbWVEYXksXG4gIFtEQVlPRllFQVJdOiB0aW1lRGF5LFxuICBbSE9VUlNdOiB0aW1lSG91cixcbiAgW01JTlVURVNdOiB0aW1lTWludXRlLFxuICBbU0VDT05EU106IHRpbWVTZWNvbmQsXG4gIFtNSUxMSVNFQ09ORFNdOiB0aW1lTWlsbGlzZWNvbmRcbn07XG5jb25zdCB1dGNJbnRlcnZhbHMgPSB7XG4gIFtZRUFSXTogdXRjWWVhcixcbiAgW1FVQVJURVJdOiB1dGNNb250aC5ldmVyeSgzKSxcbiAgW01PTlRIXTogdXRjTW9udGgsXG4gIFtXRUVLXTogdXRjV2VlayxcbiAgW0RBVEVdOiB1dGNEYXksXG4gIFtEQVldOiB1dGNEYXksXG4gIFtEQVlPRllFQVJdOiB1dGNEYXksXG4gIFtIT1VSU106IHV0Y0hvdXIsXG4gIFtNSU5VVEVTXTogdXRjTWludXRlLFxuICBbU0VDT05EU106IHV0Y1NlY29uZCxcbiAgW01JTExJU0VDT05EU106IHV0Y01pbGxpc2Vjb25kXG59O1xuZnVuY3Rpb24gdGltZUludGVydmFsKHVuaXQpIHtcbiAgcmV0dXJuIHRpbWVJbnRlcnZhbHNbdW5pdF07XG59XG5mdW5jdGlvbiB1dGNJbnRlcnZhbCh1bml0KSB7XG4gIHJldHVybiB1dGNJbnRlcnZhbHNbdW5pdF07XG59XG5mdW5jdGlvbiBvZmZzZXQoaXZhbCwgZGF0ZSwgc3RlcCkge1xuICByZXR1cm4gaXZhbCA/IGl2YWwub2Zmc2V0KGRhdGUsIHN0ZXApIDogdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gdGltZU9mZnNldCh1bml0LCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBvZmZzZXQodGltZUludGVydmFsKHVuaXQpLCBkYXRlLCBzdGVwKTtcbn1cbmZ1bmN0aW9uIHV0Y09mZnNldCh1bml0LCBkYXRlLCBzdGVwKSB7XG4gIHJldHVybiBvZmZzZXQodXRjSW50ZXJ2YWwodW5pdCksIGRhdGUsIHN0ZXApO1xufVxuZnVuY3Rpb24gc2VxdWVuY2UoaXZhbCwgc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgcmV0dXJuIGl2YWwgPyBpdmFsLnJhbmdlKHN0YXJ0LCBzdG9wLCBzdGVwKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHRpbWVTZXF1ZW5jZSh1bml0LCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICByZXR1cm4gc2VxdWVuY2UodGltZUludGVydmFsKHVuaXQpLCBzdGFydCwgc3RvcCwgc3RlcCk7XG59XG5mdW5jdGlvbiB1dGNTZXF1ZW5jZSh1bml0LCBzdGFydCwgc3RvcCwgc3RlcCkge1xuICByZXR1cm4gc2VxdWVuY2UodXRjSW50ZXJ2YWwodW5pdCksIHN0YXJ0LCBzdG9wLCBzdGVwKTtcbn1cblxuY29uc3QgZHVyYXRpb25TZWNvbmQgPSAxMDAwLFxuICBkdXJhdGlvbk1pbnV0ZSA9IGR1cmF0aW9uU2Vjb25kICogNjAsXG4gIGR1cmF0aW9uSG91ciA9IGR1cmF0aW9uTWludXRlICogNjAsXG4gIGR1cmF0aW9uRGF5ID0gZHVyYXRpb25Ib3VyICogMjQsXG4gIGR1cmF0aW9uV2VlayA9IGR1cmF0aW9uRGF5ICogNyxcbiAgZHVyYXRpb25Nb250aCA9IGR1cmF0aW9uRGF5ICogMzAsXG4gIGR1cmF0aW9uWWVhciA9IGR1cmF0aW9uRGF5ICogMzY1O1xuY29uc3QgTWlsbGkgPSBbWUVBUiwgTU9OVEgsIERBVEUsIEhPVVJTLCBNSU5VVEVTLCBTRUNPTkRTLCBNSUxMSVNFQ09ORFNdLFxuICBTZWNvbmRzID0gTWlsbGkuc2xpY2UoMCwgLTEpLFxuICBNaW51dGVzID0gU2Vjb25kcy5zbGljZSgwLCAtMSksXG4gIEhvdXJzID0gTWludXRlcy5zbGljZSgwLCAtMSksXG4gIERheSA9IEhvdXJzLnNsaWNlKDAsIC0xKSxcbiAgV2VlayA9IFtZRUFSLCBXRUVLXSxcbiAgTW9udGggPSBbWUVBUiwgTU9OVEhdLFxuICBZZWFyID0gW1lFQVJdO1xuY29uc3QgaW50ZXJ2YWxzID0gW1tTZWNvbmRzLCAxLCBkdXJhdGlvblNlY29uZF0sIFtTZWNvbmRzLCA1LCA1ICogZHVyYXRpb25TZWNvbmRdLCBbU2Vjb25kcywgMTUsIDE1ICogZHVyYXRpb25TZWNvbmRdLCBbU2Vjb25kcywgMzAsIDMwICogZHVyYXRpb25TZWNvbmRdLCBbTWludXRlcywgMSwgZHVyYXRpb25NaW51dGVdLCBbTWludXRlcywgNSwgNSAqIGR1cmF0aW9uTWludXRlXSwgW01pbnV0ZXMsIDE1LCAxNSAqIGR1cmF0aW9uTWludXRlXSwgW01pbnV0ZXMsIDMwLCAzMCAqIGR1cmF0aW9uTWludXRlXSwgW0hvdXJzLCAxLCBkdXJhdGlvbkhvdXJdLCBbSG91cnMsIDMsIDMgKiBkdXJhdGlvbkhvdXJdLCBbSG91cnMsIDYsIDYgKiBkdXJhdGlvbkhvdXJdLCBbSG91cnMsIDEyLCAxMiAqIGR1cmF0aW9uSG91cl0sIFtEYXksIDEsIGR1cmF0aW9uRGF5XSwgW1dlZWssIDEsIGR1cmF0aW9uV2Vla10sIFtNb250aCwgMSwgZHVyYXRpb25Nb250aF0sIFtNb250aCwgMywgMyAqIGR1cmF0aW9uTW9udGhdLCBbWWVhciwgMSwgZHVyYXRpb25ZZWFyXV07XG5mdW5jdGlvbiBiaW4gKG9wdCkge1xuICBjb25zdCBleHQgPSBvcHQuZXh0ZW50LFxuICAgIG1heCA9IG9wdC5tYXhiaW5zIHx8IDQwLFxuICAgIHRhcmdldCA9IE1hdGguYWJzKHNwYW4oZXh0KSkgLyBtYXg7XG4gIGxldCBpID0gYmlzZWN0b3IoaSA9PiBpWzJdKS5yaWdodChpbnRlcnZhbHMsIHRhcmdldCksXG4gICAgdW5pdHMsXG4gICAgc3RlcDtcbiAgaWYgKGkgPT09IGludGVydmFscy5sZW5ndGgpIHtcbiAgICB1bml0cyA9IFllYXIsIHN0ZXAgPSB0aWNrU3RlcChleHRbMF0gLyBkdXJhdGlvblllYXIsIGV4dFsxXSAvIGR1cmF0aW9uWWVhciwgbWF4KTtcbiAgfSBlbHNlIGlmIChpKSB7XG4gICAgaSA9IGludGVydmFsc1t0YXJnZXQgLyBpbnRlcnZhbHNbaSAtIDFdWzJdIDwgaW50ZXJ2YWxzW2ldWzJdIC8gdGFyZ2V0ID8gaSAtIDEgOiBpXTtcbiAgICB1bml0cyA9IGlbMF07XG4gICAgc3RlcCA9IGlbMV07XG4gIH0gZWxzZSB7XG4gICAgdW5pdHMgPSBNaWxsaTtcbiAgICBzdGVwID0gTWF0aC5tYXgodGlja1N0ZXAoZXh0WzBdLCBleHRbMV0sIG1heCksIDEpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdW5pdHMsXG4gICAgc3RlcFxuICB9O1xufVxuXG5leHBvcnQgeyBEQVRFLCBEQVksIERBWU9GWUVBUiwgSE9VUlMsIE1JTExJU0VDT05EUywgTUlOVVRFUywgTU9OVEgsIFFVQVJURVIsIFNFQ09ORFMsIFRJTUVfVU5JVFMsIFdFRUssIFlFQVIsIGRheW9meWVhciwgYmluIGFzIHRpbWVCaW4sIHRpbWVGbG9vciwgdGltZUludGVydmFsLCB0aW1lT2Zmc2V0LCB0aW1lU2VxdWVuY2UsIHRpbWVVbml0U3BlY2lmaWVyLCB0aW1lVW5pdHMsIHV0Y0Zsb29yLCB1dGNJbnRlcnZhbCwgdXRjT2Zmc2V0LCB1dGNTZXF1ZW5jZSwgdXRjZGF5b2Z5ZWFyLCB1dGN3ZWVrLCB3ZWVrIH07XG4iLCJpbXBvcnQgeyBleHRlbmQsIGlkZW50aXR5LCBmaWVsZCwgaGFzT3duUHJvcGVydHksIGV4dGVudEluZGV4LCBpbmhlcml0cywgYXJyYXksIGFjY2Vzc29yTmFtZSwgZXJyb3IsIGFjY2Vzc29yRmllbGRzLCBhY2Nlc3NvciwgdG9OdW1iZXIsIG1lcmdlLCBjb21wYXJlLCB0cnV0aHksIGV4dGVudCwgc3BhbiwgZmFzdG1hcCwgaXNBcnJheSwga2V5LCBhc2NlbmRpbmcsIHBlZWssIHplcm8sIGNvbnN0YW50IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHR1cGxlaWQsIFRyYW5zZm9ybSwgcmVwbGFjZSwgaW5nZXN0LCBzdGFibGVDb21wYXJlLCBPcGVyYXRvciwgZGVyaXZlLCByZWRlcml2ZSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgcXVhcnRpbGVzLCBib290c3RyYXBDSSwgYmluLCByYW5kb21LREUsIHJhbmRvbU1peHR1cmUsIHJhbmRvbU5vcm1hbCwgcmFuZG9tTG9nTm9ybWFsLCByYW5kb21Vbmlmb3JtLCBzYW1wbGVDdXJ2ZSwgZG90YmluLCBxdWFudGlsZXMsIHJhbmRvbSB9IGZyb20gJ3ZlZ2Etc3RhdGlzdGljcyc7XG5pbXBvcnQgeyBtZWRpYW4sIG1lYW4sIG1pbiwgbWF4LCByYW5nZSwgYmlzZWN0b3IgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBUSU1FX1VOSVRTLCB1dGNJbnRlcnZhbCwgdGltZUludGVydmFsLCB0aW1lQmluLCB0aW1lVW5pdHMsIHV0Y0Zsb29yLCB0aW1lRmxvb3IgfSBmcm9tICd2ZWdhLXRpbWUnO1xuXG5mdW5jdGlvbiBtdWx0aWtleShmKSB7XG4gIHJldHVybiB4ID0+IHtcbiAgICBjb25zdCBuID0gZi5sZW5ndGg7XG4gICAgbGV0IGkgPSAxLFxuICAgICAgayA9IFN0cmluZyhmWzBdKHgpKTtcbiAgICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgICAgayArPSAnfCcgKyBmW2ldKHgpO1xuICAgIH1cbiAgICByZXR1cm4gaztcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyb3Vwa2V5KGZpZWxkcykge1xuICByZXR1cm4gIWZpZWxkcyB8fCAhZmllbGRzLmxlbmd0aCA/IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gOiBmaWVsZHMubGVuZ3RoID09PSAxID8gZmllbGRzWzBdIDogbXVsdGlrZXkoZmllbGRzKTtcbn1cblxuZnVuY3Rpb24gbWVhc3VyZU5hbWUob3AsIGZpZWxkLCBhcykge1xuICByZXR1cm4gYXMgfHwgb3AgKyAoIWZpZWxkID8gJycgOiAnXycgKyBmaWVsZCk7XG59XG5jb25zdCBub29wID0gKCkgPT4ge307XG5jb25zdCBiYXNlX29wID0ge1xuICBpbml0OiBub29wLFxuICBhZGQ6IG5vb3AsXG4gIHJlbTogbm9vcCxcbiAgaWR4OiAwXG59O1xuY29uc3QgQWdncmVnYXRlT3BzID0ge1xuICB2YWx1ZXM6IHtcbiAgICBpbml0OiBtID0+IG0uY2VsbC5zdG9yZSA9IHRydWUsXG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEudmFsdWVzKCksXG4gICAgaWR4OiAtMVxuICB9LFxuICBjb3VudDoge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5udW1cbiAgfSxcbiAgX19jb3VudF9fOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5taXNzaW5nICsgbS52YWxpZFxuICB9LFxuICBtaXNzaW5nOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5taXNzaW5nXG4gIH0sXG4gIHZhbGlkOiB7XG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZFxuICB9LFxuICBzdW06IHtcbiAgICBpbml0OiBtID0+IG0uc3VtID0gMCxcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID8gbS5zdW0gOiB1bmRlZmluZWQsXG4gICAgYWRkOiAobSwgdikgPT4gbS5zdW0gKz0gK3YsXG4gICAgcmVtOiAobSwgdikgPT4gbS5zdW0gLT0gdlxuICB9LFxuICBwcm9kdWN0OiB7XG4gICAgaW5pdDogbSA9PiBtLnByb2R1Y3QgPSAxLFxuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPyBtLnByb2R1Y3QgOiB1bmRlZmluZWQsXG4gICAgYWRkOiAobSwgdikgPT4gbS5wcm9kdWN0ICo9IHYsXG4gICAgcmVtOiAobSwgdikgPT4gbS5wcm9kdWN0IC89IHZcbiAgfSxcbiAgbWVhbjoge1xuICAgIGluaXQ6IG0gPT4gbS5tZWFuID0gMCxcbiAgICB2YWx1ZTogbSA9PiBtLnZhbGlkID8gbS5tZWFuIDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IChtLm1lYW5fZCA9IHYgLSBtLm1lYW4sIG0ubWVhbiArPSBtLm1lYW5fZCAvIG0udmFsaWQpLFxuICAgIHJlbTogKG0sIHYpID0+IChtLm1lYW5fZCA9IHYgLSBtLm1lYW4sIG0ubWVhbiAtPSBtLnZhbGlkID8gbS5tZWFuX2QgLyBtLnZhbGlkIDogbS5tZWFuKVxuICB9LFxuICBhdmVyYWdlOiB7XG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZCA/IG0ubWVhbiA6IHVuZGVmaW5lZCxcbiAgICByZXE6IFsnbWVhbiddLFxuICAgIGlkeDogMVxuICB9LFxuICB2YXJpYW5jZToge1xuICAgIGluaXQ6IG0gPT4gbS5kZXYgPSAwLFxuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gbS5kZXYgLyAobS52YWxpZCAtIDEpIDogdW5kZWZpbmVkLFxuICAgIGFkZDogKG0sIHYpID0+IG0uZGV2ICs9IG0ubWVhbl9kICogKHYgLSBtLm1lYW4pLFxuICAgIHJlbTogKG0sIHYpID0+IG0uZGV2IC09IG0ubWVhbl9kICogKHYgLSBtLm1lYW4pLFxuICAgIHJlcTogWydtZWFuJ10sXG4gICAgaWR4OiAxXG4gIH0sXG4gIHZhcmlhbmNlcDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gbS5kZXYgLyBtLnZhbGlkIDogdW5kZWZpbmVkLFxuICAgIHJlcTogWyd2YXJpYW5jZSddLFxuICAgIGlkeDogMlxuICB9LFxuICBzdGRldjoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gKG0udmFsaWQgLSAxKSkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIHN0ZGV2cDoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gbS52YWxpZCkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIHN0ZGVycjoge1xuICAgIHZhbHVlOiBtID0+IG0udmFsaWQgPiAxID8gTWF0aC5zcXJ0KG0uZGV2IC8gKG0udmFsaWQgKiAobS52YWxpZCAtIDEpKSkgOiB1bmRlZmluZWQsXG4gICAgcmVxOiBbJ3ZhcmlhbmNlJ10sXG4gICAgaWR4OiAyXG4gIH0sXG4gIGRpc3RpbmN0OiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEuZGlzdGluY3QobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgY2kwOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEuY2kwKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIGNpMToge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLmNpMShtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBtZWRpYW46IHtcbiAgICB2YWx1ZTogbSA9PiBtLmNlbGwuZGF0YS5xMihtLmdldCksXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogM1xuICB9LFxuICBxMToge1xuICAgIHZhbHVlOiBtID0+IG0uY2VsbC5kYXRhLnExKG0uZ2V0KSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIHEzOiB7XG4gICAgdmFsdWU6IG0gPT4gbS5jZWxsLmRhdGEucTMobS5nZXQpLFxuICAgIHJlcTogWyd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgbWluOiB7XG4gICAgaW5pdDogbSA9PiBtLm1pbiA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLm1pbiA9IE51bWJlci5pc05hTihtLm1pbikgPyBtLmNlbGwuZGF0YS5taW4obS5nZXQpIDogbS5taW4sXG4gICAgYWRkOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPCBtLm1pbiB8fCBtLm1pbiA9PT0gdW5kZWZpbmVkKSBtLm1pbiA9IHY7XG4gICAgfSxcbiAgICByZW06IChtLCB2KSA9PiB7XG4gICAgICBpZiAodiA8PSBtLm1pbikgbS5taW4gPSBOYU47XG4gICAgfSxcbiAgICByZXE6IFsndmFsdWVzJ10sXG4gICAgaWR4OiA0XG4gIH0sXG4gIG1heDoge1xuICAgIGluaXQ6IG0gPT4gbS5tYXggPSB1bmRlZmluZWQsXG4gICAgdmFsdWU6IG0gPT4gbS5tYXggPSBOdW1iZXIuaXNOYU4obS5tYXgpID8gbS5jZWxsLmRhdGEubWF4KG0uZ2V0KSA6IG0ubWF4LFxuICAgIGFkZDogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID4gbS5tYXggfHwgbS5tYXggPT09IHVuZGVmaW5lZCkgbS5tYXggPSB2O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPj0gbS5tYXgpIG0ubWF4ID0gTmFOO1xuICAgIH0sXG4gICAgcmVxOiBbJ3ZhbHVlcyddLFxuICAgIGlkeDogNFxuICB9LFxuICBhcmdtaW46IHtcbiAgICBpbml0OiBtID0+IG0uYXJnbWluID0gdW5kZWZpbmVkLFxuICAgIHZhbHVlOiBtID0+IG0uYXJnbWluIHx8IG0uY2VsbC5kYXRhLmFyZ21pbihtLmdldCksXG4gICAgYWRkOiAobSwgdiwgdCkgPT4ge1xuICAgICAgaWYgKHYgPCBtLm1pbikgbS5hcmdtaW4gPSB0O1xuICAgIH0sXG4gICAgcmVtOiAobSwgdikgPT4ge1xuICAgICAgaWYgKHYgPD0gbS5taW4pIG0uYXJnbWluID0gdW5kZWZpbmVkO1xuICAgIH0sXG4gICAgcmVxOiBbJ21pbicsICd2YWx1ZXMnXSxcbiAgICBpZHg6IDNcbiAgfSxcbiAgYXJnbWF4OiB7XG4gICAgaW5pdDogbSA9PiBtLmFyZ21heCA9IHVuZGVmaW5lZCxcbiAgICB2YWx1ZTogbSA9PiBtLmFyZ21heCB8fCBtLmNlbGwuZGF0YS5hcmdtYXgobS5nZXQpLFxuICAgIGFkZDogKG0sIHYsIHQpID0+IHtcbiAgICAgIGlmICh2ID4gbS5tYXgpIG0uYXJnbWF4ID0gdDtcbiAgICB9LFxuICAgIHJlbTogKG0sIHYpID0+IHtcbiAgICAgIGlmICh2ID49IG0ubWF4KSBtLmFyZ21heCA9IHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIHJlcTogWydtYXgnLCAndmFsdWVzJ10sXG4gICAgaWR4OiAzXG4gIH0sXG4gIGV4cG9uZW50aWFsOiB7XG4gICAgaW5pdDogKG0sIHIpID0+IHtcbiAgICAgIG0uZXhwID0gMDtcbiAgICAgIG0uZXhwX3IgPSByO1xuICAgIH0sXG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZCA/IG0uZXhwICogKDEgLSBtLmV4cF9yKSAvICgxIC0gbS5leHBfciAqKiBtLnZhbGlkKSA6IHVuZGVmaW5lZCxcbiAgICBhZGQ6IChtLCB2KSA9PiBtLmV4cCA9IG0uZXhwX3IgKiBtLmV4cCArIHYsXG4gICAgcmVtOiAobSwgdikgPT4gbS5leHAgPSAobS5leHAgLSB2IC8gbS5leHBfciAqKiAobS52YWxpZCAtIDEpKSAvIG0uZXhwX3JcbiAgfSxcbiAgZXhwb25lbnRpYWxiOiB7XG4gICAgdmFsdWU6IG0gPT4gbS52YWxpZCA/IG0uZXhwICogKDEgLSBtLmV4cF9yKSA6IHVuZGVmaW5lZCxcbiAgICByZXE6IFsnZXhwb25lbnRpYWwnXSxcbiAgICBpZHg6IDFcbiAgfVxufTtcbmNvbnN0IFZhbGlkQWdncmVnYXRlT3BzID0gT2JqZWN0LmtleXMoQWdncmVnYXRlT3BzKS5maWx0ZXIoZCA9PiBkICE9PSAnX19jb3VudF9fJyk7XG5mdW5jdGlvbiBtZWFzdXJlKGtleSwgdmFsdWUpIHtcbiAgcmV0dXJuIChvdXQsIGFnZ3JlZ2F0ZV9wYXJhbSkgPT4gZXh0ZW5kKHtcbiAgICBuYW1lOiBrZXksXG4gICAgYWdncmVnYXRlX3BhcmFtOiBhZ2dyZWdhdGVfcGFyYW0sXG4gICAgb3V0OiBvdXQgfHwga2V5XG4gIH0sIGJhc2Vfb3AsIHZhbHVlKTtcbn1cblsuLi5WYWxpZEFnZ3JlZ2F0ZU9wcywgJ19fY291bnRfXyddLmZvckVhY2goa2V5ID0+IHtcbiAgQWdncmVnYXRlT3BzW2tleV0gPSBtZWFzdXJlKGtleSwgQWdncmVnYXRlT3BzW2tleV0pO1xufSk7XG5mdW5jdGlvbiBjcmVhdGVNZWFzdXJlKG9wLCBwYXJhbSwgbmFtZSkge1xuICByZXR1cm4gQWdncmVnYXRlT3BzW29wXShuYW1lLCBwYXJhbSk7XG59XG5mdW5jdGlvbiBjb21wYXJlSW5kZXgoYSwgYikge1xuICByZXR1cm4gYS5pZHggLSBiLmlkeDtcbn1cbmZ1bmN0aW9uIHJlc29sdmUoYWdnKSB7XG4gIGNvbnN0IG1hcCA9IHt9O1xuICBhZ2cuZm9yRWFjaChhID0+IG1hcFthLm5hbWVdID0gYSk7XG4gIGNvbnN0IGdldHJlcXMgPSBhID0+IHtcbiAgICBpZiAoIWEucmVxKSByZXR1cm47XG4gICAgYS5yZXEuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKCFtYXBba2V5XSkgZ2V0cmVxcyhtYXBba2V5XSA9IEFnZ3JlZ2F0ZU9wc1trZXldKCkpO1xuICAgIH0pO1xuICB9O1xuICBhZ2cuZm9yRWFjaChnZXRyZXFzKTtcbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMobWFwKS5zb3J0KGNvbXBhcmVJbmRleCk7XG59XG5mdW5jdGlvbiBpbml0KCkge1xuICB0aGlzLnZhbGlkID0gMDtcbiAgdGhpcy5taXNzaW5nID0gMDtcbiAgdGhpcy5fb3BzLmZvckVhY2gob3AgPT4gb3AuYWdncmVnYXRlX3BhcmFtID09IG51bGwgPyBvcC5pbml0KHRoaXMpIDogb3AuaW5pdCh0aGlzLCBvcC5hZ2dyZWdhdGVfcGFyYW0pKTtcbn1cbmZ1bmN0aW9uIGFkZCh2LCB0KSB7XG4gIGlmICh2ID09IG51bGwgfHwgdiA9PT0gJycpIHtcbiAgICArK3RoaXMubWlzc2luZztcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHYgIT09IHYpIHJldHVybjtcbiAgKyt0aGlzLnZhbGlkO1xuICB0aGlzLl9vcHMuZm9yRWFjaChvcCA9PiBvcC5hZGQodGhpcywgdiwgdCkpO1xufVxuZnVuY3Rpb24gcmVtKHYsIHQpIHtcbiAgaWYgKHYgPT0gbnVsbCB8fCB2ID09PSAnJykge1xuICAgIC0tdGhpcy5taXNzaW5nO1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAodiAhPT0gdikgcmV0dXJuO1xuICAtLXRoaXMudmFsaWQ7XG4gIHRoaXMuX29wcy5mb3JFYWNoKG9wID0+IG9wLnJlbSh0aGlzLCB2LCB0KSk7XG59XG5mdW5jdGlvbiBzZXQodCkge1xuICB0aGlzLl9vdXQuZm9yRWFjaChvcCA9PiB0W29wLm91dF0gPSBvcC52YWx1ZSh0aGlzKSk7XG4gIHJldHVybiB0O1xufVxuZnVuY3Rpb24gY29tcGlsZU1lYXN1cmVzKGFnZywgZmllbGQpIHtcbiAgY29uc3QgZ2V0ID0gZmllbGQgfHwgaWRlbnRpdHksXG4gICAgb3BzID0gcmVzb2x2ZShhZ2cpLFxuICAgIG91dCA9IGFnZy5zbGljZSgpLnNvcnQoY29tcGFyZUluZGV4KTtcbiAgZnVuY3Rpb24gY3RyKGNlbGwpIHtcbiAgICB0aGlzLl9vcHMgPSBvcHM7XG4gICAgdGhpcy5fb3V0ID0gb3V0O1xuICAgIHRoaXMuY2VsbCA9IGNlbGw7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgY3RyLnByb3RvdHlwZS5pbml0ID0gaW5pdDtcbiAgY3RyLnByb3RvdHlwZS5hZGQgPSBhZGQ7XG4gIGN0ci5wcm90b3R5cGUucmVtID0gcmVtO1xuICBjdHIucHJvdG90eXBlLnNldCA9IHNldDtcbiAgY3RyLnByb3RvdHlwZS5nZXQgPSBnZXQ7XG4gIGN0ci5maWVsZHMgPSBhZ2cubWFwKG9wID0+IG9wLm91dCk7XG4gIHJldHVybiBjdHI7XG59XG5cbmZ1bmN0aW9uIFR1cGxlU3RvcmUoa2V5KSB7XG4gIHRoaXMuX2tleSA9IGtleSA/IGZpZWxkKGtleSkgOiB0dXBsZWlkO1xuICB0aGlzLnJlc2V0KCk7XG59XG5jb25zdCBwcm90b3R5cGUkMSA9IFR1cGxlU3RvcmUucHJvdG90eXBlO1xucHJvdG90eXBlJDEucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuX2FkZCA9IFtdO1xuICB0aGlzLl9yZW0gPSBbXTtcbiAgdGhpcy5fZXh0ID0gbnVsbDtcbiAgdGhpcy5fZ2V0ID0gbnVsbDtcbiAgdGhpcy5fcSA9IG51bGw7XG59O1xucHJvdG90eXBlJDEuYWRkID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5fYWRkLnB1c2godik7XG59O1xucHJvdG90eXBlJDEucmVtID0gZnVuY3Rpb24gKHYpIHtcbiAgdGhpcy5fcmVtLnB1c2godik7XG59O1xucHJvdG90eXBlJDEudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl9nZXQgPSBudWxsO1xuICBpZiAodGhpcy5fcmVtLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXMuX2FkZDtcbiAgY29uc3QgYSA9IHRoaXMuX2FkZCxcbiAgICByID0gdGhpcy5fcmVtLFxuICAgIGsgPSB0aGlzLl9rZXksXG4gICAgbiA9IGEubGVuZ3RoLFxuICAgIG0gPSByLmxlbmd0aCxcbiAgICB4ID0gQXJyYXkobiAtIG0pLFxuICAgIG1hcCA9IHt9O1xuICBsZXQgaSwgaiwgdjtcblxuICAvLyB1c2UgdW5pcXVlIGtleSBmaWVsZCB0byBjbGVhciByZW1vdmVkIHZhbHVlc1xuICBmb3IgKGkgPSAwOyBpIDwgbTsgKytpKSB7XG4gICAgbWFwW2socltpXSldID0gMTtcbiAgfVxuICBmb3IgKGkgPSAwLCBqID0gMDsgaSA8IG47ICsraSkge1xuICAgIGlmIChtYXBbayh2ID0gYVtpXSldKSB7XG4gICAgICBtYXBbayh2KV0gPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB4W2orK10gPSB2O1xuICAgIH1cbiAgfVxuICB0aGlzLl9yZW0gPSBbXTtcbiAgcmV0dXJuIHRoaXMuX2FkZCA9IHg7XG59O1xuXG4vLyBtZW1vaXppbmcgc3RhdGlzdGljcyBtZXRob2RzXG5cbnByb3RvdHlwZSQxLmRpc3RpbmN0ID0gZnVuY3Rpb24gKGdldCkge1xuICBjb25zdCB2ID0gdGhpcy52YWx1ZXMoKSxcbiAgICBtYXAgPSB7fTtcbiAgbGV0IG4gPSB2Lmxlbmd0aCxcbiAgICBjb3VudCA9IDAsXG4gICAgcztcbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgcyA9IGdldCh2W25dKSArICcnO1xuICAgIGlmICghaGFzT3duUHJvcGVydHkobWFwLCBzKSkge1xuICAgICAgbWFwW3NdID0gMTtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5wcm90b3R5cGUkMS5leHRlbnQgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIGlmICh0aGlzLl9nZXQgIT09IGdldCB8fCAhdGhpcy5fZXh0KSB7XG4gICAgY29uc3QgdiA9IHRoaXMudmFsdWVzKCksXG4gICAgICBpID0gZXh0ZW50SW5kZXgodiwgZ2V0KTtcbiAgICB0aGlzLl9leHQgPSBbdltpWzBdXSwgdltpWzFdXV07XG4gICAgdGhpcy5fZ2V0ID0gZ2V0O1xuICB9XG4gIHJldHVybiB0aGlzLl9leHQ7XG59O1xucHJvdG90eXBlJDEuYXJnbWluID0gZnVuY3Rpb24gKGdldCkge1xuICByZXR1cm4gdGhpcy5leHRlbnQoZ2V0KVswXSB8fCB7fTtcbn07XG5wcm90b3R5cGUkMS5hcmdtYXggPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLmV4dGVudChnZXQpWzFdIHx8IHt9O1xufTtcbnByb3RvdHlwZSQxLm1pbiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgY29uc3QgbSA9IHRoaXMuZXh0ZW50KGdldClbMF07XG4gIHJldHVybiBtICE9IG51bGwgPyBnZXQobSkgOiB1bmRlZmluZWQ7XG59O1xucHJvdG90eXBlJDEubWF4ID0gZnVuY3Rpb24gKGdldCkge1xuICBjb25zdCBtID0gdGhpcy5leHRlbnQoZ2V0KVsxXTtcbiAgcmV0dXJuIG0gIT0gbnVsbCA/IGdldChtKSA6IHVuZGVmaW5lZDtcbn07XG5wcm90b3R5cGUkMS5xdWFydGlsZSA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9xKSB7XG4gICAgdGhpcy5fcSA9IHF1YXJ0aWxlcyh0aGlzLnZhbHVlcygpLCBnZXQpO1xuICAgIHRoaXMuX2dldCA9IGdldDtcbiAgfVxuICByZXR1cm4gdGhpcy5fcTtcbn07XG5wcm90b3R5cGUkMS5xMSA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVswXTtcbn07XG5wcm90b3R5cGUkMS5xMiA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsxXTtcbn07XG5wcm90b3R5cGUkMS5xMyA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMucXVhcnRpbGUoZ2V0KVsyXTtcbn07XG5wcm90b3R5cGUkMS5jaSA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgaWYgKHRoaXMuX2dldCAhPT0gZ2V0IHx8ICF0aGlzLl9jaSkge1xuICAgIHRoaXMuX2NpID0gYm9vdHN0cmFwQ0kodGhpcy52YWx1ZXMoKSwgMTAwMCwgMC4wNSwgZ2V0KTtcbiAgICB0aGlzLl9nZXQgPSBnZXQ7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX2NpO1xufTtcbnByb3RvdHlwZSQxLmNpMCA9IGZ1bmN0aW9uIChnZXQpIHtcbiAgcmV0dXJuIHRoaXMuY2koZ2V0KVswXTtcbn07XG5wcm90b3R5cGUkMS5jaTEgPSBmdW5jdGlvbiAoZ2V0KSB7XG4gIHJldHVybiB0aGlzLmNpKGdldClbMV07XG59O1xuXG4vKipcbiAqIEdyb3VwLWJ5IGFnZ3JlZ2F0aW9uIG9wZXJhdG9yLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIHRvIGdyb3VwYnkuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmZpZWxkc10gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gYWdncmVnYXRlLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLm9wc10gLSBBbiBhcnJheSBvZiBzdHJpbmdzIGluZGljYXRpbmcgYWdncmVnYXRpb24gb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5hZ2dyZWdhdGVfcGFyYW1zXSAtIEFuIG9wdGlvbmFsIGFycmF5IG9mIHBhcmFtZXRlcnMgZm9yIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQW4gYXJyYXkgb2Ygb3V0cHV0IGZpZWxkIG5hbWVzIGZvciBhZ2dyZWdhdGVkIHZhbHVlcy5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5jcm9zcz1mYWxzZV0gLSBBIGZsYWcgaW5kaWNhdGluZyB0aGF0IHRoZSBmdWxsXG4gKiAgIGNyb3NzLXByb2R1Y3Qgb2YgZ3JvdXBieSB2YWx1ZXMgc2hvdWxkIGJlIGdlbmVyYXRlZCwgaW5jbHVkaW5nIGVtcHR5IGNlbGxzLlxuICogICBJZiB0cnVlLCB0aGUgZHJvcCBwYXJhbWV0ZXIgaXMgaWdub3JlZCBhbmQgZW1wdHkgY2VsbHMgYXJlIHJldGFpbmVkLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmRyb3A9dHJ1ZV0gLSBBIGZsYWcgaW5kaWNhdGluZyBpZiBlbXB0eSBjZWxscyBzaG91bGQgYmUgcmVtb3ZlZC5cbiAqL1xuZnVuY3Rpb24gQWdncmVnYXRlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xuICB0aGlzLl9hZGRzID0gW107IC8vIGFycmF5IG9mIGFkZGVkIG91dHB1dCB0dXBsZXNcbiAgdGhpcy5fbW9kcyA9IFtdOyAvLyBhcnJheSBvZiBtb2RpZmllZCBvdXRwdXQgdHVwbGVzXG4gIHRoaXMuX2FsZW4gPSAwOyAvLyBudW1iZXIgb2YgYWN0aXZlIGFkZGVkIHR1cGxlc1xuICB0aGlzLl9tbGVuID0gMDsgLy8gbnVtYmVyIG9mIGFjdGl2ZSBtb2RpZmllZCB0dXBsZXNcbiAgdGhpcy5fZHJvcCA9IHRydWU7IC8vIHNob3VsZCBlbXB0eSBhZ2dyZWdhdGlvbiBjZWxscyBiZSByZW1vdmVkXG4gIHRoaXMuX2Nyb3NzID0gZmFsc2U7IC8vIHByb2R1Y2UgZnVsbCBjcm9zcy1wcm9kdWN0IG9mIGdyb3VwLWJ5IHZhbHVlc1xuXG4gIHRoaXMuX2RpbXMgPSBbXTsgLy8gZ3JvdXAtYnkgZGltZW5zaW9uIGFjY2Vzc29yc1xuICB0aGlzLl9kbmFtZXMgPSBbXTsgLy8gZ3JvdXAtYnkgZGltZW5zaW9uIG5hbWVzXG5cbiAgdGhpcy5fbWVhc3VyZXMgPSBbXTsgLy8gY29sbGVjdGlvbiBvZiBhZ2dyZWdhdGlvbiBtb25vaWRzXG4gIHRoaXMuX2NvdW50T25seSA9IGZhbHNlOyAvLyBmbGFnIGluZGljYXRpbmcgb25seSBjb3VudCBhZ2dyZWdhdGlvblxuICB0aGlzLl9jb3VudHMgPSBudWxsOyAvLyBjb2xsZWN0aW9uIG9mIGNvdW50IGZpZWxkc1xuICB0aGlzLl9wcmV2ID0gbnVsbDsgLy8gcHJldmlvdXMgYWdncmVnYXRpb24gY2VsbHNcblxuICB0aGlzLl9pbnB1dHMgPSBudWxsOyAvLyBhcnJheSBvZiBkZXBlbmRlbnQgaW5wdXQgdHVwbGUgZmllbGQgbmFtZXNcbiAgdGhpcy5fb3V0cHV0cyA9IG51bGw7IC8vIGFycmF5IG9mIG91dHB1dCB0dXBsZSBmaWVsZCBuYW1lc1xufVxuQWdncmVnYXRlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0FnZ3JlZ2F0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ29wcycsXG4gICAgJ3R5cGUnOiAnZW51bScsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAndmFsdWVzJzogVmFsaWRBZ2dyZWdhdGVPcHNcbiAgfSwge1xuICAgICduYW1lJzogJ2FnZ3JlZ2F0ZV9wYXJhbXMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkcycsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZHJvcCcsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdjcm9zcycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAna2V5JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfV1cbn07XG5pbmhlcml0cyhBZ2dyZWdhdGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBhZ2dyID0gdGhpcyxcbiAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSxcbiAgICAgIG1vZCA9IF8ubW9kaWZpZWQoKTtcbiAgICBhZ2dyLnN0YW1wID0gb3V0LnN0YW1wO1xuICAgIGlmIChhZ2dyLnZhbHVlICYmIChtb2QgfHwgcHVsc2UubW9kaWZpZWQoYWdnci5faW5wdXRzLCB0cnVlKSkpIHtcbiAgICAgIGFnZ3IuX3ByZXYgPSBhZ2dyLnZhbHVlO1xuICAgICAgYWdnci52YWx1ZSA9IG1vZCA/IGFnZ3IuaW5pdChfKSA6IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gYWdnci5hZGQodCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZ2dyLnZhbHVlID0gYWdnci52YWx1ZSB8fCBhZ2dyLmluaXQoXyk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4gYWdnci5yZW0odCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IGFnZ3IuYWRkKHQpKTtcbiAgICB9XG5cbiAgICAvLyBJbmRpY2F0ZSBvdXRwdXQgZmllbGRzIGFuZCByZXR1cm4gYWdncmVnYXRlIHR1cGxlcy5cbiAgICBvdXQubW9kaWZpZXMoYWdnci5fb3V0cHV0cyk7XG5cbiAgICAvLyBTaG91bGQgZW1wdHkgY2VsbHMgYmUgZHJvcHBlZD9cbiAgICBhZ2dyLl9kcm9wID0gXy5kcm9wICE9PSBmYWxzZTtcblxuICAgIC8vIElmIGRvbWFpbiBjcm9zcy1wcm9kdWN0IHJlcXVlc3RlZCwgZ2VuZXJhdGUgZW1wdHkgY2VsbHMgYXMgbmVlZGVkXG4gICAgLy8gYW5kIGVuc3VyZSB0aGF0IGVtcHR5IGNlbGxzIGFyZSBub3QgZHJvcHBlZFxuICAgIGlmIChfLmNyb3NzICYmIGFnZ3IuX2RpbXMubGVuZ3RoID4gMSkge1xuICAgICAgYWdnci5fZHJvcCA9IGZhbHNlO1xuICAgICAgYWdnci5jcm9zcygpO1xuICAgIH1cbiAgICBpZiAocHVsc2UuY2xlYW4oKSAmJiBhZ2dyLl9kcm9wKSB7XG4gICAgICBvdXQuY2xlYW4odHJ1ZSkucnVuQWZ0ZXIoKCkgPT4gdGhpcy5jbGVhbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFnZ3IuY2hhbmdlcyhvdXQpO1xuICB9LFxuICBjcm9zcygpIHtcbiAgICBjb25zdCBhZ2dyID0gdGhpcyxcbiAgICAgIGN1cnIgPSBhZ2dyLnZhbHVlLFxuICAgICAgZGltcyA9IGFnZ3IuX2RuYW1lcyxcbiAgICAgIHZhbHMgPSBkaW1zLm1hcCgoKSA9PiAoe30pKSxcbiAgICAgIG4gPSBkaW1zLmxlbmd0aDtcblxuICAgIC8vIGNvbGxlY3QgYWxsIGdyb3VwLWJ5IGRvbWFpbiB2YWx1ZXNcbiAgICBmdW5jdGlvbiBjb2xsZWN0KGNlbGxzKSB7XG4gICAgICBsZXQga2V5LCBpLCB0LCB2O1xuICAgICAgZm9yIChrZXkgaW4gY2VsbHMpIHtcbiAgICAgICAgdCA9IGNlbGxzW2tleV0udHVwbGU7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2YWxzW2ldW3YgPSB0W2RpbXNbaV1dXSA9IHY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29sbGVjdChhZ2dyLl9wcmV2KTtcbiAgICBjb2xsZWN0KGN1cnIpO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIGtleSBjcm9zcy1wcm9kdWN0LCBjcmVhdGUgY2VsbHMgYXMgbmVlZGVkXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGUoYmFzZSwgdHVwbGUsIGluZGV4KSB7XG4gICAgICBjb25zdCBuYW1lID0gZGltc1tpbmRleF0sXG4gICAgICAgIHYgPSB2YWxzW2luZGV4KytdO1xuICAgICAgZm9yIChjb25zdCBrIGluIHYpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gYmFzZSA/IGJhc2UgKyAnfCcgKyBrIDogaztcbiAgICAgICAgdHVwbGVbbmFtZV0gPSB2W2tdO1xuICAgICAgICBpZiAoaW5kZXggPCBuKSBnZW5lcmF0ZShrZXksIHR1cGxlLCBpbmRleCk7ZWxzZSBpZiAoIWN1cnJba2V5XSkgYWdnci5jZWxsKGtleSwgdHVwbGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBnZW5lcmF0ZSgnJywge30sIDApO1xuICB9LFxuICBpbml0KF8pIHtcbiAgICAvLyBpbml0aWFsaXplIGlucHV0IGFuZCBvdXRwdXQgZmllbGRzXG4gICAgY29uc3QgaW5wdXRzID0gdGhpcy5faW5wdXRzID0gW10sXG4gICAgICBvdXRwdXRzID0gdGhpcy5fb3V0cHV0cyA9IFtdLFxuICAgICAgaW5wdXRNYXAgPSB7fTtcbiAgICBmdW5jdGlvbiBpbnB1dFZpc2l0KGdldCkge1xuICAgICAgY29uc3QgZmllbGRzID0gYXJyYXkoYWNjZXNzb3JGaWVsZHMoZ2V0KSksXG4gICAgICAgIG4gPSBmaWVsZHMubGVuZ3RoO1xuICAgICAgbGV0IGkgPSAwLFxuICAgICAgICBmO1xuICAgICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgaWYgKCFpbnB1dE1hcFtmID0gZmllbGRzW2ldXSkge1xuICAgICAgICAgIGlucHV0TWFwW2ZdID0gMTtcbiAgICAgICAgICBpbnB1dHMucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgZ3JvdXAtYnkgZGltZW5zaW9uc1xuICAgIHRoaXMuX2RpbXMgPSBhcnJheShfLmdyb3VwYnkpO1xuICAgIHRoaXMuX2RuYW1lcyA9IHRoaXMuX2RpbXMubWFwKGQgPT4ge1xuICAgICAgY29uc3QgZG5hbWUgPSBhY2Nlc3Nvck5hbWUoZCk7XG4gICAgICBpbnB1dFZpc2l0KGQpO1xuICAgICAgb3V0cHV0cy5wdXNoKGRuYW1lKTtcbiAgICAgIHJldHVybiBkbmFtZTtcbiAgICB9KTtcbiAgICB0aGlzLmNlbGxrZXkgPSBfLmtleSA/IF8ua2V5IDogZ3JvdXBrZXkodGhpcy5fZGltcyk7XG5cbiAgICAvLyBpbml0aWFsaXplIGFnZ3JlZ2F0ZSBtZWFzdXJlc1xuICAgIHRoaXMuX2NvdW50T25seSA9IHRydWU7XG4gICAgdGhpcy5fY291bnRzID0gW107XG4gICAgdGhpcy5fbWVhc3VyZXMgPSBbXTtcbiAgICBjb25zdCBmaWVsZHMgPSBfLmZpZWxkcyB8fCBbbnVsbF0sXG4gICAgICBvcHMgPSBfLm9wcyB8fCBbJ2NvdW50J10sXG4gICAgICBhZ2dyZWdhdGVfcGFyYW1zID0gXy5hZ2dyZWdhdGVfcGFyYW1zIHx8IFtudWxsXSxcbiAgICAgIGFzID0gXy5hcyB8fCBbXSxcbiAgICAgIG4gPSBmaWVsZHMubGVuZ3RoLFxuICAgICAgbWFwID0ge307XG4gICAgbGV0IGZpZWxkLCBvcCwgYWdncmVnYXRlX3BhcmFtLCBtLCBtbmFtZSwgb3V0bmFtZSwgaTtcbiAgICBpZiAobiAhPT0gb3BzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1VubWF0Y2hlZCBudW1iZXIgb2YgZmllbGRzIGFuZCBhZ2dyZWdhdGUgb3BzLicpO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgIG9wID0gb3BzW2ldO1xuICAgICAgYWdncmVnYXRlX3BhcmFtID0gYWdncmVnYXRlX3BhcmFtc1tpXSB8fCBudWxsO1xuICAgICAgaWYgKGZpZWxkID09IG51bGwgJiYgb3AgIT09ICdjb3VudCcpIHtcbiAgICAgICAgZXJyb3IoJ051bGwgYWdncmVnYXRlIGZpZWxkIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cbiAgICAgIG1uYW1lID0gYWNjZXNzb3JOYW1lKGZpZWxkKTtcbiAgICAgIG91dG5hbWUgPSBtZWFzdXJlTmFtZShvcCwgbW5hbWUsIGFzW2ldKTtcbiAgICAgIG91dHB1dHMucHVzaChvdXRuYW1lKTtcbiAgICAgIGlmIChvcCA9PT0gJ2NvdW50Jykge1xuICAgICAgICB0aGlzLl9jb3VudHMucHVzaChvdXRuYW1lKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBtID0gbWFwW21uYW1lXTtcbiAgICAgIGlmICghbSkge1xuICAgICAgICBpbnB1dFZpc2l0KGZpZWxkKTtcbiAgICAgICAgbSA9IG1hcFttbmFtZV0gPSBbXTtcbiAgICAgICAgbS5maWVsZCA9IGZpZWxkO1xuICAgICAgICB0aGlzLl9tZWFzdXJlcy5wdXNoKG0pO1xuICAgICAgfVxuICAgICAgaWYgKG9wICE9PSAnY291bnQnKSB0aGlzLl9jb3VudE9ubHkgPSBmYWxzZTtcbiAgICAgIG0ucHVzaChjcmVhdGVNZWFzdXJlKG9wLCBhZ2dyZWdhdGVfcGFyYW0sIG91dG5hbWUpKTtcbiAgICB9XG4gICAgdGhpcy5fbWVhc3VyZXMgPSB0aGlzLl9tZWFzdXJlcy5tYXAobSA9PiBjb21waWxlTWVhc3VyZXMobSwgbS5maWVsZCkpO1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBhZ2dyZWdhdGlvbiBjZWxscyAodGhpcy52YWx1ZSlcbiAgfSxcbiAgLy8gLS0gQ2VsbCBNYW5hZ2VtZW50IC0tLS0tXG5cbiAgY2VsbGtleTogZ3JvdXBrZXkoKSxcbiAgY2VsbChrZXksIHQpIHtcbiAgICBsZXQgY2VsbCA9IHRoaXMudmFsdWVba2V5XTtcbiAgICBpZiAoIWNlbGwpIHtcbiAgICAgIGNlbGwgPSB0aGlzLnZhbHVlW2tleV0gPSB0aGlzLm5ld2NlbGwoa2V5LCB0KTtcbiAgICAgIHRoaXMuX2FkZHNbdGhpcy5fYWxlbisrXSA9IGNlbGw7XG4gICAgfSBlbHNlIGlmIChjZWxsLm51bSA9PT0gMCAmJiB0aGlzLl9kcm9wICYmIGNlbGwuc3RhbXAgPCB0aGlzLnN0YW1wKSB7XG4gICAgICBjZWxsLnN0YW1wID0gdGhpcy5zdGFtcDtcbiAgICAgIHRoaXMuX2FkZHNbdGhpcy5fYWxlbisrXSA9IGNlbGw7XG4gICAgfSBlbHNlIGlmIChjZWxsLnN0YW1wIDwgdGhpcy5zdGFtcCkge1xuICAgICAgY2VsbC5zdGFtcCA9IHRoaXMuc3RhbXA7XG4gICAgICB0aGlzLl9tb2RzW3RoaXMuX21sZW4rK10gPSBjZWxsO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfSxcbiAgbmV3Y2VsbChrZXksIHQpIHtcbiAgICBjb25zdCBjZWxsID0ge1xuICAgICAga2V5OiBrZXksXG4gICAgICBudW06IDAsXG4gICAgICBhZ2c6IG51bGwsXG4gICAgICB0dXBsZTogdGhpcy5uZXd0dXBsZSh0LCB0aGlzLl9wcmV2ICYmIHRoaXMuX3ByZXZba2V5XSksXG4gICAgICBzdGFtcDogdGhpcy5zdGFtcCxcbiAgICAgIHN0b3JlOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKCF0aGlzLl9jb3VudE9ubHkpIHtcbiAgICAgIGNvbnN0IG1lYXN1cmVzID0gdGhpcy5fbWVhc3VyZXMsXG4gICAgICAgIG4gPSBtZWFzdXJlcy5sZW5ndGg7XG4gICAgICBjZWxsLmFnZyA9IEFycmF5KG4pO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY2VsbC5hZ2dbaV0gPSBuZXcgbWVhc3VyZXNbaV0oY2VsbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjZWxsLnN0b3JlKSB7XG4gICAgICBjZWxsLmRhdGEgPSBuZXcgVHVwbGVTdG9yZSgpO1xuICAgIH1cbiAgICByZXR1cm4gY2VsbDtcbiAgfSxcbiAgbmV3dHVwbGUodCwgcCkge1xuICAgIGNvbnN0IG5hbWVzID0gdGhpcy5fZG5hbWVzLFxuICAgICAgZGltcyA9IHRoaXMuX2RpbXMsXG4gICAgICBuID0gZGltcy5sZW5ndGgsXG4gICAgICB4ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIHhbbmFtZXNbaV1dID0gZGltc1tpXSh0KTtcbiAgICB9XG4gICAgcmV0dXJuIHAgPyByZXBsYWNlKHAudHVwbGUsIHgpIDogaW5nZXN0KHgpO1xuICB9LFxuICBjbGVhbigpIHtcbiAgICBjb25zdCBjZWxscyA9IHRoaXMudmFsdWU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2VsbHMpIHtcbiAgICAgIGlmIChjZWxsc1trZXldLm51bSA9PT0gMCkge1xuICAgICAgICBkZWxldGUgY2VsbHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIC8vIC0tIFByb2Nlc3MgVHVwbGVzIC0tLS0tXG5cbiAgYWRkKHQpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmNlbGxrZXkodCksXG4gICAgICBjZWxsID0gdGhpcy5jZWxsKGtleSwgdCk7XG4gICAgY2VsbC5udW0gKz0gMTtcbiAgICBpZiAodGhpcy5fY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKGNlbGwuc3RvcmUpIGNlbGwuZGF0YS5hZGQodCk7XG4gICAgY29uc3QgYWdnID0gY2VsbC5hZ2c7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZ2dbaV0uYWRkKGFnZ1tpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfSxcbiAgcmVtKHQpIHtcbiAgICBjb25zdCBrZXkgPSB0aGlzLmNlbGxrZXkodCksXG4gICAgICBjZWxsID0gdGhpcy5jZWxsKGtleSwgdCk7XG4gICAgY2VsbC5udW0gLT0gMTtcbiAgICBpZiAodGhpcy5fY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKGNlbGwuc3RvcmUpIGNlbGwuZGF0YS5yZW0odCk7XG4gICAgY29uc3QgYWdnID0gY2VsbC5hZ2c7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhZ2cubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICBhZ2dbaV0ucmVtKGFnZ1tpXS5nZXQodCksIHQpO1xuICAgIH1cbiAgfSxcbiAgY2VsbHR1cGxlKGNlbGwpIHtcbiAgICBjb25zdCB0dXBsZSA9IGNlbGwudHVwbGUsXG4gICAgICBjb3VudHMgPSB0aGlzLl9jb3VudHM7XG5cbiAgICAvLyBjb25zb2xpZGF0ZSBzdG9yZWQgdmFsdWVzXG4gICAgaWYgKGNlbGwuc3RvcmUpIHtcbiAgICAgIGNlbGwuZGF0YS52YWx1ZXMoKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdHVwbGUgcHJvcGVydGllc1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gY291bnRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdHVwbGVbY291bnRzW2ldXSA9IGNlbGwubnVtO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX2NvdW50T25seSkge1xuICAgICAgY29uc3QgYWdnID0gY2VsbC5hZ2c7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbiA9IGFnZy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgYWdnW2ldLnNldCh0dXBsZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0dXBsZTtcbiAgfSxcbiAgY2hhbmdlcyhvdXQpIHtcbiAgICBjb25zdCBhZGRzID0gdGhpcy5fYWRkcyxcbiAgICAgIG1vZHMgPSB0aGlzLl9tb2RzLFxuICAgICAgcHJldiA9IHRoaXMuX3ByZXYsXG4gICAgICBkcm9wID0gdGhpcy5fZHJvcCxcbiAgICAgIGFkZCA9IG91dC5hZGQsXG4gICAgICByZW0gPSBvdXQucmVtLFxuICAgICAgbW9kID0gb3V0Lm1vZDtcbiAgICBsZXQgY2VsbCwga2V5LCBpLCBuO1xuICAgIGlmIChwcmV2KSBmb3IgKGtleSBpbiBwcmV2KSB7XG4gICAgICBjZWxsID0gcHJldltrZXldO1xuICAgICAgaWYgKCFkcm9wIHx8IGNlbGwubnVtKSByZW0ucHVzaChjZWxsLnR1cGxlKTtcbiAgICB9XG4gICAgZm9yIChpID0gMCwgbiA9IHRoaXMuX2FsZW47IGkgPCBuOyArK2kpIHtcbiAgICAgIGFkZC5wdXNoKHRoaXMuY2VsbHR1cGxlKGFkZHNbaV0pKTtcbiAgICAgIGFkZHNbaV0gPSBudWxsOyAvLyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgfVxuICAgIGZvciAoaSA9IDAsIG4gPSB0aGlzLl9tbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBjZWxsID0gbW9kc1tpXTtcbiAgICAgIChjZWxsLm51bSA9PT0gMCAmJiBkcm9wID8gcmVtIDogbW9kKS5wdXNoKHRoaXMuY2VsbHR1cGxlKGNlbGwpKTtcbiAgICAgIG1vZHNbaV0gPSBudWxsOyAvLyBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uXG4gICAgfVxuICAgIHRoaXMuX2FsZW4gPSB0aGlzLl9tbGVuID0gMDsgLy8gcmVzZXQgbGlzdCBvZiBhY3RpdmUgY2VsbHNcbiAgICB0aGlzLl9wcmV2ID0gbnVsbDtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59KTtcblxuLy8gZXBzaWxvbiBiaWFzIHRvIG9mZnNldCBmbG9hdGluZyBwb2ludCBlcnJvciAoIzE3MzcpXG5jb25zdCBFUFNJTE9OJDEgPSAxZS0xNDtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBiaW5uaW5nIGZ1bmN0aW9uIGZvciBkaXNjcmV0aXppbmcgZGF0YS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLiBUaGVcbiAqICAgcHJvdmlkZWQgdmFsdWVzIHNob3VsZCBiZSB2YWxpZCBvcHRpb25zIGZvciB0aGUge0BsaW5rIGJpbn0gZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBkYXRhIGZpZWxkIHRvIGJpbi5cbiAqL1xuZnVuY3Rpb24gQmluKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuQmluLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0JpbicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaW50ZXJ2YWwnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYW5jaG9yJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtYXhiaW5zJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjBcbiAgfSwge1xuICAgICduYW1lJzogJ2Jhc2UnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZGl2aWRlJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiBbNSwgMl1cbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3NwYW4nLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ21pbnN0ZXAnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICduaWNlJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ25hbWUnLFxuICAgICd0eXBlJzogJ3N0cmluZydcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbJ2JpbjAnLCAnYmluMSddXG4gIH1dXG59O1xuaW5oZXJpdHMoQmluLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgYmFuZCA9IF8uaW50ZXJ2YWwgIT09IGZhbHNlLFxuICAgICAgYmlucyA9IHRoaXMuX2JpbnMoXyksXG4gICAgICBzdGFydCA9IGJpbnMuc3RhcnQsXG4gICAgICBzdGVwID0gYmlucy5zdGVwLFxuICAgICAgYXMgPSBfLmFzIHx8IFsnYmluMCcsICdiaW4xJ10sXG4gICAgICBiMCA9IGFzWzBdLFxuICAgICAgYjEgPSBhc1sxXTtcbiAgICBsZXQgZmxhZztcbiAgICBpZiAoXy5tb2RpZmllZCgpKSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLnJlZmxvdyh0cnVlKTtcbiAgICAgIGZsYWcgPSBwdWxzZS5TT1VSQ0U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZsYWcgPSBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhfLmZpZWxkKSkgPyBwdWxzZS5BRERfTU9EIDogcHVsc2UuQUREO1xuICAgIH1cbiAgICBwdWxzZS52aXNpdChmbGFnLCBiYW5kID8gdCA9PiB7XG4gICAgICBjb25zdCB2ID0gYmlucyh0KTtcbiAgICAgIC8vIG1pbmltdW0gYmluIHZhbHVlIChpbmNsdXNpdmUpXG4gICAgICB0W2IwXSA9IHY7XG4gICAgICAvLyBtYXhpbXVtIGJpbiB2YWx1ZSAoZXhjbHVzaXZlKVxuICAgICAgLy8gdXNlIGNvbnZvbHV0ZWQgbWF0aCBmb3IgYmV0dGVyIGZsb2F0aW5nIHBvaW50IGFncmVlbWVudFxuICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS92ZWdhL3ZlZ2EvaXNzdWVzLzgzMFxuICAgICAgLy8gaW5maW5pdGUgdmFsdWVzIHByb3BhZ2F0ZSB0aHJvdWdoIHRoaXMgZm9ybXVsYSEgIzIyMjdcbiAgICAgIHRbYjFdID0gdiA9PSBudWxsID8gbnVsbCA6IHN0YXJ0ICsgc3RlcCAqICgxICsgKHYgLSBzdGFydCkgLyBzdGVwKTtcbiAgICB9IDogdCA9PiB0W2IwXSA9IGJpbnModCkpO1xuICAgIHJldHVybiBwdWxzZS5tb2RpZmllcyhiYW5kID8gYXMgOiBiMCk7XG4gIH0sXG4gIF9iaW5zKF8pIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpKSB7XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgICB9XG4gICAgY29uc3QgZmllbGQgPSBfLmZpZWxkLFxuICAgICAgYmlucyA9IGJpbihfKSxcbiAgICAgIHN0ZXAgPSBiaW5zLnN0ZXA7XG4gICAgbGV0IHN0YXJ0ID0gYmlucy5zdGFydCxcbiAgICAgIHN0b3AgPSBzdGFydCArIE1hdGguY2VpbCgoYmlucy5zdG9wIC0gc3RhcnQpIC8gc3RlcCkgKiBzdGVwLFxuICAgICAgYSxcbiAgICAgIGQ7XG4gICAgaWYgKChhID0gXy5hbmNob3IpICE9IG51bGwpIHtcbiAgICAgIGQgPSBhIC0gKHN0YXJ0ICsgc3RlcCAqIE1hdGguZmxvb3IoKGEgLSBzdGFydCkgLyBzdGVwKSk7XG4gICAgICBzdGFydCArPSBkO1xuICAgICAgc3RvcCArPSBkO1xuICAgIH1cbiAgICBjb25zdCBmID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgIGxldCB2ID0gdG9OdW1iZXIoZmllbGQodCkpO1xuICAgICAgcmV0dXJuIHYgPT0gbnVsbCA/IG51bGwgOiB2IDwgc3RhcnQgPyAtSW5maW5pdHkgOiB2ID4gc3RvcCA/ICtJbmZpbml0eSA6ICh2ID0gTWF0aC5tYXgoc3RhcnQsIE1hdGgubWluKHYsIHN0b3AgLSBzdGVwKSksIHN0YXJ0ICsgc3RlcCAqIE1hdGguZmxvb3IoRVBTSUxPTiQxICsgKHYgLSBzdGFydCkgLyBzdGVwKSk7XG4gICAgfTtcbiAgICBmLnN0YXJ0ID0gc3RhcnQ7XG4gICAgZi5zdG9wID0gYmlucy5zdG9wO1xuICAgIGYuc3RlcCA9IHN0ZXA7XG4gICAgcmV0dXJuIHRoaXMudmFsdWUgPSBhY2Nlc3NvcihmLCBhY2Nlc3NvckZpZWxkcyhmaWVsZCksIF8ubmFtZSB8fCAnYmluXycgKyBhY2Nlc3Nvck5hbWUoZmllbGQpKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIFNvcnRlZExpc3QgKGlkRnVuYywgc291cmNlLCBpbnB1dCkge1xuICBjb25zdCAkID0gaWRGdW5jO1xuICBsZXQgZGF0YSA9IHNvdXJjZSB8fCBbXSxcbiAgICBhZGQgPSBpbnB1dCB8fCBbXSxcbiAgICByZW0gPSB7fSxcbiAgICBjbnQgPSAwO1xuICByZXR1cm4ge1xuICAgIGFkZDogdCA9PiBhZGQucHVzaCh0KSxcbiAgICByZW1vdmU6IHQgPT4gcmVtWyQodCldID0gKytjbnQsXG4gICAgc2l6ZTogKCkgPT4gZGF0YS5sZW5ndGgsXG4gICAgZGF0YTogKGNvbXBhcmUsIHJlc29ydCkgPT4ge1xuICAgICAgaWYgKGNudCkge1xuICAgICAgICBkYXRhID0gZGF0YS5maWx0ZXIodCA9PiAhcmVtWyQodCldKTtcbiAgICAgICAgcmVtID0ge307XG4gICAgICAgIGNudCA9IDA7XG4gICAgICB9XG4gICAgICBpZiAocmVzb3J0ICYmIGNvbXBhcmUpIHtcbiAgICAgICAgZGF0YS5zb3J0KGNvbXBhcmUpO1xuICAgICAgfVxuICAgICAgaWYgKGFkZC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YSA9IGNvbXBhcmUgPyBtZXJnZShjb21wYXJlLCBkYXRhLCBhZGQuc29ydChjb21wYXJlKSkgOiBkYXRhLmNvbmNhdChhZGQpO1xuICAgICAgICBhZGQgPSBbXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0cyBhbGwgZGF0YSB0dXBsZXMgdGhhdCBwYXNzIHRocm91Z2ggdGhpcyBvcGVyYXRvci5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBbiBvcHRpb25hbFxuICogICBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBhZGRpdGlvbmFsbHkgc29ydGluZyB0aGUgY29sbGVjdGVkIHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gQ29sbGVjdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5Db2xsZWN0LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0NvbGxlY3QnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ3NvdXJjZSc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfV1cbn07XG5pbmhlcml0cyhDb2xsZWN0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5BTEwpLFxuICAgICAgbGlzdCA9IFNvcnRlZExpc3QodHVwbGVpZCwgdGhpcy52YWx1ZSwgb3V0Lm1hdGVyaWFsaXplKG91dC5BREQpLmFkZCksXG4gICAgICBzb3J0ID0gXy5zb3J0LFxuICAgICAgbW9kID0gcHVsc2UuY2hhbmdlZCgpIHx8IHNvcnQgJiYgKF8ubW9kaWZpZWQoJ3NvcnQnKSB8fCBwdWxzZS5tb2RpZmllZChzb3J0LmZpZWxkcykpO1xuICAgIG91dC52aXNpdChvdXQuUkVNLCBsaXN0LnJlbW92ZSk7XG4gICAgdGhpcy5tb2RpZmllZChtb2QpO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gbGlzdC5kYXRhKHN0YWJsZUNvbXBhcmUoc29ydCksIG1vZCk7XG5cbiAgICAvLyBwcm9wYWdhdGUgdHJlZSByb290IGlmIGRlZmluZWRcbiAgICBpZiAocHVsc2Uuc291cmNlICYmIHB1bHNlLnNvdXJjZS5yb290KSB7XG4gICAgICB0aGlzLnZhbHVlLnJvb3QgPSBwdWxzZS5zb3VyY2Uucm9vdDtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgY29tcGFyYXRvciBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmd8ZnVuY3Rpb24+fSBwYXJhbXMuZmllbGRzIC0gVGhlIGZpZWxkcyB0byBjb21wYXJlLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLm9yZGVyc10gLSBUaGUgc29ydCBvcmRlcnMuXG4gKiAgIEVhY2ggZW50cnkgc2hvdWxkIGJlIG9uZSBvZiBcImFzY2VuZGluZ1wiIChkZWZhdWx0KSBvciBcImRlc2NlbmRpbmdcIi5cbiAqL1xuZnVuY3Rpb24gQ29tcGFyZShwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBudWxsLCB1cGRhdGUkNSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKENvbXBhcmUsIE9wZXJhdG9yKTtcbmZ1bmN0aW9uIHVwZGF0ZSQ1KF8pIHtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSA/IHRoaXMudmFsdWUgOiBjb21wYXJlKF8uZmllbGRzLCBfLm9yZGVycyk7XG59XG5cbi8qKlxuICogQ291bnQgcmVnZXhwLWRlZmluZWQgcGF0dGVybiBvY2N1cnJlbmNlcyBpbiBhIHRleHQgZmllbGQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gQW4gYWNjZXNzb3IgZm9yIHRoZSB0ZXh0IGZpZWxkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMucGF0dGVybl0gLSBSZWdFeHAgc3RyaW5nIGRlZmluaW5nIHRoZSB0ZXh0IHBhdHRlcm4uXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5jYXNlXSAtIE9uZSBvZiAnbG93ZXInLCAndXBwZXInIG9yIG51bGwgKG1peGVkKSBjYXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuc3RvcHdvcmRzXSAtIFJlZ0V4cCBzdHJpbmcgb2Ygd29yZHMgdG8gaWdub3JlLlxuICovXG5mdW5jdGlvbiBDb3VudFBhdHRlcm4ocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Db3VudFBhdHRlcm4uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnQ291bnRQYXR0ZXJuJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlLFxuICAgICdjaGFuZ2VzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Nhc2UnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3VwcGVyJywgJ2xvd2VyJywgJ21peGVkJ10sXG4gICAgJ2RlZmF1bHQnOiAnbWl4ZWQnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYXR0ZXJuJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ1tcXFxcd1wiXSsnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdG9wd29yZHMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2RlZmF1bHQnOiAnJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFsndGV4dCcsICdjb3VudCddXG4gIH1dXG59O1xuZnVuY3Rpb24gdG9rZW5pemUodGV4dCwgdGNhc2UsIG1hdGNoKSB7XG4gIHN3aXRjaCAodGNhc2UpIHtcbiAgICBjYXNlICd1cHBlcic6XG4gICAgICB0ZXh0ID0gdGV4dC50b1VwcGVyQ2FzZSgpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbG93ZXInOlxuICAgICAgdGV4dCA9IHRleHQudG9Mb3dlckNhc2UoKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiB0ZXh0Lm1hdGNoKG1hdGNoKTtcbn1cbmluaGVyaXRzKENvdW50UGF0dGVybiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHByb2Nlc3MgPSB1cGRhdGUgPT4gdHVwbGUgPT4ge1xuICAgICAgdmFyIHRva2VucyA9IHRva2VuaXplKGdldCh0dXBsZSksIF8uY2FzZSwgbWF0Y2gpIHx8IFtdLFxuICAgICAgICB0O1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGlmICghc3RvcC50ZXN0KHQgPSB0b2tlbnNbaV0pKSB1cGRhdGUodCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBpbml0ID0gdGhpcy5fcGFyYW1ldGVyQ2hlY2soXywgcHVsc2UpLFxuICAgICAgY291bnRzID0gdGhpcy5fY291bnRzLFxuICAgICAgbWF0Y2ggPSB0aGlzLl9tYXRjaCxcbiAgICAgIHN0b3AgPSB0aGlzLl9zdG9wLFxuICAgICAgZ2V0ID0gXy5maWVsZCxcbiAgICAgIGFzID0gXy5hcyB8fCBbJ3RleHQnLCAnY291bnQnXSxcbiAgICAgIGFkZCA9IHByb2Nlc3ModCA9PiBjb3VudHNbdF0gPSAxICsgKGNvdW50c1t0XSB8fCAwKSksXG4gICAgICByZW0gPSBwcm9jZXNzKHQgPT4gY291bnRzW3RdIC09IDEpO1xuICAgIGlmIChpbml0KSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIGFkZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgYWRkKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgcmVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2ZpbmlzaChwdWxzZSwgYXMpOyAvLyBnZW5lcmF0ZSBvdXRwdXQgdHVwbGVzXG4gIH0sXG4gIF9wYXJhbWV0ZXJDaGVjayhfLCBwdWxzZSkge1xuICAgIGxldCBpbml0ID0gZmFsc2U7XG4gICAgaWYgKF8ubW9kaWZpZWQoJ3N0b3B3b3JkcycpIHx8ICF0aGlzLl9zdG9wKSB7XG4gICAgICB0aGlzLl9zdG9wID0gbmV3IFJlZ0V4cCgnXicgKyAoXy5zdG9wd29yZHMgfHwgJycpICsgJyQnLCAnaScpO1xuICAgICAgaW5pdCA9IHRydWU7XG4gICAgfVxuICAgIGlmIChfLm1vZGlmaWVkKCdwYXR0ZXJuJykgfHwgIXRoaXMuX21hdGNoKSB7XG4gICAgICB0aGlzLl9tYXRjaCA9IG5ldyBSZWdFeHAoXy5wYXR0ZXJuIHx8ICdbXFxcXHdcXCddKycsICdnJyk7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgcHVsc2UubW9kaWZpZWQoXy5maWVsZC5maWVsZHMpKSB7XG4gICAgICBpbml0ID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGluaXQpIHRoaXMuX2NvdW50cyA9IHt9O1xuICAgIHJldHVybiBpbml0O1xuICB9LFxuICBfZmluaXNoKHB1bHNlLCBhcykge1xuICAgIGNvbnN0IGNvdW50cyA9IHRoaXMuX2NvdW50cyxcbiAgICAgIHR1cGxlcyA9IHRoaXMuX3R1cGxlcyB8fCAodGhpcy5fdHVwbGVzID0ge30pLFxuICAgICAgdGV4dCA9IGFzWzBdLFxuICAgICAgY291bnQgPSBhc1sxXSxcbiAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKTtcbiAgICBsZXQgdywgdCwgYztcbiAgICBmb3IgKHcgaW4gY291bnRzKSB7XG4gICAgICB0ID0gdHVwbGVzW3ddO1xuICAgICAgYyA9IGNvdW50c1t3XSB8fCAwO1xuICAgICAgaWYgKCF0ICYmIGMpIHtcbiAgICAgICAgdHVwbGVzW3ddID0gdCA9IGluZ2VzdCh7fSk7XG4gICAgICAgIHRbdGV4dF0gPSB3O1xuICAgICAgICB0W2NvdW50XSA9IGM7XG4gICAgICAgIG91dC5hZGQucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoYyA9PT0gMCkge1xuICAgICAgICBpZiAodCkgb3V0LnJlbS5wdXNoKHQpO1xuICAgICAgICBjb3VudHNbd10gPSBudWxsO1xuICAgICAgICB0dXBsZXNbd10gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0W2NvdW50XSAhPT0gYykge1xuICAgICAgICB0W2NvdW50XSA9IGM7XG4gICAgICAgIG91dC5tb2QucHVzaCh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBjcm9zcy1wcm9kdWN0IG9mIGEgdHVwbGUgc3RyZWFtIHdpdGggaXRzZWxmLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6Ym9vbGVhbn0gW3BhcmFtcy5maWx0ZXJdIC0gQW4gb3B0aW9uYWwgZmlsdGVyXG4gKiAgIGZ1bmN0aW9uIGZvciBzZWxlY3RpdmVseSBpbmNsdWRpbmcgdHVwbGVzIGluIHRoZSBjcm9zcyBwcm9kdWN0LlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBbcGFyYW1zLmFzXSAtIFRoZSBuYW1lcyBvZiB0aGUgb3V0cHV0IGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gQ3Jvc3MocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5Dcm9zcy5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdDcm9zcycsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWx0ZXInLFxuICAgICd0eXBlJzogJ2V4cHInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydhJywgJ2InXVxuICB9XVxufTtcbmluaGVyaXRzKENyb3NzLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgYXMgPSBfLmFzIHx8IFsnYScsICdiJ10sXG4gICAgICBhID0gYXNbMF0sXG4gICAgICBiID0gYXNbMV0sXG4gICAgICByZXNldCA9ICF0aGlzLnZhbHVlIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgXy5tb2RpZmllZCgnYXMnKSB8fCBfLm1vZGlmaWVkKCdmaWx0ZXInKTtcbiAgICBsZXQgZGF0YSA9IHRoaXMudmFsdWU7XG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICBpZiAoZGF0YSkgb3V0LnJlbSA9IGRhdGE7XG4gICAgICBkYXRhID0gcHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2U7XG4gICAgICBvdXQuYWRkID0gdGhpcy52YWx1ZSA9IGNyb3NzKGRhdGEsIGEsIGIsIF8uZmlsdGVyIHx8IHRydXRoeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5tb2QgPSBkYXRhO1xuICAgIH1cbiAgICBvdXQuc291cmNlID0gdGhpcy52YWx1ZTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5mdW5jdGlvbiBjcm9zcyhpbnB1dCwgYSwgYiwgZmlsdGVyKSB7XG4gIHZhciBkYXRhID0gW10sXG4gICAgdCA9IHt9LFxuICAgIG4gPSBpbnB1dC5sZW5ndGgsXG4gICAgaSA9IDAsXG4gICAgaixcbiAgICBsZWZ0O1xuICBmb3IgKDsgaSA8IG47ICsraSkge1xuICAgIHRbYV0gPSBsZWZ0ID0gaW5wdXRbaV07XG4gICAgZm9yIChqID0gMDsgaiA8IG47ICsraikge1xuICAgICAgdFtiXSA9IGlucHV0W2pdO1xuICAgICAgaWYgKGZpbHRlcih0KSkge1xuICAgICAgICBkYXRhLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgICAgdCA9IHt9O1xuICAgICAgICB0W2FdID0gbGVmdDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmNvbnN0IERpc3RyaWJ1dGlvbnMgPSB7XG4gIGtkZTogcmFuZG9tS0RFLFxuICBtaXh0dXJlOiByYW5kb21NaXh0dXJlLFxuICBub3JtYWw6IHJhbmRvbU5vcm1hbCxcbiAgbG9nbm9ybWFsOiByYW5kb21Mb2dOb3JtYWwsXG4gIHVuaWZvcm06IHJhbmRvbVVuaWZvcm1cbn07XG5jb25zdCBESVNUUklCVVRJT05TID0gJ2Rpc3RyaWJ1dGlvbnMnLFxuICBGVU5DVElPTiA9ICdmdW5jdGlvbicsXG4gIEZJRUxEID0gJ2ZpZWxkJztcblxuLyoqXG4gKiBQYXJzZSBhIHBhcmFtZXRlciBvYmplY3QgZm9yIGEgcHJvYmFiaWxpdHkgZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHtvYmplY3R9IGRlZiAtIFRoZSBkaXN0cmlidXRpb24gcGFyYW1ldGVyIG9iamVjdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKTpBcnJheTxvYmplY3Q+fSAtIEEgbWV0aG9kIGZvciByZXF1ZXN0aW5nXG4gKiAgIHNvdXJjZSBkYXRhLiBVc2VkIGZvciBkaXN0cmlidXRpb25zIChzdWNoIGFzIEtERSkgdGhhdFxuICogICByZXF1aXJlIHNhbXBsZSBkYXRhIHBvaW50cy4gVGhpcyBtZXRob2Qgd2lsbCBvbmx5IGJlXG4gKiAgIGludm9rZWQgaWYgdGhlICdmcm9tJyBwYXJhbWV0ZXIgZm9yIGEgdGFyZ2V0IGRhdGEgc291cmNlXG4gKiAgIGlzIG5vdCBwcm92aWRlZC4gVHlwaWNhbGx5IHRoaXMgbWV0aG9kIHJldHVybnMgYmFja2luZ1xuICogICBzb3VyY2UgZGF0YSBmb3IgYSBQdWxzZSBvYmplY3QuXG4gKiBAcmV0dXJuIHtvYmplY3R9IC0gVGhlIG91dHB1dCBkaXN0cmlidXRpb24gb2JqZWN0LlxuICovXG5mdW5jdGlvbiBwYXJzZShkZWYsIGRhdGEpIHtcbiAgY29uc3QgZnVuYyA9IGRlZltGVU5DVElPTl07XG4gIGlmICghaGFzT3duUHJvcGVydHkoRGlzdHJpYnV0aW9ucywgZnVuYykpIHtcbiAgICBlcnJvcignVW5rbm93biBkaXN0cmlidXRpb24gZnVuY3Rpb246ICcgKyBmdW5jKTtcbiAgfVxuICBjb25zdCBkID0gRGlzdHJpYnV0aW9uc1tmdW5jXSgpO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gZGVmKSB7XG4gICAgLy8gaWYgZGF0YSBmaWVsZCwgZXh0cmFjdCB2YWx1ZXNcbiAgICBpZiAobmFtZSA9PT0gRklFTEQpIHtcbiAgICAgIGQuZGF0YSgoZGVmLmZyb20gfHwgZGF0YSgpKS5tYXAoZGVmW25hbWVdKSk7XG4gICAgfVxuXG4gICAgLy8gaWYgZGlzdHJpYnV0aW9uIG1peHR1cmUsIHJlY3Vyc2UgdG8gcGFyc2UgZWFjaCBkZWZpbml0aW9uXG4gICAgZWxzZSBpZiAobmFtZSA9PT0gRElTVFJJQlVUSU9OUykge1xuICAgICAgZFtuYW1lXShkZWZbbmFtZV0ubWFwKF8gPT4gcGFyc2UoXywgZGF0YSkpKTtcbiAgICB9XG5cbiAgICAvLyBvdGhlcndpc2UsIHNpbXBseSBzZXQgdGhlIHBhcmFtZXRlclxuICAgIGVsc2UgaWYgKHR5cGVvZiBkW25hbWVdID09PSBGVU5DVElPTikge1xuICAgICAgZFtuYW1lXShkZWZbbmFtZV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZDtcbn1cblxuLyoqXG4gKiBHcmlkIHNhbXBsZSBwb2ludHMgZm9yIGEgcHJvYmFiaWxpdHkgZGVuc2l0eS4gR2l2ZW4gYSBkaXN0cmlidXRpb24gYW5kXG4gKiBhIHNhbXBsaW5nIGV4dGVudCwgd2lsbCBnZW5lcmF0ZSBwb2ludHMgc3VpdGFibGUgZm9yIHBsb3R0aW5nIGVpdGhlclxuICogUERGIChwcm9iYWJpbGl0eSBkZW5zaXR5IGZ1bmN0aW9uKSBvciBDREYgKGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uXG4gKiBmdW5jdGlvbikgY3VydmVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLmRpc3RyaWJ1dGlvbiAtIFRoZSBwcm9iYWJpbGl0eSBkaXN0cmlidXRpb24uIFRoaXNcbiAqICAgaXMgYW4gb2JqZWN0IHBhcmFtZXRlciBkZXBlbmRlbnQgb24gdGhlIGRpc3RyaWJ1dGlvbiB0eXBlLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMubWV0aG9kPSdwZGYnXSAtIFRoZSBkaXN0cmlidXRpb24gbWV0aG9kIHRvIHNhbXBsZS5cbiAqICAgT25lIG9mICdwZGYnIG9yICdjZGYnLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmV4dGVudF0gLSBUaGUgW21pbiwgbWF4XSBleHRlbnQgb3ZlciB3aGljaFxuICogICB0byBzYW1wbGUgdGhlIGRpc3RyaWJ1dGlvbi4gVGhpcyBhcmd1bWVudCBpcyByZXF1aXJlZCBpbiBtb3N0IGNhc2VzLCBidXRcbiAqICAgY2FuIGJlIG9taXR0ZWQgaWYgdGhlIGRpc3RyaWJ1dGlvbiAoZS5nLiwgJ2tkZScpIHN1cHBvcnRzIGEgJ2RhdGEnIG1ldGhvZFxuICogICB0aGF0IHJldHVybnMgbnVtZXJpY2FsIHNhbXBsZSBwb2ludHMgZnJvbSB3aGljaCB0aGUgZXh0ZW50IGNhbiBiZSBkZWR1Y2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWluc3RlcHM9MjVdIC0gVGhlIG1pbmltdW0gbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXNcbiAqICAgZm9yIHBsb3R0aW5nIHRoZSBkZW5zaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMubWF4c3RlcHM9MjAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzXG4gKiAgIGZvciBwbG90dGluZyB0aGUgZGVuc2l0eS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBzXSAtIFRoZSBleGFjdCBudW1iZXIgb2YgY3VydmUgc2FtcGxlcyBmb3JcbiAqICAgcGxvdHRpbmcgdGhlIGRlbnNpdHkuIElmIHNwZWNpZmllZCwgb3ZlcnJpZGVzIGJvdGggbWluc3RlcHMgYW5kIG1heHN0ZXBzXG4gKiAgIHRvIHNldCBhbiBleGFjdCBudW1iZXIgb2YgdW5pZm9ybSBzYW1wbGVzLiBVc2VmdWwgaW4gY29uanVuY3Rpb24gd2l0aFxuICogICBhIGZpeGVkIGV4dGVudCB0byBlbnN1cmUgY29uc2lzdGVudCBzYW1wbGUgcG9pbnRzIGZvciBzdGFja2VkIGRlbnNpdGllcy5cbiAqL1xuZnVuY3Rpb24gRGVuc2l0eShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmNvbnN0IGRpc3RyaWJ1dGlvbnMgPSBbe1xuICAna2V5Jzoge1xuICAgICdmdW5jdGlvbic6ICdub3JtYWwnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ21lYW4nLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGRldicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfV1cbn0sIHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAnbG9nbm9ybWFsJ1xuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdtZWFuJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RkZXYnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAxXG4gIH1dXG59LCB7XG4gICdrZXknOiB7XG4gICAgJ2Z1bmN0aW9uJzogJ3VuaWZvcm0nXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ21pbicsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ21heCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfV1cbn0sIHtcbiAgJ2tleSc6IHtcbiAgICAnZnVuY3Rpb24nOiAna2RlJ1xuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2Zyb20nLFxuICAgICd0eXBlJzogJ2RhdGEnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdiYW5kd2lkdGgnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH1dXG59XTtcbmNvbnN0IG1peHR1cmUgPSB7XG4gICdrZXknOiB7XG4gICAgJ2Z1bmN0aW9uJzogJ21peHR1cmUnXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2Rpc3RyaWJ1dGlvbnMnLFxuICAgICd0eXBlJzogJ3BhcmFtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdwYXJhbXMnOiBkaXN0cmlidXRpb25zXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd3ZWlnaHRzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5EZW5zaXR5LkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0RlbnNpdHknLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3N0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtaW5zdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDI1XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdtYXhzdGVwcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDIwMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ3BkZicsXG4gICAgJ3ZhbHVlcyc6IFsncGRmJywgJ2NkZiddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdkaXN0cmlidXRpb24nLFxuICAgICd0eXBlJzogJ3BhcmFtJyxcbiAgICAncGFyYW1zJzogZGlzdHJpYnV0aW9ucy5jb25jYXQobWl4dHVyZSlcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiBbJ3ZhbHVlJywgJ2RlbnNpdHknXVxuICB9XVxufTtcbmluaGVyaXRzKERlbnNpdHksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8IHB1bHNlLmNoYW5nZWQoKSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnN0IGRpc3QgPSBwYXJzZShfLmRpc3RyaWJ1dGlvbiwgc291cmNlKHB1bHNlKSksXG4gICAgICAgIG1pbnN0ZXBzID0gXy5zdGVwcyB8fCBfLm1pbnN0ZXBzIHx8IDI1LFxuICAgICAgICBtYXhzdGVwcyA9IF8uc3RlcHMgfHwgXy5tYXhzdGVwcyB8fCAyMDA7XG4gICAgICBsZXQgbWV0aG9kID0gXy5tZXRob2QgfHwgJ3BkZic7XG4gICAgICBpZiAobWV0aG9kICE9PSAncGRmJyAmJiBtZXRob2QgIT09ICdjZGYnKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIGRlbnNpdHkgbWV0aG9kOiAnICsgbWV0aG9kKTtcbiAgICAgIH1cbiAgICAgIGlmICghXy5leHRlbnQgJiYgIWRpc3QuZGF0YSkge1xuICAgICAgICBlcnJvcignTWlzc2luZyBkZW5zaXR5IGV4dGVudCBwYXJhbWV0ZXIuJyk7XG4gICAgICB9XG4gICAgICBtZXRob2QgPSBkaXN0W21ldGhvZF07XG4gICAgICBjb25zdCBhcyA9IF8uYXMgfHwgWyd2YWx1ZScsICdkZW5zaXR5J10sXG4gICAgICAgIGRvbWFpbiA9IF8uZXh0ZW50IHx8IGV4dGVudChkaXN0LmRhdGEoKSksXG4gICAgICAgIHZhbHVlcyA9IHNhbXBsZUN1cnZlKG1ldGhvZCwgZG9tYWluLCBtaW5zdGVwcywgbWF4c3RlcHMpLm1hcCh2ID0+IHtcbiAgICAgICAgICBjb25zdCB0dXBsZSA9IHt9O1xuICAgICAgICAgIHR1cGxlW2FzWzBdXSA9IHZbMF07XG4gICAgICAgICAgdHVwbGVbYXNbMV1dID0gdlsxXTtcbiAgICAgICAgICByZXR1cm4gaW5nZXN0KHR1cGxlKTtcbiAgICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuZnVuY3Rpb24gc291cmNlKHB1bHNlKSB7XG4gIHJldHVybiAoKSA9PiBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZTtcbn1cblxuLy8gdXNlIGVpdGhlciBwcm92aWRlZCBhbGlhcyBvciBhY2Nlc3NvciBmaWVsZCBuYW1lXG5mdW5jdGlvbiBmaWVsZE5hbWVzKGZpZWxkcywgYXMpIHtcbiAgaWYgKCFmaWVsZHMpIHJldHVybiBudWxsO1xuICByZXR1cm4gZmllbGRzLm1hcCgoZiwgaSkgPT4gYXNbaV0gfHwgYWNjZXNzb3JOYW1lKGYpKTtcbn1cbmZ1bmN0aW9uIHBhcnRpdGlvbiQxKGRhdGEsIGdyb3VwYnksIGZpZWxkKSB7XG4gIGNvbnN0IGdyb3VwcyA9IFtdLFxuICAgIGdldCA9IGYgPT4gZih0KTtcbiAgbGV0IG1hcCwgaSwgbiwgdCwgaywgZztcblxuICAvLyBwYXJ0aXRpb24gZGF0YSBwb2ludHMgaW50byBncm91cHNcbiAgaWYgKGdyb3VwYnkgPT0gbnVsbCkge1xuICAgIGdyb3Vwcy5wdXNoKGRhdGEubWFwKGZpZWxkKSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yIChtYXAgPSB7fSwgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgdCA9IGRhdGFbaV07XG4gICAgICBrID0gZ3JvdXBieS5tYXAoZ2V0KTtcbiAgICAgIGcgPSBtYXBba107XG4gICAgICBpZiAoIWcpIHtcbiAgICAgICAgbWFwW2tdID0gZyA9IFtdO1xuICAgICAgICBnLmRpbXMgPSBrO1xuICAgICAgICBncm91cHMucHVzaChnKTtcbiAgICAgIH1cbiAgICAgIGcucHVzaChmaWVsZCh0KSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBncm91cHM7XG59XG5cbmNvbnN0IE91dHB1dCA9ICdiaW4nO1xuXG4vKipcbiAqIERvdCBkZW5zaXR5IGJpbm5pbmcgZm9yIGRvdCBwbG90IGNvbnN0cnVjdGlvbi5cbiAqIEJhc2VkIG9uIExlbGFuZCBXaWxraW5zb24sIERvdCBQbG90cywgVGhlIEFtZXJpY2FuIFN0YXRpc3RpY2lhbiwgMTk5OS5cbiAqIGh0dHBzOi8vd3d3LmNzLnVpYy5lZHUvfndpbGtpbnNvbi9QdWJsaWNhdGlvbnMvZG90cGxvdHMucGRmXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIHZhbHVlIGZpZWxkIHRvIGJpbi5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKj59IFtwYXJhbXMuZ3JvdXBieV0gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnMgdG8gZ3JvdXBieS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXBdIC0gVGhlIHN0ZXAgc2l6ZSAoYmluIHdpZHRoKSB3aXRoaW4gd2hpY2ggZG90cyBzaG91bGQgYmVcbiAqICAgc3RhY2tlZC4gRGVmYXVsdHMgdG8gMS8zMCBvZiB0aGUgZXh0ZW50IG9mIHRoZSBkYXRhICpmaWVsZCouXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuc21vb3RoPWZhbHNlXSAtIEEgYm9vbGVhbiBmbGFnIGluZGljYXRpbmcgaWYgZG90IGRlbnNpdHlcbiAqICAgc3RhY2tzIHNob3VsZCBiZSBzbW9vdGhlZCB0byByZWR1Y2UgdmFyaWFuY2UuXG4gKi9cbmZ1bmN0aW9uIERvdEJpbihwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbkRvdEJpbi5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdEb3RCaW4nLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzbW9vdGgnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogT3V0cHV0XG4gIH1dXG59O1xuY29uc3QgYXV0b3N0ZXAgPSAoZGF0YSwgZmllbGQpID0+IHNwYW4oZXh0ZW50KGRhdGEsIGZpZWxkKSkgLyAzMDtcbmluaGVyaXRzKERvdEJpbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmICh0aGlzLnZhbHVlICYmICEoXy5tb2RpZmllZCgpIHx8IHB1bHNlLmNoYW5nZWQoKSkpIHtcbiAgICAgIHJldHVybiBwdWxzZTsgLy8gZWFybHkgZXhpdFxuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbiQxKHB1bHNlLnNvdXJjZSwgXy5ncm91cGJ5LCBpZGVudGl0eSksXG4gICAgICBzbW9vdGggPSBfLnNtb290aCB8fCBmYWxzZSxcbiAgICAgIGZpZWxkID0gXy5maWVsZCxcbiAgICAgIHN0ZXAgPSBfLnN0ZXAgfHwgYXV0b3N0ZXAoc291cmNlLCBmaWVsZCksXG4gICAgICBzb3J0ID0gc3RhYmxlQ29tcGFyZSgoYSwgYikgPT4gZmllbGQoYSkgLSBmaWVsZChiKSksXG4gICAgICBhcyA9IF8uYXMgfHwgT3V0cHV0LFxuICAgICAgbiA9IGdyb3Vwcy5sZW5ndGg7XG5cbiAgICAvLyBjb21wdXRlIGRvdHBsb3QgYmlucyBwZXIgZ3JvdXBcbiAgICBsZXQgbWluID0gSW5maW5pdHksXG4gICAgICBtYXggPSAtSW5maW5pdHksXG4gICAgICBpID0gMCxcbiAgICAgIGo7XG4gICAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGNvbnN0IGcgPSBncm91cHNbaV0uc29ydChzb3J0KTtcbiAgICAgIGogPSAtMTtcbiAgICAgIGZvciAoY29uc3QgdiBvZiBkb3RiaW4oZywgc3RlcCwgc21vb3RoLCBmaWVsZCkpIHtcbiAgICAgICAgaWYgKHYgPCBtaW4pIG1pbiA9IHY7XG4gICAgICAgIGlmICh2ID4gbWF4KSBtYXggPSB2O1xuICAgICAgICBnWysral1bYXNdID0gdjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy52YWx1ZSA9IHtcbiAgICAgIHN0YXJ0OiBtaW4sXG4gICAgICBzdG9wOiBtYXgsXG4gICAgICBzdGVwOiBzdGVwXG4gICAgfTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KHRydWUpLm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogV3JhcHMgYW4gZXhwcmVzc2lvbiBmdW5jdGlvbiB3aXRoIGFjY2VzcyB0byBleHRlcm5hbCBwYXJhbWV0ZXJzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBwYXJhbXMuZXhwciAtIFRoZSBleHByZXNzaW9uIGZ1bmN0aW9uLiBUaGVcbiAqICBmdW5jdGlvbiBzaG91bGQgYWNjZXB0IGJvdGggYSBkYXR1bSBhbmQgYSBwYXJhbWV0ZXIgb2JqZWN0LlxuICogIFRoaXMgb3BlcmF0b3IncyB2YWx1ZSB3aWxsIGJlIGEgbmV3IGZ1bmN0aW9uIHRoYXQgd3JhcHMgdGhlXG4gKiAgZXhwcmVzc2lvbiBmdW5jdGlvbiB3aXRoIGFjY2VzcyB0byB0aGlzIG9wZXJhdG9yJ3MgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gRXhwcmVzc2lvbihwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBudWxsLCB1cGRhdGUkNCwgcGFyYW1zKTtcbiAgdGhpcy5tb2RpZmllZCh0cnVlKTtcbn1cbmluaGVyaXRzKEV4cHJlc3Npb24sIE9wZXJhdG9yKTtcbmZ1bmN0aW9uIHVwZGF0ZSQ0KF8pIHtcbiAgY29uc3QgZXhwciA9IF8uZXhwcjtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoJ2V4cHInKSA/IHRoaXMudmFsdWUgOiBhY2Nlc3NvcihkYXR1bSA9PiBleHByKGRhdHVtLCBfKSwgYWNjZXNzb3JGaWVsZHMoZXhwciksIGFjY2Vzc29yTmFtZShleHByKSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZXMgZXh0ZW50cyAobWluL21heCkgZm9yIGEgZGF0YSBmaWVsZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZmllbGQgb3ZlciB3aGljaCB0byBjb21wdXRlIGV4dGVuZHMuXG4gKi9cbmZ1bmN0aW9uIEV4dGVudChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW3VuZGVmaW5lZCwgdW5kZWZpbmVkXSwgcGFyYW1zKTtcbn1cbkV4dGVudC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdFeHRlbnQnLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoRXh0ZW50LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3QgZXh0ZW50ID0gdGhpcy52YWx1ZSxcbiAgICAgIGZpZWxkID0gXy5maWVsZCxcbiAgICAgIG1vZCA9IHB1bHNlLmNoYW5nZWQoKSB8fCBwdWxzZS5tb2RpZmllZChmaWVsZC5maWVsZHMpIHx8IF8ubW9kaWZpZWQoJ2ZpZWxkJyk7XG4gICAgbGV0IG1pbiA9IGV4dGVudFswXSxcbiAgICAgIG1heCA9IGV4dGVudFsxXTtcbiAgICBpZiAobW9kIHx8IG1pbiA9PSBudWxsKSB7XG4gICAgICBtaW4gPSArSW5maW5pdHk7XG4gICAgICBtYXggPSAtSW5maW5pdHk7XG4gICAgfVxuICAgIHB1bHNlLnZpc2l0KG1vZCA/IHB1bHNlLlNPVVJDRSA6IHB1bHNlLkFERCwgdCA9PiB7XG4gICAgICBjb25zdCB2ID0gdG9OdW1iZXIoZmllbGQodCkpO1xuICAgICAgaWYgKHYgIT0gbnVsbCkge1xuICAgICAgICAvLyBOYU5zIHdpbGwgZmFpbCBhbGwgY29tcGFyaXNvbnMhXG4gICAgICAgIGlmICh2IDwgbWluKSBtaW4gPSB2O1xuICAgICAgICBpZiAodiA+IG1heCkgbWF4ID0gdjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoIU51bWJlci5pc0Zpbml0ZShtaW4pIHx8ICFOdW1iZXIuaXNGaW5pdGUobWF4KSkge1xuICAgICAgbGV0IG5hbWUgPSBhY2Nlc3Nvck5hbWUoZmllbGQpO1xuICAgICAgaWYgKG5hbWUpIG5hbWUgPSBgIGZvciBmaWVsZCBcIiR7bmFtZX1cImA7XG4gICAgICBwdWxzZS5kYXRhZmxvdy53YXJuKGBJbmZpbml0ZSBleHRlbnQke25hbWV9OiBbJHttaW59LCAke21heH1dYCk7XG4gICAgICBtaW4gPSBtYXggPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHRoaXMudmFsdWUgPSBbbWluLCBtYXhdO1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIGJyaWRnZSBiZXR3ZWVuIGEgcGFyZW50IHRyYW5zZm9ybSBhbmQgYSB0YXJnZXQgc3ViZmxvdyB0aGF0XG4gKiBjb25zdW1lcyBvbmx5IGEgc3Vic2V0IG9mIHRoZSB0dXBsZXMgdGhhdCBwYXNzIHRocm91Z2ggdGhlIHBhcmVudC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtQdWxzZX0gcHVsc2UgLSBBIHB1bHNlIHRvIHVzZSBhcyB0aGUgdmFsdWUgb2YgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBwYXJlbnQgLSBUaGUgcGFyZW50IHRyYW5zZm9ybSAodHlwaWNhbGx5IGEgRmFjZXQgaW5zdGFuY2UpLlxuICovXG5mdW5jdGlvbiBTdWJmbG93KHB1bHNlLCBwYXJlbnQpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBwdWxzZSk7XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmNvdW50ID0gMDtcbn1cbmluaGVyaXRzKFN1YmZsb3csIE9wZXJhdG9yLCB7XG4gIC8qKlxuICAgKiBSb3V0ZXMgcHVsc2VzIGZyb20gdGhpcyBzdWJmbG93IHRvIGEgdGFyZ2V0IHRyYW5zZm9ybS5cbiAgICogQHBhcmFtIHtUcmFuc2Zvcm19IHRhcmdldCAtIEEgdHJhbnNmb3JtIHRoYXQgcmVjZWl2ZXMgdGhlIHN1YmZsb3cgb2YgdHVwbGVzLlxuICAgKi9cbiAgY29ubmVjdCh0YXJnZXQpIHtcbiAgICB0aGlzLmRldGFjaFN1YmZsb3cgPSB0YXJnZXQuZGV0YWNoU3ViZmxvdztcbiAgICB0aGlzLnRhcmdldHMoKS5hZGQodGFyZ2V0KTtcbiAgICByZXR1cm4gdGFyZ2V0LnNvdXJjZSA9IHRoaXM7XG4gIH0sXG4gIC8qKlxuICAgKiBBZGQgYW4gJ2FkZCcgdHVwbGUgdG8gdGhlIHN1YmZsb3cgcHVsc2UuXG4gICAqIEBwYXJhbSB7VHVwbGV9IHQgLSBUaGUgdHVwbGUgYmVpbmcgYWRkZWQuXG4gICAqL1xuICBhZGQodCkge1xuICAgIHRoaXMuY291bnQgKz0gMTtcbiAgICB0aGlzLnZhbHVlLmFkZC5wdXNoKHQpO1xuICB9LFxuICAvKipcbiAgICogQWRkIGEgJ3JlbScgdHVwbGUgdG8gdGhlIHN1YmZsb3cgcHVsc2UuXG4gICAqIEBwYXJhbSB7VHVwbGV9IHQgLSBUaGUgdHVwbGUgYmVpbmcgcmVtb3ZlZC5cbiAgICovXG4gIHJlbSh0KSB7XG4gICAgdGhpcy5jb3VudCAtPSAxO1xuICAgIHRoaXMudmFsdWUucmVtLnB1c2godCk7XG4gIH0sXG4gIC8qKlxuICAgKiBBZGQgYSAnbW9kJyB0dXBsZSB0byB0aGUgc3ViZmxvdyBwdWxzZS5cbiAgICogQHBhcmFtIHtUdXBsZX0gdCAtIFRoZSB0dXBsZSBiZWluZyBtb2RpZmllZC5cbiAgICovXG4gIG1vZCh0KSB7XG4gICAgdGhpcy52YWx1ZS5tb2QucHVzaCh0KTtcbiAgfSxcbiAgLyoqXG4gICAqIFJlLWluaXRpYWxpemUgdGhpcyBvcGVyYXRvcidzIHB1bHNlIHZhbHVlLlxuICAgKiBAcGFyYW0ge1B1bHNlfSBwdWxzZSAtIFRoZSBwdWxzZSB0byBjb3B5IGZyb20uXG4gICAqIEBzZWUgUHVsc2UuaW5pdFxuICAgKi9cbiAgaW5pdChwdWxzZSkge1xuICAgIHRoaXMudmFsdWUuaW5pdChwdWxzZSwgcHVsc2UuTk9fU09VUkNFKTtcbiAgfSxcbiAgLyoqXG4gICAqIEV2YWx1YXRlIHRoaXMgb3BlcmF0b3IuIFRoaXMgbWV0aG9kIG92ZXJyaWRlcyB0aGVcbiAgICogZGVmYXVsdCBiZWhhdmlvciB0byBzaW1wbHkgcmV0dXJuIHRoZSBjb250YWluZWQgcHVsc2UgdmFsdWUuXG4gICAqIEByZXR1cm4ge1B1bHNlfVxuICAgKi9cbiAgZXZhbHVhdGUoKSB7XG4gICAgLy8gYXNzZXJ0OiB0aGlzLnZhbHVlLnN0YW1wID09PSBwdWxzZS5zdGFtcFxuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG59KTtcblxuLyoqXG4gKiBGYWNldHMgYSBkYXRhZmxvdyBpbnRvIGEgc2V0IG9mIHN1YmZsb3dzIGJhc2VkIG9uIGEga2V5LlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFmbG93LCBzdHJpbmcpOiBPcGVyYXRvcn0gcGFyYW1zLnN1YmZsb3cgLSBBIGZ1bmN0aW9uXG4gKiAgIHRoYXQgZ2VuZXJhdGVzIGEgc3ViZmxvdyBvZiBvcGVyYXRvcnMgYW5kIHJldHVybnMgaXRzIHJvb3Qgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5rZXkgLSBUaGUga2V5IGZpZWxkIHRvIGZhY2V0IGJ5LlxuICovXG5mdW5jdGlvbiBGYWNldChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywge30sIHBhcmFtcyk7XG4gIHRoaXMuX2tleXMgPSBmYXN0bWFwKCk7IC8vIGNhY2hlIHByZXZpb3VzbHkgY2FsY3VsYXRlZCBrZXkgdmFsdWVzXG5cbiAgLy8ga2VlcCB0cmFjayBvZiBhY3RpdmUgc3ViZmxvd3MsIHVzZSBhcyB0YXJnZXRzIGFycmF5IGZvciBsaXN0ZW5lcnNcbiAgLy8gdGhpcyBhbGxvd3MgdXMgdG8gbGltaXQgcHJvcGFnYXRpb24gdG8gb25seSB1cGRhdGVkIHN1YmZsb3dzXG4gIGNvbnN0IGEgPSB0aGlzLl90YXJnZXRzID0gW107XG4gIGEuYWN0aXZlID0gMDtcbiAgYS5mb3JFYWNoID0gZiA9PiB7XG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBhLmFjdGl2ZTsgaSA8IG47ICsraSkge1xuICAgICAgZihhW2ldLCBpLCBhKTtcbiAgICB9XG4gIH07XG59XG5pbmhlcml0cyhGYWNldCwgVHJhbnNmb3JtLCB7XG4gIGFjdGl2YXRlKGZsb3cpIHtcbiAgICB0aGlzLl90YXJnZXRzW3RoaXMuX3RhcmdldHMuYWN0aXZlKytdID0gZmxvdztcbiAgfSxcbiAgLy8gcGFyZW50IGFyZ3VtZW50IHByb3ZpZGVkIGJ5IFByZUZhY2V0IHN1YmNsYXNzXG4gIHN1YmZsb3coa2V5LCBmbG93LCBwdWxzZSwgcGFyZW50KSB7XG4gICAgY29uc3QgZmxvd3MgPSB0aGlzLnZhbHVlO1xuICAgIGxldCBzZiA9IGhhc093blByb3BlcnR5KGZsb3dzLCBrZXkpICYmIGZsb3dzW2tleV0sXG4gICAgICBkZixcbiAgICAgIHA7XG4gICAgaWYgKCFzZikge1xuICAgICAgcCA9IHBhcmVudCB8fCAocCA9IHRoaXMuX2dyb3VwW2tleV0pICYmIHAudHVwbGU7XG4gICAgICBkZiA9IHB1bHNlLmRhdGFmbG93O1xuICAgICAgc2YgPSBuZXcgU3ViZmxvdyhwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksIHRoaXMpO1xuICAgICAgZGYuYWRkKHNmKS5jb25uZWN0KGZsb3coZGYsIGtleSwgcCkpO1xuICAgICAgZmxvd3Nba2V5XSA9IHNmO1xuICAgICAgdGhpcy5hY3RpdmF0ZShzZik7XG4gICAgfSBlbHNlIGlmIChzZi52YWx1ZS5zdGFtcCA8IHB1bHNlLnN0YW1wKSB7XG4gICAgICBzZi5pbml0KHB1bHNlKTtcbiAgICAgIHRoaXMuYWN0aXZhdGUoc2YpO1xuICAgIH1cbiAgICByZXR1cm4gc2Y7XG4gIH0sXG4gIGNsZWFuKCkge1xuICAgIGNvbnN0IGZsb3dzID0gdGhpcy52YWx1ZTtcbiAgICBsZXQgZGV0YWNoZWQgPSAwO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZsb3dzKSB7XG4gICAgICBpZiAoZmxvd3Nba2V5XS5jb3VudCA9PT0gMCkge1xuICAgICAgICBjb25zdCBkZXRhY2ggPSBmbG93c1trZXldLmRldGFjaFN1YmZsb3c7XG4gICAgICAgIGlmIChkZXRhY2gpIGRldGFjaCgpO1xuICAgICAgICBkZWxldGUgZmxvd3Nba2V5XTtcbiAgICAgICAgKytkZXRhY2hlZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyByZW1vdmUgaW5hY3RpdmUgdGFyZ2V0cyBmcm9tIHRoZSBhY3RpdmUgdGFyZ2V0cyBhcnJheVxuICAgIGlmIChkZXRhY2hlZCkge1xuICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fdGFyZ2V0cy5maWx0ZXIoc2YgPT4gc2YgJiYgc2YuY291bnQgPiAwKTtcbiAgICAgIHRoaXMuaW5pdFRhcmdldHMoYWN0aXZlKTtcbiAgICB9XG4gIH0sXG4gIGluaXRUYXJnZXRzKGFjdCkge1xuICAgIGNvbnN0IGEgPSB0aGlzLl90YXJnZXRzLFxuICAgICAgbiA9IGEubGVuZ3RoLFxuICAgICAgbSA9IGFjdCA/IGFjdC5sZW5ndGggOiAwO1xuICAgIGxldCBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG07ICsraSkge1xuICAgICAgYVtpXSA9IGFjdFtpXTtcbiAgICB9XG4gICAgZm9yICg7IGkgPCBuICYmIGFbaV0gIT0gbnVsbDsgKytpKSB7XG4gICAgICBhW2ldID0gbnVsbDsgLy8gZW5zdXJlIG9sZCBmbG93cyBjYW4gYmUgZ2FyYmFnZSBjb2xsZWN0ZWRcbiAgICB9XG4gICAgYS5hY3RpdmUgPSBtO1xuICB9LFxuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBkZiA9IHB1bHNlLmRhdGFmbG93LFxuICAgICAga2V5ID0gXy5rZXksXG4gICAgICBmbG93ID0gXy5zdWJmbG93LFxuICAgICAgY2FjaGUgPSB0aGlzLl9rZXlzLFxuICAgICAgcmVrZXkgPSBfLm1vZGlmaWVkKCdrZXknKSxcbiAgICAgIHN1YmZsb3cgPSBrZXkgPT4gdGhpcy5zdWJmbG93KGtleSwgZmxvdywgcHVsc2UpO1xuICAgIHRoaXMuX2dyb3VwID0gXy5ncm91cCB8fCB7fTtcbiAgICB0aGlzLmluaXRUYXJnZXRzKCk7IC8vIHJlc2V0IGxpc3Qgb2YgYWN0aXZlIHN1YmZsb3dzXG5cbiAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICBrID0gY2FjaGUuZ2V0KGlkKTtcbiAgICAgIGlmIChrICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY2FjaGUuZGVsZXRlKGlkKTtcbiAgICAgICAgc3ViZmxvdyhrKS5yZW0odCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgIGNvbnN0IGsgPSBrZXkodCk7XG4gICAgICBjYWNoZS5zZXQodHVwbGVpZCh0KSwgayk7XG4gICAgICBzdWJmbG93KGspLmFkZCh0KTtcbiAgICB9KTtcbiAgICBpZiAocmVrZXkgfHwgcHVsc2UubW9kaWZpZWQoa2V5LmZpZWxkcykpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdHVwbGVpZCh0KSxcbiAgICAgICAgICBrMCA9IGNhY2hlLmdldChpZCksXG4gICAgICAgICAgazEgPSBrZXkodCk7XG4gICAgICAgIGlmIChrMCA9PT0gazEpIHtcbiAgICAgICAgICBzdWJmbG93KGsxKS5tb2QodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2FjaGUuc2V0KGlkLCBrMSk7XG4gICAgICAgICAgc3ViZmxvdyhrMCkucmVtKHQpO1xuICAgICAgICAgIHN1YmZsb3coazEpLmFkZCh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChwdWxzZS5jaGFuZ2VkKHB1bHNlLk1PRCkpIHtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICAgIHN1YmZsb3coY2FjaGUuZ2V0KHR1cGxlaWQodCkpKS5tb2QodCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHJla2V5KSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRUZMT1csIHQgPT4ge1xuICAgICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCksXG4gICAgICAgICAgazAgPSBjYWNoZS5nZXQoaWQpLFxuICAgICAgICAgIGsxID0ga2V5KHQpO1xuICAgICAgICBpZiAoazAgIT09IGsxKSB7XG4gICAgICAgICAgY2FjaGUuc2V0KGlkLCBrMSk7XG4gICAgICAgICAgc3ViZmxvdyhrMCkucmVtKHQpO1xuICAgICAgICAgIHN1YmZsb3coazEpLmFkZCh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwdWxzZS5jbGVhbigpKSB7XG4gICAgICBkZi5ydW5BZnRlcigoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xlYW4oKTtcbiAgICAgICAgY2FjaGUuY2xlYW4oKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAoY2FjaGUuZW1wdHkgPiBkZi5jbGVhblRocmVzaG9sZCkge1xuICAgICAgZGYucnVuQWZ0ZXIoY2FjaGUuY2xlYW4pO1xuICAgIH1cbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBvbmUgb3IgbW9yZSBmaWVsZCBhY2Nlc3NvciBmdW5jdGlvbnMuXG4gKiBJZiB0aGUgJ25hbWUnIHBhcmFtZXRlciBpcyBhbiBhcnJheSwgYW4gYXJyYXkgb2YgZmllbGQgYWNjZXNzb3JzXG4gKiB3aWxsIGJlIGNyZWF0ZWQgYW5kIHRoZSAnYXMnIHBhcmFtZXRlciB3aWxsIGJlIGlnbm9yZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMubmFtZSAtIFRoZSBmaWVsZCBuYW1lKHMpIHRvIGFjY2Vzcy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXMgLSBUaGUgYWNjZXNzb3IgZnVuY3Rpb24gbmFtZS5cbiAqL1xuZnVuY3Rpb24gRmllbGQocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlJDMsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhGaWVsZCwgT3BlcmF0b3IpO1xuZnVuY3Rpb24gdXBkYXRlJDMoXykge1xuICByZXR1cm4gdGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpID8gdGhpcy52YWx1ZSA6IGlzQXJyYXkoXy5uYW1lKSA/IGFycmF5KF8ubmFtZSkubWFwKGYgPT4gZmllbGQoZikpIDogZmllbGQoXy5uYW1lLCBfLmFzKTtcbn1cblxuLyoqXG4gKiBGaWx0ZXJzIGRhdGEgdHVwbGVzIGFjY29yZGluZyB0byBhIHByZWRpY2F0ZSBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZXhwciAtIFRoZSBwcmVkaWNhdGUgZXhwcmVzc2lvbiBmdW5jdGlvblxuICogICB0aGF0IGRldGVybWluZXMgYSB0dXBsZSdzIGZpbHRlciBzdGF0dXMuIFRydXRoeSB2YWx1ZXMgcGFzcyB0aGUgZmlsdGVyLlxuICovXG5mdW5jdGlvbiBGaWx0ZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIGZhc3RtYXAoKSwgcGFyYW1zKTtcbn1cbkZpbHRlci5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGaWx0ZXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2V4cHInLFxuICAgICd0eXBlJzogJ2V4cHInLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhGaWx0ZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBkZiA9IHB1bHNlLmRhdGFmbG93LFxuICAgICAgY2FjaGUgPSB0aGlzLnZhbHVlLFxuICAgICAgLy8gY2FjaGUgaWRzIG9mIGZpbHRlcmVkIHR1cGxlc1xuICAgICAgb3V0cHV0ID0gcHVsc2UuZm9yaygpLFxuICAgICAgYWRkID0gb3V0cHV0LmFkZCxcbiAgICAgIHJlbSA9IG91dHB1dC5yZW0sXG4gICAgICBtb2QgPSBvdXRwdXQubW9kLFxuICAgICAgdGVzdCA9IF8uZXhwcjtcbiAgICBsZXQgaXNNb2QgPSB0cnVlO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICBjb25zdCBpZCA9IHR1cGxlaWQodCk7XG4gICAgICBpZiAoIWNhY2hlLmhhcyhpZCkpIHJlbS5wdXNoKHQpO2Vsc2UgY2FjaGUuZGVsZXRlKGlkKTtcbiAgICB9KTtcbiAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgaWYgKHRlc3QodCwgXykpIGFkZC5wdXNoKHQpO2Vsc2UgY2FjaGUuc2V0KHR1cGxlaWQodCksIDEpO1xuICAgIH0pO1xuICAgIGZ1bmN0aW9uIHJldmlzaXQodCkge1xuICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpLFxuICAgICAgICBiID0gdGVzdCh0LCBfKSxcbiAgICAgICAgcyA9IGNhY2hlLmdldChpZCk7XG4gICAgICBpZiAoYiAmJiBzKSB7XG4gICAgICAgIGNhY2hlLmRlbGV0ZShpZCk7XG4gICAgICAgIGFkZC5wdXNoKHQpO1xuICAgICAgfSBlbHNlIGlmICghYiAmJiAhcykge1xuICAgICAgICBjYWNoZS5zZXQoaWQsIDEpO1xuICAgICAgICByZW0ucHVzaCh0KTtcbiAgICAgIH0gZWxzZSBpZiAoaXNNb2QgJiYgYiAmJiAhcykge1xuICAgICAgICBtb2QucHVzaCh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCByZXZpc2l0KTtcbiAgICBpZiAoXy5tb2RpZmllZCgpKSB7XG4gICAgICBpc01vZCA9IGZhbHNlO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVGTE9XLCByZXZpc2l0KTtcbiAgICB9XG4gICAgaWYgKGNhY2hlLmVtcHR5ID4gZGYuY2xlYW5UaHJlc2hvbGQpIGRmLnJ1bkFmdGVyKGNhY2hlLmNsZWFuKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG59KTtcblxuLyoqXG4gKiBGbGF0dGVucyBhcnJheS10eXBlZCBmaWVsZCB2YWx1ZXMgaW50byBuZXcgZGF0YSBvYmplY3RzLlxuICogSWYgbXVsdGlwbGUgZmllbGRzIGFyZSBzcGVjaWZpZWQsIHRoZXkgYXJlIHRyZWF0ZWQgYXMgcGFyYWxsZWwgYXJyYXlzLFxuICogd2l0aCBvdXRwdXQgdmFsdWVzIGluY2x1ZGVkIGZvciBlYWNoIG1hdGNoaW5nIGluZGV4IChvciBudWxsIGlmIG1pc3NpbmcpLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBwYXJhbXMuZmllbGRzIC0gQW4gYXJyYXkgb2YgZmllbGRcbiAqICAgYWNjZXNzb3JzIGZvciB0aGUgdHVwbGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIGZsYXR0ZW5lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbcGFyYW1zLmluZGV4XSAtIE9wdGlvbmFsIG91dHB1dCBmaWVsZCBuYW1lIGZvciBpbmRleFxuICogICB2YWx1ZS4gSWYgdW5zcGVjaWZpZWQsIG5vIGluZGV4IGZpZWxkIGlzIGluY2x1ZGVkIGluIHRoZSBvdXRwdXQuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gT3V0cHV0IGZpZWxkIG5hbWVzIGZvciBmbGF0dGVuZWRcbiAqICAgYXJyYXkgZmllbGRzLiBBbnkgdW5zcGVjaWZpZWQgZmllbGRzIHdpbGwgdXNlIHRoZSBmaWVsZCBuYW1lIHByb3ZpZGVkXG4gKiAgIGJ5IHRoZSBmaWVsZHMgYWNjZXNzb3JzLlxuICovXG5mdW5jdGlvbiBGbGF0dGVuKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBbXSwgcGFyYW1zKTtcbn1cbkZsYXR0ZW4uRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnRmxhdHRlbicsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2luZGV4JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoRmxhdHRlbiwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKSxcbiAgICAgIGZpZWxkcyA9IF8uZmllbGRzLFxuICAgICAgYXMgPSBmaWVsZE5hbWVzKGZpZWxkcywgXy5hcyB8fCBbXSksXG4gICAgICBpbmRleCA9IF8uaW5kZXggfHwgbnVsbCxcbiAgICAgIG0gPSBhcy5sZW5ndGg7XG5cbiAgICAvLyByZW1vdmUgYW55IHByZXZpb3VzIHJlc3VsdHNcbiAgICBvdXQucmVtID0gdGhpcy52YWx1ZTtcblxuICAgIC8vIGdlbmVyYXRlIGZsYXR0ZW5lZCB0dXBsZXNcbiAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4ge1xuICAgICAgY29uc3QgYXJyYXlzID0gZmllbGRzLm1hcChmID0+IGYodCkpLFxuICAgICAgICBtYXhsZW4gPSBhcnJheXMucmVkdWNlKChsLCBhKSA9PiBNYXRoLm1heChsLCBhLmxlbmd0aCksIDApO1xuICAgICAgbGV0IGkgPSAwLFxuICAgICAgICBqLFxuICAgICAgICBkLFxuICAgICAgICB2O1xuICAgICAgZm9yICg7IGkgPCBtYXhsZW47ICsraSkge1xuICAgICAgICBkID0gZGVyaXZlKHQpO1xuICAgICAgICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB7XG4gICAgICAgICAgZFthc1tqXV0gPSAodiA9IGFycmF5c1tqXVtpXSkgPT0gbnVsbCA/IG51bGwgOiB2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCkge1xuICAgICAgICAgIGRbaW5kZXhdID0gaTtcbiAgICAgICAgfVxuICAgICAgICBvdXQuYWRkLnB1c2goZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy52YWx1ZSA9IG91dC5zb3VyY2UgPSBvdXQuYWRkO1xuICAgIGlmIChpbmRleCkgb3V0Lm1vZGlmaWVzKGluZGV4KTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogRm9sZHMgb25lIG1vcmUgdHVwbGUgZmllbGRzIGludG8gbXVsdGlwbGUgdHVwbGVzIGluIHdoaWNoIHRoZSBmaWVsZFxuICogbmFtZSBhbmQgdmFsdWVzIGFyZSBhdmFpbGFibGUgdW5kZXIgbmV3ICdrZXknIGFuZCAndmFsdWUnIGZpZWxkcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGRzIC0gQW4gYXJyYXkgb2YgZmllbGQgYWNjZXNzb3JzXG4gKiAgIGZvciB0aGUgdHVwbGUgZmllbGRzIHRoYXQgc2hvdWxkIGJlIGZvbGRlZC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGZvbGRlZCBrZXlcbiAqICAgYW5kIHZhbHVlIGZpZWxkcywgZGVmYXVsdHMgdG8gWydrZXknLCAndmFsdWUnXS5cbiAqL1xuZnVuY3Rpb24gRm9sZChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5Gb2xkLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ZvbGQnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyLFxuICAgICdkZWZhdWx0JzogWydrZXknLCAndmFsdWUnXVxuICB9XVxufTtcbmluaGVyaXRzKEZvbGQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICBmaWVsZHMgPSBfLmZpZWxkcyxcbiAgICAgIGZuYW1lcyA9IGZpZWxkcy5tYXAoYWNjZXNzb3JOYW1lKSxcbiAgICAgIGFzID0gXy5hcyB8fCBbJ2tleScsICd2YWx1ZSddLFxuICAgICAgayA9IGFzWzBdLFxuICAgICAgdiA9IGFzWzFdLFxuICAgICAgbiA9IGZpZWxkcy5sZW5ndGg7XG4gICAgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBkOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIGQgPSBkZXJpdmUodCk7XG4gICAgICAgIGRba10gPSBmbmFtZXNbaV07XG4gICAgICAgIGRbdl0gPSBmaWVsZHNbaV0odCk7XG4gICAgICAgIG91dC5hZGQucHVzaChkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLnZhbHVlID0gb3V0LnNvdXJjZSA9IG91dC5hZGQ7XG4gICAgcmV0dXJuIG91dC5tb2RpZmllcyhhcyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEludm9rZXMgYSBmdW5jdGlvbiBmb3IgZWFjaCBkYXRhIHR1cGxlIGFuZCBzYXZlcyB0aGUgcmVzdWx0cyBhcyBhIG5ldyBmaWVsZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZXhwciAtIFRoZSBmb3JtdWxhIGZ1bmN0aW9uIHRvIGludm9rZSBmb3IgZWFjaCB0dXBsZS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJhbXMuYXMgLSBUaGUgZmllbGQgbmFtZSB1bmRlciB3aGljaCB0byBzYXZlIHRoZSByZXN1bHQuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtwYXJhbXMuaW5pdG9ubHk9ZmFsc2VdIC0gSWYgdHJ1ZSwgdGhlIGZvcm11bGEgaXMgYXBwbGllZCB0b1xuICogICBhZGRlZCB0dXBsZXMgb25seSwgYW5kIGRvZXMgbm90IHVwZGF0ZSBpbiByZXNwb25zZSB0byBtb2RpZmljYXRpb25zLlxuICovXG5mdW5jdGlvbiBGb3JtdWxhKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuRm9ybXVsYS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdGb3JtdWxhJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZXhwcicsXG4gICAgJ3R5cGUnOiAnZXhwcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaW5pdG9ubHknLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nXG4gIH1dXG59O1xuaW5oZXJpdHMoRm9ybXVsYSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZ1bmMgPSBfLmV4cHIsXG4gICAgICBhcyA9IF8uYXMsXG4gICAgICBtb2QgPSBfLm1vZGlmaWVkKCksXG4gICAgICBmbGFnID0gXy5pbml0b25seSA/IHB1bHNlLkFERCA6IG1vZCA/IHB1bHNlLlNPVVJDRSA6IHB1bHNlLm1vZGlmaWVkKGZ1bmMuZmllbGRzKSB8fCBwdWxzZS5tb2RpZmllZChhcykgPyBwdWxzZS5BRERfTU9EIDogcHVsc2UuQUREO1xuICAgIGlmIChtb2QpIHtcbiAgICAgIC8vIHBhcmFtZXRlcnMgdXBkYXRlZCwgbmVlZCB0byByZWZsb3dcbiAgICAgIHB1bHNlID0gcHVsc2UubWF0ZXJpYWxpemUoKS5yZWZsb3codHJ1ZSk7XG4gICAgfVxuICAgIGlmICghXy5pbml0b25seSkge1xuICAgICAgcHVsc2UubW9kaWZpZXMoYXMpO1xuICAgIH1cbiAgICByZXR1cm4gcHVsc2UudmlzaXQoZmxhZywgdCA9PiB0W2FzXSA9IGZ1bmModCwgXykpO1xuICB9XG59KTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgZGF0YSB0dXBsZXMgdXNpbmcgYSBwcm92aWRlZCBnZW5lcmF0b3IgZnVuY3Rpb24uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oUGFyYW1ldGVycyk6IG9iamVjdH0gcGFyYW1zLmdlbmVyYXRvciAtIEEgdHVwbGUgZ2VuZXJhdG9yXG4gKiAgIGZ1bmN0aW9uLiBUaGlzIGZ1bmN0aW9uIGlzIGdpdmVuIHRoZSBvcGVyYXRvciBwYXJhbWV0ZXJzIGFzIGlucHV0LlxuICogICBDaGFuZ2VzIHRvIGFueSBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgd2lsbCBub3QgdHJpZ2dlciByZS1jYWxjdWxhdGlvblxuICogICBvZiBwcmV2aW91c2x5IGdlbmVyYXRlZCB0dXBsZXMuIE9ubHkgZnV0dXJlIHR1cGxlcyBhcmUgYWZmZWN0ZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gcGFyYW1zLnNpemUgLSBUaGUgbnVtYmVyIG9mIHR1cGxlcyB0byBwcm9kdWNlLlxuICovXG5mdW5jdGlvbiBHZW5lcmF0ZShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG59XG5pbmhlcml0cyhHZW5lcmF0ZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IG91dCA9IHB1bHNlLmZvcmsocHVsc2UuQUxMKSxcbiAgICAgIGdlbiA9IF8uZ2VuZXJhdG9yO1xuICAgIGxldCBkYXRhID0gdGhpcy52YWx1ZSxcbiAgICAgIG51bSA9IF8uc2l6ZSAtIGRhdGEubGVuZ3RoLFxuICAgICAgYWRkLFxuICAgICAgcmVtLFxuICAgICAgdDtcbiAgICBpZiAobnVtID4gMCkge1xuICAgICAgLy8gbmVlZCBtb3JlIHR1cGxlcywgZ2VuZXJhdGUgYW5kIGFkZFxuICAgICAgZm9yIChhZGQgPSBbXTsgLS1udW0gPj0gMDspIHtcbiAgICAgICAgYWRkLnB1c2godCA9IGluZ2VzdChnZW4oXykpKTtcbiAgICAgICAgZGF0YS5wdXNoKHQpO1xuICAgICAgfVxuICAgICAgb3V0LmFkZCA9IG91dC5hZGQubGVuZ3RoID8gb3V0Lm1hdGVyaWFsaXplKG91dC5BREQpLmFkZC5jb25jYXQoYWRkKSA6IGFkZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gbmVlZCBmZXdlciB0dXBsZXMsIHJlbW92ZVxuICAgICAgcmVtID0gZGF0YS5zbGljZSgwLCAtbnVtKTtcbiAgICAgIG91dC5yZW0gPSBvdXQucmVtLmxlbmd0aCA/IG91dC5tYXRlcmlhbGl6ZShvdXQuUkVNKS5yZW0uY29uY2F0KHJlbSkgOiByZW07XG4gICAgICBkYXRhID0gZGF0YS5zbGljZSgtbnVtKTtcbiAgICB9XG4gICAgb3V0LnNvdXJjZSA9IHRoaXMudmFsdWUgPSBkYXRhO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG5jb25zdCBNZXRob2RzID0ge1xuICB2YWx1ZTogJ3ZhbHVlJyxcbiAgbWVkaWFuOiBtZWRpYW4sXG4gIG1lYW46IG1lYW4sXG4gIG1pbjogbWluLFxuICBtYXg6IG1heFxufTtcbmNvbnN0IEVtcHR5ID0gW107XG5cbi8qKlxuICogSW1wdXRlIG1pc3NpbmcgdmFsdWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSB2YWx1ZSBmaWVsZCB0byBpbXB1dGUuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2ZcbiAqICAgYWNjZXNzb3JzIHRvIGRldGVybWluZSBzZXJpZXMgd2l0aGluIHdoaWNoIHRvIHBlcmZvcm0gaW1wdXRhdGlvbi5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmtleSAtIEFuIGFjY2Vzc29yIGZvciBhIGtleSB2YWx1ZS5cbiAqICAgRWFjaCBrZXkgdmFsdWUgc2hvdWxkIGJlIHVuaXF1ZSB3aXRoaW4gYSBncm91cC4gTmV3IHR1cGxlcyB3aWxsIGJlXG4gKiAgIGltcHV0ZWQgZm9yIGFueSBrZXkgdmFsdWVzIHRoYXQgYXJlIG5vdCBmb3VuZCB3aXRoaW4gYSBncm91cC5cbiAqIEBwYXJhbSB7QXJyYXk8Kj59IFtwYXJhbXMua2V5dmFsc10gLSBPcHRpb25hbCBhcnJheSBvZiByZXF1aXJlZCBrZXlcbiAqICAgdmFsdWVzLiBOZXcgdHVwbGVzIHdpbGwgYmUgaW1wdXRlZCBmb3IgYW55IGtleSB2YWx1ZXMgdGhhdCBhcmUgbm90XG4gKiAgIGZvdW5kIHdpdGhpbiBhIGdyb3VwLiBJbiBhZGRpdGlvbiwgdGhlc2UgdmFsdWVzIHdpbGwgYmUgYXV0b21hdGljYWxseVxuICogICBhdWdtZW50ZWQgd2l0aCB0aGUga2V5IHZhbHVlcyBvYnNlcnZlZCBpbiB0aGUgaW5wdXQgZGF0YS5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPSd2YWx1ZSddIC0gVGhlIGltcHV0YXRpb24gbWV0aG9kIHRvIHVzZS4gT25lIG9mXG4gKiAgICd2YWx1ZScsICdtZWFuJywgJ21lZGlhbicsICdtYXgnLCAnbWluJy5cbiAqIEBwYXJhbSB7Kn0gW3ZhbHVlPTBdIC0gVGhlIGNvbnN0YW50IHZhbHVlIHRvIHVzZSBmb3IgaW1wdXRhdGlvblxuICogICB3aGVuIHVzaW5nIG1ldGhvZCAndmFsdWUnLlxuICovXG5mdW5jdGlvbiBJbXB1dGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xufVxuSW1wdXRlLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0ltcHV0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGQnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdrZXl2YWxzJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdncm91cGJ5JyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWV0aG9kJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICd2YWx1ZScsXG4gICAgJ3ZhbHVlcyc6IFsndmFsdWUnLCAnbWVhbicsICdtZWRpYW4nLCAnbWF4JywgJ21pbiddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2YWx1ZScsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH1dXG59O1xuZnVuY3Rpb24gZ2V0VmFsdWUoXykge1xuICB2YXIgbSA9IF8ubWV0aG9kIHx8IE1ldGhvZHMudmFsdWUsXG4gICAgdjtcbiAgaWYgKE1ldGhvZHNbbV0gPT0gbnVsbCkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgaW1wdXRhdGlvbiBtZXRob2Q6ICcgKyBtKTtcbiAgfSBlbHNlIGlmIChtID09PSBNZXRob2RzLnZhbHVlKSB7XG4gICAgdiA9IF8udmFsdWUgIT09IHVuZGVmaW5lZCA/IF8udmFsdWUgOiAwO1xuICAgIHJldHVybiAoKSA9PiB2O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBNZXRob2RzW21dO1xuICB9XG59XG5mdW5jdGlvbiBnZXRGaWVsZChfKSB7XG4gIGNvbnN0IGYgPSBfLmZpZWxkO1xuICByZXR1cm4gdCA9PiB0ID8gZih0KSA6IE5hTjtcbn1cbmluaGVyaXRzKEltcHV0ZSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIHZhciBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLkFMTCksXG4gICAgICBpbXB1dGUgPSBnZXRWYWx1ZShfKSxcbiAgICAgIGZpZWxkID0gZ2V0RmllbGQoXyksXG4gICAgICBmTmFtZSA9IGFjY2Vzc29yTmFtZShfLmZpZWxkKSxcbiAgICAgIGtOYW1lID0gYWNjZXNzb3JOYW1lKF8ua2V5KSxcbiAgICAgIGdOYW1lcyA9IChfLmdyb3VwYnkgfHwgW10pLm1hcChhY2Nlc3Nvck5hbWUpLFxuICAgICAgZ3JvdXBzID0gcGFydGl0aW9uKHB1bHNlLnNvdXJjZSwgXy5ncm91cGJ5LCBfLmtleSwgXy5rZXl2YWxzKSxcbiAgICAgIGN1cnIgPSBbXSxcbiAgICAgIHByZXYgPSB0aGlzLnZhbHVlLFxuICAgICAgbSA9IGdyb3Vwcy5kb21haW4ubGVuZ3RoLFxuICAgICAgZ3JvdXAsXG4gICAgICB2YWx1ZSxcbiAgICAgIGdWYWxzLFxuICAgICAga1ZhbCxcbiAgICAgIGcsXG4gICAgICBpLFxuICAgICAgaixcbiAgICAgIGwsXG4gICAgICBuLFxuICAgICAgdDtcbiAgICBmb3IgKGcgPSAwLCBsID0gZ3JvdXBzLmxlbmd0aDsgZyA8IGw7ICsrZykge1xuICAgICAgZ3JvdXAgPSBncm91cHNbZ107XG4gICAgICBnVmFscyA9IGdyb3VwLnZhbHVlcztcbiAgICAgIHZhbHVlID0gTmFOO1xuXG4gICAgICAvLyBhZGQgdHVwbGVzIGZvciBtaXNzaW5nIHZhbHVlc1xuICAgICAgZm9yIChqID0gMDsgaiA8IG07ICsraikge1xuICAgICAgICBpZiAoZ3JvdXBbal0gIT0gbnVsbCkgY29udGludWU7XG4gICAgICAgIGtWYWwgPSBncm91cHMuZG9tYWluW2pdO1xuICAgICAgICB0ID0ge1xuICAgICAgICAgIF9pbXB1dGU6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgZm9yIChpID0gMCwgbiA9IGdWYWxzLmxlbmd0aDsgaSA8IG47ICsraSkgdFtnTmFtZXNbaV1dID0gZ1ZhbHNbaV07XG4gICAgICAgIHRba05hbWVdID0ga1ZhbDtcbiAgICAgICAgdFtmTmFtZV0gPSBOdW1iZXIuaXNOYU4odmFsdWUpID8gdmFsdWUgPSBpbXB1dGUoZ3JvdXAsIGZpZWxkKSA6IHZhbHVlO1xuICAgICAgICBjdXJyLnB1c2goaW5nZXN0KHQpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgcHVsc2Ugd2l0aCBpbXB1dGVkIHR1cGxlc1xuICAgIGlmIChjdXJyLmxlbmd0aCkgb3V0LmFkZCA9IG91dC5tYXRlcmlhbGl6ZShvdXQuQUREKS5hZGQuY29uY2F0KGN1cnIpO1xuICAgIGlmIChwcmV2Lmxlbmd0aCkgb3V0LnJlbSA9IG91dC5tYXRlcmlhbGl6ZShvdXQuUkVNKS5yZW0uY29uY2F0KHByZXYpO1xuICAgIHRoaXMudmFsdWUgPSBjdXJyO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcGFydGl0aW9uKGRhdGEsIGdyb3VwYnksIGtleSwga2V5dmFscykge1xuICB2YXIgZ2V0ID0gZiA9PiBmKHQpLFxuICAgIGdyb3VwcyA9IFtdLFxuICAgIGRvbWFpbiA9IGtleXZhbHMgPyBrZXl2YWxzLnNsaWNlKCkgOiBbXSxcbiAgICBrTWFwID0ge30sXG4gICAgZ01hcCA9IHt9LFxuICAgIGdWYWxzLFxuICAgIGdLZXksXG4gICAgZ3JvdXAsXG4gICAgaSxcbiAgICBqLFxuICAgIGssXG4gICAgbixcbiAgICB0O1xuICBkb21haW4uZm9yRWFjaCgoaywgaSkgPT4ga01hcFtrXSA9IGkgKyAxKTtcbiAgZm9yIChpID0gMCwgbiA9IGRhdGEubGVuZ3RoOyBpIDwgbjsgKytpKSB7XG4gICAgdCA9IGRhdGFbaV07XG4gICAgayA9IGtleSh0KTtcbiAgICBqID0ga01hcFtrXSB8fCAoa01hcFtrXSA9IGRvbWFpbi5wdXNoKGspKTtcbiAgICBnS2V5ID0gKGdWYWxzID0gZ3JvdXBieSA/IGdyb3VwYnkubWFwKGdldCkgOiBFbXB0eSkgKyAnJztcbiAgICBpZiAoIShncm91cCA9IGdNYXBbZ0tleV0pKSB7XG4gICAgICBncm91cCA9IGdNYXBbZ0tleV0gPSBbXTtcbiAgICAgIGdyb3Vwcy5wdXNoKGdyb3VwKTtcbiAgICAgIGdyb3VwLnZhbHVlcyA9IGdWYWxzO1xuICAgIH1cbiAgICBncm91cFtqIC0gMV0gPSB0O1xuICB9XG4gIGdyb3Vwcy5kb21haW4gPSBkb21haW47XG4gIHJldHVybiBncm91cHM7XG59XG5cbi8qKlxuICogRXh0ZW5kIGlucHV0IHR1cGxlcyB3aXRoIGFnZ3JlZ2F0ZSB2YWx1ZXMuXG4gKiBDYWxjdWF0ZXMgYWdncmVnYXRlIHZhbHVlcyBhbmQgam9pbnMgdGhlbSB3aXRoIHRoZSBpbnB1dCBzdHJlYW0uXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSm9pbkFnZ3JlZ2F0ZShwYXJhbXMpIHtcbiAgQWdncmVnYXRlLmNhbGwodGhpcywgcGFyYW1zKTtcbn1cbkpvaW5BZ2dyZWdhdGUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnSm9pbkFnZ3JlZ2F0ZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnbW9kaWZpZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3BzJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICd2YWx1ZXMnOiBWYWxpZEFnZ3JlZ2F0ZU9wc1xuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoSm9pbkFnZ3JlZ2F0ZSwgQWdncmVnYXRlLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGFnZ3IgPSB0aGlzLFxuICAgICAgbW9kID0gXy5tb2RpZmllZCgpO1xuICAgIGxldCBjZWxscztcblxuICAgIC8vIHByb2Nlc3MgYWxsIGlucHV0IHR1cGxlcyB0byBjYWxjdWxhdGUgYWdncmVnYXRlc1xuICAgIGlmIChhZ2dyLnZhbHVlICYmIChtb2QgfHwgcHVsc2UubW9kaWZpZWQoYWdnci5faW5wdXRzLCB0cnVlKSkpIHtcbiAgICAgIGNlbGxzID0gYWdnci52YWx1ZSA9IG1vZCA/IGFnZ3IuaW5pdChfKSA6IHt9O1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IGFnZ3IuYWRkKHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbHMgPSBhZ2dyLnZhbHVlID0gYWdnci52YWx1ZSB8fCB0aGlzLmluaXQoXyk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4gYWdnci5yZW0odCkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IGFnZ3IuYWRkKHQpKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgYWdncmVnYXRpb24gY2VsbHNcbiAgICBhZ2dyLmNoYW5nZXMoKTtcblxuICAgIC8vIHdyaXRlIGFnZ3JlZ2F0ZSB2YWx1ZXMgdG8gaW5wdXQgdHVwbGVzXG4gICAgcHVsc2UudmlzaXQocHVsc2UuU09VUkNFLCB0ID0+IHtcbiAgICAgIGV4dGVuZCh0LCBjZWxsc1thZ2dyLmNlbGxrZXkodCldLnR1cGxlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2UucmVmbG93KG1vZCkubW9kaWZpZXModGhpcy5fb3V0cHV0cyk7XG4gIH0sXG4gIGNoYW5nZXMoKSB7XG4gICAgY29uc3QgYWRkcyA9IHRoaXMuX2FkZHMsXG4gICAgICBtb2RzID0gdGhpcy5fbW9kcztcbiAgICBsZXQgaSwgbjtcbiAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5fYWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgdGhpcy5jZWxsdHVwbGUoYWRkc1tpXSk7XG4gICAgICBhZGRzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cbiAgICBmb3IgKGkgPSAwLCBuID0gdGhpcy5fbWxlbjsgaSA8IG47ICsraSkge1xuICAgICAgdGhpcy5jZWxsdHVwbGUobW9kc1tpXSk7XG4gICAgICBtb2RzW2ldID0gbnVsbDsgLy8gZm9yIGdhcmJhZ2UgY29sbGVjdGlvblxuICAgIH1cbiAgICB0aGlzLl9hbGVuID0gdGhpcy5fbWxlbiA9IDA7IC8vIHJlc2V0IGxpc3Qgb2YgYWN0aXZlIGNlbGxzXG4gIH1cbn0pO1xuXG4vKipcbiAqIENvbXB1dGUga2VybmVsIGRlbnNpdHkgZXN0aW1hdGVzIChLREUpIGZvciBvbmUgb3IgbW9yZSBkYXRhIGdyb3Vwcy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogICB0byBncm91cGJ5LlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBBbiBhY2Nlc3NvciBmb3IgdGhlIGRhdGEgZmllbGRcbiAqICAgdG8gZXN0aW1hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5iYW5kd2lkdGg9MF0gLSBUaGUgS0RFIGtlcm5lbCBiYW5kd2lkdGguXG4gKiAgIElmIHplcm8gb3IgdW5zcGVjaWZpZWQsIHRoZSBiYW5kd2lkdGggaXMgYXV0b21hdGljYWxseSBkZXRlcm1pbmVkLlxuICogQHBhcmFtIHtib29sZWFufSBbcGFyYW1zLmNvdW50cz1mYWxzZV0gLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIHRoZVxuICogICBvdXRwdXQgdmFsdWVzIHNob3VsZCBiZSBwcm9iYWJpbGl0eSBlc3RpbWF0ZXMgKGZhbHNlLCBkZWZhdWx0KSBvclxuICogICBzbW9vdGhlZCBjb3VudHMgKHRydWUpLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMuY3VtdWxhdGl2ZT1mYWxzZV0gLSBBIGJvb2xlYW4gZmxhZyBpbmRpY2F0aW5nIGlmIGFcbiAqICAgZGVuc2l0eSAoZmFsc2UpIG9yIGN1bXVsYXRpdmUgZGlzdHJpYnV0aW9uICh0cnVlKSBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLmV4dGVudF0gLSBUaGUgZG9tYWluIGV4dGVudCBvdmVyIHdoaWNoIHRvXG4gKiAgIHBsb3QgdGhlIGRlbnNpdHkuIElmIHVuc3BlY2lmaWVkLCB0aGUgW21pbiwgbWF4XSBkYXRhIGV4dGVudCBpcyB1c2VkLlxuICogQHBhcmFtIHtzdHJpbmd9IFtwYXJhbXMucmVzb2x2ZT0naW5kZXBlbmRlbnQnXSAtIEluZGljYXRlcyBob3cgcGFyYW1ldGVycyBmb3JcbiAqICAgbXVsdGlwbGUgZGVuc2l0aWVzIHNob3VsZCBiZSByZXNvbHZlZC4gSWYgXCJpbmRlcGVuZGVudFwiICh0aGUgZGVmYXVsdCksIGVhY2hcbiAqICAgZGVuc2l0eSBtYXkgaGF2ZSBpdHMgb3duIGRvbWFpbiBleHRlbnQgYW5kIGR5bmFtaWMgbnVtYmVyIG9mIGN1cnZlIHNhbXBsZVxuICogICBzdGVwcy4gSWYgXCJzaGFyZWRcIiwgdGhlIEtERSB0cmFuc2Zvcm0gd2lsbCBlbnN1cmUgdGhhdCBhbGwgZGVuc2l0aWVzIGFyZVxuICogICBkZWZpbmVkIG92ZXIgYSBzaGFyZWQgZG9tYWluIGFuZCBjdXJ2ZSBzdGVwcywgZW5hYmxpbmcgc3RhY2tpbmcuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5taW5zdGVwcz0yNV0gLSBUaGUgbWluaW11bSBudW1iZXIgb2YgY3VydmUgc2FtcGxlc1xuICogICBmb3IgcGxvdHRpbmcgdGhlIGRlbnNpdHkuXG4gKiBAcGFyYW0ge251bWJlcn0gW3BhcmFtcy5tYXhzdGVwcz0yMDBdIC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGN1cnZlIHNhbXBsZXNcbiAqICAgZm9yIHBsb3R0aW5nIHRoZSBkZW5zaXR5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuc3RlcHNdIC0gVGhlIGV4YWN0IG51bWJlciBvZiBjdXJ2ZSBzYW1wbGVzIGZvclxuICogICBwbG90dGluZyB0aGUgZGVuc2l0eS4gSWYgc3BlY2lmaWVkLCBvdmVycmlkZXMgYm90aCBtaW5zdGVwcyBhbmQgbWF4c3RlcHNcbiAqICAgdG8gc2V0IGFuIGV4YWN0IG51bWJlciBvZiB1bmlmb3JtIHNhbXBsZXMuIFVzZWZ1bCBpbiBjb25qdW5jdGlvbiB3aXRoXG4gKiAgIGEgZml4ZWQgZXh0ZW50IHRvIGVuc3VyZSBjb25zaXN0ZW50IHNhbXBsZSBwb2ludHMgZm9yIHN0YWNrZWQgZGVuc2l0aWVzLlxuICovXG5mdW5jdGlvbiBLREUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5LREUuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnS0RFJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdnZW5lcmF0ZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2N1bXVsYXRpdmUnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfSwge1xuICAgICduYW1lJzogJ2NvdW50cycsXG4gICAgJ3R5cGUnOiAnYm9vbGVhbicsXG4gICAgJ2RlZmF1bHQnOiBmYWxzZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYmFuZHdpZHRoJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZXh0ZW50JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ3Jlc29sdmUnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBbJ3NoYXJlZCcsICdpbmRlcGVuZGVudCddLFxuICAgICdkZWZhdWx0JzogJ2luZGVwZW5kZW50J1xuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcHMnLFxuICAgICd0eXBlJzogJ251bWJlcidcbiAgfSwge1xuICAgICduYW1lJzogJ21pbnN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjVcbiAgfSwge1xuICAgICduYW1lJzogJ21heHN0ZXBzJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMjAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdkZWZhdWx0JzogWyd2YWx1ZScsICdkZW5zaXR5J11cbiAgfV1cbn07XG5pbmhlcml0cyhLREUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7XG4gICAgaWYgKCF0aGlzLnZhbHVlIHx8IHB1bHNlLmNoYW5nZWQoKSB8fCBfLm1vZGlmaWVkKCkpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgICBncm91cHMgPSBwYXJ0aXRpb24kMShzb3VyY2UsIF8uZ3JvdXBieSwgXy5maWVsZCksXG4gICAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICAgIGJhbmR3aWR0aCA9IF8uYmFuZHdpZHRoLFxuICAgICAgICBtZXRob2QgPSBfLmN1bXVsYXRpdmUgPyAnY2RmJyA6ICdwZGYnLFxuICAgICAgICBhcyA9IF8uYXMgfHwgWyd2YWx1ZScsICdkZW5zaXR5J10sXG4gICAgICAgIHZhbHVlcyA9IFtdO1xuICAgICAgbGV0IGRvbWFpbiA9IF8uZXh0ZW50LFxuICAgICAgICBtaW5zdGVwcyA9IF8uc3RlcHMgfHwgXy5taW5zdGVwcyB8fCAyNSxcbiAgICAgICAgbWF4c3RlcHMgPSBfLnN0ZXBzIHx8IF8ubWF4c3RlcHMgfHwgMjAwO1xuICAgICAgaWYgKG1ldGhvZCAhPT0gJ3BkZicgJiYgbWV0aG9kICE9PSAnY2RmJykge1xuICAgICAgICBlcnJvcignSW52YWxpZCBkZW5zaXR5IG1ldGhvZDogJyArIG1ldGhvZCk7XG4gICAgICB9XG4gICAgICBpZiAoXy5yZXNvbHZlID09PSAnc2hhcmVkJykge1xuICAgICAgICBpZiAoIWRvbWFpbikgZG9tYWluID0gZXh0ZW50KHNvdXJjZSwgXy5maWVsZCk7XG4gICAgICAgIG1pbnN0ZXBzID0gbWF4c3RlcHMgPSBfLnN0ZXBzIHx8IG1heHN0ZXBzO1xuICAgICAgfVxuICAgICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICAgIGNvbnN0IGRlbnNpdHkgPSByYW5kb21LREUoZywgYmFuZHdpZHRoKVttZXRob2RdLFxuICAgICAgICAgIHNjYWxlID0gXy5jb3VudHMgPyBnLmxlbmd0aCA6IDEsXG4gICAgICAgICAgbG9jYWwgPSBkb21haW4gfHwgZXh0ZW50KGcpO1xuICAgICAgICBzYW1wbGVDdXJ2ZShkZW5zaXR5LCBsb2NhbCwgbWluc3RlcHMsIG1heHN0ZXBzKS5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICB0W25hbWVzW2ldXSA9IGcuZGltc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdFthc1swXV0gPSB2WzBdO1xuICAgICAgICAgIHRbYXNbMV1dID0gdlsxXSAqIHNjYWxlO1xuICAgICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy52YWx1ZSkgb3V0LnJlbSA9IHRoaXMudmFsdWU7XG4gICAgICB0aGlzLnZhbHVlID0gb3V0LmFkZCA9IG91dC5zb3VyY2UgPSB2YWx1ZXM7XG4gICAgfVxuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGtleSBmdW5jdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwYXJhbXMuZmllbGRzIC0gVGhlIGZpZWxkIG5hbWUocykgZm9yIHRoZSBrZXkgZnVuY3Rpb24uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHBhcmFtcy5mbGF0IC0gQSBib29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZiB0aGUgZmllbGQgbmFtZXNcbiAqICBzaG91bGQgYmUgdHJlYXRlZCBhcyBmbGF0IHByb3BlcnR5IG5hbWVzLCBzaWRlLXN0ZXBwaW5nIG5lc3RlZCBmaWVsZFxuICogIGxvb2t1cHMgbm9ybWFsbHkgaW5kaWNhdGVkIGJ5IGRvdCBvciBicmFja2V0IG5vdGF0aW9uLlxuICovXG5mdW5jdGlvbiBLZXkocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlJDIsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhLZXksIE9wZXJhdG9yKTtcbmZ1bmN0aW9uIHVwZGF0ZSQyKF8pIHtcbiAgcmV0dXJuIHRoaXMudmFsdWUgJiYgIV8ubW9kaWZpZWQoKSA/IHRoaXMudmFsdWUgOiBrZXkoXy5maWVsZHMsIF8uZmxhdCk7XG59XG5cbi8qKlxuICogTG9hZCBhbmQgcGFyc2UgZGF0YSBmcm9tIGFuIGV4dGVybmFsIHNvdXJjZS4gTWFyc2hhbGxzIHBhcmFtZXRlclxuICogdmFsdWVzIGFuZCB0aGVuIGludm9rZXMgdGhlIERhdGFmbG93IHJlcXVlc3QgbWV0aG9kLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLnVybCAtIFRoZSBVUkwgdG8gbG9hZCBmcm9tLlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcy5mb3JtYXQgLSBUaGUgZGF0YSBmb3JtYXQgb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gTG9hZChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgW10sIHBhcmFtcyk7XG4gIHRoaXMuX3BlbmRpbmcgPSBudWxsO1xufVxuaW5oZXJpdHMoTG9hZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3c7XG4gICAgaWYgKHRoaXMuX3BlbmRpbmcpIHtcbiAgICAgIC8vIHVwZGF0ZSBzdGF0ZSBhbmQgcmV0dXJuIHB1bHNlXG4gICAgICByZXR1cm4gb3V0cHV0KHRoaXMsIHB1bHNlLCB0aGlzLl9wZW5kaW5nKTtcbiAgICB9XG4gICAgaWYgKHN0b3AoXykpIHJldHVybiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gICAgaWYgKF8udmFsdWVzKSB7XG4gICAgICAvLyBwYXJzZSBhbmQgaW5nZXN0IHZhbHVlcywgcmV0dXJuIG91dHB1dCBwdWxzZVxuICAgICAgcmV0dXJuIG91dHB1dCh0aGlzLCBwdWxzZSwgZGYucGFyc2UoXy52YWx1ZXMsIF8uZm9ybWF0KSk7XG4gICAgfSBlbHNlIGlmIChfLmFzeW5jKSB7XG4gICAgICAvLyByZXR1cm4gcHJvbWlzZSBmb3Igbm9uLWJsb2NraW5nIGFzeW5jIGxvYWRpbmdcbiAgICAgIGNvbnN0IHAgPSBkZi5yZXF1ZXN0KF8udXJsLCBfLmZvcm1hdCkudGhlbihyZXMgPT4ge1xuICAgICAgICB0aGlzLl9wZW5kaW5nID0gYXJyYXkocmVzLmRhdGEpO1xuICAgICAgICByZXR1cm4gZGYgPT4gZGYudG91Y2godGhpcyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGFzeW5jOiBwXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gcHJvbWlzZSBmb3Igc3luY2hyb25vdXMgbG9hZGluZ1xuICAgICAgcmV0dXJuIGRmLnJlcXVlc3QoXy51cmwsIF8uZm9ybWF0KS50aGVuKHJlcyA9PiBvdXRwdXQodGhpcywgcHVsc2UsIGFycmF5KHJlcy5kYXRhKSkpO1xuICAgIH1cbiAgfVxufSk7XG5mdW5jdGlvbiBzdG9wKF8pIHtcbiAgcmV0dXJuIF8ubW9kaWZpZWQoJ2FzeW5jJykgJiYgIShfLm1vZGlmaWVkKCd2YWx1ZXMnKSB8fCBfLm1vZGlmaWVkKCd1cmwnKSB8fCBfLm1vZGlmaWVkKCdmb3JtYXQnKSk7XG59XG5mdW5jdGlvbiBvdXRwdXQob3AsIHB1bHNlLCBkYXRhKSB7XG4gIGRhdGEuZm9yRWFjaChpbmdlc3QpO1xuICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX0ZJRUxEUyAmIHB1bHNlLk5PX1NPVVJDRSk7XG4gIG91dC5yZW0gPSBvcC52YWx1ZTtcbiAgb3AudmFsdWUgPSBvdXQuc291cmNlID0gb3V0LmFkZCA9IGRhdGE7XG4gIG9wLl9wZW5kaW5nID0gbnVsbDtcbiAgaWYgKG91dC5yZW0ubGVuZ3RoKSBvdXQuY2xlYW4odHJ1ZSk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRXh0ZW5kIHR1cGxlcyBieSBqb2luaW5nIHRoZW0gd2l0aCB2YWx1ZXMgZnJvbSBhIGxvb2t1cCB0YWJsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtNYXB9IHBhcmFtcy5pbmRleCAtIFRoZSBsb29rdXAgdGFibGUgbWFwLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGRzIC0gVGhlIGZpZWxkcyB0byBsb29rdXAuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHBhcmFtcy5hcyAtIE91dHB1dCBmaWVsZCBuYW1lcyBmb3IgZWFjaCBsb29rdXAgdmFsdWUuXG4gKiBAcGFyYW0geyp9IFtwYXJhbXMuZGVmYXVsdF0gLSBBIGRlZmF1bHQgdmFsdWUgdG8gdXNlIGlmIGxvb2t1cCBmYWlscy5cbiAqL1xuZnVuY3Rpb24gTG9va3VwKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCB7fSwgcGFyYW1zKTtcbn1cbkxvb2t1cC5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdMb29rdXAnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdpbmRleCcsXG4gICAgJ3R5cGUnOiAnaW5kZXgnLFxuICAgICdwYXJhbXMnOiBbe1xuICAgICAgJ25hbWUnOiAnZnJvbScsXG4gICAgICAndHlwZSc6ICdkYXRhJyxcbiAgICAgICdyZXF1aXJlZCc6IHRydWVcbiAgICB9LCB7XG4gICAgICAnbmFtZSc6ICdrZXknLFxuICAgICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICAgIH1dXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd2YWx1ZXMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZHMnLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2RlZmF1bHQnLFxuICAgICdkZWZhdWx0JzogbnVsbFxuICB9XVxufTtcbmluaGVyaXRzKExvb2t1cCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGtleXMgPSBfLmZpZWxkcyxcbiAgICAgIGluZGV4ID0gXy5pbmRleCxcbiAgICAgIHZhbHVlcyA9IF8udmFsdWVzLFxuICAgICAgZGVmYXVsdFZhbHVlID0gXy5kZWZhdWx0ID09IG51bGwgPyBudWxsIDogXy5kZWZhdWx0LFxuICAgICAgcmVzZXQgPSBfLm1vZGlmaWVkKCksXG4gICAgICBuID0ga2V5cy5sZW5ndGg7XG4gICAgbGV0IGZsYWcgPSByZXNldCA/IHB1bHNlLlNPVVJDRSA6IHB1bHNlLkFERCxcbiAgICAgIG91dCA9IHB1bHNlLFxuICAgICAgYXMgPSBfLmFzLFxuICAgICAgc2V0LFxuICAgICAgbSxcbiAgICAgIG1vZHM7XG4gICAgaWYgKHZhbHVlcykge1xuICAgICAgbSA9IHZhbHVlcy5sZW5ndGg7XG4gICAgICBpZiAobiA+IDEgJiYgIWFzKSB7XG4gICAgICAgIGVycm9yKCdNdWx0aS1maWVsZCBsb29rdXAgcmVxdWlyZXMgZXhwbGljaXQgXCJhc1wiIHBhcmFtZXRlci4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChhcyAmJiBhcy5sZW5ndGggIT09IG4gKiBtKSB7XG4gICAgICAgIGVycm9yKCdUaGUgXCJhc1wiIHBhcmFtZXRlciBoYXMgdG9vIGZldyBvdXRwdXQgZmllbGQgbmFtZXMuJyk7XG4gICAgICB9XG4gICAgICBhcyA9IGFzIHx8IHZhbHVlcy5tYXAoYWNjZXNzb3JOYW1lKTtcbiAgICAgIHNldCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBrID0gMCwgaiwgdjsgaSA8IG47ICsraSkge1xuICAgICAgICAgIHYgPSBpbmRleC5nZXQoa2V5c1tpXSh0KSk7XG4gICAgICAgICAgaWYgKHYgPT0gbnVsbCkgZm9yIChqID0gMDsgaiA8IG07ICsraiwgKytrKSB0W2FzW2tdXSA9IGRlZmF1bHRWYWx1ZTtlbHNlIGZvciAoaiA9IDA7IGogPCBtOyArK2osICsraykgdFthc1trXV0gPSB2YWx1ZXNbal0odik7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghYXMpIHtcbiAgICAgICAgZXJyb3IoJ01pc3Npbmcgb3V0cHV0IGZpZWxkIG5hbWVzLicpO1xuICAgICAgfVxuICAgICAgc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHY7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgICB2ID0gaW5kZXguZ2V0KGtleXNbaV0odCkpO1xuICAgICAgICAgIHRbYXNbaV1dID0gdiA9PSBudWxsID8gZGVmYXVsdFZhbHVlIDogdjtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHJlc2V0KSB7XG4gICAgICBvdXQgPSBwdWxzZS5yZWZsb3codHJ1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1vZHMgPSBrZXlzLnNvbWUoayA9PiBwdWxzZS5tb2RpZmllZChrLmZpZWxkcykpO1xuICAgICAgZmxhZyB8PSBtb2RzID8gcHVsc2UuTU9EIDogMDtcbiAgICB9XG4gICAgcHVsc2UudmlzaXQoZmxhZywgc2V0KTtcbiAgICByZXR1cm4gb3V0Lm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbi8qKlxuICogQ29tcHV0ZXMgZ2xvYmFsIG1pbi9tYXggZXh0ZW50cyBvdmVyIGEgY29sbGVjdGlvbiBvZiBleHRlbnRzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBwYXJhbXMuZXh0ZW50cyAtIFRoZSBpbnB1dCBleHRlbnRzLlxuICovXG5mdW5jdGlvbiBNdWx0aUV4dGVudChwYXJhbXMpIHtcbiAgT3BlcmF0b3IuY2FsbCh0aGlzLCBudWxsLCB1cGRhdGUkMSwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKE11bHRpRXh0ZW50LCBPcGVyYXRvcik7XG5mdW5jdGlvbiB1cGRhdGUkMShfKSB7XG4gIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbiAgfVxuICBjb25zdCBleHQgPSBfLmV4dGVudHMsXG4gICAgbiA9IGV4dC5sZW5ndGg7XG4gIGxldCBtaW4gPSArSW5maW5pdHksXG4gICAgbWF4ID0gLUluZmluaXR5LFxuICAgIGksXG4gICAgZTtcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGUgPSBleHRbaV07XG4gICAgaWYgKGVbMF0gPCBtaW4pIG1pbiA9IGVbMF07XG4gICAgaWYgKGVbMV0gPiBtYXgpIG1heCA9IGVbMV07XG4gIH1cbiAgcmV0dXJuIFttaW4sIG1heF07XG59XG5cbi8qKlxuICogTWVyZ2UgYSBjb2xsZWN0aW9uIG9mIHZhbHVlIGFycmF5cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtBcnJheTxBcnJheTwqPj59IHBhcmFtcy52YWx1ZXMgLSBUaGUgaW5wdXQgdmFsdWUgYXJycmF5cy5cbiAqL1xuZnVuY3Rpb24gTXVsdGlWYWx1ZXMocGFyYW1zKSB7XG4gIE9wZXJhdG9yLmNhbGwodGhpcywgbnVsbCwgdXBkYXRlLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoTXVsdGlWYWx1ZXMsIE9wZXJhdG9yKTtcbmZ1bmN0aW9uIHVwZGF0ZShfKSB7XG4gIHJldHVybiB0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkgPyB0aGlzLnZhbHVlIDogXy52YWx1ZXMucmVkdWNlKChkYXRhLCBfKSA9PiBkYXRhLmNvbmNhdChfKSwgW10pO1xufVxuXG4vKipcbiAqIE9wZXJhdG9yIHdob3NlIHZhbHVlIGlzIHNpbXBseSBpdHMgcGFyYW1ldGVyIGhhc2guIFRoaXMgb3BlcmF0b3IgaXNcbiAqIHVzZWZ1bCBmb3IgZW5hYmxpbmcgcmVhY3RpdmUgdXBkYXRlcyB0byB2YWx1ZXMgb2YgbmVzdGVkIG9iamVjdHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqL1xuZnVuY3Rpb24gUGFyYW1zKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUGFyYW1zLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgdGhpcy5tb2RpZmllZChfLm1vZGlmaWVkKCkpO1xuICAgIHRoaXMudmFsdWUgPSBfO1xuICAgIHJldHVybiBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUyk7IC8vIGRvIG5vdCBwYXNzIHR1cGxlc1xuICB9XG59KTtcblxuLyoqXG4gKiBBZ2dyZWdhdGUgYW5kIHBpdm90IHNlbGVjdGVkIGZpZWxkIHZhbHVlcyB0byBiZWNvbWUgbmV3IGZpZWxkcy5cbiAqIFRoaXMgb3BlcmF0b3IgaXMgdXNlZnVsIHRvIGNvbnN0cnVjdGlvbiBjcm9zcy10YWJ1bGF0aW9ucy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogIHRvIGdyb3VwYnkuIFRoZXNlIGZpZWxkcyBhY3QganVzdCBsaWtlIGdyb3VwYnkgZmllbGRzIG9mIGFuIEFnZ3JlZ2F0ZSB0cmFuc2Zvcm0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZCB0byBwaXZvdCBvbi4gVGhlIHVuaXF1ZVxuICogIHZhbHVlcyBvZiB0aGlzIGZpZWxkIGJlY29tZSBuZXcgZmllbGQgbmFtZXMgaW4gdGhlIG91dHB1dCBzdHJlYW0uXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy52YWx1ZSAtIFRoZSBmaWVsZCB0byBwb3B1bGF0ZSBwaXZvdGVkIGZpZWxkcy5cbiAqICBUaGUgYWdncmVnYXRlIHZhbHVlcyBvZiB0aGlzIGZpZWxkIGJlY29tZSB0aGUgdmFsdWVzIG9mIHRoZSBuZXcgcGl2b3RlZCBmaWVsZHMuXG4gKiBAcGFyYW0ge3N0cmluZ30gW3BhcmFtcy5vcF0gLSBUaGUgYWdncmVnYXRpb24gb3BlcmF0aW9uIGZvciB0aGUgdmFsdWUgZmllbGQsXG4gKiAgYXBwbGllZCBwZXIgY2VsbCBpbiB0aGUgb3V0cHV0IHN0cmVhbS4gVGhlIGRlZmF1bHQgaXMgXCJzdW1cIi5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmxpbWl0XSAtIEFuIG9wdGlvbmFsIHBhcmFtZXRlciBpbmRpY2F0aW5nIHRoZSBtYXhpbXVtXG4gKiAgbnVtYmVyIG9mIHBpdm90ZWQgZmllbGRzIHRvIGdlbmVyYXRlLiBUaGUgcGl2b3RlZCBmaWVsZCBuYW1lcyBhcmUgc29ydGVkIGluXG4gKiAgYXNjZW5kaW5nIG9yZGVyIHByaW9yIHRvIGVuZm9yY2luZyB0aGUgbGltaXQuXG4gKi9cbmZ1bmN0aW9uIFBpdm90KHBhcmFtcykge1xuICBBZ2dyZWdhdGUuY2FsbCh0aGlzLCBwYXJhbXMpO1xufVxuUGl2b3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUGl2b3QnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3ZhbHVlJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnb3AnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICd2YWx1ZXMnOiBWYWxpZEFnZ3JlZ2F0ZU9wcyxcbiAgICAnZGVmYXVsdCc6ICdzdW0nXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdsaW1pdCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDBcbiAgfSwge1xuICAgICduYW1lJzogJ2tleScsXG4gICAgJ3R5cGUnOiAnZmllbGQnXG4gIH1dXG59O1xuaW5oZXJpdHMoUGl2b3QsIEFnZ3JlZ2F0ZSwge1xuICBfdHJhbnNmb3JtOiBBZ2dyZWdhdGUucHJvdG90eXBlLnRyYW5zZm9ybSxcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zZm9ybShhZ2dyZWdhdGVQYXJhbXMoXywgcHVsc2UpLCBwdWxzZSk7XG4gIH1cbn0pO1xuXG4vLyBTaG9laG9ybiBhIHBpdm90IHRyYW5zZm9ybSBpbnRvIGFuIGFnZ3JlZ2F0ZSB0cmFuc2Zvcm0hXG4vLyBGaXJzdCBjb2xsZWN0IGFsbCB1bmlxdWUgcGl2b3QgZmllbGQgdmFsdWVzLlxuLy8gVGhlbiBnZW5lcmF0ZSBhZ2dyZWdhdGUgZmllbGRzIGZvciBlYWNoIG91dHB1dCBwaXZvdCBmaWVsZC5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZVBhcmFtcyhfLCBwdWxzZSkge1xuICBjb25zdCBrZXkgPSBfLmZpZWxkLFxuICAgIHZhbHVlID0gXy52YWx1ZSxcbiAgICBvcCA9IChfLm9wID09PSAnY291bnQnID8gJ19fY291bnRfXycgOiBfLm9wKSB8fCAnc3VtJyxcbiAgICBmaWVsZHMgPSBhY2Nlc3NvckZpZWxkcyhrZXkpLmNvbmNhdChhY2Nlc3NvckZpZWxkcyh2YWx1ZSkpLFxuICAgIGtleXMgPSBwaXZvdEtleXMoa2V5LCBfLmxpbWl0IHx8IDAsIHB1bHNlKTtcblxuICAvLyBpZiBkYXRhIHN0cmVhbSBjb250ZW50IGNoYW5nZXMsIHBpdm90IGZpZWxkcyBtYXkgY2hhbmdlXG4gIC8vIGZsYWcgcGFyYW1ldGVyIG1vZGlmaWNhdGlvbiB0byBlbnN1cmUgcmUtaW5pdGlhbGl6YXRpb25cbiAgaWYgKHB1bHNlLmNoYW5nZWQoKSkgXy5zZXQoJ19fcGl2b3RfXycsIG51bGwsIG51bGwsIHRydWUpO1xuICByZXR1cm4ge1xuICAgIGtleTogXy5rZXksXG4gICAgZ3JvdXBieTogXy5ncm91cGJ5LFxuICAgIG9wczoga2V5cy5tYXAoKCkgPT4gb3ApLFxuICAgIGZpZWxkczoga2V5cy5tYXAoayA9PiBnZXQoaywga2V5LCB2YWx1ZSwgZmllbGRzKSksXG4gICAgYXM6IGtleXMubWFwKGsgPT4gayArICcnKSxcbiAgICBtb2RpZmllZDogXy5tb2RpZmllZC5iaW5kKF8pXG4gIH07XG59XG5cbi8vIEdlbmVyYXRlIGFnZ3JlZ2F0ZSBmaWVsZCBhY2Nlc3Nvci5cbi8vIE91dHB1dCBOYU4gZm9yIG5vbi1leGlzdGVudCB2YWx1ZXM7IGFnZ3JlZ2F0b3Igd2lsbCBpZ25vcmUhXG5mdW5jdGlvbiBnZXQoaywga2V5LCB2YWx1ZSwgZmllbGRzKSB7XG4gIHJldHVybiBhY2Nlc3NvcihkID0+IGtleShkKSA9PT0gayA/IHZhbHVlKGQpIDogTmFOLCBmaWVsZHMsIGsgKyAnJyk7XG59XG5cbi8vIENvbGxlY3QgKGFuZCBvcHRpb25hbGx5IGxpbWl0KSBhbGwgdW5pcXVlIHBpdm90IHZhbHVlcy5cbmZ1bmN0aW9uIHBpdm90S2V5cyhrZXksIGxpbWl0LCBwdWxzZSkge1xuICBjb25zdCBtYXAgPSB7fSxcbiAgICBsaXN0ID0gW107XG4gIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiB7XG4gICAgY29uc3QgayA9IGtleSh0KTtcbiAgICBpZiAoIW1hcFtrXSkge1xuICAgICAgbWFwW2tdID0gMTtcbiAgICAgIGxpc3QucHVzaChrKTtcbiAgICB9XG4gIH0pO1xuICBsaXN0LnNvcnQoYXNjZW5kaW5nKTtcbiAgcmV0dXJuIGxpbWl0ID8gbGlzdC5zbGljZSgwLCBsaW1pdCkgOiBsaXN0O1xufVxuXG4vKipcbiAqIFBhcnRpdGlvbnMgcHJlLWZhY2V0ZWQgZGF0YSBpbnRvIHR1cGxlIHN1YmZsb3dzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKERhdGFmbG93LCBzdHJpbmcpOiBPcGVyYXRvcn0gcGFyYW1zLnN1YmZsb3cgLSBBIGZ1bmN0aW9uXG4gKiAgIHRoYXQgZ2VuZXJhdGVzIGEgc3ViZmxvdyBvZiBvcGVyYXRvcnMgYW5kIHJldHVybnMgaXRzIHJvb3Qgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6IEFycmF5PG9iamVjdD59IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZFxuICogICBhY2Nlc3NvciBmb3IgYW4gYXJyYXkgb2Ygc3ViZmxvdyB0dXBsZSBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBQcmVGYWNldChwYXJhbXMpIHtcbiAgRmFjZXQuY2FsbCh0aGlzLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUHJlRmFjZXQsIEZhY2V0LCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZsb3cgPSBfLnN1YmZsb3csXG4gICAgICBmaWVsZCA9IF8uZmllbGQsXG4gICAgICBzdWJmbG93ID0gdCA9PiB0aGlzLnN1YmZsb3codHVwbGVpZCh0KSwgZmxvdywgcHVsc2UsIHQpO1xuICAgIGlmIChfLm1vZGlmaWVkKCdmaWVsZCcpIHx8IGZpZWxkICYmIHB1bHNlLm1vZGlmaWVkKGFjY2Vzc29yRmllbGRzKGZpZWxkKSkpIHtcbiAgICAgIGVycm9yKCdQcmVGYWNldCBkb2VzIG5vdCBzdXBwb3J0IGZpZWxkIG1vZGlmaWNhdGlvbi4nKTtcbiAgICB9XG4gICAgdGhpcy5pbml0VGFyZ2V0cygpOyAvLyByZXNldCBsaXN0IG9mIGFjdGl2ZSBzdWJmbG93c1xuXG4gICAgaWYgKGZpZWxkKSB7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgICBjb25zdCBzZiA9IHN1YmZsb3codCk7XG4gICAgICAgIGZpZWxkKHQpLmZvckVhY2goXyA9PiBzZi5tb2QoXykpO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4ge1xuICAgICAgICBjb25zdCBzZiA9IHN1YmZsb3codCk7XG4gICAgICAgIGZpZWxkKHQpLmZvckVhY2goXyA9PiBzZi5hZGQoaW5nZXN0KF8pKSk7XG4gICAgICB9KTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICAgIGNvbnN0IHNmID0gc3ViZmxvdyh0KTtcbiAgICAgICAgZmllbGQodCkuZm9yRWFjaChfID0+IHNmLnJlbShfKSk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHN1YmZsb3codCkubW9kKHQpKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiBzdWJmbG93KHQpLmFkZCh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4gc3ViZmxvdyh0KS5yZW0odCkpO1xuICAgIH1cbiAgICBpZiAocHVsc2UuY2xlYW4oKSkge1xuICAgICAgcHVsc2UucnVuQWZ0ZXIoKCkgPT4gdGhpcy5jbGVhbigpKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG59KTtcblxuLyoqXG4gKiBQZXJmb3JtcyBhIHJlbGF0aW9uYWwgcHJvamVjdGlvbiwgY29weWluZyBzZWxlY3RlZCBmaWVsZHMgZnJvbSBzb3VyY2VcbiAqIHR1cGxlcyB0byBhIG5ldyBzZXQgb2YgZGVyaXZlZCB0dXBsZXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7QXJyYXk8ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkcyAtIFRoZSBmaWVsZHMgdG8gcHJvamVjdCxcbiAqICAgYXMgYW4gYXJyYXkgb2YgZmllbGQgYWNjZXNzb3JzLiBJZiB1bnNwZWNpZmllZCwgYWxsIGZpZWxkcyB3aWxsIGJlXG4gKiAgIGNvcGllZCB3aXRoIG5hbWVzIHVuY2hhbmdlZC5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW3BhcmFtcy5hc10gLSBPdXRwdXQgZmllbGQgbmFtZXMgZm9yIGVhY2ggcHJvamVjdGVkXG4gKiAgIGZpZWxkLiBBbnkgdW5zcGVjaWZpZWQgZmllbGRzIHdpbGwgdXNlIHRoZSBmaWVsZCBuYW1lIHByb3ZpZGVkIGJ5XG4gKiAgIHRoZSBmaWVsZCBhY2Nlc3Nvci5cbiAqL1xuZnVuY3Rpb24gUHJvamVjdChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cblByb2plY3QuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnUHJvamVjdCcsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfV1cbn07XG5pbmhlcml0cyhQcm9qZWN0LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UpLFxuICAgICAgZmllbGRzID0gXy5maWVsZHMsXG4gICAgICBhcyA9IGZpZWxkTmFtZXMoXy5maWVsZHMsIF8uYXMgfHwgW10pLFxuICAgICAgZGVyaXZlID0gZmllbGRzID8gKHMsIHQpID0+IHByb2plY3QocywgdCwgZmllbGRzLCBhcykgOiByZWRlcml2ZTtcbiAgICBsZXQgbHV0O1xuICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgbHV0ID0gdGhpcy52YWx1ZSA9IHt9O1xuICAgIH1cbiAgICBwdWxzZS52aXNpdChwdWxzZS5SRU0sIHQgPT4ge1xuICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpO1xuICAgICAgb3V0LnJlbS5wdXNoKGx1dFtpZF0pO1xuICAgICAgbHV0W2lkXSA9IG51bGw7XG4gICAgfSk7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgIGNvbnN0IGR0ID0gZGVyaXZlKHQsIGluZ2VzdCh7fSkpO1xuICAgICAgbHV0W3R1cGxlaWQodCldID0gZHQ7XG4gICAgICBvdXQuYWRkLnB1c2goZHQpO1xuICAgIH0pO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLk1PRCwgdCA9PiB7XG4gICAgICBvdXQubW9kLnB1c2goZGVyaXZlKHQsIGx1dFt0dXBsZWlkKHQpXSkpO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcHJvamVjdChzLCB0LCBmaWVsZHMsIGFzKSB7XG4gIGZvciAobGV0IGkgPSAwLCBuID0gZmllbGRzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgIHRbYXNbaV1dID0gZmllbGRzW2ldKHMpO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG4vKipcbiAqIFByb3h5IHRoZSB2YWx1ZSBvZiBhbm90aGVyIG9wZXJhdG9yIGFzIGEgcHVyZSBzaWduYWwgdmFsdWUuXG4gKiBFbnN1cmVzIG5vIHR1cGxlcyBhcmUgcHJvcGFnYXRlZC5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHsqfSBwYXJhbXMudmFsdWUgLSBUaGUgdmFsdWUgdG8gcHJveHksIGJlY29tZXMgdGhlIHZhbHVlIG9mIHRoaXMgb3BlcmF0b3IuXG4gKi9cbmZ1bmN0aW9uIFByb3h5KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoUHJveHksIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlID0gXy52YWx1ZTtcbiAgICByZXR1cm4gXy5tb2RpZmllZCgndmFsdWUnKSA/IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFIHwgcHVsc2UuTk9fRklFTERTKSA6IHB1bHNlLlN0b3BQcm9wYWdhdGlvbjtcbiAgfVxufSk7XG5cbi8qKlxuICogR2VuZXJhdGVzIHNhbXBsZSBxdWFudGlsZSB2YWx1ZXMgZnJvbSBhbiBpbnB1dCBkYXRhIHN0cmVhbS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBBbiBhY2Nlc3NvciBmb3IgdGhlIGRhdGEgZmllbGRcbiAqICAgb3ZlciB3aGljaCB0byBjYWxjdWxhdGUgcXVhbnRpbGUgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxmdW5jdGlvbihvYmplY3QpOiAqPn0gW3BhcmFtcy5ncm91cGJ5XSAtIEFuIGFycmF5IG9mIGFjY2Vzc29yc1xuICogICB0byBncm91cGJ5LlxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbcGFyYW1zLnByb2JzXSAtIEFuIGFycmF5IG9mIHByb2JhYmlsaXRpZXMgaW5cbiAqICAgdGhlIHJhbmdlICgwLCAxKSBmb3Igd2hpY2ggdG8gY29tcHV0ZSBxdWFudGlsZSB2YWx1ZXMuIElmIG5vdCBzcGVjaWZpZWQsXG4gKiAgIHRoZSAqc3RlcCogcGFyYW1ldGVyIHdpbGwgYmUgdXNlZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5zdGVwPTAuMDFdIC0gQSBwcm9iYWJpbGl0eSBzdGVwIHNpemUgZm9yXG4gKiAgIHNhbXBsaW5nIHF1YW50aWxlIHZhbHVlcy4gQWxsIHZhbHVlcyBmcm9tIG9uZS1oYWxmIHRoZSBzdGVwIHNpemUgdXAgdG9cbiAqICAgMSAoZXhjbHVzaXZlKSB3aWxsIGJlIHNhbXBsZWQuIFRoaXMgcGFyYW1ldGVyIGlzIG9ubHkgdXNlZCBpZiB0aGVcbiAqICAgKnF1YW50aWxlcyogcGFyYW1ldGVyIGlzIG5vdCBwcm92aWRlZC5cbiAqL1xuZnVuY3Rpb24gUXVhbnRpbGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5RdWFudGlsZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdRdWFudGlsZScsXG4gICdtZXRhZGF0YSc6IHtcbiAgICAnZ2VuZXJhdGVzJzogdHJ1ZSxcbiAgICAnY2hhbmdlcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnZ3JvdXBieScsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ZpZWxkJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAncHJvYnMnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDAuMDFcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiBbJ3Byb2InLCAndmFsdWUnXVxuICB9XVxufTtcbmNvbnN0IEVQU0lMT04gPSAxZS0xNDtcbmluaGVyaXRzKFF1YW50aWxlLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UuZm9yayhwdWxzZS5OT19TT1VSQ0UgfCBwdWxzZS5OT19GSUVMRFMpLFxuICAgICAgYXMgPSBfLmFzIHx8IFsncHJvYicsICd2YWx1ZSddO1xuICAgIGlmICh0aGlzLnZhbHVlICYmICFfLm1vZGlmaWVkKCkgJiYgIXB1bHNlLmNoYW5nZWQoKSkge1xuICAgICAgb3V0LnNvdXJjZSA9IHRoaXMudmFsdWU7XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBwdWxzZS5tYXRlcmlhbGl6ZShwdWxzZS5TT1VSQ0UpLnNvdXJjZSxcbiAgICAgIGdyb3VwcyA9IHBhcnRpdGlvbiQxKHNvdXJjZSwgXy5ncm91cGJ5LCBfLmZpZWxkKSxcbiAgICAgIG5hbWVzID0gKF8uZ3JvdXBieSB8fCBbXSkubWFwKGFjY2Vzc29yTmFtZSksXG4gICAgICB2YWx1ZXMgPSBbXSxcbiAgICAgIHN0ZXAgPSBfLnN0ZXAgfHwgMC4wMSxcbiAgICAgIHAgPSBfLnByb2JzIHx8IHJhbmdlKHN0ZXAgLyAyLCAxIC0gRVBTSUxPTiwgc3RlcCksXG4gICAgICBuID0gcC5sZW5ndGg7XG4gICAgZ3JvdXBzLmZvckVhY2goZyA9PiB7XG4gICAgICBjb25zdCBxID0gcXVhbnRpbGVzKGcsIHApO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdFtuYW1lc1tpXV0gPSBnLmRpbXNbaV07XG4gICAgICAgIH1cbiAgICAgICAgdFthc1swXV0gPSBwW2ldO1xuICAgICAgICB0W2FzWzFdXSA9IHFbaV07XG4gICAgICAgIHZhbHVlcy5wdXNoKGluZ2VzdCh0KSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmFsdWUpIG91dC5yZW0gPSB0aGlzLnZhbHVlO1xuICAgIHRoaXMudmFsdWUgPSBvdXQuYWRkID0gb3V0LnNvdXJjZSA9IHZhbHVlcztcbiAgICByZXR1cm4gb3V0O1xuICB9XG59KTtcblxuLyoqXG4gKiBSZWxheXMgYSBkYXRhIHN0cmVhbSBiZXR3ZWVuIGRhdGEgcHJvY2Vzc2luZyBwaXBlbGluZXMuXG4gKiBJZiB0aGUgZGVyaXZlIHBhcmFtZXRlciBpcyBzZXQsIHRoaXMgdHJhbnNmb3JtIHdpbGwgY3JlYXRlIGRlcml2ZWRcbiAqIGNvcGllcyBvZiBvYnNlcnZlZCB0dXBsZXMuIFRoaXMgcHJvdmlkZXMgZGVyaXZlZCBkYXRhIHN0cmVhbXMgaW4gd2hpY2hcbiAqIG1vZGlmaWNhdGlvbnMgdG8gdGhlIHR1cGxlcyBkbyBub3QgcG9sbHV0ZSBhbiB1cHN0cmVhbSBkYXRhIHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLmRlcml2ZT1mYWxzZV0gLSBCb29sZWFuIGZsYWcgaW5kaWNhdGluZyBpZlxuICogICB0aGUgdHJhbnNmb3JtIHNob3VsZCBtYWtlIGRlcml2ZWQgY29waWVzIG9mIGluY29taW5nIHR1cGxlcy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZWxheShwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmluaGVyaXRzKFJlbGF5LCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgbGV0IG91dCwgbHV0O1xuICAgIGlmICh0aGlzLnZhbHVlKSB7XG4gICAgICBsdXQgPSB0aGlzLnZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXQgPSBwdWxzZSA9IHB1bHNlLmFkZEFsbCgpO1xuICAgICAgbHV0ID0gdGhpcy52YWx1ZSA9IHt9O1xuICAgIH1cbiAgICBpZiAoXy5kZXJpdmUpIHtcbiAgICAgIG91dCA9IHB1bHNlLmZvcmsocHVsc2UuTk9fU09VUkNFKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlJFTSwgdCA9PiB7XG4gICAgICAgIGNvbnN0IGlkID0gdHVwbGVpZCh0KTtcbiAgICAgICAgb3V0LnJlbS5wdXNoKGx1dFtpZF0pO1xuICAgICAgICBsdXRbaWRdID0gbnVsbDtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB0ID0+IHtcbiAgICAgICAgY29uc3QgZHQgPSBkZXJpdmUodCk7XG4gICAgICAgIGx1dFt0dXBsZWlkKHQpXSA9IGR0O1xuICAgICAgICBvdXQuYWRkLnB1c2goZHQpO1xuICAgICAgfSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5NT0QsIHQgPT4ge1xuICAgICAgICBjb25zdCBkdCA9IGx1dFt0dXBsZWlkKHQpXTtcbiAgICAgICAgZm9yIChjb25zdCBrIGluIHQpIHtcbiAgICAgICAgICBkdFtrXSA9IHRba107XG4gICAgICAgICAgLy8gZG93biBzdHJlYW0gd3JpdGVzIG1heSBvdmVyd3JpdGUgcmUtZGVyaXZlZCB0dXBsZXNcbiAgICAgICAgICAvLyBjb25zZXJ2YXRpdmVseSBtYXJrIGFsbCBzb3VyY2UgZmllbGRzIGFzIG1vZGlmaWVkXG4gICAgICAgICAgb3V0Lm1vZGlmaWVzKGspO1xuICAgICAgICB9XG4gICAgICAgIG91dC5tb2QucHVzaChkdCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfVxufSk7XG5cbi8qKlxuICogU2FtcGxlcyB0dXBsZXMgcGFzc2luZyB0aHJvdWdoIHRoaXMgb3BlcmF0b3IuXG4gKiBVc2VzIHJlc2Vydm9pciBzYW1wbGluZyB0byBtYWludGFpbiBhIHJlcHJlc2VudGF0aXZlIHNhbXBsZS5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtwYXJhbXMuc2l6ZT0xMDAwXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzYW1wbGVzLlxuICovXG5mdW5jdGlvbiBTYW1wbGUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIFtdLCBwYXJhbXMpO1xuICB0aGlzLmNvdW50ID0gMDtcbn1cblNhbXBsZS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdTYW1wbGUnLFxuICAnbWV0YWRhdGEnOiB7fSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDEwMDBcbiAgfV1cbn07XG5pbmhlcml0cyhTYW1wbGUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBvdXQgPSBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSksXG4gICAgICBtb2QgPSBfLm1vZGlmaWVkKCdzaXplJyksXG4gICAgICBudW0gPSBfLnNpemUsXG4gICAgICBtYXAgPSB0aGlzLnZhbHVlLnJlZHVjZSgobSwgdCkgPT4gKG1bdHVwbGVpZCh0KV0gPSAxLCBtKSwge30pO1xuICAgIGxldCByZXMgPSB0aGlzLnZhbHVlLFxuICAgICAgY250ID0gdGhpcy5jb3VudCxcbiAgICAgIGNhcCA9IDA7XG5cbiAgICAvLyBzYW1wbGUgcmVzZXJ2b2lyIHVwZGF0ZSBmdW5jdGlvblxuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0KSB7XG4gICAgICBsZXQgcCwgaWR4O1xuICAgICAgaWYgKHJlcy5sZW5ndGggPCBudW0pIHtcbiAgICAgICAgcmVzLnB1c2godCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZHggPSB+figoY250ICsgMSkgKiByYW5kb20oKSk7XG4gICAgICAgIGlmIChpZHggPCByZXMubGVuZ3RoICYmIGlkeCA+PSBjYXApIHtcbiAgICAgICAgICBwID0gcmVzW2lkeF07XG4gICAgICAgICAgaWYgKG1hcFt0dXBsZWlkKHApXSkgb3V0LnJlbS5wdXNoKHApOyAvLyBldmljdGlvblxuICAgICAgICAgIHJlc1tpZHhdID0gdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgKytjbnQ7XG4gICAgfVxuICAgIGlmIChwdWxzZS5yZW0ubGVuZ3RoKSB7XG4gICAgICAvLyBmaW5kIGFsbCB0dXBsZXMgdGhhdCBzaG91bGQgYmUgcmVtb3ZlZCwgYWRkIHRvIG91dHB1dFxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IHtcbiAgICAgICAgY29uc3QgaWQgPSB0dXBsZWlkKHQpO1xuICAgICAgICBpZiAobWFwW2lkXSkge1xuICAgICAgICAgIG1hcFtpZF0gPSAtMTtcbiAgICAgICAgICBvdXQucmVtLnB1c2godCk7XG4gICAgICAgIH1cbiAgICAgICAgLS1jbnQ7XG4gICAgICB9KTtcblxuICAgICAgLy8gZmlsdGVyIHJlbW92ZWQgdHVwbGVzIG91dCBvZiB0aGUgc2FtcGxlIHJlc2Vydm9pclxuICAgICAgcmVzID0gcmVzLmZpbHRlcih0ID0+IG1hcFt0dXBsZWlkKHQpXSAhPT0gLTEpO1xuICAgIH1cbiAgICBpZiAoKHB1bHNlLnJlbS5sZW5ndGggfHwgbW9kKSAmJiByZXMubGVuZ3RoIDwgbnVtICYmIHB1bHNlLnNvdXJjZSkge1xuICAgICAgLy8gcmVwbGVuaXNoIHNhbXBsZSBpZiBiYWNraW5nIGRhdGEgc291cmNlIGlzIGF2YWlsYWJsZVxuICAgICAgY2FwID0gY250ID0gcmVzLmxlbmd0aDtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgdCA9PiB7XG4gICAgICAgIC8vIHVwZGF0ZSwgYnV0IHNraXAgcHJldmlvdXNseSBzYW1wbGVkIHR1cGxlc1xuICAgICAgICBpZiAoIW1hcFt0dXBsZWlkKHQpXSkgdXBkYXRlKHQpO1xuICAgICAgfSk7XG4gICAgICBjYXAgPSAtMTtcbiAgICB9XG4gICAgaWYgKG1vZCAmJiByZXMubGVuZ3RoID4gbnVtKSB7XG4gICAgICBjb25zdCBuID0gcmVzLmxlbmd0aCAtIG51bTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICAgIG1hcFt0dXBsZWlkKHJlc1tpXSldID0gLTE7XG4gICAgICAgIG91dC5yZW0ucHVzaChyZXNbaV0pO1xuICAgICAgfVxuICAgICAgcmVzID0gcmVzLnNsaWNlKG4pO1xuICAgIH1cbiAgICBpZiAocHVsc2UubW9kLmxlbmd0aCkge1xuICAgICAgLy8gcHJvcGFnYXRlIG1vZGlmaWVkIHR1cGxlcyBpbiB0aGUgc2FtcGxlIHJlc2Vydm9pclxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCB0ID0+IHtcbiAgICAgICAgaWYgKG1hcFt0dXBsZWlkKHQpXSkgb3V0Lm1vZC5wdXNoKHQpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChwdWxzZS5hZGQubGVuZ3RoKSB7XG4gICAgICAvLyB1cGRhdGUgc2FtcGxlIHJlc2Vydm9pclxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCB1cGRhdGUpO1xuICAgIH1cbiAgICBpZiAocHVsc2UuYWRkLmxlbmd0aCB8fCBjYXAgPCAwKSB7XG4gICAgICAvLyBvdXRwdXQgbmV3bHkgYWRkZWQgdHVwbGVzXG4gICAgICBvdXQuYWRkID0gcmVzLmZpbHRlcih0ID0+ICFtYXBbdHVwbGVpZCh0KV0pO1xuICAgIH1cbiAgICB0aGlzLmNvdW50ID0gY250O1xuICAgIHRoaXMudmFsdWUgPSBvdXQuc291cmNlID0gcmVzO1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEdlbmVyYXRlcyBkYXRhIHR1cGxlcyBmb3IgYSBzcGVjaWZpZWQgc2VxdWVuY2UgcmFuZ2Ugb2YgbnVtYmVycy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdGFydCAtIFRoZSBmaXJzdCBudW1iZXIgaW4gdGhlIHNlcXVlbmNlLlxuICogQHBhcmFtIHtudW1iZXJ9IHBhcmFtcy5zdG9wIC0gVGhlIGxhc3QgbnVtYmVyIChleGNsdXNpdmUpIGluIHRoZSBzZXF1ZW5jZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbcGFyYW1zLnN0ZXA9MV0gLSBUaGUgc3RlcCBzaXplIGJldHdlZW4gbnVtYmVycyBpbiB0aGUgc2VxdWVuY2UuXG4gKi9cbmZ1bmN0aW9uIFNlcXVlbmNlKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuU2VxdWVuY2UuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnU2VxdWVuY2UnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ2dlbmVyYXRlcyc6IHRydWUsXG4gICAgJ2NoYW5nZXMnOiB0cnVlXG4gIH0sXG4gICdwYXJhbXMnOiBbe1xuICAgICduYW1lJzogJ3N0YXJ0JyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3N0b3AnLFxuICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgJ3JlcXVpcmVkJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnc3RlcCcsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDFcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdkZWZhdWx0JzogJ2RhdGEnXG4gIH1dXG59O1xuaW5oZXJpdHMoU2VxdWVuY2UsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBpZiAodGhpcy52YWx1ZSAmJiAhXy5tb2RpZmllZCgpKSByZXR1cm47XG4gICAgY29uc3Qgb3V0ID0gcHVsc2UubWF0ZXJpYWxpemUoKS5mb3JrKHB1bHNlLk1PRCksXG4gICAgICBhcyA9IF8uYXMgfHwgJ2RhdGEnO1xuICAgIG91dC5yZW0gPSB0aGlzLnZhbHVlID8gcHVsc2UucmVtLmNvbmNhdCh0aGlzLnZhbHVlKSA6IHB1bHNlLnJlbTtcbiAgICB0aGlzLnZhbHVlID0gcmFuZ2UoXy5zdGFydCwgXy5zdG9wLCBfLnN0ZXAgfHwgMSkubWFwKHYgPT4ge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgdFthc10gPSB2O1xuICAgICAgcmV0dXJuIGluZ2VzdCh0KTtcbiAgICB9KTtcbiAgICBvdXQuYWRkID0gcHVsc2UuYWRkLmNvbmNhdCh0aGlzLnZhbHVlKTtcbiAgICByZXR1cm4gb3V0O1xuICB9XG59KTtcblxuLyoqXG4gKiBQcm9wYWdhdGVzIGEgbmV3IHB1bHNlIHdpdGhvdXQgYW55IHR1cGxlcyBzbyBsb25nIGFzIHRoZSBpbnB1dFxuICogcHVsc2UgY29udGFpbnMgc29tZSBhZGRlZCwgcmVtb3ZlZCBvciBtb2RpZmllZCB0dXBsZXMuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2lldmUocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG4gIHRoaXMubW9kaWZpZWQodHJ1ZSk7IC8vIGFsd2F5cyB0cmVhdCBhcyBtb2RpZmllZFxufVxuaW5oZXJpdHMoU2lldmUsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnZhbHVlID0gcHVsc2Uuc291cmNlO1xuICAgIHJldHVybiBwdWxzZS5jaGFuZ2VkKCkgPyBwdWxzZS5mb3JrKHB1bHNlLk5PX1NPVVJDRSB8IHB1bHNlLk5PX0ZJRUxEUykgOiBwdWxzZS5TdG9wUHJvcGFnYXRpb247XG4gIH1cbn0pO1xuXG4vKipcbiAqIERpc2NyZXRpemUgZGF0ZXMgdG8gc3BlY2lmaWMgdGltZSB1bml0cy5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiAqfSBwYXJhbXMuZmllbGQgLSBUaGUgZGF0YSBmaWVsZCBjb250YWluaW5nIGRhdGUvdGltZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIFRpbWVVbml0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuY29uc3QgT1VUUFVUID0gWyd1bml0MCcsICd1bml0MSddO1xuVGltZVVuaXQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnVGltZVVuaXQnLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdmaWVsZCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2ludGVydmFsJyxcbiAgICAndHlwZSc6ICdib29sZWFuJyxcbiAgICAnZGVmYXVsdCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3VuaXRzJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAndmFsdWVzJzogVElNRV9VTklUUyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzdGVwJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdkZWZhdWx0JzogMVxuICB9LCB7XG4gICAgJ25hbWUnOiAnbWF4YmlucycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZGVmYXVsdCc6IDQwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdleHRlbnQnLFxuICAgICd0eXBlJzogJ2RhdGUnLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3RpbWV6b25lJyxcbiAgICAndHlwZSc6ICdlbnVtJyxcbiAgICAnZGVmYXVsdCc6ICdsb2NhbCcsXG4gICAgJ3ZhbHVlcyc6IFsnbG9jYWwnLCAndXRjJ11cbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBPVVRQVVRcbiAgfV1cbn07XG5pbmhlcml0cyhUaW1lVW5pdCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGZpZWxkID0gXy5maWVsZCxcbiAgICAgIGJhbmQgPSBfLmludGVydmFsICE9PSBmYWxzZSxcbiAgICAgIHV0YyA9IF8udGltZXpvbmUgPT09ICd1dGMnLFxuICAgICAgZmxvb3IgPSB0aGlzLl9mbG9vcihfLCBwdWxzZSksXG4gICAgICBvZmZzZXQgPSAodXRjID8gdXRjSW50ZXJ2YWwgOiB0aW1lSW50ZXJ2YWwpKGZsb29yLnVuaXQpLm9mZnNldCxcbiAgICAgIGFzID0gXy5hcyB8fCBPVVRQVVQsXG4gICAgICB1MCA9IGFzWzBdLFxuICAgICAgdTEgPSBhc1sxXSxcbiAgICAgIHN0ZXAgPSBmbG9vci5zdGVwO1xuICAgIGxldCBtaW4gPSBmbG9vci5zdGFydCB8fCBJbmZpbml0eSxcbiAgICAgIG1heCA9IGZsb29yLnN0b3AgfHwgLUluZmluaXR5LFxuICAgICAgZmxhZyA9IHB1bHNlLkFERDtcbiAgICBpZiAoXy5tb2RpZmllZCgpIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuUkVNKSB8fCBwdWxzZS5tb2RpZmllZChhY2Nlc3NvckZpZWxkcyhmaWVsZCkpKSB7XG4gICAgICBwdWxzZSA9IHB1bHNlLnJlZmxvdyh0cnVlKTtcbiAgICAgIGZsYWcgPSBwdWxzZS5TT1VSQ0U7XG4gICAgICBtaW4gPSBJbmZpbml0eTtcbiAgICAgIG1heCA9IC1JbmZpbml0eTtcbiAgICB9XG4gICAgcHVsc2UudmlzaXQoZmxhZywgdCA9PiB7XG4gICAgICBjb25zdCB2ID0gZmllbGQodCk7XG4gICAgICBsZXQgYSwgYjtcbiAgICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgICAgdFt1MF0gPSBudWxsO1xuICAgICAgICBpZiAoYmFuZCkgdFt1MV0gPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFt1MF0gPSBhID0gYiA9IGZsb29yKHYpO1xuICAgICAgICBpZiAoYmFuZCkgdFt1MV0gPSBiID0gb2Zmc2V0KGEsIHN0ZXApO1xuICAgICAgICBpZiAoYSA8IG1pbikgbWluID0gYTtcbiAgICAgICAgaWYgKGIgPiBtYXgpIG1heCA9IGI7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZmxvb3Iuc3RhcnQgPSBtaW47XG4gICAgZmxvb3Iuc3RvcCA9IG1heDtcbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoYmFuZCA/IGFzIDogdTApO1xuICB9LFxuICBfZmxvb3IoXywgcHVsc2UpIHtcbiAgICBjb25zdCB1dGMgPSBfLnRpbWV6b25lID09PSAndXRjJztcblxuICAgIC8vIGdldCBwYXJhbWV0ZXJzXG4gICAgY29uc3Qge1xuICAgICAgdW5pdHMsXG4gICAgICBzdGVwXG4gICAgfSA9IF8udW5pdHMgPyB7XG4gICAgICB1bml0czogXy51bml0cyxcbiAgICAgIHN0ZXA6IF8uc3RlcCB8fCAxXG4gICAgfSA6IHRpbWVCaW4oe1xuICAgICAgZXh0ZW50OiBfLmV4dGVudCB8fCBleHRlbnQocHVsc2UubWF0ZXJpYWxpemUocHVsc2UuU09VUkNFKS5zb3VyY2UsIF8uZmllbGQpLFxuICAgICAgbWF4YmluczogXy5tYXhiaW5zXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayAvIHN0YW5kYXJkaXplIHRpbWUgdW5pdHNcbiAgICBjb25zdCB0dW5pdHMgPSB0aW1lVW5pdHModW5pdHMpLFxuICAgICAgcHJldiA9IHRoaXMudmFsdWUgfHwge30sXG4gICAgICBmbG9vciA9ICh1dGMgPyB1dGNGbG9vciA6IHRpbWVGbG9vcikodHVuaXRzLCBzdGVwKTtcbiAgICBmbG9vci51bml0ID0gcGVlayh0dW5pdHMpO1xuICAgIGZsb29yLnVuaXRzID0gdHVuaXRzO1xuICAgIGZsb29yLnN0ZXAgPSBzdGVwO1xuICAgIGZsb29yLnN0YXJ0ID0gcHJldi5zdGFydDtcbiAgICBmbG9vci5zdG9wID0gcHJldi5zdG9wO1xuICAgIHJldHVybiB0aGlzLnZhbHVlID0gZmxvb3I7XG4gIH1cbn0pO1xuXG4vKipcbiAqIEFuIGluZGV4IHRoYXQgbWFwcyBmcm9tIHVuaXF1ZSwgc3RyaW5nLWNvZXJjZWQsIGZpZWxkIHZhbHVlcyB0byB0dXBsZXMuXG4gKiBBc3N1bWVzIHRoYXQgdGhlIGZpZWxkIHNlcnZlcyBhcyBhIHVuaXF1ZSBrZXkgd2l0aCBubyBkdXBsaWNhdGUgdmFsdWVzLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKG9iamVjdCk6ICp9IHBhcmFtcy5maWVsZCAtIFRoZSBmaWVsZCBhY2Nlc3NvciB0byBpbmRleC5cbiAqL1xuZnVuY3Rpb24gVHVwbGVJbmRleChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgZmFzdG1hcCgpLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVHVwbGVJbmRleCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGRmID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICBmaWVsZCA9IF8uZmllbGQsXG4gICAgICBpbmRleCA9IHRoaXMudmFsdWUsXG4gICAgICBzZXQgPSB0ID0+IGluZGV4LnNldChmaWVsZCh0KSwgdCk7XG4gICAgbGV0IG1vZCA9IHRydWU7XG4gICAgaWYgKF8ubW9kaWZpZWQoJ2ZpZWxkJykgfHwgcHVsc2UubW9kaWZpZWQoZmllbGQuZmllbGRzKSkge1xuICAgICAgaW5kZXguY2xlYXIoKTtcbiAgICAgIHB1bHNlLnZpc2l0KHB1bHNlLlNPVVJDRSwgc2V0KTtcbiAgICB9IGVsc2UgaWYgKHB1bHNlLmNoYW5nZWQoKSkge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IGluZGV4LmRlbGV0ZShmaWVsZCh0KSkpO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBzZXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBtb2QgPSBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5tb2RpZmllZChtb2QpO1xuICAgIGlmIChpbmRleC5lbXB0eSA+IGRmLmNsZWFuVGhyZXNob2xkKSBkZi5ydW5BZnRlcihpbmRleC5jbGVhbik7XG4gICAgcmV0dXJuIHB1bHNlLmZvcmsoKTtcbiAgfVxufSk7XG5cbi8qKlxuICogRXh0cmFjdHMgYW4gYXJyYXkgb2YgdmFsdWVzLiBBc3N1bWVzIHRoZSBzb3VyY2UgZGF0YSBoYXMgYWxyZWFkeSBiZWVuXG4gKiByZWR1Y2VkIGFzIG5lZWRlZCAoZS5nLiwgYnkgYW4gdXBzdHJlYW0gQWdncmVnYXRlIHRyYW5zZm9ybSkuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24ob2JqZWN0KTogKn0gcGFyYW1zLmZpZWxkIC0gVGhlIGRvbWFpbiBmaWVsZCB0byBleHRyYWN0LlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCopOiBudW1iZXJ9IFtwYXJhbXMuc29ydF0gLSBBbiBvcHRpb25hbFxuICogICBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIHRoZSB2YWx1ZXMuIFRoZSBjb21wYXJhdG9yIHdpbGwgYmVcbiAqICAgYXBwbGllZCB0byBiYWNraW5nIHR1cGxlcyBwcmlvciB0byB2YWx1ZSBleHRyYWN0aW9uLlxuICovXG5mdW5jdGlvbiBWYWx1ZXMocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhWYWx1ZXMsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCBydW4gPSAhdGhpcy52YWx1ZSB8fCBfLm1vZGlmaWVkKCdmaWVsZCcpIHx8IF8ubW9kaWZpZWQoJ3NvcnQnKSB8fCBwdWxzZS5jaGFuZ2VkKCkgfHwgXy5zb3J0ICYmIHB1bHNlLm1vZGlmaWVkKF8uc29ydC5maWVsZHMpO1xuICAgIGlmIChydW4pIHtcbiAgICAgIHRoaXMudmFsdWUgPSAoXy5zb3J0ID8gcHVsc2Uuc291cmNlLnNsaWNlKCkuc29ydChzdGFibGVDb21wYXJlKF8uc29ydCkpIDogcHVsc2Uuc291cmNlKS5tYXAoXy5maWVsZCk7XG4gICAgfVxuICB9XG59KTtcblxuZnVuY3Rpb24gV2luZG93T3Aob3AsIGZpZWxkLCBwYXJhbSwgYXMpIHtcbiAgY29uc3QgZm4gPSBXaW5kb3dPcHNbb3BdKGZpZWxkLCBwYXJhbSk7XG4gIHJldHVybiB7XG4gICAgaW5pdDogZm4uaW5pdCB8fCB6ZXJvLFxuICAgIHVwZGF0ZTogZnVuY3Rpb24gKHcsIHQpIHtcbiAgICAgIHRbYXNdID0gZm4ubmV4dCh3KTtcbiAgICB9XG4gIH07XG59XG5jb25zdCBXaW5kb3dPcHMgPSB7XG4gIHJvd19udW1iZXI6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiB3LmluZGV4ICsgMVxuICAgIH07XG4gIH0sXG4gIHJhbms6IGZ1bmN0aW9uICgpIHtcbiAgICBsZXQgcmFuaztcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gcmFuayA9IDEsXG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHcuaW5kZXgsXG4gICAgICAgICAgZGF0YSA9IHcuZGF0YTtcbiAgICAgICAgcmV0dXJuIGkgJiYgdy5jb21wYXJlKGRhdGFbaSAtIDFdLCBkYXRhW2ldKSA/IHJhbmsgPSBpICsgMSA6IHJhbms7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZGVuc2VfcmFuazogZnVuY3Rpb24gKCkge1xuICAgIGxldCBkcmFuaztcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gZHJhbmsgPSAxLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB3LmluZGV4LFxuICAgICAgICAgIGQgPSB3LmRhdGE7XG4gICAgICAgIHJldHVybiBpICYmIHcuY29tcGFyZShkW2kgLSAxXSwgZFtpXSkgPyArK2RyYW5rIDogZHJhbms7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgcGVyY2VudF9yYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgcmFuayA9IFdpbmRvd09wcy5yYW5rKCksXG4gICAgICBuZXh0ID0gcmFuay5uZXh0O1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiByYW5rLmluaXQsXG4gICAgICBuZXh0OiB3ID0+IChuZXh0KHcpIC0gMSkgLyAody5kYXRhLmxlbmd0aCAtIDEpXG4gICAgfTtcbiAgfSxcbiAgY3VtZV9kaXN0OiBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IGN1bWU7XG4gICAgcmV0dXJuIHtcbiAgICAgIGluaXQ6ICgpID0+IGN1bWUgPSAwLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSB3LmRhdGEsXG4gICAgICAgICAgYyA9IHcuY29tcGFyZTtcbiAgICAgICAgbGV0IGkgPSB3LmluZGV4O1xuICAgICAgICBpZiAoY3VtZSA8IGkpIHtcbiAgICAgICAgICB3aGlsZSAoaSArIDEgPCBkLmxlbmd0aCAmJiAhYyhkW2ldLCBkW2kgKyAxXSkpICsraTtcbiAgICAgICAgICBjdW1lID0gaTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKDEgKyBjdW1lKSAvIGQubGVuZ3RoO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIG50aWxlOiBmdW5jdGlvbiAoZmllbGQsIG51bSkge1xuICAgIG51bSA9ICtudW07XG4gICAgaWYgKCEobnVtID4gMCkpIGVycm9yKCdudGlsZSBudW0gbXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby4nKTtcbiAgICBjb25zdCBjdW1lID0gV2luZG93T3BzLmN1bWVfZGlzdCgpLFxuICAgICAgbmV4dCA9IGN1bWUubmV4dDtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogY3VtZS5pbml0LFxuICAgICAgbmV4dDogdyA9PiBNYXRoLmNlaWwobnVtICogbmV4dCh3KSlcbiAgICB9O1xuICB9LFxuICBsYWc6IGZ1bmN0aW9uIChmaWVsZCwgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gK29mZnNldCB8fCAxO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHcuaW5kZXggLSBvZmZzZXQ7XG4gICAgICAgIHJldHVybiBpID49IDAgPyBmaWVsZCh3LmRhdGFbaV0pIDogbnVsbDtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBsZWFkOiBmdW5jdGlvbiAoZmllbGQsIG9mZnNldCkge1xuICAgIG9mZnNldCA9ICtvZmZzZXQgfHwgMTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGkgPSB3LmluZGV4ICsgb2Zmc2V0LFxuICAgICAgICAgIGQgPSB3LmRhdGE7XG4gICAgICAgIHJldHVybiBpIDwgZC5sZW5ndGggPyBmaWVsZChkW2ldKSA6IG51bGw7XG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgZmlyc3RfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IGZpZWxkKHcuZGF0YVt3LmkwXSlcbiAgICB9O1xuICB9LFxuICBsYXN0X3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dDogdyA9PiBmaWVsZCh3LmRhdGFbdy5pMSAtIDFdKVxuICAgIH07XG4gIH0sXG4gIG50aF92YWx1ZTogZnVuY3Rpb24gKGZpZWxkLCBudGgpIHtcbiAgICBudGggPSArbnRoO1xuICAgIGlmICghKG50aCA+IDApKSBlcnJvcignbnRoX3ZhbHVlIG50aCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLicpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiB3ID0+IHtcbiAgICAgICAgY29uc3QgaSA9IHcuaTAgKyAobnRoIC0gMSk7XG4gICAgICAgIHJldHVybiBpIDwgdy5pMSA/IGZpZWxkKHcuZGF0YVtpXSkgOiBudWxsO1xuICAgICAgfVxuICAgIH07XG4gIH0sXG4gIHByZXZfdmFsdWU6IGZ1bmN0aW9uIChmaWVsZCkge1xuICAgIGxldCBwcmV2O1xuICAgIHJldHVybiB7XG4gICAgICBpbml0OiAoKSA9PiBwcmV2ID0gbnVsbCxcbiAgICAgIG5leHQ6IHcgPT4ge1xuICAgICAgICBjb25zdCB2ID0gZmllbGQody5kYXRhW3cuaW5kZXhdKTtcbiAgICAgICAgcmV0dXJuIHYgIT0gbnVsbCA/IHByZXYgPSB2IDogcHJldjtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBuZXh0X3ZhbHVlOiBmdW5jdGlvbiAoZmllbGQpIHtcbiAgICBsZXQgdiwgaTtcbiAgICByZXR1cm4ge1xuICAgICAgaW5pdDogKCkgPT4gKHYgPSBudWxsLCBpID0gLTEpLFxuICAgICAgbmV4dDogdyA9PiB7XG4gICAgICAgIGNvbnN0IGQgPSB3LmRhdGE7XG4gICAgICAgIHJldHVybiB3LmluZGV4IDw9IGkgPyB2IDogKGkgPSBmaW5kKGZpZWxkLCBkLCB3LmluZGV4KSkgPCAwID8gKGkgPSBkLmxlbmd0aCwgdiA9IG51bGwpIDogdiA9IGZpZWxkKGRbaV0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5mdW5jdGlvbiBmaW5kKGZpZWxkLCBkYXRhLCBpbmRleCkge1xuICBmb3IgKGxldCBuID0gZGF0YS5sZW5ndGg7IGluZGV4IDwgbjsgKytpbmRleCkge1xuICAgIGNvbnN0IHYgPSBmaWVsZChkYXRhW2luZGV4XSk7XG4gICAgaWYgKHYgIT0gbnVsbCkgcmV0dXJuIGluZGV4O1xuICB9XG4gIHJldHVybiAtMTtcbn1cbmNvbnN0IFZhbGlkV2luZG93T3BzID0gT2JqZWN0LmtleXMoV2luZG93T3BzKTtcblxuZnVuY3Rpb24gV2luZG93U3RhdGUoXykge1xuICBjb25zdCBvcHMgPSBhcnJheShfLm9wcyksXG4gICAgZmllbGRzID0gYXJyYXkoXy5maWVsZHMpLFxuICAgIHBhcmFtcyA9IGFycmF5KF8ucGFyYW1zKSxcbiAgICBhZ2dyZWdhdGVfcGFyYW1zID0gYXJyYXkoXy5hZ2dyZWdhdGVfcGFyYW1zKSxcbiAgICBhcyA9IGFycmF5KF8uYXMpLFxuICAgIG91dHB1dHMgPSB0aGlzLm91dHB1dHMgPSBbXSxcbiAgICB3aW5kb3dzID0gdGhpcy53aW5kb3dzID0gW10sXG4gICAgaW5wdXRzID0ge30sXG4gICAgbWFwID0ge30sXG4gICAgY291bnRzID0gW10sXG4gICAgbWVhc3VyZXMgPSBbXTtcbiAgbGV0IGNvdW50T25seSA9IHRydWU7XG4gIGZ1bmN0aW9uIHZpc2l0SW5wdXRzKGYpIHtcbiAgICBhcnJheShhY2Nlc3NvckZpZWxkcyhmKSkuZm9yRWFjaChfID0+IGlucHV0c1tfXSA9IDEpO1xuICB9XG4gIHZpc2l0SW5wdXRzKF8uc29ydCk7XG4gIG9wcy5mb3JFYWNoKChvcCwgaSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkID0gZmllbGRzW2ldLFxuICAgICAgcGFyYW0gPSBwYXJhbXNbaV0sXG4gICAgICBhZ2dyZWdhdGVfcGFyYW0gPSBhZ2dyZWdhdGVfcGFyYW1zW2ldIHx8IG51bGwsXG4gICAgICBtbmFtZSA9IGFjY2Vzc29yTmFtZShmaWVsZCksXG4gICAgICBuYW1lID0gbWVhc3VyZU5hbWUob3AsIG1uYW1lLCBhc1tpXSk7XG4gICAgdmlzaXRJbnB1dHMoZmllbGQpO1xuICAgIG91dHB1dHMucHVzaChuYW1lKTtcblxuICAgIC8vIFdpbmRvdyBvcGVyYXRpb25cbiAgICBpZiAoaGFzT3duUHJvcGVydHkoV2luZG93T3BzLCBvcCkpIHtcbiAgICAgIHdpbmRvd3MucHVzaChXaW5kb3dPcChvcCwgZmllbGQsIHBhcmFtLCBuYW1lKSk7XG4gICAgfVxuXG4gICAgLy8gQWdncmVnYXRlIG9wZXJhdGlvblxuICAgIGVsc2Uge1xuICAgICAgaWYgKGZpZWxkID09IG51bGwgJiYgb3AgIT09ICdjb3VudCcpIHtcbiAgICAgICAgZXJyb3IoJ051bGwgYWdncmVnYXRlIGZpZWxkIHNwZWNpZmllZC4nKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcCA9PT0gJ2NvdW50Jykge1xuICAgICAgICBjb3VudHMucHVzaChuYW1lKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY291bnRPbmx5ID0gZmFsc2U7XG4gICAgICBsZXQgbSA9IG1hcFttbmFtZV07XG4gICAgICBpZiAoIW0pIHtcbiAgICAgICAgbSA9IG1hcFttbmFtZV0gPSBbXTtcbiAgICAgICAgbS5maWVsZCA9IGZpZWxkO1xuICAgICAgICBtZWFzdXJlcy5wdXNoKG0pO1xuICAgICAgfVxuICAgICAgbS5wdXNoKGNyZWF0ZU1lYXN1cmUob3AsIGFnZ3JlZ2F0ZV9wYXJhbSwgbmFtZSkpO1xuICAgIH1cbiAgfSk7XG4gIGlmIChjb3VudHMubGVuZ3RoIHx8IG1lYXN1cmVzLmxlbmd0aCkge1xuICAgIHRoaXMuY2VsbCA9IGNlbGwobWVhc3VyZXMsIGNvdW50cywgY291bnRPbmx5KTtcbiAgfVxuICB0aGlzLmlucHV0cyA9IE9iamVjdC5rZXlzKGlucHV0cyk7XG59XG5jb25zdCBwcm90b3R5cGUgPSBXaW5kb3dTdGF0ZS5wcm90b3R5cGU7XG5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy53aW5kb3dzLmZvckVhY2goXyA9PiBfLmluaXQoKSk7XG4gIGlmICh0aGlzLmNlbGwpIHRoaXMuY2VsbC5pbml0KCk7XG59O1xucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uICh3LCB0KSB7XG4gIGNvbnN0IGNlbGwgPSB0aGlzLmNlbGwsXG4gICAgd2luZCA9IHRoaXMud2luZG93cyxcbiAgICBkYXRhID0gdy5kYXRhLFxuICAgIG0gPSB3aW5kICYmIHdpbmQubGVuZ3RoO1xuICBsZXQgajtcbiAgaWYgKGNlbGwpIHtcbiAgICBmb3IgKGogPSB3LnAwOyBqIDwgdy5pMDsgKytqKSBjZWxsLnJlbShkYXRhW2pdKTtcbiAgICBmb3IgKGogPSB3LnAxOyBqIDwgdy5pMTsgKytqKSBjZWxsLmFkZChkYXRhW2pdKTtcbiAgICBjZWxsLnNldCh0KTtcbiAgfVxuICBmb3IgKGogPSAwOyBqIDwgbTsgKytqKSB3aW5kW2pdLnVwZGF0ZSh3LCB0KTtcbn07XG5mdW5jdGlvbiBjZWxsKG1lYXN1cmVzLCBjb3VudHMsIGNvdW50T25seSkge1xuICBtZWFzdXJlcyA9IG1lYXN1cmVzLm1hcChtID0+IGNvbXBpbGVNZWFzdXJlcyhtLCBtLmZpZWxkKSk7XG4gIGNvbnN0IGNlbGwgPSB7XG4gICAgbnVtOiAwLFxuICAgIGFnZzogbnVsbCxcbiAgICBzdG9yZTogZmFsc2UsXG4gICAgY291bnQ6IGNvdW50c1xuICB9O1xuICBpZiAoIWNvdW50T25seSkge1xuICAgIHZhciBuID0gbWVhc3VyZXMubGVuZ3RoLFxuICAgICAgYSA9IGNlbGwuYWdnID0gQXJyYXkobiksXG4gICAgICBpID0gMDtcbiAgICBmb3IgKDsgaSA8IG47ICsraSkgYVtpXSA9IG5ldyBtZWFzdXJlc1tpXShjZWxsKTtcbiAgfVxuICBpZiAoY2VsbC5zdG9yZSkge1xuICAgIHZhciBzdG9yZSA9IGNlbGwuZGF0YSA9IG5ldyBUdXBsZVN0b3JlKCk7XG4gIH1cbiAgY2VsbC5hZGQgPSBmdW5jdGlvbiAodCkge1xuICAgIGNlbGwubnVtICs9IDE7XG4gICAgaWYgKGNvdW50T25seSkgcmV0dXJuO1xuICAgIGlmIChzdG9yZSkgc3RvcmUuYWRkKHQpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBhW2ldLmFkZChhW2ldLmdldCh0KSwgdCk7XG4gICAgfVxuICB9O1xuICBjZWxsLnJlbSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgY2VsbC5udW0gLT0gMTtcbiAgICBpZiAoY291bnRPbmx5KSByZXR1cm47XG4gICAgaWYgKHN0b3JlKSBzdG9yZS5yZW0odCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGFbaV0ucmVtKGFbaV0uZ2V0KHQpLCB0KTtcbiAgICB9XG4gIH07XG4gIGNlbGwuc2V0ID0gZnVuY3Rpb24gKHQpIHtcbiAgICBsZXQgaSwgbjtcblxuICAgIC8vIGNvbnNvbGlkYXRlIHN0b3JlZCB2YWx1ZXNcbiAgICBpZiAoc3RvcmUpIHN0b3JlLnZhbHVlcygpO1xuXG4gICAgLy8gdXBkYXRlIHR1cGxlIHByb3BlcnRpZXNcbiAgICBmb3IgKGkgPSAwLCBuID0gY291bnRzLmxlbmd0aDsgaSA8IG47ICsraSkgdFtjb3VudHNbaV1dID0gY2VsbC5udW07XG4gICAgaWYgKCFjb3VudE9ubHkpIGZvciAoaSA9IDAsIG4gPSBhLmxlbmd0aDsgaSA8IG47ICsraSkgYVtpXS5zZXQodCk7XG4gIH07XG4gIGNlbGwuaW5pdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjZWxsLm51bSA9IDA7XG4gICAgaWYgKHN0b3JlKSBzdG9yZS5yZXNldCgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSBhW2ldLmluaXQoKTtcbiAgfTtcbiAgcmV0dXJuIGNlbGw7XG59XG5cbi8qKlxuICogUGVyZm9ybSB3aW5kb3cgY2FsY3VsYXRpb25zIGFuZCB3cml0ZSByZXN1bHRzIHRvIHRoZSBpbnB1dCBzdHJlYW0uXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oKiwqKTogbnVtYmVyfSBbcGFyYW1zLnNvcnRdIC0gQSBjb21wYXJhdG9yIGZ1bmN0aW9uIGZvciBzb3J0aW5nIHR1cGxlcyB3aXRoaW4gYSB3aW5kb3cuXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmdyb3VwYnldIC0gQW4gYXJyYXkgb2YgYWNjZXNzb3JzIGJ5IHdoaWNoIHRvIHBhcnRpdGlvbiB0dXBsZXMgaW50byBzZXBhcmF0ZSB3aW5kb3dzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBwYXJhbXMub3BzIC0gQW4gYXJyYXkgb2Ygc3RyaW5ncyBpbmRpY2F0aW5nIHdpbmRvdyBvcGVyYXRpb25zIHRvIHBlcmZvcm0uXG4gKiBAcGFyYW0ge0FycmF5PGZ1bmN0aW9uKG9iamVjdCk6ICo+fSBbcGFyYW1zLmZpZWxkc10gLSBBbiBhcnJheSBvZiBhY2Nlc3NvcnNcbiAqICAgZm9yIGRhdGEgZmllbGRzIHRvIHVzZSBhcyBpbnB1dHMgdG8gd2luZG93IG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PCo+fSBbcGFyYW1zLnBhcmFtc10gLSBBbiBhcnJheSBvZiBwYXJhbWV0ZXIgdmFsdWVzIGZvciB3aW5kb3cgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5hZ2dyZWdhdGVfcGFyYW1zXSAtIEFuIG9wdGlvbmFsIGFycmF5IG9mIHBhcmFtZXRlciB2YWx1ZXMgZm9yIGFnZ3JlZ2F0aW9uIG9wZXJhdGlvbnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtwYXJhbXMuYXNdIC0gQW4gYXJyYXkgb2Ygb3V0cHV0IGZpZWxkIG5hbWVzIGZvciB3aW5kb3cgb3BlcmF0aW9ucy5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW3BhcmFtcy5mcmFtZV0gLSBXaW5kb3cgZnJhbWUgZGVmaW5pdGlvbiBhcyB0d28tZWxlbWVudCBhcnJheS5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW3BhcmFtcy5pZ25vcmVQZWVycz1mYWxzZV0gLSBJZiB0cnVlLCBiYXNlIHdpbmRvdyBmcmFtZSBib3VuZGFyaWVzIG9uIHJvd1xuICogICBudW1iZXIgYWxvbmUsIGlnbm9yaW5nIHBlZXJzIHdpdGggaWRlbnRpY2FsIHNvcnQgdmFsdWVzLiBJZiBmYWxzZSAoZGVmYXVsdCksXG4gKiAgIHRoZSB3aW5kb3cgYm91bmRhcmllcyB3aWxsIGJlIGFkanVzdGVkIHRvIGluY2x1ZGUgcGVlciB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIFdpbmRvdyhwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywge30sIHBhcmFtcyk7XG4gIHRoaXMuX21sZW4gPSAwO1xuICB0aGlzLl9tb2RzID0gW107XG59XG5XaW5kb3cuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnV2luZG93JyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc29ydCcsXG4gICAgJ3R5cGUnOiAnY29tcGFyZSdcbiAgfSwge1xuICAgICduYW1lJzogJ2dyb3VwYnknLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdvcHMnLFxuICAgICd0eXBlJzogJ2VudW0nLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ3ZhbHVlcyc6IFZhbGlkV2luZG93T3BzLmNvbmNhdChWYWxpZEFnZ3JlZ2F0ZU9wcylcbiAgfSwge1xuICAgICduYW1lJzogJ3BhcmFtcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYWdncmVnYXRlX3BhcmFtcycsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnZmllbGRzJyxcbiAgICAndHlwZSc6ICdmaWVsZCcsXG4gICAgJ251bGwnOiB0cnVlLFxuICAgICdhcnJheSc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ2FzJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdudWxsJzogdHJ1ZSxcbiAgICAnYXJyYXknOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmcmFtZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnbnVsbCc6IHRydWUsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogMixcbiAgICAnZGVmYXVsdCc6IFtudWxsLCAwXVxuICB9LCB7XG4gICAgJ25hbWUnOiAnaWdub3JlUGVlcnMnLFxuICAgICd0eXBlJzogJ2Jvb2xlYW4nLFxuICAgICdkZWZhdWx0JzogZmFsc2VcbiAgfV1cbn07XG5pbmhlcml0cyhXaW5kb3csIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICB0aGlzLnN0YW1wID0gcHVsc2Uuc3RhbXA7XG4gICAgY29uc3QgbW9kID0gXy5tb2RpZmllZCgpLFxuICAgICAgY21wID0gc3RhYmxlQ29tcGFyZShfLnNvcnQpLFxuICAgICAga2V5ID0gZ3JvdXBrZXkoXy5ncm91cGJ5KSxcbiAgICAgIGdyb3VwID0gdCA9PiB0aGlzLmdyb3VwKGtleSh0KSk7XG5cbiAgICAvLyBpbml0aWFsaXplIHdpbmRvdyBzdGF0ZVxuICAgIGxldCBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgaWYgKCFzdGF0ZSB8fCBtb2QpIHtcbiAgICAgIHN0YXRlID0gdGhpcy5zdGF0ZSA9IG5ldyBXaW5kb3dTdGF0ZShfKTtcbiAgICB9XG5cbiAgICAvLyBwYXJ0aXRpb24gaW5wdXQgdHVwbGVzXG4gICAgaWYgKG1vZCB8fCBwdWxzZS5tb2RpZmllZChzdGF0ZS5pbnB1dHMpKSB7XG4gICAgICB0aGlzLnZhbHVlID0ge307XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5TT1VSQ0UsIHQgPT4gZ3JvdXAodCkuYWRkKHQpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuUkVNLCB0ID0+IGdyb3VwKHQpLnJlbW92ZSh0KSk7XG4gICAgICBwdWxzZS52aXNpdChwdWxzZS5BREQsIHQgPT4gZ3JvdXAodCkuYWRkKHQpKTtcbiAgICB9XG5cbiAgICAvLyBwZXJmb3JtIHdpbmRvdyBjYWxjdWxhdGlvbnMgZm9yIGVhY2ggbW9kaWZpZWQgcGFydGl0aW9uXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSB0aGlzLl9tbGVuOyBpIDwgbjsgKytpKSB7XG4gICAgICBwcm9jZXNzUGFydGl0aW9uKHRoaXMuX21vZHNbaV0sIHN0YXRlLCBjbXAsIF8pO1xuICAgIH1cbiAgICB0aGlzLl9tbGVuID0gMDtcbiAgICB0aGlzLl9tb2RzID0gW107XG5cbiAgICAvLyBUT0RPIGRvbid0IHJlZmxvdyBldmVyeXRoaW5nP1xuICAgIHJldHVybiBwdWxzZS5yZWZsb3cobW9kKS5tb2RpZmllcyhzdGF0ZS5vdXRwdXRzKTtcbiAgfSxcbiAgZ3JvdXAoa2V5KSB7XG4gICAgbGV0IGdyb3VwID0gdGhpcy52YWx1ZVtrZXldO1xuICAgIGlmICghZ3JvdXApIHtcbiAgICAgIGdyb3VwID0gdGhpcy52YWx1ZVtrZXldID0gU29ydGVkTGlzdCh0dXBsZWlkKTtcbiAgICAgIGdyb3VwLnN0YW1wID0gLTE7XG4gICAgfVxuICAgIGlmIChncm91cC5zdGFtcCA8IHRoaXMuc3RhbXApIHtcbiAgICAgIGdyb3VwLnN0YW1wID0gdGhpcy5zdGFtcDtcbiAgICAgIHRoaXMuX21vZHNbdGhpcy5fbWxlbisrXSA9IGdyb3VwO1xuICAgIH1cbiAgICByZXR1cm4gZ3JvdXA7XG4gIH1cbn0pO1xuZnVuY3Rpb24gcHJvY2Vzc1BhcnRpdGlvbihsaXN0LCBzdGF0ZSwgY21wLCBfKSB7XG4gIGNvbnN0IHNvcnQgPSBfLnNvcnQsXG4gICAgcmFuZ2UgPSBzb3J0ICYmICFfLmlnbm9yZVBlZXJzLFxuICAgIGZyYW1lID0gXy5mcmFtZSB8fCBbbnVsbCwgMF0sXG4gICAgZGF0YSA9IGxpc3QuZGF0YShjbXApLFxuICAgIC8vIHVzZSBjbXAgZm9yIHN0YWJsZSBzb3J0XG4gICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgIGIgPSByYW5nZSA/IGJpc2VjdG9yKHNvcnQpIDogbnVsbCxcbiAgICB3ID0ge1xuICAgICAgaTA6IDAsXG4gICAgICBpMTogMCxcbiAgICAgIHAwOiAwLFxuICAgICAgcDE6IDAsXG4gICAgICBpbmRleDogMCxcbiAgICAgIGRhdGE6IGRhdGEsXG4gICAgICBjb21wYXJlOiBzb3J0IHx8IGNvbnN0YW50KC0xKVxuICAgIH07XG4gIHN0YXRlLmluaXQoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBzZXRXaW5kb3codywgZnJhbWUsIGksIG4pO1xuICAgIGlmIChyYW5nZSkgYWRqdXN0UmFuZ2UodywgYik7XG4gICAgc3RhdGUudXBkYXRlKHcsIGRhdGFbaV0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRXaW5kb3codywgZiwgaSwgbikge1xuICB3LnAwID0gdy5pMDtcbiAgdy5wMSA9IHcuaTE7XG4gIHcuaTAgPSBmWzBdID09IG51bGwgPyAwIDogTWF0aC5tYXgoMCwgaSAtIE1hdGguYWJzKGZbMF0pKTtcbiAgdy5pMSA9IGZbMV0gPT0gbnVsbCA/IG4gOiBNYXRoLm1pbihuLCBpICsgTWF0aC5hYnMoZlsxXSkgKyAxKTtcbiAgdy5pbmRleCA9IGk7XG59XG5cbi8vIGlmIGZyYW1lIHR5cGUgaXMgJ3JhbmdlJywgYWRqdXN0IHdpbmRvdyBmb3IgcGVlciB2YWx1ZXNcbmZ1bmN0aW9uIGFkanVzdFJhbmdlKHcsIGJpc2VjdCkge1xuICBjb25zdCByMCA9IHcuaTAsXG4gICAgcjEgPSB3LmkxIC0gMSxcbiAgICBjID0gdy5jb21wYXJlLFxuICAgIGQgPSB3LmRhdGEsXG4gICAgbiA9IGQubGVuZ3RoIC0gMTtcbiAgaWYgKHIwID4gMCAmJiAhYyhkW3IwXSwgZFtyMCAtIDFdKSkgdy5pMCA9IGJpc2VjdC5sZWZ0KGQsIGRbcjBdKTtcbiAgaWYgKHIxIDwgbiAmJiAhYyhkW3IxXSwgZFtyMSArIDFdKSkgdy5pMSA9IGJpc2VjdC5yaWdodChkLCBkW3IxXSk7XG59XG5cbmV4cG9ydCB7IEFnZ3JlZ2F0ZSBhcyBhZ2dyZWdhdGUsIEJpbiBhcyBiaW4sIENvbGxlY3QgYXMgY29sbGVjdCwgQ29tcGFyZSBhcyBjb21wYXJlLCBDb3VudFBhdHRlcm4gYXMgY291bnRwYXR0ZXJuLCBDcm9zcyBhcyBjcm9zcywgRGVuc2l0eSBhcyBkZW5zaXR5LCBEb3RCaW4gYXMgZG90YmluLCBFeHByZXNzaW9uIGFzIGV4cHJlc3Npb24sIEV4dGVudCBhcyBleHRlbnQsIEZhY2V0IGFzIGZhY2V0LCBGaWVsZCBhcyBmaWVsZCwgRmlsdGVyIGFzIGZpbHRlciwgRmxhdHRlbiBhcyBmbGF0dGVuLCBGb2xkIGFzIGZvbGQsIEZvcm11bGEgYXMgZm9ybXVsYSwgR2VuZXJhdGUgYXMgZ2VuZXJhdGUsIEltcHV0ZSBhcyBpbXB1dGUsIEpvaW5BZ2dyZWdhdGUgYXMgam9pbmFnZ3JlZ2F0ZSwgS0RFIGFzIGtkZSwgS2V5IGFzIGtleSwgTG9hZCBhcyBsb2FkLCBMb29rdXAgYXMgbG9va3VwLCBNdWx0aUV4dGVudCBhcyBtdWx0aWV4dGVudCwgTXVsdGlWYWx1ZXMgYXMgbXVsdGl2YWx1ZXMsIFBhcmFtcyBhcyBwYXJhbXMsIFBpdm90IGFzIHBpdm90LCBQcmVGYWNldCBhcyBwcmVmYWNldCwgUHJvamVjdCBhcyBwcm9qZWN0LCBQcm94eSBhcyBwcm94eSwgUXVhbnRpbGUgYXMgcXVhbnRpbGUsIFJlbGF5IGFzIHJlbGF5LCBTYW1wbGUgYXMgc2FtcGxlLCBTZXF1ZW5jZSBhcyBzZXF1ZW5jZSwgU2lldmUgYXMgc2lldmUsIFN1YmZsb3cgYXMgc3ViZmxvdywgVGltZVVuaXQgYXMgdGltZXVuaXQsIFR1cGxlSW5kZXggYXMgdHVwbGVpbmRleCwgVmFsdWVzIGFzIHZhbHVlcywgV2luZG93IGFzIHdpbmRvdyB9O1xuIiwiaW1wb3J0IHsgVHJhbnNmb3JtIH0gZnJvbSAndmVnYS1kYXRhZmxvdyc7XG5pbXBvcnQgeyBNYXJrcywgYm91bmRDbGlwLCBHcm91cEl0ZW0sIEl0ZW0sIEJvdW5kcywgbXVsdGlMaW5lT2Zmc2V0LCBib3VuZFN0cm9rZSB9IGZyb20gJ3ZlZ2Etc2NlbmVncmFwaCc7XG5pbXBvcnQgeyBpbmhlcml0cywgcGVlaywgaXNPYmplY3QgfSBmcm9tICd2ZWdhLXV0aWwnO1xuXG5jb25zdCBUb3AgPSAndG9wJztcbmNvbnN0IExlZnQgPSAnbGVmdCc7XG5jb25zdCBSaWdodCA9ICdyaWdodCc7XG5jb25zdCBCb3R0b20gPSAnYm90dG9tJztcbmNvbnN0IFRvcExlZnQgPSAndG9wLWxlZnQnO1xuY29uc3QgVG9wUmlnaHQgPSAndG9wLXJpZ2h0JztcbmNvbnN0IEJvdHRvbUxlZnQgPSAnYm90dG9tLWxlZnQnO1xuY29uc3QgQm90dG9tUmlnaHQgPSAnYm90dG9tLXJpZ2h0JztcbmNvbnN0IFN0YXJ0ID0gJ3N0YXJ0JztcbmNvbnN0IE1pZGRsZSA9ICdtaWRkbGUnO1xuY29uc3QgRW5kID0gJ2VuZCc7XG5jb25zdCBYID0gJ3gnO1xuY29uc3QgWSA9ICd5JztcbmNvbnN0IEdyb3VwID0gJ2dyb3VwJztcbmNvbnN0IEF4aXNSb2xlID0gJ2F4aXMnO1xuY29uc3QgVGl0bGVSb2xlID0gJ3RpdGxlJztcbmNvbnN0IEZyYW1lUm9sZSA9ICdmcmFtZSc7XG5jb25zdCBTY29wZVJvbGUgPSAnc2NvcGUnO1xuY29uc3QgTGVnZW5kUm9sZSA9ICdsZWdlbmQnO1xuY29uc3QgUm93SGVhZGVyID0gJ3Jvdy1oZWFkZXInO1xuY29uc3QgUm93Rm9vdGVyID0gJ3Jvdy1mb290ZXInO1xuY29uc3QgUm93VGl0bGUgPSAncm93LXRpdGxlJztcbmNvbnN0IENvbEhlYWRlciA9ICdjb2x1bW4taGVhZGVyJztcbmNvbnN0IENvbEZvb3RlciA9ICdjb2x1bW4tZm9vdGVyJztcbmNvbnN0IENvbFRpdGxlID0gJ2NvbHVtbi10aXRsZSc7XG5jb25zdCBQYWRkaW5nID0gJ3BhZGRpbmcnO1xuY29uc3QgU3ltYm9scyA9ICdzeW1ib2wnO1xuY29uc3QgRml0ID0gJ2ZpdCc7XG5jb25zdCBGaXRYID0gJ2ZpdC14JztcbmNvbnN0IEZpdFkgPSAnZml0LXknO1xuY29uc3QgUGFkID0gJ3BhZCc7XG5jb25zdCBOb25lID0gJ25vbmUnO1xuY29uc3QgQWxsID0gJ2FsbCc7XG5jb25zdCBFYWNoID0gJ2VhY2gnO1xuY29uc3QgRmx1c2ggPSAnZmx1c2gnO1xuY29uc3QgQ29sdW1uID0gJ2NvbHVtbic7XG5jb25zdCBSb3cgPSAncm93JztcblxuLyoqXG4gKiBDYWxjdWxhdGUgYm91bmRpbmcgYm94ZXMgZm9yIHNjZW5lZ3JhcGggaXRlbXMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFyayAtIFRoZSBzY2VuZWdyYXBoIG1hcmsgaW5zdGFuY2UgdG8gYm91bmQuXG4gKi9cbmZ1bmN0aW9uIEJvdW5kKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoQm91bmQsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCB2aWV3ID0gcHVsc2UuZGF0YWZsb3csXG4gICAgICBtYXJrID0gXy5tYXJrLFxuICAgICAgdHlwZSA9IG1hcmsubWFya3R5cGUsXG4gICAgICBlbnRyeSA9IE1hcmtzW3R5cGVdLFxuICAgICAgYm91bmQgPSBlbnRyeS5ib3VuZDtcbiAgICBsZXQgbWFya0JvdW5kcyA9IG1hcmsuYm91bmRzLFxuICAgICAgcmVib3VuZDtcbiAgICBpZiAoZW50cnkubmVzdGVkKSB7XG4gICAgICAvLyBtdWx0aS1pdGVtIG1hcmtzIGhhdmUgYSBzaW5nbGUgYm91bmRzIGluc3RhbmNlXG4gICAgICBpZiAobWFyay5pdGVtcy5sZW5ndGgpIHZpZXcuZGlydHkobWFyay5pdGVtc1swXSk7XG4gICAgICBtYXJrQm91bmRzID0gYm91bmRJdGVtKG1hcmssIGJvdW5kKTtcbiAgICAgIG1hcmsuaXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgaXRlbS5ib3VuZHMuY2xlYXIoKS51bmlvbihtYXJrQm91bmRzKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gR3JvdXAgfHwgXy5tb2RpZmllZCgpKSB7XG4gICAgICAvLyBvcGVyYXRvciBwYXJhbWV0ZXJzIG1vZGlmaWVkIC0+IHJlLWJvdW5kIGFsbCBpdGVtc1xuICAgICAgLy8gdXBkYXRlcyBncm91cCBib3VuZHMgaW4gcmVzcG9uc2UgdG8gbW9kaWZpZWQgZ3JvdXAgY29udGVudFxuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCBpdGVtID0+IHZpZXcuZGlydHkoaXRlbSkpO1xuICAgICAgbWFya0JvdW5kcy5jbGVhcigpO1xuICAgICAgbWFyay5pdGVtcy5mb3JFYWNoKGl0ZW0gPT4gbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKSk7XG5cbiAgICAgIC8vIGZvcmNlIHJlZmxvdyBmb3IgYXhlcy9sZWdlbmRzL3RpdGxlcyB0byBwcm9wYWdhdGUgYW55IGxheW91dCBjaGFuZ2VzXG4gICAgICBzd2l0Y2ggKG1hcmsucm9sZSkge1xuICAgICAgICBjYXNlIEF4aXNSb2xlOlxuICAgICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGNhc2UgVGl0bGVSb2xlOlxuICAgICAgICAgIHB1bHNlLnJlZmxvdygpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBpbmNyZW1lbnRhbGx5IHVwZGF0ZSBib3VuZHMsIHJlLWJvdW5kIG1hcmsgYXMgbmVlZGVkXG4gICAgICByZWJvdW5kID0gcHVsc2UuY2hhbmdlZChwdWxzZS5SRU0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuQURELCBpdGVtID0+IHtcbiAgICAgICAgbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKTtcbiAgICAgIH0pO1xuICAgICAgcHVsc2UudmlzaXQocHVsc2UuTU9ELCBpdGVtID0+IHtcbiAgICAgICAgcmVib3VuZCA9IHJlYm91bmQgfHwgbWFya0JvdW5kcy5hbGlnbnNXaXRoKGl0ZW0uYm91bmRzKTtcbiAgICAgICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgICAgICAgbWFya0JvdW5kcy51bmlvbihib3VuZEl0ZW0oaXRlbSwgYm91bmQpKTtcbiAgICAgIH0pO1xuICAgICAgaWYgKHJlYm91bmQpIHtcbiAgICAgICAgbWFya0JvdW5kcy5jbGVhcigpO1xuICAgICAgICBtYXJrLml0ZW1zLmZvckVhY2goaXRlbSA9PiBtYXJrQm91bmRzLnVuaW9uKGl0ZW0uYm91bmRzKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIG1hcmsgYm91bmRzIGRvIG5vdCBleGNlZWQgYW55IGNsaXBwaW5nIHJlZ2lvblxuICAgIGJvdW5kQ2xpcChtYXJrKTtcbiAgICByZXR1cm4gcHVsc2UubW9kaWZpZXMoJ2JvdW5kcycpO1xuICB9XG59KTtcbmZ1bmN0aW9uIGJvdW5kSXRlbShpdGVtLCBib3VuZCwgb3B0KSB7XG4gIHJldHVybiBib3VuZChpdGVtLmJvdW5kcy5jbGVhcigpLCBpdGVtLCBvcHQpO1xufVxuXG5jb25zdCBDT1VOVEVSX05BTUUgPSAnOnZlZ2FfaWRlbnRpZmllcjonO1xuXG4vKipcbiAqIEFkZHMgYSB1bmlxdWUgaWRlbnRpZmllciB0byBhbGwgYWRkZWQgdHVwbGVzLlxuICogVGhpcyB0cmFuc2Zvcm0gY3JlYXRlcyBhIG5ldyBzaWduYWwgdGhhdCBzZXJ2ZXMgYXMgYW4gaWQgY291bnRlci5cbiAqIEFzIGEgcmVzdWx0LCB0aGUgaWQgY291bnRlciBpcyBzaGFyZWQgYWNyb3NzIGFsbCBpbnN0YW5jZXMgb2YgdGhpc1xuICogdHJhbnNmb3JtLCBnZW5lcmF0aW5nIHVuaXF1ZSBpZHMgYWNyb3NzIG11bHRpcGxlIGRhdGEgc3RyZWFtcy4gSW5cbiAqIGFkZGl0aW9uLCB0aGlzIHNpZ25hbCB2YWx1ZSBjYW4gYmUgaW5jbHVkZWQgaW4gYSBzbmFwc2hvdCBvZiB0aGVcbiAqIGRhdGFmbG93IHN0YXRlLCBlbmFibGluZyBjb3JyZWN0IHJlc3VtcHRpb24gb2YgaWQgYWxsb2NhdGlvbi5cbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGlzIG9wZXJhdG9yLlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5hcyAtIFRoZSBmaWVsZCBuYW1lIGZvciB0aGUgZ2VuZXJhdGVkIGlkZW50aWZpZXIuXG4gKi9cbmZ1bmN0aW9uIElkZW50aWZpZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIDAsIHBhcmFtcyk7XG59XG5JZGVudGlmaWVyLkRlZmluaXRpb24gPSB7XG4gICd0eXBlJzogJ0lkZW50aWZpZXInLFxuICAnbWV0YWRhdGEnOiB7XG4gICAgJ21vZGlmaWVzJzogdHJ1ZVxuICB9LFxuICAncGFyYW1zJzogW3tcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH1dXG59O1xuaW5oZXJpdHMoSWRlbnRpZmllciwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGNvdW50ZXIgPSBnZXRDb3VudGVyKHB1bHNlLmRhdGFmbG93KSxcbiAgICAgIGFzID0gXy5hcztcbiAgICBsZXQgaWQgPSBjb3VudGVyLnZhbHVlO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgdCA9PiB0W2FzXSA9IHRbYXNdIHx8ICsraWQpO1xuICAgIGNvdW50ZXIuc2V0KHRoaXMudmFsdWUgPSBpZCk7XG4gICAgcmV0dXJuIHB1bHNlO1xuICB9XG59KTtcbmZ1bmN0aW9uIGdldENvdW50ZXIodmlldykge1xuICByZXR1cm4gdmlldy5fc2lnbmFsc1tDT1VOVEVSX05BTUVdIHx8ICh2aWV3Ll9zaWduYWxzW0NPVU5URVJfTkFNRV0gPSB2aWV3LmFkZCgwKSk7XG59XG5cbi8qKlxuICogQmluZCBzY2VuZWdyYXBoIGl0ZW1zIHRvIGEgc2NlbmVncmFwaCBtYXJrIGluc3RhbmNlLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zLm1hcmtkZWYgLSBUaGUgbWFyayBkZWZpbml0aW9uIGZvciBjcmVhdGluZyB0aGUgbWFyay5cbiAqICAgVGhpcyBpcyBhbiBvYmplY3Qgb2YgbGVnYWwgc2NlbmVncmFwaCBtYXJrIHByb3BlcnRpZXMgd2hpY2ggKm11c3QqIGluY2x1ZGVcbiAqICAgdGhlICdtYXJrdHlwZScgcHJvcGVydHkuXG4gKi9cbmZ1bmN0aW9uIE1hcmsocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhNYXJrLCBUcmFuc2Zvcm0sIHtcbiAgdHJhbnNmb3JtKF8sIHB1bHNlKSB7XG4gICAgbGV0IG1hcmsgPSB0aGlzLnZhbHVlO1xuXG4gICAgLy8gYWNxdWlyZSBtYXJrIG9uIGZpcnN0IGludm9jYXRpb24sIGJpbmQgY29udGV4dCBhbmQgZ3JvdXBcbiAgICBpZiAoIW1hcmspIHtcbiAgICAgIG1hcmsgPSBwdWxzZS5kYXRhZmxvdy5zY2VuZWdyYXBoKCkubWFyayhfLm1hcmtkZWYsIGxvb2t1cCQxKF8pLCBfLmluZGV4KTtcbiAgICAgIG1hcmsuZ3JvdXAuY29udGV4dCA9IF8uY29udGV4dDtcbiAgICAgIGlmICghXy5jb250ZXh0Lmdyb3VwKSBfLmNvbnRleHQuZ3JvdXAgPSBtYXJrLmdyb3VwO1xuICAgICAgbWFyay5zb3VyY2UgPSB0aGlzLnNvdXJjZTsgLy8gcG9pbnQgdG8gdXBzdHJlYW0gY29sbGVjdG9yXG4gICAgICBtYXJrLmNsaXAgPSBfLmNsaXA7XG4gICAgICBtYXJrLmludGVyYWN0aXZlID0gXy5pbnRlcmFjdGl2ZTtcbiAgICAgIHRoaXMudmFsdWUgPSBtYXJrO1xuICAgIH1cblxuICAgIC8vIGluaXRpYWxpemUgZW50ZXJpbmcgaXRlbXNcbiAgICBjb25zdCBJbml0ID0gbWFyay5tYXJrdHlwZSA9PT0gR3JvdXAgPyBHcm91cEl0ZW0gOiBJdGVtO1xuICAgIHB1bHNlLnZpc2l0KHB1bHNlLkFERCwgaXRlbSA9PiBJbml0LmNhbGwoaXRlbSwgbWFyaykpO1xuXG4gICAgLy8gdXBkYXRlIGNsaXBwaW5nIGFuZC9vciBpbnRlcmFjdGl2ZSBzdGF0dXNcbiAgICBpZiAoXy5tb2RpZmllZCgnY2xpcCcpIHx8IF8ubW9kaWZpZWQoJ2ludGVyYWN0aXZlJykpIHtcbiAgICAgIG1hcmsuY2xpcCA9IF8uY2xpcDtcbiAgICAgIG1hcmsuaW50ZXJhY3RpdmUgPSAhIV8uaW50ZXJhY3RpdmU7XG4gICAgICBtYXJrLnpkaXJ0eSA9IHRydWU7IC8vIGZvcmNlIHNjZW5lZ3JhcGggcmUtZXZhbFxuICAgICAgcHVsc2UucmVmbG93KCk7XG4gICAgfVxuXG4gICAgLy8gYmluZCBpdGVtcyBhcnJheSB0byBzY2VuZWdyYXBoIG1hcmtcbiAgICBtYXJrLml0ZW1zID0gcHVsc2Uuc291cmNlO1xuICAgIHJldHVybiBwdWxzZTtcbiAgfVxufSk7XG5mdW5jdGlvbiBsb29rdXAkMShfKSB7XG4gIGNvbnN0IGcgPSBfLmdyb3VwcyxcbiAgICBwID0gXy5wYXJlbnQ7XG4gIHJldHVybiBnICYmIGcuc2l6ZSA9PT0gMSA/IGcuZ2V0KE9iamVjdC5rZXlzKGcub2JqZWN0KVswXSkgOiBnICYmIHAgPyBnLmxvb2t1cChwKSA6IG51bGw7XG59XG5cbi8qKlxuICogQW5hbHl6ZSBpdGVtcyBmb3Igb3ZlcmxhcCwgY2hhbmdpbmcgb3BhY2l0eSB0byBoaWRlIGl0ZW1zIHdpdGhcbiAqIG92ZXJsYXBwaW5nIGJvdW5kaW5nIGJveGVzLiBUaGlzIHRyYW5zZm9ybSB3aWxsIHByZXNlcnZlIGF0IGxlYXN0XG4gKiB0d28gaXRlbXMgKGUuZy4sIGZpcnN0IGFuZCBsYXN0KSBldmVuIGlmIG92ZXJsYXAgcGVyc2lzdHMuXG4gKiBAcGFyYW0ge29iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIHRoaXMgb3BlcmF0b3IuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosKik6IG51bWJlcn0gW3BhcmFtcy5zb3J0XSAtIEEgY29tcGFyYXRvclxuICogICBmdW5jdGlvbiBmb3Igc29ydGluZyBpdGVtcy5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLm1ldGhvZF0gLSBUaGUgb3ZlcmxhcCByZW1vdmFsIG1ldGhvZCB0byBhcHBseS5cbiAqICAgT25lIG9mICdwYXJpdHknIChkZWZhdWx0LCBoaWRlIGV2ZXJ5IG90aGVyIGl0ZW0gdW50aWwgdGhlcmUgaXMgbm9cbiAqICAgbW9yZSBvdmVybGFwKSBvciAnZ3JlZWR5JyAoc2VxdWVudGlhbGx5IHNjYW4gYW5kIGhpZGUgYW5kIGl0ZW1zIHRoYXRcbiAqICAgb3ZlcmxhcCB3aXRoIHRoZSBsYXN0IHZpc2libGUgaXRlbSkuXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtcy5ib3VuZFNjYWxlXSAtIEEgc2NhbGUgd2hvc2UgcmFuZ2Ugc2hvdWxkIGJlIHVzZWRcbiAqICAgdG8gYm91bmQgdGhlIGl0ZW1zLiBJdGVtcyBleGNlZWRpbmcgdGhlIGJvdW5kcyBvZiB0aGUgc2NhbGUgcmFuZ2VcbiAqICAgd2lsbCBiZSB0cmVhdGVkIGFzIG92ZXJsYXBwaW5nLiBJZiBudWxsIG9yIHVuZGVmaW5lZCwgbm8gYm91bmRzIGNoZWNrXG4gKiAgIHdpbGwgYmUgYXBwbGllZC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zLmJvdW5kT3JpZW50XSAtIFRoZSBvcmllbnRhdGlvbiBvZiB0aGUgc2NhbGVcbiAqICAgKHRvcCwgYm90dG9tLCBsZWZ0LCBvciByaWdodCkgdXNlZCB0byBib3VuZCBpdGVtcy4gVGhpcyBwYXJhbWV0ZXIgaXNcbiAqICAgaWdub3JlZCBpZiBib3VuZFNjYWxlIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxuICogQHBhcmFtIHtvYmplY3R9IFtwYXJhbXMuYm91bmRUb2xlcmFuY2VdIC0gVGhlIHRvbGVyYW5jZSBpbiBwaXhlbHMgZm9yXG4gKiAgIGJvdW5kIGluY2x1c2lvbiB0ZXN0aW5nIChkZWZhdWx0IDEpLiBUaGlzIHNwZWNpZmllcyBieSBob3cgbWFueSBwaXhlbHNcbiAqICAgYW4gaXRlbSdzIGJvdW5kcyBtYXkgZXhjZWVkIHRoZSBzY2FsZSByYW5nZSBib3VuZHMgYW5kIG5vdCBiZSBjdWxsZWQuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gT3ZlcmxhcChwYXJhbXMpIHtcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgbnVsbCwgcGFyYW1zKTtcbn1cbmNvbnN0IG1ldGhvZHMgPSB7XG4gIHBhcml0eTogaXRlbXMgPT4gaXRlbXMuZmlsdGVyKChpdGVtLCBpKSA9PiBpICUgMiA/IGl0ZW0ub3BhY2l0eSA9IDAgOiAxKSxcbiAgZ3JlZWR5OiAoaXRlbXMsIHNlcCkgPT4ge1xuICAgIGxldCBhO1xuICAgIHJldHVybiBpdGVtcy5maWx0ZXIoKGIsIGkpID0+ICFpIHx8ICFpbnRlcnNlY3QoYS5ib3VuZHMsIGIuYm91bmRzLCBzZXApID8gKGEgPSBiLCAxKSA6IGIub3BhY2l0eSA9IDApO1xuICB9XG59O1xuXG4vLyBjb21wdXRlIGJvdW5kaW5nIGJveCBpbnRlcnNlY3Rpb25cbi8vIGluY2x1ZGluZyBwYWRkaW5nIHBpeGVscyBvZiBzZXBhcmF0aW9uXG5jb25zdCBpbnRlcnNlY3QgPSAoYSwgYiwgc2VwKSA9PiBzZXAgPiBNYXRoLm1heChiLngxIC0gYS54MiwgYS54MSAtIGIueDIsIGIueTEgLSBhLnkyLCBhLnkxIC0gYi55Mik7XG5jb25zdCBoYXNPdmVybGFwID0gKGl0ZW1zLCBwYWQpID0+IHtcbiAgZm9yICh2YXIgaSA9IDEsIG4gPSBpdGVtcy5sZW5ndGgsIGEgPSBpdGVtc1swXS5ib3VuZHMsIGI7IGkgPCBuOyBhID0gYiwgKytpKSB7XG4gICAgaWYgKGludGVyc2VjdChhLCBiID0gaXRlbXNbaV0uYm91bmRzLCBwYWQpKSByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbmNvbnN0IGhhc0JvdW5kcyA9IGl0ZW0gPT4ge1xuICBjb25zdCBiID0gaXRlbS5ib3VuZHM7XG4gIHJldHVybiBiLndpZHRoKCkgPiAxICYmIGIuaGVpZ2h0KCkgPiAxO1xufTtcbmNvbnN0IGJvdW5kVGVzdCA9IChzY2FsZSwgb3JpZW50LCB0b2xlcmFuY2UpID0+IHtcbiAgdmFyIHJhbmdlID0gc2NhbGUucmFuZ2UoKSxcbiAgICBiID0gbmV3IEJvdW5kcygpO1xuICBpZiAob3JpZW50ID09PSBUb3AgfHwgb3JpZW50ID09PSBCb3R0b20pIHtcbiAgICBiLnNldChyYW5nZVswXSwgLUluZmluaXR5LCByYW5nZVsxXSwgK0luZmluaXR5KTtcbiAgfSBlbHNlIHtcbiAgICBiLnNldCgtSW5maW5pdHksIHJhbmdlWzBdLCArSW5maW5pdHksIHJhbmdlWzFdKTtcbiAgfVxuICBiLmV4cGFuZCh0b2xlcmFuY2UgfHwgMSk7XG4gIHJldHVybiBpdGVtID0+IGIuZW5jbG9zZXMoaXRlbS5ib3VuZHMpO1xufTtcblxuLy8gcmVzZXQgYWxsIGl0ZW1zIHRvIGJlIGZ1bGx5IG9wYXF1ZVxuY29uc3QgcmVzZXQgPSBzb3VyY2UgPT4ge1xuICBzb3VyY2UuZm9yRWFjaChpdGVtID0+IGl0ZW0ub3BhY2l0eSA9IDEpO1xuICByZXR1cm4gc291cmNlO1xufTtcblxuLy8gYWRkIGFsbCB0dXBsZXMgdG8gbW9kLCBmb3JrIHB1bHNlIGlmIHBhcmFtZXRlcnMgd2VyZSBtb2RpZmllZFxuLy8gZm9yayBwcmV2ZW50cyBjcm9zcy1zdHJlYW0gdHVwbGUgcG9sbHV0aW9uIChlLmcuLCBwdWxzZSBmcm9tIHNjYWxlKVxuY29uc3QgcmVmbG93ID0gKHB1bHNlLCBfKSA9PiBwdWxzZS5yZWZsb3coXy5tb2RpZmllZCgpKS5tb2RpZmllcygnb3BhY2l0eScpO1xuaW5oZXJpdHMoT3ZlcmxhcCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHJlZHVjZSA9IG1ldGhvZHNbXy5tZXRob2RdIHx8IG1ldGhvZHMucGFyaXR5LFxuICAgICAgc2VwID0gXy5zZXBhcmF0aW9uIHx8IDA7XG4gICAgbGV0IHNvdXJjZSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgaXRlbXMsXG4gICAgICB0ZXN0O1xuICAgIGlmICghc291cmNlIHx8ICFzb3VyY2UubGVuZ3RoKSByZXR1cm47XG4gICAgaWYgKCFfLm1ldGhvZCkge1xuICAgICAgLy8gZWFybHkgZXhpdCBpZiBtZXRob2QgaXMgZmFsc3lcbiAgICAgIGlmIChfLm1vZGlmaWVkKCdtZXRob2QnKSkge1xuICAgICAgICByZXNldChzb3VyY2UpO1xuICAgICAgICBwdWxzZSA9IHJlZmxvdyhwdWxzZSwgXyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHVsc2U7XG4gICAgfVxuXG4gICAgLy8gc2tpcCBsYWJlbHMgd2l0aCBubyBjb250ZW50XG4gICAgc291cmNlID0gc291cmNlLmZpbHRlcihoYXNCb3VuZHMpO1xuXG4gICAgLy8gZWFybHkgZXhpdCwgbm90aGluZyB0byBkb1xuICAgIGlmICghc291cmNlLmxlbmd0aCkgcmV0dXJuO1xuICAgIGlmIChfLnNvcnQpIHtcbiAgICAgIHNvdXJjZSA9IHNvdXJjZS5zbGljZSgpLnNvcnQoXy5zb3J0KTtcbiAgICB9XG4gICAgaXRlbXMgPSByZXNldChzb3VyY2UpO1xuICAgIHB1bHNlID0gcmVmbG93KHB1bHNlLCBfKTtcbiAgICBpZiAoaXRlbXMubGVuZ3RoID49IDMgJiYgaGFzT3ZlcmxhcChpdGVtcywgc2VwKSkge1xuICAgICAgZG8ge1xuICAgICAgICBpdGVtcyA9IHJlZHVjZShpdGVtcywgc2VwKTtcbiAgICAgIH0gd2hpbGUgKGl0ZW1zLmxlbmd0aCA+PSAzICYmIGhhc092ZXJsYXAoaXRlbXMsIHNlcCkpO1xuICAgICAgaWYgKGl0ZW1zLmxlbmd0aCA8IDMgJiYgIXBlZWsoc291cmNlKS5vcGFjaXR5KSB7XG4gICAgICAgIGlmIChpdGVtcy5sZW5ndGggPiAxKSBwZWVrKGl0ZW1zKS5vcGFjaXR5ID0gMDtcbiAgICAgICAgcGVlayhzb3VyY2UpLm9wYWNpdHkgPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoXy5ib3VuZFNjYWxlICYmIF8uYm91bmRUb2xlcmFuY2UgPj0gMCkge1xuICAgICAgdGVzdCA9IGJvdW5kVGVzdChfLmJvdW5kU2NhbGUsIF8uYm91bmRPcmllbnQsICtfLmJvdW5kVG9sZXJhbmNlKTtcbiAgICAgIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICBpZiAoIXRlc3QoaXRlbSkpIGl0ZW0ub3BhY2l0eSA9IDA7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyByZS1jYWxjdWxhdGUgbWFyayBib3VuZHNcbiAgICBjb25zdCBib3VuZHMgPSBpdGVtc1swXS5tYXJrLmJvdW5kcy5jbGVhcigpO1xuICAgIHNvdXJjZS5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgaWYgKGl0ZW0ub3BhY2l0eSkgYm91bmRzLnVuaW9uKGl0ZW0uYm91bmRzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHVsc2U7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFF1ZXVlIG1vZGlmaWVkIHNjZW5lZ3JhcGggaXRlbXMgZm9yIHJlbmRlcmluZy5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZW5kZXIocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG51bGwsIHBhcmFtcyk7XG59XG5pbmhlcml0cyhSZW5kZXIsIFRyYW5zZm9ybSwge1xuICB0cmFuc2Zvcm0oXywgcHVsc2UpIHtcbiAgICBjb25zdCB2aWV3ID0gcHVsc2UuZGF0YWZsb3c7XG4gICAgcHVsc2UudmlzaXQocHVsc2UuQUxMLCBpdGVtID0+IHZpZXcuZGlydHkoaXRlbSkpO1xuXG4gICAgLy8gc2V0IHotaW5kZXggZGlydHkgZmxhZyBhcyBuZWVkZWRcbiAgICBpZiAocHVsc2UuZmllbGRzICYmIHB1bHNlLmZpZWxkc1snemluZGV4J10pIHtcbiAgICAgIGNvbnN0IGl0ZW0gPSBwdWxzZS5zb3VyY2UgJiYgcHVsc2Uuc291cmNlWzBdO1xuICAgICAgaWYgKGl0ZW0pIGl0ZW0ubWFyay56ZGlydHkgPSB0cnVlO1xuICAgIH1cbiAgfVxufSk7XG5cbmNvbnN0IHRlbXBCb3VuZHMgPSBuZXcgQm91bmRzKCk7XG5mdW5jdGlvbiBzZXQoaXRlbSwgcHJvcGVydHksIHZhbHVlKSB7XG4gIHJldHVybiBpdGVtW3Byb3BlcnR5XSA9PT0gdmFsdWUgPyAwIDogKGl0ZW1bcHJvcGVydHldID0gdmFsdWUsIDEpO1xufVxuXG5mdW5jdGlvbiBpc1lBeGlzKG1hcmspIHtcbiAgdmFyIG9yaWVudCA9IG1hcmsuaXRlbXNbMF0ub3JpZW50O1xuICByZXR1cm4gb3JpZW50ID09PSBMZWZ0IHx8IG9yaWVudCA9PT0gUmlnaHQ7XG59XG5mdW5jdGlvbiBheGlzSW5kaWNlcyhkYXR1bSkge1xuICBsZXQgaW5kZXggPSArZGF0dW0uZ3JpZDtcbiAgcmV0dXJuIFtkYXR1bS50aWNrcyA/IGluZGV4KysgOiAtMSxcbiAgLy8gdGlja3MgaW5kZXhcbiAgZGF0dW0ubGFiZWxzID8gaW5kZXgrKyA6IC0xLFxuICAvLyBsYWJlbHMgaW5kZXhcbiAgaW5kZXggKyArZGF0dW0uZG9tYWluIC8vIHRpdGxlIGluZGV4XG4gIF07XG59XG5mdW5jdGlvbiBheGlzTGF5b3V0KHZpZXcsIGF4aXMsIHdpZHRoLCBoZWlnaHQpIHtcbiAgdmFyIGl0ZW0gPSBheGlzLml0ZW1zWzBdLFxuICAgIGRhdHVtID0gaXRlbS5kYXR1bSxcbiAgICBkZWx0YSA9IGl0ZW0udHJhbnNsYXRlICE9IG51bGwgPyBpdGVtLnRyYW5zbGF0ZSA6IDAuNSxcbiAgICBvcmllbnQgPSBpdGVtLm9yaWVudCxcbiAgICBpbmRpY2VzID0gYXhpc0luZGljZXMoZGF0dW0pLFxuICAgIHJhbmdlID0gaXRlbS5yYW5nZSxcbiAgICBvZmZzZXQgPSBpdGVtLm9mZnNldCxcbiAgICBwb3NpdGlvbiA9IGl0ZW0ucG9zaXRpb24sXG4gICAgbWluRXh0ZW50ID0gaXRlbS5taW5FeHRlbnQsXG4gICAgbWF4RXh0ZW50ID0gaXRlbS5tYXhFeHRlbnQsXG4gICAgdGl0bGUgPSBkYXR1bS50aXRsZSAmJiBpdGVtLml0ZW1zW2luZGljZXNbMl1dLml0ZW1zWzBdLFxuICAgIHRpdGxlUGFkZGluZyA9IGl0ZW0udGl0bGVQYWRkaW5nLFxuICAgIGJvdW5kcyA9IGl0ZW0uYm91bmRzLFxuICAgIGRsID0gdGl0bGUgJiYgbXVsdGlMaW5lT2Zmc2V0KHRpdGxlKSxcbiAgICB4ID0gMCxcbiAgICB5ID0gMCxcbiAgICBpLFxuICAgIHM7XG4gIHRlbXBCb3VuZHMuY2xlYXIoKS51bmlvbihib3VuZHMpO1xuICBib3VuZHMuY2xlYXIoKTtcbiAgaWYgKChpID0gaW5kaWNlc1swXSkgPiAtMSkgYm91bmRzLnVuaW9uKGl0ZW0uaXRlbXNbaV0uYm91bmRzKTtcbiAgaWYgKChpID0gaW5kaWNlc1sxXSkgPiAtMSkgYm91bmRzLnVuaW9uKGl0ZW0uaXRlbXNbaV0uYm91bmRzKTtcblxuICAvLyBwb3NpdGlvbiBheGlzIGdyb3VwIGFuZCB0aXRsZVxuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgVG9wOlxuICAgICAgeCA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICB5ID0gLW9mZnNldDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgLWJvdW5kcy55MSkpO1xuICAgICAgYm91bmRzLmFkZCgwLCAtcykuYWRkKHJhbmdlLCAwKTtcbiAgICAgIGlmICh0aXRsZSkgYXhpc1RpdGxlTGF5b3V0KHZpZXcsIHRpdGxlLCBzLCB0aXRsZVBhZGRpbmcsIGRsLCAwLCAtMSwgYm91bmRzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTGVmdDpcbiAgICAgIHggPSAtb2Zmc2V0O1xuICAgICAgeSA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICBzID0gTWF0aC5tYXgobWluRXh0ZW50LCBNYXRoLm1pbihtYXhFeHRlbnQsIC1ib3VuZHMueDEpKTtcbiAgICAgIGJvdW5kcy5hZGQoLXMsIDApLmFkZCgwLCByYW5nZSk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCBkbCwgMSwgLTEsIGJvdW5kcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJpZ2h0OlxuICAgICAgeCA9IHdpZHRoICsgb2Zmc2V0O1xuICAgICAgeSA9IHBvc2l0aW9uIHx8IDA7XG4gICAgICBzID0gTWF0aC5tYXgobWluRXh0ZW50LCBNYXRoLm1pbihtYXhFeHRlbnQsIGJvdW5kcy54MikpO1xuICAgICAgYm91bmRzLmFkZCgwLCAwKS5hZGQocywgcmFuZ2UpO1xuICAgICAgaWYgKHRpdGxlKSBheGlzVGl0bGVMYXlvdXQodmlldywgdGl0bGUsIHMsIHRpdGxlUGFkZGluZywgZGwsIDEsIDEsIGJvdW5kcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJvdHRvbTpcbiAgICAgIHggPSBwb3NpdGlvbiB8fCAwO1xuICAgICAgeSA9IGhlaWdodCArIG9mZnNldDtcbiAgICAgIHMgPSBNYXRoLm1heChtaW5FeHRlbnQsIE1hdGgubWluKG1heEV4dGVudCwgYm91bmRzLnkyKSk7XG4gICAgICBib3VuZHMuYWRkKDAsIDApLmFkZChyYW5nZSwgcyk7XG4gICAgICBpZiAodGl0bGUpIGF4aXNUaXRsZUxheW91dCh2aWV3LCB0aXRsZSwgcywgdGl0bGVQYWRkaW5nLCAwLCAwLCAxLCBib3VuZHMpO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHggPSBpdGVtLng7XG4gICAgICB5ID0gaXRlbS55O1xuICB9XG5cbiAgLy8gdXBkYXRlIGJvdW5kc1xuICBib3VuZFN0cm9rZShib3VuZHMudHJhbnNsYXRlKHgsIHkpLCBpdGVtKTtcbiAgaWYgKHNldChpdGVtLCAneCcsIHggKyBkZWx0YSkgfCBzZXQoaXRlbSwgJ3knLCB5ICsgZGVsdGEpKSB7XG4gICAgaXRlbS5ib3VuZHMgPSB0ZW1wQm91bmRzO1xuICAgIHZpZXcuZGlydHkoaXRlbSk7XG4gICAgaXRlbS5ib3VuZHMgPSBib3VuZHM7XG4gICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgfVxuICByZXR1cm4gaXRlbS5tYXJrLmJvdW5kcy5jbGVhcigpLnVuaW9uKGJvdW5kcyk7XG59XG5mdW5jdGlvbiBheGlzVGl0bGVMYXlvdXQodmlldywgdGl0bGUsIG9mZnNldCwgcGFkLCBkbCwgaXNZQXhpcywgc2lnbiwgYm91bmRzKSB7XG4gIGNvbnN0IGIgPSB0aXRsZS5ib3VuZHM7XG4gIGlmICh0aXRsZS5hdXRvKSB7XG4gICAgY29uc3QgdiA9IHNpZ24gKiAob2Zmc2V0ICsgZGwgKyBwYWQpO1xuICAgIGxldCBkeCA9IDAsXG4gICAgICBkeSA9IDA7XG4gICAgdmlldy5kaXJ0eSh0aXRsZSk7XG4gICAgaXNZQXhpcyA/IGR4ID0gKHRpdGxlLnggfHwgMCkgLSAodGl0bGUueCA9IHYpIDogZHkgPSAodGl0bGUueSB8fCAwKSAtICh0aXRsZS55ID0gdik7XG4gICAgdGl0bGUubWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbihiLnRyYW5zbGF0ZSgtZHgsIC1keSkpO1xuICAgIHZpZXcuZGlydHkodGl0bGUpO1xuICB9XG4gIGJvdW5kcy51bmlvbihiKTtcbn1cblxuLy8gYWdncmVnYXRpb24gZnVuY3Rpb25zIGZvciBncmlkIG1hcmdpbiBkZXRlcm1pbmF0aW9uXG5jb25zdCBtaW4gPSAoYSwgYikgPT4gTWF0aC5mbG9vcihNYXRoLm1pbihhLCBiKSk7XG5jb25zdCBtYXggPSAoYSwgYikgPT4gTWF0aC5jZWlsKE1hdGgubWF4KGEsIGIpKTtcbmZ1bmN0aW9uIGdyaWRMYXlvdXRHcm91cHMoZ3JvdXApIHtcbiAgdmFyIGdyb3VwcyA9IGdyb3VwLml0ZW1zLFxuICAgIG4gPSBncm91cHMubGVuZ3RoLFxuICAgIGkgPSAwLFxuICAgIG1hcmssXG4gICAgaXRlbXM7XG4gIGNvbnN0IHZpZXdzID0ge1xuICAgIG1hcmtzOiBbXSxcbiAgICByb3doZWFkZXJzOiBbXSxcbiAgICByb3dmb290ZXJzOiBbXSxcbiAgICBjb2xoZWFkZXJzOiBbXSxcbiAgICBjb2xmb290ZXJzOiBbXSxcbiAgICByb3d0aXRsZTogbnVsbCxcbiAgICBjb2x0aXRsZTogbnVsbFxuICB9O1xuXG4gIC8vIGxheW91dCBheGVzLCBnYXRoZXIgbGVnZW5kcywgY29sbGVjdCBib3VuZHNcbiAgZm9yICg7IGkgPCBuOyArK2kpIHtcbiAgICBtYXJrID0gZ3JvdXBzW2ldO1xuICAgIGl0ZW1zID0gbWFyay5pdGVtcztcbiAgICBpZiAobWFyay5tYXJrdHlwZSA9PT0gR3JvdXApIHtcbiAgICAgIHN3aXRjaCAobWFyay5yb2xlKSB7XG4gICAgICAgIGNhc2UgQXhpc1JvbGU6XG4gICAgICAgIGNhc2UgTGVnZW5kUm9sZTpcbiAgICAgICAgY2FzZSBUaXRsZVJvbGU6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUm93SGVhZGVyOlxuICAgICAgICAgIHZpZXdzLnJvd2hlYWRlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUm93Rm9vdGVyOlxuICAgICAgICAgIHZpZXdzLnJvd2Zvb3RlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29sSGVhZGVyOlxuICAgICAgICAgIHZpZXdzLmNvbGhlYWRlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29sRm9vdGVyOlxuICAgICAgICAgIHZpZXdzLmNvbGZvb3RlcnMucHVzaCguLi5pdGVtcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUm93VGl0bGU6XG4gICAgICAgICAgdmlld3Mucm93dGl0bGUgPSBpdGVtc1swXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb2xUaXRsZTpcbiAgICAgICAgICB2aWV3cy5jb2x0aXRsZSA9IGl0ZW1zWzBdO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHZpZXdzLm1hcmtzLnB1c2goLi4uaXRlbXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmlld3M7XG59XG5mdW5jdGlvbiBiYm94Rmx1c2goaXRlbSkge1xuICByZXR1cm4gbmV3IEJvdW5kcygpLnNldCgwLCAwLCBpdGVtLndpZHRoIHx8IDAsIGl0ZW0uaGVpZ2h0IHx8IDApO1xufVxuZnVuY3Rpb24gYmJveEZ1bGwoaXRlbSkge1xuICBjb25zdCBiID0gaXRlbS5ib3VuZHMuY2xvbmUoKTtcbiAgcmV0dXJuIGIuZW1wdHkoKSA/IGIuc2V0KDAsIDAsIDAsIDApIDogYi50cmFuc2xhdGUoLShpdGVtLnggfHwgMCksIC0oaXRlbS55IHx8IDApKTtcbn1cbmZ1bmN0aW9uIGdldChvcHQsIGtleSwgZCkge1xuICBjb25zdCB2ID0gaXNPYmplY3Qob3B0KSA/IG9wdFtrZXldIDogb3B0O1xuICByZXR1cm4gdiAhPSBudWxsID8gdiA6IGQgIT09IHVuZGVmaW5lZCA/IGQgOiAwO1xufVxuZnVuY3Rpb24gb2Zmc2V0VmFsdWUodikge1xuICByZXR1cm4gdiA8IDAgPyBNYXRoLmNlaWwoLXYpIDogMDtcbn1cbmZ1bmN0aW9uIGdyaWRMYXlvdXQodmlldywgZ3JvdXBzLCBvcHQpIHtcbiAgdmFyIGRpcnR5ID0gIW9wdC5ub2RpcnR5LFxuICAgIGJib3ggPSBvcHQuYm91bmRzID09PSBGbHVzaCA/IGJib3hGbHVzaCA6IGJib3hGdWxsLFxuICAgIGJvdW5kcyA9IHRlbXBCb3VuZHMuc2V0KDAsIDAsIDAsIDApLFxuICAgIGFsaWduQ29sID0gZ2V0KG9wdC5hbGlnbiwgQ29sdW1uKSxcbiAgICBhbGlnblJvdyA9IGdldChvcHQuYWxpZ24sIFJvdyksXG4gICAgcGFkQ29sID0gZ2V0KG9wdC5wYWRkaW5nLCBDb2x1bW4pLFxuICAgIHBhZFJvdyA9IGdldChvcHQucGFkZGluZywgUm93KSxcbiAgICBuY29scyA9IG9wdC5jb2x1bW5zIHx8IGdyb3Vwcy5sZW5ndGgsXG4gICAgbnJvd3MgPSBuY29scyA8PSAwID8gMSA6IE1hdGguY2VpbChncm91cHMubGVuZ3RoIC8gbmNvbHMpLFxuICAgIG4gPSBncm91cHMubGVuZ3RoLFxuICAgIHhPZmZzZXQgPSBBcnJheShuKSxcbiAgICB4RXh0ZW50ID0gQXJyYXkobmNvbHMpLFxuICAgIHhNYXggPSAwLFxuICAgIHlPZmZzZXQgPSBBcnJheShuKSxcbiAgICB5RXh0ZW50ID0gQXJyYXkobnJvd3MpLFxuICAgIHlNYXggPSAwLFxuICAgIGR4ID0gQXJyYXkobiksXG4gICAgZHkgPSBBcnJheShuKSxcbiAgICBib3hlcyA9IEFycmF5KG4pLFxuICAgIG0sXG4gICAgaSxcbiAgICBjLFxuICAgIHIsXG4gICAgYixcbiAgICBnLFxuICAgIHB4LFxuICAgIHB5LFxuICAgIHgsXG4gICAgeSxcbiAgICBvZmZzZXQ7XG4gIGZvciAoaSA9IDA7IGkgPCBuY29sczsgKytpKSB4RXh0ZW50W2ldID0gMDtcbiAgZm9yIChpID0gMDsgaSA8IG5yb3dzOyArK2kpIHlFeHRlbnRbaV0gPSAwO1xuXG4gIC8vIGRldGVybWluZSBvZmZzZXRzIGZvciBlYWNoIGdyb3VwXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBnID0gZ3JvdXBzW2ldO1xuICAgIGIgPSBib3hlc1tpXSA9IGJib3goZyk7XG4gICAgZy54ID0gZy54IHx8IDA7XG4gICAgZHhbaV0gPSAwO1xuICAgIGcueSA9IGcueSB8fCAwO1xuICAgIGR5W2ldID0gMDtcbiAgICBjID0gaSAlIG5jb2xzO1xuICAgIHIgPSB+fihpIC8gbmNvbHMpO1xuICAgIHhNYXggPSBNYXRoLm1heCh4TWF4LCBweCA9IE1hdGguY2VpbChiLngyKSk7XG4gICAgeU1heCA9IE1hdGgubWF4KHlNYXgsIHB5ID0gTWF0aC5jZWlsKGIueTIpKTtcbiAgICB4RXh0ZW50W2NdID0gTWF0aC5tYXgoeEV4dGVudFtjXSwgcHgpO1xuICAgIHlFeHRlbnRbcl0gPSBNYXRoLm1heCh5RXh0ZW50W3JdLCBweSk7XG4gICAgeE9mZnNldFtpXSA9IHBhZENvbCArIG9mZnNldFZhbHVlKGIueDEpO1xuICAgIHlPZmZzZXRbaV0gPSBwYWRSb3cgKyBvZmZzZXRWYWx1ZShiLnkxKTtcbiAgICBpZiAoZGlydHkpIHZpZXcuZGlydHkoZ3JvdXBzW2ldKTtcbiAgfVxuXG4gIC8vIHNldCBpbml0aWFsIGFsaWdubWVudCBvZmZzZXRzXG4gIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICBpZiAoaSAlIG5jb2xzID09PSAwKSB4T2Zmc2V0W2ldID0gMDtcbiAgICBpZiAoaSA8IG5jb2xzKSB5T2Zmc2V0W2ldID0gMDtcbiAgfVxuXG4gIC8vIGVuZm9yY2UgY29sdW1uIGFsaWdubWVudCBjb25zdHJhaW50c1xuICBpZiAoYWxpZ25Db2wgPT09IEVhY2gpIHtcbiAgICBmb3IgKGMgPSAxOyBjIDwgbmNvbHM7ICsrYykge1xuICAgICAgZm9yIChvZmZzZXQgPSAwLCBpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgaWYgKG9mZnNldCA8IHhPZmZzZXRbaV0pIG9mZnNldCA9IHhPZmZzZXRbaV07XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSBjOyBpIDwgbjsgaSArPSBuY29scykge1xuICAgICAgICB4T2Zmc2V0W2ldID0gb2Zmc2V0ICsgeEV4dGVudFtjIC0gMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFsaWduQ29sID09PSBBbGwpIHtcbiAgICBmb3IgKG9mZnNldCA9IDAsIGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBpZiAoaSAlIG5jb2xzICYmIG9mZnNldCA8IHhPZmZzZXRbaV0pIG9mZnNldCA9IHhPZmZzZXRbaV07XG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmIChpICUgbmNvbHMpIHhPZmZzZXRbaV0gPSBvZmZzZXQgKyB4TWF4O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKGFsaWduQ29sID0gZmFsc2UsIGMgPSAxOyBjIDwgbmNvbHM7ICsrYykge1xuICAgICAgZm9yIChpID0gYzsgaSA8IG47IGkgKz0gbmNvbHMpIHtcbiAgICAgICAgeE9mZnNldFtpXSArPSB4RXh0ZW50W2MgLSAxXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBlbmZvcmNlIHJvdyBhbGlnbm1lbnQgY29uc3RyYWludHNcbiAgaWYgKGFsaWduUm93ID09PSBFYWNoKSB7XG4gICAgZm9yIChyID0gMTsgciA8IG5yb3dzOyArK3IpIHtcbiAgICAgIGZvciAob2Zmc2V0ID0gMCwgaSA9IHIgKiBuY29scywgbSA9IGkgKyBuY29sczsgaSA8IG07ICsraSkge1xuICAgICAgICBpZiAob2Zmc2V0IDwgeU9mZnNldFtpXSkgb2Zmc2V0ID0geU9mZnNldFtpXTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IHIgKiBuY29sczsgaSA8IG07ICsraSkge1xuICAgICAgICB5T2Zmc2V0W2ldID0gb2Zmc2V0ICsgeUV4dGVudFtyIC0gMV07XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKGFsaWduUm93ID09PSBBbGwpIHtcbiAgICBmb3IgKG9mZnNldCA9IDAsIGkgPSBuY29sczsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKG9mZnNldCA8IHlPZmZzZXRbaV0pIG9mZnNldCA9IHlPZmZzZXRbaV07XG4gICAgfVxuICAgIGZvciAoaSA9IG5jb2xzOyBpIDwgbjsgKytpKSB7XG4gICAgICB5T2Zmc2V0W2ldID0gb2Zmc2V0ICsgeU1heDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChhbGlnblJvdyA9IGZhbHNlLCByID0gMTsgciA8IG5yb3dzOyArK3IpIHtcbiAgICAgIGZvciAoaSA9IHIgKiBuY29scywgbSA9IGkgKyBuY29sczsgaSA8IG07ICsraSkge1xuICAgICAgICB5T2Zmc2V0W2ldICs9IHlFeHRlbnRbciAtIDFdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHBlcmZvcm0gaG9yaXpvbnRhbCBncmlkIGxheW91dFxuICBmb3IgKHggPSAwLCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgIHggPSB4T2Zmc2V0W2ldICsgKGkgJSBuY29scyA/IHggOiAwKTtcbiAgICBkeFtpXSArPSB4IC0gZ3JvdXBzW2ldLng7XG4gIH1cblxuICAvLyBwZXJmb3JtIHZlcnRpY2FsIGdyaWQgbGF5b3V0XG4gIGZvciAoYyA9IDA7IGMgPCBuY29sczsgKytjKSB7XG4gICAgZm9yICh5ID0gMCwgaSA9IGM7IGkgPCBuOyBpICs9IG5jb2xzKSB7XG4gICAgICB5ICs9IHlPZmZzZXRbaV07XG4gICAgICBkeVtpXSArPSB5IC0gZ3JvdXBzW2ldLnk7XG4gICAgfVxuICB9XG5cbiAgLy8gcGVyZm9ybSBob3Jpem9udGFsIGNlbnRlcmluZ1xuICBpZiAoYWxpZ25Db2wgJiYgZ2V0KG9wdC5jZW50ZXIsIENvbHVtbikgJiYgbnJvd3MgPiAxKSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgYiA9IGFsaWduQ29sID09PSBBbGwgPyB4TWF4IDogeEV4dGVudFtpICUgbmNvbHNdO1xuICAgICAgeCA9IGIgLSBib3hlc1tpXS54MiAtIGdyb3Vwc1tpXS54IC0gZHhbaV07XG4gICAgICBpZiAoeCA+IDApIGR4W2ldICs9IHggLyAyO1xuICAgIH1cbiAgfVxuXG4gIC8vIHBlcmZvcm0gdmVydGljYWwgY2VudGVyaW5nXG4gIGlmIChhbGlnblJvdyAmJiBnZXQob3B0LmNlbnRlciwgUm93KSAmJiBuY29scyAhPT0gMSkge1xuICAgIGZvciAoaSA9IDA7IGkgPCBuOyArK2kpIHtcbiAgICAgIGIgPSBhbGlnblJvdyA9PT0gQWxsID8geU1heCA6IHlFeHRlbnRbfn4oaSAvIG5jb2xzKV07XG4gICAgICB5ID0gYiAtIGJveGVzW2ldLnkyIC0gZ3JvdXBzW2ldLnkgLSBkeVtpXTtcbiAgICAgIGlmICh5ID4gMCkgZHlbaV0gKz0geSAvIDI7XG4gICAgfVxuICB9XG5cbiAgLy8gcG9zaXRpb24gZ3JpZCByZWxhdGl2ZSB0byBhbmNob3JcbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGJvdW5kcy51bmlvbihib3hlc1tpXS50cmFuc2xhdGUoZHhbaV0sIGR5W2ldKSk7XG4gIH1cbiAgeCA9IGdldChvcHQuYW5jaG9yLCBYKTtcbiAgeSA9IGdldChvcHQuYW5jaG9yLCBZKTtcbiAgc3dpdGNoIChnZXQob3B0LmFuY2hvciwgQ29sdW1uKSkge1xuICAgIGNhc2UgRW5kOlxuICAgICAgeCAtPSBib3VuZHMud2lkdGgoKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTWlkZGxlOlxuICAgICAgeCAtPSBib3VuZHMud2lkdGgoKSAvIDI7XG4gIH1cbiAgc3dpdGNoIChnZXQob3B0LmFuY2hvciwgUm93KSkge1xuICAgIGNhc2UgRW5kOlxuICAgICAgeSAtPSBib3VuZHMuaGVpZ2h0KCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIE1pZGRsZTpcbiAgICAgIHkgLT0gYm91bmRzLmhlaWdodCgpIC8gMjtcbiAgfVxuICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgeSA9IE1hdGgucm91bmQoeSk7XG5cbiAgLy8gdXBkYXRlIG1hcmsgcG9zaXRpb25zLCBib3VuZHMsIGRpcnR5XG4gIGJvdW5kcy5jbGVhcigpO1xuICBmb3IgKGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgZ3JvdXBzW2ldLm1hcmsuYm91bmRzLmNsZWFyKCk7XG4gIH1cbiAgZm9yIChpID0gMDsgaSA8IG47ICsraSkge1xuICAgIGcgPSBncm91cHNbaV07XG4gICAgZy54ICs9IGR4W2ldICs9IHg7XG4gICAgZy55ICs9IGR5W2ldICs9IHk7XG4gICAgYm91bmRzLnVuaW9uKGcubWFyay5ib3VuZHMudW5pb24oZy5ib3VuZHMudHJhbnNsYXRlKGR4W2ldLCBkeVtpXSkpKTtcbiAgICBpZiAoZGlydHkpIHZpZXcuZGlydHkoZyk7XG4gIH1cbiAgcmV0dXJuIGJvdW5kcztcbn1cbmZ1bmN0aW9uIHRyZWxsaXNMYXlvdXQodmlldywgZ3JvdXAsIG9wdCkge1xuICB2YXIgdmlld3MgPSBncmlkTGF5b3V0R3JvdXBzKGdyb3VwKSxcbiAgICBncm91cHMgPSB2aWV3cy5tYXJrcyxcbiAgICBiYm94ID0gb3B0LmJvdW5kcyA9PT0gRmx1c2ggPyBib3VuZEZsdXNoIDogYm91bmRGdWxsLFxuICAgIG9mZiA9IG9wdC5vZmZzZXQsXG4gICAgbmNvbHMgPSBvcHQuY29sdW1ucyB8fCBncm91cHMubGVuZ3RoLFxuICAgIG5yb3dzID0gbmNvbHMgPD0gMCA/IDEgOiBNYXRoLmNlaWwoZ3JvdXBzLmxlbmd0aCAvIG5jb2xzKSxcbiAgICBjZWxscyA9IG5yb3dzICogbmNvbHMsXG4gICAgeCxcbiAgICB5LFxuICAgIHgyLFxuICAgIHkyLFxuICAgIGFuY2hvcixcbiAgICBiYW5kLFxuICAgIG9mZnNldDtcblxuICAvLyAtLSBpbml0aWFsIGdyaWQgbGF5b3V0XG4gIGNvbnN0IGJvdW5kcyA9IGdyaWRMYXlvdXQodmlldywgZ3JvdXBzLCBvcHQpO1xuICBpZiAoYm91bmRzLmVtcHR5KCkpIGJvdW5kcy5zZXQoMCwgMCwgMCwgMCk7IC8vIGVtcHR5IGdyaWRcblxuICAvLyAtLSBsYXlvdXQgZ3JpZCBoZWFkZXJzIGFuZCBmb290ZXJzIC0tXG5cbiAgLy8gcGVyZm9ybSByb3cgaGVhZGVyIGxheW91dFxuICBpZiAodmlld3Mucm93aGVhZGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmhlYWRlckJhbmQsIFJvdywgbnVsbCk7XG4gICAgeCA9IGxheW91dEhlYWRlcnModmlldywgdmlld3Mucm93aGVhZGVycywgZ3JvdXBzLCBuY29scywgbnJvd3MsIC1nZXQob2ZmLCAncm93SGVhZGVyJyksIG1pbiwgMCwgYmJveCwgJ3gxJywgMCwgbmNvbHMsIDEsIGJhbmQpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBjb2x1bW4gaGVhZGVyIGxheW91dFxuICBpZiAodmlld3MuY29saGVhZGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmhlYWRlckJhbmQsIENvbHVtbiwgbnVsbCk7XG4gICAgeSA9IGxheW91dEhlYWRlcnModmlldywgdmlld3MuY29saGVhZGVycywgZ3JvdXBzLCBuY29scywgbmNvbHMsIC1nZXQob2ZmLCAnY29sdW1uSGVhZGVyJyksIG1pbiwgMSwgYmJveCwgJ3kxJywgMCwgMSwgbmNvbHMsIGJhbmQpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSByb3cgZm9vdGVyIGxheW91dFxuICBpZiAodmlld3Mucm93Zm9vdGVycykge1xuICAgIGJhbmQgPSBnZXQob3B0LmZvb3RlckJhbmQsIFJvdywgbnVsbCk7XG4gICAgeDIgPSBsYXlvdXRIZWFkZXJzKHZpZXcsIHZpZXdzLnJvd2Zvb3RlcnMsIGdyb3VwcywgbmNvbHMsIG5yb3dzLCBnZXQob2ZmLCAncm93Rm9vdGVyJyksIG1heCwgMCwgYmJveCwgJ3gyJywgbmNvbHMgLSAxLCBuY29scywgMSwgYmFuZCk7XG4gIH1cblxuICAvLyBwZXJmb3JtIGNvbHVtbiBmb290ZXIgbGF5b3V0XG4gIGlmICh2aWV3cy5jb2xmb290ZXJzKSB7XG4gICAgYmFuZCA9IGdldChvcHQuZm9vdGVyQmFuZCwgQ29sdW1uLCBudWxsKTtcbiAgICB5MiA9IGxheW91dEhlYWRlcnModmlldywgdmlld3MuY29sZm9vdGVycywgZ3JvdXBzLCBuY29scywgbmNvbHMsIGdldChvZmYsICdjb2x1bW5Gb290ZXInKSwgbWF4LCAxLCBiYm94LCAneTInLCBjZWxscyAtIG5jb2xzLCAxLCBuY29scywgYmFuZCk7XG4gIH1cblxuICAvLyBwZXJmb3JtIHJvdyB0aXRsZSBsYXlvdXRcbiAgaWYgKHZpZXdzLnJvd3RpdGxlKSB7XG4gICAgYW5jaG9yID0gZ2V0KG9wdC50aXRsZUFuY2hvciwgUm93KTtcbiAgICBvZmZzZXQgPSBnZXQob2ZmLCAncm93VGl0bGUnKTtcbiAgICBvZmZzZXQgPSBhbmNob3IgPT09IEVuZCA/IHgyICsgb2Zmc2V0IDogeCAtIG9mZnNldDtcbiAgICBiYW5kID0gZ2V0KG9wdC50aXRsZUJhbmQsIFJvdywgMC41KTtcbiAgICBsYXlvdXRUaXRsZSh2aWV3LCB2aWV3cy5yb3d0aXRsZSwgb2Zmc2V0LCAwLCBib3VuZHMsIGJhbmQpO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBjb2x1bW4gdGl0bGUgbGF5b3V0XG4gIGlmICh2aWV3cy5jb2x0aXRsZSkge1xuICAgIGFuY2hvciA9IGdldChvcHQudGl0bGVBbmNob3IsIENvbHVtbik7XG4gICAgb2Zmc2V0ID0gZ2V0KG9mZiwgJ2NvbHVtblRpdGxlJyk7XG4gICAgb2Zmc2V0ID0gYW5jaG9yID09PSBFbmQgPyB5MiArIG9mZnNldCA6IHkgLSBvZmZzZXQ7XG4gICAgYmFuZCA9IGdldChvcHQudGl0bGVCYW5kLCBDb2x1bW4sIDAuNSk7XG4gICAgbGF5b3V0VGl0bGUodmlldywgdmlld3MuY29sdGl0bGUsIG9mZnNldCwgMSwgYm91bmRzLCBiYW5kKTtcbiAgfVxufVxuZnVuY3Rpb24gYm91bmRGbHVzaChpdGVtLCBmaWVsZCkge1xuICByZXR1cm4gZmllbGQgPT09ICd4MScgPyBpdGVtLnggfHwgMCA6IGZpZWxkID09PSAneTEnID8gaXRlbS55IHx8IDAgOiBmaWVsZCA9PT0gJ3gyJyA/IChpdGVtLnggfHwgMCkgKyAoaXRlbS53aWR0aCB8fCAwKSA6IGZpZWxkID09PSAneTInID8gKGl0ZW0ueSB8fCAwKSArIChpdGVtLmhlaWdodCB8fCAwKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJvdW5kRnVsbChpdGVtLCBmaWVsZCkge1xuICByZXR1cm4gaXRlbS5ib3VuZHNbZmllbGRdO1xufVxuZnVuY3Rpb24gbGF5b3V0SGVhZGVycyh2aWV3LCBoZWFkZXJzLCBncm91cHMsIG5jb2xzLCBsaW1pdCwgb2Zmc2V0LCBhZ2csIGlzWCwgYm91bmQsIGJmLCBzdGFydCwgc3RyaWRlLCBiYWNrLCBiYW5kKSB7XG4gIHZhciBuID0gZ3JvdXBzLmxlbmd0aCxcbiAgICBpbml0ID0gMCxcbiAgICBlZGdlID0gMCxcbiAgICBpLFxuICAgIGosXG4gICAgayxcbiAgICBtLFxuICAgIGIsXG4gICAgaCxcbiAgICBnLFxuICAgIHgsXG4gICAgeTtcblxuICAvLyBpZiBubyBncm91cHMsIGVhcmx5IGV4aXQgYW5kIHJldHVybiAwXG4gIGlmICghbikgcmV0dXJuIGluaXQ7XG5cbiAgLy8gY29tcHV0ZSBtYXJnaW5cbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBuOyBpICs9IHN0cmlkZSkge1xuICAgIGlmIChncm91cHNbaV0pIGluaXQgPSBhZ2coaW5pdCwgYm91bmQoZ3JvdXBzW2ldLCBiZikpO1xuICB9XG5cbiAgLy8gaWYgbm8gaGVhZGVycywgcmV0dXJuIG1hcmdpbiBjYWxjdWxhdGlvblxuICBpZiAoIWhlYWRlcnMubGVuZ3RoKSByZXR1cm4gaW5pdDtcblxuICAvLyBjaGVjayBpZiBudW1iZXIgb2YgaGVhZGVycyBleGNlZWRzIG51bWJlciBvZiByb3dzIG9yIGNvbHVtbnNcbiAgaWYgKGhlYWRlcnMubGVuZ3RoID4gbGltaXQpIHtcbiAgICB2aWV3Lndhcm4oJ0dyaWQgaGVhZGVycyBleGNlZWQgbGltaXQ6ICcgKyBsaW1pdCk7XG4gICAgaGVhZGVycyA9IGhlYWRlcnMuc2xpY2UoMCwgbGltaXQpO1xuICB9XG5cbiAgLy8gYXBwbHkgb2Zmc2V0XG4gIGluaXQgKz0gb2Zmc2V0O1xuXG4gIC8vIGNsZWFyIG1hcmsgYm91bmRzIGZvciBhbGwgaGVhZGVyc1xuICBmb3IgKGogPSAwLCBtID0gaGVhZGVycy5sZW5ndGg7IGogPCBtOyArK2opIHtcbiAgICB2aWV3LmRpcnR5KGhlYWRlcnNbal0pO1xuICAgIGhlYWRlcnNbal0ubWFyay5ib3VuZHMuY2xlYXIoKTtcbiAgfVxuXG4gIC8vIGxheW91dCBlYWNoIGhlYWRlclxuICBmb3IgKGkgPSBzdGFydCwgaiA9IDAsIG0gPSBoZWFkZXJzLmxlbmd0aDsgaiA8IG07ICsraiwgaSArPSBzdHJpZGUpIHtcbiAgICBoID0gaGVhZGVyc1tqXTtcbiAgICBiID0gaC5tYXJrLmJvdW5kcztcblxuICAgIC8vIHNlYXJjaCBmb3IgbmVhcmVzdCBncm91cCB0byBhbGlnbiB0b1xuICAgIC8vIG5lY2Vzc2FyeSBpZiB0YWJsZSBoYXMgZW1wdHkgY2VsbHNcbiAgICBmb3IgKGsgPSBpOyBrID49IDAgJiYgKGcgPSBncm91cHNba10pID09IG51bGw7IGsgLT0gYmFjayk7XG5cbiAgICAvLyBhc3NpZ24gY29vcmRpbmF0ZXMgYW5kIHVwZGF0ZSBib3VuZHNcbiAgICBpZiAoaXNYKSB7XG4gICAgICB4ID0gYmFuZCA9PSBudWxsID8gZy54IDogTWF0aC5yb3VuZChnLmJvdW5kcy54MSArIGJhbmQgKiBnLmJvdW5kcy53aWR0aCgpKTtcbiAgICAgIHkgPSBpbml0O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0gaW5pdDtcbiAgICAgIHkgPSBiYW5kID09IG51bGwgPyBnLnkgOiBNYXRoLnJvdW5kKGcuYm91bmRzLnkxICsgYmFuZCAqIGcuYm91bmRzLmhlaWdodCgpKTtcbiAgICB9XG4gICAgYi51bmlvbihoLmJvdW5kcy50cmFuc2xhdGUoeCAtIChoLnggfHwgMCksIHkgLSAoaC55IHx8IDApKSk7XG4gICAgaC54ID0geDtcbiAgICBoLnkgPSB5O1xuICAgIHZpZXcuZGlydHkoaCk7XG5cbiAgICAvLyB1cGRhdGUgY3VycmVudCBlZGdlIG9mIGxheW91dCBib3VuZHNcbiAgICBlZGdlID0gYWdnKGVkZ2UsIGJbYmZdKTtcbiAgfVxuICByZXR1cm4gZWRnZTtcbn1cbmZ1bmN0aW9uIGxheW91dFRpdGxlKHZpZXcsIGcsIG9mZnNldCwgaXNYLCBib3VuZHMsIGJhbmQpIHtcbiAgaWYgKCFnKSByZXR1cm47XG4gIHZpZXcuZGlydHkoZyk7XG5cbiAgLy8gY29tcHV0ZSB0aXRsZSBjb29yZGluYXRlc1xuICB2YXIgeCA9IG9mZnNldCxcbiAgICB5ID0gb2Zmc2V0O1xuICBpc1ggPyB4ID0gTWF0aC5yb3VuZChib3VuZHMueDEgKyBiYW5kICogYm91bmRzLndpZHRoKCkpIDogeSA9IE1hdGgucm91bmQoYm91bmRzLnkxICsgYmFuZCAqIGJvdW5kcy5oZWlnaHQoKSk7XG5cbiAgLy8gYXNzaWduIGNvb3JkaW5hdGVzIGFuZCB1cGRhdGUgYm91bmRzXG4gIGcuYm91bmRzLnRyYW5zbGF0ZSh4IC0gKGcueCB8fCAwKSwgeSAtIChnLnkgfHwgMCkpO1xuICBnLm1hcmsuYm91bmRzLmNsZWFyKCkudW5pb24oZy5ib3VuZHMpO1xuICBnLnggPSB4O1xuICBnLnkgPSB5O1xuXG4gIC8vIHF1ZXVlIHRpdGxlIGZvciByZWRyYXdcbiAgdmlldy5kaXJ0eShnKTtcbn1cblxuLy8gdXRpbGl0eSBmb3IgbG9va2luZyB1cCBsZWdlbmQgbGF5b3V0IGNvbmZpZ3VyYXRpb25cbmZ1bmN0aW9uIGxvb2t1cChjb25maWcsIG9yaWVudCkge1xuICBjb25zdCBvcHQgPSBjb25maWdbb3JpZW50XSB8fCB7fTtcbiAgcmV0dXJuIChrZXksIGQpID0+IG9wdFtrZXldICE9IG51bGwgPyBvcHRba2V5XSA6IGNvbmZpZ1trZXldICE9IG51bGwgPyBjb25maWdba2V5XSA6IGQ7XG59XG5cbi8vIGlmIGxlZ2VuZHMgc3BlY2lmeSBvZmZzZXQgZGlyZWN0bHksIHVzZSB0aGUgbWF4aW11bSBzcGVjaWZpZWQgdmFsdWVcbmZ1bmN0aW9uIG9mZnNldHMobGVnZW5kcywgdmFsdWUpIHtcbiAgbGV0IG1heCA9IC1JbmZpbml0eTtcbiAgbGVnZW5kcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgIGlmIChpdGVtLm9mZnNldCAhPSBudWxsKSBtYXggPSBNYXRoLm1heChtYXgsIGl0ZW0ub2Zmc2V0KTtcbiAgfSk7XG4gIHJldHVybiBtYXggPiAtSW5maW5pdHkgPyBtYXggOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGxlZ2VuZFBhcmFtcyhnLCBvcmllbnQsIGNvbmZpZywgeGIsIHliLCB3LCBoKSB7XG4gIGNvbnN0IF8gPSBsb29rdXAoY29uZmlnLCBvcmllbnQpLFxuICAgIG9mZnNldCA9IG9mZnNldHMoZywgXygnb2Zmc2V0JywgMCkpLFxuICAgIGFuY2hvciA9IF8oJ2FuY2hvcicsIFN0YXJ0KSxcbiAgICBtdWx0ID0gYW5jaG9yID09PSBFbmQgPyAxIDogYW5jaG9yID09PSBNaWRkbGUgPyAwLjUgOiAwO1xuICBjb25zdCBwID0ge1xuICAgIGFsaWduOiBFYWNoLFxuICAgIGJvdW5kczogXygnYm91bmRzJywgRmx1c2gpLFxuICAgIGNvbHVtbnM6IF8oJ2RpcmVjdGlvbicpID09PSAndmVydGljYWwnID8gMSA6IGcubGVuZ3RoLFxuICAgIHBhZGRpbmc6IF8oJ21hcmdpbicsIDgpLFxuICAgIGNlbnRlcjogXygnY2VudGVyJyksXG4gICAgbm9kaXJ0eTogdHJ1ZVxuICB9O1xuICBzd2l0Y2ggKG9yaWVudCkge1xuICAgIGNhc2UgTGVmdDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiBNYXRoLmZsb29yKHhiLngxKSAtIG9mZnNldCxcbiAgICAgICAgY29sdW1uOiBFbmQsXG4gICAgICAgIHk6IG11bHQgKiAoaCB8fCB4Yi5oZWlnaHQoKSArIDIgKiB4Yi55MSksXG4gICAgICAgIHJvdzogYW5jaG9yXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSaWdodDpcbiAgICAgIHAuYW5jaG9yID0ge1xuICAgICAgICB4OiBNYXRoLmNlaWwoeGIueDIpICsgb2Zmc2V0LFxuICAgICAgICB5OiBtdWx0ICogKGggfHwgeGIuaGVpZ2h0KCkgKyAyICogeGIueTEpLFxuICAgICAgICByb3c6IGFuY2hvclxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgVG9wOlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHk6IE1hdGguZmxvb3IoeWIueTEpIC0gb2Zmc2V0LFxuICAgICAgICByb3c6IEVuZCxcbiAgICAgICAgeDogbXVsdCAqICh3IHx8IHliLndpZHRoKCkgKyAyICogeWIueDEpLFxuICAgICAgICBjb2x1bW46IGFuY2hvclxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQm90dG9tOlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHk6IE1hdGguY2VpbCh5Yi55MikgKyBvZmZzZXQsXG4gICAgICAgIHg6IG11bHQgKiAodyB8fCB5Yi53aWR0aCgpICsgMiAqIHliLngxKSxcbiAgICAgICAgY29sdW1uOiBhbmNob3JcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRvcExlZnQ6XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeDogb2Zmc2V0LFxuICAgICAgICB5OiBvZmZzZXRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIFRvcFJpZ2h0OlxuICAgICAgcC5hbmNob3IgPSB7XG4gICAgICAgIHg6IHcgLSBvZmZzZXQsXG4gICAgICAgIHk6IG9mZnNldCxcbiAgICAgICAgY29sdW1uOiBFbmRcbiAgICAgIH07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJvdHRvbUxlZnQ6XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeDogb2Zmc2V0LFxuICAgICAgICB5OiBoIC0gb2Zmc2V0LFxuICAgICAgICByb3c6IEVuZFxuICAgICAgfTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQm90dG9tUmlnaHQ6XG4gICAgICBwLmFuY2hvciA9IHtcbiAgICAgICAgeDogdyAtIG9mZnNldCxcbiAgICAgICAgeTogaCAtIG9mZnNldCxcbiAgICAgICAgY29sdW1uOiBFbmQsXG4gICAgICAgIHJvdzogRW5kXG4gICAgICB9O1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBsZWdlbmRMYXlvdXQodmlldywgbGVnZW5kKSB7XG4gIHZhciBpdGVtID0gbGVnZW5kLml0ZW1zWzBdLFxuICAgIGRhdHVtID0gaXRlbS5kYXR1bSxcbiAgICBvcmllbnQgPSBpdGVtLm9yaWVudCxcbiAgICBib3VuZHMgPSBpdGVtLmJvdW5kcyxcbiAgICB4ID0gaXRlbS54LFxuICAgIHkgPSBpdGVtLnksXG4gICAgdyxcbiAgICBoO1xuXG4gIC8vIGNhY2hlIGN1cnJlbnQgYm91bmRzIGZvciBsYXRlciBjb21wYXJpc29uXG4gIGl0ZW0uX2JvdW5kcyA/IGl0ZW0uX2JvdW5kcy5jbGVhcigpLnVuaW9uKGJvdW5kcykgOiBpdGVtLl9ib3VuZHMgPSBib3VuZHMuY2xvbmUoKTtcbiAgYm91bmRzLmNsZWFyKCk7XG5cbiAgLy8gYWRqdXN0IGxlZ2VuZCB0byBhY2NvbW1vZGF0ZSBwYWRkaW5nIGFuZCB0aXRsZVxuICBsZWdlbmRHcm91cExheW91dCh2aWV3LCBpdGVtLCBpdGVtLml0ZW1zWzBdLml0ZW1zWzBdKTtcblxuICAvLyBhZ2dyZWdhdGUgYm91bmRzIHRvIGRldGVybWluZSBzaXplLCBhbmQgaW5jbHVkZSBvcmlnaW5cbiAgYm91bmRzID0gbGVnZW5kQm91bmRzKGl0ZW0sIGJvdW5kcyk7XG4gIHcgPSAyICogaXRlbS5wYWRkaW5nO1xuICBoID0gMiAqIGl0ZW0ucGFkZGluZztcbiAgaWYgKCFib3VuZHMuZW1wdHkoKSkge1xuICAgIHcgPSBNYXRoLmNlaWwoYm91bmRzLndpZHRoKCkgKyB3KTtcbiAgICBoID0gTWF0aC5jZWlsKGJvdW5kcy5oZWlnaHQoKSArIGgpO1xuICB9XG4gIGlmIChkYXR1bS50eXBlID09PSBTeW1ib2xzKSB7XG4gICAgbGVnZW5kRW50cnlMYXlvdXQoaXRlbS5pdGVtc1swXS5pdGVtc1swXS5pdGVtc1swXS5pdGVtcyk7XG4gIH1cbiAgaWYgKG9yaWVudCAhPT0gTm9uZSkge1xuICAgIGl0ZW0ueCA9IHggPSAwO1xuICAgIGl0ZW0ueSA9IHkgPSAwO1xuICB9XG4gIGl0ZW0ud2lkdGggPSB3O1xuICBpdGVtLmhlaWdodCA9IGg7XG4gIGJvdW5kU3Ryb2tlKGJvdW5kcy5zZXQoeCwgeSwgeCArIHcsIHkgKyBoKSwgaXRlbSk7XG4gIGl0ZW0ubWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbihib3VuZHMpO1xuICByZXR1cm4gaXRlbTtcbn1cbmZ1bmN0aW9uIGxlZ2VuZEJvdW5kcyhpdGVtLCBiKSB7XG4gIC8vIGFnZ3JlZ2F0ZSBpdGVtIGJvdW5kc1xuICBpdGVtLml0ZW1zLmZvckVhY2goXyA9PiBiLnVuaW9uKF8uYm91bmRzKSk7XG5cbiAgLy8gYW5jaG9yIHRvIGxlZ2VuZCBvcmlnaW5cbiAgYi54MSA9IGl0ZW0ucGFkZGluZztcbiAgYi55MSA9IGl0ZW0ucGFkZGluZztcbiAgcmV0dXJuIGI7XG59XG5mdW5jdGlvbiBsZWdlbmRHcm91cExheW91dCh2aWV3LCBpdGVtLCBlbnRyeSkge1xuICB2YXIgcGFkID0gaXRlbS5wYWRkaW5nLFxuICAgIGV4ID0gcGFkIC0gZW50cnkueCxcbiAgICBleSA9IHBhZCAtIGVudHJ5Lnk7XG4gIGlmICghaXRlbS5kYXR1bS50aXRsZSkge1xuICAgIGlmIChleCB8fCBleSkgdHJhbnNsYXRlKHZpZXcsIGVudHJ5LCBleCwgZXkpO1xuICB9IGVsc2Uge1xuICAgIHZhciB0aXRsZSA9IGl0ZW0uaXRlbXNbMV0uaXRlbXNbMF0sXG4gICAgICBhbmNob3IgPSB0aXRsZS5hbmNob3IsXG4gICAgICB0cGFkID0gaXRlbS50aXRsZVBhZGRpbmcgfHwgMCxcbiAgICAgIHR4ID0gcGFkIC0gdGl0bGUueCxcbiAgICAgIHR5ID0gcGFkIC0gdGl0bGUueTtcbiAgICBzd2l0Y2ggKHRpdGxlLm9yaWVudCkge1xuICAgICAgY2FzZSBMZWZ0OlxuICAgICAgICBleCArPSBNYXRoLmNlaWwodGl0bGUuYm91bmRzLndpZHRoKCkpICsgdHBhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFJpZ2h0OlxuICAgICAgY2FzZSBCb3R0b206XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZXkgKz0gdGl0bGUuYm91bmRzLmhlaWdodCgpICsgdHBhZDtcbiAgICB9XG4gICAgaWYgKGV4IHx8IGV5KSB0cmFuc2xhdGUodmlldywgZW50cnksIGV4LCBleSk7XG4gICAgc3dpdGNoICh0aXRsZS5vcmllbnQpIHtcbiAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgdHkgKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIDEsIDEpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUmlnaHQ6XG4gICAgICAgIHR4ICs9IGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgRW5kLCAwLCAwKSArIHRwYWQ7XG4gICAgICAgIHR5ICs9IGxlZ2VuZFRpdGxlT2Zmc2V0KGl0ZW0sIGVudHJ5LCB0aXRsZSwgYW5jaG9yLCAxLCAxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgdHggKz0gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIDAsIDApO1xuICAgICAgICB0eSArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIEVuZCwgLTEsIDAsIDEpICsgdHBhZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0eCArPSBsZWdlbmRUaXRsZU9mZnNldChpdGVtLCBlbnRyeSwgdGl0bGUsIGFuY2hvciwgMCwgMCk7XG4gICAgfVxuICAgIGlmICh0eCB8fCB0eSkgdHJhbnNsYXRlKHZpZXcsIHRpdGxlLCB0eCwgdHkpO1xuXG4gICAgLy8gdHJhbnNsYXRlIGxlZ2VuZCBpZiB0aXRsZSBwdXNoZXMgaW50byBuZWdhdGl2ZSBjb29yZGluYXRlc1xuICAgIGlmICgodHggPSBNYXRoLnJvdW5kKHRpdGxlLmJvdW5kcy54MSAtIHBhZCkpIDwgMCkge1xuICAgICAgdHJhbnNsYXRlKHZpZXcsIGVudHJ5LCAtdHgsIDApO1xuICAgICAgdHJhbnNsYXRlKHZpZXcsIHRpdGxlLCAtdHgsIDApO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbGVnZW5kVGl0bGVPZmZzZXQoaXRlbSwgZW50cnksIHRpdGxlLCBhbmNob3IsIHksIGxyLCBub0Jhcikge1xuICBjb25zdCBncmFkID0gaXRlbS5kYXR1bS50eXBlICE9PSAnc3ltYm9sJyxcbiAgICB2Z3JhZCA9IHRpdGxlLmRhdHVtLnZncmFkLFxuICAgIGUgPSBncmFkICYmIChsciB8fCAhdmdyYWQpICYmICFub0JhciA/IGVudHJ5Lml0ZW1zWzBdIDogZW50cnksXG4gICAgcyA9IGUuYm91bmRzW3kgPyAneTInIDogJ3gyJ10gLSBpdGVtLnBhZGRpbmcsXG4gICAgdSA9IHZncmFkICYmIGxyID8gcyA6IDAsXG4gICAgdiA9IHZncmFkICYmIGxyID8gMCA6IHMsXG4gICAgbyA9IHkgPD0gMCA/IDAgOiBtdWx0aUxpbmVPZmZzZXQodGl0bGUpO1xuICByZXR1cm4gTWF0aC5yb3VuZChhbmNob3IgPT09IFN0YXJ0ID8gdSA6IGFuY2hvciA9PT0gRW5kID8gdiAtIG8gOiAwLjUgKiAocyAtIG8pKTtcbn1cbmZ1bmN0aW9uIHRyYW5zbGF0ZSh2aWV3LCBpdGVtLCBkeCwgZHkpIHtcbiAgaXRlbS54ICs9IGR4O1xuICBpdGVtLnkgKz0gZHk7XG4gIGl0ZW0uYm91bmRzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICBpdGVtLm1hcmsuYm91bmRzLnRyYW5zbGF0ZShkeCwgZHkpO1xuICB2aWV3LmRpcnR5KGl0ZW0pO1xufVxuZnVuY3Rpb24gbGVnZW5kRW50cnlMYXlvdXQoZW50cmllcykge1xuICAvLyBnZXQgbWF4IHdpZHRocyBmb3IgZWFjaCBjb2x1bW5cbiAgY29uc3Qgd2lkdGhzID0gZW50cmllcy5yZWR1Y2UoKHcsIGcpID0+IHtcbiAgICB3W2cuY29sdW1uXSA9IE1hdGgubWF4KGcuYm91bmRzLngyIC0gZy54LCB3W2cuY29sdW1uXSB8fCAwKTtcbiAgICByZXR1cm4gdztcbiAgfSwge30pO1xuXG4gIC8vIHNldCBkaW1lbnNpb25zIG9mIGxlZ2VuZCBlbnRyeSBncm91cHNcbiAgZW50cmllcy5mb3JFYWNoKGcgPT4ge1xuICAgIGcud2lkdGggPSB3aWR0aHNbZy5jb2x1bW5dO1xuICAgIGcuaGVpZ2h0ID0gZy5ib3VuZHMueTIgLSBnLnk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0aXRsZUxheW91dCh2aWV3LCBtYXJrLCB3aWR0aCwgaGVpZ2h0LCB2aWV3Qm91bmRzKSB7XG4gIHZhciBncm91cCA9IG1hcmsuaXRlbXNbMF0sXG4gICAgZnJhbWUgPSBncm91cC5mcmFtZSxcbiAgICBvcmllbnQgPSBncm91cC5vcmllbnQsXG4gICAgYW5jaG9yID0gZ3JvdXAuYW5jaG9yLFxuICAgIG9mZnNldCA9IGdyb3VwLm9mZnNldCxcbiAgICBwYWRkaW5nID0gZ3JvdXAucGFkZGluZyxcbiAgICB0aXRsZSA9IGdyb3VwLml0ZW1zWzBdLml0ZW1zWzBdLFxuICAgIHN1YnRpdGxlID0gZ3JvdXAuaXRlbXNbMV0gJiYgZ3JvdXAuaXRlbXNbMV0uaXRlbXNbMF0sXG4gICAgZW5kID0gb3JpZW50ID09PSBMZWZ0IHx8IG9yaWVudCA9PT0gUmlnaHQgPyBoZWlnaHQgOiB3aWR0aCxcbiAgICBzdGFydCA9IDAsXG4gICAgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgc3ggPSAwLFxuICAgIHN5ID0gMCxcbiAgICBwb3M7XG4gIGlmIChmcmFtZSAhPT0gR3JvdXApIHtcbiAgICBvcmllbnQgPT09IExlZnQgPyAoc3RhcnQgPSB2aWV3Qm91bmRzLnkyLCBlbmQgPSB2aWV3Qm91bmRzLnkxKSA6IG9yaWVudCA9PT0gUmlnaHQgPyAoc3RhcnQgPSB2aWV3Qm91bmRzLnkxLCBlbmQgPSB2aWV3Qm91bmRzLnkyKSA6IChzdGFydCA9IHZpZXdCb3VuZHMueDEsIGVuZCA9IHZpZXdCb3VuZHMueDIpO1xuICB9IGVsc2UgaWYgKG9yaWVudCA9PT0gTGVmdCkge1xuICAgIHN0YXJ0ID0gaGVpZ2h0LCBlbmQgPSAwO1xuICB9XG4gIHBvcyA9IGFuY2hvciA9PT0gU3RhcnQgPyBzdGFydCA6IGFuY2hvciA9PT0gRW5kID8gZW5kIDogKHN0YXJ0ICsgZW5kKSAvIDI7XG4gIGlmIChzdWJ0aXRsZSAmJiBzdWJ0aXRsZS50ZXh0KSB7XG4gICAgLy8gcG9zaXRpb24gc3VidGl0bGVcbiAgICBzd2l0Y2ggKG9yaWVudCkge1xuICAgICAgY2FzZSBUb3A6XG4gICAgICBjYXNlIEJvdHRvbTpcbiAgICAgICAgc3kgPSB0aXRsZS5ib3VuZHMuaGVpZ2h0KCkgKyBwYWRkaW5nO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgc3ggPSB0aXRsZS5ib3VuZHMud2lkdGgoKSArIHBhZGRpbmc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBSaWdodDpcbiAgICAgICAgc3ggPSAtdGl0bGUuYm91bmRzLndpZHRoKCkgLSBwYWRkaW5nO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGVtcEJvdW5kcy5jbGVhcigpLnVuaW9uKHN1YnRpdGxlLmJvdW5kcyk7XG4gICAgdGVtcEJvdW5kcy50cmFuc2xhdGUoc3ggLSAoc3VidGl0bGUueCB8fCAwKSwgc3kgLSAoc3VidGl0bGUueSB8fCAwKSk7XG4gICAgaWYgKHNldChzdWJ0aXRsZSwgJ3gnLCBzeCkgfCBzZXQoc3VidGl0bGUsICd5Jywgc3kpKSB7XG4gICAgICB2aWV3LmRpcnR5KHN1YnRpdGxlKTtcbiAgICAgIHN1YnRpdGxlLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgICAgc3VidGl0bGUubWFyay5ib3VuZHMuY2xlYXIoKS51bmlvbih0ZW1wQm91bmRzKTtcbiAgICAgIHZpZXcuZGlydHkoc3VidGl0bGUpO1xuICAgIH1cbiAgICB0ZW1wQm91bmRzLmNsZWFyKCkudW5pb24oc3VidGl0bGUuYm91bmRzKTtcbiAgfSBlbHNlIHtcbiAgICB0ZW1wQm91bmRzLmNsZWFyKCk7XG4gIH1cbiAgdGVtcEJvdW5kcy51bmlvbih0aXRsZS5ib3VuZHMpO1xuXG4gIC8vIHBvc2l0aW9uIHRpdGxlIGdyb3VwXG4gIHN3aXRjaCAob3JpZW50KSB7XG4gICAgY2FzZSBUb3A6XG4gICAgICB4ID0gcG9zO1xuICAgICAgeSA9IHZpZXdCb3VuZHMueTEgLSB0ZW1wQm91bmRzLmhlaWdodCgpIC0gb2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBMZWZ0OlxuICAgICAgeCA9IHZpZXdCb3VuZHMueDEgLSB0ZW1wQm91bmRzLndpZHRoKCkgLSBvZmZzZXQ7XG4gICAgICB5ID0gcG9zO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBSaWdodDpcbiAgICAgIHggPSB2aWV3Qm91bmRzLngyICsgdGVtcEJvdW5kcy53aWR0aCgpICsgb2Zmc2V0O1xuICAgICAgeSA9IHBvcztcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQm90dG9tOlxuICAgICAgeCA9IHBvcztcbiAgICAgIHkgPSB2aWV3Qm91bmRzLnkyICsgb2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHggPSBncm91cC54O1xuICAgICAgeSA9IGdyb3VwLnk7XG4gIH1cbiAgaWYgKHNldChncm91cCwgJ3gnLCB4KSB8IHNldChncm91cCwgJ3knLCB5KSkge1xuICAgIHRlbXBCb3VuZHMudHJhbnNsYXRlKHgsIHkpO1xuICAgIHZpZXcuZGlydHkoZ3JvdXApO1xuICAgIGdyb3VwLmJvdW5kcy5jbGVhcigpLnVuaW9uKHRlbXBCb3VuZHMpO1xuICAgIG1hcmsuYm91bmRzLmNsZWFyKCkudW5pb24odGVtcEJvdW5kcyk7XG4gICAgdmlldy5kaXJ0eShncm91cCk7XG4gIH1cbiAgcmV0dXJuIGdyb3VwLmJvdW5kcztcbn1cblxuLyoqXG4gKiBMYXlvdXQgdmlldyBlbGVtZW50cyBzdWNoIGFzIGF4ZXMgYW5kIGxlZ2VuZHMuXG4gKiBBbHNvIHBlcmZvcm1zIHNpemUgYWRqdXN0bWVudHMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMgLSBUaGUgcGFyYW1ldGVycyBmb3IgdGhpcyBvcGVyYXRvci5cbiAqIEBwYXJhbSB7b2JqZWN0fSBwYXJhbXMubWFyayAtIFNjZW5lZ3JhcGggbWFyayBvZiBncm91cHMgdG8gbGF5b3V0LlxuICovXG5mdW5jdGlvbiBWaWV3TGF5b3V0KHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuaW5oZXJpdHMoVmlld0xheW91dCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IHZpZXcgPSBwdWxzZS5kYXRhZmxvdztcbiAgICBfLm1hcmsuaXRlbXMuZm9yRWFjaChncm91cCA9PiB7XG4gICAgICBpZiAoXy5sYXlvdXQpIHRyZWxsaXNMYXlvdXQodmlldywgZ3JvdXAsIF8ubGF5b3V0KTtcbiAgICAgIGxheW91dEdyb3VwKHZpZXcsIGdyb3VwLCBfKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2hvdWxkUmVmbG93KF8ubWFyay5ncm91cCkgPyBwdWxzZS5yZWZsb3coKSA6IHB1bHNlO1xuICB9XG59KTtcbmZ1bmN0aW9uIHNob3VsZFJlZmxvdyhncm91cCkge1xuICAvLyBXZSB0eXBpY2FsbHkgc2hvdWxkIHJlZmxvdyBpZiBsYXlvdXQgaXMgaW52b2tlZCAoIzI1NjgpLCBhcyBjaGlsZCBpdGVtc1xuICAvLyBtYXkgaGF2ZSByZXNpemVkIGFuZCByZWZsb3cgZW5zdXJlcyBncm91cCBib3VuZHMgYXJlIHJlLWNhbGN1bGF0ZWQuXG4gIC8vIEhvd2V2ZXIsIGxlZ2VuZCBlbnRyaWVzIGhhdmUgYSBzcGVjaWFsIGV4Y2VwdGlvbiB0byBhdm9pZCBpbnN0YWJpbGl0eS5cbiAgLy8gRm9yIGV4YW1wbGUsIGlmIGEgc2VsZWN0ZWQgbGVnZW5kIHN5bWJvbCBnYWlucyBhIHN0cm9rZSBvbiBob3ZlcixcbiAgLy8gd2UgZG9uJ3Qgd2FudCB0byByZS1wb3NpdGlvbiBzdWJzZXF1ZW50IGVsZW1lbnRzIGluIHRoZSBsZWdlbmQuXG4gIHJldHVybiBncm91cCAmJiBncm91cC5tYXJrLnJvbGUgIT09ICdsZWdlbmQtZW50cnknO1xufVxuZnVuY3Rpb24gbGF5b3V0R3JvdXAodmlldywgZ3JvdXAsIF8pIHtcbiAgdmFyIGl0ZW1zID0gZ3JvdXAuaXRlbXMsXG4gICAgd2lkdGggPSBNYXRoLm1heCgwLCBncm91cC53aWR0aCB8fCAwKSxcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCBncm91cC5oZWlnaHQgfHwgMCksXG4gICAgdmlld0JvdW5kcyA9IG5ldyBCb3VuZHMoKS5zZXQoMCwgMCwgd2lkdGgsIGhlaWdodCksXG4gICAgeEJvdW5kcyA9IHZpZXdCb3VuZHMuY2xvbmUoKSxcbiAgICB5Qm91bmRzID0gdmlld0JvdW5kcy5jbG9uZSgpLFxuICAgIGxlZ2VuZHMgPSBbXSxcbiAgICB0aXRsZSxcbiAgICBtYXJrLFxuICAgIG9yaWVudCxcbiAgICBiLFxuICAgIGksXG4gICAgbjtcblxuICAvLyBsYXlvdXQgYXhlcywgZ2F0aGVyIGxlZ2VuZHMsIGNvbGxlY3QgYm91bmRzXG4gIGZvciAoaSA9IDAsIG4gPSBpdGVtcy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICBtYXJrID0gaXRlbXNbaV07XG4gICAgc3dpdGNoIChtYXJrLnJvbGUpIHtcbiAgICAgIGNhc2UgQXhpc1JvbGU6XG4gICAgICAgIGIgPSBpc1lBeGlzKG1hcmspID8geEJvdW5kcyA6IHlCb3VuZHM7XG4gICAgICAgIGIudW5pb24oYXhpc0xheW91dCh2aWV3LCBtYXJrLCB3aWR0aCwgaGVpZ2h0KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUaXRsZVJvbGU6XG4gICAgICAgIHRpdGxlID0gbWFyaztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIExlZ2VuZFJvbGU6XG4gICAgICAgIGxlZ2VuZHMucHVzaChsZWdlbmRMYXlvdXQodmlldywgbWFyaykpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgRnJhbWVSb2xlOlxuICAgICAgY2FzZSBTY29wZVJvbGU6XG4gICAgICBjYXNlIFJvd0hlYWRlcjpcbiAgICAgIGNhc2UgUm93Rm9vdGVyOlxuICAgICAgY2FzZSBSb3dUaXRsZTpcbiAgICAgIGNhc2UgQ29sSGVhZGVyOlxuICAgICAgY2FzZSBDb2xGb290ZXI6XG4gICAgICBjYXNlIENvbFRpdGxlOlxuICAgICAgICB4Qm91bmRzLnVuaW9uKG1hcmsuYm91bmRzKTtcbiAgICAgICAgeUJvdW5kcy51bmlvbihtYXJrLmJvdW5kcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdmlld0JvdW5kcy51bmlvbihtYXJrLmJvdW5kcyk7XG4gICAgfVxuICB9XG5cbiAgLy8gbGF5b3V0IGxlZ2VuZHMsIGFkanVzdCB2aWV3Qm91bmRzXG4gIGlmIChsZWdlbmRzLmxlbmd0aCkge1xuICAgIC8vIGdyb3VwIGxlZ2VuZHMgYnkgb3JpZW50XG4gICAgY29uc3QgbCA9IHt9O1xuICAgIGxlZ2VuZHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgIG9yaWVudCA9IGl0ZW0ub3JpZW50IHx8IFJpZ2h0O1xuICAgICAgaWYgKG9yaWVudCAhPT0gTm9uZSkgKGxbb3JpZW50XSB8fCAobFtvcmllbnRdID0gW10pKS5wdXNoKGl0ZW0pO1xuICAgIH0pO1xuXG4gICAgLy8gcGVyZm9ybSBncmlkIGxheW91dCBmb3IgZWFjaCBvcmllbnQgZ3JvdXBcbiAgICBmb3IgKGNvbnN0IG9yaWVudCBpbiBsKSB7XG4gICAgICBjb25zdCBnID0gbFtvcmllbnRdO1xuICAgICAgZ3JpZExheW91dCh2aWV3LCBnLCBsZWdlbmRQYXJhbXMoZywgb3JpZW50LCBfLmxlZ2VuZHMsIHhCb3VuZHMsIHlCb3VuZHMsIHdpZHRoLCBoZWlnaHQpKTtcbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgdmlldyBib3VuZHNcbiAgICBsZWdlbmRzLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICBjb25zdCBiID0gaXRlbS5ib3VuZHM7XG4gICAgICBpZiAoIWIuZXF1YWxzKGl0ZW0uX2JvdW5kcykpIHtcbiAgICAgICAgaXRlbS5ib3VuZHMgPSBpdGVtLl9ib3VuZHM7XG4gICAgICAgIHZpZXcuZGlydHkoaXRlbSk7IC8vIGRpcnR5IHByZXZpb3VzIGxvY2F0aW9uXG4gICAgICAgIGl0ZW0uYm91bmRzID0gYjtcbiAgICAgICAgdmlldy5kaXJ0eShpdGVtKTtcbiAgICAgIH1cbiAgICAgIGlmIChfLmF1dG9zaXplICYmIChfLmF1dG9zaXplLnR5cGUgPT09IEZpdCB8fCBfLmF1dG9zaXplLnR5cGUgPT09IEZpdFggfHwgXy5hdXRvc2l6ZS50eXBlID09PSBGaXRZKSkge1xuICAgICAgICAvLyBGb3IgYXV0b3NpemUgZml0LCBpbmNvcnBvcmF0ZSB0aGUgb3J0aG9nb25hbCBkaW1lbnNpb24gb25seS5cbiAgICAgICAgLy8gTGVnZW5kcyB0aGF0IG92ZXJydW4gdGhlIGNoYXJ0IGFyZWEgd2lsbCB0aGVuIGJlIGNsaXBwZWQ7XG4gICAgICAgIC8vIG90aGVyd2lzZSB0aGUgY2hhcnQgYXJlYSBnZXRzIHJlZHVjZWQgdG8gbm90aGluZyFcbiAgICAgICAgc3dpdGNoIChpdGVtLm9yaWVudCkge1xuICAgICAgICAgIGNhc2UgTGVmdDpcbiAgICAgICAgICBjYXNlIFJpZ2h0OlxuICAgICAgICAgICAgdmlld0JvdW5kcy5hZGQoYi54MSwgMCkuYWRkKGIueDIsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBUb3A6XG4gICAgICAgICAgY2FzZSBCb3R0b206XG4gICAgICAgICAgICB2aWV3Qm91bmRzLmFkZCgwLCBiLnkxKS5hZGQoMCwgYi55Mik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZpZXdCb3VuZHMudW5pb24oYik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBjb21iaW5lIGJvdW5kaW5nIGJveGVzXG4gIHZpZXdCb3VuZHMudW5pb24oeEJvdW5kcykudW5pb24oeUJvdW5kcyk7XG5cbiAgLy8gbGF5b3V0IHRpdGxlLCBhZGp1c3QgYm91bmRzXG4gIGlmICh0aXRsZSkge1xuICAgIHZpZXdCb3VuZHMudW5pb24odGl0bGVMYXlvdXQodmlldywgdGl0bGUsIHdpZHRoLCBoZWlnaHQsIHZpZXdCb3VuZHMpKTtcbiAgfVxuXG4gIC8vIG92ZXJyaWRlIGFnZ3JlZ2F0ZWQgdmlldyBib3VuZHMgaWYgY29udGVudCBpcyBjbGlwcGVkXG4gIGlmIChncm91cC5jbGlwKSB7XG4gICAgdmlld0JvdW5kcy5zZXQoMCwgMCwgZ3JvdXAud2lkdGggfHwgMCwgZ3JvdXAuaGVpZ2h0IHx8IDApO1xuICB9XG5cbiAgLy8gcGVyZm9ybSBzaXplIGFkanVzdG1lbnRcbiAgdmlld1NpemVMYXlvdXQodmlldywgZ3JvdXAsIHZpZXdCb3VuZHMsIF8pO1xufVxuZnVuY3Rpb24gdmlld1NpemVMYXlvdXQodmlldywgZ3JvdXAsIHZpZXdCb3VuZHMsIF8pIHtcbiAgY29uc3QgYXV0byA9IF8uYXV0b3NpemUgfHwge30sXG4gICAgdHlwZSA9IGF1dG8udHlwZTtcbiAgaWYgKHZpZXcuX2F1dG9zaXplIDwgMSB8fCAhdHlwZSkgcmV0dXJuO1xuICBsZXQgdmlld1dpZHRoID0gdmlldy5fd2lkdGgsXG4gICAgdmlld0hlaWdodCA9IHZpZXcuX2hlaWdodCxcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIGdyb3VwLndpZHRoIHx8IDApLFxuICAgIGxlZnQgPSBNYXRoLm1heCgwLCBNYXRoLmNlaWwoLXZpZXdCb3VuZHMueDEpKSxcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCBncm91cC5oZWlnaHQgfHwgMCksXG4gICAgdG9wID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKC12aWV3Qm91bmRzLnkxKSk7XG4gIGNvbnN0IHJpZ2h0ID0gTWF0aC5tYXgoMCwgTWF0aC5jZWlsKHZpZXdCb3VuZHMueDIgLSB3aWR0aCkpLFxuICAgIGJvdHRvbSA9IE1hdGgubWF4KDAsIE1hdGguY2VpbCh2aWV3Qm91bmRzLnkyIC0gaGVpZ2h0KSk7XG4gIGlmIChhdXRvLmNvbnRhaW5zID09PSBQYWRkaW5nKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IHZpZXcucGFkZGluZygpO1xuICAgIHZpZXdXaWR0aCAtPSBwYWRkaW5nLmxlZnQgKyBwYWRkaW5nLnJpZ2h0O1xuICAgIHZpZXdIZWlnaHQgLT0gcGFkZGluZy50b3AgKyBwYWRkaW5nLmJvdHRvbTtcbiAgfVxuICBpZiAodHlwZSA9PT0gTm9uZSkge1xuICAgIGxlZnQgPSAwO1xuICAgIHRvcCA9IDA7XG4gICAgd2lkdGggPSB2aWV3V2lkdGg7XG4gICAgaGVpZ2h0ID0gdmlld0hlaWdodDtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBGaXQpIHtcbiAgICB3aWR0aCA9IE1hdGgubWF4KDAsIHZpZXdXaWR0aCAtIGxlZnQgLSByaWdodCk7XG4gICAgaGVpZ2h0ID0gTWF0aC5tYXgoMCwgdmlld0hlaWdodCAtIHRvcCAtIGJvdHRvbSk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gRml0WCkge1xuICAgIHdpZHRoID0gTWF0aC5tYXgoMCwgdmlld1dpZHRoIC0gbGVmdCAtIHJpZ2h0KTtcbiAgICB2aWV3SGVpZ2h0ID0gaGVpZ2h0ICsgdG9wICsgYm90dG9tO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09IEZpdFkpIHtcbiAgICB2aWV3V2lkdGggPSB3aWR0aCArIGxlZnQgKyByaWdodDtcbiAgICBoZWlnaHQgPSBNYXRoLm1heCgwLCB2aWV3SGVpZ2h0IC0gdG9wIC0gYm90dG9tKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSBQYWQpIHtcbiAgICB2aWV3V2lkdGggPSB3aWR0aCArIGxlZnQgKyByaWdodDtcbiAgICB2aWV3SGVpZ2h0ID0gaGVpZ2h0ICsgdG9wICsgYm90dG9tO1xuICB9XG4gIHZpZXcuX3Jlc2l6ZVZpZXcodmlld1dpZHRoLCB2aWV3SGVpZ2h0LCB3aWR0aCwgaGVpZ2h0LCBbbGVmdCwgdG9wXSwgYXV0by5yZXNpemUpO1xufVxuXG5leHBvcnQgeyBCb3VuZCBhcyBib3VuZCwgSWRlbnRpZmllciBhcyBpZGVudGlmaWVyLCBNYXJrIGFzIG1hcmssIE92ZXJsYXAgYXMgb3ZlcmxhcCwgUmVuZGVyIGFzIHJlbmRlciwgVmlld0xheW91dCBhcyB2aWV3bGF5b3V0IH07XG4iLCJpbXBvcnQgeyBpc1N0cmluZywgZXJyb3IsIHRydXRoeSwgaGFzT3duUHJvcGVydHksIGNvbnN0YW50LCBleHRlbmQsIGFycmF5LCBpc09iamVjdCwgaXNBcnJheSwgdG9TZXQsIGRlYm91bmNlLCBpc0RhdGUsIGluaGVyaXRzLCBzdHJpbmdWYWx1ZSB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQgeyBjaGFuZ2VzZXQsIGlzQ2hhbmdlU2V0LCBFdmVudFN0cmVhbSwgdHJhbnNmb3JtcywgRGF0YWZsb3csIGFzeW5jQ2FsbGJhY2sgfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IHBvaW50LCByZW5kZXJNb2R1bGUsIENhbnZhc0hhbmRsZXIsIFJlbmRlclR5cGUsIFNjZW5lZ3JhcGggfSBmcm9tICd2ZWdhLXNjZW5lZ3JhcGgnO1xuaW1wb3J0IHsgdGlja1N0ZXAgfSBmcm9tICdkMy1hcnJheSc7XG5pbXBvcnQgeyBmdW5jdGlvbkNvbnRleHQgfSBmcm9tICd2ZWdhLWZ1bmN0aW9ucyc7XG5pbXBvcnQgeyBjb250ZXh0IH0gZnJvbSAndmVnYS1ydW50aW1lJztcbmltcG9ydCB7IGludGVydmFsIH0gZnJvbSAnZDMtdGltZXInO1xuaW1wb3J0IHsgbG9jYWxlIH0gZnJvbSAndmVnYS1mb3JtYXQnO1xuXG4vLyBpbml0aWFsaXplIGFyaWEgcm9sZSBhbmQgbGFiZWwgYXR0cmlidXRlc1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUFyaWEodmlldykge1xuICBjb25zdCBlbCA9IHZpZXcuY29udGFpbmVyKCk7XG4gIGlmIChlbCkge1xuICAgIGVsLnNldEF0dHJpYnV0ZSgncm9sZScsICdncmFwaGljcy1kb2N1bWVudCcpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1yb2xlRGVzY3JpcHRpb24nLCAndmlzdWFsaXphdGlvbicpO1xuICAgIGFyaWFMYWJlbChlbCwgdmlldy5kZXNjcmlwdGlvbigpKTtcbiAgfVxufVxuXG4vLyB1cGRhdGUgYXJpYS1sYWJlbCBpZiB3ZSBoYXZlIGEgRE9NIGNvbnRhaW5lciBlbGVtZW50XG5mdW5jdGlvbiBhcmlhTGFiZWwoZWwsIGRlc2MpIHtcbiAgaWYgKGVsKSBkZXNjID09IG51bGwgPyBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSA6IGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIGRlc2MpO1xufVxuXG5mdW5jdGlvbiBiYWNrZ3JvdW5kICh2aWV3KSB7XG4gIC8vIHJlc3BvbmQgdG8gYmFja2dyb3VuZCBzaWduYWxcbiAgdmlldy5hZGQobnVsbCwgXyA9PiB7XG4gICAgdmlldy5fYmFja2dyb3VuZCA9IF8uYmc7XG4gICAgdmlldy5fcmVzaXplID0gMTtcbiAgICByZXR1cm4gXy5iZztcbiAgfSwge1xuICAgIGJnOiB2aWV3Ll9zaWduYWxzLmJhY2tncm91bmRcbiAgfSk7XG59XG5cbmNvbnN0IERlZmF1bHQgPSAnZGVmYXVsdCc7XG5mdW5jdGlvbiBjdXJzb3IgKHZpZXcpIHtcbiAgLy8gZ2V0IGN1cnNvciBzaWduYWwsIGFkZCB0byBkYXRhZmxvdyBpZiBuZWVkZWRcbiAgY29uc3QgY3Vyc29yID0gdmlldy5fc2lnbmFscy5jdXJzb3IgfHwgKHZpZXcuX3NpZ25hbHMuY3Vyc29yID0gdmlldy5hZGQoe1xuICAgIHVzZXI6IERlZmF1bHQsXG4gICAgaXRlbTogbnVsbFxuICB9KSk7XG5cbiAgLy8gZXZhbHVhdGUgY3Vyc29yIG9uIGVhY2ggcG9pbnRlcm1vdmUgZXZlbnRcbiAgdmlldy5vbih2aWV3LmV2ZW50cygndmlldycsICdwb2ludGVybW92ZScpLCBjdXJzb3IsIChfLCBldmVudCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gY3Vyc29yLnZhbHVlLFxuICAgICAgdXNlciA9IHZhbHVlID8gaXNTdHJpbmcodmFsdWUpID8gdmFsdWUgOiB2YWx1ZS51c2VyIDogRGVmYXVsdCxcbiAgICAgIGl0ZW0gPSBldmVudC5pdGVtICYmIGV2ZW50Lml0ZW0uY3Vyc29yIHx8IG51bGw7XG4gICAgcmV0dXJuIHZhbHVlICYmIHVzZXIgPT09IHZhbHVlLnVzZXIgJiYgaXRlbSA9PSB2YWx1ZS5pdGVtID8gdmFsdWUgOiB7XG4gICAgICB1c2VyOiB1c2VyLFxuICAgICAgaXRlbTogaXRlbVxuICAgIH07XG4gIH0pO1xuXG4gIC8vIHdoZW4gY3Vyc29yIHNpZ25hbCB1cGRhdGVzLCBzZXQgdmlzaWJsZSBjdXJzb3JcbiAgdmlldy5hZGQobnVsbCwgZnVuY3Rpb24gKF8pIHtcbiAgICBsZXQgdXNlciA9IF8uY3Vyc29yLFxuICAgICAgaXRlbSA9IHRoaXMudmFsdWU7XG4gICAgaWYgKCFpc1N0cmluZyh1c2VyKSkge1xuICAgICAgaXRlbSA9IHVzZXIuaXRlbTtcbiAgICAgIHVzZXIgPSB1c2VyLnVzZXI7XG4gICAgfVxuICAgIHNldEN1cnNvcih2aWV3LCB1c2VyICYmIHVzZXIgIT09IERlZmF1bHQgPyB1c2VyIDogaXRlbSB8fCB1c2VyKTtcbiAgICByZXR1cm4gaXRlbTtcbiAgfSwge1xuICAgIGN1cnNvcjogY3Vyc29yXG4gIH0pO1xufVxuZnVuY3Rpb24gc2V0Q3Vyc29yKHZpZXcsIGN1cnNvcikge1xuICBjb25zdCBlbCA9IHZpZXcuZ2xvYmFsQ3Vyc29yKCkgPyB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmJvZHkgOiB2aWV3LmNvbnRhaW5lcigpO1xuICBpZiAoZWwpIHtcbiAgICByZXR1cm4gY3Vyc29yID09IG51bGwgPyBlbC5zdHlsZS5yZW1vdmVQcm9wZXJ0eSgnY3Vyc29yJykgOiBlbC5zdHlsZS5jdXJzb3IgPSBjdXJzb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGF0YXJlZih2aWV3LCBuYW1lKSB7XG4gIHZhciBkYXRhID0gdmlldy5fcnVudGltZS5kYXRhO1xuICBpZiAoIWhhc093blByb3BlcnR5KGRhdGEsIG5hbWUpKSB7XG4gICAgZXJyb3IoJ1VucmVjb2duaXplZCBkYXRhIHNldDogJyArIG5hbWUpO1xuICB9XG4gIHJldHVybiBkYXRhW25hbWVdO1xufVxuZnVuY3Rpb24gZGF0YShuYW1lLCB2YWx1ZXMpIHtcbiAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPCAyID8gZGF0YXJlZih0aGlzLCBuYW1lKS52YWx1ZXMudmFsdWUgOiBjaGFuZ2UuY2FsbCh0aGlzLCBuYW1lLCBjaGFuZ2VzZXQoKS5yZW1vdmUodHJ1dGh5KS5pbnNlcnQodmFsdWVzKSk7XG59XG5mdW5jdGlvbiBjaGFuZ2UobmFtZSwgY2hhbmdlcykge1xuICBpZiAoIWlzQ2hhbmdlU2V0KGNoYW5nZXMpKSB7XG4gICAgZXJyb3IoJ1NlY29uZCBhcmd1bWVudCB0byBjaGFuZ2VzIG11c3QgYmUgYSBjaGFuZ2VzZXQuJyk7XG4gIH1cbiAgY29uc3QgZGF0YXNldCA9IGRhdGFyZWYodGhpcywgbmFtZSk7XG4gIGRhdGFzZXQubW9kaWZpZWQgPSB0cnVlO1xuICByZXR1cm4gdGhpcy5wdWxzZShkYXRhc2V0LmlucHV0LCBjaGFuZ2VzKTtcbn1cbmZ1bmN0aW9uIGluc2VydChuYW1lLCBfKSB7XG4gIHJldHVybiBjaGFuZ2UuY2FsbCh0aGlzLCBuYW1lLCBjaGFuZ2VzZXQoKS5pbnNlcnQoXykpO1xufVxuZnVuY3Rpb24gcmVtb3ZlKG5hbWUsIF8pIHtcbiAgcmV0dXJuIGNoYW5nZS5jYWxsKHRoaXMsIG5hbWUsIGNoYW5nZXNldCgpLnJlbW92ZShfKSk7XG59XG5cbmZ1bmN0aW9uIHdpZHRoKHZpZXcpIHtcbiAgdmFyIHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHZpZXcuX3ZpZXdXaWR0aCArIHBhZGRpbmcubGVmdCArIHBhZGRpbmcucmlnaHQpO1xufVxuZnVuY3Rpb24gaGVpZ2h0KHZpZXcpIHtcbiAgdmFyIHBhZGRpbmcgPSB2aWV3LnBhZGRpbmcoKTtcbiAgcmV0dXJuIE1hdGgubWF4KDAsIHZpZXcuX3ZpZXdIZWlnaHQgKyBwYWRkaW5nLnRvcCArIHBhZGRpbmcuYm90dG9tKTtcbn1cbmZ1bmN0aW9uIG9mZnNldCh2aWV3KSB7XG4gIHZhciBwYWRkaW5nID0gdmlldy5wYWRkaW5nKCksXG4gICAgb3JpZ2luID0gdmlldy5fb3JpZ2luO1xuICByZXR1cm4gW3BhZGRpbmcubGVmdCArIG9yaWdpblswXSwgcGFkZGluZy50b3AgKyBvcmlnaW5bMV1dO1xufVxuZnVuY3Rpb24gcmVzaXplUmVuZGVyZXIodmlldykge1xuICB2YXIgb3JpZ2luID0gb2Zmc2V0KHZpZXcpLFxuICAgIHcgPSB3aWR0aCh2aWV3KSxcbiAgICBoID0gaGVpZ2h0KHZpZXcpO1xuICB2aWV3Ll9yZW5kZXJlci5iYWNrZ3JvdW5kKHZpZXcuYmFja2dyb3VuZCgpKTtcbiAgdmlldy5fcmVuZGVyZXIucmVzaXplKHcsIGgsIG9yaWdpbik7XG4gIHZpZXcuX2hhbmRsZXIub3JpZ2luKG9yaWdpbik7XG4gIHZpZXcuX3Jlc2l6ZUxpc3RlbmVycy5mb3JFYWNoKGhhbmRsZXIgPT4ge1xuICAgIHRyeSB7XG4gICAgICBoYW5kbGVyKHcsIGgpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB2aWV3LmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEV4dGVuZCBhbiBldmVudCB3aXRoIGFkZGl0aW9uYWwgdmlldy1zcGVjaWZpYyBtZXRob2RzLlxuICogQWRkcyBhIG5ldyBwcm9wZXJ0eSAoJ3ZlZ2EnKSB0byBhbiBldmVudCB0aGF0IHByb3ZpZGVzIGEgbnVtYmVyXG4gKiBvZiBtZXRob2RzIGZvciBxdWVyeWluZyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBpbnRlcmFjdGlvbi5cbiAqIFRoZSB2ZWdhIG9iamVjdCBwcm92aWRlcyB0aGUgZm9sbG93aW5nIG1ldGhvZHM6XG4gKiAgIHZpZXcgLSBSZXR1cm5zIHRoZSBiYWNraW5nIFZpZXcgaW5zdGFuY2UuXG4gKiAgIGl0ZW0gLSBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjZW5lZ3JhcGggaXRlbSAoaWYgYW55KS5cbiAqICAgZ3JvdXAgLSBSZXR1cm5zIHRoZSBjdXJyZW50bHkgYWN0aXZlIHNjZW5lZ3JhcGggZ3JvdXAgKGlmIGFueSkuXG4gKiAgICAgVGhpcyBtZXRob2QgYWNjZXB0cyBhIHNpbmdsZSBzdHJpbmctdHlwZWQgYXJndW1lbnQgaW5kaWNhdGluZyB0aGUgbmFtZVxuICogICAgIG9mIHRoZSBkZXNpcmVkIHBhcmVudCBncm91cC4gVGhlIHNjZW5lZ3JhcGggd2lsbCBiZSB0cmF2ZXJzZWQgZnJvbVxuICogICAgIHRoZSBpdGVtIHVwIHRvd2FyZHMgdGhlIHJvb3QgdG8gc2VhcmNoIGZvciBhIG1hdGNoaW5nIGdyb3VwLiBJZiBub1xuICogICAgIGFyZ3VtZW50IGlzIHByb3ZpZGVkIHRoZSBlbmNsb3NpbmcgZ3JvdXAgZm9yIHRoZSBhY3RpdmUgaXRlbSBpc1xuICogICAgIHJldHVybmVkLCB1bmxlc3MgdGhlIGl0ZW0gaXQgaXRzZWxmIGEgZ3JvdXAsIGluIHdoaWNoIGNhc2UgaXQgaXNcbiAqICAgICByZXR1cm5lZCBkaXJlY3RseS5cbiAqICAgeHkgLSBSZXR1cm5zIGEgdHdvLWVsZW1lbnQgYXJyYXkgY29udGFpbmluZyB0aGUgeCBhbmQgeSBjb29yZGluYXRlcyBmb3JcbiAqICAgICBtb3VzZSBvciB0b3VjaCBldmVudHMuIEZvciB0b3VjaCBldmVudHMsIHRoaXMgaXMgYmFzZWQgb24gdGhlIGZpcnN0XG4gKiAgICAgZWxlbWVudHMgaW4gdGhlIGNoYW5nZWRUb3VjaGVzIGFycmF5LiBUaGlzIG1ldGhvZCBhY2NlcHRzIGEgc2luZ2xlXG4gKiAgICAgYXJndW1lbnQ6IGVpdGhlciBhbiBpdGVtIGluc3RhbmNlIG9yIG1hcmsgbmFtZSB0aGF0IHNob3VsZCBzZXJ2ZSBhc1xuICogICAgIHRoZSByZWZlcmVuY2UgY29vcmRpbmF0ZSBzeXN0ZW0uIElmIG5vIGFyZ3VtZW50IGlzIHByb3ZpZGVkIHRoZVxuICogICAgIHRvcC1sZXZlbCB2aWV3IGNvb3JkaW5hdGUgc3lzdGVtIGlzIGFzc3VtZWQuXG4gKiAgIHggLSBSZXR1cm5zIHRoZSBjdXJyZW50IHgtY29vcmRpbmF0ZSwgYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgeHkuXG4gKiAgIHkgLSBSZXR1cm5zIHRoZSBjdXJyZW50IHktY29vcmRpbmF0ZSwgYWNjZXB0cyB0aGUgc2FtZSBhcmd1bWVudHMgYXMgeHkuXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBpbnB1dCBldmVudCB0byBleHRlbmQuXG4gKiBAcGFyYW0ge0l0ZW19IGl0ZW0gLSBUaGUgY3VycmVudGx5IGFjdGl2ZSBzY2VuZWdyYXBoIGl0ZW0gKGlmIGFueSkuXG4gKiBAcmV0dXJuIHtFdmVudH0gLSBUaGUgZXh0ZW5kZWQgaW5wdXQgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIGV2ZW50RXh0ZW5kICh2aWV3LCBldmVudCwgaXRlbSkge1xuICB2YXIgciA9IHZpZXcuX3JlbmRlcmVyLFxuICAgIGVsID0gciAmJiByLmNhbnZhcygpLFxuICAgIHAsXG4gICAgZSxcbiAgICB0cmFuc2xhdGU7XG4gIGlmIChlbCkge1xuICAgIHRyYW5zbGF0ZSA9IG9mZnNldCh2aWV3KTtcbiAgICBlID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMgPyBldmVudC5jaGFuZ2VkVG91Y2hlc1swXSA6IGV2ZW50O1xuICAgIHAgPSBwb2ludChlLCBlbCk7XG4gICAgcFswXSAtPSB0cmFuc2xhdGVbMF07XG4gICAgcFsxXSAtPSB0cmFuc2xhdGVbMV07XG4gIH1cbiAgZXZlbnQuZGF0YWZsb3cgPSB2aWV3O1xuICBldmVudC5pdGVtID0gaXRlbTtcbiAgZXZlbnQudmVnYSA9IGV4dGVuc2lvbih2aWV3LCBpdGVtLCBwKTtcbiAgcmV0dXJuIGV2ZW50O1xufVxuZnVuY3Rpb24gZXh0ZW5zaW9uKHZpZXcsIGl0ZW0sIHBvaW50KSB7XG4gIGNvbnN0IGl0ZW1Hcm91cCA9IGl0ZW0gPyBpdGVtLm1hcmsubWFya3R5cGUgPT09ICdncm91cCcgPyBpdGVtIDogaXRlbS5tYXJrLmdyb3VwIDogbnVsbDtcbiAgZnVuY3Rpb24gZ3JvdXAobmFtZSkge1xuICAgIHZhciBnID0gaXRlbUdyb3VwLFxuICAgICAgaTtcbiAgICBpZiAobmFtZSkgZm9yIChpID0gaXRlbTsgaTsgaSA9IGkubWFyay5ncm91cCkge1xuICAgICAgaWYgKGkubWFyay5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIGcgPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGcgJiYgZy5tYXJrICYmIGcubWFyay5pbnRlcmFjdGl2ZSA/IGcgOiB7fTtcbiAgfVxuICBmdW5jdGlvbiB4eShpdGVtKSB7XG4gICAgaWYgKCFpdGVtKSByZXR1cm4gcG9pbnQ7XG4gICAgaWYgKGlzU3RyaW5nKGl0ZW0pKSBpdGVtID0gZ3JvdXAoaXRlbSk7XG4gICAgY29uc3QgcCA9IHBvaW50LnNsaWNlKCk7XG4gICAgd2hpbGUgKGl0ZW0pIHtcbiAgICAgIHBbMF0gLT0gaXRlbS54IHx8IDA7XG4gICAgICBwWzFdIC09IGl0ZW0ueSB8fCAwO1xuICAgICAgaXRlbSA9IGl0ZW0ubWFyayAmJiBpdGVtLm1hcmsuZ3JvdXA7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9XG4gIHJldHVybiB7XG4gICAgdmlldzogY29uc3RhbnQodmlldyksXG4gICAgaXRlbTogY29uc3RhbnQoaXRlbSB8fCB7fSksXG4gICAgZ3JvdXA6IGdyb3VwLFxuICAgIHh5OiB4eSxcbiAgICB4OiBpdGVtID0+IHh5KGl0ZW0pWzBdLFxuICAgIHk6IGl0ZW0gPT4geHkoaXRlbSlbMV1cbiAgfTtcbn1cblxuY29uc3QgVklFVyA9ICd2aWV3JyxcbiAgVElNRVIgPSAndGltZXInLFxuICBXSU5ET1cgPSAnd2luZG93JyxcbiAgTk9fVFJBUCA9IHtcbiAgICB0cmFwOiBmYWxzZVxuICB9O1xuXG4vKipcbiAqIEluaXRpYWxpemUgZXZlbnQgaGFuZGxpbmcgY29uZmlndXJhdGlvbi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBUaGUgY29uZmlndXJhdGlvbiBzZXR0aW5ncy5cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZUV2ZW50Q29uZmlnKGNvbmZpZykge1xuICBjb25zdCBldmVudHMgPSBleHRlbmQoe1xuICAgIGRlZmF1bHRzOiB7fVxuICB9LCBjb25maWcpO1xuICBjb25zdCB1bnBhY2sgPSAob2JqLCBrZXlzKSA9PiB7XG4gICAga2V5cy5mb3JFYWNoKGsgPT4ge1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkgb2JqW2tdID0gdG9TZXQob2JqW2tdKTtcbiAgICB9KTtcbiAgfTtcbiAgdW5wYWNrKGV2ZW50cy5kZWZhdWx0cywgWydwcmV2ZW50JywgJ2FsbG93J10pO1xuICB1bnBhY2soZXZlbnRzLCBbJ3ZpZXcnLCAnd2luZG93JywgJ3NlbGVjdG9yJ10pO1xuICByZXR1cm4gZXZlbnRzO1xufVxuZnVuY3Rpb24gdHJhY2tFdmVudExpc3RlbmVyKHZpZXcsIHNvdXJjZXMsIHR5cGUsIGhhbmRsZXIpIHtcbiAgdmlldy5fZXZlbnRMaXN0ZW5lcnMucHVzaCh7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzb3VyY2VzOiBhcnJheShzb3VyY2VzKSxcbiAgICBoYW5kbGVyOiBoYW5kbGVyXG4gIH0pO1xufVxuZnVuY3Rpb24gcHJldmVudCh2aWV3LCB0eXBlKSB7XG4gIHZhciBkZWYgPSB2aWV3Ll9ldmVudENvbmZpZy5kZWZhdWx0cyxcbiAgICBwcmV2ZW50ID0gZGVmLnByZXZlbnQsXG4gICAgYWxsb3cgPSBkZWYuYWxsb3c7XG4gIHJldHVybiBwcmV2ZW50ID09PSBmYWxzZSB8fCBhbGxvdyA9PT0gdHJ1ZSA/IGZhbHNlIDogcHJldmVudCA9PT0gdHJ1ZSB8fCBhbGxvdyA9PT0gZmFsc2UgPyB0cnVlIDogcHJldmVudCA/IHByZXZlbnRbdHlwZV0gOiBhbGxvdyA/ICFhbGxvd1t0eXBlXSA6IHZpZXcucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIHBlcm1pdCh2aWV3LCBrZXksIHR5cGUpIHtcbiAgY29uc3QgcnVsZSA9IHZpZXcuX2V2ZW50Q29uZmlnICYmIHZpZXcuX2V2ZW50Q29uZmlnW2tleV07XG4gIGlmIChydWxlID09PSBmYWxzZSB8fCBpc09iamVjdChydWxlKSAmJiAhcnVsZVt0eXBlXSkge1xuICAgIHZpZXcud2FybihgQmxvY2tlZCAke2tleX0gJHt0eXBlfSBldmVudCBsaXN0ZW5lci5gKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IGV2ZW50IHN0cmVhbSBmcm9tIGFuIGV2ZW50IHNvdXJjZS5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzb3VyY2UgLSBUaGUgZXZlbnQgc291cmNlIHRvIG1vbml0b3IuXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtIHtmdW5jdGlvbihvYmplY3QpOiBib29sZWFufSBbZmlsdGVyXSAtIEV2ZW50IGZpbHRlciBmdW5jdGlvbi5cbiAqIEByZXR1cm4ge0V2ZW50U3RyZWFtfVxuICovXG5mdW5jdGlvbiBldmVudHMoc291cmNlLCB0eXBlLCBmaWx0ZXIpIHtcbiAgdmFyIHZpZXcgPSB0aGlzLFxuICAgIHMgPSBuZXcgRXZlbnRTdHJlYW0oZmlsdGVyKSxcbiAgICBzZW5kID0gZnVuY3Rpb24gKGUsIGl0ZW0pIHtcbiAgICAgIHZpZXcucnVuQXN5bmMobnVsbCwgKCkgPT4ge1xuICAgICAgICBpZiAoc291cmNlID09PSBWSUVXICYmIHByZXZlbnQodmlldywgdHlwZSkpIHtcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcy5yZWNlaXZlKGV2ZW50RXh0ZW5kKHZpZXcsIGUsIGl0ZW0pKTtcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgc291cmNlcztcbiAgaWYgKHNvdXJjZSA9PT0gVElNRVIpIHtcbiAgICBpZiAocGVybWl0KHZpZXcsICd0aW1lcicsIHR5cGUpKSB7XG4gICAgICB2aWV3LnRpbWVyKHNlbmQsIHR5cGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzb3VyY2UgPT09IFZJRVcpIHtcbiAgICBpZiAocGVybWl0KHZpZXcsICd2aWV3JywgdHlwZSkpIHtcbiAgICAgIC8vIHNlbmQgdHJhcHMgZXJyb3JzLCBzbyB1c2Uge3RyYXA6IGZhbHNlfSBvcHRpb25cbiAgICAgIHZpZXcuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBzZW5kLCBOT19UUkFQKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHNvdXJjZSA9PT0gV0lORE9XKSB7XG4gICAgICBpZiAocGVybWl0KHZpZXcsICd3aW5kb3cnLCB0eXBlKSAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBzb3VyY2VzID0gW3dpbmRvd107XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAocGVybWl0KHZpZXcsICdzZWxlY3RvcicsIHR5cGUpKSB7XG4gICAgICAgIHNvdXJjZXMgPSBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc291cmNlKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc291cmNlcykge1xuICAgICAgdmlldy53YXJuKCdDYW4gbm90IHJlc29sdmUgZXZlbnQgc291cmNlOiAnICsgc291cmNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIG4gPSBzb3VyY2VzLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgICBzb3VyY2VzW2ldLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgc2VuZCk7XG4gICAgICB9XG4gICAgICB0cmFja0V2ZW50TGlzdGVuZXIodmlldywgc291cmNlcywgdHlwZSwgc2VuZCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBpdGVtRmlsdGVyKGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5pdGVtO1xufVxuZnVuY3Rpb24gbWFya1RhcmdldChldmVudCkge1xuICAvLyBncmFiIHVwc3RyZWFtIGNvbGxlY3RvciBmZWVkaW5nIHRoZSBtYXJrIG9wZXJhdG9yXG4gIHJldHVybiBldmVudC5pdGVtLm1hcmsuc291cmNlO1xufVxuZnVuY3Rpb24gaW52b2tlKG5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChfLCBldmVudCkge1xuICAgIHJldHVybiBldmVudC52ZWdhLnZpZXcoKS5jaGFuZ2VzZXQoKS5lbmNvZGUoZXZlbnQuaXRlbSwgbmFtZSk7XG4gIH07XG59XG5mdW5jdGlvbiBob3ZlciAoaG92ZXJTZXQsIGxlYXZlU2V0KSB7XG4gIGhvdmVyU2V0ID0gW2hvdmVyU2V0IHx8ICdob3ZlciddO1xuICBsZWF2ZVNldCA9IFtsZWF2ZVNldCB8fCAndXBkYXRlJywgaG92ZXJTZXRbMF1dO1xuXG4gIC8vIGludm9rZSBob3ZlciBzZXQgdXBvbiBwb2ludGVyb3ZlclxuICB0aGlzLm9uKHRoaXMuZXZlbnRzKCd2aWV3JywgJ3BvaW50ZXJvdmVyJywgaXRlbUZpbHRlciksIG1hcmtUYXJnZXQsIGludm9rZShob3ZlclNldCkpO1xuXG4gIC8vIGludm9rZSBsZWF2ZSBzZXQgdXBvbiBwb2ludGVyb3V0XG4gIHRoaXMub24odGhpcy5ldmVudHMoJ3ZpZXcnLCAncG9pbnRlcm91dCcsIGl0ZW1GaWx0ZXIpLCBtYXJrVGFyZ2V0LCBpbnZva2UobGVhdmVTZXQpKTtcbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogRmluYWxpemUgYSBWaWV3IGluc3RhbmNlIHRoYXQgaXMgYmVpbmcgcmVtb3ZlZC5cbiAqIENhbmNlbCBhbnkgcnVubmluZyB0aW1lcnMuXG4gKiBSZW1vdmUgYWxsIGV4dGVybmFsIGV2ZW50IGxpc3RlbmVycy5cbiAqIFJlbW92ZSBhbnkgY3VycmVudGx5IGRpc3BsYXllZCB0b29sdGlwLlxuICovXG5mdW5jdGlvbiBmaW5hbGl6ZSAoKSB7XG4gIHZhciB0b29sdGlwID0gdGhpcy5fdG9vbHRpcCxcbiAgICB0aW1lcnMgPSB0aGlzLl90aW1lcnMsXG4gICAgaGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVyLmhhbmRsZXJzKCksXG4gICAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnMsXG4gICAgbixcbiAgICBtLFxuICAgIGUsXG4gICAgaCxcbiAgICB0O1xuICBuID0gdGltZXJzLmxlbmd0aDtcbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgdGltZXJzW25dLnN0b3AoKTtcbiAgfVxuICBuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgd2hpbGUgKC0tbiA+PSAwKSB7XG4gICAgZSA9IGxpc3RlbmVyc1tuXTtcbiAgICBtID0gZS5zb3VyY2VzLmxlbmd0aDtcbiAgICB3aGlsZSAoLS1tID49IDApIHtcbiAgICAgIGUuc291cmNlc1ttXS5yZW1vdmVFdmVudExpc3RlbmVyKGUudHlwZSwgZS5oYW5kbGVyKTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvb2x0aXApIHtcbiAgICB0b29sdGlwLmNhbGwodGhpcywgdGhpcy5faGFuZGxlciwgbnVsbCwgbnVsbCwgbnVsbCk7XG4gIH1cblxuICAvLyB0dXJuIG9mZiBhbGwgcmVnaXN0ZXJlZCBoYW5kbGVyc1xuICBuID0gaGFuZGxlcnMubGVuZ3RoO1xuICB3aGlsZSAoLS1uID49IDApIHtcbiAgICB0ID0gaGFuZGxlcnNbbl0udHlwZTtcbiAgICBoID0gaGFuZGxlcnNbbl0uaGFuZGxlcjtcbiAgICB0aGlzLl9oYW5kbGVyLm9mZih0LCBoKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gZWxlbWVudCAodGFnLCBhdHRyLCB0ZXh0KSB7XG4gIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBhdHRyKSBlbC5zZXRBdHRyaWJ1dGUoa2V5LCBhdHRyW2tleV0pO1xuICBpZiAodGV4dCAhPSBudWxsKSBlbC50ZXh0Q29udGVudCA9IHRleHQ7XG4gIHJldHVybiBlbDtcbn1cblxuY29uc3QgQmluZENsYXNzID0gJ3ZlZ2EtYmluZCcsXG4gIE5hbWVDbGFzcyA9ICd2ZWdhLWJpbmQtbmFtZScsXG4gIFJhZGlvQ2xhc3MgPSAndmVnYS1iaW5kLXJhZGlvJztcblxuLyoqXG4gKiBCaW5kIGEgc2lnbmFsIHRvIGFuIGV4dGVybmFsIEhUTUwgaW5wdXQgZWxlbWVudC4gVGhlIHJlc3VsdGluZyB0d28td2F5XG4gKiBiaW5kaW5nIHdpbGwgcHJvcGFnYXRlIGlucHV0IGNoYW5nZXMgdG8gc2lnbmFscywgYW5kIHByb3BhZ2F0ZSBzaWduYWxcbiAqIGNoYW5nZXMgdG8gdGhlIGlucHV0IGVsZW1lbnQgc3RhdGUuIElmIHRoaXMgdmlldyBpbnN0YW5jZSBoYXMgbm8gcGFyZW50XG4gKiBlbGVtZW50LCB3ZSBhc3N1bWUgdGhlIHZpZXcgaXMgaGVhZGxlc3MgYW5kIG5vIGJpbmRpbmdzIGFyZSBjcmVhdGVkLlxuICogQHBhcmFtIHtFbGVtZW50fHN0cmluZ30gZWwgLSBUaGUgcGFyZW50IERPTSBlbGVtZW50IHRvIHdoaWNoIHRoZSBpbnB1dFxuICogICBlbGVtZW50IHNob3VsZCBiZSBhcHBlbmRlZCBhcyBhIGNoaWxkLiBJZiBzdHJpbmctdmFsdWVkLCB0aGlzIGFyZ3VtZW50XG4gKiAgIHdpbGwgYmUgdHJlYXRlZCBhcyBhIENTUyBzZWxlY3Rvci4gSWYgbnVsbCBvciB1bmRlZmluZWQsIHRoZSBwYXJlbnRcbiAqICAgZWxlbWVudCBvZiB0aGlzIHZpZXcgd2lsbCBiZSB1c2VkIGFzIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtvYmplY3R9IHBhcmFtIC0gVGhlIGJpbmRpbmcgcGFyYW1ldGVycyB3aGljaCBzcGVjaWZ5IHRoZSBzaWduYWxcbiAqICAgdG8gYmluZCB0bywgdGhlIGlucHV0IGVsZW1lbnQgdHlwZSwgYW5kIHR5cGUtc3BlY2lmaWMgY29uZmlndXJhdGlvbi5cbiAqIEByZXR1cm4ge1ZpZXd9IC0gVGhpcyB2aWV3IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBiaW5kICh2aWV3LCBlbCwgYmluZGluZykge1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGNvbnN0IHBhcmFtID0gYmluZGluZy5wYXJhbTtcbiAgbGV0IGJpbmQgPSBiaW5kaW5nLnN0YXRlO1xuICBpZiAoIWJpbmQpIHtcbiAgICBiaW5kID0gYmluZGluZy5zdGF0ZSA9IHtcbiAgICAgIGVsZW1lbnRzOiBudWxsLFxuICAgICAgYWN0aXZlOiBmYWxzZSxcbiAgICAgIHNldDogbnVsbCxcbiAgICAgIHVwZGF0ZTogdmFsdWUgPT4ge1xuICAgICAgICBpZiAodmFsdWUgIT0gdmlldy5zaWduYWwocGFyYW0uc2lnbmFsKSkge1xuICAgICAgICAgIHZpZXcucnVuQXN5bmMobnVsbCwgKCkgPT4ge1xuICAgICAgICAgICAgYmluZC5zb3VyY2UgPSB0cnVlO1xuICAgICAgICAgICAgdmlldy5zaWduYWwocGFyYW0uc2lnbmFsLCB2YWx1ZSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChwYXJhbS5kZWJvdW5jZSkge1xuICAgICAgYmluZC51cGRhdGUgPSBkZWJvdW5jZShwYXJhbS5kZWJvdW5jZSwgYmluZC51cGRhdGUpO1xuICAgIH1cbiAgfVxuICBjb25zdCBjcmVhdGUgPSBwYXJhbS5pbnB1dCA9PSBudWxsICYmIHBhcmFtLmVsZW1lbnQgPyB0YXJnZXQgOiBnZW5lcmF0ZTtcbiAgY3JlYXRlKGJpbmQsIGVsLCBwYXJhbSwgdmlldyk7XG4gIGlmICghYmluZC5hY3RpdmUpIHtcbiAgICB2aWV3Lm9uKHZpZXcuX3NpZ25hbHNbcGFyYW0uc2lnbmFsXSwgbnVsbCwgKCkgPT4ge1xuICAgICAgYmluZC5zb3VyY2UgPyBiaW5kLnNvdXJjZSA9IGZhbHNlIDogYmluZC5zZXQodmlldy5zaWduYWwocGFyYW0uc2lnbmFsKSk7XG4gICAgfSk7XG4gICAgYmluZC5hY3RpdmUgPSB0cnVlO1xuICB9XG4gIHJldHVybiBiaW5kO1xufVxuXG4vKipcbiAqIEJpbmQgdGhlIHNpZ25hbCB0byBhbiBleHRlcm5hbCBFdmVudFRhcmdldC5cbiAqL1xuZnVuY3Rpb24gdGFyZ2V0KGJpbmQsIG5vZGUsIHBhcmFtLCB2aWV3KSB7XG4gIGNvbnN0IHR5cGUgPSBwYXJhbS5ldmVudCB8fCAnaW5wdXQnO1xuICBjb25zdCBoYW5kbGVyID0gKCkgPT4gYmluZC51cGRhdGUobm9kZS52YWx1ZSk7XG5cbiAgLy8gaW5pdGlhbGl6ZSBzaWduYWwgdmFsdWUgdG8gZXh0ZXJuYWwgaW5wdXQgdmFsdWVcbiAgdmlldy5zaWduYWwocGFyYW0uc2lnbmFsLCBub2RlLnZhbHVlKTtcblxuICAvLyBsaXN0ZW4gZm9yIGNoYW5nZXMgb24gdGhlIGVsZW1lbnRcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuXG4gIC8vIHJlZ2lzdGVyIHdpdGggdmlldywgc28gd2UgY2FuIHJlbW92ZSBpdCB1cG9uIGZpbmFsaXphdGlvblxuICB0cmFja0V2ZW50TGlzdGVuZXIodmlldywgbm9kZSwgdHlwZSwgaGFuZGxlcik7XG5cbiAgLy8gcHJvcGFnYXRlIGNoYW5nZSB0byBlbGVtZW50XG4gIGJpbmQuc2V0ID0gdmFsdWUgPT4ge1xuICAgIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgICBub2RlLmRpc3BhdGNoRXZlbnQoZXZlbnQodHlwZSkpO1xuICB9O1xufVxuZnVuY3Rpb24gZXZlbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIEV2ZW50ICE9PSAndW5kZWZpbmVkJyA/IG5ldyBFdmVudCh0eXBlKSA6IHtcbiAgICB0eXBlXG4gIH07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYW4gSFRNTCBpbnB1dCBmb3JtIGVsZW1lbnQgYW5kIGJpbmQgaXQgdG8gYSBzaWduYWwuXG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlKGJpbmQsIGVsLCBwYXJhbSwgdmlldykge1xuICBjb25zdCB2YWx1ZSA9IHZpZXcuc2lnbmFsKHBhcmFtLnNpZ25hbCk7XG4gIGNvbnN0IGRpdiA9IGVsZW1lbnQoJ2RpdicsIHtcbiAgICAnY2xhc3MnOiBCaW5kQ2xhc3NcbiAgfSk7XG4gIGNvbnN0IHdyYXBwZXIgPSBwYXJhbS5pbnB1dCA9PT0gJ3JhZGlvJyA/IGRpdiA6IGRpdi5hcHBlbmRDaGlsZChlbGVtZW50KCdsYWJlbCcpKTtcbiAgd3JhcHBlci5hcHBlbmRDaGlsZChlbGVtZW50KCdzcGFuJywge1xuICAgICdjbGFzcyc6IE5hbWVDbGFzc1xuICB9LCBwYXJhbS5uYW1lIHx8IHBhcmFtLnNpZ25hbCkpO1xuICBlbC5hcHBlbmRDaGlsZChkaXYpO1xuICBsZXQgaW5wdXQgPSBmb3JtO1xuICBzd2l0Y2ggKHBhcmFtLmlucHV0KSB7XG4gICAgY2FzZSAnY2hlY2tib3gnOlxuICAgICAgaW5wdXQgPSBjaGVja2JveDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICBpbnB1dCA9IHNlbGVjdDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JhZGlvJzpcbiAgICAgIGlucHV0ID0gcmFkaW87XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyYW5nZSc6XG4gICAgICBpbnB1dCA9IHJhbmdlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgaW5wdXQoYmluZCwgd3JhcHBlciwgcGFyYW0sIHZhbHVlKTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYW4gYXJiaXRyYXJ5IGlucHV0IGZvcm0gZWxlbWVudC5cbiAqIFRoZSBpbnB1dCB0eXBlIGlzIGNvbnRyb2xsZWQgdmlhIHVzZXItcHJvdmlkZWQgcGFyYW1ldGVycy5cbiAqL1xuZnVuY3Rpb24gZm9ybShiaW5kLCBlbCwgcGFyYW0sIHZhbHVlKSB7XG4gIGNvbnN0IG5vZGUgPSBlbGVtZW50KCdpbnB1dCcpO1xuICBmb3IgKGNvbnN0IGtleSBpbiBwYXJhbSkge1xuICAgIGlmIChrZXkgIT09ICdzaWduYWwnICYmIGtleSAhPT0gJ2VsZW1lbnQnKSB7XG4gICAgICBub2RlLnNldEF0dHJpYnV0ZShrZXkgPT09ICdpbnB1dCcgPyAndHlwZScgOiBrZXksIHBhcmFtW2tleV0pO1xuICAgIH1cbiAgfVxuICBub2RlLnNldEF0dHJpYnV0ZSgnbmFtZScsIHBhcmFtLnNpZ25hbCk7XG4gIG5vZGUudmFsdWUgPSB2YWx1ZTtcbiAgZWwuYXBwZW5kQ2hpbGQobm9kZSk7XG4gIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoKSA9PiBiaW5kLnVwZGF0ZShub2RlLnZhbHVlKSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG4gIGJpbmQuc2V0ID0gdmFsdWUgPT4gbm9kZS52YWx1ZSA9IHZhbHVlO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGNoZWNrYm94IGlucHV0IGVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrYm94KGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3QgYXR0ciA9IHtcbiAgICB0eXBlOiAnY2hlY2tib3gnLFxuICAgIG5hbWU6IHBhcmFtLnNpZ25hbFxuICB9O1xuICBpZiAodmFsdWUpIGF0dHIuY2hlY2tlZCA9IHRydWU7XG4gIGNvbnN0IG5vZGUgPSBlbGVtZW50KCdpbnB1dCcsIGF0dHIpO1xuICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBiaW5kLnVwZGF0ZShub2RlLmNoZWNrZWQpKTtcbiAgYmluZC5lbGVtZW50cyA9IFtub2RlXTtcbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiBub2RlLmNoZWNrZWQgPSAhIXZhbHVlIHx8IG51bGw7XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgc2VsZWN0aW9uIGxpc3QgaW5wdXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gc2VsZWN0KGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3Qgbm9kZSA9IGVsZW1lbnQoJ3NlbGVjdCcsIHtcbiAgICAgIG5hbWU6IHBhcmFtLnNpZ25hbFxuICAgIH0pLFxuICAgIGxhYmVscyA9IHBhcmFtLmxhYmVscyB8fCBbXTtcbiAgcGFyYW0ub3B0aW9ucy5mb3JFYWNoKChvcHRpb24sIGkpID0+IHtcbiAgICBjb25zdCBhdHRyID0ge1xuICAgICAgdmFsdWU6IG9wdGlvblxuICAgIH07XG4gICAgaWYgKHZhbHVlc0VxdWFsKG9wdGlvbiwgdmFsdWUpKSBhdHRyLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGVsZW1lbnQoJ29wdGlvbicsIGF0dHIsIChsYWJlbHNbaV0gfHwgb3B0aW9uKSArICcnKSk7XG4gIH0pO1xuICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgYmluZC51cGRhdGUocGFyYW0ub3B0aW9uc1tub2RlLnNlbGVjdGVkSW5kZXhdKTtcbiAgfSk7XG4gIGJpbmQuZWxlbWVudHMgPSBbbm9kZV07XG4gIGJpbmQuc2V0ID0gdmFsdWUgPT4ge1xuICAgIGZvciAobGV0IGkgPSAwLCBuID0gcGFyYW0ub3B0aW9ucy5sZW5ndGg7IGkgPCBuOyArK2kpIHtcbiAgICAgIGlmICh2YWx1ZXNFcXVhbChwYXJhbS5vcHRpb25zW2ldLCB2YWx1ZSkpIHtcbiAgICAgICAgbm9kZS5zZWxlY3RlZEluZGV4ID0gaTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSByYWRpbyBidXR0b24gZ3JvdXAuXG4gKi9cbmZ1bmN0aW9uIHJhZGlvKGJpbmQsIGVsLCBwYXJhbSwgdmFsdWUpIHtcbiAgY29uc3QgZ3JvdXAgPSBlbGVtZW50KCdzcGFuJywge1xuICAgICAgJ2NsYXNzJzogUmFkaW9DbGFzc1xuICAgIH0pLFxuICAgIGxhYmVscyA9IHBhcmFtLmxhYmVscyB8fCBbXTtcbiAgZWwuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICBiaW5kLmVsZW1lbnRzID0gcGFyYW0ub3B0aW9ucy5tYXAoKG9wdGlvbiwgaSkgPT4ge1xuICAgIGNvbnN0IGF0dHIgPSB7XG4gICAgICB0eXBlOiAncmFkaW8nLFxuICAgICAgbmFtZTogcGFyYW0uc2lnbmFsLFxuICAgICAgdmFsdWU6IG9wdGlvblxuICAgIH07XG4gICAgaWYgKHZhbHVlc0VxdWFsKG9wdGlvbiwgdmFsdWUpKSBhdHRyLmNoZWNrZWQgPSB0cnVlO1xuICAgIGNvbnN0IGlucHV0ID0gZWxlbWVudCgnaW5wdXQnLCBhdHRyKTtcbiAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBiaW5kLnVwZGF0ZShvcHRpb24pKTtcbiAgICBjb25zdCBsYWJlbCA9IGVsZW1lbnQoJ2xhYmVsJywge30sIChsYWJlbHNbaV0gfHwgb3B0aW9uKSArICcnKTtcbiAgICBsYWJlbC5wcmVwZW5kKGlucHV0KTtcbiAgICBncm91cC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgcmV0dXJuIGlucHV0O1xuICB9KTtcbiAgYmluZC5zZXQgPSB2YWx1ZSA9PiB7XG4gICAgY29uc3Qgbm9kZXMgPSBiaW5kLmVsZW1lbnRzLFxuICAgICAgbiA9IG5vZGVzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47ICsraSkge1xuICAgICAgaWYgKHZhbHVlc0VxdWFsKG5vZGVzW2ldLnZhbHVlLCB2YWx1ZSkpIG5vZGVzW2ldLmNoZWNrZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBzbGlkZXIgaW5wdXQgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gcmFuZ2UoYmluZCwgZWwsIHBhcmFtLCB2YWx1ZSkge1xuICB2YWx1ZSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6ICgrcGFyYW0ubWF4ICsgK3BhcmFtLm1pbikgLyAyO1xuICBjb25zdCBtYXggPSBwYXJhbS5tYXggIT0gbnVsbCA/IHBhcmFtLm1heCA6IE1hdGgubWF4KDEwMCwgK3ZhbHVlKSB8fCAxMDAsXG4gICAgbWluID0gcGFyYW0ubWluIHx8IE1hdGgubWluKDAsIG1heCwgK3ZhbHVlKSB8fCAwLFxuICAgIHN0ZXAgPSBwYXJhbS5zdGVwIHx8IHRpY2tTdGVwKG1pbiwgbWF4LCAxMDApO1xuICBjb25zdCBub2RlID0gZWxlbWVudCgnaW5wdXQnLCB7XG4gICAgdHlwZTogJ3JhbmdlJyxcbiAgICBuYW1lOiBwYXJhbS5zaWduYWwsXG4gICAgbWluOiBtaW4sXG4gICAgbWF4OiBtYXgsXG4gICAgc3RlcDogc3RlcFxuICB9KTtcbiAgbm9kZS52YWx1ZSA9IHZhbHVlO1xuICBjb25zdCBzcGFuID0gZWxlbWVudCgnc3BhbicsIHt9LCArdmFsdWUpO1xuICBlbC5hcHBlbmRDaGlsZChub2RlKTtcbiAgZWwuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gIGNvbnN0IHVwZGF0ZSA9ICgpID0+IHtcbiAgICBzcGFuLnRleHRDb250ZW50ID0gbm9kZS52YWx1ZTtcbiAgICBiaW5kLnVwZGF0ZSgrbm9kZS52YWx1ZSk7XG4gIH07XG5cbiAgLy8gc3Vic2NyaWJlIHRvIGJvdGggaW5wdXQgYW5kIGNoYW5nZVxuICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdXBkYXRlKTtcbiAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGUpO1xuICBiaW5kLmVsZW1lbnRzID0gW25vZGVdO1xuICBiaW5kLnNldCA9IHZhbHVlID0+IHtcbiAgICBub2RlLnZhbHVlID0gdmFsdWU7XG4gICAgc3Bhbi50ZXh0Q29udGVudCA9IHZhbHVlO1xuICB9O1xufVxuZnVuY3Rpb24gdmFsdWVzRXF1YWwoYSwgYikge1xuICByZXR1cm4gYSA9PT0gYiB8fCBhICsgJycgPT09IGIgKyAnJztcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlbmRlcmVyICh2aWV3LCByLCBlbCwgY29uc3RydWN0b3IsIHNjYWxlRmFjdG9yLCBvcHQpIHtcbiAgciA9IHIgfHwgbmV3IGNvbnN0cnVjdG9yKHZpZXcubG9hZGVyKCkpO1xuICByZXR1cm4gci5pbml0aWFsaXplKGVsLCB3aWR0aCh2aWV3KSwgaGVpZ2h0KHZpZXcpLCBvZmZzZXQodmlldyksIHNjYWxlRmFjdG9yLCBvcHQpLmJhY2tncm91bmQodmlldy5iYWNrZ3JvdW5kKCkpO1xufVxuXG5mdW5jdGlvbiB0cmFwICh2aWV3LCBmbikge1xuICByZXR1cm4gIWZuID8gbnVsbCA6IGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdmlldy5lcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpbml0aWFsaXplSGFuZGxlciAodmlldywgcHJldkhhbmRsZXIsIGVsLCBjb25zdHJ1Y3Rvcikge1xuICAvLyBpbnN0YW50aWF0ZSBzY2VuZWdyYXBoIGhhbmRsZXJcbiAgY29uc3QgaGFuZGxlciA9IG5ldyBjb25zdHJ1Y3Rvcih2aWV3LmxvYWRlcigpLCB0cmFwKHZpZXcsIHZpZXcudG9vbHRpcCgpKSkuc2NlbmUodmlldy5zY2VuZWdyYXBoKCkucm9vdCkuaW5pdGlhbGl6ZShlbCwgb2Zmc2V0KHZpZXcpLCB2aWV3KTtcblxuICAvLyB0cmFuc2ZlciBldmVudCBoYW5kbGVyc1xuICBpZiAocHJldkhhbmRsZXIpIHtcbiAgICBwcmV2SGFuZGxlci5oYW5kbGVycygpLmZvckVhY2goaCA9PiB7XG4gICAgICBoYW5kbGVyLm9uKGgudHlwZSwgaC5oYW5kbGVyKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gaGFuZGxlcjtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZSAoZWwsIGVsQmluZCkge1xuICBjb25zdCB2aWV3ID0gdGhpcyxcbiAgICB0eXBlID0gdmlldy5fcmVuZGVyVHlwZSxcbiAgICBjb25maWcgPSB2aWV3Ll9ldmVudENvbmZpZy5iaW5kLFxuICAgIG1vZHVsZSA9IHJlbmRlck1vZHVsZSh0eXBlKTtcblxuICAvLyBjb250YWluaW5nIGRvbSBlbGVtZW50XG4gIGVsID0gdmlldy5fZWwgPSBlbCA/IGxvb2t1cCh2aWV3LCBlbCwgdHJ1ZSkgOiBudWxsO1xuXG4gIC8vIGluaXRpYWxpemUgYXJpYSBhdHRyaWJ1dGVzXG4gIGluaXRpYWxpemVBcmlhKHZpZXcpO1xuXG4gIC8vIHNlbGVjdCBhcHByb3ByaWF0ZSByZW5kZXJlciAmIGhhbmRsZXJcbiAgaWYgKCFtb2R1bGUpIHZpZXcuZXJyb3IoJ1VucmVjb2duaXplZCByZW5kZXJlciB0eXBlOiAnICsgdHlwZSk7XG4gIGNvbnN0IEhhbmRsZXIgPSBtb2R1bGUuaGFuZGxlciB8fCBDYW52YXNIYW5kbGVyLFxuICAgIFJlbmRlcmVyID0gZWwgPyBtb2R1bGUucmVuZGVyZXIgOiBtb2R1bGUuaGVhZGxlc3M7XG5cbiAgLy8gaW5pdGlhbGl6ZSByZW5kZXJlciBhbmQgaW5wdXQgaGFuZGxlclxuICB2aWV3Ll9yZW5kZXJlciA9ICFSZW5kZXJlciA/IG51bGwgOiBpbml0aWFsaXplUmVuZGVyZXIodmlldywgdmlldy5fcmVuZGVyZXIsIGVsLCBSZW5kZXJlcik7XG4gIHZpZXcuX2hhbmRsZXIgPSBpbml0aWFsaXplSGFuZGxlcih2aWV3LCB2aWV3Ll9oYW5kbGVyLCBlbCwgSGFuZGxlcik7XG4gIHZpZXcuX3JlZHJhdyA9IHRydWU7XG5cbiAgLy8gaW5pdGlhbGl6ZSBzaWduYWwgYmluZGluZ3NcbiAgaWYgKGVsICYmIGNvbmZpZyAhPT0gJ25vbmUnKSB7XG4gICAgZWxCaW5kID0gZWxCaW5kID8gdmlldy5fZWxCaW5kID0gbG9va3VwKHZpZXcsIGVsQmluZCwgdHJ1ZSkgOiBlbC5hcHBlbmRDaGlsZChlbGVtZW50KCdmb3JtJywge1xuICAgICAgJ2NsYXNzJzogJ3ZlZ2EtYmluZGluZ3MnXG4gICAgfSkpO1xuICAgIHZpZXcuX2JpbmQuZm9yRWFjaChfID0+IHtcbiAgICAgIGlmIChfLnBhcmFtLmVsZW1lbnQgJiYgY29uZmlnICE9PSAnY29udGFpbmVyJykge1xuICAgICAgICBfLmVsZW1lbnQgPSBsb29rdXAodmlldywgXy5wYXJhbS5lbGVtZW50LCAhIV8ucGFyYW0uaW5wdXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHZpZXcuX2JpbmQuZm9yRWFjaChfID0+IHtcbiAgICAgIGJpbmQodmlldywgXy5lbGVtZW50IHx8IGVsQmluZCwgXyk7XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHZpZXc7XG59XG5mdW5jdGlvbiBsb29rdXAodmlldywgZWwsIGNsZWFyKSB7XG4gIGlmICh0eXBlb2YgZWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihlbCk7XG4gICAgICBpZiAoIWVsKSB7XG4gICAgICAgIHZpZXcuZXJyb3IoJ1NpZ25hbCBiaW5kIGVsZW1lbnQgbm90IGZvdW5kOiAnICsgZWwpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmlldy5lcnJvcignRE9NIGRvY3VtZW50IGluc3RhbmNlIG5vdCBmb3VuZC4nKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBpZiAoZWwgJiYgY2xlYXIpIHtcbiAgICB0cnkge1xuICAgICAgZWwudGV4dENvbnRlbnQgPSAnJztcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBlbCA9IG51bGw7XG4gICAgICB2aWV3LmVycm9yKGUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZWw7XG59XG5cbmNvbnN0IG51bWJlciA9IF8gPT4gK18gfHwgMDtcbmNvbnN0IHBhZGRpbmdPYmplY3QgPSBfID0+ICh7XG4gIHRvcDogXyxcbiAgYm90dG9tOiBfLFxuICBsZWZ0OiBfLFxuICByaWdodDogX1xufSk7XG5mdW5jdGlvbiBwYWRkaW5nIChfKSB7XG4gIHJldHVybiBpc09iamVjdChfKSA/IHtcbiAgICB0b3A6IG51bWJlcihfLnRvcCksXG4gICAgYm90dG9tOiBudW1iZXIoXy5ib3R0b20pLFxuICAgIGxlZnQ6IG51bWJlcihfLmxlZnQpLFxuICAgIHJpZ2h0OiBudW1iZXIoXy5yaWdodClcbiAgfSA6IHBhZGRpbmdPYmplY3QobnVtYmVyKF8pKTtcbn1cblxuLyoqXG4gKiBSZW5kZXIgdGhlIGN1cnJlbnQgc2NlbmUgaW4gYSBoZWFkbGVzcyBmYXNoaW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIHJlbmRlcmVyLlxuICovXG5hc3luYyBmdW5jdGlvbiByZW5kZXJIZWFkbGVzcyAodmlldywgdHlwZSwgc2NhbGVGYWN0b3IsIG9wdCkge1xuICBjb25zdCBtb2R1bGUgPSByZW5kZXJNb2R1bGUodHlwZSksXG4gICAgY3RyID0gbW9kdWxlICYmIG1vZHVsZS5oZWFkbGVzcztcbiAgaWYgKCFjdHIpIGVycm9yKCdVbnJlY29nbml6ZWQgcmVuZGVyZXIgdHlwZTogJyArIHR5cGUpO1xuICBhd2FpdCB2aWV3LnJ1bkFzeW5jKCk7XG4gIHJldHVybiBpbml0aWFsaXplUmVuZGVyZXIodmlldywgbnVsbCwgbnVsbCwgY3RyLCBzY2FsZUZhY3Rvciwgb3B0KS5yZW5kZXJBc3luYyh2aWV3Ll9zY2VuZWdyYXBoLnJvb3QpO1xufVxuXG4vKipcbiAqIFByb2R1Y2UgYW4gaW1hZ2UgVVJMIGZvciB0aGUgdmlzdWFsaXphdGlvbi4gRGVwZW5kaW5nIG9uIHRoZSB0eXBlXG4gKiBwYXJhbWV0ZXIsIHRoZSBnZW5lcmF0ZWQgVVJMIGNvbnRhaW5zIGRhdGEgZm9yIGVpdGhlciBhIFBORyBvciBTVkcgaW1hZ2UuXG4gKiBUaGUgVVJMIGNhbiBiZSB1c2VkIChmb3IgZXhhbXBsZSkgdG8gZG93bmxvYWQgaW1hZ2VzIG9mIHRoZSB2aXN1YWxpemF0aW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBUaGUgaW1hZ2UgdHlwZS4gT25lIG9mICdzdmcnLCAncG5nJyBvciAnY2FudmFzJy5cbiAqICAgVGhlICdjYW52YXMnIGFuZCAncG5nJyB0eXBlcyBhcmUgc3lub255bXMgZm9yIGEgUE5HIGltYWdlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBpbWFnZSBVUkwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlclRvSW1hZ2VVUkwgKHR5cGUsIHNjYWxlRmFjdG9yKSB7XG4gIGlmICh0eXBlICE9PSBSZW5kZXJUeXBlLkNhbnZhcyAmJiB0eXBlICE9PSBSZW5kZXJUeXBlLlNWRyAmJiB0eXBlICE9PSBSZW5kZXJUeXBlLlBORykge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgaW1hZ2UgdHlwZTogJyArIHR5cGUpO1xuICB9XG4gIGNvbnN0IHIgPSBhd2FpdCByZW5kZXJIZWFkbGVzcyh0aGlzLCB0eXBlLCBzY2FsZUZhY3Rvcik7XG4gIHJldHVybiB0eXBlID09PSBSZW5kZXJUeXBlLlNWRyA/IHRvQmxvYlVSTChyLnN2ZygpLCAnaW1hZ2Uvc3ZnK3htbCcpIDogci5jYW52YXMoKS50b0RhdGFVUkwoJ2ltYWdlL3BuZycpO1xufVxuZnVuY3Rpb24gdG9CbG9iVVJMKGRhdGEsIG1pbWUpIHtcbiAgY29uc3QgYmxvYiA9IG5ldyBCbG9iKFtkYXRhXSwge1xuICAgIHR5cGU6IG1pbWVcbiAgfSk7XG4gIHJldHVybiB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbn1cblxuLyoqXG4gKiBQcm9kdWNlIGEgQ2FudmFzIGluc3RhbmNlIGNvbnRhaW5pbmcgYSByZW5kZXJlZCB2aXN1YWxpemF0aW9uLlxuICogVGhpcyBtZXRob2QgaXMgYXN5bmNocm9ub3VzLCByZXR1cm5pbmcgYSBQcm9taXNlIGluc3RhbmNlLlxuICogQHJldHVybiB7UHJvbWlzZX0gLSBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhIENhbnZhcyBpbnN0YW5jZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVuZGVyVG9DYW52YXMgKHNjYWxlRmFjdG9yLCBvcHQpIHtcbiAgY29uc3QgciA9IGF3YWl0IHJlbmRlckhlYWRsZXNzKHRoaXMsIFJlbmRlclR5cGUuQ2FudmFzLCBzY2FsZUZhY3Rvciwgb3B0KTtcbiAgcmV0dXJuIHIuY2FudmFzKCk7XG59XG5cbi8qKlxuICogUHJvZHVjZSBhIHJlbmRlcmVkIFNWRyBzdHJpbmcgb2YgdGhlIHZpc3VhbGl6YXRpb24uXG4gKiBUaGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMsIHJldHVybmluZyBhIFByb21pc2UgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHtQcm9taXNlfSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGFuIFNWRyBzdHJpbmcuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlbmRlclRvU1ZHIChzY2FsZUZhY3Rvcikge1xuICBjb25zdCByID0gYXdhaXQgcmVuZGVySGVhZGxlc3ModGhpcywgUmVuZGVyVHlwZS5TVkcsIHNjYWxlRmFjdG9yKTtcbiAgcmV0dXJuIHIuc3ZnKCk7XG59XG5cbmZ1bmN0aW9uIHJ1bnRpbWUgKHZpZXcsIHNwZWMsIGV4cHIpIHtcbiAgcmV0dXJuIGNvbnRleHQodmlldywgdHJhbnNmb3JtcywgZnVuY3Rpb25Db250ZXh0LCBleHByKS5wYXJzZShzcGVjKTtcbn1cblxuZnVuY3Rpb24gc2NhbGUobmFtZSkge1xuICB2YXIgc2NhbGVzID0gdGhpcy5fcnVudGltZS5zY2FsZXM7XG4gIGlmICghaGFzT3duUHJvcGVydHkoc2NhbGVzLCBuYW1lKSkge1xuICAgIGVycm9yKCdVbnJlY29nbml6ZWQgc2NhbGUgb3IgcHJvamVjdGlvbjogJyArIG5hbWUpO1xuICB9XG4gIHJldHVybiBzY2FsZXNbbmFtZV0udmFsdWU7XG59XG5cbnZhciBXaWR0aCA9ICd3aWR0aCcsXG4gIEhlaWdodCA9ICdoZWlnaHQnLFxuICBQYWRkaW5nID0gJ3BhZGRpbmcnLFxuICBTa2lwID0ge1xuICAgIHNraXA6IHRydWVcbiAgfTtcbmZ1bmN0aW9uIHZpZXdXaWR0aCh2aWV3LCB3aWR0aCkge1xuICB2YXIgYSA9IHZpZXcuYXV0b3NpemUoKSxcbiAgICBwID0gdmlldy5wYWRkaW5nKCk7XG4gIHJldHVybiB3aWR0aCAtIChhICYmIGEuY29udGFpbnMgPT09IFBhZGRpbmcgPyBwLmxlZnQgKyBwLnJpZ2h0IDogMCk7XG59XG5mdW5jdGlvbiB2aWV3SGVpZ2h0KHZpZXcsIGhlaWdodCkge1xuICB2YXIgYSA9IHZpZXcuYXV0b3NpemUoKSxcbiAgICBwID0gdmlldy5wYWRkaW5nKCk7XG4gIHJldHVybiBoZWlnaHQgLSAoYSAmJiBhLmNvbnRhaW5zID09PSBQYWRkaW5nID8gcC50b3AgKyBwLmJvdHRvbSA6IDApO1xufVxuZnVuY3Rpb24gaW5pdGlhbGl6ZVJlc2l6ZSh2aWV3KSB7XG4gIHZhciBzID0gdmlldy5fc2lnbmFscyxcbiAgICB3ID0gc1tXaWR0aF0sXG4gICAgaCA9IHNbSGVpZ2h0XSxcbiAgICBwID0gc1tQYWRkaW5nXTtcbiAgZnVuY3Rpb24gcmVzZXRTaXplKCkge1xuICAgIHZpZXcuX2F1dG9zaXplID0gdmlldy5fcmVzaXplID0gMTtcbiAgfVxuXG4gIC8vIHJlc3BvbmQgdG8gd2lkdGggc2lnbmFsXG4gIHZpZXcuX3Jlc2l6ZVdpZHRoID0gdmlldy5hZGQobnVsbCwgXyA9PiB7XG4gICAgdmlldy5fd2lkdGggPSBfLnNpemU7XG4gICAgdmlldy5fdmlld1dpZHRoID0gdmlld1dpZHRoKHZpZXcsIF8uc2l6ZSk7XG4gICAgcmVzZXRTaXplKCk7XG4gIH0sIHtcbiAgICBzaXplOiB3XG4gIH0pO1xuXG4gIC8vIHJlc3BvbmQgdG8gaGVpZ2h0IHNpZ25hbFxuICB2aWV3Ll9yZXNpemVIZWlnaHQgPSB2aWV3LmFkZChudWxsLCBfID0+IHtcbiAgICB2aWV3Ll9oZWlnaHQgPSBfLnNpemU7XG4gICAgdmlldy5fdmlld0hlaWdodCA9IHZpZXdIZWlnaHQodmlldywgXy5zaXplKTtcbiAgICByZXNldFNpemUoKTtcbiAgfSwge1xuICAgIHNpemU6IGhcbiAgfSk7XG5cbiAgLy8gcmVzcG9uZCB0byBwYWRkaW5nIHNpZ25hbFxuICBjb25zdCByZXNpemVQYWRkaW5nID0gdmlldy5hZGQobnVsbCwgcmVzZXRTaXplLCB7XG4gICAgcGFkOiBwXG4gIH0pO1xuXG4gIC8vIHNldCByYW5rIHRvIHJ1biBpbW1lZGlhdGVseSBhZnRlciBzb3VyY2Ugc2lnbmFsXG4gIHZpZXcuX3Jlc2l6ZVdpZHRoLnJhbmsgPSB3LnJhbmsgKyAxO1xuICB2aWV3Ll9yZXNpemVIZWlnaHQucmFuayA9IGgucmFuayArIDE7XG4gIHJlc2l6ZVBhZGRpbmcucmFuayA9IHAucmFuayArIDE7XG59XG5mdW5jdGlvbiByZXNpemVWaWV3KHZpZXdXaWR0aCwgdmlld0hlaWdodCwgd2lkdGgsIGhlaWdodCwgb3JpZ2luLCBhdXRvKSB7XG4gIHRoaXMucnVuQWZ0ZXIodmlldyA9PiB7XG4gICAgbGV0IHJlcnVuID0gMDtcblxuICAgIC8vIHJlc2V0IGF1dG9zaXplIGZsYWdcbiAgICB2aWV3Ll9hdXRvc2l6ZSA9IDA7XG5cbiAgICAvLyB3aWR0aCB2YWx1ZSBjaGFuZ2VkOiB1cGRhdGUgc2lnbmFsLCBza2lwIHJlc2l6ZSBvcFxuICAgIGlmICh2aWV3LndpZHRoKCkgIT09IHdpZHRoKSB7XG4gICAgICByZXJ1biA9IDE7XG4gICAgICB2aWV3LnNpZ25hbChXaWR0aCwgd2lkdGgsIFNraXApOyAvLyBzZXQgd2lkdGgsIHNraXAgdXBkYXRlIGNhbGNcbiAgICAgIHZpZXcuX3Jlc2l6ZVdpZHRoLnNraXAodHJ1ZSk7IC8vIHNraXAgd2lkdGggcmVzaXplIGhhbmRsZXJcbiAgICB9XG5cbiAgICAvLyBoZWlnaHQgdmFsdWUgY2hhbmdlZDogdXBkYXRlIHNpZ25hbCwgc2tpcCByZXNpemUgb3BcbiAgICBpZiAodmlldy5oZWlnaHQoKSAhPT0gaGVpZ2h0KSB7XG4gICAgICByZXJ1biA9IDE7XG4gICAgICB2aWV3LnNpZ25hbChIZWlnaHQsIGhlaWdodCwgU2tpcCk7IC8vIHNldCBoZWlnaHQsIHNraXAgdXBkYXRlIGNhbGNcbiAgICAgIHZpZXcuX3Jlc2l6ZUhlaWdodC5za2lwKHRydWUpOyAvLyBza2lwIGhlaWdodCByZXNpemUgaGFuZGxlclxuICAgIH1cblxuICAgIC8vIHZpZXcgd2lkdGggY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuICAgIGlmICh2aWV3Ll92aWV3V2lkdGggIT09IHZpZXdXaWR0aCkge1xuICAgICAgdmlldy5fcmVzaXplID0gMTtcbiAgICAgIHZpZXcuX3ZpZXdXaWR0aCA9IHZpZXdXaWR0aDtcbiAgICB9XG5cbiAgICAvLyB2aWV3IGhlaWdodCBjaGFuZ2VkOiB1cGRhdGUgdmlldyBwcm9wZXJ0eSwgc2V0IHJlc2l6ZSBmbGFnXG4gICAgaWYgKHZpZXcuX3ZpZXdIZWlnaHQgIT09IHZpZXdIZWlnaHQpIHtcbiAgICAgIHZpZXcuX3Jlc2l6ZSA9IDE7XG4gICAgICB2aWV3Ll92aWV3SGVpZ2h0ID0gdmlld0hlaWdodDtcbiAgICB9XG5cbiAgICAvLyBvcmlnaW4gY2hhbmdlZDogdXBkYXRlIHZpZXcgcHJvcGVydHksIHNldCByZXNpemUgZmxhZ1xuICAgIGlmICh2aWV3Ll9vcmlnaW5bMF0gIT09IG9yaWdpblswXSB8fCB2aWV3Ll9vcmlnaW5bMV0gIT09IG9yaWdpblsxXSkge1xuICAgICAgdmlldy5fcmVzaXplID0gMTtcbiAgICAgIHZpZXcuX29yaWdpbiA9IG9yaWdpbjtcbiAgICB9XG5cbiAgICAvLyBydW4gZGF0YWZsb3cgb24gd2lkdGgvaGVpZ2h0IHNpZ25hbCBjaGFuZ2VcbiAgICBpZiAocmVydW4pIHZpZXcucnVuKCdlbnRlcicpO1xuICAgIGlmIChhdXRvKSB2aWV3LnJ1bkFmdGVyKHYgPT4gdi5yZXNpemUoKSk7XG4gIH0sIGZhbHNlLCAxKTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgdmlldyBzdGF0ZSwgY29uc2lzdGluZyBvZiBzaWduYWwgdmFsdWVzIGFuZC9vciBkYXRhIHNldHMuXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmbGFncyBpbmRpY2F0aW5nIHdoaWNoIHN0YXRlIHRvIGV4cG9ydC5cbiAqICAgSWYgdW5zcGVjaWZpZWQsIGFsbCBzaWduYWxzIGFuZCBkYXRhIHNldHMgd2lsbCBiZSBleHBvcnRlZC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb24oc3RyaW5nLCBPcGVyYXRvcik6Ym9vbGVhbn0gW29wdGlvbnMuc2lnbmFsc10gLSBPcHRpb25hbFxuICogICBwcmVkaWNhdGUgZnVuY3Rpb24gZm9yIHRlc3RpbmcgaWYgYSBzaWduYWwgc2hvdWxkIGJlIGluY2x1ZGVkIGluIHRoZVxuICogICBleHBvcnRlZCBzdGF0ZS4gSWYgdW5zcGVjaWZpZWQsIGFsbCBzaWduYWxzIHdpbGwgYmUgaW5jbHVkZWQsIGV4Y2VwdCBmb3JcbiAqICAgdGhvc2UgbmFtZWQgJ3BhcmVudCcgb3IgdGhvc2Ugd2hpY2ggcmVmZXIgdG8gYSBUcmFuc2Zvcm0gdmFsdWUuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KTpib29sZWFufSBbb3B0aW9ucy5kYXRhXSAtIE9wdGlvbmFsXG4gKiAgIHByZWRpY2F0ZSBmdW5jdGlvbiBmb3IgdGVzdGluZyBpZiBhIGRhdGEgc2V0J3MgaW5wdXQgc2hvdWxkIGJlIGluY2x1ZGVkXG4gKiAgIGluIHRoZSBleHBvcnRlZCBzdGF0ZS4gSWYgdW5zcGVjaWZpZWQsIGFsbCBkYXRhIHNldHMgdGhhdCBoYXZlIGJlZW5cbiAqICAgZXhwbGljaXRseSBtb2RpZmllZCB3aWxsIGJlIGluY2x1ZGVkLlxuICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5yZWN1cnNlPXRydWVdIC0gRmxhZyBpbmRpY2F0aW5nIGlmIHRoZSBleHBvcnRlZFxuICogICBzdGF0ZSBzaG91bGQgcmVjdXJzaXZlbHkgaW5jbHVkZSBzdGF0ZSBmcm9tIGdyb3VwIG1hcmsgc3ViLWNvbnRleHRzLlxuICogQHJldHVybiB7b2JqZWN0fSAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBleHBvcnRlZCBzdGF0ZSB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGdldFN0YXRlKG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuX3J1bnRpbWUuZ2V0U3RhdGUob3B0aW9ucyB8fCB7XG4gICAgZGF0YTogZGF0YVRlc3QsXG4gICAgc2lnbmFsczogc2lnbmFsVGVzdCxcbiAgICByZWN1cnNlOiB0cnVlXG4gIH0pO1xufVxuZnVuY3Rpb24gZGF0YVRlc3QobmFtZSwgZGF0YSkge1xuICByZXR1cm4gZGF0YS5tb2RpZmllZCAmJiBpc0FycmF5KGRhdGEuaW5wdXQudmFsdWUpICYmICFuYW1lLnN0YXJ0c1dpdGgoJ186dmVnYTpfJyk7XG59XG5mdW5jdGlvbiBzaWduYWxUZXN0KG5hbWUsIG9wKSB7XG4gIHJldHVybiAhKG5hbWUgPT09ICdwYXJlbnQnIHx8IG9wIGluc3RhbmNlb2YgdHJhbnNmb3Jtcy5wcm94eSk7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgY3VycmVudCB2aWV3IHN0YXRlIGFuZCB1cGRhdGVzIHRoZSB2aWV3IGJ5IGludm9raW5nIHJ1bi5cbiAqIEBwYXJhbSB7b2JqZWN0fSBzdGF0ZSAtIEEgc3RhdGUgb2JqZWN0IGNvbnRhaW5pbmcgc2lnbmFsIGFuZC9vclxuICogICBkYXRhIHNldCB2YWx1ZXMsIGZvbGxvd2luZyB0aGUgZm9ybWF0IHVzZWQgYnkgdGhlIGdldFN0YXRlIG1ldGhvZC5cbiAqIEByZXR1cm4ge1ZpZXd9IC0gVGhpcyB2aWV3IGluc3RhbmNlLlxuICovXG5mdW5jdGlvbiBzZXRTdGF0ZShzdGF0ZSkge1xuICB0aGlzLnJ1bkFzeW5jKG51bGwsIHYgPT4ge1xuICAgIHYuX3RyaWdnZXIgPSBmYWxzZTtcbiAgICB2Ll9ydW50aW1lLnNldFN0YXRlKHN0YXRlKTtcbiAgfSwgdiA9PiB7XG4gICAgdi5fdHJpZ2dlciA9IHRydWU7XG4gIH0pO1xuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gdGltZXIgKGNhbGxiYWNrLCBkZWxheSkge1xuICBmdW5jdGlvbiB0aWNrKGVsYXBzZWQpIHtcbiAgICBjYWxsYmFjayh7XG4gICAgICB0aW1lc3RhbXA6IERhdGUubm93KCksXG4gICAgICBlbGFwc2VkOiBlbGFwc2VkXG4gICAgfSk7XG4gIH1cbiAgdGhpcy5fdGltZXJzLnB1c2goaW50ZXJ2YWwodGljaywgZGVsYXkpKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdFRvb2x0aXAgKGhhbmRsZXIsIGV2ZW50LCBpdGVtLCB2YWx1ZSkge1xuICBjb25zdCBlbCA9IGhhbmRsZXIuZWxlbWVudCgpO1xuICBpZiAoZWwpIGVsLnNldEF0dHJpYnV0ZSgndGl0bGUnLCBmb3JtYXRUb29sdGlwKHZhbHVlKSk7XG59XG5mdW5jdGlvbiBmb3JtYXRUb29sdGlwKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiBpc0FycmF5KHZhbHVlKSA/IGZvcm1hdEFycmF5KHZhbHVlKSA6IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNEYXRlKHZhbHVlKSA/IGZvcm1hdE9iamVjdCh2YWx1ZSkgOiB2YWx1ZSArICcnO1xufVxuZnVuY3Rpb24gZm9ybWF0T2JqZWN0KG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5tYXAoa2V5ID0+IHtcbiAgICBjb25zdCB2ID0gb2JqW2tleV07XG4gICAgcmV0dXJuIGtleSArICc6ICcgKyAoaXNBcnJheSh2KSA/IGZvcm1hdEFycmF5KHYpIDogZm9ybWF0VmFsdWUodikpO1xuICB9KS5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIGZvcm1hdEFycmF5KHZhbHVlKSB7XG4gIHJldHVybiAnWycgKyB2YWx1ZS5tYXAoZm9ybWF0VmFsdWUpLmpvaW4oJywgJykgKyAnXSc7XG59XG5mdW5jdGlvbiBmb3JtYXRWYWx1ZSh2YWx1ZSkge1xuICByZXR1cm4gaXNBcnJheSh2YWx1ZSkgPyAnW1xcdTIwMjZdJyA6IGlzT2JqZWN0KHZhbHVlKSAmJiAhaXNEYXRlKHZhbHVlKSA/ICd7XFx1MjAyNn0nIDogdmFsdWU7XG59XG5cbmZ1bmN0aW9uIHdhdGNoUGl4ZWxSYXRpbyAoKSB7XG4gIC8vIGJhc2VkIG9uIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvZGV2aWNlUGl4ZWxSYXRpbyNtb25pdG9yaW5nX3NjcmVlbl9yZXNvbHV0aW9uX29yX3pvb21fbGV2ZWxfY2hhbmdlc1xuICBpZiAodGhpcy5yZW5kZXJlcigpID09PSAnY2FudmFzJyAmJiB0aGlzLl9yZW5kZXJlci5fY2FudmFzKSB7XG4gICAgbGV0IHJlbW92ZSA9IG51bGw7XG4gICAgY29uc3QgdXBkYXRlUGl4ZWxSYXRpbyA9ICgpID0+IHtcbiAgICAgIGlmIChyZW1vdmUgIT0gbnVsbCkge1xuICAgICAgICByZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lZGlhID0gbWF0Y2hNZWRpYShgKHJlc29sdXRpb246ICR7d2luZG93LmRldmljZVBpeGVsUmF0aW99ZHBweClgKTtcbiAgICAgIG1lZGlhLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZVBpeGVsUmF0aW8pO1xuICAgICAgcmVtb3ZlID0gKCkgPT4ge1xuICAgICAgICBtZWRpYS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGRhdGVQaXhlbFJhdGlvKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9yZW5kZXJlci5fY2FudmFzLmdldENvbnRleHQoJzJkJykucGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICB0aGlzLl9yZWRyYXcgPSB0cnVlO1xuICAgICAgdGhpcy5fcmVzaXplID0gMTtcbiAgICAgIHRoaXMucmVzaXplKCkucnVuQXN5bmMoKTtcbiAgICB9O1xuICAgIHVwZGF0ZVBpeGVsUmF0aW8oKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBWaWV3IGluc3RhbmNlIGZyb20gYSBWZWdhIGRhdGFmbG93IHJ1bnRpbWUgc3BlY2lmaWNhdGlvbi5cbiAqIFRoZSBnZW5lcmF0ZWQgVmlldyB3aWxsIG5vdCBpbW1lZGlhdGVseSBiZSByZWFkeSBmb3IgZGlzcGxheS4gQ2FsbGVyc1xuICogc2hvdWxkIGFsc28gaW52b2tlIHRoZSBpbml0aWFsaXplIG1ldGhvZCAoZS5nLiwgdG8gc2V0IHRoZSBwYXJlbnRcbiAqIERPTSBlbGVtZW50IGluIGJyb3dzZXItYmFzZWQgZGVwbG95bWVudCkgYW5kIHRoZW4gaW52b2tlIHRoZSBydW5cbiAqIG1ldGhvZCB0byBldmFsdWF0ZSB0aGUgZGF0YWZsb3cgZ3JhcGguIFJlbmRlcmluZyB3aWxsIGF1dG9tYXRpY2FsbHlcbiAqIGJlIHBlcmZvcm1lZCB1cG9uIGRhdGFmbG93IHJ1bnMuXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7b2JqZWN0fSBzcGVjIC0gVGhlIFZlZ2EgZGF0YWZsb3cgcnVudGltZSBzcGVjaWZpY2F0aW9uLlxuICovXG5mdW5jdGlvbiBWaWV3KHNwZWMsIG9wdGlvbnMpIHtcbiAgY29uc3QgdmlldyA9IHRoaXM7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBEYXRhZmxvdy5jYWxsKHZpZXcpO1xuICBpZiAob3B0aW9ucy5sb2FkZXIpIHZpZXcubG9hZGVyKG9wdGlvbnMubG9hZGVyKTtcbiAgaWYgKG9wdGlvbnMubG9nZ2VyKSB2aWV3LmxvZ2dlcihvcHRpb25zLmxvZ2dlcik7XG4gIGlmIChvcHRpb25zLmxvZ0xldmVsICE9IG51bGwpIHZpZXcubG9nTGV2ZWwob3B0aW9ucy5sb2dMZXZlbCk7XG4gIGlmIChvcHRpb25zLmxvY2FsZSB8fCBzcGVjLmxvY2FsZSkge1xuICAgIGNvbnN0IGxvYyA9IGV4dGVuZCh7fSwgc3BlYy5sb2NhbGUsIG9wdGlvbnMubG9jYWxlKTtcbiAgICB2aWV3LmxvY2FsZShsb2NhbGUobG9jLm51bWJlciwgbG9jLnRpbWUpKTtcbiAgfVxuICB2aWV3Ll9lbCA9IG51bGw7XG4gIHZpZXcuX2VsQmluZCA9IG51bGw7XG4gIHZpZXcuX3JlbmRlclR5cGUgPSBvcHRpb25zLnJlbmRlcmVyIHx8IFJlbmRlclR5cGUuQ2FudmFzO1xuICB2aWV3Ll9zY2VuZWdyYXBoID0gbmV3IFNjZW5lZ3JhcGgoKTtcbiAgY29uc3Qgcm9vdCA9IHZpZXcuX3NjZW5lZ3JhcGgucm9vdDtcblxuICAvLyBpbml0aWFsaXplIHJlbmRlcmVyLCBoYW5kbGVyIGFuZCBldmVudCBtYW5hZ2VtZW50XG4gIHZpZXcuX3JlbmRlcmVyID0gbnVsbDtcbiAgdmlldy5fdG9vbHRpcCA9IG9wdGlvbnMudG9vbHRpcCB8fCBkZWZhdWx0VG9vbHRpcCwgdmlldy5fcmVkcmF3ID0gdHJ1ZTtcbiAgdmlldy5faGFuZGxlciA9IG5ldyBDYW52YXNIYW5kbGVyKCkuc2NlbmUocm9vdCk7XG4gIHZpZXcuX2dsb2JhbEN1cnNvciA9IGZhbHNlO1xuICB2aWV3Ll9wcmV2ZW50RGVmYXVsdCA9IGZhbHNlO1xuICB2aWV3Ll90aW1lcnMgPSBbXTtcbiAgdmlldy5fZXZlbnRMaXN0ZW5lcnMgPSBbXTtcbiAgdmlldy5fcmVzaXplTGlzdGVuZXJzID0gW107XG5cbiAgLy8gaW5pdGlhbGl6ZSBldmVudCBjb25maWd1cmF0aW9uXG4gIHZpZXcuX2V2ZW50Q29uZmlnID0gaW5pdGlhbGl6ZUV2ZW50Q29uZmlnKHNwZWMuZXZlbnRDb25maWcpO1xuICB2aWV3Lmdsb2JhbEN1cnNvcih2aWV3Ll9ldmVudENvbmZpZy5nbG9iYWxDdXJzb3IpO1xuXG4gIC8vIGluaXRpYWxpemUgZGF0YWZsb3cgZ3JhcGhcbiAgY29uc3QgY3R4ID0gcnVudGltZSh2aWV3LCBzcGVjLCBvcHRpb25zLmV4cHIpO1xuICB2aWV3Ll9ydW50aW1lID0gY3R4O1xuICB2aWV3Ll9zaWduYWxzID0gY3R4LnNpZ25hbHM7XG4gIHZpZXcuX2JpbmQgPSAoc3BlYy5iaW5kaW5ncyB8fCBbXSkubWFwKF8gPT4gKHtcbiAgICBzdGF0ZTogbnVsbCxcbiAgICBwYXJhbTogZXh0ZW5kKHt9LCBfKVxuICB9KSk7XG5cbiAgLy8gaW5pdGlhbGl6ZSBzY2VuZWdyYXBoXG4gIGlmIChjdHgucm9vdCkgY3R4LnJvb3Quc2V0KHJvb3QpO1xuICByb290LnNvdXJjZSA9IGN0eC5kYXRhLnJvb3QuaW5wdXQ7XG4gIHZpZXcucHVsc2UoY3R4LmRhdGEucm9vdC5pbnB1dCwgdmlldy5jaGFuZ2VzZXQoKS5pbnNlcnQocm9vdC5pdGVtcykpO1xuXG4gIC8vIGluaXRpYWxpemUgdmlldyBzaXplXG4gIHZpZXcuX3dpZHRoID0gdmlldy53aWR0aCgpO1xuICB2aWV3Ll9oZWlnaHQgPSB2aWV3LmhlaWdodCgpO1xuICB2aWV3Ll92aWV3V2lkdGggPSB2aWV3V2lkdGgodmlldywgdmlldy5fd2lkdGgpO1xuICB2aWV3Ll92aWV3SGVpZ2h0ID0gdmlld0hlaWdodCh2aWV3LCB2aWV3Ll9oZWlnaHQpO1xuICB2aWV3Ll9vcmlnaW4gPSBbMCwgMF07XG4gIHZpZXcuX3Jlc2l6ZSA9IDA7XG4gIHZpZXcuX2F1dG9zaXplID0gMTtcbiAgaW5pdGlhbGl6ZVJlc2l6ZSh2aWV3KTtcblxuICAvLyBpbml0aWFsaXplIGJhY2tncm91bmQgY29sb3JcbiAgYmFja2dyb3VuZCh2aWV3KTtcblxuICAvLyBpbml0aWFsaXplIGN1cnNvclxuICBjdXJzb3Iodmlldyk7XG5cbiAgLy8gaW5pdGlhbGl6ZSB2aWV3IGRlc2NyaXB0aW9uXG4gIHZpZXcuZGVzY3JpcHRpb24oc3BlYy5kZXNjcmlwdGlvbik7XG5cbiAgLy8gaW5pdGlhbGl6ZSBob3ZlciBwcm9lc3NpbmcsIGlmIHJlcXVlc3RlZFxuICBpZiAob3B0aW9ucy5ob3Zlcikgdmlldy5ob3ZlcigpO1xuXG4gIC8vIGluaXRpYWxpemUgRE9NIGNvbnRhaW5lcihzKSBhbmQgcmVuZGVyZXJcbiAgaWYgKG9wdGlvbnMuY29udGFpbmVyKSB2aWV3LmluaXRpYWxpemUob3B0aW9ucy5jb250YWluZXIsIG9wdGlvbnMuYmluZCk7XG4gIGlmIChvcHRpb25zLndhdGNoUGl4ZWxSYXRpbykgdmlldy5fd2F0Y2hQaXhlbFJhdGlvKCk7XG59XG5mdW5jdGlvbiBsb29rdXBTaWduYWwodmlldywgbmFtZSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkodmlldy5fc2lnbmFscywgbmFtZSkgPyB2aWV3Ll9zaWduYWxzW25hbWVdIDogZXJyb3IoJ1VucmVjb2duaXplZCBzaWduYWwgbmFtZTogJyArIHN0cmluZ1ZhbHVlKG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGZpbmRPcGVyYXRvckhhbmRsZXIob3AsIGhhbmRsZXIpIHtcbiAgY29uc3QgaCA9IChvcC5fdGFyZ2V0cyB8fCBbXSkuZmlsdGVyKG9wID0+IG9wLl91cGRhdGUgJiYgb3AuX3VwZGF0ZS5oYW5kbGVyID09PSBoYW5kbGVyKTtcbiAgcmV0dXJuIGgubGVuZ3RoID8gaFswXSA6IG51bGw7XG59XG5mdW5jdGlvbiBhZGRPcGVyYXRvckxpc3RlbmVyKHZpZXcsIG5hbWUsIG9wLCBoYW5kbGVyKSB7XG4gIGxldCBoID0gZmluZE9wZXJhdG9ySGFuZGxlcihvcCwgaGFuZGxlcik7XG4gIGlmICghaCkge1xuICAgIGggPSB0cmFwKHZpZXcsICgpID0+IGhhbmRsZXIobmFtZSwgb3AudmFsdWUpKTtcbiAgICBoLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgIHZpZXcub24ob3AsIG51bGwsIGgpO1xuICB9XG4gIHJldHVybiB2aWV3O1xufVxuZnVuY3Rpb24gcmVtb3ZlT3BlcmF0b3JMaXN0ZW5lcih2aWV3LCBvcCwgaGFuZGxlcikge1xuICBjb25zdCBoID0gZmluZE9wZXJhdG9ySGFuZGxlcihvcCwgaGFuZGxlcik7XG4gIGlmIChoKSBvcC5fdGFyZ2V0cy5yZW1vdmUoaCk7XG4gIHJldHVybiB2aWV3O1xufVxuaW5oZXJpdHMoVmlldywgRGF0YWZsb3csIHtcbiAgLy8gLS0gREFUQUZMT1cgLyBSRU5ERVJJTkcgLS0tLVxuXG4gIGFzeW5jIGV2YWx1YXRlKGVuY29kZSwgcHJlcnVuLCBwb3N0cnVuKSB7XG4gICAgLy8gZXZhbHVhdGUgZGF0YWZsb3cgYW5kIHByZXJ1blxuICAgIGF3YWl0IERhdGFmbG93LnByb3RvdHlwZS5ldmFsdWF0ZS5jYWxsKHRoaXMsIGVuY29kZSwgcHJlcnVuKTtcblxuICAgIC8vIHJlbmRlciBhcyBuZWVkZWRcbiAgICBpZiAodGhpcy5fcmVkcmF3IHx8IHRoaXMuX3Jlc2l6ZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlcmVyKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX3Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVzaXplID0gMDtcbiAgICAgICAgICAgIHJlc2l6ZVJlbmRlcmVyKHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhd2FpdCB0aGlzLl9yZW5kZXJlci5yZW5kZXJBc3luYyh0aGlzLl9zY2VuZWdyYXBoLnJvb3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlZHJhdyA9IGZhbHNlO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmVycm9yKGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGV2YWx1YXRlIHBvc3RydW5cbiAgICBpZiAocG9zdHJ1bikgYXN5bmNDYWxsYmFjayh0aGlzLCBwb3N0cnVuKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgZGlydHkoaXRlbSkge1xuICAgIHRoaXMuX3JlZHJhdyA9IHRydWU7XG4gICAgdGhpcy5fcmVuZGVyZXIgJiYgdGhpcy5fcmVuZGVyZXIuZGlydHkoaXRlbSk7XG4gIH0sXG4gIC8vIC0tIEdFVCAvIFNFVCAtLS0tXG5cbiAgZGVzY3JpcHRpb24odGV4dCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBkZXNjID0gdGV4dCAhPSBudWxsID8gdGV4dCArICcnIDogbnVsbDtcbiAgICAgIGlmIChkZXNjICE9PSB0aGlzLl9kZXNjKSBhcmlhTGFiZWwodGhpcy5fZWwsIHRoaXMuX2Rlc2MgPSBkZXNjKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fZGVzYztcbiAgfSxcbiAgY29udGFpbmVyKCkge1xuICAgIHJldHVybiB0aGlzLl9lbDtcbiAgfSxcbiAgc2NlbmVncmFwaCgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NlbmVncmFwaDtcbiAgfSxcbiAgb3JpZ2luKCkge1xuICAgIHJldHVybiB0aGlzLl9vcmlnaW4uc2xpY2UoKTtcbiAgfSxcbiAgc2lnbmFsKG5hbWUsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qgb3AgPSBsb29rdXBTaWduYWwodGhpcywgbmFtZSk7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgPyBvcC52YWx1ZSA6IHRoaXMudXBkYXRlKG9wLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH0sXG4gIHdpZHRoKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCd3aWR0aCcsIF8pIDogdGhpcy5zaWduYWwoJ3dpZHRoJyk7XG4gIH0sXG4gIGhlaWdodChfKSB7XG4gICAgcmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLnNpZ25hbCgnaGVpZ2h0JywgXykgOiB0aGlzLnNpZ25hbCgnaGVpZ2h0Jyk7XG4gIH0sXG4gIHBhZGRpbmcoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ3BhZGRpbmcnLCBwYWRkaW5nKF8pKSA6IHBhZGRpbmcodGhpcy5zaWduYWwoJ3BhZGRpbmcnKSk7XG4gIH0sXG4gIGF1dG9zaXplKF8pIHtcbiAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMuc2lnbmFsKCdhdXRvc2l6ZScsIF8pIDogdGhpcy5zaWduYWwoJ2F1dG9zaXplJyk7XG4gIH0sXG4gIGJhY2tncm91bmQoXykge1xuICAgIHJldHVybiBhcmd1bWVudHMubGVuZ3RoID8gdGhpcy5zaWduYWwoJ2JhY2tncm91bmQnLCBfKSA6IHRoaXMuc2lnbmFsKCdiYWNrZ3JvdW5kJyk7XG4gIH0sXG4gIHJlbmRlcmVyKHR5cGUpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9yZW5kZXJUeXBlO1xuICAgIGlmICghcmVuZGVyTW9kdWxlKHR5cGUpKSBlcnJvcignVW5yZWNvZ25pemVkIHJlbmRlcmVyIHR5cGU6ICcgKyB0eXBlKTtcbiAgICBpZiAodHlwZSAhPT0gdGhpcy5fcmVuZGVyVHlwZSkge1xuICAgICAgdGhpcy5fcmVuZGVyVHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLl9yZXNldFJlbmRlcmVyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB0b29sdGlwKGhhbmRsZXIpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl90b29sdGlwO1xuICAgIGlmIChoYW5kbGVyICE9PSB0aGlzLl90b29sdGlwKSB7XG4gICAgICB0aGlzLl90b29sdGlwID0gaGFuZGxlcjtcbiAgICAgIHRoaXMuX3Jlc2V0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGxvYWRlcihsb2FkZXIpIHtcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLl9sb2FkZXI7XG4gICAgaWYgKGxvYWRlciAhPT0gdGhpcy5fbG9hZGVyKSB7XG4gICAgICBEYXRhZmxvdy5wcm90b3R5cGUubG9hZGVyLmNhbGwodGhpcywgbG9hZGVyKTtcbiAgICAgIHRoaXMuX3Jlc2V0UmVuZGVyZXIoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlc2l6ZSgpIHtcbiAgICAvLyBzZXQgZmxhZyB0byBwZXJmb3JtIGF1dG9zaXplXG4gICAgdGhpcy5fYXV0b3NpemUgPSAxO1xuICAgIC8vIHRvdWNoIGF1dG9zaXplIHNpZ25hbCB0byBlbnN1cmUgdG9wLWxldmVsIFZpZXdMYXlvdXQgcnVuc1xuICAgIHJldHVybiB0aGlzLnRvdWNoKGxvb2t1cFNpZ25hbCh0aGlzLCAnYXV0b3NpemUnKSk7XG4gIH0sXG4gIF9yZXNldFJlbmRlcmVyKCkge1xuICAgIGlmICh0aGlzLl9yZW5kZXJlcikge1xuICAgICAgdGhpcy5fcmVuZGVyZXIgPSBudWxsO1xuICAgICAgdGhpcy5pbml0aWFsaXplKHRoaXMuX2VsLCB0aGlzLl9lbEJpbmQpO1xuICAgIH1cbiAgfSxcbiAgLy8gLS0gU0laSU5HIC0tLS1cbiAgX3Jlc2l6ZVZpZXc6IHJlc2l6ZVZpZXcsXG4gIC8vIC0tIEVWRU5UIEhBTkRMSU5HIC0tLS1cblxuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMpIHtcbiAgICBsZXQgY2FsbGJhY2sgPSBoYW5kbGVyO1xuICAgIGlmICghKG9wdGlvbnMgJiYgb3B0aW9ucy50cmFwID09PSBmYWxzZSkpIHtcbiAgICAgIC8vIHdyYXAgY2FsbGJhY2sgaW4gZXJyb3IgaGFuZGxlclxuICAgICAgY2FsbGJhY2sgPSB0cmFwKHRoaXMsIGhhbmRsZXIpO1xuICAgICAgY2FsbGJhY2sucmF3ID0gaGFuZGxlcjtcbiAgICB9XG4gICAgdGhpcy5faGFuZGxlci5vbih0eXBlLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIHZhciBoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXIuaGFuZGxlcnModHlwZSksXG4gICAgICBpID0gaGFuZGxlcnMubGVuZ3RoLFxuICAgICAgaCxcbiAgICAgIHQ7XG5cbiAgICAvLyBzZWFyY2ggcmVnaXN0ZXJlZCBoYW5kbGVycywgcmVtb3ZlIGlmIG1hdGNoIGZvdW5kXG4gICAgd2hpbGUgKC0taSA+PSAwKSB7XG4gICAgICB0ID0gaGFuZGxlcnNbaV0udHlwZTtcbiAgICAgIGggPSBoYW5kbGVyc1tpXS5oYW5kbGVyO1xuICAgICAgaWYgKHR5cGUgPT09IHQgJiYgKGhhbmRsZXIgPT09IGggfHwgaGFuZGxlciA9PT0gaC5yYXcpKSB7XG4gICAgICAgIHRoaXMuX2hhbmRsZXIub2ZmKHQsIGgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZFJlc2l6ZUxpc3RlbmVyKGhhbmRsZXIpIHtcbiAgICBjb25zdCBsID0gdGhpcy5fcmVzaXplTGlzdGVuZXJzO1xuICAgIGlmICghbC5pbmNsdWRlcyhoYW5kbGVyKSkge1xuICAgICAgLy8gYWRkIGhhbmRsZXIgaWYgaXQgaXNuJ3QgYWxyZWFkeSByZWdpc3RlcmVkXG4gICAgICAvLyBub3RlOiBlcnJvciB0cmFwcGluZyBoYW5kbGVkIGVsc2V3aGVyZSwgc29cbiAgICAgIC8vIG5vIG5lZWQgdG8gd3JhcCBoYW5kbGVycyBoZXJlXG4gICAgICBsLnB1c2goaGFuZGxlcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICByZW1vdmVSZXNpemVMaXN0ZW5lcihoYW5kbGVyKSB7XG4gICAgdmFyIGwgPSB0aGlzLl9yZXNpemVMaXN0ZW5lcnMsXG4gICAgICBpID0gbC5pbmRleE9mKGhhbmRsZXIpO1xuICAgIGlmIChpID49IDApIHtcbiAgICAgIGwuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgYWRkU2lnbmFsTGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBhZGRPcGVyYXRvckxpc3RlbmVyKHRoaXMsIG5hbWUsIGxvb2t1cFNpZ25hbCh0aGlzLCBuYW1lKSwgaGFuZGxlcik7XG4gIH0sXG4gIHJlbW92ZVNpZ25hbExpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVtb3ZlT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBsb29rdXBTaWduYWwodGhpcywgbmFtZSksIGhhbmRsZXIpO1xuICB9LFxuICBhZGREYXRhTGlzdGVuZXIobmFtZSwgaGFuZGxlcikge1xuICAgIHJldHVybiBhZGRPcGVyYXRvckxpc3RlbmVyKHRoaXMsIG5hbWUsIGRhdGFyZWYodGhpcywgbmFtZSkudmFsdWVzLCBoYW5kbGVyKTtcbiAgfSxcbiAgcmVtb3ZlRGF0YUxpc3RlbmVyKG5hbWUsIGhhbmRsZXIpIHtcbiAgICByZXR1cm4gcmVtb3ZlT3BlcmF0b3JMaXN0ZW5lcih0aGlzLCBkYXRhcmVmKHRoaXMsIG5hbWUpLnZhbHVlcywgaGFuZGxlcik7XG4gIH0sXG4gIGdsb2JhbEN1cnNvcihfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzLl9nbG9iYWxDdXJzb3IgIT09ICEhXykge1xuICAgICAgICBjb25zdCBwcmV2ID0gc2V0Q3Vyc29yKHRoaXMsIG51bGwpOyAvLyBjbGVhciBwcmV2aW91cyBjdXJzb3JcbiAgICAgICAgdGhpcy5fZ2xvYmFsQ3Vyc29yID0gISFfO1xuICAgICAgICBpZiAocHJldikgc2V0Q3Vyc29yKHRoaXMsIHByZXYpOyAvLyBzd2FwIGN1cnNvclxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0aGlzLl9nbG9iYWxDdXJzb3I7XG4gICAgfVxuICB9LFxuICBwcmV2ZW50RGVmYXVsdChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuX3ByZXZlbnREZWZhdWx0ID0gXztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fcHJldmVudERlZmF1bHQ7XG4gICAgfVxuICB9LFxuICB0aW1lcixcbiAgZXZlbnRzLFxuICBmaW5hbGl6ZSxcbiAgaG92ZXIsXG4gIC8vIC0tIERBVEEgLS0tLVxuICBkYXRhLFxuICBjaGFuZ2UsXG4gIGluc2VydCxcbiAgcmVtb3ZlLFxuICAvLyAtLSBTQ0FMRVMgLS1cbiAgc2NhbGUsXG4gIC8vIC0tIElOSVRJQUxJWkFUSU9OIC0tLS1cbiAgaW5pdGlhbGl6ZSxcbiAgLy8gLS0gSEVBRExFU1MgUkVOREVSSU5HIC0tLS1cbiAgdG9JbWFnZVVSTDogcmVuZGVyVG9JbWFnZVVSTCxcbiAgdG9DYW52YXM6IHJlbmRlclRvQ2FudmFzLFxuICB0b1NWRzogcmVuZGVyVG9TVkcsXG4gIC8vIC0tIFNBVkUgLyBSRVNUT1JFIFNUQVRFIC0tLS1cbiAgZ2V0U3RhdGUsXG4gIHNldFN0YXRlLFxuICAvLyBSRS1SRU5ERVIgT04gWk9PTVxuICBfd2F0Y2hQaXhlbFJhdGlvOiB3YXRjaFBpeGVsUmF0aW9cbn0pO1xuXG5leHBvcnQgeyBWaWV3IH07XG4iLCJpbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICd2ZWdhLWRhdGFmbG93JztcbmltcG9ydCB7IGluaGVyaXRzIH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IERlbGF1bmF5IH0gZnJvbSAnZDMtZGVsYXVuYXknO1xuXG5mdW5jdGlvbiBWb3Jvbm9pKHBhcmFtcykge1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBudWxsLCBwYXJhbXMpO1xufVxuVm9yb25vaS5EZWZpbml0aW9uID0ge1xuICAndHlwZSc6ICdWb3Jvbm9pJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAneCcsXG4gICAgJ3R5cGUnOiAnZmllbGQnLFxuICAgICdyZXF1aXJlZCc6IHRydWVcbiAgfSwge1xuICAgICduYW1lJzogJ3knLFxuICAgICd0eXBlJzogJ2ZpZWxkJyxcbiAgICAncmVxdWlyZWQnOiB0cnVlXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdzaXplJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDJcbiAgfSwge1xuICAgICduYW1lJzogJ2V4dGVudCcsXG4gICAgJ3R5cGUnOiAnYXJyYXknLFxuICAgICdhcnJheSc6IHRydWUsXG4gICAgJ2xlbmd0aCc6IDIsXG4gICAgJ2RlZmF1bHQnOiBbWy0xZTUsIC0xZTVdLCBbMWU1LCAxZTVdXSxcbiAgICAnY29udGVudCc6IHtcbiAgICAgICd0eXBlJzogJ251bWJlcicsXG4gICAgICAnYXJyYXknOiB0cnVlLFxuICAgICAgJ2xlbmd0aCc6IDJcbiAgICB9XG4gIH0sIHtcbiAgICAnbmFtZSc6ICdhcycsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAnZGVmYXVsdCc6ICdwYXRoJ1xuICB9XVxufTtcbmNvbnN0IGRlZmF1bHRFeHRlbnQgPSBbLTFlNSwgLTFlNSwgMWU1LCAxZTVdO1xuaW5oZXJpdHMoVm9yb25vaSwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGNvbnN0IGFzID0gXy5hcyB8fCAncGF0aCcsXG4gICAgICBkYXRhID0gcHVsc2Uuc291cmNlO1xuXG4gICAgLy8gbm90aGluZyB0byBkbyBpZiBubyBkYXRhXG4gICAgaWYgKCFkYXRhIHx8ICFkYXRhLmxlbmd0aCkgcmV0dXJuIHB1bHNlO1xuXG4gICAgLy8gY29uZmlndXJlIGFuZCBjb25zdHJ1Y3Qgdm9yb25vaSBkaWFncmFtXG4gICAgbGV0IHMgPSBfLnNpemU7XG4gICAgcyA9IHMgPyBbMCwgMCwgc1swXSwgc1sxXV0gOiAocyA9IF8uZXh0ZW50KSA/IFtzWzBdWzBdLCBzWzBdWzFdLCBzWzFdWzBdLCBzWzFdWzFdXSA6IGRlZmF1bHRFeHRlbnQ7XG4gICAgY29uc3Qgdm9yb25vaSA9IHRoaXMudmFsdWUgPSBEZWxhdW5heS5mcm9tKGRhdGEsIF8ueCwgXy55KS52b3Jvbm9pKHMpO1xuXG4gICAgLy8gbWFwIHBvbHlnb25zIHRvIHBhdGhzXG4gICAgZm9yIChsZXQgaSA9IDAsIG4gPSBkYXRhLmxlbmd0aDsgaSA8IG47ICsraSkge1xuICAgICAgY29uc3QgcG9seWdvbiA9IHZvcm9ub2kuY2VsbFBvbHlnb24oaSk7XG4gICAgICBkYXRhW2ldW2FzXSA9IHBvbHlnb24gJiYgIWlzUG9pbnQocG9seWdvbikgPyB0b1BhdGhTdHJpbmcocG9seWdvbikgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gcHVsc2UucmVmbG93KF8ubW9kaWZpZWQoKSkubW9kaWZpZXMoYXMpO1xuICB9XG59KTtcblxuLy8gc3VwcHJlc3MgZHVwbGljYXRlZCBlbmQgcG9pbnQgdmVydGljZXNcbmZ1bmN0aW9uIHRvUGF0aFN0cmluZyhwKSB7XG4gIGNvbnN0IHggPSBwWzBdWzBdLFxuICAgIHkgPSBwWzBdWzFdO1xuICBsZXQgbiA9IHAubGVuZ3RoIC0gMTtcbiAgZm9yICg7IHBbbl1bMF0gPT09IHggJiYgcFtuXVsxXSA9PT0geTsgLS1uKTtcbiAgcmV0dXJuICdNJyArIHAuc2xpY2UoMCwgbiArIDEpLmpvaW4oJ0wnKSArICdaJztcbn1cbmZ1bmN0aW9uIGlzUG9pbnQocCkge1xuICByZXR1cm4gcC5sZW5ndGggPT09IDIgJiYgcFswXVswXSA9PT0gcFsxXVswXSAmJiBwWzBdWzFdID09PSBwWzFdWzFdO1xufVxuXG5leHBvcnQgeyBWb3Jvbm9pIGFzIHZvcm9ub2kgfTtcbiIsImltcG9ydCB7IGNhbnZhcyB9IGZyb20gJ3ZlZ2EtY2FudmFzJztcbmltcG9ydCB7IFRyYW5zZm9ybSB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0IHsgaW5oZXJpdHMsIGVycm9yLCBpc0Z1bmN0aW9uLCBjb25zdGFudCwgZXh0ZW50IH0gZnJvbSAndmVnYS11dGlsJztcbmltcG9ydCB7IHNjYWxlIH0gZnJvbSAndmVnYS1zY2FsZSc7XG5pbXBvcnQgeyByYW5kb20gfSBmcm9tICd2ZWdhLXN0YXRpc3RpY3MnO1xuXG4vKlxuQ29weXJpZ2h0IChjKSAyMDEzLCBKYXNvbiBEYXZpZXMuXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxuXG5SZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbm1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuXG4gICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlLCB0aGlzXG4gICAgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG5cbiAgKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UsXG4gICAgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGUgZG9jdW1lbnRhdGlvblxuICAgIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuXG4gICogVGhlIG5hbWUgSmFzb24gRGF2aWVzIG1heSBub3QgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAgICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yIHdyaXR0ZW4gcGVybWlzc2lvbi5cblxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCIgQU5EXG5BTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRFxuV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRVxuRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgSkFTT04gREFWSUVTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsXG5JTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyAoSU5DTFVESU5HLCBCVVQgTk9UXG5MSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSwgREFUQSwgT1JcblBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EIE9OIEFOWSBUSEVPUlkgT0ZcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVCAoSU5DTFVESU5HIE5FR0xJR0VOQ0Vcbk9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUZcbkFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuKi9cblxuLy8gV29yZCBjbG91ZCBsYXlvdXQgYnkgSmFzb24gRGF2aWVzLCBodHRwczovL3d3dy5qYXNvbmRhdmllcy5jb20vd29yZGNsb3VkL1xuLy8gQWxnb3JpdGhtIGR1ZSB0byBKb25hdGhhbiBGZWluYmVyZywgaHR0cDovL3N0YXRpYy5tcmZlaW5iZXJnLmNvbS9idl9jaDAzLnBkZlxuXG52YXIgY2xvdWRSYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcbiAgY3cgPSAxIDw8IDExID4+IDUsXG4gIGNoID0gMSA8PCAxMTtcbmZ1bmN0aW9uIGNsb3VkICgpIHtcbiAgdmFyIHNpemUgPSBbMjU2LCAyNTZdLFxuICAgIHRleHQsXG4gICAgZm9udCxcbiAgICBmb250U2l6ZSxcbiAgICBmb250U3R5bGUsXG4gICAgZm9udFdlaWdodCxcbiAgICByb3RhdGUsXG4gICAgcGFkZGluZyxcbiAgICBzcGlyYWwgPSBhcmNoaW1lZGVhblNwaXJhbCxcbiAgICB3b3JkcyA9IFtdLFxuICAgIHJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgIGNsb3VkID0ge307XG4gIGNsb3VkLmxheW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29udGV4dEFuZFJhdGlvID0gZ2V0Q29udGV4dChjYW52YXMoKSksXG4gICAgICBib2FyZCA9IHplcm9BcnJheSgoc2l6ZVswXSA+PiA1KSAqIHNpemVbMV0pLFxuICAgICAgYm91bmRzID0gbnVsbCxcbiAgICAgIG4gPSB3b3Jkcy5sZW5ndGgsXG4gICAgICBpID0gLTEsXG4gICAgICB0YWdzID0gW10sXG4gICAgICBkYXRhID0gd29yZHMubWFwKGQgPT4gKHtcbiAgICAgICAgdGV4dDogdGV4dChkKSxcbiAgICAgICAgZm9udDogZm9udChkKSxcbiAgICAgICAgc3R5bGU6IGZvbnRTdHlsZShkKSxcbiAgICAgICAgd2VpZ2h0OiBmb250V2VpZ2h0KGQpLFxuICAgICAgICByb3RhdGU6IHJvdGF0ZShkKSxcbiAgICAgICAgc2l6ZTogfn4oZm9udFNpemUoZCkgKyAxZS0xNCksXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcoZCksXG4gICAgICAgIHhvZmY6IDAsXG4gICAgICAgIHlvZmY6IDAsXG4gICAgICAgIHgxOiAwLFxuICAgICAgICB5MTogMCxcbiAgICAgICAgeDA6IDAsXG4gICAgICAgIHkwOiAwLFxuICAgICAgICBoYXNUZXh0OiBmYWxzZSxcbiAgICAgICAgc3ByaXRlOiBudWxsLFxuICAgICAgICBkYXR1bTogZFxuICAgICAgfSkpLnNvcnQoKGEsIGIpID0+IGIuc2l6ZSAtIGEuc2l6ZSk7XG4gICAgd2hpbGUgKCsraSA8IG4pIHtcbiAgICAgIHZhciBkID0gZGF0YVtpXTtcbiAgICAgIGQueCA9IHNpemVbMF0gKiAocmFuZG9tKCkgKyAuNSkgPj4gMTtcbiAgICAgIGQueSA9IHNpemVbMV0gKiAocmFuZG9tKCkgKyAuNSkgPj4gMTtcbiAgICAgIGNsb3VkU3ByaXRlKGNvbnRleHRBbmRSYXRpbywgZCwgZGF0YSwgaSk7XG4gICAgICBpZiAoZC5oYXNUZXh0ICYmIHBsYWNlKGJvYXJkLCBkLCBib3VuZHMpKSB7XG4gICAgICAgIHRhZ3MucHVzaChkKTtcbiAgICAgICAgaWYgKGJvdW5kcykgY2xvdWRCb3VuZHMoYm91bmRzLCBkKTtlbHNlIGJvdW5kcyA9IFt7XG4gICAgICAgICAgeDogZC54ICsgZC54MCxcbiAgICAgICAgICB5OiBkLnkgKyBkLnkwXG4gICAgICAgIH0sIHtcbiAgICAgICAgICB4OiBkLnggKyBkLngxLFxuICAgICAgICAgIHk6IGQueSArIGQueTFcbiAgICAgICAgfV07XG4gICAgICAgIC8vIFRlbXBvcmFyeSBoYWNrXG4gICAgICAgIGQueCAtPSBzaXplWzBdID4+IDE7XG4gICAgICAgIGQueSAtPSBzaXplWzFdID4+IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0YWdzO1xuICB9O1xuICBmdW5jdGlvbiBnZXRDb250ZXh0KGNhbnZhcykge1xuICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgIHZhciByYXRpbyA9IE1hdGguc3FydChjYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5sZW5ndGggPj4gMik7XG4gICAgY2FudmFzLndpZHRoID0gKGN3IDw8IDUpIC8gcmF0aW87XG4gICAgY2FudmFzLmhlaWdodCA9IGNoIC8gcmF0aW87XG4gICAgdmFyIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGNvbnRleHQuc3Ryb2tlU3R5bGUgPSAncmVkJztcbiAgICBjb250ZXh0LnRleHRBbGlnbiA9ICdjZW50ZXInO1xuICAgIHJldHVybiB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgcmF0aW86IHJhdGlvXG4gICAgfTtcbiAgfVxuICBmdW5jdGlvbiBwbGFjZShib2FyZCwgdGFnLCBib3VuZHMpIHtcbiAgICB2YXIgc3RhcnRYID0gdGFnLngsXG4gICAgICBzdGFydFkgPSB0YWcueSxcbiAgICAgIG1heERlbHRhID0gTWF0aC5oeXBvdChzaXplWzBdLCBzaXplWzFdKSxcbiAgICAgIHMgPSBzcGlyYWwoc2l6ZSksXG4gICAgICBkdCA9IHJhbmRvbSgpIDwgLjUgPyAxIDogLTEsXG4gICAgICB0ID0gLWR0LFxuICAgICAgZHhkeSxcbiAgICAgIGR4LFxuICAgICAgZHk7XG4gICAgd2hpbGUgKGR4ZHkgPSBzKHQgKz0gZHQpKSB7XG4gICAgICBkeCA9IH5+ZHhkeVswXTtcbiAgICAgIGR5ID0gfn5keGR5WzFdO1xuICAgICAgaWYgKE1hdGgubWluKE1hdGguYWJzKGR4KSwgTWF0aC5hYnMoZHkpKSA+PSBtYXhEZWx0YSkgYnJlYWs7XG4gICAgICB0YWcueCA9IHN0YXJ0WCArIGR4O1xuICAgICAgdGFnLnkgPSBzdGFydFkgKyBkeTtcbiAgICAgIGlmICh0YWcueCArIHRhZy54MCA8IDAgfHwgdGFnLnkgKyB0YWcueTAgPCAwIHx8IHRhZy54ICsgdGFnLngxID4gc2l6ZVswXSB8fCB0YWcueSArIHRhZy55MSA+IHNpemVbMV0pIGNvbnRpbnVlO1xuICAgICAgLy8gVE9ETyBvbmx5IGNoZWNrIGZvciBjb2xsaXNpb25zIHdpdGhpbiBjdXJyZW50IGJvdW5kcy5cbiAgICAgIGlmICghYm91bmRzIHx8ICFjbG91ZENvbGxpZGUodGFnLCBib2FyZCwgc2l6ZVswXSkpIHtcbiAgICAgICAgaWYgKCFib3VuZHMgfHwgY29sbGlkZVJlY3RzKHRhZywgYm91bmRzKSkge1xuICAgICAgICAgIHZhciBzcHJpdGUgPSB0YWcuc3ByaXRlLFxuICAgICAgICAgICAgdyA9IHRhZy53aWR0aCA+PiA1LFxuICAgICAgICAgICAgc3cgPSBzaXplWzBdID4+IDUsXG4gICAgICAgICAgICBseCA9IHRhZy54IC0gKHcgPDwgNCksXG4gICAgICAgICAgICBzeCA9IGx4ICYgMHg3ZixcbiAgICAgICAgICAgIG1zeCA9IDMyIC0gc3gsXG4gICAgICAgICAgICBoID0gdGFnLnkxIC0gdGFnLnkwLFxuICAgICAgICAgICAgeCA9ICh0YWcueSArIHRhZy55MCkgKiBzdyArIChseCA+PiA1KSxcbiAgICAgICAgICAgIGxhc3Q7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgICAgICAgIGxhc3QgPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICAgICAgICAgIGJvYXJkW3ggKyBpXSB8PSBsYXN0IDw8IG1zeCB8IChpIDwgdyA/IChsYXN0ID0gc3ByaXRlW2ogKiB3ICsgaV0pID4+PiBzeCA6IDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCArPSBzdztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGFnLnNwcml0ZSA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNsb3VkLndvcmRzID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgd29yZHMgPSBfO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gd29yZHM7XG4gICAgfVxuICB9O1xuICBjbG91ZC5zaXplID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgc2l6ZSA9IFsrX1swXSwgK19bMV1dO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gIH07XG4gIGNsb3VkLmZvbnQgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250ID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZvbnQ7XG4gICAgfVxuICB9O1xuICBjbG91ZC5mb250U3R5bGUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250U3R5bGUgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9udFN0eWxlO1xuICAgIH1cbiAgfTtcbiAgY2xvdWQuZm9udFdlaWdodCA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIGZvbnRXZWlnaHQgPSBmdW5jdG9yKF8pO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZm9udFdlaWdodDtcbiAgICB9XG4gIH07XG4gIGNsb3VkLnJvdGF0ZSA9IGZ1bmN0aW9uIChfKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHJvdGF0ZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiByb3RhdGU7XG4gICAgfVxuICB9O1xuICBjbG91ZC50ZXh0ID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgdGV4dCA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgfTtcbiAgY2xvdWQuc3BpcmFsID0gZnVuY3Rpb24gKF8pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgc3BpcmFsID0gc3BpcmFsc1tfXSB8fCBfO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3BpcmFsO1xuICAgIH1cbiAgfTtcbiAgY2xvdWQuZm9udFNpemUgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBmb250U2l6ZSA9IGZ1bmN0b3IoXyk7XG4gICAgICByZXR1cm4gY2xvdWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmb250U2l6ZTtcbiAgICB9XG4gIH07XG4gIGNsb3VkLnBhZGRpbmcgPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBwYWRkaW5nID0gZnVuY3RvcihfKTtcbiAgICAgIHJldHVybiBjbG91ZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHBhZGRpbmc7XG4gICAgfVxuICB9O1xuICBjbG91ZC5yYW5kb20gPSBmdW5jdGlvbiAoXykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICByYW5kb20gPSBfO1xuICAgICAgcmV0dXJuIGNsb3VkO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gcmFuZG9tO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGNsb3VkO1xufVxuXG4vLyBGZXRjaGVzIGEgbW9ub2Nocm9tZSBzcHJpdGUgYml0bWFwIGZvciB0aGUgc3BlY2lmaWVkIHRleHQuXG4vLyBMb2FkIGluIGJhdGNoZXMgZm9yIHNwZWVkLlxuZnVuY3Rpb24gY2xvdWRTcHJpdGUoY29udGV4dEFuZFJhdGlvLCBkLCBkYXRhLCBkaSkge1xuICBpZiAoZC5zcHJpdGUpIHJldHVybjtcbiAgdmFyIGMgPSBjb250ZXh0QW5kUmF0aW8uY29udGV4dCxcbiAgICByYXRpbyA9IGNvbnRleHRBbmRSYXRpby5yYXRpbztcbiAgYy5jbGVhclJlY3QoMCwgMCwgKGN3IDw8IDUpIC8gcmF0aW8sIGNoIC8gcmF0aW8pO1xuICB2YXIgeCA9IDAsXG4gICAgeSA9IDAsXG4gICAgbWF4aCA9IDAsXG4gICAgbiA9IGRhdGEubGVuZ3RoLFxuICAgIHcsXG4gICAgdzMyLFxuICAgIGgsXG4gICAgaSxcbiAgICBqO1xuICAtLWRpO1xuICB3aGlsZSAoKytkaSA8IG4pIHtcbiAgICBkID0gZGF0YVtkaV07XG4gICAgYy5zYXZlKCk7XG4gICAgYy5mb250ID0gZC5zdHlsZSArICcgJyArIGQud2VpZ2h0ICsgJyAnICsgfn4oKGQuc2l6ZSArIDEpIC8gcmF0aW8pICsgJ3B4ICcgKyBkLmZvbnQ7XG4gICAgdyA9IGMubWVhc3VyZVRleHQoZC50ZXh0ICsgJ20nKS53aWR0aCAqIHJhdGlvO1xuICAgIGggPSBkLnNpemUgPDwgMTtcbiAgICBpZiAoZC5yb3RhdGUpIHtcbiAgICAgIHZhciBzciA9IE1hdGguc2luKGQucm90YXRlICogY2xvdWRSYWRpYW5zKSxcbiAgICAgICAgY3IgPSBNYXRoLmNvcyhkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyksXG4gICAgICAgIHdjciA9IHcgKiBjcixcbiAgICAgICAgd3NyID0gdyAqIHNyLFxuICAgICAgICBoY3IgPSBoICogY3IsXG4gICAgICAgIGhzciA9IGggKiBzcjtcbiAgICAgIHcgPSBNYXRoLm1heChNYXRoLmFicyh3Y3IgKyBoc3IpLCBNYXRoLmFicyh3Y3IgLSBoc3IpKSArIDB4MWYgPj4gNSA8PCA1O1xuICAgICAgaCA9IH5+TWF0aC5tYXgoTWF0aC5hYnMod3NyICsgaGNyKSwgTWF0aC5hYnMod3NyIC0gaGNyKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHcgPSB3ICsgMHgxZiA+PiA1IDw8IDU7XG4gICAgfVxuICAgIGlmIChoID4gbWF4aCkgbWF4aCA9IGg7XG4gICAgaWYgKHggKyB3ID49IGN3IDw8IDUpIHtcbiAgICAgIHggPSAwO1xuICAgICAgeSArPSBtYXhoO1xuICAgICAgbWF4aCA9IDA7XG4gICAgfVxuICAgIGlmICh5ICsgaCA+PSBjaCkgYnJlYWs7XG4gICAgYy50cmFuc2xhdGUoKHggKyAodyA+PiAxKSkgLyByYXRpbywgKHkgKyAoaCA+PiAxKSkgLyByYXRpbyk7XG4gICAgaWYgKGQucm90YXRlKSBjLnJvdGF0ZShkLnJvdGF0ZSAqIGNsb3VkUmFkaWFucyk7XG4gICAgYy5maWxsVGV4dChkLnRleHQsIDAsIDApO1xuICAgIGlmIChkLnBhZGRpbmcpIHtcbiAgICAgIGMubGluZVdpZHRoID0gMiAqIGQucGFkZGluZztcbiAgICAgIGMuc3Ryb2tlVGV4dChkLnRleHQsIDAsIDApO1xuICAgIH1cbiAgICBjLnJlc3RvcmUoKTtcbiAgICBkLndpZHRoID0gdztcbiAgICBkLmhlaWdodCA9IGg7XG4gICAgZC54b2ZmID0geDtcbiAgICBkLnlvZmYgPSB5O1xuICAgIGQueDEgPSB3ID4+IDE7XG4gICAgZC55MSA9IGggPj4gMTtcbiAgICBkLngwID0gLWQueDE7XG4gICAgZC55MCA9IC1kLnkxO1xuICAgIGQuaGFzVGV4dCA9IHRydWU7XG4gICAgeCArPSB3O1xuICB9XG4gIHZhciBwaXhlbHMgPSBjLmdldEltYWdlRGF0YSgwLCAwLCAoY3cgPDwgNSkgLyByYXRpbywgY2ggLyByYXRpbykuZGF0YSxcbiAgICBzcHJpdGUgPSBbXTtcbiAgd2hpbGUgKC0tZGkgPj0gMCkge1xuICAgIGQgPSBkYXRhW2RpXTtcbiAgICBpZiAoIWQuaGFzVGV4dCkgY29udGludWU7XG4gICAgdyA9IGQud2lkdGg7XG4gICAgdzMyID0gdyA+PiA1O1xuICAgIGggPSBkLnkxIC0gZC55MDtcbiAgICAvLyBaZXJvIHRoZSBidWZmZXJcbiAgICBmb3IgKGkgPSAwOyBpIDwgaCAqIHczMjsgaSsrKSBzcHJpdGVbaV0gPSAwO1xuICAgIHggPSBkLnhvZmY7XG4gICAgaWYgKHggPT0gbnVsbCkgcmV0dXJuO1xuICAgIHkgPSBkLnlvZmY7XG4gICAgdmFyIHNlZW4gPSAwLFxuICAgICAgc2VlblJvdyA9IC0xO1xuICAgIGZvciAoaiA9IDA7IGogPCBoOyBqKyspIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB3OyBpKyspIHtcbiAgICAgICAgdmFyIGsgPSB3MzIgKiBqICsgKGkgPj4gNSksXG4gICAgICAgICAgbSA9IHBpeGVsc1soeSArIGopICogKGN3IDw8IDUpICsgKHggKyBpKSA8PCAyXSA/IDEgPDwgMzEgLSBpICUgMzIgOiAwO1xuICAgICAgICBzcHJpdGVba10gfD0gbTtcbiAgICAgICAgc2VlbiB8PSBtO1xuICAgICAgfVxuICAgICAgaWYgKHNlZW4pIHNlZW5Sb3cgPSBqO2Vsc2Uge1xuICAgICAgICBkLnkwKys7XG4gICAgICAgIGgtLTtcbiAgICAgICAgai0tO1xuICAgICAgICB5Kys7XG4gICAgICB9XG4gICAgfVxuICAgIGQueTEgPSBkLnkwICsgc2VlblJvdztcbiAgICBkLnNwcml0ZSA9IHNwcml0ZS5zbGljZSgwLCAoZC55MSAtIGQueTApICogdzMyKTtcbiAgfVxufVxuXG4vLyBVc2UgbWFzay1iYXNlZCBjb2xsaXNpb24gZGV0ZWN0aW9uLlxuZnVuY3Rpb24gY2xvdWRDb2xsaWRlKHRhZywgYm9hcmQsIHN3KSB7XG4gIHN3ID4+PSA1O1xuICB2YXIgc3ByaXRlID0gdGFnLnNwcml0ZSxcbiAgICB3ID0gdGFnLndpZHRoID4+IDUsXG4gICAgbHggPSB0YWcueCAtICh3IDw8IDQpLFxuICAgIHN4ID0gbHggJiAweDdmLFxuICAgIG1zeCA9IDMyIC0gc3gsXG4gICAgaCA9IHRhZy55MSAtIHRhZy55MCxcbiAgICB4ID0gKHRhZy55ICsgdGFnLnkwKSAqIHN3ICsgKGx4ID4+IDUpLFxuICAgIGxhc3Q7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgaDsgaisrKSB7XG4gICAgbGFzdCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gdzsgaSsrKSB7XG4gICAgICBpZiAoKGxhc3QgPDwgbXN4IHwgKGkgPCB3ID8gKGxhc3QgPSBzcHJpdGVbaiAqIHcgKyBpXSkgPj4+IHN4IDogMCkpICYgYm9hcmRbeCArIGldKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgeCArPSBzdztcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjbG91ZEJvdW5kcyhib3VuZHMsIGQpIHtcbiAgdmFyIGIwID0gYm91bmRzWzBdLFxuICAgIGIxID0gYm91bmRzWzFdO1xuICBpZiAoZC54ICsgZC54MCA8IGIwLngpIGIwLnggPSBkLnggKyBkLngwO1xuICBpZiAoZC55ICsgZC55MCA8IGIwLnkpIGIwLnkgPSBkLnkgKyBkLnkwO1xuICBpZiAoZC54ICsgZC54MSA+IGIxLngpIGIxLnggPSBkLnggKyBkLngxO1xuICBpZiAoZC55ICsgZC55MSA+IGIxLnkpIGIxLnkgPSBkLnkgKyBkLnkxO1xufVxuZnVuY3Rpb24gY29sbGlkZVJlY3RzKGEsIGIpIHtcbiAgcmV0dXJuIGEueCArIGEueDEgPiBiWzBdLnggJiYgYS54ICsgYS54MCA8IGJbMV0ueCAmJiBhLnkgKyBhLnkxID4gYlswXS55ICYmIGEueSArIGEueTAgPCBiWzFdLnk7XG59XG5mdW5jdGlvbiBhcmNoaW1lZGVhblNwaXJhbChzaXplKSB7XG4gIHZhciBlID0gc2l6ZVswXSAvIHNpemVbMV07XG4gIHJldHVybiBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbZSAqICh0ICo9IC4xKSAqIE1hdGguY29zKHQpLCB0ICogTWF0aC5zaW4odCldO1xuICB9O1xufVxuZnVuY3Rpb24gcmVjdGFuZ3VsYXJTcGlyYWwoc2l6ZSkge1xuICB2YXIgZHkgPSA0LFxuICAgIGR4ID0gZHkgKiBzaXplWzBdIC8gc2l6ZVsxXSxcbiAgICB4ID0gMCxcbiAgICB5ID0gMDtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHNpZ24gPSB0IDwgMCA/IC0xIDogMTtcbiAgICAvLyBTZWUgdHJpYW5ndWxhciBudW1iZXJzOiBUX24gPSBuICogKG4gKyAxKSAvIDIuXG4gICAgc3dpdGNoIChNYXRoLnNxcnQoMSArIDQgKiBzaWduICogdCkgLSBzaWduICYgMykge1xuICAgICAgY2FzZSAwOlxuICAgICAgICB4ICs9IGR4O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgeSArPSBkeTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHggLT0gZHg7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgeSAtPSBkeTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBbeCwgeV07XG4gIH07XG59XG5cbi8vIFRPRE8gcmV1c2UgYXJyYXlzP1xuZnVuY3Rpb24gemVyb0FycmF5KG4pIHtcbiAgdmFyIGEgPSBbXSxcbiAgICBpID0gLTE7XG4gIHdoaWxlICgrK2kgPCBuKSBhW2ldID0gMDtcbiAgcmV0dXJuIGE7XG59XG5mdW5jdGlvbiBmdW5jdG9yKGQpIHtcbiAgcmV0dXJuIHR5cGVvZiBkID09PSAnZnVuY3Rpb24nID8gZCA6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZDtcbiAgfTtcbn1cbnZhciBzcGlyYWxzID0ge1xuICBhcmNoaW1lZGVhbjogYXJjaGltZWRlYW5TcGlyYWwsXG4gIHJlY3Rhbmd1bGFyOiByZWN0YW5ndWxhclNwaXJhbFxufTtcblxuY29uc3QgT3V0cHV0ID0gWyd4JywgJ3knLCAnZm9udCcsICdmb250U2l6ZScsICdmb250U3R5bGUnLCAnZm9udFdlaWdodCcsICdhbmdsZSddO1xuY29uc3QgUGFyYW1zID0gWyd0ZXh0JywgJ2ZvbnQnLCAncm90YXRlJywgJ2ZvbnRTaXplJywgJ2ZvbnRTdHlsZScsICdmb250V2VpZ2h0J107XG5mdW5jdGlvbiBXb3JkY2xvdWQocGFyYW1zKSB7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIGNsb3VkKCksIHBhcmFtcyk7XG59XG5Xb3JkY2xvdWQuRGVmaW5pdGlvbiA9IHtcbiAgJ3R5cGUnOiAnV29yZGNsb3VkJyxcbiAgJ21ldGFkYXRhJzoge1xuICAgICdtb2RpZmllcyc6IHRydWVcbiAgfSxcbiAgJ3BhcmFtcyc6IFt7XG4gICAgJ25hbWUnOiAnc2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiB0cnVlLFxuICAgICdsZW5ndGgnOiAyXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdzYW5zLXNlcmlmJ1xuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFN0eWxlJyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdub3JtYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250V2VpZ2h0JyxcbiAgICAndHlwZSc6ICdzdHJpbmcnLFxuICAgICdleHByJzogdHJ1ZSxcbiAgICAnZGVmYXVsdCc6ICdub3JtYWwnXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdmb250U2l6ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAxNFxuICB9LCB7XG4gICAgJ25hbWUnOiAnZm9udFNpemVSYW5nZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnYXJyYXknOiAnbnVsbGFibGUnLFxuICAgICdkZWZhdWx0JzogWzEwLCA1MF1cbiAgfSwge1xuICAgICduYW1lJzogJ3JvdGF0ZScsXG4gICAgJ3R5cGUnOiAnbnVtYmVyJyxcbiAgICAnZXhwcic6IHRydWUsXG4gICAgJ2RlZmF1bHQnOiAwXG4gIH0sIHtcbiAgICAnbmFtZSc6ICd0ZXh0JyxcbiAgICAndHlwZSc6ICdmaWVsZCdcbiAgfSwge1xuICAgICduYW1lJzogJ3NwaXJhbCcsXG4gICAgJ3R5cGUnOiAnc3RyaW5nJyxcbiAgICAndmFsdWVzJzogWydhcmNoaW1lZGVhbicsICdyZWN0YW5ndWxhciddXG4gIH0sIHtcbiAgICAnbmFtZSc6ICdwYWRkaW5nJyxcbiAgICAndHlwZSc6ICdudW1iZXInLFxuICAgICdleHByJzogdHJ1ZVxuICB9LCB7XG4gICAgJ25hbWUnOiAnYXMnLFxuICAgICd0eXBlJzogJ3N0cmluZycsXG4gICAgJ2FycmF5JzogdHJ1ZSxcbiAgICAnbGVuZ3RoJzogNyxcbiAgICAnZGVmYXVsdCc6IE91dHB1dFxuICB9XVxufTtcbmluaGVyaXRzKFdvcmRjbG91ZCwgVHJhbnNmb3JtLCB7XG4gIHRyYW5zZm9ybShfLCBwdWxzZSkge1xuICAgIGlmIChfLnNpemUgJiYgIShfLnNpemVbMF0gJiYgXy5zaXplWzFdKSkge1xuICAgICAgZXJyb3IoJ1dvcmRjbG91ZCBzaXplIGRpbWVuc2lvbnMgbXVzdCBiZSBub24temVyby4nKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbW9kcChwYXJhbSkge1xuICAgICAgY29uc3QgcCA9IF9bcGFyYW1dO1xuICAgICAgcmV0dXJuIGlzRnVuY3Rpb24ocCkgJiYgcHVsc2UubW9kaWZpZWQocC5maWVsZHMpO1xuICAgIH1cbiAgICBjb25zdCBtb2QgPSBfLm1vZGlmaWVkKCk7XG4gICAgaWYgKCEobW9kIHx8IHB1bHNlLmNoYW5nZWQocHVsc2UuQUREX1JFTSkgfHwgUGFyYW1zLnNvbWUobW9kcCkpKSByZXR1cm47XG4gICAgY29uc3QgZGF0YSA9IHB1bHNlLm1hdGVyaWFsaXplKHB1bHNlLlNPVVJDRSkuc291cmNlLFxuICAgICAgbGF5b3V0ID0gdGhpcy52YWx1ZSxcbiAgICAgIGFzID0gXy5hcyB8fCBPdXRwdXQ7XG4gICAgbGV0IGZvbnRTaXplID0gXy5mb250U2l6ZSB8fCAxNCxcbiAgICAgIHJhbmdlO1xuICAgIGlzRnVuY3Rpb24oZm9udFNpemUpID8gcmFuZ2UgPSBfLmZvbnRTaXplUmFuZ2UgOiBmb250U2l6ZSA9IGNvbnN0YW50KGZvbnRTaXplKTtcblxuICAgIC8vIGNyZWF0ZSBmb250IHNpemUgc2NhbGluZyBmdW5jdGlvbiBhcyBuZWVkZWRcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIGNvbnN0IGZzaXplID0gZm9udFNpemUsXG4gICAgICAgIHNpemVTY2FsZSA9IHNjYWxlKCdzcXJ0JykoKS5kb21haW4oZXh0ZW50KGRhdGEsIGZzaXplKSkucmFuZ2UocmFuZ2UpO1xuICAgICAgZm9udFNpemUgPSB4ID0+IHNpemVTY2FsZShmc2l6ZSh4KSk7XG4gICAgfVxuICAgIGRhdGEuZm9yRWFjaCh0ID0+IHtcbiAgICAgIHRbYXNbMF1dID0gTmFOO1xuICAgICAgdFthc1sxXV0gPSBOYU47XG4gICAgICB0W2FzWzNdXSA9IDA7XG4gICAgfSk7XG5cbiAgICAvLyBjb25maWd1cmUgbGF5b3V0XG4gICAgY29uc3Qgd29yZHMgPSBsYXlvdXQud29yZHMoZGF0YSkudGV4dChfLnRleHQpLnNpemUoXy5zaXplIHx8IFs1MDAsIDUwMF0pLnBhZGRpbmcoXy5wYWRkaW5nIHx8IDEpLnNwaXJhbChfLnNwaXJhbCB8fCAnYXJjaGltZWRlYW4nKS5yb3RhdGUoXy5yb3RhdGUgfHwgMCkuZm9udChfLmZvbnQgfHwgJ3NhbnMtc2VyaWYnKS5mb250U3R5bGUoXy5mb250U3R5bGUgfHwgJ25vcm1hbCcpLmZvbnRXZWlnaHQoXy5mb250V2VpZ2h0IHx8ICdub3JtYWwnKS5mb250U2l6ZShmb250U2l6ZSkucmFuZG9tKHJhbmRvbSkubGF5b3V0KCk7XG4gICAgY29uc3Qgc2l6ZSA9IGxheW91dC5zaXplKCksXG4gICAgICBkeCA9IHNpemVbMF0gPj4gMSxcbiAgICAgIGR5ID0gc2l6ZVsxXSA+PiAxLFxuICAgICAgbiA9IHdvcmRzLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMCwgdywgdDsgaSA8IG47ICsraSkge1xuICAgICAgdyA9IHdvcmRzW2ldO1xuICAgICAgdCA9IHcuZGF0dW07XG4gICAgICB0W2FzWzBdXSA9IHcueCArIGR4O1xuICAgICAgdFthc1sxXV0gPSB3LnkgKyBkeTtcbiAgICAgIHRbYXNbMl1dID0gdy5mb250O1xuICAgICAgdFthc1szXV0gPSB3LnNpemU7XG4gICAgICB0W2FzWzRdXSA9IHcuc3R5bGU7XG4gICAgICB0W2FzWzVdXSA9IHcud2VpZ2h0O1xuICAgICAgdFthc1s2XV0gPSB3LnJvdGF0ZTtcbiAgICB9XG4gICAgcmV0dXJuIHB1bHNlLnJlZmxvdyhtb2QpLm1vZGlmaWVzKGFzKTtcbiAgfVxufSk7XG5cbmV4cG9ydCB7IFdvcmRjbG91ZCBhcyB3b3JkY2xvdWQgfTtcbiIsImltcG9ydCB7IGV4dGVuZCB9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5leHBvcnQgKiBmcm9tICd2ZWdhLXV0aWwnO1xuaW1wb3J0IHsgdHJhbnNmb3JtcyB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuZXhwb3J0IHsgRGF0YWZsb3csIEV2ZW50U3RyZWFtLCBNdWx0aVB1bHNlLCBPcGVyYXRvciwgUGFyYW1ldGVycywgUHVsc2UsIFRyYW5zZm9ybSwgY2hhbmdlc2V0LCBkZWZpbml0aW9uLCBpbmdlc3QsIGlzVHVwbGUsIHRyYW5zZm9ybSwgdHJhbnNmb3JtcywgdHVwbGVpZCB9IGZyb20gJ3ZlZ2EtZGF0YWZsb3cnO1xuaW1wb3J0ICogYXMgdHggZnJvbSAndmVnYS10cmFuc2Zvcm1zJztcbmltcG9ydCAqIGFzIHZ0eCBmcm9tICd2ZWdhLXZpZXctdHJhbnNmb3Jtcyc7XG5pbXBvcnQgKiBhcyBlbmNvZGUgZnJvbSAndmVnYS1lbmNvZGUnO1xuaW1wb3J0ICogYXMgZ2VvIGZyb20gJ3ZlZ2EtZ2VvJztcbmltcG9ydCAqIGFzIGZvcmNlIGZyb20gJ3ZlZ2EtZm9yY2UnO1xuaW1wb3J0ICogYXMgdHJlZSBmcm9tICd2ZWdhLWhpZXJhcmNoeSc7XG5pbXBvcnQgKiBhcyBsYWJlbCBmcm9tICd2ZWdhLWxhYmVsJztcbmltcG9ydCAqIGFzIHJlZyBmcm9tICd2ZWdhLXJlZ3Jlc3Npb24nO1xuaW1wb3J0ICogYXMgdm9yb25vaSBmcm9tICd2ZWdhLXZvcm9ub2knO1xuaW1wb3J0ICogYXMgd29yZGNsb3VkIGZyb20gJ3ZlZ2Etd29yZGNsb3VkJztcbmltcG9ydCAqIGFzIHhmIGZyb20gJ3ZlZ2EtY3Jvc3NmaWx0ZXInO1xuZXhwb3J0ICogZnJvbSAndmVnYS1zdGF0aXN0aWNzJztcbmV4cG9ydCAqIGZyb20gJ3ZlZ2EtdGltZSc7XG5leHBvcnQgKiBmcm9tICd2ZWdhLWxvYWRlcic7XG5leHBvcnQgKiBmcm9tICd2ZWdhLXNjZW5lZ3JhcGgnO1xuZXhwb3J0IHsgaW50ZXJwb2xhdGUsIGludGVycG9sYXRlQ29sb3JzLCBpbnRlcnBvbGF0ZVJhbmdlLCBxdWFudGl6ZUludGVycG9sYXRvciwgc2NhbGUsIHNjaGVtZSB9IGZyb20gJ3ZlZ2Etc2NhbGUnO1xuZXhwb3J0IHsgcHJvamVjdGlvbiB9IGZyb20gJ3ZlZ2EtcHJvamVjdGlvbic7XG5leHBvcnQgeyBWaWV3IH0gZnJvbSAndmVnYS12aWV3JztcbmV4cG9ydCB7IGRlZmF1bHRMb2NhbGUsIG51bWJlckZvcm1hdERlZmF1bHRMb2NhbGUgYXMgZm9ybWF0TG9jYWxlLCBsb2NhbGUsIHJlc2V0RGVmYXVsdExvY2FsZSwgdGltZUZvcm1hdERlZmF1bHRMb2NhbGUgYXMgdGltZUZvcm1hdExvY2FsZSB9IGZyb20gJ3ZlZ2EtZm9ybWF0JztcbmV4cG9ydCB7IGV4cHJlc3Npb25GdW5jdGlvbiB9IGZyb20gJ3ZlZ2EtZnVuY3Rpb25zJztcbmV4cG9ydCB7IHBhcnNlIH0gZnJvbSAndmVnYS1wYXJzZXInO1xuZXhwb3J0IHsgY29udGV4dCBhcyBydW50aW1lQ29udGV4dCB9IGZyb20gJ3ZlZ2EtcnVudGltZSc7XG5leHBvcnQgeyBjb2RlZ2VuRXhwcmVzc2lvbiwgcGFyc2VFeHByZXNzaW9uIH0gZnJvbSAndmVnYS1leHByZXNzaW9uJztcbmV4cG9ydCB7IHBhcnNlU2VsZWN0b3IgfSBmcm9tICd2ZWdhLWV2ZW50LXNlbGVjdG9yJztcblxudmFyIHZlcnNpb24gPSBcIjUuMzMuMFwiO1xuXG4vLyAtLSBUcmFuc2Zvcm1zIC0tLS0tXG5cbmV4dGVuZCh0cmFuc2Zvcm1zLCB0eCwgdnR4LCBlbmNvZGUsIGdlbywgZm9yY2UsIGxhYmVsLCB0cmVlLCByZWcsIHZvcm9ub2ksIHdvcmRjbG91ZCwgeGYpO1xuXG5leHBvcnQgeyB2ZXJzaW9uIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=