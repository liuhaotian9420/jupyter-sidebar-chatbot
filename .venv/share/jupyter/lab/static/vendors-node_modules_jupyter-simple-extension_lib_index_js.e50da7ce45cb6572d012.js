"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/api-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/api-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: icons_1.extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/globals.js":
/*!**************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/globals.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/icons.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/icons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Import the main CSS file
__webpack_require__(/*! ../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/markdown-config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/markdown-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = text.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks, handle list items
        return line.replace(/([^\n\s])-\s/g, '$1\n- ');
    });
    return processedLines.join('\n');
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
/**
 * Manages the state and interactions of the multi-level popup menu.
 */
class PopupMenuManager {
    constructor(docManager, widgetNode, callbacks) {
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        this.currentNotebook = null;
        this.selectedMenuItemIndex = -1; // Track currently selected menu item
        this.isRenderingContent = false; // Flag to prevent recursive renders
        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders
        this.docManager = docManager;
        this.widgetNode = widgetNode;
        this.callbacks = callbacks;
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        // Attach to the widget node instead of the body
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Create search input
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search...';
        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling
        // Use 'input' event instead of directly re-rendering on every keystroke
        this.searchInput.addEventListener('input', () => {
            // Only re-render if the search term has actually changed
            if (this.searchInput.value !== this.lastSearchTerm) {
                this.lastSearchTerm = this.searchInput.value;
                this.renderMenuContent();
            }
        });
        // Handle keydown in search input to stop propagation for navigation keys
        this.searchInput.addEventListener('keydown', (event) => {
            console.log(`POPUP Search KeyDown: Key='${event.key}'`);
            // IMPORTANT: Prevent these keys from being captured by the document handler
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);
                if (event.key === 'Escape') {
                    // Handle Escape directly here
                    this.hidePopupMenu();
                }
                else if (event.key === 'Enter') {
                    // Maybe select first item on Enter?
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        this.selectedMenuItemIndex = 0;
                        this.updateSelectionHighlight();
                        // Optionally activate the item:
                        // menuItems[0].click(); 
                    }
                }
                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    // Move to first/last menu item
                    // The blur() will be handled by main key handler
                }
                event.stopPropagation();
            }
            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys
            // This allows default behavior to work properly
        }, true); // Use capture phase
        document.addEventListener('click', this.handleDocumentClick.bind(this), true);
        // IMPORTANT: Use a separate bound function for the document keydown
        // so we can remove the exact same listener later
        this.boundHandleKeyDown = this.handleKeyDown.bind(this);
        document.addEventListener('keydown', this.boundHandleKeyDown, true);
        if (globals_1.globals.notebookTracker) {
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            globals_1.globals.notebookTracker.currentChanged.connect((_, notebook) => {
                this.currentNotebook = notebook;
            });
        }
    }
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);
        // Remove using the exact same bound function
        document.removeEventListener('keydown', this.boundHandleKeyDown, true);
        // Remove from widgetNode if attached
        if (this.popupMenuContainer.parentNode === this.widgetNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
    handleDocumentClick(event) {
        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');
            if (atButton && atButton.contains(event.target)) {
                console.log('POPUP: Click was on the @ button, not hiding.');
                return;
            }
            console.log('POPUP: Click detected outside the menu.');
            this.hidePopupMenu();
        }
    }
    async showPopupMenu(x, y) {
        console.log(`POPUP: Showing menu at (${x}, ${y})`);
        // Store the initial anchor point for positioning
        this._anchorX = x;
        this._anchorY = y;
        if (this.popupMenuContainer.style.display === 'none') {
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
            this.searchInput.value = ''; // Clear search on show
            this.lastSearchTerm = ''; // Reset last search term
            await this.setCurrentDirectoryPath();
        }
        await this.renderMenuContent();
        // Ensure it's attached to the widget node if somehow detached
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Position the popup menu - handled in updatePopupPosition
        this.updatePopupPosition();
        // Focus the search input if we are in file/directory view, otherwise focus the first item
        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
            setTimeout(() => {
                // Focus after timeout to ensure DOM is ready
                this.searchInput.focus();
                console.log('POPUP: Focused search input');
            }, 50); // Slightly longer timeout
            this.selectedMenuItemIndex = -1; // Don't select an item if search is focused
        }
        else {
            // Reset and select the first menu item for top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 50);
        }
    }
    hidePopupMenu() {
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding menu.');
            this.popupMenuContainer.style.display = 'none';
            // No need to explicitly remove from widgetNode unless causing issues
            // If performance becomes an issue with many menus, consider removing/re-adding
            // if (this.popupMenuContainer.parentNode === this.widgetNode) {
            //     this.widgetNode.removeChild(this.popupMenuContainer);
            // }
        }
    }
    async renderMenuContent() {
        // Prevent recursive renders
        if (this.isRenderingContent) {
            console.log('POPUP: Skipping render - already rendering');
            return;
        }
        this.isRenderingContent = true;
        try {
            // Clear existing content
            while (this.popupMenuContainer.firstChild) {
                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);
            }
            // If not at top level, add a search input for filtering items
            if (this.currentMenuLevel !== 'top') {
                // Add search input at the top of the menu
                this.popupMenuContainer.appendChild(this.searchInput);
                // Add the current path display
                const pathDisplay = document.createElement('div');
                pathDisplay.className = 'jp-llm-ext-popup-menu-path';
                if (this.currentMenuLevel === 'cells') {
                    pathDisplay.textContent = 'Current Notebook Cells';
                }
                else {
                    // For files and directories
                    pathDisplay.textContent = this.currentMenuPath || '/';
                }
                this.popupMenuContainer.appendChild(pathDisplay);
                // Add back button if there's a history
                if (this.menuHistory.length > 0) {
                    const backButton = this.createMenuItem('« Back', 'navigate-back');
                    backButton.classList.add('jp-llm-ext-popup-menu-back');
                    this.popupMenuContainer.appendChild(backButton);
                }
            }
            // Render different menu content based on current level
            switch (this.currentMenuLevel) {
                case 'top':
                    this.renderTopLevelItems();
                    break;
                case 'files':
                case 'directories':
                    await this.renderDirectoryBrowserItems();
                    break;
                case 'cells':
                    await this.renderCellItems();
                    break;
            }
            // Reset selection after rendering
            this.selectedMenuItemIndex = -1;
            this.updateSelectionHighlight();
            // Update the position to maintain the fixed bottom edge
            if (this.popupMenuContainer.style.display !== 'none' && this._anchorX !== undefined && this._anchorY !== undefined) {
                this.updatePopupPosition();
            }
        }
        catch (error) {
            console.error('POPUP: Error rendering menu content', error);
        }
        finally {
            this.isRenderingContent = false;
        }
    }
    renderTopLevelItems() {
        const topLevelCommands = [
            { label: 'Code', description: '', actionId: 'insert-code' },
            { label: 'Cells', description: '', actionId: 'browse-cells' },
            { label: 'File', description: '', actionId: 'browse-files' },
            { label: 'Directory', description: '', actionId: 'browse-directories' }
        ];
        topLevelCommands.forEach(cmd => {
            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);
            this.popupMenuContainer.appendChild(item);
        });
    }
    async renderDirectoryBrowserItems() {
        var _a;
        // Get search term
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        // Temporarily add loading item below search/path
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // If contents were already fetched recently and we're just filtering again,
            // we could potentially cache the results to avoid unnecessary API calls
            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';
            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, undefined); // Get both files and dirs first
            // Check if still in DOM before trying to remove
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (contents && contents.length > 0) {
                // Filter based on search term and required type (file/dir)
                const filteredContents = contents.filter(item => {
                    const nameMatches = item.name.toLowerCase().includes(searchTerm);
                    const typeMatches = this.currentMenuLevel === 'files' ? item.type === 'file' : item.type === 'directory';
                    return nameMatches && typeMatches;
                });
                if (filteredContents.length > 0) {
                    filteredContents.forEach(item => {
                        const itemName = item.name;
                        const itemType = item.type;
                        const itemPath = item.path;
                        const icon = itemType === 'directory' ? '📁' : '📄';
                        let actionId;
                        if (itemType === 'directory') {
                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';
                        }
                        else { // itemType === 'file'
                            actionId = 'select-file';
                        }
                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath);
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                }
                else {
                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');
                    emptyItem.style.pointerEvents = 'none';
                    this.popupMenuContainer.appendChild(emptyItem);
                }
            }
            else {
                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
            }
        }
        catch (error) {
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading/filtering directory contents:', error);
        }
    }
    /**
     * Renders all cells from the current notebook
     */
    async renderCellItems() {
        var _a, _b;
        // Get search term for filtering
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        // Create a loading indicator
        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // Check if we have an active notebook
            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {
                // Remove loading item
                if (this.popupMenuContainer.contains(loadingItem)) {
                    this.popupMenuContainer.removeChild(loadingItem);
                }
                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');
                errorItem.style.color = 'red';
                errorItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(errorItem);
                return;
            }
            const notebookModel = this.currentNotebook.content.model;
            const cells = notebookModel.cells;
            // Remove loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (!cells || cells.length === 0) {
                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
                return;
            }
            // Process and display each cell
            let filteredCellCount = 0;
            for (let i = 0; i < cells.length; i++) {
                const cell = cells.get(i);
                const cellType = cell.type;
                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :
                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');
                // Use type casting to avoid TypeScript errors
                const executionCount = cellType === 'code' ?
                    (cell.executionCount !== undefined && cell.executionCount !== null ?
                        cell.executionCount : '*') :
                    '';
                // Create a preview of the cell content (truncate if needed)
                const contentPreview = typeof cellContent === 'string' ?
                    cellContent :
                    (Array.isArray(cellContent) ? cellContent.join('\n') : '');
                const firstLine = contentPreview.split('\n')[0] || '';
                const truncatedContent = firstLine.length > 30 ?
                    firstLine.substring(0, 30) + '...' :
                    firstLine;
                // Create cell label with styled type indicator
                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';
                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';
                // Create menu item for this cell
                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML
                'select-cell', i.toString() // Store cell index in path
                );
                // Create styled content with HTML elements
                const typeSpan = document.createElement('span');
                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;
                typeSpan.textContent = typeIndicator;
                const execSpan = document.createElement('span');
                execSpan.className = 'cell-exec-count';
                execSpan.textContent = executionDisplay;
                execSpan.style.marginRight = '8px';
                const contentSpan = document.createElement('span');
                contentSpan.className = 'cell-content-preview';
                contentSpan.textContent = truncatedContent;
                // Get the label span (first child of the menu item)
                const labelSpan = cellItem.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = ''; // Clear existing text
                    labelSpan.appendChild(typeSpan);
                    if (executionDisplay) {
                        labelSpan.appendChild(execSpan);
                    }
                    labelSpan.appendChild(contentSpan);
                }
                // Construct full searchable text
                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();
                // Filter by search term if one is provided
                if (searchTerm && !searchableText.includes(searchTerm)) {
                    continue;
                }
                this.popupMenuContainer.appendChild(cellItem);
                filteredCellCount++;
            }
            if (filteredCellCount === 0) {
                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');
                noMatchItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(noMatchItem);
            }
        }
        catch (error) {
            // Clean up loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading notebook cells:', error);
        }
    }
    createMenuItem(text, actionId, path = '', description = '') {
        const item = document.createElement('div');
        item.className = 'jp-llm-ext-popup-menu-item';
        item.dataset.actionId = actionId;
        if (path) {
            item.dataset.path = path;
        }
        item.onclick = (event) => this.handleMenuClick(event);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = text;
        item.appendChild(labelSpan);
        if (description) {
            labelSpan.style.fontWeight = 'bold';
            const descSpan = document.createElement('span');
            descSpan.textContent = description;
            descSpan.style.display = 'block';
            descSpan.style.fontSize = '0.8em';
            descSpan.style.color = 'var(--jp-ui-font-color2)';
            item.appendChild(descSpan);
        }
        return item;
    }
    async handleMenuClick(event) {
        const target = event.currentTarget;
        const actionId = target.dataset.actionId;
        const path = target.dataset.path || '';
        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);
        switch (actionId) {
            case 'navigate-back':
                this.navigateBackMenu();
                break;
            case 'insert-code': {
                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;
                if (selectedText) {
                    this.callbacks.insertCode(selectedText);
                }
                else {
                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                    if (cellContent) {
                        this.callbacks.insertCode(cellContent);
                    }
                }
                this.hidePopupMenu();
                break;
            }
            case 'browse-cells':
                await this.navigateMenu('cells', '');
                this.searchInput.value = '';
                break;
            case 'browse-files':
                await this.navigateMenu('files', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'browse-directories':
                await this.navigateMenu('directories', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'select-cell':
                if (path) {
                    const cellIndex = parseInt(path);
                    if (!isNaN(cellIndex) && this.callbacks.insertCellByIndex) {
                        this.callbacks.insertCellByIndex(cellIndex);
                        this.hidePopupMenu();
                    }
                    else {
                        console.error('POPUP: Invalid cell index or callback missing.');
                    }
                }
                break;
            case 'select-file':
                if (path) {
                    this.callbacks.insertFilePath(path);
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: File selected but path is missing.');
                }
                break;
            case 'select-directory-navigate': // New action to navigate into dir when in file view
                if (path) {
                    await this.navigateMenu('files', path); // Navigate deeper, still looking for files
                    this.searchInput.value = ''; // Clear search on navigation
                }
                else {
                    console.error('POPUP: Directory selected for navigation but path is missing.');
                }
                break;
            case 'select-directory-callback': // New action to select dir when in directory view
                if (path) {
                    this.callbacks.insertDirectoryPath(path); // Use the callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected for callback but path is missing.');
                }
                break;
            case 'placeholder-action':
                console.log('Placeholder action triggered.');
                this.hidePopupMenu();
                break;
            case 'loading':
            case 'empty':
            case 'error':
                break;
            default:
                console.warn('Unknown menu action:', actionId);
                this.hidePopupMenu();
                break;
        }
        event.stopPropagation();
    }
    async navigateMenu(level, path) {
        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);
        // Only push history if we are actually moving to a new state
        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {
            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
        }
        this.currentMenuLevel = level;
        this.currentMenuPath = path;
        // Don't clear search on programmatic navigation (like back button)
        // this.searchInput.value = ''; // Maybe keep search term?
        await this.renderMenuContent();
        // Focus search input after navigating to file/dir view
        if (level === 'files' || level === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0);
            this.selectedMenuItemIndex = -1; // Reset selection
        }
        else {
            // Select first item if navigating back to top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 0);
        }
    }
    navigateBackMenu() {
        const previousState = this.menuHistory.pop();
        if (previousState) {
            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);
            this.currentMenuLevel = previousState.level;
            this.currentMenuPath = previousState.path;
            // Don't clear search on back navigation
            this.renderMenuContent().then(() => {
                // Focus search input if going back to file/dir view
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    setTimeout(() => this.searchInput.focus(), 0);
                    this.selectedMenuItemIndex = -1; // Reset selection
                }
                else {
                    // Select first item if going back to top level
                    this.selectedMenuItemIndex = -1;
                    setTimeout(() => this.selectNextMenuItem(), 0);
                }
            });
        }
        else {
            console.log('POPUP: Already at the top level.');
            this.hidePopupMenu();
        }
    }
    async listCurrentDirectoryContents(basePath, filterType) {
        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);
        try {
            const effectivePath = basePath === '/' ? '' : basePath;
            // Ensure trailing slash removed for consistency unless it's root
            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;
            const contents = await this.docManager.services.contents.get(pathForApi || ''); // Use empty string for root
            if (contents.type === 'directory') {
                let items = contents.content.map((item) => ({
                    name: item.name,
                    path: item.path,
                    type: item.type === 'directory' ? 'directory' : 'file' // Simplify type
                }));
                // Filter only to files and directories (excluding notebooks, etc. if needed later)
                items = items.filter((item) => item.type === 'file' || item.type === 'directory');
                // Apply optional filter *if provided*
                if (filterType) {
                    items = items.filter((item) => item.type === filterType);
                }
                console.log(`POPUP: Directory items for '${basePath}':`, items);
                return items.sort((a, b) => {
                    // Sort directories first, then files, then alphabetically
                    if (a.type === 'directory' && b.type !== 'directory')
                        return -1;
                    if (a.type !== 'directory' && b.type === 'directory')
                        return 1;
                    return a.name.localeCompare(b.name);
                });
            }
            else {
                console.error('Path is not a directory:', basePath);
                return null;
            }
        }
        catch (error) {
            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);
            // Handle specific errors like 404 Not Found if needed
            return null;
        }
    }
    async setCurrentDirectoryPath() {
        var _a;
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            this.currentMenuPath = '';
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                dirPath = this.getParentDirectory(path);
                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);
            }
        }
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            if (typeof notebookPath === 'string') {
                dirPath = this.getParentDirectory(notebookPath);
                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);
            }
        }
        if (dirPath === null) {
            try {
                const leftWidgets = Array.from(app.shell.widgets('left'));
                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
                if (fileBrowserWidget && ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path)) {
                    dirPath = fileBrowserWidget.model.path;
                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);
                }
                else {
                    console.log('POPUP: File browser widget path not directly accessible.');
                }
            }
            catch (e) {
                console.warn('POPUP: Could not get path from file browser.', e);
            }
        }
        if (dirPath === null) {
            dirPath = '';
            console.log('POPUP: Falling back to server root path.');
        }
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);
    }
    getParentDirectory(path) {
        if (!path)
            return '';
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));
        if (lastSlash === -1)
            return ''; // No directory part, likely root or just a filename
        return path.substring(0, lastSlash);
    }
    /**
     * Handle keyboard navigation when the popup menu is shown
     */
    handleKeyDown(event) {
        var _a;
        // Skip if menu not visible
        if (this.popupMenuContainer.style.display === 'none') {
            return;
        }
        console.log(`POPUP KeyDown: Key='${event.key}', Target='${(_a = event.target) === null || _a === void 0 ? void 0 : _a.tagName}', SearchFocused='${document.activeElement === this.searchInput}'`);
        // Special handling for when search input is focused
        if (document.activeElement === this.searchInput) {
            // The input's own keydown handler will handle most keys
            // But for certain keys like arrow keys, we may need to move focus
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                // Move selection to first/last item
                event.preventDefault();
                event.stopPropagation();
                // Delay before moving focus - this gives time for the search input's
                // own keydown handler to process the key first
                setTimeout(() => {
                    if (event.key === 'ArrowDown') {
                        this.searchInput.blur();
                        this.selectNextMenuItem();
                    }
                    else { // ArrowUp
                        this.searchInput.blur();
                        this.selectPreviousMenuItem();
                    }
                }, 0);
                return;
            }
            // IMPORTANT: For Backspace in search input, just return without handling
            // Let the default behavior happen
            if (event.key === 'Backspace') {
                // Just perform default behavior in search input
                return;
            }
            // Let all other keys be handled by the search input's own handler
            return;
        }
        // From here, search input is NOT focused
        const menuItems = this.getMenuItems();
        switch (event.key) {
            case 'ArrowDown':
                if (menuItems.length > 0) {
                    console.log('POPUP KeyDown (Menu Focused): ArrowDown');
                    event.preventDefault();
                    event.stopPropagation();
                    this.selectNextMenuItem();
                }
                break;
            case 'ArrowUp':
                if (menuItems.length > 0) {
                    console.log('POPUP KeyDown (Menu Focused): ArrowUp');
                    event.preventDefault();
                    event.stopPropagation();
                    this.selectPreviousMenuItem();
                }
                break;
            case 'Backspace':
                console.log('POPUP KeyDown (Menu Focused): Backspace');
                // Only prevent default and navigate back if we have history
                if (this.menuHistory.length > 0) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.navigateBackMenu();
                }
                else {
                    console.log('POPUP KeyDown (Menu Focused): No history, allowing Backspace default action');
                    // Allow default - don't prevent or stop propagation
                }
                break;
            case 'Enter':
                console.log('POPUP KeyDown (Menu Focused): Enter');
                // Only activate if an item is selected
                if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {
                    event.preventDefault();
                    event.stopPropagation();
                    menuItems[this.selectedMenuItemIndex].click();
                }
                break;
            case 'Tab':
                console.log('POPUP KeyDown (Menu Focused): Tab');
                // Basic Tab support: move focus between search and first/last item
                event.preventDefault();
                event.stopPropagation();
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    this.searchInput.focus();
                    this.deselectAllMenuItems(); // Deselect items when search gets focus via Tab
                }
                else {
                    // Maybe close menu on Tab from top level? Or do nothing.
                    this.hidePopupMenu();
                }
                break;
            case 'Escape':
                console.log('POPUP KeyDown (Menu Focused): Escape');
                event.preventDefault();
                event.stopPropagation();
                this.hidePopupMenu();
                break;
            default:
                console.log(`POPUP KeyDown (Menu Focused): Default key '${event.key}'`);
                // If typing a character and in file/dir view, focus search
                if ((this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') &&
                    event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault(); // Prevent character appearing elsewhere
                    event.stopPropagation();
                    this.searchInput.focus();
                    // Manually append the typed character as focus happens after keydown default action
                    this.searchInput.value += event.key;
                    // Trigger input event manually to update list
                    this.searchInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
                // Allow other keys (e.g., modifiers) to pass through if not handled
                break;
        }
    }
    updateSelectionHighlight() {
        const menuItems = this.getMenuItems();
        console.log(`POPUP updateSelectionHighlight: Highlighting index ${this.selectedMenuItemIndex} among ${menuItems.length} items.`);
        menuItems.forEach((item, index) => {
            if (index === this.selectedMenuItemIndex) {
                if (!item.classList.contains('selected')) {
                    item.classList.add('selected');
                    console.log(`POPUP updateSelectionHighlight: Added 'selected' to item ${index}`);
                    // Ensure item is visible
                    item.scrollIntoView({ block: 'nearest' });
                }
            }
            else {
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    console.log(`POPUP updateSelectionHighlight: Removed 'selected' from item ${index}`);
                }
            }
        });
    }
    deselectAllMenuItems() {
        const menuItems = this.getMenuItems();
        menuItems.forEach(item => item.classList.remove('selected'));
        this.selectedMenuItemIndex = -1;
    }
    selectNextMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectNext: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the next item or loop back to the first
        this.selectedMenuItemIndex = (this.selectedMenuItemIndex + 1) % menuItems.length;
        console.log(`POPUP selectNext: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    selectPreviousMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectPrevious: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the previous item or loop to the last
        this.selectedMenuItemIndex = this.selectedMenuItemIndex <= 0 ?
            menuItems.length - 1 : this.selectedMenuItemIndex - 1;
        console.log(`POPUP selectPrevious: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    /**
     * Get all interactive menu items
     */
    getMenuItems() {
        const items = Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));
        // Filter out non-interactive items like loading, empty, error
        return items.filter(item => {
            const actionId = item.dataset.actionId;
            return actionId !== 'loading' && actionId !== 'empty' && actionId !== 'error';
        });
    }
    /**
     * Update popup position, keeping the bottom edge fixed at the anchor point
     */
    updatePopupPosition() {
        var _a, _b;
        // Make sure anchor points are defined
        const anchorX = (_a = this._anchorX) !== null && _a !== void 0 ? _a : 0;
        const anchorY = (_b = this._anchorY) !== null && _b !== void 0 ? _b : 0;
        // Position the popup menu
        this.popupMenuContainer.style.position = 'absolute';
        this.popupMenuContainer.style.left = `${anchorX}px`;
        // Show the menu so we can calculate its height
        this.popupMenuContainer.style.display = 'block';
        // Get the actual height after rendering
        const menuHeight = this.popupMenuContainer.offsetHeight;
        // Add a small gap (10px) between the bottom of the menu and the trigger point
        const gap = 10;
        // Position above the cursor/button to keep bottom edge at the anchor point:
        // y - gap = bottom edge of popup, so popup top = y - gap - menuHeight
        this.popupMenuContainer.style.top = `${anchorY - gap - menuHeight}px`;
        console.log(`POPUP: Positioned menu at height ${menuHeight}px with bottom at ${anchorY - gap}px`);
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
const markdown_config_1 = __webpack_require__(/*! ./markdown-config */ "./node_modules/jupyter-simple-extension/lib/markdown-config.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js");
// Configure marked with our settings
(0, markdown_config_1.configureMarked)();
/**
 * Main sidebar widget for the AI chat interface
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    constructor(docManager) {
        super();
        this.isMarkdownMode = false;
        this.isInputExpanded = false;
        this.chatHistory = [];
        this.currentChatId = '';
        this.isHistoryViewActive = false;
        this.hasAtSymbol = false; // Track whether @ symbol is present in input
        /**
         * Handles keyboard shortcuts
         */
        this.handleKeyDown = (event) => {
            var _a, _b;
            // Check for @ key (for context menu) - changed from Ctrl+@
            if (event.key === '@') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Only show menu if input field is focused
                if (document.activeElement === this.inputField) {
                    // Get cursor position in input field
                    const cursorPosition = this.inputField.selectionStart || 0;
                    const textBeforeCursor = this.inputField.value.substring(0, cursorPosition);
                    // Calculate position to show menu
                    const inputRect = this.inputField.getBoundingClientRect();
                    const lineHeight = parseInt(window.getComputedStyle(this.inputField).lineHeight) || 20;
                    // Count newlines before cursor to determine vertical position
                    const linesBeforeCursor = (textBeforeCursor.match(/\n/g) || []).length;
                    // Calculate cursor position within current line
                    const lastNewline = textBeforeCursor.lastIndexOf('\n');
                    const charsInCurrentLine = lastNewline === -1 ? cursorPosition : cursorPosition - lastNewline - 1;
                    // Estimate horizontal position (using average character width)
                    const charWidth = 8; // Approximate width of a character in pixels
                    const horizontalOffset = charsInCurrentLine * charWidth;
                    // Calculate positions
                    const left = inputRect.left + horizontalOffset;
                    // Calculate the cursor's vertical position
                    const cursorTop = inputRect.top + (linesBeforeCursor * lineHeight);
                    console.log(`Showing popup at cursor position: (${left}, ${cursorTop})`);
                    // Insert @ symbol at cursor position
                    const newValue = this.inputField.value.substring(0, cursorPosition) +
                        '@' +
                        this.inputField.value.substring(cursorPosition);
                    this.inputField.value = newValue;
                    // Update has @ symbol flag
                    this.hasAtSymbol = true;
                    // Move cursor after the @ symbol
                    this.inputField.selectionStart = cursorPosition + 1;
                    this.inputField.selectionEnd = cursorPosition + 1;
                    // Show the popup menu above the cursor position
                    this.popupMenuManager.showPopupMenu(left + 60, cursorTop - 20);
                    this.showKeyboardShortcutIndicator('Browse cells, code, files, and more');
                }
            }
            // Check for Ctrl+L (for selected code)
            else if (event.ctrlKey && event.key.toLowerCase() === 'l') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Get the current active cell
                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
                if (!cell || !cell.editor) {
                    return;
                }
                try {
                    // Get the CodeMirror editor instance
                    const editor = cell.editor;
                    const view = editor.editor;
                    if (!view) {
                        return;
                    }
                    // Check if there's a selection
                    const state = view.state;
                    const selection = state.selection;
                    if (!selection.main.empty) {
                        // If there's a selection, use @code
                        const from = selection.main.from;
                        const to = selection.main.to;
                        const selectedText = state.doc.sliceString(from, to);
                        this.appendToInput(`@code ${selectedText}`);
                        this.showKeyboardShortcutIndicator('Selected code inserted');
                    }
                    else {
                        // If no selection, use @cell
                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();
                        if (cellContext) {
                            this.appendToInput(`@cell ${cellContext.text}`);
                            this.showKeyboardShortcutIndicator('Cell content inserted');
                        }
                    }
                    // Ensure the sidebar is visible and focused
                    if (this.isHidden) {
                        this.show();
                    }
                    this.inputField.focus();
                }
                catch (error) {
                    console.error('Error handling keyboard shortcut:', error);
                }
            }
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        // Add the main CSS class for styling
        this.addClass('jp-llm-ext-sidebar');
        // Initialize API client
        this.apiClient = new api_client_1.ApiClient();
        // Initialize container elements before creating layout
        this.messageContainer = document.createElement('div');
        this.inputField = document.createElement('textarea');
        this.titleInput = document.createElement('input');
        this.historyContainer = document.createElement('div');
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'jp-llm-ext-keyboard-shortcut-indicator';
        this.node.appendChild(this.keyboardShortcutIndicator);
        // Create settings modal
        this.settingsModalContainer = this.createSettingsModal();
        this.node.appendChild(this.settingsModalContainer);
        // Instantiate the PopupMenuManager with callbacks
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {
            insertCode: (code) => this.appendToInput(`code ${code}`),
            insertCell: (content) => this.appendToInput(`cell ${content}`),
            insertFilePath: (path) => this.appendToInput(`file ${path}`),
            insertDirectoryPath: (path) => this.appendToInput(`directory ${path}`), // If needed
            getSelectedText: () => this.getSelectedText(),
            getCurrentCellContent: () => this.getCurrentCellContent(),
            insertCellByIndex: (index) => this.insertCellByIndex(index)
        });
        // Create a new chat on start
        this.createNewChat();
        this.node.appendChild(this.createLayout());
        // Pop-up menu will be attached to document.body when shown
        // Add keyboard shortcut listener
        document.addEventListener('keydown', this.handleKeyDown);
    }
    /**
     * Shows a visual indicator for keyboard shortcuts
     */
    showKeyboardShortcutIndicator(text) {
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Hide after 1 second
        setTimeout(() => {
            this.keyboardShortcutIndicator.classList.remove('visible');
        }, 1000);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        // Remove keyboard shortcut listener
        document.removeEventListener('keydown', this.handleKeyDown);
        // Remove keyboard shortcut indicator
        if (this.keyboardShortcutIndicator.parentNode) {
            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);
        }
        // Dispose the popup menu manager
        if (this.popupMenuManager) {
            this.popupMenuManager.dispose();
        }
        super.dispose();
    }
    /**
     * Creates the main layout for the sidebar
     */
    createLayout() {
        // Create the main container
        const mainContent = document.createElement('div');
        // The main class 'jp-llm-ext-sidebar' is added to this.node in the constructor
        // This container can have its own class if needed for further nesting/styling
        mainContent.className = 'jp-llm-ext-content-wrapper';
        // Create title input container
        const titleContainer = document.createElement('div');
        titleContainer.className = 'jp-llm-ext-title-container';
        // Set up title input
        this.titleInput.className = 'chat-title-input'; // Assuming this is styled correctly in CSS
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat';
        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());
        titleContainer.appendChild(this.titleInput);
        // Create New Chat & History buttons
        const newChatButton = document.createElement('button');
        newChatButton.className = 'jp-Button jp-llm-ext-action-button';
        newChatButton.textContent = '+ New Chat';
        newChatButton.title = 'Start a new chat';
        newChatButton.addEventListener('click', () => this.createNewChat());
        const historyButton = document.createElement('button');
        historyButton.className = 'jp-Button jp-llm-ext-action-button';
        historyButton.textContent = 'History';
        historyButton.title = 'View chat history';
        historyButton.addEventListener('click', () => this.toggleHistoryView());
        // Configure message container
        this.messageContainer.className = 'jp-llm-ext-message-container';
        // Configure history container
        this.historyContainer.className = 'jp-llm-ext-history-container';
        this.historyContainer.style.display = 'none';
        // Configure input field (directly used later)
        this.inputField.placeholder = 'Ask me anything...';
        this.inputField.rows = 1;
        this.inputField.className = 'jp-llm-ext-input-field'; // Add class for styling
        // Add keypress listener to input field
        this.inputField.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.handleSendMessage();
            }
        });
        // Add input event listener to detect changes to the input field
        this.inputField.addEventListener('input', () => {
            // Check if the @ symbol has been removed
            const cursorPosition = this.inputField.selectionStart;
            const textBeforeCursor = this.inputField.value.slice(0, cursorPosition);
            const hasAtNow = textBeforeCursor.endsWith('@') &&
                (cursorPosition === 1 || // @ is at start of input
                    !!textBeforeCursor[cursorPosition - 2].match(/\s/)); // @ follows whitespace
            if (this.hasAtSymbol && !hasAtNow) {
                // @ symbol was present but now it's gone, hide the popup
                this.popupMenuManager.hidePopupMenu();
            }
            this.hasAtSymbol = hasAtNow;
        });
        // Create send button container (directly used later)
        const inputActionsContainer = document.createElement('div');
        inputActionsContainer.className = 'jp-llm-ext-input-actions-container';
        // Create send button
        const sendButton = document.createElement('button');
        sendButton.className = 'jp-Button jp-llm-ext-send-button';
        sendButton.textContent = 'Send';
        sendButton.addEventListener('click', () => this.handleSendMessage());
        inputActionsContainer.appendChild(sendButton);
        // Create controls container (Markdown toggle, @, etc.) (directly used later)
        const controlsContainer = this.createControlsContainer();
        // Create the new bottom bar container with three rows
        const bottomBarContainer = document.createElement('div');
        bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';
        this.bottomBarContainer = bottomBarContainer;
        // First row: Controls (Markdown toggle and action buttons)
        const topRow = document.createElement('div');
        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';
        topRow.appendChild(controlsContainer);
        // Second row: Input field
        const middleRow = document.createElement('div');
        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';
        middleRow.appendChild(this.inputField);
        // Third row: Action buttons (Send, New Chat, History)
        const bottomRow = document.createElement('div');
        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';
        // Add all buttons to bottom row
        bottomRow.appendChild(sendButton);
        bottomRow.appendChild(newChatButton);
        bottomRow.appendChild(historyButton);
        // Add all rows to the bottom bar container
        bottomBarContainer.appendChild(topRow);
        bottomBarContainer.appendChild(middleRow);
        bottomBarContainer.appendChild(bottomRow);
        // Assemble all main components
        mainContent.appendChild(titleContainer);
        mainContent.appendChild(this.messageContainer);
        mainContent.appendChild(this.historyContainer);
        mainContent.appendChild(bottomBarContainer);
        return mainContent;
    }
    /**
     * Creates a new chat session
     */
    createNewChat() {
        // Generate a unique ID for the chat
        const chatId = `chat-${Date.now()}`;
        // Create a new chat item
        const newChat = {
            id: chatId,
            title: 'New Chat',
            messages: []
        };
        // Add to history
        this.chatHistory.push(newChat);
        // Set as current chat
        this.currentChatId = chatId;
        // Update title input
        this.titleInput.value = newChat.title;
        // Clear message container
        if (this.messageContainer) {
            this.messageContainer.innerHTML = '';
        }
        // Hide history if it's visible
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Toggles between chat view and history view
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Show history view, hide message view and bottom bar
            this.messageContainer.style.display = 'none';
            this.historyContainer.style.display = 'block';
            this.bottomBarContainer.style.display = 'none'; // Use class property directly
            this.titleInput.style.display = 'none';
            // Populate history
            this.renderChatHistory();
        }
        else {
            // Show message view and bottom bar, hide history view
            this.messageContainer.style.display = 'block';
            this.historyContainer.style.display = 'none';
            this.bottomBarContainer.style.display = 'flex'; // Use class property directly
            this.titleInput.style.display = 'block';
        }
    }
    /**
     * Renders the chat history in the history container
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = '';
        if (this.chatHistory.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'jp-llm-ext-empty-history-message';
            emptyMessage.textContent = 'No chat history yet';
            this.historyContainer.appendChild(emptyMessage);
            return;
        }
        // Create a list of chat history items
        this.chatHistory.forEach(chat => {
            const historyItem = document.createElement('div');
            historyItem.className = 'jp-llm-ext-history-item';
            if (chat.id === this.currentChatId) {
                historyItem.classList.add('jp-llm-ext-active');
            }
            // Add title
            const title = document.createElement('div');
            title.className = 'jp-llm-ext-history-title';
            title.textContent = chat.title;
            // Add message preview
            const preview = document.createElement('div');
            preview.className = 'jp-llm-ext-history-preview';
            const lastMessage = chat.messages[chat.messages.length - 1];
            preview.textContent = lastMessage
                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`
                : 'Empty chat';
            // Add click event
            historyItem.addEventListener('click', () => this.loadChat(chat.id));
            historyItem.appendChild(title);
            historyItem.appendChild(preview);
            this.historyContainer.appendChild(historyItem);
        });
    }
    /**
     * Loads a chat from history
     */
    loadChat(chatId) {
        const chat = this.chatHistory.find(c => c.id === chatId);
        if (!chat)
            return;
        // Set as current chat
        this.currentChatId = chatId;
        // Update title
        this.titleInput.value = chat.title;
        // Clear and re-populate message container
        this.messageContainer.innerHTML = '';
        chat.messages.forEach(msg => {
            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);
        });
        // Switch back to chat view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Updates the title of the current chat
     */
    updateCurrentChatTitle() {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            chat.title = this.titleInput.value;
        }
    }
    /**
     * Creates the controls container with toggles and action buttons
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'jp-llm-ext-controls-container';
        // Create markdown toggle container
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'jp-llm-ext-toggle-container';
        // Create markdown toggle
        const markdownToggle = document.createElement('input');
        markdownToggle.type = 'checkbox';
        markdownToggle.id = 'markdown-toggle';
        // markdownToggle.style.marginRight = '5px'; // Style via CSS
        markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            this.inputField.placeholder = this.isMarkdownMode ?
                'Write markdown here...\n\n# Example heading\n- List item\n\n```code block```' :
                'Ask me anything...';
        });
        // Create toggle label
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        // toggleLabel.style.fontSize = '12px'; // Style via CSS
        // Add toggle elements to container
        toggleContainer.appendChild(markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // Create action buttons container (@, expand, settings)
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';
        // Create all action buttons
        const buttons = [
            {
                text: '@',
                title: 'Browse cells, code, files, and more',
                action: (event) => {
                    // Get the button's position
                    const targetButton = event.currentTarget;
                    const rect = targetButton.getBoundingClientRect();
                    // Show the popup menu above the button's top edge
                    this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);
                    event.preventDefault();
                    event.stopPropagation();
                }
            },
            { text: '⤢', title: 'Expand input', action: () => this.toggleInputExpansion(actionButtonsContainer.children[3]) },
            { text: '⚙️', title: 'Settings', action: (event) => { event.preventDefault(); event.stopPropagation(); this.showSettingsModal(); } },
        ];
        // Add all buttons to the container
        buttons.forEach(button => {
            const btn = this.createButton(button.text, button.title);
            btn.addEventListener('click', (e) => button.action(e));
            actionButtonsContainer.appendChild(btn);
        });
        // Add toggle and action buttons to the controls container
        // controlsContainer is now just for these inline controls, above the input field
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field
     */
    toggleInputExpansion(button) {
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            // Adjust height based on a class or CSS variable instead of fixed pixels if possible
            this.inputField.style.height = '200px';
            this.inputField.style.resize = 'vertical';
            button.textContent = '⤡';
            button.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = ''; // Reset height
            this.inputField.style.resize = 'none';
            this.inputField.rows = 1; // Ensure it collapses back to 1 row height
            button.textContent = '⤢';
            button.title = 'Expand input';
        }
    }
    /**
     * Helper function to create a button with given text and tooltip
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        button.className = 'jp-Button jp-llm-ext-action-button';
        return button;
    }
    /**
     * Handles sending a message from the input field
     */
    handleSendMessage() {
        const message = this.inputField.value.trim();
        if (message) {
            // Add user message to UI
            this.addMessage(message, 'user', this.isMarkdownMode);
            this.inputField.value = '';
            this.inputField.rows = 1; // Reset rows after sending
            this.inputField.style.height = ''; // Reset height after sending
            // Reset expanded state if needed after sending
            if (this.isInputExpanded) {
                // Find the expand button to reset its state if needed (this might need adjustment based on final structure)
                const expandButton = this.node.querySelector('.jp-llm-ext-action-buttons-container button[title*="Collapse"]');
                if (expandButton) {
                    this.toggleInputExpansion(expandButton); // Collapse after sending
                }
                else {
                    this.inputField.style.height = ''; // Fallback reset
                    this.inputField.rows = 1;
                }
            }
            // Create a temporary message container for the bot's streaming response
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'jp-llm-ext-bot-message';
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            botMessageDiv.appendChild(markdownIndicator);
            // Create separate divs for streaming text and final markdown
            const streamingDiv = document.createElement('div');
            streamingDiv.className = 'streaming-content';
            streamingDiv.style.whiteSpace = 'pre-wrap';
            streamingDiv.style.fontFamily = 'monospace';
            streamingDiv.style.fontSize = '0.9em';
            botMessageDiv.appendChild(streamingDiv);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            contentDiv.style.display = 'none'; // Initially hidden
            botMessageDiv.appendChild(contentDiv);
            this.messageContainer.appendChild(botMessageDiv);
            // Variable to collect the complete response
            let completeResponse = '';
            // Get cell context if available
            const cellContext = globals_1.globals.cellContextTracker ?
                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;
            // Stream response from API
            this.apiClient.streamChat(message, { cellContext }, 
            // On each chunk received
            (chunk) => {
                completeResponse += chunk;
                streamingDiv.textContent = completeResponse;
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On complete
            () => {
                // Hide streaming div, show markdown div
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                // Pre-process and render markdown
                try {
                    // Pre-process the markdown to fix any issues with code blocks
                    const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
                    // Parse and sanitize
                    const rawHtml = marked_1.marked.parse(processedMarkdown);
                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                    // Apply the HTML with proper code block styling
                    contentDiv.innerHTML = sanitizedHtml;
                    // Add syntax highlighting classes to code blocks
                    const codeBlocks = contentDiv.querySelectorAll('pre code');
                    codeBlocks.forEach(block => {
                        var _a;
                        block.classList.add('jp-RenderedText');
                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                    });
                    // Add action buttons to the bot message
                    console.log('Adding action buttons to streamed bot message');
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'jp-llm-ext-message-actions';
                    actionsDiv.style.display = 'flex'; // Ensure display is set
                    // Copy button with icon
                    const copyButton = document.createElement('button');
                    copyButton.className = 'jp-llm-ext-message-action-button';
                    copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    copyButton.title = 'Copy message to clipboard';
                    copyButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.copyMessageToClipboard(completeResponse);
                    });
                    actionsDiv.appendChild(copyButton);
                    // Add to button with icon
                    const addToButton = document.createElement('button');
                    addToButton.className = 'jp-llm-ext-message-action-button';
                    addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                    addToButton.title = 'Add message to current cell';
                    addToButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.addMessageToCell(completeResponse);
                    });
                    actionsDiv.appendChild(addToButton);
                    // Add buttons to message
                    botMessageDiv.appendChild(actionsDiv);
                    console.log('Action buttons added to bot message:', actionsDiv);
                }
                catch (error) {
                    contentDiv.textContent = completeResponse;
                    console.error('Failed to render markdown:', error);
                }
                // Save to chat history
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages.push({
                        text: completeResponse,
                        sender: 'bot',
                        isMarkdown: true
                    });
                }
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On error
            (error) => {
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                contentDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                console.error('API Error:', error);
            });
        }
    }
    /**
     * Adds a message to the chat interface
     */
    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {
        console.log('Adding message:', { sender, isMarkdown }); // Debug log
        const messageDiv = document.createElement('div');
        messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';
        // Add message content
        if (isMarkdown || sender === 'bot') {
            // Bot messages are always rendered as markdown
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            messageDiv.appendChild(markdownIndicator);
            // Create a container for the rendered markdown
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            try {
                // Pre-process the markdown text
                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
                // Parse and render markdown
                const rawHtml = marked_1.marked.parse(processedText);
                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                contentDiv.innerHTML = sanitizedHtml;
                // Add syntax highlighting classes to code blocks
                const codeBlocks = contentDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    var _a;
                    block.classList.add('jp-RenderedText');
                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                });
            }
            catch (error) {
                contentDiv.textContent = text;
                console.error('Failed to render markdown:', error);
            }
            messageDiv.appendChild(contentDiv);
            // Add action buttons for bot messages
            if (sender === 'bot') {
                console.log('Adding action buttons to bot message'); // Debug log
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'jp-llm-ext-message-actions';
                // Copy button with icon
                const copyButton = document.createElement('button');
                copyButton.className = 'jp-llm-ext-message-action-button';
                copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                copyButton.title = 'Copy message to clipboard';
                copyButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.copyMessageToClipboard(text);
                });
                actionsDiv.appendChild(copyButton);
                // Add to button with icon
                const addToButton = document.createElement('button');
                addToButton.className = 'jp-llm-ext-message-action-button';
                addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                addToButton.title = 'Add message to current cell';
                addToButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.addMessageToCell(text);
                });
                actionsDiv.appendChild(addToButton);
                // Add buttons to message
                messageDiv.appendChild(actionsDiv);
                console.log('Action buttons added to message:', actionsDiv); // Debug log
            }
        }
        else {
            messageDiv.textContent = text;
        }
        this.messageContainer.appendChild(messageDiv);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        // Save to chat history
        if (saveToHistory) {
            const chat = this.chatHistory.find(c => c.id === this.currentChatId);
            if (chat) {
                chat.messages.push({
                    text,
                    sender,
                    isMarkdown: isMarkdown || sender === 'bot'
                });
            }
        }
    }
    /**
     * Copies message content to clipboard
     */
    copyMessageToClipboard(text) {
        try {
            navigator.clipboard.writeText(text).then(() => {
                console.log('Content copied to clipboard');
                // Find the button element that was clicked
                const buttons = document.querySelectorAll('.jp-llm-ext-message-action-button');
                let clickedButton = null;
                for (let i = 0; i < buttons.length; i++) {
                    const button = buttons[i];
                    if (button.title === 'Copy message to clipboard' && button === document.activeElement) {
                        clickedButton = button;
                        break;
                    }
                }
                // Show visual feedback if we found the button
                if (clickedButton) {
                    const originalHTML = clickedButton.innerHTML;
                    clickedButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                    setTimeout(() => {
                        clickedButton.innerHTML = originalHTML;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        catch (error) {
            console.error('Error copying to clipboard:', error);
        }
    }
    /**
     * Adds message content to the current cell
     */
    addMessageToCell(text) {
        var _a;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell || !cell.editor) {
            return;
        }
        try {
            const editor = cell.editor;
            const view = editor.editor;
            if (!view) {
                return;
            }
            // Get current cursor position
            const state = view.state;
            const selection = state.selection;
            const cursorPos = selection.main.head;
            // Insert newline and message content at cursor position
            const transaction = state.update({
                changes: {
                    from: cursorPos,
                    insert: `\n${text}`
                },
                selection: { anchor: cursorPos + text.length + 1 }
            });
            view.dispatch(transaction);
        }
        catch (error) {
            console.error('Error adding message to cell:', error);
        }
    }
    /**
     * Gets the currently selected text from the active notebook cell.
     * (Helper for PopupMenuManager callback)
     */
    getSelectedText() {
        var _a, _b, _c;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (cell === null || cell === void 0 ? void 0 : cell.editor) {
            const editor = cell.editor; // IEditor
            // Access CodeMirror editor instance if possible
            const cmEditor = editor.editor;
            if (cmEditor && cmEditor.state) {
                const state = cmEditor.state;
                const selection = state.selection.main; // Get the main selection
                if (selection.empty) {
                    return null; // No text selected
                }
                return state.doc.sliceString(selection.from, selection.to);
            }
            console.warn("Could not access CodeMirror state to get selection.");
            // Avoid using getRange as it's confirmed not to exist on IEditor
            return null;
        }
        else {
            // Attempt to get selection from document if no notebook active (e.g., text editor)
            const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
            if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {
                const editor = activeWidget.content.editor;
                const cmEditor = editor.editor;
                if (cmEditor && cmEditor.state) {
                    const state = cmEditor.state;
                    const selection = state.selection.main;
                    if (selection.empty) {
                        return null;
                    }
                    return state.doc.sliceString(selection.from, selection.to);
                }
                console.warn("Could not access CodeMirror state for non-notebook editor selection.");
                return null; // Avoid getRange
            }
        }
        return null;
    }
    /**
     * Gets the content of the currently active notebook cell.
     * (Helper for PopupMenuManager callback)
     */
    getCurrentCellContent() {
        var _a, _b, _c;
        const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {
            // Try using sharedModel first (more robust)
            if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {
                return activeCell.model.sharedModel.getSource();
            }
            // Fallback: Try using toJSON().source
            const cellJson = activeCell.model.toJSON();
            if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {
                return cellJson.source;
            }
            else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {
                // If source is an array of strings, join them
                return cellJson.source.join('\n');
            }
            console.warn("Could not get cell content via model.value.text or toJSON().source");
            return null;
        }
        // Fallback for non-notebook editors if needed
        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
        if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {
            return activeWidget.content.model.value.text;
        }
        return null;
    }
    /**
     * Appends text to the input field with proper spacing
     */
    appendToInput(text) {
        try {
            const currentValue = this.inputField.value;
            if (currentValue) {
                // add a space between the current value and the new text
                this.inputField.value = `${currentValue}${text}`;
            }
            else {
                this.inputField.value = text;
            }
            // Focus the input field and move cursor to end
            this.inputField.focus();
            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    // Settings modal methods
    createSettingsModal() {
        const modal = document.createElement('div');
        modal.className = 'jp-llm-ext-settings-modal';
        modal.style.display = 'none'; // Keep this inline style for toggling visibility
        const content = document.createElement('div');
        content.className = 'jp-llm-ext-settings-content';
        const title = document.createElement('h2');
        title.className = 'jp-llm-ext-settings-title';
        title.textContent = 'Settings';
        content.appendChild(title);
        const form = document.createElement('form');
        form.className = 'jp-llm-ext-settings-form';
        // Provider selection
        const providerLabel = document.createElement('label');
        providerLabel.className = 'jp-llm-ext-settings-label';
        providerLabel.textContent = 'API Provider:';
        form.appendChild(providerLabel);
        const providerSelect = document.createElement('select');
        providerSelect.className = 'jp-llm-ext-settings-select';
        providerSelect.id = 'settings-provider';
        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            providerSelect.appendChild(option);
        });
        form.appendChild(providerSelect);
        // API Key input
        const apiKeyLabel = document.createElement('label');
        apiKeyLabel.className = 'jp-llm-ext-settings-label';
        apiKeyLabel.textContent = 'API Key:';
        form.appendChild(apiKeyLabel);
        const apiKeyInput = document.createElement('input');
        apiKeyInput.className = 'jp-llm-ext-settings-input';
        apiKeyInput.type = 'password';
        apiKeyInput.id = 'settings-api-key';
        form.appendChild(apiKeyInput);
        // API URL input
        const apiUrlLabel = document.createElement('label');
        apiUrlLabel.className = 'jp-llm-ext-settings-label';
        apiUrlLabel.textContent = 'API URL (optional):';
        form.appendChild(apiUrlLabel);
        const apiUrlInput = document.createElement('input');
        apiUrlInput.className = 'jp-llm-ext-settings-input';
        apiUrlInput.type = 'text';
        apiUrlInput.id = 'settings-api-url';
        form.appendChild(apiUrlInput);
        // Rules input
        const rulesLabel = document.createElement('label');
        rulesLabel.className = 'jp-llm-ext-settings-label';
        rulesLabel.textContent = 'Custom Rules (optional):';
        form.appendChild(rulesLabel);
        const rulesInput = document.createElement('textarea');
        rulesInput.className = 'jp-llm-ext-settings-textarea';
        rulesInput.id = 'settings-rules';
        form.appendChild(rulesInput);
        // Buttons container
        const btnContainer = document.createElement('div');
        btnContainer.className = 'jp-llm-ext-settings-buttons';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Add this line
            const provider = document.getElementById('settings-provider').value;
            const key = document.getElementById('settings-api-key').value;
            const url = document.getElementById('settings-api-url').value;
            const rules = document.getElementById('settings-rules').value;
            // Save settings to localStorage for persistence
            const settings = { provider, key, url, rules };
            localStorage.setItem('jp-llm-ext-settings', JSON.stringify(settings));
            console.log('Settings saved:', settings);
            this.hideSettingsModal();
            this.popSaveSuccess();
            // Update API client with new settings if needed
            if (url) {
                this.apiClient = new api_client_1.ApiClient(url);
            }
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Add this line
            this.hideSettingsModal();
        });
        btnContainer.appendChild(saveBtn);
        btnContainer.appendChild(cancelBtn);
        form.appendChild(btnContainer);
        content.appendChild(form);
        modal.appendChild(content);
        return modal;
    }
    showSettingsModal() {
        // Load saved settings from localStorage
        this.loadSavedSettings();
        this.settingsModalContainer.style.display = 'flex';
    }
    loadSavedSettings() {
        const savedSettings = localStorage.getItem('jp-llm-ext-settings');
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                // Update UI with saved settings
                if (settings.provider) {
                    document.getElementById('settings-provider').value = settings.provider;
                }
                if (settings.key) {
                    document.getElementById('settings-api-key').value = settings.key;
                }
                if (settings.url) {
                    document.getElementById('settings-api-url').value = settings.url;
                }
                if (settings.rules) {
                    document.getElementById('settings-rules').value = settings.rules;
                }
            }
            catch (error) {
                console.error('Error loading saved settings:', error);
            }
        }
    }
    hideSettingsModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    popSaveSuccess() {
        // Create a toast notification container
        const toast = document.createElement('div');
        toast.className = 'jp-llm-ext-toast-notification jp-llm-ext-settings-success';
        toast.textContent = 'Settings saved successfully';
        // Add to the main widget (not the modal which is hidden)
        this.node.appendChild(toast);
        // Animate in
        setTimeout(() => {
            toast.classList.add('visible');
        }, 10);
        // Remove after delay
        setTimeout(() => {
            toast.classList.remove('visible');
            // Wait for fade out animation to complete before removing
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    /**
     * Gets cell content by index from the current notebook and inserts it into the input field
     */
    insertCellByIndex(index) {
        try {
            if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {
                console.error('No active notebook found');
                return;
            }
            const notebookPanel = globals_1.globals.notebookTracker.currentWidget;
            const model = notebookPanel.content.model;
            if (!model || !model.cells || index >= model.cells.length) {
                console.error(`Invalid cell index: ${index}`);
                return;
            }
            const cell = model.cells.get(index);
            let cellContent = '';
            // Get cell content - handle different ways content might be stored
            if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {
                cellContent = cell.sharedModel.getSource();
            }
            else {
                const cellJson = cell.toJSON();
                if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {
                    cellContent = cellJson.source;
                }
                else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {
                    cellContent = cellJson.source.join('\n');
                }
            }
            // Insert cell reference with content, without type indicator or execution count
            this.appendToInput(`cell ${cellContent}`);
        }
        catch (error) {
            console.error('Error inserting cell by index:', error);
        }
    }
}
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy5lNTBkYTdjZTQ1Y2I2NTcyZDAxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7OztBQ3JFSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsS0FBSztBQUNsRSxnRUFBZ0UsUUFBUTtBQUN4RSxpRUFBaUUsS0FBSztBQUN0RSwyRUFBMkUsS0FBSztBQUNoRjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtDQUFrQyxFQUFFLDBDQUEwQztBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYSxFQUFFLEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvYXBpLWNsaWVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jZWxsLWNvbnRleHQtdHJhY2tlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9nbG9iYWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2ljb25zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL21hcmtkb3duLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9wb3B1cC1tZW51LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvc2lkZWJhci13aWRnZXQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbi8qKlxuICogQVBJIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZCBMTE0gc2VydmljZVxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJykge1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYSBjaGF0IHJlc3BvbnNlIGZyb20gdGhlIG1vY2sgTExNXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIHVzZXIgbWVzc2FnZSB0byBzZW5kXG4gICAgICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBvbkNodW5rIENhbGxiYWNrIGZvciBlYWNoIHRleHQgY2h1bmsgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gb25Db21wbGV0ZSBDYWxsYmFjayB3aGVuIHN0cmVhbWluZyBpcyBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSBvbkVycm9yIENhbGxiYWNrIGZvciBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW1DaGF0KG1lc3NhZ2UsIGNvbnRleHQgPSBudWxsLCBvbkNodW5rLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vY2hhdGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhZGFibGVTdHJlYW0gbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdXAgc3RyZWFtIHJlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZTogcmVhZGVyRG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBkb25lID0gcmVhZGVyRG9uZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06ICFkb25lIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGhlYWx0aCBjaGVjayBmb3IgdGhlIEFQSVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIEFQSSBpcyBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vaGVhbHRoYCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFwaUNsaWVudCA9IEFwaUNsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSB2b2lkIDA7XG4vKipcbiAqIFRyYWNrcyBjZWxsIGNvbnRleHQgYW5kIGN1cnNvciBwb3NpdGlvbiB3aXRoaW4gSnVweXRlciBub3RlYm9va3NcbiAqL1xuY2xhc3MgQ2VsbENvbnRleHRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGVkaXRvciBldmVudHMgKGtleWRvd24sIG1vdXNldXApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUVkaXRvckV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbCBmcm9tIHRoZSB0cmFja2VyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGlubmVyIEVkaXRvclZpZXcgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYW5kIHN0b3JlIHRoZSBjdXJzb3IgY29udGV4dFxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gdGhpcy5nZXRDbUNvbnRleHQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZWRpdG9yIGV2ZW50IGhhbmRsZXI6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG4gICAgICAgIHRoaXMuc2V0dXBUcmFja2VycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGhhcyBiZWVuIGRpc3Bvc2VkXG4gICAgICovXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IHRyYWNrZXJzXG4gICAgICovXG4gICAgc2V0dXBUcmFja2VycygpIHtcbiAgICAgICAgLy8gSGFuZGxlIGFjdGl2ZSBjZWxsIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIC8vIEhhbmRsZSBub3RlYm9vayBjaGFuZ2VzXG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmNvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAqL1xuICAgIGhhbmRsZU5vdGVib29rQ2hhbmdlKHRyYWNrZXIsIHBhbmVsKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmIChwYW5lbCAmJiBwYW5lbC5jb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gcGFuZWwuY29udGVudC5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENlbGxMaXN0ZW5lcnModHJhY2tlciwgY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgc2V0dXBDZWxsTGlzdGVuZXJzKF90cmFja2VyLCBjZWxsKSB7XG4gICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKGNlbGwuZWRpdG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxOb2RlID0gY2VsbC5ub2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvck5vZGUgPSBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtRWRpdG9yJykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUucXVlcnlTZWxlY3RvcignLmpwLUlucHV0QXJlYS1lZGl0b3InKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gZWRpdG9yTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyBmb3Iga2V5IGFuZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY2FwdHVyZSBpbW1lZGlhdGUgY29udGV4dCBpZiBFZGl0b3JWaWV3IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gY2VsbC5lZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZXR0aW5nIHVwIGNlbGwgbGlzdGVuZXJzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBhY3RpdmUgY2VsbFxuICAgICAqL1xuICAgIGNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbnRleHQgaW5mb3JtYXRpb24gZnJvbSBDb2RlTWlycm9yIEVkaXRvclZpZXdcbiAgICAgKi9cbiAgICBnZXRDbUNvbnRleHQodmlldykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIGNvbnN0IGZ1bGxUZXh0ID0gc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGluZTogbGluZS5udW1iZXIgLSAxLFxuICAgICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBsaW5lLmZyb20sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0UmFkaXVzID0gMTAwO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIG9mZnNldCAtIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihmdWxsVGV4dC5sZW5ndGgsIG9mZnNldCArIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBjb250ZXh0QmVmb3JlOiBmdWxsVGV4dC5zdWJzdHJpbmcoc3RhcnQsIG9mZnNldCksXG4gICAgICAgICAgICBjb250ZXh0QWZ0ZXI6IGZ1bGxUZXh0LnN1YnN0cmluZyhvZmZzZXQsIGVuZClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBjZWxsIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2VsbENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDZWxsQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgYWxsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGxDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5zZXR1cENlbGxMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuaGFuZGxlTm90ZWJvb2tDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2VsbENvbnRleHRUcmFja2VyID0gQ2VsbENvbnRleHRUcmFja2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2lzdGVyQ29tbWFuZHMgPSByZWdpc3RlckNvbW1hbmRzO1xuY29uc3QgaWNvbnNfMSA9IHJlcXVpcmUoXCIuL2ljb25zXCIpO1xuLyoqXG4gKiBSZWdpc3RlcnMgY29tbWFuZHMgZm9yIHRoZSBleHRlbnNpb25cbiAqL1xuZnVuY3Rpb24gcmVnaXN0ZXJDb21tYW5kcyhhcHAsIHBhbGV0dGUsIGxhdW5jaGVyLCBzaWRlYmFyV2lkZ2V0KSB7XG4gICAgLy8gQWRkIGNvbW1hbmQgdG8gdG9nZ2xlIHRoZSBzaWRlYmFyXG4gICAgYXBwLmNvbW1hbmRzLmFkZENvbW1hbmQoJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLCB7XG4gICAgICAgIGxhYmVsOiAnVG9nZ2xlIEFJIEFzc2lzdGFudCBTaWRlYmFyJyxcbiAgICAgICAgaWNvbjogaWNvbnNfMS5leHRlbnNpb25JY29uLFxuICAgICAgICBleGVjdXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2lkZWJhcldpZGdldC5pc0F0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgc2lkZWJhcldpZGdldC5wYXJlbnQgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwLnNoZWxsLmFkZChzaWRlYmFyV2lkZ2V0LCAnbGVmdCcsIHsgcmFuazogOTk5OSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCB0aGUgY29tbWFuZCB0byB0aGUgY29tbWFuZCBwYWxldHRlXG4gICAgcGFsZXR0ZS5hZGRJdGVtKHtcbiAgICAgICAgY29tbWFuZDogJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLFxuICAgICAgICBjYXRlZ29yeTogJ0V4dGVuc2lvbidcbiAgICB9KTtcbiAgICAvLyBBZGQgYSBsYXVuY2hlciBpdGVtXG4gICAgbGF1bmNoZXIuYWRkKHtcbiAgICAgICAgY29tbWFuZDogJ3NpbXBsZS1leHRlbnNpb246dG9nZ2xlLXNpZGViYXInLFxuICAgICAgICBjYXRlZ29yeTogJ090aGVyJyxcbiAgICAgICAgcmFuazogOTk5OVxuICAgIH0pO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdsb2JhbHMgPSB2b2lkIDA7XG5leHBvcnRzLmluaXRHbG9iYWxzID0gaW5pdEdsb2JhbHM7XG4vKipcbiAqIEdsb2JhbCByZWZlcmVuY2VzIHRvIGtleSBjb21wb25lbnRzIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmdsb2JhbHMgPSB7fTtcbi8qKlxuICogSW5pdGlhbGl6ZSBnbG9iYWwgcmVmZXJlbmNlc1xuICovXG5mdW5jdGlvbiBpbml0R2xvYmFscyhhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgIGV4cG9ydHMuZ2xvYmFscy5hcHAgPSBhcHA7XG4gICAgZXhwb3J0cy5nbG9iYWxzLm5vdGVib29rVHJhY2tlciA9IG5vdGVib29rVHJhY2tlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbnNpb25JY29uID0gdm9pZCAwO1xuY29uc3QgdWlfY29tcG9uZW50c18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL3VpLWNvbXBvbmVudHNcIik7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJY29uIERlZmluaXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IGljb25TdmdTdHIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwiYmkgYmktY2hhdC1sZWZ0LXRleHRcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+JyArXG4gICAgJzxwYXRoIGQ9XCJNMTQgMWExIDEgMCAwIDEgMSAxdjhhMSAxIDAgMCAxLTEgMUg0LjQxNEEyIDIgMCAwIDAgMyAxMS41ODZsLTIgMlYyYTEgMSAwIDAgMSAxLTFoMTJ6TTIgMGEyIDIgMCAwIDAtMiAydjEyLjc5M2EuNS41IDAgMCAwIC44NTQuMzUzbDIuODUzLTIuODUzQTEgMSAwIDAgMSA0LjQxNCAxMkgxNGEyIDIgMCAwIDAgMi0yVjJhMiAyIDAgMCAwLTItMkgyelwiLz4nICtcbiAgICAnPHBhdGggZD1cIk0zIDMuNWEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlhLjUuNSAwIDAgMS0uNS0uNXpNMyA2YS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOUEuNS41IDAgMCAxIDMgNnptMCAyLjVhLjUuNSAwIDAgMSAuNS0uNWg1YS41LjUgMCAwIDEgMCAxaC01YS41LjUgMCAwIDEtLjUtLjV6XCIvPicgK1xuICAgICc8L3N2Zz4nO1xuLyoqXG4gKiBJY29uIGZvciB0aGUgQUkgQXNzaXN0YW50IGV4dGVuc2lvblxuICovXG5leHBvcnRzLmV4dGVuc2lvbkljb24gPSBuZXcgdWlfY29tcG9uZW50c18xLkxhYkljb24oe1xuICAgIG5hbWU6ICdzaW1wbGU6aWNvbicsXG4gICAgc3Znc3RyOiBpY29uU3ZnU3RyXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BcGlDbGllbnQgPSB2b2lkIDA7XG5jb25zdCBsYXVuY2hlcl8xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2xhdW5jaGVyXCIpO1xuY29uc3QgYXBwdXRpbHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9hcHB1dGlsc1wiKTtcbmNvbnN0IG5vdGVib29rXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbm90ZWJvb2tcIik7XG5jb25zdCBkb2NtYW5hZ2VyXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvZG9jbWFuYWdlclwiKTtcbmNvbnN0IHNpZGViYXJfd2lkZ2V0XzEgPSByZXF1aXJlKFwiLi9zaWRlYmFyLXdpZGdldFwiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIi4vY29tbWFuZHNcIik7XG5jb25zdCBjZWxsX2NvbnRleHRfdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vY2VsbC1jb250ZXh0LXRyYWNrZXJcIik7XG4vLyBpbXBvcnQgeyBBcGlDbGllbnQgfSBmcm9tICcuL2FwaS1jbGllbnQnO1xuLy8gSW1wb3J0IHRoZSBtYWluIENTUyBmaWxlXG5yZXF1aXJlKFwiLi4vc3R5bGUvaW5kZXguY3NzXCIpO1xuLy8gRXhwb3J0IEFwaUNsaWVudCBmb3IgdXNlIGJ5IG90aGVyIGNvbXBvbmVudHNcbnZhciBhcGlfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9hcGktY2xpZW50XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQXBpQ2xpZW50XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBhcGlfY2xpZW50XzEuQXBpQ2xpZW50OyB9IH0pO1xuLyoqXG4gKiBJbml0aWFsaXphdGlvbiBkYXRhIGZvciB0aGUganVweXRlci1zaW1wbGUtZXh0ZW5zaW9uIGV4dGVuc2lvbi5cbiAqL1xuY29uc3QgcGx1Z2luID0ge1xuICAgIGlkOiAnanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uOnBsdWdpbicsXG4gICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbbGF1bmNoZXJfMS5JTGF1bmNoZXIsIGFwcHV0aWxzXzEuSUNvbW1hbmRQYWxldHRlLCBub3RlYm9va18xLklOb3RlYm9va1RyYWNrZXIsIGRvY21hbmFnZXJfMS5JRG9jdW1lbnRNYW5hZ2VyXSxcbiAgICBhY3RpdmF0ZTogKGp1cHl0ZXJBcHAsIGxhdW5jaGVyLCBwYWxldHRlLCB0cmFja2VyLCBkb2NNYW5hZ2VyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKdXB5dGVyTGFiIGV4dGVuc2lvbiBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gaXMgYWN0aXZhdGVkIScpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzXG4gICAgICAgICgwLCBnbG9iYWxzXzEuaW5pdEdsb2JhbHMpKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNlbGwgY29udGV4dCB0cmFja2VyXG4gICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlciA9IG5ldyBjZWxsX2NvbnRleHRfdHJhY2tlcl8xLkNlbGxDb250ZXh0VHJhY2tlcihqdXB5dGVyQXBwLCB0cmFja2VyKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgc2lkZWJhciB3aWRnZXRcbiAgICAgICAgY29uc3Qgc2lkZWJhcldpZGdldCA9IG5ldyBzaWRlYmFyX3dpZGdldF8xLlNpbXBsZVNpZGViYXJXaWRnZXQoZG9jTWFuYWdlcik7XG4gICAgICAgIGp1cHl0ZXJBcHAuc2hlbGwuYWRkKHNpZGViYXJXaWRnZXQsICdsZWZ0JywgeyByYW5rOiA5OTk5IH0pO1xuICAgICAgICAvLyBSZWdpc3RlciBjb21tYW5kc1xuICAgICAgICAoMCwgY29tbWFuZHNfMS5yZWdpc3RlckNvbW1hbmRzKShqdXB5dGVyQXBwLCBwYWxldHRlLCBsYXVuY2hlciwgc2lkZWJhcldpZGdldCk7XG4gICAgfVxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IHBsdWdpbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25maWd1cmVNYXJrZWQgPSBjb25maWd1cmVNYXJrZWQ7XG5leHBvcnRzLnByZXByb2Nlc3NNYXJrZG93biA9IHByZXByb2Nlc3NNYXJrZG93bjtcbmNvbnN0IG1hcmtlZF8xID0gcmVxdWlyZShcIm1hcmtlZFwiKTtcbi8qKlxuICogQ29uZmlndXJlIG1hcmtlZCB3aXRoIGJldHRlciByZW5kZXJpbmcgb3B0aW9ucyBmb3IgY29kZSBibG9ja3NcbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlTWFya2VkKCkge1xuICAgIC8vIENvbmZpZ3VyZSBtYXJrZWQgb3B0aW9uc1xuICAgIG1hcmtlZF8xLm1hcmtlZC5zZXRPcHRpb25zKHtcbiAgICAgICAgZ2ZtOiB0cnVlLCAvLyBFbmFibGUgR2l0SHViIEZsYXZvcmVkIE1hcmtkb3duXG4gICAgICAgIGJyZWFrczogdHJ1ZSwgLy8gQWRkIDxicj4gb24gc2luZ2xlIGxpbmUgYnJlYWtzXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSwgLy8gQ29uZm9ybSB0byBvcmlnaW5hbCBtYXJrZG93biBzcGVjXG4gICAgICAgIGFzeW5jOiBmYWxzZSwgLy8gRGlzYWJsZSBhc3luYyByZW5kZXJpbmdcbiAgICAgICAgc2lsZW50OiBmYWxzZSAvLyBFbmFibGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgfSk7XG59XG4vKipcbiAqIFByZS1wcm9jZXNzIG1hcmtkb3duIHRleHQgdG8gZml4IGNvbW1vbiBpc3N1ZXMgd2l0aCBzdHJlYW1pbmcgY29udGVudFxuICovXG5mdW5jdGlvbiBwcmVwcm9jZXNzTWFya2Rvd24odGV4dCkge1xuICAgIC8vIEhhbmRsZSBjb2RlIGJsb2NrcyBmaXJzdFxuICAgIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVzID0gdGV4dC5zcGxpdCgnXFxuJyk7XG4gICAgY29uc3QgcHJvY2Vzc2VkTGluZXMgPSBsaW5lcy5tYXAoKGxpbmUsIGkpID0+IHtcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGNvZGUgYmxvY2sgbWFya2Vyc1xuICAgICAgICBpZiAobGluZS50cmltKCkuc3RhcnRzV2l0aCgnYGBgJykpIHtcbiAgICAgICAgICAgIGluQ29kZUJsb2NrID0gIWluQ29kZUJsb2NrO1xuICAgICAgICAgICAgLy8gUHJlc2VydmUgbGFuZ3VhZ2Ugc3BlY2lmaWNhdGlvblxuICAgICAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlJ3JlIGluIGEgY29kZSBibG9jaywgcHJlc2VydmUgdGhlIGxpbmUgYXMgaXNcbiAgICAgICAgaWYgKGluQ29kZUJsb2NrKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPdXRzaWRlIGNvZGUgYmxvY2tzLCBoYW5kbGUgbGlzdCBpdGVtc1xuICAgICAgICByZXR1cm4gbGluZS5yZXBsYWNlKC8oW15cXG5cXHNdKS1cXHMvZywgJyQxXFxuLSAnKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvY2Vzc2VkTGluZXMuam9pbignXFxuJyk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBpbnRlcmFjdGlvbnMgb2YgdGhlIG11bHRpLWxldmVsIHBvcHVwIG1lbnUuXG4gKi9cbmNsYXNzIFBvcHVwTWVudU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIsIHdpZGdldE5vZGUsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgdGhpcy5tZW51SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnROb3RlYm9vayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFRyYWNrIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51IGl0ZW1cbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQgPSBmYWxzZTsgLy8gRmxhZyB0byBwcmV2ZW50IHJlY3Vyc2l2ZSByZW5kZXJzXG4gICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSAnJzsgLy8gVHJhY2sgbGFzdCBzZWFyY2ggdGVybSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzXG4gICAgICAgIHRoaXMuZG9jTWFuYWdlciA9IGRvY01hbmFnZXI7XG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZSA9IHdpZGdldE5vZGU7XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIEF0dGFjaCB0byB0aGUgd2lkZ2V0IG5vZGUgaW5zdGVhZCBvZiB0aGUgYm9keVxuICAgICAgICB0aGlzLndpZGdldE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICAvLyBDcmVhdGUgc2VhcmNoIGlucHV0XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQucGxhY2Vob2xkZXIgPSAnU2VhcmNoLi4uJztcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LXNlYXJjaCc7IC8vIEFkZCBjbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICAvLyBVc2UgJ2lucHV0JyBldmVudCBpbnN0ZWFkIG9mIGRpcmVjdGx5IHJlLXJlbmRlcmluZyBvbiBldmVyeSBrZXlzdHJva2VcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIE9ubHkgcmUtcmVuZGVyIGlmIHRoZSBzZWFyY2ggdGVybSBoYXMgYWN0dWFsbHkgY2hhbmdlZFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgIT09IHRoaXMubGFzdFNlYXJjaFRlcm0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBIYW5kbGUga2V5ZG93biBpbiBzZWFyY2ggaW5wdXQgdG8gc3RvcCBwcm9wYWdhdGlvbiBmb3IgbmF2aWdhdGlvbiBrZXlzXG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIFNlYXJjaCBLZXlEb3duOiBLZXk9JyR7ZXZlbnQua2V5fSdgKTtcbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogUHJldmVudCB0aGVzZSBrZXlzIGZyb20gYmVpbmcgY2FwdHVyZWQgYnkgdGhlIGRvY3VtZW50IGhhbmRsZXJcbiAgICAgICAgICAgIGlmIChbJ0Fycm93VXAnLCAnQXJyb3dEb3duJywgJ0VudGVyJywgJ1RhYicsICdFc2NhcGUnXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIChTZWFyY2ggSW5wdXQpOiBTdG9wcGluZyBwcm9wYWdhdGlvbiBmb3IgbmF2aWdhdGlvbiBrZXk6JywgZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgRXNjYXBlIGRpcmVjdGx5IGhlcmVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBzZWxlY3QgZmlyc3QgaXRlbSBvbiBFbnRlcj9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBhY3RpdmF0ZSB0aGUgaXRlbTpcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1lbnVJdGVtc1swXS5jbGljaygpOyBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nIHx8IGV2ZW50LmtleSA9PT0gJ0Fycm93VXAnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgdG8gZmlyc3QvbGFzdCBtZW51IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsdXIoKSB3aWxsIGJlIGhhbmRsZWQgYnkgbWFpbiBrZXkgaGFuZGxlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENSSVRJQ0FMOiBETyBOT1Qgc3RvcCBwcm9wYWdhdGlvbiBmb3IgQmFja3NwYWNlIG9yIG90aGVyIHRleHQgZWRpdGluZyBrZXlzXG4gICAgICAgICAgICAvLyBUaGlzIGFsbG93cyBkZWZhdWx0IGJlaGF2aW9yIHRvIHdvcmsgcHJvcGVybHlcbiAgICAgICAgfSwgdHJ1ZSk7IC8vIFVzZSBjYXB0dXJlIHBoYXNlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAvLyBJTVBPUlRBTlQ6IFVzZSBhIHNlcGFyYXRlIGJvdW5kIGZ1bmN0aW9uIGZvciB0aGUgZG9jdW1lbnQga2V5ZG93blxuICAgICAgICAvLyBzbyB3ZSBjYW4gcmVtb3ZlIHRoZSBleGFjdCBzYW1lIGxpc3RlbmVyIGxhdGVyXG4gICAgICAgIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duID0gdGhpcy5oYW5kbGVLZXlEb3duLmJpbmQodGhpcyk7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIGlmIChnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuY29ubmVjdCgoXywgbm90ZWJvb2spID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnROb3RlYm9vayA9IG5vdGVib29rO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIC8vIFJlbW92ZSB1c2luZyB0aGUgZXhhY3Qgc2FtZSBib3VuZCBmdW5jdGlvblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5ib3VuZEhhbmRsZUtleURvd24sIHRydWUpO1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSB3aWRnZXROb2RlIGlmIGF0dGFjaGVkXG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5wYXJlbnROb2RlID09PSB0aGlzLndpZGdldE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZURvY3VtZW50Q2xpY2soZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiAhdGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgY29uc3QgYXRCdXR0b24gPSB0aGlzLndpZGdldE5vZGUucXVlcnlTZWxlY3RvcignI2pwLWxsbS1leHQtYXQtYnV0dG9uJyk7XG4gICAgICAgICAgICBpZiAoYXRCdXR0b24gJiYgYXRCdXR0b24uY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQ2xpY2sgd2FzIG9uIHRoZSBAIGJ1dHRvbiwgbm90IGhpZGluZy4nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IENsaWNrIGRldGVjdGVkIG91dHNpZGUgdGhlIG1lbnUuJyk7XG4gICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzaG93UG9wdXBNZW51KHgsIHkpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBTaG93aW5nIG1lbnUgYXQgKCR7eH0sICR7eX0pYCk7XG4gICAgICAgIC8vIFN0b3JlIHRoZSBpbml0aWFsIGFuY2hvciBwb2ludCBmb3IgcG9zaXRpb25pbmdcbiAgICAgICAgdGhpcy5fYW5jaG9yWCA9IHg7XG4gICAgICAgIHRoaXMuX2FuY2hvclkgPSB5O1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5ID0gW107XG4gICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlID0gJyc7IC8vIENsZWFyIHNlYXJjaCBvbiBzaG93XG4gICAgICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gJyc7IC8vIFJlc2V0IGxhc3Qgc2VhcmNoIHRlcm1cbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2V0Q3VycmVudERpcmVjdG9yeVBhdGgoKTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgIC8vIEVuc3VyZSBpdCdzIGF0dGFjaGVkIHRvIHRoZSB3aWRnZXQgbm9kZSBpZiBzb21laG93IGRldGFjaGVkXG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBwb3B1cCBtZW51IC0gaGFuZGxlZCBpbiB1cGRhdGVQb3B1cFBvc2l0aW9uXG4gICAgICAgIHRoaXMudXBkYXRlUG9wdXBQb3NpdGlvbigpO1xuICAgICAgICAvLyBGb2N1cyB0aGUgc2VhcmNoIGlucHV0IGlmIHdlIGFyZSBpbiBmaWxlL2RpcmVjdG9yeSB2aWV3LCBvdGhlcndpc2UgZm9jdXMgdGhlIGZpcnN0IGl0ZW1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZvY3VzIGFmdGVyIHRpbWVvdXQgdG8gZW5zdXJlIERPTSBpcyByZWFkeVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEZvY3VzZWQgc2VhcmNoIGlucHV0Jyk7XG4gICAgICAgICAgICB9LCA1MCk7IC8vIFNsaWdodGx5IGxvbmdlciB0aW1lb3V0XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBEb24ndCBzZWxlY3QgYW4gaXRlbSBpZiBzZWFyY2ggaXMgZm9jdXNlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUmVzZXQgYW5kIHNlbGVjdCB0aGUgZmlyc3QgbWVudSBpdGVtIGZvciB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCksIDUwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlUG9wdXBNZW51KCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEhpZGluZyBtZW51LicpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gZXhwbGljaXRseSByZW1vdmUgZnJvbSB3aWRnZXROb2RlIHVubGVzcyBjYXVzaW5nIGlzc3Vlc1xuICAgICAgICAgICAgLy8gSWYgcGVyZm9ybWFuY2UgYmVjb21lcyBhbiBpc3N1ZSB3aXRoIG1hbnkgbWVudXMsIGNvbnNpZGVyIHJlbW92aW5nL3JlLWFkZGluZ1xuICAgICAgICAgICAgLy8gaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMud2lkZ2V0Tm9kZSkge1xuICAgICAgICAgICAgLy8gICAgIHRoaXMud2lkZ2V0Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgICAgICAvLyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgcmVuZGVyTWVudUNvbnRlbnQoKSB7XG4gICAgICAgIC8vIFByZXZlbnQgcmVjdXJzaXZlIHJlbmRlcnNcbiAgICAgICAgaWYgKHRoaXMuaXNSZW5kZXJpbmdDb250ZW50KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IFNraXBwaW5nIHJlbmRlciAtIGFscmVhZHkgcmVuZGVyaW5nJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQgPSB0cnVlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgY29udGVudFxuICAgICAgICAgICAgd2hpbGUgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIG5vdCBhdCB0b3AgbGV2ZWwsIGFkZCBhIHNlYXJjaCBpbnB1dCBmb3IgZmlsdGVyaW5nIGl0ZW1zXG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsICE9PSAndG9wJykge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBzZWFyY2ggaW5wdXQgYXQgdGhlIHRvcCBvZiB0aGUgbWVudVxuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuc2VhcmNoSW5wdXQpO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgY3VycmVudCBwYXRoIGRpc3BsYXlcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoRGlzcGxheSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIHBhdGhEaXNwbGF5LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCc7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2NlbGxzJykge1xuICAgICAgICAgICAgICAgICAgICBwYXRoRGlzcGxheS50ZXh0Q29udGVudCA9ICdDdXJyZW50IE5vdGVib29rIENlbGxzJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBmaWxlcyBhbmQgZGlyZWN0b3JpZXNcbiAgICAgICAgICAgICAgICAgICAgcGF0aERpc3BsYXkudGV4dENvbnRlbnQgPSB0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKHBhdGhEaXNwbGF5KTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYmFjayBidXR0b24gaWYgdGhlcmUncyBhIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW51SGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tCdXR0b24gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCfCqyBCYWNrJywgJ25hdmlnYXRlLWJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgYmFja0J1dHRvbi5jbGFzc0xpc3QuYWRkKCdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtYmFjaycpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChiYWNrQnV0dG9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW5kZXIgZGlmZmVyZW50IG1lbnUgY29udGVudCBiYXNlZCBvbiBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudE1lbnVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9wTGV2ZWxJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlyZWN0b3JpZXMnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZWxscyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyQ2VsbEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgc2VsZWN0aW9uIGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIHRvIG1haW50YWluIHRoZSBmaXhlZCBib3R0b20gZWRnZVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiB0aGlzLl9hbmNob3JYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fYW5jaG9yWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgcmVuZGVyaW5nIG1lbnUgY29udGVudCcsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVG9wTGV2ZWxJdGVtcygpIHtcbiAgICAgICAgY29uc3QgdG9wTGV2ZWxDb21tYW5kcyA9IFtcbiAgICAgICAgICAgIHsgbGFiZWw6ICdDb2RlJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2luc2VydC1jb2RlJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0NlbGxzJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2Jyb3dzZS1jZWxscycgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdGaWxlJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2Jyb3dzZS1maWxlcycgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdEaXJlY3RvcnknLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWRpcmVjdG9yaWVzJyB9XG4gICAgICAgIF07XG4gICAgICAgIHRvcExldmVsQ29tbWFuZHMuZm9yRWFjaChjbWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oY21kLmxhYmVsLCBjbWQuYWN0aW9uSWQsICcnLCBjbWQuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZW5kZXJEaXJlY3RvcnlCcm93c2VySXRlbXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gR2V0IHNlYXJjaCB0ZXJtXG4gICAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBjb25zdCBsb2FkaW5nSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ0xvYWRpbmcuLi4nLCAnbG9hZGluZycsICcnLCAnJyk7XG4gICAgICAgIGxvYWRpbmdJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGFkZCBsb2FkaW5nIGl0ZW0gYmVsb3cgc2VhcmNoL3BhdGhcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uUG9pbnQgPSAoX2EgPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1wb3B1cC1tZW51LXBhdGgnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHRTaWJsaW5nO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbnNlcnRCZWZvcmUobG9hZGluZ0l0ZW0sIGluc2VydGlvblBvaW50IHx8IG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgY29udGVudHMgd2VyZSBhbHJlYWR5IGZldGNoZWQgcmVjZW50bHkgYW5kIHdlJ3JlIGp1c3QgZmlsdGVyaW5nIGFnYWluLFxuICAgICAgICAgICAgLy8gd2UgY291bGQgcG90ZW50aWFsbHkgY2FjaGUgdGhlIHJlc3VsdHMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgQVBJIGNhbGxzXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJUeXBlID0gdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSc7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHRoaXMubGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyh0aGlzLmN1cnJlbnRNZW51UGF0aCwgdW5kZWZpbmVkKTsgLy8gR2V0IGJvdGggZmlsZXMgYW5kIGRpcnMgZmlyc3RcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHN0aWxsIGluIERPTSBiZWZvcmUgdHJ5aW5nIHRvIHJlbW92ZVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50cyAmJiBjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJhc2VkIG9uIHNlYXJjaCB0ZXJtIGFuZCByZXF1aXJlZCB0eXBlIChmaWxlL2RpcilcbiAgICAgICAgICAgICAgICBjb25zdCBmaWx0ZXJlZENvbnRlbnRzID0gY29udGVudHMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuYW1lTWF0Y2hlcyA9IGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlTWF0Y2hlcyA9IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyA/IGl0ZW0udHlwZSA9PT0gJ2ZpbGUnIDogaXRlbS50eXBlID09PSAnZGlyZWN0b3J5JztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hbWVNYXRjaGVzICYmIHR5cGVNYXRjaGVzO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZENvbnRlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRDb250ZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbU5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1QYXRoID0gaXRlbS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5JyA/ICfwn5OBJyA6ICfwn5OEJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZCA9IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyA/ICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJyA6ICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpdGVtVHlwZSA9PT0gJ2ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWQgPSAnc2VsZWN0LWZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGAke2ljb259ICR7aXRlbU5hbWV9YCwgYWN0aW9uSWQsIGl0ZW1QYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKHNlYXJjaFRlcm0gPyAnTm8gbWF0Y2hlcyBmb3VuZCcgOiBgTm8gJHtmaWx0ZXJUeXBlfXMgZm91bmRgLCAnZW1wdHknLCAnJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBObyBpdGVtcyBmb3VuZCBpbiB0aGlzIGRpcmVjdG9yeWAsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBFcnJvcjogJHtlcnJvcn1gLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgbG9hZGluZy9maWx0ZXJpbmcgZGlyZWN0b3J5IGNvbnRlbnRzOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFsbCBjZWxscyBmcm9tIHRoZSBjdXJyZW50IG5vdGVib29rXG4gICAgICovXG4gICAgYXN5bmMgcmVuZGVyQ2VsbEl0ZW1zKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBHZXQgc2VhcmNoIHRlcm0gZm9yIGZpbHRlcmluZ1xuICAgICAgICBjb25zdCBzZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgY29uc3QgbG9hZGluZ0l0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdMb2FkaW5nIGNlbGxzLi4uJywgJ2xvYWRpbmcnLCAnJywgJycpO1xuICAgICAgICBsb2FkaW5nSXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IChfYSA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dFNpYmxpbmc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmluc2VydEJlZm9yZShsb2FkaW5nSXRlbSwgaW5zZXJ0aW9uUG9pbnQgfHwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSBub3RlYm9va1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnROb3RlYm9vayB8fCAhdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudCB8fCAhdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsb2FkaW5nIGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTm8gYWN0aXZlIG5vdGVib29rIGZvdW5kJywgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTW9kZWwgPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50Lm1vZGVsO1xuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBub3RlYm9va01vZGVsLmNlbGxzO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjZWxscyB8fCBjZWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdObyBjZWxscyBpbiBub3RlYm9vaycsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGFuZCBkaXNwbGF5IGVhY2ggY2VsbFxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkQ2VsbENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxUeXBlID0gY2VsbC50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZW50ID0gY2VsbC5zaGFyZWRNb2RlbCA/IGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCkgOlxuICAgICAgICAgICAgICAgICAgICAoKChfYiA9IGNlbGwudG9KU09OKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb3VyY2UpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdHlwZSBjYXN0aW5nIHRvIGF2b2lkIFR5cGVTY3JpcHQgZXJyb3JzXG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uQ291bnQgPSBjZWxsVHlwZSA9PT0gJ2NvZGUnID9cbiAgICAgICAgICAgICAgICAgICAgKGNlbGwuZXhlY3V0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjZWxsLmV4ZWN1dGlvbkNvdW50ICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZXhlY3V0aW9uQ291bnQgOiAnKicpIDpcbiAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJldmlldyBvZiB0aGUgY2VsbCBjb250ZW50ICh0cnVuY2F0ZSBpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFByZXZpZXcgPSB0eXBlb2YgY2VsbENvbnRlbnQgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgOlxuICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjZWxsQ29udGVudCkgPyBjZWxsQ29udGVudC5qb2luKCdcXG4nKSA6ICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSBjb250ZW50UHJldmlldy5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJ1bmNhdGVkQ29udGVudCA9IGZpcnN0TGluZS5sZW5ndGggPiAzMCA/XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TGluZS5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicgOlxuICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmU7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNlbGwgbGFiZWwgd2l0aCBzdHlsZWQgdHlwZSBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlSW5kaWNhdG9yID0gY2VsbFR5cGUgPT09ICdtYXJrZG93bicgPyAnTScgOiAnQyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uRGlzcGxheSA9IGV4ZWN1dGlvbkNvdW50ICE9PSAnJyA/IGBbJHtleGVjdXRpb25Db3VudH1dYCA6ICcnO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBtZW51IGl0ZW0gZm9yIHRoaXMgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnJywgLy8gRW1wdHkgdGV4dCwgd2lsbCBiZSBhZGRlZCBhcyBIVE1MXG4gICAgICAgICAgICAgICAgJ3NlbGVjdC1jZWxsJywgaS50b1N0cmluZygpIC8vIFN0b3JlIGNlbGwgaW5kZXggaW4gcGF0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN0eWxlZCBjb250ZW50IHdpdGggSFRNTCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIHR5cGVTcGFuLmNsYXNzTmFtZSA9IGBjZWxsLXR5cGUtaW5kaWNhdG9yIGNlbGwtdHlwZS0ke2NlbGxUeXBlID09PSAnbWFya2Rvd24nID8gJ21kJyA6ICdjb2RlJ31gO1xuICAgICAgICAgICAgICAgIHR5cGVTcGFuLnRleHRDb250ZW50ID0gdHlwZUluZGljYXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi5jbGFzc05hbWUgPSAnY2VsbC1leGVjLWNvdW50JztcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi50ZXh0Q29udGVudCA9IGV4ZWN1dGlvbkRpc3BsYXk7XG4gICAgICAgICAgICAgICAgZXhlY1NwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSAnOHB4JztcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBjb250ZW50U3Bhbi5jbGFzc05hbWUgPSAnY2VsbC1jb250ZW50LXByZXZpZXcnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTcGFuLnRleHRDb250ZW50ID0gdHJ1bmNhdGVkQ29udGVudDtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGxhYmVsIHNwYW4gKGZpcnN0IGNoaWxkIG9mIHRoZSBtZW51IGl0ZW0pXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxTcGFuID0gY2VsbEl0ZW0ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbFNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLnRleHRDb250ZW50ID0gJyc7IC8vIENsZWFyIGV4aXN0aW5nIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKHR5cGVTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3Bhbi5hcHBlbmRDaGlsZChleGVjU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKGNvbnRlbnRTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGZ1bGwgc2VhcmNoYWJsZSB0ZXh0XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoYWJsZVRleHQgPSBgJHt0eXBlSW5kaWNhdG9yfSAke2V4ZWN1dGlvbkRpc3BsYXl9ICR7dHJ1bmNhdGVkQ29udGVudH1gLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHNlYXJjaCB0ZXJtIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hUZXJtICYmICFzZWFyY2hhYmxlVGV4dC5pbmNsdWRlcyhzZWFyY2hUZXJtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoY2VsbEl0ZW0pO1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ2VsbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRDZWxsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub01hdGNoSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ05vIG1hdGNoaW5nIGNlbGxzIGZvdW5kJywgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBub01hdGNoSXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG5vTWF0Y2hJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShgRXJyb3I6ICR7ZXJyb3J9YCwgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckl0ZW0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEVycm9yIGxvYWRpbmcgbm90ZWJvb2sgY2VsbHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZU1lbnVJdGVtKHRleHQsIGFjdGlvbklkLCBwYXRoID0gJycsIGRlc2NyaXB0aW9uID0gJycpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbSc7XG4gICAgICAgIGl0ZW0uZGF0YXNldC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgaXRlbS5kYXRhc2V0LnBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ub25jbGljayA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNZW51Q2xpY2soZXZlbnQpO1xuICAgICAgICBjb25zdCBsYWJlbFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxhYmVsU3Bhbi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQobGFiZWxTcGFuKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBsYWJlbFNwYW4uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICAgIGNvbnN0IGRlc2NTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgZGVzY1NwYW4udGV4dENvbnRlbnQgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIGRlc2NTcGFuLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgZGVzY1NwYW4uc3R5bGUuZm9udFNpemUgPSAnMC44ZW0nO1xuICAgICAgICAgICAgZGVzY1NwYW4uc3R5bGUuY29sb3IgPSAndmFyKC0tanAtdWktZm9udC1jb2xvcjIpJztcbiAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQoZGVzY1NwYW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBhc3luYyBoYW5kbGVNZW51Q2xpY2soZXZlbnQpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgY29uc3QgYWN0aW9uSWQgPSB0YXJnZXQuZGF0YXNldC5hY3Rpb25JZDtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRhcmdldC5kYXRhc2V0LnBhdGggfHwgJyc7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogTWVudSBpdGVtIGNsaWNrZWQuIEFjdGlvbjogJHthY3Rpb25JZH0sIFBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb25JZCkge1xuICAgICAgICAgICAgY2FzZSAnbmF2aWdhdGUtYmFjayc6XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUJhY2tNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNlcnQtY29kZSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmNhbGxiYWNrcy5nZXRTZWxlY3RlZFRleHQgPyB0aGlzLmNhbGxiYWNrcy5nZXRTZWxlY3RlZFRleHQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2RlKHNlbGVjdGVkVGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29udGVudCA9IHRoaXMuY2FsbGJhY2tzLmdldEN1cnJlbnRDZWxsQ29udGVudCA/IHRoaXMuY2FsbGJhY2tzLmdldEN1cnJlbnRDZWxsQ29udGVudCgpIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxDb250ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2RlKGNlbGxDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1jZWxscyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2NlbGxzJywgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1maWxlcyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2ZpbGVzJywgdGhpcy5jdXJyZW50TWVudVBhdGggfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaCB3aGVuIGNoYW5naW5nIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1kaXJlY3Rvcmllcyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2RpcmVjdG9yaWVzJywgdGhpcy5jdXJyZW50TWVudVBhdGggfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaCB3aGVuIGNoYW5naW5nIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1jZWxsJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBwYXJzZUludChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihjZWxsSW5kZXgpICYmIHRoaXMuY2FsbGJhY2tzLmluc2VydENlbGxCeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDZWxsQnlJbmRleChjZWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogSW52YWxpZCBjZWxsIGluZGV4IG9yIGNhbGxiYWNrIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZmlsZSc6XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0RmlsZVBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEZpbGUgc2VsZWN0ZWQgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJzogLy8gTmV3IGFjdGlvbiB0byBuYXZpZ2F0ZSBpbnRvIGRpciB3aGVuIGluIGZpbGUgdmlld1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMubmF2aWdhdGVNZW51KCdmaWxlcycsIHBhdGgpOyAvLyBOYXZpZ2F0ZSBkZWVwZXIsIHN0aWxsIGxvb2tpbmcgZm9yIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIG5hdmlnYXRpb24gYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJzogLy8gTmV3IGFjdGlvbiB0byBzZWxlY3QgZGlyIHdoZW4gaW4gZGlyZWN0b3J5IHZpZXdcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnREaXJlY3RvcnlQYXRoKHBhdGgpOyAvLyBVc2UgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IERpcmVjdG9yeSBzZWxlY3RlZCBmb3IgY2FsbGJhY2sgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwbGFjZWhvbGRlci1hY3Rpb24nOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQbGFjZWhvbGRlciBhY3Rpb24gdHJpZ2dlcmVkLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgICBjYXNlICdlbXB0eSc6XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biBtZW51IGFjdGlvbjonLCBhY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlTWVudShsZXZlbCwgcGF0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IE5hdmlnYXRpbmcgdG8gbGV2ZWw6ICR7bGV2ZWx9LCBwYXRoOiAke3BhdGh9YCk7XG4gICAgICAgIC8vIE9ubHkgcHVzaCBoaXN0b3J5IGlmIHdlIGFyZSBhY3R1YWxseSBtb3ZpbmcgdG8gYSBuZXcgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5jdXJyZW50TWVudVBhdGggIT09IHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWVudUhpc3RvcnkucHVzaCh7IGxldmVsOiB0aGlzLmN1cnJlbnRNZW51TGV2ZWwsIHBhdGg6IHRoaXMuY3VycmVudE1lbnVQYXRoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IHBhdGg7XG4gICAgICAgIC8vIERvbid0IGNsZWFyIHNlYXJjaCBvbiBwcm9ncmFtbWF0aWMgbmF2aWdhdGlvbiAobGlrZSBiYWNrIGJ1dHRvbilcbiAgICAgICAgLy8gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBNYXliZSBrZWVwIHNlYXJjaCB0ZXJtP1xuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBhZnRlciBuYXZpZ2F0aW5nIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgaWYgKGxldmVsID09PSAnZmlsZXMnIHx8IGxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBSZXNldCBzZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdCBmaXJzdCBpdGVtIGlmIG5hdmlnYXRpbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCksIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5hdmlnYXRlQmFja01lbnUoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLm1lbnVIaXN0b3J5LnBvcCgpO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIGJhY2sgdG8gbGV2ZWw6ICR7cHJldmlvdXNTdGF0ZS5sZXZlbH0sIHBhdGg6ICR7cHJldmlvdXNTdGF0ZS5wYXRofWApO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gcHJldmlvdXNTdGF0ZS5sZXZlbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gcHJldmlvdXNTdGF0ZS5wYXRoO1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2xlYXIgc2VhcmNoIG9uIGJhY2sgbmF2aWdhdGlvblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBpZiBnb2luZyBiYWNrIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFJlc2V0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZpcnN0IGl0ZW0gaWYgZ29pbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQWxyZWFkeSBhdCB0aGUgdG9wIGxldmVsLicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyhiYXNlUGF0aCwgZmlsdGVyVHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IExpc3RpbmcgZGlyZWN0b3J5IGNvbnRlbnRzIGZvciBwYXRoOiAnJHtiYXNlUGF0aH0nLCBmaWx0ZXI6ICR7ZmlsdGVyVHlwZSB8fCAnYWxsJ31gKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVBhdGggPSBiYXNlUGF0aCA9PT0gJy8nID8gJycgOiBiYXNlUGF0aDtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSB1bmxlc3MgaXQncyByb290XG4gICAgICAgICAgICBjb25zdCBwYXRoRm9yQXBpID0gZWZmZWN0aXZlUGF0aC5lbmRzV2l0aCgnLycpICYmIGVmZmVjdGl2ZVBhdGgubGVuZ3RoID4gMSA/IGVmZmVjdGl2ZVBhdGguc2xpY2UoMCwgLTEpIDogZWZmZWN0aXZlUGF0aDtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5kb2NNYW5hZ2VyLnNlcnZpY2VzLmNvbnRlbnRzLmdldChwYXRoRm9yQXBpIHx8ICcnKTsgLy8gVXNlIGVtcHR5IHN0cmluZyBmb3Igcm9vdFxuICAgICAgICAgICAgaWYgKGNvbnRlbnRzLnR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgbGV0IGl0ZW1zID0gY29udGVudHMuY29udGVudC5tYXAoKGl0ZW0pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknID8gJ2RpcmVjdG9yeScgOiAnZmlsZScgLy8gU2ltcGxpZnkgdHlwZVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgb25seSB0byBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgKGV4Y2x1ZGluZyBub3RlYm9va3MsIGV0Yy4gaWYgbmVlZGVkIGxhdGVyKVxuICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09ICdmaWxlJyB8fCBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknKTtcbiAgICAgICAgICAgICAgICAvLyBBcHBseSBvcHRpb25hbCBmaWx0ZXIgKmlmIHByb3ZpZGVkKlxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnR5cGUgPT09IGZpbHRlclR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IERpcmVjdG9yeSBpdGVtcyBmb3IgJyR7YmFzZVBhdGh9JzpgLCBpdGVtcyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW1zLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU29ydCBkaXJlY3RvcmllcyBmaXJzdCwgdGhlbiBmaWxlcywgdGhlbiBhbHBoYWJldGljYWxseVxuICAgICAgICAgICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZGlyZWN0b3J5JyAmJiBiLnR5cGUgIT09ICdkaXJlY3RvcnknKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYS50eXBlICE9PSAnZGlyZWN0b3J5JyAmJiBiLnR5cGUgPT09ICdkaXJlY3RvcnknKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGF0aCBpcyBub3QgYSBkaXJlY3Rvcnk6JywgYmFzZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUE9QVVA6IEVycm9yIGxpc3RpbmcgZGlyZWN0b3J5IGNvbnRlbnRzIGZvciAnJHtiYXNlUGF0aH0nOmAsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBzcGVjaWZpYyBlcnJvcnMgbGlrZSA0MDQgTm90IEZvdW5kIGlmIG5lZWRlZFxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0Q3VycmVudERpcmVjdG9yeVBhdGgoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRpclBhdGggPSBudWxsO1xuICAgICAgICBjb25zdCBhcHAgPSBnbG9iYWxzXzEuZ2xvYmFscy5hcHA7XG4gICAgICAgIGlmICghYXBwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogQXBwbGljYXRpb24gcmVmZXJlbmNlIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFNoZWxsV2lkZ2V0ID0gYXBwLnNoZWxsLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgIGlmIChjdXJyZW50U2hlbGxXaWRnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldENvbnRleHQgPSB0aGlzLmRvY01hbmFnZXIuY29udGV4dEZvcldpZGdldChjdXJyZW50U2hlbGxXaWRnZXQpO1xuICAgICAgICAgICAgaWYgKHdpZGdldENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gd2lkZ2V0Q29udGV4dC5wYXRoO1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSB0aGlzLmdldFBhcmVudERpcmVjdG9yeShwYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBhdGggZnJvbSBjdXJyZW50IHdpZGdldCBjb250ZXh0OiAke3BhdGh9IC0+ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCAmJiB0aGlzLmN1cnJlbnROb3RlYm9vayAmJiB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBub3RlYm9va1BhdGggPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vdGVib29rUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkaXJQYXRoID0gdGhpcy5nZXRQYXJlbnREaXJlY3Rvcnkobm90ZWJvb2tQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBhdGggZnJvbSBhY3RpdmUgbm90ZWJvb2s6ICR7bm90ZWJvb2tQYXRofSAtPiAke2RpclBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFdpZGdldHMgPSBBcnJheS5mcm9tKGFwcC5zaGVsbC53aWRnZXRzKCdsZWZ0JykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVCcm93c2VyV2lkZ2V0ID0gbGVmdFdpZGdldHMuZmluZCh3aWRnZXQgPT4gd2lkZ2V0LmlkID09PSAnZmlsZWJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUJyb3dzZXJXaWRnZXQgJiYgKChfYSA9IGZpbGVCcm93c2VyV2lkZ2V0Lm1vZGVsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGF0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZGlyUGF0aCA9IGZpbGVCcm93c2VyV2lkZ2V0Lm1vZGVsLnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGZpbGUgYnJvd3NlciB3aWRnZXQgbW9kZWw6ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRmlsZSBicm93c2VyIHdpZGdldCBwYXRoIG5vdCBkaXJlY3RseSBhY2Nlc3NpYmxlLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQT1BVUDogQ291bGQgbm90IGdldCBwYXRoIGZyb20gZmlsZSBicm93c2VyLicsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsKSB7XG4gICAgICAgICAgICBkaXJQYXRoID0gJyc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEZhbGxpbmcgYmFjayB0byBzZXJ2ZXIgcm9vdCBwYXRoLicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gZGlyUGF0aDtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBJbml0aWFsIGN1cnJlbnQgbWVudSBwYXRoIHNldCB0bzogJyR7dGhpcy5jdXJyZW50TWVudVBhdGh9J2ApO1xuICAgIH1cbiAgICBnZXRQYXJlbnREaXJlY3RvcnkocGF0aCkge1xuICAgICAgICBpZiAoIXBhdGgpXG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIGNvbnN0IGxhc3RTbGFzaCA9IE1hdGgubWF4KHBhdGgubGFzdEluZGV4T2YoJy8nKSwgcGF0aC5sYXN0SW5kZXhPZignXFxcXFxcXFwnKSk7XG4gICAgICAgIGlmIChsYXN0U2xhc2ggPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuICcnOyAvLyBObyBkaXJlY3RvcnkgcGFydCwgbGlrZWx5IHJvb3Qgb3IganVzdCBhIGZpbGVuYW1lXG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBsYXN0U2xhc2gpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUga2V5Ym9hcmQgbmF2aWdhdGlvbiB3aGVuIHRoZSBwb3B1cCBtZW51IGlzIHNob3duXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bihldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIC8vIFNraXAgaWYgbWVudSBub3QgdmlzaWJsZVxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIEtleURvd246IEtleT0nJHtldmVudC5rZXl9JywgVGFyZ2V0PSckeyhfYSA9IGV2ZW50LnRhcmdldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRhZ05hbWV9JywgU2VhcmNoRm9jdXNlZD0nJHtkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnNlYXJjaElucHV0fSdgKTtcbiAgICAgICAgLy8gU3BlY2lhbCBoYW5kbGluZyBmb3Igd2hlbiBzZWFyY2ggaW5wdXQgaXMgZm9jdXNlZFxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5zZWFyY2hJbnB1dCkge1xuICAgICAgICAgICAgLy8gVGhlIGlucHV0J3Mgb3duIGtleWRvd24gaGFuZGxlciB3aWxsIGhhbmRsZSBtb3N0IGtleXNcbiAgICAgICAgICAgIC8vIEJ1dCBmb3IgY2VydGFpbiBrZXlzIGxpa2UgYXJyb3cga2V5cywgd2UgbWF5IG5lZWQgdG8gbW92ZSBmb2N1c1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIHNlbGVjdGlvbiB0byBmaXJzdC9sYXN0IGl0ZW1cbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIERlbGF5IGJlZm9yZSBtb3ZpbmcgZm9jdXMgLSB0aGlzIGdpdmVzIHRpbWUgZm9yIHRoZSBzZWFyY2ggaW5wdXQnc1xuICAgICAgICAgICAgICAgIC8vIG93biBrZXlkb3duIGhhbmRsZXIgdG8gcHJvY2VzcyB0aGUga2V5IGZpcnN0XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIEFycm93VXBcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91c01lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJTVBPUlRBTlQ6IEZvciBCYWNrc3BhY2UgaW4gc2VhcmNoIGlucHV0LCBqdXN0IHJldHVybiB3aXRob3V0IGhhbmRsaW5nXG4gICAgICAgICAgICAvLyBMZXQgdGhlIGRlZmF1bHQgYmVoYXZpb3IgaGFwcGVuXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICAgICAgICAgIC8vIEp1c3QgcGVyZm9ybSBkZWZhdWx0IGJlaGF2aW9yIGluIHNlYXJjaCBpbnB1dFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIExldCBhbGwgb3RoZXIga2V5cyBiZSBoYW5kbGVkIGJ5IHRoZSBzZWFyY2ggaW5wdXQncyBvd24gaGFuZGxlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZyb20gaGVyZSwgc2VhcmNoIGlucHV0IGlzIE5PVCBmb2N1c2VkXG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIHN3aXRjaCAoZXZlbnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgIGlmIChtZW51SXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogQXJyb3dEb3duJyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIGlmIChtZW51SXRlbXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogQXJyb3dVcCcpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RQcmV2aW91c01lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQmFja3NwYWNlJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogQmFja3NwYWNlJyk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBwcmV2ZW50IGRlZmF1bHQgYW5kIG5hdmlnYXRlIGJhY2sgaWYgd2UgaGF2ZSBoaXN0b3J5XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWVudUhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUJhY2tNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogTm8gaGlzdG9yeSwgYWxsb3dpbmcgQmFja3NwYWNlIGRlZmF1bHQgYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGRlZmF1bHQgLSBkb24ndCBwcmV2ZW50IG9yIHN0b3AgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFbnRlcic6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IEVudGVyJyk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBhY3RpdmF0ZSBpZiBhbiBpdGVtIGlzIHNlbGVjdGVkXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID49IDAgJiYgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPCBtZW51SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXNbdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXhdLmNsaWNrKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVGFiJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogVGFiJyk7XG4gICAgICAgICAgICAgICAgLy8gQmFzaWMgVGFiIHN1cHBvcnQ6IG1vdmUgZm9jdXMgYmV0d2VlbiBzZWFyY2ggYW5kIGZpcnN0L2xhc3QgaXRlbVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRlc2VsZWN0QWxsTWVudUl0ZW1zKCk7IC8vIERlc2VsZWN0IGl0ZW1zIHdoZW4gc2VhcmNoIGdldHMgZm9jdXMgdmlhIFRhYlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWF5YmUgY2xvc2UgbWVudSBvbiBUYWIgZnJvbSB0b3AgbGV2ZWw/IE9yIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VzY2FwZSc6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IEVzY2FwZScpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBEZWZhdWx0IGtleSAnJHtldmVudC5rZXl9J2ApO1xuICAgICAgICAgICAgICAgIC8vIElmIHR5cGluZyBhIGNoYXJhY3RlciBhbmQgaW4gZmlsZS9kaXIgdmlldywgZm9jdXMgc2VhcmNoXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSAmJlxuICAgICAgICAgICAgICAgICAgICBldmVudC5rZXkubGVuZ3RoID09PSAxICYmICFldmVudC5jdHJsS2V5ICYmICFldmVudC5tZXRhS2V5ICYmICFldmVudC5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBjaGFyYWN0ZXIgYXBwZWFyaW5nIGVsc2V3aGVyZVxuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAvLyBNYW51YWxseSBhcHBlbmQgdGhlIHR5cGVkIGNoYXJhY3RlciBhcyBmb2N1cyBoYXBwZW5zIGFmdGVyIGtleWRvd24gZGVmYXVsdCBhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSArPSBldmVudC5rZXk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHkgdG8gdXBkYXRlIGxpc3RcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBbGxvdyBvdGhlciBrZXlzIChlLmcuLCBtb2RpZmllcnMpIHRvIHBhc3MgdGhyb3VnaCBpZiBub3QgaGFuZGxlZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIHVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodDogSGlnaGxpZ2h0aW5nIGluZGV4ICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9IGFtb25nICR7bWVudUl0ZW1zLmxlbmd0aH0gaXRlbXMuYCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCkge1xuICAgICAgICAgICAgICAgIGlmICghaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0OiBBZGRlZCAnc2VsZWN0ZWQnIHRvIGl0ZW0gJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIGl0ZW0gaXMgdmlzaWJsZVxuICAgICAgICAgICAgICAgICAgICBpdGVtLnNjcm9sbEludG9WaWV3KHsgYmxvY2s6ICduZWFyZXN0JyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5jbGFzc0xpc3QuY29udGFpbnMoJ3NlbGVjdGVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0OiBSZW1vdmVkICdzZWxlY3RlZCcgZnJvbSBpdGVtICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzZWxlY3RBbGxNZW51SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4gaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdzZWxlY3RlZCcpKTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICB9XG4gICAgc2VsZWN0TmV4dE1lbnVJdGVtKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBpZiAoIW1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBzZWxlY3ROZXh0OiBObyBpdGVtcyB0byBzZWxlY3QuJyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBFbnN1cmUgaW5kZXggaXMgcmVzZXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4O1xuICAgICAgICAvLyBEZXNlbGVjdCBjdXJyZW50IGZpcnN0IGlzIGhhbmRsZWQgYnkgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0XG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIG5leHQgaXRlbSBvciBsb29wIGJhY2sgdG8gdGhlIGZpcnN0XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ICsgMSkgJSBtZW51SXRlbXMubGVuZ3RoO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgc2VsZWN0TmV4dDogSW5kZXggY2hhbmdlZCBmcm9tICR7b2xkSW5kZXh9IHRvICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgfVxuICAgIHNlbGVjdFByZXZpb3VzTWVudUl0ZW0oKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIGlmICghbWVudUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIHNlbGVjdFByZXZpb3VzOiBObyBpdGVtcyB0byBzZWxlY3QuJyk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBFbnN1cmUgaW5kZXggaXMgcmVzZXRcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRJbmRleCA9IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4O1xuICAgICAgICAvLyBEZXNlbGVjdCBjdXJyZW50IGZpcnN0IGlzIGhhbmRsZWQgYnkgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0XG4gICAgICAgIC8vIE1vdmUgdG8gdGhlIHByZXZpb3VzIGl0ZW0gb3IgbG9vcCB0byB0aGUgbGFzdFxuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IDw9IDAgP1xuICAgICAgICAgICAgbWVudUl0ZW1zLmxlbmd0aCAtIDEgOiB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCAtIDE7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBzZWxlY3RQcmV2aW91czogSW5kZXggY2hhbmdlZCBmcm9tICR7b2xkSW5kZXh9IHRvICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9YCk7XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhbGwgaW50ZXJhY3RpdmUgbWVudSBpdGVtc1xuICAgICAqL1xuICAgIGdldE1lbnVJdGVtcygpIHtcbiAgICAgICAgY29uc3QgaXRlbXMgPSBBcnJheS5mcm9tKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbScpKTtcbiAgICAgICAgLy8gRmlsdGVyIG91dCBub24taW50ZXJhY3RpdmUgaXRlbXMgbGlrZSBsb2FkaW5nLCBlbXB0eSwgZXJyb3JcbiAgICAgICAgcmV0dXJuIGl0ZW1zLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFjdGlvbklkID0gaXRlbS5kYXRhc2V0LmFjdGlvbklkO1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvbklkICE9PSAnbG9hZGluZycgJiYgYWN0aW9uSWQgIT09ICdlbXB0eScgJiYgYWN0aW9uSWQgIT09ICdlcnJvcic7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgcG9wdXAgcG9zaXRpb24sIGtlZXBpbmcgdGhlIGJvdHRvbSBlZGdlIGZpeGVkIGF0IHRoZSBhbmNob3IgcG9pbnRcbiAgICAgKi9cbiAgICB1cGRhdGVQb3B1cFBvc2l0aW9uKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYW5jaG9yIHBvaW50cyBhcmUgZGVmaW5lZFxuICAgICAgICBjb25zdCBhbmNob3JYID0gKF9hID0gdGhpcy5fYW5jaG9yWCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMDtcbiAgICAgICAgY29uc3QgYW5jaG9yWSA9IChfYiA9IHRoaXMuX2FuY2hvclkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgICAgIC8vIFBvc2l0aW9uIHRoZSBwb3B1cCBtZW51XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUubGVmdCA9IGAke2FuY2hvclh9cHhgO1xuICAgICAgICAvLyBTaG93IHRoZSBtZW51IHNvIHdlIGNhbiBjYWxjdWxhdGUgaXRzIGhlaWdodFxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgaGVpZ2h0IGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICBjb25zdCBtZW51SGVpZ2h0ID0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAvLyBBZGQgYSBzbWFsbCBnYXAgKDEwcHgpIGJldHdlZW4gdGhlIGJvdHRvbSBvZiB0aGUgbWVudSBhbmQgdGhlIHRyaWdnZXIgcG9pbnRcbiAgICAgICAgY29uc3QgZ2FwID0gMTA7XG4gICAgICAgIC8vIFBvc2l0aW9uIGFib3ZlIHRoZSBjdXJzb3IvYnV0dG9uIHRvIGtlZXAgYm90dG9tIGVkZ2UgYXQgdGhlIGFuY2hvciBwb2ludDpcbiAgICAgICAgLy8geSAtIGdhcCA9IGJvdHRvbSBlZGdlIG9mIHBvcHVwLCBzbyBwb3B1cCB0b3AgPSB5IC0gZ2FwIC0gbWVudUhlaWdodFxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS50b3AgPSBgJHthbmNob3JZIC0gZ2FwIC0gbWVudUhlaWdodH1weGA7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUG9zaXRpb25lZCBtZW51IGF0IGhlaWdodCAke21lbnVIZWlnaHR9cHggd2l0aCBib3R0b20gYXQgJHthbmNob3JZIC0gZ2FwfXB4YCk7XG4gICAgfVxufVxuZXhwb3J0cy5Qb3B1cE1lbnVNYW5hZ2VyID0gUG9wdXBNZW51TWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TaW1wbGVTaWRlYmFyV2lkZ2V0ID0gdm9pZCAwO1xuY29uc3Qgd2lkZ2V0c18xID0gcmVxdWlyZShcIkBsdW1pbm8vd2lkZ2V0c1wiKTtcbmNvbnN0IG1hcmtlZF8xID0gcmVxdWlyZShcIm1hcmtlZFwiKTtcbmNvbnN0IGRvbXB1cmlmeV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkb21wdXJpZnlcIikpO1xuY29uc3QgaWNvbnNfMSA9IHJlcXVpcmUoXCIuL2ljb25zXCIpO1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcbmNvbnN0IGFwaV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2FwaS1jbGllbnRcIik7XG5jb25zdCBtYXJrZG93bl9jb25maWdfMSA9IHJlcXVpcmUoXCIuL21hcmtkb3duLWNvbmZpZ1wiKTtcbmNvbnN0IHBvcHVwX21lbnVfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vcG9wdXAtbWVudS1tYW5hZ2VyXCIpO1xuLy8gQ29uZmlndXJlIG1hcmtlZCB3aXRoIG91ciBzZXR0aW5nc1xuKDAsIG1hcmtkb3duX2NvbmZpZ18xLmNvbmZpZ3VyZU1hcmtlZCkoKTtcbi8qKlxuICogTWFpbiBzaWRlYmFyIHdpZGdldCBmb3IgdGhlIEFJIGNoYXQgaW50ZXJmYWNlXG4gKi9cbmNsYXNzIFNpbXBsZVNpZGViYXJXaWRnZXQgZXh0ZW5kcyB3aWRnZXRzXzEuV2lkZ2V0IHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NNYW5hZ2VyKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSAnJztcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaGFzQXRTeW1ib2wgPSBmYWxzZTsgLy8gVHJhY2sgd2hldGhlciBAIHN5bWJvbCBpcyBwcmVzZW50IGluIGlucHV0XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEAga2V5IChmb3IgY29udGV4dCBtZW51KSAtIGNoYW5nZWQgZnJvbSBDdHJsK0BcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdAJykge1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHNob3cgbWVudSBpZiBpbnB1dCBmaWVsZCBpcyBmb2N1c2VkXG4gICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuaW5wdXRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY3Vyc29yIHBvc2l0aW9uIGluIGlucHV0IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5pbnB1dEZpZWxkLnNlbGVjdGlvblN0YXJ0IHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLmlucHV0RmllbGQudmFsdWUuc3Vic3RyaW5nKDAsIGN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uIHRvIHNob3cgbWVudVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dFJlY3QgPSB0aGlzLmlucHV0RmllbGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVIZWlnaHQgPSBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmlucHV0RmllbGQpLmxpbmVIZWlnaHQpIHx8IDIwO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3VudCBuZXdsaW5lcyBiZWZvcmUgY3Vyc29yIHRvIGRldGVybWluZSB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lc0JlZm9yZUN1cnNvciA9ICh0ZXh0QmVmb3JlQ3Vyc29yLm1hdGNoKC9cXG4vZykgfHwgW10pLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIGN1cnNvciBwb3NpdGlvbiB3aXRoaW4gY3VycmVudCBsaW5lXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhc3ROZXdsaW5lID0gdGV4dEJlZm9yZUN1cnNvci5sYXN0SW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXJzSW5DdXJyZW50TGluZSA9IGxhc3ROZXdsaW5lID09PSAtMSA/IGN1cnNvclBvc2l0aW9uIDogY3Vyc29yUG9zaXRpb24gLSBsYXN0TmV3bGluZSAtIDE7XG4gICAgICAgICAgICAgICAgICAgIC8vIEVzdGltYXRlIGhvcml6b250YWwgcG9zaXRpb24gKHVzaW5nIGF2ZXJhZ2UgY2hhcmFjdGVyIHdpZHRoKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyV2lkdGggPSA4OyAvLyBBcHByb3hpbWF0ZSB3aWR0aCBvZiBhIGNoYXJhY3RlciBpbiBwaXhlbHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaG9yaXpvbnRhbE9mZnNldCA9IGNoYXJzSW5DdXJyZW50TGluZSAqIGNoYXJXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHBvc2l0aW9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWZ0ID0gaW5wdXRSZWN0LmxlZnQgKyBob3Jpem9udGFsT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGN1cnNvcidzIHZlcnRpY2FsIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvclRvcCA9IGlucHV0UmVjdC50b3AgKyAobGluZXNCZWZvcmVDdXJzb3IgKiBsaW5lSGVpZ2h0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFNob3dpbmcgcG9wdXAgYXQgY3Vyc29yIHBvc2l0aW9uOiAoJHtsZWZ0fSwgJHtjdXJzb3JUb3B9KWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBJbnNlcnQgQCBzeW1ib2wgYXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlLnN1YnN0cmluZygwLCBjdXJzb3JQb3NpdGlvbikgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ0AnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZS5zdWJzdHJpbmcoY3Vyc29yUG9zaXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGhhcyBAIHN5bWJvbCBmbGFnXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFzQXRTeW1ib2wgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIGN1cnNvciBhZnRlciB0aGUgQCBzeW1ib2xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNlbGVjdGlvblN0YXJ0ID0gY3Vyc29yUG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc2VsZWN0aW9uRW5kID0gY3Vyc29yUG9zaXRpb24gKyAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHRoZSBwb3B1cCBtZW51IGFib3ZlIHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUobGVmdCArIDYwLCBjdXJzb3JUb3AgLSAyMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IoJ0Jyb3dzZSBjZWxscywgY29kZSwgZmlsZXMsIGFuZCBtb3JlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIEN0cmwrTCAoZm9yIHNlbGVjdGVkIGNvZGUpXG4gICAgICAgICAgICBlbHNlIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50LmtleS50b0xvd2VyQ2FzZSgpID09PSAnbCcpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjZWxsXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgQ29kZU1pcnJvciBlZGl0b3IgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGVyZSdzIGEgc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5tYWluLmVtcHR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGVyZSdzIGEgc2VsZWN0aW9uLCB1c2UgQGNvZGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyb20gPSBzZWxlY3Rpb24ubWFpbi5mcm9tO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG8gPSBzZWxlY3Rpb24ubWFpbi50bztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGVkVGV4dCA9IHN0YXRlLmRvYy5zbGljZVN0cmluZyhmcm9tLCB0byk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjb2RlICR7c2VsZWN0ZWRUZXh0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignU2VsZWN0ZWQgY29kZSBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gc2VsZWN0aW9uLCB1c2UgQGNlbGxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZ2V0Q3VycmVudENlbGxDb250ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcGVuZFRvSW5wdXQoYEBjZWxsICR7Y2VsbENvbnRleHQudGV4dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dLZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKCdDZWxsIGNvbnRlbnQgaW5zZXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIHNpZGViYXIgaXMgdmlzaWJsZSBhbmQgZm9jdXNlZFxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0hpZGRlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoYW5kbGluZyBrZXlib2FyZCBzaG9ydGN1dDonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRvY01hbmFnZXIgPSBkb2NNYW5hZ2VyO1xuICAgICAgICB0aGlzLmlkID0gJ3NpbXBsZS1zaWRlYmFyJztcbiAgICAgICAgdGhpcy50aXRsZS5sYWJlbCA9ICcnO1xuICAgICAgICB0aGlzLnRpdGxlLmNhcHRpb24gPSAnQUkgQ2hhdCBJbnRlcmZhY2UnO1xuICAgICAgICB0aGlzLnRpdGxlLmljb24gPSBpY29uc18xLmV4dGVuc2lvbkljb247XG4gICAgICAgIHRoaXMudGl0bGUuY2xvc2FibGUgPSB0cnVlO1xuICAgICAgICAvLyBBZGQgdGhlIG1haW4gQ1NTIGNsYXNzIGZvciBzdHlsaW5nXG4gICAgICAgIHRoaXMuYWRkQ2xhc3MoJ2pwLWxsbS1leHQtc2lkZWJhcicpO1xuICAgICAgICAvLyBJbml0aWFsaXplIEFQSSBjbGllbnRcbiAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgYXBpX2NsaWVudF8xLkFwaUNsaWVudCgpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNvbnRhaW5lciBlbGVtZW50cyBiZWZvcmUgY3JlYXRpbmcgbGF5b3V0XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1rZXlib2FyZC1zaG9ydGN1dC1pbmRpY2F0b3InO1xuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgLy8gQ3JlYXRlIHNldHRpbmdzIG1vZGFsXG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciA9IHRoaXMuY3JlYXRlU2V0dGluZ3NNb2RhbCgpO1xuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyKTtcbiAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIFBvcHVwTWVudU1hbmFnZXIgd2l0aCBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyID0gbmV3IHBvcHVwX21lbnVfbWFuYWdlcl8xLlBvcHVwTWVudU1hbmFnZXIodGhpcy5kb2NNYW5hZ2VyLCB0aGlzLm5vZGUsIHtcbiAgICAgICAgICAgIGluc2VydENvZGU6IChjb2RlKSA9PiB0aGlzLmFwcGVuZFRvSW5wdXQoYGNvZGUgJHtjb2RlfWApLFxuICAgICAgICAgICAgaW5zZXJ0Q2VsbDogKGNvbnRlbnQpID0+IHRoaXMuYXBwZW5kVG9JbnB1dChgY2VsbCAke2NvbnRlbnR9YCksXG4gICAgICAgICAgICBpbnNlcnRGaWxlUGF0aDogKHBhdGgpID0+IHRoaXMuYXBwZW5kVG9JbnB1dChgZmlsZSAke3BhdGh9YCksXG4gICAgICAgICAgICBpbnNlcnREaXJlY3RvcnlQYXRoOiAocGF0aCkgPT4gdGhpcy5hcHBlbmRUb0lucHV0KGBkaXJlY3RvcnkgJHtwYXRofWApLCAvLyBJZiBuZWVkZWRcbiAgICAgICAgICAgIGdldFNlbGVjdGVkVGV4dDogKCkgPT4gdGhpcy5nZXRTZWxlY3RlZFRleHQoKSxcbiAgICAgICAgICAgIGdldEN1cnJlbnRDZWxsQ29udGVudDogKCkgPT4gdGhpcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQoKSxcbiAgICAgICAgICAgIGluc2VydENlbGxCeUluZGV4OiAoaW5kZXgpID0+IHRoaXMuaW5zZXJ0Q2VsbEJ5SW5kZXgoaW5kZXgpXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2hhdCBvbiBzdGFydFxuICAgICAgICB0aGlzLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuY3JlYXRlTGF5b3V0KCkpO1xuICAgICAgICAvLyBQb3AtdXAgbWVudSB3aWxsIGJlIGF0dGFjaGVkIHRvIGRvY3VtZW50LmJvZHkgd2hlbiBzaG93blxuICAgICAgICAvLyBBZGQga2V5Ym9hcmQgc2hvcnRjdXQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgdmlzdWFsIGluZGljYXRvciBmb3Iga2V5Ym9hcmQgc2hvcnRjdXRzXG4gICAgICovXG4gICAgc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IodGV4dCkge1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyBIaWRlIGFmdGVyIDEgc2Vjb25kXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyBSZW1vdmUga2V5Ym9hcmQgc2hvcnRjdXQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIC8vIFJlbW92ZSBrZXlib2FyZCBzaG9ydGN1dCBpbmRpY2F0b3JcbiAgICAgICAgaWYgKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2UgdGhlIHBvcHVwIG1lbnUgbWFuYWdlclxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVNYW5hZ2VyKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgbWFpbiBsYXlvdXQgZm9yIHRoZSBzaWRlYmFyXG4gICAgICovXG4gICAgY3JlYXRlTGF5b3V0KCkge1xuICAgICAgICAvLyBDcmVhdGUgdGhlIG1haW4gY29udGFpbmVyXG4gICAgICAgIGNvbnN0IG1haW5Db250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIFRoZSBtYWluIGNsYXNzICdqcC1sbG0tZXh0LXNpZGViYXInIGlzIGFkZGVkIHRvIHRoaXMubm9kZSBpbiB0aGUgY29uc3RydWN0b3JcbiAgICAgICAgLy8gVGhpcyBjb250YWluZXIgY2FuIGhhdmUgaXRzIG93biBjbGFzcyBpZiBuZWVkZWQgZm9yIGZ1cnRoZXIgbmVzdGluZy9zdHlsaW5nXG4gICAgICAgIG1haW5Db250ZW50LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbnRlbnQtd3JhcHBlcic7XG4gICAgICAgIC8vIENyZWF0ZSB0aXRsZSBpbnB1dCBjb250YWluZXJcbiAgICAgICAgY29uc3QgdGl0bGVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdGl0bGUtY29udGFpbmVyJztcbiAgICAgICAgLy8gU2V0IHVwIHRpdGxlIGlucHV0XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5jbGFzc05hbWUgPSAnY2hhdC10aXRsZS1pbnB1dCc7IC8vIEFzc3VtaW5nIHRoaXMgaXMgc3R5bGVkIGNvcnJlY3RseSBpbiBDU1NcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5wbGFjZWhvbGRlciA9ICdDaGF0IHRpdGxlJztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnZhbHVlID0gJ05ldyBDaGF0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsICgpID0+IHRoaXMudXBkYXRlQ3VycmVudENoYXRUaXRsZSgpKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZUlucHV0KTtcbiAgICAgICAgLy8gQ3JlYXRlIE5ldyBDaGF0ICYgSGlzdG9yeSBidXR0b25zXG4gICAgICAgIGNvbnN0IG5ld0NoYXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIG5ld0NoYXRCdXR0b24udGV4dENvbnRlbnQgPSAnKyBOZXcgQ2hhdCc7XG4gICAgICAgIG5ld0NoYXRCdXR0b24udGl0bGUgPSAnU3RhcnQgYSBuZXcgY2hhdCc7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmNyZWF0ZU5ld0NoYXQoKSk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGhpc3RvcnlCdXR0b24udGV4dENvbnRlbnQgPSAnSGlzdG9yeSc7XG4gICAgICAgIGhpc3RvcnlCdXR0b24udGl0bGUgPSAnVmlldyBjaGF0IGhpc3RvcnknO1xuICAgICAgICBoaXN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy50b2dnbGVIaXN0b3J5VmlldygpKTtcbiAgICAgICAgLy8gQ29uZmlndXJlIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1jb250YWluZXInO1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gQ29uZmlndXJlIGlucHV0IGZpZWxkIChkaXJlY3RseSB1c2VkIGxhdGVyKVxuICAgICAgICB0aGlzLmlucHV0RmllbGQucGxhY2Vob2xkZXIgPSAnQXNrIG1lIGFueXRoaW5nLi4uJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJvd3MgPSAxO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtZmllbGQnOyAvLyBBZGQgY2xhc3MgZm9yIHN0eWxpbmdcbiAgICAgICAgLy8gQWRkIGtleXByZXNzIGxpc3RlbmVyIHRvIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEFkZCBpbnB1dCBldmVudCBsaXN0ZW5lciB0byBkZXRlY3QgY2hhbmdlcyB0byB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIEAgc3ltYm9sIGhhcyBiZWVuIHJlbW92ZWRcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5pbnB1dEZpZWxkLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgY29uc3QgdGV4dEJlZm9yZUN1cnNvciA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZS5zbGljZSgwLCBjdXJzb3JQb3NpdGlvbik7XG4gICAgICAgICAgICBjb25zdCBoYXNBdE5vdyA9IHRleHRCZWZvcmVDdXJzb3IuZW5kc1dpdGgoJ0AnKSAmJlxuICAgICAgICAgICAgICAgIChjdXJzb3JQb3NpdGlvbiA9PT0gMSB8fCAvLyBAIGlzIGF0IHN0YXJ0IG9mIGlucHV0XG4gICAgICAgICAgICAgICAgICAgICEhdGV4dEJlZm9yZUN1cnNvcltjdXJzb3JQb3NpdGlvbiAtIDJdLm1hdGNoKC9cXHMvKSk7IC8vIEAgZm9sbG93cyB3aGl0ZXNwYWNlXG4gICAgICAgICAgICBpZiAodGhpcy5oYXNBdFN5bWJvbCAmJiAhaGFzQXROb3cpIHtcbiAgICAgICAgICAgICAgICAvLyBAIHN5bWJvbCB3YXMgcHJlc2VudCBidXQgbm93IGl0J3MgZ29uZSwgaGlkZSB0aGUgcG9wdXBcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGhhc0F0Tm93O1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIHNlbmQgYnV0dG9uIGNvbnRhaW5lciAoZGlyZWN0bHkgdXNlZCBsYXRlcilcbiAgICAgICAgY29uc3QgaW5wdXRBY3Rpb25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGlucHV0QWN0aW9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbnB1dC1hY3Rpb25zLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSBzZW5kIGJ1dHRvblxuICAgICAgICBjb25zdCBzZW5kQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNlbmRCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LXNlbmQtYnV0dG9uJztcbiAgICAgICAgc2VuZEJ1dHRvbi50ZXh0Q29udGVudCA9ICdTZW5kJztcbiAgICAgICAgc2VuZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2UoKSk7XG4gICAgICAgIGlucHV0QWN0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZW5kQnV0dG9uKTtcbiAgICAgICAgLy8gQ3JlYXRlIGNvbnRyb2xzIGNvbnRhaW5lciAoTWFya2Rvd24gdG9nZ2xlLCBALCBldGMuKSAoZGlyZWN0bHkgdXNlZCBsYXRlcilcbiAgICAgICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSB0aGlzLmNyZWF0ZUNvbnRyb2xzQ29udGFpbmVyKCk7XG4gICAgICAgIC8vIENyZWF0ZSB0aGUgbmV3IGJvdHRvbSBiYXIgY29udGFpbmVyIHdpdGggdGhyZWUgcm93c1xuICAgICAgICBjb25zdCBib3R0b21CYXJDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYm90dG9tQmFyQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIgPSBib3R0b21CYXJDb250YWluZXI7XG4gICAgICAgIC8vIEZpcnN0IHJvdzogQ29udHJvbHMgKE1hcmtkb3duIHRvZ2dsZSBhbmQgYWN0aW9uIGJ1dHRvbnMpXG4gICAgICAgIGNvbnN0IHRvcFJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b3BSb3cuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYm90dG9tLWJhci1yb3cganAtbGxtLWV4dC1jb250cm9scy1yb3cnO1xuICAgICAgICB0b3BSb3cuYXBwZW5kQ2hpbGQoY29udHJvbHNDb250YWluZXIpO1xuICAgICAgICAvLyBTZWNvbmQgcm93OiBJbnB1dCBmaWVsZFxuICAgICAgICBjb25zdCBtaWRkbGVSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWlkZGxlUm93LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtaW5wdXQtcm93JztcbiAgICAgICAgbWlkZGxlUm93LmFwcGVuZENoaWxkKHRoaXMuaW5wdXRGaWVsZCk7XG4gICAgICAgIC8vIFRoaXJkIHJvdzogQWN0aW9uIGJ1dHRvbnMgKFNlbmQsIE5ldyBDaGF0LCBIaXN0b3J5KVxuICAgICAgICBjb25zdCBib3R0b21Sb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYm90dG9tUm93LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtYnV0dG9ucy1yb3cnO1xuICAgICAgICAvLyBBZGQgYWxsIGJ1dHRvbnMgdG8gYm90dG9tIHJvd1xuICAgICAgICBib3R0b21Sb3cuYXBwZW5kQ2hpbGQoc2VuZEJ1dHRvbik7XG4gICAgICAgIGJvdHRvbVJvdy5hcHBlbmRDaGlsZChuZXdDaGF0QnV0dG9uKTtcbiAgICAgICAgYm90dG9tUm93LmFwcGVuZENoaWxkKGhpc3RvcnlCdXR0b24pO1xuICAgICAgICAvLyBBZGQgYWxsIHJvd3MgdG8gdGhlIGJvdHRvbSBiYXIgY29udGFpbmVyXG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b3BSb3cpO1xuICAgICAgICBib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQobWlkZGxlUm93KTtcbiAgICAgICAgYm90dG9tQmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGJvdHRvbVJvdyk7XG4gICAgICAgIC8vIEFzc2VtYmxlIGFsbCBtYWluIGNvbXBvbmVudHNcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGl0bGVDb250YWluZXIpO1xuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VDb250YWluZXIpO1xuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmhpc3RvcnlDb250YWluZXIpO1xuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZChib3R0b21CYXJDb250YWluZXIpO1xuICAgICAgICByZXR1cm4gbWFpbkNvbnRlbnQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uXG4gICAgICovXG4gICAgY3JlYXRlTmV3Q2hhdCgpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoZSBjaGF0XG4gICAgICAgIGNvbnN0IGNoYXRJZCA9IGBjaGF0LSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2hhdCBpdGVtXG4gICAgICAgIGNvbnN0IG5ld0NoYXQgPSB7XG4gICAgICAgICAgICBpZDogY2hhdElkLFxuICAgICAgICAgICAgdGl0bGU6ICdOZXcgQ2hhdCcsXG4gICAgICAgICAgICBtZXNzYWdlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIHRvIGhpc3RvcnlcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeS5wdXNoKG5ld0NoYXQpO1xuICAgICAgICAvLyBTZXQgYXMgY3VycmVudCBjaGF0XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9IGNoYXRJZDtcbiAgICAgICAgLy8gVXBkYXRlIHRpdGxlIGlucHV0XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC52YWx1ZSA9IG5ld0NoYXQudGl0bGU7XG4gICAgICAgIC8vIENsZWFyIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgfVxuICAgICAgICAvLyBIaWRlIGhpc3RvcnkgaWYgaXQncyB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSGlzdG9yeVZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGJldHdlZW4gY2hhdCB2aWV3IGFuZCBoaXN0b3J5IHZpZXdcbiAgICAgKi9cbiAgICB0b2dnbGVIaXN0b3J5VmlldygpIHtcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gIXRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZTtcbiAgICAgICAgaWYgKHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSkge1xuICAgICAgICAgICAgLy8gU2hvdyBoaXN0b3J5IHZpZXcsIGhpZGUgbWVzc2FnZSB2aWV3IGFuZCBib3R0b20gYmFyXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIFVzZSBjbGFzcyBwcm9wZXJ0eSBkaXJlY3RseVxuICAgICAgICAgICAgdGhpcy50aXRsZUlucHV0LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAvLyBQb3B1bGF0ZSBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoYXRIaXN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTaG93IG1lc3NhZ2UgdmlldyBhbmQgYm90dG9tIGJhciwgaGlkZSBoaXN0b3J5IHZpZXdcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgLy8gVXNlIGNsYXNzIHByb3BlcnR5IGRpcmVjdGx5XG4gICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXQuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2hhdCBoaXN0b3J5IGluIHRoZSBoaXN0b3J5IGNvbnRhaW5lclxuICAgICAqL1xuICAgIHJlbmRlckNoYXRIaXN0b3J5KCkge1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGlmICh0aGlzLmNoYXRIaXN0b3J5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlNZXNzYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtZW1wdHktaGlzdG9yeS1tZXNzYWdlJztcbiAgICAgICAgICAgIGVtcHR5TWVzc2FnZS50ZXh0Q29udGVudCA9ICdObyBjaGF0IGhpc3RvcnkgeWV0JztcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eU1lc3NhZ2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgY2hhdCBoaXN0b3J5IGl0ZW1zXG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkuZm9yRWFjaChjaGF0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGhpc3RvcnlJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWl0ZW0nO1xuICAgICAgICAgICAgaWYgKGNoYXQuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCkge1xuICAgICAgICAgICAgICAgIGhpc3RvcnlJdGVtLmNsYXNzTGlzdC5hZGQoJ2pwLWxsbS1leHQtYWN0aXZlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdGl0bGVcbiAgICAgICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICB0aXRsZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LXRpdGxlJztcbiAgICAgICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gY2hhdC50aXRsZTtcbiAgICAgICAgICAgIC8vIEFkZCBtZXNzYWdlIHByZXZpZXdcbiAgICAgICAgICAgIGNvbnN0IHByZXZpZXcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHByZXZpZXcuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1wcmV2aWV3JztcbiAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gY2hhdC5tZXNzYWdlc1tjaGF0Lm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcHJldmlldy50ZXh0Q29udGVudCA9IGxhc3RNZXNzYWdlXG4gICAgICAgICAgICAgICAgPyBgJHtsYXN0TWVzc2FnZS50ZXh0LnN1YnN0cmluZygwLCA0MCl9JHtsYXN0TWVzc2FnZS50ZXh0Lmxlbmd0aCA+IDQwID8gJy4uLicgOiAnJ31gXG4gICAgICAgICAgICAgICAgOiAnRW1wdHkgY2hhdCc7XG4gICAgICAgICAgICAvLyBBZGQgY2xpY2sgZXZlbnRcbiAgICAgICAgICAgIGhpc3RvcnlJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5sb2FkQ2hhdChjaGF0LmlkKSk7XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS5hcHBlbmRDaGlsZChwcmV2aWV3KTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5hcHBlbmRDaGlsZChoaXN0b3J5SXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGNoYXQgZnJvbSBoaXN0b3J5XG4gICAgICovXG4gICAgbG9hZENoYXQoY2hhdElkKSB7XG4gICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSBjaGF0SWQpO1xuICAgICAgICBpZiAoIWNoYXQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFNldCBhcyBjdXJyZW50IGNoYXRcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhdElkID0gY2hhdElkO1xuICAgICAgICAvLyBVcGRhdGUgdGl0bGVcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnZhbHVlID0gY2hhdC50aXRsZTtcbiAgICAgICAgLy8gQ2xlYXIgYW5kIHJlLXBvcHVsYXRlIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY2hhdC5tZXNzYWdlcy5mb3JFYWNoKG1zZyA9PiB7XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobXNnLnRleHQsIG1zZy5zZW5kZXIsIG1zZy5pc01hcmtkb3duLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBTd2l0Y2ggYmFjayB0byBjaGF0IHZpZXdcbiAgICAgICAgaWYgKHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVIaXN0b3J5VmlldygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHRpdGxlIG9mIHRoZSBjdXJyZW50IGNoYXRcbiAgICAgKi9cbiAgICB1cGRhdGVDdXJyZW50Q2hhdFRpdGxlKCkge1xuICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgaWYgKGNoYXQpIHtcbiAgICAgICAgICAgIGNoYXQudGl0bGUgPSB0aGlzLnRpdGxlSW5wdXQudmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgY29udHJvbHMgY29udGFpbmVyIHdpdGggdG9nZ2xlcyBhbmQgYWN0aW9uIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBjcmVhdGVDb250cm9sc0NvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29udHJvbHMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtkb3duIHRvZ2dsZSBjb250YWluZXJcbiAgICAgICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10b2dnbGUtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtkb3duIHRvZ2dsZVxuICAgICAgICBjb25zdCBtYXJrZG93blRvZ2dsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIG1hcmtkb3duVG9nZ2xlLnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICBtYXJrZG93blRvZ2dsZS5pZCA9ICdtYXJrZG93bi10b2dnbGUnO1xuICAgICAgICAvLyBtYXJrZG93blRvZ2dsZS5zdHlsZS5tYXJnaW5SaWdodCA9ICc1cHgnOyAvLyBTdHlsZSB2aWEgQ1NTXG4gICAgICAgIG1hcmtkb3duVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5wbGFjZWhvbGRlciA9IHRoaXMuaXNNYXJrZG93bk1vZGUgP1xuICAgICAgICAgICAgICAgICdXcml0ZSBtYXJrZG93biBoZXJlLi4uXFxuXFxuIyBFeGFtcGxlIGhlYWRpbmdcXG4tIExpc3QgaXRlbVxcblxcbmBgYGNvZGUgYmxvY2tgYGAnIDpcbiAgICAgICAgICAgICAgICAnQXNrIG1lIGFueXRoaW5nLi4uJztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSB0b2dnbGUgbGFiZWxcbiAgICAgICAgY29uc3QgdG9nZ2xlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICB0b2dnbGVMYWJlbC5odG1sRm9yID0gJ21hcmtkb3duLXRvZ2dsZSc7XG4gICAgICAgIHRvZ2dsZUxhYmVsLnRleHRDb250ZW50ID0gJ01hcmtkb3duIG1vZGUnO1xuICAgICAgICAvLyB0b2dnbGVMYWJlbC5zdHlsZS5mb250U2l6ZSA9ICcxMnB4JzsgLy8gU3R5bGUgdmlhIENTU1xuICAgICAgICAvLyBBZGQgdG9nZ2xlIGVsZW1lbnRzIHRvIGNvbnRhaW5lclxuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQobWFya2Rvd25Ub2dnbGUpO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlTGFiZWwpO1xuICAgICAgICAvLyBDcmVhdGUgYWN0aW9uIGJ1dHRvbnMgY29udGFpbmVyIChALCBleHBhbmQsIHNldHRpbmdzKVxuICAgICAgICBjb25zdCBhY3Rpb25CdXR0b25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFjdGlvbkJ1dHRvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbnMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBhY3Rpb24gYnV0dG9uc1xuICAgICAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdAJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0Jyb3dzZSBjZWxscywgY29kZSwgZmlsZXMsIGFuZCBtb3JlJyxcbiAgICAgICAgICAgICAgICBhY3Rpb246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJ1dHRvbidzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHBvcHVwIG1lbnUgYWJvdmUgdGhlIGJ1dHRvbidzIHRvcCBlZGdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KHJlY3QubGVmdCArIDYwLCByZWN0LnRvcCAtIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdGV4dDogJ+KkoicsIHRpdGxlOiAnRXhwYW5kIGlucHV0JywgYWN0aW9uOiAoKSA9PiB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKGFjdGlvbkJ1dHRvbnNDb250YWluZXIuY2hpbGRyZW5bM10pIH0sXG4gICAgICAgICAgICB7IHRleHQ6ICfimpnvuI8nLCB0aXRsZTogJ1NldHRpbmdzJywgYWN0aW9uOiAoZXZlbnQpID0+IHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IHRoaXMuc2hvd1NldHRpbmdzTW9kYWwoKTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICAvLyBBZGQgYWxsIGJ1dHRvbnMgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ0biA9IHRoaXMuY3JlYXRlQnV0dG9uKGJ1dHRvbi50ZXh0LCBidXR0b24udGl0bGUpO1xuICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IGJ1dHRvbi5hY3Rpb24oZSkpO1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRvZ2dsZSBhbmQgYWN0aW9uIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2xzIGNvbnRhaW5lclxuICAgICAgICAvLyBjb250cm9sc0NvbnRhaW5lciBpcyBub3cganVzdCBmb3IgdGhlc2UgaW5saW5lIGNvbnRyb2xzLCBhYm92ZSB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlQ29udGFpbmVyKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQoYWN0aW9uQnV0dG9uc0NvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250cm9sc0NvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIHRvZ2dsZUlucHV0RXhwYW5zaW9uKGJ1dHRvbikge1xuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9ICF0aGlzLmlzSW5wdXRFeHBhbmRlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgaGVpZ2h0IGJhc2VkIG9uIGEgY2xhc3Mgb3IgQ1NTIHZhcmlhYmxlIGluc3RlYWQgb2YgZml4ZWQgcGl4ZWxzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5yZXNpemUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gJ+KkoSc7XG4gICAgICAgICAgICBidXR0b24udGl0bGUgPSAnQ29sbGFwc2UgaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcnOyAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5yZXNpemUgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucm93cyA9IDE7IC8vIEVuc3VyZSBpdCBjb2xsYXBzZXMgYmFjayB0byAxIHJvdyBoZWlnaHRcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKInO1xuICAgICAgICAgICAgYnV0dG9uLnRpdGxlID0gJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGJ1dHRvbiB3aXRoIGdpdmVuIHRleHQgYW5kIHRvb2x0aXBcbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b24odGV4dCwgdG9vbHRpcCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzZW5kaW5nIGEgbWVzc2FnZSBmcm9tIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIEFkZCB1c2VyIG1lc3NhZ2UgdG8gVUlcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlLCAndXNlcicsIHRoaXMuaXNNYXJrZG93bk1vZGUpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gJyc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucm93cyA9IDE7IC8vIFJlc2V0IHJvd3MgYWZ0ZXIgc2VuZGluZ1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcnOyAvLyBSZXNldCBoZWlnaHQgYWZ0ZXIgc2VuZGluZ1xuICAgICAgICAgICAgLy8gUmVzZXQgZXhwYW5kZWQgc3RhdGUgaWYgbmVlZGVkIGFmdGVyIHNlbmRpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGV4cGFuZCBidXR0b24gdG8gcmVzZXQgaXRzIHN0YXRlIGlmIG5lZWRlZCAodGhpcyBtaWdodCBuZWVkIGFkanVzdG1lbnQgYmFzZWQgb24gZmluYWwgc3RydWN0dXJlKVxuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGFuZEJ1dHRvbiA9IHRoaXMubm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1hY3Rpb24tYnV0dG9ucy1jb250YWluZXIgYnV0dG9uW3RpdGxlKj1cIkNvbGxhcHNlXCJdJyk7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKGV4cGFuZEJ1dHRvbik7IC8vIENvbGxhcHNlIGFmdGVyIHNlbmRpbmdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnJzsgLy8gRmFsbGJhY2sgcmVzZXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJvd3MgPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBtZXNzYWdlIGNvbnRhaW5lciBmb3IgdGhlIGJvdCdzIHN0cmVhbWluZyByZXNwb25zZVxuICAgICAgICAgICAgY29uc3QgYm90TWVzc2FnZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3QtbWVzc2FnZSc7XG4gICAgICAgICAgICBjb25zdCBtYXJrZG93bkluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IudGV4dENvbnRlbnQgPSBcIk1EXCI7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci5jbGFzc05hbWUgPSAnbWFya2Rvd24taW5kaWNhdG9yJztcbiAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNlcGFyYXRlIGRpdnMgZm9yIHN0cmVhbWluZyB0ZXh0IGFuZCBmaW5hbCBtYXJrZG93blxuICAgICAgICAgICAgY29uc3Qgc3RyZWFtaW5nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYuY2xhc3NOYW1lID0gJ3N0cmVhbWluZy1jb250ZW50JztcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS53aGl0ZVNwYWNlID0gJ3ByZS13cmFwJztcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5mb250RmFtaWx5ID0gJ21vbm9zcGFjZSc7XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZm9udFNpemUgPSAnMC45ZW0nO1xuICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChzdHJlYW1pbmdEaXYpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGVudERpdi5jbGFzc05hbWUgPSAnbWFya2Rvd24tY29udGVudCc7XG4gICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoYm90TWVzc2FnZURpdik7XG4gICAgICAgICAgICAvLyBWYXJpYWJsZSB0byBjb2xsZWN0IHRoZSBjb21wbGV0ZSByZXNwb25zZVxuICAgICAgICAgICAgbGV0IGNvbXBsZXRlUmVzcG9uc2UgPSAnJztcbiAgICAgICAgICAgIC8vIEdldCBjZWxsIGNvbnRleHQgaWYgYXZhaWxhYmxlXG4gICAgICAgICAgICBjb25zdCBjZWxsQ29udGV4dCA9IGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlciA/XG4gICAgICAgICAgICAgICAgZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyLmdldEN1cnJlbnRDZWxsQ29udGV4dCgpIDogbnVsbDtcbiAgICAgICAgICAgIC8vIFN0cmVhbSByZXNwb25zZSBmcm9tIEFQSVxuICAgICAgICAgICAgdGhpcy5hcGlDbGllbnQuc3RyZWFtQ2hhdChtZXNzYWdlLCB7IGNlbGxDb250ZXh0IH0sIFxuICAgICAgICAgICAgLy8gT24gZWFjaCBjaHVuayByZWNlaXZlZFxuICAgICAgICAgICAgKGNodW5rKSA9PiB7XG4gICAgICAgICAgICAgICAgY29tcGxldGVSZXNwb25zZSArPSBjaHVuaztcbiAgICAgICAgICAgICAgICBzdHJlYW1pbmdEaXYudGV4dENvbnRlbnQgPSBjb21wbGV0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBPbiBjb21wbGV0ZVxuICAgICAgICAgICAgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEhpZGUgc3RyZWFtaW5nIGRpdiwgc2hvdyBtYXJrZG93biBkaXZcbiAgICAgICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIC8vIFByZS1wcm9jZXNzIGFuZCByZW5kZXIgbWFya2Rvd25cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmUtcHJvY2VzcyB0aGUgbWFya2Rvd24gdG8gZml4IGFueSBpc3N1ZXMgd2l0aCBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRNYXJrZG93biA9ICgwLCBtYXJrZG93bl9jb25maWdfMS5wcmVwcm9jZXNzTWFya2Rvd24pKGNvbXBsZXRlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQYXJzZSBhbmQgc2FuaXRpemVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRNYXJrZG93bik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBseSB0aGUgSFRNTCB3aXRoIHByb3BlciBjb2RlIGJsb2NrIHN0eWxpbmdcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgc3ludGF4IGhpZ2hsaWdodGluZyBjbGFzc2VzIHRvIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVCbG9ja3MgPSBjb250ZW50RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVCbG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZFRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIChfYSA9IGJsb2NrLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZEhUTUxDb21tb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyB0byB0aGUgYm90IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBhY3Rpb24gYnV0dG9ucyB0byBzdHJlYW1lZCBib3QgbWVzc2FnZScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb25zJztcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOyAvLyBFbnN1cmUgZGlzcGxheSBpcyBzZXRcbiAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLnRpdGxlID0gJ0NvcHkgbWVzc2FnZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29weU1lc3NhZ2VUb0NsaXBib2FyZChjb21wbGV0ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZFRvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlwiPjwvcGF0aD48cmVjdCB4PVwiOFwiIHk9XCIyXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMVwiIHJ5PVwiMVwiPjwvcmVjdD48cGF0aCBkPVwiTTEyIDExdjZcIj48L3BhdGg+PHBhdGggZD1cIk05IDE0aDZcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24udGl0bGUgPSAnQWRkIG1lc3NhZ2UgdG8gY3VycmVudCBjZWxsJztcbiAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlVG9DZWxsKGNvbXBsZXRlUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRUb0J1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBidXR0b25zIHRvIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FjdGlvbiBidXR0b25zIGFkZGVkIHRvIGJvdCBtZXNzYWdlOicsIGFjdGlvbnNEaXYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERpdi50ZXh0Q29udGVudCA9IGNvbXBsZXRlUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBTYXZlIHRvIGNoYXQgaGlzdG9yeVxuICAgICAgICAgICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgICAgICAgICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNoYXQubWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb21wbGV0ZVJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VuZGVyOiAnYm90JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTWFya2Rvd246IHRydWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyBPbiBlcnJvclxuICAgICAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiZXJyb3ItbWVzc2FnZVwiPkVycm9yOiAke2Vycm9yLm1lc3NhZ2V9PC9kaXY+YDtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgRXJyb3I6JywgZXJyb3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1lc3NhZ2UgdG8gdGhlIGNoYXQgaW50ZXJmYWNlXG4gICAgICovXG4gICAgYWRkTWVzc2FnZSh0ZXh0LCBzZW5kZXIsIGlzTWFya2Rvd24gPSBmYWxzZSwgc2F2ZVRvSGlzdG9yeSA9IHRydWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ0FkZGluZyBtZXNzYWdlOicsIHsgc2VuZGVyLCBpc01hcmtkb3duIH0pOyAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgY29uc3QgbWVzc2FnZURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtZXNzYWdlRGl2LmNsYXNzTmFtZSA9IHNlbmRlciA9PT0gJ3VzZXInID8gJ2pwLWxsbS1leHQtdXNlci1tZXNzYWdlJyA6ICdqcC1sbG0tZXh0LWJvdC1tZXNzYWdlJztcbiAgICAgICAgLy8gQWRkIG1lc3NhZ2UgY29udGVudFxuICAgICAgICBpZiAoaXNNYXJrZG93biB8fCBzZW5kZXIgPT09ICdib3QnKSB7XG4gICAgICAgICAgICAvLyBCb3QgbWVzc2FnZXMgYXJlIGFsd2F5cyByZW5kZXJlZCBhcyBtYXJrZG93blxuICAgICAgICAgICAgY29uc3QgbWFya2Rvd25JbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLnRleHRDb250ZW50ID0gXCJNRFwiO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IuY2xhc3NOYW1lID0gJ21hcmtkb3duLWluZGljYXRvcic7XG4gICAgICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKG1hcmtkb3duSW5kaWNhdG9yKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhlIHJlbmRlcmVkIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gUHJlLXByb2Nlc3MgdGhlIG1hcmtkb3duIHRleHRcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRUZXh0ID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikodGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgYW5kIHJlbmRlciBtYXJrZG93blxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBzeW50YXggaGlnaGxpZ2h0aW5nIGNsYXNzZXMgdG8gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgICAgIGNvZGVCbG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suY2xhc3NMaXN0LmFkZCgnanAtUmVuZGVyZWRUZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGJsb2NrLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZEhUTUxDb21tb24nKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgYm90IG1lc3NhZ2VzXG4gICAgICAgICAgICBpZiAoc2VuZGVyID09PSAnYm90Jykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgYWN0aW9uIGJ1dHRvbnMgdG8gYm90IG1lc3NhZ2UnKTsgLy8gRGVidWcgbG9nXG4gICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb25zJztcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGJ1dHRvbiB3aXRoIGljb25cbiAgICAgICAgICAgICAgICBjb25zdCBjb3B5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgY29weUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgY29weUJ1dHRvbi50aXRsZSA9ICdDb3B5IG1lc3NhZ2UgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQodGV4dCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChjb3B5QnV0dG9uKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgdG8gYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZFRvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24udGl0bGUgPSAnQWRkIG1lc3NhZ2UgdG8gY3VycmVudCBjZWxsJztcbiAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlVG9DZWxsKHRleHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoYWRkVG9CdXR0b24pO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBidXR0b25zIHRvIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9ucyBhZGRlZCB0byBtZXNzYWdlOicsIGFjdGlvbnNEaXYpOyAvLyBEZWJ1ZyBsb2dcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG1lc3NhZ2VEaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChtZXNzYWdlRGl2KTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIC8vIFNhdmUgdG8gY2hhdCBoaXN0b3J5XG4gICAgICAgIGlmIChzYXZlVG9IaXN0b3J5KSB7XG4gICAgICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICAgICAgY2hhdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICAgICAgc2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICBpc01hcmtkb3duOiBpc01hcmtkb3duIHx8IHNlbmRlciA9PT0gJ2JvdCdcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgbWVzc2FnZSBjb250ZW50IHRvIGNsaXBib2FyZFxuICAgICAqL1xuICAgIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0NvbnRlbnQgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGJ1dHRvbiBlbGVtZW50IHRoYXQgd2FzIGNsaWNrZWRcbiAgICAgICAgICAgICAgICBjb25zdCBidXR0b25zID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmpwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgbGV0IGNsaWNrZWRCdXR0b24gPSBudWxsO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnV0dG9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBidXR0b24gPSBidXR0b25zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnV0dG9uLnRpdGxlID09PSAnQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCcgJiYgYnV0dG9uID09PSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja2VkQnV0dG9uID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gU2hvdyB2aXN1YWwgZmVlZGJhY2sgaWYgd2UgZm91bmQgdGhlIGJ1dHRvblxuICAgICAgICAgICAgICAgIGlmIChjbGlja2VkQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsSFRNTCA9IGNsaWNrZWRCdXR0b24uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICBjbGlja2VkQnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0yMCA2TDkgMTdsLTUtNVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrZWRCdXR0b24uaW5uZXJIVE1MID0gb3JpZ2luYWxIVE1MO1xuICAgICAgICAgICAgICAgICAgICB9LCAyMDAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IHRleHQ6ICcsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvcHlpbmcgdG8gY2xpcGJvYXJkOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG1lc3NhZ2UgY29udGVudCB0byB0aGUgY3VycmVudCBjZWxsXG4gICAgICovXG4gICAgYWRkTWVzc2FnZVRvQ2VsbCh0ZXh0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uO1xuICAgICAgICAgICAgY29uc3QgY3Vyc29yUG9zID0gc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgICAgIC8vIEluc2VydCBuZXdsaW5lIGFuZCBtZXNzYWdlIGNvbnRlbnQgYXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHN0YXRlLnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgY2hhbmdlczoge1xuICAgICAgICAgICAgICAgICAgICBmcm9tOiBjdXJzb3JQb3MsXG4gICAgICAgICAgICAgICAgICAgIGluc2VydDogYFxcbiR7dGV4dH1gXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjdXJzb3JQb3MgKyB0ZXh0Lmxlbmd0aCArIDEgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2aWV3LmRpc3BhdGNoKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFkZGluZyBtZXNzYWdlIHRvIGNlbGw6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IGZyb20gdGhlIGFjdGl2ZSBub3RlYm9vayBjZWxsLlxuICAgICAqIChIZWxwZXIgZm9yIFBvcHVwTWVudU1hbmFnZXIgY2FsbGJhY2spXG4gICAgICovXG4gICAgZ2V0U2VsZWN0ZWRUZXh0KCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgY29uc3QgY2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgICAgIGlmIChjZWxsID09PSBudWxsIHx8IGNlbGwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGwuZWRpdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjsgLy8gSUVkaXRvclxuICAgICAgICAgICAgLy8gQWNjZXNzIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICBjb25zdCBjbUVkaXRvciA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICBpZiAoY21FZGl0b3IgJiYgY21FZGl0b3Iuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNtRWRpdG9yLnN0YXRlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi5tYWluOyAvLyBHZXQgdGhlIG1haW4gc2VsZWN0aW9uXG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gTm8gdGV4dCBzZWxlY3RlZFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGUuZG9jLnNsaWNlU3RyaW5nKHNlbGVjdGlvbi5mcm9tLCBzZWxlY3Rpb24udG8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFjY2VzcyBDb2RlTWlycm9yIHN0YXRlIHRvIGdldCBzZWxlY3Rpb24uXCIpO1xuICAgICAgICAgICAgLy8gQXZvaWQgdXNpbmcgZ2V0UmFuZ2UgYXMgaXQncyBjb25maXJtZWQgbm90IHRvIGV4aXN0IG9uIElFZGl0b3JcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBnZXQgc2VsZWN0aW9uIGZyb20gZG9jdW1lbnQgaWYgbm8gbm90ZWJvb2sgYWN0aXZlIChlLmcuLCB0ZXh0IGVkaXRvcilcbiAgICAgICAgICAgIGNvbnN0IGFjdGl2ZVdpZGdldCA9IChfYyA9IChfYiA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoZWxsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgIGlmIChhY3RpdmVXaWRnZXQgJiYgJ2NvbnRlbnQnIGluIGFjdGl2ZVdpZGdldCAmJiBhY3RpdmVXaWRnZXQuY29udGVudC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVXaWRnZXQuY29udGVudC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGlmIChjbUVkaXRvciAmJiBjbUVkaXRvci5zdGF0ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNtRWRpdG9yLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRvYy5zbGljZVN0cmluZyhzZWxlY3Rpb24uZnJvbSwgc2VsZWN0aW9uLnRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFjY2VzcyBDb2RlTWlycm9yIHN0YXRlIGZvciBub24tbm90ZWJvb2sgZWRpdG9yIHNlbGVjdGlvbi5cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIEF2b2lkIGdldFJhbmdlXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgbm90ZWJvb2sgY2VsbC5cbiAgICAgKiAoSGVscGVyIGZvciBQb3B1cE1lbnVNYW5hZ2VyIGNhbGxiYWNrKVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDZWxsQ29udGVudCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGFjdGl2ZUNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICBpZiAoYWN0aXZlQ2VsbCA9PT0gbnVsbCB8fCBhY3RpdmVDZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhY3RpdmVDZWxsLm1vZGVsKSB7XG4gICAgICAgICAgICAvLyBUcnkgdXNpbmcgc2hhcmVkTW9kZWwgZmlyc3QgKG1vcmUgcm9idXN0KVxuICAgICAgICAgICAgaWYgKGFjdGl2ZUNlbGwubW9kZWwuc2hhcmVkTW9kZWwgJiYgdHlwZW9mIGFjdGl2ZUNlbGwubW9kZWwuc2hhcmVkTW9kZWwuZ2V0U291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGl2ZUNlbGwubW9kZWwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGYWxsYmFjazogVHJ5IHVzaW5nIHRvSlNPTigpLnNvdXJjZVxuICAgICAgICAgICAgY29uc3QgY2VsbEpzb24gPSBhY3RpdmVDZWxsLm1vZGVsLnRvSlNPTigpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2VsbEpzb24gPT09IG51bGwgfHwgY2VsbEpzb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGxKc29uLnNvdXJjZSkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxKc29uLnNvdXJjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2VsbEpzb24gPT09IG51bGwgfHwgY2VsbEpzb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGxKc29uLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzb3VyY2UgaXMgYW4gYXJyYXkgb2Ygc3RyaW5ncywgam9pbiB0aGVtXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNlbGxKc29uLnNvdXJjZS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBnZXQgY2VsbCBjb250ZW50IHZpYSBtb2RlbC52YWx1ZS50ZXh0IG9yIHRvSlNPTigpLnNvdXJjZVwiKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tbm90ZWJvb2sgZWRpdG9ycyBpZiBuZWVkZWRcbiAgICAgICAgY29uc3QgYWN0aXZlV2lkZ2V0ID0gKF9jID0gKF9iID0gZ2xvYmFsc18xLmdsb2JhbHMuYXBwKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2hlbGwpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jdXJyZW50V2lkZ2V0O1xuICAgICAgICBpZiAoYWN0aXZlV2lkZ2V0ICYmICdjb250ZW50JyBpbiBhY3RpdmVXaWRnZXQgJiYgYWN0aXZlV2lkZ2V0LmNvbnRlbnQubW9kZWwpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVXaWRnZXQuY29udGVudC5tb2RlbC52YWx1ZS50ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRleHQgdG8gdGhlIGlucHV0IGZpZWxkIHdpdGggcHJvcGVyIHNwYWNpbmdcbiAgICAgKi9cbiAgICBhcHBlbmRUb0lucHV0KHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VmFsdWUpIHtcbiAgICAgICAgICAgICAgICAvLyBhZGQgYSBzcGFjZSBiZXR3ZWVuIHRoZSBjdXJyZW50IHZhbHVlIGFuZCB0aGUgbmV3IHRleHRcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSBgJHtjdXJyZW50VmFsdWV9JHt0ZXh0fWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRm9jdXMgdGhlIGlucHV0IGZpZWxkIGFuZCBtb3ZlIGN1cnNvciB0byBlbmRcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldFNlbGVjdGlvblJhbmdlKHRoaXMuaW5wdXRGaWVsZC52YWx1ZS5sZW5ndGgsIHRoaXMuaW5wdXRGaWVsZC52YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYXBwZW5kaW5nIHRvIGlucHV0OicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTZXR0aW5ncyBtb2RhbCBtZXRob2RzXG4gICAgY3JlYXRlU2V0dGluZ3NNb2RhbCgpIHtcbiAgICAgICAgY29uc3QgbW9kYWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbW9kYWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbW9kYWwnO1xuICAgICAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBLZWVwIHRoaXMgaW5saW5lIHN0eWxlIGZvciB0b2dnbGluZyB2aXNpYmlsaXR5XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGVudC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1jb250ZW50JztcbiAgICAgICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuICAgICAgICB0aXRsZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy10aXRsZSc7XG4gICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gJ1NldHRpbmdzJztcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgICAgIGZvcm0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtZm9ybSc7XG4gICAgICAgIC8vIFByb3ZpZGVyIHNlbGVjdGlvblxuICAgICAgICBjb25zdCBwcm92aWRlckxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgcHJvdmlkZXJMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgICAgIHByb3ZpZGVyTGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIFByb3ZpZGVyOic7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQocHJvdmlkZXJMYWJlbCk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyU2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2VsZWN0Jyk7XG4gICAgICAgIHByb3ZpZGVyU2VsZWN0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLXNlbGVjdCc7XG4gICAgICAgIHByb3ZpZGVyU2VsZWN0LmlkID0gJ3NldHRpbmdzLXByb3ZpZGVyJztcbiAgICAgICAgWydPcGVuQUknLCAnSHVnZ2luZ0ZhY2UnLCAnTG9jYWwnXS5mb3JFYWNoKG9wdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdDtcbiAgICAgICAgICAgIG9wdGlvbi50ZXh0Q29udGVudCA9IG9wdDtcbiAgICAgICAgICAgIHByb3ZpZGVyU2VsZWN0LmFwcGVuZENoaWxkKG9wdGlvbik7XG4gICAgICAgIH0pO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHByb3ZpZGVyU2VsZWN0KTtcbiAgICAgICAgLy8gQVBJIEtleSBpbnB1dFxuICAgICAgICBjb25zdCBhcGlLZXlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIGFwaUtleUxhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICAgICAgYXBpS2V5TGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIEtleTonO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGFwaUtleUxhYmVsKTtcbiAgICAgICAgY29uc3QgYXBpS2V5SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBhcGlLZXlJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1pbnB1dCc7XG4gICAgICAgIGFwaUtleUlucHV0LnR5cGUgPSAncGFzc3dvcmQnO1xuICAgICAgICBhcGlLZXlJbnB1dC5pZCA9ICdzZXR0aW5ncy1hcGkta2V5JztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChhcGlLZXlJbnB1dCk7XG4gICAgICAgIC8vIEFQSSBVUkwgaW5wdXRcbiAgICAgICAgY29uc3QgYXBpVXJsTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBhcGlVcmxMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgICAgIGFwaVVybExhYmVsLnRleHRDb250ZW50ID0gJ0FQSSBVUkwgKG9wdGlvbmFsKTonO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGFwaVVybExhYmVsKTtcbiAgICAgICAgY29uc3QgYXBpVXJsSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBhcGlVcmxJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1pbnB1dCc7XG4gICAgICAgIGFwaVVybElucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICAgIGFwaVVybElucHV0LmlkID0gJ3NldHRpbmdzLWFwaS11cmwnO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGFwaVVybElucHV0KTtcbiAgICAgICAgLy8gUnVsZXMgaW5wdXRcbiAgICAgICAgY29uc3QgcnVsZXNMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHJ1bGVzTGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgICAgICBydWxlc0xhYmVsLnRleHRDb250ZW50ID0gJ0N1c3RvbSBSdWxlcyAob3B0aW9uYWwpOic7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQocnVsZXNMYWJlbCk7XG4gICAgICAgIGNvbnN0IHJ1bGVzSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICBydWxlc0lucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLXRleHRhcmVhJztcbiAgICAgICAgcnVsZXNJbnB1dC5pZCA9ICdzZXR0aW5ncy1ydWxlcyc7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQocnVsZXNJbnB1dCk7XG4gICAgICAgIC8vIEJ1dHRvbnMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGJ0bkNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBidG5Db250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtYnV0dG9ucyc7XG4gICAgICAgIGNvbnN0IHNhdmVCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgc2F2ZUJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1idXR0b24ganAtbGxtLWV4dC1zZXR0aW5ncy1zYXZlLWJ1dHRvbic7XG4gICAgICAgIHNhdmVCdG4udGV4dENvbnRlbnQgPSAnU2F2ZSc7XG4gICAgICAgIHNhdmVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIEFkZCB0aGlzIGxpbmVcbiAgICAgICAgICAgIGNvbnN0IHByb3ZpZGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLXByb3ZpZGVyJykudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtYXBpLWtleScpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdXJsID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLWFwaS11cmwnKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLXJ1bGVzJykudmFsdWU7XG4gICAgICAgICAgICAvLyBTYXZlIHNldHRpbmdzIHRvIGxvY2FsU3RvcmFnZSBmb3IgcGVyc2lzdGVuY2VcbiAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0geyBwcm92aWRlciwga2V5LCB1cmwsIHJ1bGVzIH07XG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbSgnanAtbGxtLWV4dC1zZXR0aW5ncycsIEpTT04uc3RyaW5naWZ5KHNldHRpbmdzKSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQ6Jywgc2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5oaWRlU2V0dGluZ3NNb2RhbCgpO1xuICAgICAgICAgICAgdGhpcy5wb3BTYXZlU3VjY2VzcygpO1xuICAgICAgICAgICAgLy8gVXBkYXRlIEFQSSBjbGllbnQgd2l0aCBuZXcgc2V0dGluZ3MgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcGlDbGllbnQgPSBuZXcgYXBpX2NsaWVudF8xLkFwaUNsaWVudCh1cmwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuY2VsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGNhbmNlbEJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1idXR0b24ganAtbGxtLWV4dC1zZXR0aW5ncy1jYW5jZWwtYnV0dG9uJztcbiAgICAgICAgY2FuY2VsQnRuLnRleHRDb250ZW50ID0gJ0NhbmNlbCc7XG4gICAgICAgIGNhbmNlbEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gQWRkIHRoaXMgbGluZVxuICAgICAgICAgICAgdGhpcy5oaWRlU2V0dGluZ3NNb2RhbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgYnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHNhdmVCdG4pO1xuICAgICAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoY2FuY2VsQnRuKTtcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChidG5Db250YWluZXIpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG1vZGFsO1xuICAgIH1cbiAgICBzaG93U2V0dGluZ3NNb2RhbCgpIHtcbiAgICAgICAgLy8gTG9hZCBzYXZlZCBzZXR0aW5ncyBmcm9tIGxvY2FsU3RvcmFnZVxuICAgICAgICB0aGlzLmxvYWRTYXZlZFNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnO1xuICAgIH1cbiAgICBsb2FkU2F2ZWRTZXR0aW5ncygpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRTZXR0aW5ncyA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdqcC1sbG0tZXh0LXNldHRpbmdzJyk7XG4gICAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAvLyBVcGRhdGUgVUkgd2l0aCBzYXZlZCBzZXR0aW5nc1xuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5wcm92aWRlcikge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcHJvdmlkZXInKS52YWx1ZSA9IHNldHRpbmdzLnByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3Mua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1hcGkta2V5JykudmFsdWUgPSBzZXR0aW5ncy5rZXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy51cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLWFwaS11cmwnKS52YWx1ZSA9IHNldHRpbmdzLnVybDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLnJ1bGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1ydWxlcycpLnZhbHVlID0gc2V0dGluZ3MucnVsZXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzYXZlZCBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGlkZVNldHRpbmdzTW9kYWwoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICBwb3BTYXZlU3VjY2VzcygpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgdG9hc3Qgbm90aWZpY2F0aW9uIGNvbnRhaW5lclxuICAgICAgICBjb25zdCB0b2FzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b2FzdC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10b2FzdC1ub3RpZmljYXRpb24ganAtbGxtLWV4dC1zZXR0aW5ncy1zdWNjZXNzJztcbiAgICAgICAgdG9hc3QudGV4dENvbnRlbnQgPSAnU2V0dGluZ3Mgc2F2ZWQgc3VjY2Vzc2Z1bGx5JztcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBtYWluIHdpZGdldCAobm90IHRoZSBtb2RhbCB3aGljaCBpcyBoaWRkZW4pXG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0b2FzdCk7XG4gICAgICAgIC8vIEFuaW1hdGUgaW5cbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICB0b2FzdC5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgIH0sIDEwKTtcbiAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdG9hc3QuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICAgICAgLy8gV2FpdCBmb3IgZmFkZSBvdXQgYW5pbWF0aW9uIHRvIGNvbXBsZXRlIGJlZm9yZSByZW1vdmluZ1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdG9hc3QucmVtb3ZlKCk7XG4gICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICB9LCAzMDAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBjZWxsIGNvbnRlbnQgYnkgaW5kZXggZnJvbSB0aGUgY3VycmVudCBub3RlYm9vayBhbmQgaW5zZXJ0cyBpdCBpbnRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGluc2VydENlbGxCeUluZGV4KGluZGV4KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoIWdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlciB8fCAhZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBhY3RpdmUgbm90ZWJvb2sgZm91bmQnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub3RlYm9va1BhbmVsID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgICAgICBjb25zdCBtb2RlbCA9IG5vdGVib29rUGFuZWwuY29udGVudC5tb2RlbDtcbiAgICAgICAgICAgIGlmICghbW9kZWwgfHwgIW1vZGVsLmNlbGxzIHx8IGluZGV4ID49IG1vZGVsLmNlbGxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgY2VsbCBpbmRleDogJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gbW9kZWwuY2VsbHMuZ2V0KGluZGV4KTtcbiAgICAgICAgICAgIGxldCBjZWxsQ29udGVudCA9ICcnO1xuICAgICAgICAgICAgLy8gR2V0IGNlbGwgY29udGVudCAtIGhhbmRsZSBkaWZmZXJlbnQgd2F5cyBjb250ZW50IG1pZ2h0IGJlIHN0b3JlZFxuICAgICAgICAgICAgaWYgKGNlbGwuc2hhcmVkTW9kZWwgJiYgdHlwZW9mIGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBjZWxsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEpzb24gPSBjZWxsLnRvSlNPTigpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGNlbGxKc29uID09PSBudWxsIHx8IGNlbGxKc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsSnNvbi5zb3VyY2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA9IGNlbGxKc29uLnNvdXJjZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA9IGNlbGxKc29uLnNvdXJjZS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJbnNlcnQgY2VsbCByZWZlcmVuY2Ugd2l0aCBjb250ZW50LCB3aXRob3V0IHR5cGUgaW5kaWNhdG9yIG9yIGV4ZWN1dGlvbiBjb3VudFxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBjZWxsICR7Y2VsbENvbnRlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbnNlcnRpbmcgY2VsbCBieSBpbmRleDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSBTaW1wbGVTaWRlYmFyV2lkZ2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9