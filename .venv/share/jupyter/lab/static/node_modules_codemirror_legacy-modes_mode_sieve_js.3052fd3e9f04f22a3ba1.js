"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_sieve_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/sieve.js":
/*!*************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/sieve.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   sieve: () => (/* binding */ sieve)
/* harmony export */ });
function words(str) {
  var obj = {}, words = str.split(" ");
  for (var i = 0; i < words.length; ++i) obj[words[i]] = true;
  return obj;
}

var keywords = words("if elsif else stop require");
var atoms = words("true false not");

function tokenBase(stream, state) {

  var ch = stream.next();
  if (ch == "/" && stream.eat("*")) {
    state.tokenize = tokenCComment;
    return tokenCComment(stream, state);
  }

  if (ch === '#') {
    stream.skipToEnd();
    return "comment";
  }

  if (ch == "\"") {
    state.tokenize = tokenString(ch);
    return state.tokenize(stream, state);
  }

  if (ch == "(") {
    state._indent.push("(");
    // add virtual angel wings so that editor behaves...
    // ...more sane incase of broken brackets
    state._indent.push("{");
    return null;
  }

  if (ch === "{") {
    state._indent.push("{");
    return null;
  }

  if (ch == ")")  {
    state._indent.pop();
    state._indent.pop();
  }

  if (ch === "}") {
    state._indent.pop();
    return null;
  }

  if (ch == ",")
    return null;

  if (ch == ";")
    return null;


  if (/[{}\(\),;]/.test(ch))
    return null;

  // 1*DIGIT "K" / "M" / "G"
  if (/\d/.test(ch)) {
    stream.eatWhile(/[\d]/);
    stream.eat(/[KkMmGg]/);
    return "number";
  }

  // ":" (ALPHA / "_") *(ALPHA / DIGIT / "_")
  if (ch == ":") {
    stream.eatWhile(/[a-zA-Z_]/);
    stream.eatWhile(/[a-zA-Z0-9_]/);

    return "operator";
  }

  stream.eatWhile(/\w/);
  var cur = stream.current();

  // "text:" *(SP / HTAB) (hash-comment / CRLF)
  // *(multiline-literal / multiline-dotstart)
  // "." CRLF
  if ((cur == "text") && stream.eat(":"))
  {
    state.tokenize = tokenMultiLineString;
    return "string";
  }

  if (keywords.propertyIsEnumerable(cur))
    return "keyword";

  if (atoms.propertyIsEnumerable(cur))
    return "atom";

  return null;
}

function tokenMultiLineString(stream, state)
{
  state._multiLineString = true;
  // the first line is special it may contain a comment
  if (!stream.sol()) {
    stream.eatSpace();

    if (stream.peek() == "#") {
      stream.skipToEnd();
      return "comment";
    }

    stream.skipToEnd();
    return "string";
  }

  if ((stream.next() == ".")  && (stream.eol()))
  {
    state._multiLineString = false;
    state.tokenize = tokenBase;
  }

  return "string";
}

function tokenCComment(stream, state) {
  var maybeEnd = false, ch;
  while ((ch = stream.next()) != null) {
    if (maybeEnd && ch == "/") {
      state.tokenize = tokenBase;
      break;
    }
    maybeEnd = (ch == "*");
  }
  return "comment";
}

function tokenString(quote) {
  return function(stream, state) {
    var escaped = false, ch;
    while ((ch = stream.next()) != null) {
      if (ch == quote && !escaped)
        break;
      escaped = !escaped && ch == "\\";
    }
    if (!escaped) state.tokenize = tokenBase;
    return "string";
  };
}

const sieve = {
  name: "sieve",
  startState: function(base) {
    return {tokenize: tokenBase,
            baseIndent: base || 0,
            _indent: []};
  },

  token: function(stream, state) {
    if (stream.eatSpace())
      return null;

    return (state.tokenize || tokenBase)(stream, state);
  },

  indent: function(state, _textAfter, cx) {
    var length = state._indent.length;
    if (_textAfter && (_textAfter[0] == "}"))
      length--;

    if (length <0)
      length = 0;

    return length * cx.unit;
  },

  languageData: {
    indentOnInput: /^\s*\}$/
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfc2lldmVfanMuMzA1MmZkM2U5ZjA0ZjIyYTNiYTEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0EsY0FBYztBQUNkLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQSxlQUFlO0FBQ2YseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWM7QUFDZDs7O0FBR0EsVUFBVSxNQUFNO0FBQ2hCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNvZGVtaXJyb3IvbGVnYWN5LW1vZGVzL21vZGUvc2lldmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gd29yZHMoc3RyKSB7XG4gIHZhciBvYmogPSB7fSwgd29yZHMgPSBzdHIuc3BsaXQoXCIgXCIpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSBvYmpbd29yZHNbaV1dID0gdHJ1ZTtcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIGtleXdvcmRzID0gd29yZHMoXCJpZiBlbHNpZiBlbHNlIHN0b3AgcmVxdWlyZVwiKTtcbnZhciBhdG9tcyA9IHdvcmRzKFwidHJ1ZSBmYWxzZSBub3RcIik7XG5cbmZ1bmN0aW9uIHRva2VuQmFzZShzdHJlYW0sIHN0YXRlKSB7XG5cbiAgdmFyIGNoID0gc3RyZWFtLm5leHQoKTtcbiAgaWYgKGNoID09IFwiL1wiICYmIHN0cmVhbS5lYXQoXCIqXCIpKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlbkNDb21tZW50O1xuICAgIHJldHVybiB0b2tlbkNDb21tZW50KHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgaWYgKGNoID09PSAnIycpIHtcbiAgICBzdHJlYW0uc2tpcFRvRW5kKCk7XG4gICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICB9XG5cbiAgaWYgKGNoID09IFwiXFxcIlwiKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSB0b2tlblN0cmluZyhjaCk7XG4gICAgcmV0dXJuIHN0YXRlLnRva2VuaXplKHN0cmVhbSwgc3RhdGUpO1xuICB9XG5cbiAgaWYgKGNoID09IFwiKFwiKSB7XG4gICAgc3RhdGUuX2luZGVudC5wdXNoKFwiKFwiKTtcbiAgICAvLyBhZGQgdmlydHVhbCBhbmdlbCB3aW5ncyBzbyB0aGF0IGVkaXRvciBiZWhhdmVzLi4uXG4gICAgLy8gLi4ubW9yZSBzYW5lIGluY2FzZSBvZiBicm9rZW4gYnJhY2tldHNcbiAgICBzdGF0ZS5faW5kZW50LnB1c2goXCJ7XCIpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKGNoID09PSBcIntcIikge1xuICAgIHN0YXRlLl9pbmRlbnQucHVzaChcIntcIik7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2ggPT0gXCIpXCIpICB7XG4gICAgc3RhdGUuX2luZGVudC5wb3AoKTtcbiAgICBzdGF0ZS5faW5kZW50LnBvcCgpO1xuICB9XG5cbiAgaWYgKGNoID09PSBcIn1cIikge1xuICAgIHN0YXRlLl9pbmRlbnQucG9wKCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoY2ggPT0gXCIsXCIpXG4gICAgcmV0dXJuIG51bGw7XG5cbiAgaWYgKGNoID09IFwiO1wiKVxuICAgIHJldHVybiBudWxsO1xuXG5cbiAgaWYgKC9be31cXChcXCksO10vLnRlc3QoY2gpKVxuICAgIHJldHVybiBudWxsO1xuXG4gIC8vIDEqRElHSVQgXCJLXCIgLyBcIk1cIiAvIFwiR1wiXG4gIGlmICgvXFxkLy50ZXN0KGNoKSkge1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW1xcZF0vKTtcbiAgICBzdHJlYW0uZWF0KC9bS2tNbUdnXS8pO1xuICAgIHJldHVybiBcIm51bWJlclwiO1xuICB9XG5cbiAgLy8gXCI6XCIgKEFMUEhBIC8gXCJfXCIpICooQUxQSEEgLyBESUdJVCAvIFwiX1wiKVxuICBpZiAoY2ggPT0gXCI6XCIpIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1thLXpBLVpfXS8pO1xuICAgIHN0cmVhbS5lYXRXaGlsZSgvW2EtekEtWjAtOV9dLyk7XG5cbiAgICByZXR1cm4gXCJvcGVyYXRvclwiO1xuICB9XG5cbiAgc3RyZWFtLmVhdFdoaWxlKC9cXHcvKTtcbiAgdmFyIGN1ciA9IHN0cmVhbS5jdXJyZW50KCk7XG5cbiAgLy8gXCJ0ZXh0OlwiICooU1AgLyBIVEFCKSAoaGFzaC1jb21tZW50IC8gQ1JMRilcbiAgLy8gKihtdWx0aWxpbmUtbGl0ZXJhbCAvIG11bHRpbGluZS1kb3RzdGFydClcbiAgLy8gXCIuXCIgQ1JMRlxuICBpZiAoKGN1ciA9PSBcInRleHRcIikgJiYgc3RyZWFtLmVhdChcIjpcIikpXG4gIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuTXVsdGlMaW5lU3RyaW5nO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9XG5cbiAgaWYgKGtleXdvcmRzLnByb3BlcnR5SXNFbnVtZXJhYmxlKGN1cikpXG4gICAgcmV0dXJuIFwia2V5d29yZFwiO1xuXG4gIGlmIChhdG9tcy5wcm9wZXJ0eUlzRW51bWVyYWJsZShjdXIpKVxuICAgIHJldHVybiBcImF0b21cIjtcblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdG9rZW5NdWx0aUxpbmVTdHJpbmcoc3RyZWFtLCBzdGF0ZSlcbntcbiAgc3RhdGUuX211bHRpTGluZVN0cmluZyA9IHRydWU7XG4gIC8vIHRoZSBmaXJzdCBsaW5lIGlzIHNwZWNpYWwgaXQgbWF5IGNvbnRhaW4gYSBjb21tZW50XG4gIGlmICghc3RyZWFtLnNvbCgpKSB7XG4gICAgc3RyZWFtLmVhdFNwYWNlKCk7XG5cbiAgICBpZiAoc3RyZWFtLnBlZWsoKSA9PSBcIiNcIikge1xuICAgICAgc3RyZWFtLnNraXBUb0VuZCgpO1xuICAgICAgcmV0dXJuIFwiY29tbWVudFwiO1xuICAgIH1cblxuICAgIHN0cmVhbS5za2lwVG9FbmQoKTtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGlmICgoc3RyZWFtLm5leHQoKSA9PSBcIi5cIikgICYmIChzdHJlYW0uZW9sKCkpKVxuICB7XG4gICAgc3RhdGUuX211bHRpTGluZVN0cmluZyA9IGZhbHNlO1xuICAgIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICB9XG5cbiAgcmV0dXJuIFwic3RyaW5nXCI7XG59XG5cbmZ1bmN0aW9uIHRva2VuQ0NvbW1lbnQoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbWF5YmVFbmQgPSBmYWxzZSwgY2g7XG4gIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgaWYgKG1heWJlRW5kICYmIGNoID09IFwiL1wiKSB7XG4gICAgICBzdGF0ZS50b2tlbml6ZSA9IHRva2VuQmFzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBtYXliZUVuZCA9IChjaCA9PSBcIipcIik7XG4gIH1cbiAgcmV0dXJuIFwiY29tbWVudFwiO1xufVxuXG5mdW5jdGlvbiB0b2tlblN0cmluZyhxdW90ZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHZhciBlc2NhcGVkID0gZmFsc2UsIGNoO1xuICAgIHdoaWxlICgoY2ggPSBzdHJlYW0ubmV4dCgpKSAhPSBudWxsKSB7XG4gICAgICBpZiAoY2ggPT0gcXVvdGUgJiYgIWVzY2FwZWQpXG4gICAgICAgIGJyZWFrO1xuICAgICAgZXNjYXBlZCA9ICFlc2NhcGVkICYmIGNoID09IFwiXFxcXFwiO1xuICAgIH1cbiAgICBpZiAoIWVzY2FwZWQpIHN0YXRlLnRva2VuaXplID0gdG9rZW5CYXNlO1xuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG5leHBvcnQgY29uc3Qgc2lldmUgPSB7XG4gIG5hbWU6IFwic2lldmVcIixcbiAgc3RhcnRTdGF0ZTogZnVuY3Rpb24oYmFzZSkge1xuICAgIHJldHVybiB7dG9rZW5pemU6IHRva2VuQmFzZSxcbiAgICAgICAgICAgIGJhc2VJbmRlbnQ6IGJhc2UgfHwgMCxcbiAgICAgICAgICAgIF9pbmRlbnQ6IFtdfTtcbiAgfSxcblxuICB0b2tlbjogZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIGlmIChzdHJlYW0uZWF0U3BhY2UoKSlcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgcmV0dXJuIChzdGF0ZS50b2tlbml6ZSB8fCB0b2tlbkJhc2UpKHN0cmVhbSwgc3RhdGUpO1xuICB9LFxuXG4gIGluZGVudDogZnVuY3Rpb24oc3RhdGUsIF90ZXh0QWZ0ZXIsIGN4KSB7XG4gICAgdmFyIGxlbmd0aCA9IHN0YXRlLl9pbmRlbnQubGVuZ3RoO1xuICAgIGlmIChfdGV4dEFmdGVyICYmIChfdGV4dEFmdGVyWzBdID09IFwifVwiKSlcbiAgICAgIGxlbmd0aC0tO1xuXG4gICAgaWYgKGxlbmd0aCA8MClcbiAgICAgIGxlbmd0aCA9IDA7XG5cbiAgICByZXR1cm4gbGVuZ3RoICogY3gudW5pdDtcbiAgfSxcblxuICBsYW5ndWFnZURhdGE6IHtcbiAgICBpbmRlbnRPbklucHV0OiAvXlxccypcXH0kL1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9