"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_handlers_html_HTMLHandler_js"],{

/***/ "./node_modules/mathjax-full/js/core/Handler.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/Handler.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractHandler = void 0;
var MathDocument_js_1 = __webpack_require__(/*! ./MathDocument.js */ "./node_modules/mathjax-full/js/core/MathDocument.js");
var DefaultMathDocument = (function (_super) {
    __extends(DefaultMathDocument, _super);
    function DefaultMathDocument() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DefaultMathDocument;
}(MathDocument_js_1.AbstractMathDocument));
var AbstractHandler = (function () {
    function AbstractHandler(adaptor, priority) {
        if (priority === void 0) { priority = 5; }
        this.documentClass = DefaultMathDocument;
        this.adaptor = adaptor;
        this.priority = priority;
    }
    Object.defineProperty(AbstractHandler.prototype, "name", {
        get: function () {
            return this.constructor.NAME;
        },
        enumerable: false,
        configurable: true
    });
    AbstractHandler.prototype.handlesDocument = function (_document) {
        return false;
    };
    AbstractHandler.prototype.create = function (document, options) {
        return new this.documentClass(document, this.adaptor, options);
    };
    AbstractHandler.NAME = 'generic';
    return AbstractHandler;
}());
exports.AbstractHandler = AbstractHandler;
//# sourceMappingURL=Handler.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/InputJax.js":
/*!*******************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/InputJax.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractInputJax = void 0;
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var FunctionList_js_1 = __webpack_require__(/*! ../util/FunctionList.js */ "./node_modules/mathjax-full/js/util/FunctionList.js");
var AbstractInputJax = (function () {
    function AbstractInputJax(options) {
        if (options === void 0) { options = {}; }
        this.adaptor = null;
        this.mmlFactory = null;
        var CLASS = this.constructor;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
        this.preFilters = new FunctionList_js_1.FunctionList();
        this.postFilters = new FunctionList_js_1.FunctionList();
    }
    Object.defineProperty(AbstractInputJax.prototype, "name", {
        get: function () {
            return this.constructor.NAME;
        },
        enumerable: false,
        configurable: true
    });
    AbstractInputJax.prototype.setAdaptor = function (adaptor) {
        this.adaptor = adaptor;
    };
    AbstractInputJax.prototype.setMmlFactory = function (mmlFactory) {
        this.mmlFactory = mmlFactory;
    };
    AbstractInputJax.prototype.initialize = function () {
    };
    AbstractInputJax.prototype.reset = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    Object.defineProperty(AbstractInputJax.prototype, "processStrings", {
        get: function () {
            return true;
        },
        enumerable: false,
        configurable: true
    });
    AbstractInputJax.prototype.findMath = function (_node, _options) {
        return [];
    };
    AbstractInputJax.prototype.executeFilters = function (filters, math, document, data) {
        var args = { math: math, document: document, data: data };
        filters.execute(args);
        return args.data;
    };
    AbstractInputJax.NAME = 'generic';
    AbstractInputJax.OPTIONS = {};
    return AbstractInputJax;
}());
exports.AbstractInputJax = AbstractInputJax;
//# sourceMappingURL=InputJax.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/MathDocument.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/MathDocument.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMathDocument = exports.resetAllOptions = exports.resetOptions = exports.RenderList = void 0;
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var InputJax_js_1 = __webpack_require__(/*! ./InputJax.js */ "./node_modules/mathjax-full/js/core/InputJax.js");
var OutputJax_js_1 = __webpack_require__(/*! ./OutputJax.js */ "./node_modules/mathjax-full/js/core/OutputJax.js");
var MathList_js_1 = __webpack_require__(/*! ./MathList.js */ "./node_modules/mathjax-full/js/core/MathList.js");
var MathItem_js_1 = __webpack_require__(/*! ./MathItem.js */ "./node_modules/mathjax-full/js/core/MathItem.js");
var MmlFactory_js_1 = __webpack_require__(/*! ../core/MmlTree/MmlFactory.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlFactory.js");
var BitField_js_1 = __webpack_require__(/*! ../util/BitField.js */ "./node_modules/mathjax-full/js/util/BitField.js");
var PrioritizedList_js_1 = __webpack_require__(/*! ../util/PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var RenderList = (function (_super) {
    __extends(RenderList, _super);
    function RenderList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    RenderList.create = function (actions) {
        var e_1, _a;
        var list = new this();
        try {
            for (var _b = __values(Object.keys(actions)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var id = _c.value;
                var _d = __read(this.action(id, actions[id]), 2), action = _d[0], priority = _d[1];
                if (priority) {
                    list.add(action, priority);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return list;
    };
    RenderList.action = function (id, action) {
        var _a, _b, _c, _d;
        var renderDoc, renderMath;
        var convert = true;
        var priority = action[0];
        if (action.length === 1 || typeof action[1] === 'boolean') {
            action.length === 2 && (convert = action[1]);
            _a = __read(this.methodActions(id), 2), renderDoc = _a[0], renderMath = _a[1];
        }
        else if (typeof action[1] === 'string') {
            if (typeof action[2] === 'string') {
                action.length === 4 && (convert = action[3]);
                var _e = __read(action.slice(1), 2), method1 = _e[0], method2 = _e[1];
                _b = __read(this.methodActions(method1, method2), 2), renderDoc = _b[0], renderMath = _b[1];
            }
            else {
                action.length === 3 && (convert = action[2]);
                _c = __read(this.methodActions(action[1]), 2), renderDoc = _c[0], renderMath = _c[1];
            }
        }
        else {
            action.length === 4 && (convert = action[3]);
            _d = __read(action.slice(1), 2), renderDoc = _d[0], renderMath = _d[1];
        }
        return [{ id: id, renderDoc: renderDoc, renderMath: renderMath, convert: convert }, priority];
    };
    RenderList.methodActions = function (method1, method2) {
        if (method2 === void 0) { method2 = method1; }
        return [
            function (document) { method1 && document[method1](); return false; },
            function (math, document) { method2 && math[method2](document); return false; }
        ];
    };
    RenderList.prototype.renderDoc = function (document, start) {
        var e_2, _a;
        if (start === void 0) { start = MathItem_js_1.STATE.UNPROCESSED; }
        try {
            for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.priority >= start) {
                    if (item.item.renderDoc(document))
                        return;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    };
    RenderList.prototype.renderMath = function (math, document, start) {
        var e_3, _a;
        if (start === void 0) { start = MathItem_js_1.STATE.UNPROCESSED; }
        try {
            for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.priority >= start) {
                    if (item.item.renderMath(math, document))
                        return;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    RenderList.prototype.renderConvert = function (math, document, end) {
        var e_4, _a;
        if (end === void 0) { end = MathItem_js_1.STATE.LAST; }
        try {
            for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.priority > end)
                    return;
                if (item.item.convert) {
                    if (item.item.renderMath(math, document))
                        return;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
    };
    RenderList.prototype.findID = function (id) {
        var e_5, _a;
        try {
            for (var _b = __values(this.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                if (item.item.id === id) {
                    return item.item;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return null;
    };
    return RenderList;
}(PrioritizedList_js_1.PrioritizedList));
exports.RenderList = RenderList;
exports.resetOptions = {
    all: false,
    processed: false,
    inputJax: null,
    outputJax: null
};
exports.resetAllOptions = {
    all: true,
    processed: true,
    inputJax: [],
    outputJax: []
};
var DefaultInputJax = (function (_super) {
    __extends(DefaultInputJax, _super);
    function DefaultInputJax() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultInputJax.prototype.compile = function (_math) {
        return null;
    };
    return DefaultInputJax;
}(InputJax_js_1.AbstractInputJax));
var DefaultOutputJax = (function (_super) {
    __extends(DefaultOutputJax, _super);
    function DefaultOutputJax() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DefaultOutputJax.prototype.typeset = function (_math, _document) {
        if (_document === void 0) { _document = null; }
        return null;
    };
    DefaultOutputJax.prototype.escaped = function (_math, _document) {
        return null;
    };
    return DefaultOutputJax;
}(OutputJax_js_1.AbstractOutputJax));
var DefaultMathList = (function (_super) {
    __extends(DefaultMathList, _super);
    function DefaultMathList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DefaultMathList;
}(MathList_js_1.AbstractMathList));
var DefaultMathItem = (function (_super) {
    __extends(DefaultMathItem, _super);
    function DefaultMathItem() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return DefaultMathItem;
}(MathItem_js_1.AbstractMathItem));
var AbstractMathDocument = (function () {
    function AbstractMathDocument(document, adaptor, options) {
        var _this = this;
        var CLASS = this.constructor;
        this.document = document;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
        this.math = new (this.options['MathList'] || DefaultMathList)();
        this.renderActions = RenderList.create(this.options['renderActions']);
        this.processed = new AbstractMathDocument.ProcessBits();
        this.outputJax = this.options['OutputJax'] || new DefaultOutputJax();
        var inputJax = this.options['InputJax'] || [new DefaultInputJax()];
        if (!Array.isArray(inputJax)) {
            inputJax = [inputJax];
        }
        this.inputJax = inputJax;
        this.adaptor = adaptor;
        this.outputJax.setAdaptor(adaptor);
        this.inputJax.map(function (jax) { return jax.setAdaptor(adaptor); });
        this.mmlFactory = this.options['MmlFactory'] || new MmlFactory_js_1.MmlFactory();
        this.inputJax.map(function (jax) { return jax.setMmlFactory(_this.mmlFactory); });
        this.outputJax.initialize();
        this.inputJax.map(function (jax) { return jax.initialize(); });
    }
    Object.defineProperty(AbstractMathDocument.prototype, "kind", {
        get: function () {
            return this.constructor.KIND;
        },
        enumerable: false,
        configurable: true
    });
    AbstractMathDocument.prototype.addRenderAction = function (id) {
        var action = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            action[_i - 1] = arguments[_i];
        }
        var _a = __read(RenderList.action(id, action), 2), fn = _a[0], p = _a[1];
        this.renderActions.add(fn, p);
    };
    AbstractMathDocument.prototype.removeRenderAction = function (id) {
        var action = this.renderActions.findID(id);
        if (action) {
            this.renderActions.remove(action);
        }
    };
    AbstractMathDocument.prototype.render = function () {
        this.renderActions.renderDoc(this);
        return this;
    };
    AbstractMathDocument.prototype.rerender = function (start) {
        if (start === void 0) { start = MathItem_js_1.STATE.RERENDER; }
        this.state(start - 1);
        this.render();
        return this;
    };
    AbstractMathDocument.prototype.convert = function (math, options) {
        if (options === void 0) { options = {}; }
        var _a = (0, Options_js_1.userOptions)({
            format: this.inputJax[0].name, display: true, end: MathItem_js_1.STATE.LAST,
            em: 16, ex: 8, containerWidth: null, lineWidth: 1000000, scale: 1, family: ''
        }, options), format = _a.format, display = _a.display, end = _a.end, ex = _a.ex, em = _a.em, containerWidth = _a.containerWidth, lineWidth = _a.lineWidth, scale = _a.scale, family = _a.family;
        if (containerWidth === null) {
            containerWidth = 80 * ex;
        }
        var jax = this.inputJax.reduce(function (jax, ijax) { return (ijax.name === format ? ijax : jax); }, null);
        var mitem = new this.options.MathItem(math, jax, display);
        mitem.start.node = this.adaptor.body(this.document);
        mitem.setMetrics(em, ex, containerWidth, lineWidth, scale);
        if (this.outputJax.options.mtextInheritFont) {
            mitem.outputData.mtextFamily = family;
        }
        if (this.outputJax.options.merrorInheritFont) {
            mitem.outputData.merrorFamily = family;
        }
        mitem.convert(this, end);
        return (mitem.typesetRoot || mitem.root);
    };
    AbstractMathDocument.prototype.findMath = function (_options) {
        if (_options === void 0) { _options = null; }
        this.processed.set('findMath');
        return this;
    };
    AbstractMathDocument.prototype.compile = function () {
        var e_6, _a, e_7, _b;
        if (!this.processed.isSet('compile')) {
            var recompile = [];
            try {
                for (var _c = __values(this.math), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var math = _d.value;
                    this.compileMath(math);
                    if (math.inputData.recompile !== undefined) {
                        recompile.push(math);
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_6) throw e_6.error; }
            }
            try {
                for (var recompile_1 = __values(recompile), recompile_1_1 = recompile_1.next(); !recompile_1_1.done; recompile_1_1 = recompile_1.next()) {
                    var math = recompile_1_1.value;
                    var data = math.inputData.recompile;
                    math.state(data.state);
                    math.inputData.recompile = data;
                    this.compileMath(math);
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (recompile_1_1 && !recompile_1_1.done && (_b = recompile_1.return)) _b.call(recompile_1);
                }
                finally { if (e_7) throw e_7.error; }
            }
            this.processed.set('compile');
        }
        return this;
    };
    AbstractMathDocument.prototype.compileMath = function (math) {
        try {
            math.compile(this);
        }
        catch (err) {
            if (err.retry || err.restart) {
                throw err;
            }
            this.options['compileError'](this, math, err);
            math.inputData['error'] = err;
        }
    };
    AbstractMathDocument.prototype.compileError = function (math, err) {
        math.root = this.mmlFactory.create('math', null, [
            this.mmlFactory.create('merror', { 'data-mjx-error': err.message, title: err.message }, [
                this.mmlFactory.create('mtext', null, [
                    this.mmlFactory.create('text').setText('Math input error')
                ])
            ])
        ]);
        if (math.display) {
            math.root.attributes.set('display', 'block');
        }
        math.inputData.error = err.message;
    };
    AbstractMathDocument.prototype.typeset = function () {
        var e_8, _a;
        if (!this.processed.isSet('typeset')) {
            try {
                for (var _b = __values(this.math), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var math = _c.value;
                    try {
                        math.typeset(this);
                    }
                    catch (err) {
                        if (err.retry || err.restart) {
                            throw err;
                        }
                        this.options['typesetError'](this, math, err);
                        math.outputData['error'] = err;
                    }
                }
            }
            catch (e_8_1) { e_8 = { error: e_8_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_8) throw e_8.error; }
            }
            this.processed.set('typeset');
        }
        return this;
    };
    AbstractMathDocument.prototype.typesetError = function (math, err) {
        math.typesetRoot = this.adaptor.node('mjx-container', {
            class: 'MathJax mjx-output-error',
            jax: this.outputJax.name,
        }, [
            this.adaptor.node('span', {
                'data-mjx-error': err.message,
                title: err.message,
                style: {
                    color: 'red',
                    'background-color': 'yellow',
                    'line-height': 'normal'
                }
            }, [
                this.adaptor.text('Math output error')
            ])
        ]);
        if (math.display) {
            this.adaptor.setAttributes(math.typesetRoot, {
                style: {
                    display: 'block',
                    margin: '1em 0',
                    'text-align': 'center'
                }
            });
        }
        math.outputData.error = err.message;
    };
    AbstractMathDocument.prototype.getMetrics = function () {
        if (!this.processed.isSet('getMetrics')) {
            this.outputJax.getMetrics(this);
            this.processed.set('getMetrics');
        }
        return this;
    };
    AbstractMathDocument.prototype.updateDocument = function () {
        var e_9, _a;
        if (!this.processed.isSet('updateDocument')) {
            try {
                for (var _b = __values(this.math.reversed()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var math = _c.value;
                    math.updateDocument(this);
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_9) throw e_9.error; }
            }
            this.processed.set('updateDocument');
        }
        return this;
    };
    AbstractMathDocument.prototype.removeFromDocument = function (_restore) {
        if (_restore === void 0) { _restore = false; }
        return this;
    };
    AbstractMathDocument.prototype.state = function (state, restore) {
        var e_10, _a;
        if (restore === void 0) { restore = false; }
        try {
            for (var _b = __values(this.math), _c = _b.next(); !_c.done; _c = _b.next()) {
                var math = _c.value;
                math.state(state, restore);
            }
        }
        catch (e_10_1) { e_10 = { error: e_10_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_10) throw e_10.error; }
        }
        if (state < MathItem_js_1.STATE.INSERTED) {
            this.processed.clear('updateDocument');
        }
        if (state < MathItem_js_1.STATE.TYPESET) {
            this.processed.clear('typeset');
            this.processed.clear('getMetrics');
        }
        if (state < MathItem_js_1.STATE.COMPILED) {
            this.processed.clear('compile');
        }
        return this;
    };
    AbstractMathDocument.prototype.reset = function (options) {
        var _a;
        if (options === void 0) { options = { processed: true }; }
        options = (0, Options_js_1.userOptions)(Object.assign({}, exports.resetOptions), options);
        options.all && Object.assign(options, exports.resetAllOptions);
        options.processed && this.processed.reset();
        options.inputJax && this.inputJax.forEach(function (jax) { return jax.reset.apply(jax, __spreadArray([], __read(options.inputJax), false)); });
        options.outputJax && (_a = this.outputJax).reset.apply(_a, __spreadArray([], __read(options.outputJax), false));
        return this;
    };
    AbstractMathDocument.prototype.clear = function () {
        this.reset();
        this.math.clear();
        return this;
    };
    AbstractMathDocument.prototype.concat = function (list) {
        this.math.merge(list);
        return this;
    };
    AbstractMathDocument.prototype.clearMathItemsWithin = function (containers) {
        var _a;
        var items = this.getMathItemsWithin(containers);
        (_a = this.math).remove.apply(_a, __spreadArray([], __read(items), false));
        return items;
    };
    AbstractMathDocument.prototype.getMathItemsWithin = function (elements) {
        var e_11, _a, e_12, _b;
        if (!Array.isArray(elements)) {
            elements = [elements];
        }
        var adaptor = this.adaptor;
        var items = [];
        var containers = adaptor.getElements(elements, this.document);
        try {
            ITEMS: for (var _c = __values(this.math), _d = _c.next(); !_d.done; _d = _c.next()) {
                var item = _d.value;
                try {
                    for (var containers_1 = (e_12 = void 0, __values(containers)), containers_1_1 = containers_1.next(); !containers_1_1.done; containers_1_1 = containers_1.next()) {
                        var container = containers_1_1.value;
                        if (item.start.node && adaptor.contains(container, item.start.node)) {
                            items.push(item);
                            continue ITEMS;
                        }
                    }
                }
                catch (e_12_1) { e_12 = { error: e_12_1 }; }
                finally {
                    try {
                        if (containers_1_1 && !containers_1_1.done && (_b = containers_1.return)) _b.call(containers_1);
                    }
                    finally { if (e_12) throw e_12.error; }
                }
            }
        }
        catch (e_11_1) { e_11 = { error: e_11_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_11) throw e_11.error; }
        }
        return items;
    };
    AbstractMathDocument.KIND = 'MathDocument';
    AbstractMathDocument.OPTIONS = {
        OutputJax: null,
        InputJax: null,
        MmlFactory: null,
        MathList: DefaultMathList,
        MathItem: DefaultMathItem,
        compileError: function (doc, math, err) {
            doc.compileError(math, err);
        },
        typesetError: function (doc, math, err) {
            doc.typesetError(math, err);
        },
        renderActions: (0, Options_js_1.expandable)({
            find: [MathItem_js_1.STATE.FINDMATH, 'findMath', '', false],
            compile: [MathItem_js_1.STATE.COMPILED],
            metrics: [MathItem_js_1.STATE.METRICS, 'getMetrics', '', false],
            typeset: [MathItem_js_1.STATE.TYPESET],
            update: [MathItem_js_1.STATE.INSERTED, 'updateDocument', false]
        })
    };
    AbstractMathDocument.ProcessBits = (0, BitField_js_1.BitFieldClass)('findMath', 'compile', 'getMetrics', 'typeset', 'updateDocument');
    return AbstractMathDocument;
}());
exports.AbstractMathDocument = AbstractMathDocument;
//# sourceMappingURL=MathDocument.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/MathList.js":
/*!*******************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/MathList.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMathList = void 0;
var LinkedList_js_1 = __webpack_require__(/*! ../util/LinkedList.js */ "./node_modules/mathjax-full/js/util/LinkedList.js");
var AbstractMathList = (function (_super) {
    __extends(AbstractMathList, _super);
    function AbstractMathList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractMathList.prototype.isBefore = function (a, b) {
        return (a.start.i < b.start.i || (a.start.i === b.start.i && a.start.n < b.start.n));
    };
    return AbstractMathList;
}(LinkedList_js_1.LinkedList));
exports.AbstractMathList = AbstractMathList;
//# sourceMappingURL=MathList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/OutputJax.js":
/*!********************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/OutputJax.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractOutputJax = void 0;
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var FunctionList_js_1 = __webpack_require__(/*! ../util/FunctionList.js */ "./node_modules/mathjax-full/js/util/FunctionList.js");
var AbstractOutputJax = (function () {
    function AbstractOutputJax(options) {
        if (options === void 0) { options = {}; }
        this.adaptor = null;
        var CLASS = this.constructor;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
        this.postFilters = new FunctionList_js_1.FunctionList();
    }
    Object.defineProperty(AbstractOutputJax.prototype, "name", {
        get: function () {
            return this.constructor.NAME;
        },
        enumerable: false,
        configurable: true
    });
    AbstractOutputJax.prototype.setAdaptor = function (adaptor) {
        this.adaptor = adaptor;
    };
    AbstractOutputJax.prototype.initialize = function () {
    };
    AbstractOutputJax.prototype.reset = function () {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
    };
    AbstractOutputJax.prototype.getMetrics = function (_document) {
    };
    AbstractOutputJax.prototype.styleSheet = function (_document) {
        return null;
    };
    AbstractOutputJax.prototype.pageElements = function (_document) {
        return null;
    };
    AbstractOutputJax.prototype.executeFilters = function (filters, math, document, data) {
        var args = { math: math, document: document, data: data };
        filters.execute(args);
        return args.data;
    };
    AbstractOutputJax.NAME = 'generic';
    AbstractOutputJax.OPTIONS = {};
    return AbstractOutputJax;
}());
exports.AbstractOutputJax = AbstractOutputJax;
//# sourceMappingURL=OutputJax.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/handlers/html/HTMLDocument.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/handlers/html/HTMLDocument.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTMLDocument = void 0;
var MathDocument_js_1 = __webpack_require__(/*! ../../core/MathDocument.js */ "./node_modules/mathjax-full/js/core/MathDocument.js");
var Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var HTMLMathItem_js_1 = __webpack_require__(/*! ./HTMLMathItem.js */ "./node_modules/mathjax-full/js/handlers/html/HTMLMathItem.js");
var HTMLMathList_js_1 = __webpack_require__(/*! ./HTMLMathList.js */ "./node_modules/mathjax-full/js/handlers/html/HTMLMathList.js");
var HTMLDomStrings_js_1 = __webpack_require__(/*! ./HTMLDomStrings.js */ "./node_modules/mathjax-full/js/handlers/html/HTMLDomStrings.js");
var MathItem_js_1 = __webpack_require__(/*! ../../core/MathItem.js */ "./node_modules/mathjax-full/js/core/MathItem.js");
var HTMLDocument = (function (_super) {
    __extends(HTMLDocument, _super);
    function HTMLDocument(document, adaptor, options) {
        var _this = this;
        var _a = __read((0, Options_js_1.separateOptions)(options, HTMLDomStrings_js_1.HTMLDomStrings.OPTIONS), 2), html = _a[0], dom = _a[1];
        _this = _super.call(this, document, adaptor, html) || this;
        _this.domStrings = _this.options['DomStrings'] || new HTMLDomStrings_js_1.HTMLDomStrings(dom);
        _this.domStrings.adaptor = adaptor;
        _this.styles = [];
        return _this;
    }
    HTMLDocument.prototype.findPosition = function (N, index, delim, nodes) {
        var e_1, _a;
        var adaptor = this.adaptor;
        try {
            for (var _b = __values(nodes[N]), _c = _b.next(); !_c.done; _c = _b.next()) {
                var list = _c.value;
                var _d = __read(list, 2), node = _d[0], n = _d[1];
                if (index <= n && adaptor.kind(node) === '#text') {
                    return { node: node, n: Math.max(index, 0), delim: delim };
                }
                index -= n;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return { node: null, n: 0, delim: delim };
    };
    HTMLDocument.prototype.mathItem = function (item, jax, nodes) {
        var math = item.math;
        var start = this.findPosition(item.n, item.start.n, item.open, nodes);
        var end = this.findPosition(item.n, item.end.n, item.close, nodes);
        return new this.options.MathItem(math, jax, item.display, start, end);
    };
    HTMLDocument.prototype.findMath = function (options) {
        var e_2, _a, e_3, _b, _c, e_4, _d, e_5, _e;
        if (!this.processed.isSet('findMath')) {
            this.adaptor.document = this.document;
            options = (0, Options_js_1.userOptions)({ elements: this.options.elements || [this.adaptor.body(this.document)] }, options);
            try {
                for (var _f = __values(this.adaptor.getElements(options['elements'], this.document)), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var container = _g.value;
                    var _h = __read([null, null], 2), strings = _h[0], nodes = _h[1];
                    try {
                        for (var _j = (e_3 = void 0, __values(this.inputJax)), _k = _j.next(); !_k.done; _k = _j.next()) {
                            var jax = _k.value;
                            var list = new (this.options['MathList'])();
                            if (jax.processStrings) {
                                if (strings === null) {
                                    _c = __read(this.domStrings.find(container), 2), strings = _c[0], nodes = _c[1];
                                }
                                try {
                                    for (var _l = (e_4 = void 0, __values(jax.findMath(strings))), _m = _l.next(); !_m.done; _m = _l.next()) {
                                        var math = _m.value;
                                        list.push(this.mathItem(math, jax, nodes));
                                    }
                                }
                                catch (e_4_1) { e_4 = { error: e_4_1 }; }
                                finally {
                                    try {
                                        if (_m && !_m.done && (_d = _l.return)) _d.call(_l);
                                    }
                                    finally { if (e_4) throw e_4.error; }
                                }
                            }
                            else {
                                try {
                                    for (var _o = (e_5 = void 0, __values(jax.findMath(container))), _p = _o.next(); !_p.done; _p = _o.next()) {
                                        var math = _p.value;
                                        var item = new this.options.MathItem(math.math, jax, math.display, math.start, math.end);
                                        list.push(item);
                                    }
                                }
                                catch (e_5_1) { e_5 = { error: e_5_1 }; }
                                finally {
                                    try {
                                        if (_p && !_p.done && (_e = _o.return)) _e.call(_o);
                                    }
                                    finally { if (e_5) throw e_5.error; }
                                }
                            }
                            this.math.merge(list);
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (_k && !_k.done && (_b = _j.return)) _b.call(_j);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_a = _f.return)) _a.call(_f);
                }
                finally { if (e_2) throw e_2.error; }
            }
            this.processed.set('findMath');
        }
        return this;
    };
    HTMLDocument.prototype.updateDocument = function () {
        if (!this.processed.isSet('updateDocument')) {
            this.addPageElements();
            this.addStyleSheet();
            _super.prototype.updateDocument.call(this);
            this.processed.set('updateDocument');
        }
        return this;
    };
    HTMLDocument.prototype.addPageElements = function () {
        var body = this.adaptor.body(this.document);
        var node = this.documentPageElements();
        if (node) {
            this.adaptor.append(body, node);
        }
    };
    HTMLDocument.prototype.addStyleSheet = function () {
        var sheet = this.documentStyleSheet();
        var adaptor = this.adaptor;
        if (sheet && !adaptor.parent(sheet)) {
            var head = adaptor.head(this.document);
            var styles = this.findSheet(head, adaptor.getAttribute(sheet, 'id'));
            if (styles) {
                adaptor.replace(sheet, styles);
            }
            else {
                adaptor.append(head, sheet);
            }
        }
    };
    HTMLDocument.prototype.findSheet = function (head, id) {
        var e_6, _a;
        if (id) {
            try {
                for (var _b = __values(this.adaptor.tags(head, 'style')), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var sheet = _c.value;
                    if (this.adaptor.getAttribute(sheet, 'id') === id) {
                        return sheet;
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_6) throw e_6.error; }
            }
        }
        return null;
    };
    HTMLDocument.prototype.removeFromDocument = function (restore) {
        var e_7, _a;
        if (restore === void 0) { restore = false; }
        if (this.processed.isSet('updateDocument')) {
            try {
                for (var _b = __values(this.math), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var math = _c.value;
                    if (math.state() >= MathItem_js_1.STATE.INSERTED) {
                        math.state(MathItem_js_1.STATE.TYPESET, restore);
                    }
                }
            }
            catch (e_7_1) { e_7 = { error: e_7_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_7) throw e_7.error; }
            }
        }
        this.processed.clear('updateDocument');
        return this;
    };
    HTMLDocument.prototype.documentStyleSheet = function () {
        return this.outputJax.styleSheet(this);
    };
    HTMLDocument.prototype.documentPageElements = function () {
        return this.outputJax.pageElements(this);
    };
    HTMLDocument.prototype.addStyles = function (styles) {
        this.styles.push(styles);
    };
    HTMLDocument.prototype.getStyles = function () {
        return this.styles;
    };
    HTMLDocument.KIND = 'HTML';
    HTMLDocument.OPTIONS = __assign(__assign({}, MathDocument_js_1.AbstractMathDocument.OPTIONS), { renderActions: (0, Options_js_1.expandable)(__assign(__assign({}, MathDocument_js_1.AbstractMathDocument.OPTIONS.renderActions), { styles: [MathItem_js_1.STATE.INSERTED + 1, '', 'updateStyleSheet', false] })), MathList: HTMLMathList_js_1.HTMLMathList, MathItem: HTMLMathItem_js_1.HTMLMathItem, DomStrings: null });
    return HTMLDocument;
}(MathDocument_js_1.AbstractMathDocument));
exports.HTMLDocument = HTMLDocument;
//# sourceMappingURL=HTMLDocument.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/handlers/html/HTMLDomStrings.js":
/*!**********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/handlers/html/HTMLDomStrings.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTMLDomStrings = void 0;
var Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var HTMLDomStrings = (function () {
    function HTMLDomStrings(options) {
        if (options === void 0) { options = null; }
        var CLASS = this.constructor;
        this.options = (0, Options_js_1.userOptions)((0, Options_js_1.defaultOptions)({}, CLASS.OPTIONS), options);
        this.init();
        this.getPatterns();
    }
    HTMLDomStrings.prototype.init = function () {
        this.strings = [];
        this.string = '';
        this.snodes = [];
        this.nodes = [];
        this.stack = [];
    };
    HTMLDomStrings.prototype.getPatterns = function () {
        var skip = (0, Options_js_1.makeArray)(this.options['skipHtmlTags']);
        var ignore = (0, Options_js_1.makeArray)(this.options['ignoreHtmlClass']);
        var process = (0, Options_js_1.makeArray)(this.options['processHtmlClass']);
        this.skipHtmlTags = new RegExp('^(?:' + skip.join('|') + ')$', 'i');
        this.ignoreHtmlClass = new RegExp('(?:^| )(?:' + ignore.join('|') + ')(?: |$)');
        this.processHtmlClass = new RegExp('(?:^| )(?:' + process + ')(?: |$)');
    };
    HTMLDomStrings.prototype.pushString = function () {
        if (this.string.match(/\S/)) {
            this.strings.push(this.string);
            this.nodes.push(this.snodes);
        }
        this.string = '';
        this.snodes = [];
    };
    HTMLDomStrings.prototype.extendString = function (node, text) {
        this.snodes.push([node, text.length]);
        this.string += text;
    };
    HTMLDomStrings.prototype.handleText = function (node, ignore) {
        if (!ignore) {
            this.extendString(node, this.adaptor.value(node));
        }
        return this.adaptor.next(node);
    };
    HTMLDomStrings.prototype.handleTag = function (node, ignore) {
        if (!ignore) {
            var text = this.options['includeHtmlTags'][this.adaptor.kind(node)];
            this.extendString(node, text);
        }
        return this.adaptor.next(node);
    };
    HTMLDomStrings.prototype.handleContainer = function (node, ignore) {
        this.pushString();
        var cname = this.adaptor.getAttribute(node, 'class') || '';
        var tname = this.adaptor.kind(node) || '';
        var process = this.processHtmlClass.exec(cname);
        var next = node;
        if (this.adaptor.firstChild(node) && !this.adaptor.getAttribute(node, 'data-MJX') &&
            (process || !this.skipHtmlTags.exec(tname))) {
            if (this.adaptor.next(node)) {
                this.stack.push([this.adaptor.next(node), ignore]);
            }
            next = this.adaptor.firstChild(node);
            ignore = (ignore || this.ignoreHtmlClass.exec(cname)) && !process;
        }
        else {
            next = this.adaptor.next(node);
        }
        return [next, ignore];
    };
    HTMLDomStrings.prototype.handleOther = function (node, _ignore) {
        this.pushString();
        return this.adaptor.next(node);
    };
    HTMLDomStrings.prototype.find = function (node) {
        var _a, _b;
        this.init();
        var stop = this.adaptor.next(node);
        var ignore = false;
        var include = this.options['includeHtmlTags'];
        while (node && node !== stop) {
            var kind = this.adaptor.kind(node);
            if (kind === '#text') {
                node = this.handleText(node, ignore);
            }
            else if (include.hasOwnProperty(kind)) {
                node = this.handleTag(node, ignore);
            }
            else if (kind) {
                _a = __read(this.handleContainer(node, ignore), 2), node = _a[0], ignore = _a[1];
            }
            else {
                node = this.handleOther(node, ignore);
            }
            if (!node && this.stack.length) {
                this.pushString();
                _b = __read(this.stack.pop(), 2), node = _b[0], ignore = _b[1];
            }
        }
        this.pushString();
        var result = [this.strings, this.nodes];
        this.init();
        return result;
    };
    HTMLDomStrings.OPTIONS = {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code', 'annotation', 'annotation-xml'],
        includeHtmlTags: { br: '\n', wbr: '', '#comment': '' },
        ignoreHtmlClass: 'mathjax_ignore',
        processHtmlClass: 'mathjax_process'
    };
    return HTMLDomStrings;
}());
exports.HTMLDomStrings = HTMLDomStrings;
//# sourceMappingURL=HTMLDomStrings.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/handlers/html/HTMLHandler.js":
/*!*******************************************************************!*\
  !*** ./node_modules/mathjax-full/js/handlers/html/HTMLHandler.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTMLHandler = void 0;
var Handler_js_1 = __webpack_require__(/*! ../../core/Handler.js */ "./node_modules/mathjax-full/js/core/Handler.js");
var HTMLDocument_js_1 = __webpack_require__(/*! ./HTMLDocument.js */ "./node_modules/mathjax-full/js/handlers/html/HTMLDocument.js");
var HTMLHandler = (function (_super) {
    __extends(HTMLHandler, _super);
    function HTMLHandler() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.documentClass = HTMLDocument_js_1.HTMLDocument;
        return _this;
    }
    HTMLHandler.prototype.handlesDocument = function (document) {
        var adaptor = this.adaptor;
        if (typeof (document) === 'string') {
            try {
                document = adaptor.parse(document, 'text/html');
            }
            catch (err) { }
        }
        if (document instanceof adaptor.window.Document ||
            document instanceof adaptor.window.HTMLElement ||
            document instanceof adaptor.window.DocumentFragment) {
            return true;
        }
        return false;
    };
    HTMLHandler.prototype.create = function (document, options) {
        var adaptor = this.adaptor;
        if (typeof (document) === 'string') {
            document = adaptor.parse(document, 'text/html');
        }
        else if (document instanceof adaptor.window.HTMLElement ||
            document instanceof adaptor.window.DocumentFragment) {
            var child = document;
            document = adaptor.parse('', 'text/html');
            adaptor.append(adaptor.body(document), child);
        }
        return _super.prototype.create.call(this, document, options);
    };
    return HTMLHandler;
}(Handler_js_1.AbstractHandler));
exports.HTMLHandler = HTMLHandler;
//# sourceMappingURL=HTMLHandler.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/handlers/html/HTMLMathItem.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/handlers/html/HTMLMathItem.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTMLMathItem = void 0;
var MathItem_js_1 = __webpack_require__(/*! ../../core/MathItem.js */ "./node_modules/mathjax-full/js/core/MathItem.js");
var HTMLMathItem = (function (_super) {
    __extends(HTMLMathItem, _super);
    function HTMLMathItem(math, jax, display, start, end) {
        if (display === void 0) { display = true; }
        if (start === void 0) { start = { node: null, n: 0, delim: '' }; }
        if (end === void 0) { end = { node: null, n: 0, delim: '' }; }
        return _super.call(this, math, jax, display, start, end) || this;
    }
    Object.defineProperty(HTMLMathItem.prototype, "adaptor", {
        get: function () {
            return this.inputJax.adaptor;
        },
        enumerable: false,
        configurable: true
    });
    HTMLMathItem.prototype.updateDocument = function (_html) {
        if (this.state() < MathItem_js_1.STATE.INSERTED) {
            if (this.inputJax.processStrings) {
                var node = this.start.node;
                if (node === this.end.node) {
                    if (this.end.n && this.end.n < this.adaptor.value(this.end.node).length) {
                        this.adaptor.split(this.end.node, this.end.n);
                    }
                    if (this.start.n) {
                        node = this.adaptor.split(this.start.node, this.start.n);
                    }
                    this.adaptor.replace(this.typesetRoot, node);
                }
                else {
                    if (this.start.n) {
                        node = this.adaptor.split(node, this.start.n);
                    }
                    while (node !== this.end.node) {
                        var next = this.adaptor.next(node);
                        this.adaptor.remove(node);
                        node = next;
                    }
                    this.adaptor.insert(this.typesetRoot, node);
                    if (this.end.n < this.adaptor.value(node).length) {
                        this.adaptor.split(node, this.end.n);
                    }
                    this.adaptor.remove(node);
                }
            }
            else {
                this.adaptor.replace(this.typesetRoot, this.start.node);
            }
            this.start.node = this.end.node = this.typesetRoot;
            this.start.n = this.end.n = 0;
            this.state(MathItem_js_1.STATE.INSERTED);
        }
    };
    HTMLMathItem.prototype.updateStyleSheet = function (document) {
        document.addStyleSheet();
    };
    HTMLMathItem.prototype.removeFromDocument = function (restore) {
        if (restore === void 0) { restore = false; }
        if (this.state() >= MathItem_js_1.STATE.TYPESET) {
            var adaptor = this.adaptor;
            var node = this.start.node;
            var math = adaptor.text('');
            if (restore) {
                var text = this.start.delim + this.math + this.end.delim;
                if (this.inputJax.processStrings) {
                    math = adaptor.text(text);
                }
                else {
                    var doc = adaptor.parse(text, 'text/html');
                    math = adaptor.firstChild(adaptor.body(doc));
                }
            }
            if (adaptor.parent(node)) {
                adaptor.replace(math, node);
            }
            this.start.node = this.end.node = math;
            this.start.n = this.end.n = 0;
        }
    };
    return HTMLMathItem;
}(MathItem_js_1.AbstractMathItem));
exports.HTMLMathItem = HTMLMathItem;
//# sourceMappingURL=HTMLMathItem.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/handlers/html/HTMLMathList.js":
/*!********************************************************************!*\
  !*** ./node_modules/mathjax-full/js/handlers/html/HTMLMathList.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HTMLMathList = void 0;
var MathList_js_1 = __webpack_require__(/*! ../../core/MathList.js */ "./node_modules/mathjax-full/js/core/MathList.js");
var HTMLMathList = (function (_super) {
    __extends(HTMLMathList, _super);
    function HTMLMathList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return HTMLMathList;
}(MathList_js_1.AbstractMathList));
exports.HTMLMathList = HTMLMathList;
//# sourceMappingURL=HTMLMathList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/BitField.js":
/*!*******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/BitField.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BitFieldClass = exports.BitField = void 0;
var BitField = (function () {
    function BitField() {
        this.bits = 0;
    }
    BitField.allocate = function () {
        var e_1, _a;
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            names[_i] = arguments[_i];
        }
        try {
            for (var names_1 = __values(names), names_1_1 = names_1.next(); !names_1_1.done; names_1_1 = names_1.next()) {
                var name_1 = names_1_1.value;
                if (this.has(name_1)) {
                    throw new Error('Bit already allocated for ' + name_1);
                }
                if (this.next === BitField.MAXBIT) {
                    throw new Error('Maximum number of bits already allocated');
                }
                this.names.set(name_1, this.next);
                this.next <<= 1;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (names_1_1 && !names_1_1.done && (_a = names_1.return)) _a.call(names_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    BitField.has = function (name) {
        return this.names.has(name);
    };
    BitField.prototype.set = function (name) {
        this.bits |= this.getBit(name);
    };
    BitField.prototype.clear = function (name) {
        this.bits &= ~this.getBit(name);
    };
    BitField.prototype.isSet = function (name) {
        return !!(this.bits & this.getBit(name));
    };
    BitField.prototype.reset = function () {
        this.bits = 0;
    };
    BitField.prototype.getBit = function (name) {
        var bit = this.constructor.names.get(name);
        if (!bit) {
            throw new Error('Unknown bit-field name: ' + name);
        }
        return bit;
    };
    BitField.MAXBIT = 1 << 31;
    BitField.next = 1;
    BitField.names = new Map();
    return BitField;
}());
exports.BitField = BitField;
function BitFieldClass() {
    var names = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        names[_i] = arguments[_i];
    }
    var Bits = (function (_super) {
        __extends(Bits, _super);
        function Bits() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        return Bits;
    }(BitField));
    Bits.allocate.apply(Bits, __spreadArray([], __read(names), false));
    return Bits;
}
exports.BitFieldClass = BitFieldClass;
//# sourceMappingURL=BitField.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/FunctionList.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/FunctionList.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionList = void 0;
var PrioritizedList_js_1 = __webpack_require__(/*! ./PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var FunctionList = (function (_super) {
    __extends(FunctionList, _super);
    function FunctionList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionList.prototype.execute = function () {
        var e_1, _a;
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                var result = item.item.apply(item, __spreadArray([], __read(data), false));
                if (result === false) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    FunctionList.prototype.asyncExecute = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        var i = -1;
        var items = this.items;
        return new Promise(function (ok, fail) {
            (function execute() {
                var _a;
                while (++i < items.length) {
                    var result = (_a = items[i]).item.apply(_a, __spreadArray([], __read(data), false));
                    if (result instanceof Promise) {
                        result.then(execute).catch(function (err) { return fail(err); });
                        return;
                    }
                    if (result === false) {
                        ok(false);
                        return;
                    }
                }
                ok(true);
            })();
        });
    };
    return FunctionList;
}(PrioritizedList_js_1.PrioritizedList));
exports.FunctionList = FunctionList;
//# sourceMappingURL=FunctionList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/LinkedList.js":
/*!*********************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/LinkedList.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports) {


var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LinkedList = exports.ListItem = exports.END = void 0;
exports.END = Symbol();
var ListItem = (function () {
    function ListItem(data) {
        if (data === void 0) { data = null; }
        this.next = null;
        this.prev = null;
        this.data = data;
    }
    return ListItem;
}());
exports.ListItem = ListItem;
var LinkedList = (function () {
    function LinkedList() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        this.list = new ListItem(exports.END);
        this.list.next = this.list.prev = this.list;
        this.push.apply(this, __spreadArray([], __read(args), false));
    }
    LinkedList.prototype.isBefore = function (a, b) {
        return a < b;
    };
    LinkedList.prototype.push = function () {
        var e_1, _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var data = args_1_1.value;
                var item = new ListItem(data);
                item.next = this.list;
                item.prev = this.list.prev;
                this.list.prev = item;
                item.prev.next = item;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return this;
    };
    LinkedList.prototype.pop = function () {
        var item = this.list.prev;
        if (item.data === exports.END) {
            return null;
        }
        this.list.prev = item.prev;
        item.prev.next = this.list;
        item.next = item.prev = null;
        return item.data;
    };
    LinkedList.prototype.unshift = function () {
        var e_2, _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            for (var _b = __values(args.slice(0).reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var data = _c.value;
                var item = new ListItem(data);
                item.next = this.list.next;
                item.prev = this.list;
                this.list.next = item;
                item.next.prev = item;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return this;
    };
    LinkedList.prototype.shift = function () {
        var item = this.list.next;
        if (item.data === exports.END) {
            return null;
        }
        this.list.next = item.next;
        item.next.prev = this.list;
        item.next = item.prev = null;
        return item.data;
    };
    LinkedList.prototype.remove = function () {
        var e_3, _a;
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        var map = new Map();
        try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                var item_1 = items_1_1.value;
                map.set(item_1, true);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (items_1_1 && !items_1_1.done && (_a = items_1.return)) _a.call(items_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        var item = this.list.next;
        while (item.data !== exports.END) {
            var next = item.next;
            if (map.has(item.data)) {
                item.prev.next = item.next;
                item.next.prev = item.prev;
                item.next = item.prev = null;
            }
            item = next;
        }
    };
    LinkedList.prototype.clear = function () {
        this.list.next.prev = this.list.prev.next = null;
        this.list.next = this.list.prev = this.list;
        return this;
    };
    LinkedList.prototype[Symbol.iterator] = function () {
        var current;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    current = this.list.next;
                    _a.label = 1;
                case 1:
                    if (!(current.data !== exports.END)) return [3, 3];
                    return [4, current.data];
                case 2:
                    _a.sent();
                    current = current.next;
                    return [3, 1];
                case 3: return [2];
            }
        });
    };
    LinkedList.prototype.reversed = function () {
        var current;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    current = this.list.prev;
                    _a.label = 1;
                case 1:
                    if (!(current.data !== exports.END)) return [3, 3];
                    return [4, current.data];
                case 2:
                    _a.sent();
                    current = current.prev;
                    return [3, 1];
                case 3: return [2];
            }
        });
    };
    LinkedList.prototype.insert = function (data, isBefore) {
        if (isBefore === void 0) { isBefore = null; }
        if (isBefore === null) {
            isBefore = this.isBefore.bind(this);
        }
        var item = new ListItem(data);
        var cur = this.list.next;
        while (cur.data !== exports.END && isBefore(cur.data, item.data)) {
            cur = cur.next;
        }
        item.prev = cur.prev;
        item.next = cur;
        cur.prev.next = cur.prev = item;
        return this;
    };
    LinkedList.prototype.sort = function (isBefore) {
        var e_4, _a;
        if (isBefore === void 0) { isBefore = null; }
        if (isBefore === null) {
            isBefore = this.isBefore.bind(this);
        }
        var lists = [];
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                lists.push(new LinkedList(item));
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        this.list.next = this.list.prev = this.list;
        while (lists.length > 1) {
            var l1 = lists.shift();
            var l2 = lists.shift();
            l1.merge(l2, isBefore);
            lists.push(l1);
        }
        if (lists.length) {
            this.list = lists[0].list;
        }
        return this;
    };
    LinkedList.prototype.merge = function (list, isBefore) {
        var _a, _b, _c, _d, _e;
        if (isBefore === void 0) { isBefore = null; }
        if (isBefore === null) {
            isBefore = this.isBefore.bind(this);
        }
        var lcur = this.list.next;
        var mcur = list.list.next;
        while (lcur.data !== exports.END && mcur.data !== exports.END) {
            if (isBefore(mcur.data, lcur.data)) {
                _a = __read([lcur, mcur], 2), mcur.prev.next = _a[0], lcur.prev.next = _a[1];
                _b = __read([lcur.prev, mcur.prev], 2), mcur.prev = _b[0], lcur.prev = _b[1];
                _c = __read([list.list, this.list], 2), this.list.prev.next = _c[0], list.list.prev.next = _c[1];
                _d = __read([list.list.prev, this.list.prev], 2), this.list.prev = _d[0], list.list.prev = _d[1];
                _e = __read([mcur.next, lcur], 2), lcur = _e[0], mcur = _e[1];
            }
            else {
                lcur = lcur.next;
            }
        }
        if (mcur.data !== exports.END) {
            this.list.prev.next = list.list.next;
            list.list.next.prev = this.list.prev;
            list.list.prev.next = this.list;
            this.list.prev = list.list.prev;
            list.list.next = list.list.prev = list.list;
        }
        return this;
    };
    return LinkedList;
}());
exports.LinkedList = LinkedList;
//# sourceMappingURL=LinkedList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/PrioritizedList.js":
/*!**************************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/PrioritizedList.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrioritizedList = void 0;
var PrioritizedList = (function () {
    function PrioritizedList() {
        this.items = [];
        this.items = [];
    }
    PrioritizedList.prototype[Symbol.iterator] = function () {
        var i = 0;
        var items = this.items;
        return {
            next: function () {
                return { value: items[i++], done: (i > items.length) };
            }
        };
    };
    PrioritizedList.prototype.add = function (item, priority) {
        if (priority === void 0) { priority = PrioritizedList.DEFAULTPRIORITY; }
        var i = this.items.length;
        do {
            i--;
        } while (i >= 0 && priority < this.items[i].priority);
        this.items.splice(i + 1, 0, { item: item, priority: priority });
        return item;
    };
    PrioritizedList.prototype.remove = function (item) {
        var i = this.items.length;
        do {
            i--;
        } while (i >= 0 && this.items[i].item !== item);
        if (i >= 0) {
            this.items.splice(i, 1);
        }
    };
    PrioritizedList.DEFAULTPRIORITY = 5;
    return PrioritizedList;
}());
exports.PrioritizedList = PrioritizedList;
//# sourceMappingURL=PrioritizedList.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2hhbmRsZXJzX2h0bWxfSFRNTEhhbmRsZXJfanMuMjNjNzk4MTc3YzUyNjU3Mzg5ZTYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRCw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCO0FBQ3ZCLHdCQUF3QixtQkFBTyxDQUFDLDhFQUFtQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCOzs7Ozs7Ozs7O0FDbERhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixtQkFBbUIsbUJBQU8sQ0FBQywwRUFBb0I7QUFDL0Msd0JBQXdCLG1CQUFPLENBQUMsb0ZBQXlCO0FBQ3pEO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FB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O0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsa0JBQWtCO0FBQ2xCOzs7Ozs7Ozs7O0FDdlRhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Ysc0NBQXNDLGdDQUFnQztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHVCQUF1QjtBQUN2QiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29yZS9IYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29yZS9JbnB1dEpheC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvTWF0aERvY3VtZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29yZS9NYXRoTGlzdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvT3V0cHV0SmF4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaGFuZGxlcnMvaHRtbC9IVE1MRG9jdW1lbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9oYW5kbGVycy9odG1sL0hUTUxEb21TdHJpbmdzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaGFuZGxlcnMvaHRtbC9IVE1MSGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2hhbmRsZXJzL2h0bWwvSFRNTE1hdGhJdGVtLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaGFuZGxlcnMvaHRtbC9IVE1MTWF0aExpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL0JpdEZpZWxkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9GdW5jdGlvbkxpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL0xpbmtlZExpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL1ByaW9yaXRpemVkTGlzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0SGFuZGxlciA9IHZvaWQgMDtcbnZhciBNYXRoRG9jdW1lbnRfanNfMSA9IHJlcXVpcmUoXCIuL01hdGhEb2N1bWVudC5qc1wiKTtcbnZhciBEZWZhdWx0TWF0aERvY3VtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdE1hdGhEb2N1bWVudCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0TWF0aERvY3VtZW50KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIHJldHVybiBEZWZhdWx0TWF0aERvY3VtZW50O1xufShNYXRoRG9jdW1lbnRfanNfMS5BYnN0cmFjdE1hdGhEb2N1bWVudCkpO1xudmFyIEFic3RyYWN0SGFuZGxlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RIYW5kbGVyKGFkYXB0b3IsIHByaW9yaXR5KSB7XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gNTsgfVxuICAgICAgICB0aGlzLmRvY3VtZW50Q2xhc3MgPSBEZWZhdWx0TWF0aERvY3VtZW50O1xuICAgICAgICB0aGlzLmFkYXB0b3IgPSBhZGFwdG9yO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdEhhbmRsZXIucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLk5BTUU7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdEhhbmRsZXIucHJvdG90eXBlLmhhbmRsZXNEb2N1bWVudCA9IGZ1bmN0aW9uIChfZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgQWJzdHJhY3RIYW5kbGVyLnByb3RvdHlwZS5jcmVhdGUgPSBmdW5jdGlvbiAoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0aGlzLmRvY3VtZW50Q2xhc3MoZG9jdW1lbnQsIHRoaXMuYWRhcHRvciwgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdEhhbmRsZXIuTkFNRSA9ICdnZW5lcmljJztcbiAgICByZXR1cm4gQWJzdHJhY3RIYW5kbGVyO1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RIYW5kbGVyID0gQWJzdHJhY3RIYW5kbGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RJbnB1dEpheCA9IHZvaWQgMDtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xudmFyIEZ1bmN0aW9uTGlzdF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvRnVuY3Rpb25MaXN0LmpzXCIpO1xudmFyIEFic3RyYWN0SW5wdXRKYXggPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEFic3RyYWN0SW5wdXRKYXgob3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB0aGlzLmFkYXB0b3IgPSBudWxsO1xuICAgICAgICB0aGlzLm1tbEZhY3RvcnkgPSBudWxsO1xuICAgICAgICB2YXIgQ0xBU1MgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgT3B0aW9uc19qc18xLnVzZXJPcHRpb25zKSgoMCwgT3B0aW9uc19qc18xLmRlZmF1bHRPcHRpb25zKSh7fSwgQ0xBU1MuT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnByZUZpbHRlcnMgPSBuZXcgRnVuY3Rpb25MaXN0X2pzXzEuRnVuY3Rpb25MaXN0KCk7XG4gICAgICAgIHRoaXMucG9zdEZpbHRlcnMgPSBuZXcgRnVuY3Rpb25MaXN0X2pzXzEuRnVuY3Rpb25MaXN0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdElucHV0SmF4LnByb3RvdHlwZSwgXCJuYW1lXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5OQU1FO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RJbnB1dEpheC5wcm90b3R5cGUuc2V0QWRhcHRvciA9IGZ1bmN0aW9uIChhZGFwdG9yKSB7XG4gICAgICAgIHRoaXMuYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgfTtcbiAgICBBYnN0cmFjdElucHV0SmF4LnByb3RvdHlwZS5zZXRNbWxGYWN0b3J5ID0gZnVuY3Rpb24gKG1tbEZhY3RvcnkpIHtcbiAgICAgICAgdGhpcy5tbWxGYWN0b3J5ID0gbW1sRmFjdG9yeTtcbiAgICB9O1xuICAgIEFic3RyYWN0SW5wdXRKYXgucHJvdG90eXBlLmluaXRpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgfTtcbiAgICBBYnN0cmFjdElucHV0SmF4LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RJbnB1dEpheC5wcm90b3R5cGUsIFwicHJvY2Vzc1N0cmluZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RJbnB1dEpheC5wcm90b3R5cGUuZmluZE1hdGggPSBmdW5jdGlvbiAoX25vZGUsIF9vcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9O1xuICAgIEFic3RyYWN0SW5wdXRKYXgucHJvdG90eXBlLmV4ZWN1dGVGaWx0ZXJzID0gZnVuY3Rpb24gKGZpbHRlcnMsIG1hdGgsIGRvY3VtZW50LCBkYXRhKSB7XG4gICAgICAgIHZhciBhcmdzID0geyBtYXRoOiBtYXRoLCBkb2N1bWVudDogZG9jdW1lbnQsIGRhdGE6IGRhdGEgfTtcbiAgICAgICAgZmlsdGVycy5leGVjdXRlKGFyZ3MpO1xuICAgICAgICByZXR1cm4gYXJncy5kYXRhO1xuICAgIH07XG4gICAgQWJzdHJhY3RJbnB1dEpheC5OQU1FID0gJ2dlbmVyaWMnO1xuICAgIEFic3RyYWN0SW5wdXRKYXguT1BUSU9OUyA9IHt9O1xuICAgIHJldHVybiBBYnN0cmFjdElucHV0SmF4O1xufSgpKTtcbmV4cG9ydHMuQWJzdHJhY3RJbnB1dEpheCA9IEFic3RyYWN0SW5wdXRKYXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbnB1dEpheC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFic3RyYWN0TWF0aERvY3VtZW50ID0gZXhwb3J0cy5yZXNldEFsbE9wdGlvbnMgPSBleHBvcnRzLnJlc2V0T3B0aW9ucyA9IGV4cG9ydHMuUmVuZGVyTGlzdCA9IHZvaWQgMDtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xudmFyIElucHV0SmF4X2pzXzEgPSByZXF1aXJlKFwiLi9JbnB1dEpheC5qc1wiKTtcbnZhciBPdXRwdXRKYXhfanNfMSA9IHJlcXVpcmUoXCIuL091dHB1dEpheC5qc1wiKTtcbnZhciBNYXRoTGlzdF9qc18xID0gcmVxdWlyZShcIi4vTWF0aExpc3QuanNcIik7XG52YXIgTWF0aEl0ZW1fanNfMSA9IHJlcXVpcmUoXCIuL01hdGhJdGVtLmpzXCIpO1xudmFyIE1tbEZhY3RvcnlfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL01tbFRyZWUvTW1sRmFjdG9yeS5qc1wiKTtcbnZhciBCaXRGaWVsZF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvQml0RmllbGQuanNcIik7XG52YXIgUHJpb3JpdGl6ZWRMaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9Qcmlvcml0aXplZExpc3QuanNcIik7XG52YXIgUmVuZGVyTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKFJlbmRlckxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVuZGVyTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBSZW5kZXJMaXN0LmNyZWF0ZSA9IGZ1bmN0aW9uIChhY3Rpb25zKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgbGlzdCA9IG5ldyB0aGlzKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGFjdGlvbnMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZCh0aGlzLmFjdGlvbihpZCwgYWN0aW9uc1tpZF0pLCAyKSwgYWN0aW9uID0gX2RbMF0sIHByaW9yaXR5ID0gX2RbMV07XG4gICAgICAgICAgICAgICAgaWYgKHByaW9yaXR5KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QuYWRkKGFjdGlvbiwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsaXN0O1xuICAgIH07XG4gICAgUmVuZGVyTGlzdC5hY3Rpb24gPSBmdW5jdGlvbiAoaWQsIGFjdGlvbikge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIHZhciByZW5kZXJEb2MsIHJlbmRlck1hdGg7XG4gICAgICAgIHZhciBjb252ZXJ0ID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByaW9yaXR5ID0gYWN0aW9uWzBdO1xuICAgICAgICBpZiAoYWN0aW9uLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYWN0aW9uWzFdID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgIGFjdGlvbi5sZW5ndGggPT09IDIgJiYgKGNvbnZlcnQgPSBhY3Rpb25bMV0pO1xuICAgICAgICAgICAgX2EgPSBfX3JlYWQodGhpcy5tZXRob2RBY3Rpb25zKGlkKSwgMiksIHJlbmRlckRvYyA9IF9hWzBdLCByZW5kZXJNYXRoID0gX2FbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGFjdGlvblsxXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uWzJdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGFjdGlvbi5sZW5ndGggPT09IDQgJiYgKGNvbnZlcnQgPSBhY3Rpb25bM10pO1xuICAgICAgICAgICAgICAgIHZhciBfZSA9IF9fcmVhZChhY3Rpb24uc2xpY2UoMSksIDIpLCBtZXRob2QxID0gX2VbMF0sIG1ldGhvZDIgPSBfZVsxXTtcbiAgICAgICAgICAgICAgICBfYiA9IF9fcmVhZCh0aGlzLm1ldGhvZEFjdGlvbnMobWV0aG9kMSwgbWV0aG9kMiksIDIpLCByZW5kZXJEb2MgPSBfYlswXSwgcmVuZGVyTWF0aCA9IF9iWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uLmxlbmd0aCA9PT0gMyAmJiAoY29udmVydCA9IGFjdGlvblsyXSk7XG4gICAgICAgICAgICAgICAgX2MgPSBfX3JlYWQodGhpcy5tZXRob2RBY3Rpb25zKGFjdGlvblsxXSksIDIpLCByZW5kZXJEb2MgPSBfY1swXSwgcmVuZGVyTWF0aCA9IF9jWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uLmxlbmd0aCA9PT0gNCAmJiAoY29udmVydCA9IGFjdGlvblszXSk7XG4gICAgICAgICAgICBfZCA9IF9fcmVhZChhY3Rpb24uc2xpY2UoMSksIDIpLCByZW5kZXJEb2MgPSBfZFswXSwgcmVuZGVyTWF0aCA9IF9kWzFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbeyBpZDogaWQsIHJlbmRlckRvYzogcmVuZGVyRG9jLCByZW5kZXJNYXRoOiByZW5kZXJNYXRoLCBjb252ZXJ0OiBjb252ZXJ0IH0sIHByaW9yaXR5XTtcbiAgICB9O1xuICAgIFJlbmRlckxpc3QubWV0aG9kQWN0aW9ucyA9IGZ1bmN0aW9uIChtZXRob2QxLCBtZXRob2QyKSB7XG4gICAgICAgIGlmIChtZXRob2QyID09PSB2b2lkIDApIHsgbWV0aG9kMiA9IG1ldGhvZDE7IH1cbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkb2N1bWVudCkgeyBtZXRob2QxICYmIGRvY3VtZW50W21ldGhvZDFdKCk7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRoLCBkb2N1bWVudCkgeyBtZXRob2QyICYmIG1hdGhbbWV0aG9kMl0oZG9jdW1lbnQpOyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgXTtcbiAgICB9O1xuICAgIFJlbmRlckxpc3QucHJvdG90eXBlLnJlbmRlckRvYyA9IGZ1bmN0aW9uIChkb2N1bWVudCwgc3RhcnQpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIGlmIChzdGFydCA9PT0gdm9pZCAwKSB7IHN0YXJ0ID0gTWF0aEl0ZW1fanNfMS5TVEFURS5VTlBST0NFU1NFRDsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLml0ZW1zKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0ucHJpb3JpdHkgPj0gc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbS5yZW5kZXJEb2MoZG9jdW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJMaXN0LnByb3RvdHlwZS5yZW5kZXJNYXRoID0gZnVuY3Rpb24gKG1hdGgsIGRvY3VtZW50LCBzdGFydCkge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSBNYXRoSXRlbV9qc18xLlNUQVRFLlVOUFJPQ0VTU0VEOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuaXRlbXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5wcmlvcml0eSA+PSBzdGFydCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtLnJlbmRlck1hdGgobWF0aCwgZG9jdW1lbnQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZW5kZXJMaXN0LnByb3RvdHlwZS5yZW5kZXJDb252ZXJ0ID0gZnVuY3Rpb24gKG1hdGgsIGRvY3VtZW50LCBlbmQpIHtcbiAgICAgICAgdmFyIGVfNCwgX2E7XG4gICAgICAgIGlmIChlbmQgPT09IHZvaWQgMCkgeyBlbmQgPSBNYXRoSXRlbV9qc18xLlNUQVRFLkxBU1Q7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5pdGVtcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnByaW9yaXR5ID4gZW5kKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbS5jb252ZXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW0ucmVuZGVyTWF0aChtYXRoLCBkb2N1bWVudCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlbmRlckxpc3QucHJvdG90eXBlLmZpbmRJRCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgZV81LCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5pdGVtcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLml0ZW07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gUmVuZGVyTGlzdDtcbn0oUHJpb3JpdGl6ZWRMaXN0X2pzXzEuUHJpb3JpdGl6ZWRMaXN0KSk7XG5leHBvcnRzLlJlbmRlckxpc3QgPSBSZW5kZXJMaXN0O1xuZXhwb3J0cy5yZXNldE9wdGlvbnMgPSB7XG4gICAgYWxsOiBmYWxzZSxcbiAgICBwcm9jZXNzZWQ6IGZhbHNlLFxuICAgIGlucHV0SmF4OiBudWxsLFxuICAgIG91dHB1dEpheDogbnVsbFxufTtcbmV4cG9ydHMucmVzZXRBbGxPcHRpb25zID0ge1xuICAgIGFsbDogdHJ1ZSxcbiAgICBwcm9jZXNzZWQ6IHRydWUsXG4gICAgaW5wdXRKYXg6IFtdLFxuICAgIG91dHB1dEpheDogW11cbn07XG52YXIgRGVmYXVsdElucHV0SmF4ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdElucHV0SmF4LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRJbnB1dEpheCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBEZWZhdWx0SW5wdXRKYXgucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoX21hdGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gRGVmYXVsdElucHV0SmF4O1xufShJbnB1dEpheF9qc18xLkFic3RyYWN0SW5wdXRKYXgpKTtcbnZhciBEZWZhdWx0T3V0cHV0SmF4ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdE91dHB1dEpheCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0T3V0cHV0SmF4KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIERlZmF1bHRPdXRwdXRKYXgucHJvdG90eXBlLnR5cGVzZXQgPSBmdW5jdGlvbiAoX21hdGgsIF9kb2N1bWVudCkge1xuICAgICAgICBpZiAoX2RvY3VtZW50ID09PSB2b2lkIDApIHsgX2RvY3VtZW50ID0gbnVsbDsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIERlZmF1bHRPdXRwdXRKYXgucHJvdG90eXBlLmVzY2FwZWQgPSBmdW5jdGlvbiAoX21hdGgsIF9kb2N1bWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBEZWZhdWx0T3V0cHV0SmF4O1xufShPdXRwdXRKYXhfanNfMS5BYnN0cmFjdE91dHB1dEpheCkpO1xudmFyIERlZmF1bHRNYXRoTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKERlZmF1bHRNYXRoTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBEZWZhdWx0TWF0aExpc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIERlZmF1bHRNYXRoTGlzdDtcbn0oTWF0aExpc3RfanNfMS5BYnN0cmFjdE1hdGhMaXN0KSk7XG52YXIgRGVmYXVsdE1hdGhJdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRGVmYXVsdE1hdGhJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIERlZmF1bHRNYXRoSXRlbSgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICByZXR1cm4gRGVmYXVsdE1hdGhJdGVtO1xufShNYXRoSXRlbV9qc18xLkFic3RyYWN0TWF0aEl0ZW0pKTtcbnZhciBBYnN0cmFjdE1hdGhEb2N1bWVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RNYXRoRG9jdW1lbnQoZG9jdW1lbnQsIGFkYXB0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIENMQVNTID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgT3B0aW9uc19qc18xLnVzZXJPcHRpb25zKSgoMCwgT3B0aW9uc19qc18xLmRlZmF1bHRPcHRpb25zKSh7fSwgQ0xBU1MuT1BUSU9OUyksIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm1hdGggPSBuZXcgKHRoaXMub3B0aW9uc1snTWF0aExpc3QnXSB8fCBEZWZhdWx0TWF0aExpc3QpKCk7XG4gICAgICAgIHRoaXMucmVuZGVyQWN0aW9ucyA9IFJlbmRlckxpc3QuY3JlYXRlKHRoaXMub3B0aW9uc1sncmVuZGVyQWN0aW9ucyddKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzZWQgPSBuZXcgQWJzdHJhY3RNYXRoRG9jdW1lbnQuUHJvY2Vzc0JpdHMoKTtcbiAgICAgICAgdGhpcy5vdXRwdXRKYXggPSB0aGlzLm9wdGlvbnNbJ091dHB1dEpheCddIHx8IG5ldyBEZWZhdWx0T3V0cHV0SmF4KCk7XG4gICAgICAgIHZhciBpbnB1dEpheCA9IHRoaXMub3B0aW9uc1snSW5wdXRKYXgnXSB8fCBbbmV3IERlZmF1bHRJbnB1dEpheCgpXTtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0SmF4KSkge1xuICAgICAgICAgICAgaW5wdXRKYXggPSBbaW5wdXRKYXhdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5wdXRKYXggPSBpbnB1dEpheDtcbiAgICAgICAgdGhpcy5hZGFwdG9yID0gYWRhcHRvcjtcbiAgICAgICAgdGhpcy5vdXRwdXRKYXguc2V0QWRhcHRvcihhZGFwdG9yKTtcbiAgICAgICAgdGhpcy5pbnB1dEpheC5tYXAoZnVuY3Rpb24gKGpheCkgeyByZXR1cm4gamF4LnNldEFkYXB0b3IoYWRhcHRvcik7IH0pO1xuICAgICAgICB0aGlzLm1tbEZhY3RvcnkgPSB0aGlzLm9wdGlvbnNbJ01tbEZhY3RvcnknXSB8fCBuZXcgTW1sRmFjdG9yeV9qc18xLk1tbEZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5pbnB1dEpheC5tYXAoZnVuY3Rpb24gKGpheCkgeyByZXR1cm4gamF4LnNldE1tbEZhY3RvcnkoX3RoaXMubW1sRmFjdG9yeSk7IH0pO1xuICAgICAgICB0aGlzLm91dHB1dEpheC5pbml0aWFsaXplKCk7XG4gICAgICAgIHRoaXMuaW5wdXRKYXgubWFwKGZ1bmN0aW9uIChqYXgpIHsgcmV0dXJuIGpheC5pbml0aWFsaXplKCk7IH0pO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLCBcImtpbmRcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLktJTkQ7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUuYWRkUmVuZGVyQWN0aW9uID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIHZhciBhY3Rpb24gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFjdGlvbltfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoUmVuZGVyTGlzdC5hY3Rpb24oaWQsIGFjdGlvbiksIDIpLCBmbiA9IF9hWzBdLCBwID0gX2FbMV07XG4gICAgICAgIHRoaXMucmVuZGVyQWN0aW9ucy5hZGQoZm4sIHApO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZVJlbmRlckFjdGlvbiA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgYWN0aW9uID0gdGhpcy5yZW5kZXJBY3Rpb25zLmZpbmRJRChpZCk7XG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQWN0aW9ucy5yZW1vdmUoYWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJBY3Rpb25zLnJlbmRlckRvYyh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUucmVyZW5kZXIgPSBmdW5jdGlvbiAoc3RhcnQpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSB2b2lkIDApIHsgc3RhcnQgPSBNYXRoSXRlbV9qc18xLlNUQVRFLlJFUkVOREVSOyB9XG4gICAgICAgIHRoaXMuc3RhdGUoc3RhcnQgLSAxKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUuY29udmVydCA9IGZ1bmN0aW9uIChtYXRoLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHZhciBfYSA9ICgwLCBPcHRpb25zX2pzXzEudXNlck9wdGlvbnMpKHtcbiAgICAgICAgICAgIGZvcm1hdDogdGhpcy5pbnB1dEpheFswXS5uYW1lLCBkaXNwbGF5OiB0cnVlLCBlbmQ6IE1hdGhJdGVtX2pzXzEuU1RBVEUuTEFTVCxcbiAgICAgICAgICAgIGVtOiAxNiwgZXg6IDgsIGNvbnRhaW5lcldpZHRoOiBudWxsLCBsaW5lV2lkdGg6IDEwMDAwMDAsIHNjYWxlOiAxLCBmYW1pbHk6ICcnXG4gICAgICAgIH0sIG9wdGlvbnMpLCBmb3JtYXQgPSBfYS5mb3JtYXQsIGRpc3BsYXkgPSBfYS5kaXNwbGF5LCBlbmQgPSBfYS5lbmQsIGV4ID0gX2EuZXgsIGVtID0gX2EuZW0sIGNvbnRhaW5lcldpZHRoID0gX2EuY29udGFpbmVyV2lkdGgsIGxpbmVXaWR0aCA9IF9hLmxpbmVXaWR0aCwgc2NhbGUgPSBfYS5zY2FsZSwgZmFtaWx5ID0gX2EuZmFtaWx5O1xuICAgICAgICBpZiAoY29udGFpbmVyV2lkdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lcldpZHRoID0gODAgKiBleDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgamF4ID0gdGhpcy5pbnB1dEpheC5yZWR1Y2UoZnVuY3Rpb24gKGpheCwgaWpheCkgeyByZXR1cm4gKGlqYXgubmFtZSA9PT0gZm9ybWF0ID8gaWpheCA6IGpheCk7IH0sIG51bGwpO1xuICAgICAgICB2YXIgbWl0ZW0gPSBuZXcgdGhpcy5vcHRpb25zLk1hdGhJdGVtKG1hdGgsIGpheCwgZGlzcGxheSk7XG4gICAgICAgIG1pdGVtLnN0YXJ0Lm5vZGUgPSB0aGlzLmFkYXB0b3IuYm9keSh0aGlzLmRvY3VtZW50KTtcbiAgICAgICAgbWl0ZW0uc2V0TWV0cmljcyhlbSwgZXgsIGNvbnRhaW5lcldpZHRoLCBsaW5lV2lkdGgsIHNjYWxlKTtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0SmF4Lm9wdGlvbnMubXRleHRJbmhlcml0Rm9udCkge1xuICAgICAgICAgICAgbWl0ZW0ub3V0cHV0RGF0YS5tdGV4dEZhbWlseSA9IGZhbWlseTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vdXRwdXRKYXgub3B0aW9ucy5tZXJyb3JJbmhlcml0Rm9udCkge1xuICAgICAgICAgICAgbWl0ZW0ub3V0cHV0RGF0YS5tZXJyb3JGYW1pbHkgPSBmYW1pbHk7XG4gICAgICAgIH1cbiAgICAgICAgbWl0ZW0uY29udmVydCh0aGlzLCBlbmQpO1xuICAgICAgICByZXR1cm4gKG1pdGVtLnR5cGVzZXRSb290IHx8IG1pdGVtLnJvb3QpO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLmZpbmRNYXRoID0gZnVuY3Rpb24gKF9vcHRpb25zKSB7XG4gICAgICAgIGlmIChfb3B0aW9ucyA9PT0gdm9pZCAwKSB7IF9vcHRpb25zID0gbnVsbDsgfVxuICAgICAgICB0aGlzLnByb2Nlc3NlZC5zZXQoJ2ZpbmRNYXRoJyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLmNvbXBpbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzYsIF9hLCBlXzcsIF9iO1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc2VkLmlzU2V0KCdjb21waWxlJykpIHtcbiAgICAgICAgICAgIHZhciByZWNvbXBpbGUgPSBbXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyh0aGlzLm1hdGgpLCBfZCA9IF9jLm5leHQoKTsgIV9kLmRvbmU7IF9kID0gX2MubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRoID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGlsZU1hdGgobWF0aCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRoLmlucHV0RGF0YS5yZWNvbXBpbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVjb21waWxlLnB1c2gobWF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHJlY29tcGlsZV8xID0gX192YWx1ZXMocmVjb21waWxlKSwgcmVjb21waWxlXzFfMSA9IHJlY29tcGlsZV8xLm5leHQoKTsgIXJlY29tcGlsZV8xXzEuZG9uZTsgcmVjb21waWxlXzFfMSA9IHJlY29tcGlsZV8xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0aCA9IHJlY29tcGlsZV8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0gbWF0aC5pbnB1dERhdGEucmVjb21waWxlO1xuICAgICAgICAgICAgICAgICAgICBtYXRoLnN0YXRlKGRhdGEuc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICBtYXRoLmlucHV0RGF0YS5yZWNvbXBpbGUgPSBkYXRhO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbXBpbGVNYXRoKG1hdGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb21waWxlXzFfMSAmJiAhcmVjb21waWxlXzFfMS5kb25lICYmIChfYiA9IHJlY29tcGlsZV8xLnJldHVybikpIF9iLmNhbGwocmVjb21waWxlXzEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNykgdGhyb3cgZV83LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZC5zZXQoJ2NvbXBpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0TWF0aERvY3VtZW50LnByb3RvdHlwZS5jb21waWxlTWF0aCA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBtYXRoLmNvbXBpbGUodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGVyci5yZXRyeSB8fCBlcnIucmVzdGFydCkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub3B0aW9uc1snY29tcGlsZUVycm9yJ10odGhpcywgbWF0aCwgZXJyKTtcbiAgICAgICAgICAgIG1hdGguaW5wdXREYXRhWydlcnJvciddID0gZXJyO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUuY29tcGlsZUVycm9yID0gZnVuY3Rpb24gKG1hdGgsIGVycikge1xuICAgICAgICBtYXRoLnJvb3QgPSB0aGlzLm1tbEZhY3RvcnkuY3JlYXRlKCdtYXRoJywgbnVsbCwgW1xuICAgICAgICAgICAgdGhpcy5tbWxGYWN0b3J5LmNyZWF0ZSgnbWVycm9yJywgeyAnZGF0YS1tangtZXJyb3InOiBlcnIubWVzc2FnZSwgdGl0bGU6IGVyci5tZXNzYWdlIH0sIFtcbiAgICAgICAgICAgICAgICB0aGlzLm1tbEZhY3RvcnkuY3JlYXRlKCdtdGV4dCcsIG51bGwsIFtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tbWxGYWN0b3J5LmNyZWF0ZSgndGV4dCcpLnNldFRleHQoJ01hdGggaW5wdXQgZXJyb3InKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICBdKVxuICAgICAgICBdKTtcbiAgICAgICAgaWYgKG1hdGguZGlzcGxheSkge1xuICAgICAgICAgICAgbWF0aC5yb290LmF0dHJpYnV0ZXMuc2V0KCdkaXNwbGF5JywgJ2Jsb2NrJyk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0aC5pbnB1dERhdGEuZXJyb3IgPSBlcnIubWVzc2FnZTtcbiAgICB9O1xuICAgIEFic3RyYWN0TWF0aERvY3VtZW50LnByb3RvdHlwZS50eXBlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV84LCBfYTtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NlZC5pc1NldCgndHlwZXNldCcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5tYXRoKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0aCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0aC50eXBlc2V0KHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIucmV0cnkgfHwgZXJyLnJlc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnNbJ3R5cGVzZXRFcnJvciddKHRoaXMsIG1hdGgsIGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRoLm91dHB1dERhdGFbJ2Vycm9yJ10gPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV84XzEpIHsgZV84ID0geyBlcnJvcjogZV84XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfOCkgdGhyb3cgZV84LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NlZC5zZXQoJ3R5cGVzZXQnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0TWF0aERvY3VtZW50LnByb3RvdHlwZS50eXBlc2V0RXJyb3IgPSBmdW5jdGlvbiAobWF0aCwgZXJyKSB7XG4gICAgICAgIG1hdGgudHlwZXNldFJvb3QgPSB0aGlzLmFkYXB0b3Iubm9kZSgnbWp4LWNvbnRhaW5lcicsIHtcbiAgICAgICAgICAgIGNsYXNzOiAnTWF0aEpheCBtangtb3V0cHV0LWVycm9yJyxcbiAgICAgICAgICAgIGpheDogdGhpcy5vdXRwdXRKYXgubmFtZSxcbiAgICAgICAgfSwgW1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLm5vZGUoJ3NwYW4nLCB7XG4gICAgICAgICAgICAgICAgJ2RhdGEtbWp4LWVycm9yJzogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgdGl0bGU6IGVyci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAncmVkJyxcbiAgICAgICAgICAgICAgICAgICAgJ2JhY2tncm91bmQtY29sb3InOiAneWVsbG93JyxcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmUtaGVpZ2h0JzogJ25vcm1hbCdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCBbXG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdG9yLnRleHQoJ01hdGggb3V0cHV0IGVycm9yJylcbiAgICAgICAgICAgIF0pXG4gICAgICAgIF0pO1xuICAgICAgICBpZiAobWF0aC5kaXNwbGF5KSB7XG4gICAgICAgICAgICB0aGlzLmFkYXB0b3Iuc2V0QXR0cmlidXRlcyhtYXRoLnR5cGVzZXRSb290LCB7XG4gICAgICAgICAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICAgICAgICAgICAgICAgICAgbWFyZ2luOiAnMWVtIDAnLFxuICAgICAgICAgICAgICAgICAgICAndGV4dC1hbGlnbic6ICdjZW50ZXInXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbWF0aC5vdXRwdXREYXRhLmVycm9yID0gZXJyLm1lc3NhZ2U7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUuZ2V0TWV0cmljcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NlZC5pc1NldCgnZ2V0TWV0cmljcycpKSB7XG4gICAgICAgICAgICB0aGlzLm91dHB1dEpheC5nZXRNZXRyaWNzKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuc2V0KCdnZXRNZXRyaWNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzksIF9hO1xuICAgICAgICBpZiAoIXRoaXMucHJvY2Vzc2VkLmlzU2V0KCd1cGRhdGVEb2N1bWVudCcpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5tYXRoLnJldmVyc2VkKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRoID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIG1hdGgudXBkYXRlRG9jdW1lbnQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfOV8xKSB7IGVfOSA9IHsgZXJyb3I6IGVfOV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzkpIHRocm93IGVfOS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuc2V0KCd1cGRhdGVEb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZUZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uIChfcmVzdG9yZSkge1xuICAgICAgICBpZiAoX3Jlc3RvcmUgPT09IHZvaWQgMCkgeyBfcmVzdG9yZSA9IGZhbHNlOyB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLnN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByZXN0b3JlKSB7XG4gICAgICAgIHZhciBlXzEwLCBfYTtcbiAgICAgICAgaWYgKHJlc3RvcmUgPT09IHZvaWQgMCkgeyByZXN0b3JlID0gZmFsc2U7IH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5tYXRoKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXRoID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgbWF0aC5zdGF0ZShzdGF0ZSwgcmVzdG9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMTBfMSkgeyBlXzEwID0geyBlcnJvcjogZV8xMF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xMCkgdGhyb3cgZV8xMC5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA8IE1hdGhJdGVtX2pzXzEuU1RBVEUuSU5TRVJURUQpIHtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkLmNsZWFyKCd1cGRhdGVEb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA8IE1hdGhJdGVtX2pzXzEuU1RBVEUuVFlQRVNFVCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuY2xlYXIoJ3R5cGVzZXQnKTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc2VkLmNsZWFyKCdnZXRNZXRyaWNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlIDwgTWF0aEl0ZW1fanNfMS5TVEFURS5DT01QSUxFRCkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuY2xlYXIoJ2NvbXBpbGUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEFic3RyYWN0TWF0aERvY3VtZW50LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0geyBwcm9jZXNzZWQ6IHRydWUgfTsgfVxuICAgICAgICBvcHRpb25zID0gKDAsIE9wdGlvbnNfanNfMS51c2VyT3B0aW9ucykoT2JqZWN0LmFzc2lnbih7fSwgZXhwb3J0cy5yZXNldE9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5hbGwgJiYgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBleHBvcnRzLnJlc2V0QWxsT3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMucHJvY2Vzc2VkICYmIHRoaXMucHJvY2Vzc2VkLnJlc2V0KCk7XG4gICAgICAgIG9wdGlvbnMuaW5wdXRKYXggJiYgdGhpcy5pbnB1dEpheC5mb3JFYWNoKGZ1bmN0aW9uIChqYXgpIHsgcmV0dXJuIGpheC5yZXNldC5hcHBseShqYXgsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChvcHRpb25zLmlucHV0SmF4KSwgZmFsc2UpKTsgfSk7XG4gICAgICAgIG9wdGlvbnMub3V0cHV0SmF4ICYmIChfYSA9IHRoaXMub3V0cHV0SmF4KS5yZXNldC5hcHBseShfYSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKG9wdGlvbnMub3V0cHV0SmF4KSwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy5tYXRoLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLmNvbmNhdCA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIHRoaXMubWF0aC5tZXJnZShsaXN0KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5wcm90b3R5cGUuY2xlYXJNYXRoSXRlbXNXaXRoaW4gPSBmdW5jdGlvbiAoY29udGFpbmVycykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuZ2V0TWF0aEl0ZW1zV2l0aGluKGNvbnRhaW5lcnMpO1xuICAgICAgICAoX2EgPSB0aGlzLm1hdGgpLnJlbW92ZS5hcHBseShfYSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGl0ZW1zKSwgZmFsc2UpKTtcbiAgICAgICAgcmV0dXJuIGl0ZW1zO1xuICAgIH07XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQucHJvdG90eXBlLmdldE1hdGhJdGVtc1dpdGhpbiA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgICAgICB2YXIgZV8xMSwgX2EsIGVfMTIsIF9iO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZWxlbWVudHMpKSB7XG4gICAgICAgICAgICBlbGVtZW50cyA9IFtlbGVtZW50c107XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIHZhciBpdGVtcyA9IFtdO1xuICAgICAgICB2YXIgY29udGFpbmVycyA9IGFkYXB0b3IuZ2V0RWxlbWVudHMoZWxlbWVudHMsIHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgSVRFTVM6IGZvciAodmFyIF9jID0gX192YWx1ZXModGhpcy5tYXRoKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2QudmFsdWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgY29udGFpbmVyc18xID0gKGVfMTIgPSB2b2lkIDAsIF9fdmFsdWVzKGNvbnRhaW5lcnMpKSwgY29udGFpbmVyc18xXzEgPSBjb250YWluZXJzXzEubmV4dCgpOyAhY29udGFpbmVyc18xXzEuZG9uZTsgY29udGFpbmVyc18xXzEgPSBjb250YWluZXJzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gY29udGFpbmVyc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydC5ub2RlICYmIGFkYXB0b3IuY29udGFpbnMoY29udGFpbmVyLCBpdGVtLnN0YXJ0Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBJVEVNUztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZV8xMl8xKSB7IGVfMTIgPSB7IGVycm9yOiBlXzEyXzEgfTsgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRhaW5lcnNfMV8xICYmICFjb250YWluZXJzXzFfMS5kb25lICYmIChfYiA9IGNvbnRhaW5lcnNfMS5yZXR1cm4pKSBfYi5jYWxsKGNvbnRhaW5lcnNfMSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEyKSB0aHJvdyBlXzEyLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzExXzEpIHsgZV8xMSA9IHsgZXJyb3I6IGVfMTFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2QgJiYgIV9kLmRvbmUgJiYgKF9hID0gX2MucmV0dXJuKSkgX2EuY2FsbChfYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMTEpIHRocm93IGVfMTEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5LSU5EID0gJ01hdGhEb2N1bWVudCc7XG4gICAgQWJzdHJhY3RNYXRoRG9jdW1lbnQuT1BUSU9OUyA9IHtcbiAgICAgICAgT3V0cHV0SmF4OiBudWxsLFxuICAgICAgICBJbnB1dEpheDogbnVsbCxcbiAgICAgICAgTW1sRmFjdG9yeTogbnVsbCxcbiAgICAgICAgTWF0aExpc3Q6IERlZmF1bHRNYXRoTGlzdCxcbiAgICAgICAgTWF0aEl0ZW06IERlZmF1bHRNYXRoSXRlbSxcbiAgICAgICAgY29tcGlsZUVycm9yOiBmdW5jdGlvbiAoZG9jLCBtYXRoLCBlcnIpIHtcbiAgICAgICAgICAgIGRvYy5jb21waWxlRXJyb3IobWF0aCwgZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZXNldEVycm9yOiBmdW5jdGlvbiAoZG9jLCBtYXRoLCBlcnIpIHtcbiAgICAgICAgICAgIGRvYy50eXBlc2V0RXJyb3IobWF0aCwgZXJyKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVuZGVyQWN0aW9uczogKDAsIE9wdGlvbnNfanNfMS5leHBhbmRhYmxlKSh7XG4gICAgICAgICAgICBmaW5kOiBbTWF0aEl0ZW1fanNfMS5TVEFURS5GSU5ETUFUSCwgJ2ZpbmRNYXRoJywgJycsIGZhbHNlXSxcbiAgICAgICAgICAgIGNvbXBpbGU6IFtNYXRoSXRlbV9qc18xLlNUQVRFLkNPTVBJTEVEXSxcbiAgICAgICAgICAgIG1ldHJpY3M6IFtNYXRoSXRlbV9qc18xLlNUQVRFLk1FVFJJQ1MsICdnZXRNZXRyaWNzJywgJycsIGZhbHNlXSxcbiAgICAgICAgICAgIHR5cGVzZXQ6IFtNYXRoSXRlbV9qc18xLlNUQVRFLlRZUEVTRVRdLFxuICAgICAgICAgICAgdXBkYXRlOiBbTWF0aEl0ZW1fanNfMS5TVEFURS5JTlNFUlRFRCwgJ3VwZGF0ZURvY3VtZW50JywgZmFsc2VdXG4gICAgICAgIH0pXG4gICAgfTtcbiAgICBBYnN0cmFjdE1hdGhEb2N1bWVudC5Qcm9jZXNzQml0cyA9ICgwLCBCaXRGaWVsZF9qc18xLkJpdEZpZWxkQ2xhc3MpKCdmaW5kTWF0aCcsICdjb21waWxlJywgJ2dldE1ldHJpY3MnLCAndHlwZXNldCcsICd1cGRhdGVEb2N1bWVudCcpO1xuICAgIHJldHVybiBBYnN0cmFjdE1hdGhEb2N1bWVudDtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0TWF0aERvY3VtZW50ID0gQWJzdHJhY3RNYXRoRG9jdW1lbnQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXRoRG9jdW1lbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdE1hdGhMaXN0ID0gdm9pZCAwO1xudmFyIExpbmtlZExpc3RfanNfMSA9IHJlcXVpcmUoXCIuLi91dGlsL0xpbmtlZExpc3QuanNcIik7XG52YXIgQWJzdHJhY3RNYXRoTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEFic3RyYWN0TWF0aExpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQWJzdHJhY3RNYXRoTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBBYnN0cmFjdE1hdGhMaXN0LnByb3RvdHlwZS5pc0JlZm9yZSA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiAoYS5zdGFydC5pIDwgYi5zdGFydC5pIHx8IChhLnN0YXJ0LmkgPT09IGIuc3RhcnQuaSAmJiBhLnN0YXJ0Lm4gPCBiLnN0YXJ0Lm4pKTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdE1hdGhMaXN0O1xufShMaW5rZWRMaXN0X2pzXzEuTGlua2VkTGlzdCkpO1xuZXhwb3J0cy5BYnN0cmFjdE1hdGhMaXN0ID0gQWJzdHJhY3RNYXRoTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU1hdGhMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BYnN0cmFjdE91dHB1dEpheCA9IHZvaWQgMDtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xudmFyIEZ1bmN0aW9uTGlzdF9qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvRnVuY3Rpb25MaXN0LmpzXCIpO1xudmFyIEFic3RyYWN0T3V0cHV0SmF4ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdE91dHB1dEpheChvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgICAgIHRoaXMuYWRhcHRvciA9IG51bGw7XG4gICAgICAgIHZhciBDTEFTUyA9IHRoaXMuY29uc3RydWN0b3I7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9ICgwLCBPcHRpb25zX2pzXzEudXNlck9wdGlvbnMpKCgwLCBPcHRpb25zX2pzXzEuZGVmYXVsdE9wdGlvbnMpKHt9LCBDTEFTUy5PUFRJT05TKSwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMucG9zdEZpbHRlcnMgPSBuZXcgRnVuY3Rpb25MaXN0X2pzXzEuRnVuY3Rpb25MaXN0KCk7XG4gICAgfVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdE91dHB1dEpheC5wcm90b3R5cGUsIFwibmFtZVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuTkFNRTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFic3RyYWN0T3V0cHV0SmF4LnByb3RvdHlwZS5zZXRBZGFwdG9yID0gZnVuY3Rpb24gKGFkYXB0b3IpIHtcbiAgICAgICAgdGhpcy5hZGFwdG9yID0gYWRhcHRvcjtcbiAgICB9O1xuICAgIEFic3RyYWN0T3V0cHV0SmF4LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIH07XG4gICAgQWJzdHJhY3RPdXRwdXRKYXgucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2FyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIF9hcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEFic3RyYWN0T3V0cHV0SmF4LnByb3RvdHlwZS5nZXRNZXRyaWNzID0gZnVuY3Rpb24gKF9kb2N1bWVudCkge1xuICAgIH07XG4gICAgQWJzdHJhY3RPdXRwdXRKYXgucHJvdG90eXBlLnN0eWxlU2hlZXQgPSBmdW5jdGlvbiAoX2RvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH07XG4gICAgQWJzdHJhY3RPdXRwdXRKYXgucHJvdG90eXBlLnBhZ2VFbGVtZW50cyA9IGZ1bmN0aW9uIChfZG9jdW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdE91dHB1dEpheC5wcm90b3R5cGUuZXhlY3V0ZUZpbHRlcnMgPSBmdW5jdGlvbiAoZmlsdGVycywgbWF0aCwgZG9jdW1lbnQsIGRhdGEpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSB7IG1hdGg6IG1hdGgsIGRvY3VtZW50OiBkb2N1bWVudCwgZGF0YTogZGF0YSB9O1xuICAgICAgICBmaWx0ZXJzLmV4ZWN1dGUoYXJncyk7XG4gICAgICAgIHJldHVybiBhcmdzLmRhdGE7XG4gICAgfTtcbiAgICBBYnN0cmFjdE91dHB1dEpheC5OQU1FID0gJ2dlbmVyaWMnO1xuICAgIEFic3RyYWN0T3V0cHV0SmF4Lk9QVElPTlMgPSB7fTtcbiAgICByZXR1cm4gQWJzdHJhY3RPdXRwdXRKYXg7XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdE91dHB1dEpheCA9IEFic3RyYWN0T3V0cHV0SmF4O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T3V0cHV0SmF4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhUTUxEb2N1bWVudCA9IHZvaWQgMDtcbnZhciBNYXRoRG9jdW1lbnRfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL01hdGhEb2N1bWVudC5qc1wiKTtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xudmFyIEhUTUxNYXRoSXRlbV9qc18xID0gcmVxdWlyZShcIi4vSFRNTE1hdGhJdGVtLmpzXCIpO1xudmFyIEhUTUxNYXRoTGlzdF9qc18xID0gcmVxdWlyZShcIi4vSFRNTE1hdGhMaXN0LmpzXCIpO1xudmFyIEhUTUxEb21TdHJpbmdzX2pzXzEgPSByZXF1aXJlKFwiLi9IVE1MRG9tU3RyaW5ncy5qc1wiKTtcbnZhciBNYXRoSXRlbV9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTWF0aEl0ZW0uanNcIik7XG52YXIgSFRNTERvY3VtZW50ID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFRNTERvY3VtZW50LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhUTUxEb2N1bWVudChkb2N1bWVudCwgYWRhcHRvciwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQoKDAsIE9wdGlvbnNfanNfMS5zZXBhcmF0ZU9wdGlvbnMpKG9wdGlvbnMsIEhUTUxEb21TdHJpbmdzX2pzXzEuSFRNTERvbVN0cmluZ3MuT1BUSU9OUyksIDIpLCBodG1sID0gX2FbMF0sIGRvbSA9IF9hWzFdO1xuICAgICAgICBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGRvY3VtZW50LCBhZGFwdG9yLCBodG1sKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kb21TdHJpbmdzID0gX3RoaXMub3B0aW9uc1snRG9tU3RyaW5ncyddIHx8IG5ldyBIVE1MRG9tU3RyaW5nc19qc18xLkhUTUxEb21TdHJpbmdzKGRvbSk7XG4gICAgICAgIF90aGlzLmRvbVN0cmluZ3MuYWRhcHRvciA9IGFkYXB0b3I7XG4gICAgICAgIF90aGlzLnN0eWxlcyA9IFtdO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhUTUxEb2N1bWVudC5wcm90b3R5cGUuZmluZFBvc2l0aW9uID0gZnVuY3Rpb24gKE4sIGluZGV4LCBkZWxpbSwgbm9kZXMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhub2Rlc1tOXSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZChsaXN0LCAyKSwgbm9kZSA9IF9kWzBdLCBuID0gX2RbMV07XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4IDw9IG4gJiYgYWRhcHRvci5raW5kKG5vZGUpID09PSAnI3RleHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IG5vZGUsIG46IE1hdGgubWF4KGluZGV4LCAwKSwgZGVsaW06IGRlbGltIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGluZGV4IC09IG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBub2RlOiBudWxsLCBuOiAwLCBkZWxpbTogZGVsaW0gfTtcbiAgICB9O1xuICAgIEhUTUxEb2N1bWVudC5wcm90b3R5cGUubWF0aEl0ZW0gPSBmdW5jdGlvbiAoaXRlbSwgamF4LCBub2Rlcykge1xuICAgICAgICB2YXIgbWF0aCA9IGl0ZW0ubWF0aDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5maW5kUG9zaXRpb24oaXRlbS5uLCBpdGVtLnN0YXJ0Lm4sIGl0ZW0ub3Blbiwgbm9kZXMpO1xuICAgICAgICB2YXIgZW5kID0gdGhpcy5maW5kUG9zaXRpb24oaXRlbS5uLCBpdGVtLmVuZC5uLCBpdGVtLmNsb3NlLCBub2Rlcyk7XG4gICAgICAgIHJldHVybiBuZXcgdGhpcy5vcHRpb25zLk1hdGhJdGVtKG1hdGgsIGpheCwgaXRlbS5kaXNwbGF5LCBzdGFydCwgZW5kKTtcbiAgICB9O1xuICAgIEhUTUxEb2N1bWVudC5wcm90b3R5cGUuZmluZE1hdGggPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB2YXIgZV8yLCBfYSwgZV8zLCBfYiwgX2MsIGVfNCwgX2QsIGVfNSwgX2U7XG4gICAgICAgIGlmICghdGhpcy5wcm9jZXNzZWQuaXNTZXQoJ2ZpbmRNYXRoJykpIHtcbiAgICAgICAgICAgIHRoaXMuYWRhcHRvci5kb2N1bWVudCA9IHRoaXMuZG9jdW1lbnQ7XG4gICAgICAgICAgICBvcHRpb25zID0gKDAsIE9wdGlvbnNfanNfMS51c2VyT3B0aW9ucykoeyBlbGVtZW50czogdGhpcy5vcHRpb25zLmVsZW1lbnRzIHx8IFt0aGlzLmFkYXB0b3IuYm9keSh0aGlzLmRvY3VtZW50KV0gfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9mID0gX192YWx1ZXModGhpcy5hZGFwdG9yLmdldEVsZW1lbnRzKG9wdGlvbnNbJ2VsZW1lbnRzJ10sIHRoaXMuZG9jdW1lbnQpKSwgX2cgPSBfZi5uZXh0KCk7ICFfZy5kb25lOyBfZyA9IF9mLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGFpbmVyID0gX2cudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfaCA9IF9fcmVhZChbbnVsbCwgbnVsbF0sIDIpLCBzdHJpbmdzID0gX2hbMF0sIG5vZGVzID0gX2hbMV07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaiA9IChlXzMgPSB2b2lkIDAsIF9fdmFsdWVzKHRoaXMuaW5wdXRKYXgpKSwgX2sgPSBfai5uZXh0KCk7ICFfay5kb25lOyBfayA9IF9qLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBqYXggPSBfay52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGlzdCA9IG5ldyAodGhpcy5vcHRpb25zWydNYXRoTGlzdCddKSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqYXgucHJvY2Vzc1N0cmluZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0cmluZ3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jID0gX19yZWFkKHRoaXMuZG9tU3RyaW5ncy5maW5kKGNvbnRhaW5lciksIDIpLCBzdHJpbmdzID0gX2NbMF0sIG5vZGVzID0gX2NbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9sID0gKGVfNCA9IHZvaWQgMCwgX192YWx1ZXMoamF4LmZpbmRNYXRoKHN0cmluZ3MpKSksIF9tID0gX2wubmV4dCgpOyAhX20uZG9uZTsgX20gPSBfbC5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0aCA9IF9tLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaCh0aGlzLm1hdGhJdGVtKG1hdGgsIGpheCwgbm9kZXMpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV80XzEpIHsgZV80ID0geyBlcnJvcjogZV80XzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9tICYmICFfbS5kb25lICYmIChfZCA9IF9sLnJldHVybikpIF9kLmNhbGwoX2wpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzQpIHRocm93IGVfNC5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX28gPSAoZV81ID0gdm9pZCAwLCBfX3ZhbHVlcyhqYXguZmluZE1hdGgoY29udGFpbmVyKSkpLCBfcCA9IF9vLm5leHQoKTsgIV9wLmRvbmU7IF9wID0gX28ubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGggPSBfcC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IG5ldyB0aGlzLm9wdGlvbnMuTWF0aEl0ZW0obWF0aC5tYXRoLCBqYXgsIG1hdGguZGlzcGxheSwgbWF0aC5zdGFydCwgbWF0aC5lbmQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV81XzEpIHsgZV81ID0geyBlcnJvcjogZV81XzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9wICYmICFfcC5kb25lICYmIChfZSA9IF9vLnJldHVybikpIF9lLmNhbGwoX28pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWF0aC5tZXJnZShsaXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9rICYmICFfay5kb25lICYmIChfYiA9IF9qLnJldHVybikpIF9iLmNhbGwoX2opO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfZyAmJiAhX2cuZG9uZSAmJiAoX2EgPSBfZi5yZXR1cm4pKSBfYS5jYWxsKF9mKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuc2V0KCdmaW5kTWF0aCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSFRNTERvY3VtZW50LnByb3RvdHlwZS51cGRhdGVEb2N1bWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NlZC5pc1NldCgndXBkYXRlRG9jdW1lbnQnKSkge1xuICAgICAgICAgICAgdGhpcy5hZGRQYWdlRWxlbWVudHMoKTtcbiAgICAgICAgICAgIHRoaXMuYWRkU3R5bGVTaGVldCgpO1xuICAgICAgICAgICAgX3N1cGVyLnByb3RvdHlwZS51cGRhdGVEb2N1bWVudC5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuc2V0KCd1cGRhdGVEb2N1bWVudCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgSFRNTERvY3VtZW50LnByb3RvdHlwZS5hZGRQYWdlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5hZGFwdG9yLmJvZHkodGhpcy5kb2N1bWVudCk7XG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kb2N1bWVudFBhZ2VFbGVtZW50cygpO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hZGFwdG9yLmFwcGVuZChib2R5LCBub2RlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRNTERvY3VtZW50LnByb3RvdHlwZS5hZGRTdHlsZVNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgc2hlZXQgPSB0aGlzLmRvY3VtZW50U3R5bGVTaGVldCgpO1xuICAgICAgICB2YXIgYWRhcHRvciA9IHRoaXMuYWRhcHRvcjtcbiAgICAgICAgaWYgKHNoZWV0ICYmICFhZGFwdG9yLnBhcmVudChzaGVldCkpIHtcbiAgICAgICAgICAgIHZhciBoZWFkID0gYWRhcHRvci5oZWFkKHRoaXMuZG9jdW1lbnQpO1xuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IHRoaXMuZmluZFNoZWV0KGhlYWQsIGFkYXB0b3IuZ2V0QXR0cmlidXRlKHNoZWV0LCAnaWQnKSk7XG4gICAgICAgICAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgICAgICAgICAgYWRhcHRvci5yZXBsYWNlKHNoZWV0LCBzdHlsZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYWRhcHRvci5hcHBlbmQoaGVhZCwgc2hlZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBIVE1MRG9jdW1lbnQucHJvdG90eXBlLmZpbmRTaGVldCA9IGZ1bmN0aW9uIChoZWFkLCBpZCkge1xuICAgICAgICB2YXIgZV82LCBfYTtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5hZGFwdG9yLnRhZ3MoaGVhZCwgJ3N0eWxlJykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzaGVldCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hZGFwdG9yLmdldEF0dHJpYnV0ZShzaGVldCwgJ2lkJykgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2hlZXQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBIVE1MRG9jdW1lbnQucHJvdG90eXBlLnJlbW92ZUZyb21Eb2N1bWVudCA9IGZ1bmN0aW9uIChyZXN0b3JlKSB7XG4gICAgICAgIHZhciBlXzcsIF9hO1xuICAgICAgICBpZiAocmVzdG9yZSA9PT0gdm9pZCAwKSB7IHJlc3RvcmUgPSBmYWxzZTsgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzZWQuaXNTZXQoJ3VwZGF0ZURvY3VtZW50JykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLm1hdGgpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRoID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRoLnN0YXRlKCkgPj0gTWF0aEl0ZW1fanNfMS5TVEFURS5JTlNFUlRFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0aC5zdGF0ZShNYXRoSXRlbV9qc18xLlNUQVRFLlRZUEVTRVQsIHJlc3RvcmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfN18xKSB7IGVfNyA9IHsgZXJyb3I6IGVfN18xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzcpIHRocm93IGVfNy5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJvY2Vzc2VkLmNsZWFyKCd1cGRhdGVEb2N1bWVudCcpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIEhUTUxEb2N1bWVudC5wcm90b3R5cGUuZG9jdW1lbnRTdHlsZVNoZWV0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vdXRwdXRKYXguc3R5bGVTaGVldCh0aGlzKTtcbiAgICB9O1xuICAgIEhUTUxEb2N1bWVudC5wcm90b3R5cGUuZG9jdW1lbnRQYWdlRWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dEpheC5wYWdlRWxlbWVudHModGhpcyk7XG4gICAgfTtcbiAgICBIVE1MRG9jdW1lbnQucHJvdG90eXBlLmFkZFN0eWxlcyA9IGZ1bmN0aW9uIChzdHlsZXMpIHtcbiAgICAgICAgdGhpcy5zdHlsZXMucHVzaChzdHlsZXMpO1xuICAgIH07XG4gICAgSFRNTERvY3VtZW50LnByb3RvdHlwZS5nZXRTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0eWxlcztcbiAgICB9O1xuICAgIEhUTUxEb2N1bWVudC5LSU5EID0gJ0hUTUwnO1xuICAgIEhUTUxEb2N1bWVudC5PUFRJT05TID0gX19hc3NpZ24oX19hc3NpZ24oe30sIE1hdGhEb2N1bWVudF9qc18xLkFic3RyYWN0TWF0aERvY3VtZW50Lk9QVElPTlMpLCB7IHJlbmRlckFjdGlvbnM6ICgwLCBPcHRpb25zX2pzXzEuZXhwYW5kYWJsZSkoX19hc3NpZ24oX19hc3NpZ24oe30sIE1hdGhEb2N1bWVudF9qc18xLkFic3RyYWN0TWF0aERvY3VtZW50Lk9QVElPTlMucmVuZGVyQWN0aW9ucyksIHsgc3R5bGVzOiBbTWF0aEl0ZW1fanNfMS5TVEFURS5JTlNFUlRFRCArIDEsICcnLCAndXBkYXRlU3R5bGVTaGVldCcsIGZhbHNlXSB9KSksIE1hdGhMaXN0OiBIVE1MTWF0aExpc3RfanNfMS5IVE1MTWF0aExpc3QsIE1hdGhJdGVtOiBIVE1MTWF0aEl0ZW1fanNfMS5IVE1MTWF0aEl0ZW0sIERvbVN0cmluZ3M6IG51bGwgfSk7XG4gICAgcmV0dXJuIEhUTUxEb2N1bWVudDtcbn0oTWF0aERvY3VtZW50X2pzXzEuQWJzdHJhY3RNYXRoRG9jdW1lbnQpKTtcbmV4cG9ydHMuSFRNTERvY3VtZW50ID0gSFRNTERvY3VtZW50O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTERvY3VtZW50LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IVE1MRG9tU3RyaW5ncyA9IHZvaWQgMDtcbnZhciBPcHRpb25zX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbC9PcHRpb25zLmpzXCIpO1xudmFyIEhUTUxEb21TdHJpbmdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBIVE1MRG9tU3RyaW5ncyhvcHRpb25zKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IG51bGw7IH1cbiAgICAgICAgdmFyIENMQVNTID0gdGhpcy5jb25zdHJ1Y3RvcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gKDAsIE9wdGlvbnNfanNfMS51c2VyT3B0aW9ucykoKDAsIE9wdGlvbnNfanNfMS5kZWZhdWx0T3B0aW9ucykoe30sIENMQVNTLk9QVElPTlMpLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgICAgIHRoaXMuZ2V0UGF0dGVybnMoKTtcbiAgICB9XG4gICAgSFRNTERvbVN0cmluZ3MucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuc3RyaW5ncyA9IFtdO1xuICAgICAgICB0aGlzLnN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLnNub2RlcyA9IFtdO1xuICAgICAgICB0aGlzLm5vZGVzID0gW107XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB9O1xuICAgIEhUTUxEb21TdHJpbmdzLnByb3RvdHlwZS5nZXRQYXR0ZXJucyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNraXAgPSAoMCwgT3B0aW9uc19qc18xLm1ha2VBcnJheSkodGhpcy5vcHRpb25zWydza2lwSHRtbFRhZ3MnXSk7XG4gICAgICAgIHZhciBpZ25vcmUgPSAoMCwgT3B0aW9uc19qc18xLm1ha2VBcnJheSkodGhpcy5vcHRpb25zWydpZ25vcmVIdG1sQ2xhc3MnXSk7XG4gICAgICAgIHZhciBwcm9jZXNzID0gKDAsIE9wdGlvbnNfanNfMS5tYWtlQXJyYXkpKHRoaXMub3B0aW9uc1sncHJvY2Vzc0h0bWxDbGFzcyddKTtcbiAgICAgICAgdGhpcy5za2lwSHRtbFRhZ3MgPSBuZXcgUmVnRXhwKCdeKD86JyArIHNraXAuam9pbignfCcpICsgJykkJywgJ2knKTtcbiAgICAgICAgdGhpcy5pZ25vcmVIdG1sQ2xhc3MgPSBuZXcgUmVnRXhwKCcoPzpefCApKD86JyArIGlnbm9yZS5qb2luKCd8JykgKyAnKSg/OiB8JCknKTtcbiAgICAgICAgdGhpcy5wcm9jZXNzSHRtbENsYXNzID0gbmV3IFJlZ0V4cCgnKD86XnwgKSg/OicgKyBwcm9jZXNzICsgJykoPzogfCQpJyk7XG4gICAgfTtcbiAgICBIVE1MRG9tU3RyaW5ncy5wcm90b3R5cGUucHVzaFN0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RyaW5nLm1hdGNoKC9cXFMvKSkge1xuICAgICAgICAgICAgdGhpcy5zdHJpbmdzLnB1c2godGhpcy5zdHJpbmcpO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5wdXNoKHRoaXMuc25vZGVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0cmluZyA9ICcnO1xuICAgICAgICB0aGlzLnNub2RlcyA9IFtdO1xuICAgIH07XG4gICAgSFRNTERvbVN0cmluZ3MucHJvdG90eXBlLmV4dGVuZFN0cmluZyA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICAgIHRoaXMuc25vZGVzLnB1c2goW25vZGUsIHRleHQubGVuZ3RoXSk7XG4gICAgICAgIHRoaXMuc3RyaW5nICs9IHRleHQ7XG4gICAgfTtcbiAgICBIVE1MRG9tU3RyaW5ncy5wcm90b3R5cGUuaGFuZGxlVGV4dCA9IGZ1bmN0aW9uIChub2RlLCBpZ25vcmUpIHtcbiAgICAgICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU3RyaW5nKG5vZGUsIHRoaXMuYWRhcHRvci52YWx1ZShub2RlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRvci5uZXh0KG5vZGUpO1xuICAgIH07XG4gICAgSFRNTERvbVN0cmluZ3MucHJvdG90eXBlLmhhbmRsZVRhZyA9IGZ1bmN0aW9uIChub2RlLCBpZ25vcmUpIHtcbiAgICAgICAgaWYgKCFpZ25vcmUpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5vcHRpb25zWydpbmNsdWRlSHRtbFRhZ3MnXVt0aGlzLmFkYXB0b3Iua2luZChub2RlKV07XG4gICAgICAgICAgICB0aGlzLmV4dGVuZFN0cmluZyhub2RlLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdG9yLm5leHQobm9kZSk7XG4gICAgfTtcbiAgICBIVE1MRG9tU3RyaW5ncy5wcm90b3R5cGUuaGFuZGxlQ29udGFpbmVyID0gZnVuY3Rpb24gKG5vZGUsIGlnbm9yZSkge1xuICAgICAgICB0aGlzLnB1c2hTdHJpbmcoKTtcbiAgICAgICAgdmFyIGNuYW1lID0gdGhpcy5hZGFwdG9yLmdldEF0dHJpYnV0ZShub2RlLCAnY2xhc3MnKSB8fCAnJztcbiAgICAgICAgdmFyIHRuYW1lID0gdGhpcy5hZGFwdG9yLmtpbmQobm9kZSkgfHwgJyc7XG4gICAgICAgIHZhciBwcm9jZXNzID0gdGhpcy5wcm9jZXNzSHRtbENsYXNzLmV4ZWMoY25hbWUpO1xuICAgICAgICB2YXIgbmV4dCA9IG5vZGU7XG4gICAgICAgIGlmICh0aGlzLmFkYXB0b3IuZmlyc3RDaGlsZChub2RlKSAmJiAhdGhpcy5hZGFwdG9yLmdldEF0dHJpYnV0ZShub2RlLCAnZGF0YS1NSlgnKSAmJlxuICAgICAgICAgICAgKHByb2Nlc3MgfHwgIXRoaXMuc2tpcEh0bWxUYWdzLmV4ZWModG5hbWUpKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWRhcHRvci5uZXh0KG5vZGUpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKFt0aGlzLmFkYXB0b3IubmV4dChub2RlKSwgaWdub3JlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gdGhpcy5hZGFwdG9yLmZpcnN0Q2hpbGQobm9kZSk7XG4gICAgICAgICAgICBpZ25vcmUgPSAoaWdub3JlIHx8IHRoaXMuaWdub3JlSHRtbENsYXNzLmV4ZWMoY25hbWUpKSAmJiAhcHJvY2VzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG5leHQgPSB0aGlzLmFkYXB0b3IubmV4dChub2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW25leHQsIGlnbm9yZV07XG4gICAgfTtcbiAgICBIVE1MRG9tU3RyaW5ncy5wcm90b3R5cGUuaGFuZGxlT3RoZXIgPSBmdW5jdGlvbiAobm9kZSwgX2lnbm9yZSkge1xuICAgICAgICB0aGlzLnB1c2hTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRvci5uZXh0KG5vZGUpO1xuICAgIH07XG4gICAgSFRNTERvbVN0cmluZ3MucHJvdG90eXBlLmZpbmQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgdmFyIHN0b3AgPSB0aGlzLmFkYXB0b3IubmV4dChub2RlKTtcbiAgICAgICAgdmFyIGlnbm9yZSA9IGZhbHNlO1xuICAgICAgICB2YXIgaW5jbHVkZSA9IHRoaXMub3B0aW9uc1snaW5jbHVkZUh0bWxUYWdzJ107XG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IHN0b3ApIHtcbiAgICAgICAgICAgIHZhciBraW5kID0gdGhpcy5hZGFwdG9yLmtpbmQobm9kZSk7XG4gICAgICAgICAgICBpZiAoa2luZCA9PT0gJyN0ZXh0Jykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhbmRsZVRleHQobm9kZSwgaWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGluY2x1ZGUuaGFzT3duUHJvcGVydHkoa2luZCkpIHtcbiAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5oYW5kbGVUYWcobm9kZSwgaWdub3JlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGtpbmQpIHtcbiAgICAgICAgICAgICAgICBfYSA9IF9fcmVhZCh0aGlzLmhhbmRsZUNvbnRhaW5lcihub2RlLCBpZ25vcmUpLCAyKSwgbm9kZSA9IF9hWzBdLCBpZ25vcmUgPSBfYVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmhhbmRsZU90aGVyKG5vZGUsIGlnbm9yZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW5vZGUgJiYgdGhpcy5zdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnB1c2hTdHJpbmcoKTtcbiAgICAgICAgICAgICAgICBfYiA9IF9fcmVhZCh0aGlzLnN0YWNrLnBvcCgpLCAyKSwgbm9kZSA9IF9iWzBdLCBpZ25vcmUgPSBfYlsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnB1c2hTdHJpbmcoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IFt0aGlzLnN0cmluZ3MsIHRoaXMubm9kZXNdO1xuICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIEhUTUxEb21TdHJpbmdzLk9QVElPTlMgPSB7XG4gICAgICAgIHNraXBIdG1sVGFnczogWydzY3JpcHQnLCAnbm9zY3JpcHQnLCAnc3R5bGUnLCAndGV4dGFyZWEnLCAncHJlJywgJ2NvZGUnLCAnYW5ub3RhdGlvbicsICdhbm5vdGF0aW9uLXhtbCddLFxuICAgICAgICBpbmNsdWRlSHRtbFRhZ3M6IHsgYnI6ICdcXG4nLCB3YnI6ICcnLCAnI2NvbW1lbnQnOiAnJyB9LFxuICAgICAgICBpZ25vcmVIdG1sQ2xhc3M6ICdtYXRoamF4X2lnbm9yZScsXG4gICAgICAgIHByb2Nlc3NIdG1sQ2xhc3M6ICdtYXRoamF4X3Byb2Nlc3MnXG4gICAgfTtcbiAgICByZXR1cm4gSFRNTERvbVN0cmluZ3M7XG59KCkpO1xuZXhwb3J0cy5IVE1MRG9tU3RyaW5ncyA9IEhUTUxEb21TdHJpbmdzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SFRNTERvbVN0cmluZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IVE1MSGFuZGxlciA9IHZvaWQgMDtcbnZhciBIYW5kbGVyX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9IYW5kbGVyLmpzXCIpO1xudmFyIEhUTUxEb2N1bWVudF9qc18xID0gcmVxdWlyZShcIi4vSFRNTERvY3VtZW50LmpzXCIpO1xudmFyIEhUTUxIYW5kbGVyID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFRNTEhhbmRsZXIsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSFRNTEhhbmRsZXIoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kb2N1bWVudENsYXNzID0gSFRNTERvY3VtZW50X2pzXzEuSFRNTERvY3VtZW50O1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEhUTUxIYW5kbGVyLnByb3RvdHlwZS5oYW5kbGVzRG9jdW1lbnQgPSBmdW5jdGlvbiAoZG9jdW1lbnQpIHtcbiAgICAgICAgdmFyIGFkYXB0b3IgPSB0aGlzLmFkYXB0b3I7XG4gICAgICAgIGlmICh0eXBlb2YgKGRvY3VtZW50KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9jdW1lbnQgPSBhZGFwdG9yLnBhcnNlKGRvY3VtZW50LCAndGV4dC9odG1sJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnQgaW5zdGFuY2VvZiBhZGFwdG9yLndpbmRvdy5Eb2N1bWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQgaW5zdGFuY2VvZiBhZGFwdG9yLndpbmRvdy5IVE1MRWxlbWVudCB8fFxuICAgICAgICAgICAgZG9jdW1lbnQgaW5zdGFuY2VvZiBhZGFwdG9yLndpbmRvdy5Eb2N1bWVudEZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICBIVE1MSGFuZGxlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGRvY3VtZW50LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICBpZiAodHlwZW9mIChkb2N1bWVudCkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBkb2N1bWVudCA9IGFkYXB0b3IucGFyc2UoZG9jdW1lbnQsICd0ZXh0L2h0bWwnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChkb2N1bWVudCBpbnN0YW5jZW9mIGFkYXB0b3Iud2luZG93LkhUTUxFbGVtZW50IHx8XG4gICAgICAgICAgICBkb2N1bWVudCBpbnN0YW5jZW9mIGFkYXB0b3Iud2luZG93LkRvY3VtZW50RnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgZG9jdW1lbnQgPSBhZGFwdG9yLnBhcnNlKCcnLCAndGV4dC9odG1sJyk7XG4gICAgICAgICAgICBhZGFwdG9yLmFwcGVuZChhZGFwdG9yLmJvZHkoZG9jdW1lbnQpLCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuY3JlYXRlLmNhbGwodGhpcywgZG9jdW1lbnQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgcmV0dXJuIEhUTUxIYW5kbGVyO1xufShIYW5kbGVyX2pzXzEuQWJzdHJhY3RIYW5kbGVyKSk7XG5leHBvcnRzLkhUTUxIYW5kbGVyID0gSFRNTEhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MSGFuZGxlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhUTUxNYXRoSXRlbSA9IHZvaWQgMDtcbnZhciBNYXRoSXRlbV9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTWF0aEl0ZW0uanNcIik7XG52YXIgSFRNTE1hdGhJdGVtID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoSFRNTE1hdGhJdGVtLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEhUTUxNYXRoSXRlbShtYXRoLCBqYXgsIGRpc3BsYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgaWYgKGRpc3BsYXkgPT09IHZvaWQgMCkgeyBkaXNwbGF5ID0gdHJ1ZTsgfVxuICAgICAgICBpZiAoc3RhcnQgPT09IHZvaWQgMCkgeyBzdGFydCA9IHsgbm9kZTogbnVsbCwgbjogMCwgZGVsaW06ICcnIH07IH1cbiAgICAgICAgaWYgKGVuZCA9PT0gdm9pZCAwKSB7IGVuZCA9IHsgbm9kZTogbnVsbCwgbjogMCwgZGVsaW06ICcnIH07IH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIG1hdGgsIGpheCwgZGlzcGxheSwgc3RhcnQsIGVuZCkgfHwgdGhpcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxNYXRoSXRlbS5wcm90b3R5cGUsIFwiYWRhcHRvclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRKYXguYWRhcHRvcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEhUTUxNYXRoSXRlbS5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnQgPSBmdW5jdGlvbiAoX2h0bWwpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA8IE1hdGhJdGVtX2pzXzEuU1RBVEUuSU5TRVJURUQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SmF4LnByb2Nlc3NTdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Lm5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMuZW5kLm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5kLm4gJiYgdGhpcy5lbmQubiA8IHRoaXMuYWRhcHRvci52YWx1ZSh0aGlzLmVuZC5ub2RlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zcGxpdCh0aGlzLmVuZC5ub2RlLCB0aGlzLmVuZC5uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGFydC5uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gdGhpcy5hZGFwdG9yLnNwbGl0KHRoaXMuc3RhcnQubm9kZSwgdGhpcy5zdGFydC5uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3IucmVwbGFjZSh0aGlzLnR5cGVzZXRSb290LCBub2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0Lm4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSB0aGlzLmFkYXB0b3Iuc3BsaXQobm9kZSwgdGhpcy5zdGFydC5uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAobm9kZSAhPT0gdGhpcy5lbmQubm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5leHQgPSB0aGlzLmFkYXB0b3IubmV4dChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5yZW1vdmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3IuaW5zZXJ0KHRoaXMudHlwZXNldFJvb3QsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5lbmQubiA8IHRoaXMuYWRhcHRvci52YWx1ZShub2RlKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5zcGxpdChub2RlLCB0aGlzLmVuZC5uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFkYXB0b3IucmVtb3ZlKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRvci5yZXBsYWNlKHRoaXMudHlwZXNldFJvb3QsIHRoaXMuc3RhcnQubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXJ0Lm5vZGUgPSB0aGlzLmVuZC5ub2RlID0gdGhpcy50eXBlc2V0Um9vdDtcbiAgICAgICAgICAgIHRoaXMuc3RhcnQubiA9IHRoaXMuZW5kLm4gPSAwO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZShNYXRoSXRlbV9qc18xLlNUQVRFLklOU0VSVEVEKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgSFRNTE1hdGhJdGVtLnByb3RvdHlwZS51cGRhdGVTdHlsZVNoZWV0ID0gZnVuY3Rpb24gKGRvY3VtZW50KSB7XG4gICAgICAgIGRvY3VtZW50LmFkZFN0eWxlU2hlZXQoKTtcbiAgICB9O1xuICAgIEhUTUxNYXRoSXRlbS5wcm90b3R5cGUucmVtb3ZlRnJvbURvY3VtZW50ID0gZnVuY3Rpb24gKHJlc3RvcmUpIHtcbiAgICAgICAgaWYgKHJlc3RvcmUgPT09IHZvaWQgMCkgeyByZXN0b3JlID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA+PSBNYXRoSXRlbV9qc18xLlNUQVRFLlRZUEVTRVQpIHtcbiAgICAgICAgICAgIHZhciBhZGFwdG9yID0gdGhpcy5hZGFwdG9yO1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YXJ0Lm5vZGU7XG4gICAgICAgICAgICB2YXIgbWF0aCA9IGFkYXB0b3IudGV4dCgnJyk7XG4gICAgICAgICAgICBpZiAocmVzdG9yZSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gdGhpcy5zdGFydC5kZWxpbSArIHRoaXMubWF0aCArIHRoaXMuZW5kLmRlbGltO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlucHV0SmF4LnByb2Nlc3NTdHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGggPSBhZGFwdG9yLnRleHQodGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZG9jID0gYWRhcHRvci5wYXJzZSh0ZXh0LCAndGV4dC9odG1sJyk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGggPSBhZGFwdG9yLmZpcnN0Q2hpbGQoYWRhcHRvci5ib2R5KGRvYykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhZGFwdG9yLnBhcmVudChub2RlKSkge1xuICAgICAgICAgICAgICAgIGFkYXB0b3IucmVwbGFjZShtYXRoLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3RhcnQubm9kZSA9IHRoaXMuZW5kLm5vZGUgPSBtYXRoO1xuICAgICAgICAgICAgdGhpcy5zdGFydC5uID0gdGhpcy5lbmQubiA9IDA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBIVE1MTWF0aEl0ZW07XG59KE1hdGhJdGVtX2pzXzEuQWJzdHJhY3RNYXRoSXRlbSkpO1xuZXhwb3J0cy5IVE1MTWF0aEl0ZW0gPSBIVE1MTWF0aEl0ZW07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IVE1MTWF0aEl0ZW0uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IVE1MTWF0aExpc3QgPSB2b2lkIDA7XG52YXIgTWF0aExpc3RfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL01hdGhMaXN0LmpzXCIpO1xudmFyIEhUTUxNYXRoTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEhUTUxNYXRoTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIVE1MTWF0aExpc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgcmV0dXJuIEhUTUxNYXRoTGlzdDtcbn0oTWF0aExpc3RfanNfMS5BYnN0cmFjdE1hdGhMaXN0KSk7XG5leHBvcnRzLkhUTUxNYXRoTGlzdCA9IEhUTUxNYXRoTGlzdDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUhUTUxNYXRoTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkJpdEZpZWxkQ2xhc3MgPSBleHBvcnRzLkJpdEZpZWxkID0gdm9pZCAwO1xudmFyIEJpdEZpZWxkID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaXRGaWVsZCgpIHtcbiAgICAgICAgdGhpcy5iaXRzID0gMDtcbiAgICB9XG4gICAgQml0RmllbGQuYWxsb2NhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIG5hbWVzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIG5hbWVzXzEgPSBfX3ZhbHVlcyhuYW1lcyksIG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpOyAhbmFtZXNfMV8xLmRvbmU7IG5hbWVzXzFfMSA9IG5hbWVzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IG5hbWVzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXMobmFtZV8xKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0JpdCBhbHJlYWR5IGFsbG9jYXRlZCBmb3IgJyArIG5hbWVfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5leHQgPT09IEJpdEZpZWxkLk1BWEJJVCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gbnVtYmVyIG9mIGJpdHMgYWxyZWFkeSBhbGxvY2F0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5uYW1lcy5zZXQobmFtZV8xLCB0aGlzLm5leHQpO1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dCA8PD0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVzXzFfMSAmJiAhbmFtZXNfMV8xLmRvbmUgJiYgKF9hID0gbmFtZXNfMS5yZXR1cm4pKSBfYS5jYWxsKG5hbWVzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBCaXRGaWVsZC5oYXMgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uYW1lcy5oYXMobmFtZSk7XG4gICAgfTtcbiAgICBCaXRGaWVsZC5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5iaXRzIHw9IHRoaXMuZ2V0Qml0KG5hbWUpO1xuICAgIH07XG4gICAgQml0RmllbGQucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdGhpcy5iaXRzICY9IH50aGlzLmdldEJpdChuYW1lKTtcbiAgICB9O1xuICAgIEJpdEZpZWxkLnByb3RvdHlwZS5pc1NldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiAhISh0aGlzLmJpdHMgJiB0aGlzLmdldEJpdChuYW1lKSk7XG4gICAgfTtcbiAgICBCaXRGaWVsZC5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuYml0cyA9IDA7XG4gICAgfTtcbiAgICBCaXRGaWVsZC5wcm90b3R5cGUuZ2V0Qml0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGJpdCA9IHRoaXMuY29uc3RydWN0b3IubmFtZXMuZ2V0KG5hbWUpO1xuICAgICAgICBpZiAoIWJpdCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGJpdC1maWVsZCBuYW1lOiAnICsgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpdDtcbiAgICB9O1xuICAgIEJpdEZpZWxkLk1BWEJJVCA9IDEgPDwgMzE7XG4gICAgQml0RmllbGQubmV4dCA9IDE7XG4gICAgQml0RmllbGQubmFtZXMgPSBuZXcgTWFwKCk7XG4gICAgcmV0dXJuIEJpdEZpZWxkO1xufSgpKTtcbmV4cG9ydHMuQml0RmllbGQgPSBCaXRGaWVsZDtcbmZ1bmN0aW9uIEJpdEZpZWxkQ2xhc3MoKSB7XG4gICAgdmFyIG5hbWVzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgbmFtZXNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgdmFyIEJpdHMgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgICAgICBfX2V4dGVuZHMoQml0cywgX3N1cGVyKTtcbiAgICAgICAgZnVuY3Rpb24gQml0cygpIHtcbiAgICAgICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQml0cztcbiAgICB9KEJpdEZpZWxkKSk7XG4gICAgQml0cy5hbGxvY2F0ZS5hcHBseShCaXRzLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQobmFtZXMpLCBmYWxzZSkpO1xuICAgIHJldHVybiBCaXRzO1xufVxuZXhwb3J0cy5CaXRGaWVsZENsYXNzID0gQml0RmllbGRDbGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJpdEZpZWxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRnVuY3Rpb25MaXN0ID0gdm9pZCAwO1xudmFyIFByaW9yaXRpemVkTGlzdF9qc18xID0gcmVxdWlyZShcIi4vUHJpb3JpdGl6ZWRMaXN0LmpzXCIpO1xudmFyIEZ1bmN0aW9uTGlzdCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKEZ1bmN0aW9uTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBGdW5jdGlvbkxpc3QoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgRnVuY3Rpb25MaXN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGRhdGEgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGRhdGFbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGl0ZW0uaXRlbS5hcHBseShpdGVtLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZGF0YSksIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gICAgRnVuY3Rpb25MaXN0LnByb3RvdHlwZS5hc3luY0V4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBkYXRhW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChvaywgZmFpbCkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIGV4ZWN1dGUoKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHdoaWxlICgrK2kgPCBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IChfYSA9IGl0ZW1zW2ldKS5pdGVtLmFwcGx5KF9hLCBfX3NwcmVhZEFycmF5KFtdLCBfX3JlYWQoZGF0YSksIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQudGhlbihleGVjdXRlKS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBmYWlsKGVycik7IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2sodHJ1ZSk7XG4gICAgICAgICAgICB9KSgpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiBGdW5jdGlvbkxpc3Q7XG59KFByaW9yaXRpemVkTGlzdF9qc18xLlByaW9yaXRpemVkTGlzdCkpO1xuZXhwb3J0cy5GdW5jdGlvbkxpc3QgPSBGdW5jdGlvbkxpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GdW5jdGlvbkxpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19nZW5lcmF0b3IgPSAodGhpcyAmJiB0aGlzLl9fZ2VuZXJhdG9yKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgYm9keSkge1xuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xuICAgICAgICAgICAgaWYgKHkgPSAwLCB0KSBvcCA9IFtvcFswXSAmIDIsIHQudmFsdWVdO1xuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgNDogXy5sYWJlbCsrOyByZXR1cm4geyB2YWx1ZTogb3BbMV0sIGRvbmU6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSA2ICYmIF8ubGFiZWwgPCB0WzFdKSB7IF8ubGFiZWwgPSB0WzFdOyB0ID0gb3A7IGJyZWFrOyB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHsgb3AgPSBbNiwgZV07IHkgPSAwOyB9IGZpbmFsbHkgeyBmID0gdCA9IDA7IH1cbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XG4gICAgfVxufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTGlua2VkTGlzdCA9IGV4cG9ydHMuTGlzdEl0ZW0gPSBleHBvcnRzLkVORCA9IHZvaWQgMDtcbmV4cG9ydHMuRU5EID0gU3ltYm9sKCk7XG52YXIgTGlzdEl0ZW0gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpc3RJdGVtKGRhdGEpIHtcbiAgICAgICAgaWYgKGRhdGEgPT09IHZvaWQgMCkgeyBkYXRhID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gTGlzdEl0ZW07XG59KCkpO1xuZXhwb3J0cy5MaXN0SXRlbSA9IExpc3RJdGVtO1xudmFyIExpbmtlZExpc3QgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExpbmtlZExpc3QoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0ID0gbmV3IExpc3RJdGVtKGV4cG9ydHMuRU5EKTtcbiAgICAgICAgdGhpcy5saXN0Lm5leHQgPSB0aGlzLmxpc3QucHJldiA9IHRoaXMubGlzdDtcbiAgICAgICAgdGhpcy5wdXNoLmFwcGx5KHRoaXMsIF9fc3ByZWFkQXJyYXkoW10sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICB9XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuaXNCZWZvcmUgPSBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gYSA8IGI7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYXJnc18xID0gX192YWx1ZXMoYXJncyksIGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKTsgIWFyZ3NfMV8xLmRvbmU7IGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBkYXRhID0gYXJnc18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBuZXcgTGlzdEl0ZW0oZGF0YSk7XG4gICAgICAgICAgICAgICAgaXRlbS5uZXh0ID0gdGhpcy5saXN0O1xuICAgICAgICAgICAgICAgIGl0ZW0ucHJldiA9IHRoaXMubGlzdC5wcmV2O1xuICAgICAgICAgICAgICAgIHRoaXMubGlzdC5wcmV2ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBpdGVtLnByZXYubmV4dCA9IGl0ZW07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChhcmdzXzFfMSAmJiAhYXJnc18xXzEuZG9uZSAmJiAoX2EgPSBhcmdzXzEucmV0dXJuKSkgX2EuY2FsbChhcmdzXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUucG9wID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgaXRlbSA9IHRoaXMubGlzdC5wcmV2O1xuICAgICAgICBpZiAoaXRlbS5kYXRhID09PSBleHBvcnRzLkVORCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0LnByZXYgPSBpdGVtLnByZXY7XG4gICAgICAgIGl0ZW0ucHJldi5uZXh0ID0gdGhpcy5saXN0O1xuICAgICAgICBpdGVtLm5leHQgPSBpdGVtLnByZXYgPSBudWxsO1xuICAgICAgICByZXR1cm4gaXRlbS5kYXRhO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoYXJncy5zbGljZSgwKS5yZXZlcnNlKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IG5ldyBMaXN0SXRlbShkYXRhKTtcbiAgICAgICAgICAgICAgICBpdGVtLm5leHQgPSB0aGlzLmxpc3QubmV4dDtcbiAgICAgICAgICAgICAgICBpdGVtLnByZXYgPSB0aGlzLmxpc3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5saXN0Lm5leHQgPSBpdGVtO1xuICAgICAgICAgICAgICAgIGl0ZW0ubmV4dC5wcmV2ID0gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gICAgTGlua2VkTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5saXN0Lm5leHQ7XG4gICAgICAgIGlmIChpdGVtLmRhdGEgPT09IGV4cG9ydHMuRU5EKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpc3QubmV4dCA9IGl0ZW0ubmV4dDtcbiAgICAgICAgaXRlbS5uZXh0LnByZXYgPSB0aGlzLmxpc3Q7XG4gICAgICAgIGl0ZW0ubmV4dCA9IGl0ZW0ucHJldiA9IG51bGw7XG4gICAgICAgIHJldHVybiBpdGVtLmRhdGE7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgaXRlbXMgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGl0ZW1zW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIGl0ZW1zXzEgPSBfX3ZhbHVlcyhpdGVtcyksIGl0ZW1zXzFfMSA9IGl0ZW1zXzEubmV4dCgpOyAhaXRlbXNfMV8xLmRvbmU7IGl0ZW1zXzFfMSA9IGl0ZW1zXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1fMSA9IGl0ZW1zXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBtYXAuc2V0KGl0ZW1fMSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtc18xXzEgJiYgIWl0ZW1zXzFfMS5kb25lICYmIChfYSA9IGl0ZW1zXzEucmV0dXJuKSkgX2EuY2FsbChpdGVtc18xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaXRlbSA9IHRoaXMubGlzdC5uZXh0O1xuICAgICAgICB3aGlsZSAoaXRlbS5kYXRhICE9PSBleHBvcnRzLkVORCkge1xuICAgICAgICAgICAgdmFyIG5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICBpZiAobWFwLmhhcyhpdGVtLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgaXRlbS5wcmV2Lm5leHQgPSBpdGVtLm5leHQ7XG4gICAgICAgICAgICAgICAgaXRlbS5uZXh0LnByZXYgPSBpdGVtLnByZXY7XG4gICAgICAgICAgICAgICAgaXRlbS5uZXh0ID0gaXRlbS5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZW0gPSBuZXh0O1xuICAgICAgICB9XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5saXN0Lm5leHQucHJldiA9IHRoaXMubGlzdC5wcmV2Lm5leHQgPSBudWxsO1xuICAgICAgICB0aGlzLmxpc3QubmV4dCA9IHRoaXMubGlzdC5wcmV2ID0gdGhpcy5saXN0O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjdXJyZW50O1xuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gdGhpcy5saXN0Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGlmICghKGN1cnJlbnQuZGF0YSAhPT0gZXhwb3J0cy5FTkQpKSByZXR1cm4gWzMsIDNdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQsIGN1cnJlbnQuZGF0YV07XG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMywgMV07XG4gICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIExpbmtlZExpc3QucHJvdG90eXBlLnJldmVyc2VkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY3VycmVudDtcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xuICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudCA9IHRoaXMubGlzdC5wcmV2O1xuICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgICAgICBpZiAoIShjdXJyZW50LmRhdGEgIT09IGV4cG9ydHMuRU5EKSkgcmV0dXJuIFszLCAzXTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0LCBjdXJyZW50LmRhdGFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5wcmV2O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMsIDFdO1xuICAgICAgICAgICAgICAgIGNhc2UgMzogcmV0dXJuIFsyXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiAoZGF0YSwgaXNCZWZvcmUpIHtcbiAgICAgICAgaWYgKGlzQmVmb3JlID09PSB2b2lkIDApIHsgaXNCZWZvcmUgPSBudWxsOyB9XG4gICAgICAgIGlmIChpc0JlZm9yZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaXNCZWZvcmUgPSB0aGlzLmlzQmVmb3JlLmJpbmQodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW0gPSBuZXcgTGlzdEl0ZW0oZGF0YSk7XG4gICAgICAgIHZhciBjdXIgPSB0aGlzLmxpc3QubmV4dDtcbiAgICAgICAgd2hpbGUgKGN1ci5kYXRhICE9PSBleHBvcnRzLkVORCAmJiBpc0JlZm9yZShjdXIuZGF0YSwgaXRlbS5kYXRhKSkge1xuICAgICAgICAgICAgY3VyID0gY3VyLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5wcmV2ID0gY3VyLnByZXY7XG4gICAgICAgIGl0ZW0ubmV4dCA9IGN1cjtcbiAgICAgICAgY3VyLnByZXYubmV4dCA9IGN1ci5wcmV2ID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5zb3J0ID0gZnVuY3Rpb24gKGlzQmVmb3JlKSB7XG4gICAgICAgIHZhciBlXzQsIF9hO1xuICAgICAgICBpZiAoaXNCZWZvcmUgPT09IHZvaWQgMCkgeyBpc0JlZm9yZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKGlzQmVmb3JlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpc0JlZm9yZSA9IHRoaXMuaXNCZWZvcmUuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGlzdHMgPSBbXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIGxpc3RzLnB1c2gobmV3IExpbmtlZExpc3QoaXRlbSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzRfMSkgeyBlXzQgPSB7IGVycm9yOiBlXzRfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNCkgdGhyb3cgZV80LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saXN0Lm5leHQgPSB0aGlzLmxpc3QucHJldiA9IHRoaXMubGlzdDtcbiAgICAgICAgd2hpbGUgKGxpc3RzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhciBsMSA9IGxpc3RzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgbDIgPSBsaXN0cy5zaGlmdCgpO1xuICAgICAgICAgICAgbDEubWVyZ2UobDIsIGlzQmVmb3JlKTtcbiAgICAgICAgICAgIGxpc3RzLnB1c2gobDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdCA9IGxpc3RzWzBdLmxpc3Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcbiAgICBMaW5rZWRMaXN0LnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uIChsaXN0LCBpc0JlZm9yZSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lO1xuICAgICAgICBpZiAoaXNCZWZvcmUgPT09IHZvaWQgMCkgeyBpc0JlZm9yZSA9IG51bGw7IH1cbiAgICAgICAgaWYgKGlzQmVmb3JlID09PSBudWxsKSB7XG4gICAgICAgICAgICBpc0JlZm9yZSA9IHRoaXMuaXNCZWZvcmUuYmluZCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGN1ciA9IHRoaXMubGlzdC5uZXh0O1xuICAgICAgICB2YXIgbWN1ciA9IGxpc3QubGlzdC5uZXh0O1xuICAgICAgICB3aGlsZSAobGN1ci5kYXRhICE9PSBleHBvcnRzLkVORCAmJiBtY3VyLmRhdGEgIT09IGV4cG9ydHMuRU5EKSB7XG4gICAgICAgICAgICBpZiAoaXNCZWZvcmUobWN1ci5kYXRhLCBsY3VyLmRhdGEpKSB7XG4gICAgICAgICAgICAgICAgX2EgPSBfX3JlYWQoW2xjdXIsIG1jdXJdLCAyKSwgbWN1ci5wcmV2Lm5leHQgPSBfYVswXSwgbGN1ci5wcmV2Lm5leHQgPSBfYVsxXTtcbiAgICAgICAgICAgICAgICBfYiA9IF9fcmVhZChbbGN1ci5wcmV2LCBtY3VyLnByZXZdLCAyKSwgbWN1ci5wcmV2ID0gX2JbMF0sIGxjdXIucHJldiA9IF9iWzFdO1xuICAgICAgICAgICAgICAgIF9jID0gX19yZWFkKFtsaXN0Lmxpc3QsIHRoaXMubGlzdF0sIDIpLCB0aGlzLmxpc3QucHJldi5uZXh0ID0gX2NbMF0sIGxpc3QubGlzdC5wcmV2Lm5leHQgPSBfY1sxXTtcbiAgICAgICAgICAgICAgICBfZCA9IF9fcmVhZChbbGlzdC5saXN0LnByZXYsIHRoaXMubGlzdC5wcmV2XSwgMiksIHRoaXMubGlzdC5wcmV2ID0gX2RbMF0sIGxpc3QubGlzdC5wcmV2ID0gX2RbMV07XG4gICAgICAgICAgICAgICAgX2UgPSBfX3JlYWQoW21jdXIubmV4dCwgbGN1cl0sIDIpLCBsY3VyID0gX2VbMF0sIG1jdXIgPSBfZVsxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxjdXIgPSBsY3VyLm5leHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1jdXIuZGF0YSAhPT0gZXhwb3J0cy5FTkQpIHtcbiAgICAgICAgICAgIHRoaXMubGlzdC5wcmV2Lm5leHQgPSBsaXN0Lmxpc3QubmV4dDtcbiAgICAgICAgICAgIGxpc3QubGlzdC5uZXh0LnByZXYgPSB0aGlzLmxpc3QucHJldjtcbiAgICAgICAgICAgIGxpc3QubGlzdC5wcmV2Lm5leHQgPSB0aGlzLmxpc3Q7XG4gICAgICAgICAgICB0aGlzLmxpc3QucHJldiA9IGxpc3QubGlzdC5wcmV2O1xuICAgICAgICAgICAgbGlzdC5saXN0Lm5leHQgPSBsaXN0Lmxpc3QucHJldiA9IGxpc3QubGlzdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIHJldHVybiBMaW5rZWRMaXN0O1xufSgpKTtcbmV4cG9ydHMuTGlua2VkTGlzdCA9IExpbmtlZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1MaW5rZWRMaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcmlvcml0aXplZExpc3QgPSB2b2lkIDA7XG52YXIgUHJpb3JpdGl6ZWRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcmlvcml0aXplZExpc3QoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBQcmlvcml0aXplZExpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbXNbaSsrXSwgZG9uZTogKGkgPiBpdGVtcy5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQcmlvcml0aXplZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IFByaW9yaXRpemVkTGlzdC5ERUZBVUxUUFJJT1JJVFk7IH1cbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9IHdoaWxlIChpID49IDAgJiYgcHJpb3JpdHkgPCB0aGlzLml0ZW1zW2ldLnByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSArIDEsIDAsIHsgaXRlbTogaXRlbSwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIFByaW9yaXRpemVkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9IHdoaWxlIChpID49IDAgJiYgdGhpcy5pdGVtc1tpXS5pdGVtICE9PSBpdGVtKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXRpemVkTGlzdC5ERUZBVUxUUFJJT1JJVFkgPSA1O1xuICAgIHJldHVybiBQcmlvcml0aXplZExpc3Q7XG59KCkpO1xuZXhwb3J0cy5Qcmlvcml0aXplZExpc3QgPSBQcmlvcml0aXplZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0aXplZExpc3QuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9