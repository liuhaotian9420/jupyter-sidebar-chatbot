"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_input_tex_Configuration_js-node_modules_mathjax-full_js_-8c4c26"],{

/***/ "./node_modules/mathjax-full/js/components/version.js":
/*!************************************************************!*\
  !*** ./node_modules/mathjax-full/js/components/version.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VERSION = void 0;
exports.VERSION = '3.2.2';
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/HandlerList.js":
/*!**********************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/HandlerList.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HandlerList = void 0;
var PrioritizedList_js_1 = __webpack_require__(/*! ../util/PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var HandlerList = (function (_super) {
    __extends(HandlerList, _super);
    function HandlerList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    HandlerList.prototype.register = function (handler) {
        return this.add(handler, handler.priority);
    };
    HandlerList.prototype.unregister = function (handler) {
        this.remove(handler);
    };
    HandlerList.prototype.handlesDocument = function (document) {
        var e_1, _a;
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                var handler = item.item;
                if (handler.handlesDocument(document)) {
                    return handler;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        throw new Error("Can't find handler for document");
    };
    HandlerList.prototype.document = function (document, options) {
        if (options === void 0) { options = null; }
        return this.handlesDocument(document).create(document, options);
    };
    return HandlerList;
}(PrioritizedList_js_1.PrioritizedList));
exports.HandlerList = HandlerList;
//# sourceMappingURL=HandlerList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/Configuration.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/Configuration.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParserConfiguration = exports.ConfigurationHandler = exports.Configuration = void 0;
var Options_js_1 = __webpack_require__(/*! ../../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var MapHandler_js_1 = __webpack_require__(/*! ./MapHandler.js */ "./node_modules/mathjax-full/js/input/tex/MapHandler.js");
var FunctionList_js_1 = __webpack_require__(/*! ../../util/FunctionList.js */ "./node_modules/mathjax-full/js/util/FunctionList.js");
var PrioritizedList_js_1 = __webpack_require__(/*! ../../util/PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var Tags_js_1 = __webpack_require__(/*! ./Tags.js */ "./node_modules/mathjax-full/js/input/tex/Tags.js");
var Configuration = (function () {
    function Configuration(name, handler, fallback, items, tags, options, nodes, preprocessors, postprocessors, initMethod, configMethod, priority, parser) {
        if (handler === void 0) { handler = {}; }
        if (fallback === void 0) { fallback = {}; }
        if (items === void 0) { items = {}; }
        if (tags === void 0) { tags = {}; }
        if (options === void 0) { options = {}; }
        if (nodes === void 0) { nodes = {}; }
        if (preprocessors === void 0) { preprocessors = []; }
        if (postprocessors === void 0) { postprocessors = []; }
        if (initMethod === void 0) { initMethod = null; }
        if (configMethod === void 0) { configMethod = null; }
        this.name = name;
        this.handler = handler;
        this.fallback = fallback;
        this.items = items;
        this.tags = tags;
        this.options = options;
        this.nodes = nodes;
        this.preprocessors = preprocessors;
        this.postprocessors = postprocessors;
        this.initMethod = initMethod;
        this.configMethod = configMethod;
        this.priority = priority;
        this.parser = parser;
        this.handler = Object.assign({ character: [], delimiter: [], macro: [], environment: [] }, handler);
    }
    Configuration.makeProcessor = function (func, priority) {
        return Array.isArray(func) ? func : [func, priority];
    };
    Configuration._create = function (name, config) {
        var _this = this;
        if (config === void 0) { config = {}; }
        var priority = config.priority || PrioritizedList_js_1.PrioritizedList.DEFAULTPRIORITY;
        var init = config.init ? this.makeProcessor(config.init, priority) : null;
        var conf = config.config ? this.makeProcessor(config.config, priority) : null;
        var preprocessors = (config.preprocessors || []).map(function (pre) { return _this.makeProcessor(pre, priority); });
        var postprocessors = (config.postprocessors || []).map(function (post) { return _this.makeProcessor(post, priority); });
        var parser = config.parser || 'tex';
        return new Configuration(name, config.handler || {}, config.fallback || {}, config.items || {}, config.tags || {}, config.options || {}, config.nodes || {}, preprocessors, postprocessors, init, conf, priority, parser);
    };
    Configuration.create = function (name, config) {
        if (config === void 0) { config = {}; }
        var configuration = Configuration._create(name, config);
        ConfigurationHandler.set(name, configuration);
        return configuration;
    };
    Configuration.local = function (config) {
        if (config === void 0) { config = {}; }
        return Configuration._create('', config);
    };
    Object.defineProperty(Configuration.prototype, "init", {
        get: function () {
            return this.initMethod ? this.initMethod[0] : null;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Configuration.prototype, "config", {
        get: function () {
            return this.configMethod ? this.configMethod[0] : null;
        },
        enumerable: false,
        configurable: true
    });
    return Configuration;
}());
exports.Configuration = Configuration;
var ConfigurationHandler;
(function (ConfigurationHandler) {
    var maps = new Map();
    ConfigurationHandler.set = function (name, map) {
        maps.set(name, map);
    };
    ConfigurationHandler.get = function (name) {
        return maps.get(name);
    };
    ConfigurationHandler.keys = function () {
        return maps.keys();
    };
})(ConfigurationHandler = exports.ConfigurationHandler || (exports.ConfigurationHandler = {}));
var ParserConfiguration = (function () {
    function ParserConfiguration(packages, parsers) {
        var e_1, _a, e_2, _b;
        if (parsers === void 0) { parsers = ['tex']; }
        this.initMethod = new FunctionList_js_1.FunctionList();
        this.configMethod = new FunctionList_js_1.FunctionList();
        this.configurations = new PrioritizedList_js_1.PrioritizedList();
        this.parsers = [];
        this.handlers = new MapHandler_js_1.SubHandlers();
        this.items = {};
        this.tags = {};
        this.options = {};
        this.nodes = {};
        this.parsers = parsers;
        try {
            for (var _c = __values(packages.slice().reverse()), _d = _c.next(); !_d.done; _d = _c.next()) {
                var pkg = _d.value;
                this.addPackage(pkg);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_1) throw e_1.error; }
        }
        try {
            for (var _e = __values(this.configurations), _f = _e.next(); !_f.done; _f = _e.next()) {
                var _g = _f.value, config = _g.item, priority = _g.priority;
                this.append(config, priority);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    ParserConfiguration.prototype.init = function () {
        this.initMethod.execute(this);
    };
    ParserConfiguration.prototype.config = function (jax) {
        var e_3, _a;
        this.configMethod.execute(this, jax);
        try {
            for (var _b = __values(this.configurations), _c = _b.next(); !_c.done; _c = _b.next()) {
                var config = _c.value;
                this.addFilters(jax, config.item);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    ParserConfiguration.prototype.addPackage = function (pkg) {
        var name = typeof pkg === 'string' ? pkg : pkg[0];
        var conf = this.getPackage(name);
        conf && this.configurations.add(conf, typeof pkg === 'string' ? conf.priority : pkg[1]);
    };
    ParserConfiguration.prototype.add = function (name, jax, options) {
        var e_4, _a;
        if (options === void 0) { options = {}; }
        var config = this.getPackage(name);
        this.append(config);
        this.configurations.add(config, config.priority);
        this.init();
        var parser = jax.parseOptions;
        parser.nodeFactory.setCreators(config.nodes);
        try {
            for (var _b = __values(Object.keys(config.items)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var kind = _c.value;
                parser.itemFactory.setNodeClass(kind, config.items[kind]);
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        Tags_js_1.TagsFactory.addTags(config.tags);
        (0, Options_js_1.defaultOptions)(parser.options, config.options);
        (0, Options_js_1.userOptions)(parser.options, options);
        this.addFilters(jax, config);
        if (config.config) {
            config.config(this, jax);
        }
    };
    ParserConfiguration.prototype.getPackage = function (name) {
        var config = ConfigurationHandler.get(name);
        if (config && this.parsers.indexOf(config.parser) < 0) {
            throw Error("Package ".concat(name, " doesn't target the proper parser"));
        }
        return config;
    };
    ParserConfiguration.prototype.append = function (config, priority) {
        priority = priority || config.priority;
        if (config.initMethod) {
            this.initMethod.add(config.initMethod[0], config.initMethod[1]);
        }
        if (config.configMethod) {
            this.configMethod.add(config.configMethod[0], config.configMethod[1]);
        }
        this.handlers.add(config.handler, config.fallback, priority);
        Object.assign(this.items, config.items);
        Object.assign(this.tags, config.tags);
        (0, Options_js_1.defaultOptions)(this.options, config.options);
        Object.assign(this.nodes, config.nodes);
    };
    ParserConfiguration.prototype.addFilters = function (jax, config) {
        var e_5, _a, e_6, _b;
        try {
            for (var _c = __values(config.preprocessors), _d = _c.next(); !_d.done; _d = _c.next()) {
                var _e = __read(_d.value, 2), pre = _e[0], priority = _e[1];
                jax.preFilters.add(pre, priority);
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_5) throw e_5.error; }
        }
        try {
            for (var _f = __values(config.postprocessors), _g = _f.next(); !_g.done; _g = _f.next()) {
                var _h = __read(_g.value, 2), post = _h[0], priority = _h[1];
                jax.postFilters.add(post, priority);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    return ParserConfiguration;
}());
exports.ParserConfiguration = ParserConfiguration;
//# sourceMappingURL=Configuration.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/MapHandler.js":
/*!**************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/MapHandler.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubHandlers = exports.SubHandler = exports.MapHandler = void 0;
var PrioritizedList_js_1 = __webpack_require__(/*! ../../util/PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var FunctionList_js_1 = __webpack_require__(/*! ../../util/FunctionList.js */ "./node_modules/mathjax-full/js/util/FunctionList.js");
var MapHandler;
(function (MapHandler) {
    var maps = new Map();
    MapHandler.register = function (map) {
        maps.set(map.name, map);
    };
    MapHandler.getMap = function (name) {
        return maps.get(name);
    };
})(MapHandler = exports.MapHandler || (exports.MapHandler = {}));
var SubHandler = (function () {
    function SubHandler() {
        this._configuration = new PrioritizedList_js_1.PrioritizedList();
        this._fallback = new FunctionList_js_1.FunctionList();
    }
    SubHandler.prototype.add = function (maps, fallback, priority) {
        var e_1, _a;
        if (priority === void 0) { priority = PrioritizedList_js_1.PrioritizedList.DEFAULTPRIORITY; }
        try {
            for (var _b = __values(maps.slice().reverse()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_1 = _c.value;
                var map = MapHandler.getMap(name_1);
                if (!map) {
                    this.warn('Configuration ' + name_1 + ' not found! Omitted.');
                    return;
                }
                this._configuration.add(map, priority);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        if (fallback) {
            this._fallback.add(fallback, priority);
        }
    };
    SubHandler.prototype.parse = function (input) {
        var e_2, _a;
        try {
            for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {
                var map = _c.value.item;
                var result = map.parse(input);
                if (result) {
                    return result;
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        var _d = __read(input, 2), env = _d[0], symbol = _d[1];
        Array.from(this._fallback)[0].item(env, symbol);
    };
    SubHandler.prototype.lookup = function (symbol) {
        var map = this.applicable(symbol);
        return map ? map.lookup(symbol) : null;
    };
    SubHandler.prototype.contains = function (symbol) {
        return this.applicable(symbol) ? true : false;
    };
    SubHandler.prototype.toString = function () {
        var e_3, _a;
        var names = [];
        try {
            for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {
                var map = _c.value.item;
                names.push(map.name);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return names.join(', ');
    };
    SubHandler.prototype.applicable = function (symbol) {
        var e_4, _a;
        try {
            for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {
                var map = _c.value.item;
                if (map.contains(symbol)) {
                    return map;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return null;
    };
    SubHandler.prototype.retrieve = function (name) {
        var e_5, _a;
        try {
            for (var _b = __values(this._configuration), _c = _b.next(); !_c.done; _c = _b.next()) {
                var map = _c.value.item;
                if (map.name === name) {
                    return map;
                }
            }
        }
        catch (e_5_1) { e_5 = { error: e_5_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_5) throw e_5.error; }
        }
        return null;
    };
    SubHandler.prototype.warn = function (message) {
        console.log('TexParser Warning: ' + message);
    };
    return SubHandler;
}());
exports.SubHandler = SubHandler;
var SubHandlers = (function () {
    function SubHandlers() {
        this.map = new Map();
    }
    SubHandlers.prototype.add = function (handlers, fallbacks, priority) {
        var e_6, _a;
        if (priority === void 0) { priority = PrioritizedList_js_1.PrioritizedList.DEFAULTPRIORITY; }
        try {
            for (var _b = __values(Object.keys(handlers)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                var name_2 = key;
                var subHandler = this.get(name_2);
                if (!subHandler) {
                    subHandler = new SubHandler();
                    this.set(name_2, subHandler);
                }
                subHandler.add(handlers[name_2], fallbacks[name_2], priority);
            }
        }
        catch (e_6_1) { e_6 = { error: e_6_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_6) throw e_6.error; }
        }
    };
    SubHandlers.prototype.set = function (name, subHandler) {
        this.map.set(name, subHandler);
    };
    SubHandlers.prototype.get = function (name) {
        return this.map.get(name);
    };
    SubHandlers.prototype.retrieve = function (name) {
        var e_7, _a;
        try {
            for (var _b = __values(this.map.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var handler = _c.value;
                var map = handler.retrieve(name);
                if (map) {
                    return map;
                }
            }
        }
        catch (e_7_1) { e_7 = { error: e_7_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_7) throw e_7.error; }
        }
        return null;
    };
    SubHandlers.prototype.keys = function () {
        return this.map.keys();
    };
    return SubHandlers;
}());
exports.SubHandlers = SubHandlers;
//# sourceMappingURL=MapHandler.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js":
/*!************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/NodeUtil.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var MmlNode_js_1 = __webpack_require__(/*! ../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var mo_js_1 = __webpack_require__(/*! ../../core/MmlTree/MmlNodes/mo.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mo.js");
var NodeUtil;
(function (NodeUtil) {
    var attrs = new Map([
        ['autoOP', true],
        ['fnOP', true],
        ['movesupsub', true],
        ['subsupOK', true],
        ['texprimestyle', true],
        ['useHeight', true],
        ['variantForm', true],
        ['withDelims', true],
        ['mathaccent', true],
        ['open', true],
        ['close', true]
    ]);
    function createEntity(code) {
        return String.fromCodePoint(parseInt(code, 16));
    }
    NodeUtil.createEntity = createEntity;
    function getChildren(node) {
        return node.childNodes;
    }
    NodeUtil.getChildren = getChildren;
    function getText(node) {
        return node.getText();
    }
    NodeUtil.getText = getText;
    function appendChildren(node, children) {
        var e_1, _a;
        try {
            for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                var child = children_1_1.value;
                node.appendChild(child);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    NodeUtil.appendChildren = appendChildren;
    function setAttribute(node, attribute, value) {
        node.attributes.set(attribute, value);
    }
    NodeUtil.setAttribute = setAttribute;
    function setProperty(node, property, value) {
        node.setProperty(property, value);
    }
    NodeUtil.setProperty = setProperty;
    function setProperties(node, properties) {
        var e_2, _a;
        try {
            for (var _b = __values(Object.keys(properties)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_1 = _c.value;
                var value = properties[name_1];
                if (name_1 === 'texClass') {
                    node.texClass = value;
                    node.setProperty(name_1, value);
                }
                else if (name_1 === 'movablelimits') {
                    node.setProperty('movablelimits', value);
                    if (node.isKind('mo') || node.isKind('mstyle')) {
                        node.attributes.set('movablelimits', value);
                    }
                }
                else if (name_1 === 'inferred') {
                }
                else if (attrs.has(name_1)) {
                    node.setProperty(name_1, value);
                }
                else {
                    node.attributes.set(name_1, value);
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
    }
    NodeUtil.setProperties = setProperties;
    function getProperty(node, property) {
        return node.getProperty(property);
    }
    NodeUtil.getProperty = getProperty;
    function getAttribute(node, attr) {
        return node.attributes.get(attr);
    }
    NodeUtil.getAttribute = getAttribute;
    function removeProperties(node) {
        var properties = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            properties[_i - 1] = arguments[_i];
        }
        node.removeProperty.apply(node, __spreadArray([], __read(properties), false));
    }
    NodeUtil.removeProperties = removeProperties;
    function getChildAt(node, position) {
        return node.childNodes[position];
    }
    NodeUtil.getChildAt = getChildAt;
    function setChild(node, position, child) {
        var children = node.childNodes;
        children[position] = child;
        if (child) {
            child.parent = node;
        }
    }
    NodeUtil.setChild = setChild;
    function copyChildren(oldNode, newNode) {
        var children = oldNode.childNodes;
        for (var i = 0; i < children.length; i++) {
            setChild(newNode, i, children[i]);
        }
    }
    NodeUtil.copyChildren = copyChildren;
    function copyAttributes(oldNode, newNode) {
        newNode.attributes = oldNode.attributes;
        setProperties(newNode, oldNode.getAllProperties());
    }
    NodeUtil.copyAttributes = copyAttributes;
    function isType(node, kind) {
        return node.isKind(kind);
    }
    NodeUtil.isType = isType;
    function isEmbellished(node) {
        return node.isEmbellished;
    }
    NodeUtil.isEmbellished = isEmbellished;
    function getTexClass(node) {
        return node.texClass;
    }
    NodeUtil.getTexClass = getTexClass;
    function getCoreMO(node) {
        return node.coreMO();
    }
    NodeUtil.getCoreMO = getCoreMO;
    function isNode(item) {
        return item instanceof MmlNode_js_1.AbstractMmlNode || item instanceof MmlNode_js_1.AbstractMmlEmptyNode;
    }
    NodeUtil.isNode = isNode;
    function isInferred(node) {
        return node.isInferred;
    }
    NodeUtil.isInferred = isInferred;
    function getForm(node) {
        var e_3, _a;
        if (!isType(node, 'mo')) {
            return null;
        }
        var mo = node;
        var forms = mo.getForms();
        try {
            for (var forms_1 = __values(forms), forms_1_1 = forms_1.next(); !forms_1_1.done; forms_1_1 = forms_1.next()) {
                var form = forms_1_1.value;
                var symbol = mo_js_1.MmlMo.OPTABLE[form][mo.getText()];
                if (symbol) {
                    return symbol;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (forms_1_1 && !forms_1_1.done && (_a = forms_1.return)) _a.call(forms_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return null;
    }
    NodeUtil.getForm = getForm;
})(NodeUtil || (NodeUtil = {}));
exports["default"] = NodeUtil;
//# sourceMappingURL=NodeUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/ParseUtil.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var MmlNode_js_1 = __webpack_require__(/*! ../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ./TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ./TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var Entities_js_1 = __webpack_require__(/*! ../../util/Entities.js */ "./node_modules/mathjax-full/js/util/Entities.js");
var ParseUtil;
(function (ParseUtil) {
    var emPerInch = 7.2;
    var pxPerInch = 72;
    var UNIT_CASES = {
        'em': function (m) { return m; },
        'ex': function (m) { return m * .43; },
        'pt': function (m) { return m / 10; },
        'pc': function (m) { return m * 1.2; },
        'px': function (m) { return m * emPerInch / pxPerInch; },
        'in': function (m) { return m * emPerInch; },
        'cm': function (m) { return m * emPerInch / 2.54; },
        'mm': function (m) { return m * emPerInch / 25.4; },
        'mu': function (m) { return m / 18; },
    };
    var num = '([-+]?([.,]\\d+|\\d+([.,]\\d*)?))';
    var unit = '(pt|em|ex|mu|px|mm|cm|in|pc)';
    var dimenEnd = RegExp('^\\s*' + num + '\\s*' + unit + '\\s*$');
    var dimenRest = RegExp('^\\s*' + num + '\\s*' + unit + ' ?');
    function matchDimen(dim, rest) {
        if (rest === void 0) { rest = false; }
        var match = dim.match(rest ? dimenRest : dimenEnd);
        return match ?
            muReplace([match[1].replace(/,/, '.'), match[4], match[0].length]) :
            [null, null, 0];
    }
    ParseUtil.matchDimen = matchDimen;
    function muReplace(_a) {
        var _b = __read(_a, 3), value = _b[0], unit = _b[1], length = _b[2];
        if (unit !== 'mu') {
            return [value, unit, length];
        }
        var em = Em(UNIT_CASES[unit](parseFloat(value || '1')));
        return [em.slice(0, -2), 'em', length];
    }
    function dimen2em(dim) {
        var _a = __read(matchDimen(dim), 2), value = _a[0], unit = _a[1];
        var m = parseFloat(value || '1');
        var func = UNIT_CASES[unit];
        return func ? func(m) : 0;
    }
    ParseUtil.dimen2em = dimen2em;
    function Em(m) {
        if (Math.abs(m) < .0006) {
            return '0em';
        }
        return m.toFixed(3).replace(/\.?0+$/, '') + 'em';
    }
    ParseUtil.Em = Em;
    function cols() {
        var W = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            W[_i] = arguments[_i];
        }
        return W.map(function (n) { return Em(n); }).join(' ');
    }
    ParseUtil.cols = cols;
    function fenced(configuration, open, mml, close, big, color) {
        if (big === void 0) { big = ''; }
        if (color === void 0) { color = ''; }
        var nf = configuration.nodeFactory;
        var mrow = nf.create('node', 'mrow', [], { open: open, close: close, texClass: MmlNode_js_1.TEXCLASS.INNER });
        var mo;
        if (big) {
            mo = new TexParser_js_1.default('\\' + big + 'l' + open, configuration.parser.stack.env, configuration).mml();
        }
        else {
            var openNode = nf.create('text', open);
            mo = nf.create('node', 'mo', [], { fence: true, stretchy: true, symmetric: true, texClass: MmlNode_js_1.TEXCLASS.OPEN }, openNode);
        }
        NodeUtil_js_1.default.appendChildren(mrow, [mo, mml]);
        if (big) {
            mo = new TexParser_js_1.default('\\' + big + 'r' + close, configuration.parser.stack.env, configuration).mml();
        }
        else {
            var closeNode = nf.create('text', close);
            mo = nf.create('node', 'mo', [], { fence: true, stretchy: true, symmetric: true, texClass: MmlNode_js_1.TEXCLASS.CLOSE }, closeNode);
        }
        color && mo.attributes.set('mathcolor', color);
        NodeUtil_js_1.default.appendChildren(mrow, [mo]);
        return mrow;
    }
    ParseUtil.fenced = fenced;
    function fixedFence(configuration, open, mml, close) {
        var mrow = configuration.nodeFactory.create('node', 'mrow', [], { open: open, close: close, texClass: MmlNode_js_1.TEXCLASS.ORD });
        if (open) {
            NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, open, 'l')]);
        }
        if (NodeUtil_js_1.default.isType(mml, 'mrow')) {
            NodeUtil_js_1.default.appendChildren(mrow, NodeUtil_js_1.default.getChildren(mml));
        }
        else {
            NodeUtil_js_1.default.appendChildren(mrow, [mml]);
        }
        if (close) {
            NodeUtil_js_1.default.appendChildren(mrow, [mathPalette(configuration, close, 'r')]);
        }
        return mrow;
    }
    ParseUtil.fixedFence = fixedFence;
    function mathPalette(configuration, fence, side) {
        if (fence === '{' || fence === '}') {
            fence = '\\' + fence;
        }
        var D = '{\\bigg' + side + ' ' + fence + '}';
        var T = '{\\big' + side + ' ' + fence + '}';
        return new TexParser_js_1.default('\\mathchoice' + D + T + T + T, {}, configuration).mml();
    }
    ParseUtil.mathPalette = mathPalette;
    function fixInitialMO(configuration, nodes) {
        for (var i = 0, m = nodes.length; i < m; i++) {
            var child = nodes[i];
            if (child && (!NodeUtil_js_1.default.isType(child, 'mspace') &&
                (!NodeUtil_js_1.default.isType(child, 'TeXAtom') ||
                    (NodeUtil_js_1.default.getChildren(child)[0] &&
                        NodeUtil_js_1.default.getChildren(NodeUtil_js_1.default.getChildren(child)[0]).length)))) {
                if (NodeUtil_js_1.default.isEmbellished(child) ||
                    (NodeUtil_js_1.default.isType(child, 'TeXAtom') && NodeUtil_js_1.default.getTexClass(child) === MmlNode_js_1.TEXCLASS.REL)) {
                    var mi = configuration.nodeFactory.create('node', 'mi');
                    nodes.unshift(mi);
                }
                break;
            }
        }
    }
    ParseUtil.fixInitialMO = fixInitialMO;
    function internalMath(parser, text, level, font) {
        if (parser.configuration.options.internalMath) {
            return parser.configuration.options.internalMath(parser, text, level, font);
        }
        var mathvariant = font || parser.stack.env.font;
        var def = (mathvariant ? { mathvariant: mathvariant } : {});
        var mml = [], i = 0, k = 0, c, node, match = '', braces = 0;
        if (text.match(/\\?[${}\\]|\\\(|\\(eq)?ref\s*\{/)) {
            while (i < text.length) {
                c = text.charAt(i++);
                if (c === '$') {
                    if (match === '$' && braces === 0) {
                        node = parser.create('node', 'TeXAtom', [(new TexParser_js_1.default(text.slice(k, i - 1), {}, parser.configuration)).mml()]);
                        mml.push(node);
                        match = '';
                        k = i;
                    }
                    else if (match === '') {
                        if (k < i - 1) {
                            mml.push(internalText(parser, text.slice(k, i - 1), def));
                        }
                        match = '$';
                        k = i;
                    }
                }
                else if (c === '{' && match !== '') {
                    braces++;
                }
                else if (c === '}') {
                    if (match === '}' && braces === 0) {
                        var atom = (new TexParser_js_1.default(text.slice(k, i), {}, parser.configuration)).mml();
                        node = parser.create('node', 'TeXAtom', [atom], def);
                        mml.push(node);
                        match = '';
                        k = i;
                    }
                    else if (match !== '') {
                        if (braces) {
                            braces--;
                        }
                    }
                }
                else if (c === '\\') {
                    if (match === '' && text.substr(i).match(/^(eq)?ref\s*\{/)) {
                        var len = RegExp['$&'].length;
                        if (k < i - 1) {
                            mml.push(internalText(parser, text.slice(k, i - 1), def));
                        }
                        match = '}';
                        k = i - 1;
                        i += len;
                    }
                    else {
                        c = text.charAt(i++);
                        if (c === '(' && match === '') {
                            if (k < i - 2) {
                                mml.push(internalText(parser, text.slice(k, i - 2), def));
                            }
                            match = ')';
                            k = i;
                        }
                        else if (c === ')' && match === ')' && braces === 0) {
                            node = parser.create('node', 'TeXAtom', [(new TexParser_js_1.default(text.slice(k, i - 2), {}, parser.configuration)).mml()]);
                            mml.push(node);
                            match = '';
                            k = i;
                        }
                        else if (c.match(/[${}\\]/) && match === '') {
                            i--;
                            text = text.substr(0, i - 1) + text.substr(i);
                        }
                    }
                }
            }
            if (match !== '') {
                throw new TexError_js_1.default('MathNotTerminated', 'Math not terminated in text box');
            }
        }
        if (k < text.length) {
            mml.push(internalText(parser, text.slice(k), def));
        }
        if (level != null) {
            mml = [parser.create('node', 'mstyle', mml, { displaystyle: false, scriptlevel: level })];
        }
        else if (mml.length > 1) {
            mml = [parser.create('node', 'mrow', mml)];
        }
        return mml;
    }
    ParseUtil.internalMath = internalMath;
    function internalText(parser, text, def) {
        text = text.replace(/^\s+/, Entities_js_1.entities.nbsp).replace(/\s+$/, Entities_js_1.entities.nbsp);
        var textNode = parser.create('text', text);
        return parser.create('node', 'mtext', [], def, textNode);
    }
    ParseUtil.internalText = internalText;
    function underOver(parser, base, script, pos, stack) {
        ParseUtil.checkMovableLimits(base);
        if (NodeUtil_js_1.default.isType(base, 'munderover') && NodeUtil_js_1.default.isEmbellished(base)) {
            NodeUtil_js_1.default.setProperties(NodeUtil_js_1.default.getCoreMO(base), { lspace: 0, rspace: 0 });
            var mo = parser.create('node', 'mo', [], { rspace: 0 });
            base = parser.create('node', 'mrow', [mo, base]);
        }
        var mml = parser.create('node', 'munderover', [base]);
        NodeUtil_js_1.default.setChild(mml, pos === 'over' ? mml.over : mml.under, script);
        var node = mml;
        if (stack) {
            node = parser.create('node', 'TeXAtom', [mml], { texClass: MmlNode_js_1.TEXCLASS.OP, movesupsub: true });
        }
        NodeUtil_js_1.default.setProperty(node, 'subsupOK', true);
        return node;
    }
    ParseUtil.underOver = underOver;
    function checkMovableLimits(base) {
        var symbol = (NodeUtil_js_1.default.isType(base, 'mo') ? NodeUtil_js_1.default.getForm(base) : null);
        if (NodeUtil_js_1.default.getProperty(base, 'movablelimits') || (symbol && symbol[3] && symbol[3].movablelimits)) {
            NodeUtil_js_1.default.setProperties(base, { movablelimits: false });
        }
    }
    ParseUtil.checkMovableLimits = checkMovableLimits;
    function trimSpaces(text) {
        if (typeof (text) !== 'string') {
            return text;
        }
        var TEXT = text.trim();
        if (TEXT.match(/\\$/) && text.match(/ $/)) {
            TEXT += ' ';
        }
        return TEXT;
    }
    ParseUtil.trimSpaces = trimSpaces;
    function setArrayAlign(array, align) {
        align = ParseUtil.trimSpaces(align || '');
        if (align === 't') {
            array.arraydef.align = 'baseline 1';
        }
        else if (align === 'b') {
            array.arraydef.align = 'baseline -1';
        }
        else if (align === 'c') {
            array.arraydef.align = 'axis';
        }
        else if (align) {
            array.arraydef.align = align;
        }
        return array;
    }
    ParseUtil.setArrayAlign = setArrayAlign;
    function substituteArgs(parser, args, str) {
        var text = '';
        var newstring = '';
        var i = 0;
        while (i < str.length) {
            var c = str.charAt(i++);
            if (c === '\\') {
                text += c + str.charAt(i++);
            }
            else if (c === '#') {
                c = str.charAt(i++);
                if (c === '#') {
                    text += c;
                }
                else {
                    if (!c.match(/[1-9]/) || parseInt(c, 10) > args.length) {
                        throw new TexError_js_1.default('IllegalMacroParam', 'Illegal macro parameter reference');
                    }
                    newstring = addArgs(parser, addArgs(parser, newstring, text), args[parseInt(c, 10) - 1]);
                    text = '';
                }
            }
            else {
                text += c;
            }
        }
        return addArgs(parser, newstring, text);
    }
    ParseUtil.substituteArgs = substituteArgs;
    function addArgs(parser, s1, s2) {
        if (s2.match(/^[a-z]/i) && s1.match(/(^|[^\\])(\\\\)*\\[a-z]+$/i)) {
            s1 += ' ';
        }
        if (s1.length + s2.length > parser.configuration.options['maxBuffer']) {
            throw new TexError_js_1.default('MaxBufferSize', 'MathJax internal buffer size exceeded; is there a' +
                ' recursive macro call?');
        }
        return s1 + s2;
    }
    ParseUtil.addArgs = addArgs;
    function checkMaxMacros(parser, isMacro) {
        if (isMacro === void 0) { isMacro = true; }
        if (++parser.macroCount <= parser.configuration.options['maxMacros']) {
            return;
        }
        if (isMacro) {
            throw new TexError_js_1.default('MaxMacroSub1', 'MathJax maximum macro substitution count exceeded; ' +
                'is here a recursive macro call?');
        }
        else {
            throw new TexError_js_1.default('MaxMacroSub2', 'MathJax maximum substitution count exceeded; ' +
                'is there a recursive latex environment?');
        }
    }
    ParseUtil.checkMaxMacros = checkMaxMacros;
    function checkEqnEnv(parser) {
        if (parser.stack.global.eqnenv) {
            throw new TexError_js_1.default('ErroneousNestingEq', 'Erroneous nesting of equation structures');
        }
        parser.stack.global.eqnenv = true;
    }
    ParseUtil.checkEqnEnv = checkEqnEnv;
    function copyNode(node, parser) {
        var tree = node.copy();
        var options = parser.configuration;
        tree.walkTree(function (n) {
            var e_1, _a;
            options.addNode(n.kind, n);
            var lists = (n.getProperty('in-lists') || '').split(/,/);
            try {
                for (var lists_1 = __values(lists), lists_1_1 = lists_1.next(); !lists_1_1.done; lists_1_1 = lists_1.next()) {
                    var list = lists_1_1.value;
                    list && options.addNode(list, n);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (lists_1_1 && !lists_1_1.done && (_a = lists_1.return)) _a.call(lists_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
        return tree;
    }
    ParseUtil.copyNode = copyNode;
    function MmlFilterAttribute(_parser, _name, value) {
        return value;
    }
    ParseUtil.MmlFilterAttribute = MmlFilterAttribute;
    function getFontDef(parser) {
        var font = parser.stack.env['font'];
        return (font ? { mathvariant: font } : {});
    }
    ParseUtil.getFontDef = getFontDef;
    function keyvalOptions(attrib, allowed, error) {
        var e_2, _a;
        if (allowed === void 0) { allowed = null; }
        if (error === void 0) { error = false; }
        var def = readKeyval(attrib);
        if (allowed) {
            try {
                for (var _b = __values(Object.keys(def)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var key = _c.value;
                    if (!allowed.hasOwnProperty(key)) {
                        if (error) {
                            throw new TexError_js_1.default('InvalidOption', 'Invalid option: %1', key);
                        }
                        delete def[key];
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
        return def;
    }
    ParseUtil.keyvalOptions = keyvalOptions;
    function readKeyval(text) {
        var _a, _b;
        var options = {};
        var rest = text;
        var end, key, val;
        while (rest) {
            _a = __read(readValue(rest, ['=', ',']), 3), key = _a[0], end = _a[1], rest = _a[2];
            if (end === '=') {
                _b = __read(readValue(rest, [',']), 3), val = _b[0], end = _b[1], rest = _b[2];
                val = (val === 'false' || val === 'true') ?
                    JSON.parse(val) : val;
                options[key] = val;
            }
            else if (key) {
                options[key] = true;
            }
        }
        return options;
    }
    function removeBraces(text, count) {
        while (count > 0) {
            text = text.trim().slice(1, -1);
            count--;
        }
        return text.trim();
    }
    function readValue(text, end) {
        var length = text.length;
        var braces = 0;
        var value = '';
        var index = 0;
        var start = 0;
        var startCount = true;
        var stopCount = false;
        while (index < length) {
            var c = text[index++];
            switch (c) {
                case ' ':
                    break;
                case '{':
                    if (startCount) {
                        start++;
                    }
                    else {
                        stopCount = false;
                        if (start > braces) {
                            start = braces;
                        }
                    }
                    braces++;
                    break;
                case '}':
                    if (braces) {
                        braces--;
                    }
                    if (startCount || stopCount) {
                        start--;
                        stopCount = true;
                    }
                    startCount = false;
                    break;
                default:
                    if (!braces && end.indexOf(c) !== -1) {
                        return [stopCount ? 'true' :
                                removeBraces(value, start), c, text.slice(index)];
                    }
                    startCount = false;
                    stopCount = false;
            }
            value += c;
        }
        if (braces) {
            throw new TexError_js_1.default('ExtraOpenMissingClose', 'Extra open brace or missing close brace');
        }
        return [stopCount ? 'true' : removeBraces(value, start), '', text.slice(index)];
    }
})(ParseUtil || (ParseUtil = {}));
exports["default"] = ParseUtil;
//# sourceMappingURL=ParseUtil.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/Stack.js":
/*!*********************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/Stack.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var NodeUtil_js_1 = __importDefault(__webpack_require__(/*! ./NodeUtil.js */ "./node_modules/mathjax-full/js/input/tex/NodeUtil.js"));
var Stack = (function () {
    function Stack(_factory, _env, inner) {
        this._factory = _factory;
        this._env = _env;
        this.global = {};
        this.stack = [];
        this.global = { isInner: inner };
        this.stack = [this._factory.create('start', this.global)];
        if (_env) {
            this.stack[0].env = _env;
        }
        this.env = this.stack[0].env;
    }
    Object.defineProperty(Stack.prototype, "env", {
        get: function () {
            return this._env;
        },
        set: function (env) {
            this._env = env;
        },
        enumerable: false,
        configurable: true
    });
    Stack.prototype.Push = function () {
        var e_1, _a;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var node = args_1_1.value;
                if (!node) {
                    continue;
                }
                var item = NodeUtil_js_1.default.isNode(node) ?
                    this._factory.create('mml', node) : node;
                item.global = this.global;
                var _b = __read(this.stack.length ? this.Top().checkItem(item) : [null, true], 2), top_1 = _b[0], success = _b[1];
                if (!success) {
                    continue;
                }
                if (top_1) {
                    this.Pop();
                    this.Push.apply(this, __spreadArray([], __read(top_1), false));
                    continue;
                }
                this.stack.push(item);
                if (item.env) {
                    if (item.copyEnv) {
                        Object.assign(item.env, this.env);
                    }
                    this.env = item.env;
                }
                else {
                    item.env = this.env;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    Stack.prototype.Pop = function () {
        var item = this.stack.pop();
        if (!item.isOpen) {
            delete item.env;
        }
        this.env = (this.stack.length ? this.Top().env : {});
        return item;
    };
    Stack.prototype.Top = function (n) {
        if (n === void 0) { n = 1; }
        return this.stack.length < n ? null : this.stack[this.stack.length - n];
    };
    Stack.prototype.Prev = function (noPop) {
        var top = this.Top();
        return noPop ? top.First : top.Pop();
    };
    Stack.prototype.toString = function () {
        return 'stack[\n  ' + this.stack.join('\n  ') + '\n]';
    };
    return Stack;
}());
exports["default"] = Stack;
//# sourceMappingURL=Stack.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/Symbol.js":
/*!**********************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/Symbol.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Macro = exports.Symbol = void 0;
var Symbol = (function () {
    function Symbol(_symbol, _char, _attributes) {
        this._symbol = _symbol;
        this._char = _char;
        this._attributes = _attributes;
    }
    Object.defineProperty(Symbol.prototype, "symbol", {
        get: function () {
            return this._symbol;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "char", {
        get: function () {
            return this._char;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Symbol.prototype, "attributes", {
        get: function () {
            return this._attributes;
        },
        enumerable: false,
        configurable: true
    });
    return Symbol;
}());
exports.Symbol = Symbol;
var Macro = (function () {
    function Macro(_symbol, _func, _args) {
        if (_args === void 0) { _args = []; }
        this._symbol = _symbol;
        this._func = _func;
        this._args = _args;
    }
    Object.defineProperty(Macro.prototype, "symbol", {
        get: function () {
            return this._symbol;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Macro.prototype, "func", {
        get: function () {
            return this._func;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(Macro.prototype, "args", {
        get: function () {
            return this._args;
        },
        enumerable: false,
        configurable: true
    });
    return Macro;
}());
exports.Macro = Macro;
//# sourceMappingURL=Symbol.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/SymbolMap.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/SymbolMap.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnvironmentMap = exports.CommandMap = exports.MacroMap = exports.DelimiterMap = exports.CharacterMap = exports.AbstractParseMap = exports.RegExpMap = exports.AbstractSymbolMap = exports.parseResult = void 0;
var Symbol_js_1 = __webpack_require__(/*! ./Symbol.js */ "./node_modules/mathjax-full/js/input/tex/Symbol.js");
var MapHandler_js_1 = __webpack_require__(/*! ./MapHandler.js */ "./node_modules/mathjax-full/js/input/tex/MapHandler.js");
function parseResult(result) {
    return result === void 0 ? true : result;
}
exports.parseResult = parseResult;
var AbstractSymbolMap = (function () {
    function AbstractSymbolMap(_name, _parser) {
        this._name = _name;
        this._parser = _parser;
        MapHandler_js_1.MapHandler.register(this);
    }
    Object.defineProperty(AbstractSymbolMap.prototype, "name", {
        get: function () {
            return this._name;
        },
        enumerable: false,
        configurable: true
    });
    AbstractSymbolMap.prototype.parserFor = function (symbol) {
        return this.contains(symbol) ? this.parser : null;
    };
    AbstractSymbolMap.prototype.parse = function (_a) {
        var _b = __read(_a, 2), env = _b[0], symbol = _b[1];
        var parser = this.parserFor(symbol);
        var mapped = this.lookup(symbol);
        return (parser && mapped) ? parseResult(parser(env, mapped)) : null;
    };
    Object.defineProperty(AbstractSymbolMap.prototype, "parser", {
        get: function () {
            return this._parser;
        },
        set: function (parser) {
            this._parser = parser;
        },
        enumerable: false,
        configurable: true
    });
    return AbstractSymbolMap;
}());
exports.AbstractSymbolMap = AbstractSymbolMap;
var RegExpMap = (function (_super) {
    __extends(RegExpMap, _super);
    function RegExpMap(name, parser, _regExp) {
        var _this = _super.call(this, name, parser) || this;
        _this._regExp = _regExp;
        return _this;
    }
    RegExpMap.prototype.contains = function (symbol) {
        return this._regExp.test(symbol);
    };
    RegExpMap.prototype.lookup = function (symbol) {
        return this.contains(symbol) ? symbol : null;
    };
    return RegExpMap;
}(AbstractSymbolMap));
exports.RegExpMap = RegExpMap;
var AbstractParseMap = (function (_super) {
    __extends(AbstractParseMap, _super);
    function AbstractParseMap() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.map = new Map();
        return _this;
    }
    AbstractParseMap.prototype.lookup = function (symbol) {
        return this.map.get(symbol);
    };
    AbstractParseMap.prototype.contains = function (symbol) {
        return this.map.has(symbol);
    };
    AbstractParseMap.prototype.add = function (symbol, object) {
        this.map.set(symbol, object);
    };
    AbstractParseMap.prototype.remove = function (symbol) {
        this.map.delete(symbol);
    };
    return AbstractParseMap;
}(AbstractSymbolMap));
exports.AbstractParseMap = AbstractParseMap;
var CharacterMap = (function (_super) {
    __extends(CharacterMap, _super);
    function CharacterMap(name, parser, json) {
        var e_1, _a;
        var _this = _super.call(this, name, parser) || this;
        try {
            for (var _b = __values(Object.keys(json)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                var value = json[key];
                var _d = __read((typeof (value) === 'string') ? [value, null] : value, 2), char = _d[0], attrs = _d[1];
                var character = new Symbol_js_1.Symbol(key, char, attrs);
                _this.add(key, character);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return _this;
    }
    return CharacterMap;
}(AbstractParseMap));
exports.CharacterMap = CharacterMap;
var DelimiterMap = (function (_super) {
    __extends(DelimiterMap, _super);
    function DelimiterMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    DelimiterMap.prototype.parse = function (_a) {
        var _b = __read(_a, 2), env = _b[0], symbol = _b[1];
        return _super.prototype.parse.call(this, [env, '\\' + symbol]);
    };
    return DelimiterMap;
}(CharacterMap));
exports.DelimiterMap = DelimiterMap;
var MacroMap = (function (_super) {
    __extends(MacroMap, _super);
    function MacroMap(name, json, functionMap) {
        var e_2, _a;
        var _this = _super.call(this, name, null) || this;
        try {
            for (var _b = __values(Object.keys(json)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                var value = json[key];
                var _d = __read((typeof (value) === 'string') ? [value] : value), func = _d[0], attrs = _d.slice(1);
                var character = new Symbol_js_1.Macro(key, functionMap[func], attrs);
                _this.add(key, character);
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return _this;
    }
    MacroMap.prototype.parserFor = function (symbol) {
        var macro = this.lookup(symbol);
        return macro ? macro.func : null;
    };
    MacroMap.prototype.parse = function (_a) {
        var _b = __read(_a, 2), env = _b[0], symbol = _b[1];
        var macro = this.lookup(symbol);
        var parser = this.parserFor(symbol);
        if (!macro || !parser) {
            return null;
        }
        return parseResult(parser.apply(void 0, __spreadArray([env, macro.symbol], __read(macro.args), false)));
    };
    return MacroMap;
}(AbstractParseMap));
exports.MacroMap = MacroMap;
var CommandMap = (function (_super) {
    __extends(CommandMap, _super);
    function CommandMap() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    CommandMap.prototype.parse = function (_a) {
        var _b = __read(_a, 2), env = _b[0], symbol = _b[1];
        var macro = this.lookup(symbol);
        var parser = this.parserFor(symbol);
        if (!macro || !parser) {
            return null;
        }
        var saveCommand = env.currentCS;
        env.currentCS = '\\' + symbol;
        var result = parser.apply(void 0, __spreadArray([env, '\\' + macro.symbol], __read(macro.args), false));
        env.currentCS = saveCommand;
        return parseResult(result);
    };
    return CommandMap;
}(MacroMap));
exports.CommandMap = CommandMap;
var EnvironmentMap = (function (_super) {
    __extends(EnvironmentMap, _super);
    function EnvironmentMap(name, parser, json, functionMap) {
        var _this = _super.call(this, name, json, functionMap) || this;
        _this.parser = parser;
        return _this;
    }
    EnvironmentMap.prototype.parse = function (_a) {
        var _b = __read(_a, 2), env = _b[0], symbol = _b[1];
        var macro = this.lookup(symbol);
        var envParser = this.parserFor(symbol);
        if (!macro || !envParser) {
            return null;
        }
        return parseResult(this.parser(env, macro.symbol, envParser, macro.args));
    };
    return EnvironmentMap;
}(MacroMap));
exports.EnvironmentMap = EnvironmentMap;
//# sourceMappingURL=SymbolMap.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/Tags.js":
/*!********************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/Tags.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TagsFactory = exports.AllTags = exports.NoTags = exports.AbstractTags = exports.TagInfo = exports.Label = void 0;
var TexParser_js_1 = __importDefault(__webpack_require__(/*! ./TexParser.js */ "./node_modules/mathjax-full/js/input/tex/TexParser.js"));
var Label = (function () {
    function Label(tag, id) {
        if (tag === void 0) { tag = '???'; }
        if (id === void 0) { id = ''; }
        this.tag = tag;
        this.id = id;
    }
    return Label;
}());
exports.Label = Label;
var TagInfo = (function () {
    function TagInfo(env, taggable, defaultTags, tag, tagId, tagFormat, noTag, labelId) {
        if (env === void 0) { env = ''; }
        if (taggable === void 0) { taggable = false; }
        if (defaultTags === void 0) { defaultTags = false; }
        if (tag === void 0) { tag = null; }
        if (tagId === void 0) { tagId = ''; }
        if (tagFormat === void 0) { tagFormat = ''; }
        if (noTag === void 0) { noTag = false; }
        if (labelId === void 0) { labelId = ''; }
        this.env = env;
        this.taggable = taggable;
        this.defaultTags = defaultTags;
        this.tag = tag;
        this.tagId = tagId;
        this.tagFormat = tagFormat;
        this.noTag = noTag;
        this.labelId = labelId;
    }
    return TagInfo;
}());
exports.TagInfo = TagInfo;
var AbstractTags = (function () {
    function AbstractTags() {
        this.counter = 0;
        this.allCounter = 0;
        this.configuration = null;
        this.ids = {};
        this.allIds = {};
        this.labels = {};
        this.allLabels = {};
        this.redo = false;
        this.refUpdate = false;
        this.currentTag = new TagInfo();
        this.history = [];
        this.stack = [];
        this.enTag = function (node, tag) {
            var nf = this.configuration.nodeFactory;
            var cell = nf.create('node', 'mtd', [node]);
            var row = nf.create('node', 'mlabeledtr', [tag, cell]);
            var table = nf.create('node', 'mtable', [row], {
                side: this.configuration.options['tagSide'],
                minlabelspacing: this.configuration.options['tagIndent'],
                displaystyle: true
            });
            return table;
        };
    }
    AbstractTags.prototype.start = function (env, taggable, defaultTags) {
        if (this.currentTag) {
            this.stack.push(this.currentTag);
        }
        this.currentTag = new TagInfo(env, taggable, defaultTags);
    };
    Object.defineProperty(AbstractTags.prototype, "env", {
        get: function () {
            return this.currentTag.env;
        },
        enumerable: false,
        configurable: true
    });
    AbstractTags.prototype.end = function () {
        this.history.push(this.currentTag);
        this.currentTag = this.stack.pop();
    };
    AbstractTags.prototype.tag = function (tag, noFormat) {
        this.currentTag.tag = tag;
        this.currentTag.tagFormat = noFormat ? tag : this.formatTag(tag);
        this.currentTag.noTag = false;
    };
    AbstractTags.prototype.notag = function () {
        this.tag('', true);
        this.currentTag.noTag = true;
    };
    Object.defineProperty(AbstractTags.prototype, "noTag", {
        get: function () {
            return this.currentTag.noTag;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(AbstractTags.prototype, "label", {
        get: function () {
            return this.currentTag.labelId;
        },
        set: function (label) {
            this.currentTag.labelId = label;
        },
        enumerable: false,
        configurable: true
    });
    AbstractTags.prototype.formatUrl = function (id, base) {
        return base + '#' + encodeURIComponent(id);
    };
    AbstractTags.prototype.formatTag = function (tag) {
        return '(' + tag + ')';
    };
    AbstractTags.prototype.formatId = function (id) {
        return 'mjx-eqn:' + id.replace(/\s/g, '_');
    };
    AbstractTags.prototype.formatNumber = function (n) {
        return n.toString();
    };
    AbstractTags.prototype.autoTag = function () {
        if (this.currentTag.tag == null) {
            this.counter++;
            this.tag(this.formatNumber(this.counter), false);
        }
    };
    AbstractTags.prototype.clearTag = function () {
        this.label = '';
        this.tag(null, true);
        this.currentTag.tagId = '';
    };
    AbstractTags.prototype.getTag = function (force) {
        if (force === void 0) { force = false; }
        if (force) {
            this.autoTag();
            return this.makeTag();
        }
        var ct = this.currentTag;
        if (ct.taggable && !ct.noTag) {
            if (ct.defaultTags) {
                this.autoTag();
            }
            if (ct.tag) {
                return this.makeTag();
            }
        }
        return null;
    };
    AbstractTags.prototype.resetTag = function () {
        this.history = [];
        this.redo = false;
        this.refUpdate = false;
        this.clearTag();
    };
    AbstractTags.prototype.reset = function (offset) {
        if (offset === void 0) { offset = 0; }
        this.resetTag();
        this.counter = this.allCounter = offset;
        this.allLabels = {};
        this.allIds = {};
    };
    AbstractTags.prototype.startEquation = function (math) {
        this.history = [];
        this.stack = [];
        this.clearTag();
        this.currentTag = new TagInfo('', undefined, undefined);
        this.labels = {};
        this.ids = {};
        this.counter = this.allCounter;
        this.redo = false;
        var recompile = math.inputData.recompile;
        if (recompile) {
            this.refUpdate = true;
            this.counter = recompile.counter;
        }
    };
    AbstractTags.prototype.finishEquation = function (math) {
        if (this.redo) {
            math.inputData.recompile = {
                state: math.state(),
                counter: this.allCounter
            };
        }
        if (!this.refUpdate) {
            this.allCounter = this.counter;
        }
        Object.assign(this.allIds, this.ids);
        Object.assign(this.allLabels, this.labels);
    };
    AbstractTags.prototype.finalize = function (node, env) {
        if (!env.display || this.currentTag.env ||
            this.currentTag.tag == null) {
            return node;
        }
        var tag = this.makeTag();
        var table = this.enTag(node, tag);
        return table;
    };
    AbstractTags.prototype.makeId = function () {
        this.currentTag.tagId = this.formatId(this.configuration.options['useLabelIds'] ?
            (this.label || this.currentTag.tag) : this.currentTag.tag);
    };
    AbstractTags.prototype.makeTag = function () {
        this.makeId();
        if (this.label) {
            this.labels[this.label] = new Label(this.currentTag.tag, this.currentTag.tagId);
        }
        var mml = new TexParser_js_1.default('\\text{' + this.currentTag.tagFormat + '}', {}, this.configuration).mml();
        return this.configuration.nodeFactory.create('node', 'mtd', [mml], { id: this.currentTag.tagId });
    };
    return AbstractTags;
}());
exports.AbstractTags = AbstractTags;
var NoTags = (function (_super) {
    __extends(NoTags, _super);
    function NoTags() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    NoTags.prototype.autoTag = function () { };
    NoTags.prototype.getTag = function () {
        return !this.currentTag.tag ? null : _super.prototype.getTag.call(this);
    };
    return NoTags;
}(AbstractTags));
exports.NoTags = NoTags;
var AllTags = (function (_super) {
    __extends(AllTags, _super);
    function AllTags() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AllTags.prototype.finalize = function (node, env) {
        if (!env.display || this.history.find(function (x) { return x.taggable; })) {
            return node;
        }
        var tag = this.getTag(true);
        return this.enTag(node, tag);
    };
    return AllTags;
}(AbstractTags));
exports.AllTags = AllTags;
var TagsFactory;
(function (TagsFactory) {
    var tagsMapping = new Map([
        ['none', NoTags],
        ['all', AllTags]
    ]);
    var defaultTags = 'none';
    TagsFactory.OPTIONS = {
        tags: defaultTags,
        tagSide: 'right',
        tagIndent: '0.8em',
        useLabelIds: true,
        ignoreDuplicateLabels: false
    };
    TagsFactory.add = function (name, constr) {
        tagsMapping.set(name, constr);
    };
    TagsFactory.addTags = function (tags) {
        var e_1, _a;
        try {
            for (var _b = __values(Object.keys(tags)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var key = _c.value;
                TagsFactory.add(key, tags[key]);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    TagsFactory.create = function (name) {
        var constr = tagsMapping.get(name) || tagsMapping.get(defaultTags);
        if (!constr) {
            throw Error('Unknown tags class');
        }
        return new constr();
    };
    TagsFactory.setDefault = function (name) {
        defaultTags = name;
    };
    TagsFactory.getDefault = function () {
        return TagsFactory.create(defaultTags);
    };
})(TagsFactory = exports.TagsFactory || (exports.TagsFactory = {}));
//# sourceMappingURL=Tags.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/TexError.js":
/*!************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/TexError.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
var TexError = (function () {
    function TexError(id, message) {
        var rest = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            rest[_i - 2] = arguments[_i];
        }
        this.id = id;
        this.message = TexError.processString(message, rest);
    }
    TexError.processString = function (str, args) {
        var parts = str.split(TexError.pattern);
        for (var i = 1, m = parts.length; i < m; i += 2) {
            var c = parts[i].charAt(0);
            if (c >= '0' && c <= '9') {
                parts[i] = args[parseInt(parts[i], 10) - 1];
                if (typeof parts[i] === 'number') {
                    parts[i] = parts[i].toString();
                }
            }
            else if (c === '{') {
                c = parts[i].substr(1);
                if (c >= '0' && c <= '9') {
                    parts[i] = args[parseInt(parts[i].substr(1, parts[i].length - 2), 10) - 1];
                    if (typeof parts[i] === 'number') {
                        parts[i] = parts[i].toString();
                    }
                }
                else {
                    var match = parts[i].match(/^\{([a-z]+):%(\d+)\|(.*)\}$/);
                    if (match) {
                        parts[i] = '%' + parts[i];
                    }
                }
            }
            if (parts[i] == null) {
                parts[i] = '???';
            }
        }
        return parts.join('');
    };
    TexError.pattern = /%(\d+|\{\d+\}|\{[a-z]+:\%\d+(?:\|(?:%\{\d+\}|%.|[^\}])*)+\}|.)/g;
    return TexError;
}());
exports["default"] = TexError;
//# sourceMappingURL=TexError.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/input/tex/TexParser.js":
/*!*************************************************************!*\
  !*** ./node_modules/mathjax-full/js/input/tex/TexParser.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
var ParseUtil_js_1 = __importDefault(__webpack_require__(/*! ./ParseUtil.js */ "./node_modules/mathjax-full/js/input/tex/ParseUtil.js"));
var Stack_js_1 = __importDefault(__webpack_require__(/*! ./Stack.js */ "./node_modules/mathjax-full/js/input/tex/Stack.js"));
var TexError_js_1 = __importDefault(__webpack_require__(/*! ./TexError.js */ "./node_modules/mathjax-full/js/input/tex/TexError.js"));
var MmlNode_js_1 = __webpack_require__(/*! ../../core/MmlTree/MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var TexParser = (function () {
    function TexParser(_string, env, configuration) {
        var e_1, _a;
        this._string = _string;
        this.configuration = configuration;
        this.macroCount = 0;
        this.i = 0;
        this.currentCS = '';
        var inner = env.hasOwnProperty('isInner');
        var isInner = env['isInner'];
        delete env['isInner'];
        var ENV;
        if (env) {
            ENV = {};
            try {
                for (var _b = __values(Object.keys(env)), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var id = _c.value;
                    ENV[id] = env[id];
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        this.configuration.pushParser(this);
        this.stack = new Stack_js_1.default(this.itemFactory, ENV, inner ? isInner : true);
        this.Parse();
        this.Push(this.itemFactory.create('stop'));
    }
    Object.defineProperty(TexParser.prototype, "options", {
        get: function () {
            return this.configuration.options;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TexParser.prototype, "itemFactory", {
        get: function () {
            return this.configuration.itemFactory;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TexParser.prototype, "tags", {
        get: function () {
            return this.configuration.tags;
        },
        enumerable: false,
        configurable: true
    });
    Object.defineProperty(TexParser.prototype, "string", {
        get: function () {
            return this._string;
        },
        set: function (str) {
            this._string = str;
        },
        enumerable: false,
        configurable: true
    });
    TexParser.prototype.parse = function (kind, input) {
        return this.configuration.handlers.get(kind).parse(input);
    };
    TexParser.prototype.lookup = function (kind, symbol) {
        return this.configuration.handlers.get(kind).lookup(symbol);
    };
    TexParser.prototype.contains = function (kind, symbol) {
        return this.configuration.handlers.get(kind).contains(symbol);
    };
    TexParser.prototype.toString = function () {
        var e_2, _a;
        var str = '';
        try {
            for (var _b = __values(Array.from(this.configuration.handlers.keys())), _c = _b.next(); !_c.done; _c = _b.next()) {
                var config = _c.value;
                str += config + ': ' +
                    this.configuration.handlers.get(config) + '\n';
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return str;
    };
    TexParser.prototype.Parse = function () {
        var c;
        while (this.i < this.string.length) {
            c = this.getCodePoint();
            this.i += c.length;
            this.parse('character', [this, c]);
        }
    };
    TexParser.prototype.Push = function (arg) {
        if (arg instanceof MmlNode_js_1.AbstractMmlNode && arg.isInferred) {
            this.PushAll(arg.childNodes);
        }
        else {
            this.stack.Push(arg);
        }
    };
    TexParser.prototype.PushAll = function (args) {
        var e_3, _a;
        try {
            for (var args_1 = __values(args), args_1_1 = args_1.next(); !args_1_1.done; args_1_1 = args_1.next()) {
                var arg = args_1_1.value;
                this.stack.Push(arg);
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (args_1_1 && !args_1_1.done && (_a = args_1.return)) _a.call(args_1);
            }
            finally { if (e_3) throw e_3.error; }
        }
    };
    TexParser.prototype.mml = function () {
        if (!this.stack.Top().isKind('mml')) {
            return null;
        }
        var node = this.stack.Top().First;
        this.configuration.popParser();
        return node;
    };
    TexParser.prototype.convertDelimiter = function (c) {
        var symbol = this.lookup('delimiter', c);
        return symbol ? symbol.char : null;
    };
    TexParser.prototype.getCodePoint = function () {
        var code = this.string.codePointAt(this.i);
        return code === undefined ? '' : String.fromCodePoint(code);
    };
    TexParser.prototype.nextIsSpace = function () {
        return !!this.string.charAt(this.i).match(/\s/);
    };
    TexParser.prototype.GetNext = function () {
        while (this.nextIsSpace()) {
            this.i++;
        }
        return this.getCodePoint();
    };
    TexParser.prototype.GetCS = function () {
        var CS = this.string.slice(this.i).match(/^(([a-z]+) ?|[\uD800-\uDBFF].|.)/i);
        if (CS) {
            this.i += CS[0].length;
            return CS[2] || CS[1];
        }
        else {
            this.i++;
            return ' ';
        }
    };
    TexParser.prototype.GetArgument = function (_name, noneOK) {
        switch (this.GetNext()) {
            case '':
                if (!noneOK) {
                    throw new TexError_js_1.default('MissingArgFor', 'Missing argument for %1', this.currentCS);
                }
                return null;
            case '}':
                if (!noneOK) {
                    throw new TexError_js_1.default('ExtraCloseMissingOpen', 'Extra close brace or missing open brace');
                }
                return null;
            case '\\':
                this.i++;
                return '\\' + this.GetCS();
            case '{':
                var j = ++this.i, parens = 1;
                while (this.i < this.string.length) {
                    switch (this.string.charAt(this.i++)) {
                        case '\\':
                            this.i++;
                            break;
                        case '{':
                            parens++;
                            break;
                        case '}':
                            if (--parens === 0) {
                                return this.string.slice(j, this.i - 1);
                            }
                            break;
                    }
                }
                throw new TexError_js_1.default('MissingCloseBrace', 'Missing close brace');
        }
        var c = this.getCodePoint();
        this.i += c.length;
        return c;
    };
    TexParser.prototype.GetBrackets = function (_name, def) {
        if (this.GetNext() !== '[') {
            return def;
        }
        var j = ++this.i, parens = 0;
        while (this.i < this.string.length) {
            switch (this.string.charAt(this.i++)) {
                case '{':
                    parens++;
                    break;
                case '\\':
                    this.i++;
                    break;
                case '}':
                    if (parens-- <= 0) {
                        throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', '\']\'');
                    }
                    break;
                case ']':
                    if (parens === 0) {
                        return this.string.slice(j, this.i - 1);
                    }
                    break;
            }
        }
        throw new TexError_js_1.default('MissingCloseBracket', 'Could not find closing \']\' for argument to %1', this.currentCS);
    };
    TexParser.prototype.GetDelimiter = function (name, braceOK) {
        var c = this.GetNext();
        this.i += c.length;
        if (this.i <= this.string.length) {
            if (c === '\\') {
                c += this.GetCS();
            }
            else if (c === '{' && braceOK) {
                this.i--;
                c = this.GetArgument(name).trim();
            }
            if (this.contains('delimiter', c)) {
                return this.convertDelimiter(c);
            }
        }
        throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);
    };
    TexParser.prototype.GetDimen = function (name) {
        if (this.GetNext() === '{') {
            var dimen = this.GetArgument(name);
            var _a = __read(ParseUtil_js_1.default.matchDimen(dimen), 2), value = _a[0], unit = _a[1];
            if (value) {
                return value + unit;
            }
        }
        else {
            var dimen = this.string.slice(this.i);
            var _b = __read(ParseUtil_js_1.default.matchDimen(dimen, true), 3), value = _b[0], unit = _b[1], length_1 = _b[2];
            if (value) {
                this.i += length_1;
                return value + unit;
            }
        }
        throw new TexError_js_1.default('MissingDimOrUnits', 'Missing dimension or its units for %1', this.currentCS);
    };
    TexParser.prototype.GetUpTo = function (_name, token) {
        while (this.nextIsSpace()) {
            this.i++;
        }
        var j = this.i;
        var parens = 0;
        while (this.i < this.string.length) {
            var k = this.i;
            var c = this.GetNext();
            this.i += c.length;
            switch (c) {
                case '\\':
                    c += this.GetCS();
                    break;
                case '{':
                    parens++;
                    break;
                case '}':
                    if (parens === 0) {
                        throw new TexError_js_1.default('ExtraCloseLooking', 'Extra close brace while looking for %1', token);
                    }
                    parens--;
                    break;
            }
            if (parens === 0 && c === token) {
                return this.string.slice(j, k);
            }
        }
        throw new TexError_js_1.default('TokenNotFoundForCommand', 'Could not find %1 for %2', token, this.currentCS);
    };
    TexParser.prototype.ParseArg = function (name) {
        return new TexParser(this.GetArgument(name), this.stack.env, this.configuration).mml();
    };
    TexParser.prototype.ParseUpTo = function (name, token) {
        return new TexParser(this.GetUpTo(name, token), this.stack.env, this.configuration).mml();
    };
    TexParser.prototype.GetDelimiterArg = function (name) {
        var c = ParseUtil_js_1.default.trimSpaces(this.GetArgument(name));
        if (c === '') {
            return null;
        }
        if (this.contains('delimiter', c)) {
            return c;
        }
        throw new TexError_js_1.default('MissingOrUnrecognizedDelim', 'Missing or unrecognized delimiter for %1', this.currentCS);
    };
    TexParser.prototype.GetStar = function () {
        var star = (this.GetNext() === '*');
        if (star) {
            this.i++;
        }
        return star;
    };
    TexParser.prototype.create = function (kind) {
        var _a;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        return (_a = this.configuration.nodeFactory).create.apply(_a, __spreadArray([kind], __read(rest), false));
    };
    return TexParser;
}());
exports["default"] = TexParser;
//# sourceMappingURL=TexParser.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/mathjax.js":
/*!*************************************************!*\
  !*** ./node_modules/mathjax-full/js/mathjax.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.mathjax = void 0;
var version_js_1 = __webpack_require__(/*! ./components/version.js */ "./node_modules/mathjax-full/js/components/version.js");
var HandlerList_js_1 = __webpack_require__(/*! ./core/HandlerList.js */ "./node_modules/mathjax-full/js/core/HandlerList.js");
var Retries_js_1 = __webpack_require__(/*! ./util/Retries.js */ "./node_modules/mathjax-full/js/util/Retries.js");
exports.mathjax = {
    version: version_js_1.VERSION,
    handlers: new HandlerList_js_1.HandlerList(),
    document: function (document, options) {
        return exports.mathjax.handlers.document(document, options);
    },
    handleRetriesFor: Retries_js_1.handleRetriesFor,
    retryAfter: Retries_js_1.retryAfter,
    asyncLoad: null,
};
//# sourceMappingURL=mathjax.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/AsyncLoad.js":
/*!********************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/AsyncLoad.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.asyncLoad = void 0;
var mathjax_js_1 = __webpack_require__(/*! ../mathjax.js */ "./node_modules/mathjax-full/js/mathjax.js");
function asyncLoad(name) {
    if (!mathjax_js_1.mathjax.asyncLoad) {
        return Promise.reject("Can't load '".concat(name, "': No asyncLoad method specified"));
    }
    return new Promise(function (ok, fail) {
        var result = mathjax_js_1.mathjax.asyncLoad(name);
        if (result instanceof Promise) {
            result.then(function (value) { return ok(value); }).catch(function (err) { return fail(err); });
        }
        else {
            ok(result);
        }
    });
}
exports.asyncLoad = asyncLoad;
//# sourceMappingURL=AsyncLoad.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/Entities.js":
/*!*******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/Entities.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.numeric = exports.translate = exports.remove = exports.add = exports.entities = exports.options = void 0;
var Retries_js_1 = __webpack_require__(/*! ./Retries.js */ "./node_modules/mathjax-full/js/util/Retries.js");
var AsyncLoad_js_1 = __webpack_require__(/*! ./AsyncLoad.js */ "./node_modules/mathjax-full/js/util/AsyncLoad.js");
exports.options = {
    loadMissingEntities: true
};
exports.entities = {
    ApplyFunction: '\u2061',
    Backslash: '\u2216',
    Because: '\u2235',
    Breve: '\u02D8',
    Cap: '\u22D2',
    CenterDot: '\u00B7',
    CircleDot: '\u2299',
    CircleMinus: '\u2296',
    CirclePlus: '\u2295',
    CircleTimes: '\u2297',
    Congruent: '\u2261',
    ContourIntegral: '\u222E',
    Coproduct: '\u2210',
    Cross: '\u2A2F',
    Cup: '\u22D3',
    CupCap: '\u224D',
    Dagger: '\u2021',
    Del: '\u2207',
    Delta: '\u0394',
    Diamond: '\u22C4',
    DifferentialD: '\u2146',
    DotEqual: '\u2250',
    DoubleDot: '\u00A8',
    DoubleRightTee: '\u22A8',
    DoubleVerticalBar: '\u2225',
    DownArrow: '\u2193',
    DownLeftVector: '\u21BD',
    DownRightVector: '\u21C1',
    DownTee: '\u22A4',
    Downarrow: '\u21D3',
    Element: '\u2208',
    EqualTilde: '\u2242',
    Equilibrium: '\u21CC',
    Exists: '\u2203',
    ExponentialE: '\u2147',
    FilledVerySmallSquare: '\u25AA',
    ForAll: '\u2200',
    Gamma: '\u0393',
    Gg: '\u22D9',
    GreaterEqual: '\u2265',
    GreaterEqualLess: '\u22DB',
    GreaterFullEqual: '\u2267',
    GreaterLess: '\u2277',
    GreaterSlantEqual: '\u2A7E',
    GreaterTilde: '\u2273',
    Hacek: '\u02C7',
    Hat: '\u005E',
    HumpDownHump: '\u224E',
    HumpEqual: '\u224F',
    Im: '\u2111',
    ImaginaryI: '\u2148',
    Integral: '\u222B',
    Intersection: '\u22C2',
    InvisibleComma: '\u2063',
    InvisibleTimes: '\u2062',
    Lambda: '\u039B',
    Larr: '\u219E',
    LeftAngleBracket: '\u27E8',
    LeftArrow: '\u2190',
    LeftArrowRightArrow: '\u21C6',
    LeftCeiling: '\u2308',
    LeftDownVector: '\u21C3',
    LeftFloor: '\u230A',
    LeftRightArrow: '\u2194',
    LeftTee: '\u22A3',
    LeftTriangle: '\u22B2',
    LeftTriangleEqual: '\u22B4',
    LeftUpVector: '\u21BF',
    LeftVector: '\u21BC',
    Leftarrow: '\u21D0',
    Leftrightarrow: '\u21D4',
    LessEqualGreater: '\u22DA',
    LessFullEqual: '\u2266',
    LessGreater: '\u2276',
    LessSlantEqual: '\u2A7D',
    LessTilde: '\u2272',
    Ll: '\u22D8',
    Lleftarrow: '\u21DA',
    LongLeftArrow: '\u27F5',
    LongLeftRightArrow: '\u27F7',
    LongRightArrow: '\u27F6',
    Longleftarrow: '\u27F8',
    Longleftrightarrow: '\u27FA',
    Longrightarrow: '\u27F9',
    Lsh: '\u21B0',
    MinusPlus: '\u2213',
    NestedGreaterGreater: '\u226B',
    NestedLessLess: '\u226A',
    NotDoubleVerticalBar: '\u2226',
    NotElement: '\u2209',
    NotEqual: '\u2260',
    NotExists: '\u2204',
    NotGreater: '\u226F',
    NotGreaterEqual: '\u2271',
    NotLeftTriangle: '\u22EA',
    NotLeftTriangleEqual: '\u22EC',
    NotLess: '\u226E',
    NotLessEqual: '\u2270',
    NotPrecedes: '\u2280',
    NotPrecedesSlantEqual: '\u22E0',
    NotRightTriangle: '\u22EB',
    NotRightTriangleEqual: '\u22ED',
    NotSubsetEqual: '\u2288',
    NotSucceeds: '\u2281',
    NotSucceedsSlantEqual: '\u22E1',
    NotSupersetEqual: '\u2289',
    NotTilde: '\u2241',
    NotVerticalBar: '\u2224',
    Omega: '\u03A9',
    OverBar: '\u203E',
    OverBrace: '\u23DE',
    PartialD: '\u2202',
    Phi: '\u03A6',
    Pi: '\u03A0',
    PlusMinus: '\u00B1',
    Precedes: '\u227A',
    PrecedesEqual: '\u2AAF',
    PrecedesSlantEqual: '\u227C',
    PrecedesTilde: '\u227E',
    Product: '\u220F',
    Proportional: '\u221D',
    Psi: '\u03A8',
    Rarr: '\u21A0',
    Re: '\u211C',
    ReverseEquilibrium: '\u21CB',
    RightAngleBracket: '\u27E9',
    RightArrow: '\u2192',
    RightArrowLeftArrow: '\u21C4',
    RightCeiling: '\u2309',
    RightDownVector: '\u21C2',
    RightFloor: '\u230B',
    RightTee: '\u22A2',
    RightTeeArrow: '\u21A6',
    RightTriangle: '\u22B3',
    RightTriangleEqual: '\u22B5',
    RightUpVector: '\u21BE',
    RightVector: '\u21C0',
    Rightarrow: '\u21D2',
    Rrightarrow: '\u21DB',
    Rsh: '\u21B1',
    Sigma: '\u03A3',
    SmallCircle: '\u2218',
    Sqrt: '\u221A',
    Square: '\u25A1',
    SquareIntersection: '\u2293',
    SquareSubset: '\u228F',
    SquareSubsetEqual: '\u2291',
    SquareSuperset: '\u2290',
    SquareSupersetEqual: '\u2292',
    SquareUnion: '\u2294',
    Star: '\u22C6',
    Subset: '\u22D0',
    SubsetEqual: '\u2286',
    Succeeds: '\u227B',
    SucceedsEqual: '\u2AB0',
    SucceedsSlantEqual: '\u227D',
    SucceedsTilde: '\u227F',
    SuchThat: '\u220B',
    Sum: '\u2211',
    Superset: '\u2283',
    SupersetEqual: '\u2287',
    Supset: '\u22D1',
    Therefore: '\u2234',
    Theta: '\u0398',
    Tilde: '\u223C',
    TildeEqual: '\u2243',
    TildeFullEqual: '\u2245',
    TildeTilde: '\u2248',
    UnderBar: '\u005F',
    UnderBrace: '\u23DF',
    Union: '\u22C3',
    UnionPlus: '\u228E',
    UpArrow: '\u2191',
    UpDownArrow: '\u2195',
    UpTee: '\u22A5',
    Uparrow: '\u21D1',
    Updownarrow: '\u21D5',
    Upsilon: '\u03A5',
    Vdash: '\u22A9',
    Vee: '\u22C1',
    VerticalBar: '\u2223',
    VerticalTilde: '\u2240',
    Vvdash: '\u22AA',
    Wedge: '\u22C0',
    Xi: '\u039E',
    amp: '\u0026',
    acute: '\u00B4',
    aleph: '\u2135',
    alpha: '\u03B1',
    amalg: '\u2A3F',
    and: '\u2227',
    ang: '\u2220',
    angmsd: '\u2221',
    angsph: '\u2222',
    ape: '\u224A',
    backprime: '\u2035',
    backsim: '\u223D',
    backsimeq: '\u22CD',
    beta: '\u03B2',
    beth: '\u2136',
    between: '\u226C',
    bigcirc: '\u25EF',
    bigodot: '\u2A00',
    bigoplus: '\u2A01',
    bigotimes: '\u2A02',
    bigsqcup: '\u2A06',
    bigstar: '\u2605',
    bigtriangledown: '\u25BD',
    bigtriangleup: '\u25B3',
    biguplus: '\u2A04',
    blacklozenge: '\u29EB',
    blacktriangle: '\u25B4',
    blacktriangledown: '\u25BE',
    blacktriangleleft: '\u25C2',
    bowtie: '\u22C8',
    boxdl: '\u2510',
    boxdr: '\u250C',
    boxminus: '\u229F',
    boxplus: '\u229E',
    boxtimes: '\u22A0',
    boxul: '\u2518',
    boxur: '\u2514',
    bsol: '\u005C',
    bull: '\u2022',
    cap: '\u2229',
    check: '\u2713',
    chi: '\u03C7',
    circ: '\u02C6',
    circeq: '\u2257',
    circlearrowleft: '\u21BA',
    circlearrowright: '\u21BB',
    circledR: '\u00AE',
    circledS: '\u24C8',
    circledast: '\u229B',
    circledcirc: '\u229A',
    circleddash: '\u229D',
    clubs: '\u2663',
    colon: '\u003A',
    comp: '\u2201',
    ctdot: '\u22EF',
    cuepr: '\u22DE',
    cuesc: '\u22DF',
    cularr: '\u21B6',
    cup: '\u222A',
    curarr: '\u21B7',
    curlyvee: '\u22CE',
    curlywedge: '\u22CF',
    dagger: '\u2020',
    daleth: '\u2138',
    ddarr: '\u21CA',
    deg: '\u00B0',
    delta: '\u03B4',
    digamma: '\u03DD',
    div: '\u00F7',
    divideontimes: '\u22C7',
    dot: '\u02D9',
    doteqdot: '\u2251',
    dotplus: '\u2214',
    dotsquare: '\u22A1',
    dtdot: '\u22F1',
    ecir: '\u2256',
    efDot: '\u2252',
    egs: '\u2A96',
    ell: '\u2113',
    els: '\u2A95',
    empty: '\u2205',
    epsi: '\u03B5',
    epsiv: '\u03F5',
    erDot: '\u2253',
    eta: '\u03B7',
    eth: '\u00F0',
    flat: '\u266D',
    fork: '\u22D4',
    frown: '\u2322',
    gEl: '\u2A8C',
    gamma: '\u03B3',
    gap: '\u2A86',
    gimel: '\u2137',
    gnE: '\u2269',
    gnap: '\u2A8A',
    gne: '\u2A88',
    gnsim: '\u22E7',
    gt: '\u003E',
    gtdot: '\u22D7',
    harrw: '\u21AD',
    hbar: '\u210F',
    hellip: '\u2026',
    hookleftarrow: '\u21A9',
    hookrightarrow: '\u21AA',
    imath: '\u0131',
    infin: '\u221E',
    intcal: '\u22BA',
    iota: '\u03B9',
    jmath: '\u0237',
    kappa: '\u03BA',
    kappav: '\u03F0',
    lEg: '\u2A8B',
    lambda: '\u03BB',
    lap: '\u2A85',
    larrlp: '\u21AB',
    larrtl: '\u21A2',
    lbrace: '\u007B',
    lbrack: '\u005B',
    le: '\u2264',
    leftleftarrows: '\u21C7',
    leftthreetimes: '\u22CB',
    lessdot: '\u22D6',
    lmoust: '\u23B0',
    lnE: '\u2268',
    lnap: '\u2A89',
    lne: '\u2A87',
    lnsim: '\u22E6',
    longmapsto: '\u27FC',
    looparrowright: '\u21AC',
    lowast: '\u2217',
    loz: '\u25CA',
    lt: '\u003C',
    ltimes: '\u22C9',
    ltri: '\u25C3',
    macr: '\u00AF',
    malt: '\u2720',
    mho: '\u2127',
    mu: '\u03BC',
    multimap: '\u22B8',
    nLeftarrow: '\u21CD',
    nLeftrightarrow: '\u21CE',
    nRightarrow: '\u21CF',
    nVDash: '\u22AF',
    nVdash: '\u22AE',
    natur: '\u266E',
    nearr: '\u2197',
    nharr: '\u21AE',
    nlarr: '\u219A',
    not: '\u00AC',
    nrarr: '\u219B',
    nu: '\u03BD',
    nvDash: '\u22AD',
    nvdash: '\u22AC',
    nwarr: '\u2196',
    omega: '\u03C9',
    omicron: '\u03BF',
    or: '\u2228',
    osol: '\u2298',
    period: '\u002E',
    phi: '\u03C6',
    phiv: '\u03D5',
    pi: '\u03C0',
    piv: '\u03D6',
    prap: '\u2AB7',
    precnapprox: '\u2AB9',
    precneqq: '\u2AB5',
    precnsim: '\u22E8',
    prime: '\u2032',
    psi: '\u03C8',
    quot: '\u0022',
    rarrtl: '\u21A3',
    rbrace: '\u007D',
    rbrack: '\u005D',
    rho: '\u03C1',
    rhov: '\u03F1',
    rightrightarrows: '\u21C9',
    rightthreetimes: '\u22CC',
    ring: '\u02DA',
    rmoust: '\u23B1',
    rtimes: '\u22CA',
    rtri: '\u25B9',
    scap: '\u2AB8',
    scnE: '\u2AB6',
    scnap: '\u2ABA',
    scnsim: '\u22E9',
    sdot: '\u22C5',
    searr: '\u2198',
    sect: '\u00A7',
    sharp: '\u266F',
    sigma: '\u03C3',
    sigmav: '\u03C2',
    simne: '\u2246',
    smile: '\u2323',
    spades: '\u2660',
    sub: '\u2282',
    subE: '\u2AC5',
    subnE: '\u2ACB',
    subne: '\u228A',
    supE: '\u2AC6',
    supnE: '\u2ACC',
    supne: '\u228B',
    swarr: '\u2199',
    tau: '\u03C4',
    theta: '\u03B8',
    thetav: '\u03D1',
    tilde: '\u02DC',
    times: '\u00D7',
    triangle: '\u25B5',
    triangleq: '\u225C',
    upsi: '\u03C5',
    upuparrows: '\u21C8',
    veebar: '\u22BB',
    vellip: '\u22EE',
    weierp: '\u2118',
    xi: '\u03BE',
    yen: '\u00A5',
    zeta: '\u03B6',
    zigrarr: '\u21DD',
    nbsp: '\u00A0',
    rsquo: '\u2019',
    lsquo: '\u2018'
};
var loaded = {};
function add(additions, file) {
    Object.assign(exports.entities, additions);
    loaded[file] = true;
}
exports.add = add;
function remove(entity) {
    delete exports.entities[entity];
}
exports.remove = remove;
function translate(text) {
    return text.replace(/&([a-z][a-z0-9]*|#(?:[0-9]+|x[0-9a-f]+));/ig, replace);
}
exports.translate = translate;
function replace(match, entity) {
    if (entity.charAt(0) === '#') {
        return numeric(entity.slice(1));
    }
    if (exports.entities[entity]) {
        return exports.entities[entity];
    }
    if (exports.options['loadMissingEntities']) {
        var file = (entity.match(/^[a-zA-Z](fr|scr|opf)$/) ? RegExp.$1 : entity.charAt(0).toLowerCase());
        if (!loaded[file]) {
            loaded[file] = true;
            (0, Retries_js_1.retryAfter)((0, AsyncLoad_js_1.asyncLoad)('./util/entities/' + file + '.js'));
        }
    }
    return match;
}
function numeric(entity) {
    var n = (entity.charAt(0) === 'x' ?
        parseInt(entity.slice(1), 16) :
        parseInt(entity));
    return String.fromCodePoint(n);
}
exports.numeric = numeric;
//# sourceMappingURL=Entities.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/FunctionList.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/FunctionList.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionList = void 0;
var PrioritizedList_js_1 = __webpack_require__(/*! ./PrioritizedList.js */ "./node_modules/mathjax-full/js/util/PrioritizedList.js");
var FunctionList = (function (_super) {
    __extends(FunctionList, _super);
    function FunctionList() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    FunctionList.prototype.execute = function () {
        var e_1, _a;
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        try {
            for (var _b = __values(this), _c = _b.next(); !_c.done; _c = _b.next()) {
                var item = _c.value;
                var result = item.item.apply(item, __spreadArray([], __read(data), false));
                if (result === false) {
                    return false;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return true;
    };
    FunctionList.prototype.asyncExecute = function () {
        var data = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            data[_i] = arguments[_i];
        }
        var i = -1;
        var items = this.items;
        return new Promise(function (ok, fail) {
            (function execute() {
                var _a;
                while (++i < items.length) {
                    var result = (_a = items[i]).item.apply(_a, __spreadArray([], __read(data), false));
                    if (result instanceof Promise) {
                        result.then(execute).catch(function (err) { return fail(err); });
                        return;
                    }
                    if (result === false) {
                        ok(false);
                        return;
                    }
                }
                ok(true);
            })();
        });
    };
    return FunctionList;
}(PrioritizedList_js_1.PrioritizedList));
exports.FunctionList = FunctionList;
//# sourceMappingURL=FunctionList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/PrioritizedList.js":
/*!**************************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/PrioritizedList.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrioritizedList = void 0;
var PrioritizedList = (function () {
    function PrioritizedList() {
        this.items = [];
        this.items = [];
    }
    PrioritizedList.prototype[Symbol.iterator] = function () {
        var i = 0;
        var items = this.items;
        return {
            next: function () {
                return { value: items[i++], done: (i > items.length) };
            }
        };
    };
    PrioritizedList.prototype.add = function (item, priority) {
        if (priority === void 0) { priority = PrioritizedList.DEFAULTPRIORITY; }
        var i = this.items.length;
        do {
            i--;
        } while (i >= 0 && priority < this.items[i].priority);
        this.items.splice(i + 1, 0, { item: item, priority: priority });
        return item;
    };
    PrioritizedList.prototype.remove = function (item) {
        var i = this.items.length;
        do {
            i--;
        } while (i >= 0 && this.items[i].item !== item);
        if (i >= 0) {
            this.items.splice(i, 1);
        }
    };
    PrioritizedList.DEFAULTPRIORITY = 5;
    return PrioritizedList;
}());
exports.PrioritizedList = PrioritizedList;
//# sourceMappingURL=PrioritizedList.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/util/Retries.js":
/*!******************************************************!*\
  !*** ./node_modules/mathjax-full/js/util/Retries.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.retryAfter = exports.handleRetriesFor = void 0;
function handleRetriesFor(code) {
    return new Promise(function run(ok, fail) {
        try {
            ok(code());
        }
        catch (err) {
            if (err.retry && err.retry instanceof Promise) {
                err.retry.then(function () { return run(ok, fail); })
                    .catch(function (perr) { return fail(perr); });
            }
            else if (err.restart && err.restart.isCallback) {
                MathJax.Callback.After(function () { return run(ok, fail); }, err.restart);
            }
            else {
                fail(err);
            }
        }
    });
}
exports.handleRetriesFor = handleRetriesFor;
function retryAfter(promise) {
    var err = new Error('MathJax retry');
    err.retry = promise;
    throw err;
}
exports.retryAfter = retryAfter;
//# sourceMappingURL=Retries.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2lucHV0X3RleF9Db25maWd1cmF0aW9uX2pzLW5vZGVfbW9kdWxlc19tYXRoamF4LWZ1bGxfanNfLThjNGMyNi41NGQ4YWU2ZjNkODc2OGYyNjlkZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlO0FBQ2YsZUFBZTtBQUNmOzs7Ozs7Ozs7O0FDSmE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CO0FBQ25CLDJCQUEyQixtQkFBTyxDQUFDLDBGQUE0QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELFVBQVU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsbUJBQW1CO0FBQ25COzs7Ozs7Ozs7O0FDcEVhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7Ozs7Ozs7Ozs7QUNyY2E7QUFDYjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQixzQ0FBc0Msa0JBQWtCO0FBQ3ZGLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLE9BQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0JBQW9CO0FBQ3BCLDJCQUEyQixtQkFBTyxDQUFDLG9GQUFzQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQSwwREFBMEQsVUFBVTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsdUJBQXVCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLG1CQUFtQjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0EsQ0FBQztBQUNELG9CQUFvQjtBQUNwQjs7Ozs7Ozs7OztBQ2hIYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLHNDQUFzQyxnQ0FBZ0M7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCx1QkFBdUI7QUFDdkI7Ozs7Ozs7Ozs7QUN2Q2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsd0JBQXdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVCQUF1QjtBQUNwRSw2Q0FBNkMsb0JBQW9CO0FBQ2pFO0FBQ0E7QUFDQSxxREFBcUQsdUJBQXVCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29tcG9uZW50cy92ZXJzaW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvY29yZS9IYW5kbGVyTGlzdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9Db25maWd1cmF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L01hcEhhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvTm9kZVV0aWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvUGFyc2VVdGlsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L1N0YWNrLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvaW5wdXQvdGV4L1N5bWJvbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9TeW1ib2xNYXAuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9pbnB1dC90ZXgvVGFncy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9UZXhFcnJvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2lucHV0L3RleC9UZXhQYXJzZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9tYXRoamF4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9Bc3luY0xvYWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL0VudGl0aWVzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9tYXRoamF4LWZ1bGwvanMvdXRpbC9GdW5jdGlvbkxpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy91dGlsL1ByaW9yaXRpemVkTGlzdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL3V0aWwvUmV0cmllcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVkVSU0lPTiA9IHZvaWQgMDtcbmV4cG9ydHMuVkVSU0lPTiA9ICczLjIuMic7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSGFuZGxlckxpc3QgPSB2b2lkIDA7XG52YXIgUHJpb3JpdGl6ZWRMaXN0X2pzXzEgPSByZXF1aXJlKFwiLi4vdXRpbC9Qcmlvcml0aXplZExpc3QuanNcIik7XG52YXIgSGFuZGxlckxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhIYW5kbGVyTGlzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBIYW5kbGVyTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xuICAgIH1cbiAgICBIYW5kbGVyTGlzdC5wcm90b3R5cGUucmVnaXN0ZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5hZGQoaGFuZGxlciwgaGFuZGxlci5wcmlvcml0eSk7XG4gICAgfTtcbiAgICBIYW5kbGVyTGlzdC5wcm90b3R5cGUudW5yZWdpc3RlciA9IGZ1bmN0aW9uIChoYW5kbGVyKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKGhhbmRsZXIpO1xuICAgIH07XG4gICAgSGFuZGxlckxpc3QucHJvdG90eXBlLmhhbmRsZXNEb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBoYW5kbGVyID0gaXRlbS5pdGVtO1xuICAgICAgICAgICAgICAgIGlmIChoYW5kbGVyLmhhbmRsZXNEb2N1bWVudChkb2N1bWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgZmluZCBoYW5kbGVyIGZvciBkb2N1bWVudFwiKTtcbiAgICB9O1xuICAgIEhhbmRsZXJMaXN0LnByb3RvdHlwZS5kb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSBudWxsOyB9XG4gICAgICAgIHJldHVybiB0aGlzLmhhbmRsZXNEb2N1bWVudChkb2N1bWVudCkuY3JlYXRlKGRvY3VtZW50LCBvcHRpb25zKTtcbiAgICB9O1xuICAgIHJldHVybiBIYW5kbGVyTGlzdDtcbn0oUHJpb3JpdGl6ZWRMaXN0X2pzXzEuUHJpb3JpdGl6ZWRMaXN0KSk7XG5leHBvcnRzLkhhbmRsZXJMaXN0ID0gSGFuZGxlckxpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1IYW5kbGVyTGlzdC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyc2VyQ29uZmlndXJhdGlvbiA9IGV4cG9ydHMuQ29uZmlndXJhdGlvbkhhbmRsZXIgPSBleHBvcnRzLkNvbmZpZ3VyYXRpb24gPSB2b2lkIDA7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBNYXBIYW5kbGVyX2pzXzEgPSByZXF1aXJlKFwiLi9NYXBIYW5kbGVyLmpzXCIpO1xudmFyIEZ1bmN0aW9uTGlzdF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvRnVuY3Rpb25MaXN0LmpzXCIpO1xudmFyIFByaW9yaXRpemVkTGlzdF9qc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWwvUHJpb3JpdGl6ZWRMaXN0LmpzXCIpO1xudmFyIFRhZ3NfanNfMSA9IHJlcXVpcmUoXCIuL1RhZ3MuanNcIik7XG52YXIgQ29uZmlndXJhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29uZmlndXJhdGlvbihuYW1lLCBoYW5kbGVyLCBmYWxsYmFjaywgaXRlbXMsIHRhZ3MsIG9wdGlvbnMsIG5vZGVzLCBwcmVwcm9jZXNzb3JzLCBwb3N0cHJvY2Vzc29ycywgaW5pdE1ldGhvZCwgY29uZmlnTWV0aG9kLCBwcmlvcml0eSwgcGFyc2VyKSB7XG4gICAgICAgIGlmIChoYW5kbGVyID09PSB2b2lkIDApIHsgaGFuZGxlciA9IHt9OyB9XG4gICAgICAgIGlmIChmYWxsYmFjayA9PT0gdm9pZCAwKSB7IGZhbGxiYWNrID0ge307IH1cbiAgICAgICAgaWYgKGl0ZW1zID09PSB2b2lkIDApIHsgaXRlbXMgPSB7fTsgfVxuICAgICAgICBpZiAodGFncyA9PT0gdm9pZCAwKSB7IHRhZ3MgPSB7fTsgfVxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICBpZiAobm9kZXMgPT09IHZvaWQgMCkgeyBub2RlcyA9IHt9OyB9XG4gICAgICAgIGlmIChwcmVwcm9jZXNzb3JzID09PSB2b2lkIDApIHsgcHJlcHJvY2Vzc29ycyA9IFtdOyB9XG4gICAgICAgIGlmIChwb3N0cHJvY2Vzc29ycyA9PT0gdm9pZCAwKSB7IHBvc3Rwcm9jZXNzb3JzID0gW107IH1cbiAgICAgICAgaWYgKGluaXRNZXRob2QgPT09IHZvaWQgMCkgeyBpbml0TWV0aG9kID0gbnVsbDsgfVxuICAgICAgICBpZiAoY29uZmlnTWV0aG9kID09PSB2b2lkIDApIHsgY29uZmlnTWV0aG9kID0gbnVsbDsgfVxuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBoYW5kbGVyO1xuICAgICAgICB0aGlzLmZhbGxiYWNrID0gZmFsbGJhY2s7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy50YWdzID0gdGFncztcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5ub2RlcyA9IG5vZGVzO1xuICAgICAgICB0aGlzLnByZXByb2Nlc3NvcnMgPSBwcmVwcm9jZXNzb3JzO1xuICAgICAgICB0aGlzLnBvc3Rwcm9jZXNzb3JzID0gcG9zdHByb2Nlc3NvcnM7XG4gICAgICAgIHRoaXMuaW5pdE1ldGhvZCA9IGluaXRNZXRob2Q7XG4gICAgICAgIHRoaXMuY29uZmlnTWV0aG9kID0gY29uZmlnTWV0aG9kO1xuICAgICAgICB0aGlzLnByaW9yaXR5ID0gcHJpb3JpdHk7XG4gICAgICAgIHRoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICB0aGlzLmhhbmRsZXIgPSBPYmplY3QuYXNzaWduKHsgY2hhcmFjdGVyOiBbXSwgZGVsaW1pdGVyOiBbXSwgbWFjcm86IFtdLCBlbnZpcm9ubWVudDogW10gfSwgaGFuZGxlcik7XG4gICAgfVxuICAgIENvbmZpZ3VyYXRpb24ubWFrZVByb2Nlc3NvciA9IGZ1bmN0aW9uIChmdW5jLCBwcmlvcml0eSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShmdW5jKSA/IGZ1bmMgOiBbZnVuYywgcHJpb3JpdHldO1xuICAgIH07XG4gICAgQ29uZmlndXJhdGlvbi5fY3JlYXRlID0gZnVuY3Rpb24gKG5hbWUsIGNvbmZpZykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgdmFyIHByaW9yaXR5ID0gY29uZmlnLnByaW9yaXR5IHx8IFByaW9yaXRpemVkTGlzdF9qc18xLlByaW9yaXRpemVkTGlzdC5ERUZBVUxUUFJJT1JJVFk7XG4gICAgICAgIHZhciBpbml0ID0gY29uZmlnLmluaXQgPyB0aGlzLm1ha2VQcm9jZXNzb3IoY29uZmlnLmluaXQsIHByaW9yaXR5KSA6IG51bGw7XG4gICAgICAgIHZhciBjb25mID0gY29uZmlnLmNvbmZpZyA/IHRoaXMubWFrZVByb2Nlc3Nvcihjb25maWcuY29uZmlnLCBwcmlvcml0eSkgOiBudWxsO1xuICAgICAgICB2YXIgcHJlcHJvY2Vzc29ycyA9IChjb25maWcucHJlcHJvY2Vzc29ycyB8fCBbXSkubWFwKGZ1bmN0aW9uIChwcmUpIHsgcmV0dXJuIF90aGlzLm1ha2VQcm9jZXNzb3IocHJlLCBwcmlvcml0eSk7IH0pO1xuICAgICAgICB2YXIgcG9zdHByb2Nlc3NvcnMgPSAoY29uZmlnLnBvc3Rwcm9jZXNzb3JzIHx8IFtdKS5tYXAoZnVuY3Rpb24gKHBvc3QpIHsgcmV0dXJuIF90aGlzLm1ha2VQcm9jZXNzb3IocG9zdCwgcHJpb3JpdHkpOyB9KTtcbiAgICAgICAgdmFyIHBhcnNlciA9IGNvbmZpZy5wYXJzZXIgfHwgJ3RleCc7XG4gICAgICAgIHJldHVybiBuZXcgQ29uZmlndXJhdGlvbihuYW1lLCBjb25maWcuaGFuZGxlciB8fCB7fSwgY29uZmlnLmZhbGxiYWNrIHx8IHt9LCBjb25maWcuaXRlbXMgfHwge30sIGNvbmZpZy50YWdzIHx8IHt9LCBjb25maWcub3B0aW9ucyB8fCB7fSwgY29uZmlnLm5vZGVzIHx8IHt9LCBwcmVwcm9jZXNzb3JzLCBwb3N0cHJvY2Vzc29ycywgaW5pdCwgY29uZiwgcHJpb3JpdHksIHBhcnNlcik7XG4gICAgfTtcbiAgICBDb25maWd1cmF0aW9uLmNyZWF0ZSA9IGZ1bmN0aW9uIChuYW1lLCBjb25maWcpIHtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gdm9pZCAwKSB7IGNvbmZpZyA9IHt9OyB9XG4gICAgICAgIHZhciBjb25maWd1cmF0aW9uID0gQ29uZmlndXJhdGlvbi5fY3JlYXRlKG5hbWUsIGNvbmZpZyk7XG4gICAgICAgIENvbmZpZ3VyYXRpb25IYW5kbGVyLnNldChuYW1lLCBjb25maWd1cmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIGNvbmZpZ3VyYXRpb247XG4gICAgfTtcbiAgICBDb25maWd1cmF0aW9uLmxvY2FsID0gZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICBpZiAoY29uZmlnID09PSB2b2lkIDApIHsgY29uZmlnID0ge307IH1cbiAgICAgICAgcmV0dXJuIENvbmZpZ3VyYXRpb24uX2NyZWF0ZSgnJywgY29uZmlnKTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgXCJpbml0XCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pbml0TWV0aG9kID8gdGhpcy5pbml0TWV0aG9kWzBdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25maWd1cmF0aW9uLnByb3RvdHlwZSwgXCJjb25maWdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ01ldGhvZCA/IHRoaXMuY29uZmlnTWV0aG9kWzBdIDogbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBDb25maWd1cmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuQ29uZmlndXJhdGlvbiA9IENvbmZpZ3VyYXRpb247XG52YXIgQ29uZmlndXJhdGlvbkhhbmRsZXI7XG4oZnVuY3Rpb24gKENvbmZpZ3VyYXRpb25IYW5kbGVyKSB7XG4gICAgdmFyIG1hcHMgPSBuZXcgTWFwKCk7XG4gICAgQ29uZmlndXJhdGlvbkhhbmRsZXIuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIG1hcCkge1xuICAgICAgICBtYXBzLnNldChuYW1lLCBtYXApO1xuICAgIH07XG4gICAgQ29uZmlndXJhdGlvbkhhbmRsZXIuZ2V0ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG1hcHMuZ2V0KG5hbWUpO1xuICAgIH07XG4gICAgQ29uZmlndXJhdGlvbkhhbmRsZXIua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1hcHMua2V5cygpO1xuICAgIH07XG59KShDb25maWd1cmF0aW9uSGFuZGxlciA9IGV4cG9ydHMuQ29uZmlndXJhdGlvbkhhbmRsZXIgfHwgKGV4cG9ydHMuQ29uZmlndXJhdGlvbkhhbmRsZXIgPSB7fSkpO1xudmFyIFBhcnNlckNvbmZpZ3VyYXRpb24gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBhcnNlckNvbmZpZ3VyYXRpb24ocGFja2FnZXMsIHBhcnNlcnMpIHtcbiAgICAgICAgdmFyIGVfMSwgX2EsIGVfMiwgX2I7XG4gICAgICAgIGlmIChwYXJzZXJzID09PSB2b2lkIDApIHsgcGFyc2VycyA9IFsndGV4J107IH1cbiAgICAgICAgdGhpcy5pbml0TWV0aG9kID0gbmV3IEZ1bmN0aW9uTGlzdF9qc18xLkZ1bmN0aW9uTGlzdCgpO1xuICAgICAgICB0aGlzLmNvbmZpZ01ldGhvZCA9IG5ldyBGdW5jdGlvbkxpc3RfanNfMS5GdW5jdGlvbkxpc3QoKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9ucyA9IG5ldyBQcmlvcml0aXplZExpc3RfanNfMS5Qcmlvcml0aXplZExpc3QoKTtcbiAgICAgICAgdGhpcy5wYXJzZXJzID0gW107XG4gICAgICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwSGFuZGxlcl9qc18xLlN1YkhhbmRsZXJzKCk7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB7fTtcbiAgICAgICAgdGhpcy50YWdzID0ge307XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLm5vZGVzID0ge307XG4gICAgICAgIHRoaXMucGFyc2VycyA9IHBhcnNlcnM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYyA9IF9fdmFsdWVzKHBhY2thZ2VzLnNsaWNlKCkucmV2ZXJzZSgpKSwgX2QgPSBfYy5uZXh0KCk7ICFfZC5kb25lOyBfZCA9IF9jLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBwa2cgPSBfZC52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZFBhY2thZ2UocGtnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9kICYmICFfZC5kb25lICYmIChfYSA9IF9jLnJldHVybikpIF9hLmNhbGwoX2MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfZSA9IF9fdmFsdWVzKHRoaXMuY29uZmlndXJhdGlvbnMpLCBfZiA9IF9lLm5leHQoKTsgIV9mLmRvbmU7IF9mID0gX2UubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9nID0gX2YudmFsdWUsIGNvbmZpZyA9IF9nLml0ZW0sIHByaW9yaXR5ID0gX2cucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmQoY29uZmlnLCBwcmlvcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZiAmJiAhX2YuZG9uZSAmJiAoX2IgPSBfZS5yZXR1cm4pKSBfYi5jYWxsKF9lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8yKSB0aHJvdyBlXzIuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJzZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmluaXRNZXRob2QuZXhlY3V0ZSh0aGlzKTtcbiAgICB9O1xuICAgIFBhcnNlckNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmNvbmZpZyA9IGZ1bmN0aW9uIChqYXgpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIHRoaXMuY29uZmlnTWV0aG9kLmV4ZWN1dGUodGhpcywgamF4KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5jb25maWd1cmF0aW9ucyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRGaWx0ZXJzKGpheCwgY29uZmlnLml0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFBhcnNlckNvbmZpZ3VyYXRpb24ucHJvdG90eXBlLmFkZFBhY2thZ2UgPSBmdW5jdGlvbiAocGtnKSB7XG4gICAgICAgIHZhciBuYW1lID0gdHlwZW9mIHBrZyA9PT0gJ3N0cmluZycgPyBwa2cgOiBwa2dbMF07XG4gICAgICAgIHZhciBjb25mID0gdGhpcy5nZXRQYWNrYWdlKG5hbWUpO1xuICAgICAgICBjb25mICYmIHRoaXMuY29uZmlndXJhdGlvbnMuYWRkKGNvbmYsIHR5cGVvZiBwa2cgPT09ICdzdHJpbmcnID8gY29uZi5wcmlvcml0eSA6IHBrZ1sxXSk7XG4gICAgfTtcbiAgICBQYXJzZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgamF4LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBlXzQsIF9hO1xuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgICAgICB2YXIgY29uZmlnID0gdGhpcy5nZXRQYWNrYWdlKG5hbWUpO1xuICAgICAgICB0aGlzLmFwcGVuZChjb25maWcpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25zLmFkZChjb25maWcsIGNvbmZpZy5wcmlvcml0eSk7XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgICAgICB2YXIgcGFyc2VyID0gamF4LnBhcnNlT3B0aW9ucztcbiAgICAgICAgcGFyc2VyLm5vZGVGYWN0b3J5LnNldENyZWF0b3JzKGNvbmZpZy5ub2Rlcyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGNvbmZpZy5pdGVtcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtpbmQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBwYXJzZXIuaXRlbUZhY3Rvcnkuc2V0Tm9kZUNsYXNzKGtpbmQsIGNvbmZpZy5pdGVtc1traW5kXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBUYWdzX2pzXzEuVGFnc0ZhY3RvcnkuYWRkVGFncyhjb25maWcudGFncyk7XG4gICAgICAgICgwLCBPcHRpb25zX2pzXzEuZGVmYXVsdE9wdGlvbnMpKHBhcnNlci5vcHRpb25zLCBjb25maWcub3B0aW9ucyk7XG4gICAgICAgICgwLCBPcHRpb25zX2pzXzEudXNlck9wdGlvbnMpKHBhcnNlci5vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5hZGRGaWx0ZXJzKGpheCwgY29uZmlnKTtcbiAgICAgICAgaWYgKGNvbmZpZy5jb25maWcpIHtcbiAgICAgICAgICAgIGNvbmZpZy5jb25maWcodGhpcywgamF4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUGFyc2VyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuZ2V0UGFja2FnZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBjb25maWcgPSBDb25maWd1cmF0aW9uSGFuZGxlci5nZXQobmFtZSk7XG4gICAgICAgIGlmIChjb25maWcgJiYgdGhpcy5wYXJzZXJzLmluZGV4T2YoY29uZmlnLnBhcnNlcikgPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlBhY2thZ2UgXCIuY29uY2F0KG5hbWUsIFwiIGRvZXNuJ3QgdGFyZ2V0IHRoZSBwcm9wZXIgcGFyc2VyXCIpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29uZmlnO1xuICAgIH07XG4gICAgUGFyc2VyQ29uZmlndXJhdGlvbi5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKGNvbmZpZywgcHJpb3JpdHkpIHtcbiAgICAgICAgcHJpb3JpdHkgPSBwcmlvcml0eSB8fCBjb25maWcucHJpb3JpdHk7XG4gICAgICAgIGlmIChjb25maWcuaW5pdE1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy5pbml0TWV0aG9kLmFkZChjb25maWcuaW5pdE1ldGhvZFswXSwgY29uZmlnLmluaXRNZXRob2RbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25maWcuY29uZmlnTWV0aG9kKSB7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ01ldGhvZC5hZGQoY29uZmlnLmNvbmZpZ01ldGhvZFswXSwgY29uZmlnLmNvbmZpZ01ldGhvZFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oYW5kbGVycy5hZGQoY29uZmlnLmhhbmRsZXIsIGNvbmZpZy5mYWxsYmFjaywgcHJpb3JpdHkpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuaXRlbXMsIGNvbmZpZy5pdGVtcyk7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcy50YWdzLCBjb25maWcudGFncyk7XG4gICAgICAgICgwLCBPcHRpb25zX2pzXzEuZGVmYXVsdE9wdGlvbnMpKHRoaXMub3B0aW9ucywgY29uZmlnLm9wdGlvbnMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMubm9kZXMsIGNvbmZpZy5ub2Rlcyk7XG4gICAgfTtcbiAgICBQYXJzZXJDb25maWd1cmF0aW9uLnByb3RvdHlwZS5hZGRGaWx0ZXJzID0gZnVuY3Rpb24gKGpheCwgY29uZmlnKSB7XG4gICAgICAgIHZhciBlXzUsIF9hLCBlXzYsIF9iO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2MgPSBfX3ZhbHVlcyhjb25maWcucHJlcHJvY2Vzc29ycyksIF9kID0gX2MubmV4dCgpOyAhX2QuZG9uZTsgX2QgPSBfYy5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2UgPSBfX3JlYWQoX2QudmFsdWUsIDIpLCBwcmUgPSBfZVswXSwgcHJpb3JpdHkgPSBfZVsxXTtcbiAgICAgICAgICAgICAgICBqYXgucHJlRmlsdGVycy5hZGQocHJlLCBwcmlvcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNV8xKSB7IGVfNSA9IHsgZXJyb3I6IGVfNV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfZCAmJiAhX2QuZG9uZSAmJiAoX2EgPSBfYy5yZXR1cm4pKSBfYS5jYWxsKF9jKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV81KSB0aHJvdyBlXzUuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSBfX3ZhbHVlcyhjb25maWcucG9zdHByb2Nlc3NvcnMpLCBfZyA9IF9mLm5leHQoKTsgIV9nLmRvbmU7IF9nID0gX2YubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9oID0gX19yZWFkKF9nLnZhbHVlLCAyKSwgcG9zdCA9IF9oWzBdLCBwcmlvcml0eSA9IF9oWzFdO1xuICAgICAgICAgICAgICAgIGpheC5wb3N0RmlsdGVycy5hZGQocG9zdCwgcHJpb3JpdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzZfMSkgeyBlXzYgPSB7IGVycm9yOiBlXzZfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2cgJiYgIV9nLmRvbmUgJiYgKF9iID0gX2YucmV0dXJuKSkgX2IuY2FsbChfZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNikgdGhyb3cgZV82LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBQYXJzZXJDb25maWd1cmF0aW9uO1xufSgpKTtcbmV4cG9ydHMuUGFyc2VyQ29uZmlndXJhdGlvbiA9IFBhcnNlckNvbmZpZ3VyYXRpb247XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db25maWd1cmF0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdWJIYW5kbGVycyA9IGV4cG9ydHMuU3ViSGFuZGxlciA9IGV4cG9ydHMuTWFwSGFuZGxlciA9IHZvaWQgMDtcbnZhciBQcmlvcml0aXplZExpc3RfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL1ByaW9yaXRpemVkTGlzdC5qc1wiKTtcbnZhciBGdW5jdGlvbkxpc3RfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0Z1bmN0aW9uTGlzdC5qc1wiKTtcbnZhciBNYXBIYW5kbGVyO1xuKGZ1bmN0aW9uIChNYXBIYW5kbGVyKSB7XG4gICAgdmFyIG1hcHMgPSBuZXcgTWFwKCk7XG4gICAgTWFwSGFuZGxlci5yZWdpc3RlciA9IGZ1bmN0aW9uIChtYXApIHtcbiAgICAgICAgbWFwcy5zZXQobWFwLm5hbWUsIG1hcCk7XG4gICAgfTtcbiAgICBNYXBIYW5kbGVyLmdldE1hcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXBzLmdldChuYW1lKTtcbiAgICB9O1xufSkoTWFwSGFuZGxlciA9IGV4cG9ydHMuTWFwSGFuZGxlciB8fCAoZXhwb3J0cy5NYXBIYW5kbGVyID0ge30pKTtcbnZhciBTdWJIYW5kbGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWJIYW5kbGVyKCkge1xuICAgICAgICB0aGlzLl9jb25maWd1cmF0aW9uID0gbmV3IFByaW9yaXRpemVkTGlzdF9qc18xLlByaW9yaXRpemVkTGlzdCgpO1xuICAgICAgICB0aGlzLl9mYWxsYmFjayA9IG5ldyBGdW5jdGlvbkxpc3RfanNfMS5GdW5jdGlvbkxpc3QoKTtcbiAgICB9XG4gICAgU3ViSGFuZGxlci5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gKG1hcHMsIGZhbGxiYWNrLCBwcmlvcml0eSkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgaWYgKHByaW9yaXR5ID09PSB2b2lkIDApIHsgcHJpb3JpdHkgPSBQcmlvcml0aXplZExpc3RfanNfMS5Qcmlvcml0aXplZExpc3QuREVGQVVMVFBSSU9SSVRZOyB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKG1hcHMuc2xpY2UoKS5yZXZlcnNlKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBNYXBIYW5kbGVyLmdldE1hcChuYW1lXzEpO1xuICAgICAgICAgICAgICAgIGlmICghbWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2FybignQ29uZmlndXJhdGlvbiAnICsgbmFtZV8xICsgJyBub3QgZm91bmQhIE9taXR0ZWQuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fY29uZmlndXJhdGlvbi5hZGQobWFwLCBwcmlvcml0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmFsbGJhY2spIHtcbiAgICAgICAgICAgIHRoaXMuX2ZhbGxiYWNrLmFkZChmYWxsYmFjaywgcHJpb3JpdHkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJIYW5kbGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5fY29uZmlndXJhdGlvbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gX2MudmFsdWUuaXRlbTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gbWFwLnBhcnNlKGlucHV0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9kID0gX19yZWFkKGlucHV0LCAyKSwgZW52ID0gX2RbMF0sIHN5bWJvbCA9IF9kWzFdO1xuICAgICAgICBBcnJheS5mcm9tKHRoaXMuX2ZhbGxiYWNrKVswXS5pdGVtKGVudiwgc3ltYm9sKTtcbiAgICB9O1xuICAgIFN1YkhhbmRsZXIucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMuYXBwbGljYWJsZShzeW1ib2wpO1xuICAgICAgICByZXR1cm4gbWFwID8gbWFwLmxvb2t1cChzeW1ib2wpIDogbnVsbDtcbiAgICB9O1xuICAgIFN1YkhhbmRsZXIucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcHBsaWNhYmxlKHN5bWJvbCkgPyB0cnVlIDogZmFsc2U7XG4gICAgfTtcbiAgICBTdWJIYW5kbGVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMywgX2E7XG4gICAgICAgIHZhciBuYW1lcyA9IFtdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyh0aGlzLl9jb25maWd1cmF0aW9uKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBfYy52YWx1ZS5pdGVtO1xuICAgICAgICAgICAgICAgIG5hbWVzLnB1c2gobWFwLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWVzLmpvaW4oJywgJyk7XG4gICAgfTtcbiAgICBTdWJIYW5kbGVyLnByb3RvdHlwZS5hcHBsaWNhYmxlID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICB2YXIgZV80LCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5fY29uZmlndXJhdGlvbiksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gX2MudmFsdWUuaXRlbTtcbiAgICAgICAgICAgICAgICBpZiAobWFwLmNvbnRhaW5zKHN5bWJvbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfNF8xKSB7IGVfNCA9IHsgZXJyb3I6IGVfNF8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIFN1YkhhbmRsZXIucHJvdG90eXBlLnJldHJpZXZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGVfNSwgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMuX2NvbmZpZ3VyYXRpb24pLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcCA9IF9jLnZhbHVlLml0ZW07XG4gICAgICAgICAgICAgICAgaWYgKG1hcC5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzVfMSkgeyBlXzUgPSB7IGVycm9yOiBlXzVfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNSkgdGhyb3cgZV81LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdWJIYW5kbGVyLnByb3RvdHlwZS53YXJuID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ1RleFBhcnNlciBXYXJuaW5nOiAnICsgbWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gU3ViSGFuZGxlcjtcbn0oKSk7XG5leHBvcnRzLlN1YkhhbmRsZXIgPSBTdWJIYW5kbGVyO1xudmFyIFN1YkhhbmRsZXJzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdWJIYW5kbGVycygpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIFN1YkhhbmRsZXJzLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiAoaGFuZGxlcnMsIGZhbGxiYWNrcywgcHJpb3JpdHkpIHtcbiAgICAgICAgdmFyIGVfNiwgX2E7XG4gICAgICAgIGlmIChwcmlvcml0eSA9PT0gdm9pZCAwKSB7IHByaW9yaXR5ID0gUHJpb3JpdGl6ZWRMaXN0X2pzXzEuUHJpb3JpdGl6ZWRMaXN0LkRFRkFVTFRQUklPUklUWTsgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhoYW5kbGVycykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzIgPSBrZXk7XG4gICAgICAgICAgICAgICAgdmFyIHN1YkhhbmRsZXIgPSB0aGlzLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgICAgIGlmICghc3ViSGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBzdWJIYW5kbGVyID0gbmV3IFN1YkhhbmRsZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQobmFtZV8yLCBzdWJIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3ViSGFuZGxlci5hZGQoaGFuZGxlcnNbbmFtZV8yXSwgZmFsbGJhY2tzW25hbWVfMl0sIHByaW9yaXR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV82XzEpIHsgZV82ID0geyBlcnJvcjogZV82XzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzYpIHRocm93IGVfNi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBTdWJIYW5kbGVycy5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHN1YkhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5tYXAuc2V0KG5hbWUsIHN1YkhhbmRsZXIpO1xuICAgIH07XG4gICAgU3ViSGFuZGxlcnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5nZXQobmFtZSk7XG4gICAgfTtcbiAgICBTdWJIYW5kbGVycy5wcm90b3R5cGUucmV0cmlldmUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgZV83LCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcy5tYXAudmFsdWVzKCkpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGhhbmRsZXIgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgbWFwID0gaGFuZGxlci5yZXRyaWV2ZShuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAobWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzdfMSkgeyBlXzcgPSB7IGVycm9yOiBlXzdfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfNykgdGhyb3cgZV83LmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBTdWJIYW5kbGVycy5wcm90b3R5cGUua2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmtleXMoKTtcbiAgICB9O1xuICAgIHJldHVybiBTdWJIYW5kbGVycztcbn0oKSk7XG5leHBvcnRzLlN1YkhhbmRsZXJzID0gU3ViSGFuZGxlcnM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NYXBIYW5kbGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE1tbE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb3JlL01tbFRyZWUvTW1sTm9kZS5qc1wiKTtcbnZhciBtb19qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2Rlcy9tby5qc1wiKTtcbnZhciBOb2RlVXRpbDtcbihmdW5jdGlvbiAoTm9kZVV0aWwpIHtcbiAgICB2YXIgYXR0cnMgPSBuZXcgTWFwKFtcbiAgICAgICAgWydhdXRvT1AnLCB0cnVlXSxcbiAgICAgICAgWydmbk9QJywgdHJ1ZV0sXG4gICAgICAgIFsnbW92ZXN1cHN1YicsIHRydWVdLFxuICAgICAgICBbJ3N1YnN1cE9LJywgdHJ1ZV0sXG4gICAgICAgIFsndGV4cHJpbWVzdHlsZScsIHRydWVdLFxuICAgICAgICBbJ3VzZUhlaWdodCcsIHRydWVdLFxuICAgICAgICBbJ3ZhcmlhbnRGb3JtJywgdHJ1ZV0sXG4gICAgICAgIFsnd2l0aERlbGltcycsIHRydWVdLFxuICAgICAgICBbJ21hdGhhY2NlbnQnLCB0cnVlXSxcbiAgICAgICAgWydvcGVuJywgdHJ1ZV0sXG4gICAgICAgIFsnY2xvc2UnLCB0cnVlXVxuICAgIF0pO1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVudGl0eShjb2RlKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChwYXJzZUludChjb2RlLCAxNikpO1xuICAgIH1cbiAgICBOb2RlVXRpbC5jcmVhdGVFbnRpdHkgPSBjcmVhdGVFbnRpdHk7XG4gICAgZnVuY3Rpb24gZ2V0Q2hpbGRyZW4obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5jaGlsZE5vZGVzO1xuICAgIH1cbiAgICBOb2RlVXRpbC5nZXRDaGlsZHJlbiA9IGdldENoaWxkcmVuO1xuICAgIGZ1bmN0aW9uIGdldFRleHQobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5nZXRUZXh0KCk7XG4gICAgfVxuICAgIE5vZGVVdGlsLmdldFRleHQgPSBnZXRUZXh0O1xuICAgIGZ1bmN0aW9uIGFwcGVuZENoaWxkcmVuKG5vZGUsIGNoaWxkcmVuKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgY2hpbGRyZW5fMSA9IF9fdmFsdWVzKGNoaWxkcmVuKSwgY2hpbGRyZW5fMV8xID0gY2hpbGRyZW5fMS5uZXh0KCk7ICFjaGlsZHJlbl8xXzEuZG9uZTsgY2hpbGRyZW5fMV8xID0gY2hpbGRyZW5fMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBjaGlsZHJlbl8xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjaGlsZHJlbl8xXzEgJiYgIWNoaWxkcmVuXzFfMS5kb25lICYmIChfYSA9IGNoaWxkcmVuXzEucmV0dXJuKSkgX2EuY2FsbChjaGlsZHJlbl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBOb2RlVXRpbC5hcHBlbmRDaGlsZHJlbiA9IGFwcGVuZENoaWxkcmVuO1xuICAgIGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICAgIG5vZGUuYXR0cmlidXRlcy5zZXQoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfVxuICAgIE5vZGVVdGlsLnNldEF0dHJpYnV0ZSA9IHNldEF0dHJpYnV0ZTtcbiAgICBmdW5jdGlvbiBzZXRQcm9wZXJ0eShub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICAgICAgbm9kZS5zZXRQcm9wZXJ0eShwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH1cbiAgICBOb2RlVXRpbC5zZXRQcm9wZXJ0eSA9IHNldFByb3BlcnR5O1xuICAgIGZ1bmN0aW9uIHNldFByb3BlcnRpZXMobm9kZSwgcHJvcGVydGllcykge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoT2JqZWN0LmtleXMocHJvcGVydGllcykpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5hbWVfMSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BlcnRpZXNbbmFtZV8xXTtcbiAgICAgICAgICAgICAgICBpZiAobmFtZV8xID09PSAndGV4Q2xhc3MnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudGV4Q2xhc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0eShuYW1lXzEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmFtZV8xID09PSAnbW92YWJsZWxpbWl0cycpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0eSgnbW92YWJsZWxpbWl0cycsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuaXNLaW5kKCdtbycpIHx8IG5vZGUuaXNLaW5kKCdtc3R5bGUnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hdHRyaWJ1dGVzLnNldCgnbW92YWJsZWxpbWl0cycsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChuYW1lXzEgPT09ICdpbmZlcnJlZCcpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYXR0cnMuaGFzKG5hbWVfMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zZXRQcm9wZXJ0eShuYW1lXzEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYXR0cmlidXRlcy5zZXQobmFtZV8xLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgTm9kZVV0aWwuc2V0UHJvcGVydGllcyA9IHNldFByb3BlcnRpZXM7XG4gICAgZnVuY3Rpb24gZ2V0UHJvcGVydHkobm9kZSwgcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuZ2V0UHJvcGVydHkocHJvcGVydHkpO1xuICAgIH1cbiAgICBOb2RlVXRpbC5nZXRQcm9wZXJ0eSA9IGdldFByb3BlcnR5O1xuICAgIGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBhdHRyKSB7XG4gICAgICAgIHJldHVybiBub2RlLmF0dHJpYnV0ZXMuZ2V0KGF0dHIpO1xuICAgIH1cbiAgICBOb2RlVXRpbC5nZXRBdHRyaWJ1dGUgPSBnZXRBdHRyaWJ1dGU7XG4gICAgZnVuY3Rpb24gcmVtb3ZlUHJvcGVydGllcyhub2RlKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUucmVtb3ZlUHJvcGVydHkuYXBwbHkobm9kZSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHByb3BlcnRpZXMpLCBmYWxzZSkpO1xuICAgIH1cbiAgICBOb2RlVXRpbC5yZW1vdmVQcm9wZXJ0aWVzID0gcmVtb3ZlUHJvcGVydGllcztcbiAgICBmdW5jdGlvbiBnZXRDaGlsZEF0KG5vZGUsIHBvc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBub2RlLmNoaWxkTm9kZXNbcG9zaXRpb25dO1xuICAgIH1cbiAgICBOb2RlVXRpbC5nZXRDaGlsZEF0ID0gZ2V0Q2hpbGRBdDtcbiAgICBmdW5jdGlvbiBzZXRDaGlsZChub2RlLCBwb3NpdGlvbiwgY2hpbGQpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gbm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBjaGlsZHJlbltwb3NpdGlvbl0gPSBjaGlsZDtcbiAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wYXJlbnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE5vZGVVdGlsLnNldENoaWxkID0gc2V0Q2hpbGQ7XG4gICAgZnVuY3Rpb24gY29weUNoaWxkcmVuKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgdmFyIGNoaWxkcmVuID0gb2xkTm9kZS5jaGlsZE5vZGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZXRDaGlsZChuZXdOb2RlLCBpLCBjaGlsZHJlbltpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgTm9kZVV0aWwuY29weUNoaWxkcmVuID0gY29weUNoaWxkcmVuO1xuICAgIGZ1bmN0aW9uIGNvcHlBdHRyaWJ1dGVzKG9sZE5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgbmV3Tm9kZS5hdHRyaWJ1dGVzID0gb2xkTm9kZS5hdHRyaWJ1dGVzO1xuICAgICAgICBzZXRQcm9wZXJ0aWVzKG5ld05vZGUsIG9sZE5vZGUuZ2V0QWxsUHJvcGVydGllcygpKTtcbiAgICB9XG4gICAgTm9kZVV0aWwuY29weUF0dHJpYnV0ZXMgPSBjb3B5QXR0cmlidXRlcztcbiAgICBmdW5jdGlvbiBpc1R5cGUobm9kZSwga2luZCkge1xuICAgICAgICByZXR1cm4gbm9kZS5pc0tpbmQoa2luZCk7XG4gICAgfVxuICAgIE5vZGVVdGlsLmlzVHlwZSA9IGlzVHlwZTtcbiAgICBmdW5jdGlvbiBpc0VtYmVsbGlzaGVkKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5vZGUuaXNFbWJlbGxpc2hlZDtcbiAgICB9XG4gICAgTm9kZVV0aWwuaXNFbWJlbGxpc2hlZCA9IGlzRW1iZWxsaXNoZWQ7XG4gICAgZnVuY3Rpb24gZ2V0VGV4Q2xhc3Mobm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS50ZXhDbGFzcztcbiAgICB9XG4gICAgTm9kZVV0aWwuZ2V0VGV4Q2xhc3MgPSBnZXRUZXhDbGFzcztcbiAgICBmdW5jdGlvbiBnZXRDb3JlTU8obm9kZSkge1xuICAgICAgICByZXR1cm4gbm9kZS5jb3JlTU8oKTtcbiAgICB9XG4gICAgTm9kZVV0aWwuZ2V0Q29yZU1PID0gZ2V0Q29yZU1PO1xuICAgIGZ1bmN0aW9uIGlzTm9kZShpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtIGluc3RhbmNlb2YgTW1sTm9kZV9qc18xLkFic3RyYWN0TW1sTm9kZSB8fCBpdGVtIGluc3RhbmNlb2YgTW1sTm9kZV9qc18xLkFic3RyYWN0TW1sRW1wdHlOb2RlO1xuICAgIH1cbiAgICBOb2RlVXRpbC5pc05vZGUgPSBpc05vZGU7XG4gICAgZnVuY3Rpb24gaXNJbmZlcnJlZChub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmlzSW5mZXJyZWQ7XG4gICAgfVxuICAgIE5vZGVVdGlsLmlzSW5mZXJyZWQgPSBpc0luZmVycmVkO1xuICAgIGZ1bmN0aW9uIGdldEZvcm0obm9kZSkge1xuICAgICAgICB2YXIgZV8zLCBfYTtcbiAgICAgICAgaWYgKCFpc1R5cGUobm9kZSwgJ21vJykpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtbyA9IG5vZGU7XG4gICAgICAgIHZhciBmb3JtcyA9IG1vLmdldEZvcm1zKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBmb3Jtc18xID0gX192YWx1ZXMoZm9ybXMpLCBmb3Jtc18xXzEgPSBmb3Jtc18xLm5leHQoKTsgIWZvcm1zXzFfMS5kb25lOyBmb3Jtc18xXzEgPSBmb3Jtc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBmb3JtID0gZm9ybXNfMV8xLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBzeW1ib2wgPSBtb19qc18xLk1tbE1vLk9QVEFCTEVbZm9ybV1bbW8uZ2V0VGV4dCgpXTtcbiAgICAgICAgICAgICAgICBpZiAoc3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzeW1ib2w7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzNfMSkgeyBlXzMgPSB7IGVycm9yOiBlXzNfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoZm9ybXNfMV8xICYmICFmb3Jtc18xXzEuZG9uZSAmJiAoX2EgPSBmb3Jtc18xLnJldHVybikpIF9hLmNhbGwoZm9ybXNfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIE5vZGVVdGlsLmdldEZvcm0gPSBnZXRGb3JtO1xufSkoTm9kZVV0aWwgfHwgKE5vZGVVdGlsID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE5vZGVVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Tm9kZVV0aWwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgTW1sTm9kZV9qc18xID0gcmVxdWlyZShcIi4uLy4uL2NvcmUvTW1sVHJlZS9NbWxOb2RlLmpzXCIpO1xudmFyIE5vZGVVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTm9kZVV0aWwuanNcIikpO1xudmFyIFRleFBhcnNlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1RleFBhcnNlci5qc1wiKSk7XG52YXIgVGV4RXJyb3JfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiLi9UZXhFcnJvci5qc1wiKSk7XG52YXIgRW50aXRpZXNfanNfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsL0VudGl0aWVzLmpzXCIpO1xudmFyIFBhcnNlVXRpbDtcbihmdW5jdGlvbiAoUGFyc2VVdGlsKSB7XG4gICAgdmFyIGVtUGVySW5jaCA9IDcuMjtcbiAgICB2YXIgcHhQZXJJbmNoID0gNzI7XG4gICAgdmFyIFVOSVRfQ0FTRVMgPSB7XG4gICAgICAgICdlbSc6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtOyB9LFxuICAgICAgICAnZXgnOiBmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAqIC40MzsgfSxcbiAgICAgICAgJ3B0JzogZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gLyAxMDsgfSxcbiAgICAgICAgJ3BjJzogZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gKiAxLjI7IH0sXG4gICAgICAgICdweCc6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtICogZW1QZXJJbmNoIC8gcHhQZXJJbmNoOyB9LFxuICAgICAgICAnaW4nOiBmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAqIGVtUGVySW5jaDsgfSxcbiAgICAgICAgJ2NtJzogZnVuY3Rpb24gKG0pIHsgcmV0dXJuIG0gKiBlbVBlckluY2ggLyAyLjU0OyB9LFxuICAgICAgICAnbW0nOiBmdW5jdGlvbiAobSkgeyByZXR1cm4gbSAqIGVtUGVySW5jaCAvIDI1LjQ7IH0sXG4gICAgICAgICdtdSc6IGZ1bmN0aW9uIChtKSB7IHJldHVybiBtIC8gMTg7IH0sXG4gICAgfTtcbiAgICB2YXIgbnVtID0gJyhbLStdPyhbLixdXFxcXGQrfFxcXFxkKyhbLixdXFxcXGQqKT8pKSc7XG4gICAgdmFyIHVuaXQgPSAnKHB0fGVtfGV4fG11fHB4fG1tfGNtfGlufHBjKSc7XG4gICAgdmFyIGRpbWVuRW5kID0gUmVnRXhwKCdeXFxcXHMqJyArIG51bSArICdcXFxccyonICsgdW5pdCArICdcXFxccyokJyk7XG4gICAgdmFyIGRpbWVuUmVzdCA9IFJlZ0V4cCgnXlxcXFxzKicgKyBudW0gKyAnXFxcXHMqJyArIHVuaXQgKyAnID8nKTtcbiAgICBmdW5jdGlvbiBtYXRjaERpbWVuKGRpbSwgcmVzdCkge1xuICAgICAgICBpZiAocmVzdCA9PT0gdm9pZCAwKSB7IHJlc3QgPSBmYWxzZTsgfVxuICAgICAgICB2YXIgbWF0Y2ggPSBkaW0ubWF0Y2gocmVzdCA/IGRpbWVuUmVzdCA6IGRpbWVuRW5kKTtcbiAgICAgICAgcmV0dXJuIG1hdGNoID9cbiAgICAgICAgICAgIG11UmVwbGFjZShbbWF0Y2hbMV0ucmVwbGFjZSgvLC8sICcuJyksIG1hdGNoWzRdLCBtYXRjaFswXS5sZW5ndGhdKSA6XG4gICAgICAgICAgICBbbnVsbCwgbnVsbCwgMF07XG4gICAgfVxuICAgIFBhcnNlVXRpbC5tYXRjaERpbWVuID0gbWF0Y2hEaW1lbjtcbiAgICBmdW5jdGlvbiBtdVJlcGxhY2UoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAzKSwgdmFsdWUgPSBfYlswXSwgdW5pdCA9IF9iWzFdLCBsZW5ndGggPSBfYlsyXTtcbiAgICAgICAgaWYgKHVuaXQgIT09ICdtdScpIHtcbiAgICAgICAgICAgIHJldHVybiBbdmFsdWUsIHVuaXQsIGxlbmd0aF07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVtID0gRW0oVU5JVF9DQVNFU1t1bml0XShwYXJzZUZsb2F0KHZhbHVlIHx8ICcxJykpKTtcbiAgICAgICAgcmV0dXJuIFtlbS5zbGljZSgwLCAtMiksICdlbScsIGxlbmd0aF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpbWVuMmVtKGRpbSkge1xuICAgICAgICB2YXIgX2EgPSBfX3JlYWQobWF0Y2hEaW1lbihkaW0pLCAyKSwgdmFsdWUgPSBfYVswXSwgdW5pdCA9IF9hWzFdO1xuICAgICAgICB2YXIgbSA9IHBhcnNlRmxvYXQodmFsdWUgfHwgJzEnKTtcbiAgICAgICAgdmFyIGZ1bmMgPSBVTklUX0NBU0VTW3VuaXRdO1xuICAgICAgICByZXR1cm4gZnVuYyA/IGZ1bmMobSkgOiAwO1xuICAgIH1cbiAgICBQYXJzZVV0aWwuZGltZW4yZW0gPSBkaW1lbjJlbTtcbiAgICBmdW5jdGlvbiBFbShtKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhtKSA8IC4wMDA2KSB7XG4gICAgICAgICAgICByZXR1cm4gJzBlbSc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG0udG9GaXhlZCgzKS5yZXBsYWNlKC9cXC4/MCskLywgJycpICsgJ2VtJztcbiAgICB9XG4gICAgUGFyc2VVdGlsLkVtID0gRW07XG4gICAgZnVuY3Rpb24gY29scygpIHtcbiAgICAgICAgdmFyIFcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIFdbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVy5tYXAoZnVuY3Rpb24gKG4pIHsgcmV0dXJuIEVtKG4pOyB9KS5qb2luKCcgJyk7XG4gICAgfVxuICAgIFBhcnNlVXRpbC5jb2xzID0gY29scztcbiAgICBmdW5jdGlvbiBmZW5jZWQoY29uZmlndXJhdGlvbiwgb3BlbiwgbW1sLCBjbG9zZSwgYmlnLCBjb2xvcikge1xuICAgICAgICBpZiAoYmlnID09PSB2b2lkIDApIHsgYmlnID0gJyc7IH1cbiAgICAgICAgaWYgKGNvbG9yID09PSB2b2lkIDApIHsgY29sb3IgPSAnJzsgfVxuICAgICAgICB2YXIgbmYgPSBjb25maWd1cmF0aW9uLm5vZGVGYWN0b3J5O1xuICAgICAgICB2YXIgbXJvdyA9IG5mLmNyZWF0ZSgnbm9kZScsICdtcm93JywgW10sIHsgb3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlLCB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLklOTkVSIH0pO1xuICAgICAgICB2YXIgbW87XG4gICAgICAgIGlmIChiaWcpIHtcbiAgICAgICAgICAgIG1vID0gbmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQoJ1xcXFwnICsgYmlnICsgJ2wnICsgb3BlbiwgY29uZmlndXJhdGlvbi5wYXJzZXIuc3RhY2suZW52LCBjb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvcGVuTm9kZSA9IG5mLmNyZWF0ZSgndGV4dCcsIG9wZW4pO1xuICAgICAgICAgICAgbW8gPSBuZi5jcmVhdGUoJ25vZGUnLCAnbW8nLCBbXSwgeyBmZW5jZTogdHJ1ZSwgc3RyZXRjaHk6IHRydWUsIHN5bW1ldHJpYzogdHJ1ZSwgdGV4Q2xhc3M6IE1tbE5vZGVfanNfMS5URVhDTEFTUy5PUEVOIH0sIG9wZW5Ob2RlKTtcbiAgICAgICAgfVxuICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuYXBwZW5kQ2hpbGRyZW4obXJvdywgW21vLCBtbWxdKTtcbiAgICAgICAgaWYgKGJpZykge1xuICAgICAgICAgICAgbW8gPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdCgnXFxcXCcgKyBiaWcgKyAncicgKyBjbG9zZSwgY29uZmlndXJhdGlvbi5wYXJzZXIuc3RhY2suZW52LCBjb25maWd1cmF0aW9uKS5tbWwoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBjbG9zZU5vZGUgPSBuZi5jcmVhdGUoJ3RleHQnLCBjbG9zZSk7XG4gICAgICAgICAgICBtbyA9IG5mLmNyZWF0ZSgnbm9kZScsICdtbycsIFtdLCB7IGZlbmNlOiB0cnVlLCBzdHJldGNoeTogdHJ1ZSwgc3ltbWV0cmljOiB0cnVlLCB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLkNMT1NFIH0sIGNsb3NlTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sb3IgJiYgbW8uYXR0cmlidXRlcy5zZXQoJ21hdGhjb2xvcicsIGNvbG9yKTtcbiAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmFwcGVuZENoaWxkcmVuKG1yb3csIFttb10pO1xuICAgICAgICByZXR1cm4gbXJvdztcbiAgICB9XG4gICAgUGFyc2VVdGlsLmZlbmNlZCA9IGZlbmNlZDtcbiAgICBmdW5jdGlvbiBmaXhlZEZlbmNlKGNvbmZpZ3VyYXRpb24sIG9wZW4sIG1tbCwgY2xvc2UpIHtcbiAgICAgICAgdmFyIG1yb3cgPSBjb25maWd1cmF0aW9uLm5vZGVGYWN0b3J5LmNyZWF0ZSgnbm9kZScsICdtcm93JywgW10sIHsgb3Blbjogb3BlbiwgY2xvc2U6IGNsb3NlLCB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLk9SRCB9KTtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5hcHBlbmRDaGlsZHJlbihtcm93LCBbbWF0aFBhbGV0dGUoY29uZmlndXJhdGlvbiwgb3BlbiwgJ2wnKV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKG1tbCwgJ21yb3cnKSkge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LmFwcGVuZENoaWxkcmVuKG1yb3csIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbihtbWwpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5hcHBlbmRDaGlsZHJlbihtcm93LCBbbW1sXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNsb3NlKSB7XG4gICAgICAgICAgICBOb2RlVXRpbF9qc18xLmRlZmF1bHQuYXBwZW5kQ2hpbGRyZW4obXJvdywgW21hdGhQYWxldHRlKGNvbmZpZ3VyYXRpb24sIGNsb3NlLCAncicpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1yb3c7XG4gICAgfVxuICAgIFBhcnNlVXRpbC5maXhlZEZlbmNlID0gZml4ZWRGZW5jZTtcbiAgICBmdW5jdGlvbiBtYXRoUGFsZXR0ZShjb25maWd1cmF0aW9uLCBmZW5jZSwgc2lkZSkge1xuICAgICAgICBpZiAoZmVuY2UgPT09ICd7JyB8fCBmZW5jZSA9PT0gJ30nKSB7XG4gICAgICAgICAgICBmZW5jZSA9ICdcXFxcJyArIGZlbmNlO1xuICAgICAgICB9XG4gICAgICAgIHZhciBEID0gJ3tcXFxcYmlnZycgKyBzaWRlICsgJyAnICsgZmVuY2UgKyAnfSc7XG4gICAgICAgIHZhciBUID0gJ3tcXFxcYmlnJyArIHNpZGUgKyAnICcgKyBmZW5jZSArICd9JztcbiAgICAgICAgcmV0dXJuIG5ldyBUZXhQYXJzZXJfanNfMS5kZWZhdWx0KCdcXFxcbWF0aGNob2ljZScgKyBEICsgVCArIFQgKyBULCB7fSwgY29uZmlndXJhdGlvbikubW1sKCk7XG4gICAgfVxuICAgIFBhcnNlVXRpbC5tYXRoUGFsZXR0ZSA9IG1hdGhQYWxldHRlO1xuICAgIGZ1bmN0aW9uIGZpeEluaXRpYWxNTyhjb25maWd1cmF0aW9uLCBub2Rlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbSA9IG5vZGVzLmxlbmd0aDsgaSA8IG07IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoaWxkID0gbm9kZXNbaV07XG4gICAgICAgICAgICBpZiAoY2hpbGQgJiYgKCFOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKGNoaWxkLCAnbXNwYWNlJykgJiZcbiAgICAgICAgICAgICAgICAoIU5vZGVVdGlsX2pzXzEuZGVmYXVsdC5pc1R5cGUoY2hpbGQsICdUZVhBdG9tJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbihjaGlsZClbMF0gJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRDaGlsZHJlbihOb2RlVXRpbF9qc18xLmRlZmF1bHQuZ2V0Q2hpbGRyZW4oY2hpbGQpWzBdKS5sZW5ndGgpKSkpIHtcbiAgICAgICAgICAgICAgICBpZiAoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzRW1iZWxsaXNoZWQoY2hpbGQpIHx8XG4gICAgICAgICAgICAgICAgICAgIChOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKGNoaWxkLCAnVGVYQXRvbScpICYmIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRUZXhDbGFzcyhjaGlsZCkgPT09IE1tbE5vZGVfanNfMS5URVhDTEFTUy5SRUwpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtaSA9IGNvbmZpZ3VyYXRpb24ubm9kZUZhY3RvcnkuY3JlYXRlKCdub2RlJywgJ21pJyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnVuc2hpZnQobWkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJzZVV0aWwuZml4SW5pdGlhbE1PID0gZml4SW5pdGlhbE1PO1xuICAgIGZ1bmN0aW9uIGludGVybmFsTWF0aChwYXJzZXIsIHRleHQsIGxldmVsLCBmb250KSB7XG4gICAgICAgIGlmIChwYXJzZXIuY29uZmlndXJhdGlvbi5vcHRpb25zLmludGVybmFsTWF0aCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlci5jb25maWd1cmF0aW9uLm9wdGlvbnMuaW50ZXJuYWxNYXRoKHBhcnNlciwgdGV4dCwgbGV2ZWwsIGZvbnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXRodmFyaWFudCA9IGZvbnQgfHwgcGFyc2VyLnN0YWNrLmVudi5mb250O1xuICAgICAgICB2YXIgZGVmID0gKG1hdGh2YXJpYW50ID8geyBtYXRodmFyaWFudDogbWF0aHZhcmlhbnQgfSA6IHt9KTtcbiAgICAgICAgdmFyIG1tbCA9IFtdLCBpID0gMCwgayA9IDAsIGMsIG5vZGUsIG1hdGNoID0gJycsIGJyYWNlcyA9IDA7XG4gICAgICAgIGlmICh0ZXh0Lm1hdGNoKC9cXFxcP1ske31cXFxcXXxcXFxcXFwofFxcXFwoZXEpP3JlZlxccypcXHsvKSkge1xuICAgICAgICAgICAgd2hpbGUgKGkgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGMgPSB0ZXh0LmNoYXJBdChpKyspO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSAnJCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoID09PSAnJCcgJiYgYnJhY2VzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgWyhuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdCh0ZXh0LnNsaWNlKGssIGkgLSAxKSwge30sIHBhcnNlci5jb25maWd1cmF0aW9uKSkubW1sKCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1tbC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG1hdGNoID09PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGsgPCBpIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1tbC5wdXNoKGludGVybmFsVGV4dChwYXJzZXIsIHRleHQuc2xpY2UoaywgaSAtIDEpLCBkZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gJyQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ3snICYmIG1hdGNoICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICBicmFjZXMrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJ30nICYmIGJyYWNlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGF0b20gPSAobmV3IFRleFBhcnNlcl9qc18xLmRlZmF1bHQodGV4dC5zbGljZShrLCBpKSwge30sIHBhcnNlci5jb25maWd1cmF0aW9uKSkubW1sKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgW2F0b21dLCBkZWYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbW1sLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgayA9IGk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2ggIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhY2VzLS07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PT0gJycgJiYgdGV4dC5zdWJzdHIoaSkubWF0Y2goL14oZXEpP3JlZlxccypcXHsvKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IFJlZ0V4cFsnJCYnXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA8IGkgLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW1sLnB1c2goaW50ZXJuYWxUZXh0KHBhcnNlciwgdGV4dC5zbGljZShrLCBpIC0gMSksIGRlZikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAnfSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBrID0gaSAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGxlbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGMgPSB0ZXh0LmNoYXJBdChpKyspO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMgPT09ICcoJyAmJiBtYXRjaCA9PT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoayA8IGkgLSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1tbC5wdXNoKGludGVybmFsVGV4dChwYXJzZXIsIHRleHQuc2xpY2UoaywgaSAtIDIpLCBkZWYpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSAnKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgayA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjID09PSAnKScgJiYgbWF0Y2ggPT09ICcpJyAmJiBicmFjZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdUZVhBdG9tJywgWyhuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdCh0ZXh0LnNsaWNlKGssIGkgLSAyKSwge30sIHBhcnNlci5jb25maWd1cmF0aW9uKSkubW1sKCldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtbWwucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGsgPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoYy5tYXRjaCgvWyR7fVxcXFxdLykgJiYgbWF0Y2ggPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaS0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgPSB0ZXh0LnN1YnN0cigwLCBpIC0gMSkgKyB0ZXh0LnN1YnN0cihpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNYXRoTm90VGVybWluYXRlZCcsICdNYXRoIG5vdCB0ZXJtaW5hdGVkIGluIHRleHQgYm94Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGsgPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgbW1sLnB1c2goaW50ZXJuYWxUZXh0KHBhcnNlciwgdGV4dC5zbGljZShrKSwgZGVmKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxldmVsICE9IG51bGwpIHtcbiAgICAgICAgICAgIG1tbCA9IFtwYXJzZXIuY3JlYXRlKCdub2RlJywgJ21zdHlsZScsIG1tbCwgeyBkaXNwbGF5c3R5bGU6IGZhbHNlLCBzY3JpcHRsZXZlbDogbGV2ZWwgfSldO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1tbC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBtbWwgPSBbcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcm93JywgbW1sKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1tbDtcbiAgICB9XG4gICAgUGFyc2VVdGlsLmludGVybmFsTWF0aCA9IGludGVybmFsTWF0aDtcbiAgICBmdW5jdGlvbiBpbnRlcm5hbFRleHQocGFyc2VyLCB0ZXh0LCBkZWYpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZSgvXlxccysvLCBFbnRpdGllc19qc18xLmVudGl0aWVzLm5ic3ApLnJlcGxhY2UoL1xccyskLywgRW50aXRpZXNfanNfMS5lbnRpdGllcy5uYnNwKTtcbiAgICAgICAgdmFyIHRleHROb2RlID0gcGFyc2VyLmNyZWF0ZSgndGV4dCcsIHRleHQpO1xuICAgICAgICByZXR1cm4gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtdGV4dCcsIFtdLCBkZWYsIHRleHROb2RlKTtcbiAgICB9XG4gICAgUGFyc2VVdGlsLmludGVybmFsVGV4dCA9IGludGVybmFsVGV4dDtcbiAgICBmdW5jdGlvbiB1bmRlck92ZXIocGFyc2VyLCBiYXNlLCBzY3JpcHQsIHBvcywgc3RhY2spIHtcbiAgICAgICAgUGFyc2VVdGlsLmNoZWNrTW92YWJsZUxpbWl0cyhiYXNlKTtcbiAgICAgICAgaWYgKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5pc1R5cGUoYmFzZSwgJ211bmRlcm92ZXInKSAmJiBOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNFbWJlbGxpc2hlZChiYXNlKSkge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnRpZXMoTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldENvcmVNTyhiYXNlKSwgeyBsc3BhY2U6IDAsIHJzcGFjZTogMCB9KTtcbiAgICAgICAgICAgIHZhciBtbyA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbW8nLCBbXSwgeyByc3BhY2U6IDAgfSk7XG4gICAgICAgICAgICBiYXNlID0gcGFyc2VyLmNyZWF0ZSgnbm9kZScsICdtcm93JywgW21vLCBiYXNlXSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1tbCA9IHBhcnNlci5jcmVhdGUoJ25vZGUnLCAnbXVuZGVyb3ZlcicsIFtiYXNlXSk7XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRDaGlsZChtbWwsIHBvcyA9PT0gJ292ZXInID8gbW1sLm92ZXIgOiBtbWwudW5kZXIsIHNjcmlwdCk7XG4gICAgICAgIHZhciBub2RlID0gbW1sO1xuICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgIG5vZGUgPSBwYXJzZXIuY3JlYXRlKCdub2RlJywgJ1RlWEF0b20nLCBbbW1sXSwgeyB0ZXhDbGFzczogTW1sTm9kZV9qc18xLlRFWENMQVNTLk9QLCBtb3Zlc3Vwc3ViOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5zZXRQcm9wZXJ0eShub2RlLCAnc3Vic3VwT0snLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIFBhcnNlVXRpbC51bmRlck92ZXIgPSB1bmRlck92ZXI7XG4gICAgZnVuY3Rpb24gY2hlY2tNb3ZhYmxlTGltaXRzKGJhc2UpIHtcbiAgICAgICAgdmFyIHN5bWJvbCA9IChOb2RlVXRpbF9qc18xLmRlZmF1bHQuaXNUeXBlKGJhc2UsICdtbycpID8gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmdldEZvcm0oYmFzZSkgOiBudWxsKTtcbiAgICAgICAgaWYgKE5vZGVVdGlsX2pzXzEuZGVmYXVsdC5nZXRQcm9wZXJ0eShiYXNlLCAnbW92YWJsZWxpbWl0cycpIHx8IChzeW1ib2wgJiYgc3ltYm9sWzNdICYmIHN5bWJvbFszXS5tb3ZhYmxlbGltaXRzKSkge1xuICAgICAgICAgICAgTm9kZVV0aWxfanNfMS5kZWZhdWx0LnNldFByb3BlcnRpZXMoYmFzZSwgeyBtb3ZhYmxlbGltaXRzOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJzZVV0aWwuY2hlY2tNb3ZhYmxlTGltaXRzID0gY2hlY2tNb3ZhYmxlTGltaXRzO1xuICAgIGZ1bmN0aW9uIHRyaW1TcGFjZXModGV4dCkge1xuICAgICAgICBpZiAodHlwZW9mICh0ZXh0KSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIHZhciBURVhUID0gdGV4dC50cmltKCk7XG4gICAgICAgIGlmIChURVhULm1hdGNoKC9cXFxcJC8pICYmIHRleHQubWF0Y2goLyAkLykpIHtcbiAgICAgICAgICAgIFRFWFQgKz0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBURVhUO1xuICAgIH1cbiAgICBQYXJzZVV0aWwudHJpbVNwYWNlcyA9IHRyaW1TcGFjZXM7XG4gICAgZnVuY3Rpb24gc2V0QXJyYXlBbGlnbihhcnJheSwgYWxpZ24pIHtcbiAgICAgICAgYWxpZ24gPSBQYXJzZVV0aWwudHJpbVNwYWNlcyhhbGlnbiB8fCAnJyk7XG4gICAgICAgIGlmIChhbGlnbiA9PT0gJ3QnKSB7XG4gICAgICAgICAgICBhcnJheS5hcnJheWRlZi5hbGlnbiA9ICdiYXNlbGluZSAxJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhbGlnbiA9PT0gJ2InKSB7XG4gICAgICAgICAgICBhcnJheS5hcnJheWRlZi5hbGlnbiA9ICdiYXNlbGluZSAtMSc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxpZ24gPT09ICdjJykge1xuICAgICAgICAgICAgYXJyYXkuYXJyYXlkZWYuYWxpZ24gPSAnYXhpcyc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYWxpZ24pIHtcbiAgICAgICAgICAgIGFycmF5LmFycmF5ZGVmLmFsaWduID0gYWxpZ247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cbiAgICBQYXJzZVV0aWwuc2V0QXJyYXlBbGlnbiA9IHNldEFycmF5QWxpZ247XG4gICAgZnVuY3Rpb24gc3Vic3RpdHV0ZUFyZ3MocGFyc2VyLCBhcmdzLCBzdHIpIHtcbiAgICAgICAgdmFyIHRleHQgPSAnJztcbiAgICAgICAgdmFyIG5ld3N0cmluZyA9ICcnO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHdoaWxlIChpIDwgc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSBzdHIuY2hhckF0KGkrKyk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSBjICsgc3RyLmNoYXJBdChpKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgYyA9IHN0ci5jaGFyQXQoaSsrKTtcbiAgICAgICAgICAgICAgICBpZiAoYyA9PT0gJyMnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHQgKz0gYztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYy5tYXRjaCgvWzEtOV0vKSB8fCBwYXJzZUludChjLCAxMCkgPiBhcmdzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnSWxsZWdhbE1hY3JvUGFyYW0nLCAnSWxsZWdhbCBtYWNybyBwYXJhbWV0ZXIgcmVmZXJlbmNlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbmV3c3RyaW5nID0gYWRkQXJncyhwYXJzZXIsIGFkZEFyZ3MocGFyc2VyLCBuZXdzdHJpbmcsIHRleHQpLCBhcmdzW3BhcnNlSW50KGMsIDEwKSAtIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkQXJncyhwYXJzZXIsIG5ld3N0cmluZywgdGV4dCk7XG4gICAgfVxuICAgIFBhcnNlVXRpbC5zdWJzdGl0dXRlQXJncyA9IHN1YnN0aXR1dGVBcmdzO1xuICAgIGZ1bmN0aW9uIGFkZEFyZ3MocGFyc2VyLCBzMSwgczIpIHtcbiAgICAgICAgaWYgKHMyLm1hdGNoKC9eW2Etel0vaSkgJiYgczEubWF0Y2goLyhefFteXFxcXF0pKFxcXFxcXFxcKSpcXFxcW2Etel0rJC9pKSkge1xuICAgICAgICAgICAgczEgKz0gJyAnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMS5sZW5ndGggKyBzMi5sZW5ndGggPiBwYXJzZXIuY29uZmlndXJhdGlvbi5vcHRpb25zWydtYXhCdWZmZXInXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTWF4QnVmZmVyU2l6ZScsICdNYXRoSmF4IGludGVybmFsIGJ1ZmZlciBzaXplIGV4Y2VlZGVkOyBpcyB0aGVyZSBhJyArXG4gICAgICAgICAgICAgICAgJyByZWN1cnNpdmUgbWFjcm8gY2FsbD8nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gczEgKyBzMjtcbiAgICB9XG4gICAgUGFyc2VVdGlsLmFkZEFyZ3MgPSBhZGRBcmdzO1xuICAgIGZ1bmN0aW9uIGNoZWNrTWF4TWFjcm9zKHBhcnNlciwgaXNNYWNybykge1xuICAgICAgICBpZiAoaXNNYWNybyA9PT0gdm9pZCAwKSB7IGlzTWFjcm8gPSB0cnVlOyB9XG4gICAgICAgIGlmICgrK3BhcnNlci5tYWNyb0NvdW50IDw9IHBhcnNlci5jb25maWd1cmF0aW9uLm9wdGlvbnNbJ21heE1hY3JvcyddKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzTWFjcm8pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01heE1hY3JvU3ViMScsICdNYXRoSmF4IG1heGltdW0gbWFjcm8gc3Vic3RpdHV0aW9uIGNvdW50IGV4Y2VlZGVkOyAnICtcbiAgICAgICAgICAgICAgICAnaXMgaGVyZSBhIHJlY3Vyc2l2ZSBtYWNybyBjYWxsPycpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTWF4TWFjcm9TdWIyJywgJ01hdGhKYXggbWF4aW11bSBzdWJzdGl0dXRpb24gY291bnQgZXhjZWVkZWQ7ICcgK1xuICAgICAgICAgICAgICAgICdpcyB0aGVyZSBhIHJlY3Vyc2l2ZSBsYXRleCBlbnZpcm9ubWVudD8nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBQYXJzZVV0aWwuY2hlY2tNYXhNYWNyb3MgPSBjaGVja01heE1hY3JvcztcbiAgICBmdW5jdGlvbiBjaGVja0VxbkVudihwYXJzZXIpIHtcbiAgICAgICAgaWYgKHBhcnNlci5zdGFjay5nbG9iYWwuZXFuZW52KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdFcnJvbmVvdXNOZXN0aW5nRXEnLCAnRXJyb25lb3VzIG5lc3Rpbmcgb2YgZXF1YXRpb24gc3RydWN0dXJlcycpO1xuICAgICAgICB9XG4gICAgICAgIHBhcnNlci5zdGFjay5nbG9iYWwuZXFuZW52ID0gdHJ1ZTtcbiAgICB9XG4gICAgUGFyc2VVdGlsLmNoZWNrRXFuRW52ID0gY2hlY2tFcW5FbnY7XG4gICAgZnVuY3Rpb24gY29weU5vZGUobm9kZSwgcGFyc2VyKSB7XG4gICAgICAgIHZhciB0cmVlID0gbm9kZS5jb3B5KCk7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyc2VyLmNvbmZpZ3VyYXRpb247XG4gICAgICAgIHRyZWUud2Fsa1RyZWUoZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICAgICAgb3B0aW9ucy5hZGROb2RlKG4ua2luZCwgbik7XG4gICAgICAgICAgICB2YXIgbGlzdHMgPSAobi5nZXRQcm9wZXJ0eSgnaW4tbGlzdHMnKSB8fCAnJykuc3BsaXQoLywvKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGlzdHNfMSA9IF9fdmFsdWVzKGxpc3RzKSwgbGlzdHNfMV8xID0gbGlzdHNfMS5uZXh0KCk7ICFsaXN0c18xXzEuZG9uZTsgbGlzdHNfMV8xID0gbGlzdHNfMS5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxpc3QgPSBsaXN0c18xXzEudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGxpc3QgJiYgb3B0aW9ucy5hZGROb2RlKGxpc3QsIG4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobGlzdHNfMV8xICYmICFsaXN0c18xXzEuZG9uZSAmJiAoX2EgPSBsaXN0c18xLnJldHVybikpIF9hLmNhbGwobGlzdHNfMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cmVlO1xuICAgIH1cbiAgICBQYXJzZVV0aWwuY29weU5vZGUgPSBjb3B5Tm9kZTtcbiAgICBmdW5jdGlvbiBNbWxGaWx0ZXJBdHRyaWJ1dGUoX3BhcnNlciwgX25hbWUsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgUGFyc2VVdGlsLk1tbEZpbHRlckF0dHJpYnV0ZSA9IE1tbEZpbHRlckF0dHJpYnV0ZTtcbiAgICBmdW5jdGlvbiBnZXRGb250RGVmKHBhcnNlcikge1xuICAgICAgICB2YXIgZm9udCA9IHBhcnNlci5zdGFjay5lbnZbJ2ZvbnQnXTtcbiAgICAgICAgcmV0dXJuIChmb250ID8geyBtYXRodmFyaWFudDogZm9udCB9IDoge30pO1xuICAgIH1cbiAgICBQYXJzZVV0aWwuZ2V0Rm9udERlZiA9IGdldEZvbnREZWY7XG4gICAgZnVuY3Rpb24ga2V5dmFsT3B0aW9ucyhhdHRyaWIsIGFsbG93ZWQsIGVycm9yKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICBpZiAoYWxsb3dlZCA9PT0gdm9pZCAwKSB7IGFsbG93ZWQgPSBudWxsOyB9XG4gICAgICAgIGlmIChlcnJvciA9PT0gdm9pZCAwKSB7IGVycm9yID0gZmFsc2U7IH1cbiAgICAgICAgdmFyIGRlZiA9IHJlYWRLZXl2YWwoYXR0cmliKTtcbiAgICAgICAgaWYgKGFsbG93ZWQpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhkZWYpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dlZC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdJbnZhbGlkT3B0aW9uJywgJ0ludmFsaWQgb3B0aW9uOiAlMScsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgZGVmW2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZjtcbiAgICB9XG4gICAgUGFyc2VVdGlsLmtleXZhbE9wdGlvbnMgPSBrZXl2YWxPcHRpb25zO1xuICAgIGZ1bmN0aW9uIHJlYWRLZXl2YWwodGV4dCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHt9O1xuICAgICAgICB2YXIgcmVzdCA9IHRleHQ7XG4gICAgICAgIHZhciBlbmQsIGtleSwgdmFsO1xuICAgICAgICB3aGlsZSAocmVzdCkge1xuICAgICAgICAgICAgX2EgPSBfX3JlYWQocmVhZFZhbHVlKHJlc3QsIFsnPScsICcsJ10pLCAzKSwga2V5ID0gX2FbMF0sIGVuZCA9IF9hWzFdLCByZXN0ID0gX2FbMl07XG4gICAgICAgICAgICBpZiAoZW5kID09PSAnPScpIHtcbiAgICAgICAgICAgICAgICBfYiA9IF9fcmVhZChyZWFkVmFsdWUocmVzdCwgWycsJ10pLCAzKSwgdmFsID0gX2JbMF0sIGVuZCA9IF9iWzFdLCByZXN0ID0gX2JbMl07XG4gICAgICAgICAgICAgICAgdmFsID0gKHZhbCA9PT0gJ2ZhbHNlJyB8fCB2YWwgPT09ICd0cnVlJykgP1xuICAgICAgICAgICAgICAgICAgICBKU09OLnBhcnNlKHZhbCkgOiB2YWw7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgb3B0aW9uc1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQnJhY2VzKHRleHQsIGNvdW50KSB7XG4gICAgICAgIHdoaWxlIChjb3VudCA+IDApIHtcbiAgICAgICAgICAgIHRleHQgPSB0ZXh0LnRyaW0oKS5zbGljZSgxLCAtMSk7XG4gICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0LnRyaW0oKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVhZFZhbHVlKHRleHQsIGVuZCkge1xuICAgICAgICB2YXIgbGVuZ3RoID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIHZhciBicmFjZXMgPSAwO1xuICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0ID0gMDtcbiAgICAgICAgdmFyIHN0YXJ0Q291bnQgPSB0cnVlO1xuICAgICAgICB2YXIgc3RvcENvdW50ID0gZmFsc2U7XG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIGMgPSB0ZXh0W2luZGV4KytdO1xuICAgICAgICAgICAgc3dpdGNoIChjKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnICc6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQrKztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0b3BDb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXJ0ID4gYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnQgPSBicmFjZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJhY2VzKys7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ30nOlxuICAgICAgICAgICAgICAgICAgICBpZiAoYnJhY2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmFjZXMtLTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhcnRDb3VudCB8fCBzdG9wQ291bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9wQ291bnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0Q291bnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFicmFjZXMgJiYgZW5kLmluZGV4T2YoYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3N0b3BDb3VudCA/ICd0cnVlJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZUJyYWNlcyh2YWx1ZSwgc3RhcnQpLCBjLCB0ZXh0LnNsaWNlKGluZGV4KV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb3VudCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBzdG9wQ291bnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlICs9IGM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJyYWNlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnRXh0cmFPcGVuTWlzc2luZ0Nsb3NlJywgJ0V4dHJhIG9wZW4gYnJhY2Ugb3IgbWlzc2luZyBjbG9zZSBicmFjZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbc3RvcENvdW50ID8gJ3RydWUnIDogcmVtb3ZlQnJhY2VzKHZhbHVlLCBzdGFydCksICcnLCB0ZXh0LnNsaWNlKGluZGV4KV07XG4gICAgfVxufSkoUGFyc2VVdGlsIHx8IChQYXJzZVV0aWwgPSB7fSkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUGFyc2VVdGlsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFyc2VVdGlsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9fcmVhZCA9ICh0aGlzICYmIHRoaXMuX19yZWFkKSB8fCBmdW5jdGlvbiAobywgbikge1xuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcbiAgICBpZiAoIW0pIHJldHVybiBvO1xuICAgIHZhciBpID0gbS5jYWxsKG8pLCByLCBhciA9IFtdLCBlO1xuICAgIHRyeSB7XG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cbiAgICBmaW5hbGx5IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkgeyBpZiAoZSkgdGhyb3cgZS5lcnJvcjsgfVxuICAgIH1cbiAgICByZXR1cm4gYXI7XG59O1xudmFyIF9fc3ByZWFkQXJyYXkgPSAodGhpcyAmJiB0aGlzLl9fc3ByZWFkQXJyYXkpIHx8IGZ1bmN0aW9uICh0bywgZnJvbSwgcGFjaykge1xuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tKSk7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIE5vZGVVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vTm9kZVV0aWwuanNcIikpO1xudmFyIFN0YWNrID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBTdGFjayhfZmFjdG9yeSwgX2VudiwgaW5uZXIpIHtcbiAgICAgICAgdGhpcy5fZmFjdG9yeSA9IF9mYWN0b3J5O1xuICAgICAgICB0aGlzLl9lbnYgPSBfZW52O1xuICAgICAgICB0aGlzLmdsb2JhbCA9IHt9O1xuICAgICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICAgIHRoaXMuZ2xvYmFsID0geyBpc0lubmVyOiBpbm5lciB9O1xuICAgICAgICB0aGlzLnN0YWNrID0gW3RoaXMuX2ZhY3RvcnkuY3JlYXRlKCdzdGFydCcsIHRoaXMuZ2xvYmFsKV07XG4gICAgICAgIGlmIChfZW52KSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrWzBdLmVudiA9IF9lbnY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbnYgPSB0aGlzLnN0YWNrWzBdLmVudjtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN0YWNrLnByb3RvdHlwZSwgXCJlbnZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9lbnY7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKGVudikge1xuICAgICAgICAgICAgdGhpcy5fZW52ID0gZW52O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgU3RhY2sucHJvdG90eXBlLlB1c2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBhcmdzXzEgPSBfX3ZhbHVlcyhhcmdzKSwgYXJnc18xXzEgPSBhcmdzXzEubmV4dCgpOyAhYXJnc18xXzEuZG9uZTsgYXJnc18xXzEgPSBhcmdzXzEubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBhcmdzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBpdGVtID0gTm9kZVV0aWxfanNfMS5kZWZhdWx0LmlzTm9kZShub2RlKSA/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhY3RvcnkuY3JlYXRlKCdtbWwnLCBub2RlKSA6IG5vZGU7XG4gICAgICAgICAgICAgICAgaXRlbS5nbG9iYWwgPSB0aGlzLmdsb2JhbDtcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBfX3JlYWQodGhpcy5zdGFjay5sZW5ndGggPyB0aGlzLlRvcCgpLmNoZWNrSXRlbShpdGVtKSA6IFtudWxsLCB0cnVlXSwgMiksIHRvcF8xID0gX2JbMF0sIHN1Y2Nlc3MgPSBfYlsxXTtcbiAgICAgICAgICAgICAgICBpZiAoIXN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0b3BfMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlBvcCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLlB1c2guYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKHRvcF8xKSwgZmFsc2UpKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5lbnYpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uY29weUVudikge1xuICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihpdGVtLmVudiwgdGhpcy5lbnYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW52ID0gaXRlbS5lbnY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmVudiA9IHRoaXMuZW52O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NfMV8xICYmICFhcmdzXzFfMS5kb25lICYmIChfYSA9IGFyZ3NfMS5yZXR1cm4pKSBfYS5jYWxsKGFyZ3NfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFN0YWNrLnByb3RvdHlwZS5Qb3AgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpdGVtID0gdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKCFpdGVtLmlzT3Blbikge1xuICAgICAgICAgICAgZGVsZXRlIGl0ZW0uZW52O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW52ID0gKHRoaXMuc3RhY2subGVuZ3RoID8gdGhpcy5Ub3AoKS5lbnYgOiB7fSk7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH07XG4gICAgU3RhY2sucHJvdG90eXBlLlRvcCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIGlmIChuID09PSB2b2lkIDApIHsgbiA9IDE7IH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2subGVuZ3RoIDwgbiA/IG51bGwgOiB0aGlzLnN0YWNrW3RoaXMuc3RhY2subGVuZ3RoIC0gbl07XG4gICAgfTtcbiAgICBTdGFjay5wcm90b3R5cGUuUHJldiA9IGZ1bmN0aW9uIChub1BvcCkge1xuICAgICAgICB2YXIgdG9wID0gdGhpcy5Ub3AoKTtcbiAgICAgICAgcmV0dXJuIG5vUG9wID8gdG9wLkZpcnN0IDogdG9wLlBvcCgpO1xuICAgIH07XG4gICAgU3RhY2sucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gJ3N0YWNrW1xcbiAgJyArIHRoaXMuc3RhY2suam9pbignXFxuICAnKSArICdcXG5dJztcbiAgICB9O1xuICAgIHJldHVybiBTdGFjaztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGFjaztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN0YWNrLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NYWNybyA9IGV4cG9ydHMuU3ltYm9sID0gdm9pZCAwO1xudmFyIFN5bWJvbCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU3ltYm9sKF9zeW1ib2wsIF9jaGFyLCBfYXR0cmlidXRlcykge1xuICAgICAgICB0aGlzLl9zeW1ib2wgPSBfc3ltYm9sO1xuICAgICAgICB0aGlzLl9jaGFyID0gX2NoYXI7XG4gICAgICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBfYXR0cmlidXRlcztcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsIFwic3ltYm9sXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc3ltYm9sO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFN5bWJvbC5wcm90b3R5cGUsIFwiY2hhclwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2NoYXI7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoU3ltYm9sLnByb3RvdHlwZSwgXCJhdHRyaWJ1dGVzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYXR0cmlidXRlcztcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBTeW1ib2w7XG59KCkpO1xuZXhwb3J0cy5TeW1ib2wgPSBTeW1ib2w7XG52YXIgTWFjcm8gPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1hY3JvKF9zeW1ib2wsIF9mdW5jLCBfYXJncykge1xuICAgICAgICBpZiAoX2FyZ3MgPT09IHZvaWQgMCkgeyBfYXJncyA9IFtdOyB9XG4gICAgICAgIHRoaXMuX3N5bWJvbCA9IF9zeW1ib2w7XG4gICAgICAgIHRoaXMuX2Z1bmMgPSBfZnVuYztcbiAgICAgICAgdGhpcy5fYXJncyA9IF9hcmdzO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFjcm8ucHJvdG90eXBlLCBcInN5bWJvbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N5bWJvbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYWNyby5wcm90b3R5cGUsIFwiZnVuY1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2Z1bmM7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFjcm8ucHJvdG90eXBlLCBcImFyZ3NcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hcmdzO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIE1hY3JvO1xufSgpKTtcbmV4cG9ydHMuTWFjcm8gPSBNYWNybztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN5bWJvbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkVudmlyb25tZW50TWFwID0gZXhwb3J0cy5Db21tYW5kTWFwID0gZXhwb3J0cy5NYWNyb01hcCA9IGV4cG9ydHMuRGVsaW1pdGVyTWFwID0gZXhwb3J0cy5DaGFyYWN0ZXJNYXAgPSBleHBvcnRzLkFic3RyYWN0UGFyc2VNYXAgPSBleHBvcnRzLlJlZ0V4cE1hcCA9IGV4cG9ydHMuQWJzdHJhY3RTeW1ib2xNYXAgPSBleHBvcnRzLnBhcnNlUmVzdWx0ID0gdm9pZCAwO1xudmFyIFN5bWJvbF9qc18xID0gcmVxdWlyZShcIi4vU3ltYm9sLmpzXCIpO1xudmFyIE1hcEhhbmRsZXJfanNfMSA9IHJlcXVpcmUoXCIuL01hcEhhbmRsZXIuanNcIik7XG5mdW5jdGlvbiBwYXJzZVJlc3VsdChyZXN1bHQpIHtcbiAgICByZXR1cm4gcmVzdWx0ID09PSB2b2lkIDAgPyB0cnVlIDogcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZVJlc3VsdCA9IHBhcnNlUmVzdWx0O1xudmFyIEFic3RyYWN0U3ltYm9sTWFwID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFN5bWJvbE1hcChfbmFtZSwgX3BhcnNlcikge1xuICAgICAgICB0aGlzLl9uYW1lID0gX25hbWU7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IF9wYXJzZXI7XG4gICAgICAgIE1hcEhhbmRsZXJfanNfMS5NYXBIYW5kbGVyLnJlZ2lzdGVyKHRoaXMpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RTeW1ib2xNYXAucHJvdG90eXBlLCBcIm5hbWVcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RTeW1ib2xNYXAucHJvdG90eXBlLnBhcnNlckZvciA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGFpbnMoc3ltYm9sKSA/IHRoaXMucGFyc2VyIDogbnVsbDtcbiAgICB9O1xuICAgIEFic3RyYWN0U3ltYm9sTWFwLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBlbnYgPSBfYlswXSwgc3ltYm9sID0gX2JbMV07XG4gICAgICAgIHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlckZvcihzeW1ib2wpO1xuICAgICAgICB2YXIgbWFwcGVkID0gdGhpcy5sb29rdXAoc3ltYm9sKTtcbiAgICAgICAgcmV0dXJuIChwYXJzZXIgJiYgbWFwcGVkKSA/IHBhcnNlUmVzdWx0KHBhcnNlcihlbnYsIG1hcHBlZCkpIDogbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShBYnN0cmFjdFN5bWJvbE1hcC5wcm90b3R5cGUsIFwicGFyc2VyXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGFyc2VyO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChwYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcnNlciA9IHBhcnNlcjtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiBBYnN0cmFjdFN5bWJvbE1hcDtcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0U3ltYm9sTWFwID0gQWJzdHJhY3RTeW1ib2xNYXA7XG52YXIgUmVnRXhwTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoUmVnRXhwTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFJlZ0V4cE1hcChuYW1lLCBwYXJzZXIsIF9yZWdFeHApIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgcGFyc2VyKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5fcmVnRXhwID0gX3JlZ0V4cDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBSZWdFeHBNYXAucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVnRXhwLnRlc3Qoc3ltYm9sKTtcbiAgICB9O1xuICAgIFJlZ0V4cE1hcC5wcm90b3R5cGUubG9va3VwID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250YWlucyhzeW1ib2wpID8gc3ltYm9sIDogbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBSZWdFeHBNYXA7XG59KEFic3RyYWN0U3ltYm9sTWFwKSk7XG5leHBvcnRzLlJlZ0V4cE1hcCA9IFJlZ0V4cE1hcDtcbnZhciBBYnN0cmFjdFBhcnNlTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQWJzdHJhY3RQYXJzZU1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFBhcnNlTWFwKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMubWFwID0gbmV3IE1hcCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEFic3RyYWN0UGFyc2VNYXAucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFwLmdldChzeW1ib2wpO1xuICAgIH07XG4gICAgQWJzdHJhY3RQYXJzZU1hcC5wcm90b3R5cGUuY29udGFpbnMgPSBmdW5jdGlvbiAoc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hcC5oYXMoc3ltYm9sKTtcbiAgICB9O1xuICAgIEFic3RyYWN0UGFyc2VNYXAucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChzeW1ib2wsIG9iamVjdCkge1xuICAgICAgICB0aGlzLm1hcC5zZXQoc3ltYm9sLCBvYmplY3QpO1xuICAgIH07XG4gICAgQWJzdHJhY3RQYXJzZU1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICB0aGlzLm1hcC5kZWxldGUoc3ltYm9sKTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdFBhcnNlTWFwO1xufShBYnN0cmFjdFN5bWJvbE1hcCkpO1xuZXhwb3J0cy5BYnN0cmFjdFBhcnNlTWFwID0gQWJzdHJhY3RQYXJzZU1hcDtcbnZhciBDaGFyYWN0ZXJNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhDaGFyYWN0ZXJNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhcmFjdGVyTWFwKG5hbWUsIHBhcnNlciwganNvbikge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbmFtZSwgcGFyc2VyKSB8fCB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhqc29uKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ganNvbltrZXldO1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZCgodHlwZW9mICh2YWx1ZSkgPT09ICdzdHJpbmcnKSA/IFt2YWx1ZSwgbnVsbF0gOiB2YWx1ZSwgMiksIGNoYXIgPSBfZFswXSwgYXR0cnMgPSBfZFsxXTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gbmV3IFN5bWJvbF9qc18xLlN5bWJvbChrZXksIGNoYXIsIGF0dHJzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGQoa2V5LCBjaGFyYWN0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gQ2hhcmFjdGVyTWFwO1xufShBYnN0cmFjdFBhcnNlTWFwKSk7XG5leHBvcnRzLkNoYXJhY3Rlck1hcCA9IENoYXJhY3Rlck1hcDtcbnZhciBEZWxpbWl0ZXJNYXAgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhEZWxpbWl0ZXJNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRGVsaW1pdGVyTWFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIERlbGltaXRlck1hcC5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgdmFyIF9iID0gX19yZWFkKF9hLCAyKSwgZW52ID0gX2JbMF0sIHN5bWJvbCA9IF9iWzFdO1xuICAgICAgICByZXR1cm4gX3N1cGVyLnByb3RvdHlwZS5wYXJzZS5jYWxsKHRoaXMsIFtlbnYsICdcXFxcJyArIHN5bWJvbF0pO1xuICAgIH07XG4gICAgcmV0dXJuIERlbGltaXRlck1hcDtcbn0oQ2hhcmFjdGVyTWFwKSk7XG5leHBvcnRzLkRlbGltaXRlck1hcCA9IERlbGltaXRlck1hcDtcbnZhciBNYWNyb01hcCA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1hY3JvTWFwLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1hY3JvTWFwKG5hbWUsIGpzb24sIGZ1bmN0aW9uTWFwKSB7XG4gICAgICAgIHZhciBlXzIsIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBudWxsKSB8fCB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhqc29uKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlID0ganNvbltrZXldO1xuICAgICAgICAgICAgICAgIHZhciBfZCA9IF9fcmVhZCgodHlwZW9mICh2YWx1ZSkgPT09ICdzdHJpbmcnKSA/IFt2YWx1ZV0gOiB2YWx1ZSksIGZ1bmMgPSBfZFswXSwgYXR0cnMgPSBfZC5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICB2YXIgY2hhcmFjdGVyID0gbmV3IFN5bWJvbF9qc18xLk1hY3JvKGtleSwgZnVuY3Rpb25NYXBbZnVuY10sIGF0dHJzKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5hZGQoa2V5LCBjaGFyYWN0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlXzJfMSkgeyBlXzIgPSB7IGVycm9yOiBlXzJfMSB9OyB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMikgdGhyb3cgZV8yLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBNYWNyb01hcC5wcm90b3R5cGUucGFyc2VyRm9yID0gZnVuY3Rpb24gKHN5bWJvbCkge1xuICAgICAgICB2YXIgbWFjcm8gPSB0aGlzLmxvb2t1cChzeW1ib2wpO1xuICAgICAgICByZXR1cm4gbWFjcm8gPyBtYWNyby5mdW5jIDogbnVsbDtcbiAgICB9O1xuICAgIE1hY3JvTWFwLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBlbnYgPSBfYlswXSwgc3ltYm9sID0gX2JbMV07XG4gICAgICAgIHZhciBtYWNybyA9IHRoaXMubG9va3VwKHN5bWJvbCk7XG4gICAgICAgIHZhciBwYXJzZXIgPSB0aGlzLnBhcnNlckZvcihzeW1ib2wpO1xuICAgICAgICBpZiAoIW1hY3JvIHx8ICFwYXJzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3VsdChwYXJzZXIuYXBwbHkodm9pZCAwLCBfX3NwcmVhZEFycmF5KFtlbnYsIG1hY3JvLnN5bWJvbF0sIF9fcmVhZChtYWNyby5hcmdzKSwgZmFsc2UpKSk7XG4gICAgfTtcbiAgICByZXR1cm4gTWFjcm9NYXA7XG59KEFic3RyYWN0UGFyc2VNYXApKTtcbmV4cG9ydHMuTWFjcm9NYXAgPSBNYWNyb01hcDtcbnZhciBDb21tYW5kTWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoQ29tbWFuZE1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21tYW5kTWFwKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIENvbW1hbmRNYXAucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgIHZhciBfYiA9IF9fcmVhZChfYSwgMiksIGVudiA9IF9iWzBdLCBzeW1ib2wgPSBfYlsxXTtcbiAgICAgICAgdmFyIG1hY3JvID0gdGhpcy5sb29rdXAoc3ltYm9sKTtcbiAgICAgICAgdmFyIHBhcnNlciA9IHRoaXMucGFyc2VyRm9yKHN5bWJvbCk7XG4gICAgICAgIGlmICghbWFjcm8gfHwgIXBhcnNlcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNhdmVDb21tYW5kID0gZW52LmN1cnJlbnRDUztcbiAgICAgICAgZW52LmN1cnJlbnRDUyA9ICdcXFxcJyArIHN5bWJvbDtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlci5hcHBseSh2b2lkIDAsIF9fc3ByZWFkQXJyYXkoW2VudiwgJ1xcXFwnICsgbWFjcm8uc3ltYm9sXSwgX19yZWFkKG1hY3JvLmFyZ3MpLCBmYWxzZSkpO1xuICAgICAgICBlbnYuY3VycmVudENTID0gc2F2ZUNvbW1hbmQ7XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3VsdChyZXN1bHQpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbW1hbmRNYXA7XG59KE1hY3JvTWFwKSk7XG5leHBvcnRzLkNvbW1hbmRNYXAgPSBDb21tYW5kTWFwO1xudmFyIEVudmlyb25tZW50TWFwID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoRW52aXJvbm1lbnRNYXAsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRW52aXJvbm1lbnRNYXAobmFtZSwgcGFyc2VyLCBqc29uLCBmdW5jdGlvbk1hcCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBuYW1lLCBqc29uLCBmdW5jdGlvbk1hcCkgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGFyc2VyID0gcGFyc2VyO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEVudmlyb25tZW50TWFwLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgX2IgPSBfX3JlYWQoX2EsIDIpLCBlbnYgPSBfYlswXSwgc3ltYm9sID0gX2JbMV07XG4gICAgICAgIHZhciBtYWNybyA9IHRoaXMubG9va3VwKHN5bWJvbCk7XG4gICAgICAgIHZhciBlbnZQYXJzZXIgPSB0aGlzLnBhcnNlckZvcihzeW1ib2wpO1xuICAgICAgICBpZiAoIW1hY3JvIHx8ICFlbnZQYXJzZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJzZVJlc3VsdCh0aGlzLnBhcnNlcihlbnYsIG1hY3JvLnN5bWJvbCwgZW52UGFyc2VyLCBtYWNyby5hcmdzKSk7XG4gICAgfTtcbiAgICByZXR1cm4gRW52aXJvbm1lbnRNYXA7XG59KE1hY3JvTWFwKSk7XG5leHBvcnRzLkVudmlyb25tZW50TWFwID0gRW52aXJvbm1lbnRNYXA7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TeW1ib2xNYXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19leHRlbmRzID0gKHRoaXMgJiYgdGhpcy5fX2V4dGVuZHMpIHx8IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XG4gICAgICAgICAgICAoeyBfX3Byb3RvX186IFtdIH0gaW5zdGFuY2VvZiBBcnJheSAmJiBmdW5jdGlvbiAoZCwgYikgeyBkLl9fcHJvdG9fXyA9IGI7IH0pIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xuICAgICAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZCwgYikge1xuICAgICAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xuICAgICAgICBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cbiAgICAgICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xuICAgIH07XG59KSgpO1xudmFyIF9fdmFsdWVzID0gKHRoaXMgJiYgdGhpcy5fX3ZhbHVlcykgfHwgZnVuY3Rpb24obykge1xuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XG4gICAgaWYgKG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcIm51bWJlclwiKSByZXR1cm4ge1xuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKHMgPyBcIk9iamVjdCBpcyBub3QgaXRlcmFibGUuXCIgOiBcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UYWdzRmFjdG9yeSA9IGV4cG9ydHMuQWxsVGFncyA9IGV4cG9ydHMuTm9UYWdzID0gZXhwb3J0cy5BYnN0cmFjdFRhZ3MgPSBleHBvcnRzLlRhZ0luZm8gPSBleHBvcnRzLkxhYmVsID0gdm9pZCAwO1xudmFyIFRleFBhcnNlcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1RleFBhcnNlci5qc1wiKSk7XG52YXIgTGFiZWwgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExhYmVsKHRhZywgaWQpIHtcbiAgICAgICAgaWYgKHRhZyA9PT0gdm9pZCAwKSB7IHRhZyA9ICc/Pz8nOyB9XG4gICAgICAgIGlmIChpZCA9PT0gdm9pZCAwKSB7IGlkID0gJyc7IH1cbiAgICAgICAgdGhpcy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgcmV0dXJuIExhYmVsO1xufSgpKTtcbmV4cG9ydHMuTGFiZWwgPSBMYWJlbDtcbnZhciBUYWdJbmZvID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUYWdJbmZvKGVudiwgdGFnZ2FibGUsIGRlZmF1bHRUYWdzLCB0YWcsIHRhZ0lkLCB0YWdGb3JtYXQsIG5vVGFnLCBsYWJlbElkKSB7XG4gICAgICAgIGlmIChlbnYgPT09IHZvaWQgMCkgeyBlbnYgPSAnJzsgfVxuICAgICAgICBpZiAodGFnZ2FibGUgPT09IHZvaWQgMCkgeyB0YWdnYWJsZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChkZWZhdWx0VGFncyA9PT0gdm9pZCAwKSB7IGRlZmF1bHRUYWdzID0gZmFsc2U7IH1cbiAgICAgICAgaWYgKHRhZyA9PT0gdm9pZCAwKSB7IHRhZyA9IG51bGw7IH1cbiAgICAgICAgaWYgKHRhZ0lkID09PSB2b2lkIDApIHsgdGFnSWQgPSAnJzsgfVxuICAgICAgICBpZiAodGFnRm9ybWF0ID09PSB2b2lkIDApIHsgdGFnRm9ybWF0ID0gJyc7IH1cbiAgICAgICAgaWYgKG5vVGFnID09PSB2b2lkIDApIHsgbm9UYWcgPSBmYWxzZTsgfVxuICAgICAgICBpZiAobGFiZWxJZCA9PT0gdm9pZCAwKSB7IGxhYmVsSWQgPSAnJzsgfVxuICAgICAgICB0aGlzLmVudiA9IGVudjtcbiAgICAgICAgdGhpcy50YWdnYWJsZSA9IHRhZ2dhYmxlO1xuICAgICAgICB0aGlzLmRlZmF1bHRUYWdzID0gZGVmYXVsdFRhZ3M7XG4gICAgICAgIHRoaXMudGFnID0gdGFnO1xuICAgICAgICB0aGlzLnRhZ0lkID0gdGFnSWQ7XG4gICAgICAgIHRoaXMudGFnRm9ybWF0ID0gdGFnRm9ybWF0O1xuICAgICAgICB0aGlzLm5vVGFnID0gbm9UYWc7XG4gICAgICAgIHRoaXMubGFiZWxJZCA9IGxhYmVsSWQ7XG4gICAgfVxuICAgIHJldHVybiBUYWdJbmZvO1xufSgpKTtcbmV4cG9ydHMuVGFnSW5mbyA9IFRhZ0luZm87XG52YXIgQWJzdHJhY3RUYWdzID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFRhZ3MoKSB7XG4gICAgICAgIHRoaXMuY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuYWxsQ291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbiA9IG51bGw7XG4gICAgICAgIHRoaXMuaWRzID0ge307XG4gICAgICAgIHRoaXMuYWxsSWRzID0ge307XG4gICAgICAgIHRoaXMubGFiZWxzID0ge307XG4gICAgICAgIHRoaXMuYWxsTGFiZWxzID0ge307XG4gICAgICAgIHRoaXMucmVkbyA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlZlVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnJlbnRUYWcgPSBuZXcgVGFnSW5mbygpO1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5zdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmVuVGFnID0gZnVuY3Rpb24gKG5vZGUsIHRhZykge1xuICAgICAgICAgICAgdmFyIG5mID0gdGhpcy5jb25maWd1cmF0aW9uLm5vZGVGYWN0b3J5O1xuICAgICAgICAgICAgdmFyIGNlbGwgPSBuZi5jcmVhdGUoJ25vZGUnLCAnbXRkJywgW25vZGVdKTtcbiAgICAgICAgICAgIHZhciByb3cgPSBuZi5jcmVhdGUoJ25vZGUnLCAnbWxhYmVsZWR0cicsIFt0YWcsIGNlbGxdKTtcbiAgICAgICAgICAgIHZhciB0YWJsZSA9IG5mLmNyZWF0ZSgnbm9kZScsICdtdGFibGUnLCBbcm93XSwge1xuICAgICAgICAgICAgICAgIHNpZGU6IHRoaXMuY29uZmlndXJhdGlvbi5vcHRpb25zWyd0YWdTaWRlJ10sXG4gICAgICAgICAgICAgICAgbWlubGFiZWxzcGFjaW5nOiB0aGlzLmNvbmZpZ3VyYXRpb24ub3B0aW9uc1sndGFnSW5kZW50J10sXG4gICAgICAgICAgICAgICAgZGlzcGxheXN0eWxlOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0YWJsZTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5zdGFydCA9IGZ1bmN0aW9uIChlbnYsIHRhZ2dhYmxlLCBkZWZhdWx0VGFncykge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGFnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2godGhpcy5jdXJyZW50VGFnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRUYWcgPSBuZXcgVGFnSW5mbyhlbnYsIHRhZ2dhYmxlLCBkZWZhdWx0VGFncyk7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RUYWdzLnByb3RvdHlwZSwgXCJlbnZcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUYWcuZW52O1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeS5wdXNoKHRoaXMuY3VycmVudFRhZyk7XG4gICAgICAgIHRoaXMuY3VycmVudFRhZyA9IHRoaXMuc3RhY2sucG9wKCk7XG4gICAgfTtcbiAgICBBYnN0cmFjdFRhZ3MucHJvdG90eXBlLnRhZyA9IGZ1bmN0aW9uICh0YWcsIG5vRm9ybWF0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudFRhZy50YWcgPSB0YWc7XG4gICAgICAgIHRoaXMuY3VycmVudFRhZy50YWdGb3JtYXQgPSBub0Zvcm1hdCA/IHRhZyA6IHRoaXMuZm9ybWF0VGFnKHRhZyk7XG4gICAgICAgIHRoaXMuY3VycmVudFRhZy5ub1RhZyA9IGZhbHNlO1xuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5ub3RhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50YWcoJycsIHRydWUpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUYWcubm9UYWcgPSB0cnVlO1xuICAgIH07XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEFic3RyYWN0VGFncy5wcm90b3R5cGUsIFwibm9UYWdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRUYWcubm9UYWc7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQWJzdHJhY3RUYWdzLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFRhZy5sYWJlbElkO1xuICAgICAgICB9LFxuICAgICAgICBzZXQ6IGZ1bmN0aW9uIChsYWJlbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGFnLmxhYmVsSWQgPSBsYWJlbDtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIEFic3RyYWN0VGFncy5wcm90b3R5cGUuZm9ybWF0VXJsID0gZnVuY3Rpb24gKGlkLCBiYXNlKSB7XG4gICAgICAgIHJldHVybiBiYXNlICsgJyMnICsgZW5jb2RlVVJJQ29tcG9uZW50KGlkKTtcbiAgICB9O1xuICAgIEFic3RyYWN0VGFncy5wcm90b3R5cGUuZm9ybWF0VGFnID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICByZXR1cm4gJygnICsgdGFnICsgJyknO1xuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5mb3JtYXRJZCA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICByZXR1cm4gJ21qeC1lcW46JyArIGlkLnJlcGxhY2UoL1xccy9nLCAnXycpO1xuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5mb3JtYXROdW1iZXIgPSBmdW5jdGlvbiAobikge1xuICAgICAgICByZXR1cm4gbi50b1N0cmluZygpO1xuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5hdXRvVGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5jdXJyZW50VGFnLnRhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXIrKztcbiAgICAgICAgICAgIHRoaXMudGFnKHRoaXMuZm9ybWF0TnVtYmVyKHRoaXMuY291bnRlciksIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5jbGVhclRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5sYWJlbCA9ICcnO1xuICAgICAgICB0aGlzLnRhZyhudWxsLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jdXJyZW50VGFnLnRhZ0lkID0gJyc7XG4gICAgfTtcbiAgICBBYnN0cmFjdFRhZ3MucHJvdG90eXBlLmdldFRhZyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICAgICAgICBpZiAoZm9yY2UgPT09IHZvaWQgMCkgeyBmb3JjZSA9IGZhbHNlOyB9XG4gICAgICAgIGlmIChmb3JjZSkge1xuICAgICAgICAgICAgdGhpcy5hdXRvVGFnKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlVGFnKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGN0ID0gdGhpcy5jdXJyZW50VGFnO1xuICAgICAgICBpZiAoY3QudGFnZ2FibGUgJiYgIWN0Lm5vVGFnKSB7XG4gICAgICAgICAgICBpZiAoY3QuZGVmYXVsdFRhZ3MpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF1dG9UYWcoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjdC50YWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5tYWtlVGFnKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfTtcbiAgICBBYnN0cmFjdFRhZ3MucHJvdG90eXBlLnJlc2V0VGFnID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmhpc3RvcnkgPSBbXTtcbiAgICAgICAgdGhpcy5yZWRvID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVmVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2xlYXJUYWcoKTtcbiAgICB9O1xuICAgIEFic3RyYWN0VGFncy5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAob2Zmc2V0KSB7XG4gICAgICAgIGlmIChvZmZzZXQgPT09IHZvaWQgMCkgeyBvZmZzZXQgPSAwOyB9XG4gICAgICAgIHRoaXMucmVzZXRUYWcoKTtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gdGhpcy5hbGxDb3VudGVyID0gb2Zmc2V0O1xuICAgICAgICB0aGlzLmFsbExhYmVscyA9IHt9O1xuICAgICAgICB0aGlzLmFsbElkcyA9IHt9O1xuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5zdGFydEVxdWF0aW9uID0gZnVuY3Rpb24gKG1hdGgpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5jbGVhclRhZygpO1xuICAgICAgICB0aGlzLmN1cnJlbnRUYWcgPSBuZXcgVGFnSW5mbygnJywgdW5kZWZpbmVkLCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmxhYmVscyA9IHt9O1xuICAgICAgICB0aGlzLmlkcyA9IHt9O1xuICAgICAgICB0aGlzLmNvdW50ZXIgPSB0aGlzLmFsbENvdW50ZXI7XG4gICAgICAgIHRoaXMucmVkbyA9IGZhbHNlO1xuICAgICAgICB2YXIgcmVjb21waWxlID0gbWF0aC5pbnB1dERhdGEucmVjb21waWxlO1xuICAgICAgICBpZiAocmVjb21waWxlKSB7XG4gICAgICAgICAgICB0aGlzLnJlZlVwZGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNvdW50ZXIgPSByZWNvbXBpbGUuY291bnRlcjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQWJzdHJhY3RUYWdzLnByb3RvdHlwZS5maW5pc2hFcXVhdGlvbiA9IGZ1bmN0aW9uIChtYXRoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZG8pIHtcbiAgICAgICAgICAgIG1hdGguaW5wdXREYXRhLnJlY29tcGlsZSA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogbWF0aC5zdGF0ZSgpLFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IHRoaXMuYWxsQ291bnRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMucmVmVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLmFsbENvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XG4gICAgICAgIH1cbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLmFsbElkcywgdGhpcy5pZHMpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuYWxsTGFiZWxzLCB0aGlzLmxhYmVscyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdFRhZ3MucHJvdG90eXBlLmZpbmFsaXplID0gZnVuY3Rpb24gKG5vZGUsIGVudikge1xuICAgICAgICBpZiAoIWVudi5kaXNwbGF5IHx8IHRoaXMuY3VycmVudFRhZy5lbnYgfHxcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRhZy50YWcgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHRhZyA9IHRoaXMubWFrZVRhZygpO1xuICAgICAgICB2YXIgdGFibGUgPSB0aGlzLmVuVGFnKG5vZGUsIHRhZyk7XG4gICAgICAgIHJldHVybiB0YWJsZTtcbiAgICB9O1xuICAgIEFic3RyYWN0VGFncy5wcm90b3R5cGUubWFrZUlkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRUYWcudGFnSWQgPSB0aGlzLmZvcm1hdElkKHRoaXMuY29uZmlndXJhdGlvbi5vcHRpb25zWyd1c2VMYWJlbElkcyddID9cbiAgICAgICAgICAgICh0aGlzLmxhYmVsIHx8IHRoaXMuY3VycmVudFRhZy50YWcpIDogdGhpcy5jdXJyZW50VGFnLnRhZyk7XG4gICAgfTtcbiAgICBBYnN0cmFjdFRhZ3MucHJvdG90eXBlLm1ha2VUYWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMubWFrZUlkKCk7XG4gICAgICAgIGlmICh0aGlzLmxhYmVsKSB7XG4gICAgICAgICAgICB0aGlzLmxhYmVsc1t0aGlzLmxhYmVsXSA9IG5ldyBMYWJlbCh0aGlzLmN1cnJlbnRUYWcudGFnLCB0aGlzLmN1cnJlbnRUYWcudGFnSWQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtbWwgPSBuZXcgVGV4UGFyc2VyX2pzXzEuZGVmYXVsdCgnXFxcXHRleHR7JyArIHRoaXMuY3VycmVudFRhZy50YWdGb3JtYXQgKyAnfScsIHt9LCB0aGlzLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLm5vZGVGYWN0b3J5LmNyZWF0ZSgnbm9kZScsICdtdGQnLCBbbW1sXSwgeyBpZDogdGhpcy5jdXJyZW50VGFnLnRhZ0lkIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFic3RyYWN0VGFncztcbn0oKSk7XG5leHBvcnRzLkFic3RyYWN0VGFncyA9IEFic3RyYWN0VGFncztcbnZhciBOb1RhZ3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhOb1RhZ3MsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTm9UYWdzKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIE5vVGFncy5wcm90b3R5cGUuYXV0b1RhZyA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBOb1RhZ3MucHJvdG90eXBlLmdldFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmN1cnJlbnRUYWcudGFnID8gbnVsbCA6IF9zdXBlci5wcm90b3R5cGUuZ2V0VGFnLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICByZXR1cm4gTm9UYWdzO1xufShBYnN0cmFjdFRhZ3MpKTtcbmV4cG9ydHMuTm9UYWdzID0gTm9UYWdzO1xudmFyIEFsbFRhZ3MgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhBbGxUYWdzLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEFsbFRhZ3MoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgQWxsVGFncy5wcm90b3R5cGUuZmluYWxpemUgPSBmdW5jdGlvbiAobm9kZSwgZW52KSB7XG4gICAgICAgIGlmICghZW52LmRpc3BsYXkgfHwgdGhpcy5oaXN0b3J5LmZpbmQoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHgudGFnZ2FibGU7IH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGFnID0gdGhpcy5nZXRUYWcodHJ1ZSk7XG4gICAgICAgIHJldHVybiB0aGlzLmVuVGFnKG5vZGUsIHRhZyk7XG4gICAgfTtcbiAgICByZXR1cm4gQWxsVGFncztcbn0oQWJzdHJhY3RUYWdzKSk7XG5leHBvcnRzLkFsbFRhZ3MgPSBBbGxUYWdzO1xudmFyIFRhZ3NGYWN0b3J5O1xuKGZ1bmN0aW9uIChUYWdzRmFjdG9yeSkge1xuICAgIHZhciB0YWdzTWFwcGluZyA9IG5ldyBNYXAoW1xuICAgICAgICBbJ25vbmUnLCBOb1RhZ3NdLFxuICAgICAgICBbJ2FsbCcsIEFsbFRhZ3NdXG4gICAgXSk7XG4gICAgdmFyIGRlZmF1bHRUYWdzID0gJ25vbmUnO1xuICAgIFRhZ3NGYWN0b3J5Lk9QVElPTlMgPSB7XG4gICAgICAgIHRhZ3M6IGRlZmF1bHRUYWdzLFxuICAgICAgICB0YWdTaWRlOiAncmlnaHQnLFxuICAgICAgICB0YWdJbmRlbnQ6ICcwLjhlbScsXG4gICAgICAgIHVzZUxhYmVsSWRzOiB0cnVlLFxuICAgICAgICBpZ25vcmVEdXBsaWNhdGVMYWJlbHM6IGZhbHNlXG4gICAgfTtcbiAgICBUYWdzRmFjdG9yeS5hZGQgPSBmdW5jdGlvbiAobmFtZSwgY29uc3RyKSB7XG4gICAgICAgIHRhZ3NNYXBwaW5nLnNldChuYW1lLCBjb25zdHIpO1xuICAgIH07XG4gICAgVGFnc0ZhY3RvcnkuYWRkVGFncyA9IGZ1bmN0aW9uICh0YWdzKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyh0YWdzKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgVGFnc0ZhY3RvcnkuYWRkKGtleSwgdGFnc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBUYWdzRmFjdG9yeS5jcmVhdGUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICB2YXIgY29uc3RyID0gdGFnc01hcHBpbmcuZ2V0KG5hbWUpIHx8IHRhZ3NNYXBwaW5nLmdldChkZWZhdWx0VGFncyk7XG4gICAgICAgIGlmICghY29uc3RyKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignVW5rbm93biB0YWdzIGNsYXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBjb25zdHIoKTtcbiAgICB9O1xuICAgIFRhZ3NGYWN0b3J5LnNldERlZmF1bHQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBkZWZhdWx0VGFncyA9IG5hbWU7XG4gICAgfTtcbiAgICBUYWdzRmFjdG9yeS5nZXREZWZhdWx0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gVGFnc0ZhY3RvcnkuY3JlYXRlKGRlZmF1bHRUYWdzKTtcbiAgICB9O1xufSkoVGFnc0ZhY3RvcnkgPSBleHBvcnRzLlRhZ3NGYWN0b3J5IHx8IChleHBvcnRzLlRhZ3NGYWN0b3J5ID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRhZ3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgVGV4RXJyb3IgPSAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFRleEVycm9yKGlkLCBtZXNzYWdlKSB7XG4gICAgICAgIHZhciByZXN0ID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICByZXN0W19pIC0gMl0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gVGV4RXJyb3IucHJvY2Vzc1N0cmluZyhtZXNzYWdlLCByZXN0KTtcbiAgICB9XG4gICAgVGV4RXJyb3IucHJvY2Vzc1N0cmluZyA9IGZ1bmN0aW9uIChzdHIsIGFyZ3MpIHtcbiAgICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KFRleEVycm9yLnBhdHRlcm4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMSwgbSA9IHBhcnRzLmxlbmd0aDsgaSA8IG07IGkgKz0gMikge1xuICAgICAgICAgICAgdmFyIGMgPSBwYXJ0c1tpXS5jaGFyQXQoMCk7XG4gICAgICAgICAgICBpZiAoYyA+PSAnMCcgJiYgYyA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGFyZ3NbcGFyc2VJbnQocGFydHNbaV0sIDEwKSAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFydHNbaV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjID09PSAneycpIHtcbiAgICAgICAgICAgICAgICBjID0gcGFydHNbaV0uc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgIGlmIChjID49ICcwJyAmJiBjIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9IGFyZ3NbcGFyc2VJbnQocGFydHNbaV0uc3Vic3RyKDEsIHBhcnRzW2ldLmxlbmd0aCAtIDIpLCAxMCkgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJ0c1tpXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0udG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hdGNoID0gcGFydHNbaV0ubWF0Y2goL15cXHsoW2Etel0rKTolKFxcZCspXFx8KC4qKVxcfSQvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9ICclJyArIHBhcnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcnRzW2ldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwYXJ0c1tpXSA9ICc/Pz8nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cy5qb2luKCcnKTtcbiAgICB9O1xuICAgIFRleEVycm9yLnBhdHRlcm4gPSAvJShcXGQrfFxce1xcZCtcXH18XFx7W2Etel0rOlxcJVxcZCsoPzpcXHwoPzolXFx7XFxkK1xcfXwlLnxbXlxcfV0pKikrXFx9fC4pL2c7XG4gICAgcmV0dXJuIFRleEVycm9yO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRleEVycm9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGV4RXJyb3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGFyc2VVdGlsX2pzXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIi4vUGFyc2VVdGlsLmpzXCIpKTtcbnZhciBTdGFja19qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1N0YWNrLmpzXCIpKTtcbnZhciBUZXhFcnJvcl9qc18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCIuL1RleEVycm9yLmpzXCIpKTtcbnZhciBNbWxOb2RlX2pzXzEgPSByZXF1aXJlKFwiLi4vLi4vY29yZS9NbWxUcmVlL01tbE5vZGUuanNcIik7XG52YXIgVGV4UGFyc2VyID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBUZXhQYXJzZXIoX3N0cmluZywgZW52LCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB0aGlzLl9zdHJpbmcgPSBfc3RyaW5nO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24gPSBjb25maWd1cmF0aW9uO1xuICAgICAgICB0aGlzLm1hY3JvQ291bnQgPSAwO1xuICAgICAgICB0aGlzLmkgPSAwO1xuICAgICAgICB0aGlzLmN1cnJlbnRDUyA9ICcnO1xuICAgICAgICB2YXIgaW5uZXIgPSBlbnYuaGFzT3duUHJvcGVydHkoJ2lzSW5uZXInKTtcbiAgICAgICAgdmFyIGlzSW5uZXIgPSBlbnZbJ2lzSW5uZXInXTtcbiAgICAgICAgZGVsZXRlIGVudlsnaXNJbm5lciddO1xuICAgICAgICB2YXIgRU5WO1xuICAgICAgICBpZiAoZW52KSB7XG4gICAgICAgICAgICBFTlYgPSB7fTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhPYmplY3Qua2V5cyhlbnYpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgRU5WW2lkXSA9IGVudltpZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvbi5wdXNoUGFyc2VyKHRoaXMpO1xuICAgICAgICB0aGlzLnN0YWNrID0gbmV3IFN0YWNrX2pzXzEuZGVmYXVsdCh0aGlzLml0ZW1GYWN0b3J5LCBFTlYsIGlubmVyID8gaXNJbm5lciA6IHRydWUpO1xuICAgICAgICB0aGlzLlBhcnNlKCk7XG4gICAgICAgIHRoaXMuUHVzaCh0aGlzLml0ZW1GYWN0b3J5LmNyZWF0ZSgnc3RvcCcpKTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleFBhcnNlci5wcm90b3R5cGUsIFwib3B0aW9uc1wiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5vcHRpb25zO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFRleFBhcnNlci5wcm90b3R5cGUsIFwiaXRlbUZhY3RvcnlcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmZpZ3VyYXRpb24uaXRlbUZhY3Rvcnk7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4UGFyc2VyLnByb3RvdHlwZSwgXCJ0YWdzXCIsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLnRhZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVGV4UGFyc2VyLnByb3RvdHlwZSwgXCJzdHJpbmdcIiwge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zdHJpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNldDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICAgICAgdGhpcy5fc3RyaW5nID0gc3RyO1xuICAgICAgICB9LFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uIChraW5kLCBpbnB1dCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmhhbmRsZXJzLmdldChraW5kKS5wYXJzZShpbnB1dCk7XG4gICAgfTtcbiAgICBUZXhQYXJzZXIucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChraW5kLCBzeW1ib2wpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlndXJhdGlvbi5oYW5kbGVycy5nZXQoa2luZCkubG9va3VwKHN5bWJvbCk7XG4gICAgfTtcbiAgICBUZXhQYXJzZXIucHJvdG90eXBlLmNvbnRhaW5zID0gZnVuY3Rpb24gKGtpbmQsIHN5bWJvbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWd1cmF0aW9uLmhhbmRsZXJzLmdldChraW5kKS5jb250YWlucyhzeW1ib2wpO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMiwgX2E7XG4gICAgICAgIHZhciBzdHIgPSAnJztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMoQXJyYXkuZnJvbSh0aGlzLmNvbmZpZ3VyYXRpb24uaGFuZGxlcnMua2V5cygpKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY29uZmlnID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgc3RyICs9IGNvbmZpZyArICc6ICcgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24uaGFuZGxlcnMuZ2V0KGNvbmZpZykgKyAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcbiAgICBUZXhQYXJzZXIucHJvdG90eXBlLlBhcnNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYztcbiAgICAgICAgd2hpbGUgKHRoaXMuaSA8IHRoaXMuc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgYyA9IHRoaXMuZ2V0Q29kZVBvaW50KCk7XG4gICAgICAgICAgICB0aGlzLmkgKz0gYy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKCdjaGFyYWN0ZXInLCBbdGhpcywgY10pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUZXhQYXJzZXIucHJvdG90eXBlLlB1c2ggPSBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICAgIGlmIChhcmcgaW5zdGFuY2VvZiBNbWxOb2RlX2pzXzEuQWJzdHJhY3RNbWxOb2RlICYmIGFyZy5pc0luZmVycmVkKSB7XG4gICAgICAgICAgICB0aGlzLlB1c2hBbGwoYXJnLmNoaWxkTm9kZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFjay5QdXNoKGFyZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUuUHVzaEFsbCA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgYXJnc18xID0gX192YWx1ZXMoYXJncyksIGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKTsgIWFyZ3NfMV8xLmRvbmU7IGFyZ3NfMV8xID0gYXJnc18xLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzXzFfMS52YWx1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLlB1c2goYXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8zXzEpIHsgZV8zID0geyBlcnJvcjogZV8zXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3NfMV8xICYmICFhcmdzXzFfMS5kb25lICYmIChfYSA9IGFyZ3NfMS5yZXR1cm4pKSBfYS5jYWxsKGFyZ3NfMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMykgdGhyb3cgZV8zLmVycm9yOyB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUubW1sID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhY2suVG9wKCkuaXNLaW5kKCdtbWwnKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLnN0YWNrLlRvcCgpLkZpcnN0O1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb24ucG9wUGFyc2VyKCk7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5jb252ZXJ0RGVsaW1pdGVyID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgdmFyIHN5bWJvbCA9IHRoaXMubG9va3VwKCdkZWxpbWl0ZXInLCBjKTtcbiAgICAgICAgcmV0dXJuIHN5bWJvbCA/IHN5bWJvbC5jaGFyIDogbnVsbDtcbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUuZ2V0Q29kZVBvaW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29kZSA9IHRoaXMuc3RyaW5nLmNvZGVQb2ludEF0KHRoaXMuaSk7XG4gICAgICAgIHJldHVybiBjb2RlID09PSB1bmRlZmluZWQgPyAnJyA6IFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGUpO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5uZXh0SXNTcGFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5zdHJpbmcuY2hhckF0KHRoaXMuaSkubWF0Y2goL1xccy8pO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5HZXROZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0SXNTcGFjZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2RlUG9pbnQoKTtcbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUuR2V0Q1MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBDUyA9IHRoaXMuc3RyaW5nLnNsaWNlKHRoaXMuaSkubWF0Y2goL14oKFthLXpdKykgP3xbXFx1RDgwMC1cXHVEQkZGXS58LikvaSk7XG4gICAgICAgIGlmIChDUykge1xuICAgICAgICAgICAgdGhpcy5pICs9IENTWzBdLmxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiBDU1syXSB8fCBDU1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaSsrO1xuICAgICAgICAgICAgcmV0dXJuICcgJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5HZXRBcmd1bWVudCA9IGZ1bmN0aW9uIChfbmFtZSwgbm9uZU9LKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5HZXROZXh0KCkpIHtcbiAgICAgICAgICAgIGNhc2UgJyc6XG4gICAgICAgICAgICAgICAgaWYgKCFub25lT0spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTWlzc2luZ0FyZ0ZvcicsICdNaXNzaW5nIGFyZ3VtZW50IGZvciAlMScsIHRoaXMuY3VycmVudENTKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICBpZiAoIW5vbmVPSykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdFeHRyYUNsb3NlTWlzc2luZ09wZW4nLCAnRXh0cmEgY2xvc2UgYnJhY2Ugb3IgbWlzc2luZyBvcGVuIGJyYWNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgdGhpcy5pKys7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdcXFxcJyArIHRoaXMuR2V0Q1MoKTtcbiAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgIHZhciBqID0gKyt0aGlzLmksIHBhcmVucyA9IDE7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuaSA8IHRoaXMuc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RyaW5nLmNoYXJBdCh0aGlzLmkrKykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW5zKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoLS1wYXJlbnMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGosIHRoaXMuaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNaXNzaW5nQ2xvc2VCcmFjZScsICdNaXNzaW5nIGNsb3NlIGJyYWNlJyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGMgPSB0aGlzLmdldENvZGVQb2ludCgpO1xuICAgICAgICB0aGlzLmkgKz0gYy5sZW5ndGg7XG4gICAgICAgIHJldHVybiBjO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5HZXRCcmFja2V0cyA9IGZ1bmN0aW9uIChfbmFtZSwgZGVmKSB7XG4gICAgICAgIGlmICh0aGlzLkdldE5leHQoKSAhPT0gJ1snKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9XG4gICAgICAgIHZhciBqID0gKyt0aGlzLmksIHBhcmVucyA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLmkgPCB0aGlzLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5zdHJpbmcuY2hhckF0KHRoaXMuaSsrKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3snOlxuICAgICAgICAgICAgICAgICAgICBwYXJlbnMrKztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaSsrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVucy0tIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ0V4dHJhQ2xvc2VMb29raW5nJywgJ0V4dHJhIGNsb3NlIGJyYWNlIHdoaWxlIGxvb2tpbmcgZm9yICUxJywgJ1xcJ11cXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICddJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyaW5nLnNsaWNlKGosIHRoaXMuaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdDbG9zZUJyYWNrZXQnLCAnQ291bGQgbm90IGZpbmQgY2xvc2luZyBcXCddXFwnIGZvciBhcmd1bWVudCB0byAlMScsIHRoaXMuY3VycmVudENTKTtcbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUuR2V0RGVsaW1pdGVyID0gZnVuY3Rpb24gKG5hbWUsIGJyYWNlT0spIHtcbiAgICAgICAgdmFyIGMgPSB0aGlzLkdldE5leHQoKTtcbiAgICAgICAgdGhpcy5pICs9IGMubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5pIDw9IHRoaXMuc3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGMgKz0gdGhpcy5HZXRDUygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gJ3snICYmIGJyYWNlT0spIHtcbiAgICAgICAgICAgICAgICB0aGlzLmktLTtcbiAgICAgICAgICAgICAgICBjID0gdGhpcy5HZXRBcmd1bWVudChuYW1lKS50cmltKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jb250YWlucygnZGVsaW1pdGVyJywgYykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb252ZXJ0RGVsaW1pdGVyKGMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUZXhFcnJvcl9qc18xLmRlZmF1bHQoJ01pc3NpbmdPclVucmVjb2duaXplZERlbGltJywgJ01pc3Npbmcgb3IgdW5yZWNvZ25pemVkIGRlbGltaXRlciBmb3IgJTEnLCB0aGlzLmN1cnJlbnRDUyk7XG4gICAgfTtcbiAgICBUZXhQYXJzZXIucHJvdG90eXBlLkdldERpbWVuID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuR2V0TmV4dCgpID09PSAneycpIHtcbiAgICAgICAgICAgIHZhciBkaW1lbiA9IHRoaXMuR2V0QXJndW1lbnQobmFtZSk7XG4gICAgICAgICAgICB2YXIgX2EgPSBfX3JlYWQoUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC5tYXRjaERpbWVuKGRpbWVuKSwgMiksIHZhbHVlID0gX2FbMF0sIHVuaXQgPSBfYVsxXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZSArIHVuaXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgZGltZW4gPSB0aGlzLnN0cmluZy5zbGljZSh0aGlzLmkpO1xuICAgICAgICAgICAgdmFyIF9iID0gX19yZWFkKFBhcnNlVXRpbF9qc18xLmRlZmF1bHQubWF0Y2hEaW1lbihkaW1lbiwgdHJ1ZSksIDMpLCB2YWx1ZSA9IF9iWzBdLCB1bml0ID0gX2JbMV0sIGxlbmd0aF8xID0gX2JbMl07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmkgKz0gbGVuZ3RoXzE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICsgdW5pdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdNaXNzaW5nRGltT3JVbml0cycsICdNaXNzaW5nIGRpbWVuc2lvbiBvciBpdHMgdW5pdHMgZm9yICUxJywgdGhpcy5jdXJyZW50Q1MpO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5HZXRVcFRvID0gZnVuY3Rpb24gKF9uYW1lLCB0b2tlbikge1xuICAgICAgICB3aGlsZSAodGhpcy5uZXh0SXNTcGFjZSgpKSB7XG4gICAgICAgICAgICB0aGlzLmkrKztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaiA9IHRoaXMuaTtcbiAgICAgICAgdmFyIHBhcmVucyA9IDA7XG4gICAgICAgIHdoaWxlICh0aGlzLmkgPCB0aGlzLnN0cmluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBrID0gdGhpcy5pO1xuICAgICAgICAgICAgdmFyIGMgPSB0aGlzLkdldE5leHQoKTtcbiAgICAgICAgICAgIHRoaXMuaSArPSBjLmxlbmd0aDtcbiAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1xcXFwnOlxuICAgICAgICAgICAgICAgICAgICBjICs9IHRoaXMuR2V0Q1MoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgIHBhcmVucysrO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd9JzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnRXh0cmFDbG9zZUxvb2tpbmcnLCAnRXh0cmEgY2xvc2UgYnJhY2Ugd2hpbGUgbG9va2luZyBmb3IgJTEnLCB0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcGFyZW5zLS07XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmVucyA9PT0gMCAmJiBjID09PSB0b2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnN0cmluZy5zbGljZShqLCBrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVGV4RXJyb3JfanNfMS5kZWZhdWx0KCdUb2tlbk5vdEZvdW5kRm9yQ29tbWFuZCcsICdDb3VsZCBub3QgZmluZCAlMSBmb3IgJTInLCB0b2tlbiwgdGhpcy5jdXJyZW50Q1MpO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5QYXJzZUFyZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHJldHVybiBuZXcgVGV4UGFyc2VyKHRoaXMuR2V0QXJndW1lbnQobmFtZSksIHRoaXMuc3RhY2suZW52LCB0aGlzLmNvbmZpZ3VyYXRpb24pLm1tbCgpO1xuICAgIH07XG4gICAgVGV4UGFyc2VyLnByb3RvdHlwZS5QYXJzZVVwVG8gPSBmdW5jdGlvbiAobmFtZSwgdG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUZXhQYXJzZXIodGhpcy5HZXRVcFRvKG5hbWUsIHRva2VuKSwgdGhpcy5zdGFjay5lbnYsIHRoaXMuY29uZmlndXJhdGlvbikubW1sKCk7XG4gICAgfTtcbiAgICBUZXhQYXJzZXIucHJvdG90eXBlLkdldERlbGltaXRlckFyZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICAgIHZhciBjID0gUGFyc2VVdGlsX2pzXzEuZGVmYXVsdC50cmltU3BhY2VzKHRoaXMuR2V0QXJndW1lbnQobmFtZSkpO1xuICAgICAgICBpZiAoYyA9PT0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5zKCdkZWxpbWl0ZXInLCBjKSkge1xuICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IFRleEVycm9yX2pzXzEuZGVmYXVsdCgnTWlzc2luZ09yVW5yZWNvZ25pemVkRGVsaW0nLCAnTWlzc2luZyBvciB1bnJlY29nbml6ZWQgZGVsaW1pdGVyIGZvciAlMScsIHRoaXMuY3VycmVudENTKTtcbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUuR2V0U3RhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0YXIgPSAodGhpcy5HZXROZXh0KCkgPT09ICcqJyk7XG4gICAgICAgIGlmIChzdGFyKSB7XG4gICAgICAgICAgICB0aGlzLmkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhcjtcbiAgICB9O1xuICAgIFRleFBhcnNlci5wcm90b3R5cGUuY3JlYXRlID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgcmVzdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgcmVzdFtfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5jb25maWd1cmF0aW9uLm5vZGVGYWN0b3J5KS5jcmVhdGUuYXBwbHkoX2EsIF9fc3ByZWFkQXJyYXkoW2tpbmRdLCBfX3JlYWQocmVzdCksIGZhbHNlKSk7XG4gICAgfTtcbiAgICByZXR1cm4gVGV4UGFyc2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFRleFBhcnNlcjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleFBhcnNlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMubWF0aGpheCA9IHZvaWQgMDtcbnZhciB2ZXJzaW9uX2pzXzEgPSByZXF1aXJlKFwiLi9jb21wb25lbnRzL3ZlcnNpb24uanNcIik7XG52YXIgSGFuZGxlckxpc3RfanNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvSGFuZGxlckxpc3QuanNcIik7XG52YXIgUmV0cmllc19qc18xID0gcmVxdWlyZShcIi4vdXRpbC9SZXRyaWVzLmpzXCIpO1xuZXhwb3J0cy5tYXRoamF4ID0ge1xuICAgIHZlcnNpb246IHZlcnNpb25fanNfMS5WRVJTSU9OLFxuICAgIGhhbmRsZXJzOiBuZXcgSGFuZGxlckxpc3RfanNfMS5IYW5kbGVyTGlzdCgpLFxuICAgIGRvY3VtZW50OiBmdW5jdGlvbiAoZG9jdW1lbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGV4cG9ydHMubWF0aGpheC5oYW5kbGVycy5kb2N1bWVudChkb2N1bWVudCwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBoYW5kbGVSZXRyaWVzRm9yOiBSZXRyaWVzX2pzXzEuaGFuZGxlUmV0cmllc0ZvcixcbiAgICByZXRyeUFmdGVyOiBSZXRyaWVzX2pzXzEucmV0cnlBZnRlcixcbiAgICBhc3luY0xvYWQ6IG51bGwsXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bWF0aGpheC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYXN5bmNMb2FkID0gdm9pZCAwO1xudmFyIG1hdGhqYXhfanNfMSA9IHJlcXVpcmUoXCIuLi9tYXRoamF4LmpzXCIpO1xuZnVuY3Rpb24gYXN5bmNMb2FkKG5hbWUpIHtcbiAgICBpZiAoIW1hdGhqYXhfanNfMS5tYXRoamF4LmFzeW5jTG9hZCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoXCJDYW4ndCBsb2FkICdcIi5jb25jYXQobmFtZSwgXCInOiBObyBhc3luY0xvYWQgbWV0aG9kIHNwZWNpZmllZFwiKSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAob2ssIGZhaWwpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG1hdGhqYXhfanNfMS5tYXRoamF4LmFzeW5jTG9hZChuYW1lKTtcbiAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJlc3VsdC50aGVuKGZ1bmN0aW9uICh2YWx1ZSkgeyByZXR1cm4gb2sodmFsdWUpOyB9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBmYWlsKGVycik7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb2socmVzdWx0KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0cy5hc3luY0xvYWQgPSBhc3luY0xvYWQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Bc3luY0xvYWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm51bWVyaWMgPSBleHBvcnRzLnRyYW5zbGF0ZSA9IGV4cG9ydHMucmVtb3ZlID0gZXhwb3J0cy5hZGQgPSBleHBvcnRzLmVudGl0aWVzID0gZXhwb3J0cy5vcHRpb25zID0gdm9pZCAwO1xudmFyIFJldHJpZXNfanNfMSA9IHJlcXVpcmUoXCIuL1JldHJpZXMuanNcIik7XG52YXIgQXN5bmNMb2FkX2pzXzEgPSByZXF1aXJlKFwiLi9Bc3luY0xvYWQuanNcIik7XG5leHBvcnRzLm9wdGlvbnMgPSB7XG4gICAgbG9hZE1pc3NpbmdFbnRpdGllczogdHJ1ZVxufTtcbmV4cG9ydHMuZW50aXRpZXMgPSB7XG4gICAgQXBwbHlGdW5jdGlvbjogJ1xcdTIwNjEnLFxuICAgIEJhY2tzbGFzaDogJ1xcdTIyMTYnLFxuICAgIEJlY2F1c2U6ICdcXHUyMjM1JyxcbiAgICBCcmV2ZTogJ1xcdTAyRDgnLFxuICAgIENhcDogJ1xcdTIyRDInLFxuICAgIENlbnRlckRvdDogJ1xcdTAwQjcnLFxuICAgIENpcmNsZURvdDogJ1xcdTIyOTknLFxuICAgIENpcmNsZU1pbnVzOiAnXFx1MjI5NicsXG4gICAgQ2lyY2xlUGx1czogJ1xcdTIyOTUnLFxuICAgIENpcmNsZVRpbWVzOiAnXFx1MjI5NycsXG4gICAgQ29uZ3J1ZW50OiAnXFx1MjI2MScsXG4gICAgQ29udG91ckludGVncmFsOiAnXFx1MjIyRScsXG4gICAgQ29wcm9kdWN0OiAnXFx1MjIxMCcsXG4gICAgQ3Jvc3M6ICdcXHUyQTJGJyxcbiAgICBDdXA6ICdcXHUyMkQzJyxcbiAgICBDdXBDYXA6ICdcXHUyMjREJyxcbiAgICBEYWdnZXI6ICdcXHUyMDIxJyxcbiAgICBEZWw6ICdcXHUyMjA3JyxcbiAgICBEZWx0YTogJ1xcdTAzOTQnLFxuICAgIERpYW1vbmQ6ICdcXHUyMkM0JyxcbiAgICBEaWZmZXJlbnRpYWxEOiAnXFx1MjE0NicsXG4gICAgRG90RXF1YWw6ICdcXHUyMjUwJyxcbiAgICBEb3VibGVEb3Q6ICdcXHUwMEE4JyxcbiAgICBEb3VibGVSaWdodFRlZTogJ1xcdTIyQTgnLFxuICAgIERvdWJsZVZlcnRpY2FsQmFyOiAnXFx1MjIyNScsXG4gICAgRG93bkFycm93OiAnXFx1MjE5MycsXG4gICAgRG93bkxlZnRWZWN0b3I6ICdcXHUyMUJEJyxcbiAgICBEb3duUmlnaHRWZWN0b3I6ICdcXHUyMUMxJyxcbiAgICBEb3duVGVlOiAnXFx1MjJBNCcsXG4gICAgRG93bmFycm93OiAnXFx1MjFEMycsXG4gICAgRWxlbWVudDogJ1xcdTIyMDgnLFxuICAgIEVxdWFsVGlsZGU6ICdcXHUyMjQyJyxcbiAgICBFcXVpbGlicml1bTogJ1xcdTIxQ0MnLFxuICAgIEV4aXN0czogJ1xcdTIyMDMnLFxuICAgIEV4cG9uZW50aWFsRTogJ1xcdTIxNDcnLFxuICAgIEZpbGxlZFZlcnlTbWFsbFNxdWFyZTogJ1xcdTI1QUEnLFxuICAgIEZvckFsbDogJ1xcdTIyMDAnLFxuICAgIEdhbW1hOiAnXFx1MDM5MycsXG4gICAgR2c6ICdcXHUyMkQ5JyxcbiAgICBHcmVhdGVyRXF1YWw6ICdcXHUyMjY1JyxcbiAgICBHcmVhdGVyRXF1YWxMZXNzOiAnXFx1MjJEQicsXG4gICAgR3JlYXRlckZ1bGxFcXVhbDogJ1xcdTIyNjcnLFxuICAgIEdyZWF0ZXJMZXNzOiAnXFx1MjI3NycsXG4gICAgR3JlYXRlclNsYW50RXF1YWw6ICdcXHUyQTdFJyxcbiAgICBHcmVhdGVyVGlsZGU6ICdcXHUyMjczJyxcbiAgICBIYWNlazogJ1xcdTAyQzcnLFxuICAgIEhhdDogJ1xcdTAwNUUnLFxuICAgIEh1bXBEb3duSHVtcDogJ1xcdTIyNEUnLFxuICAgIEh1bXBFcXVhbDogJ1xcdTIyNEYnLFxuICAgIEltOiAnXFx1MjExMScsXG4gICAgSW1hZ2luYXJ5STogJ1xcdTIxNDgnLFxuICAgIEludGVncmFsOiAnXFx1MjIyQicsXG4gICAgSW50ZXJzZWN0aW9uOiAnXFx1MjJDMicsXG4gICAgSW52aXNpYmxlQ29tbWE6ICdcXHUyMDYzJyxcbiAgICBJbnZpc2libGVUaW1lczogJ1xcdTIwNjInLFxuICAgIExhbWJkYTogJ1xcdTAzOUInLFxuICAgIExhcnI6ICdcXHUyMTlFJyxcbiAgICBMZWZ0QW5nbGVCcmFja2V0OiAnXFx1MjdFOCcsXG4gICAgTGVmdEFycm93OiAnXFx1MjE5MCcsXG4gICAgTGVmdEFycm93UmlnaHRBcnJvdzogJ1xcdTIxQzYnLFxuICAgIExlZnRDZWlsaW5nOiAnXFx1MjMwOCcsXG4gICAgTGVmdERvd25WZWN0b3I6ICdcXHUyMUMzJyxcbiAgICBMZWZ0Rmxvb3I6ICdcXHUyMzBBJyxcbiAgICBMZWZ0UmlnaHRBcnJvdzogJ1xcdTIxOTQnLFxuICAgIExlZnRUZWU6ICdcXHUyMkEzJyxcbiAgICBMZWZ0VHJpYW5nbGU6ICdcXHUyMkIyJyxcbiAgICBMZWZ0VHJpYW5nbGVFcXVhbDogJ1xcdTIyQjQnLFxuICAgIExlZnRVcFZlY3RvcjogJ1xcdTIxQkYnLFxuICAgIExlZnRWZWN0b3I6ICdcXHUyMUJDJyxcbiAgICBMZWZ0YXJyb3c6ICdcXHUyMUQwJyxcbiAgICBMZWZ0cmlnaHRhcnJvdzogJ1xcdTIxRDQnLFxuICAgIExlc3NFcXVhbEdyZWF0ZXI6ICdcXHUyMkRBJyxcbiAgICBMZXNzRnVsbEVxdWFsOiAnXFx1MjI2NicsXG4gICAgTGVzc0dyZWF0ZXI6ICdcXHUyMjc2JyxcbiAgICBMZXNzU2xhbnRFcXVhbDogJ1xcdTJBN0QnLFxuICAgIExlc3NUaWxkZTogJ1xcdTIyNzInLFxuICAgIExsOiAnXFx1MjJEOCcsXG4gICAgTGxlZnRhcnJvdzogJ1xcdTIxREEnLFxuICAgIExvbmdMZWZ0QXJyb3c6ICdcXHUyN0Y1JyxcbiAgICBMb25nTGVmdFJpZ2h0QXJyb3c6ICdcXHUyN0Y3JyxcbiAgICBMb25nUmlnaHRBcnJvdzogJ1xcdTI3RjYnLFxuICAgIExvbmdsZWZ0YXJyb3c6ICdcXHUyN0Y4JyxcbiAgICBMb25nbGVmdHJpZ2h0YXJyb3c6ICdcXHUyN0ZBJyxcbiAgICBMb25ncmlnaHRhcnJvdzogJ1xcdTI3RjknLFxuICAgIExzaDogJ1xcdTIxQjAnLFxuICAgIE1pbnVzUGx1czogJ1xcdTIyMTMnLFxuICAgIE5lc3RlZEdyZWF0ZXJHcmVhdGVyOiAnXFx1MjI2QicsXG4gICAgTmVzdGVkTGVzc0xlc3M6ICdcXHUyMjZBJyxcbiAgICBOb3REb3VibGVWZXJ0aWNhbEJhcjogJ1xcdTIyMjYnLFxuICAgIE5vdEVsZW1lbnQ6ICdcXHUyMjA5JyxcbiAgICBOb3RFcXVhbDogJ1xcdTIyNjAnLFxuICAgIE5vdEV4aXN0czogJ1xcdTIyMDQnLFxuICAgIE5vdEdyZWF0ZXI6ICdcXHUyMjZGJyxcbiAgICBOb3RHcmVhdGVyRXF1YWw6ICdcXHUyMjcxJyxcbiAgICBOb3RMZWZ0VHJpYW5nbGU6ICdcXHUyMkVBJyxcbiAgICBOb3RMZWZ0VHJpYW5nbGVFcXVhbDogJ1xcdTIyRUMnLFxuICAgIE5vdExlc3M6ICdcXHUyMjZFJyxcbiAgICBOb3RMZXNzRXF1YWw6ICdcXHUyMjcwJyxcbiAgICBOb3RQcmVjZWRlczogJ1xcdTIyODAnLFxuICAgIE5vdFByZWNlZGVzU2xhbnRFcXVhbDogJ1xcdTIyRTAnLFxuICAgIE5vdFJpZ2h0VHJpYW5nbGU6ICdcXHUyMkVCJyxcbiAgICBOb3RSaWdodFRyaWFuZ2xlRXF1YWw6ICdcXHUyMkVEJyxcbiAgICBOb3RTdWJzZXRFcXVhbDogJ1xcdTIyODgnLFxuICAgIE5vdFN1Y2NlZWRzOiAnXFx1MjI4MScsXG4gICAgTm90U3VjY2VlZHNTbGFudEVxdWFsOiAnXFx1MjJFMScsXG4gICAgTm90U3VwZXJzZXRFcXVhbDogJ1xcdTIyODknLFxuICAgIE5vdFRpbGRlOiAnXFx1MjI0MScsXG4gICAgTm90VmVydGljYWxCYXI6ICdcXHUyMjI0JyxcbiAgICBPbWVnYTogJ1xcdTAzQTknLFxuICAgIE92ZXJCYXI6ICdcXHUyMDNFJyxcbiAgICBPdmVyQnJhY2U6ICdcXHUyM0RFJyxcbiAgICBQYXJ0aWFsRDogJ1xcdTIyMDInLFxuICAgIFBoaTogJ1xcdTAzQTYnLFxuICAgIFBpOiAnXFx1MDNBMCcsXG4gICAgUGx1c01pbnVzOiAnXFx1MDBCMScsXG4gICAgUHJlY2VkZXM6ICdcXHUyMjdBJyxcbiAgICBQcmVjZWRlc0VxdWFsOiAnXFx1MkFBRicsXG4gICAgUHJlY2VkZXNTbGFudEVxdWFsOiAnXFx1MjI3QycsXG4gICAgUHJlY2VkZXNUaWxkZTogJ1xcdTIyN0UnLFxuICAgIFByb2R1Y3Q6ICdcXHUyMjBGJyxcbiAgICBQcm9wb3J0aW9uYWw6ICdcXHUyMjFEJyxcbiAgICBQc2k6ICdcXHUwM0E4JyxcbiAgICBSYXJyOiAnXFx1MjFBMCcsXG4gICAgUmU6ICdcXHUyMTFDJyxcbiAgICBSZXZlcnNlRXF1aWxpYnJpdW06ICdcXHUyMUNCJyxcbiAgICBSaWdodEFuZ2xlQnJhY2tldDogJ1xcdTI3RTknLFxuICAgIFJpZ2h0QXJyb3c6ICdcXHUyMTkyJyxcbiAgICBSaWdodEFycm93TGVmdEFycm93OiAnXFx1MjFDNCcsXG4gICAgUmlnaHRDZWlsaW5nOiAnXFx1MjMwOScsXG4gICAgUmlnaHREb3duVmVjdG9yOiAnXFx1MjFDMicsXG4gICAgUmlnaHRGbG9vcjogJ1xcdTIzMEInLFxuICAgIFJpZ2h0VGVlOiAnXFx1MjJBMicsXG4gICAgUmlnaHRUZWVBcnJvdzogJ1xcdTIxQTYnLFxuICAgIFJpZ2h0VHJpYW5nbGU6ICdcXHUyMkIzJyxcbiAgICBSaWdodFRyaWFuZ2xlRXF1YWw6ICdcXHUyMkI1JyxcbiAgICBSaWdodFVwVmVjdG9yOiAnXFx1MjFCRScsXG4gICAgUmlnaHRWZWN0b3I6ICdcXHUyMUMwJyxcbiAgICBSaWdodGFycm93OiAnXFx1MjFEMicsXG4gICAgUnJpZ2h0YXJyb3c6ICdcXHUyMURCJyxcbiAgICBSc2g6ICdcXHUyMUIxJyxcbiAgICBTaWdtYTogJ1xcdTAzQTMnLFxuICAgIFNtYWxsQ2lyY2xlOiAnXFx1MjIxOCcsXG4gICAgU3FydDogJ1xcdTIyMUEnLFxuICAgIFNxdWFyZTogJ1xcdTI1QTEnLFxuICAgIFNxdWFyZUludGVyc2VjdGlvbjogJ1xcdTIyOTMnLFxuICAgIFNxdWFyZVN1YnNldDogJ1xcdTIyOEYnLFxuICAgIFNxdWFyZVN1YnNldEVxdWFsOiAnXFx1MjI5MScsXG4gICAgU3F1YXJlU3VwZXJzZXQ6ICdcXHUyMjkwJyxcbiAgICBTcXVhcmVTdXBlcnNldEVxdWFsOiAnXFx1MjI5MicsXG4gICAgU3F1YXJlVW5pb246ICdcXHUyMjk0JyxcbiAgICBTdGFyOiAnXFx1MjJDNicsXG4gICAgU3Vic2V0OiAnXFx1MjJEMCcsXG4gICAgU3Vic2V0RXF1YWw6ICdcXHUyMjg2JyxcbiAgICBTdWNjZWVkczogJ1xcdTIyN0InLFxuICAgIFN1Y2NlZWRzRXF1YWw6ICdcXHUyQUIwJyxcbiAgICBTdWNjZWVkc1NsYW50RXF1YWw6ICdcXHUyMjdEJyxcbiAgICBTdWNjZWVkc1RpbGRlOiAnXFx1MjI3RicsXG4gICAgU3VjaFRoYXQ6ICdcXHUyMjBCJyxcbiAgICBTdW06ICdcXHUyMjExJyxcbiAgICBTdXBlcnNldDogJ1xcdTIyODMnLFxuICAgIFN1cGVyc2V0RXF1YWw6ICdcXHUyMjg3JyxcbiAgICBTdXBzZXQ6ICdcXHUyMkQxJyxcbiAgICBUaGVyZWZvcmU6ICdcXHUyMjM0JyxcbiAgICBUaGV0YTogJ1xcdTAzOTgnLFxuICAgIFRpbGRlOiAnXFx1MjIzQycsXG4gICAgVGlsZGVFcXVhbDogJ1xcdTIyNDMnLFxuICAgIFRpbGRlRnVsbEVxdWFsOiAnXFx1MjI0NScsXG4gICAgVGlsZGVUaWxkZTogJ1xcdTIyNDgnLFxuICAgIFVuZGVyQmFyOiAnXFx1MDA1RicsXG4gICAgVW5kZXJCcmFjZTogJ1xcdTIzREYnLFxuICAgIFVuaW9uOiAnXFx1MjJDMycsXG4gICAgVW5pb25QbHVzOiAnXFx1MjI4RScsXG4gICAgVXBBcnJvdzogJ1xcdTIxOTEnLFxuICAgIFVwRG93bkFycm93OiAnXFx1MjE5NScsXG4gICAgVXBUZWU6ICdcXHUyMkE1JyxcbiAgICBVcGFycm93OiAnXFx1MjFEMScsXG4gICAgVXBkb3duYXJyb3c6ICdcXHUyMUQ1JyxcbiAgICBVcHNpbG9uOiAnXFx1MDNBNScsXG4gICAgVmRhc2g6ICdcXHUyMkE5JyxcbiAgICBWZWU6ICdcXHUyMkMxJyxcbiAgICBWZXJ0aWNhbEJhcjogJ1xcdTIyMjMnLFxuICAgIFZlcnRpY2FsVGlsZGU6ICdcXHUyMjQwJyxcbiAgICBWdmRhc2g6ICdcXHUyMkFBJyxcbiAgICBXZWRnZTogJ1xcdTIyQzAnLFxuICAgIFhpOiAnXFx1MDM5RScsXG4gICAgYW1wOiAnXFx1MDAyNicsXG4gICAgYWN1dGU6ICdcXHUwMEI0JyxcbiAgICBhbGVwaDogJ1xcdTIxMzUnLFxuICAgIGFscGhhOiAnXFx1MDNCMScsXG4gICAgYW1hbGc6ICdcXHUyQTNGJyxcbiAgICBhbmQ6ICdcXHUyMjI3JyxcbiAgICBhbmc6ICdcXHUyMjIwJyxcbiAgICBhbmdtc2Q6ICdcXHUyMjIxJyxcbiAgICBhbmdzcGg6ICdcXHUyMjIyJyxcbiAgICBhcGU6ICdcXHUyMjRBJyxcbiAgICBiYWNrcHJpbWU6ICdcXHUyMDM1JyxcbiAgICBiYWNrc2ltOiAnXFx1MjIzRCcsXG4gICAgYmFja3NpbWVxOiAnXFx1MjJDRCcsXG4gICAgYmV0YTogJ1xcdTAzQjInLFxuICAgIGJldGg6ICdcXHUyMTM2JyxcbiAgICBiZXR3ZWVuOiAnXFx1MjI2QycsXG4gICAgYmlnY2lyYzogJ1xcdTI1RUYnLFxuICAgIGJpZ29kb3Q6ICdcXHUyQTAwJyxcbiAgICBiaWdvcGx1czogJ1xcdTJBMDEnLFxuICAgIGJpZ290aW1lczogJ1xcdTJBMDInLFxuICAgIGJpZ3NxY3VwOiAnXFx1MkEwNicsXG4gICAgYmlnc3RhcjogJ1xcdTI2MDUnLFxuICAgIGJpZ3RyaWFuZ2xlZG93bjogJ1xcdTI1QkQnLFxuICAgIGJpZ3RyaWFuZ2xldXA6ICdcXHUyNUIzJyxcbiAgICBiaWd1cGx1czogJ1xcdTJBMDQnLFxuICAgIGJsYWNrbG96ZW5nZTogJ1xcdTI5RUInLFxuICAgIGJsYWNrdHJpYW5nbGU6ICdcXHUyNUI0JyxcbiAgICBibGFja3RyaWFuZ2xlZG93bjogJ1xcdTI1QkUnLFxuICAgIGJsYWNrdHJpYW5nbGVsZWZ0OiAnXFx1MjVDMicsXG4gICAgYm93dGllOiAnXFx1MjJDOCcsXG4gICAgYm94ZGw6ICdcXHUyNTEwJyxcbiAgICBib3hkcjogJ1xcdTI1MEMnLFxuICAgIGJveG1pbnVzOiAnXFx1MjI5RicsXG4gICAgYm94cGx1czogJ1xcdTIyOUUnLFxuICAgIGJveHRpbWVzOiAnXFx1MjJBMCcsXG4gICAgYm94dWw6ICdcXHUyNTE4JyxcbiAgICBib3h1cjogJ1xcdTI1MTQnLFxuICAgIGJzb2w6ICdcXHUwMDVDJyxcbiAgICBidWxsOiAnXFx1MjAyMicsXG4gICAgY2FwOiAnXFx1MjIyOScsXG4gICAgY2hlY2s6ICdcXHUyNzEzJyxcbiAgICBjaGk6ICdcXHUwM0M3JyxcbiAgICBjaXJjOiAnXFx1MDJDNicsXG4gICAgY2lyY2VxOiAnXFx1MjI1NycsXG4gICAgY2lyY2xlYXJyb3dsZWZ0OiAnXFx1MjFCQScsXG4gICAgY2lyY2xlYXJyb3dyaWdodDogJ1xcdTIxQkInLFxuICAgIGNpcmNsZWRSOiAnXFx1MDBBRScsXG4gICAgY2lyY2xlZFM6ICdcXHUyNEM4JyxcbiAgICBjaXJjbGVkYXN0OiAnXFx1MjI5QicsXG4gICAgY2lyY2xlZGNpcmM6ICdcXHUyMjlBJyxcbiAgICBjaXJjbGVkZGFzaDogJ1xcdTIyOUQnLFxuICAgIGNsdWJzOiAnXFx1MjY2MycsXG4gICAgY29sb246ICdcXHUwMDNBJyxcbiAgICBjb21wOiAnXFx1MjIwMScsXG4gICAgY3Rkb3Q6ICdcXHUyMkVGJyxcbiAgICBjdWVwcjogJ1xcdTIyREUnLFxuICAgIGN1ZXNjOiAnXFx1MjJERicsXG4gICAgY3VsYXJyOiAnXFx1MjFCNicsXG4gICAgY3VwOiAnXFx1MjIyQScsXG4gICAgY3VyYXJyOiAnXFx1MjFCNycsXG4gICAgY3VybHl2ZWU6ICdcXHUyMkNFJyxcbiAgICBjdXJseXdlZGdlOiAnXFx1MjJDRicsXG4gICAgZGFnZ2VyOiAnXFx1MjAyMCcsXG4gICAgZGFsZXRoOiAnXFx1MjEzOCcsXG4gICAgZGRhcnI6ICdcXHUyMUNBJyxcbiAgICBkZWc6ICdcXHUwMEIwJyxcbiAgICBkZWx0YTogJ1xcdTAzQjQnLFxuICAgIGRpZ2FtbWE6ICdcXHUwM0REJyxcbiAgICBkaXY6ICdcXHUwMEY3JyxcbiAgICBkaXZpZGVvbnRpbWVzOiAnXFx1MjJDNycsXG4gICAgZG90OiAnXFx1MDJEOScsXG4gICAgZG90ZXFkb3Q6ICdcXHUyMjUxJyxcbiAgICBkb3RwbHVzOiAnXFx1MjIxNCcsXG4gICAgZG90c3F1YXJlOiAnXFx1MjJBMScsXG4gICAgZHRkb3Q6ICdcXHUyMkYxJyxcbiAgICBlY2lyOiAnXFx1MjI1NicsXG4gICAgZWZEb3Q6ICdcXHUyMjUyJyxcbiAgICBlZ3M6ICdcXHUyQTk2JyxcbiAgICBlbGw6ICdcXHUyMTEzJyxcbiAgICBlbHM6ICdcXHUyQTk1JyxcbiAgICBlbXB0eTogJ1xcdTIyMDUnLFxuICAgIGVwc2k6ICdcXHUwM0I1JyxcbiAgICBlcHNpdjogJ1xcdTAzRjUnLFxuICAgIGVyRG90OiAnXFx1MjI1MycsXG4gICAgZXRhOiAnXFx1MDNCNycsXG4gICAgZXRoOiAnXFx1MDBGMCcsXG4gICAgZmxhdDogJ1xcdTI2NkQnLFxuICAgIGZvcms6ICdcXHUyMkQ0JyxcbiAgICBmcm93bjogJ1xcdTIzMjInLFxuICAgIGdFbDogJ1xcdTJBOEMnLFxuICAgIGdhbW1hOiAnXFx1MDNCMycsXG4gICAgZ2FwOiAnXFx1MkE4NicsXG4gICAgZ2ltZWw6ICdcXHUyMTM3JyxcbiAgICBnbkU6ICdcXHUyMjY5JyxcbiAgICBnbmFwOiAnXFx1MkE4QScsXG4gICAgZ25lOiAnXFx1MkE4OCcsXG4gICAgZ25zaW06ICdcXHUyMkU3JyxcbiAgICBndDogJ1xcdTAwM0UnLFxuICAgIGd0ZG90OiAnXFx1MjJENycsXG4gICAgaGFycnc6ICdcXHUyMUFEJyxcbiAgICBoYmFyOiAnXFx1MjEwRicsXG4gICAgaGVsbGlwOiAnXFx1MjAyNicsXG4gICAgaG9va2xlZnRhcnJvdzogJ1xcdTIxQTknLFxuICAgIGhvb2tyaWdodGFycm93OiAnXFx1MjFBQScsXG4gICAgaW1hdGg6ICdcXHUwMTMxJyxcbiAgICBpbmZpbjogJ1xcdTIyMUUnLFxuICAgIGludGNhbDogJ1xcdTIyQkEnLFxuICAgIGlvdGE6ICdcXHUwM0I5JyxcbiAgICBqbWF0aDogJ1xcdTAyMzcnLFxuICAgIGthcHBhOiAnXFx1MDNCQScsXG4gICAga2FwcGF2OiAnXFx1MDNGMCcsXG4gICAgbEVnOiAnXFx1MkE4QicsXG4gICAgbGFtYmRhOiAnXFx1MDNCQicsXG4gICAgbGFwOiAnXFx1MkE4NScsXG4gICAgbGFycmxwOiAnXFx1MjFBQicsXG4gICAgbGFycnRsOiAnXFx1MjFBMicsXG4gICAgbGJyYWNlOiAnXFx1MDA3QicsXG4gICAgbGJyYWNrOiAnXFx1MDA1QicsXG4gICAgbGU6ICdcXHUyMjY0JyxcbiAgICBsZWZ0bGVmdGFycm93czogJ1xcdTIxQzcnLFxuICAgIGxlZnR0aHJlZXRpbWVzOiAnXFx1MjJDQicsXG4gICAgbGVzc2RvdDogJ1xcdTIyRDYnLFxuICAgIGxtb3VzdDogJ1xcdTIzQjAnLFxuICAgIGxuRTogJ1xcdTIyNjgnLFxuICAgIGxuYXA6ICdcXHUyQTg5JyxcbiAgICBsbmU6ICdcXHUyQTg3JyxcbiAgICBsbnNpbTogJ1xcdTIyRTYnLFxuICAgIGxvbmdtYXBzdG86ICdcXHUyN0ZDJyxcbiAgICBsb29wYXJyb3dyaWdodDogJ1xcdTIxQUMnLFxuICAgIGxvd2FzdDogJ1xcdTIyMTcnLFxuICAgIGxvejogJ1xcdTI1Q0EnLFxuICAgIGx0OiAnXFx1MDAzQycsXG4gICAgbHRpbWVzOiAnXFx1MjJDOScsXG4gICAgbHRyaTogJ1xcdTI1QzMnLFxuICAgIG1hY3I6ICdcXHUwMEFGJyxcbiAgICBtYWx0OiAnXFx1MjcyMCcsXG4gICAgbWhvOiAnXFx1MjEyNycsXG4gICAgbXU6ICdcXHUwM0JDJyxcbiAgICBtdWx0aW1hcDogJ1xcdTIyQjgnLFxuICAgIG5MZWZ0YXJyb3c6ICdcXHUyMUNEJyxcbiAgICBuTGVmdHJpZ2h0YXJyb3c6ICdcXHUyMUNFJyxcbiAgICBuUmlnaHRhcnJvdzogJ1xcdTIxQ0YnLFxuICAgIG5WRGFzaDogJ1xcdTIyQUYnLFxuICAgIG5WZGFzaDogJ1xcdTIyQUUnLFxuICAgIG5hdHVyOiAnXFx1MjY2RScsXG4gICAgbmVhcnI6ICdcXHUyMTk3JyxcbiAgICBuaGFycjogJ1xcdTIxQUUnLFxuICAgIG5sYXJyOiAnXFx1MjE5QScsXG4gICAgbm90OiAnXFx1MDBBQycsXG4gICAgbnJhcnI6ICdcXHUyMTlCJyxcbiAgICBudTogJ1xcdTAzQkQnLFxuICAgIG52RGFzaDogJ1xcdTIyQUQnLFxuICAgIG52ZGFzaDogJ1xcdTIyQUMnLFxuICAgIG53YXJyOiAnXFx1MjE5NicsXG4gICAgb21lZ2E6ICdcXHUwM0M5JyxcbiAgICBvbWljcm9uOiAnXFx1MDNCRicsXG4gICAgb3I6ICdcXHUyMjI4JyxcbiAgICBvc29sOiAnXFx1MjI5OCcsXG4gICAgcGVyaW9kOiAnXFx1MDAyRScsXG4gICAgcGhpOiAnXFx1MDNDNicsXG4gICAgcGhpdjogJ1xcdTAzRDUnLFxuICAgIHBpOiAnXFx1MDNDMCcsXG4gICAgcGl2OiAnXFx1MDNENicsXG4gICAgcHJhcDogJ1xcdTJBQjcnLFxuICAgIHByZWNuYXBwcm94OiAnXFx1MkFCOScsXG4gICAgcHJlY25lcXE6ICdcXHUyQUI1JyxcbiAgICBwcmVjbnNpbTogJ1xcdTIyRTgnLFxuICAgIHByaW1lOiAnXFx1MjAzMicsXG4gICAgcHNpOiAnXFx1MDNDOCcsXG4gICAgcXVvdDogJ1xcdTAwMjInLFxuICAgIHJhcnJ0bDogJ1xcdTIxQTMnLFxuICAgIHJicmFjZTogJ1xcdTAwN0QnLFxuICAgIHJicmFjazogJ1xcdTAwNUQnLFxuICAgIHJobzogJ1xcdTAzQzEnLFxuICAgIHJob3Y6ICdcXHUwM0YxJyxcbiAgICByaWdodHJpZ2h0YXJyb3dzOiAnXFx1MjFDOScsXG4gICAgcmlnaHR0aHJlZXRpbWVzOiAnXFx1MjJDQycsXG4gICAgcmluZzogJ1xcdTAyREEnLFxuICAgIHJtb3VzdDogJ1xcdTIzQjEnLFxuICAgIHJ0aW1lczogJ1xcdTIyQ0EnLFxuICAgIHJ0cmk6ICdcXHUyNUI5JyxcbiAgICBzY2FwOiAnXFx1MkFCOCcsXG4gICAgc2NuRTogJ1xcdTJBQjYnLFxuICAgIHNjbmFwOiAnXFx1MkFCQScsXG4gICAgc2Nuc2ltOiAnXFx1MjJFOScsXG4gICAgc2RvdDogJ1xcdTIyQzUnLFxuICAgIHNlYXJyOiAnXFx1MjE5OCcsXG4gICAgc2VjdDogJ1xcdTAwQTcnLFxuICAgIHNoYXJwOiAnXFx1MjY2RicsXG4gICAgc2lnbWE6ICdcXHUwM0MzJyxcbiAgICBzaWdtYXY6ICdcXHUwM0MyJyxcbiAgICBzaW1uZTogJ1xcdTIyNDYnLFxuICAgIHNtaWxlOiAnXFx1MjMyMycsXG4gICAgc3BhZGVzOiAnXFx1MjY2MCcsXG4gICAgc3ViOiAnXFx1MjI4MicsXG4gICAgc3ViRTogJ1xcdTJBQzUnLFxuICAgIHN1Ym5FOiAnXFx1MkFDQicsXG4gICAgc3VibmU6ICdcXHUyMjhBJyxcbiAgICBzdXBFOiAnXFx1MkFDNicsXG4gICAgc3VwbkU6ICdcXHUyQUNDJyxcbiAgICBzdXBuZTogJ1xcdTIyOEInLFxuICAgIHN3YXJyOiAnXFx1MjE5OScsXG4gICAgdGF1OiAnXFx1MDNDNCcsXG4gICAgdGhldGE6ICdcXHUwM0I4JyxcbiAgICB0aGV0YXY6ICdcXHUwM0QxJyxcbiAgICB0aWxkZTogJ1xcdTAyREMnLFxuICAgIHRpbWVzOiAnXFx1MDBENycsXG4gICAgdHJpYW5nbGU6ICdcXHUyNUI1JyxcbiAgICB0cmlhbmdsZXE6ICdcXHUyMjVDJyxcbiAgICB1cHNpOiAnXFx1MDNDNScsXG4gICAgdXB1cGFycm93czogJ1xcdTIxQzgnLFxuICAgIHZlZWJhcjogJ1xcdTIyQkInLFxuICAgIHZlbGxpcDogJ1xcdTIyRUUnLFxuICAgIHdlaWVycDogJ1xcdTIxMTgnLFxuICAgIHhpOiAnXFx1MDNCRScsXG4gICAgeWVuOiAnXFx1MDBBNScsXG4gICAgemV0YTogJ1xcdTAzQjYnLFxuICAgIHppZ3JhcnI6ICdcXHUyMUREJyxcbiAgICBuYnNwOiAnXFx1MDBBMCcsXG4gICAgcnNxdW86ICdcXHUyMDE5JyxcbiAgICBsc3F1bzogJ1xcdTIwMTgnXG59O1xudmFyIGxvYWRlZCA9IHt9O1xuZnVuY3Rpb24gYWRkKGFkZGl0aW9ucywgZmlsZSkge1xuICAgIE9iamVjdC5hc3NpZ24oZXhwb3J0cy5lbnRpdGllcywgYWRkaXRpb25zKTtcbiAgICBsb2FkZWRbZmlsZV0gPSB0cnVlO1xufVxuZXhwb3J0cy5hZGQgPSBhZGQ7XG5mdW5jdGlvbiByZW1vdmUoZW50aXR5KSB7XG4gICAgZGVsZXRlIGV4cG9ydHMuZW50aXRpZXNbZW50aXR5XTtcbn1cbmV4cG9ydHMucmVtb3ZlID0gcmVtb3ZlO1xuZnVuY3Rpb24gdHJhbnNsYXRlKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKC8mKFthLXpdW2EtejAtOV0qfCMoPzpbMC05XSt8eFswLTlhLWZdKykpOy9pZywgcmVwbGFjZSk7XG59XG5leHBvcnRzLnRyYW5zbGF0ZSA9IHRyYW5zbGF0ZTtcbmZ1bmN0aW9uIHJlcGxhY2UobWF0Y2gsIGVudGl0eSkge1xuICAgIGlmIChlbnRpdHkuY2hhckF0KDApID09PSAnIycpIHtcbiAgICAgICAgcmV0dXJuIG51bWVyaWMoZW50aXR5LnNsaWNlKDEpKTtcbiAgICB9XG4gICAgaWYgKGV4cG9ydHMuZW50aXRpZXNbZW50aXR5XSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5lbnRpdGllc1tlbnRpdHldO1xuICAgIH1cbiAgICBpZiAoZXhwb3J0cy5vcHRpb25zWydsb2FkTWlzc2luZ0VudGl0aWVzJ10pIHtcbiAgICAgICAgdmFyIGZpbGUgPSAoZW50aXR5Lm1hdGNoKC9eW2EtekEtWl0oZnJ8c2NyfG9wZikkLykgPyBSZWdFeHAuJDEgOiBlbnRpdHkuY2hhckF0KDApLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIWxvYWRlZFtmaWxlXSkge1xuICAgICAgICAgICAgbG9hZGVkW2ZpbGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICgwLCBSZXRyaWVzX2pzXzEucmV0cnlBZnRlcikoKDAsIEFzeW5jTG9hZF9qc18xLmFzeW5jTG9hZCkoJy4vdXRpbC9lbnRpdGllcy8nICsgZmlsZSArICcuanMnKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hdGNoO1xufVxuZnVuY3Rpb24gbnVtZXJpYyhlbnRpdHkpIHtcbiAgICB2YXIgbiA9IChlbnRpdHkuY2hhckF0KDApID09PSAneCcgP1xuICAgICAgICBwYXJzZUludChlbnRpdHkuc2xpY2UoMSksIDE2KSA6XG4gICAgICAgIHBhcnNlSW50KGVudGl0eSkpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludChuKTtcbn1cbmV4cG9ydHMubnVtZXJpYyA9IG51bWVyaWM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FbnRpdGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkZ1bmN0aW9uTGlzdCA9IHZvaWQgMDtcbnZhciBQcmlvcml0aXplZExpc3RfanNfMSA9IHJlcXVpcmUoXCIuL1ByaW9yaXRpemVkTGlzdC5qc1wiKTtcbnZhciBGdW5jdGlvbkxpc3QgPSAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIF9fZXh0ZW5kcyhGdW5jdGlvbkxpc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRnVuY3Rpb25MaXN0KCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIEZ1bmN0aW9uTGlzdC5wcm90b3R5cGUuZXhlY3V0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgIHZhciBkYXRhID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBkYXRhW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXModGhpcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXRlbSA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBpdGVtLml0ZW0uYXBwbHkoaXRlbSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGRhdGEpLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfMV8xKSB7IGVfMSA9IHsgZXJyb3I6IGVfMV8xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIEZ1bmN0aW9uTGlzdC5wcm90b3R5cGUuYXN5bmNFeGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgZGF0YSA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgZGF0YVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBpID0gLTE7XG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMuaXRlbXM7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAob2ssIGZhaWwpIHtcbiAgICAgICAgICAgIChmdW5jdGlvbiBleGVjdXRlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSAoX2EgPSBpdGVtc1tpXSkuaXRlbS5hcHBseShfYSwgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGRhdGEpLCBmYWxzZSkpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnRoZW4oZXhlY3V0ZSkuY2F0Y2goZnVuY3Rpb24gKGVycikgeyByZXR1cm4gZmFpbChlcnIpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9rKHRydWUpO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gRnVuY3Rpb25MaXN0O1xufShQcmlvcml0aXplZExpc3RfanNfMS5Qcmlvcml0aXplZExpc3QpKTtcbmV4cG9ydHMuRnVuY3Rpb25MaXN0ID0gRnVuY3Rpb25MaXN0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RnVuY3Rpb25MaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcmlvcml0aXplZExpc3QgPSB2b2lkIDA7XG52YXIgUHJpb3JpdGl6ZWRMaXN0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcmlvcml0aXplZExpc3QoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBbXTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgIH1cbiAgICBQcmlvcml0aXplZExpc3QucHJvdG90eXBlW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5pdGVtcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbXNbaSsrXSwgZG9uZTogKGkgPiBpdGVtcy5sZW5ndGgpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQcmlvcml0aXplZExpc3QucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIChpdGVtLCBwcmlvcml0eSkge1xuICAgICAgICBpZiAocHJpb3JpdHkgPT09IHZvaWQgMCkgeyBwcmlvcml0eSA9IFByaW9yaXRpemVkTGlzdC5ERUZBVUxUUFJJT1JJVFk7IH1cbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9IHdoaWxlIChpID49IDAgJiYgcHJpb3JpdHkgPCB0aGlzLml0ZW1zW2ldLnByaW9yaXR5KTtcbiAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSArIDEsIDAsIHsgaXRlbTogaXRlbSwgcHJpb3JpdHk6IHByaW9yaXR5IH0pO1xuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9O1xuICAgIFByaW9yaXRpemVkTGlzdC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIGkgPSB0aGlzLml0ZW1zLmxlbmd0aDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgaS0tO1xuICAgICAgICB9IHdoaWxlIChpID49IDAgJiYgdGhpcy5pdGVtc1tpXS5pdGVtICE9PSBpdGVtKTtcbiAgICAgICAgaWYgKGkgPj0gMCkge1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFByaW9yaXRpemVkTGlzdC5ERUZBVUxUUFJJT1JJVFkgPSA1O1xuICAgIHJldHVybiBQcmlvcml0aXplZExpc3Q7XG59KCkpO1xuZXhwb3J0cy5Qcmlvcml0aXplZExpc3QgPSBQcmlvcml0aXplZExpc3Q7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1Qcmlvcml0aXplZExpc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJldHJ5QWZ0ZXIgPSBleHBvcnRzLmhhbmRsZVJldHJpZXNGb3IgPSB2b2lkIDA7XG5mdW5jdGlvbiBoYW5kbGVSZXRyaWVzRm9yKGNvZGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gcnVuKG9rLCBmYWlsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBvayhjb2RlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIucmV0cnkgJiYgZXJyLnJldHJ5IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGVyci5yZXRyeS50aGVuKGZ1bmN0aW9uICgpIHsgcmV0dXJuIHJ1bihvaywgZmFpbCk7IH0pXG4gICAgICAgICAgICAgICAgICAgIC5jYXRjaChmdW5jdGlvbiAocGVycikgeyByZXR1cm4gZmFpbChwZXJyKTsgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlcnIucmVzdGFydCAmJiBlcnIucmVzdGFydC5pc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgTWF0aEpheC5DYWxsYmFjay5BZnRlcihmdW5jdGlvbiAoKSB7IHJldHVybiBydW4ob2ssIGZhaWwpOyB9LCBlcnIucmVzdGFydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYWlsKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMuaGFuZGxlUmV0cmllc0ZvciA9IGhhbmRsZVJldHJpZXNGb3I7XG5mdW5jdGlvbiByZXRyeUFmdGVyKHByb21pc2UpIHtcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdNYXRoSmF4IHJldHJ5Jyk7XG4gICAgZXJyLnJldHJ5ID0gcHJvbWlzZTtcbiAgICB0aHJvdyBlcnI7XG59XG5leHBvcnRzLnJldHJ5QWZ0ZXIgPSByZXRyeUFmdGVyO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UmV0cmllcy5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=