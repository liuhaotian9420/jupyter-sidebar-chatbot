"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/api-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/api-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: icons_1.extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/globals.js":
/*!**************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/globals.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/icons.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/icons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Import the main CSS file
__webpack_require__(/*! ../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/markdown-config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/markdown-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Normalize line endings
    const normalizedText = text.replace(/\r\n/g, '\n');
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = normalizedText.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks:
        // 1. Handle list items with proper spacing
        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines
        let processed = line;
        // Handle dash list items by ensuring they have a space after the dash
        processed = processed.replace(/(\s*)-(\S)/g, '$1- $2');
        // Handle mixed space/dash issues - ensure proper newlines before list items
        processed = processed.replace(/([^\n\s])-\s/g, '$1\n- ');
        return processed;
    });
    // Join lines and ensure code blocks are properly formatted
    let result = processedLines.join('\n');
    // Handle empty code blocks (add a space so they render properly)
    result = result.replace(/```(.*)\n```/g, '```$1\n \n```');
    return result;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
/**
 * Manages the state and interactions of the multi-level popup menu.
 */
class PopupMenuManager {
    constructor(docManager, widgetNode, callbacks) {
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        this.currentNotebook = null;
        this.selectedMenuItemIndex = -1; // Track currently selected menu item
        this.isRenderingContent = false; // Flag to prevent recursive renders
        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders
        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];
        this.fileCache = new Map();
        this.docManager = docManager;
        this.widgetNode = widgetNode;
        this.callbacks = callbacks;
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        // Attach to the widget node instead of the body
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Create search input
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search...';
        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling
        // Use 'input' event instead of directly re-rendering on every keystroke
        this.searchInput.addEventListener('input', () => {
            // Only re-render if the search term has actually changed
            if (this.searchInput.value !== this.lastSearchTerm) {
                this.lastSearchTerm = this.searchInput.value;
                this.renderMenuContent();
            }
        });
        // Handle keydown in search input to stop propagation for navigation keys
        this.searchInput.addEventListener('keydown', (event) => {
            console.log(`POPUP Search KeyDown: Key='${event.key}'`);
            // IMPORTANT: Prevent these keys from being captured by the document handler
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);
                if (event.key === 'Escape') {
                    // Handle Escape directly here
                    this.hidePopupMenu();
                }
                else if (event.key === 'Enter') {
                    // Maybe select first item on Enter?
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        this.selectedMenuItemIndex = 0;
                        this.updateSelectionHighlight();
                        // Optionally activate the item:
                        // menuItems[0].click(); 
                    }
                }
                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    // Move to first/last menu item
                    // The blur() will be handled by main key handler
                }
                event.stopPropagation();
            }
            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys
            // This allows default behavior to work properly
        }, true); // Use capture phase
        document.addEventListener('click', this.handleDocumentClick.bind(this), true);
        // IMPORTANT: Use a separate bound function for the document keydown
        // so we can remove the exact same listener later
        this.boundHandleKeyDown = this.handleKeyDown.bind(this);
        document.addEventListener('keydown', this.boundHandleKeyDown, true);
        if (globals_1.globals.notebookTracker) {
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            globals_1.globals.notebookTracker.currentChanged.connect((_, notebook) => {
                this.currentNotebook = notebook;
            });
        }
    }
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);
        // Remove using the exact same bound function
        document.removeEventListener('keydown', this.boundHandleKeyDown, true);
        // Remove from widgetNode if attached
        if (this.popupMenuContainer.parentNode === this.widgetNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
    handleDocumentClick(event) {
        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');
            if (atButton && atButton.contains(event.target)) {
                console.log('POPUP: Click was on the @ button, not hiding.');
                return;
            }
            console.log('POPUP: Click detected outside the menu.');
            this.hidePopupMenu();
        }
    }
    async showPopupMenu(x, y) {
        console.log(`POPUP: Showing menu at (${x}, ${y})`);
        // Store the initial anchor point for positioning
        this._anchorX = x;
        this._anchorY = y;
        if (this.popupMenuContainer.style.display === 'none') {
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
            this.searchInput.value = ''; // Clear search on show
            this.lastSearchTerm = ''; // Reset last search term
            await this.setCurrentDirectoryPath();
        }
        await this.renderMenuContent();
        // Ensure it's attached to the widget node if somehow detached
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Position the popup menu - handled in updatePopupPosition
        this.updatePopupPosition();
        // Focus the search input if we are in file/directory view, otherwise focus the first item
        if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
            setTimeout(() => {
                // Focus after timeout to ensure DOM is ready
                this.searchInput.focus();
                console.log('POPUP: Focused search input');
            }, 50); // Slightly longer timeout
            this.selectedMenuItemIndex = -1; // Don't select an item if search is focused
        }
        else {
            // Reset and select the first menu item for top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 50);
        }
    }
    hidePopupMenu() {
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding menu.');
            this.popupMenuContainer.style.display = 'none';
            // No need to explicitly remove from widgetNode unless causing issues
            // If performance becomes an issue with many menus, consider removing/re-adding
            // if (this.popupMenuContainer.parentNode === this.widgetNode) {
            //     this.widgetNode.removeChild(this.popupMenuContainer);
            // }
        }
    }
    async renderMenuContent() {
        // Prevent recursive renders
        if (this.isRenderingContent) {
            console.log('POPUP: Skipping render - already rendering');
            return;
        }
        this.isRenderingContent = true;
        try {
            // Clear existing content
            while (this.popupMenuContainer.firstChild) {
                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);
            }
            // If not at top level, add a search input for filtering items
            if (this.currentMenuLevel !== 'top') {
                // Add search input at the top of the menu
                this.popupMenuContainer.appendChild(this.searchInput);
                // Path display and back button removed for cleaner UI
            }
            // Render different menu content based on current level
            switch (this.currentMenuLevel) {
                case 'top':
                    this.renderTopLevelItems();
                    break;
                case 'files':
                case 'directories':
                    await this.renderDirectoryBrowserItems();
                    break;
                case 'cells':
                    await this.renderCellItems();
                    break;
            }
            // Reset selection after rendering
            this.selectedMenuItemIndex = -1;
            this.updateSelectionHighlight();
            // Update the position to maintain the fixed bottom edge
            if (this.popupMenuContainer.style.display !== 'none' && this._anchorX !== undefined && this._anchorY !== undefined) {
                this.updatePopupPosition();
            }
        }
        catch (error) {
            console.error('POPUP: Error rendering menu content', error);
        }
        finally {
            this.isRenderingContent = false;
        }
    }
    renderTopLevelItems() {
        const topLevelCommands = [
            { label: 'Code', description: '', actionId: 'insert-code' },
            { label: 'Cells', description: '', actionId: 'browse-cells' },
            { label: 'File', description: '', actionId: 'browse-files' },
            { label: 'Directory', description: '', actionId: 'browse-directories' }
        ];
        topLevelCommands.forEach(cmd => {
            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);
            this.popupMenuContainer.appendChild(item);
        });
    }
    async renderDirectoryBrowserItems() {
        var _a;
        // Get search term
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        // Temporarily add loading item below search/path
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // If contents were already fetched recently and we're just filtering again,
            // we could potentially cache the results to avoid unnecessary API calls
            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';
            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);
            // Check if still in DOM before trying to remove
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (contents && contents.length > 0) {
                // Filter based on search term
                const filteredContents = contents.filter(item => {
                    return item.name.toLowerCase().includes(searchTerm) ||
                        item.relativePath.toLowerCase().includes(searchTerm);
                });
                if (filteredContents.length > 0) {
                    filteredContents.forEach(item => {
                        const itemName = item.name;
                        const itemType = item.type;
                        const itemPath = item.path;
                        const relativePath = item.relativePath;
                        const icon = itemType === 'directory' ? 'üìÅ' : 'üìÑ';
                        let actionId;
                        if (itemType === 'directory') {
                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';
                        }
                        else { // itemType === 'file'
                            actionId = 'select-file';
                        }
                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                }
                else {
                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');
                    emptyItem.style.pointerEvents = 'none';
                    this.popupMenuContainer.appendChild(emptyItem);
                }
            }
            else {
                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
            }
        }
        catch (error) {
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading/filtering directory contents:', error);
        }
    }
    /**
     * Renders all cells from the current notebook
     */
    async renderCellItems() {
        var _a, _b;
        // Get search term for filtering
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        // Create a loading indicator
        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // Check if we have an active notebook
            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {
                // Remove loading item
                if (this.popupMenuContainer.contains(loadingItem)) {
                    this.popupMenuContainer.removeChild(loadingItem);
                }
                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');
                errorItem.style.color = 'red';
                errorItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(errorItem);
                return;
            }
            const notebookModel = this.currentNotebook.content.model;
            const cells = notebookModel.cells;
            // Remove loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (!cells || cells.length === 0) {
                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
                return;
            }
            // Process and display each cell
            let filteredCellCount = 0;
            for (let i = 0; i < cells.length; i++) {
                const cell = cells.get(i);
                const cellType = cell.type;
                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :
                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');
                // Use type casting to avoid TypeScript errors
                const executionCount = cellType === 'code' ?
                    (cell.executionCount !== undefined && cell.executionCount !== null ?
                        cell.executionCount : '*') :
                    '';
                // Create a preview of the cell content (truncate if needed)
                const contentPreview = typeof cellContent === 'string' ?
                    cellContent :
                    (Array.isArray(cellContent) ? cellContent.join('\n') : '');
                const firstLine = contentPreview.split('\n')[0] || '';
                const truncatedContent = firstLine.length > 30 ?
                    firstLine.substring(0, 30) + '...' :
                    firstLine;
                // Create cell label with styled type indicator
                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';
                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';
                // Create menu item for this cell
                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML
                'select-cell', i.toString() // Store cell index in path
                );
                // Create styled content with HTML elements
                const typeSpan = document.createElement('span');
                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;
                typeSpan.textContent = typeIndicator;
                const execSpan = document.createElement('span');
                execSpan.className = 'cell-exec-count';
                execSpan.textContent = executionDisplay;
                execSpan.style.marginRight = '8px';
                const contentSpan = document.createElement('span');
                contentSpan.className = 'cell-content-preview';
                contentSpan.textContent = truncatedContent;
                // Get the label span (first child of the menu item)
                const labelSpan = cellItem.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = ''; // Clear existing text
                    labelSpan.appendChild(typeSpan);
                    if (executionDisplay) {
                        labelSpan.appendChild(execSpan);
                    }
                    labelSpan.appendChild(contentSpan);
                }
                // Construct full searchable text
                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();
                // Filter by search term if one is provided
                if (searchTerm && !searchableText.includes(searchTerm)) {
                    continue;
                }
                this.popupMenuContainer.appendChild(cellItem);
                filteredCellCount++;
            }
            if (filteredCellCount === 0) {
                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');
                noMatchItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(noMatchItem);
            }
        }
        catch (error) {
            // Clean up loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading notebook cells:', error);
        }
    }
    createMenuItem(text, actionId, path = '', description = '') {
        const item = document.createElement('div');
        item.className = 'jp-llm-ext-popup-menu-item';
        item.dataset.actionId = actionId;
        if (path) {
            item.dataset.path = path;
        }
        item.onclick = (event) => this.handleMenuClick(event);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = text;
        item.appendChild(labelSpan);
        if (description) {
            const pathSpan = document.createElement('span');
            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';
            pathSpan.textContent = description;
            pathSpan.style.fontSize = '0.85em';
            pathSpan.style.color = 'var(--jp-ui-font-color2)';
            pathSpan.style.marginLeft = '8px';
            pathSpan.style.opacity = '0.8';
            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed
            item.appendChild(pathSpan);
        }
        return item;
    }
    async handleMenuClick(event) {
        var _a;
        const target = event.currentTarget;
        const actionId = target.dataset.actionId;
        const path = target.dataset.path || '';
        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);
        switch (actionId) {
            case 'navigate-back':
                this.navigateBackMenu();
                break;
            case 'insert-code': {
                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;
                if (selectedText) {
                    // Show submenu for code insertion options
                    const submenuItems = [
                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },
                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }
                    ];
                    // Replace current menu with submenu options
                    this.popupMenuContainer.innerHTML = '';
                    submenuItems.forEach(item => {
                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                    // Add back button
                    const backButton = this.createMenuItem('Back', 'navigate-back');
                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';
                    this.popupMenuContainer.appendChild(backButton);
                    return; // Don't hide menu, wait for submenu selection
                }
                else {
                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                    if (cellContent) {
                        this.callbacks.insertCode(cellContent);
                    }
                }
                this.hidePopupMenu();
                break;
            }
            case 'insert-plain-code': {
                if (path) {
                    this.callbacks.insertCode(path);
                    this.hidePopupMenu();
                }
                break;
            }
            case 'collapse-code-ref': {
                if (path && this.currentNotebook) {
                    try {
                        // Get notebook file name (without extension)
                        const notebookPath = this.currentNotebook.context.path;
                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';
                        // Find current cell index and approximate line number
                        const currentCell = this.currentNotebook.content.activeCell;
                        if (!currentCell) {
                            throw new Error('No active cell found');
                        }
                        // Get current cell index
                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;
                        // Estimate line number from cursor position
                        let lineNumber = 1; // Default to line 1
                        if (currentCell.editor) {
                            const editor = currentCell.editor;
                            const cursor = editor.getCursorPosition();
                            if (cursor) {
                                lineNumber = cursor.line + 1; // Convert to 1-indexed
                            }
                        }
                        // Invoke the callback with all the information needed
                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);
                        this.hidePopupMenu();
                    }
                    catch (error) {
                        console.error('Error creating collapsed code reference:', error);
                        // Fallback to inserting code directly
                        this.callbacks.insertCode(path);
                        this.hidePopupMenu();
                    }
                }
                else {
                    // If something went wrong or no path provided, just insert as regular code
                    if (path) {
                        this.callbacks.insertCode(path);
                    }
                    this.hidePopupMenu();
                }
                break;
            }
            case 'browse-cells':
                await this.navigateMenu('cells', '');
                this.searchInput.value = '';
                break;
            case 'browse-files':
                await this.navigateMenu('files', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'browse-directories':
                await this.navigateMenu('directories', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'select-cell':
                if (path) {
                    const cellIndex = parseInt(path);
                    if (!isNaN(cellIndex) && this.callbacks.insertCellByIndex) {
                        this.callbacks.insertCellByIndex(cellIndex);
                        this.hidePopupMenu();
                    }
                    else {
                        console.error('POPUP: Invalid cell index or callback missing.');
                    }
                }
                break;
            case 'select-file':
                if (path) {
                    this.callbacks.insertFilePath(path);
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: File selected but path is missing.');
                }
                break;
            case 'select-directory-navigate': // New action to navigate into dir when in file view
                if (path) {
                    // Clear the file cache for the specific directory to force a refresh
                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;
                    this.fileCache.delete(cacheKey);
                    // Make sure we're passing the correct level type
                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?
                        this.currentMenuLevel : 'files';
                    await this.navigateMenu(level, path);
                    this.searchInput.value = ''; // Clear search on navigation
                }
                else {
                    console.error('POPUP: Directory selected for navigation but path is missing.');
                }
                break;
            case 'select-directory-callback': // New action to select dir when in directory view
                if (path) {
                    this.callbacks.insertDirectoryPath(path); // Use the callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected for callback but path is missing.');
                }
                break;
            case 'placeholder-action':
                console.log('Placeholder action triggered.');
                this.hidePopupMenu();
                break;
            case 'loading':
            case 'empty':
            case 'error':
                break;
            default:
                console.warn('Unknown menu action:', actionId);
                this.hidePopupMenu();
                break;
        }
        event.stopPropagation();
    }
    async navigateMenu(level, path) {
        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);
        // Only push history if we are actually moving to a new state
        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {
            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
        }
        this.currentMenuLevel = level;
        this.currentMenuPath = path;
        // Don't clear search on programmatic navigation (like back button)
        // this.searchInput.value = ''; // Maybe keep search term?
        await this.renderMenuContent();
        // Focus search input after navigating to file/dir view
        if (level === 'files' || level === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0);
            this.selectedMenuItemIndex = -1; // Reset selection
        }
        else {
            // Select first item if navigating back to top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 0);
        }
    }
    navigateBackMenu() {
        const previousState = this.menuHistory.pop();
        if (previousState) {
            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);
            this.currentMenuLevel = previousState.level;
            this.currentMenuPath = previousState.path;
            // Don't clear search on back navigation
            this.renderMenuContent().then(() => {
                // Focus search input if going back to file/dir view
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    setTimeout(() => this.searchInput.focus(), 0);
                    this.selectedMenuItemIndex = -1; // Reset selection
                }
                else {
                    // Select first item if going back to top level
                    this.selectedMenuItemIndex = -1;
                    setTimeout(() => this.selectNextMenuItem(), 0);
                }
            });
        }
        else {
            console.log('POPUP: Already at the top level.');
            this.hidePopupMenu();
        }
    }
    async listCurrentDirectoryContents(basePath, filterType) {
        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);
        // Check cache first
        const cacheKey = `${basePath}:${filterType || 'all'}`;
        if (this.fileCache.has(cacheKey)) {
            console.log('POPUP: Using cached directory contents');
            return this.fileCache.get(cacheKey) || null;
        }
        try {
            const effectivePath = basePath === '/' ? '' : basePath;
            // Ensure trailing slash removed for consistency unless it's root
            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;
            // Result array that will hold all files and directories
            let allResults = [];
            // Get the base directory contents (non-recursive)
            const baseContents = await this.docManager.services.contents.get(pathForApi || '');
            if (baseContents.type !== 'directory') {
                console.error('Path is not a directory:', basePath);
                return null;
            }
            // Process base directory items
            for (const item of baseContents.content) {
                const itemType = item.type === 'directory' ? 'directory' : 'file';
                // Add directories if we're listing directories or both
                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {
                    allResults.push({
                        name: item.name,
                        path: item.path,
                        type: 'directory',
                        relativePath: `./${item.name}`
                    });
                }
                // Add files if we're listing files and the extension is allowed
                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {
                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();
                    if (this.allowedExtensions.includes(fileExt)) {
                        allResults.push({
                            name: item.name,
                            path: item.path,
                            type: 'file',
                            relativePath: `./${item.name}`
                        });
                    }
                }
            }
            // Sort the results appropriately
            allResults = allResults.sort((a, b) => {
                // If listing directories only, sort alphabetically
                if (filterType === 'directory') {
                    return a.name.localeCompare(b.name);
                }
                // If listing files only, sort alphabetically
                if (filterType === 'file') {
                    return a.name.localeCompare(b.name);
                }
                // If listing both, sort directories first, then files alphabetically
                if (a.type === 'directory' && b.type !== 'directory')
                    return -1;
                if (a.type !== 'directory' && b.type === 'directory')
                    return 1;
                return a.name.localeCompare(b.name);
            });
            // Cache the results for future use
            this.fileCache.set(cacheKey, allResults);
            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);
            return allResults;
        }
        catch (error) {
            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);
            return null;
        }
    }
    async setCurrentDirectoryPath() {
        var _a;
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            this.currentMenuPath = '';
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                dirPath = this.getParentDirectory(path);
                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);
            }
        }
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            if (typeof notebookPath === 'string') {
                dirPath = this.getParentDirectory(notebookPath);
                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);
            }
        }
        if (dirPath === null) {
            try {
                const leftWidgets = Array.from(app.shell.widgets('left'));
                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
                if (fileBrowserWidget && ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path)) {
                    dirPath = fileBrowserWidget.model.path;
                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);
                }
                else {
                    console.log('POPUP: File browser widget path not directly accessible.');
                }
            }
            catch (e) {
                console.warn('POPUP: Could not get path from file browser.', e);
            }
        }
        if (dirPath === null) {
            dirPath = '';
            console.log('POPUP: Falling back to server root path.');
        }
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);
    }
    getParentDirectory(path) {
        if (!path)
            return '';
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\\\'));
        if (lastSlash === -1)
            return ''; // No directory part, likely root or just a filename
        return path.substring(0, lastSlash);
    }
    /**
     * Handle keyboard navigation when the popup menu is shown
     */
    handleKeyDown(event) {
        var _a;
        // Skip if menu not visible
        if (this.popupMenuContainer.style.display === 'none') {
            return;
        }
        console.log(`POPUP KeyDown: Key='${event.key}', Target='${(_a = event.target) === null || _a === void 0 ? void 0 : _a.tagName}', SearchFocused='${document.activeElement === this.searchInput}'`);
        // Special handling for when search input is focused
        if (document.activeElement === this.searchInput) {
            // The input's own keydown handler will handle most keys
            // But for certain keys like arrow keys, we may need to move focus
            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                // Move selection to first/last item
                event.preventDefault();
                event.stopPropagation();
                // Delay before moving focus - this gives time for the search input's
                // own keydown handler to process the key first
                setTimeout(() => {
                    if (event.key === 'ArrowDown') {
                        this.searchInput.blur();
                        this.selectNextMenuItem();
                    }
                    else { // ArrowUp
                        this.searchInput.blur();
                        this.selectPreviousMenuItem();
                    }
                }, 0);
                return;
            }
            // IMPORTANT: For Backspace in search input, just return without handling
            // Let the default behavior happen
            if (event.key === 'Backspace') {
                // Just perform default behavior in search input
                return;
            }
            // Let all other keys be handled by the search input's own handler
            return;
        }
        // From here, search input is NOT focused
        const menuItems = this.getMenuItems();
        switch (event.key) {
            case 'ArrowDown':
                if (menuItems.length > 0) {
                    console.log('POPUP KeyDown (Menu Focused): ArrowDown');
                    event.preventDefault();
                    event.stopPropagation();
                    this.selectNextMenuItem();
                }
                break;
            case 'ArrowUp':
                if (menuItems.length > 0) {
                    console.log('POPUP KeyDown (Menu Focused): ArrowUp');
                    event.preventDefault();
                    event.stopPropagation();
                    this.selectPreviousMenuItem();
                }
                break;
            case 'Backspace':
                console.log('POPUP KeyDown (Menu Focused): Backspace');
                // Only prevent default and navigate back if we have history
                if (this.menuHistory.length > 0) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.navigateBackMenu();
                }
                else {
                    console.log('POPUP KeyDown (Menu Focused): No history, allowing Backspace default action');
                    // Allow default - don't prevent or stop propagation
                }
                break;
            case 'Enter':
                console.log('POPUP KeyDown (Menu Focused): Enter');
                // Only activate if an item is selected
                if (this.selectedMenuItemIndex >= 0 && this.selectedMenuItemIndex < menuItems.length) {
                    event.preventDefault();
                    event.stopPropagation();
                    menuItems[this.selectedMenuItemIndex].click();
                }
                break;
            case 'Tab':
                console.log('POPUP KeyDown (Menu Focused): Tab');
                // Basic Tab support: move focus between search and first/last item
                event.preventDefault();
                event.stopPropagation();
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    this.searchInput.focus();
                    this.deselectAllMenuItems(); // Deselect items when search gets focus via Tab
                }
                else {
                    // Maybe close menu on Tab from top level? Or do nothing.
                    this.hidePopupMenu();
                }
                break;
            case 'Escape':
                console.log('POPUP KeyDown (Menu Focused): Escape');
                event.preventDefault();
                event.stopPropagation();
                this.hidePopupMenu();
                break;
            default:
                console.log(`POPUP KeyDown (Menu Focused): Default key '${event.key}'`);
                // If typing a character and in file/dir view, focus search
                if ((this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') &&
                    event.key.length === 1 && !event.ctrlKey && !event.metaKey && !event.altKey) {
                    event.preventDefault(); // Prevent character appearing elsewhere
                    event.stopPropagation();
                    this.searchInput.focus();
                    // Manually append the typed character as focus happens after keydown default action
                    this.searchInput.value += event.key;
                    // Trigger input event manually to update list
                    this.searchInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                }
                // Allow other keys (e.g., modifiers) to pass through if not handled
                break;
        }
    }
    updateSelectionHighlight() {
        const menuItems = this.getMenuItems();
        console.log(`POPUP updateSelectionHighlight: Highlighting index ${this.selectedMenuItemIndex} among ${menuItems.length} items.`);
        menuItems.forEach((item, index) => {
            if (index === this.selectedMenuItemIndex) {
                if (!item.classList.contains('selected')) {
                    item.classList.add('selected');
                    console.log(`POPUP updateSelectionHighlight: Added 'selected' to item ${index}`);
                    // Ensure item is visible
                    item.scrollIntoView({ block: 'nearest' });
                }
            }
            else {
                if (item.classList.contains('selected')) {
                    item.classList.remove('selected');
                    console.log(`POPUP updateSelectionHighlight: Removed 'selected' from item ${index}`);
                }
            }
        });
    }
    deselectAllMenuItems() {
        const menuItems = this.getMenuItems();
        menuItems.forEach(item => item.classList.remove('selected'));
        this.selectedMenuItemIndex = -1;
    }
    selectNextMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectNext: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the next item or loop back to the first
        this.selectedMenuItemIndex = (this.selectedMenuItemIndex + 1) % menuItems.length;
        console.log(`POPUP selectNext: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    selectPreviousMenuItem() {
        const menuItems = this.getMenuItems();
        if (!menuItems.length) {
            console.log('POPUP selectPrevious: No items to select.');
            this.selectedMenuItemIndex = -1; // Ensure index is reset
            return;
        }
        const oldIndex = this.selectedMenuItemIndex;
        // Deselect current first is handled by updateSelectionHighlight
        // Move to the previous item or loop to the last
        this.selectedMenuItemIndex = this.selectedMenuItemIndex <= 0 ?
            menuItems.length - 1 : this.selectedMenuItemIndex - 1;
        console.log(`POPUP selectPrevious: Index changed from ${oldIndex} to ${this.selectedMenuItemIndex}`);
        this.updateSelectionHighlight();
    }
    /**
     * Get all interactive menu items
     */
    getMenuItems() {
        const items = Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));
        // Filter out non-interactive items like loading, empty, error
        return items.filter(item => {
            const actionId = item.dataset.actionId;
            return actionId !== 'loading' && actionId !== 'empty' && actionId !== 'error';
        });
    }
    /**
     * Update popup position, keeping the bottom edge fixed at the anchor point
     */
    updatePopupPosition() {
        var _a, _b;
        // Make sure anchor points are defined
        const anchorX = (_a = this._anchorX) !== null && _a !== void 0 ? _a : 0;
        const anchorY = (_b = this._anchorY) !== null && _b !== void 0 ? _b : 0;
        // Position the popup menu
        this.popupMenuContainer.style.position = 'absolute';
        this.popupMenuContainer.style.left = `${anchorX}px`;
        // Show the menu so we can calculate its height
        this.popupMenuContainer.style.display = 'block';
        // Get the actual height after rendering
        const menuHeight = this.popupMenuContainer.offsetHeight;
        // Add a small gap (10px) between the bottom of the menu and the trigger point
        const gap = 10;
        // Position above the cursor/button to keep bottom edge at the anchor point:
        // y - gap = bottom edge of popup, so popup top = y - gap - menuHeight
        this.popupMenuContainer.style.top = `${anchorY - gap - menuHeight}px`;
        console.log(`POPUP: Positioned menu at height ${menuHeight}px with bottom at ${anchorY - gap}px`);
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
const markdown_config_1 = __webpack_require__(/*! ./markdown-config */ "./node_modules/jupyter-simple-extension/lib/markdown-config.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/popup-menu-manager.js");
const highlight_js_1 = __importDefault(__webpack_require__(/*! highlight.js */ "webpack/sharing/consume/default/highlight.js/highlight.js"));
// Add image cache object for base64 images - COMMENTED OUT, no longer needed for URL method
// const imageCache: Record<string, string> = {};
// Configure marked with our settings
(0, markdown_config_1.configureMarked)();
/**
 * Main sidebar widget for the AI chat interface
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    constructor(docManager) {
        super();
        this.isMarkdownMode = false;
        this.isInputExpanded = false;
        this.chatHistory = [];
        this.currentChatId = '';
        this.isHistoryViewActive = false;
        this.hasAtSymbol = false; // Track whether @ symbol is present in input
        this.hasCodeRefListeners = false; // Track whether code ref listeners are added
        /**
         * Handles keyboard shortcuts
         */
        this.handleKeyDown = (event) => {
            var _a, _b;
            // Check for @ key (for context menu) - changed from Ctrl+@
            if (event.key === '@') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Only show menu if input field is focused
                if (document.activeElement === this.inputField) {
                    // Get cursor position in input field
                    const cursorPosition = this.inputField.selectionStart || 0;
                    const textBeforeCursor = this.inputField.value.substring(0, cursorPosition);
                    // Calculate position to show menu
                    const inputRect = this.inputField.getBoundingClientRect();
                    const lineHeight = parseInt(window.getComputedStyle(this.inputField).lineHeight) || 20;
                    // Count newlines before cursor to determine vertical position
                    const linesBeforeCursor = (textBeforeCursor.match(/\n/g) || []).length;
                    // Calculate cursor position within current line
                    const lastNewline = textBeforeCursor.lastIndexOf('\n');
                    const charsInCurrentLine = lastNewline === -1 ? cursorPosition : cursorPosition - lastNewline - 1;
                    // Estimate horizontal position (using average character width)
                    const charWidth = 8; // Approximate width of a character in pixels
                    const horizontalOffset = charsInCurrentLine * charWidth;
                    // Calculate positions
                    const left = inputRect.left + horizontalOffset;
                    // Calculate the cursor's vertical position
                    const cursorTop = inputRect.top + (linesBeforeCursor * lineHeight);
                    console.log(`Showing popup at cursor position: (${left}, ${cursorTop})`);
                    // Insert @ symbol at cursor position
                    const newValue = this.inputField.value.substring(0, cursorPosition) +
                        '@' +
                        this.inputField.value.substring(cursorPosition);
                    this.inputField.value = newValue;
                    // Update has @ symbol flag
                    this.hasAtSymbol = true;
                    // Move cursor after the @ symbol
                    this.inputField.selectionStart = cursorPosition + 1;
                    this.inputField.selectionEnd = cursorPosition + 1;
                    // Show the popup menu above the cursor position
                    this.popupMenuManager.showPopupMenu(left + 60, cursorTop - 20);
                    this.showKeyboardShortcutIndicator('Browse cells, code, files, and more');
                }
            }
            // Check for Ctrl+L (for selected code)
            else if (event.ctrlKey && event.key.toLowerCase() === 'l') {
                // Prevent default browser behavior
                event.preventDefault();
                event.stopPropagation();
                // Get the current active cell
                const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
                if (!cell || !cell.editor) {
                    return;
                }
                try {
                    // Get the CodeMirror editor instance
                    const editor = cell.editor;
                    const view = editor.editor;
                    if (!view) {
                        return;
                    }
                    // Check if there's a selection
                    const state = view.state;
                    const selection = state.selection;
                    if (!selection.main.empty) {
                        // If there's a selection, use @code
                        const from = selection.main.from;
                        const to = selection.main.to;
                        const selectedText = state.doc.sliceString(from, to);
                        this.appendToInput(`@code ${selectedText}`);
                        this.showKeyboardShortcutIndicator('Selected code inserted');
                    }
                    else {
                        // If no selection, use @cell
                        const cellContext = (_b = globals_1.globals.cellContextTracker) === null || _b === void 0 ? void 0 : _b.getCurrentCellContext();
                        if (cellContext) {
                            this.appendToInput(`@cell ${cellContext.text}`);
                            this.showKeyboardShortcutIndicator('Cell content inserted');
                        }
                    }
                    // Ensure the sidebar is visible and focused
                    if (this.isHidden) {
                        this.show();
                    }
                    this.inputField.focus();
                }
                catch (error) {
                    console.error('Error handling keyboard shortcut:', error);
                }
            }
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        // Add the main CSS class for styling
        this.addClass('jp-llm-ext-sidebar');
        // Initialize API client
        this.apiClient = new api_client_1.ApiClient();
        // Initialize container elements before creating layout
        this.messageContainer = document.createElement('div');
        this.inputField = document.createElement('textarea');
        this.titleInput = document.createElement('input');
        this.historyContainer = document.createElement('div');
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'jp-llm-ext-keyboard-shortcut-indicator';
        this.node.appendChild(this.keyboardShortcutIndicator);
        // Create settings modal
        this.settingsModalContainer = this.createSettingsModal();
        this.node.appendChild(this.settingsModalContainer);
        // Instantiate the PopupMenuManager with callbacks
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {
            insertCode: (code) => this.appendToInput(`code ${code}`),
            insertCell: (content) => this.appendToInput(`cell ${content}`),
            insertFilePath: (path) => this.appendToInput(`file ${path}`),
            insertDirectoryPath: (path) => this.appendToInput(`directory ${path}`), // If needed
            getSelectedText: () => this.getSelectedText(),
            getCurrentCellContent: () => this.getCurrentCellContent(),
            insertCellByIndex: (index) => this.insertCellByIndex(index),
            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => this.insertCollapsedCodeRef(code, cellIndex, lineNumber, notebookName)
        });
        // Create a new chat on start
        this.createNewChat();
        this.node.appendChild(this.createLayout());
        // Pop-up menu will be attached to document.body when shown
        // Add keyboard shortcut listener
        document.addEventListener('keydown', this.handleKeyDown);
    }
    /**
     * Shows a visual indicator for keyboard shortcuts
     */
    showKeyboardShortcutIndicator(text) {
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Hide after 1 second
        setTimeout(() => {
            this.keyboardShortcutIndicator.classList.remove('visible');
        }, 1000);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        // Remove keyboard shortcut listener
        document.removeEventListener('keydown', this.handleKeyDown);
        // Remove keyboard shortcut indicator
        if (this.keyboardShortcutIndicator.parentNode) {
            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);
        }
        // Dispose the popup menu manager
        if (this.popupMenuManager) {
            this.popupMenuManager.dispose();
        }
        super.dispose();
    }
    /**
     * Creates the main layout for the sidebar
     */
    createLayout() {
        // Create the main container
        const mainContent = document.createElement('div');
        // The main class 'jp-llm-ext-sidebar' is added to this.node in the constructor
        // This container can have its own class if needed for further nesting/styling
        mainContent.className = 'jp-llm-ext-content-wrapper';
        // Create title input container
        const titleContainer = document.createElement('div');
        titleContainer.className = 'jp-llm-ext-title-container';
        // Set up title input
        this.titleInput.className = 'chat-title-input'; // Assuming this is styled correctly in CSS
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat';
        this.titleInput.addEventListener('change', () => this.updateCurrentChatTitle());
        titleContainer.appendChild(this.titleInput);
        // Create New Chat & History buttons
        const newChatButton = document.createElement('button');
        newChatButton.className = 'jp-Button jp-llm-ext-action-button';
        newChatButton.textContent = '+ New Chat';
        newChatButton.title = 'Start a new chat';
        newChatButton.addEventListener('click', () => this.createNewChat());
        const historyButton = document.createElement('button');
        historyButton.className = 'jp-Button jp-llm-ext-action-button';
        historyButton.textContent = 'History';
        historyButton.title = 'View chat history';
        historyButton.addEventListener('click', () => this.toggleHistoryView());
        // Configure message container
        this.messageContainer.className = 'jp-llm-ext-message-container';
        // Configure history container
        this.historyContainer.className = 'jp-llm-ext-history-container';
        this.historyContainer.style.display = 'none';
        // Configure input field (directly used later)
        this.inputField.placeholder = 'Ask me anything...';
        this.inputField.rows = 1;
        this.inputField.className = 'jp-llm-ext-input-field'; // Add class for styling
        // Add keypress listener to input field
        this.inputField.addEventListener('keypress', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.handleSendMessage();
            }
        });
        // Add input event listener to detect changes to the input field
        this.inputField.addEventListener('input', () => {
            // Check if the @ symbol has been removed
            const cursorPosition = this.inputField.selectionStart;
            const textBeforeCursor = this.inputField.value.slice(0, cursorPosition);
            const hasAtNow = textBeforeCursor.endsWith('@') &&
                (cursorPosition === 1 || // @ is at start of input
                    !!textBeforeCursor[cursorPosition - 2].match(/\s/)); // @ follows whitespace
            if (this.hasAtSymbol && !hasAtNow) {
                // @ symbol was present but now it's gone, hide the popup
                this.popupMenuManager.hidePopupMenu();
            }
            this.hasAtSymbol = hasAtNow;
        });
        // Create send button container (directly used later)
        const inputActionsContainer = document.createElement('div');
        inputActionsContainer.className = 'jp-llm-ext-input-actions-container';
        // Create send button
        const sendButton = document.createElement('button');
        sendButton.className = 'jp-Button jp-llm-ext-send-button';
        sendButton.textContent = 'Send';
        sendButton.addEventListener('click', () => this.handleSendMessage());
        inputActionsContainer.appendChild(sendButton);
        // Create controls container (Markdown toggle, @, etc.) (directly used later)
        const controlsContainer = this.createControlsContainer();
        // Create the new bottom bar container with three rows
        const bottomBarContainer = document.createElement('div');
        bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';
        this.bottomBarContainer = bottomBarContainer;
        // First row: Controls (Markdown toggle and action buttons)
        const topRow = document.createElement('div');
        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';
        topRow.appendChild(controlsContainer);
        // Second row: Input field
        const middleRow = document.createElement('div');
        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';
        middleRow.appendChild(this.inputField);
        // Third row: Action buttons (Send, New Chat, History)
        const bottomRow = document.createElement('div');
        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';
        // Add all buttons to bottom row
        bottomRow.appendChild(sendButton);
        bottomRow.appendChild(newChatButton);
        bottomRow.appendChild(historyButton);
        // Add all rows to the bottom bar container
        bottomBarContainer.appendChild(topRow);
        bottomBarContainer.appendChild(middleRow);
        bottomBarContainer.appendChild(bottomRow);
        // Assemble all main components
        mainContent.appendChild(titleContainer);
        mainContent.appendChild(this.messageContainer);
        mainContent.appendChild(this.historyContainer);
        mainContent.appendChild(bottomBarContainer);
        return mainContent;
    }
    /**
     * Creates a new chat session
     */
    createNewChat() {
        // Generate a unique ID for the chat
        const chatId = `chat-${Date.now()}`;
        // Create a new chat item
        const newChat = {
            id: chatId,
            title: 'New Chat',
            messages: []
        };
        // Add to history
        this.chatHistory.push(newChat);
        // Set as current chat
        this.currentChatId = chatId;
        // Update title input
        this.titleInput.value = newChat.title;
        // Clear message container
        if (this.messageContainer) {
            this.messageContainer.innerHTML = '';
        }
        // Hide history if it's visible
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Toggles between chat view and history view
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Show history view, hide message view and bottom bar
            this.messageContainer.style.display = 'none';
            this.historyContainer.style.display = 'block';
            this.bottomBarContainer.style.display = 'none'; // Use class property directly
            this.titleInput.style.display = 'none';
            // Populate history
            this.renderChatHistory();
        }
        else {
            // Show message view and bottom bar, hide history view
            this.messageContainer.style.display = 'block';
            this.historyContainer.style.display = 'none';
            this.bottomBarContainer.style.display = 'flex'; // Use class property directly
            this.titleInput.style.display = 'block';
        }
    }
    /**
     * Renders the chat history in the history container
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = '';
        if (this.chatHistory.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'jp-llm-ext-empty-history-message';
            emptyMessage.textContent = 'No chat history yet';
            this.historyContainer.appendChild(emptyMessage);
            return;
        }
        // Create a list of chat history items
        this.chatHistory.forEach(chat => {
            const historyItem = document.createElement('div');
            historyItem.className = 'jp-llm-ext-history-item';
            if (chat.id === this.currentChatId) {
                historyItem.classList.add('jp-llm-ext-active');
            }
            // Add title
            const title = document.createElement('div');
            title.className = 'jp-llm-ext-history-title';
            title.textContent = chat.title;
            // Add message preview
            const preview = document.createElement('div');
            preview.className = 'jp-llm-ext-history-preview';
            const lastMessage = chat.messages[chat.messages.length - 1];
            preview.textContent = lastMessage
                ? `${lastMessage.text.substring(0, 40)}${lastMessage.text.length > 40 ? '...' : ''}`
                : 'Empty chat';
            // Add click event
            historyItem.addEventListener('click', () => this.loadChat(chat.id));
            historyItem.appendChild(title);
            historyItem.appendChild(preview);
            this.historyContainer.appendChild(historyItem);
        });
    }
    /**
     * Loads a chat from history
     */
    loadChat(chatId) {
        const chat = this.chatHistory.find(c => c.id === chatId);
        if (!chat)
            return;
        // Set as current chat
        this.currentChatId = chatId;
        // Update title
        this.titleInput.value = chat.title;
        // Clear and re-populate message container
        this.messageContainer.innerHTML = '';
        chat.messages.forEach(msg => {
            this.addMessage(msg.text, msg.sender, msg.isMarkdown, false);
        });
        // Switch back to chat view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView();
        }
    }
    /**
     * Updates the title of the current chat
     */
    updateCurrentChatTitle() {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            chat.title = this.titleInput.value;
            // Add notification that title has been set
            const notification = document.createElement('div');
            notification.className = 'jp-llm-ext-toast-notification jp-llm-ext-title-updated';
            notification.textContent = 'Chat title updated';
            // Add to the main widget
            this.node.appendChild(notification);
            // Animate in
            setTimeout(() => {
                notification.classList.add('visible');
            }, 10);
            // Remove after delay
            setTimeout(() => {
                notification.classList.remove('visible');
                // Wait for fade out animation to complete before removing
                setTimeout(() => {
                    notification.remove();
                }, 300);
            }, 2000);
        }
    }
    /**
     * Creates the controls container with toggles and action buttons
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'jp-llm-ext-controls-container';
        // Create markdown toggle container
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'jp-llm-ext-toggle-container';
        // Create markdown toggle
        const markdownToggle = document.createElement('input');
        markdownToggle.type = 'checkbox';
        markdownToggle.id = 'markdown-toggle';
        // markdownToggle.style.marginRight = '5px'; // Style via CSS
        markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            this.inputField.placeholder = this.isMarkdownMode ?
                'Write markdown here...\n\n# Example heading\n- List item\n\n```code block```' :
                'Ask me anything...';
        });
        // Create toggle label
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        // toggleLabel.style.fontSize = '12px'; // Style via CSS
        // Add toggle elements to container
        toggleContainer.appendChild(markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // Create action buttons container (@, expand, settings)
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';
        // Create all action buttons
        const buttons = [
            {
                text: '@',
                title: 'Browse cells, code, files, and more',
                action: (event) => {
                    // Get the button's position
                    const targetButton = event.currentTarget;
                    const rect = targetButton.getBoundingClientRect();
                    // Show the popup menu above the button's top edge
                    this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);
                    event.preventDefault();
                    event.stopPropagation();
                }
            },
            { text: '‚§¢', title: 'Expand input', action: () => this.toggleInputExpansion(actionButtonsContainer.children[3]) },
            { text: '‚öôÔ∏è', title: 'Settings', action: (event) => { event.preventDefault(); event.stopPropagation(); this.showSettingsModal(); } },
        ];
        // Add all buttons to the container
        buttons.forEach(button => {
            const btn = this.createButton(button.text, button.title);
            btn.addEventListener('click', (e) => button.action(e));
            actionButtonsContainer.appendChild(btn);
        });
        // Add toggle and action buttons to the controls container
        // controlsContainer is now just for these inline controls, above the input field
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field
     */
    toggleInputExpansion(button) {
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            // Adjust height based on a class or CSS variable instead of fixed pixels if possible
            this.inputField.style.height = '200px';
            this.inputField.style.resize = 'vertical';
            button.textContent = '‚§°';
            button.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = ''; // Reset height
            this.inputField.style.resize = 'none';
            this.inputField.rows = 1; // Ensure it collapses back to 1 row height
            button.textContent = '‚§¢';
            button.title = 'Expand input';
        }
    }
    /**
     * Helper function to create a button with given text and tooltip
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        button.className = 'jp-Button jp-llm-ext-action-button';
        return button;
    }
    /**
     * Handles sending a message from the input field
     */
    handleSendMessage() {
        const message = this.inputField.value.trim();
        if (message) {
            // Process the message to replace code reference placeholders
            let processedMessage = message;
            let hasCodeRefs = false;
            // Check if we have code references
            if ('_codeRefMap' in this.inputField && this.inputField._codeRefMap instanceof Map) {
                const codeRefMap = this.inputField._codeRefMap;
                hasCodeRefs = codeRefMap.size > 0;
                // Create a processed message with the placeholders for display
                // We'll keep the original message for sending to the API
                processedMessage = message;
                // No need to actually modify the message since we'll use the DOM for rendering
            }
            // Add user message to UI (send as text, not markdown by default for user)
            this.addMessage(processedMessage, 'user', hasCodeRefs);
            // Clear input and reset the code reference map
            this.inputField.value = '';
            if ('_codeRefMap' in this.inputField) {
                this.inputField._codeRefMap = new Map();
            }
            this.inputField.rows = 1; // Reset rows after sending
            this.inputField.style.height = ''; // Reset height after sending
            // Reset expanded state if needed after sending
            if (this.isInputExpanded) {
                // Find the expand button to reset its state if needed (this might need adjustment based on final structure)
                const expandButton = this.node.querySelector('.jp-llm-ext-action-buttons-container button[title*="Collapse"]');
                if (expandButton) {
                    this.toggleInputExpansion(expandButton); // Collapse after sending
                }
                else {
                    this.inputField.style.height = ''; // Fallback reset
                    this.inputField.rows = 1;
                }
            }
            // Create a temporary message container for the bot's streaming response
            const botMessageDiv = document.createElement('div');
            botMessageDiv.className = 'jp-llm-ext-bot-message';
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            botMessageDiv.appendChild(markdownIndicator);
            // Create separate divs for streaming text and final markdown
            const streamingDiv = document.createElement('div');
            streamingDiv.className = 'streaming-content';
            streamingDiv.style.whiteSpace = 'pre-wrap';
            streamingDiv.style.fontFamily = 'monospace';
            streamingDiv.style.fontSize = '0.9em';
            botMessageDiv.appendChild(streamingDiv);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            contentDiv.style.display = 'none'; // Initially hidden
            botMessageDiv.appendChild(contentDiv);
            this.messageContainer.appendChild(botMessageDiv);
            // Variable to collect the complete response
            let completeResponse = '';
            // Get cell context if available
            const cellContext = globals_1.globals.cellContextTracker ?
                globals_1.globals.cellContextTracker.getCurrentCellContext() : null;
            // Stream response from API
            this.apiClient.streamChat(message, { cellContext }, 
            // On each chunk received
            (chunk) => {
                completeResponse += chunk;
                streamingDiv.textContent = completeResponse;
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On complete
            () => {
                // Hide streaming div, show final content div
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                // Check if the complete response is an image URL
                const isImageUrl = completeResponse.startsWith('/images/') && completeResponse.endsWith('.png');
                if (isImageUrl) {
                    // Create a container for the image that allows positioning the buttons
                    const imageContainer = document.createElement('div');
                    imageContainer.className = 'jp-llm-ext-image-container';
                    imageContainer.style.position = 'relative';
                    // Render as an image tag
                    const img = document.createElement('img');
                    const fullImageUrl = `http://127.0.0.1:8000${completeResponse}`; // Construct full URL
                    img.src = fullImageUrl;
                    img.alt = 'Image from bot';
                    img.style.maxWidth = '100%';
                    img.style.height = 'auto';
                    imageContainer.appendChild(img);
                    // Add action buttons for the image
                    const imgActionsDiv = document.createElement('div');
                    imgActionsDiv.className = 'jp-llm-ext-image-actions';
                    imgActionsDiv.style.position = 'absolute';
                    imgActionsDiv.style.bottom = '10px';
                    imgActionsDiv.style.right = '10px';
                    imgActionsDiv.style.display = 'flex';
                    imgActionsDiv.style.gap = '8px';
                    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                    imgActionsDiv.style.borderRadius = '4px';
                    imgActionsDiv.style.padding = '4px';
                    // Copy image button
                    const copyImgBtn = document.createElement('button');
                    copyImgBtn.className = 'jp-llm-ext-image-action-button';
                    copyImgBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    copyImgBtn.title = 'Copy image to clipboard';
                    copyImgBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.copyImageToClipboard(fullImageUrl);
                    });
                    imgActionsDiv.appendChild(copyImgBtn);
                    // Add file path button
                    const addPathBtn = document.createElement('button');
                    addPathBtn.className = 'jp-llm-ext-image-action-button';
                    addPathBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                    addPathBtn.title = 'Add image path to current cell';
                    addPathBtn.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.addMessageToCell(completeResponse); // Adds just the image path to the cell
                    });
                    imgActionsDiv.appendChild(addPathBtn);
                    // Add the buttons to the image container
                    imageContainer.appendChild(imgActionsDiv);
                    // Add the image container to the content div
                    contentDiv.appendChild(imageContainer);
                    // Save image URL to history (as text)
                    const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                    if (chat) {
                        chat.messages.push({
                            text: completeResponse, // Store the URL
                            sender: 'bot',
                            isMarkdown: false // Treat it as non-markdown for history
                        });
                    }
                }
                else {
                    // Try to render markdown
                    try {
                        const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
                        const rawHtml = marked_1.marked.parse(processedText);
                        const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                        contentDiv.innerHTML = sanitizedHtml;
                        // Check if this is an interrupt message
                        const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');
                        if (isInterrupt) {
                            // Create buttons container
                            const buttonsContainer = document.createElement('div');
                            buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';
                            buttonsContainer.style.marginTop = '12px';
                            buttonsContainer.style.display = 'flex';
                            buttonsContainer.style.gap = '8px';
                            // Create confirm button
                            const confirmButton = document.createElement('button');
                            confirmButton.className = 'jp-llm-ext-confirm-button';
                            confirmButton.textContent = 'Confirm';
                            confirmButton.style.padding = '6px 12px';
                            confirmButton.style.background = '#4CAF50';
                            confirmButton.style.color = 'white';
                            confirmButton.style.border = 'none';
                            confirmButton.style.borderRadius = '4px';
                            confirmButton.style.cursor = 'pointer';
                            confirmButton.style.fontWeight = 'bold';
                            confirmButton.addEventListener('click', () => {
                                // Disable buttons after click
                                confirmButton.disabled = true;
                                rejectButton.disabled = true;
                                confirmButton.style.opacity = '0.5';
                                rejectButton.style.opacity = '0.5';
                                // Add "confirmed" message as user 
                                this.addMessage('confirmed', 'user', false);
                                // Add status indicator
                                const statusIndicator = document.createElement('div');
                                statusIndicator.className = 'jp-llm-ext-status-indicator';
                                statusIndicator.innerHTML = `<span class="status-icon confirm-icon">‚úÖ</span><span class="status-line"></span><span class="status-text">User confirmed</span><span class="status-line"></span>`;
                                this.messageContainer.appendChild(statusIndicator);
                                // Send auto message to API without adding a new user message
                                this.handleSendAutoMessage('confirmed');
                            });
                            // Create reject button
                            const rejectButton = document.createElement('button');
                            rejectButton.className = 'jp-llm-ext-reject-button';
                            rejectButton.textContent = 'Reject';
                            rejectButton.style.padding = '6px 12px';
                            rejectButton.style.background = '#F44336';
                            rejectButton.style.color = 'white';
                            rejectButton.style.border = 'none';
                            rejectButton.style.borderRadius = '4px';
                            rejectButton.style.cursor = 'pointer';
                            rejectButton.style.fontWeight = 'bold';
                            rejectButton.addEventListener('click', () => {
                                // Disable buttons after click
                                confirmButton.disabled = true;
                                rejectButton.disabled = true;
                                confirmButton.style.opacity = '0.5';
                                rejectButton.style.opacity = '0.5';
                                // Add "rejected" message as user
                                this.addMessage('rejected', 'user', false);
                                // Add status indicator
                                const statusIndicator = document.createElement('div');
                                statusIndicator.className = 'jp-llm-ext-status-indicator';
                                statusIndicator.innerHTML = `<span class="status-icon reject-icon">‚ùå</span><span class="status-line"></span><span class="status-text">User rejected</span><span class="status-line"></span>`;
                                this.messageContainer.appendChild(statusIndicator);
                                // Send auto message to API without adding a new user message
                                this.handleSendAutoMessage('rejected');
                            });
                            // Add buttons to container
                            buttonsContainer.appendChild(confirmButton);
                            buttonsContainer.appendChild(rejectButton);
                            // Add container below the message
                            contentDiv.appendChild(buttonsContainer);
                        }
                        // Enhance code blocks with language detection and action buttons
                        const codeBlocks = contentDiv.querySelectorAll('pre code');
                        codeBlocks.forEach(block => {
                            var _a;
                            // Add standard JupyterLab classes for consistency
                            block.classList.add('jp-RenderedText');
                            (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                            // Get code content to detect language
                            const codeContent = block.textContent || '';
                            // Create code block header for buttons
                            const codeHeader = document.createElement('div');
                            codeHeader.className = 'jp-llm-ext-code-header';
                            // Add language indicator if detected
                            const language = this.detectLanguage(codeContent);
                            if (language) {
                                const langIndicator = document.createElement('span');
                                langIndicator.className = 'jp-llm-ext-code-language';
                                langIndicator.textContent = language;
                                codeHeader.appendChild(langIndicator);
                                // Add language class for syntax highlighting
                                block.classList.add(`language-${language}`);
                                // Apply syntax highlighting
                                try {
                                    block.innerHTML = this.highlightCode(codeContent, language);
                                }
                                catch (error) {
                                    console.error('Error applying syntax highlighting:', error);
                                    // Keep original content if highlighting fails
                                }
                            }
                            else {
                                // Try auto-detection if no specific language detected
                                try {
                                    block.innerHTML = this.highlightCode(codeContent, '');
                                }
                                catch (error) {
                                    console.error('Error applying auto syntax highlighting:', error);
                                    // Keep original content if highlighting fails
                                }
                            }
                            // Add action buttons to the code header
                            const actionsDiv = document.createElement('div');
                            actionsDiv.className = 'jp-llm-ext-code-actions';
                            // Copy button with icon
                            const copyButton = document.createElement('button');
                            copyButton.className = 'jp-llm-ext-code-action-button';
                            copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                            copyButton.title = 'Copy code to clipboard';
                            copyButton.addEventListener('click', (event) => {
                                event.stopPropagation();
                                this.copyToClipboard(codeContent);
                            });
                            actionsDiv.appendChild(copyButton);
                            // Add to button with icon
                            const addToButton = document.createElement('button');
                            addToButton.className = 'jp-llm-ext-code-action-button';
                            addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                            addToButton.title = 'Add code to current cell';
                            addToButton.addEventListener('click', (event) => {
                                event.stopPropagation();
                                this.addMessageToCell(codeContent);
                            });
                            actionsDiv.appendChild(addToButton);
                            // Add the actions to the header
                            codeHeader.appendChild(actionsDiv);
                            // Insert the header before the code block
                            if (block.parentElement) {
                                block.parentElement.insertBefore(codeHeader, block);
                            }
                        });
                        // Add action buttons for the bot message (Copy, Add to Cell)
                        console.log('Adding action buttons to streamed bot message');
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'jp-llm-ext-message-actions';
                        actionsDiv.style.display = 'flex'; // Ensure display is set
                        // Copy button
                        const copyButton = document.createElement('button');
                        copyButton.className = 'jp-llm-ext-message-action-button';
                        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                        copyButton.title = 'Copy message to clipboard';
                        copyButton.addEventListener('click', (event) => {
                            event.stopPropagation();
                            this.copyMessageToClipboard(completeResponse); // Copy the original markdown
                        });
                        actionsDiv.appendChild(copyButton);
                        // Add to Cell button
                        const addToButton = document.createElement('button');
                        addToButton.className = 'jp-llm-ext-message-action-button';
                        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                        addToButton.title = 'Add message to current cell';
                        addToButton.addEventListener('click', (event) => {
                            event.stopPropagation();
                            this.addMessageToCell(completeResponse); // Add the original markdown
                        });
                        actionsDiv.appendChild(addToButton);
                        botMessageDiv.appendChild(actionsDiv);
                        console.log('Action buttons added to bot message:', actionsDiv);
                    }
                    catch (error) {
                        contentDiv.textContent = completeResponse;
                        console.error('Failed to render markdown:', error);
                    }
                    // Save markdown to chat history
                    const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                    if (chat) {
                        chat.messages.push({
                            text: completeResponse,
                            sender: 'bot',
                            isMarkdown: true // It's markdown
                        });
                    }
                }
                this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
            }, 
            // On error
            (error) => {
                streamingDiv.style.display = 'none';
                contentDiv.style.display = 'block';
                contentDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
                console.error('API Error:', error);
            });
        }
    }
    /**
     * Handles sending an automatic message (like confirmed/rejected) from the UI
     */
    handleSendAutoMessage(message) {
        if (!message.trim())
            return;
        // Skip adding user message - the calling function will handle this
        // Prevent duplication of messages when called from confirm/reject buttons
        // Add a confirmation/rejection status indicator line only if not already added
        // by the calling function (checking if this is a direct call)
        const statusIndicator = document.createElement('div');
        statusIndicator.className = 'jp-llm-ext-status-indicator';
        // Set the appropriate icon and text based on the message
        if (message.toLowerCase() === 'confirmed') {
            statusIndicator.innerHTML = `<span class="status-icon confirm-icon">‚úÖ</span><span class="status-line"></span><span class="status-text">User confirmed</span><span class="status-line"></span>`;
        }
        else if (message.toLowerCase() === 'rejected') {
            statusIndicator.innerHTML = `<span class="status-icon reject-icon">‚ùå</span><span class="status-line"></span><span class="status-text">User rejected</span><span class="status-line"></span>`;
        }
        // Create a temporary message container for the bot's streaming response
        const botMessageDiv = document.createElement('div');
        botMessageDiv.className = 'jp-llm-ext-bot-message';
        const markdownIndicator = document.createElement('div');
        markdownIndicator.textContent = "MD";
        markdownIndicator.className = 'markdown-indicator';
        botMessageDiv.appendChild(markdownIndicator);
        // Create separate divs for streaming text and final markdown
        const streamingDiv = document.createElement('div');
        streamingDiv.className = 'streaming-content';
        streamingDiv.style.whiteSpace = 'pre-wrap';
        streamingDiv.style.fontFamily = 'monospace';
        streamingDiv.style.fontSize = '0.9em';
        botMessageDiv.appendChild(streamingDiv);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-content';
        contentDiv.style.display = 'none'; // Initially hidden
        botMessageDiv.appendChild(contentDiv);
        this.messageContainer.appendChild(botMessageDiv);
        // Variable to collect the complete response
        let completeResponse = '';
        // Get cell context if available
        const cellContext = globals_1.globals.cellContextTracker ?
            globals_1.globals.cellContextTracker.getCurrentCellContext() : null;
        // Stream response from API
        this.apiClient.streamChat(message, // This will be 'confirmed' or 'rejected'
        { cellContext }, 
        // On each chunk received
        (chunk) => {
            completeResponse += chunk;
            streamingDiv.textContent = completeResponse;
            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        }, 
        // On complete
        () => {
            // Hide streaming div, show final content div
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Check if the complete response is an image URL
            const isImageUrl = completeResponse.trim().startsWith('/images/') &&
                (completeResponse.trim().endsWith('.png') ||
                    completeResponse.trim().endsWith('.jpg') ||
                    completeResponse.trim().endsWith('.jpeg') ||
                    completeResponse.trim().endsWith('.gif'));
            if (isImageUrl) {
                // Create a container for the image
                const imageContainer = document.createElement('div');
                imageContainer.className = 'jp-llm-ext-image-container';
                imageContainer.style.position = 'relative';
                // Render as an image tag
                const img = document.createElement('img');
                const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // Construct full URL
                img.src = fullImageUrl;
                img.alt = 'Image from bot';
                img.style.maxWidth = '100%';
                img.style.height = 'auto';
                imageContainer.appendChild(img);
                // Add action buttons for the image
                const imgActionsDiv = document.createElement('div');
                imgActionsDiv.className = 'jp-llm-ext-image-actions';
                imgActionsDiv.style.position = 'absolute';
                imgActionsDiv.style.bottom = '10px';
                imgActionsDiv.style.right = '10px';
                imgActionsDiv.style.display = 'flex';
                imgActionsDiv.style.gap = '8px';
                imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
                imgActionsDiv.style.borderRadius = '4px';
                imgActionsDiv.style.padding = '4px';
                // Copy image button
                const copyImgBtn = document.createElement('button');
                copyImgBtn.className = 'jp-llm-ext-image-action-button';
                copyImgBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                copyImgBtn.title = 'Copy image to clipboard';
                copyImgBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.copyImageToClipboard(fullImageUrl);
                });
                imgActionsDiv.appendChild(copyImgBtn);
                // Add file path button
                const addPathBtn = document.createElement('button');
                addPathBtn.className = 'jp-llm-ext-image-action-button';
                addPathBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                addPathBtn.title = 'Add image path to current cell';
                addPathBtn.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.addMessageToCell(fullImageUrl); // Use the full image URL
                });
                imgActionsDiv.appendChild(addPathBtn);
                // Add the buttons to the image container
                imageContainer.appendChild(imgActionsDiv);
                // Add the image container to the content div
                contentDiv.appendChild(imageContainer);
                // Save image URL to history (as text)
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages.push({
                        text: completeResponse.trim(), // Store the URL
                        sender: 'bot',
                        isMarkdown: false // Treat it as non-markdown for history
                    });
                }
            }
            else {
                // Try to render markdown
                try {
                    const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
                    const rawHtml = marked_1.marked.parse(processedText);
                    const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                    contentDiv.innerHTML = sanitizedHtml;
                    // Check if this is an interrupt message
                    const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');
                    if (isInterrupt) {
                        // Add confirm/reject buttons (same as in addMessage method)
                        // Create buttons container
                        const buttonsContainer = document.createElement('div');
                        buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';
                        buttonsContainer.style.marginTop = '12px';
                        buttonsContainer.style.display = 'flex';
                        buttonsContainer.style.gap = '8px';
                        // Create confirm button
                        const confirmButton = document.createElement('button');
                        confirmButton.className = 'jp-llm-ext-confirm-button';
                        confirmButton.textContent = 'Confirm';
                        confirmButton.style.padding = '6px 12px';
                        confirmButton.style.background = '#4CAF50';
                        confirmButton.style.color = 'white';
                        confirmButton.style.border = 'none';
                        confirmButton.style.borderRadius = '4px';
                        confirmButton.style.cursor = 'pointer';
                        confirmButton.style.fontWeight = 'bold';
                        confirmButton.addEventListener('click', () => {
                            // Disable buttons after click
                            confirmButton.disabled = true;
                            rejectButton.disabled = true;
                            confirmButton.style.opacity = '0.5';
                            rejectButton.style.opacity = '0.5';
                            // Add "confirmed" message as user 
                            this.addMessage('confirmed', 'user', false);
                            // Add status indicator
                            const statusIndicator = document.createElement('div');
                            statusIndicator.className = 'jp-llm-ext-status-indicator';
                            statusIndicator.innerHTML = `<span class="status-icon confirm-icon">‚úÖ</span><span class="status-line"></span><span class="status-text">User confirmed</span><span class="status-line"></span>`;
                            this.messageContainer.appendChild(statusIndicator);
                            // Send auto message to API without adding a new user message
                            this.handleSendAutoMessage('confirmed');
                        });
                        // Create reject button
                        const rejectButton = document.createElement('button');
                        rejectButton.className = 'jp-llm-ext-reject-button';
                        rejectButton.textContent = 'Reject';
                        rejectButton.style.padding = '6px 12px';
                        rejectButton.style.background = '#F44336';
                        rejectButton.style.color = 'white';
                        rejectButton.style.border = 'none';
                        rejectButton.style.borderRadius = '4px';
                        rejectButton.style.cursor = 'pointer';
                        rejectButton.style.fontWeight = 'bold';
                        rejectButton.addEventListener('click', () => {
                            // Disable buttons after click
                            confirmButton.disabled = true;
                            rejectButton.disabled = true;
                            confirmButton.style.opacity = '0.5';
                            rejectButton.style.opacity = '0.5';
                            // Add "rejected" message as user
                            this.addMessage('rejected', 'user', false);
                            // Add status indicator
                            const statusIndicator = document.createElement('div');
                            statusIndicator.className = 'jp-llm-ext-status-indicator';
                            statusIndicator.innerHTML = `<span class="status-icon reject-icon">‚ùå</span><span class="status-line"></span><span class="status-text">User rejected</span><span class="status-line"></span>`;
                            this.messageContainer.appendChild(statusIndicator);
                            // Send auto message to API without adding a new user message
                            this.handleSendAutoMessage('rejected');
                        });
                        // Add buttons to container
                        buttonsContainer.appendChild(confirmButton);
                        buttonsContainer.appendChild(rejectButton);
                        // Add container below the message
                        contentDiv.appendChild(buttonsContainer);
                    }
                    // Enhance code blocks (existing code)
                    const codeBlocks = contentDiv.querySelectorAll('pre code');
                    codeBlocks.forEach(block => {
                        var _a;
                        // Add standard JupyterLab classes for consistency
                        block.classList.add('jp-RenderedText');
                        (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                        // Get code content to detect language
                        const codeContent = block.textContent || '';
                        // Create code block header for buttons
                        const codeHeader = document.createElement('div');
                        codeHeader.className = 'jp-llm-ext-code-header';
                        // Add language indicator if detected
                        const language = this.detectLanguage(codeContent);
                        if (language) {
                            const langIndicator = document.createElement('span');
                            langIndicator.className = 'jp-llm-ext-code-language';
                            langIndicator.textContent = language;
                            codeHeader.appendChild(langIndicator);
                            // Add language class for syntax highlighting
                            block.classList.add(`language-${language}`);
                            // Apply syntax highlighting
                            try {
                                block.innerHTML = this.highlightCode(codeContent, language);
                            }
                            catch (error) {
                                console.error('Error applying syntax highlighting:', error);
                                // Keep original content if highlighting fails
                            }
                        }
                        else {
                            // Try auto-detection if no specific language detected
                            try {
                                block.innerHTML = this.highlightCode(codeContent, '');
                            }
                            catch (error) {
                                console.error('Error applying auto syntax highlighting:', error);
                                // Keep original content if highlighting fails
                            }
                        }
                        // Add action buttons to the code header
                        const actionsDiv = document.createElement('div');
                        actionsDiv.className = 'jp-llm-ext-code-actions';
                        // Copy button with icon
                        const copyButton = document.createElement('button');
                        copyButton.className = 'jp-llm-ext-code-action-button';
                        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                        copyButton.title = 'Copy code to clipboard';
                        copyButton.addEventListener('click', (event) => {
                            event.stopPropagation();
                            this.copyToClipboard(codeContent);
                        });
                        actionsDiv.appendChild(copyButton);
                        // Add to button with icon
                        const addToButton = document.createElement('button');
                        addToButton.className = 'jp-llm-ext-code-action-button';
                        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                        addToButton.title = 'Add code to current cell';
                        addToButton.addEventListener('click', (event) => {
                            event.stopPropagation();
                            this.addMessageToCell(codeContent);
                        });
                        actionsDiv.appendChild(addToButton);
                        // Add the actions to the header
                        codeHeader.appendChild(actionsDiv);
                        // Insert the header before the code block
                        if (block.parentElement) {
                            block.parentElement.insertBefore(codeHeader, block);
                        }
                    });
                }
                catch (error) {
                    contentDiv.textContent = completeResponse;
                    console.error('Failed to render markdown:', error);
                }
                // Save markdown to chat history
                const chat = this.chatHistory.find(c => c.id === this.currentChatId);
                if (chat) {
                    chat.messages.push({
                        text: completeResponse,
                        sender: 'bot',
                        isMarkdown: true // It's markdown
                    });
                }
            }
            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        }, 
        // On error
        (error) => {
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            contentDiv.innerHTML = `<div class="error-message">Error: ${error.message}</div>`;
            console.error('API Error:', error);
        });
    }
    /**
     * Adds a message to the chat interface
     */
    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {
        console.log('Adding message:', { sender, isMarkdown });
        const messageDiv = document.createElement('div');
        messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';
        // Check if the message is an image URL from our backend
        const isImageUrl = sender === 'bot' && text.trim().startsWith('/images/') &&
            (text.trim().endsWith('.png') ||
                text.trim().endsWith('.jpg') ||
                text.trim().endsWith('.jpeg') ||
                text.trim().endsWith('.gif'));
        if (isImageUrl) {
            // Create a container for the image that allows positioning the buttons
            const imageContainer = document.createElement('div');
            imageContainer.className = 'jp-llm-ext-image-container';
            imageContainer.style.position = 'relative';
            // Render as an image tag
            const img = document.createElement('img');
            // Construct full URL assuming backend is at http://127.0.0.1:8000
            // TODO: Make backend URL configurable
            const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;
            img.src = fullImageUrl;
            img.alt = 'Image from bot';
            img.style.maxWidth = '100%'; // Ensure image fits within the container
            img.style.height = 'auto';
            imageContainer.appendChild(img);
            // Add action buttons for the image
            const imgActionsDiv = document.createElement('div');
            imgActionsDiv.className = 'jp-llm-ext-image-actions';
            imgActionsDiv.style.position = 'absolute';
            imgActionsDiv.style.bottom = '10px';
            imgActionsDiv.style.right = '10px';
            imgActionsDiv.style.display = 'flex';
            imgActionsDiv.style.gap = '8px';
            imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
            imgActionsDiv.style.borderRadius = '4px';
            imgActionsDiv.style.padding = '4px';
            // Copy image button
            const copyImgBtn = document.createElement('button');
            copyImgBtn.className = 'jp-llm-ext-image-action-button';
            copyImgBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
            copyImgBtn.title = 'Copy image to clipboard';
            copyImgBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                this.copyImageToClipboard(fullImageUrl);
            });
            imgActionsDiv.appendChild(copyImgBtn);
            // Add file path button
            const addPathBtn = document.createElement('button');
            addPathBtn.className = 'jp-llm-ext-image-action-button';
            addPathBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
            addPathBtn.title = 'Add image path to current cell';
            addPathBtn.addEventListener('click', (event) => {
                event.stopPropagation();
                this.addMessageToCell(fullImageUrl); // Use the full image URL
            });
            imgActionsDiv.appendChild(addPathBtn);
            // Add the buttons to the image container
            imageContainer.appendChild(imgActionsDiv);
            // Add the image container to the message div
            messageDiv.appendChild(imageContainer);
        }
        else if (sender === 'user' && isMarkdown) {
            // Special case: User message with code references
            const contentDiv = document.createElement('div');
            contentDiv.className = 'user-content-with-refs';
            // Process the text to replace code reference placeholders
            let processedText = text;
            // Check if we have a code reference map attached to the input field
            if ('_codeRefMap' in this.inputField && this.inputField._codeRefMap instanceof Map) {
                const codeRefMap = this.inputField._codeRefMap;
                // If we have code reference widgets to render
                if (codeRefMap.size > 0) {
                    // Create a document fragment to avoid multiple reflows
                    const fragment = document.createDocumentFragment();
                    // Split the text by code reference placeholders and create the widgets
                    const regex = /\[CodeRef:([^\]]+)\]/g;
                    let lastIndex = 0;
                    let match;
                    while ((match = regex.exec(processedText)) !== null) {
                        // Add the text before the placeholder
                        const textBefore = processedText.substring(lastIndex, match.index);
                        if (textBefore) {
                            const textNode = document.createTextNode(textBefore);
                            fragment.appendChild(textNode);
                        }
                        // Get the placeholder and its corresponding HTML
                        const placeholder = match[0];
                        const widgetHtml = codeRefMap.get(placeholder);
                        if (widgetHtml) {
                            // Create a temporary container for the HTML
                            const tempContainer = document.createElement('div');
                            tempContainer.innerHTML = widgetHtml;
                            // Append the code reference widget
                            while (tempContainer.firstChild) {
                                fragment.appendChild(tempContainer.firstChild);
                            }
                        }
                        else {
                            // If widget HTML not found, just add the placeholder text
                            const placeholderNode = document.createTextNode(placeholder);
                            fragment.appendChild(placeholderNode);
                        }
                        lastIndex = match.index + placeholder.length;
                    }
                    // Add any remaining text after the last placeholder
                    if (lastIndex < processedText.length) {
                        const textAfter = processedText.substring(lastIndex);
                        const textNode = document.createTextNode(textAfter);
                        fragment.appendChild(textNode);
                    }
                    // Add the processed content to the message
                    contentDiv.appendChild(fragment);
                    // Add click event handlers for the code reference widgets
                    const toggleButtons = contentDiv.querySelectorAll('.jp-llm-ext-code-ref-toggle');
                    toggleButtons.forEach(button => {
                        button.addEventListener('click', (event) => {
                            const target = event.target;
                            const widget = target.closest('.jp-llm-ext-code-ref-widget');
                            const content = widget === null || widget === void 0 ? void 0 : widget.querySelector('.jp-llm-ext-code-ref-content');
                            if (content) {
                                const isVisible = content.style.display !== 'none';
                                content.style.display = isVisible ? 'none' : 'block';
                                target.textContent = isVisible ? '‚Øà' : '‚ØÜ';
                            }
                            event.preventDefault();
                            event.stopPropagation();
                        });
                    });
                }
                else {
                    // Just plain text without code references
                    contentDiv.textContent = processedText;
                }
            }
            else {
                // No code reference map, just add the text
                contentDiv.textContent = processedText;
            }
            messageDiv.appendChild(contentDiv);
        }
        else if (isMarkdown || sender === 'bot') {
            // Render as markdown (existing logic)
            const markdownIndicator = document.createElement('div');
            markdownIndicator.textContent = "MD";
            markdownIndicator.className = 'markdown-indicator';
            messageDiv.appendChild(markdownIndicator);
            const contentDiv = document.createElement('div');
            contentDiv.className = 'markdown-content';
            try {
                // Process the text to handle common markdown issues
                const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
                // Parse markdown to HTML
                const rawHtml = marked_1.marked.parse(processedText);
                // Sanitize HTML to prevent XSS
                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                // Set content
                contentDiv.innerHTML = sanitizedHtml;
                // Enhance code blocks with language detection and action buttons
                const codeBlocks = contentDiv.querySelectorAll('pre code');
                codeBlocks.forEach(block => {
                    var _a;
                    // Add standard JupyterLab classes for consistency
                    block.classList.add('jp-RenderedText');
                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('jp-RenderedHTMLCommon');
                    // Get code content to detect language
                    const codeContent = block.textContent || '';
                    // Create code block header for buttons
                    const codeHeader = document.createElement('div');
                    codeHeader.className = 'jp-llm-ext-code-header';
                    // Add language indicator if detected
                    const language = this.detectLanguage(codeContent);
                    if (language) {
                        const langIndicator = document.createElement('span');
                        langIndicator.className = 'jp-llm-ext-code-language';
                        langIndicator.textContent = language;
                        codeHeader.appendChild(langIndicator);
                        // Add language class for syntax highlighting
                        block.classList.add(`language-${language}`);
                        // Apply syntax highlighting
                        try {
                            block.innerHTML = this.highlightCode(codeContent, language);
                        }
                        catch (error) {
                            console.error('Error applying syntax highlighting:', error);
                            // Keep original content if highlighting fails
                        }
                    }
                    else {
                        // Try auto-detection if no specific language detected
                        try {
                            block.innerHTML = this.highlightCode(codeContent, '');
                        }
                        catch (error) {
                            console.error('Error applying auto syntax highlighting:', error);
                            // Keep original content if highlighting fails
                        }
                    }
                    // Add action buttons to the code header
                    const actionsDiv = document.createElement('div');
                    actionsDiv.className = 'jp-llm-ext-code-actions';
                    // Copy button with icon
                    const copyButton = document.createElement('button');
                    copyButton.className = 'jp-llm-ext-code-action-button';
                    copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                    copyButton.title = 'Copy code to clipboard';
                    copyButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.copyToClipboard(codeContent);
                    });
                    actionsDiv.appendChild(copyButton);
                    // Add to button with icon
                    const addToButton = document.createElement('button');
                    addToButton.className = 'jp-llm-ext-code-action-button';
                    addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                    addToButton.title = 'Add code to current cell';
                    addToButton.addEventListener('click', (event) => {
                        event.stopPropagation();
                        this.addMessageToCell(codeContent);
                    });
                    actionsDiv.appendChild(addToButton);
                    // Add the actions to the header
                    codeHeader.appendChild(actionsDiv);
                    // Insert the header before the code block
                    if (block.parentElement) {
                        block.parentElement.insertBefore(codeHeader, block);
                    }
                });
            }
            catch (error) {
                contentDiv.textContent = text;
                console.error('Failed to render markdown:', error);
            }
            messageDiv.appendChild(contentDiv);
            // Add action buttons for bot messages (only for the whole message, not code blocks)
            if (sender === 'bot') {
                console.log('Adding action buttons to bot message'); // Debug log
                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'jp-llm-ext-message-actions';
                // Copy button with icon
                const copyButton = document.createElement('button');
                copyButton.className = 'jp-llm-ext-message-action-button';
                copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
                copyButton.title = 'Copy message to clipboard';
                copyButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.copyMessageToClipboard(text);
                });
                actionsDiv.appendChild(copyButton);
                // Add to button with icon
                const addToButton = document.createElement('button');
                addToButton.className = 'jp-llm-ext-message-action-button';
                addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
                addToButton.title = 'Add message to current cell';
                addToButton.addEventListener('click', (event) => {
                    event.stopPropagation();
                    this.addMessageToCell(text);
                });
                actionsDiv.appendChild(addToButton);
                // Add buttons to message
                messageDiv.appendChild(actionsDiv);
                console.log('Action buttons added to message:', actionsDiv); // Debug log
            }
        }
        else {
            messageDiv.textContent = text;
        }
        this.messageContainer.appendChild(messageDiv);
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        // Save to chat history
        if (saveToHistory) {
            const chat = this.chatHistory.find(c => c.id === this.currentChatId);
            if (chat) {
                chat.messages.push({
                    text,
                    sender,
                    isMarkdown: isMarkdown || sender === 'bot'
                });
            }
        }
    }
    /**
     * Copies message content to clipboard
     */
    copyMessageToClipboard(text) {
        try {
            navigator.clipboard.writeText(text).then(() => {
                console.log('Content copied to clipboard');
                // Find the button element that was clicked
                const buttons = document.querySelectorAll('.jp-llm-ext-message-action-button');
                let clickedButton = null;
                for (let i = 0; i < buttons.length; i++) {
                    const button = buttons[i];
                    if (button.title === 'Copy message to clipboard' && button === document.activeElement) {
                        clickedButton = button;
                        break;
                    }
                }
                // Show visual feedback if we found the button
                if (clickedButton) {
                    const originalHTML = clickedButton.innerHTML;
                    clickedButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6L9 17l-5-5"></path></svg>';
                    setTimeout(() => {
                        clickedButton.innerHTML = originalHTML;
                    }, 2000);
                }
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        catch (error) {
            console.error('Error copying to clipboard:', error);
        }
    }
    /**
     * Adds message content to the current cell
     */
    addMessageToCell(text) {
        var _a;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell || !cell.editor) {
            return;
        }
        try {
            const editor = cell.editor;
            const view = editor.editor;
            if (!view) {
                return;
            }
            // Get current cursor position
            const state = view.state;
            const selection = state.selection;
            const cursorPos = selection.main.head;
            // Insert newline and message content at cursor position
            const transaction = state.update({
                changes: {
                    from: cursorPos,
                    insert: `\n${text}`
                },
                selection: { anchor: cursorPos + text.length + 1 }
            });
            view.dispatch(transaction);
        }
        catch (error) {
            console.error('Error adding message to cell:', error);
        }
    }
    /**
     * Gets the currently selected text from the active notebook cell.
     * (Helper for PopupMenuManager callback)
     */
    getSelectedText() {
        var _a, _b, _c;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (cell === null || cell === void 0 ? void 0 : cell.editor) {
            const editor = cell.editor; // IEditor
            // Access CodeMirror editor instance if possible
            const cmEditor = editor.editor;
            if (cmEditor && cmEditor.state) {
                const state = cmEditor.state;
                const selection = state.selection.main; // Get the main selection
                if (selection.empty) {
                    return null; // No text selected
                }
                return state.doc.sliceString(selection.from, selection.to);
            }
            console.warn("Could not access CodeMirror state to get selection.");
            // Avoid using getRange as it's confirmed not to exist on IEditor
            return null;
        }
        else {
            // Attempt to get selection from document if no notebook active (e.g., text editor)
            const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
            if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {
                const editor = activeWidget.content.editor;
                const cmEditor = editor.editor;
                if (cmEditor && cmEditor.state) {
                    const state = cmEditor.state;
                    const selection = state.selection.main;
                    if (selection.empty) {
                        return null;
                    }
                    return state.doc.sliceString(selection.from, selection.to);
                }
                console.warn("Could not access CodeMirror state for non-notebook editor selection.");
                return null; // Avoid getRange
            }
        }
        return null;
    }
    /**
     * Gets the content of the currently active notebook cell.
     * (Helper for PopupMenuManager callback)
     */
    getCurrentCellContent() {
        var _a, _b, _c;
        const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {
            // Try using sharedModel first (more robust)
            if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {
                return activeCell.model.sharedModel.getSource();
            }
            // Fallback: Try using toJSON().source
            const cellJson = activeCell.model.toJSON();
            if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {
                return cellJson.source;
            }
            else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {
                // If source is an array of strings, join them
                return cellJson.source.join('\n');
            }
            console.warn("Could not get cell content via model.value.text or toJSON().source");
            return null;
        }
        // Fallback for non-notebook editors if needed
        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
        if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {
            return activeWidget.content.model.value.text;
        }
        return null;
    }
    /**
     * Appends text to the input field with proper spacing
     */
    appendToInput(text) {
        try {
            const currentValue = this.inputField.value;
            if (currentValue) {
                // add a space between the current value and the new text
                this.inputField.value = `${currentValue}${text}`;
            }
            else {
                this.inputField.value = text;
            }
            // Focus the input field and move cursor to end
            this.inputField.focus();
            this.inputField.setSelectionRange(this.inputField.value.length, this.inputField.value.length);
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    // Settings modal methods
    createSettingsModal() {
        const modal = document.createElement('div');
        modal.className = 'jp-llm-ext-settings-modal';
        modal.style.display = 'none'; // Keep this inline style for toggling visibility
        const content = document.createElement('div');
        content.className = 'jp-llm-ext-settings-content';
        const title = document.createElement('h2');
        title.className = 'jp-llm-ext-settings-title';
        title.textContent = 'Settings';
        content.appendChild(title);
        const form = document.createElement('form');
        form.className = 'jp-llm-ext-settings-form';
        // Provider selection
        const providerLabel = document.createElement('label');
        providerLabel.className = 'jp-llm-ext-settings-label';
        providerLabel.textContent = 'API Provider:';
        form.appendChild(providerLabel);
        const providerSelect = document.createElement('select');
        providerSelect.className = 'jp-llm-ext-settings-select';
        providerSelect.id = 'settings-provider';
        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            providerSelect.appendChild(option);
        });
        form.appendChild(providerSelect);
        // API Key input
        const apiKeyLabel = document.createElement('label');
        apiKeyLabel.className = 'jp-llm-ext-settings-label';
        apiKeyLabel.textContent = 'API Key:';
        form.appendChild(apiKeyLabel);
        const apiKeyInput = document.createElement('input');
        apiKeyInput.className = 'jp-llm-ext-settings-input';
        apiKeyInput.type = 'password';
        apiKeyInput.id = 'settings-api-key';
        form.appendChild(apiKeyInput);
        // API URL input
        const apiUrlLabel = document.createElement('label');
        apiUrlLabel.className = 'jp-llm-ext-settings-label';
        apiUrlLabel.textContent = 'API URL (optional):';
        form.appendChild(apiUrlLabel);
        const apiUrlInput = document.createElement('input');
        apiUrlInput.className = 'jp-llm-ext-settings-input';
        apiUrlInput.type = 'text';
        apiUrlInput.id = 'settings-api-url';
        form.appendChild(apiUrlInput);
        // Rules input
        const rulesLabel = document.createElement('label');
        rulesLabel.className = 'jp-llm-ext-settings-label';
        rulesLabel.textContent = 'Custom Rules (optional):';
        form.appendChild(rulesLabel);
        const rulesInput = document.createElement('textarea');
        rulesInput.className = 'jp-llm-ext-settings-textarea';
        rulesInput.id = 'settings-rules';
        form.appendChild(rulesInput);
        // Buttons container
        const btnContainer = document.createElement('div');
        btnContainer.className = 'jp-llm-ext-settings-buttons';
        const saveBtn = document.createElement('button');
        saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Add this line
            const provider = document.getElementById('settings-provider').value;
            const key = document.getElementById('settings-api-key').value;
            const url = document.getElementById('settings-api-url').value;
            const rules = document.getElementById('settings-rules').value;
            // Save settings to localStorage for persistence
            const settings = { provider, key, url, rules };
            localStorage.setItem('jp-llm-ext-settings', JSON.stringify(settings));
            console.log('Settings saved:', settings);
            this.hideSettingsModal();
            this.popSaveSuccess();
            // Update API client with new settings if needed
            if (url) {
                this.apiClient = new api_client_1.ApiClient(url);
            }
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';
        cancelBtn.textContent = 'Cancel';
        cancelBtn.addEventListener('click', (event) => {
            event.preventDefault(); // Add this line
            this.hideSettingsModal();
        });
        btnContainer.appendChild(saveBtn);
        btnContainer.appendChild(cancelBtn);
        form.appendChild(btnContainer);
        content.appendChild(form);
        modal.appendChild(content);
        return modal;
    }
    showSettingsModal() {
        // Load saved settings from localStorage
        this.loadSavedSettings();
        this.settingsModalContainer.style.display = 'flex';
    }
    loadSavedSettings() {
        const savedSettings = localStorage.getItem('jp-llm-ext-settings');
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                // Update UI with saved settings
                if (settings.provider) {
                    document.getElementById('settings-provider').value = settings.provider;
                }
                if (settings.key) {
                    document.getElementById('settings-api-key').value = settings.key;
                }
                if (settings.url) {
                    document.getElementById('settings-api-url').value = settings.url;
                }
                if (settings.rules) {
                    document.getElementById('settings-rules').value = settings.rules;
                }
            }
            catch (error) {
                console.error('Error loading saved settings:', error);
            }
        }
    }
    hideSettingsModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    popSaveSuccess() {
        // Create a toast notification container
        const toast = document.createElement('div');
        toast.className = 'jp-llm-ext-toast-notification jp-llm-ext-settings-success';
        toast.textContent = 'Settings saved successfully';
        // Add to the main widget (not the modal which is hidden)
        this.node.appendChild(toast);
        // Animate in
        setTimeout(() => {
            toast.classList.add('visible');
        }, 10);
        // Remove after delay
        setTimeout(() => {
            toast.classList.remove('visible');
            // Wait for fade out animation to complete before removing
            setTimeout(() => {
                toast.remove();
            }, 300);
        }, 3000);
    }
    /**
     * Gets cell content by index from the current notebook and inserts it into the input field
     */
    insertCellByIndex(index) {
        try {
            if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {
                console.error('No active notebook found');
                return;
            }
            const notebookPanel = globals_1.globals.notebookTracker.currentWidget;
            const model = notebookPanel.content.model;
            if (!model || !model.cells || index >= model.cells.length) {
                console.error(`Invalid cell index: ${index}`);
                return;
            }
            const cell = model.cells.get(index);
            let cellContent = '';
            // Get cell content - handle different ways content might be stored
            if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {
                cellContent = cell.sharedModel.getSource();
            }
            else {
                const cellJson = cell.toJSON();
                if (typeof (cellJson === null || cellJson === void 0 ? void 0 : cellJson.source) === 'string') {
                    cellContent = cellJson.source;
                }
                else if (Array.isArray(cellJson === null || cellJson === void 0 ? void 0 : cellJson.source)) {
                    cellContent = cellJson.source.join('\n');
                }
            }
            // Insert cell reference with content, without type indicator or execution count
            this.appendToInput(`cell ${cellContent}`);
        }
        catch (error) {
            console.error('Error inserting cell by index:', error);
        }
    }
    /**
     * Detects the programming language from code block content
     */
    detectLanguage(code) {
        try {
            // Try auto detection first
            const result = highlight_js_1.default.highlightAuto(code, [
                'python', 'javascript', 'typescript', 'java',
                'html', 'css', 'cpp', 'csharp', 'sql', 'rust',
                'php', 'bash', 'json', 'xml', 'markdown'
            ]);
            // If confidence is high enough, use that language
            if (result.relevance > 5) {
                return result.language || '';
            }
            // Fall back to pattern matching for better accuracy
            if (/^(?:\s*)?(?:import\s+[^;]+;|package\s+[^;]+;|public\s+class)/.test(code)) {
                return 'java';
            }
            else if (/^(?:\s*)?(import|from|def|class|if __name__)\s/.test(code)) {
                return 'python';
            }
            else if (/^(?:\s*)?(?:function|const|let|var|import)\s/.test(code)) {
                return 'javascript';
            }
            else if (/^(?:\s*)?(?:<!DOCTYPE|<html|<head|<body)/.test(code)) {
                return 'html';
            }
            else if (/^(?:\s*)?#include/.test(code)) {
                return 'cpp';
            }
            else if (/^(?:\s*)?(?:using\s+System|namespace|public\s+static\s+void\s+Main)/.test(code)) {
                return 'csharp';
            }
            else if (/^(?:\s*)?(?:\$|SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\s/i.test(code)) {
                return 'sql';
            }
            else if (/^(?:\s*)?(?:module|fn|let|struct|enum|trait|impl)\s/.test(code)) {
                return 'rust';
            }
            else if (/^(?:\s*)?(?:<?php|use\s+[\w\\]+;)/.test(code)) {
                return 'php';
            }
            else if (/^(?:\s*)?(?:#\s*!\/usr\/bin\/env|require|module\.exports|console\.)/.test(code)) {
                return 'bash';
            }
            return '';
        }
        catch (error) {
            console.error('Error detecting language:', error);
            return '';
        }
    }
    /**
     * Highlights code with appropriate syntax highlighting
     */
    highlightCode(code, language) {
        try {
            if (!language) {
                // Try to auto-detect if no language specified
                return highlight_js_1.default.highlightAuto(code).value;
            }
            if (highlight_js_1.default.getLanguage(language)) {
                return highlight_js_1.default.highlight(code, { language }).value;
            }
            else {
                // Fallback to auto-detection if specified language isn't available
                return highlight_js_1.default.highlightAuto(code).value;
            }
        }
        catch (error) {
            console.error('Error highlighting code:', error);
            return code; // Return original code on error
        }
    }
    // Helper function to copy text to clipboard with visual feedback
    copyToClipboard(text) {
        try {
            navigator.clipboard.writeText(text).then(() => {
                console.log('Content copied to clipboard');
                // Show a temporary notification
                const notification = document.createElement('div');
                notification.className = 'jp-llm-ext-toast-notification jp-llm-ext-copy-success';
                notification.textContent = 'Copied to clipboard';
                // Add to the main widget
                this.node.appendChild(notification);
                // Animate in
                setTimeout(() => {
                    notification.classList.add('visible');
                }, 10);
                // Remove after delay
                setTimeout(() => {
                    notification.classList.remove('visible');
                    // Wait for fade out animation to complete before removing
                    setTimeout(() => {
                        notification.remove();
                    }, 300);
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy text: ', err);
            });
        }
        catch (error) {
            console.error('Error copying to clipboard:', error);
        }
    }
    /**
     * Copies an image to the clipboard
     */
    copyImageToClipboard(imageUrl) {
        try {
            // Fetch the image
            fetch(imageUrl)
                .then(response => response.blob())
                .then(blob => {
                // Create a ClipboardItem with the image blob
                const item = new ClipboardItem({
                    [blob.type]: blob
                });
                // Copy the image to clipboard
                navigator.clipboard.write([item]).then(() => {
                    console.log('Image copied to clipboard');
                    // Show visual feedback
                    const notification = document.createElement('div');
                    notification.className = 'jp-llm-ext-toast-notification jp-llm-ext-copy-success';
                    notification.textContent = 'Image copied to clipboard';
                    // Add to the main widget
                    this.node.appendChild(notification);
                    // Animate in
                    setTimeout(() => {
                        notification.classList.add('visible');
                    }, 10);
                    // Remove after delay
                    setTimeout(() => {
                        notification.classList.remove('visible');
                        // Wait for fade out animation to complete before removing
                        setTimeout(() => {
                            notification.remove();
                        }, 300);
                    }, 1500);
                })
                    .catch(err => {
                    console.error('Failed to copy image: ', err);
                    alert('Failed to copy image: ' + err.message);
                });
            })
                .catch(err => {
                console.error('Failed to fetch image: ', err);
                alert('Failed to fetch image: ' + err.message);
            });
        }
        catch (error) {
            console.error('Error copying image to clipboard:', error);
            alert('Error copying image to clipboard: ' + error);
        }
    }
    /**
     * Inserts a collapsible code reference widget in the input area
     */
    insertCollapsedCodeRef(code, cellIndex, lineNumber, notebookName) {
        try {
            // Create a unique ID for this reference
            const refId = `code-ref-${Date.now()}-${Math.floor(Math.random() * 10000)}`;
            // Format the reference as "notebook-name:cell-index-line-number"
            const codeRef = `${notebookName}:${cellIndex}-${lineNumber}`;
            // Create the collapsible widget HTML
            const widgetHtml = `<span class="jp-llm-ext-code-ref-widget" data-ref-id="${refId}" data-code="${encodeURIComponent(code)}" data-ref="${codeRef}">
        <span class="jp-llm-ext-code-ref-label">${codeRef}</span>
        <button class="jp-llm-ext-code-ref-toggle" title="Expand/collapse code">‚Øà</button>
        <span class="jp-llm-ext-code-ref-content" style="display:none;">${code}</span>
      </span>`;
            // Insert at cursor position or append to end
            const cursorPos = this.inputField.selectionStart || 0;
            const textBeforeCursor = this.inputField.value.substring(0, cursorPos);
            const textAfterCursor = this.inputField.value.substring(cursorPos);
            // Insert widget placeholder text in the textarea
            const placeholderText = `[CodeRef:${codeRef}]`;
            this.inputField.value = textBeforeCursor + placeholderText + textAfterCursor;
            // Store the HTML to replace the placeholder when rendering
            let elementMap;
            if (!('_codeRefMap' in this.inputField)) {
                elementMap = new Map();
                this.inputField._codeRefMap = elementMap;
            }
            else {
                elementMap = this.inputField._codeRefMap;
            }
            // Store the HTML to replace the placeholder when rendering
            elementMap.set(placeholderText, widgetHtml);
            // Focus the input field and move cursor to after the inserted widget
            this.inputField.focus();
            this.inputField.setSelectionRange(cursorPos + placeholderText.length, cursorPos + placeholderText.length);
            // Add event listener for expanding/collapsing (delegated to parent)
            if (!this.hasCodeRefListeners) {
                this.inputField.addEventListener('click', this.handleCodeRefClick.bind(this));
                this.hasCodeRefListeners = true;
            }
        }
        catch (error) {
            console.error('Error inserting collapsed code reference:', error);
            // Fallback to inserting code directly
            this.appendToInput(`code ${code}`);
        }
    }
    /**
     * Handle clicks on code reference expand/collapse buttons
     */
    handleCodeRefClick(event) {
        const target = event.target;
        // Check if it's the toggle button
        if (target.classList.contains('jp-llm-ext-code-ref-toggle')) {
            // Find the parent widget
            const widget = target.closest('.jp-llm-ext-code-ref-widget');
            if (!widget)
                return;
            // Find the content element
            const content = widget.querySelector('.jp-llm-ext-code-ref-content');
            if (!content)
                return;
            // Toggle the content visibility
            const isVisible = content.style.display !== 'none';
            content.style.display = isVisible ? 'none' : 'block';
            // Update the toggle button text
            target.textContent = isVisible ? '‚Øà' : '‚ØÜ';
            // Stop event propagation
            event.preventDefault();
            event.stopPropagation();
        }
    }
}
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy5jYzg5YTllZmFiN2FhMzBjOGJjMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7OztBQ3JFSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7Ozs7Ozs7OztBQzdJYjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsZ0JBQWdCLG1CQUFPLENBQUMscUVBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsWUFBWTtBQUNuRTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7Ozs7Ozs7Ozs7O0FDaENhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGVBQWU7QUFDZixtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxtQkFBbUI7QUFDdkIsSUFBSSwrQkFBK0I7QUFDbkM7Ozs7Ozs7Ozs7O0FDZGE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QscUJBQXFCO0FBQ3JCLHdCQUF3QixtQkFBTyxDQUFDLHNIQUEyQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsQ0FBQzs7Ozs7Ozs7Ozs7QUNqQlk7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUJBQWlCO0FBQ2pCLG1CQUFtQixtQkFBTyxDQUFDLHVHQUFzQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBc0I7QUFDakQsbUJBQW1CLG1CQUFPLENBQUMsdUdBQXNCO0FBQ2pELHFCQUFxQixtQkFBTyxDQUFDLDZHQUF3QjtBQUNyRCx5QkFBeUIsbUJBQU8sQ0FBQyx1RkFBa0I7QUFDbkQsa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckMsbUJBQW1CLG1CQUFPLENBQUMsMkVBQVk7QUFDdkMsK0JBQStCLG1CQUFPLENBQUMsbUdBQXdCO0FBQy9ELFlBQVksWUFBWTtBQUN4QjtBQUNBLG1CQUFPLENBQUMsbUZBQW9CO0FBQzVCO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsK0VBQWM7QUFDekMsNkNBQTRDLEVBQUUscUNBQXFDLGtDQUFrQyxFQUFDO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxZQUFZO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWU7Ozs7Ozs7Ozs7O0FDckNGO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QiwwQkFBMEI7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7OztBQ3JEYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLHlDQUF5QztBQUN6QyxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsRUFBRSxJQUFJLEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLHlEQUF5RDtBQUN2RSxjQUFjLDJEQUEyRDtBQUN6RSxjQUFjLDBEQUEwRDtBQUN4RSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLGdFQUFnRSxNQUFNLEVBQUUsU0FBUztBQUNqRjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0Esa0dBQWtHLFdBQVc7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxNQUFNO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixrQkFBa0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsZUFBZTtBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0Usd0NBQXdDO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsZUFBZSxFQUFFLGtCQUFrQixFQUFFLGlCQUFpQjtBQUNoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsTUFBTTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsU0FBUyxVQUFVLEtBQUs7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGtGQUFrRjtBQUM1RywwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxLQUFLLEdBQUcseURBQXlEO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsTUFBTSxVQUFVLEtBQUs7QUFDeEU7QUFDQTtBQUNBLG9DQUFvQywwREFBMEQ7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsb0JBQW9CLFVBQVUsbUJBQW1CO0FBQzdHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxTQUFTLGFBQWEsb0JBQW9CO0FBQzlHO0FBQ0EsNEJBQTRCLFNBQVMsR0FBRyxvQkFBb0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsVUFBVTtBQUNyRCxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJCQUEyQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLFVBQVU7QUFDekQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSx3Q0FBd0MsbUJBQW1CLGtCQUFrQixTQUFTO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSxTQUFTO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxNQUFNLEtBQUssUUFBUTtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYyxLQUFLLFFBQVE7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxRQUFRO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUscUJBQXFCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFVBQVUsYUFBYSxvRUFBb0Usb0JBQW9CLDRDQUE0QztBQUN0TTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsVUFBVTtBQUNwRjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxpQ0FBaUM7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNEJBQTRCLFFBQVEsa0JBQWtCO0FBQ2hJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLE1BQU07QUFDbEc7QUFDQSwwQ0FBMEMsa0JBQWtCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnR0FBZ0csTUFBTTtBQUN0RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxVQUFVLEtBQUssMkJBQTJCO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVLEtBQUssMkJBQTJCO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsMkJBQTJCO0FBQzFFLHdEQUF3RCxXQUFXLG9CQUFvQixjQUFjO0FBQ3JHO0FBQ0E7QUFDQSx3QkFBd0I7Ozs7Ozs7Ozs7O0FDbjdCWDtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQjtBQUMzQixrQkFBa0IsbUJBQU8sQ0FBQyx3RkFBaUI7QUFDM0MsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVE7QUFDakMsb0NBQW9DLG1CQUFPLENBQUMsc0VBQVc7QUFDdkQsZ0JBQWdCLG1CQUFPLENBQUMscUVBQVM7QUFDakMsa0JBQWtCLG1CQUFPLENBQUMseUVBQVc7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsK0VBQWM7QUFDM0MsMEJBQTBCLG1CQUFPLENBQUMseUZBQW1CO0FBQ3JELDZCQUE2QixtQkFBTyxDQUFDLCtGQUFzQjtBQUMzRCx1Q0FBdUMsbUJBQU8sQ0FBQywrRUFBYztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLEtBQUssSUFBSSxVQUFVO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGFBQWE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGlCQUFpQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxLQUFLO0FBQ2xFLGdFQUFnRSxRQUFRO0FBQ3hFLGlFQUFpRSxLQUFLO0FBQ3RFLDJFQUEyRSxLQUFLO0FBQ2hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsV0FBVztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixrQ0FBa0MsRUFBRSwwQ0FBMEM7QUFDbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixjQUFjLCtHQUErRztBQUM3SCxjQUFjLG9EQUFvRCx3QkFBd0IseUJBQXlCLDZCQUE2QjtBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZEO0FBQzdEO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxhQUFhO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxpQkFBaUIsR0FBRztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRTtBQUNqRSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLFNBQVM7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRDtBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJFQUEyRTtBQUMzRSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRTtBQUNyRSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSxjQUFjO0FBQzFGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsYUFBYTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCx3QkFBd0IsR0FBRztBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsU0FBUztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3RUFBd0UsY0FBYztBQUN0RjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLG9CQUFvQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFlBQVk7QUFDckU7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRCxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsU0FBUztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msb0JBQW9CO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxLQUFLO0FBQ3RDLGlCQUFpQjtBQUNqQiw2QkFBNkI7QUFDN0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsYUFBYSxFQUFFLEtBQUs7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELE1BQU07QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFlBQVk7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEdBQUcsY0FBYyxHQUFHO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsVUFBVTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxXQUFXLEdBQUcsa0NBQWtDO0FBQ3RGO0FBQ0EsK0JBQStCLGFBQWEsR0FBRyxVQUFVLEdBQUcsV0FBVztBQUN2RTtBQUNBLHdGQUF3RixNQUFNLGVBQWUseUJBQXlCLGNBQWMsUUFBUTtBQUM1SixrREFBa0QsUUFBUTtBQUMxRDtBQUNBLHNFQUFzRSxJQUFJLEtBQUs7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEtBQUs7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9hcGktY2xpZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NlbGwtY29udGV4dC10cmFja2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NvbW1hbmRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2dsb2JhbHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaWNvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvbWFya2Rvd24tY29uZmlnLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3BvcHVwLW1lbnUtbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9zaWRlYmFyLXdpZGdldC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBpQ2xpZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBBUEkgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kIExMTSBzZXJ2aWNlXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYmFzZVVybCA9ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnKSB7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBhIGNoYXQgcmVzcG9uc2UgZnJvbSB0aGUgbW9jayBMTE1cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgdXNlciBtZXNzYWdlIHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIG9uQ2h1bmsgQ2FsbGJhY2sgZm9yIGVhY2ggdGV4dCBjaHVuayByZWNlaXZlZFxuICAgICAqIEBwYXJhbSBvbkNvbXBsZXRlIENhbGxiYWNrIHdoZW4gc3RyZWFtaW5nIGlzIGNvbXBsZXRlXG4gICAgICogQHBhcmFtIG9uRXJyb3IgQ2FsbGJhY2sgZm9yIGVycm9yc1xuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbUNoYXQobWVzc2FnZSwgY29udGV4dCA9IG51bGwsIG9uQ2h1bmssIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9jaGF0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZVN0cmVhbSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB1cCBzdHJlYW0gcmVhZGluZ1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lOiByZWFkZXJEb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGRvbmUgPSByZWFkZXJEb25lO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogIWRvbmUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgaGVhbHRoIGNoZWNrIGZvciB0aGUgQVBJXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgQVBJIGlzIGhlYWx0aHlcbiAgICAgKi9cbiAgICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9oZWFsdGhgKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBoZWFsdGggY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXBpQ2xpZW50ID0gQXBpQ2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNlbGxDb250ZXh0VHJhY2tlciA9IHZvaWQgMDtcbi8qKlxuICogVHJhY2tzIGNlbGwgY29udGV4dCBhbmQgY3Vyc29yIHBvc2l0aW9uIHdpdGhpbiBKdXB5dGVyIG5vdGVib29rc1xuICovXG5jbGFzcyBDZWxsQ29udGV4dFRyYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGFwcCwgbm90ZWJvb2tUcmFja2VyKSB7XG4gICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBudWxsO1xuICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IG51bGw7XG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhhbmRsZXMgZWRpdG9yIGV2ZW50cyAoa2V5ZG93biwgbW91c2V1cClcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IGFjdGl2ZSBjZWxsIGZyb20gdGhlIHRyYWNrZXJcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICBpZiAoIWNlbGwgfHwgIWNlbGwuZWRpdG9yKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgaW5uZXIgRWRpdG9yVmlldyBpbnN0YW5jZVxuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGlmICghdmlldylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEdldCBhbmQgc3RvcmUgdGhlIGN1cnNvciBjb250ZXh0XG4gICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBpbiBlZGl0b3IgZXZlbnQgaGFuZGxlcjpcIiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlciA9IG5vdGVib29rVHJhY2tlcjtcbiAgICAgICAgdGhpcy5zZXR1cFRyYWNrZXJzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhpcyBvYmplY3QgaGFzIGJlZW4gZGlzcG9zZWRcbiAgICAgKi9cbiAgICBnZXQgaXNEaXNwb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzRGlzcG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgYWxsIHRoZSBuZWNlc3NhcnkgZXZlbnQgdHJhY2tlcnNcbiAgICAgKi9cbiAgICBzZXR1cFRyYWNrZXJzKCkge1xuICAgICAgICAvLyBIYW5kbGUgYWN0aXZlIGNlbGwgY2hhbmdlc1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5hY3RpdmVDZWxsQ2hhbmdlZC5jb25uZWN0KHRoaXMuc2V0dXBDZWxsTGlzdGVuZXJzLCB0aGlzKTtcbiAgICAgICAgLy8gSGFuZGxlIG5vdGVib29rIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuY3VycmVudENoYW5nZWQuY29ubmVjdCh0aGlzLmhhbmRsZU5vdGVib29rQ2hhbmdlLCB0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBub3RlYm9vayBjaGFuZ2VzXG4gICAgICovXG4gICAgaGFuZGxlTm90ZWJvb2tDaGFuZ2UodHJhY2tlciwgcGFuZWwpIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKHBhbmVsICYmIHBhbmVsLmNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBwYW5lbC5jb250ZW50LmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICB0aGlzLnNldHVwQ2VsbExpc3RlbmVycyh0cmFja2VyLCBjZWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycyBvbiB0aGUgYWN0aXZlIGNlbGxcbiAgICAgKi9cbiAgICBzZXR1cENlbGxMaXN0ZW5lcnMoX3RyYWNrZXIsIGNlbGwpIHtcbiAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpO1xuICAgICAgICBpZiAoY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbE5vZGUgPSBjZWxsLm5vZGU7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yTm9kZSA9IGNlbGxOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcC1FZGl0b3InKSB8fFxuICAgICAgICAgICAgICAgICAgICBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtSW5wdXRBcmVhLWVkaXRvcicpO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3JOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBlZGl0b3JOb2RlO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXJzIGZvciBrZXkgYW5kIG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICBlZGl0b3JOb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBjYXB0dXJlIGltbWVkaWF0ZSBjb250ZXh0IGlmIEVkaXRvclZpZXcgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBjZWxsLmVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RDZWxsQ29udGV4dCA9IHRoaXMuZ2V0Q21Db250ZXh0KHZpZXcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHNldHRpbmcgdXAgY2VsbCBsaXN0ZW5lcnM6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIHByZXZpb3VzIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAodGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLmhhbmRsZUVkaXRvckV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY29udGV4dCBpbmZvcm1hdGlvbiBmcm9tIENvZGVNaXJyb3IgRWRpdG9yVmlld1xuICAgICAqL1xuICAgIGdldENtQ29udGV4dCh2aWV3KSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc3RhdGUuc2VsZWN0aW9uLm1haW4uaGVhZDtcbiAgICAgICAgY29uc3QgZnVsbFRleHQgPSBzdGF0ZS5kb2MudG9TdHJpbmcoKTtcbiAgICAgICAgY29uc3QgbGluZSA9IHN0YXRlLmRvYy5saW5lQXQob2Zmc2V0KTtcbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB7XG4gICAgICAgICAgICBsaW5lOiBsaW5lLm51bWJlciAtIDEsXG4gICAgICAgICAgICBjb2x1bW46IG9mZnNldCAtIGxpbmUuZnJvbSxcbiAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNvbnRleHRSYWRpdXMgPSAxMDA7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gTWF0aC5tYXgoMCwgb2Zmc2V0IC0gY29udGV4dFJhZGl1cyk7XG4gICAgICAgIGNvbnN0IGVuZCA9IE1hdGgubWluKGZ1bGxUZXh0Lmxlbmd0aCwgb2Zmc2V0ICsgY29udGV4dFJhZGl1cyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0ZXh0OiBmdWxsVGV4dCxcbiAgICAgICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcbiAgICAgICAgICAgIGNvbnRleHRCZWZvcmU6IGZ1bGxUZXh0LnN1YnN0cmluZyhzdGFydCwgb2Zmc2V0KSxcbiAgICAgICAgICAgIGNvbnRleHRBZnRlcjogZnVsbFRleHQuc3Vic3RyaW5nKG9mZnNldCwgZW5kKVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGNlbGwgY29udGV4dFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDZWxsQ29udGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFzdENlbGxDb250ZXh0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuZGlzY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxufVxuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSBDZWxsQ29udGV4dFRyYWNrZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVnaXN0ZXJDb21tYW5kcyA9IHJlZ2lzdGVyQ29tbWFuZHM7XG5jb25zdCBpY29uc18xID0gcmVxdWlyZShcIi4vaWNvbnNcIik7XG4vKipcbiAqIFJlZ2lzdGVycyBjb21tYW5kcyBmb3IgdGhlIGV4dGVuc2lvblxuICovXG5mdW5jdGlvbiByZWdpc3RlckNvbW1hbmRzKGFwcCwgcGFsZXR0ZSwgbGF1bmNoZXIsIHNpZGViYXJXaWRnZXQpIHtcbiAgICAvLyBBZGQgY29tbWFuZCB0byB0b2dnbGUgdGhlIHNpZGViYXJcbiAgICBhcHAuY29tbWFuZHMuYWRkQ29tbWFuZCgnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsIHtcbiAgICAgICAgbGFiZWw6ICdUb2dnbGUgQUkgQXNzaXN0YW50IFNpZGViYXInLFxuICAgICAgICBpY29uOiBpY29uc18xLmV4dGVuc2lvbkljb24sXG4gICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzaWRlYmFyV2lkZ2V0LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBzaWRlYmFyV2lkZ2V0LnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHAuc2hlbGwuYWRkKHNpZGViYXJXaWRnZXQsICdsZWZ0JywgeyByYW5rOiA5OTk5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIHRoZSBjb21tYW5kIHRvIHRoZSBjb21tYW5kIHBhbGV0dGVcbiAgICBwYWxldHRlLmFkZEl0ZW0oe1xuICAgICAgICBjb21tYW5kOiAnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsXG4gICAgICAgIGNhdGVnb3J5OiAnRXh0ZW5zaW9uJ1xuICAgIH0pO1xuICAgIC8vIEFkZCBhIGxhdW5jaGVyIGl0ZW1cbiAgICBsYXVuY2hlci5hZGQoe1xuICAgICAgICBjb21tYW5kOiAnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsXG4gICAgICAgIGNhdGVnb3J5OiAnT3RoZXInLFxuICAgICAgICByYW5rOiA5OTk5XG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZ2xvYmFscyA9IHZvaWQgMDtcbmV4cG9ydHMuaW5pdEdsb2JhbHMgPSBpbml0R2xvYmFscztcbi8qKlxuICogR2xvYmFsIHJlZmVyZW5jZXMgdG8ga2V5IGNvbXBvbmVudHMgaW4gdGhlIGFwcGxpY2F0aW9uXG4gKi9cbmV4cG9ydHMuZ2xvYmFscyA9IHt9O1xuLyoqXG4gKiBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzXG4gKi9cbmZ1bmN0aW9uIGluaXRHbG9iYWxzKGFwcCwgbm90ZWJvb2tUcmFja2VyKSB7XG4gICAgZXhwb3J0cy5nbG9iYWxzLmFwcCA9IGFwcDtcbiAgICBleHBvcnRzLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyID0gbm90ZWJvb2tUcmFja2VyO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmV4dGVuc2lvbkljb24gPSB2b2lkIDA7XG5jb25zdCB1aV9jb21wb25lbnRzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvdWktY29tcG9uZW50c1wiKTtcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIEljb24gRGVmaW5pdGlvblxuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuY29uc3QgaWNvblN2Z1N0ciA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiBmaWxsPVwiY3VycmVudENvbG9yXCIgY2xhc3M9XCJiaSBiaS1jaGF0LWxlZnQtdGV4dFwiIHZpZXdCb3g9XCIwIDAgMTYgMTZcIj4nICtcbiAgICAnPHBhdGggZD1cIk0xNCAxYTEgMSAwIDAgMSAxIDF2OGExIDEgMCAwIDEtMSAxSDQuNDE0QTIgMiAwIDAgMCAzIDExLjU4NmwtMiAyVjJhMSAxIDAgMCAxIDEtMWgxMnpNMiAwYTIgMiAwIDAgMC0yIDJ2MTIuNzkzYS41LjUgMCAwIDAgLjg1NC4zNTNsMi44NTMtMi44NTNBMSAxIDAgMCAxIDQuNDE0IDEySDE0YTIgMiAwIDAgMCAyLTJWMmEyIDIgMCAwIDAtMi0ySDJ6XCIvPicgK1xuICAgICc8cGF0aCBkPVwiTTMgMy41YS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOWEuNS41IDAgMCAxLS41LS41ek0zIDZhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05QS41LjUgMCAwIDEgMyA2em0wIDIuNWEuNS41IDAgMCAxIC41LS41aDVhLjUuNSAwIDAgMSAwIDFoLTVhLjUuNSAwIDAgMS0uNS0uNXpcIi8+JyArXG4gICAgJzwvc3ZnPic7XG4vKipcbiAqIEljb24gZm9yIHRoZSBBSSBBc3Npc3RhbnQgZXh0ZW5zaW9uXG4gKi9cbmV4cG9ydHMuZXh0ZW5zaW9uSWNvbiA9IG5ldyB1aV9jb21wb25lbnRzXzEuTGFiSWNvbih7XG4gICAgbmFtZTogJ3NpbXBsZTppY29uJyxcbiAgICBzdmdzdHI6IGljb25TdmdTdHJcbn0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IGxhdW5jaGVyXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvbGF1bmNoZXJcIik7XG5jb25zdCBhcHB1dGlsc18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2FwcHV0aWxzXCIpO1xuY29uc3Qgbm90ZWJvb2tfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9ub3RlYm9va1wiKTtcbmNvbnN0IGRvY21hbmFnZXJfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9kb2NtYW5hZ2VyXCIpO1xuY29uc3Qgc2lkZWJhcl93aWRnZXRfMSA9IHJlcXVpcmUoXCIuL3NpZGViYXItd2lkZ2V0XCIpO1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vZ2xvYmFsc1wiKTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiLi9jb21tYW5kc1wiKTtcbmNvbnN0IGNlbGxfY29udGV4dF90cmFja2VyXzEgPSByZXF1aXJlKFwiLi9jZWxsLWNvbnRleHQtdHJhY2tlclwiKTtcbi8vIGltcG9ydCB7IEFwaUNsaWVudCB9IGZyb20gJy4vYXBpLWNsaWVudCc7XG4vLyBJbXBvcnQgdGhlIG1haW4gQ1NTIGZpbGVcbnJlcXVpcmUoXCIuLi9zdHlsZS9pbmRleC5jc3NcIik7XG4vLyBFeHBvcnQgQXBpQ2xpZW50IGZvciB1c2UgYnkgb3RoZXIgY29tcG9uZW50c1xudmFyIGFwaV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2FwaS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcGlDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwaV9jbGllbnRfMS5BcGlDbGllbnQ7IH0gfSk7XG4vKipcbiAqIEluaXRpYWxpemF0aW9uIGRhdGEgZm9yIHRoZSBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gZXh0ZW5zaW9uLlxuICovXG5jb25zdCBwbHVnaW4gPSB7XG4gICAgaWQ6ICdqdXB5dGVyLXNpbXBsZS1leHRlbnNpb246cGx1Z2luJyxcbiAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgcmVxdWlyZXM6IFtsYXVuY2hlcl8xLklMYXVuY2hlciwgYXBwdXRpbHNfMS5JQ29tbWFuZFBhbGV0dGUsIG5vdGVib29rXzEuSU5vdGVib29rVHJhY2tlciwgZG9jbWFuYWdlcl8xLklEb2N1bWVudE1hbmFnZXJdLFxuICAgIGFjdGl2YXRlOiAoanVweXRlckFwcCwgbGF1bmNoZXIsIHBhbGV0dGUsIHRyYWNrZXIsIGRvY01hbmFnZXIpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0p1cHl0ZXJMYWIgZXh0ZW5zaW9uIGp1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbiBpcyBhY3RpdmF0ZWQhJyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsIHJlZmVyZW5jZXNcbiAgICAgICAgKDAsIGdsb2JhbHNfMS5pbml0R2xvYmFscykoanVweXRlckFwcCwgdHJhY2tlcik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2VsbCBjb250ZXh0IHRyYWNrZXJcbiAgICAgICAgZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyID0gbmV3IGNlbGxfY29udGV4dF90cmFja2VyXzEuQ2VsbENvbnRleHRUcmFja2VyKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBzaWRlYmFyIHdpZGdldFxuICAgICAgICBjb25zdCBzaWRlYmFyV2lkZ2V0ID0gbmV3IHNpZGViYXJfd2lkZ2V0XzEuU2ltcGxlU2lkZWJhcldpZGdldChkb2NNYW5hZ2VyKTtcbiAgICAgICAganVweXRlckFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGNvbW1hbmRzXG4gICAgICAgICgwLCBjb21tYW5kc18xLnJlZ2lzdGVyQ29tbWFuZHMpKGp1cHl0ZXJBcHAsIHBhbGV0dGUsIGxhdW5jaGVyLCBzaWRlYmFyV2lkZ2V0KTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcGx1Z2luO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvbmZpZ3VyZU1hcmtlZCA9IGNvbmZpZ3VyZU1hcmtlZDtcbmV4cG9ydHMucHJlcHJvY2Vzc01hcmtkb3duID0gcHJlcHJvY2Vzc01hcmtkb3duO1xuY29uc3QgbWFya2VkXzEgPSByZXF1aXJlKFwibWFya2VkXCIpO1xuLyoqXG4gKiBDb25maWd1cmUgbWFya2VkIHdpdGggYmV0dGVyIHJlbmRlcmluZyBvcHRpb25zIGZvciBjb2RlIGJsb2Nrc1xuICovXG5mdW5jdGlvbiBjb25maWd1cmVNYXJrZWQoKSB7XG4gICAgLy8gQ29uZmlndXJlIG1hcmtlZCBvcHRpb25zXG4gICAgbWFya2VkXzEubWFya2VkLnNldE9wdGlvbnMoe1xuICAgICAgICBnZm06IHRydWUsIC8vIEVuYWJsZSBHaXRIdWIgRmxhdm9yZWQgTWFya2Rvd25cbiAgICAgICAgYnJlYWtzOiB0cnVlLCAvLyBBZGQgPGJyPiBvbiBzaW5nbGUgbGluZSBicmVha3NcbiAgICAgICAgcGVkYW50aWM6IGZhbHNlLCAvLyBDb25mb3JtIHRvIG9yaWdpbmFsIG1hcmtkb3duIHNwZWNcbiAgICAgICAgYXN5bmM6IGZhbHNlLCAvLyBEaXNhYmxlIGFzeW5jIHJlbmRlcmluZ1xuICAgICAgICBzaWxlbnQ6IGZhbHNlIC8vIEVuYWJsZSBlcnJvciByZXBvcnRpbmdcbiAgICB9KTtcbn1cbi8qKlxuICogUHJlLXByb2Nlc3MgbWFya2Rvd24gdGV4dCB0byBmaXggY29tbW9uIGlzc3VlcyB3aXRoIHN0cmVhbWluZyBjb250ZW50XG4gKi9cbmZ1bmN0aW9uIHByZXByb2Nlc3NNYXJrZG93bih0ZXh0KSB7XG4gICAgLy8gTm9ybWFsaXplIGxpbmUgZW5kaW5nc1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRUZXh0ID0gdGV4dC5yZXBsYWNlKC9cXHJcXG4vZywgJ1xcbicpO1xuICAgIC8vIEhhbmRsZSBjb2RlIGJsb2NrcyBmaXJzdFxuICAgIGxldCBpbkNvZGVCbG9jayA9IGZhbHNlO1xuICAgIGNvbnN0IGxpbmVzID0gbm9ybWFsaXplZFRleHQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHByb2Nlc3NlZExpbmVzID0gbGluZXMubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlIGJsb2NrIG1hcmtlcnNcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2BgYCcpKSB7XG4gICAgICAgICAgICBpbkNvZGVCbG9jayA9ICFpbkNvZGVCbG9jaztcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxhbmd1YWdlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIGNvZGUgYmxvY2ssIHByZXNlcnZlIHRoZSBsaW5lIGFzIGlzXG4gICAgICAgIGlmIChpbkNvZGVCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3V0c2lkZSBjb2RlIGJsb2NrczpcbiAgICAgICAgLy8gMS4gSGFuZGxlIGxpc3QgaXRlbXMgd2l0aCBwcm9wZXIgc3BhY2luZ1xuICAgICAgICAvLyAyLiBUcmltIGV4Y2Vzc2l2ZSB3aGl0ZXNwYWNlIGF0IHN0YXJ0IGFuZCBlbmQsIGJ1dCBwcmVzZXJ2ZSBpbmRlbnRhdGlvbiB3aXRoaW4gbGluZXNcbiAgICAgICAgbGV0IHByb2Nlc3NlZCA9IGxpbmU7XG4gICAgICAgIC8vIEhhbmRsZSBkYXNoIGxpc3QgaXRlbXMgYnkgZW5zdXJpbmcgdGhleSBoYXZlIGEgc3BhY2UgYWZ0ZXIgdGhlIGRhc2hcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UoLyhcXHMqKS0oXFxTKS9nLCAnJDEtICQyJyk7XG4gICAgICAgIC8vIEhhbmRsZSBtaXhlZCBzcGFjZS9kYXNoIGlzc3VlcyAtIGVuc3VyZSBwcm9wZXIgbmV3bGluZXMgYmVmb3JlIGxpc3QgaXRlbXNcbiAgICAgICAgcHJvY2Vzc2VkID0gcHJvY2Vzc2VkLnJlcGxhY2UoLyhbXlxcblxcc10pLVxccy9nLCAnJDFcXG4tICcpO1xuICAgICAgICByZXR1cm4gcHJvY2Vzc2VkO1xuICAgIH0pO1xuICAgIC8vIEpvaW4gbGluZXMgYW5kIGVuc3VyZSBjb2RlIGJsb2NrcyBhcmUgcHJvcGVybHkgZm9ybWF0dGVkXG4gICAgbGV0IHJlc3VsdCA9IHByb2Nlc3NlZExpbmVzLmpvaW4oJ1xcbicpO1xuICAgIC8vIEhhbmRsZSBlbXB0eSBjb2RlIGJsb2NrcyAoYWRkIGEgc3BhY2Ugc28gdGhleSByZW5kZXIgcHJvcGVybHkpXG4gICAgcmVzdWx0ID0gcmVzdWx0LnJlcGxhY2UoL2BgYCguKilcXG5gYGAvZywgJ2BgYCQxXFxuIFxcbmBgYCcpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBpbnRlcmFjdGlvbnMgb2YgdGhlIG11bHRpLWxldmVsIHBvcHVwIG1lbnUuXG4gKi9cbmNsYXNzIFBvcHVwTWVudU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIsIHdpZGdldE5vZGUsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgdGhpcy5tZW51SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnROb3RlYm9vayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFRyYWNrIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51IGl0ZW1cbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQgPSBmYWxzZTsgLy8gRmxhZyB0byBwcmV2ZW50IHJlY3Vyc2l2ZSByZW5kZXJzXG4gICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSAnJzsgLy8gVHJhY2sgbGFzdCBzZWFyY2ggdGVybSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzXG4gICAgICAgIHRoaXMuYWxsb3dlZEV4dGVuc2lvbnMgPSBbJy5weScsICcuaXB5bmInLCAnLm1kJywgJy5qc29uJywgJy50eHQnLCAnLmNzdiddO1xuICAgICAgICB0aGlzLmZpbGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICAgICAgdGhpcy53aWRnZXROb2RlID0gd2lkZ2V0Tm9kZTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gQXR0YWNoIHRvIHRoZSB3aWRnZXQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBib2R5XG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIC8vIENyZWF0ZSBzZWFyY2ggaW5wdXRcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5wbGFjZWhvbGRlciA9ICdTZWFyY2guLi4nO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtc2VhcmNoJzsgLy8gQWRkIGNsYXNzIGZvciBzdHlsaW5nXG4gICAgICAgIC8vIFVzZSAnaW5wdXQnIGV2ZW50IGluc3RlYWQgb2YgZGlyZWN0bHkgcmUtcmVuZGVyaW5nIG9uIGV2ZXJ5IGtleXN0cm9rZVxuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSByZS1yZW5kZXIgaWYgdGhlIHNlYXJjaCB0ZXJtIGhhcyBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2hJbnB1dC52YWx1ZSAhPT0gdGhpcy5sYXN0U2VhcmNoVGVybSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhhbmRsZSBrZXlkb3duIGluIHNlYXJjaCBpbnB1dCB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBuYXZpZ2F0aW9uIGtleXNcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgU2VhcmNoIEtleURvd246IEtleT0nJHtldmVudC5rZXl9J2ApO1xuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBQcmV2ZW50IHRoZXNlIGtleXMgZnJvbSBiZWluZyBjYXB0dXJlZCBieSB0aGUgZG9jdW1lbnQgaGFuZGxlclxuICAgICAgICAgICAgaWYgKFsnQXJyb3dVcCcsICdBcnJvd0Rvd24nLCAnRW50ZXInLCAnVGFiJywgJ0VzY2FwZSddLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgKFNlYXJjaCBJbnB1dCk6IFN0b3BwaW5nIHByb3BhZ2F0aW9uIGZvciBuYXZpZ2F0aW9uIGtleTonLCBldmVudC5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBFc2NhcGUgZGlyZWN0bHkgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHNlbGVjdCBmaXJzdCBpdGVtIG9uIEVudGVyP1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IGFjdGl2YXRlIHRoZSBpdGVtOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVudUl0ZW1zWzBdLmNsaWNrKCk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBmaXJzdC9sYXN0IG1lbnUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmx1cigpIHdpbGwgYmUgaGFuZGxlZCBieSBtYWluIGtleSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ1JJVElDQUw6IERPIE5PVCBzdG9wIHByb3BhZ2F0aW9uIGZvciBCYWNrc3BhY2Ugb3Igb3RoZXIgdGV4dCBlZGl0aW5nIGtleXNcbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGRlZmF1bHQgYmVoYXZpb3IgdG8gd29yayBwcm9wZXJseVxuICAgICAgICB9LCB0cnVlKTsgLy8gVXNlIGNhcHR1cmUgcGhhc2VcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIC8vIElNUE9SVEFOVDogVXNlIGEgc2VwYXJhdGUgYm91bmQgZnVuY3Rpb24gZm9yIHRoZSBkb2N1bWVudCBrZXlkb3duXG4gICAgICAgIC8vIHNvIHdlIGNhbiByZW1vdmUgdGhlIGV4YWN0IHNhbWUgbGlzdGVuZXIgbGF0ZXJcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUtleURvd24gPSB0aGlzLmhhbmRsZUtleURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgICAgICAgaWYgKGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5jb25uZWN0KChfLCBub3RlYm9vaykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudE5vdGVib29rID0gbm90ZWJvb2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuaGFuZGxlRG9jdW1lbnRDbGljay5iaW5kKHRoaXMpLCB0cnVlKTtcbiAgICAgICAgLy8gUmVtb3ZlIHVzaW5nIHRoZSBleGFjdCBzYW1lIGJvdW5kIGZ1bmN0aW9uXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmJvdW5kSGFuZGxlS2V5RG93biwgdHJ1ZSk7XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHdpZGdldE5vZGUgaWYgYXR0YWNoZWRcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMud2lkZ2V0Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlRG9jdW1lbnRDbGljayhldmVudCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnICYmICF0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICBjb25zdCBhdEJ1dHRvbiA9IHRoaXMud2lkZ2V0Tm9kZS5xdWVyeVNlbGVjdG9yKCcjanAtbGxtLWV4dC1hdC1idXR0b24nKTtcbiAgICAgICAgICAgIGlmIChhdEJ1dHRvbiAmJiBhdEJ1dHRvbi5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBDbGljayB3YXMgb24gdGhlIEAgYnV0dG9uLCBub3QgaGlkaW5nLicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQ2xpY2sgZGV0ZWN0ZWQgb3V0c2lkZSB0aGUgbWVudS4nKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNob3dQb3B1cE1lbnUoeCwgeSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNob3dpbmcgbWVudSBhdCAoJHt4fSwgJHt5fSlgKTtcbiAgICAgICAgLy8gU3RvcmUgdGhlIGluaXRpYWwgYW5jaG9yIHBvaW50IGZvciBwb3NpdGlvbmluZ1xuICAgICAgICB0aGlzLl9hbmNob3JYID0geDtcbiAgICAgICAgdGhpcy5fYW5jaG9yWSA9IHk7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9ICd0b3AnO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHRoaXMubWVudUhpc3RvcnkgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIHNob3dcbiAgICAgICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSAnJzsgLy8gUmVzZXQgbGFzdCBzZWFyY2ggdGVybVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5zZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKTtcbiAgICAgICAgLy8gRW5zdXJlIGl0J3MgYXR0YWNoZWQgdG8gdGhlIHdpZGdldCBub2RlIGlmIHNvbWVob3cgZGV0YWNoZWRcbiAgICAgICAgdGhpcy53aWRnZXROb2RlLmFwcGVuZENoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHBvcHVwIG1lbnUgLSBoYW5kbGVkIGluIHVwZGF0ZVBvcHVwUG9zaXRpb25cbiAgICAgICAgdGhpcy51cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgIC8vIEZvY3VzIHRoZSBzZWFyY2ggaW5wdXQgaWYgd2UgYXJlIGluIGZpbGUvZGlyZWN0b3J5IHZpZXcsIG90aGVyd2lzZSBmb2N1cyB0aGUgZmlyc3QgaXRlbVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRm9jdXMgYWZ0ZXIgdGltZW91dCB0byBlbnN1cmUgRE9NIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRm9jdXNlZCBzZWFyY2ggaW5wdXQnKTtcbiAgICAgICAgICAgIH0sIDUwKTsgLy8gU2xpZ2h0bHkgbG9uZ2VyIHRpbWVvdXRcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIERvbid0IHNlbGVjdCBhbiBpdGVtIGlmIHNlYXJjaCBpcyBmb2N1c2VkXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBSZXNldCBhbmQgc2VsZWN0IHRoZSBmaXJzdCBtZW51IGl0ZW0gZm9yIHRvcCBsZXZlbFxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKSwgNTApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGVQb3B1cE1lbnUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogSGlkaW5nIG1lbnUuJyk7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBleHBsaWNpdGx5IHJlbW92ZSBmcm9tIHdpZGdldE5vZGUgdW5sZXNzIGNhdXNpbmcgaXNzdWVzXG4gICAgICAgICAgICAvLyBJZiBwZXJmb3JtYW5jZSBiZWNvbWVzIGFuIGlzc3VlIHdpdGggbWFueSBtZW51cywgY29uc2lkZXIgcmVtb3ZpbmcvcmUtYWRkaW5nXG4gICAgICAgICAgICAvLyBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy53aWRnZXROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZW5kZXJNZW51Q29udGVudCgpIHtcbiAgICAgICAgLy8gUHJldmVudCByZWN1cnNpdmUgcmVuZGVyc1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogU2tpcHBpbmcgcmVuZGVyIC0gYWxyZWFkeSByZW5kZXJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgbm90IGF0IHRvcCBsZXZlbCwgYWRkIGEgc2VhcmNoIGlucHV0IGZvciBmaWx0ZXJpbmcgaXRlbXNcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHNlYXJjaCBpbnB1dCBhdCB0aGUgdG9wIG9mIHRoZSBtZW51XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWFyY2hJbnB1dCk7XG4gICAgICAgICAgICAgICAgLy8gUGF0aCBkaXNwbGF5IGFuZCBiYWNrIGJ1dHRvbiByZW1vdmVkIGZvciBjbGVhbmVyIFVJXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW5kZXIgZGlmZmVyZW50IG1lbnUgY29udGVudCBiYXNlZCBvbiBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudE1lbnVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9wTGV2ZWxJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlyZWN0b3JpZXMnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZWxscyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyQ2VsbEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgc2VsZWN0aW9uIGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIHRvIG1haW50YWluIHRoZSBmaXhlZCBib3R0b20gZWRnZVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJiB0aGlzLl9hbmNob3JYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fYW5jaG9yWSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgcmVuZGVyaW5nIG1lbnUgY29udGVudCcsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZW5kZXJpbmdDb250ZW50ID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVuZGVyVG9wTGV2ZWxJdGVtcygpIHtcbiAgICAgICAgY29uc3QgdG9wTGV2ZWxDb21tYW5kcyA9IFtcbiAgICAgICAgICAgIHsgbGFiZWw6ICdDb2RlJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2luc2VydC1jb2RlJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0NlbGxzJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2Jyb3dzZS1jZWxscycgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdGaWxlJywgZGVzY3JpcHRpb246ICcnLCBhY3Rpb25JZDogJ2Jyb3dzZS1maWxlcycgfSxcbiAgICAgICAgICAgIHsgbGFiZWw6ICdEaXJlY3RvcnknLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWRpcmVjdG9yaWVzJyB9XG4gICAgICAgIF07XG4gICAgICAgIHRvcExldmVsQ29tbWFuZHMuZm9yRWFjaChjbWQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oY21kLmxhYmVsLCBjbWQuYWN0aW9uSWQsICcnLCBjbWQuZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyByZW5kZXJEaXJlY3RvcnlCcm93c2VySXRlbXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gR2V0IHNlYXJjaCB0ZXJtXG4gICAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICBjb25zdCBsb2FkaW5nSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ0xvYWRpbmcuLi4nLCAnbG9hZGluZycsICcnLCAnJyk7XG4gICAgICAgIGxvYWRpbmdJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIC8vIFRlbXBvcmFyaWx5IGFkZCBsb2FkaW5nIGl0ZW0gYmVsb3cgc2VhcmNoL3BhdGhcbiAgICAgICAgY29uc3QgaW5zZXJ0aW9uUG9pbnQgPSAoX2EgPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1wb3B1cC1tZW51LXBhdGgnKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5leHRTaWJsaW5nO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbnNlcnRCZWZvcmUobG9hZGluZ0l0ZW0sIGluc2VydGlvblBvaW50IHx8IG51bGwpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gSWYgY29udGVudHMgd2VyZSBhbHJlYWR5IGZldGNoZWQgcmVjZW50bHkgYW5kIHdlJ3JlIGp1c3QgZmlsdGVyaW5nIGFnYWluLFxuICAgICAgICAgICAgLy8gd2UgY291bGQgcG90ZW50aWFsbHkgY2FjaGUgdGhlIHJlc3VsdHMgdG8gYXZvaWQgdW5uZWNlc3NhcnkgQVBJIGNhbGxzXG4gICAgICAgICAgICBjb25zdCBmaWx0ZXJUeXBlID0gdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSc7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHRoaXMubGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyh0aGlzLmN1cnJlbnRNZW51UGF0aCwgZmlsdGVyVHlwZSk7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBzdGlsbCBpbiBET00gYmVmb3JlIHRyeWluZyB0byByZW1vdmVcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudHMgJiYgY29udGVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEZpbHRlciBiYXNlZCBvbiBzZWFyY2ggdGVybVxuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcmVkQ29udGVudHMgPSBjb250ZW50cy5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpdGVtLm5hbWUudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS5yZWxhdGl2ZVBhdGgudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhzZWFyY2hUZXJtKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyZWRDb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29udGVudHMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1OYW1lID0gaXRlbS5uYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtUGF0aCA9IGl0ZW0ucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGF0aCA9IGl0ZW0ucmVsYXRpdmVQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaWNvbiA9IGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5JyA/ICfwn5OBJyA6ICfwn5OEJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZCA9IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyA/ICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJyA6ICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBpdGVtVHlwZSA9PT0gJ2ZpbGUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uSWQgPSAnc2VsZWN0LWZpbGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGAke2ljb259ICR7aXRlbU5hbWV9YCwgYWN0aW9uSWQsIGl0ZW1QYXRoLCByZWxhdGl2ZVBhdGggIT09ICcuJyA/IHJlbGF0aXZlUGF0aCA6ICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKHNlYXJjaFRlcm0gPyAnTm8gbWF0Y2hlcyBmb3VuZCcgOiBgTm8gJHtmaWx0ZXJUeXBlfXMgZm91bmRgLCAnZW1wdHknLCAnJywgJycpO1xuICAgICAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBObyBpdGVtcyBmb3VuZCBpbiB0aGlzIGRpcmVjdG9yeWAsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBFcnJvcjogJHtlcnJvcn1gLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgbG9hZGluZy9maWx0ZXJpbmcgZGlyZWN0b3J5IGNvbnRlbnRzOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW5kZXJzIGFsbCBjZWxscyBmcm9tIHRoZSBjdXJyZW50IG5vdGVib29rXG4gICAgICovXG4gICAgYXN5bmMgcmVuZGVyQ2VsbEl0ZW1zKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAvLyBHZXQgc2VhcmNoIHRlcm0gZm9yIGZpbHRlcmluZ1xuICAgICAgICBjb25zdCBzZWFyY2hUZXJtID0gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZS50b0xvd2VyQ2FzZSgpLnRyaW0oKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgY29uc3QgbG9hZGluZ0l0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdMb2FkaW5nIGNlbGxzLi4uJywgJ2xvYWRpbmcnLCAnJywgJycpO1xuICAgICAgICBsb2FkaW5nSXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IChfYSA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dFNpYmxpbmc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmluc2VydEJlZm9yZShsb2FkaW5nSXRlbSwgaW5zZXJ0aW9uUG9pbnQgfHwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDaGVjayBpZiB3ZSBoYXZlIGFuIGFjdGl2ZSBub3RlYm9va1xuICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnROb3RlYm9vayB8fCAhdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudCB8fCAhdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudC5tb2RlbCkge1xuICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBsb2FkaW5nIGl0ZW1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTm8gYWN0aXZlIG5vdGVib29rIGZvdW5kJywgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTW9kZWwgPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50Lm1vZGVsO1xuICAgICAgICAgICAgY29uc3QgY2VsbHMgPSBub3RlYm9va01vZGVsLmNlbGxzO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjZWxscyB8fCBjZWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eUl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdObyBjZWxscyBpbiBub3RlYm9vaycsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgZW1wdHlJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlJdGVtKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQcm9jZXNzIGFuZCBkaXNwbGF5IGVhY2ggY2VsbFxuICAgICAgICAgICAgbGV0IGZpbHRlcmVkQ2VsbENvdW50ID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2VsbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gY2VsbHMuZ2V0KGkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxUeXBlID0gY2VsbC50eXBlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZW50ID0gY2VsbC5zaGFyZWRNb2RlbCA/IGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCkgOlxuICAgICAgICAgICAgICAgICAgICAoKChfYiA9IGNlbGwudG9KU09OKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zb3VyY2UpIHx8ICcnKTtcbiAgICAgICAgICAgICAgICAvLyBVc2UgdHlwZSBjYXN0aW5nIHRvIGF2b2lkIFR5cGVTY3JpcHQgZXJyb3JzXG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uQ291bnQgPSBjZWxsVHlwZSA9PT0gJ2NvZGUnID9cbiAgICAgICAgICAgICAgICAgICAgKGNlbGwuZXhlY3V0aW9uQ291bnQgIT09IHVuZGVmaW5lZCAmJiBjZWxsLmV4ZWN1dGlvbkNvdW50ICE9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuZXhlY3V0aW9uQ291bnQgOiAnKicpIDpcbiAgICAgICAgICAgICAgICAgICAgJyc7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgcHJldmlldyBvZiB0aGUgY2VsbCBjb250ZW50ICh0cnVuY2F0ZSBpZiBuZWVkZWQpXG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudFByZXZpZXcgPSB0eXBlb2YgY2VsbENvbnRlbnQgPT09ICdzdHJpbmcnID9cbiAgICAgICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgOlxuICAgICAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheShjZWxsQ29udGVudCkgPyBjZWxsQ29udGVudC5qb2luKCdcXG4nKSA6ICcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaXJzdExpbmUgPSBjb250ZW50UHJldmlldy5zcGxpdCgnXFxuJylbMF0gfHwgJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJ1bmNhdGVkQ29udGVudCA9IGZpcnN0TGluZS5sZW5ndGggPiAzMCA/XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TGluZS5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicgOlxuICAgICAgICAgICAgICAgICAgICBmaXJzdExpbmU7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNlbGwgbGFiZWwgd2l0aCBzdHlsZWQgdHlwZSBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlSW5kaWNhdG9yID0gY2VsbFR5cGUgPT09ICdtYXJrZG93bicgPyAnTScgOiAnQyc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlY3V0aW9uRGlzcGxheSA9IGV4ZWN1dGlvbkNvdW50ICE9PSAnJyA/IGBbJHtleGVjdXRpb25Db3VudH1dYCA6ICcnO1xuICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBtZW51IGl0ZW0gZm9yIHRoaXMgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnJywgLy8gRW1wdHkgdGV4dCwgd2lsbCBiZSBhZGRlZCBhcyBIVE1MXG4gICAgICAgICAgICAgICAgJ3NlbGVjdC1jZWxsJywgaS50b1N0cmluZygpIC8vIFN0b3JlIGNlbGwgaW5kZXggaW4gcGF0aFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHN0eWxlZCBjb250ZW50IHdpdGggSFRNTCBlbGVtZW50c1xuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIHR5cGVTcGFuLmNsYXNzTmFtZSA9IGBjZWxsLXR5cGUtaW5kaWNhdG9yIGNlbGwtdHlwZS0ke2NlbGxUeXBlID09PSAnbWFya2Rvd24nID8gJ21kJyA6ICdjb2RlJ31gO1xuICAgICAgICAgICAgICAgIHR5cGVTcGFuLnRleHRDb250ZW50ID0gdHlwZUluZGljYXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi5jbGFzc05hbWUgPSAnY2VsbC1leGVjLWNvdW50JztcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi50ZXh0Q29udGVudCA9IGV4ZWN1dGlvbkRpc3BsYXk7XG4gICAgICAgICAgICAgICAgZXhlY1NwYW4uc3R5bGUubWFyZ2luUmlnaHQgPSAnOHB4JztcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50U3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICBjb250ZW50U3Bhbi5jbGFzc05hbWUgPSAnY2VsbC1jb250ZW50LXByZXZpZXcnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTcGFuLnRleHRDb250ZW50ID0gdHJ1bmNhdGVkQ29udGVudDtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGxhYmVsIHNwYW4gKGZpcnN0IGNoaWxkIG9mIHRoZSBtZW51IGl0ZW0pXG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWxTcGFuID0gY2VsbEl0ZW0ucXVlcnlTZWxlY3Rvcignc3BhbicpO1xuICAgICAgICAgICAgICAgIGlmIChsYWJlbFNwYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLnRleHRDb250ZW50ID0gJyc7IC8vIENsZWFyIGV4aXN0aW5nIHRleHRcbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKHR5cGVTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkRpc3BsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhYmVsU3Bhbi5hcHBlbmRDaGlsZChleGVjU3Bhbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKGNvbnRlbnRTcGFuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ29uc3RydWN0IGZ1bGwgc2VhcmNoYWJsZSB0ZXh0XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VhcmNoYWJsZVRleHQgPSBgJHt0eXBlSW5kaWNhdG9yfSAke2V4ZWN1dGlvbkRpc3BsYXl9ICR7dHJ1bmNhdGVkQ29udGVudH1gLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJ5IHNlYXJjaCB0ZXJtIGlmIG9uZSBpcyBwcm92aWRlZFxuICAgICAgICAgICAgICAgIGlmIChzZWFyY2hUZXJtICYmICFzZWFyY2hhYmxlVGV4dC5pbmNsdWRlcyhzZWFyY2hUZXJtKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoY2VsbEl0ZW0pO1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ2VsbENvdW50Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZmlsdGVyZWRDZWxsQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub01hdGNoSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ05vIG1hdGNoaW5nIGNlbGxzIGZvdW5kJywgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBub01hdGNoSXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG5vTWF0Y2hJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIENsZWFuIHVwIGxvYWRpbmcgaW5kaWNhdG9yXG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuY29udGFpbnMobG9hZGluZ0l0ZW0pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShgRXJyb3I6ICR7ZXJyb3J9YCwgJ2Vycm9yJywgJycsICcnKTtcbiAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlcnJvckl0ZW0pO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEVycm9yIGxvYWRpbmcgbm90ZWJvb2sgY2VsbHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZU1lbnVJdGVtKHRleHQsIGFjdGlvbklkLCBwYXRoID0gJycsIGRlc2NyaXB0aW9uID0gJycpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpdGVtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbSc7XG4gICAgICAgIGl0ZW0uZGF0YXNldC5hY3Rpb25JZCA9IGFjdGlvbklkO1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgaXRlbS5kYXRhc2V0LnBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0ub25jbGljayA9IChldmVudCkgPT4gdGhpcy5oYW5kbGVNZW51Q2xpY2soZXZlbnQpO1xuICAgICAgICBjb25zdCBsYWJlbFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIGxhYmVsU3Bhbi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQobGFiZWxTcGFuKTtcbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHBhdGhTcGFuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aC1pbmRpY2F0b3InO1xuICAgICAgICAgICAgcGF0aFNwYW4udGV4dENvbnRlbnQgPSBkZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIHBhdGhTcGFuLnN0eWxlLmZvbnRTaXplID0gJzAuODVlbSc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5jb2xvciA9ICd2YXIoLS1qcC11aS1mb250LWNvbG9yMiknO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUubWFyZ2luTGVmdCA9ICc4cHgnO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUub3BhY2l0eSA9ICcwLjgnO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmxpbmUtYmxvY2snOyAvLyBFbnN1cmUgdGhlIHBhdGggaXMgYWx3YXlzIGRpc3BsYXllZFxuICAgICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChwYXRoU3Bhbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZU1lbnVDbGljayhldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGFjdGlvbklkID0gdGFyZ2V0LmRhdGFzZXQuYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHBhdGggPSB0YXJnZXQuZGF0YXNldC5wYXRoIHx8ICcnO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IE1lbnUgaXRlbSBjbGlja2VkLiBBY3Rpb246ICR7YWN0aW9uSWR9LCBQYXRoOiAke3BhdGh9YCk7XG4gICAgICAgIHN3aXRjaCAoYWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGNhc2UgJ25hdmlnYXRlLWJhY2snOlxuICAgICAgICAgICAgICAgIHRoaXMubmF2aWdhdGVCYWNrTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0LWNvZGUnOiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5jYWxsYmFja3MuZ2V0U2VsZWN0ZWRUZXh0ID8gdGhpcy5jYWxsYmFja3MuZ2V0U2VsZWN0ZWRUZXh0KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyBzdWJtZW51IGZvciBjb2RlIGluc2VydGlvbiBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN1Ym1lbnVJdGVtcyA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdJbnNlcnQgYXMgcGxhaW4gY29kZScsIGFjdGlvbklkOiAnaW5zZXJ0LXBsYWluLWNvZGUnLCBkYXRhOiBzZWxlY3RlZFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbGFiZWw6ICdJbnNlcnQgYXMgY29sbGFwc2VkIHJlZmVyZW5jZScsIGFjdGlvbklkOiAnY29sbGFwc2UtY29kZS1yZWYnLCBkYXRhOiBzZWxlY3RlZFRleHQgfVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIGN1cnJlbnQgbWVudSB3aXRoIHN1Ym1lbnUgb3B0aW9uc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgc3VibWVudUl0ZW1zLmZvckVhY2goaXRlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oaXRlbS5sYWJlbCwgaXRlbS5hY3Rpb25JZCwgaXRlbS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKG1lbnVJdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBiYWNrIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBiYWNrQnV0dG9uID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnQmFjaycsICduYXZpZ2F0ZS1iYWNrJyk7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tCdXR0b24uc3R5bGUuYm9yZGVyVG9wID0gJzFweCBzb2xpZCB2YXIoLS1qcC1ib3JkZXItY29sb3IxKSc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGJhY2tCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IGhpZGUgbWVudSwgd2FpdCBmb3Igc3VibWVudSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxDb250ZW50ID0gdGhpcy5jYWxsYmFja3MuZ2V0Q3VycmVudENlbGxDb250ZW50ID8gdGhpcy5jYWxsYmFja3MuZ2V0Q3VycmVudENlbGxDb250ZW50KCkgOiBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUoY2VsbENvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnaW5zZXJ0LXBsYWluLWNvZGUnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY29sbGFwc2UtY29kZS1yZWYnOiB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggJiYgdGhpcy5jdXJyZW50Tm90ZWJvb2spIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEdldCBub3RlYm9vayBmaWxlIG5hbWUgKHdpdGhvdXQgZXh0ZW5zaW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYXRoID0gdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGV4dC5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tOYW1lID0gKChfYSA9IG5vdGVib29rUGF0aC5zcGxpdCgnLycpLnBvcCgpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3BsaXQoJy4nKVswXSkgfHwgJ25vdGVib29rJztcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmQgY3VycmVudCBjZWxsIGluZGV4IGFuZCBhcHByb3hpbWF0ZSBsaW5lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENlbGwgPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50LmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWN1cnJlbnRDZWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBhY3RpdmUgY2VsbCBmb3VuZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnJlbnQgY2VsbCBpbmRleFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudENlbGxJbmRleCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRlbnQuYWN0aXZlQ2VsbEluZGV4O1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXN0aW1hdGUgbGluZSBudW1iZXIgZnJvbSBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBsaW5lTnVtYmVyID0gMTsgLy8gRGVmYXVsdCB0byBsaW5lIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjdXJyZW50Q2VsbC5lZGl0b3I7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyc29yID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyID0gY3Vyc29yLmxpbmUgKyAxOyAvLyBDb252ZXJ0IHRvIDEtaW5kZXhlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBhbGwgdGhlIGluZm9ybWF0aW9uIG5lZWRlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29sbGFwc2VkQ29kZVJlZihwYXRoLCBjdXJyZW50Q2VsbEluZGV4LCBsaW5lTnVtYmVyLCBub3RlYm9va05hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjcmVhdGluZyBjb2xsYXBzZWQgY29kZSByZWZlcmVuY2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gaW5zZXJ0aW5nIGNvZGUgZGlyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdlbnQgd3Jvbmcgb3Igbm8gcGF0aCBwcm92aWRlZCwganVzdCBpbnNlcnQgYXMgcmVndWxhciBjb2RlXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2RlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1jZWxscyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2NlbGxzJywgJycpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1maWxlcyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2ZpbGVzJywgdGhpcy5jdXJyZW50TWVudVBhdGggfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaCB3aGVuIGNoYW5naW5nIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Jyb3dzZS1kaXJlY3Rvcmllcyc6XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5uYXZpZ2F0ZU1lbnUoJ2RpcmVjdG9yaWVzJywgdGhpcy5jdXJyZW50TWVudVBhdGggfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHNlYXJjaCB3aGVuIGNoYW5naW5nIHZpZXcgdHlwZVxuICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1jZWxsJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsSW5kZXggPSBwYXJzZUludChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc05hTihjZWxsSW5kZXgpICYmIHRoaXMuY2FsbGJhY2tzLmluc2VydENlbGxCeUluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDZWxsQnlJbmRleChjZWxsSW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogSW52YWxpZCBjZWxsIGluZGV4IG9yIGNhbGxiYWNrIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZmlsZSc6XG4gICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0RmlsZVBhdGgocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEZpbGUgc2VsZWN0ZWQgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJzogLy8gTmV3IGFjdGlvbiB0byBuYXZpZ2F0ZSBpbnRvIGRpciB3aGVuIGluIGZpbGUgdmlld1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBmaWxlIGNhY2hlIGZvciB0aGUgc3BlY2lmaWMgZGlyZWN0b3J5IHRvIGZvcmNlIGEgcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGAke3BhdGh9OiR7dGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSd9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIHBhc3NpbmcgdGhlIGNvcnJlY3QgbGV2ZWwgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9ICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgOiAnZmlsZXMnO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudShsZXZlbCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIG5hdmlnYXRpb24gYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJzogLy8gTmV3IGFjdGlvbiB0byBzZWxlY3QgZGlyIHdoZW4gaW4gZGlyZWN0b3J5IHZpZXdcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnREaXJlY3RvcnlQYXRoKHBhdGgpOyAvLyBVc2UgdGhlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IERpcmVjdG9yeSBzZWxlY3RlZCBmb3IgY2FsbGJhY2sgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdwbGFjZWhvbGRlci1hY3Rpb24nOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQbGFjZWhvbGRlciBhY3Rpb24gdHJpZ2dlcmVkLicpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbG9hZGluZyc6XG4gICAgICAgICAgICBjYXNlICdlbXB0eSc6XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVW5rbm93biBtZW51IGFjdGlvbjonLCBhY3Rpb25JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfVxuICAgIGFzeW5jIG5hdmlnYXRlTWVudShsZXZlbCwgcGF0aCkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IE5hdmlnYXRpbmcgdG8gbGV2ZWw6ICR7bGV2ZWx9LCBwYXRoOiAke3BhdGh9YCk7XG4gICAgICAgIC8vIE9ubHkgcHVzaCBoaXN0b3J5IGlmIHdlIGFyZSBhY3R1YWxseSBtb3ZpbmcgdG8gYSBuZXcgc3RhdGVcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCAhPT0gbGV2ZWwgfHwgdGhpcy5jdXJyZW50TWVudVBhdGggIT09IHBhdGgpIHtcbiAgICAgICAgICAgIHRoaXMubWVudUhpc3RvcnkucHVzaCh7IGxldmVsOiB0aGlzLmN1cnJlbnRNZW51TGV2ZWwsIHBhdGg6IHRoaXMuY3VycmVudE1lbnVQYXRoIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9IGxldmVsO1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IHBhdGg7XG4gICAgICAgIC8vIERvbid0IGNsZWFyIHNlYXJjaCBvbiBwcm9ncmFtbWF0aWMgbmF2aWdhdGlvbiAobGlrZSBiYWNrIGJ1dHRvbilcbiAgICAgICAgLy8gdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBNYXliZSBrZWVwIHNlYXJjaCB0ZXJtP1xuICAgICAgICBhd2FpdCB0aGlzLnJlbmRlck1lbnVDb250ZW50KCk7XG4gICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBhZnRlciBuYXZpZ2F0aW5nIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgaWYgKGxldmVsID09PSAnZmlsZXMnIHx8IGxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBSZXNldCBzZWxlY3Rpb25cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFNlbGVjdCBmaXJzdCBpdGVtIGlmIG5hdmlnYXRpbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCksIDApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5hdmlnYXRlQmFja01lbnUoKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLm1lbnVIaXN0b3J5LnBvcCgpO1xuICAgICAgICBpZiAocHJldmlvdXNTdGF0ZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIGJhY2sgdG8gbGV2ZWw6ICR7cHJldmlvdXNTdGF0ZS5sZXZlbH0sIHBhdGg6ICR7cHJldmlvdXNTdGF0ZS5wYXRofWApO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gcHJldmlvdXNTdGF0ZS5sZXZlbDtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gcHJldmlvdXNTdGF0ZS5wYXRoO1xuICAgICAgICAgICAgLy8gRG9uJ3QgY2xlYXIgc2VhcmNoIG9uIGJhY2sgbmF2aWdhdGlvblxuICAgICAgICAgICAgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEZvY3VzIHNlYXJjaCBpbnB1dCBpZiBnb2luZyBiYWNrIHRvIGZpbGUvZGlyIHZpZXdcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuc2VhcmNoSW5wdXQuZm9jdXMoKSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFJlc2V0IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2VsZWN0IGZpcnN0IGl0ZW0gaWYgZ29pbmcgYmFjayB0byB0b3AgbGV2ZWxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpLCAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQWxyZWFkeSBhdCB0aGUgdG9wIGxldmVsLicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbGlzdEN1cnJlbnREaXJlY3RvcnlDb250ZW50cyhiYXNlUGF0aCwgZmlsdGVyVHlwZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IExpc3RpbmcgZGlyZWN0b3J5IGNvbnRlbnRzIGZvciBwYXRoOiAnJHtiYXNlUGF0aH0nLCBmaWx0ZXI6ICR7ZmlsdGVyVHlwZSB8fCAnYWxsJ31gKTtcbiAgICAgICAgLy8gQ2hlY2sgY2FjaGUgZmlyc3RcbiAgICAgICAgY29uc3QgY2FjaGVLZXkgPSBgJHtiYXNlUGF0aH06JHtmaWx0ZXJUeXBlIHx8ICdhbGwnfWA7XG4gICAgICAgIGlmICh0aGlzLmZpbGVDYWNoZS5oYXMoY2FjaGVLZXkpKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IFVzaW5nIGNhY2hlZCBkaXJlY3RvcnkgY29udGVudHMnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVDYWNoZS5nZXQoY2FjaGVLZXkpIHx8IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVmZmVjdGl2ZVBhdGggPSBiYXNlUGF0aCA9PT0gJy8nID8gJycgOiBiYXNlUGF0aDtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0cmFpbGluZyBzbGFzaCByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSB1bmxlc3MgaXQncyByb290XG4gICAgICAgICAgICBjb25zdCBwYXRoRm9yQXBpID0gZWZmZWN0aXZlUGF0aC5lbmRzV2l0aCgnLycpICYmIGVmZmVjdGl2ZVBhdGgubGVuZ3RoID4gMSA/IGVmZmVjdGl2ZVBhdGguc2xpY2UoMCwgLTEpIDogZWZmZWN0aXZlUGF0aDtcbiAgICAgICAgICAgIC8vIFJlc3VsdCBhcnJheSB0aGF0IHdpbGwgaG9sZCBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzXG4gICAgICAgICAgICBsZXQgYWxsUmVzdWx0cyA9IFtdO1xuICAgICAgICAgICAgLy8gR2V0IHRoZSBiYXNlIGRpcmVjdG9yeSBjb250ZW50cyAobm9uLXJlY3Vyc2l2ZSlcbiAgICAgICAgICAgIGNvbnN0IGJhc2VDb250ZW50cyA9IGF3YWl0IHRoaXMuZG9jTWFuYWdlci5zZXJ2aWNlcy5jb250ZW50cy5nZXQocGF0aEZvckFwaSB8fCAnJyk7XG4gICAgICAgICAgICBpZiAoYmFzZUNvbnRlbnRzLnR5cGUgIT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUGF0aCBpcyBub3QgYSBkaXJlY3Rvcnk6JywgYmFzZVBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUHJvY2VzcyBiYXNlIGRpcmVjdG9yeSBpdGVtc1xuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGJhc2VDb250ZW50cy5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbVR5cGUgPSBpdGVtLnR5cGUgPT09ICdkaXJlY3RvcnknID8gJ2RpcmVjdG9yeScgOiAnZmlsZSc7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGRpcmVjdG9yaWVzIGlmIHdlJ3JlIGxpc3RpbmcgZGlyZWN0b3JpZXMgb3IgYm90aFxuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2RpcmVjdG9yeScgJiYgKGZpbHRlclR5cGUgPT09ICdkaXJlY3RvcnknIHx8IGZpbHRlclR5cGUgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaXJlY3RvcnknLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiBgLi8ke2l0ZW0ubmFtZX1gXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBBZGQgZmlsZXMgaWYgd2UncmUgbGlzdGluZyBmaWxlcyBhbmQgdGhlIGV4dGVuc2lvbiBpcyBhbGxvd2VkXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnZmlsZScgJiYgKGZpbHRlclR5cGUgPT09ICdmaWxlJyB8fCBmaWx0ZXJUeXBlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVFeHQgPSBgLiR7aXRlbS5uYW1lLnNwbGl0KCcuJykucG9wKCl9YC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbGxvd2VkRXh0ZW5zaW9ucy5pbmNsdWRlcyhmaWxlRXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxsUmVzdWx0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogaXRlbS5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhdGg6IGAuLyR7aXRlbS5uYW1lfWBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29ydCB0aGUgcmVzdWx0cyBhcHByb3ByaWF0ZWx5XG4gICAgICAgICAgICBhbGxSZXN1bHRzID0gYWxsUmVzdWx0cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbGlzdGluZyBkaXJlY3RvcmllcyBvbmx5LCBzb3J0IGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclR5cGUgPT09ICdkaXJlY3RvcnknKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBsaXN0aW5nIGZpbGVzIG9ubHksIHNvcnQgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAoZmlsdGVyVHlwZSA9PT0gJ2ZpbGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBJZiBsaXN0aW5nIGJvdGgsIHNvcnQgZGlyZWN0b3JpZXMgZmlyc3QsIHRoZW4gZmlsZXMgYWxwaGFiZXRpY2FsbHlcbiAgICAgICAgICAgICAgICBpZiAoYS50eXBlID09PSAnZGlyZWN0b3J5JyAmJiBiLnR5cGUgIT09ICdkaXJlY3RvcnknKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgaWYgKGEudHlwZSAhPT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlID09PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEubmFtZS5sb2NhbGVDb21wYXJlKGIubmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIENhY2hlIHRoZSByZXN1bHRzIGZvciBmdXR1cmUgdXNlXG4gICAgICAgICAgICB0aGlzLmZpbGVDYWNoZS5zZXQoY2FjaGVLZXksIGFsbFJlc3VsdHMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBGb3VuZCAke2FsbFJlc3VsdHMubGVuZ3RofSBpdGVtcyBmb3IgcGF0aCAnJHtiYXNlUGF0aH0nYCk7XG4gICAgICAgICAgICByZXR1cm4gYWxsUmVzdWx0cztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYFBPUFVQOiBFcnJvciBsaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50cyBmb3IgJyR7YmFzZVBhdGh9JzpgLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBzZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgZGlyUGF0aCA9IG51bGw7XG4gICAgICAgIGNvbnN0IGFwcCA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcDtcbiAgICAgICAgaWYgKCFhcHApIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBBcHBsaWNhdGlvbiByZWZlcmVuY2Ugbm90IGF2YWlsYWJsZScpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50U2hlbGxXaWRnZXQgPSBhcHAuc2hlbGwuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGN1cnJlbnRTaGVsbFdpZGdldCkge1xuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0Q29udGV4dCA9IHRoaXMuZG9jTWFuYWdlci5jb250ZXh0Rm9yV2lkZ2V0KGN1cnJlbnRTaGVsbFdpZGdldCk7XG4gICAgICAgICAgICBpZiAod2lkZ2V0Q29udGV4dCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGggPSB3aWRnZXRDb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgZGlyUGF0aCA9IHRoaXMuZ2V0UGFyZW50RGlyZWN0b3J5KHBhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGN1cnJlbnQgd2lkZ2V0IGNvbnRleHQ6ICR7cGF0aH0gLT4gJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkaXJQYXRoID09PSBudWxsICYmIHRoaXMuY3VycmVudE5vdGVib29rICYmIHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rUGF0aCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbm90ZWJvb2tQYXRoID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSB0aGlzLmdldFBhcmVudERpcmVjdG9yeShub3RlYm9va1BhdGgpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUGF0aCBmcm9tIGFjdGl2ZSBub3RlYm9vazogJHtub3RlYm9va1BhdGh9IC0+ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWZ0V2lkZ2V0cyA9IEFycmF5LmZyb20oYXBwLnNoZWxsLndpZGdldHMoJ2xlZnQnKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZUJyb3dzZXJXaWRnZXQgPSBsZWZ0V2lkZ2V0cy5maW5kKHdpZGdldCA9PiB3aWRnZXQuaWQgPT09ICdmaWxlYnJvd3NlcicpO1xuICAgICAgICAgICAgICAgIGlmIChmaWxlQnJvd3NlcldpZGdldCAmJiAoKF9hID0gZmlsZUJyb3dzZXJXaWRnZXQubW9kZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXRoKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJQYXRoID0gZmlsZUJyb3dzZXJXaWRnZXQubW9kZWwucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBQYXRoIGZyb20gZmlsZSBicm93c2VyIHdpZGdldCBtb2RlbDogJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGaWxlIGJyb3dzZXIgd2lkZ2V0IHBhdGggbm90IGRpcmVjdGx5IGFjY2Vzc2libGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BPUFVQOiBDb3VsZCBub3QgZ2V0IHBhdGggZnJvbSBmaWxlIGJyb3dzZXIuJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpclBhdGggPSAnJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRmFsbGluZyBiYWNrIHRvIHNlcnZlciByb290IHBhdGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBkaXJQYXRoO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IEluaXRpYWwgY3VycmVudCBtZW51IHBhdGggc2V0IHRvOiAnJHt0aGlzLmN1cnJlbnRNZW51UGF0aH0nYCk7XG4gICAgfVxuICAgIGdldFBhcmVudERpcmVjdG9yeShwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gTWF0aC5tYXgocGF0aC5sYXN0SW5kZXhPZignLycpLCBwYXRoLmxhc3RJbmRleE9mKCdcXFxcXFxcXCcpKTtcbiAgICAgICAgaWYgKGxhc3RTbGFzaCA9PT0gLTEpXG4gICAgICAgICAgICByZXR1cm4gJyc7IC8vIE5vIGRpcmVjdG9yeSBwYXJ0LCBsaWtlbHkgcm9vdCBvciBqdXN0IGEgZmlsZW5hbWVcbiAgICAgICAgcmV0dXJuIHBhdGguc3Vic3RyaW5nKDAsIGxhc3RTbGFzaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBrZXlib2FyZCBuYXZpZ2F0aW9uIHdoZW4gdGhlIHBvcHVwIG1lbnUgaXMgc2hvd25cbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLy8gU2tpcCBpZiBtZW51IG5vdCB2aXNpYmxlXG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgS2V5RG93bjogS2V5PScke2V2ZW50LmtleX0nLCBUYXJnZXQ9JyR7KF9hID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudGFnTmFtZX0nLCBTZWFyY2hGb2N1c2VkPScke2RvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IHRoaXMuc2VhcmNoSW5wdXR9J2ApO1xuICAgICAgICAvLyBTcGVjaWFsIGhhbmRsaW5nIGZvciB3aGVuIHNlYXJjaCBpbnB1dCBpcyBmb2N1c2VkXG4gICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLnNlYXJjaElucHV0KSB7XG4gICAgICAgICAgICAvLyBUaGUgaW5wdXQncyBvd24ga2V5ZG93biBoYW5kbGVyIHdpbGwgaGFuZGxlIG1vc3Qga2V5c1xuICAgICAgICAgICAgLy8gQnV0IGZvciBjZXJ0YWluIGtleXMgbGlrZSBhcnJvdyBrZXlzLCB3ZSBtYXkgbmVlZCB0byBtb3ZlIGZvY3VzXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXkgPT09ICdBcnJvd1VwJykge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgc2VsZWN0aW9uIHRvIGZpcnN0L2xhc3QgaXRlbVxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gRGVsYXkgYmVmb3JlIG1vdmluZyBmb2N1cyAtIHRoaXMgZ2l2ZXMgdGltZSBmb3IgdGhlIHNlYXJjaCBpbnB1dCdzXG4gICAgICAgICAgICAgICAgLy8gb3duIGtleWRvd24gaGFuZGxlciB0byBwcm9jZXNzIHRoZSBrZXkgZmlyc3RcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHsgLy8gQXJyb3dVcFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5ibHVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzTWVudUl0ZW0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElNUE9SVEFOVDogRm9yIEJhY2tzcGFjZSBpbiBzZWFyY2ggaW5wdXQsIGp1c3QgcmV0dXJuIHdpdGhvdXQgaGFuZGxpbmdcbiAgICAgICAgICAgIC8vIExldCB0aGUgZGVmYXVsdCBiZWhhdmlvciBoYXBwZW5cbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gSnVzdCBwZXJmb3JtIGRlZmF1bHQgYmVoYXZpb3IgaW4gc2VhcmNoIGlucHV0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV0IGFsbCBvdGhlciBrZXlzIGJlIGhhbmRsZWQgYnkgdGhlIHNlYXJjaCBpbnB1dCdzIG93biBoYW5kbGVyXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRnJvbSBoZXJlLCBzZWFyY2ggaW5wdXQgaXMgTk9UIGZvY3VzZWRcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgc3dpdGNoIChldmVudC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6XG4gICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBBcnJvd0Rvd24nKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6XG4gICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBBcnJvd1VwJyk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFByZXZpb3VzTWVudUl0ZW0oKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdCYWNrc3BhY2UnOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBCYWNrc3BhY2UnKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHByZXZlbnQgZGVmYXVsdCBhbmQgbmF2aWdhdGUgYmFjayBpZiB3ZSBoYXZlIGhpc3RvcnlcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5tZW51SGlzdG9yeS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlQmFja01lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBObyBoaXN0b3J5LCBhbGxvd2luZyBCYWNrc3BhY2UgZGVmYXVsdCBhY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWxsb3cgZGVmYXVsdCAtIGRvbid0IHByZXZlbnQgb3Igc3RvcCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VudGVyJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogRW50ZXInKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IGFjdGl2YXRlIGlmIGFuIGl0ZW0gaXMgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPj0gMCAmJiB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA8IG1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIG1lbnVJdGVtc1t0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleF0uY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdUYWInOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUCBLZXlEb3duIChNZW51IEZvY3VzZWQpOiBUYWInKTtcbiAgICAgICAgICAgICAgICAvLyBCYXNpYyBUYWIgc3VwcG9ydDogbW92ZSBmb2N1cyBiZXR3ZWVuIHNlYXJjaCBhbmQgZmlyc3QvbGFzdCBpdGVtXG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnIHx8IHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGVzZWxlY3RBbGxNZW51SXRlbXMoKTsgLy8gRGVzZWxlY3QgaXRlbXMgd2hlbiBzZWFyY2ggZ2V0cyBmb2N1cyB2aWEgVGFiXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXliZSBjbG9zZSBtZW51IG9uIFRhYiBmcm9tIHRvcCBsZXZlbD8gT3IgZG8gbm90aGluZy5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgS2V5RG93biAoTWVudSBGb2N1c2VkKTogRXNjYXBlJyk7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIEtleURvd24gKE1lbnUgRm9jdXNlZCk6IERlZmF1bHQga2V5ICcke2V2ZW50LmtleX0nYCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdHlwaW5nIGEgY2hhcmFjdGVyIGFuZCBpbiBmaWxlL2RpciB2aWV3LCBmb2N1cyBzZWFyY2hcbiAgICAgICAgICAgICAgICBpZiAoKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpICYmXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmtleS5sZW5ndGggPT09IDEgJiYgIWV2ZW50LmN0cmxLZXkgJiYgIWV2ZW50Lm1ldGFLZXkgJiYgIWV2ZW50LmFsdEtleSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGNoYXJhY3RlciBhcHBlYXJpbmcgZWxzZXdoZXJlXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGFwcGVuZCB0aGUgdHlwZWQgY2hhcmFjdGVyIGFzIGZvY3VzIGhhcHBlbnMgYWZ0ZXIga2V5ZG93biBkZWZhdWx0IGFjdGlvblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LnZhbHVlICs9IGV2ZW50LmtleTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVHJpZ2dlciBpbnB1dCBldmVudCBtYW51YWxseSB0byB1cGRhdGUgbGlzdFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFsbG93IG90aGVyIGtleXMgKGUuZy4sIG1vZGlmaWVycykgdG8gcGFzcyB0aHJvdWdoIGlmIG5vdCBoYW5kbGVkXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgdXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0OiBIaWdobGlnaHRpbmcgaW5kZXggJHt0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleH0gYW1vbmcgJHttZW51SXRlbXMubGVuZ3RofSBpdGVtcy5gKTtcbiAgICAgICAgbWVudUl0ZW1zLmZvckVhY2goKGl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpdGVtLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQ6IEFkZGVkICdzZWxlY3RlZCcgdG8gaXRlbSAke2luZGV4fWApO1xuICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgaXRlbSBpcyB2aXNpYmxlXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ25lYXJlc3QnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNsYXNzTGlzdC5jb250YWlucygnc2VsZWN0ZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQ6IFJlbW92ZWQgJ3NlbGVjdGVkJyBmcm9tIGl0ZW0gJHtpbmRleH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXNlbGVjdEFsbE1lbnVJdGVtcygpIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgbWVudUl0ZW1zLmZvckVhY2goaXRlbSA9PiBpdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ3NlbGVjdGVkJykpO1xuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xO1xuICAgIH1cbiAgICBzZWxlY3ROZXh0TWVudUl0ZW0oKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIGlmICghbWVudUl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIHNlbGVjdE5leHQ6IE5vIGl0ZW1zIHRvIHNlbGVjdC4nKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIEVuc3VyZSBpbmRleCBpcyByZXNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXg7XG4gICAgICAgIC8vIERlc2VsZWN0IGN1cnJlbnQgZmlyc3QgaXMgaGFuZGxlZCBieSB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHRcbiAgICAgICAgLy8gTW92ZSB0byB0aGUgbmV4dCBpdGVtIG9yIGxvb3AgYmFjayB0byB0aGUgZmlyc3RcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggKyAxKSAlIG1lbnVJdGVtcy5sZW5ndGg7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUCBzZWxlY3ROZXh0OiBJbmRleCBjaGFuZ2VkIGZyb20gJHtvbGRJbmRleH0gdG8gJHt0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleH1gKTtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKTtcbiAgICB9XG4gICAgc2VsZWN0UHJldmlvdXNNZW51SXRlbSgpIHtcbiAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgaWYgKCFtZW51SXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgc2VsZWN0UHJldmlvdXM6IE5vIGl0ZW1zIHRvIHNlbGVjdC4nKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIEVuc3VyZSBpbmRleCBpcyByZXNldFxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9sZEluZGV4ID0gdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXg7XG4gICAgICAgIC8vIERlc2VsZWN0IGN1cnJlbnQgZmlyc3QgaXMgaGFuZGxlZCBieSB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHRcbiAgICAgICAgLy8gTW92ZSB0byB0aGUgcHJldmlvdXMgaXRlbSBvciBsb29wIHRvIHRoZSBsYXN0XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPD0gMCA/XG4gICAgICAgICAgICBtZW51SXRlbXMubGVuZ3RoIC0gMSA6IHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4IC0gMTtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQIHNlbGVjdFByZXZpb3VzOiBJbmRleCBjaGFuZ2VkIGZyb20gJHtvbGRJbmRleH0gdG8gJHt0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleH1gKTtcbiAgICAgICAgdGhpcy51cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBpbnRlcmFjdGl2ZSBtZW51IGl0ZW1zXG4gICAgICovXG4gICAgZ2V0TWVudUl0ZW1zKCkge1xuICAgICAgICBjb25zdCBpdGVtcyA9IEFycmF5LmZyb20odGhpcy5wb3B1cE1lbnVDb250YWluZXIucXVlcnlTZWxlY3RvckFsbCgnLmpwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJykpO1xuICAgICAgICAvLyBGaWx0ZXIgb3V0IG5vbi1pbnRlcmFjdGl2ZSBpdGVtcyBsaWtlIGxvYWRpbmcsIGVtcHR5LCBlcnJvclxuICAgICAgICByZXR1cm4gaXRlbXMuZmlsdGVyKGl0ZW0gPT4ge1xuICAgICAgICAgICAgY29uc3QgYWN0aW9uSWQgPSBpdGVtLmRhdGFzZXQuYWN0aW9uSWQ7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uSWQgIT09ICdsb2FkaW5nJyAmJiBhY3Rpb25JZCAhPT0gJ2VtcHR5JyAmJiBhY3Rpb25JZCAhPT0gJ2Vycm9yJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSBwb3B1cCBwb3NpdGlvbiwga2VlcGluZyB0aGUgYm90dG9tIGVkZ2UgZml4ZWQgYXQgdGhlIGFuY2hvciBwb2ludFxuICAgICAqL1xuICAgIHVwZGF0ZVBvcHVwUG9zaXRpb24oKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSBhbmNob3IgcG9pbnRzIGFyZSBkZWZpbmVkXG4gICAgICAgIGNvbnN0IGFuY2hvclggPSAoX2EgPSB0aGlzLl9hbmNob3JYKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBjb25zdCBhbmNob3JZID0gKF9iID0gdGhpcy5fYW5jaG9yWSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIHBvcHVwIG1lbnVcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7YW5jaG9yWH1weGA7XG4gICAgICAgIC8vIFNob3cgdGhlIG1lbnUgc28gd2UgY2FuIGNhbGN1bGF0ZSBpdHMgaGVpZ2h0XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAvLyBHZXQgdGhlIGFjdHVhbCBoZWlnaHQgYWZ0ZXIgcmVuZGVyaW5nXG4gICAgICAgIGNvbnN0IG1lbnVIZWlnaHQgPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIC8vIEFkZCBhIHNtYWxsIGdhcCAoMTBweCkgYmV0d2VlbiB0aGUgYm90dG9tIG9mIHRoZSBtZW51IGFuZCB0aGUgdHJpZ2dlciBwb2ludFxuICAgICAgICBjb25zdCBnYXAgPSAxMDtcbiAgICAgICAgLy8gUG9zaXRpb24gYWJvdmUgdGhlIGN1cnNvci9idXR0b24gdG8ga2VlcCBib3R0b20gZWRnZSBhdCB0aGUgYW5jaG9yIHBvaW50OlxuICAgICAgICAvLyB5IC0gZ2FwID0gYm90dG9tIGVkZ2Ugb2YgcG9wdXAsIHNvIHBvcHVwIHRvcCA9IHkgLSBnYXAgLSBtZW51SGVpZ2h0XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLnRvcCA9IGAke2FuY2hvclkgLSBnYXAgLSBtZW51SGVpZ2h0fXB4YDtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBQb3NpdGlvbmVkIG1lbnUgYXQgaGVpZ2h0ICR7bWVudUhlaWdodH1weCB3aXRoIGJvdHRvbSBhdCAke2FuY2hvclkgLSBnYXB9cHhgKTtcbiAgICB9XG59XG5leHBvcnRzLlBvcHVwTWVudU1hbmFnZXIgPSBQb3B1cE1lbnVNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSB2b2lkIDA7XG5jb25zdCB3aWRnZXRzXzEgPSByZXF1aXJlKFwiQGx1bWluby93aWRnZXRzXCIpO1xuY29uc3QgbWFya2VkXzEgPSByZXF1aXJlKFwibWFya2VkXCIpO1xuY29uc3QgZG9tcHVyaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbXB1cmlmeVwiKSk7XG5jb25zdCBpY29uc18xID0gcmVxdWlyZShcIi4vaWNvbnNcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9nbG9iYWxzXCIpO1xuY29uc3QgYXBpX2NsaWVudF8xID0gcmVxdWlyZShcIi4vYXBpLWNsaWVudFwiKTtcbmNvbnN0IG1hcmtkb3duX2NvbmZpZ18xID0gcmVxdWlyZShcIi4vbWFya2Rvd24tY29uZmlnXCIpO1xuY29uc3QgcG9wdXBfbWVudV9tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9wb3B1cC1tZW51LW1hbmFnZXJcIik7XG5jb25zdCBoaWdobGlnaHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaGlnaGxpZ2h0LmpzXCIpKTtcbi8vIEFkZCBpbWFnZSBjYWNoZSBvYmplY3QgZm9yIGJhc2U2NCBpbWFnZXMgLSBDT01NRU5URUQgT1VULCBubyBsb25nZXIgbmVlZGVkIGZvciBVUkwgbWV0aG9kXG4vLyBjb25zdCBpbWFnZUNhY2hlOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4vLyBDb25maWd1cmUgbWFya2VkIHdpdGggb3VyIHNldHRpbmdzXG4oMCwgbWFya2Rvd25fY29uZmlnXzEuY29uZmlndXJlTWFya2VkKSgpO1xuLyoqXG4gKiBNYWluIHNpZGViYXIgd2lkZ2V0IGZvciB0aGUgQUkgY2hhdCBpbnRlcmZhY2VcbiAqL1xuY2xhc3MgU2ltcGxlU2lkZWJhcldpZGdldCBleHRlbmRzIHdpZGdldHNfMS5XaWRnZXQge1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc01hcmtkb3duTW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9ICcnO1xuICAgICAgICB0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGZhbHNlOyAvLyBUcmFjayB3aGV0aGVyIEAgc3ltYm9sIGlzIHByZXNlbnQgaW4gaW5wdXRcbiAgICAgICAgdGhpcy5oYXNDb2RlUmVmTGlzdGVuZXJzID0gZmFsc2U7IC8vIFRyYWNrIHdoZXRoZXIgY29kZSByZWYgbGlzdGVuZXJzIGFyZSBhZGRlZFxuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBrZXlib2FyZCBzaG9ydGN1dHNcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBAIGtleSAoZm9yIGNvbnRleHQgbWVudSkgLSBjaGFuZ2VkIGZyb20gQ3RybCtAXG4gICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQCcpIHtcbiAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBiZWhhdmlvclxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgLy8gT25seSBzaG93IG1lbnUgaWYgaW5wdXQgZmllbGQgaXMgZm9jdXNlZFxuICAgICAgICAgICAgICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ID09PSB0aGlzLmlucHV0RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGN1cnNvciBwb3NpdGlvbiBpbiBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuaW5wdXRGaWVsZC5zZWxlY3Rpb25TdGFydCB8fCAwO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0QmVmb3JlQ3Vyc29yID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlLnN1YnN0cmluZygwLCBjdXJzb3JQb3NpdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiB0byBzaG93IG1lbnVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5wdXRSZWN0ID0gdGhpcy5pbnB1dEZpZWxkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5lSGVpZ2h0ID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUodGhpcy5pbnB1dEZpZWxkKS5saW5lSGVpZ2h0KSB8fCAyMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ291bnQgbmV3bGluZXMgYmVmb3JlIGN1cnNvciB0byBkZXRlcm1pbmUgdmVydGljYWwgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGluZXNCZWZvcmVDdXJzb3IgPSAodGV4dEJlZm9yZUN1cnNvci5tYXRjaCgvXFxuL2cpIHx8IFtdKS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBjdXJzb3IgcG9zaXRpb24gd2l0aGluIGN1cnJlbnQgbGluZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsYXN0TmV3bGluZSA9IHRleHRCZWZvcmVDdXJzb3IubGFzdEluZGV4T2YoJ1xcbicpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyc0luQ3VycmVudExpbmUgPSBsYXN0TmV3bGluZSA9PT0gLTEgPyBjdXJzb3JQb3NpdGlvbiA6IGN1cnNvclBvc2l0aW9uIC0gbGFzdE5ld2xpbmUgLSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBob3Jpem9udGFsIHBvc2l0aW9uICh1c2luZyBhdmVyYWdlIGNoYXJhY3RlciB3aWR0aClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhcldpZHRoID0gODsgLy8gQXBwcm94aW1hdGUgd2lkdGggb2YgYSBjaGFyYWN0ZXIgaW4gcGl4ZWxzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhvcml6b250YWxPZmZzZXQgPSBjaGFyc0luQ3VycmVudExpbmUgKiBjaGFyV2lkdGg7XG4gICAgICAgICAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVmdCA9IGlucHV0UmVjdC5sZWZ0ICsgaG9yaXpvbnRhbE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBjdXJzb3IncyB2ZXJ0aWNhbCBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3JUb3AgPSBpbnB1dFJlY3QudG9wICsgKGxpbmVzQmVmb3JlQ3Vyc29yICogbGluZUhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTaG93aW5nIHBvcHVwIGF0IGN1cnNvciBwb3NpdGlvbjogKCR7bGVmdH0sICR7Y3Vyc29yVG9wfSlgKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IEAgc3ltYm9sIGF0IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZS5zdWJzdHJpbmcoMCwgY3Vyc29yUG9zaXRpb24pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdAJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUuc3Vic3RyaW5nKGN1cnNvclBvc2l0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBoYXMgQCBzeW1ib2wgZmxhZ1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0F0U3ltYm9sID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWZ0ZXIgdGhlIEAgc3ltYm9sXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZWxlY3Rpb25TdGFydCA9IGN1cnNvclBvc2l0aW9uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNlbGVjdGlvbkVuZCA9IGN1cnNvclBvc2l0aW9uICsgMTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB0aGUgcG9wdXAgbWVudSBhYm92ZSB0aGUgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KGxlZnQgKyA2MCwgY3Vyc29yVG9wIC0gMjApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dLZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKCdCcm93c2UgY2VsbHMsIGNvZGUsIGZpbGVzLCBhbmQgbW9yZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGZvciBDdHJsK0wgKGZvciBzZWxlY3RlZCBjb2RlKVxuICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQuY3RybEtleSAmJiBldmVudC5rZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGJyb3dzZXIgYmVoYXZpb3JcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbFxuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY2VsbCB8fCAhY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF2aWV3KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlcmUncyBhIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24ubWFpbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlcmUncyBhIHNlbGVjdGlvbiwgdXNlIEBjb2RlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmcm9tID0gc2VsZWN0aW9uLm1haW4uZnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gc2VsZWN0aW9uLm1haW4udG87XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY29kZSAke3NlbGVjdGVkVGV4dH1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IoJ1NlbGVjdGVkIGNvZGUgaW5zZXJ0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIHNlbGVjdGlvbiwgdXNlIEBjZWxsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29udGV4dCA9IChfYiA9IGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldEN1cnJlbnRDZWxsQ29udGV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGxDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBAY2VsbCAke2NlbGxDb250ZXh0LnRleHR9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignQ2VsbCBjb250ZW50IGluc2VydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRW5zdXJlIHRoZSBzaWRlYmFyIGlzIHZpc2libGUgYW5kIGZvY3VzZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvdygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaGFuZGxpbmcga2V5Ym9hcmQgc2hvcnRjdXQ6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICAgICAgdGhpcy5pZCA9ICdzaW1wbGUtc2lkZWJhcic7XG4gICAgICAgIHRoaXMudGl0bGUubGFiZWwgPSAnJztcbiAgICAgICAgdGhpcy50aXRsZS5jYXB0aW9uID0gJ0FJIENoYXQgSW50ZXJmYWNlJztcbiAgICAgICAgdGhpcy50aXRsZS5pY29uID0gaWNvbnNfMS5leHRlbnNpb25JY29uO1xuICAgICAgICB0aGlzLnRpdGxlLmNsb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgLy8gQWRkIHRoZSBtYWluIENTUyBjbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICB0aGlzLmFkZENsYXNzKCdqcC1sbG0tZXh0LXNpZGViYXInKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBBUEkgY2xpZW50XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IGFwaV9jbGllbnRfMS5BcGlDbGllbnQoKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjb250YWluZXIgZWxlbWVudHMgYmVmb3JlIGNyZWF0aW5nIGxheW91dFxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgdGhpcy50aXRsZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQta2V5Ym9hcmQtc2hvcnRjdXQtaW5kaWNhdG9yJztcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcik7XG4gICAgICAgIC8vIENyZWF0ZSBzZXR0aW5ncyBtb2RhbFxuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIgPSB0aGlzLmNyZWF0ZVNldHRpbmdzTW9kYWwoKTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lcik7XG4gICAgICAgIC8vIEluc3RhbnRpYXRlIHRoZSBQb3B1cE1lbnVNYW5hZ2VyIHdpdGggY2FsbGJhY2tzXG4gICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlciA9IG5ldyBwb3B1cF9tZW51X21hbmFnZXJfMS5Qb3B1cE1lbnVNYW5hZ2VyKHRoaXMuZG9jTWFuYWdlciwgdGhpcy5ub2RlLCB7XG4gICAgICAgICAgICBpbnNlcnRDb2RlOiAoY29kZSkgPT4gdGhpcy5hcHBlbmRUb0lucHV0KGBjb2RlICR7Y29kZX1gKSxcbiAgICAgICAgICAgIGluc2VydENlbGw6IChjb250ZW50KSA9PiB0aGlzLmFwcGVuZFRvSW5wdXQoYGNlbGwgJHtjb250ZW50fWApLFxuICAgICAgICAgICAgaW5zZXJ0RmlsZVBhdGg6IChwYXRoKSA9PiB0aGlzLmFwcGVuZFRvSW5wdXQoYGZpbGUgJHtwYXRofWApLFxuICAgICAgICAgICAgaW5zZXJ0RGlyZWN0b3J5UGF0aDogKHBhdGgpID0+IHRoaXMuYXBwZW5kVG9JbnB1dChgZGlyZWN0b3J5ICR7cGF0aH1gKSwgLy8gSWYgbmVlZGVkXG4gICAgICAgICAgICBnZXRTZWxlY3RlZFRleHQ6ICgpID0+IHRoaXMuZ2V0U2VsZWN0ZWRUZXh0KCksXG4gICAgICAgICAgICBnZXRDdXJyZW50Q2VsbENvbnRlbnQ6ICgpID0+IHRoaXMuZ2V0Q3VycmVudENlbGxDb250ZW50KCksXG4gICAgICAgICAgICBpbnNlcnRDZWxsQnlJbmRleDogKGluZGV4KSA9PiB0aGlzLmluc2VydENlbGxCeUluZGV4KGluZGV4KSxcbiAgICAgICAgICAgIGluc2VydENvbGxhcHNlZENvZGVSZWY6IChjb2RlLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSkgPT4gdGhpcy5pbnNlcnRDb2xsYXBzZWRDb2RlUmVmKGNvZGUsIGNlbGxJbmRleCwgbGluZU51bWJlciwgbm90ZWJvb2tOYW1lKVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgb24gc3RhcnRcbiAgICAgICAgdGhpcy5jcmVhdGVOZXdDaGF0KCk7XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxheW91dCgpKTtcbiAgICAgICAgLy8gUG9wLXVwIG1lbnUgd2lsbCBiZSBhdHRhY2hlZCB0byBkb2N1bWVudC5ib2R5IHdoZW4gc2hvd25cbiAgICAgICAgLy8gQWRkIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHZpc3VhbCBpbmRpY2F0b3IgZm9yIGtleWJvYXJkIHNob3J0Y3V0c1xuICAgICAqL1xuICAgIHNob3dLZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKHRleHQpIHtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gSGlkZSBhZnRlciAxIHNlY29uZFxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgIH0sIDEwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwb3NlcyBhbGwgcmVzb3VyY2VzXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCB0aGlzLmhhbmRsZUtleURvd24pO1xuICAgICAgICAvLyBSZW1vdmUga2V5Ym9hcmQgc2hvcnRjdXQgaW5kaWNhdG9yXG4gICAgICAgIGlmICh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEaXNwb3NlIHRoZSBwb3B1cCBtZW51IG1hbmFnZXJcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51TWFuYWdlcikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1haW4gbGF5b3V0IGZvciB0aGUgc2lkZWJhclxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAvLyBUaGUgbWFpbiBjbGFzcyAnanAtbGxtLWV4dC1zaWRlYmFyJyBpcyBhZGRlZCB0byB0aGlzLm5vZGUgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAgIC8vIFRoaXMgY29udGFpbmVyIGNhbiBoYXZlIGl0cyBvd24gY2xhc3MgaWYgbmVlZGVkIGZvciBmdXJ0aGVyIG5lc3Rpbmcvc3R5bGluZ1xuICAgICAgICBtYWluQ29udGVudC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb250ZW50LXdyYXBwZXInO1xuICAgICAgICAvLyBDcmVhdGUgdGl0bGUgaW5wdXQgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRpdGxlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXRpdGxlLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIFNldCB1cCB0aXRsZSBpbnB1dFxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQuY2xhc3NOYW1lID0gJ2NoYXQtdGl0bGUtaW5wdXQnOyAvLyBBc3N1bWluZyB0aGlzIGlzIHN0eWxlZCBjb3JyZWN0bHkgaW4gQ1NTXG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQucGxhY2Vob2xkZXIgPSAnQ2hhdCB0aXRsZSc7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC52YWx1ZSA9ICdOZXcgQ2hhdCc7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB0aGlzLnVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUoKSk7XG4gICAgICAgIHRpdGxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGl0bGVJbnB1dCk7XG4gICAgICAgIC8vIENyZWF0ZSBOZXcgQ2hhdCAmIEhpc3RvcnkgYnV0dG9uc1xuICAgICAgICBjb25zdCBuZXdDaGF0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLnRleHRDb250ZW50ID0gJysgTmV3IENoYXQnO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLnRpdGxlID0gJ1N0YXJ0IGEgbmV3IGNoYXQnO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5jcmVhdGVOZXdDaGF0KCkpO1xuICAgICAgICBjb25zdCBoaXN0b3J5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uY2xhc3NOYW1lID0gJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nO1xuICAgICAgICBoaXN0b3J5QnV0dG9uLnRleHRDb250ZW50ID0gJ0hpc3RvcnknO1xuICAgICAgICBoaXN0b3J5QnV0dG9uLnRpdGxlID0gJ1ZpZXcgY2hhdCBoaXN0b3J5JztcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMudG9nZ2xlSGlzdG9yeVZpZXcoKSk7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1jb250YWluZXInO1xuICAgICAgICAvLyBDb25maWd1cmUgaGlzdG9yeSBjb250YWluZXJcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBpbnB1dCBmaWVsZCAoZGlyZWN0bHkgdXNlZCBsYXRlcilcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gJ0FzayBtZSBhbnl0aGluZy4uLic7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5yb3dzID0gMTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWlucHV0LWZpZWxkJzsgLy8gQWRkIGNsYXNzIGZvciBzdHlsaW5nXG4gICAgICAgIC8vIEFkZCBrZXlwcmVzcyBsaXN0ZW5lciB0byBpbnB1dCBmaWVsZFxuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBBZGQgaW5wdXQgZXZlbnQgbGlzdGVuZXIgdG8gZGV0ZWN0IGNoYW5nZXMgdG8gdGhlIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBAIHN5bWJvbCBoYXMgYmVlbiByZW1vdmVkXG4gICAgICAgICAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IHRoaXMuaW5wdXRGaWVsZC5zZWxlY3Rpb25TdGFydDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLmlucHV0RmllbGQudmFsdWUuc2xpY2UoMCwgY3Vyc29yUG9zaXRpb24pO1xuICAgICAgICAgICAgY29uc3QgaGFzQXROb3cgPSB0ZXh0QmVmb3JlQ3Vyc29yLmVuZHNXaXRoKCdAJykgJiZcbiAgICAgICAgICAgICAgICAoY3Vyc29yUG9zaXRpb24gPT09IDEgfHwgLy8gQCBpcyBhdCBzdGFydCBvZiBpbnB1dFxuICAgICAgICAgICAgICAgICAgICAhIXRleHRCZWZvcmVDdXJzb3JbY3Vyc29yUG9zaXRpb24gLSAyXS5tYXRjaCgvXFxzLykpOyAvLyBAIGZvbGxvd3Mgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQXRTeW1ib2wgJiYgIWhhc0F0Tm93KSB7XG4gICAgICAgICAgICAgICAgLy8gQCBzeW1ib2wgd2FzIHByZXNlbnQgYnV0IG5vdyBpdCdzIGdvbmUsIGhpZGUgdGhlIHBvcHVwXG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaGFzQXRTeW1ib2wgPSBoYXNBdE5vdztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSBzZW5kIGJ1dHRvbiBjb250YWluZXIgKGRpcmVjdGx5IHVzZWQgbGF0ZXIpXG4gICAgICAgIGNvbnN0IGlucHV0QWN0aW9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpbnB1dEFjdGlvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtYWN0aW9ucy1jb250YWluZXInO1xuICAgICAgICAvLyBDcmVhdGUgc2VuZCBidXR0b25cbiAgICAgICAgY29uc3Qgc2VuZEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBzZW5kQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1zZW5kLWJ1dHRvbic7XG4gICAgICAgIHNlbmRCdXR0b24udGV4dENvbnRlbnQgPSAnU2VuZCc7XG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlKCkpO1xuICAgICAgICBpbnB1dEFjdGlvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoc2VuZEJ1dHRvbik7XG4gICAgICAgIC8vIENyZWF0ZSBjb250cm9scyBjb250YWluZXIgKE1hcmtkb3duIHRvZ2dsZSwgQCwgZXRjLikgKGRpcmVjdGx5IHVzZWQgbGF0ZXIpXG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpO1xuICAgICAgICAvLyBDcmVhdGUgdGhlIG5ldyBib3R0b20gYmFyIGNvbnRhaW5lciB3aXRoIHRocmVlIHJvd3NcbiAgICAgICAgY29uc3QgYm90dG9tQmFyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMuYm90dG9tQmFyQ29udGFpbmVyID0gYm90dG9tQmFyQ29udGFpbmVyO1xuICAgICAgICAvLyBGaXJzdCByb3c6IENvbnRyb2xzIChNYXJrZG93biB0b2dnbGUgYW5kIGFjdGlvbiBidXR0b25zKVxuICAgICAgICBjb25zdCB0b3BSb3cgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9wUm93LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtY29udHJvbHMtcm93JztcbiAgICAgICAgdG9wUm93LmFwcGVuZENoaWxkKGNvbnRyb2xzQ29udGFpbmVyKTtcbiAgICAgICAgLy8gU2Vjb25kIHJvdzogSW5wdXQgZmllbGRcbiAgICAgICAgY29uc3QgbWlkZGxlUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1pZGRsZVJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWlucHV0LXJvdyc7XG4gICAgICAgIG1pZGRsZVJvdy5hcHBlbmRDaGlsZCh0aGlzLmlucHV0RmllbGQpO1xuICAgICAgICAvLyBUaGlyZCByb3c6IEFjdGlvbiBidXR0b25zIChTZW5kLCBOZXcgQ2hhdCwgSGlzdG9yeSlcbiAgICAgICAgY29uc3QgYm90dG9tUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJvdHRvbVJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWJ1dHRvbnMtcm93JztcbiAgICAgICAgLy8gQWRkIGFsbCBidXR0b25zIHRvIGJvdHRvbSByb3dcbiAgICAgICAgYm90dG9tUm93LmFwcGVuZENoaWxkKHNlbmRCdXR0b24pO1xuICAgICAgICBib3R0b21Sb3cuYXBwZW5kQ2hpbGQobmV3Q2hhdEJ1dHRvbik7XG4gICAgICAgIGJvdHRvbVJvdy5hcHBlbmRDaGlsZChoaXN0b3J5QnV0dG9uKTtcbiAgICAgICAgLy8gQWRkIGFsbCByb3dzIHRvIHRoZSBib3R0b20gYmFyIGNvbnRhaW5lclxuICAgICAgICBib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQodG9wUm93KTtcbiAgICAgICAgYm90dG9tQmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKG1pZGRsZVJvdyk7XG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChib3R0b21Sb3cpO1xuICAgICAgICAvLyBBc3NlbWJsZSBhbGwgbWFpbiBjb21wb25lbnRzXG4gICAgICAgIG1haW5Db250ZW50LmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5tZXNzYWdlQ29udGFpbmVyKTtcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGhpcy5oaXN0b3J5Q29udGFpbmVyKTtcbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQoYm90dG9tQmFyQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIG1haW5Db250ZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvblxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQoKSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciB0aGUgY2hhdFxuICAgICAgICBjb25zdCBjaGF0SWQgPSBgY2hhdC0ke0RhdGUubm93KCl9YDtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgaXRlbVxuICAgICAgICBjb25zdCBuZXdDaGF0ID0ge1xuICAgICAgICAgICAgaWQ6IGNoYXRJZCxcbiAgICAgICAgICAgIHRpdGxlOiAnTmV3IENoYXQnLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIC8vIEFkZCB0byBoaXN0b3J5XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgLy8gU2V0IGFzIGN1cnJlbnQgY2hhdFxuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIC8vIFVwZGF0ZSB0aXRsZSBpbnB1dFxuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBuZXdDaGF0LnRpdGxlO1xuICAgICAgICAvLyBDbGVhciBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICBpZiAodGhpcy5tZXNzYWdlQ29udGFpbmVyKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGlkZSBoaXN0b3J5IGlmIGl0J3MgdmlzaWJsZVxuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyBiZXR3ZWVuIGNoYXQgdmlldyBhbmQgaGlzdG9yeSB2aWV3XG4gICAgICovXG4gICAgdG9nZ2xlSGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSA9ICF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmU7XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIC8vIFNob3cgaGlzdG9yeSB2aWV3LCBoaWRlIG1lc3NhZ2UgdmlldyBhbmQgYm90dG9tIGJhclxuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBVc2UgY2xhc3MgcHJvcGVydHkgZGlyZWN0bHlcbiAgICAgICAgICAgIHRoaXMudGl0bGVJbnB1dC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgaGlzdG9yeVxuICAgICAgICAgICAgdGhpcy5yZW5kZXJDaGF0SGlzdG9yeSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2hvdyBtZXNzYWdlIHZpZXcgYW5kIGJvdHRvbSBiYXIsIGhpZGUgaGlzdG9yeSB2aWV3XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIFVzZSBjbGFzcyBwcm9wZXJ0eSBkaXJlY3RseVxuICAgICAgICAgICAgdGhpcy50aXRsZUlucHV0LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGNoYXQgaGlzdG9yeSBpbiB0aGUgaGlzdG9yeSBjb250YWluZXJcbiAgICAgKi9cbiAgICByZW5kZXJDaGF0SGlzdG9yeSgpIHtcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICBpZiAodGhpcy5jaGF0SGlzdG9yeS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZW1wdHlNZXNzYWdlLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWVtcHR5LWhpc3RvcnktbWVzc2FnZSc7XG4gICAgICAgICAgICBlbXB0eU1lc3NhZ2UudGV4dENvbnRlbnQgPSAnTm8gY2hhdCBoaXN0b3J5IHlldCc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQoZW1wdHlNZXNzYWdlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBsaXN0IG9mIGNoYXQgaGlzdG9yeSBpdGVtc1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5LmZvckVhY2goY2hhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoaXN0b3J5SXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtJztcbiAgICAgICAgICAgIGlmIChjaGF0LmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpIHtcbiAgICAgICAgICAgICAgICBoaXN0b3J5SXRlbS5jbGFzc0xpc3QuYWRkKCdqcC1sbG0tZXh0LWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRpdGxlXG4gICAgICAgICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdGl0bGUuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS10aXRsZSc7XG4gICAgICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IGNoYXQudGl0bGU7XG4gICAgICAgICAgICAvLyBBZGQgbWVzc2FnZSBwcmV2aWV3XG4gICAgICAgICAgICBjb25zdCBwcmV2aWV3ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwcmV2aWV3LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktcHJldmlldyc7XG4gICAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IGNoYXQubWVzc2FnZXNbY2hhdC5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHByZXZpZXcudGV4dENvbnRlbnQgPSBsYXN0TWVzc2FnZVxuICAgICAgICAgICAgICAgID8gYCR7bGFzdE1lc3NhZ2UudGV4dC5zdWJzdHJpbmcoMCwgNDApfSR7bGFzdE1lc3NhZ2UudGV4dC5sZW5ndGggPiA0MCA/ICcuLi4nIDogJyd9YFxuICAgICAgICAgICAgICAgIDogJ0VtcHR5IGNoYXQnO1xuICAgICAgICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50XG4gICAgICAgICAgICBoaXN0b3J5SXRlbS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHRoaXMubG9hZENoYXQoY2hhdC5pZCkpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgICAgICAgICAgaGlzdG9yeUl0ZW0uYXBwZW5kQ2hpbGQocHJldmlldyk7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQoaGlzdG9yeUl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBjaGF0IGZyb20gaGlzdG9yeVxuICAgICAqL1xuICAgIGxvYWRDaGF0KGNoYXRJZCkge1xuICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gY2hhdElkKTtcbiAgICAgICAgaWYgKCFjaGF0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvLyBTZXQgYXMgY3VycmVudCBjaGF0XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9IGNoYXRJZDtcbiAgICAgICAgLy8gVXBkYXRlIHRpdGxlXG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC52YWx1ZSA9IGNoYXQudGl0bGU7XG4gICAgICAgIC8vIENsZWFyIGFuZCByZS1wb3B1bGF0ZSBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIGNoYXQubWVzc2FnZXMuZm9yRWFjaChtc2cgPT4ge1xuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKG1zZy50ZXh0LCBtc2cuc2VuZGVyLCBtc2cuaXNNYXJrZG93biwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3dpdGNoIGJhY2sgdG8gY2hhdCB2aWV3XG4gICAgICAgIGlmICh0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSGlzdG9yeVZpZXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBjaGF0XG4gICAgICovXG4gICAgdXBkYXRlQ3VycmVudENoYXRUaXRsZSgpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICBjaGF0LnRpdGxlID0gdGhpcy50aXRsZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgLy8gQWRkIG5vdGlmaWNhdGlvbiB0aGF0IHRpdGxlIGhhcyBiZWVuIHNldFxuICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBub3RpZmljYXRpb24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdG9hc3Qtbm90aWZpY2F0aW9uIGpwLWxsbS1leHQtdGl0bGUtdXBkYXRlZCc7XG4gICAgICAgICAgICBub3RpZmljYXRpb24udGV4dENvbnRlbnQgPSAnQ2hhdCB0aXRsZSB1cGRhdGVkJztcbiAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgbWFpbiB3aWRnZXRcbiAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgLy8gQW5pbWF0ZSBpblxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBhZnRlciBkZWxheVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBmYWRlIG91dCBhbmltYXRpb24gdG8gY29tcGxldGUgYmVmb3JlIHJlbW92aW5nXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgY29udHJvbHMgY29udGFpbmVyIHdpdGggdG9nZ2xlcyBhbmQgYWN0aW9uIGJ1dHRvbnNcbiAgICAgKi9cbiAgICBjcmVhdGVDb250cm9sc0NvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29udHJvbHMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtkb3duIHRvZ2dsZSBjb250YWluZXJcbiAgICAgICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10b2dnbGUtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIG1hcmtkb3duIHRvZ2dsZVxuICAgICAgICBjb25zdCBtYXJrZG93blRvZ2dsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIG1hcmtkb3duVG9nZ2xlLnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICBtYXJrZG93blRvZ2dsZS5pZCA9ICdtYXJrZG93bi10b2dnbGUnO1xuICAgICAgICAvLyBtYXJrZG93blRvZ2dsZS5zdHlsZS5tYXJnaW5SaWdodCA9ICc1cHgnOyAvLyBTdHlsZSB2aWEgQ1NTXG4gICAgICAgIG1hcmtkb3duVG9nZ2xlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIChlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSBlLnRhcmdldDtcbiAgICAgICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSB0YXJnZXQuY2hlY2tlZDtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5wbGFjZWhvbGRlciA9IHRoaXMuaXNNYXJrZG93bk1vZGUgP1xuICAgICAgICAgICAgICAgICdXcml0ZSBtYXJrZG93biBoZXJlLi4uXFxuXFxuIyBFeGFtcGxlIGhlYWRpbmdcXG4tIExpc3QgaXRlbVxcblxcbmBgYGNvZGUgYmxvY2tgYGAnIDpcbiAgICAgICAgICAgICAgICAnQXNrIG1lIGFueXRoaW5nLi4uJztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENyZWF0ZSB0b2dnbGUgbGFiZWxcbiAgICAgICAgY29uc3QgdG9nZ2xlTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICB0b2dnbGVMYWJlbC5odG1sRm9yID0gJ21hcmtkb3duLXRvZ2dsZSc7XG4gICAgICAgIHRvZ2dsZUxhYmVsLnRleHRDb250ZW50ID0gJ01hcmtkb3duIG1vZGUnO1xuICAgICAgICAvLyB0b2dnbGVMYWJlbC5zdHlsZS5mb250U2l6ZSA9ICcxMnB4JzsgLy8gU3R5bGUgdmlhIENTU1xuICAgICAgICAvLyBBZGQgdG9nZ2xlIGVsZW1lbnRzIHRvIGNvbnRhaW5lclxuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQobWFya2Rvd25Ub2dnbGUpO1xuICAgICAgICB0b2dnbGVDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlTGFiZWwpO1xuICAgICAgICAvLyBDcmVhdGUgYWN0aW9uIGJ1dHRvbnMgY29udGFpbmVyIChALCBleHBhbmQsIHNldHRpbmdzKVxuICAgICAgICBjb25zdCBhY3Rpb25CdXR0b25zQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGFjdGlvbkJ1dHRvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbnMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIGFsbCBhY3Rpb24gYnV0dG9uc1xuICAgICAgICBjb25zdCBidXR0b25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHRleHQ6ICdAJyxcbiAgICAgICAgICAgICAgICB0aXRsZTogJ0Jyb3dzZSBjZWxscywgY29kZSwgZmlsZXMsIGFuZCBtb3JlJyxcbiAgICAgICAgICAgICAgICBhY3Rpb246IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJ1dHRvbidzIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldEJ1dHRvbiA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSB0YXJnZXRCdXR0b24uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIHBvcHVwIG1lbnUgYWJvdmUgdGhlIGJ1dHRvbidzIHRvcCBlZGdlXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KHJlY3QubGVmdCArIDYwLCByZWN0LnRvcCAtIDIwKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHsgdGV4dDogJ+KkoicsIHRpdGxlOiAnRXhwYW5kIGlucHV0JywgYWN0aW9uOiAoKSA9PiB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKGFjdGlvbkJ1dHRvbnNDb250YWluZXIuY2hpbGRyZW5bM10pIH0sXG4gICAgICAgICAgICB7IHRleHQ6ICfimpnvuI8nLCB0aXRsZTogJ1NldHRpbmdzJywgYWN0aW9uOiAoZXZlbnQpID0+IHsgZXZlbnQucHJldmVudERlZmF1bHQoKTsgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7IHRoaXMuc2hvd1NldHRpbmdzTW9kYWwoKTsgfSB9LFxuICAgICAgICBdO1xuICAgICAgICAvLyBBZGQgYWxsIGJ1dHRvbnMgdG8gdGhlIGNvbnRhaW5lclxuICAgICAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ0biA9IHRoaXMuY3JlYXRlQnV0dG9uKGJ1dHRvbi50ZXh0LCBidXR0b24udGl0bGUpO1xuICAgICAgICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IGJ1dHRvbi5hY3Rpb24oZSkpO1xuICAgICAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChidG4pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gQWRkIHRvZ2dsZSBhbmQgYWN0aW9uIGJ1dHRvbnMgdG8gdGhlIGNvbnRyb2xzIGNvbnRhaW5lclxuICAgICAgICAvLyBjb250cm9sc0NvbnRhaW5lciBpcyBub3cganVzdCBmb3IgdGhlc2UgaW5saW5lIGNvbnRyb2xzLCBhYm92ZSB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQodG9nZ2xlQ29udGFpbmVyKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQoYWN0aW9uQnV0dG9uc0NvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBjb250cm9sc0NvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIHRvZ2dsZUlucHV0RXhwYW5zaW9uKGJ1dHRvbikge1xuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9ICF0aGlzLmlzSW5wdXRFeHBhbmRlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7XG4gICAgICAgICAgICAvLyBBZGp1c3QgaGVpZ2h0IGJhc2VkIG9uIGEgY2xhc3Mgb3IgQ1NTIHZhcmlhYmxlIGluc3RlYWQgb2YgZml4ZWQgcGl4ZWxzIGlmIHBvc3NpYmxlXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JztcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5yZXNpemUgPSAndmVydGljYWwnO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gJ+KkoSc7XG4gICAgICAgICAgICBidXR0b24udGl0bGUgPSAnQ29sbGFwc2UgaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcnOyAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5yZXNpemUgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQucm93cyA9IDE7IC8vIEVuc3VyZSBpdCBjb2xsYXBzZXMgYmFjayB0byAxIHJvdyBoZWlnaHRcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKInO1xuICAgICAgICAgICAgYnV0dG9uLnRpdGxlID0gJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGVscGVyIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIGJ1dHRvbiB3aXRoIGdpdmVuIHRleHQgYW5kIHRvb2x0aXBcbiAgICAgKi9cbiAgICBjcmVhdGVCdXR0b24odGV4dCwgdG9vbHRpcCkge1xuICAgICAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgYnV0dG9uLnRpdGxlID0gdG9vbHRpcDtcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBzZW5kaW5nIGEgbWVzc2FnZSBmcm9tIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRNZXNzYWdlKCkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5pbnB1dEZpZWxkLnZhbHVlLnRyaW0oKTtcbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIG1lc3NhZ2UgdG8gcmVwbGFjZSBjb2RlIHJlZmVyZW5jZSBwbGFjZWhvbGRlcnNcbiAgICAgICAgICAgIGxldCBwcm9jZXNzZWRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgIGxldCBoYXNDb2RlUmVmcyA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBjb2RlIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGlmICgnX2NvZGVSZWZNYXAnIGluIHRoaXMuaW5wdXRGaWVsZCAmJiB0aGlzLmlucHV0RmllbGQuX2NvZGVSZWZNYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUmVmTWFwID0gdGhpcy5pbnB1dEZpZWxkLl9jb2RlUmVmTWFwO1xuICAgICAgICAgICAgICAgIGhhc0NvZGVSZWZzID0gY29kZVJlZk1hcC5zaXplID4gMDtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwcm9jZXNzZWQgbWVzc2FnZSB3aXRoIHRoZSBwbGFjZWhvbGRlcnMgZm9yIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAvLyBXZSdsbCBrZWVwIHRoZSBvcmlnaW5hbCBtZXNzYWdlIGZvciBzZW5kaW5nIHRvIHRoZSBBUElcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRNZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICAvLyBObyBuZWVkIHRvIGFjdHVhbGx5IG1vZGlmeSB0aGUgbWVzc2FnZSBzaW5jZSB3ZSdsbCB1c2UgdGhlIERPTSBmb3IgcmVuZGVyaW5nXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIFVJIChzZW5kIGFzIHRleHQsIG5vdCBtYXJrZG93biBieSBkZWZhdWx0IGZvciB1c2VyKVxuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHByb2Nlc3NlZE1lc3NhZ2UsICd1c2VyJywgaGFzQ29kZVJlZnMpO1xuICAgICAgICAgICAgLy8gQ2xlYXIgaW5wdXQgYW5kIHJlc2V0IHRoZSBjb2RlIHJlZmVyZW5jZSBtYXBcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgaWYgKCdfY29kZVJlZk1hcCcgaW4gdGhpcy5pbnB1dEZpZWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLl9jb2RlUmVmTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnJvd3MgPSAxOyAvLyBSZXNldCByb3dzIGFmdGVyIHNlbmRpbmdcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnJzsgLy8gUmVzZXQgaGVpZ2h0IGFmdGVyIHNlbmRpbmdcbiAgICAgICAgICAgIC8vIFJlc2V0IGV4cGFuZGVkIHN0YXRlIGlmIG5lZWRlZCBhZnRlciBzZW5kaW5nXG4gICAgICAgICAgICBpZiAodGhpcy5pc0lucHV0RXhwYW5kZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBleHBhbmQgYnV0dG9uIHRvIHJlc2V0IGl0cyBzdGF0ZSBpZiBuZWVkZWQgKHRoaXMgbWlnaHQgbmVlZCBhZGp1c3RtZW50IGJhc2VkIG9uIGZpbmFsIHN0cnVjdHVyZSlcbiAgICAgICAgICAgICAgICBjb25zdCBleHBhbmRCdXR0b24gPSB0aGlzLm5vZGUucXVlcnlTZWxlY3RvcignLmpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbnMtY29udGFpbmVyIGJ1dHRvblt0aXRsZSo9XCJDb2xsYXBzZVwiXScpO1xuICAgICAgICAgICAgICAgIGlmIChleHBhbmRCdXR0b24pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50b2dnbGVJbnB1dEV4cGFuc2lvbihleHBhbmRCdXR0b24pOyAvLyBDb2xsYXBzZSBhZnRlciBzZW5kaW5nXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJyc7IC8vIEZhbGxiYWNrIHJlc2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5yb3dzID0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSB0ZW1wb3JhcnkgbWVzc2FnZSBjb250YWluZXIgZm9yIHRoZSBib3QncyBzdHJlYW1pbmcgcmVzcG9uc2VcbiAgICAgICAgICAgIGNvbnN0IGJvdE1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYm90LW1lc3NhZ2UnO1xuICAgICAgICAgICAgY29uc3QgbWFya2Rvd25JbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLnRleHRDb250ZW50ID0gXCJNRFwiO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IuY2xhc3NOYW1lID0gJ21hcmtkb3duLWluZGljYXRvcic7XG4gICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKG1hcmtkb3duSW5kaWNhdG9yKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzZXBhcmF0ZSBkaXZzIGZvciBzdHJlYW1pbmcgdGV4dCBhbmQgZmluYWwgbWFya2Rvd25cbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbWluZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LmNsYXNzTmFtZSA9ICdzdHJlYW1pbmctY29udGVudCc7XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZm9udEZhbWlseSA9ICdtb25vc3BhY2UnO1xuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmZvbnRTaXplID0gJzAuOWVtJztcbiAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoc3RyZWFtaW5nRGl2KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ21hcmtkb3duLWNvbnRlbnQnO1xuICAgICAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgICAgICAgICBib3RNZXNzYWdlRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGJvdE1lc3NhZ2VEaXYpO1xuICAgICAgICAgICAgLy8gVmFyaWFibGUgdG8gY29sbGVjdCB0aGUgY29tcGxldGUgcmVzcG9uc2VcbiAgICAgICAgICAgIGxldCBjb21wbGV0ZVJlc3BvbnNlID0gJyc7XG4gICAgICAgICAgICAvLyBHZXQgY2VsbCBjb250ZXh0IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29uc3QgY2VsbENvbnRleHQgPSBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIgP1xuICAgICAgICAgICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLmNlbGxDb250ZXh0VHJhY2tlci5nZXRDdXJyZW50Q2VsbENvbnRleHQoKSA6IG51bGw7XG4gICAgICAgICAgICAvLyBTdHJlYW0gcmVzcG9uc2UgZnJvbSBBUElcbiAgICAgICAgICAgIHRoaXMuYXBpQ2xpZW50LnN0cmVhbUNoYXQobWVzc2FnZSwgeyBjZWxsQ29udGV4dCB9LCBcbiAgICAgICAgICAgIC8vIE9uIGVhY2ggY2h1bmsgcmVjZWl2ZWRcbiAgICAgICAgICAgIChjaHVuaykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UgKz0gY2h1bms7XG4gICAgICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnRleHRDb250ZW50ID0gY29tcGxldGVSZXNwb25zZTtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gT24gY29tcGxldGVcbiAgICAgICAgICAgICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBIaWRlIHN0cmVhbWluZyBkaXYsIHNob3cgZmluYWwgY29udGVudCBkaXZcbiAgICAgICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb21wbGV0ZSByZXNwb25zZSBpcyBhbiBpbWFnZSBVUkxcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ltYWdlVXJsID0gY29tcGxldGVSZXNwb25zZS5zdGFydHNXaXRoKCcvaW1hZ2VzLycpICYmIGNvbXBsZXRlUmVzcG9uc2UuZW5kc1dpdGgoJy5wbmcnKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbWFnZVVybCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSBpbWFnZSB0aGF0IGFsbG93cyBwb3NpdGlvbmluZyB0aGUgYnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1jb250YWluZXInO1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbmRlciBhcyBhbiBpbWFnZSB0YWdcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxJbWFnZVVybCA9IGBodHRwOi8vMTI3LjAuMC4xOjgwMDAke2NvbXBsZXRlUmVzcG9uc2V9YDsgLy8gQ29uc3RydWN0IGZ1bGwgVVJMXG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSBmdWxsSW1hZ2VVcmw7XG4gICAgICAgICAgICAgICAgICAgIGltZy5hbHQgPSAnSW1hZ2UgZnJvbSBib3QnO1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3R5bGUubWF4V2lkdGggPSAnMTAwJSc7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XG4gICAgICAgICAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgdGhlIGltYWdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGltZ0FjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb25zJztcbiAgICAgICAgICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYm90dG9tID0gJzEwcHgnO1xuICAgICAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnJpZ2h0ID0gJzEwcHgnO1xuICAgICAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuZ2FwID0gJzhweCc7XG4gICAgICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC42KSc7XG4gICAgICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XG4gICAgICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUucGFkZGluZyA9ICc0cHgnO1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGltYWdlIGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5SW1nQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlJbWdCdG4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW1hZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlJbWdCdG4uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlJbWdCdG4udGl0bGUgPSAnQ29weSBpbWFnZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICAgICAgICAgICAgICBjb3B5SW1nQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29weUltYWdlVG9DbGlwYm9hcmQoZnVsbEltYWdlVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUltZ0J0bik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBmaWxlIHBhdGggYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZFBhdGhCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0aEJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0aEJ0bi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgIGFkZFBhdGhCdG4udGl0bGUgPSAnQWRkIGltYWdlIHBhdGggdG8gY3VycmVudCBjZWxsJztcbiAgICAgICAgICAgICAgICAgICAgYWRkUGF0aEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2VUb0NlbGwoY29tcGxldGVSZXNwb25zZSk7IC8vIEFkZHMganVzdCB0aGUgaW1hZ2UgcGF0aCB0byB0aGUgY2VsbFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRQYXRoQnRuKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBidXR0b25zIHRvIHRoZSBpbWFnZSBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nQWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgaW1hZ2UgY29udGFpbmVyIHRvIHRoZSBjb250ZW50IGRpdlxuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LmFwcGVuZENoaWxkKGltYWdlQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2F2ZSBpbWFnZSBVUkwgdG8gaGlzdG9yeSAoYXMgdGV4dClcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGF0Lm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbXBsZXRlUmVzcG9uc2UsIC8vIFN0b3JlIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6ICdib3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzTWFya2Rvd246IGZhbHNlIC8vIFRyZWF0IGl0IGFzIG5vbi1tYXJrZG93biBmb3IgaGlzdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byByZW5kZXIgbWFya2Rvd25cbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKShjb21wbGV0ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRIdG1sID0gZG9tcHVyaWZ5XzEuZGVmYXVsdC5zYW5pdGl6ZShyYXdIdG1sKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYW4gaW50ZXJydXB0IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJydXB0ID0gY29tcGxldGVSZXNwb25zZS5zdGFydHNXaXRoKCcqKltJTlRFUlJVUFRdKionKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0ludGVycnVwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBidXR0b25zIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWludGVycnVwdC1idXR0b25zJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLnN0eWxlLm1hcmdpblRvcCA9ICcxMnB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uc0NvbnRhaW5lci5zdHlsZS5nYXAgPSAnOHB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29uZmlybSBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb25maXJtLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi50ZXh0Q29udGVudCA9ICdDb25maXJtJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLnBhZGRpbmcgPSAnNnB4IDEycHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuYmFja2dyb3VuZCA9ICcjNENBRjUwJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc0cHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIGJ1dHRvbnMgYWZ0ZXIgY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgXCJjb25maXJtZWRcIiBtZXNzYWdlIGFzIHVzZXIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSgnY29uZmlybWVkJywgJ3VzZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5pbm5lckhUTUwgPSBgPHNwYW4gY2xhc3M9XCJzdGF0dXMtaWNvbiBjb25maXJtLWljb25cIj7inIU8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInN0YXR1cy10ZXh0XCI+VXNlciBjb25maXJtZWQ8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBhdXRvIG1lc3NhZ2UgdG8gQVBJIHdpdGhvdXQgYWRkaW5nIGEgbmV3IHVzZXIgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRBdXRvTWVzc2FnZSgnY29uZmlybWVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIHJlamVjdCBidXR0b25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWplY3RCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcmVqZWN0LWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnRleHRDb250ZW50ID0gJ1JlamVjdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLnBhZGRpbmcgPSAnNnB4IDEycHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kID0gJyNGNDQzMzYnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERpc2FibGUgYnV0dG9ucyBhZnRlciBjbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBcInJlamVjdGVkXCIgbWVzc2FnZSBhcyB1c2VyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSgncmVqZWN0ZWQnLCAndXNlcicsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zdGF0dXMtaW5kaWNhdG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInN0YXR1cy1pY29uIHJlamVjdC1pY29uXCI+4p2MPC9zcGFuPjxzcGFuIGNsYXNzPVwic3RhdHVzLWxpbmVcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtdGV4dFwiPlVzZXIgcmVqZWN0ZWQ8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoc3RhdHVzSW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2VuZCBhdXRvIG1lc3NhZ2UgdG8gQVBJIHdpdGhvdXQgYWRkaW5nIGEgbmV3IHVzZXIgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRBdXRvTWVzc2FnZSgncmVqZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYnV0dG9ucyB0byBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbmZpcm1CdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQocmVqZWN0QnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY29udGFpbmVyIGJlbG93IHRoZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudERpdi5hcHBlbmRDaGlsZChidXR0b25zQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuaGFuY2UgY29kZSBibG9ja3Mgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24gYW5kIGFjdGlvbiBidXR0b25zXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHN0YW5kYXJkIEp1cHl0ZXJMYWIgY2xhc3NlcyBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZFRleHQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoX2EgPSBibG9jay5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LmFkZCgnanAtUmVuZGVyZWRIVE1MQ29tbW9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvZGUgY29udGVudCB0byBkZXRlY3QgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlQ29udGVudCA9IGJsb2NrLnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjb2RlIGJsb2NrIGhlYWRlciBmb3IgYnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSGVhZGVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtaGVhZGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbGFuZ3VhZ2UgaW5kaWNhdG9yIGlmIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmRldGVjdExhbmd1YWdlKGNvZGVDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ0luZGljYXRvci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWxhbmd1YWdlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ0luZGljYXRvci50ZXh0Q29udGVudCA9IGxhbmd1YWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSGVhZGVyLmFwcGVuZENoaWxkKGxhbmdJbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbGFuZ3VhZ2UgY2xhc3MgZm9yIHN5bnRheCBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suY2xhc3NMaXN0LmFkZChgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgc3ludGF4IGhpZ2hsaWdodGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suaW5uZXJIVE1MID0gdGhpcy5oaWdobGlnaHRDb2RlKGNvZGVDb250ZW50LCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyBzeW50YXggaGlnaGxpZ2h0aW5nOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb3JpZ2luYWwgY29udGVudCBpZiBoaWdobGlnaHRpbmcgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGF1dG8tZGV0ZWN0aW9uIGlmIG5vIHNwZWNpZmljIGxhbmd1YWdlIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5pbm5lckhUTUwgPSB0aGlzLmhpZ2hsaWdodENvZGUoY29kZUNvbnRlbnQsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGx5aW5nIGF1dG8gc3ludGF4IGhpZ2hsaWdodGluZzonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9yaWdpbmFsIGNvbnRlbnQgaWYgaGlnaGxpZ2h0aW5nIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIHRvIHRoZSBjb2RlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9ucyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBjb2RlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5VG9DbGlwYm9hcmQoY29kZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIGJ1dHRvbiB3aXRoIGljb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBjb2RlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZVRvQ2VsbChjb2RlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRUb0J1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBhY3Rpb25zIHRvIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlSGVhZGVyLmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluc2VydCB0aGUgaGVhZGVyIGJlZm9yZSB0aGUgY29kZSBibG9ja1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jay5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNvZGVIZWFkZXIsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgdGhlIGJvdCBtZXNzYWdlIChDb3B5LCBBZGQgdG8gQ2VsbClcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBZGRpbmcgYWN0aW9uIGJ1dHRvbnMgdG8gc3RyZWFtZWQgYm90IG1lc3NhZ2UnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb25zJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgLy8gRW5zdXJlIGRpc3BsYXkgaXMgc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxyZWN0IHg9XCI5XCIgeT1cIjlcIiB3aWR0aD1cIjEzXCIgaGVpZ2h0PVwiMTNcIiByeD1cIjJcIiByeT1cIjJcIj48L3JlY3Q+PHBhdGggZD1cIk01IDE1SDRhMiAyIDAgMCAxLTItMlY0YTIgMiAwIDAgMSAyLTJoOWEyIDIgMCAwIDEgMiAydjFcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkKGNvbXBsZXRlUmVzcG9uc2UpOyAvLyBDb3B5IHRoZSBvcmlnaW5hbCBtYXJrZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRvIENlbGwgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlwiPjwvcGF0aD48cmVjdCB4PVwiOFwiIHk9XCIyXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMVwiIHJ5PVwiMVwiPjwvcmVjdD48cGF0aCBkPVwiTTEyIDExdjZcIj48L3BhdGg+PHBhdGggZD1cIk05IDE0aDZcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBtZXNzYWdlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZVRvQ2VsbChjb21wbGV0ZVJlc3BvbnNlKTsgLy8gQWRkIHRoZSBvcmlnaW5hbCBtYXJrZG93blxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoYWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbnMgYWRkZWQgdG8gYm90IG1lc3NhZ2U6JywgYWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gY29tcGxldGVSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNhdmUgbWFya2Rvd24gdG8gY2hhdCBoaXN0b3J5XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0OiBjb21wbGV0ZVJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogJ2JvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNNYXJrZG93bjogdHJ1ZSAvLyBJdCdzIG1hcmtkb3duXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgICAgIH0sIFxuICAgICAgICAgICAgLy8gT24gZXJyb3JcbiAgICAgICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImVycm9yLW1lc3NhZ2VcIj5FcnJvcjogJHtlcnJvci5tZXNzYWdlfTwvZGl2PmA7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignQVBJIEVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2VuZGluZyBhbiBhdXRvbWF0aWMgbWVzc2FnZSAobGlrZSBjb25maXJtZWQvcmVqZWN0ZWQpIGZyb20gdGhlIFVJXG4gICAgICovXG4gICAgaGFuZGxlU2VuZEF1dG9NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnRyaW0oKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gU2tpcCBhZGRpbmcgdXNlciBtZXNzYWdlIC0gdGhlIGNhbGxpbmcgZnVuY3Rpb24gd2lsbCBoYW5kbGUgdGhpc1xuICAgICAgICAvLyBQcmV2ZW50IGR1cGxpY2F0aW9uIG9mIG1lc3NhZ2VzIHdoZW4gY2FsbGVkIGZyb20gY29uZmlybS9yZWplY3QgYnV0dG9uc1xuICAgICAgICAvLyBBZGQgYSBjb25maXJtYXRpb24vcmVqZWN0aW9uIHN0YXR1cyBpbmRpY2F0b3IgbGluZSBvbmx5IGlmIG5vdCBhbHJlYWR5IGFkZGVkXG4gICAgICAgIC8vIGJ5IHRoZSBjYWxsaW5nIGZ1bmN0aW9uIChjaGVja2luZyBpZiB0aGlzIGlzIGEgZGlyZWN0IGNhbGwpXG4gICAgICAgIGNvbnN0IHN0YXR1c0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgIC8vIFNldCB0aGUgYXBwcm9wcmlhdGUgaWNvbiBhbmQgdGV4dCBiYXNlZCBvbiB0aGUgbWVzc2FnZVxuICAgICAgICBpZiAobWVzc2FnZS50b0xvd2VyQ2FzZSgpID09PSAnY29uZmlybWVkJykge1xuICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInN0YXR1cy1pY29uIGNvbmZpcm0taWNvblwiPuKchTwvc3Bhbj48c3BhbiBjbGFzcz1cInN0YXR1cy1saW5lXCI+PC9zcGFuPjxzcGFuIGNsYXNzPVwic3RhdHVzLXRleHRcIj5Vc2VyIGNvbmZpcm1lZDwvc3Bhbj48c3BhbiBjbGFzcz1cInN0YXR1cy1saW5lXCI+PC9zcGFuPmA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobWVzc2FnZS50b0xvd2VyQ2FzZSgpID09PSAncmVqZWN0ZWQnKSB7XG4gICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuaW5uZXJIVE1MID0gYDxzcGFuIGNsYXNzPVwic3RhdHVzLWljb24gcmVqZWN0LWljb25cIj7inYw8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInN0YXR1cy10ZXh0XCI+VXNlciByZWplY3RlZDwvc3Bhbj48c3BhbiBjbGFzcz1cInN0YXR1cy1saW5lXCI+PC9zcGFuPmA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYXJ5IG1lc3NhZ2UgY29udGFpbmVyIGZvciB0aGUgYm90J3Mgc3RyZWFtaW5nIHJlc3BvbnNlXG4gICAgICAgIGNvbnN0IGJvdE1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYm90TWVzc2FnZURpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3QtbWVzc2FnZSc7XG4gICAgICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLnRleHRDb250ZW50ID0gXCJNRFwiO1xuICAgICAgICBtYXJrZG93bkluZGljYXRvci5jbGFzc05hbWUgPSAnbWFya2Rvd24taW5kaWNhdG9yJztcbiAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChtYXJrZG93bkluZGljYXRvcik7XG4gICAgICAgIC8vIENyZWF0ZSBzZXBhcmF0ZSBkaXZzIGZvciBzdHJlYW1pbmcgdGV4dCBhbmQgZmluYWwgbWFya2Rvd25cbiAgICAgICAgY29uc3Qgc3RyZWFtaW5nRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHN0cmVhbWluZ0Rpdi5jbGFzc05hbWUgPSAnc3RyZWFtaW5nLWNvbnRlbnQnO1xuICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUud2hpdGVTcGFjZSA9ICdwcmUtd3JhcCc7XG4gICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5mb250RmFtaWx5ID0gJ21vbm9zcGFjZSc7XG4gICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5mb250U2l6ZSA9ICcwLjllbSc7XG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoc3RyZWFtaW5nRGl2KTtcbiAgICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoY29udGVudERpdik7XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChib3RNZXNzYWdlRGl2KTtcbiAgICAgICAgLy8gVmFyaWFibGUgdG8gY29sbGVjdCB0aGUgY29tcGxldGUgcmVzcG9uc2VcbiAgICAgICAgbGV0IGNvbXBsZXRlUmVzcG9uc2UgPSAnJztcbiAgICAgICAgLy8gR2V0IGNlbGwgY29udGV4dCBpZiBhdmFpbGFibGVcbiAgICAgICAgY29uc3QgY2VsbENvbnRleHQgPSBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIgP1xuICAgICAgICAgICAgZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyLmdldEN1cnJlbnRDZWxsQ29udGV4dCgpIDogbnVsbDtcbiAgICAgICAgLy8gU3RyZWFtIHJlc3BvbnNlIGZyb20gQVBJXG4gICAgICAgIHRoaXMuYXBpQ2xpZW50LnN0cmVhbUNoYXQobWVzc2FnZSwgLy8gVGhpcyB3aWxsIGJlICdjb25maXJtZWQnIG9yICdyZWplY3RlZCdcbiAgICAgICAgeyBjZWxsQ29udGV4dCB9LCBcbiAgICAgICAgLy8gT24gZWFjaCBjaHVuayByZWNlaXZlZFxuICAgICAgICAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UgKz0gY2h1bms7XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYudGV4dENvbnRlbnQgPSBjb21wbGV0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH0sIFxuICAgICAgICAvLyBPbiBjb21wbGV0ZVxuICAgICAgICAoKSA9PiB7XG4gICAgICAgICAgICAvLyBIaWRlIHN0cmVhbWluZyBkaXYsIHNob3cgZmluYWwgY29udGVudCBkaXZcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjb21wbGV0ZSByZXNwb25zZSBpcyBhbiBpbWFnZSBVUkxcbiAgICAgICAgICAgIGNvbnN0IGlzSW1hZ2VVcmwgPSBjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKS5zdGFydHNXaXRoKCcvaW1hZ2VzLycpICYmXG4gICAgICAgICAgICAgICAgKGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcucG5nJykgfHxcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVSZXNwb25zZS50cmltKCkuZW5kc1dpdGgoJy5qcGcnKSB8fFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKS5lbmRzV2l0aCgnLmpwZWcnKSB8fFxuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKS5lbmRzV2l0aCgnLmdpZicpKTtcbiAgICAgICAgICAgIGlmIChpc0ltYWdlVXJsKSB7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBpbWFnZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWNvbnRhaW5lcic7XG4gICAgICAgICAgICAgICAgaW1hZ2VDb250YWluZXIuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgICAgICAgICAgICAgIC8vIFJlbmRlciBhcyBhbiBpbWFnZSB0YWdcbiAgICAgICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmdWxsSW1hZ2VVcmwgPSBgaHR0cDovLzEyNy4wLjAuMTo4MDAwJHtjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKX1gOyAvLyBDb25zdHJ1Y3QgZnVsbCBVUkxcbiAgICAgICAgICAgICAgICBpbWcuc3JjID0gZnVsbEltYWdlVXJsO1xuICAgICAgICAgICAgICAgIGltZy5hbHQgPSAnSW1hZ2UgZnJvbSBib3QnO1xuICAgICAgICAgICAgICAgIGltZy5zdHlsZS5tYXhXaWR0aCA9ICcxMDAlJztcbiAgICAgICAgICAgICAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIGZvciB0aGUgaW1hZ2VcbiAgICAgICAgICAgICAgICBjb25zdCBpbWdBY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb25zJztcbiAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmJvdHRvbSA9ICcxMHB4JztcbiAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnJpZ2h0ID0gJzEwcHgnO1xuICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmdhcCA9ICc4cHgnO1xuICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJ3JnYmEoMjU1LCAyNTUsIDI1NSwgMC42KSc7XG4gICAgICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcbiAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcbiAgICAgICAgICAgICAgICAvLyBDb3B5IGltYWdlIGJ1dHRvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvcHlJbWdCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICBjb3B5SW1nQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgIGNvcHlJbWdCdG4uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cmVjdCB4PVwiOVwiIHk9XCI5XCIgd2lkdGg9XCIxM1wiIGhlaWdodD1cIjEzXCIgcng9XCIyXCIgcnk9XCIyXCI+PC9yZWN0PjxwYXRoIGQ9XCJNNSAxNUg0YTIgMiAwIDAgMS0yLTJWNGEyIDIgMCAwIDEgMi0yaDlhMiAyIDAgMCAxIDIgMnYxXCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgY29weUltZ0J0bi50aXRsZSA9ICdDb3B5IGltYWdlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgY29weUltZ0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5SW1hZ2VUb0NsaXBib2FyZChmdWxsSW1hZ2VVcmwpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUltZ0J0bik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIGZpbGUgcGF0aCBidXR0b25cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRQYXRoQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgYWRkUGF0aEJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICBhZGRQYXRoQnRuLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlwiPjwvcGF0aD48cmVjdCB4PVwiOFwiIHk9XCIyXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMVwiIHJ5PVwiMVwiPjwvcmVjdD48cGF0aCBkPVwiTTEyIDExdjZcIj48L3BhdGg+PHBhdGggZD1cIk05IDE0aDZcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICBhZGRQYXRoQnRuLnRpdGxlID0gJ0FkZCBpbWFnZSBwYXRoIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICAgICAgYWRkUGF0aEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlVG9DZWxsKGZ1bGxJbWFnZVVybCk7IC8vIFVzZSB0aGUgZnVsbCBpbWFnZSBVUkxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbWdBY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFBhdGhCdG4pO1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYnV0dG9ucyB0byB0aGUgaW1hZ2UgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nQWN0aW9uc0Rpdik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBpbWFnZSBjb250YWluZXIgdG8gdGhlIGNvbnRlbnQgZGl2XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5hcHBlbmRDaGlsZChpbWFnZUNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgLy8gU2F2ZSBpbWFnZSBVUkwgdG8gaGlzdG9yeSAoYXMgdGV4dClcbiAgICAgICAgICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgICAgICBjaGF0Lm1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29tcGxldGVSZXNwb25zZS50cmltKCksIC8vIFN0b3JlIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbmRlcjogJ2JvdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc01hcmtkb3duOiBmYWxzZSAvLyBUcmVhdCBpdCBhcyBub24tbWFya2Rvd24gZm9yIGhpc3RvcnlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIHJlbmRlciBtYXJrZG93blxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKShjb21wbGV0ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBpbnRlcnJ1cHQgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ludGVycnVwdCA9IGNvbXBsZXRlUmVzcG9uc2Uuc3RhcnRzV2l0aCgnKipbSU5URVJSVVBUXSoqJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludGVycnVwdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNvbmZpcm0vcmVqZWN0IGJ1dHRvbnMgKHNhbWUgYXMgaW4gYWRkTWVzc2FnZSBtZXRob2QpXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYnV0dG9ucyBjb250YWluZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ1dHRvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW50ZXJydXB0LWJ1dHRvbnMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uc0NvbnRhaW5lci5zdHlsZS5tYXJnaW5Ub3AgPSAnMTJweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLnN0eWxlLmdhcCA9ICc4cHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGNvbmZpcm0gYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25maXJtQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbmZpcm0tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24udGV4dENvbnRlbnQgPSAnQ29uZmlybSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLnBhZGRpbmcgPSAnNnB4IDEycHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5iYWNrZ3JvdW5kID0gJyM0Q0FGNTAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGlzYWJsZSBidXR0b25zIGFmdGVyIGNsaWNrXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybUJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLnN0eWxlLm9wYWNpdHkgPSAnMC41JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBcImNvbmZpcm1lZFwiIG1lc3NhZ2UgYXMgdXNlciBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoJ2NvbmZpcm1lZCcsICd1c2VyJywgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzdGF0dXMgaW5kaWNhdG9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdHVzSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXN0YXR1cy1pbmRpY2F0b3InO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1c0luZGljYXRvci5pbm5lckhUTUwgPSBgPHNwYW4gY2xhc3M9XCJzdGF0dXMtaWNvbiBjb25maXJtLWljb25cIj7inIU8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj48c3BhbiBjbGFzcz1cInN0YXR1cy10ZXh0XCI+VXNlciBjb25maXJtZWQ8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgYXV0byBtZXNzYWdlIHRvIEFQSSB3aXRob3V0IGFkZGluZyBhIG5ldyB1c2VyIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRBdXRvTWVzc2FnZSgnY29uZmlybWVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSByZWplY3QgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByZWplY3RCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1yZWplY3QtYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi50ZXh0Q29udGVudCA9ICdSZWplY3QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLnBhZGRpbmcgPSAnNnB4IDEycHgnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLmJhY2tncm91bmQgPSAnI0Y0NDMzNic7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uc3R5bGUuY29sb3IgPSAnd2hpdGUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0QnV0dG9uLnN0eWxlLmJvcmRlciA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uc3R5bGUuZm9udFdlaWdodCA9ICdib2xkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEaXNhYmxlIGJ1dHRvbnMgYWZ0ZXIgY2xpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3RCdXR0b24uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1CdXR0b24uc3R5bGUub3BhY2l0eSA9ICcwLjUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIFwicmVqZWN0ZWRcIiBtZXNzYWdlIGFzIHVzZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2UoJ3JlamVjdGVkJywgJ3VzZXInLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHN0YXR1cyBpbmRpY2F0b3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0dXNJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXNJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc3RhdHVzLWluZGljYXRvcic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzSW5kaWNhdG9yLmlubmVySFRNTCA9IGA8c3BhbiBjbGFzcz1cInN0YXR1cy1pY29uIHJlamVjdC1pY29uXCI+4p2MPC9zcGFuPjxzcGFuIGNsYXNzPVwic3RhdHVzLWxpbmVcIj48L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtdGV4dFwiPlVzZXIgcmVqZWN0ZWQ8L3NwYW4+PHNwYW4gY2xhc3M9XCJzdGF0dXMtbGluZVwiPjwvc3Bhbj5gO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChzdGF0dXNJbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgYXV0byBtZXNzYWdlIHRvIEFQSSB3aXRob3V0IGFkZGluZyBhIG5ldyB1c2VyIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVNlbmRBdXRvTWVzc2FnZSgncmVqZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJ1dHRvbnMgdG8gY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBidXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGNvbmZpcm1CdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChyZWplY3RCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGNvbnRhaW5lciBiZWxvdyB0aGUgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudERpdi5hcHBlbmRDaGlsZChidXR0b25zQ29udGFpbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBFbmhhbmNlIGNvZGUgYmxvY2tzIChleGlzdGluZyBjb2RlKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgICAgICAgICBjb2RlQmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHN0YW5kYXJkIEp1cHl0ZXJMYWIgY2xhc3NlcyBmb3IgY29uc2lzdGVuY3lcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkVGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgKF9hID0gYmxvY2sucGFyZW50RWxlbWVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkSFRNTENvbW1vbicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IGNvZGUgY29udGVudCB0byBkZXRlY3QgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVDb250ZW50ID0gYmxvY2sudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY29kZSBibG9jayBoZWFkZXIgZm9yIGJ1dHRvbnNcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVIZWFkZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1oZWFkZXInO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGxhbmd1YWdlIGluZGljYXRvciBpZiBkZXRlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ3VhZ2UgPSB0aGlzLmRldGVjdExhbmd1YWdlKGNvZGVDb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmdJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ0luZGljYXRvci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWxhbmd1YWdlJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYW5nSW5kaWNhdG9yLnRleHRDb250ZW50ID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZUhlYWRlci5hcHBlbmRDaGlsZChsYW5nSW5kaWNhdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbGFuZ3VhZ2UgY2xhc3MgZm9yIHN5bnRheCBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5jbGFzc0xpc3QuYWRkKGBsYW5ndWFnZS0ke2xhbmd1YWdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFwcGx5IHN5bnRheCBoaWdobGlnaHRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5pbm5lckhUTUwgPSB0aGlzLmhpZ2hsaWdodENvZGUoY29kZUNvbnRlbnQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGx5aW5nIHN5bnRheCBoaWdobGlnaHRpbmc6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9yaWdpbmFsIGNvbnRlbnQgaWYgaGlnaGxpZ2h0aW5nIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVHJ5IGF1dG8tZGV0ZWN0aW9uIGlmIG5vIHNwZWNpZmljIGxhbmd1YWdlIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2suaW5uZXJIVE1MID0gdGhpcy5oaWdobGlnaHRDb2RlKGNvZGVDb250ZW50LCAnJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBseWluZyBhdXRvIHN5bnRheCBoaWdobGlnaHRpbmc6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIG9yaWdpbmFsIGNvbnRlbnQgaWYgaGlnaGxpZ2h0aW5nIGZhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFjdGlvbiBidXR0b25zIHRvIHRoZSBjb2RlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbnMnO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ29weSBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi50aXRsZSA9ICdDb3B5IGNvZGUgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlUb0NsaXBib2FyZChjb2RlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkVG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgY29kZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2VUb0NlbGwoY29kZUNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgYWN0aW9ucyB0byB0aGUgaGVhZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSGVhZGVyLmFwcGVuZENoaWxkKGFjdGlvbnNEaXYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBoZWFkZXIgYmVmb3JlIHRoZSBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrLnBhcmVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKGNvZGVIZWFkZXIsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gY29tcGxldGVSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciBtYXJrZG93bjonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNhdmUgbWFya2Rvd24gdG8gY2hhdCBoaXN0b3J5XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhdC5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRleHQ6IGNvbXBsZXRlUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBzZW5kZXI6ICdib3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNNYXJrZG93bjogdHJ1ZSAvLyBJdCdzIG1hcmtkb3duXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICB9LCBcbiAgICAgICAgLy8gT24gZXJyb3JcbiAgICAgICAgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIGNvbnRlbnREaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICBjb250ZW50RGl2LmlubmVySFRNTCA9IGA8ZGl2IGNsYXNzPVwiZXJyb3ItbWVzc2FnZVwiPkVycm9yOiAke2Vycm9yLm1lc3NhZ2V9PC9kaXY+YDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgY2hhdCBpbnRlcmZhY2VcbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKHRleHQsIHNlbmRlciwgaXNNYXJrZG93biA9IGZhbHNlLCBzYXZlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIG1lc3NhZ2U6JywgeyBzZW5kZXIsIGlzTWFya2Rvd24gfSk7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWVzc2FnZURpdi5jbGFzc05hbWUgPSBzZW5kZXIgPT09ICd1c2VyJyA/ICdqcC1sbG0tZXh0LXVzZXItbWVzc2FnZScgOiAnanAtbGxtLWV4dC1ib3QtbWVzc2FnZSc7XG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIGFuIGltYWdlIFVSTCBmcm9tIG91ciBiYWNrZW5kXG4gICAgICAgIGNvbnN0IGlzSW1hZ2VVcmwgPSBzZW5kZXIgPT09ICdib3QnICYmIHRleHQudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJykgJiZcbiAgICAgICAgICAgICh0ZXh0LnRyaW0oKS5lbmRzV2l0aCgnLnBuZycpIHx8XG4gICAgICAgICAgICAgICAgdGV4dC50cmltKCkuZW5kc1dpdGgoJy5qcGcnKSB8fFxuICAgICAgICAgICAgICAgIHRleHQudHJpbSgpLmVuZHNXaXRoKCcuanBlZycpIHx8XG4gICAgICAgICAgICAgICAgdGV4dC50cmltKCkuZW5kc1dpdGgoJy5naWYnKSk7XG4gICAgICAgIGlmIChpc0ltYWdlVXJsKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSBpbWFnZSB0aGF0IGFsbG93cyBwb3NpdGlvbmluZyB0aGUgYnV0dG9uc1xuICAgICAgICAgICAgY29uc3QgaW1hZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGltYWdlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWNvbnRhaW5lcic7XG4gICAgICAgICAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgICAgICAgICAvLyBSZW5kZXIgYXMgYW4gaW1hZ2UgdGFnXG4gICAgICAgICAgICBjb25zdCBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbWcnKTtcbiAgICAgICAgICAgIC8vIENvbnN0cnVjdCBmdWxsIFVSTCBhc3N1bWluZyBiYWNrZW5kIGlzIGF0IGh0dHA6Ly8xMjcuMC4wLjE6ODAwMFxuICAgICAgICAgICAgLy8gVE9ETzogTWFrZSBiYWNrZW5kIFVSTCBjb25maWd1cmFibGVcbiAgICAgICAgICAgIGNvbnN0IGZ1bGxJbWFnZVVybCA9IGBodHRwOi8vMTI3LjAuMC4xOjgwMDAke3RleHQudHJpbSgpfWA7XG4gICAgICAgICAgICBpbWcuc3JjID0gZnVsbEltYWdlVXJsO1xuICAgICAgICAgICAgaW1nLmFsdCA9ICdJbWFnZSBmcm9tIGJvdCc7XG4gICAgICAgICAgICBpbWcuc3R5bGUubWF4V2lkdGggPSAnMTAwJSc7IC8vIEVuc3VyZSBpbWFnZSBmaXRzIHdpdGhpbiB0aGUgY29udGFpbmVyXG4gICAgICAgICAgICBpbWcuc3R5bGUuaGVpZ2h0ID0gJ2F1dG8nO1xuICAgICAgICAgICAgaW1hZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgdGhlIGltYWdlXG4gICAgICAgICAgICBjb25zdCBpbWdBY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBpbWdBY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbnMnO1xuICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmJvdHRvbSA9ICcxMHB4JztcbiAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUucmlnaHQgPSAnMTBweCc7XG4gICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmdhcCA9ICc4cHgnO1xuICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgyNTUsIDI1NSwgMjU1LCAwLjYpJztcbiAgICAgICAgICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XG4gICAgICAgICAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLnBhZGRpbmcgPSAnNHB4JztcbiAgICAgICAgICAgIC8vIENvcHkgaW1hZ2UgYnV0dG9uXG4gICAgICAgICAgICBjb25zdCBjb3B5SW1nQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBjb3B5SW1nQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgY29weUltZ0J0bi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxyZWN0IHg9XCI5XCIgeT1cIjlcIiB3aWR0aD1cIjEzXCIgaGVpZ2h0PVwiMTNcIiByeD1cIjJcIiByeT1cIjJcIj48L3JlY3Q+PHBhdGggZD1cIk01IDE1SDRhMiAyIDAgMCAxLTItMlY0YTIgMiAwIDAgMSAyLTJoOWEyIDIgMCAwIDEgMiAydjFcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgIGNvcHlJbWdCdG4udGl0bGUgPSAnQ29weSBpbWFnZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICAgICAgY29weUltZ0J0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29weUltYWdlVG9DbGlwYm9hcmQoZnVsbEltYWdlVXJsKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChjb3B5SW1nQnRuKTtcbiAgICAgICAgICAgIC8vIEFkZCBmaWxlIHBhdGggYnV0dG9uXG4gICAgICAgICAgICBjb25zdCBhZGRQYXRoQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICBhZGRQYXRoQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgYWRkUGF0aEJ0bi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICBhZGRQYXRoQnRuLnRpdGxlID0gJ0FkZCBpbWFnZSBwYXRoIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICBhZGRQYXRoQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlVG9DZWxsKGZ1bGxJbWFnZVVybCk7IC8vIFVzZSB0aGUgZnVsbCBpbWFnZSBVUkxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaW1nQWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRQYXRoQnRuKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgYnV0dG9ucyB0byB0aGUgaW1hZ2UgY29udGFpbmVyXG4gICAgICAgICAgICBpbWFnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWdBY3Rpb25zRGl2KTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgaW1hZ2UgY29udGFpbmVyIHRvIHRoZSBtZXNzYWdlIGRpdlxuICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChpbWFnZUNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2VuZGVyID09PSAndXNlcicgJiYgaXNNYXJrZG93bikge1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlOiBVc2VyIG1lc3NhZ2Ugd2l0aCBjb2RlIHJlZmVyZW5jZXNcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuY2xhc3NOYW1lID0gJ3VzZXItY29udGVudC13aXRoLXJlZnMnO1xuICAgICAgICAgICAgLy8gUHJvY2VzcyB0aGUgdGV4dCB0byByZXBsYWNlIGNvZGUgcmVmZXJlbmNlIHBsYWNlaG9sZGVyc1xuICAgICAgICAgICAgbGV0IHByb2Nlc3NlZFRleHQgPSB0ZXh0O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgaGF2ZSBhIGNvZGUgcmVmZXJlbmNlIG1hcCBhdHRhY2hlZCB0byB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgICAgIGlmICgnX2NvZGVSZWZNYXAnIGluIHRoaXMuaW5wdXRGaWVsZCAmJiB0aGlzLmlucHV0RmllbGQuX2NvZGVSZWZNYXAgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb2RlUmVmTWFwID0gdGhpcy5pbnB1dEZpZWxkLl9jb2RlUmVmTWFwO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgY29kZSByZWZlcmVuY2Ugd2lkZ2V0cyB0byByZW5kZXJcbiAgICAgICAgICAgICAgICBpZiAoY29kZVJlZk1hcC5zaXplID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBkb2N1bWVudCBmcmFnbWVudCB0byBhdm9pZCBtdWx0aXBsZSByZWZsb3dzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBTcGxpdCB0aGUgdGV4dCBieSBjb2RlIHJlZmVyZW5jZSBwbGFjZWhvbGRlcnMgYW5kIGNyZWF0ZSB0aGUgd2lkZ2V0c1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWdleCA9IC9cXFtDb2RlUmVmOihbXlxcXV0rKVxcXS9nO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gcmVnZXguZXhlYyhwcm9jZXNzZWRUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgdGV4dCBiZWZvcmUgdGhlIHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0QmVmb3JlID0gcHJvY2Vzc2VkVGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaC5pbmRleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGV4dEJlZm9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dEJlZm9yZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IHRoZSBwbGFjZWhvbGRlciBhbmQgaXRzIGNvcnJlc3BvbmRpbmcgSFRNTFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXIgPSBtYXRjaFswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZGdldEh0bWwgPSBjb2RlUmVmTWFwLmdldChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAod2lkZ2V0SHRtbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBhIHRlbXBvcmFyeSBjb250YWluZXIgZm9yIHRoZSBIVE1MXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGVtcENvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBDb250YWluZXIuaW5uZXJIVE1MID0gd2lkZ2V0SHRtbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIGNvZGUgcmVmZXJlbmNlIHdpZGdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICh0ZW1wQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQodGVtcENvbnRhaW5lci5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiB3aWRnZXQgSFRNTCBub3QgZm91bmQsIGp1c3QgYWRkIHRoZSBwbGFjZWhvbGRlciB0ZXh0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGxhY2Vob2xkZXJOb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHBsYWNlaG9sZGVyTm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBtYXRjaC5pbmRleCArIHBsYWNlaG9sZGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYW55IHJlbWFpbmluZyB0ZXh0IGFmdGVyIHRoZSBsYXN0IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgICAgICAgIGlmIChsYXN0SW5kZXggPCBwcm9jZXNzZWRUZXh0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dEFmdGVyID0gcHJvY2Vzc2VkVGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dEFmdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIHByb2Nlc3NlZCBjb250ZW50IHRvIHRoZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnREaXYuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY2xpY2sgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjb2RlIHJlZmVyZW5jZSB3aWRnZXRzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRvZ2dsZUJ1dHRvbnMgPSBjb250ZW50RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcC1sbG0tZXh0LWNvZGUtcmVmLXRvZ2dsZScpO1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVCdXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aWRnZXQgPSB0YXJnZXQuY2xvc2VzdCgnLmpwLWxsbS1leHQtY29kZS1yZWYtd2lkZ2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHdpZGdldCA9PT0gbnVsbCB8fCB3aWRnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpZGdldC5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1jb2RlLXJlZi1jb250ZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gY29udGVudC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQuc3R5bGUuZGlzcGxheSA9IGlzVmlzaWJsZSA/ICdub25lJyA6ICdibG9jayc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9IGlzVmlzaWJsZSA/ICfir4gnIDogJ+Kvhic7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBKdXN0IHBsYWluIHRleHQgd2l0aG91dCBjb2RlIHJlZmVyZW5jZXNcbiAgICAgICAgICAgICAgICAgICAgY29udGVudERpdi50ZXh0Q29udGVudCA9IHByb2Nlc3NlZFRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTm8gY29kZSByZWZlcmVuY2UgbWFwLCBqdXN0IGFkZCB0aGUgdGV4dFxuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSBwcm9jZXNzZWRUZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc01hcmtkb3duIHx8IHNlbmRlciA9PT0gJ2JvdCcpIHtcbiAgICAgICAgICAgIC8vIFJlbmRlciBhcyBtYXJrZG93biAoZXhpc3RpbmcgbG9naWMpXG4gICAgICAgICAgICBjb25zdCBtYXJrZG93bkluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IudGV4dENvbnRlbnQgPSBcIk1EXCI7XG4gICAgICAgICAgICBtYXJrZG93bkluZGljYXRvci5jbGFzc05hbWUgPSAnbWFya2Rvd24taW5kaWNhdG9yJztcbiAgICAgICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgY29udGVudERpdi5jbGFzc05hbWUgPSAnbWFya2Rvd24tY29udGVudCc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIHRleHQgdG8gaGFuZGxlIGNvbW1vbiBtYXJrZG93biBpc3N1ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9jZXNzZWRUZXh0ID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikodGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gUGFyc2UgbWFya2Rvd24gdG8gSFRNTFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gU2FuaXRpemUgSFRNTCB0byBwcmV2ZW50IFhTU1xuICAgICAgICAgICAgICAgIGNvbnN0IHNhbml0aXplZEh0bWwgPSBkb21wdXJpZnlfMS5kZWZhdWx0LnNhbml0aXplKHJhd0h0bWwpO1xuICAgICAgICAgICAgICAgIC8vIFNldCBjb250ZW50XG4gICAgICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgICAgIC8vIEVuaGFuY2UgY29kZSBibG9ja3Mgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24gYW5kIGFjdGlvbiBidXR0b25zXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgICAgICBjb2RlQmxvY2tzLmZvckVhY2goYmxvY2sgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBzdGFuZGFyZCBKdXB5dGVyTGFiIGNsYXNzZXMgZm9yIGNvbnNpc3RlbmN5XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLmNsYXNzTGlzdC5hZGQoJ2pwLVJlbmRlcmVkVGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBibG9jay5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LmFkZCgnanAtUmVuZGVyZWRIVE1MQ29tbW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBjb2RlIGNvbnRlbnQgdG8gZGV0ZWN0IGxhbmd1YWdlXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVDb250ZW50ID0gYmxvY2sudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBjb2RlIGJsb2NrIGhlYWRlciBmb3IgYnV0dG9uc1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlSGVhZGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvZGVIZWFkZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1oZWFkZXInO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgbGFuZ3VhZ2UgaW5kaWNhdG9yIGlmIGRldGVjdGVkXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlID0gdGhpcy5kZXRlY3RMYW5ndWFnZShjb2RlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGFuZ0luZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmdJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1sYW5ndWFnZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYW5nSW5kaWNhdG9yLnRleHRDb250ZW50ID0gbGFuZ3VhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2RlSGVhZGVyLmFwcGVuZENoaWxkKGxhbmdJbmRpY2F0b3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGxhbmd1YWdlIGNsYXNzIGZvciBzeW50YXggaGlnaGxpZ2h0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5jbGFzc0xpc3QuYWRkKGBsYW5ndWFnZS0ke2xhbmd1YWdlfWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXBwbHkgc3ludGF4IGhpZ2hsaWdodGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5pbm5lckhUTUwgPSB0aGlzLmhpZ2hsaWdodENvZGUoY29kZUNvbnRlbnQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGx5aW5nIHN5bnRheCBoaWdobGlnaHRpbmc6JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEtlZXAgb3JpZ2luYWwgY29udGVudCBpZiBoaWdobGlnaHRpbmcgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSBhdXRvLWRldGVjdGlvbiBpZiBubyBzcGVjaWZpYyBsYW5ndWFnZSBkZXRlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jay5pbm5lckhUTUwgPSB0aGlzLmhpZ2hsaWdodENvZGUoY29kZUNvbnRlbnQsICcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGx5aW5nIGF1dG8gc3ludGF4IGhpZ2hsaWdodGluZzonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gS2VlcCBvcmlnaW5hbCBjb250ZW50IGlmIGhpZ2hsaWdodGluZyBmYWlsc1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyB0byB0aGUgY29kZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtYWN0aW9ucyc7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvcHkgYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3B5QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxyZWN0IHg9XCI5XCIgeT1cIjlcIiB3aWR0aD1cIjEzXCIgaGVpZ2h0PVwiMTNcIiByeD1cIjJcIiByeT1cIjJcIj48L3JlY3Q+PHBhdGggZD1cIk01IDE1SDRhMiAyIDAgMCAxLTItMlY0YTIgMiAwIDAgMSAyLTJoOWEyIDIgMCAwIDEgMiAydjFcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi50aXRsZSA9ICdDb3B5IGNvZGUgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNvcHlUb0NsaXBib2FyZChjb2RlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdG8gYnV0dG9uIHdpdGggaWNvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICAgICAgICAgICAgICBhZGRUb0J1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNFwiIGhlaWdodD1cIjE0XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBjb2RlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZVRvQ2VsbChjb2RlQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBhY3Rpb25zIHRvIHRoZSBoZWFkZXJcbiAgICAgICAgICAgICAgICAgICAgY29kZUhlYWRlci5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBoZWFkZXIgYmVmb3JlIHRoZSBjb2RlIGJsb2NrXG4gICAgICAgICAgICAgICAgICAgIGlmIChibG9jay5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBibG9jay5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZShjb2RlSGVhZGVyLCBibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byByZW5kZXIgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgYm90IG1lc3NhZ2VzIChvbmx5IGZvciB0aGUgd2hvbGUgbWVzc2FnZSwgbm90IGNvZGUgYmxvY2tzKVxuICAgICAgICAgICAgaWYgKHNlbmRlciA9PT0gJ2JvdCcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFjdGlvbiBidXR0b25zIHRvIGJvdCBtZXNzYWdlJyk7IC8vIERlYnVnIGxvZ1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbnNEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9ucyc7XG4gICAgICAgICAgICAgICAgLy8gQ29weSBidXR0b24gd2l0aCBpY29uXG4gICAgICAgICAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgIGNvcHlCdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgIGNvcHlCdXR0b24udGl0bGUgPSAnQ29weSBtZXNzYWdlIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkKHRleHQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFjdGlvbnNEaXYuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIGJ1dHRvbiB3aXRoIGljb25cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRUb0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICAgICAgICAgIGFkZFRvQnV0dG9uLnRpdGxlID0gJ0FkZCBtZXNzYWdlIHRvIGN1cnJlbnQgY2VsbCc7XG4gICAgICAgICAgICAgICAgYWRkVG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZVRvQ2VsbCh0ZXh0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICAgICAgICAgICAgICAvLyBBZGQgYnV0dG9ucyB0byBtZXNzYWdlXG4gICAgICAgICAgICAgICAgbWVzc2FnZURpdi5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQWN0aW9uIGJ1dHRvbnMgYWRkZWQgdG8gbWVzc2FnZTonLCBhY3Rpb25zRGl2KTsgLy8gRGVidWcgbG9nXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlRGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQobWVzc2FnZURpdik7XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxUb3AgPSB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAvLyBTYXZlIHRvIGNoYXQgaGlzdG9yeVxuICAgICAgICBpZiAoc2F2ZVRvSGlzdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IHRoaXMuY3VycmVudENoYXRJZCk7XG4gICAgICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgICAgIGNoYXQubWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgICAgICAgIHNlbmRlcixcbiAgICAgICAgICAgICAgICAgICAgaXNNYXJrZG93bjogaXNNYXJrZG93biB8fCBzZW5kZXIgPT09ICdib3QnXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIG1lc3NhZ2UgY29udGVudCB0byBjbGlwYm9hcmRcbiAgICAgKi9cbiAgICBjb3B5TWVzc2FnZVRvQ2xpcGJvYXJkKHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGVUZXh0KHRleHQpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGNvcGllZCB0byBjbGlwYm9hcmQnKTtcbiAgICAgICAgICAgICAgICAvLyBGaW5kIHRoZSBidXR0b24gZWxlbWVudCB0aGF0IHdhcyBjbGlja2VkXG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9ucyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbicpO1xuICAgICAgICAgICAgICAgIGxldCBjbGlja2VkQnV0dG9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gYnV0dG9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbi50aXRsZSA9PT0gJ0NvcHkgbWVzc2FnZSB0byBjbGlwYm9hcmQnICYmIGJ1dHRvbiA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2tlZEJ1dHRvbiA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFNob3cgdmlzdWFsIGZlZWRiYWNrIGlmIHdlIGZvdW5kIHRoZSBidXR0b25cbiAgICAgICAgICAgICAgICBpZiAoY2xpY2tlZEJ1dHRvbikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhUTUwgPSBjbGlja2VkQnV0dG9uLmlubmVySFRNTDtcbiAgICAgICAgICAgICAgICAgICAgY2xpY2tlZEJ1dHRvbi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMjAgNkw5IDE3bC01LTVcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGlja2VkQnV0dG9uLmlubmVySFRNTCA9IG9yaWdpbmFsSFRNTDtcbiAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSB0ZXh0OiAnLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjb3B5aW5nIHRvIGNsaXBib2FyZDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBtZXNzYWdlIGNvbnRlbnQgdG8gdGhlIGN1cnJlbnQgY2VsbFxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2VUb0NlbGwodGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICBpZiAoIWNlbGwgfHwgIWNlbGwuZWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgdmlldyA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgICAgICBpZiAoIXZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdmlldy5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvcyA9IHNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgICAgICAvLyBJbnNlcnQgbmV3bGluZSBhbmQgbWVzc2FnZSBjb250ZW50IGF0IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgdHJhbnNhY3Rpb24gPSBzdGF0ZS51cGRhdGUoe1xuICAgICAgICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgZnJvbTogY3Vyc29yUG9zLFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnQ6IGBcXG4ke3RleHR9YFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uOiB7IGFuY2hvcjogY3Vyc29yUG9zICsgdGV4dC5sZW5ndGggKyAxIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbWVzc2FnZSB0byBjZWxsOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgdGV4dCBmcm9tIHRoZSBhY3RpdmUgbm90ZWJvb2sgY2VsbC5cbiAgICAgKiAoSGVscGVyIGZvciBQb3B1cE1lbnVNYW5hZ2VyIGNhbGxiYWNrKVxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkVGV4dCgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICBpZiAoY2VsbCA9PT0gbnVsbCB8fCBjZWxsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7IC8vIElFZGl0b3JcbiAgICAgICAgICAgIC8vIEFjY2VzcyBDb2RlTWlycm9yIGVkaXRvciBpbnN0YW5jZSBpZiBwb3NzaWJsZVxuICAgICAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgaWYgKGNtRWRpdG9yICYmIGNtRWRpdG9yLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjbUVkaXRvci5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjsgLy8gR2V0IHRoZSBtYWluIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7IC8vIE5vIHRleHQgc2VsZWN0ZWRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlLmRvYy5zbGljZVN0cmluZyhzZWxlY3Rpb24uZnJvbSwgc2VsZWN0aW9uLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgQ29kZU1pcnJvciBzdGF0ZSB0byBnZXQgc2VsZWN0aW9uLlwiKTtcbiAgICAgICAgICAgIC8vIEF2b2lkIHVzaW5nIGdldFJhbmdlIGFzIGl0J3MgY29uZmlybWVkIG5vdCB0byBleGlzdCBvbiBJRWRpdG9yXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEF0dGVtcHQgdG8gZ2V0IHNlbGVjdGlvbiBmcm9tIGRvY3VtZW50IGlmIG5vIG5vdGVib29rIGFjdGl2ZSAoZS5nLiwgdGV4dCBlZGl0b3IpXG4gICAgICAgICAgICBjb25zdCBhY3RpdmVXaWRnZXQgPSAoX2MgPSAoX2IgPSBnbG9iYWxzXzEuZ2xvYmFscy5hcHApID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaGVsbCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgICAgICBpZiAoYWN0aXZlV2lkZ2V0ICYmICdjb250ZW50JyBpbiBhY3RpdmVXaWRnZXQgJiYgYWN0aXZlV2lkZ2V0LmNvbnRlbnQuZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlV2lkZ2V0LmNvbnRlbnQuZWRpdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNtRWRpdG9yID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoY21FZGl0b3IgJiYgY21FZGl0b3Iuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjbUVkaXRvci5zdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24uZW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgQ29kZU1pcnJvciBzdGF0ZSBmb3Igbm9uLW5vdGVib29rIGVkaXRvciBzZWxlY3Rpb24uXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsOyAvLyBBdm9pZCBnZXRSYW5nZVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjb250ZW50IG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIG5vdGVib29rIGNlbGwuXG4gICAgICogKEhlbHBlciBmb3IgUG9wdXBNZW51TWFuYWdlciBjYWxsYmFjaylcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2VsbENvbnRlbnQoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBjb25zdCBhY3RpdmVDZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKGFjdGl2ZUNlbGwgPT09IG51bGwgfHwgYWN0aXZlQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlQ2VsbC5tb2RlbCkge1xuICAgICAgICAgICAgLy8gVHJ5IHVzaW5nIHNoYXJlZE1vZGVsIGZpcnN0IChtb3JlIHJvYnVzdClcbiAgICAgICAgICAgIGlmIChhY3RpdmVDZWxsLm1vZGVsLnNoYXJlZE1vZGVsICYmIHR5cGVvZiBhY3RpdmVDZWxsLm1vZGVsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY3RpdmVDZWxsLm1vZGVsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbGJhY2s6IFRyeSB1c2luZyB0b0pTT04oKS5zb3VyY2VcbiAgICAgICAgICAgIGNvbnN0IGNlbGxKc29uID0gYWN0aXZlQ2VsbC5tb2RlbC50b0pTT04oKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgKGNlbGxKc29uID09PSBudWxsIHx8IGNlbGxKc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsSnNvbi5zb3VyY2UpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsSnNvbi5zb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNlbGxKc29uID09PSBudWxsIHx8IGNlbGxKc29uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjZWxsSnNvbi5zb3VyY2UpKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgc291cmNlIGlzIGFuIGFycmF5IG9mIHN0cmluZ3MsIGpvaW4gdGhlbVxuICAgICAgICAgICAgICAgIHJldHVybiBjZWxsSnNvbi5zb3VyY2Uuam9pbignXFxuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZ2V0IGNlbGwgY29udGVudCB2aWEgbW9kZWwudmFsdWUudGV4dCBvciB0b0pTT04oKS5zb3VyY2VcIik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBGYWxsYmFjayBmb3Igbm9uLW5vdGVib29rIGVkaXRvcnMgaWYgbmVlZGVkXG4gICAgICAgIGNvbnN0IGFjdGl2ZVdpZGdldCA9IChfYyA9IChfYiA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoZWxsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGFjdGl2ZVdpZGdldCAmJiAnY29udGVudCcgaW4gYWN0aXZlV2lkZ2V0ICYmIGFjdGl2ZVdpZGdldC5jb250ZW50Lm1vZGVsKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aXZlV2lkZ2V0LmNvbnRlbnQubW9kZWwudmFsdWUudGV4dDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0ZXh0IHRvIHRoZSBpbnB1dCBmaWVsZCB3aXRoIHByb3BlciBzcGFjaW5nXG4gICAgICovXG4gICAgYXBwZW5kVG9JbnB1dCh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VmFsdWUgPSB0aGlzLmlucHV0RmllbGQudmFsdWU7XG4gICAgICAgICAgICBpZiAoY3VycmVudFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgLy8gYWRkIGEgc3BhY2UgYmV0d2VlbiB0aGUgY3VycmVudCB2YWx1ZSBhbmQgdGhlIG5ldyB0ZXh0XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gYCR7Y3VycmVudFZhbHVlfSR7dGV4dH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvY3VzIHRoZSBpbnB1dCBmaWVsZCBhbmQgbW92ZSBjdXJzb3IgdG8gZW5kXG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuZm9jdXMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zZXRTZWxlY3Rpb25SYW5nZSh0aGlzLmlucHV0RmllbGQudmFsdWUubGVuZ3RoLCB0aGlzLmlucHV0RmllbGQudmFsdWUubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFwcGVuZGluZyB0byBpbnB1dDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU2V0dGluZ3MgbW9kYWwgbWV0aG9kc1xuICAgIGNyZWF0ZVNldHRpbmdzTW9kYWwoKSB7XG4gICAgICAgIGNvbnN0IG1vZGFsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1vZGFsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLW1vZGFsJztcbiAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdub25lJzsgLy8gS2VlcCB0aGlzIGlubGluZSBzdHlsZSBmb3IgdG9nZ2xpbmcgdmlzaWJpbGl0eVxuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtY29udGVudCc7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDInKTtcbiAgICAgICAgdGl0bGUuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtdGl0bGUnO1xuICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9ICdTZXR0aW5ncyc7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGl0bGUpO1xuICAgICAgICBjb25zdCBmb3JtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgICAgICBmb3JtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWZvcm0nO1xuICAgICAgICAvLyBQcm92aWRlciBzZWxlY3Rpb25cbiAgICAgICAgY29uc3QgcHJvdmlkZXJMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHByb3ZpZGVyTGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgICAgICBwcm92aWRlckxhYmVsLnRleHRDb250ZW50ID0gJ0FQSSBQcm92aWRlcjonO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHByb3ZpZGVyTGFiZWwpO1xuICAgICAgICBjb25zdCBwcm92aWRlclNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgICBwcm92aWRlclNlbGVjdC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1zZWxlY3QnO1xuICAgICAgICBwcm92aWRlclNlbGVjdC5pZCA9ICdzZXR0aW5ncy1wcm92aWRlcic7XG4gICAgICAgIFsnT3BlbkFJJywgJ0h1Z2dpbmdGYWNlJywgJ0xvY2FsJ10uZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBvcHQ7XG4gICAgICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBvcHQ7XG4gICAgICAgICAgICBwcm92aWRlclNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChwcm92aWRlclNlbGVjdCk7XG4gICAgICAgIC8vIEFQSSBLZXkgaW5wdXRcbiAgICAgICAgY29uc3QgYXBpS2V5TGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBhcGlLZXlMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgICAgIGFwaUtleUxhYmVsLnRleHRDb250ZW50ID0gJ0FQSSBLZXk6JztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChhcGlLZXlMYWJlbCk7XG4gICAgICAgIGNvbnN0IGFwaUtleUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgYXBpS2V5SW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtaW5wdXQnO1xuICAgICAgICBhcGlLZXlJbnB1dC50eXBlID0gJ3Bhc3N3b3JkJztcbiAgICAgICAgYXBpS2V5SW5wdXQuaWQgPSAnc2V0dGluZ3MtYXBpLWtleSc7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpS2V5SW5wdXQpO1xuICAgICAgICAvLyBBUEkgVVJMIGlucHV0XG4gICAgICAgIGNvbnN0IGFwaVVybExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgYXBpVXJsTGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgICAgICBhcGlVcmxMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgVVJMIChvcHRpb25hbCk6JztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChhcGlVcmxMYWJlbCk7XG4gICAgICAgIGNvbnN0IGFwaVVybElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgYXBpVXJsSW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtaW5wdXQnO1xuICAgICAgICBhcGlVcmxJbnB1dC50eXBlID0gJ3RleHQnO1xuICAgICAgICBhcGlVcmxJbnB1dC5pZCA9ICdzZXR0aW5ncy1hcGktdXJsJztcbiAgICAgICAgZm9ybS5hcHBlbmRDaGlsZChhcGlVcmxJbnB1dCk7XG4gICAgICAgIC8vIFJ1bGVzIGlucHV0XG4gICAgICAgIGNvbnN0IHJ1bGVzTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBydWxlc0xhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICAgICAgcnVsZXNMYWJlbC50ZXh0Q29udGVudCA9ICdDdXN0b20gUnVsZXMgKG9wdGlvbmFsKTonO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHJ1bGVzTGFiZWwpO1xuICAgICAgICBjb25zdCBydWxlc0lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgcnVsZXNJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy10ZXh0YXJlYSc7XG4gICAgICAgIHJ1bGVzSW5wdXQuaWQgPSAnc2V0dGluZ3MtcnVsZXMnO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKHJ1bGVzSW5wdXQpO1xuICAgICAgICAvLyBCdXR0b25zIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBidG5Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYnRuQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWJ1dHRvbnMnO1xuICAgICAgICBjb25zdCBzYXZlQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNhdmVCdG4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtYnV0dG9uIGpwLWxsbS1leHQtc2V0dGluZ3Mtc2F2ZS1idXR0b24nO1xuICAgICAgICBzYXZlQnRuLnRleHRDb250ZW50ID0gJ1NhdmUnO1xuICAgICAgICBzYXZlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBBZGQgdGhpcyBsaW5lXG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1wcm92aWRlcicpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLWFwaS1rZXknKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1hcGktdXJsJykudmFsdWU7XG4gICAgICAgICAgICBjb25zdCBydWxlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1ydWxlcycpLnZhbHVlO1xuICAgICAgICAgICAgLy8gU2F2ZSBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2UgZm9yIHBlcnNpc3RlbmNlXG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHsgcHJvdmlkZXIsIGtleSwgdXJsLCBydWxlcyB9O1xuICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2pwLWxsbS1leHQtc2V0dGluZ3MnLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIHNhdmVkOicsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVNldHRpbmdzTW9kYWwoKTtcbiAgICAgICAgICAgIHRoaXMucG9wU2F2ZVN1Y2Nlc3MoKTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSBBUEkgY2xpZW50IHdpdGggbmV3IHNldHRpbmdzIGlmIG5lZWRlZFxuICAgICAgICAgICAgaWYgKHVybCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IGFwaV9jbGllbnRfMS5BcGlDbGllbnQodXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjYW5jZWxCdG4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtYnV0dG9uIGpwLWxsbS1leHQtc2V0dGluZ3MtY2FuY2VsLWJ1dHRvbic7XG4gICAgICAgIGNhbmNlbEJ0bi50ZXh0Q29udGVudCA9ICdDYW5jZWwnO1xuICAgICAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIEFkZCB0aGlzIGxpbmVcbiAgICAgICAgICAgIHRoaXMuaGlkZVNldHRpbmdzTW9kYWwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChzYXZlQnRuKTtcbiAgICAgICAgYnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbmNlbEJ0bik7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYnRuQ29udGFpbmVyKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICAgICAgbW9kYWwuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gICAgICAgIHJldHVybiBtb2RhbDtcbiAgICB9XG4gICAgc2hvd1NldHRpbmdzTW9kYWwoKSB7XG4gICAgICAgIC8vIExvYWQgc2F2ZWQgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2VcbiAgICAgICAgdGhpcy5sb2FkU2F2ZWRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9XG4gICAgbG9hZFNhdmVkU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnanAtbGxtLWV4dC1zZXR0aW5ncycpO1xuICAgICAgICBpZiAoc2F2ZWRTZXR0aW5ncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IEpTT04ucGFyc2Uoc2F2ZWRTZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgLy8gVXBkYXRlIFVJIHdpdGggc2F2ZWQgc2V0dGluZ3NcbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MucHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLXByb3ZpZGVyJykudmFsdWUgPSBzZXR0aW5ncy5wcm92aWRlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzLmtleSkge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtYXBpLWtleScpLnZhbHVlID0gc2V0dGluZ3Mua2V5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc2V0dGluZ3MudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1hcGktdXJsJykudmFsdWUgPSBzZXR0aW5ncy51cmw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5ydWxlcykge1xuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcnVsZXMnKS52YWx1ZSA9IHNldHRpbmdzLnJ1bGVzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGxvYWRpbmcgc2F2ZWQgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGVTZXR0aW5nc01vZGFsKCkge1xuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICB9XG4gICAgcG9wU2F2ZVN1Y2Nlc3MoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIHRvYXN0IG5vdGlmaWNhdGlvbiBjb250YWluZXJcbiAgICAgICAgY29uc3QgdG9hc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9hc3QuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdG9hc3Qtbm90aWZpY2F0aW9uIGpwLWxsbS1leHQtc2V0dGluZ3Mtc3VjY2Vzcyc7XG4gICAgICAgIHRvYXN0LnRleHRDb250ZW50ID0gJ1NldHRpbmdzIHNhdmVkIHN1Y2Nlc3NmdWxseSc7XG4gICAgICAgIC8vIEFkZCB0byB0aGUgbWFpbiB3aWRnZXQgKG5vdCB0aGUgbW9kYWwgd2hpY2ggaXMgaGlkZGVuKVxuICAgICAgICB0aGlzLm5vZGUuYXBwZW5kQ2hpbGQodG9hc3QpO1xuICAgICAgICAvLyBBbmltYXRlIGluXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdG9hc3QuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICB9LCAxMCk7XG4gICAgICAgIC8vIFJlbW92ZSBhZnRlciBkZWxheVxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRvYXN0LmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgIC8vIFdhaXQgZm9yIGZhZGUgb3V0IGFuaW1hdGlvbiB0byBjb21wbGV0ZSBiZWZvcmUgcmVtb3ZpbmdcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRvYXN0LnJlbW92ZSgpO1xuICAgICAgICAgICAgfSwgMzAwKTtcbiAgICAgICAgfSwgMzAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgY2VsbCBjb250ZW50IGJ5IGluZGV4IGZyb20gdGhlIGN1cnJlbnQgbm90ZWJvb2sgYW5kIGluc2VydHMgaXQgaW50byB0aGUgaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBpbnNlcnRDZWxsQnlJbmRleChpbmRleCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKCFnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIgfHwgIWdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50V2lkZ2V0KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gYWN0aXZlIG5vdGVib29rIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tQYW5lbCA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50V2lkZ2V0O1xuICAgICAgICAgICAgY29uc3QgbW9kZWwgPSBub3RlYm9va1BhbmVsLmNvbnRlbnQubW9kZWw7XG4gICAgICAgICAgICBpZiAoIW1vZGVsIHx8ICFtb2RlbC5jZWxscyB8fCBpbmRleCA+PSBtb2RlbC5jZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBJbnZhbGlkIGNlbGwgaW5kZXg6ICR7aW5kZXh9YCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2VsbCA9IG1vZGVsLmNlbGxzLmdldChpbmRleCk7XG4gICAgICAgICAgICBsZXQgY2VsbENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIC8vIEdldCBjZWxsIGNvbnRlbnQgLSBoYW5kbGUgZGlmZmVyZW50IHdheXMgY29udGVudCBtaWdodCBiZSBzdG9yZWRcbiAgICAgICAgICAgIGlmIChjZWxsLnNoYXJlZE1vZGVsICYmIHR5cGVvZiBjZWxsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNlbGxDb250ZW50ID0gY2VsbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxKc29uID0gY2VsbC50b0pTT04oKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlKSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBjZWxsSnNvbi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoY2VsbEpzb24gPT09IG51bGwgfHwgY2VsbEpzb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGxKc29uLnNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBjZWxsSnNvbi5zb3VyY2Uuam9pbignXFxuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSW5zZXJ0IGNlbGwgcmVmZXJlbmNlIHdpdGggY29udGVudCwgd2l0aG91dCB0eXBlIGluZGljYXRvciBvciBleGVjdXRpb24gY291bnRcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kVG9JbnB1dChgY2VsbCAke2NlbGxDb250ZW50fWApO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zZXJ0aW5nIGNlbGwgYnkgaW5kZXg6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERldGVjdHMgdGhlIHByb2dyYW1taW5nIGxhbmd1YWdlIGZyb20gY29kZSBibG9jayBjb250ZW50XG4gICAgICovXG4gICAgZGV0ZWN0TGFuZ3VhZ2UoY29kZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVHJ5IGF1dG8gZGV0ZWN0aW9uIGZpcnN0XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmhpZ2hsaWdodEF1dG8oY29kZSwgW1xuICAgICAgICAgICAgICAgICdweXRob24nLCAnamF2YXNjcmlwdCcsICd0eXBlc2NyaXB0JywgJ2phdmEnLFxuICAgICAgICAgICAgICAgICdodG1sJywgJ2NzcycsICdjcHAnLCAnY3NoYXJwJywgJ3NxbCcsICdydXN0JyxcbiAgICAgICAgICAgICAgICAncGhwJywgJ2Jhc2gnLCAnanNvbicsICd4bWwnLCAnbWFya2Rvd24nXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIC8vIElmIGNvbmZpZGVuY2UgaXMgaGlnaCBlbm91Z2gsIHVzZSB0aGF0IGxhbmd1YWdlXG4gICAgICAgICAgICBpZiAocmVzdWx0LnJlbGV2YW5jZSA+IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0Lmxhbmd1YWdlIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIGJldHRlciBhY2N1cmFjeVxuICAgICAgICAgICAgaWYgKC9eKD86XFxzKik/KD86aW1wb3J0XFxzK1teO10rO3xwYWNrYWdlXFxzK1teO10rO3xwdWJsaWNcXHMrY2xhc3MpLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdqYXZhJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KGltcG9ydHxmcm9tfGRlZnxjbGFzc3xpZiBfX25hbWVfXylcXHMvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3B5dGhvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OmZ1bmN0aW9ufGNvbnN0fGxldHx2YXJ8aW1wb3J0KVxccy8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnamF2YXNjcmlwdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OjwhRE9DVFlQRXw8aHRtbHw8aGVhZHw8Ym9keSkvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2h0bWwnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8jaW5jbHVkZS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnY3BwJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86dXNpbmdcXHMrU3lzdGVtfG5hbWVzcGFjZXxwdWJsaWNcXHMrc3RhdGljXFxzK3ZvaWRcXHMrTWFpbikvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NzaGFycCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OlxcJHxTRUxFQ1R8SU5TRVJUfFVQREFURXxERUxFVEV8Q1JFQVRFfEFMVEVSKVxccy9pLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3NxbCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/Om1vZHVsZXxmbnxsZXR8c3RydWN0fGVudW18dHJhaXR8aW1wbClcXHMvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3J1c3QnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzo8P3BocHx1c2VcXHMrW1xcd1xcXFxdKzspLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwaHAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8oPzojXFxzKiFcXC91c3JcXC9iaW5cXC9lbnZ8cmVxdWlyZXxtb2R1bGVcXC5leHBvcnRzfGNvbnNvbGVcXC4pLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdiYXNoJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGRldGVjdGluZyBsYW5ndWFnZTonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0cyBjb2RlIHdpdGggYXBwcm9wcmlhdGUgc3ludGF4IGhpZ2hsaWdodGluZ1xuICAgICAqL1xuICAgIGhpZ2hsaWdodENvZGUoY29kZSwgbGFuZ3VhZ2UpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghbGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgICAgICAvLyBUcnkgdG8gYXV0by1kZXRlY3QgaWYgbm8gbGFuZ3VhZ2Ugc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodF9qc18xLmRlZmF1bHQuaGlnaGxpZ2h0QXV0byhjb2RlKS52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRfanNfMS5kZWZhdWx0LmdldExhbmd1YWdlKGxhbmd1YWdlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmhpZ2hsaWdodChjb2RlLCB7IGxhbmd1YWdlIH0pLnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2sgdG8gYXV0by1kZXRlY3Rpb24gaWYgc3BlY2lmaWVkIGxhbmd1YWdlIGlzbid0IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgIHJldHVybiBoaWdobGlnaHRfanNfMS5kZWZhdWx0LmhpZ2hsaWdodEF1dG8oY29kZSkudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBoaWdobGlnaHRpbmcgY29kZTonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gY29kZTsgLy8gUmV0dXJuIG9yaWdpbmFsIGNvZGUgb24gZXJyb3JcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29weSB0ZXh0IHRvIGNsaXBib2FyZCB3aXRoIHZpc3VhbCBmZWVkYmFja1xuICAgIGNvcHlUb0NsaXBib2FyZCh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnQ29udGVudCBjb3BpZWQgdG8gY2xpcGJvYXJkJyk7XG4gICAgICAgICAgICAgICAgLy8gU2hvdyBhIHRlbXBvcmFyeSBub3RpZmljYXRpb25cbiAgICAgICAgICAgICAgICBjb25zdCBub3RpZmljYXRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdG9hc3Qtbm90aWZpY2F0aW9uIGpwLWxsbS1leHQtY29weS1zdWNjZXNzJztcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb24udGV4dENvbnRlbnQgPSAnQ29waWVkIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRvIHRoZSBtYWluIHdpZGdldFxuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZChub3RpZmljYXRpb24pO1xuICAgICAgICAgICAgICAgIC8vIEFuaW1hdGUgaW5cbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgbm90aWZpY2F0aW9uLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGFmdGVyIGRlbGF5XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGZhZGUgb3V0IGFuaW1hdGlvbiB0byBjb21wbGV0ZSBiZWZvcmUgcmVtb3ZpbmdcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XG4gICAgICAgICAgICAgICAgfSwgMTUwMCk7XG4gICAgICAgICAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBjb3B5IHRleHQ6ICcsIGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvcHlpbmcgdG8gY2xpcGJvYXJkOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3BpZXMgYW4gaW1hZ2UgdG8gdGhlIGNsaXBib2FyZFxuICAgICAqL1xuICAgIGNvcHlJbWFnZVRvQ2xpcGJvYXJkKGltYWdlVXJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBGZXRjaCB0aGUgaW1hZ2VcbiAgICAgICAgICAgIGZldGNoKGltYWdlVXJsKVxuICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJsb2IoKSlcbiAgICAgICAgICAgICAgICAudGhlbihibG9iID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBDbGlwYm9hcmRJdGVtIHdpdGggdGhlIGltYWdlIGJsb2JcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gbmV3IENsaXBib2FyZEl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICBbYmxvYi50eXBlXTogYmxvYlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIC8vIENvcHkgdGhlIGltYWdlIHRvIGNsaXBib2FyZFxuICAgICAgICAgICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGUoW2l0ZW1dKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ltYWdlIGNvcGllZCB0byBjbGlwYm9hcmQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2hvdyB2aXN1YWwgZmVlZGJhY2tcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm90aWZpY2F0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10b2FzdC1ub3RpZmljYXRpb24ganAtbGxtLWV4dC1jb3B5LXN1Y2Nlc3MnO1xuICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24udGV4dENvbnRlbnQgPSAnSW1hZ2UgY29waWVkIHRvIGNsaXBib2FyZCc7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFkZCB0byB0aGUgbWFpbiB3aWRnZXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKG5vdGlmaWNhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFuaW1hdGUgaW5cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24uY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBhZnRlciBkZWxheVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vdGlmaWNhdGlvbi5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciBmYWRlIG91dCBhbmltYXRpb24gdG8gY29tcGxldGUgYmVmb3JlIHJlbW92aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub3RpZmljYXRpb24ucmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xuICAgICAgICAgICAgICAgICAgICB9LCAxNTAwKTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGNvcHkgaW1hZ2U6ICcsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gY29weSBpbWFnZTogJyArIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGZldGNoIGltYWdlOiAnLCBlcnIpO1xuICAgICAgICAgICAgICAgIGFsZXJ0KCdGYWlsZWQgdG8gZmV0Y2ggaW1hZ2U6ICcgKyBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvcHlpbmcgaW1hZ2UgdG8gY2xpcGJvYXJkOicsIGVycm9yKTtcbiAgICAgICAgICAgIGFsZXJ0KCdFcnJvciBjb3B5aW5nIGltYWdlIHRvIGNsaXBib2FyZDogJyArIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnNlcnRzIGEgY29sbGFwc2libGUgY29kZSByZWZlcmVuY2Ugd2lkZ2V0IGluIHRoZSBpbnB1dCBhcmVhXG4gICAgICovXG4gICAgaW5zZXJ0Q29sbGFwc2VkQ29kZVJlZihjb2RlLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGEgdW5pcXVlIElEIGZvciB0aGlzIHJlZmVyZW5jZVxuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSBgY29kZS1yZWYtJHtEYXRlLm5vdygpfS0ke01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKX1gO1xuICAgICAgICAgICAgLy8gRm9ybWF0IHRoZSByZWZlcmVuY2UgYXMgXCJub3RlYm9vay1uYW1lOmNlbGwtaW5kZXgtbGluZS1udW1iZXJcIlxuICAgICAgICAgICAgY29uc3QgY29kZVJlZiA9IGAke25vdGVib29rTmFtZX06JHtjZWxsSW5kZXh9LSR7bGluZU51bWJlcn1gO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHRoZSBjb2xsYXBzaWJsZSB3aWRnZXQgSFRNTFxuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0SHRtbCA9IGA8c3BhbiBjbGFzcz1cImpwLWxsbS1leHQtY29kZS1yZWYtd2lkZ2V0XCIgZGF0YS1yZWYtaWQ9XCIke3JlZklkfVwiIGRhdGEtY29kZT1cIiR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvZGUpfVwiIGRhdGEtcmVmPVwiJHtjb2RlUmVmfVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cImpwLWxsbS1leHQtY29kZS1yZWYtbGFiZWxcIj4ke2NvZGVSZWZ9PC9zcGFuPlxuICAgICAgICA8YnV0dG9uIGNsYXNzPVwianAtbGxtLWV4dC1jb2RlLXJlZi10b2dnbGVcIiB0aXRsZT1cIkV4cGFuZC9jb2xsYXBzZSBjb2RlXCI+4q+IPC9idXR0b24+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwianAtbGxtLWV4dC1jb2RlLXJlZi1jb250ZW50XCIgc3R5bGU9XCJkaXNwbGF5Om5vbmU7XCI+JHtjb2RlfTwvc3Bhbj5cbiAgICAgIDwvc3Bhbj5gO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IGF0IGN1cnNvciBwb3NpdGlvbiBvciBhcHBlbmQgdG8gZW5kXG4gICAgICAgICAgICBjb25zdCBjdXJzb3JQb3MgPSB0aGlzLmlucHV0RmllbGQuc2VsZWN0aW9uU3RhcnQgfHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHRleHRCZWZvcmVDdXJzb3IgPSB0aGlzLmlucHV0RmllbGQudmFsdWUuc3Vic3RyaW5nKDAsIGN1cnNvclBvcyk7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QWZ0ZXJDdXJzb3IgPSB0aGlzLmlucHV0RmllbGQudmFsdWUuc3Vic3RyaW5nKGN1cnNvclBvcyk7XG4gICAgICAgICAgICAvLyBJbnNlcnQgd2lkZ2V0IHBsYWNlaG9sZGVyIHRleHQgaW4gdGhlIHRleHRhcmVhXG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlclRleHQgPSBgW0NvZGVSZWY6JHtjb2RlUmVmfV1gO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gdGV4dEJlZm9yZUN1cnNvciArIHBsYWNlaG9sZGVyVGV4dCArIHRleHRBZnRlckN1cnNvcjtcbiAgICAgICAgICAgIC8vIFN0b3JlIHRoZSBIVE1MIHRvIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIHdoZW4gcmVuZGVyaW5nXG4gICAgICAgICAgICBsZXQgZWxlbWVudE1hcDtcbiAgICAgICAgICAgIGlmICghKCdfY29kZVJlZk1hcCcgaW4gdGhpcy5pbnB1dEZpZWxkKSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLl9jb2RlUmVmTWFwID0gZWxlbWVudE1hcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVsZW1lbnRNYXAgPSB0aGlzLmlucHV0RmllbGQuX2NvZGVSZWZNYXA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdG9yZSB0aGUgSFRNTCB0byByZXBsYWNlIHRoZSBwbGFjZWhvbGRlciB3aGVuIHJlbmRlcmluZ1xuICAgICAgICAgICAgZWxlbWVudE1hcC5zZXQocGxhY2Vob2xkZXJUZXh0LCB3aWRnZXRIdG1sKTtcbiAgICAgICAgICAgIC8vIEZvY3VzIHRoZSBpbnB1dCBmaWVsZCBhbmQgbW92ZSBjdXJzb3IgdG8gYWZ0ZXIgdGhlIGluc2VydGVkIHdpZGdldFxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0U2VsZWN0aW9uUmFuZ2UoY3Vyc29yUG9zICsgcGxhY2Vob2xkZXJUZXh0Lmxlbmd0aCwgY3Vyc29yUG9zICsgcGxhY2Vob2xkZXJUZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICAvLyBBZGQgZXZlbnQgbGlzdGVuZXIgZm9yIGV4cGFuZGluZy9jb2xsYXBzaW5nIChkZWxlZ2F0ZWQgdG8gcGFyZW50KVxuICAgICAgICAgICAgaWYgKCF0aGlzLmhhc0NvZGVSZWZMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZUNvZGVSZWZDbGljay5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhc0NvZGVSZWZMaXN0ZW5lcnMgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zZXJ0aW5nIGNvbGxhcHNlZCBjb2RlIHJlZmVyZW5jZTonLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBpbnNlcnRpbmcgY29kZSBkaXJlY3RseVxuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KGBjb2RlICR7Y29kZX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgY2xpY2tzIG9uIGNvZGUgcmVmZXJlbmNlIGV4cGFuZC9jb2xsYXBzZSBidXR0b25zXG4gICAgICovXG4gICAgaGFuZGxlQ29kZVJlZkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgLy8gQ2hlY2sgaWYgaXQncyB0aGUgdG9nZ2xlIGJ1dHRvblxuICAgICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucygnanAtbGxtLWV4dC1jb2RlLXJlZi10b2dnbGUnKSkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgcGFyZW50IHdpZGdldFxuICAgICAgICAgICAgY29uc3Qgd2lkZ2V0ID0gdGFyZ2V0LmNsb3Nlc3QoJy5qcC1sbG0tZXh0LWNvZGUtcmVmLXdpZGdldCcpO1xuICAgICAgICAgICAgaWYgKCF3aWRnZXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgY29udGVudCBlbGVtZW50XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gd2lkZ2V0LnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LWNvZGUtcmVmLWNvbnRlbnQnKTtcbiAgICAgICAgICAgIGlmICghY29udGVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBUb2dnbGUgdGhlIGNvbnRlbnQgdmlzaWJpbGl0eVxuICAgICAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gY29udGVudC5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gICAgICAgICAgICBjb250ZW50LnN0eWxlLmRpc3BsYXkgPSBpc1Zpc2libGUgPyAnbm9uZScgOiAnYmxvY2snO1xuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSB0b2dnbGUgYnV0dG9uIHRleHRcbiAgICAgICAgICAgIHRhcmdldC50ZXh0Q29udGVudCA9IGlzVmlzaWJsZSA/ICfir4gnIDogJ+Kvhic7XG4gICAgICAgICAgICAvLyBTdG9wIGV2ZW50IHByb3BhZ2F0aW9uXG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSBTaW1wbGVTaWRlYmFyV2lkZ2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9