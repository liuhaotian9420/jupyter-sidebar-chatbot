"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components"); // Import LabIcon if needed as placeholder
// Placeholder icon (replace if you have a specific icon)
const extensionIcon = ui_components_1.LabIcon.resolve({ icon: 'ui-components:jupyterlab' }); // Use resolve for built-in
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/api-client.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/api-client.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/globals.js":
/*!*******************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/globals.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/core/icons.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/core/icons.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HistoryHandler = void 0;
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js"); // Assuming renderers are needed
/**
 * Manages the display and interaction logic for the chat history view.
 */
class HistoryHandler {
    constructor(chatState, uiManager, callbacks, rendererCallbacks) {
        this.isHistoryViewActive = false;
        this.chatState = chatState;
        this.uiManager = uiManager;
        this.callbacks = callbacks;
        this.rendererCallbacks = rendererCallbacks;
        // Get the history container element from UIManager
        this.historyContainer = this.uiManager.getUIElements().historyContainer;
    }
    /**
     * Toggles between the main chat view and the history view.
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Use UIManager to hide chat, show history
            this.uiManager.showHistoryView();
            this.renderChatHistory(); // Populate the history view
        }
        else {
            // Use UIManager to show chat, hide history
            this.uiManager.showChatView();
            // Ensure the correct title is displayed when switching back
            const currentChat = this.chatState.getCurrentChat();
            if (currentChat) {
                this.callbacks.updateTitleInput(currentChat.title);
            }
        }
    }
    /**
     * Renders the list of past chats in the history container.
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = ''; // Clear previous list
        const history = this.chatState.getChatHistory();
        const currentChatId = this.chatState.getCurrentChatId();
        if (history.length === 0) {
            this.historyContainer.innerHTML = '<div class="jp-llm-ext-history-empty">No chat history yet.</div>';
            return;
        }
        const list = document.createElement('ul');
        list.className = 'jp-llm-ext-history-list';
        history.forEach(chat => {
            const listItem = document.createElement('li');
            listItem.className = 'jp-llm-ext-history-item';
            if (chat.id === currentChatId) {
                listItem.classList.add('jp-llm-ext-active');
            }
            // Simple representation: Title
            // TODO: Add preview, timestamp, delete button etc.
            const titleDiv = document.createElement('div');
            titleDiv.className = 'jp-llm-ext-history-item-title';
            titleDiv.textContent = chat.title || 'Untitled Chat';
            listItem.appendChild(titleDiv);
            // Add click event to load the chat
            listItem.addEventListener('click', () => this.loadChat(chat.id));
            list.appendChild(listItem);
        });
        this.historyContainer.appendChild(list);
    }
    /**
     * Loads a specific chat session from history into the main view.
     */
    loadChat(chatId) {
        const chat = this.chatState.getChatById(chatId);
        if (!chat) {
            console.error(`Chat with ID ${chatId} not found.`);
            return;
        }
        // Set this chat as the active one in the state
        this.chatState.setCurrentChatId(chatId);
        // Update the main UI title input
        this.callbacks.updateTitleInput(chat.title);
        // Clear the current message display
        this.callbacks.clearMessageContainer();
        // Re-populate the message container with messages from the loaded chat
        // Use the renderer functions via callbacks
        chat.messages.forEach((msg) => {
            let messageElement;
            if (msg.sender === 'user') {
                messageElement = (0, message_renderer_1.renderUserMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);
            }
            else { // 'bot'
                messageElement = (0, message_renderer_1.renderBotMessage)(msg.text, { isMarkdown: msg.isMarkdown }, this.rendererCallbacks);
            }
            // Add the rendered element to the message container via callback
            this.callbacks.addRenderedMessage(messageElement);
        });
        // Switch back to the chat view if we were in the history view
        if (this.isHistoryViewActive) {
            this.toggleHistoryView(); // This will call uiManager.showChatView()
        }
        else {
            // If already in chat view, ensure scrolling is correct
            this.uiManager.scrollToBottom();
        }
        // Optional: Re-render history list to update the active item indicator
        // Only really needed if not switching views
        // if (!this.isHistoryViewActive) { this.renderChatHistory(); }
    }
}
exports.HistoryHandler = HistoryHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/input-handler.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/input-handler.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputHandler = void 0;
const content_editable_utils_1 = __webpack_require__(/*! ../utils/content-editable-utils */ "./node_modules/jupyter-simple-extension/lib/utils/content-editable-utils.js"); // Helper needed
/**
 * Handles events and logic related to the chat input field.
 */
class InputHandler {
    constructor(chatInput, callbacks
    // uiManager: UIManager // Removed unused parameter
    ) {
        // private uiManager: UIManager; // Removed unused member
        // --- Code Reference State ---
        this.codeRefMap = new Map();
        this.nextRefId = 1;
        // ---------------------------
        this.hasAtSymbol = false;
        this.isMarkdownMode = false; // Internal state, potentially synced with UIManager
        this.isInputExpanded = false; // Internal state, potentially synced with UIManager
        // -----------------------------
        // --- Private Event Handlers ---
        this._handleKeyPress = (event) => {
            // Handle Enter key press (send message)
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default newline insertion
                // Use textContent for div
                let message = this.chatInput.textContent || '';
                message = message.trim(); // Just trim the raw message
                if (message) {
                    this.callbacks.handleSendMessage(message); // Pass raw message with placeholders
                }
            }
            // --- Handle Tab/Escape/Arrows for popup interaction ---
            // Check if popup is visible (needs a way to know, maybe via callbacks or direct reference?)
            // Assuming popupMenuManager reference is available or state is tracked
            // else if (this.popupMenuManager.isPopupMenuVisible()) { // Pseudo-code
            //    if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown') {
            //        // Prevent default input field behavior
            //        event.preventDefault();
            //        // Let the PopupMenuManager's document handler manage the event
            //    }
            // }
            // --- End Popup Interaction Handling ---
        };
        this._handleInput = () => {
            // Use textContent for div
            const currentText = this.chatInput.textContent || '';
            // --- Update Code Ref Placeholders --- 
            // Optional: If we want visual placeholders to update live
            // This could involve complex DOM manipulation or using a library.
            // For now, we resolve refs only on send.
            // --- At Symbol Detection for Popup --- 
            // This logic was moved to UIManager.handleInputForReference
            // because UIManager needs to coordinate showing the popup.
            // InputHandler might still need to know *if* an @ was typed recently
            // to adjust behavior (e.g., how Enter works), but UIManager handles the popup trigger.
            // Simple check if text contains '@' for potential state management
            this.hasAtSymbol = currentText.includes('@');
            // Adjust input height dynamically based on content?
            // Can be complex with contenteditable divs. Requires careful calculation.
            // this.adjustInputHeight(); 
        };
        this.chatInput = chatInput;
        this.callbacks = callbacks;
        // this.uiManager = uiManager; // Removed unused assignment
        // Bind event listeners
        this.chatInput.addEventListener('keypress', this._handleKeyPress);
        this.chatInput.addEventListener('input', this._handleInput);
        // Note: Actual markdown toggle and expand buttons are likely managed by UIManager,
        // which would then call methods like `setMarkdownMode` or `toggleExpansion` on this handler.
    }
    /**
     * Removes event listeners.
     */
    dispose() {
        this.chatInput.removeEventListener('keypress', this._handleKeyPress);
        this.chatInput.removeEventListener('input', this._handleInput);
    }
    /**
     * Appends text to the input field, potentially replacing a preceding '@' symbol.
     */
    appendToInput(text) {
        try {
            this.chatInput.focus(); // Ensure focus first
            const selection = window.getSelection();
            if (!selection || selection.rangeCount === 0) {
                console.error('Cannot append to input: No selection found.');
                // Fallback: append to end
                this.chatInput.textContent = (this.chatInput.textContent || '') + text;
                return;
            }
            const range = selection.getRangeAt(0);
            const { startContainer, startOffset } = range;
            let currentTextContent = this.chatInput.textContent || ''; // Use textContent
            let insertPos = (0, content_editable_utils_1.getCaretPosition)(this.chatInput); // Get linear position
            // Simple check: if the character before the linear caret position is '@'
            if (insertPos > 0 && currentTextContent[insertPos - 1] === '@') {
                // Replace the '@' - more complex with DOM manipulation,
                // For simplicity, we'll replace in textContent and reset
                const before = currentTextContent.slice(0, insertPos - 1);
                const after = currentTextContent.slice(insertPos);
                this.chatInput.textContent = before + text + after;
                // Set cursor position after the inserted text
                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, (insertPos - 1) + text.length);
            }
            else {
                // Standard insertion - more complex with DOM manipulation
                // For simplicity, we'll insert in textContent and reset
                const before = currentTextContent.slice(0, insertPos);
                const after = currentTextContent.slice(insertPos);
                this.chatInput.textContent = before + text + after;
                // Set cursor position after the inserted text
                (0, content_editable_utils_1.setCaretPosition)(this.chatInput, insertPos + text.length);
            }
            // Trigger input event manually since we're changing textContent directly
            this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    /**
     * Clears the input field and resets associated state after sending.
     */
    clearInput() {
        // Use textContent for div
        this.chatInput.textContent = '';
        // Directly reset internal state instead of relying on callback
        this.resetCodeReferences();
        // Remove rows manipulation
        // this.chatInput.rows = 1;
        this.chatInput.style.height = ''; // Reset height
        this.hasAtSymbol = false; // Reset @ state
        // Reset expand button state if it was expanded
        if (this.isInputExpanded) {
            this.toggleInputExpansion(false); // Collapse input
        }
        // Trigger input event manually after clearing
        this.chatInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
    }
    /**
     * Sets the markdown mode state and updates the placeholder.
     */
    setMarkdownMode(isMarkdown) {
        this.isMarkdownMode = isMarkdown;
        this.callbacks.updatePlaceholder(this.isMarkdownMode);
        // Update placeholder directly (alternative to callback)
        // this.chatInput.placeholder = this.isMarkdownMode ? 
        //   'Write markdown here...' : 
        //   'Ask me anything...';
    }
    /**
     * Toggles the input expansion state and updates UI.
     */
    toggleInputExpansion(forceState) {
        this.isInputExpanded = forceState !== undefined ? forceState : !this.isInputExpanded;
        if (this.isInputExpanded) {
            // Use max-height or height for div
            this.chatInput.style.height = '200px'; // Example height
            // Allow vertical resizing if desired, or keep as 'none'
            this.chatInput.style.resize = 'vertical';
            this.chatInput.style.overflowY = 'auto'; // Ensure scrollbar appears if needed
        }
        else {
            this.chatInput.style.height = ''; // Reset height
            this.chatInput.style.resize = 'none';
            // Remove rows manipulation
            // this.chatInput.rows = 1; // Ensure it collapses back to 1 row height
            this.chatInput.style.overflowY = 'hidden'; // Hide scrollbar when collapsed
        }
        // Notify UIManager/LayoutBuilder to update button appearance
        this.callbacks.toggleInputExpansionUI(this.isInputExpanded);
    }
    // --- Code Reference Methods ---
    /**
     * Adds a code reference to the internal map and returns its ID.
     * @param code The actual code content.
     * @param notebookName The name of the notebook the code is from.
     * @param cellIndex The index of the cell the code is from (0-based).
     * @param lineNumber The starting line number of the code within the cell (1-based).
     * @param lineEndNumber The ending line number of the code within the cell (1-based).
     * @returns The generated reference ID (e.g., "ref-1").
     */
    addCodeReference(code, notebookName, cellIndex, lineNumber, // Start line
    lineEndNumber // End line
    ) {
        const refId = `ref-${this.nextRefId++}`;
        // Store both start and end line numbers
        const refData = { code, notebookName, cellIndex, lineNumber, lineEndNumber };
        // Store the ACTUAL CodeRefData object in the map
        this.codeRefMap.set(refId, refData);
        // Log the details separately
        console.log('Added code reference:', refId, '->', `(${notebookName}, Cell ${cellIndex + 1}, Line ${lineNumber}${lineNumber !== lineEndNumber ? '_' + lineEndNumber : ''}) ` +
            code.substring(0, 30) + '...' // Log metadata too
        );
        return refId;
    }
    /**
     * Returns the current map of code references.
     */
    getCodeReferenceMap() {
        return this.codeRefMap;
    }
    /**
     * Clears the code reference map and resets the ID counter.
     */
    resetCodeReferences() {
        // --- DEBUG LOG --- 
        console.log('[InputHandler] resetCodeReferences called!', new Error().stack); // Log call stack
        // --- END DEBUG LOG --- 
        this.codeRefMap.clear();
        this.nextRefId = 1;
        console.log('Code references reset.'); // Debug log
    }
    /**
     * Replaces code reference placeholders (e.g., "[ref-1]") in a message string
     * with the actual code from the map.
     * @param message The message string potentially containing placeholders.
     * @returns The message string with placeholders resolved.
     */
    resolveCodeReferences(message) {
        if (this.codeRefMap.size === 0) {
            return message; // No references to resolve
        }
        // Regex to find placeholders like [ref-1], [ref-12], etc.
        const placeholderRegex = /\[(ref-\d+)\]/g;
        let resolvedMessage = message.replace(placeholderRegex, (match, refId) => {
            // Access the .code property from the stored object
            const refData = this.codeRefMap.get(refId);
            if (refData) {
                console.log('Resolving code reference:', refId); // Debug log
                // Add context around the replaced code
                return `\n\`\`\`\n${refData.code}\n\`\`\`\n`; // Use refData.code
            }
            else {
                console.warn('Could not find code for reference:', refId); // Warn if ref ID not found
                return match; // Keep the placeholder if not found
            }
        });
        return resolvedMessage;
    }
    /**
      // Handle @ symbol removal to hide popup using selection API
      const selection = window.getSelection();
      if (!selection || !selection.rangeCount) return;
  
      const range = selection.getRangeAt(0);
      // Check if the input field contains the start of the range
      if (!this.chatInput.contains(range.startContainer)) return;
  
      const cursorPosition = getCaretPosition(this.chatInput); // Use helper
      if (cursorPosition === null) return;
  
      const textContent = this.chatInput.textContent || '';
      const textBeforeCursor = textContent.slice(0, cursorPosition);
  
      // Check if the character immediately before the cursor is '@'
      // and if it's preceded by whitespace or is at the start of the input.
      const isAtSymbolContext = textBeforeCursor.endsWith('@') &&
                             (cursorPosition === 1 ||
                              cursorPosition > 1 && /\s/.test(textBeforeCursor[cursorPosition - 2]));
  
      if (this.hasAtSymbol && !isAtSymbolContext) {
        // @ symbol context was present but now it's gone, hide the popup
        this.callbacks.hidePopupMenu();
      }
      // Update the state *after* checking the previous state
      this.hasAtSymbol = isAtSymbolContext;
  
      // --- Auto-resize logic (optional) ---
      // Simple auto-resize based on scroll height (might need refinement)
      if (!this.isInputExpanded) { // Only auto-resize if not manually expanded
          this.chatInput.style.height = 'auto'; // Temporarily shrink to content
          const scrollHeight = this.chatInput.scrollHeight;
          // Set a max height to prevent infinite growth, e.g., 150px
          const maxHeight = 150;
          const newHeight = Math.min(scrollHeight, maxHeight);
           // Only update height if it actually changes to avoid flicker
          if (this.chatInput.offsetHeight < newHeight) {
               this.chatInput.style.height = `${newHeight}px`;
               this.chatInput.style.overflowY = scrollHeight > maxHeight ? 'auto' : 'hidden';
          } else if (scrollHeight <= this.chatInput.clientHeight) {
              // Shrink if content height is less than current height
              this.chatInput.style.height = `${scrollHeight}px`;
              this.chatInput.style.overflowY = 'hidden';
          }
      }
      // -----------------------------------
    };
    
    /**
     * Explicitly sets the hasAtSymbol flag. Called by shortcut handler.
     */
    setHasAtSymbol(value) {
        this.hasAtSymbol = value;
    }
    /**
     * Gets the current value of the hasAtSymbol flag. Called by shortcut handler.
     */
    getHasAtSymbol() {
        return this.hasAtSymbol;
    }
}
exports.InputHandler = InputHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageHandler = void 0;
const message_renderer_1 = __webpack_require__(/*! ../ui/message-renderer */ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js");
const notebook_integration_1 = __webpack_require__(/*! ../utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js"); // Import globals for notebook tracker
/**
 * Handles sending messages, interacting with the API,
 * managing streaming responses, and updating the UI and state.
 */
class MessageHandler {
    constructor(apiClient, chatState, uiManager, rendererCallbacks, inputHandler) {
        this.apiClient = apiClient;
        this.chatState = chatState;
        this.uiManager = uiManager;
        this.rendererCallbacks = rendererCallbacks;
        this.inputHandler = inputHandler;
    }
    /**
     * Processes and sends a user-initiated message.
     * Also handles adding the user message to the UI and clearing the input.
     * Accepts the message text.
     */
    handleSendMessage(message) {
        if (!message.trim())
            return;
        console.log(`[MessageHandler] Handling send: "${message}"`);
        // Add user message to UI FIRST
        // Assume user messages aren't markdown unless specific toggle is used elsewhere
        this.addMessage(message, 'user');
        // Clear input via InputHandler (which uses UIManager)
        // REMOVED: this.inputHandler.clearInput(); // Input clearing is now handled by UIManager after the callback
        // Send message to backend API and handle streaming response
        this.streamAndRenderResponse(message);
    }
    /**
     * Sends an automatic message (e.g., 'confirmed', 'rejected')
     * to the backend and handles the streaming response.
     * Also adds the user's confirmation/rejection action and a separator to the UI.
     */
    handleSendAutoMessage(message) {
        if (!message.trim())
            return;
        // Add the user's action ('Confirmed' or 'Rejected') to the UI immediately
        const userDisplayMessage = message.charAt(0).toUpperCase() + message.slice(1);
        // Explicitly false for isMarkdown, true for isAuto
        this.addMessage(userDisplayMessage, 'user', false, true);
        // Create and add the separator element
        console.log('[MessageHandler] Creating action separator element...'); // Debug log
        const separatorDiv = document.createElement('div');
        separatorDiv.className = 'jp-llm-ext-action-separator'; // Add a class for potential styling
        separatorDiv.style.textAlign = 'center'; // Basic styling
        separatorDiv.style.margin = '10px 0'; // Add some vertical space
        separatorDiv.style.fontSize = '0.9em';
        separatorDiv.style.color = 'var(--jp-ui-font-color2, grey)'; // Use JupyterLab theme variable
        if (message === 'confirmed') {
            separatorDiv.textContent = '--------✅ Confirmed--------';
        }
        else if (message === 'rejected') {
            separatorDiv.textContent = '--------❌ Rejected--------';
        }
        else {
            // Optional: Handle unexpected messages? Or just don't add a separator.
            separatorDiv.textContent = `--------${userDisplayMessage}--------`;
        }
        // Add the separator directly to the UI Manager's container
        console.log('[MessageHandler] Attempting to add separator element:', separatorDiv); // Debug log
        this.uiManager.addChatMessageElement(separatorDiv);
        console.log('[MessageHandler] Separator element should be added.'); // Debug log
        // Send the technical message ('confirmed' or 'rejected') to the backend
        // and handle the streaming response from the backend.
        this.streamAndRenderResponse(message);
    }
    /**
     * Adds a message to the UI via UIManager and saves to ChatState.
     */
    addMessage(text, sender, isMarkdown = false, // Default false, overridden below
    isAuto = false // Flag for auto messages like confirm/reject
    ) {
        console.log(`[MessageHandler] Adding message: Sender=${sender}, Markdown=${isMarkdown}, Auto=${isAuto}`);
        let messageElement;
        // Prepare extended callbacks for the renderer
        const extendedCallbacks = Object.assign(Object.assign({}, this.rendererCallbacks), { getCodeRefData: (refId) => {
                return this.inputHandler.getCodeReferenceMap().get(refId);
            }, getCurrentNotebookContext: () => {
                var _a, _b;
                const currentNotebook = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.currentWidget;
                if (currentNotebook === null || currentNotebook === void 0 ? void 0 : currentNotebook.context) {
                    const path = currentNotebook.context.path;
                    const name = ((_b = path.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';
                    return { name, path };
                }
                return undefined;
            } });
        if (sender === 'user') {
            // Pass the isMarkdown option and extended callbacks to the renderer
            messageElement = (0, message_renderer_1.renderUserMessage)(text, { isMarkdown }, extendedCallbacks);
        }
        else {
            // Bot messages usually are markdown unless specified otherwise
            // Handle auto messages specifically if they shouldn't be parsed as markdown
            const botIsMarkdown = !isAuto; // Assume auto messages aren't markdown
            // Pass extended callbacks to bot message renderer too, in case it needs them later
            messageElement = (0, message_renderer_1.renderBotMessage)(text, { isMarkdown: botIsMarkdown }, extendedCallbacks);
        }
        this.uiManager.addChatMessageElement(messageElement);
        // Don't save internal 'confirmed'/'rejected' messages to history
        if (!isAuto) {
            // Add isMarkdown back to the saved message state
            const chatMessage = { sender, text, isMarkdown };
            this.chatState.addMessageToCurrentChat(chatMessage);
        }
    }
    /**
     * Core logic for sending a message to the API, handling the stream,
     * rendering the response, and saving the final bot message.
     */
    streamAndRenderResponse(messageToSend) {
        // --- Prepare streaming UI elements (managed by UIManager) ---
        // UIManager should provide a method to create/get these elements
        const { streamingDiv, contentDiv } = this.uiManager.createBotMessageContainer();
        let completeResponse = '';
        const cellContext = (0, notebook_integration_1.getCurrentCellContent)(); // Use utility
        // Stream response from API
        this.apiClient.streamChat(messageToSend, { cellContext }, 
        // On chunk received
        (chunk) => {
            completeResponse += chunk;
            // Update the temporary streaming div
            streamingDiv.textContent = completeResponse;
            this.uiManager.scrollToBottom();
        }, 
        // On complete
        () => {
            var _a;
            // Hide streaming div, show final content div
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Render the complete response using the renderer function
            const renderedContent = (0, message_renderer_1.renderBotMessage)(completeResponse, { isMarkdown: true }, this.rendererCallbacks);
            contentDiv.innerHTML = ''; // Clear placeholder/previous content
            // Append rendered nodes, skipping any potential wrapper/indicator added by renderBotMessage itself
            while (renderedContent.firstChild) {
                // Check if the node is the specific markdown indicator we might add/remove
                // Or just append everything if renderBotMessage returns the pure content
                if (!((_a = renderedContent.firstChild.classList) === null || _a === void 0 ? void 0 : _a.contains('markdown-indicator'))) {
                    contentDiv.appendChild(renderedContent.firstChild);
                }
                else {
                    // Remove the indicator if it was part of the returned fragment
                    renderedContent.removeChild(renderedContent.firstChild);
                }
            }
            // Save final bot response to history via ChatState
            const isImage = completeResponse.trim().startsWith('/images/'); // Simple check
            const botMessageData = {
                text: completeResponse,
                sender: 'bot',
                isMarkdown: !isImage // Save as markdown unless it's an image URL
            };
            this.chatState.addMessageToCurrentChat(botMessageData);
            this.uiManager.scrollToBottom();
        }, 
        // On error
        (error) => {
            // Hide streaming div, show final content div with error
            streamingDiv.style.display = 'none';
            contentDiv.style.display = 'block';
            // Use a dedicated error rendering style/component if available
            contentDiv.innerHTML = `<div class="jp-llm-ext-error-message">Error: ${error.message}</div>`;
            console.error('API Error:', error);
            this.uiManager.scrollToBottom();
        });
    }
}
exports.MessageHandler = MessageHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
/**
 * Manages the state and interactions of the multi-level popup menu.
 */
class PopupMenuManager {
    constructor(docManager, widgetNode, callbacks) {
        this.currentMenuLevel = 'top';
        this.currentMenuPath = '';
        this.menuHistory = [];
        this.currentNotebook = null;
        this.selectedMenuItemIndex = -1; // Track currently selected menu item
        this.isRenderingContent = false; // Flag to prevent recursive renders
        this.lastSearchTerm = ''; // Track last search term to avoid unnecessary re-renders
        this.allowedExtensions = ['.py', '.ipynb', '.md', '.json', '.txt', '.csv'];
        this.fileCache = new Map();
        this.docManager = docManager;
        this.widgetNode = widgetNode;
        this.callbacks = callbacks;
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        // Attach to the widget node instead of the body
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Create search input
        this.searchInput = document.createElement('input');
        this.searchInput.type = 'text';
        this.searchInput.placeholder = 'Search...';
        this.searchInput.className = 'jp-llm-ext-popup-menu-search'; // Add class for styling
        // Use 'input' event instead of directly re-rendering on every keystroke
        this.searchInput.addEventListener('input', () => {
            // Only re-render if the search term has actually changed
            if (this.searchInput.value !== this.lastSearchTerm) {
                this.lastSearchTerm = this.searchInput.value;
                this.renderMenuContent();
            }
        });
        // Handle keydown in search input to stop propagation for navigation keys
        this.searchInput.addEventListener('keydown', (event) => {
            console.log(`POPUP Search KeyDown: Key='${event.key}'`);
            // IMPORTANT: Prevent these keys from being captured by the document handler
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                console.log('POPUP (Search Input): Stopping propagation for navigation key:', event.key);
                if (event.key === 'Escape') {
                    // Handle Escape directly here
                    this.hidePopupMenu();
                }
                else if (event.key === 'Enter') {
                    // Maybe select first item on Enter?
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        this.selectedMenuItemIndex = 0;
                        this.updateSelectionHighlight();
                        // Optionally activate the item:
                        // menuItems[0].click(); 
                    }
                }
                else if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                    // Move to first/last menu item
                    // The blur() will be handled by main key handler
                }
                event.stopPropagation();
            }
            // CRITICAL: DO NOT stop propagation for Backspace or other text editing keys
            // This allows default behavior to work properly
        }, true); // Use capture phase
        document.addEventListener('click', this.handleDocumentClick.bind(this), true);
        // IMPORTANT: Use a separate bound function for the document keydown
        // so we can remove the exact same listener later
        this.boundHandleKeyDown = this.handleKeyDown.bind(this);
        document.addEventListener('keydown', this.boundHandleKeyDown, true);
        if (globals_1.globals.notebookTracker) {
            this.currentNotebook = globals_1.globals.notebookTracker.currentWidget;
            globals_1.globals.notebookTracker.currentChanged.connect((sender, notebook) => {
                this.currentNotebook = notebook;
            });
        }
    }
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick.bind(this), true);
        // Remove using the exact same bound function
        document.removeEventListener('keydown', this.boundHandleKeyDown, true);
        // Remove from widgetNode if attached
        if (this.popupMenuContainer.parentNode === this.widgetNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
    handleDocumentClick(event) {
        if (this.popupMenuContainer.style.display !== 'none' && !this.popupMenuContainer.contains(event.target)) {
            const atButton = this.widgetNode.querySelector('#jp-llm-ext-at-button');
            if (atButton && atButton.contains(event.target)) {
                console.log('POPUP: Click was on the @ button, not hiding.');
                return;
            }
            console.log('POPUP: Click detected outside the menu.');
            this.hidePopupMenu();
        }
    }
    async showPopupMenu(x, y) {
        console.log(`POPUP: Showing menu at (${x}, ${y})`);
        // Store the initial anchor point for positioning
        this._anchorX = x;
        this._anchorY = y;
        if (this.popupMenuContainer.style.display === 'none') {
            this.currentMenuLevel = 'top';
            this.currentMenuPath = '';
            this.menuHistory = [];
            this.searchInput.value = ''; // Clear search on show
            this.lastSearchTerm = ''; // Reset last search term
            await this.setCurrentDirectoryPath();
        }
        await this.renderMenuContent();
        // Ensure it's attached to the widget node if somehow detached
        this.widgetNode.appendChild(this.popupMenuContainer);
        // Position the popup menu - DEFER calculation slightly
        setTimeout(() => {
            console.log("POPUP: Deferred updatePopupPosition call.");
            try {
                this.updatePopupPosition();
            }
            catch (error) {
                console.error("POPUP: Error during deferred updatePopupPosition:", error);
            }
            // Focus the search input *after* positioning if in file/dir view
            // Otherwise, focus first menu item
            if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                this.searchInput.focus();
                console.log('POPUP: Focused search input after deferred positioning.');
                this.selectedMenuItemIndex = -1; // Don't select an item if search is focused
            }
            else { // Top level or cells
                this.selectedMenuItemIndex = -1;
                this.selectNextMenuItem(); // Select first item
                // Optionally focus the first item for immediate keyboard nav
                // const menuItems = this.getMenuItems();
                // if (menuItems.length > 0) menuItems[0].focus(); 
            }
        }, 0); // 0ms delay is usually sufficient
    }
    hidePopupMenu() {
        if (this.popupMenuContainer.style.display !== 'none') {
            console.log('POPUP: Hiding menu. Called from:', new Error().stack);
            this.popupMenuContainer.style.display = 'none';
            this.currentMenuLevel = 'top'; // Reset level
        }
    }
    async renderMenuContent() {
        // Prevent recursive renders
        if (this.isRenderingContent) {
            console.log('POPUP: Skipping render - already rendering');
            return;
        }
        this.isRenderingContent = true;
        try {
            // Clear existing content
            while (this.popupMenuContainer.firstChild) {
                this.popupMenuContainer.removeChild(this.popupMenuContainer.firstChild);
            }
            // Only add search input if NOT at top level
            if (this.currentMenuLevel !== 'top') {
                // Add search input at the top of the menu
                this.popupMenuContainer.appendChild(this.searchInput);
                this.searchInput.value = ''; // Clear for file/dir/cell levels
                this.lastSearchTerm = '';
            }
            // Render different menu content based on current level
            switch (this.currentMenuLevel) {
                case 'top':
                    this.renderTopLevelItems();
                    break;
                case 'files':
                case 'directories':
                    await this.renderDirectoryBrowserItems();
                    break;
                case 'cells':
                    await this.renderCellItems();
                    break;
            }
            // Reset selection after rendering
            this.selectedMenuItemIndex = -1;
            this.updateSelectionHighlight();
            // Update the position (might have changed due to content rendering)
            console.log("POPUP: ===> About to call updatePopupPosition after renderMenuContent");
            try {
                this.updatePopupPosition();
            }
            catch (err) {
                console.error("POPUP: Error calling updatePopupPosition after render:", err);
            }
        }
        catch (error) {
            console.error('POPUP: Error rendering menu content', error);
        }
        finally {
            this.isRenderingContent = false;
        }
    }
    renderTopLevelItems() {
        const topLevelCommands = [
            { label: 'Code', description: '', actionId: 'insert-code' },
            { label: 'Cells', description: '', actionId: 'browse-cells' },
            { label: 'File', description: '', actionId: 'browse-files' },
            { label: 'Directory', description: '', actionId: 'browse-directories' }
        ];
        topLevelCommands.forEach(cmd => {
            const item = this.createMenuItem(cmd.label, cmd.actionId, '', cmd.description);
            this.popupMenuContainer.appendChild(item);
        });
    }
    async renderDirectoryBrowserItems() {
        var _a;
        // Get search term
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        const loadingItem = this.createMenuItem('Loading...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        // Temporarily add loading item below search/path
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // If contents were already fetched recently and we're just filtering again,
            // we could potentially cache the results to avoid unnecessary API calls
            const filterType = this.currentMenuLevel === 'files' ? 'file' : 'directory';
            const contents = await this.listCurrentDirectoryContents(this.currentMenuPath, filterType);
            // Check if still in DOM before trying to remove
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (contents && contents.length > 0) {
                // Filter based on search term
                const filteredContents = contents.filter(item => {
                    return item.name.toLowerCase().includes(searchTerm) ||
                        item.relativePath.toLowerCase().includes(searchTerm);
                });
                if (filteredContents.length > 0) {
                    filteredContents.forEach(item => {
                        const itemName = item.name;
                        const itemType = item.type;
                        const itemPath = item.path;
                        const relativePath = item.relativePath;
                        const icon = itemType === 'directory' ? '📁' : '📄';
                        let actionId;
                        if (itemType === 'directory') {
                            actionId = this.currentMenuLevel === 'files' ? 'select-directory-navigate' : 'select-directory-callback';
                        }
                        else { // itemType === 'file'
                            actionId = 'select-file';
                        }
                        const menuItem = this.createMenuItem(`${icon} ${itemName}`, actionId, itemPath, relativePath !== '.' ? relativePath : '');
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                }
                else {
                    const emptyItem = this.createMenuItem(searchTerm ? 'No matches found' : `No ${filterType}s found`, 'empty', '', '');
                    emptyItem.style.pointerEvents = 'none';
                    this.popupMenuContainer.appendChild(emptyItem);
                }
            }
            else {
                const emptyItem = this.createMenuItem(`No items found in this directory`, 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
            }
        }
        catch (error) {
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading/filtering directory contents:', error);
        }
    }
    /**
     * Renders all cells from the current notebook
     */
    async renderCellItems() {
        var _a, _b;
        // Get search term for filtering
        const searchTerm = this.searchInput.value.toLowerCase().trim();
        // Create a loading indicator
        const loadingItem = this.createMenuItem('Loading cells...', 'loading', '', '');
        loadingItem.style.pointerEvents = 'none';
        const insertionPoint = (_a = this.popupMenuContainer.querySelector('.jp-llm-ext-popup-menu-path')) === null || _a === void 0 ? void 0 : _a.nextSibling;
        this.popupMenuContainer.insertBefore(loadingItem, insertionPoint || null);
        try {
            // Check if we have an active notebook
            if (!this.currentNotebook || !this.currentNotebook.content || !this.currentNotebook.content.model) {
                // Remove loading item
                if (this.popupMenuContainer.contains(loadingItem)) {
                    this.popupMenuContainer.removeChild(loadingItem);
                }
                const errorItem = this.createMenuItem('No active notebook found', 'error', '', '');
                errorItem.style.color = 'red';
                errorItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(errorItem);
                return;
            }
            const notebookModel = this.currentNotebook.content.model;
            const cells = notebookModel.cells;
            // Remove loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            if (!cells || cells.length === 0) {
                const emptyItem = this.createMenuItem('No cells in notebook', 'empty', '', '');
                emptyItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(emptyItem);
                return;
            }
            // Process and display each cell
            let filteredCellCount = 0;
            for (let i = 0; i < cells.length; i++) {
                const cell = cells.get(i);
                const cellType = cell.type;
                const cellContent = cell.sharedModel ? cell.sharedModel.getSource() :
                    (((_b = cell.toJSON()) === null || _b === void 0 ? void 0 : _b.source) || '');
                // Use type casting to avoid TypeScript errors
                const executionCount = cellType === 'code' ?
                    (cell.executionCount !== undefined && cell.executionCount !== null ?
                        cell.executionCount : '*') :
                    '';
                // Create a preview of the cell content (truncate if needed)
                const contentPreview = typeof cellContent === 'string' ?
                    cellContent :
                    (Array.isArray(cellContent) ? cellContent.join('\n') : '');
                const firstLine = contentPreview.split('\n')[0] || '';
                const truncatedContent = firstLine.length > 30 ?
                    firstLine.substring(0, 30) + '...' :
                    firstLine;
                // Create cell label with styled type indicator
                const typeIndicator = cellType === 'markdown' ? 'M' : 'C';
                const executionDisplay = executionCount !== '' ? `[${executionCount}]` : '';
                // Create menu item for this cell
                const cellItem = this.createMenuItem('', // Empty text, will be added as HTML
                'select-cell', i.toString() // Store cell index in path
                );
                // Create styled content with HTML elements
                const typeSpan = document.createElement('span');
                typeSpan.className = `cell-type-indicator cell-type-${cellType === 'markdown' ? 'md' : 'code'}`;
                typeSpan.textContent = typeIndicator;
                const execSpan = document.createElement('span');
                execSpan.className = 'cell-exec-count';
                execSpan.textContent = executionDisplay;
                execSpan.style.marginRight = '8px';
                const contentSpan = document.createElement('span');
                contentSpan.className = 'cell-content-preview';
                contentSpan.textContent = truncatedContent;
                // Get the label span (first child of the menu item)
                const labelSpan = cellItem.querySelector('span');
                if (labelSpan) {
                    labelSpan.textContent = ''; // Clear existing text
                    labelSpan.appendChild(typeSpan);
                    if (executionDisplay) {
                        labelSpan.appendChild(execSpan);
                    }
                    labelSpan.appendChild(contentSpan);
                }
                // Construct full searchable text
                const searchableText = `${typeIndicator} ${executionDisplay} ${truncatedContent}`.toLowerCase();
                // Filter by search term if one is provided
                if (searchTerm && !searchableText.includes(searchTerm)) {
                    continue;
                }
                this.popupMenuContainer.appendChild(cellItem);
                filteredCellCount++;
            }
            if (filteredCellCount === 0) {
                const noMatchItem = this.createMenuItem('No matching cells found', 'empty', '', '');
                noMatchItem.style.pointerEvents = 'none';
                this.popupMenuContainer.appendChild(noMatchItem);
            }
        }
        catch (error) {
            // Clean up loading indicator
            if (this.popupMenuContainer.contains(loadingItem)) {
                this.popupMenuContainer.removeChild(loadingItem);
            }
            const errorItem = this.createMenuItem(`Error: ${error}`, 'error', '', '');
            errorItem.style.color = 'red';
            errorItem.style.pointerEvents = 'none';
            this.popupMenuContainer.appendChild(errorItem);
            console.error('POPUP: Error loading notebook cells:', error);
        }
    }
    createMenuItem(text, actionId, path = '', description = '') {
        const item = document.createElement('div');
        item.className = 'jp-llm-ext-popup-menu-item';
        item.dataset.actionId = actionId;
        if (path) {
            item.dataset.path = path;
        }
        item.onclick = (event) => this.handleMenuClick(event);
        const labelSpan = document.createElement('span');
        labelSpan.textContent = text;
        item.appendChild(labelSpan);
        if (description) {
            const pathSpan = document.createElement('span');
            pathSpan.className = 'jp-llm-ext-popup-menu-path-indicator';
            pathSpan.textContent = description;
            pathSpan.style.fontSize = '0.85em';
            pathSpan.style.color = 'var(--jp-ui-font-color2)';
            pathSpan.style.marginLeft = '8px';
            pathSpan.style.opacity = '0.8';
            pathSpan.style.display = 'inline-block'; // Ensure the path is always displayed
            item.appendChild(pathSpan);
        }
        return item;
    }
    async handleMenuClick(event) {
        var _a;
        const target = event.currentTarget;
        const actionId = target.dataset.actionId;
        const path = target.dataset.path || '';
        console.log(`POPUP: Menu item clicked. Action: ${actionId}, Path: ${path}`);
        switch (actionId) {
            case 'navigate-back':
                this.navigateBackMenu();
                break;
            case 'insert-code': {
                const selectedText = this.callbacks.getSelectedText ? this.callbacks.getSelectedText() : null;
                if (selectedText) {
                    // Show submenu for code insertion options
                    const submenuItems = [
                        { label: 'Insert as plain code', actionId: 'insert-plain-code', data: selectedText },
                        { label: 'Insert as collapsed reference', actionId: 'collapse-code-ref', data: selectedText }
                    ];
                    // Replace current menu with submenu options
                    this.popupMenuContainer.innerHTML = '';
                    submenuItems.forEach(item => {
                        const menuItem = this.createMenuItem(item.label, item.actionId, item.data);
                        this.popupMenuContainer.appendChild(menuItem);
                    });
                    // Add back button
                    const backButton = this.createMenuItem('Back', 'navigate-back');
                    backButton.style.borderTop = '1px solid var(--jp-border-color1)';
                    this.popupMenuContainer.appendChild(backButton);
                    return; // Don't hide menu, wait for submenu selection
                }
                else {
                    const cellContent = this.callbacks.getCurrentCellContent ? this.callbacks.getCurrentCellContent() : null;
                    if (cellContent) {
                        this.callbacks.insertCode(cellContent);
                    }
                }
                this.hidePopupMenu();
                break;
            }
            case 'insert-plain-code': {
                if (path) {
                    this.callbacks.insertCode(path);
                    this.hidePopupMenu();
                }
                break;
            }
            case 'collapse-code-ref': {
                if (path && this.currentNotebook) {
                    try {
                        // Get notebook file name (without extension)
                        const notebookPath = this.currentNotebook.context.path;
                        const notebookName = ((_a = notebookPath.split('/').pop()) === null || _a === void 0 ? void 0 : _a.split('.')[0]) || 'notebook';
                        // Find current cell index and approximate line number
                        const currentCell = this.currentNotebook.content.activeCell;
                        if (!currentCell) {
                            throw new Error('No active cell found');
                        }
                        // Get current cell index
                        const currentCellIndex = this.currentNotebook.content.activeCellIndex;
                        // Estimate line number from cursor position
                        let lineNumber = 1; // Default to line 1
                        if (currentCell.editor) {
                            const editor = currentCell.editor;
                            const cursor = editor.getCursorPosition();
                            if (cursor) {
                                lineNumber = cursor.line + 1; // Convert to 1-indexed
                            }
                        }
                        // Invoke the callback with all the information needed
                        this.callbacks.insertCollapsedCodeRef(path, currentCellIndex, lineNumber, notebookName);
                        this.hidePopupMenu();
                    }
                    catch (error) {
                        console.error('Error creating collapsed code reference:', error);
                        // Fallback to inserting code directly
                        this.callbacks.insertCode(path);
                        this.hidePopupMenu();
                    }
                }
                else {
                    // If something went wrong or no path provided, just insert as regular code
                    if (path) {
                        this.callbacks.insertCode(path);
                    }
                    this.hidePopupMenu();
                }
                break;
            }
            case 'browse-cells':
                await this.navigateMenu('cells', '');
                this.searchInput.value = '';
                break;
            case 'browse-files':
                await this.navigateMenu('files', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'browse-directories':
                await this.navigateMenu('directories', this.currentMenuPath || '');
                // Clear search when changing view type
                this.searchInput.value = '';
                break;
            case 'select-cell':
                if (path) {
                    const cellIndex = parseInt(path);
                    if (!isNaN(cellIndex)) {
                        // Construct the reference text (e.g., "@Cell 3")
                        // const refText = `@Cell ${cellIndex + 1}`; // Use 1-based index for display
                        // console.log("TODO: Implement cell reference insertion: ", refText);
                        this.callbacks.insertCellByIndex(cellIndex); // Call the appropriate callback
                        this.hidePopupMenu();
                    }
                    else {
                        console.error('POPUP: Invalid cell index.');
                    }
                }
                else {
                    console.error('POPUP: Cell selected but index (path) is missing.');
                }
                break;
            case 'select-file':
                if (path) {
                    // Construct the reference text (e.g., "@file path/to/file.py")
                    // const refText = `@file ${path}`;
                    // console.log("TODO: Implement file reference insertion: ", refText);
                    this.callbacks.insertFilePath(path); // Call the appropriate callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: File selected but path is missing.');
                }
                break;
            case 'select-directory-navigate': // New action to navigate into dir when in file view
                if (path) {
                    // Clear the file cache for the specific directory to force a refresh
                    const cacheKey = `${path}:${this.currentMenuLevel === 'files' ? 'file' : 'directory'}`;
                    this.fileCache.delete(cacheKey);
                    // Make sure we're passing the correct level type
                    const level = (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') ?
                        this.currentMenuLevel : 'files';
                    await this.navigateMenu(level, path);
                    this.searchInput.value = ''; // Clear search on navigation
                }
                else {
                    console.error('POPUP: Directory selected for navigation but path is missing.');
                }
                break;
            case 'select-directory-callback': // New action to select dir when in directory view
                if (path) {
                    // Construct the reference text (e.g., "@dir path/to/directory")
                    // const refText = `@dir ${path}`;
                    // console.log("TODO: Implement directory reference insertion: ", refText);
                    this.callbacks.insertDirectoryPath(path); // Call the appropriate callback
                    this.hidePopupMenu();
                }
                else {
                    console.error('POPUP: Directory selected for callback but path is missing.');
                }
                break;
            case 'placeholder-action':
                console.log('Placeholder action triggered.');
                this.hidePopupMenu();
                break;
            case 'loading':
            case 'empty':
            case 'error':
                break;
            default:
                console.warn('Unknown menu action:', actionId);
                this.hidePopupMenu();
                break;
        }
        event.stopPropagation();
    }
    async navigateMenu(level, path) {
        console.log(`POPUP: Navigating to level: ${level}, path: ${path}`);
        // Only push history if we are actually moving to a new state
        if (this.currentMenuLevel !== level || this.currentMenuPath !== path) {
            this.menuHistory.push({ level: this.currentMenuLevel, path: this.currentMenuPath });
        }
        this.currentMenuLevel = level;
        this.currentMenuPath = path;
        // Don't clear search on programmatic navigation (like back button)
        // this.searchInput.value = ''; // Maybe keep search term?
        await this.renderMenuContent();
        // Focus search input after navigating to file/dir view
        if (level === 'files' || level === 'directories') {
            setTimeout(() => this.searchInput.focus(), 0);
            this.selectedMenuItemIndex = -1; // Reset selection
        }
        else {
            // Select first item if navigating back to top level
            this.selectedMenuItemIndex = -1;
            setTimeout(() => this.selectNextMenuItem(), 0);
        }
    }
    navigateBackMenu() {
        const previousState = this.menuHistory.pop();
        if (previousState) {
            console.log(`POPUP: Navigating back to level: ${previousState.level}, path: ${previousState.path}`);
            this.currentMenuLevel = previousState.level;
            this.currentMenuPath = previousState.path;
            // Don't clear search on back navigation
            this.renderMenuContent().then(() => {
                // Focus search input if going back to file/dir view
                if (this.currentMenuLevel === 'files' || this.currentMenuLevel === 'directories') {
                    setTimeout(() => this.searchInput.focus(), 0);
                    this.selectedMenuItemIndex = -1; // Reset selection
                }
                else {
                    // Select first item if going back to top level
                    this.selectedMenuItemIndex = -1;
                    setTimeout(() => this.selectNextMenuItem(), 0);
                }
            });
        }
        else {
            console.log('POPUP: Already at the top level.');
            this.hidePopupMenu();
        }
    }
    async listCurrentDirectoryContents(basePath, filterType) {
        console.log(`POPUP: Listing directory contents for path: '${basePath}', filter: ${filterType || 'all'}`);
        // Check cache first
        const cacheKey = `${basePath}:${filterType || 'all'}`;
        if (this.fileCache.has(cacheKey)) {
            console.log('POPUP: Using cached directory contents');
            return this.fileCache.get(cacheKey) || null;
        }
        try {
            const effectivePath = basePath === '/' ? '' : basePath;
            // Ensure trailing slash removed for consistency unless it's root
            const pathForApi = effectivePath.endsWith('/') && effectivePath.length > 1 ? effectivePath.slice(0, -1) : effectivePath;
            // Result array that will hold all files and directories
            let allResults = [];
            // Get the base directory contents (non-recursive)
            const baseContents = await this.docManager.services.contents.get(pathForApi || '');
            if (baseContents.type !== 'directory') {
                console.error('Path is not a directory:', basePath);
                return null;
            }
            // Process base directory items
            for (const item of baseContents.content) {
                const itemType = item.type === 'directory' ? 'directory' : 'file';
                // Add directories if we're listing directories or both
                if (itemType === 'directory' && (filterType === 'directory' || filterType === undefined)) {
                    allResults.push({
                        name: item.name,
                        path: item.path,
                        type: 'directory',
                        relativePath: `./${item.name}`
                    });
                }
                // Add files if we're listing files and the extension is allowed
                if (itemType === 'file' && (filterType === 'file' || filterType === undefined)) {
                    const fileExt = `.${item.name.split('.').pop()}`.toLowerCase();
                    if (this.allowedExtensions.includes(fileExt)) {
                        allResults.push({
                            name: item.name,
                            path: item.path,
                            type: 'file',
                            relativePath: `./${item.name}`
                        });
                    }
                }
            }
            // Sort the results appropriately
            allResults = allResults.sort((a, b) => {
                // If listing directories only, sort alphabetically
                if (filterType === 'directory') {
                    return a.name.localeCompare(b.name);
                }
                // If listing files only, sort alphabetically
                if (filterType === 'file') {
                    return a.name.localeCompare(b.name);
                }
                // If listing both, sort directories first, then files alphabetically
                if (a.type === 'directory' && b.type !== 'directory')
                    return -1;
                if (a.type !== 'directory' && b.type === 'directory')
                    return 1;
                return a.name.localeCompare(b.name);
            });
            // Cache the results for future use
            this.fileCache.set(cacheKey, allResults);
            console.log(`POPUP: Found ${allResults.length} items for path '${basePath}'`);
            return allResults;
        }
        catch (error) {
            console.error(`POPUP: Error listing directory contents for '${basePath}':`, error);
            return null;
        }
    }
    async setCurrentDirectoryPath() {
        var _a;
        let dirPath = null;
        const app = globals_1.globals.app;
        if (!app) {
            console.error('POPUP: Application reference not available');
            this.currentMenuPath = '';
            return;
        }
        const currentShellWidget = app.shell.currentWidget;
        if (currentShellWidget) {
            const widgetContext = this.docManager.contextForWidget(currentShellWidget);
            if (widgetContext) {
                const path = widgetContext.path;
                dirPath = this.getParentDirectory(path);
                console.log(`POPUP: Path from current widget context: ${path} -> ${dirPath}`);
            }
        }
        if (dirPath === null && this.currentNotebook && this.currentNotebook.context) {
            const notebookPath = this.currentNotebook.context.path;
            if (typeof notebookPath === 'string') {
                dirPath = this.getParentDirectory(notebookPath);
                console.log(`POPUP: Path from active notebook: ${notebookPath} -> ${dirPath}`);
            }
        }
        if (dirPath === null) {
            try {
                const leftWidgets = Array.from(app.shell.widgets('left'));
                const fileBrowserWidget = leftWidgets.find(widget => widget.id === 'filebrowser');
                if (fileBrowserWidget && typeof ((_a = fileBrowserWidget.model) === null || _a === void 0 ? void 0 : _a.path) === 'string') {
                    dirPath = fileBrowserWidget.model.path;
                    console.log(`POPUP: Path from file browser widget model: ${dirPath}`);
                }
                else {
                    console.log('POPUP: File browser widget path not directly accessible.');
                }
            }
            catch (e) {
                console.warn('POPUP: Could not get path from file browser.', e);
            }
        }
        if (dirPath === null) {
            dirPath = '';
            console.log('POPUP: Falling back to server root path.');
        }
        this.currentMenuPath = dirPath;
        console.log(`POPUP: Initial current menu path set to: '${this.currentMenuPath}'`);
    }
    getParentDirectory(path) {
        if (!path)
            return '';
        const lastSlash = Math.max(path.lastIndexOf('/'), path.lastIndexOf('\\'));
        if (lastSlash === -1)
            return ''; // No directory part, likely root or just a filename
        return path.substring(0, lastSlash);
    }
    /**
     * Handle keyboard navigation when the popup menu is shown
     */
    handleKeyDown(event) {
        // Only handle keys if the popup is visible
        if (!this.isPopupMenuVisible()) {
            return;
        }
        console.log(`POPUP Document KeyDown: Key='${event.key}', Target=`, event.target);
        // Allow default browser search behavior (e.g., Cmd+F)
        if (event.metaKey || event.ctrlKey) {
            return;
        }
        // If focus is inside the search input, let its handler manage navigation keys
        if (event.target === this.searchInput) {
            console.log('POPUP (Document): Key event target is search input, skipping document handler.');
            // Allow Backspace etc. to work naturally in search input
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                // Let the search input's keydown handle Escape, stop propagation
                // But let the main handler process Up/Down/Enter/Tab by blurring
                if (event.key === 'ArrowUp' || event.key === 'ArrowDown') {
                    // Trigger blur to shift focus to menu items
                    this.searchInput.blur();
                    // Prevent default scrolling behavior
                    event.preventDefault();
                    // Process the key event now in the menu context
                    this.processMenuNavigation(event.key);
                }
                else if (event.key === 'Enter') {
                    this.searchInput.blur();
                    event.preventDefault();
                    this.processMenuNavigation(event.key);
                }
                else if (event.key === 'Tab') {
                    // Allow tabbing away (or maybe cycle focus?)
                    this.searchInput.blur();
                    // Don't prevent default - allow tabbing
                }
                else if (event.key === 'Escape') {
                    // Already handled by searchInput's listener, just stop propagation
                    event.stopPropagation();
                }
            }
            else {
                // Allow other keys (typing) in the search input
                return;
            }
        }
        else {
            // Focus is NOT in the search input, process normally
            this.processMenuNavigation(event.key);
            // Prevent default browser actions for these keys when menu is active
            if (['ArrowUp', 'ArrowDown', 'Enter', 'Tab', 'Escape'].includes(event.key)) {
                event.preventDefault();
                event.stopPropagation();
            }
        }
    }
    processMenuNavigation(key) {
        switch (key) {
            case 'ArrowDown':
                console.log('POPUP: Arrow Down pressed');
                this.selectNextMenuItem();
                break;
            case 'ArrowUp':
                console.log('POPUP: Arrow Up pressed');
                this.selectPreviousMenuItem();
                break;
            case 'Enter':
            case 'Tab': // Treat Tab like Enter for selection
                console.log(`POPUP: ${key} pressed`);
                if (this.selectedMenuItemIndex >= 0) {
                    const menuItems = this.getMenuItems();
                    if (menuItems[this.selectedMenuItemIndex]) {
                        console.log('POPUP: Simulating click on selected item:', menuItems[this.selectedMenuItemIndex].textContent);
                        // Simulate click to trigger handleMenuClick
                        menuItems[this.selectedMenuItemIndex].click();
                    }
                    else {
                        console.log('POPUP: Selected index out of bounds?');
                    }
                }
                else {
                    console.log('POPUP: Enter/Tab pressed but no item selected');
                    // If no item is selected, maybe select the first one and activate?
                    const menuItems = this.getMenuItems();
                    if (menuItems.length > 0) {
                        menuItems[0].click(); // Activate first item
                    }
                }
                break;
            case 'Escape':
                console.log('POPUP: Escape pressed');
                // If in a submenu, navigate back; otherwise, hide.
                if (this.menuHistory.length > 0) {
                    this.navigateBackMenu();
                }
                else {
                    this.hidePopupMenu();
                }
                break;
        }
    }
    updateSelectionHighlight() {
        const menuItems = this.getMenuItems();
        menuItems.forEach((item, index) => {
            if (index === this.selectedMenuItemIndex) {
                item.classList.add('jp-llm-ext-popup-menu-item-selected');
                // Scroll into view if necessary
                item.scrollIntoView({ block: 'nearest' });
            }
            else {
                item.classList.remove('jp-llm-ext-popup-menu-item-selected');
            }
        });
    }
    deselectAllMenuItems() {
        const menuItems = this.getMenuItems();
        menuItems.forEach(item => {
            item.classList.remove('jp-llm-ext-popup-menu-item-selected');
        });
        this.selectedMenuItemIndex = -1;
    }
    selectNextMenuItem() {
        const menuItems = this.getMenuItems();
        if (menuItems.length === 0)
            return;
        this.selectedMenuItemIndex++;
        if (this.selectedMenuItemIndex >= menuItems.length) {
            this.selectedMenuItemIndex = 0; // Wrap around
        }
        this.updateSelectionHighlight();
        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);
    }
    selectPreviousMenuItem() {
        const menuItems = this.getMenuItems();
        if (menuItems.length === 0)
            return;
        this.selectedMenuItemIndex--;
        if (this.selectedMenuItemIndex < 0) {
            this.selectedMenuItemIndex = menuItems.length - 1; // Wrap around
        }
        this.updateSelectionHighlight();
        console.log(`POPUP: Selected item index: ${this.selectedMenuItemIndex}`);
    }
    /**
     * Get all interactive menu items currently displayed
     */
    getMenuItems() {
        return Array.from(this.popupMenuContainer.querySelectorAll('.jp-llm-ext-popup-menu-item'));
    }
    /**
     * Updates the position of the popup menu based on the active reference range
     * or the initial anchor point. Tries to position the BOTTOM of the menu
     * just ABOVE the range/anchor.
     */
    updatePopupPosition() {
        if (!this.widgetNode)
            return;
        const widgetRect = this.widgetNode.getBoundingClientRect();
        let targetTop;
        let targetLeft;
        // Use the anchor coordinates provided (now from the reliable temp span)
        if (this._anchorX !== undefined && this._anchorY !== undefined) {
            console.log(`POPUP: Positioning based on anchor point: (${this._anchorX}, ${this._anchorY})`);
            // Target position relative to viewport
            targetTop = this._anchorY;
            targetLeft = this._anchorX;
        }
        else {
            console.warn("POPUP: Cannot update position - no anchor point provided.");
            return;
        }
        // Make sure the popup is visible and rendered to get its height
        this.popupMenuContainer.style.visibility = 'hidden'; // Keep it hidden while calculating
        this.popupMenuContainer.style.display = 'block';
        const popupHeight = this.popupMenuContainer.offsetHeight;
        const popupWidth = this.popupMenuContainer.offsetWidth;
        // Calculate desired 'top' style relative to the widgetNode
        // Position the bottom of the popup just above the target's top
        let top = (targetTop - widgetRect.top) - popupHeight;
        // Calculate desired 'left' style relative to the widgetNode
        let left = targetLeft - widgetRect.left;
        // --- Boundary checks (relative to widget) ---
        const widgetClientWidth = this.widgetNode.clientWidth; // Use clientWidth for inner width
        const widgetClientHeight = this.widgetNode.clientHeight;
        // Prevent going off the left edge of the widget
        if (left < 0) {
            left = 5; // Small padding
            console.log("POPUP Adjust: Corrected left edge");
        }
        // Prevent going off the right edge of the widget
        if (left + popupWidth > widgetClientWidth) {
            left = widgetClientWidth - popupWidth - 5; // Adjust left, add padding
            console.log("POPUP Adjust: Corrected right edge");
        }
        // Prevent going off the top edge of the widget
        if (top < 0) {
            // If it goes off the top, try positioning it *below* the target instead
            const spaceBelow = widgetClientHeight - (targetTop - widgetRect.top + 10); // Space below target
            if (spaceBelow >= popupHeight) {
                top = (targetTop - widgetRect.top) + 10; // Position below target with padding
                console.log("POPUP Adjust: Flipping below target (was off top)");
            }
            else {
                // Not enough space below either, clamp to top
                top = 5; // Small padding from top
                console.log("POPUP Adjust: Clamped to top edge (no space below)");
            }
        }
        console.log(`POPUP: Setting position - Top: ${top}px, Left: ${left}px (Relative to Widget)`);
        this.popupMenuContainer.style.top = `${top}px`;
        this.popupMenuContainer.style.left = `${left}px`;
        // Make it visible again
        this.popupMenuContainer.style.display = 'block';
        this.popupMenuContainer.style.visibility = 'visible';
    }
    /**
     * Checks if the popup menu is currently visible.
     */
    isPopupMenuVisible() {
        return this.popupMenuContainer.style.display !== 'none';
    }
    /**
     * Gets the current level of the popup menu.
     */
    getCurrentMenuLevel() {
        return this.currentMenuLevel;
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsHandler = void 0;
/**
 * Handles the logic related to the settings modal:
 * displaying, hiding, populating, saving, and showing feedback.
 */
class SettingsHandler {
    constructor(state, settingsModalContainer, uiManager // Pass UIManager for notifications
    ) {
        this.state = state;
        this.settingsModalContainer = settingsModalContainer;
        this.uiManager = uiManager;
    }
    /**
     * Populates the settings form with current values and displays the modal.
     */
    showModal() {
        const currentSettings = this.state.getSettings();
        if (currentSettings) {
            try {
                // Query elements within the modal container
                this.settingsModalContainer.querySelector('#settings-provider').value = currentSettings.provider;
                this.settingsModalContainer.querySelector('#settings-api-key').value = currentSettings.apiKey;
                this.settingsModalContainer.querySelector('#settings-api-url').value = currentSettings.apiUrl;
                this.settingsModalContainer.querySelector('#settings-rules').value = currentSettings.rules;
            }
            catch (error) {
                console.error('Error populating settings form:', error);
                // Optionally show an error to the user
            }
        }
        this.settingsModalContainer.style.display = 'flex';
    }
    /**
     * Hides the settings modal.
     */
    hideModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    /**
     * Reads values from the form, saves them using SettingsState,
     * updates the ApiClient, hides the modal, and shows a success notification.
     * This method is intended to be called by the modal's save button listener.
     */
    saveSettings() {
        var _a, _b, _c, _d;
        // Get values from form fields within the modal container
        const provider = (_a = this.settingsModalContainer.querySelector('#settings-provider')) === null || _a === void 0 ? void 0 : _a.value;
        const key = (_b = this.settingsModalContainer.querySelector('#settings-api-key')) === null || _b === void 0 ? void 0 : _b.value;
        const url = (_c = this.settingsModalContainer.querySelector('#settings-api-url')) === null || _c === void 0 ? void 0 : _c.value;
        const rules = (_d = this.settingsModalContainer.querySelector('#settings-rules')) === null || _d === void 0 ? void 0 : _d.value;
        // Basic validation
        if (provider === undefined || key === undefined || url === undefined || rules === undefined) {
            console.error("Could not find all settings input elements.");
            this.showNotification('Error: Could not save settings. Input elements missing.', 'error');
            return;
        }
        const settings = { provider, apiKey: key, apiUrl: url, rules };
        try {
            // Save settings using SettingsState
            this.state.saveSettings(settings);
            console.log('Settings saved via SettingsState:', settings);
            // Reconfigure ApiClient instance
            // TODO: The ApiClient should ideally observe the SettingsState 
            // or have a dedicated update method instead of creating a new instance.
            // For now, we assume the main widget will recreate/update the ApiClient 
            // or pass an update callback.
            // Example: this.apiClient.updateConfig(settings.apiUrl || undefined);
            console.log('API Client needs reconfiguration with new settings.');
            this.hideModal();
            this.showNotification('Settings saved successfully', 'success');
        }
        catch (error) {
            console.error('Error saving settings:', error);
            this.showNotification(`Error saving settings: ${error}`, 'error');
        }
    }
    /**
     * Displays a temporary notification message.
     * Relies on UIManager to provide the actual notification mechanism.
     */
    showNotification(message, type) {
        // Delegate notification display to UIManager or a dedicated notification service
        if (this.uiManager && typeof this.uiManager.showNotification === 'function') {
            this.uiManager.showNotification(message, type);
        }
        else {
            // Fallback or log if UIManager doesn't support notifications yet
            console.log(`Notification (${type}): ${message}`);
            // The old popSaveSuccess logic requires direct access to the widget node,
            // which this handler shouldn't have. This needs to be handled by the UI layer.
        }
    }
}
exports.SettingsHandler = SettingsHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.setupShortcuts = setupShortcuts;
exports.removeShortcuts = removeShortcuts;
const notebook_integration_1 = __webpack_require__(/*! ../utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
let _handleKeyDown = null;
/**
 * Sets up global keyboard shortcuts for the extension.
 *
 * @param inputHandler Instance of InputHandler to interact with input state/methods.
 * @param popupMenuManager Instance of PopupMenuManager.
 * @param callbacks Object containing callback functions for UI interactions.
 */
function setupShortcuts(inputHandler, // Pass InputHandler instance directly
popupMenuManager, callbacks) {
    if (_handleKeyDown) {
        console.warn('Shortcuts already set up. Removing previous listener.');
        removeShortcuts();
    }
    _handleKeyDown = (event) => {
        const { showIndicator, appendToInput, showWidget, focusInput } = callbacks;
        // Check for @ key - event.key should correctly report '@' even with Shift
        // Also check for SHIFT+2 as an alternative way to trigger '@'
        if (event.key === '@' || (event.shiftKey && event.key === '2')) {
            console.log("SHORTCUT HANDLER: '@' key or SHIFT+2 detected");
            const inputField = document.activeElement;
            const isContentEditableInput = inputField &&
                inputField.getAttribute('contenteditable') === 'true' &&
                inputField.classList.contains('jp-llm-ext-input-field');
            // Handle the case where the input field is NOT the active element first
            if (isContentEditableInput) {
                console.log("SHORTCUT HANDLER: Input field IS active element. Letting default behavior proceed.");
                // If not in our input field, prevent default, show widget, focus, insert '@', and show popup.
                event.preventDefault();
                event.stopPropagation();
                showWidget();
                focusInput();
                // After focus, show popup via window.setTimeout to ensure input is ready
                window.setTimeout(() => {
                    const inputElement = document.querySelector('.jp-llm-ext-input-field');
                    if (inputElement) {
                        const selection = window.getSelection();
                        if (selection) { // Check if selection exists (even if rangeCount is 0 initially)
                            // Ensure the input field has focus *before* manipulating the range
                            if (document.activeElement !== inputElement) {
                                inputElement.focus(); // Re-focus just in case
                            }
                            // Create or get the range
                            let range;
                            if (selection.rangeCount > 0) {
                                range = selection.getRangeAt(0);
                                // Double-check if the focus is now correctly inside the input element
                                if (!inputElement.contains(range.commonAncestorContainer)) {
                                    console.log("SHORTCUT HANDLER: Range is not inside the input field after focus. Creating new range.");
                                    // If range is not inside, create a new one collapsed at the end
                                    range = document.createRange();
                                    range.selectNodeContents(inputElement);
                                    range.collapse(false); // Collapse to the end
                                    selection.removeAllRanges();
                                    selection.addRange(range);
                                }
                            }
                            else {
                                // If no range exists, create one collapsed at the end
                                console.log("SHORTCUT HANDLER: No range found after focus. Creating new range.");
                                range = document.createRange();
                                range.selectNodeContents(inputElement);
                                range.collapse(false); // Collapse to the end
                                selection.removeAllRanges();
                                selection.addRange(range);
                            }
                            // Manually insert '@' since we prevented default
                            const atNode = document.createTextNode('@');
                            range.deleteContents(); // Clear any selection just in case
                            range.insertNode(atNode);
                            // Move cursor after the inserted '@'
                            range.setStartAfter(atNode);
                            range.setEndAfter(atNode);
                            selection.removeAllRanges(); // Update selection to the new cursor position
                            selection.addRange(range);
                            // **NESTED TIMEOUT:** Give browser time to render before getting range position
                            window.setTimeout(() => {
                                console.log("SHORTCUT HANDLER: Showing popup after focusing, inserting '@', and nested timeout.");
                                // Ensure we get the most up-to-date range reference
                                const currentSelection = window.getSelection();
                                if (currentSelection && currentSelection.rangeCount > 0) {
                                    const currentRange = currentSelection.getRangeAt(0);
                                    // --- Insert temporary span to get reliable coords --- 
                                    const tempAnchorId = 'jp-llm-shortcut-popup-anchor';
                                    let tempSpan = document.getElementById(tempAnchorId);
                                    if (tempSpan)
                                        tempSpan.remove(); // Clean up previous
                                    tempSpan = document.createElement('span');
                                    tempSpan.id = tempAnchorId;
                                    tempSpan.style.visibility = 'hidden';
                                    tempSpan.style.width = '0';
                                    tempSpan.style.overflow = 'hidden';
                                    tempSpan.textContent = '\u200B'; // Zero-width space
                                    currentRange.insertNode(tempSpan); // Insert at cursor
                                    const spanRect = tempSpan.getBoundingClientRect();
                                    tempSpan.remove(); // Remove immediately
                                    // --- End temporary span logic ---
                                    if (spanRect.top === 0 && spanRect.left === 0) {
                                        console.error("SHORTCUT HANDLER: Failed to get valid coordinates from temp anchor span.");
                                    }
                                    else {
                                        console.log(`SHORTCUT HANDLER: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);
                                        popupMenuManager.showPopupMenu(spanRect.left, spanRect.top);
                                        showIndicator('Browsing references...');
                                    }
                                }
                                else {
                                    console.error("SHORTCUT HANDLER: Could not get range immediately before showing popup.");
                                }
                            }, 0); // 0ms delay is often sufficient
                        }
                        else {
                            console.log("SHORTCUT HANDLER: No selection object after focus, cannot insert '@' or show popup reliably.");
                        }
                    }
                    else {
                        console.log("SHORTCUT HANDLER: Could not find input element after timeout.");
                    }
                }, 50); // Outer timeout remains 50ms
            }
            else {
                console.log("SHORTCUT HANDLER: Input field is NOT active element. Handling '@' globally.");
                // If the input field is already focused, DO NOTHING here.
                // The default browser behavior will insert the '@'.
                // The 'input' event listener in UIManager will then detect the '@'
                // and trigger the popup via handleInputForReference.
                // We do NOT preventDefault or stopPropagation.
            }
        }
        // Check for Ctrl+L (insert selection or cell)
        else if (event.ctrlKey && event.key.toLowerCase() === 'l') {
            event.preventDefault();
            event.stopPropagation();
            const selected = (0, notebook_integration_1.getSelectedText)();
            if (selected) {
                appendToInput(`@code ${selected}`); // Use callback
                showIndicator('Selected code inserted');
            }
            else {
                const cellContent = (0, notebook_integration_1.getCurrentCellContent)();
                if (cellContent) {
                    appendToInput(`@cell ${cellContent}`); // Use callback
                    showIndicator('Cell content inserted');
                }
            }
            // Ensure the sidebar is visible and input is focused
            showWidget(); // Use callback
            focusInput(); // Use callback
        }
    };
    // Add the event listener to the document
    document.addEventListener('keydown', _handleKeyDown);
}
/**
 * Removes the global keyboard shortcut listener.
 */
function removeShortcuts() {
    if (_handleKeyDown) {
        document.removeEventListener('keydown', _handleKeyDown);
        _handleKeyDown = null;
        console.log('Removed keyboard shortcuts.');
    }
    else {
        console.warn('Attempted to remove shortcuts, but none were active.');
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
const sidebar_widget_1 = __webpack_require__(/*! ./sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// import { ApiClient } from './api-client';
// Import the main CSS file
__webpack_require__(/*! ../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./core/api-client */ "./node_modules/jupyter-simple-extension/lib/core/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/sidebar-widget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/sidebar-widget.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const icons_1 = __webpack_require__(/*! ./core/icons */ "./node_modules/jupyter-simple-extension/lib/core/icons.js");
const api_client_1 = __webpack_require__(/*! ./core/api-client */ "./node_modules/jupyter-simple-extension/lib/core/api-client.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./handlers/popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/handlers/popup-menu-manager.js");
const shortcut_handler_1 = __webpack_require__(/*! ./handlers/shortcut-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/shortcut-handler.js");
const layout_builder_1 = __webpack_require__(/*! ./ui/layout-builder */ "./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js");
const settings_modal_1 = __webpack_require__(/*! ./ui/settings-modal */ "./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js");
const chat_state_1 = __webpack_require__(/*! ./state/chat-state */ "./node_modules/jupyter-simple-extension/lib/state/chat-state.js");
const settings_state_1 = __webpack_require__(/*! ./state/settings-state */ "./node_modules/jupyter-simple-extension/lib/state/settings-state.js");
const input_handler_1 = __webpack_require__(/*! ./handlers/input-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/input-handler.js");
const message_handler_1 = __webpack_require__(/*! ./handlers/message-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/message-handler.js");
const history_handler_1 = __webpack_require__(/*! ./handlers/history-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/history-handler.js");
const settings_handler_1 = __webpack_require__(/*! ./handlers/settings-handler */ "./node_modules/jupyter-simple-extension/lib/handlers/settings-handler.js");
const ui_manager_1 = __webpack_require__(/*! ./ui/ui-manager */ "./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js");
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
const globals_1 = __webpack_require__(/*! ./core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
// --- Import Utility Functions ---
const clipboard_1 = __webpack_require__(/*! ./utils/clipboard */ "./node_modules/jupyter-simple-extension/lib/utils/clipboard.js");
const notebook_integration_1 = __webpack_require__(/*! ./utils/notebook-integration */ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js");
/**
 * Main sidebar widget for the AI chat interface - Now acts as an orchestrator.
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    /**
     * Helper function to replace a text range with a non-editable widget span.
     */
    createWidgetSpan(range, refText) {
        if (!range)
            return;
        // Extract a display-friendly version (e.g., filename from path)
        let displayLabel = refText;
        if (refText.startsWith('@file ') || refText.startsWith('@dir ')) {
            const parts = refText.split(' ');
            if (parts.length > 1) {
                const pathParts = parts[1].split(/[\\/]/);
                displayLabel = pathParts[pathParts.length - 1] || parts[1]; // Use last part of path or full path
            }
        }
        else if (refText.startsWith('@Cell ')) {
            displayLabel = refText.substring(1); // Remove leading '@'
        } // Add more conditions for other types if needed
        // Create the widget span
        const span = document.createElement('span');
        span.className = 'jp-llm-ext-ref-widget'; // Class for styling
        span.setAttribute('contenteditable', 'false'); // Make it non-editable
        span.setAttribute('data-ref-text', refText); // Store original text for serialization
        span.textContent = displayLabel; // Set visible text
        // Replace the range content with the span
        range.deleteContents();
        range.insertNode(span);
        // Move cursor after the inserted span
        const selection = window.getSelection();
        if (selection) {
            const newRange = document.createRange();
            newRange.setStartAfter(span);
            newRange.setEndAfter(span);
            selection.removeAllRanges();
            selection.addRange(newRange);
        }
    }
    constructor(docManager) {
        super();
        // Placeholder for handler methods used in UIManager callbacks
        this.handleNewChat = () => {
            var _a;
            console.log('Handle New Chat clicked');
            const newChat = this.chatState.createNewChat();
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);
        };
        this.handleToggleHistory = () => {
            console.log('Handle Toggle History clicked');
            this.historyHandler.toggleHistoryView();
        };
        this.handleSendMessage = (message) => {
            // 1. Get the current text from the input field via UIManager or LayoutElements
            // const text = this.layoutElements.inputField.value; // No longer needed, text is passed in
            if (!message.trim())
                return; // Don't send empty messages (check the passed message)
            // 2. Get the markdown state from UIManager - REMOVED
            // const isMarkdown = this.uiManager.getIsMarkdownMode(); 
            console.log(`[Widget] handleSendMessage: Text='${message}'`); // Debug log using passed message
            // 3. Call the MessageHandler's send method with text and state
            this.messageHandler.handleSendMessage(message); // Pass the received message - REMOVED isMarkdown
            // NOTE: Input clearing is now handled by UIManager after this callback returns.
            // Do NOT clear input here or in MessageHandler.
        };
        this.handleShowSettings = (event) => {
            console.log('Handle Show Settings clicked');
            this.settingsHandler.showModal();
        };
        this.handleShowPopupMenu = (event, targetButton) => {
            console.log('Handle Show Popup Menu clicked');
            const rect = targetButton.getBoundingClientRect();
            this.popupMenuManager.showPopupMenu(rect.left, rect.bottom + 5);
        };
        this.handleUpdateTitle = () => {
            var _a;
            const newTitle = ((_a = this.layoutElements.titleInput) === null || _a === void 0 ? void 0 : _a.value) || 'Chat';
            console.log('Handle Update Title called:', newTitle);
            this.chatState.updateCurrentChatTitle(newTitle);
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        this.addClass('jp-llm-ext-sidebar');
        // --- 1. Initialize Core Components & State ---
        this.settingsState = new settings_state_1.SettingsState();
        const initialSettings = this.settingsState.getSettings();
        this.apiClient = new api_client_1.ApiClient((initialSettings === null || initialSettings === void 0 ? void 0 : initialSettings.apiUrl) || undefined);
        this.chatState = new chat_state_1.ChatState();
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.docManager, this.node, {
            insertCode: (code) => {
                var _a, _b, _c;
                if (!this.inputHandler || !globals_1.globals.notebookTracker)
                    return;
                const currentNotebookPanel = globals_1.globals.notebookTracker.currentWidget;
                if (!currentNotebookPanel || !currentNotebookPanel.context || !currentNotebookPanel.content) {
                    console.warn('Could not get notebook context for code reference, inserting raw code as fallback.');
                    (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(code);
                    return;
                }
                const notebookPath = currentNotebookPanel.context.path;
                const notebookName = ((_b = notebookPath.split('/').pop()) === null || _b === void 0 ? void 0 : _b.split('.')[0]) || 'notebook';
                const currentCell = currentNotebookPanel.content.activeCell;
                if (!currentCell) {
                    console.warn('Could not get active cell for code reference, inserting raw code as fallback.');
                    (_c = this.inputHandler) === null || _c === void 0 ? void 0 : _c.appendToInput(code);
                    return;
                }
                const cellIndex = currentNotebookPanel.content.activeCellIndex;
                let lineNumber = 1; // Default line number
                let lineEndNumber = 1; // Default end line number
                // --- DEBUG LOG --- 
                console.log('Are we currently in a code cell?');
                // check if currentCell is in editor 
                console.log(currentCell.editor);
                // --- END DEBUG LOG ---
                if (currentCell.editor) {
                    const editor = currentCell.editor;
                    const cmEditor = editor.editor; // Access CodeMirror editor instance (EditorView)
                    if (cmEditor && cmEditor.state) {
                        const state = cmEditor.state;
                        const selection = state.selection.main;
                        if (!selection.empty) {
                            lineNumber = state.doc.lineAt(selection.from).number; // 1-based start line
                            lineEndNumber = state.doc.lineAt(selection.to).number; // 1-based end line
                        }
                        else {
                            // Fallback for cursor position if no selection
                            const cursor = editor.getCursorPosition();
                            if (cursor) {
                                lineNumber = cursor.line + 1; // 1-based line number
                                lineEndNumber = lineNumber; // Start and end are the same for cursor
                            }
                        }
                    }
                    else {
                        // Fallback if cmEditor or state is not available (should not happen often)
                        console.warn('Could not access CodeMirror state for line numbers.');
                        const cursor = editor.getCursorPosition();
                        if (cursor) {
                            lineNumber = cursor.line + 1;
                            lineEndNumber = lineNumber;
                        }
                    }
                }
                else {
                    console.warn('Could not access cell editor for line numbers.');
                    // Keep default line numbers 1, 1 if editor is not available
                }
                // --- DEBUG LOG --- 
                console.log(`[SimpleSidebarWidget.insertCode] Determined lines: Start=${lineNumber}, End=${lineEndNumber}`);
                // --- END DEBUG LOG ---
                // Pass both start and end line numbers
                const refId = this.inputHandler.addCodeReference(code, notebookName, cellIndex, lineNumber, lineEndNumber);
                const placeholder = `@code[${refId}]`;
                this.inputHandler.appendToInput(placeholder);
            },
            insertCell: (content) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@cell ${content}`); },
            insertFilePath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@file[${path}]`); },
            insertDirectoryPath: (path) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(`@dir[${path}]`); },
            getSelectedText: notebook_integration_1.getSelectedText,
            getCurrentCellContent: notebook_integration_1.getCurrentCellContent,
            insertCellByIndex: (index) => {
                var _a;
                const oneBasedIndex = index + 1;
                const refText = `@Cell[${oneBasedIndex}]`;
                (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(refText);
            },
            insertCollapsedCodeRef: (code, cellIndex, lineNumber, notebookName) => {
                // Handle reference from cursor position (assume start/end line are the same)
                if (!this.inputHandler)
                    return;
                const lineEndNumber = lineNumber; // Start and end are the same for a single line reference
                const refId = this.inputHandler.addCodeReference(code, notebookName, cellIndex, lineNumber, lineEndNumber);
                const placeholder = `@code[${refId}]`;
                this.inputHandler.appendToInput(placeholder);
            }
        });
        // --- 2. Define Callbacks (used by buildLayout and Handlers) ---
        // Callbacks for UI actions (passed to buildLayout)
        const createNewChatCallback = () => {
            var _a;
            const newChat = this.chatState.createNewChat();
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.loadChat(newChat.id);
        };
        const toggleHistoryCallback = () => {
            var _a;
            (_a = this.historyHandler) === null || _a === void 0 ? void 0 : _a.toggleHistoryView();
        };
        const showSettingsCallback = () => {
            var _a;
            (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.showModal();
        };
        const updateTitleCallback = (newTitle) => {
            var _a;
            this.chatState.updateCurrentChatTitle(newTitle);
            (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showNotification('Chat title updated', 'info');
        };
        const showPopupMenuCallback = (event) => {
            const rect = event.target.getBoundingClientRect();
            this.popupMenuManager.showPopupMenu(rect.left + 60, rect.top - 20);
            event.preventDefault();
            event.stopPropagation();
        };
        const sendMessageViaButtonCallback = () => {
            const inputElement = this.layoutElements.inputField;
            const event = new KeyboardEvent('keypress', { key: 'Enter', bubbles: true });
            inputElement.dispatchEvent(event);
        };
        const toggleMarkdownModeCallback = (isMarkdown) => {
            var _a;
            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.setMarkdownMode(isMarkdown);
        };
        const toggleExpandInputCallback = (button) => {
            var _a;
            (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.toggleInputExpansion();
        };
        // Callbacks for Message Rendering (passed to MessageHandler -> UIManager -> renderers)
        const messageRendererCallbacks = {
            showCopyFeedback: (button, success = true) => {
                const originalHTML = button.innerHTML;
                button.innerHTML = success ? 'Copied!' : 'Failed!';
                button.disabled = true;
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.disabled = false;
                }, 1000);
            },
            addMessageToCell: notebook_integration_1.addMessageToCell,
            copyToClipboard: (text, feedbackCb) => {
                navigator.clipboard.writeText(text).then(() => feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb()).catch(err => {
                    console.error('Failed to copy text: ', err);
                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();
                });
            },
            copyImageToClipboard: (imageUrl, feedbackCb) => {
                (0, clipboard_1.copyImageToClipboard)(imageUrl, (success) => {
                    feedbackCb === null || feedbackCb === void 0 ? void 0 : feedbackCb();
                });
            },
            copyMessageToClipboard: (text, feedbackCb) => {
                (0, clipboard_1.copyMessageToClipboard)(text, (success) => {
                    feedbackCb();
                });
            },
            handleConfirmInterrupt: () => {
                var _a;
                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('confirmed');
            },
            handleRejectInterrupt: () => {
                var _a;
                (_a = this.messageHandler) === null || _a === void 0 ? void 0 : _a.handleSendAutoMessage('rejected');
            }
        };
        const settingsModalCallbacks = {
            handleSave: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.saveSettings(); },
            handleCancel: () => { var _a; (_a = this.settingsHandler) === null || _a === void 0 ? void 0 : _a.hideModal(); }
        };
        const historyHandlerCallbacks = {
            updateTitleInput: (title) => this.uiManager.updateTitleInput(title),
            clearMessageContainer: () => this.uiManager.clearMessageContainer(),
            addRenderedMessage: (messageElement) => this.uiManager.addChatMessageElement(messageElement)
        };
        const inputHandlerCallbacks = {
            handleSendMessage: (message) => {
                if (this.messageHandler) {
                    this.messageHandler.handleSendMessage(message);
                }
                else {
                    console.error('MessageHandler not initialized when trying to send message from InputHandler');
                }
            },
            showPopupMenu: (left, top) => this.popupMenuManager.showPopupMenu(left, top),
            hidePopupMenu: () => this.popupMenuManager.hidePopupMenu(),
            updatePlaceholder: (isMarkdown) => {
                // Use dataset for data-placeholder attribute
                this.layoutElements.inputField.dataset.placeholder = isMarkdown ? 'Enter markdown...' : 'Ask anything...';
            },
            toggleInputExpansionUI: (isExpanded) => {
                const button = this.layoutElements.expandButton;
                // Clear existing content (text or old icon)
                while (button.firstChild) {
                    button.removeChild(button.firstChild);
                }
                // Add the appropriate icon using LabIcon.resolve
                const icon = isExpanded
                    ? ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-up' })
                    : ui_components_1.LabIcon.resolve({ icon: 'ui-components:caret-down' });
                icon.element({ container: button, tag: 'span' }); // Add icon to button
                // Update title for accessibility
                button.title = isExpanded ? 'Collapse input' : 'Expand input';
            },
            getCodeRefMap: () => { var _a; return ((_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.getCodeReferenceMap()) || new Map(); },
            resetCodeRefMap: () => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.resetCodeReferences(); }
        };
        const shortcutCallbacks = {
            showIndicator: (text) => { var _a; return (_a = this.uiManager) === null || _a === void 0 ? void 0 : _a.showIndicator(text); },
            appendToInput: (text) => { var _a; return (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.appendToInput(text); },
            showWidget: () => { if (this.isHidden) {
                this.show();
            } },
            focusInput: () => { var _a, _b; return (_b = (_a = this.layoutElements) === null || _a === void 0 ? void 0 : _a.inputField) === null || _b === void 0 ? void 0 : _b.focus(); }
        };
        // --- 3. Build UI Layout ---
        this.layoutElements = (0, layout_builder_1.buildLayout)({
            onNewChatClick: createNewChatCallback,
            onHistoryToggleClick: toggleHistoryCallback,
            onSettingsClick: showSettingsCallback,
            onTitleChange: updateTitleCallback,
            onAtButtonClick: showPopupMenuCallback,
            onSendMessageClick: sendMessageViaButtonCallback,
            onMarkdownToggleChange: toggleMarkdownModeCallback,
            onExpandToggleClick: toggleExpandInputCallback,
        });
        this.settingsModalContainer = (0, settings_modal_1.createSettingsModalElement)(settingsModalCallbacks);
        // --- Initialize State Managers ---
        this.chatState = new chat_state_1.ChatState();
        this.settingsState = new settings_state_1.SettingsState();
        // --- Initialize Core Components ---
        this.apiClient = new api_client_1.ApiClient();
        // --- Initialize UI Manager (needs dependencies) ---
        const uiManagerCallbacks = {
            handleNewChat: this.handleNewChat,
            handleToggleHistory: this.handleToggleHistory,
            handleSendMessage: this.handleSendMessage,
            handleShowSettings: this.handleShowSettings,
            handleShowPopupMenu: this.handleShowPopupMenu,
            handleUpdateTitle: this.handleUpdateTitle
        };
        this.uiManager = new ui_manager_1.UIManager(this.popupMenuManager, uiManagerCallbacks, this.layoutElements);
        // --- 4. Initialize Handlers (using UI elements and core components) ---
        this.inputHandler = new input_handler_1.InputHandler(this.layoutElements.inputField, inputHandlerCallbacks);
        this.messageHandler = new message_handler_1.MessageHandler(this.apiClient, this.chatState, this.uiManager, messageRendererCallbacks, this.inputHandler);
        this.historyHandler = new history_handler_1.HistoryHandler(this.chatState, this.uiManager, historyHandlerCallbacks, messageRendererCallbacks);
        this.settingsHandler = new settings_handler_1.SettingsHandler(this.settingsState, this.settingsModalContainer, this.uiManager);
        // --- 5. Final Setup (Attach event listeners, connect signals, etc.) ---
        const initialChatId = this.chatState.getCurrentChatId();
        if (initialChatId) {
            this.historyHandler.loadChat(initialChatId);
        }
        else {
            const newChat = this.chatState.createNewChat();
            this.historyHandler.loadChat(newChat.id);
        }
        // Setup global keyboard shortcuts with the UIManager for proper @ key handling
        (0, shortcut_handler_1.setupShortcuts)(this.inputHandler, this.popupMenuManager, shortcutCallbacks);
        this.node.appendChild(this.layoutElements.mainElement);
        this.node.appendChild(this.settingsModalContainer);
    }
    /**
     * Disposes all resources
     */
    dispose() {
        var _a, _b;
        if (this.isDisposed) {
            return;
        }
        (0, shortcut_handler_1.removeShortcuts)();
        (_a = this.inputHandler) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this.popupMenuManager) === null || _b === void 0 ? void 0 : _b.dispose();
        super.dispose();
    }
} // End of SimpleSidebarWidget class
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/chat-state.js":
/*!***********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/chat-state.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChatState = void 0;
const uuid_1 = __webpack_require__(/*! uuid */ "webpack/sharing/consume/default/uuid/uuid");
/**
 * Manages the state of chat history and the currently active chat.
 */
class ChatState {
    constructor() {
        var _a;
        this.chatHistory = [];
        this.currentChatId = null;
        // Potential: Load initial state from storage if persistence is added later
        if (this.chatHistory.length === 0) {
            this.createNewChat('Welcome Chat'); // Create an initial chat if none exists
        }
        else {
            this.currentChatId = ((_a = this.chatHistory[0]) === null || _a === void 0 ? void 0 : _a.id) || null; // Set current chat to the first one
        }
    }
    /**
     * Creates a new chat session and sets it as the current chat.
     * @param title - The initial title for the new chat.
     * @returns The newly created chat item.
     */
    createNewChat(title = 'New Chat') {
        const chatId = `chat-${(0, uuid_1.v4)()}`; // Use UUID for better uniqueness
        const newChat = {
            id: chatId,
            title: title,
            messages: [],
            // Optional: Add timestamp or other metadata if needed later
            // createdAt: Date; 
        };
        this.chatHistory.push(newChat);
        this.currentChatId = chatId;
        console.log('Created new chat:', newChat);
        return newChat;
    }
    /**
     * Sets the currently active chat ID.
     * @param chatId - The ID of the chat to set as current.
     */
    setCurrentChatId(chatId) {
        if (this.chatHistory.some(chat => chat.id === chatId)) {
            this.currentChatId = chatId;
        }
        else {
            console.warn(`Chat ID ${chatId} not found in history.`);
        }
    }
    /**
     * Gets the ID of the currently active chat.
     * @returns The current chat ID or null if none is active.
     */
    getCurrentChatId() {
        return this.currentChatId;
    }
    /**
     * Retrieves a specific chat by its ID.
     * @param chatId - The ID of the chat to retrieve.
     * @returns The chat item or undefined if not found.
     */
    getChatById(chatId) {
        return this.chatHistory.find(chat => chat.id === chatId);
    }
    /**
     * Retrieves the currently active chat item.
     * @returns The current chat item or undefined if no chat is active or found.
     */
    getCurrentChat() {
        if (!this.currentChatId) {
            return undefined;
        }
        return this.getChatById(this.currentChatId);
    }
    /**
     * Updates the title of the currently active chat.
     * @param newTitle - The new title for the chat.
     */
    updateCurrentChatTitle(newTitle) {
        const currentChat = this.getCurrentChat();
        if (currentChat) {
            currentChat.title = newTitle;
            console.log(`Updated title for chat ${this.currentChatId} to "${newTitle}"`);
        }
        else {
            console.warn('Cannot update title: No current chat selected.');
        }
    }
    /**
     * Adds a message to the currently active chat.
     * @param message - The message object to add.
     */
    addMessageToCurrentChat(message) {
        const currentChat = this.getCurrentChat();
        if (currentChat) {
            currentChat.messages.push(message);
        }
        else {
            console.warn('Cannot add message: No current chat selected.');
        }
    }
    /**
     * Gets all messages from the currently active chat.
     * @returns An array of messages or an empty array if no chat is active.
     */
    getCurrentChatMessages() {
        const currentChat = this.getCurrentChat();
        return currentChat ? currentChat.messages : [];
    }
    /**
     * Gets the entire chat history.
     * @returns An array of all chat history items.
     */
    getChatHistory() {
        return [...this.chatHistory]; // Return a copy to prevent direct modification
    }
}
exports.ChatState = ChatState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/state/settings-state.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/state/settings-state.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsState = void 0;
const SETTINGS_STORAGE_KEY = 'jp-llm-ext-settings';
/**
 * Manages loading and saving application settings to localStorage.
 */
class SettingsState {
    constructor() {
        this.currentSettings = null;
        this.currentSettings = this.loadSettings();
    }
    /**
     * Loads settings from localStorage.
     * @returns The loaded settings or null if none are saved or an error occurs.
     */
    loadSettings() {
        const savedSettings = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (savedSettings) {
            try {
                const settings = JSON.parse(savedSettings);
                // Basic validation (can be expanded)
                if (settings && settings.provider) {
                    this.currentSettings = settings;
                    console.log('Loaded settings:', this.currentSettings);
                    return this.currentSettings;
                }
            }
            catch (error) {
                console.error('Error loading saved settings:', error);
                localStorage.removeItem(SETTINGS_STORAGE_KEY); // Clear corrupted data
            }
        }
        console.log('No valid settings found in localStorage.');
        return null;
    }
    /**
     * Saves the provided settings to localStorage.
     * @param settings - The settings object to save.
     */
    saveSettings(settings) {
        try {
            localStorage.setItem(SETTINGS_STORAGE_KEY, JSON.stringify(settings));
            this.currentSettings = Object.assign({}, settings); // Update internal state
            console.log('Settings saved:', this.currentSettings);
        }
        catch (error) {
            console.error('Error saving settings:', error);
            // Optional: Notify user of save failure
        }
    }
    /**
     * Gets the currently loaded settings.
     * @returns The current settings object or null if not loaded.
     */
    getSettings() {
        return this.currentSettings ? Object.assign({}, this.currentSettings) : null; // Return a copy
    }
    /**
     * Gets a specific setting value.
     * @param key - The key of the setting to retrieve.
     * @returns The value of the setting or undefined if not found.
     */
    getSetting(key) {
        return this.currentSettings ? this.currentSettings[key] : undefined;
    }
}
exports.SettingsState = SettingsState;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.createDiv = createDiv;
exports.createButton = createButton;
exports.createSpan = createSpan;
exports.createTextArea = createTextArea;
exports.createInputElement = createInputElement;
exports.createImageElement = createImageElement;
exports.createAnchorElement = createAnchorElement;
exports.createLabelElement = createLabelElement;
exports.createFormElement = createFormElement;
/**
 * Generic function to create an HTMLElement.
 *
 * @param tagName - The HTML tag name (e.g., 'div', 'button').
 * @param options - Optional configuration for the element.
 * @returns The created HTMLElement.
 */
function createElement(tagName, options = {}) {
    const element = document.createElement(tagName);
    if (options.id) {
        element.id = options.id;
    }
    if (options.classes) {
        const classesToAdd = Array.isArray(options.classes)
            ? options.classes
            : options.classes.split(' ').filter(c => c);
        element.classList.add(...classesToAdd);
    }
    if (options.text) {
        element.textContent = options.text;
    }
    else if (options.html) {
        element.innerHTML = options.html; // Be cautious with HTML injection
    }
    if (options.attributes) {
        for (const key in options.attributes) {
            if (options.attributes.hasOwnProperty(key)) {
                element.setAttribute(key, options.attributes[key]);
            }
        }
    }
    if (options.style) {
        for (const key in options.style) {
            if (options.style.hasOwnProperty(key)) {
                element.style[key] = options.style[key];
            }
        }
    }
    if (options.children) {
        options.children.forEach(child => {
            if (typeof child === 'string') {
                element.appendChild(document.createTextNode(child));
            }
            else {
                element.appendChild(child);
            }
        });
    }
    return element;
}
/** Creates a <div> element. */
function createDiv(options = {}) {
    return createElement('div', options);
}
/** Creates a <button> element. */
function createButton(options = {}) {
    return createElement('button', options);
}
/** Creates a <span> element. */
function createSpan(options = {}) {
    return createElement('span', options);
}
/** Creates a <textarea> element. */
function createTextArea(options = {}) {
    return createElement('textarea', options);
}
/** Creates an <input> element. */
function createInputElement(options = {}) {
    var _a;
    // Ensure type is set if provided in attributes, otherwise default or leave unset
    if ((_a = options.attributes) === null || _a === void 0 ? void 0 : _a.type) {
        // Type is already set in attributes, do nothing extra
    }
    else if (!options.attributes) {
        options.attributes = { type: 'text' }; // Default to text if no attributes specified
    }
    else if (!options.attributes.type) {
        options.attributes.type = 'text'; // Default to text if type is not in attributes
    }
    return createElement('input', options);
}
/** Creates an <img> element. */
function createImageElement(options) {
    const imgOptions = Object.assign({}, options);
    imgOptions.attributes = Object.assign(Object.assign({}, options.attributes), { src: options.src });
    if (options.alt) {
        imgOptions.attributes.alt = options.alt;
    }
    return createElement('img', imgOptions);
}
/** Creates an <a> element. */
function createAnchorElement(options) {
    const anchorOptions = Object.assign({}, options);
    anchorOptions.attributes = Object.assign(Object.assign({}, options.attributes), { href: options.href });
    return createElement('a', anchorOptions);
}
/** Creates a <label> element. */
function createLabelElement(options) {
    const labelOptions = Object.assign({}, options);
    if (options.htmlFor) {
        labelOptions.attributes = Object.assign(Object.assign({}, options.attributes), { for: options.htmlFor });
    }
    return createElement('label', labelOptions);
}
/** Creates a <form> element. */
function createFormElement(options = {}) {
    return createElement('form', options);
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js":
/*!************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/layout-builder.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.buildLayout = buildLayout;
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
/**
 * Builds the main HTML structure for the sidebar widget.
 *
 * @param callbacks - An object containing callback functions for various UI interactions.
 * @returns An object containing the main widget HTMLElement and references to key interactive elements.
 */
function buildLayout(callbacks = {}) {
    // --- Main Content Wrapper ---
    const mainElement = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-content-wrapper'
    });
    // --- Title Bar ---
    const titleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-title-container' });
    const titleInput = (0, dom_elements_1.createInputElement)({
        id: 'chat-title-input',
        classes: 'chat-title-input',
        attributes: { type: 'text', placeholder: 'Chat title', value: 'New Chat' }
    });
    if (callbacks.onTitleChange) {
        titleInput.addEventListener('change', () => callbacks.onTitleChange(titleInput.value));
    }
    titleContainer.appendChild(titleInput);
    // --- Message & History Containers ---
    const messageContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-message-container' });
    const historyContainer = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-history-container',
        style: { display: 'none' } // Hidden by default
    });
    // --- Bottom Bar Area ---
    const bottomBarContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-container' });
    // Row 1: Controls (Markdown Toggle, @, Expand, Settings)
    const controlsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row' });
    const controlsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-controls-container' });
    // Markdown Toggle
    const toggleContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-toggle-container' });
    const markdownToggleButton = (0, dom_elements_1.createInputElement)({
        id: 'markdown-toggle',
        attributes: { type: 'checkbox' }
    });
    const toggleLabel = (0, dom_elements_1.createLabelElement)({
        text: 'Markdown mode',
        htmlFor: 'markdown-toggle'
    });
    if (callbacks.onMarkdownToggleChange) {
        markdownToggleButton.addEventListener('change', () => {
            callbacks.onMarkdownToggleChange(markdownToggleButton.checked);
        });
    }
    toggleContainer.appendChild(markdownToggleButton);
    toggleContainer.appendChild(toggleLabel);
    // Action Buttons (@, Expand, Settings)
    const actionButtonsContainer = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-action-buttons-container' });
    const atButton = (0, dom_elements_1.createButton)({ text: '@', attributes: { title: 'Browse cells, code, files, and more' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onAtButtonClick) {
        atButton.addEventListener('click', callbacks.onAtButtonClick);
    }
    const expandButton = (0, dom_elements_1.createButton)({ text: '⤢', attributes: { title: 'Expand input' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onExpandToggleClick) {
        expandButton.addEventListener('click', () => callbacks.onExpandToggleClick(expandButton));
    }
    const settingsButton = (0, dom_elements_1.createButton)({ text: '⚙️', attributes: { title: 'Settings' }, classes: 'jp-Button jp-llm-ext-action-button' });
    if (callbacks.onSettingsClick) {
        settingsButton.addEventListener('click', callbacks.onSettingsClick);
    }
    actionButtonsContainer.appendChild(atButton);
    actionButtonsContainer.appendChild(expandButton);
    actionButtonsContainer.appendChild(settingsButton);
    controlsContainer.appendChild(toggleContainer);
    controlsContainer.appendChild(actionButtonsContainer);
    controlsRow.appendChild(controlsContainer);
    // Row 2: Input Field
    const inputRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row' });
    const inputField = (0, dom_elements_1.createDiv)({
        classes: 'jp-llm-ext-input-field',
        attributes: {
            contenteditable: 'true',
            role: 'textbox',
            'aria-multiline': 'true',
            'data-placeholder': 'Ask me anything...'
        },
        style: { minHeight: '20px', overflowY: 'hidden' }
    });
    if (callbacks.onInputFieldKeyPress) {
        inputField.addEventListener('keypress', callbacks.onInputFieldKeyPress);
    }
    if (callbacks.onInputFieldValueChange) {
        inputField.addEventListener('input', () => callbacks.onInputFieldValueChange(inputField.textContent || ''));
    }
    inputRow.appendChild(inputField);
    // Row 3: Main Buttons (Send, New Chat, History)
    const buttonsRow = (0, dom_elements_1.createDiv)({ classes: 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row' });
    const sendButton = (0, dom_elements_1.createButton)({
        text: 'Send',
        classes: 'jp-Button jp-llm-ext-send-button'
    });
    if (callbacks.onSendMessageClick) {
        sendButton.addEventListener('click', callbacks.onSendMessageClick);
    }
    const newChatButton = (0, dom_elements_1.createButton)({
        text: '+ New Chat',
        attributes: { title: 'Start a new chat' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onNewChatClick) {
        newChatButton.addEventListener('click', callbacks.onNewChatClick);
    }
    const historyButton = (0, dom_elements_1.createButton)({
        text: 'History',
        attributes: { title: 'View chat history' },
        classes: 'jp-Button jp-llm-ext-action-button'
    });
    if (callbacks.onHistoryToggleClick) {
        historyButton.addEventListener('click', callbacks.onHistoryToggleClick);
    }
    buttonsRow.appendChild(sendButton);
    buttonsRow.appendChild(newChatButton);
    buttonsRow.appendChild(historyButton);
    // Assemble Bottom Bar
    bottomBarContainer.appendChild(controlsRow);
    bottomBarContainer.appendChild(inputRow);
    bottomBarContainer.appendChild(buttonsRow);
    // --- Assemble Main Element ---
    mainElement.appendChild(titleContainer);
    mainElement.appendChild(messageContainer);
    mainElement.appendChild(historyContainer);
    mainElement.appendChild(bottomBarContainer);
    return {
        mainElement,
        titleInput,
        messageContainer,
        historyContainer,
        inputField,
        bottomBarContainer,
        sendButton,
        newChatButton,
        historyButton,
        markdownToggleButton,
        expandButton,
        atButton,
        settingsButton
    };
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/message-renderer.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRenderer = void 0;
exports.renderUserMessage = renderUserMessage;
exports.renderBotMessage = renderBotMessage;
exports.renderBotMessageStreamingStart = renderBotMessageStreamingStart;
exports.renderBotMessageStreamingUpdate = renderBotMessageStreamingUpdate;
exports.renderBotMessageFinal = renderBotMessageFinal;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
// import hljs from 'highlight.js'; // Removed unused import
const dom_elements_1 = __webpack_require__(/*! ./dom-elements */ "./node_modules/jupyter-simple-extension/lib/ui/dom-elements.js");
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js"); // Import globals
// Removed unused import block for clipboard utils (used via callbacks)
// import { copyToClipboard, copyImageToClipboard, copyMessageToClipboard } from '../utils/clipboard';
// Removed unused import (used via callbacks)
// import { addMessageToCell } from '../utils/notebook-integration';
const highlighting_1 = __webpack_require__(/*! ../utils/highlighting */ "./node_modules/jupyter-simple-extension/lib/utils/highlighting.js");
const markdown_config_1 = __webpack_require__(/*! ../utils/markdown-config */ "./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js");
/**
 * Base function to create a message container div.
 */
function createMessageDiv(sender) {
    const messageDiv = document.createElement('div');
    messageDiv.className = sender === 'user' ? 'jp-llm-ext-user-message' : 'jp-llm-ext-bot-message';
    return messageDiv;
}
/**
 * Renders a user message.
 */
function renderUserMessage(text, options = {}, callbacks = {}) {
    const messageDiv = createMessageDiv('user');
    if (options.isMarkdown) {
        // TODO: Integrate Code Reference rendering properly here
        // For now, render the whole body as Markdown
        const contentDiv = document.createElement('div');
        // Use 'markdown-content' class for consistent styling
        contentDiv.className = 'markdown-content';
        try {
            // Preprocess, parse, and sanitize like in bot messages
            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // Enhance code blocks if user messages can contain them
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                // Pass only relevant callbacks if needed for user code blocks
                enhanceCodeBlock(block, {
                // e.g., showCopyFeedback: callbacks.showCopyFeedback 
                });
            });
        }
        catch (error) {
            console.error('Failed to render user markdown:', error);
            // Fallback to plain text if Markdown rendering fails
            contentDiv.textContent = text;
        }
        messageDiv.appendChild(contentDiv);
    }
    else {
        // Non-Markdown user message (plain text)
        // Replace simple textContent assignment with ref-aware rendering
        // messageDiv.textContent = text;
        renderMessageContentWithRefs(messageDiv, text, callbacks);
    }
    // TODO: Add user message specific actions if needed (e.g., copy text)
    return messageDiv;
}
/**
 * NEW: Renders message content, replacing @references with widgets.
 */
function renderMessageContentWithRefs(container, text, callbacks) {
    // --- DEBUG LOG --- 
    console.log('[renderMessageContentWithRefs] Processing text:', JSON.stringify(text)); // Log exact text
    // --- END DEBUG LOG ---
    // Regex to find @file, @dir, @Cell, @code references (with optional surrounding whitespace)
    const refRegex = /\s*(@(file|dir|Cell|code)\[([^\]]+?)\])\s*/g;
    let lastIndex = 0;
    let match;
    // Reset regex state just in case
    refRegex.lastIndex = 0;
    while ((match = refRegex.exec(text)) !== null) {
        // Append text before the match
        if (match.index > lastIndex) {
            container.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
        }
        // Process the matched reference
        const fullMatchWithWhitespace = match[0]; // Includes potential whitespace
        const fullMatch = match[1]; // The actual @type[value] part
        const type = match[2];
        const value = match[3];
        try {
            const widget = createRefWidget(type, value, fullMatch, callbacks); // Pass the clean match
            container.appendChild(widget);
        }
        catch (error) {
            console.error(`Failed to create widget for reference: ${fullMatch}`, error);
            // Fallback: append the original reference text (with potential whitespace)
            container.appendChild(document.createTextNode(fullMatchWithWhitespace));
        }
        lastIndex = refRegex.lastIndex;
    }
    // Append any remaining text after the last match
    if (lastIndex < text.length) {
        container.appendChild(document.createTextNode(text.substring(lastIndex)));
    }
}
/**
 * NEW: Creates a reference widget span.
 */
function createRefWidget(type, value, originalRefText, // The full @type[value] string
callbacks) {
    const widget = document.createElement('span');
    widget.className = `jp-llm-ext-ref-widget ref-${type.toLowerCase()}`;
    widget.setAttribute('contenteditable', 'false');
    widget.dataset.refText = originalRefText; // Store the original reference
    let displayText = '';
    let titleText = originalRefText; // Default tooltip
    switch (type) {
        case 'file':
            displayText = value.split(/[\\/]/).pop() || value; // Extract filename
            titleText = `File: ${value}`;
            break;
        case 'dir':
            displayText = value.split(/[\\/]/).pop() || value || '/'; // Extract dirname, handle root
            titleText = `Directory: ${value}`;
            break;
        case 'Cell': {
            const cellIndex = parseInt(value) - 1; // Convert back to 0-based index
            const notebookContext = callbacks.getCurrentNotebookContext ? callbacks.getCurrentNotebookContext() : undefined;
            // --- DEBUG LOG --- 
            console.log(`[createRefWidget @Cell] Input Value: ${value}, Parsed Index: ${cellIndex}, Notebook Context:`, notebookContext);
            // --- END DEBUG LOG --- 
            const notebookName = (notebookContext === null || notebookContext === void 0 ? void 0 : notebookContext.name) || 'notebook';
            let cellTypeChar = '?';
            if (notebookContext && globals_1.globals.notebookTracker) {
                const currentNotebookPanel = globals_1.globals.notebookTracker.find(widget => widget.context.path === notebookContext.path);
                if (currentNotebookPanel && currentNotebookPanel.model) {
                    const cellModel = currentNotebookPanel.model.cells.get(cellIndex);
                    if (cellModel) {
                        cellTypeChar = cellModel.type === 'markdown' ? 'M' : 'C';
                    }
                }
            }
            displayText = `${notebookName}-${cellTypeChar}-${value}`; // value is 1-based index
            titleText = `Cell ${value} (${cellTypeChar === 'M' ? 'Markdown' : 'Code'}) in ${notebookName}`;
            break;
        }
        case 'code': {
            const refId = value;
            const refData = callbacks.getCodeRefData ? callbacks.getCodeRefData(refId) : undefined;
            // --- DEBUG LOG --- 
            console.log(`[createRefWidget @code] Input Value (refId): ${refId}, Ref Data Found:`, refData);
            // --- END DEBUG LOG --- 
            if (refData) {
                // Construct display text using start and end lines
                const startLine = refData.lineNumber;
                const endLine = refData.lineEndNumber;
                const linePart = startLine === endLine ? `${startLine}` : `${startLine}_${endLine}`;
                displayText = `${refData.notebookName}-${refData.cellIndex + 1}-${linePart}`;
                // Update title text as well
                const titleLinePart = startLine === endLine ? `Line ${startLine}` : `Lines ${startLine}-${endLine}`;
                titleText = `Code Reference: ${refData.notebookName}, Cell ${refData.cellIndex + 1}, ${titleLinePart}`;
            }
            else {
                displayText = `code-ref-${refId}`; // Fallback display
                titleText = `Code Reference ID: ${refId} (Data not found)`;
            }
            break;
        }
    }
    widget.textContent = displayText;
    widget.title = titleText; // Add tooltip
    return widget;
}
/**
 * NEW: Recursively finds and replaces @references within text nodes of an element.
 */
function renderRefsInElement(element, callbacks) {
    // Use the same updated regex here
    const refRegex = /\s*(@(file|dir|Cell|code)\[([^\]]+?)\])\s*/g;
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT, null);
    let node;
    const nodesToProcess = [];
    while ((node = walker.nextNode())) {
        if (node instanceof Text &&
            node.textContent &&
            !(node.parentElement && node.parentElement.closest('.jp-llm-ext-ref-widget'))) {
            // Test with the specific regex before adding
            refRegex.lastIndex = 0; // Reset before test
            if (refRegex.test(node.textContent)) {
                nodesToProcess.push(node);
            }
        }
    }
    // Now, process the collected text nodes
    nodesToProcess.forEach(textNode => {
        const parent = textNode.parentNode;
        if (!parent)
            return;
        const text = textNode.textContent || '';
        const fragment = document.createDocumentFragment();
        let lastIndex = 0;
        let match;
        refRegex.lastIndex = 0; // Reset regex state for each node
        while ((match = refRegex.exec(text)) !== null) {
            // Append text before the match
            if (match.index > lastIndex) {
                fragment.appendChild(document.createTextNode(text.substring(lastIndex, match.index)));
            }
            // Process the matched reference
            const fullMatchWithWhitespace = match[0];
            const fullMatch = match[1];
            const type = match[2];
            const value = match[3];
            try {
                const widget = createRefWidget(type, value, fullMatch, callbacks);
                fragment.appendChild(widget);
            }
            catch (error) {
                console.error(`Failed to create widget for reference: ${fullMatch}`, error);
                fragment.appendChild(document.createTextNode(fullMatchWithWhitespace)); // Fallback
            }
            lastIndex = refRegex.lastIndex;
        }
        // Append any remaining text after the last match
        if (lastIndex < text.length) {
            fragment.appendChild(document.createTextNode(text.substring(lastIndex)));
        }
        // Replace the original text node with the fragment
        parent.replaceChild(fragment, textNode);
    });
}
/**
 * Renders a bot message (text, markdown, images, code blocks).
 */
function renderBotMessage(text, options = { isMarkdown: true }, callbacks = {}) {
    const messageDiv = createMessageDiv('bot');
    // Check if the message is an image URL
    const isImageUrl = text.trim().startsWith('/images/') &&
        (text.trim().endsWith('.png') ||
            text.trim().endsWith('.jpg') ||
            text.trim().endsWith('.jpeg') ||
            text.trim().endsWith('.gif'));
    if (isImageUrl) {
        // Construct full URL (TODO: Make base URL configurable)
        const fullImageUrl = `http://127.0.0.1:8000${text.trim()}`;
        // Call dedicated image rendering function
        renderImageMessage(messageDiv, fullImageUrl, callbacks);
    }
    else if (options.isMarkdown) {
        // Render as markdown (logic from addMessage)
        const markdownIndicator = document.createElement('div');
        markdownIndicator.textContent = "MD";
        markdownIndicator.className = 'markdown-indicator';
        messageDiv.appendChild(markdownIndicator);
        const contentDiv = document.createElement('div');
        contentDiv.className = 'markdown-content';
        try {
            const processedText = (0, markdown_config_1.preprocessMarkdown)(text);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // --- NEW: Render references within the sanitized HTML --- 
            renderRefsInElement(contentDiv, callbacks);
            // --- End NEW ---
            // Enhance code blocks after setting innerHTML and rendering refs
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                enhanceCodeBlock(block, callbacks);
            });
            // Check for and render interrupt buttons
            const isInterrupt = text.startsWith('**[INTERRUPT]**');
            if (isInterrupt) {
                renderInterruptButtons(contentDiv, callbacks);
            }
        }
        catch (error) {
            contentDiv.textContent = text; // Fallback to plain text
            console.error('Failed to render markdown:', error);
        }
        messageDiv.appendChild(contentDiv);
        // Add overall message action buttons AFTER content is added
        addBotMessageActions(messageDiv, text, callbacks);
    }
    else {
        // Render as plain text
        messageDiv.textContent = text;
        // Add overall message action buttons even for plain text bot messages
        addBotMessageActions(messageDiv, text, callbacks);
    }
    return messageDiv;
}
// Define createMessageWrapper based on createMessageDiv
function createMessageWrapper(sender) {
    return createMessageDiv(sender);
}
// --- More specific rendering functions or helpers can be added below ---
/**
 * Renders an image message with action buttons inside a container.
 *
 * @param container The parent HTML element to append the image message to.
 * @param imageUrl The full URL of the image to render.
 * @param callbacks Callbacks for actions like copy image, add path.
 */
function renderImageMessage(container, imageUrl, callbacks = {}) {
    // Create a container for the image that allows positioning the buttons
    const imageContainer = document.createElement('div');
    imageContainer.className = 'jp-llm-ext-image-container';
    imageContainer.style.position = 'relative';
    // Render as an image tag
    const img = document.createElement('img');
    img.src = imageUrl;
    img.alt = 'Image from bot';
    img.style.maxWidth = '100%'; // Ensure image fits within the container
    img.style.height = 'auto';
    imageContainer.appendChild(img);
    // Add action buttons for the image
    const imgActionsDiv = document.createElement('div');
    imgActionsDiv.className = 'jp-llm-ext-image-actions';
    imgActionsDiv.style.position = 'absolute';
    imgActionsDiv.style.bottom = '10px';
    imgActionsDiv.style.right = '10px';
    imgActionsDiv.style.display = 'flex';
    imgActionsDiv.style.gap = '8px';
    imgActionsDiv.style.backgroundColor = 'rgba(255, 255, 255, 0.6)'; // Added slight background for visibility
    imgActionsDiv.style.borderRadius = '4px';
    imgActionsDiv.style.padding = '4px';
    // Copy image button (using callback)
    if (callbacks.copyImageToClipboard && callbacks.showCopyFeedback) {
        const copyImgBtn = document.createElement('button');
        copyImgBtn.className = 'jp-llm-ext-image-action-button';
        copyImgBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyImgBtn.title = 'Copy image to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyImgBtn);
        copyImgBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyImageToClipboard(imageUrl, feedbackCb);
        });
        imgActionsDiv.appendChild(copyImgBtn);
    }
    // Add file path button (using callback)
    if (callbacks.addMessageToCell) {
        const addPathBtn = document.createElement('button');
        addPathBtn.className = 'jp-llm-ext-image-action-button';
        addPathBtn.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addPathBtn.title = 'Add image path to current cell';
        addPathBtn.addEventListener('click', (event) => {
            event.stopPropagation();
            // Pass the image URL (which is the message text in this case)
            callbacks.addMessageToCell(imageUrl);
        });
        imgActionsDiv.appendChild(addPathBtn);
    }
    // Only add the actions div if it has buttons
    if (imgActionsDiv.hasChildNodes()) {
        imageContainer.appendChild(imgActionsDiv);
    }
    // Add the image container to the main message div
    container.appendChild(imageContainer);
}
/**
 * Creates the initial structure for a bot message that will receive streaming content.
 *
 * @returns Object containing the wrapper, streaming div, and final content div.
 */
function renderBotMessageStreamingStart() {
    const wrapper = createMessageWrapper('bot');
    const markdownIndicator = (0, dom_elements_1.createDiv)({
        text: 'MD',
        classes: 'markdown-indicator'
    });
    wrapper.appendChild(markdownIndicator);
    const streamingDiv = (0, dom_elements_1.createDiv)({
        classes: 'streaming-content',
        style: {
            whiteSpace: 'pre-wrap',
            fontFamily: 'monospace',
            fontSize: '0.9em'
        }
    });
    wrapper.appendChild(streamingDiv);
    const contentDiv = (0, dom_elements_1.createDiv)({
        classes: 'markdown-content',
        style: { display: 'none' } // Initially hidden
    });
    wrapper.appendChild(contentDiv);
    return { wrapper, streamingDiv, contentDiv };
}
/**
 * Updates the streaming div with a new chunk of text.
 *
 * @param streamingDiv - The div displaying streaming content.
 * @param chunk - The new text chunk to append.
 */
function renderBotMessageStreamingUpdate(streamingDiv, chunk) {
    // Simple append, might need refinement for complex streams
    streamingDiv.textContent += chunk;
}
/**
 * Renders the final content of a bot message after streaming is complete.
 * Handles markdown, images, code blocks, and interrupts.
 *
 * @param contentDiv - The div where the final content should be rendered.
 * @param streamingDiv - The div that was used for streaming (will be hidden).
 * @param completeResponse - The full text content from the bot.
 * @param options - Rendering options including callbacks for actions.
 * @returns The populated contentDiv.
 */
function renderBotMessageFinal(contentDiv, streamingDiv, completeResponse, options = {}, callbacks = {}) {
    // Hide streaming div, show final content div
    streamingDiv.style.display = 'none';
    contentDiv.style.display = 'block';
    // Consolidate callbacks access
    const effectiveCallbacks = Object.assign(Object.assign({}, options), callbacks);
    // --- Image Handling ---
    const isImageUrl = completeResponse.trim().startsWith('/images/') &&
        (completeResponse.trim().endsWith('.png') ||
            completeResponse.trim().endsWith('.jpg') ||
            completeResponse.trim().endsWith('.jpeg') ||
            completeResponse.trim().endsWith('.gif'));
    if (isImageUrl) {
        const fullImageUrl = `http://127.0.0.1:8000${completeResponse.trim()}`; // TODO: Make base URL configurable
        renderImageMessage(contentDiv, fullImageUrl, effectiveCallbacks);
    }
    else {
        // --- Markdown & Code Block Handling ---
        try {
            const processedText = (0, markdown_config_1.preprocessMarkdown)(completeResponse);
            const rawHtml = marked_1.marked.parse(processedText);
            const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
            contentDiv.innerHTML = sanitizedHtml;
            // --- NEW: Render references within the sanitized HTML --- 
            renderRefsInElement(contentDiv, effectiveCallbacks);
            // --- End NEW ---
            // --- Interrupt Handling ---
            const isInterrupt = completeResponse.startsWith('**[INTERRUPT]**');
            if (isInterrupt) {
                renderInterruptButtons(contentDiv, effectiveCallbacks);
            }
            // --- Code Block Enhancements ---
            const codeBlocks = contentDiv.querySelectorAll('pre code');
            codeBlocks.forEach(block => {
                enhanceCodeBlock(block, effectiveCallbacks);
            });
        }
        catch (error) {
            console.error('Error rendering markdown:', error);
            contentDiv.textContent = completeResponse; // Fallback to plain text
        }
    }
    return contentDiv;
}
/**
 * Enhances a code block element with highlighting and action buttons.
 *
 * @param codeBlockElement The <code> element within a <pre>.
 * @param callbacks Callbacks for actions like copy code, add to cell.
 */
function enhanceCodeBlock(codeBlockElement, callbacks = {}) {
    var _a;
    const preElement = codeBlockElement.parentElement;
    if (!preElement || preElement.tagName !== 'PRE') {
        console.warn('Code block enhancement called on element not within a <pre> tag.');
        return;
    }
    // Add standard JupyterLab classes for consistency
    codeBlockElement.classList.add('jp-RenderedText');
    preElement.classList.add('jp-RenderedHTMLCommon');
    // Get code content
    const codeContent = codeBlockElement.textContent || '';
    // Create code block header for buttons and language indicator
    const codeHeader = document.createElement('div');
    codeHeader.className = 'jp-llm-ext-code-header';
    // Add language indicator if detected
    const language = (0, highlighting_1.detectLanguage)(codeContent); // Use imported util
    if (language) {
        const langIndicator = document.createElement('span');
        langIndicator.className = 'jp-llm-ext-code-language';
        langIndicator.textContent = language;
        codeHeader.appendChild(langIndicator);
        codeBlockElement.classList.add(`language-${language}`);
    }
    // Apply syntax highlighting
    try {
        // Use imported util (handles auto-detection if language is empty)
        codeBlockElement.innerHTML = (0, highlighting_1.highlightCode)(codeContent, language);
    }
    catch (error) {
        console.error('Error applying syntax highlighting:', error);
        // codeBlockElement might contain original text or partially highlighted
    }
    // Add action buttons to the code header
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'jp-llm-ext-code-actions';
    // Copy button
    if (callbacks.copyToClipboard && callbacks.showCopyFeedback) {
        const copyButton = document.createElement('button');
        copyButton.className = 'jp-llm-ext-code-action-button';
        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyButton.title = 'Copy code to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);
        copyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyToClipboard(codeContent, feedbackCb);
        });
        actionsDiv.appendChild(copyButton);
    }
    // Add to cell button
    if (callbacks.addMessageToCell) {
        const addToButton = document.createElement('button');
        addToButton.className = 'jp-llm-ext-code-action-button';
        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addToButton.title = 'Add code to current cell';
        addToButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.addMessageToCell(codeContent);
        });
        actionsDiv.appendChild(addToButton);
    }
    // Add the actions to the header, and insert header before the <pre>
    if (actionsDiv.hasChildNodes()) {
        codeHeader.appendChild(actionsDiv);
    }
    if (codeHeader.hasChildNodes()) {
        (_a = preElement.parentNode) === null || _a === void 0 ? void 0 : _a.insertBefore(codeHeader, preElement);
    }
}
/**
 * Renders Confirm/Reject buttons for an interrupt message.
 *
 * @param container The parent HTML element (message content div) to append buttons to.
 * @param callbacks Callbacks for confirm and reject actions.
 */
function renderInterruptButtons(container, callbacks = {}) {
    if (!callbacks.handleConfirmInterrupt || !callbacks.handleRejectInterrupt) {
        console.warn('Interrupt message needs confirm/reject callbacks.');
        return;
    }
    const buttonsContainer = document.createElement('div');
    buttonsContainer.className = 'jp-llm-ext-interrupt-buttons';
    buttonsContainer.style.marginTop = '12px';
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.gap = '8px';
    // Create confirm button
    const confirmButton = document.createElement('button');
    confirmButton.className = 'jp-llm-ext-confirm-button';
    confirmButton.textContent = 'Confirm';
    // Apply specific styling (can be moved to CSS)
    confirmButton.style.padding = '6px 12px';
    confirmButton.style.background = '#4CAF50';
    confirmButton.style.color = 'white';
    confirmButton.style.border = 'none';
    confirmButton.style.borderRadius = '4px';
    confirmButton.style.cursor = 'pointer';
    confirmButton.style.fontWeight = 'bold';
    // Create reject button
    const rejectButton = document.createElement('button');
    rejectButton.className = 'jp-llm-ext-reject-button';
    rejectButton.textContent = 'Reject';
    // Apply specific styling (can be moved to CSS)
    rejectButton.style.padding = '6px 12px';
    rejectButton.style.background = '#F44336';
    rejectButton.style.color = 'white';
    rejectButton.style.border = 'none';
    rejectButton.style.borderRadius = '4px';
    rejectButton.style.cursor = 'pointer';
    rejectButton.style.fontWeight = 'bold';
    // Add event listeners
    confirmButton.addEventListener('click', () => {
        confirmButton.disabled = true;
        rejectButton.disabled = true;
        confirmButton.style.opacity = '0.5';
        rejectButton.style.opacity = '0.5';
        callbacks.handleConfirmInterrupt();
    });
    rejectButton.addEventListener('click', () => {
        confirmButton.disabled = true;
        rejectButton.disabled = true;
        confirmButton.style.opacity = '0.5';
        rejectButton.style.opacity = '0.5';
        callbacks.handleRejectInterrupt();
    });
    // Add buttons to container and container to message
    buttonsContainer.appendChild(confirmButton);
    buttonsContainer.appendChild(rejectButton);
    container.appendChild(buttonsContainer);
}
/**
 * Adds overall action buttons (Copy, Add to Cell) to a bot message container.
 *
 * @param messageDiv The main div container for the bot message.
 * @param messageText The raw text content of the message.
 * @param callbacks Callbacks for actions like copy message, add to cell.
 */
function addBotMessageActions(messageDiv, messageText, callbacks = {}) {
    // Only add actions if corresponding callbacks are provided
    if (!callbacks.copyMessageToClipboard && !callbacks.addMessageToCell) {
        return;
    }
    console.log('Adding action buttons to bot message'); // Keep debug log for now
    const actionsDiv = document.createElement('div');
    actionsDiv.className = 'jp-llm-ext-message-actions';
    // actionsDiv.style.display = 'flex'; // Ensure display via CSS if needed
    // Copy Message button
    if (callbacks.copyMessageToClipboard && callbacks.showCopyFeedback) {
        const copyButton = document.createElement('button');
        copyButton.className = 'jp-llm-ext-message-action-button';
        copyButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>';
        copyButton.title = 'Copy message to clipboard';
        const feedbackCb = () => callbacks.showCopyFeedback(copyButton);
        copyButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.copyMessageToClipboard(messageText, feedbackCb);
        });
        actionsDiv.appendChild(copyButton);
    }
    // Add to Cell button
    if (callbacks.addMessageToCell) {
        const addToButton = document.createElement('button');
        addToButton.className = 'jp-llm-ext-message-action-button';
        addToButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M12 11v6"></path><path d="M9 14h6"></path></svg>';
        addToButton.title = 'Add message to current cell';
        addToButton.addEventListener('click', (event) => {
            event.stopPropagation();
            callbacks.addMessageToCell(messageText);
        });
        actionsDiv.appendChild(addToButton);
    }
    // Append the actions container if it has any buttons
    if (actionsDiv.hasChildNodes()) {
        messageDiv.appendChild(actionsDiv);
        console.log('Action buttons added to bot message:', actionsDiv); // Keep debug log
    }
}
// Potential future additions:
// - renderErrorMessage
// - renderSystemMessage
// - A main renderMessage function that delegates based on type? 
/**
 * Handles rendering individual messages (user, bot, system) into HTML elements.
 */
class MessageRenderer {
    // private callbacks: MessageRendererCallbacks; // Removed unused member
    // private uiManager: UIManager; // Might not be needed directly if callbacks handle UI updates
    constructor( /* callbacks: MessageRendererCallbacks */ /* , uiManager: UIManager */) {
        // this.callbacks = callbacks; // Removed unused assignment
        // this.uiManager = uiManager;
    }
}
exports.MessageRenderer = MessageRenderer;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js":
/*!************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/settings-modal.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsModal = void 0;
exports.createSettingsModalElement = createSettingsModalElement;
/**
 * Creates the HTML element for the settings modal.
 * @param callbacks Callbacks for save and cancel actions.
 * @returns The main modal HTMLElement.
 */
function createSettingsModalElement(callbacks) {
    const modal = document.createElement('div');
    modal.className = 'jp-llm-ext-settings-modal';
    modal.style.display = 'none'; // Initially hidden
    const content = document.createElement('div');
    content.className = 'jp-llm-ext-settings-content';
    const title = document.createElement('h2');
    title.className = 'jp-llm-ext-settings-title';
    title.textContent = 'Settings';
    content.appendChild(title);
    const form = document.createElement('form');
    form.className = 'jp-llm-ext-settings-form';
    // Provider selection
    const providerLabel = document.createElement('label');
    providerLabel.className = 'jp-llm-ext-settings-label';
    providerLabel.textContent = 'API Provider:';
    form.appendChild(providerLabel);
    const providerSelect = document.createElement('select');
    providerSelect.className = 'jp-llm-ext-settings-select';
    providerSelect.id = 'settings-provider'; // Keep ID for retrieval
    ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
        const option = document.createElement('option');
        option.value = opt;
        option.textContent = opt;
        providerSelect.appendChild(option);
    });
    form.appendChild(providerSelect);
    // API Key input
    const apiKeyLabel = document.createElement('label');
    apiKeyLabel.className = 'jp-llm-ext-settings-label';
    apiKeyLabel.textContent = 'API Key:';
    form.appendChild(apiKeyLabel);
    const apiKeyInput = document.createElement('input');
    apiKeyInput.className = 'jp-llm-ext-settings-input';
    apiKeyInput.type = 'password';
    apiKeyInput.id = 'settings-api-key'; // Keep ID for retrieval
    form.appendChild(apiKeyInput);
    // API URL input
    const apiUrlLabel = document.createElement('label');
    apiUrlLabel.className = 'jp-llm-ext-settings-label';
    apiUrlLabel.textContent = 'API URL (optional):';
    form.appendChild(apiUrlLabel);
    const apiUrlInput = document.createElement('input');
    apiUrlInput.className = 'jp-llm-ext-settings-input';
    apiUrlInput.type = 'text';
    apiUrlInput.id = 'settings-api-url'; // Keep ID for retrieval
    form.appendChild(apiUrlInput);
    // Rules input
    const rulesLabel = document.createElement('label');
    rulesLabel.className = 'jp-llm-ext-settings-label';
    rulesLabel.textContent = 'Custom Rules (optional):';
    form.appendChild(rulesLabel);
    const rulesInput = document.createElement('textarea');
    rulesInput.className = 'jp-llm-ext-settings-textarea';
    rulesInput.id = 'settings-rules'; // Keep ID for retrieval
    form.appendChild(rulesInput);
    // Buttons container
    const btnContainer = document.createElement('div');
    btnContainer.className = 'jp-llm-ext-settings-buttons';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-save-button';
    saveBtn.textContent = 'Save';
    saveBtn.type = 'button'; // Prevent default form submission
    saveBtn.addEventListener('click', (event) => {
        event.preventDefault();
        // The callback implementation will handle reading values and saving
        const settings = {
            apiKey: apiKeyInput.value,
            apiUrl: apiUrlInput.value,
            rules: rulesInput.value,
            provider: providerSelect.value
        };
        callbacks.handleSave(settings);
    });
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'jp-llm-ext-settings-button jp-llm-ext-settings-cancel-button';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.type = 'button'; // Prevent default form submission
    cancelBtn.addEventListener('click', (event) => {
        event.preventDefault();
        callbacks.handleCancel();
    });
    btnContainer.appendChild(saveBtn);
    btnContainer.appendChild(cancelBtn);
    form.appendChild(btnContainer);
    content.appendChild(form);
    modal.appendChild(content);
    return modal;
}
/**
 * Creates and manages the settings modal dialog.
 */
class SettingsModal {
    // private modalElement: HTMLDivElement; // Commented out - unused
    // private settings: AppSettings; // Commented out - unused
    constructor(callbacks) {
        // this.modalElement = createSettingsModalElement(callbacks); // Commented out - unused assignment
        // this.settings = { // Commented out - unused initialization
        //     provider: '', 
        //     apiKey: '', 
        //     apiUrl: '', 
        //     rules: '' 
        // }; 
    }
}
exports.SettingsModal = SettingsModal;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js":
/*!********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/ui/ui-manager.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UIManager = void 0;
/**
 * Manages UI elements and transitions for the chat interface.
 * This acts as a central point for UI manipulations, simplifying dependencies for handlers.
 */
class UIManager {
    constructor(popupMenuManager, callbacks, layoutElements) {
        this.notificationTimeout = null; // Timeout for the shortcut indicator
        // Internal UI state
        this.isInputExpanded = false;
        this.isMarkdownMode = false;
        this.popupMenuManager = popupMenuManager;
        this.callbacks = callbacks;
        this.layoutElements = layoutElements; // Store the layout elements passed in
        // Assign class properties directly from the passed layoutElements
        this.inputField = layoutElements.inputField; // Use provided input field
        this.messageContainer = layoutElements.messageContainer;
        this.historyContainer = layoutElements.historyContainer;
        this.titleInput = layoutElements.titleInput;
        this.bottomBarContainer = layoutElements.bottomBarContainer;
        // Initialize and append the keyboard shortcut indicator
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'jp-llm-ext-shortcut-indicator';
        this.keyboardShortcutIndicator.style.display = 'none'; // Hidden by default
        // Append the indicator to the main layout or another appropriate place
        // Ensure the necessary element (e.g., bottomBarContainer) exists before appending
        if (this.bottomBarContainer) { // Check if bottomBarContainer exists from layoutElements
            // Prepend within the main content wrapper, before other elements
            // Or append to bottom bar, depending on desired position
            // Appending after bottomBarContainer seems reasonable
            this.bottomBarContainer.insertAdjacentElement('afterend', this.keyboardShortcutIndicator);
        }
        else {
            // If bottomBarContainer is not available, maybe append to mainElement? 
            // Or log an error if it's essential.
            console.error('UIManager: bottomBarContainer element not found during indicator initialization.');
        }
    }
    /**
     * Returns the core layout elements.
     */
    getUIElements() {
        return this.layoutElements;
    }
    /**
     * Creates the main layout structure for the sidebar.
     * @returns References to key DOM elements.
     */
    createLayout() {
        // Create the main container
        const mainContent = document.createElement('div');
        mainContent.className = 'jp-llm-ext-content-wrapper';
        // --- Title Container ---
        const titleContainer = document.createElement('div');
        titleContainer.className = 'jp-llm-ext-title-container';
        this.titleInput = document.createElement('input');
        this.titleInput.className = 'chat-title-input';
        this.titleInput.type = 'text';
        this.titleInput.placeholder = 'Chat title';
        this.titleInput.value = 'New Chat'; // Default value, widget might update later
        this.titleInput.addEventListener('change', this.callbacks.handleUpdateTitle);
        titleContainer.appendChild(this.titleInput);
        // --- Message & History Containers ---
        this.messageContainer = document.createElement('div');
        this.messageContainer.className = 'jp-llm-ext-message-container';
        this.historyContainer = document.createElement('div');
        this.historyContainer.className = 'jp-llm-ext-history-container';
        this.historyContainer.style.display = 'none'; // Initially hidden
        // --- Bottom Bar ---
        this.bottomBarContainer = document.createElement('div');
        this.bottomBarContainer.className = 'jp-llm-ext-bottom-bar-container';
        // Controls Row (Markdown Toggle, Action Buttons)
        const topRow = document.createElement('div');
        topRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-controls-row';
        const controlsContainer = this.createControlsContainer(); // Creates markdown toggle, @, expand, settings
        topRow.appendChild(controlsContainer);
        // Input Row
        const middleRow = document.createElement('div');
        middleRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-input-row';
        this.inputField = document.createElement('div');
        this.inputField.setAttribute('contenteditable', 'true');
        this.inputField.setAttribute('role', 'textbox');
        this.inputField.setAttribute('aria-multiline', 'true');
        this.inputField.setAttribute('data-placeholder', 'Ask me anything...');
        this.inputField.className = 'jp-llm-ext-input-field';
        // --- Input Event Listener for @ detection ---
        this.inputField.addEventListener('input', (event) => {
            this.handleInputForReference();
        });
        // --- End Input Event Listener ---
        this.inputField.addEventListener('keydown', (event) => {
            console.log(`UI_MANAGER KeyDown: Key='${event.key}', Shift='${event.shiftKey}', Code='${event.code}'`);
            const selection = window.getSelection();
            // --- Backspace handling for widgets ---
            if (event.key === 'Backspace' && selection && selection.isCollapsed) {
                const range = selection.getRangeAt(0);
                const nodeBefore = range.startContainer.childNodes[range.startOffset - 1] || range.startContainer.previousSibling;
                // Check nodeBefore more carefully
                let potentialWidget = null;
                if (range.startOffset > 0 && range.startContainer.childNodes.length >= range.startOffset) {
                    potentialWidget = range.startContainer.childNodes[range.startOffset - 1];
                }
                else if (range.startOffset === 0 && range.startContainer.previousSibling) {
                    potentialWidget = range.startContainer.previousSibling;
                }
                else if (range.startContainer !== this.inputField && range.startContainer.parentNode === this.inputField && range.startOffset === 0) {
                    // Cursor might be at the start of a text node following a widget
                    potentialWidget = range.startContainer.previousSibling;
                }
                if (potentialWidget &&
                    potentialWidget.nodeType === Node.ELEMENT_NODE &&
                    potentialWidget.classList.contains('jp-llm-ext-ref-widget')) {
                    event.preventDefault(); // Stop default backspace
                    potentialWidget.remove(); // Remove the entire widget node
                    // Manually trigger input event for consistency?
                    this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    return; // Stop further processing for this keydown
                }
            }
            // --- End Backspace handling ---
            // --- @ Key Direct Handling ---
            // REMOVED: This logic is now centralized in shortcut-handler.ts
            // --- End @ Key Direct Handling ---
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault(); // Prevent default newline insertion
                const message = this.getSerializedInput();
                if (message.trim()) {
                    this.callbacks.handleSendMessage(message);
                    this.clearInputField();
                }
            }
            // --- New: Handle Tab/Escape for popup interaction ---
            else if (this.popupMenuManager.isPopupMenuVisible()) {
                if (event.key === 'Tab' || event.key === 'Escape' || event.key === 'ArrowUp' || event.key === 'ArrowDown' || event.key === 'Enter') {
                    // Let the PopupMenuManager's document keydown handler manage these
                    // We just need to prevent the default input field behavior
                    if (event.key !== 'Enter') { // Allow Enter to potentially work if menu doesn't handle it
                        event.preventDefault();
                        // We don't stop propagation here; let the document handler in PopupMenuManager receive it.
                    }
                }
            }
            // --- End New ---
        });
        // --- Copy/Paste Event Listeners ---
        this.inputField.addEventListener('copy', (event) => {
            this.handleCopy(event);
        });
        this.inputField.addEventListener('paste', (event) => {
            this.handlePaste(event);
        });
        // --- End Copy/Paste ---
        middleRow.appendChild(this.inputField);
        // Buttons Row (Send, New Chat, History)
        const bottomRow = document.createElement('div');
        bottomRow.className = 'jp-llm-ext-bottom-bar-row jp-llm-ext-buttons-row';
        const sendButton = this.createButton('Send', 'Send message');
        sendButton.classList.add('jp-llm-ext-send-button'); // Specific class for send
        sendButton.addEventListener('click', () => {
            const message = this.getSerializedInput();
            if (message.trim()) {
                this.callbacks.handleSendMessage(message);
                this.clearInputField();
            }
        });
        const newChatButton = this.createButton('+ New Chat', 'Start a new chat');
        newChatButton.addEventListener('click', this.callbacks.handleNewChat);
        const historyButton = this.createButton('History', 'View chat history');
        historyButton.addEventListener('click', this.callbacks.handleToggleHistory);
        bottomRow.appendChild(sendButton);
        bottomRow.appendChild(newChatButton);
        bottomRow.appendChild(historyButton);
        // Assemble Bottom Bar
        this.bottomBarContainer.appendChild(topRow);
        this.bottomBarContainer.appendChild(middleRow);
        this.bottomBarContainer.appendChild(bottomRow);
        // --- Assemble Main Content ---
        mainContent.appendChild(titleContainer);
        mainContent.appendChild(this.messageContainer);
        mainContent.appendChild(this.historyContainer);
        mainContent.appendChild(this.bottomBarContainer);
        // Return references to key elements
        return {
            mainLayout: mainContent,
            messageContainer: this.messageContainer,
            inputField: this.inputField,
            titleInput: this.titleInput,
            historyContainer: this.historyContainer,
            bottomBarContainer: this.bottomBarContainer,
        };
    }
    /**
     * Creates the controls container with toggles and action buttons.
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'jp-llm-ext-controls-container';
        // --- Markdown Toggle ---
        const toggleContainer = document.createElement('div');
        toggleContainer.className = 'jp-llm-ext-toggle-container';
        this.markdownToggle = document.createElement('input');
        this.markdownToggle.type = 'checkbox';
        this.markdownToggle.id = 'markdown-toggle'; // Ensure unique ID or handle differently
        this.markdownToggle.addEventListener('change', (e) => {
            const target = e.target;
            this.isMarkdownMode = target.checked;
            const placeholderText = this.isMarkdownMode
                ? 'Write markdown here...\\n\\n# Example heading\\n- List item\\n\\n```code block```'
                : 'Ask me anything...';
            this.inputField.setAttribute('data-placeholder', placeholderText);
            this.inputField.blur();
            this.inputField.focus();
        });
        const toggleLabel = document.createElement('label');
        toggleLabel.htmlFor = 'markdown-toggle';
        toggleLabel.textContent = 'Markdown mode';
        toggleContainer.appendChild(this.markdownToggle);
        toggleContainer.appendChild(toggleLabel);
        // --- Action Buttons (@, Expand, Settings) ---
        const actionButtonsContainer = document.createElement('div');
        actionButtonsContainer.className = 'jp-llm-ext-action-buttons-container';
        // '@' Button
        const atButton = this.createButton('@', 'Browse cells, code, files, and more');
        atButton.addEventListener('click', (event) => {
            this.callbacks.handleShowPopupMenu(event, event.currentTarget);
        });
        // Expand Button (store reference)
        this.expandButton = this.createButton('⤢', 'Expand input');
        this.expandButton.addEventListener('click', () => this.toggleInputExpansion());
        // Settings Button
        const settingsButton = this.createButton('⚙️', 'Settings');
        settingsButton.addEventListener('click', this.callbacks.handleShowSettings);
        // Add buttons to container
        actionButtonsContainer.appendChild(atButton);
        actionButtonsContainer.appendChild(this.expandButton);
        actionButtonsContainer.appendChild(settingsButton);
        // Assemble Controls Container
        controlsContainer.appendChild(toggleContainer);
        controlsContainer.appendChild(actionButtonsContainer);
        return controlsContainer;
    }
    /**
     * Toggles the expansion state of the input field.
     */
    toggleInputExpansion() {
        if (!this.inputField || !this.expandButton)
            return; // Ensure elements exist
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            this.inputField.style.height = '200px'; // Keep for now, consider CSS classes
            this.inputField.style.resize = 'vertical'; // Works on divs too (if overflow visible/auto)
            this.expandButton.textContent = '⤡';
            this.expandButton.title = 'Collapse input';
        }
        else {
            this.inputField.style.height = ''; // Reset height
            this.inputField.style.resize = 'none';
            this.expandButton.textContent = '⤢';
            this.expandButton.title = 'Expand input';
        }
        // Future: Notify widget/handler if needed: this.callbacks.handleToggleExpansion(this.isInputExpanded);
    }
    /**
     * Helper function to create a styled button.
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        // Apply base JupyterLab button class and our specific class
        button.className = 'jp-Button jp-llm-ext-action-button';
        return button;
    }
    /**
     * Appends a new chat message element to the message container and scrolls down.
     * @param element The message element (user or bot) to add.
     */
    addChatMessageElement(element) {
        if (this.messageContainer) {
            this.messageContainer.appendChild(element);
            this.scrollToBottom(); // Scroll after adding the new element
        }
        else {
            console.error('Message container not initialized in UIManager.');
        }
    }
    /**
     * Scrolls the message container to the bottom.
     */
    scrollToBottom() {
        if (this.messageContainer) {
            this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        }
        else {
            console.error('Message container not initialized in UIManager.');
        }
    }
    /**
     * Switches the view to show the chat history.
     */
    showHistoryView() {
        this.layoutElements.messageContainer.style.display = 'none';
        this.layoutElements.historyContainer.style.display = 'block';
        this.layoutElements.bottomBarContainer.style.display = 'none';
        // Optionally update header/title elements if needed
    }
    /**
     * Switches the view to show the main chat interface.
     */
    showChatView() {
        this.layoutElements.historyContainer.style.display = 'none';
        this.layoutElements.messageContainer.style.display = 'block';
        this.layoutElements.bottomBarContainer.style.display = 'flex'; // Assuming flex display
        this.scrollToBottom(); // Scroll down when showing chat
    }
    /**
     * Clears all messages from the message container.
     */
    clearMessageContainer() {
        this.layoutElements.messageContainer.innerHTML = '';
    }
    /**
     * Updates the value of the title input field.
     */
    updateTitleInput(title) {
        if (this.layoutElements.titleInput) {
            this.layoutElements.titleInput.value = title;
        }
    }
    /**
     * Creates and returns a container structure for a bot message,
     * including elements for streaming text and final rendered content.
     * This helps manage the transition from streaming to final message display.
     */
    createBotMessageContainer() {
        const botMessageDiv = document.createElement('div');
        botMessageDiv.className = 'jp-llm-ext-bot-message'; // Base class
        // Div for streaming content (initially visible)
        const streamingDiv = document.createElement('div');
        streamingDiv.className = 'jp-llm-ext-streaming-content';
        streamingDiv.style.display = 'block'; // Show streaming initially
        // Div for final rendered content (initially hidden)
        const contentDiv = document.createElement('div');
        contentDiv.className = 'jp-llm-ext-rendered-content';
        contentDiv.style.display = 'none'; // Hide final content initially
        botMessageDiv.appendChild(streamingDiv);
        botMessageDiv.appendChild(contentDiv);
        // Add the whole container to the message list *before* streaming starts
        this.addChatMessageElement(botMessageDiv);
        return { botMessageDiv, streamingDiv, contentDiv };
    }
    /**
     * Displays a temporary notification message.
     * TODO: Implement a more robust notification system (e.g., toast).
     */
    showNotification(message, type, duration = 3000) {
        console.log(`Notification (${type}): ${message}`);
        // Basic temporary implementation using the existing indicator element
        const indicator = this.layoutElements.mainElement.querySelector('.jp-llm-ext-keyboard-shortcut-indicator');
        if (indicator) {
            if (this.notificationTimeout) {
                clearTimeout(this.notificationTimeout); // Clear previous timeout
            }
            indicator.textContent = message;
            indicator.className = `jp-llm-ext-keyboard-shortcut-indicator visible jp-llm-ext-notification-${type}`; // Add type class
            this.notificationTimeout = window.setTimeout(() => {
                indicator.classList.remove('visible');
                this.notificationTimeout = null;
            }, duration);
        }
        else {
            console.warn('Notification indicator element not found for UIManager.');
        }
    }
    /**
     * Shows a visual indicator for keyboard shortcuts.
     * @param text The text to display in the indicator.
     */
    showIndicator(text) {
        if (!this.keyboardShortcutIndicator)
            return; // Guard
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Clear any existing timeout to prevent multiple timeouts running
        if (this.notificationTimeout) {
            clearTimeout(this.notificationTimeout);
        }
        // Set new timeout to hide the indicator
        this.notificationTimeout = window.setTimeout(() => {
            if (this.keyboardShortcutIndicator) { // Check if element still exists
                this.keyboardShortcutIndicator.classList.remove('visible');
            }
            this.notificationTimeout = null;
        }, 1000); // Hide after 1 second
    }
    /**
     * Clears the indicator immediately and cancels any pending hide timeout.
     * Useful if the widget is hidden while the indicator is shown.
     */
    clearIndicator() {
        if (!this.keyboardShortcutIndicator)
            return;
        this.keyboardShortcutIndicator.classList.remove('visible');
        this.keyboardShortcutIndicator.textContent = '';
        if (this.notificationTimeout) {
            clearTimeout(this.notificationTimeout);
            this.notificationTimeout = null;
        }
    }
    /**
     * Checks the input field content and cursor position to determine if
     * the reference suggestion popup should be shown or hidden.
     * Triggered on 'input' events.
     */
    handleInputForReference() {
        var _a, _b;
        const selection = window.getSelection();
        if (!selection || !selection.rangeCount || !selection.isCollapsed) {
            // Need a collapsed selection (cursor) inside the input field
            this.popupMenuManager.hidePopupMenu();
            return;
        }
        const range = selection.getRangeAt(0);
        const container = range.startContainer;
        const offset = range.startOffset;
        // Ensure the cursor is within the input field itself
        if (!this.inputField.contains(container)) {
            this.popupMenuManager.hidePopupMenu();
            return;
        }
        // Combine text content from preceding siblings if cursor is at the start of a text node
        let textBeforeCursor = '';
        let currentContainer = container;
        let currentOffset = offset;
        while (currentContainer) {
            if (currentContainer.nodeType === Node.TEXT_NODE) {
                textBeforeCursor = ((_a = currentContainer.textContent) === null || _a === void 0 ? void 0 : _a.substring(0, currentOffset)) + textBeforeCursor;
            }
            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.classList.contains('jp-llm-ext-ref-widget')) {
                // If we encounter a widget before the cursor, we can't be right after '@'
                textBeforeCursor = '[widget]' + textBeforeCursor; // Add placeholder to break '@' sequence
            }
            else if (currentContainer.nodeType === Node.ELEMENT_NODE && currentContainer.tagName === 'BR') {
                textBeforeCursor = '\n' + textBeforeCursor; // Treat BR as newline
            }
            // Move to the previous sibling or parent's previous sibling
            if (currentContainer.previousSibling) {
                currentContainer = currentContainer.previousSibling;
                // If moving to a new node, take its full content
                currentOffset = (currentContainer.textContent || '').length;
            }
            else {
                // Move up to parent, continue search from before the parent
                currentContainer = currentContainer.parentNode;
                if (currentContainer === this.inputField || !currentContainer) {
                    break; // Stop if we reached the input field or top
                }
                currentOffset = Array.prototype.indexOf.call(((_b = currentContainer.parentNode) === null || _b === void 0 ? void 0 : _b.childNodes) || [], currentContainer);
            }
        }
        console.log(`UI_MANAGER handleInput: Text before cursor: "${textBeforeCursor}"`);
        // --- Check for trigger conditions --- 
        const endsWithAt = textBeforeCursor.endsWith('@');
        const endsWithAtSpace = textBeforeCursor.endsWith('@ ');
        if (endsWithAt || endsWithAtSpace) {
            if (this.popupMenuManager.isPopupMenuVisible()) {
                // TODO: If visible, maybe just update the query in the popup?
                console.log('UI_MANAGER handleInput: Popup already visible, skipping show.');
            }
            else {
                // Find the start of the query (after '@' or '@ ')
                const atIndex = textBeforeCursor.lastIndexOf('@');
                let queryStartIndex = atIndex + 1;
                if (endsWithAtSpace) {
                    queryStartIndex = atIndex + 2;
                }
                const query = textBeforeCursor.substring(queryStartIndex);
                // --- Insert temporary span to get reliable coordinates --- 
                const tempAnchorId = 'jp-llm-temp-popup-anchor';
                let tempSpan = document.getElementById(tempAnchorId);
                if (tempSpan)
                    tempSpan.remove(); // Clean up previous if any
                tempSpan = document.createElement('span');
                tempSpan.id = tempAnchorId;
                // Style to be invisible and take no space
                tempSpan.style.visibility = 'hidden';
                tempSpan.style.width = '0';
                tempSpan.style.height = '0';
                tempSpan.style.overflow = 'hidden';
                tempSpan.textContent = '\u200B'; // Zero-width space might help rendering
                // Insert the span at the current cursor position
                range.insertNode(tempSpan);
                const spanRect = tempSpan.getBoundingClientRect();
                tempSpan.remove(); // Remove immediately after getting coords
                // --- End temporary span logic ---
                if (spanRect.top === 0 && spanRect.left === 0) {
                    console.error("UI_MANAGER handleInput: Failed to get valid coordinates from temp anchor span.");
                    // Fallback or alternative positioning might be needed here
                    // Maybe position relative to input field bottom-left?
                    this.popupMenuManager.hidePopupMenu(); // Don't show if coords are bad
                }
                else {
                    console.log(`UI_MANAGER handleInput: Anchor coords from temp span: Top=${spanRect.top}, Left=${spanRect.left}`);
                    // Show the TOP LEVEL suggestions using the reliable coordinates
                    // Pass the coordinates directly to showPopupMenu
                    this.popupMenuManager.showPopupMenu(spanRect.top, spanRect.left);
                }
            }
        }
        else {
            // If text doesn't end with @ or @-space, hide the popup
            // Only hide if it was previously showing the 'top' or 'references' menu triggered by '@'
            // Avoid hiding menus triggered by the button click unnecessarily
            if (this.popupMenuManager.isPopupMenuVisible()) { // && (this.popupMenuManager.getCurrentMenuLevel() === 'references' || /* Need way to know if triggered by @ */ )) {
                console.log('UI_MANAGER handleInput: Hiding popup, trigger condition no longer met.');
                this.popupMenuManager.hidePopupMenu();
            }
        }
        // TODO: Update popup query if it's already visible and the text after @ changes
        // (Need more robust logic here, considering backspace, etc.)
    }
    /**
     * Serializes the content of the input field, converting known widgets
     * back to their reference strings (e.g., @file:path/to/file.txt).
     *
     * NOTE: This currently uses a simple text serialization. For full fidelity
     * preserving structure (like multiple paragraphs), a more complex approach
     * (e.g., HTML processing or a dedicated editor model) would be needed.
     *
     * @returns {string} The serialized plain text content of the input field.
     */
    getSerializedInput() {
        let serialized = '';
        const nodes = this.inputField.childNodes;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.nodeType === Node.TEXT_NODE) {
                serialized += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {
                    // Append the reference text stored in the data attribute
                    serialized += element.dataset.referenceText;
                }
                else if (element.tagName === 'BR') {
                    // Convert BR tags back to newlines
                    serialized += '\n';
                }
                else if (element.tagName === 'DIV') {
                    // Handle DIV elements (might be inserted by browser on paste/enter)
                    // Add newline before if needed, then serialize children recursively?
                    if (i > 0) { // Add newline only if not the first element
                        serialized += '\n';
                    }
                    serialized += this.serializeNodeChildren(element); // Recursively serialize children
                }
                else {
                    // Include text content of other unexpected elements, but log a warning
                    console.warn('UIManager getSerializedInput: Encountered unexpected element:', element.tagName);
                    serialized += element.textContent;
                }
            } // Ignore other node types (comments, etc.)
        }
        return serialized.trim(); // Trim leading/trailing whitespace
    }
    // Helper to serialize children of a node (e.g., for DIVs)
    serializeNodeChildren(parentNode) {
        let content = '';
        const nodes = parentNode.childNodes;
        for (let i = 0; i < nodes.length; i++) {
            const node = nodes[i];
            if (node.nodeType === Node.TEXT_NODE) {
                content += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {
                    content += element.dataset.referenceText;
                }
                else if (element.tagName === 'BR') {
                    content += '\n';
                }
                else {
                    // Recursively handle nested elements if necessary, or just get text content
                    content += this.serializeNodeChildren(element);
                }
            }
        }
        return content;
    }
    clearInputField() {
        this.inputField.innerHTML = ''; // Clear all content
        // Reset expansion state if needed
        if (this.isInputExpanded) {
            this.toggleInputExpansion();
        }
        // Ensure placeholder reappears if using CSS for it
        this.inputField.dispatchEvent(new Event('input')); // Trigger event to update UI state if necessary
    }
    /**
     * Handles the 'copy' event to put serialized plain text onto the clipboard.
     */
    handleCopy(event) {
        const selection = window.getSelection();
        if (!selection || selection.isCollapsed || !event.clipboardData) {
            return; // Nothing selected or no clipboard data object
        }
        const range = selection.getRangeAt(0);
        // Ensure the selection is within our input field
        if (!this.inputField.contains(range.commonAncestorContainer)) {
            return;
        }
        const selectedText = this.serializeRangeContent(range);
        event.preventDefault(); // Prevent default copy behavior
        event.clipboardData.setData('text/plain', selectedText);
        console.log('UIManager handleCopy: Copied serialized text:', selectedText);
    }
    /**
     * Handles the 'paste' event to insert plain text content.
     */
    handlePaste(event) {
        var _a;
        if (!event.clipboardData) {
            return;
        }
        const text = event.clipboardData.getData('text/plain');
        if (text) {
            event.preventDefault(); // Prevent default paste behavior
            // Insert the plain text at the current cursor position
            const selection = window.getSelection();
            if (selection && selection.rangeCount > 0) {
                const range = selection.getRangeAt(0);
                range.deleteContents(); // Delete selected content if any
                const textNode = document.createTextNode(text);
                range.insertNode(textNode);
                // Move cursor after inserted text
                range.setStartAfter(textNode);
                range.setEndAfter(textNode);
                selection.removeAllRanges();
                selection.addRange(range);
                // Ensure scroll into view and trigger input event for potential updates
                this.inputField.focus();
                (_a = textNode.parentElement) === null || _a === void 0 ? void 0 : _a.scrollIntoView({ block: 'nearest' });
                this.inputField.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            }
            console.log('UIManager handlePaste: Pasted text:', text);
        }
    }
    // --- Methods for updating UI elements will be added later ---
    // e.g., updateMessageContainer(html: string), showHistoryView(), showChatView()
    // --- Potentially add methods to get element references if needed externally ---
    // public getInputField(): HTMLTextAreaElement { return this.inputField; }
    // etc.
    // Helper to serialize a range (needed for copy)
    serializeRangeContent(range) {
        const fragment = range.cloneContents();
        let tempDiv = document.createElement('div');
        tempDiv.appendChild(fragment);
        // Now, serialize tempDiv's content like we do for getSerializedInput
        let serialized = '';
        const nodes = tempDiv.childNodes;
        const serializeNode = (node) => {
            if (node.nodeType === Node.TEXT_NODE) {
                serialized += node.textContent;
            }
            else if (node.nodeType === Node.ELEMENT_NODE) {
                const element = node;
                if (element.classList.contains('jp-llm-ext-ref-widget') && element.dataset.referenceText) {
                    serialized += element.dataset.referenceText;
                }
                else if (element.tagName === 'BR') {
                    serialized += '\n';
                }
                else { // For other elements (like DIVs potentially in fragment), serialize children
                    const childNodes = element.childNodes;
                    for (let j = 0; j < childNodes.length; j++) {
                        serializeNode(childNodes[j]);
                    }
                }
            }
        };
        for (let i = 0; i < nodes.length; i++) {
            serializeNode(nodes[i]);
        }
        return serialized;
    }
}
exports.UIManager = UIManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/clipboard.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/clipboard.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.copyToClipboard = copyToClipboard;
exports.copyMessageToClipboard = copyMessageToClipboard;
exports.copyImageToClipboard = copyImageToClipboard;
/**
 * Helper function to copy text to clipboard.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyToClipboard(text, feedbackCallback) {
    try {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Content copied to clipboard');
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(); // Call optional feedback callback
        }).catch(err => {
            console.error('Failed to copy text: ', err);
        });
    }
    catch (error) {
        console.error('Error copying text to clipboard:', error);
    }
}
/**
 * Copies message content to clipboard.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyMessageToClipboard(text, feedbackCallback) {
    try {
        navigator.clipboard.writeText(text).then(() => {
            console.log('Message content copied to clipboard');
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success
        }).catch(err => {
            console.error('Failed to copy message text: ', err);
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
        });
    }
    catch (error) {
        console.error('Error copying message to clipboard:', error);
        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
    }
}
/**
 * Copies an image to the clipboard from a given URL.
 * Provides visual feedback via console logs and optionally a callback.
 */
function copyImageToClipboard(imageUrl, feedbackCallback) {
    try {
        fetch(imageUrl)
            .then(response => {
            if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.statusText}`);
            }
            return response.blob();
        })
            .then(blob => {
            // Create a ClipboardItem with the image blob
            // Note: ClipboardItem might not be defined in all environments
            // You might need to add `"dom.iterable"` to tsconfig lib or handle appropriately.
            const item = new ClipboardItem({ [blob.type]: blob });
            navigator.clipboard.write([item]).then(() => {
                console.log('Image copied to clipboard');
                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(true); // Indicate success
            })
                .catch(err => {
                console.error('Failed to copy image to clipboard: ', err);
                alert('Failed to copy image: ' + err.message); // Keep alert for critical user feedback
                feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
            });
        })
            .catch(err => {
            console.error('Failed to fetch or process image: ', err);
            alert('Failed to fetch image: ' + err.message); // Keep alert for critical user feedback
            feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
        });
    }
    catch (error) {
        console.error('Error preparing image copy:', error);
        alert('Error copying image: ' + error); // Keep alert for critical user feedback
        feedbackCallback === null || feedbackCallback === void 0 ? void 0 : feedbackCallback(false); // Indicate failure
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/content-editable-utils.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/content-editable-utils.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getCaretPosition = getCaretPosition;
exports.setCaretPosition = setCaretPosition;
/**
 * Gets the caret position within a contenteditable element.
 * Returns the linear offset from the start of the element's text content.
 */
function getCaretPosition(element) {
    const selection = window.getSelection();
    if (!selection || selection.rangeCount === 0 || !element.contains(selection.anchorNode)) {
        // Check if selection is within the element
        return 0;
    }
    const range = selection.getRangeAt(0);
    // Create a range that spans from the beginning of the element to the caret
    const preCaretRange = range.cloneRange();
    preCaretRange.selectNodeContents(element);
    preCaretRange.setEnd(range.startContainer, range.startOffset);
    // The length of the text content within this pre-caret range is the position
    // Using toString() is generally more reliable than textContent for range length
    return preCaretRange.toString().length;
}
/**
 * Sets the caret position within a contenteditable element.
 * @param element The contenteditable element.
 * @param position The desired linear offset from the start of the text content.
 */
function setCaretPosition(element, position) {
    var _a;
    const selection = window.getSelection();
    if (!selection) {
        return;
    }
    const range = document.createRange();
    let charCount = 0;
    let foundNode = false;
    let nodeStack = [element]; // Use a stack for DFS traversal
    // Depth-first search to find the correct text node and offset
    while (nodeStack.length > 0) {
        const node = nodeStack.pop();
        if (node.nodeType === Node.TEXT_NODE) {
            const textLength = ((_a = node.textContent) === null || _a === void 0 ? void 0 : _a.length) || 0;
            if (position >= charCount && position <= charCount + textLength) {
                range.setStart(node, position - charCount);
                range.setEnd(node, position - charCount);
                foundNode = true;
                break; // Found the node, exit loop
            }
            charCount += textLength;
        }
        else if (node.nodeType === Node.ELEMENT_NODE) {
            const elementNode = node;
            if (elementNode.tagName === 'BR') {
                if (position === charCount) { // Position is right before BR
                    range.setStartBefore(node);
                    range.setEndBefore(node);
                    foundNode = true;
                    break;
                }
                charCount += 1; // Treat BR as one character
            }
            else if (elementNode.getAttribute('contenteditable') === 'false') {
                // Treat non-editable elements (like our widgets) as single characters
                if (position === charCount) {
                    // Position is right before the widget
                    range.setStartBefore(node);
                    range.setEndBefore(node);
                    foundNode = true;
                    break;
                }
                charCount += 1;
            }
            else {
                // Add child nodes to the stack in reverse order for correct DFS
                const children = node.childNodes;
                for (let i = children.length - 1; i >= 0; i--) {
                    nodeStack.push(children[i]);
                }
            }
        }
    }
    // If the position is beyond the content or wasn't found, place cursor at the end
    if (!foundNode) {
        range.selectNodeContents(element);
        range.collapse(false); // Collapse to the end
    }
    selection.removeAllRanges();
    selection.addRange(range);
    // Restore focus only if the element was previously focused or is the target
    // This avoids stealing focus unnecessarily
    if (document.activeElement !== element) {
        element.focus({ preventScroll: true }); // preventScroll helps avoid jumping
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/highlighting.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/highlighting.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.detectLanguage = detectLanguage;
exports.highlightCode = highlightCode;
const highlight_js_1 = __importDefault(__webpack_require__(/*! highlight.js */ "webpack/sharing/consume/default/highlight.js/highlight.js"));
/**
 * Detects the programming language from code block content using highlight.js
 * and custom pattern matching for common languages.
 */
function detectLanguage(code) {
    try {
        // Try auto detection first with a limited set of common languages
        const result = highlight_js_1.default.highlightAuto(code, [
            'python', 'javascript', 'typescript', 'java',
            'html', 'css', 'cpp', 'csharp', 'sql', 'rust',
            'php', 'bash', 'json', 'xml', 'markdown'
        ]);
        // If confidence is reasonably high, use that language
        if (result.relevance > 5 && result.language) {
            return result.language;
        }
        // Fall back to basic pattern matching for better accuracy on ambiguous cases
        if (/^(?:\s*)?(?:import\s+[^;]+;|package\s+[^;]+;|public\s+class)/.test(code)) {
            return 'java';
        }
        else if (/^(?:\s*)?(import|from|def|class|if __name__)/.test(code)) {
            return 'python';
        }
        else if (/^(?:\s*)?(?:function|const|let|var|import|export|=>)/.test(code)) {
            // Broader check for JS/TS
            if (/^(?:\s*)?(?:import\s.+|export\s.+|interface|type|enum|declare|:|\s<)/.test(code)) {
                return 'typescript';
            }
            return 'javascript';
        }
        else if (/^(?:\s*)?(?:<!DOCTYPE|<html|<head|<body)/i.test(code)) {
            return 'html';
        }
        else if (/^(?:\s*)?#include/.test(code)) {
            return 'cpp';
        }
        else if (/^(?:\s*)?(?:using\s+System|namespace|public\s+static\s+void\s+Main)/.test(code)) {
            return 'csharp';
        }
        else if (/^(?:\s*)?(?:SELECT|INSERT|UPDATE|DELETE|CREATE|ALTER)\s/i.test(code)) {
            return 'sql';
        }
        else if (/^(?:\s*)?(?:fn|let|struct|enum|trait|impl|mod)\s/.test(code)) {
            return 'rust';
        }
        else if (/^(?:\s*)?(?:<\?php|use\s+[\w\\]+;)/.test(code)) {
            return 'php';
        }
        else if (/^(?:\s*)?(?:#\s*!\/bin\/(?:bash|sh|zsh)|\$)/.test(code)) {
            return 'bash';
        }
        else if (/^\s*\{/.test(code) && /\}\s*$/.test(code)) {
            // Simple check for JSON-like structure
            return 'json';
        }
        else if (/^\s*<\?xml/.test(code) || /^\s*<\w+/.test(code)) {
            // Simple check for XML/HTML like structure
            return 'xml';
        }
        // If no specific language detected, return empty string for default handling
        return '';
    }
    catch (error) {
        console.error('Error detecting language:', error);
        return ''; // Return empty on error
    }
}
/**
 * Highlights code using highlight.js.
 * Falls back to auto-detection if the specified language is not supported.
 */
function highlightCode(code, language) {
    try {
        if (language && highlight_js_1.default.getLanguage(language)) {
            return highlight_js_1.default.highlight(code, { language, ignoreIllegals: true }).value;
        }
        else {
            // Fallback to auto-detection if language is empty or not registered
            return highlight_js_1.default.highlightAuto(code).value;
        }
    }
    catch (error) {
        console.error(`Error highlighting code (language: ${language || 'auto'}):`, error);
        // Return original code escaped for safety on error
        return code.replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/markdown-config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Normalize line endings
    const normalizedText = text.replace(/\r\n/g, '\n');
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = normalizedText.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks:
        // 1. Handle list items with proper spacing
        // 2. Trim excessive whitespace at start and end, but preserve indentation within lines
        let processed = line;
        // Handle dash list items by ensuring they have a space after the dash
        processed = processed.replace(/(\s*)-(\S)/g, '$1- $2');
        // Handle mixed space/dash issues - ensure proper newlines before list items
        processed = processed.replace(/([^\n\s])-\s/g, '$1\n- ');
        return processed;
    });
    // Join lines and ensure code blocks are properly formatted
    let result = processedLines.join('\n');
    // Handle empty code blocks (add a space so they render properly)
    result = result.replace(/```(.*)\n```/g, '```$1\n \n```');
    return result;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/utils/notebook-integration.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.addMessageToCell = addMessageToCell;
exports.getSelectedText = getSelectedText;
exports.getCurrentCellContent = getCurrentCellContent;
exports.insertCellContentByIndex = insertCellContentByIndex;
const globals_1 = __webpack_require__(/*! ../core/globals */ "./node_modules/jupyter-simple-extension/lib/core/globals.js");
/**
 * Adds message content to the current cell in the active notebook.
 */
function addMessageToCell(text) {
    var _a;
    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (!cell || !cell.editor) {
        console.warn('Cannot add message: No active cell or editor found.');
        return;
    }
    try {
        const editor = cell.editor;
        // Access the underlying CodeMirror editor view (adjust if using a different editor)
        const view = editor.editor;
        if (!view) {
            console.warn('Cannot add message: CodeMirror view not accessible.');
            return;
        }
        // Get current cursor position
        const state = view.state;
        const selection = state.selection;
        const cursorPos = selection.main.head;
        // Insert newline and message content at cursor position
        const transaction = state.update({
            changes: {
                from: cursorPos,
                insert: `\n${text}`
            },
            // Optionally move cursor to end of inserted text
            selection: { anchor: cursorPos + text.length + 1 }
        });
        view.dispatch(transaction);
    }
    catch (error) {
        console.error('Error adding message to cell:', error);
    }
}
/**
 * Gets the currently selected text from the active notebook cell or text editor.
 */
function getSelectedText() {
    var _a, _b, _c;
    const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (cell === null || cell === void 0 ? void 0 : cell.editor) {
        const editor = cell.editor;
        const cmEditor = editor.editor; // Access CodeMirror editor instance
        if (cmEditor && cmEditor.state) {
            const state = cmEditor.state;
            const selection = state.selection.main;
            return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);
        }
        console.warn("Could not access CodeMirror state to get selection.");
        return null;
    }
    else {
        // Fallback for non-notebook editors (e.g., text editor)
        const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
        if (activeWidget && 'content' in activeWidget && activeWidget.content.editor) {
            const editor = activeWidget.content.editor;
            const cmEditor = editor.editor;
            if (cmEditor && cmEditor.state) {
                const state = cmEditor.state;
                const selection = state.selection.main;
                return selection.empty ? null : state.doc.sliceString(selection.from, selection.to);
            }
            console.warn("Could not access CodeMirror state for non-notebook editor selection.");
            return null;
        }
    }
    return null;
}
/**
 * Gets the content of the currently active notebook cell or text editor.
 */
function getCurrentCellContent() {
    var _a, _b, _c, _d, _e;
    const activeCell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
    if (activeCell === null || activeCell === void 0 ? void 0 : activeCell.model) {
        // Try using sharedModel first (more robust)
        if (activeCell.model.sharedModel && typeof activeCell.model.sharedModel.getSource === 'function') {
            return activeCell.model.sharedModel.getSource();
        }
        // Fallback: Try using toJSON().source
        const cellJson = activeCell.model.toJSON();
        const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
        if (typeof source === 'string') {
            return source;
        }
        else if (Array.isArray(source)) {
            return source.join('\n');
        }
        console.warn("Could not get cell content via sharedModel or toJSON().source");
        return null;
    }
    // Fallback for non-notebook editors if needed
    const activeWidget = (_c = (_b = globals_1.globals.app) === null || _b === void 0 ? void 0 : _b.shell) === null || _c === void 0 ? void 0 : _c.currentWidget;
    if (activeWidget && 'content' in activeWidget && activeWidget.content.model) {
        // Assuming model.value.text for generic text editors
        return (_e = (_d = activeWidget.content.model.value) === null || _d === void 0 ? void 0 : _d.text) !== null && _e !== void 0 ? _e : null;
    }
    return null;
}
/**
 * Gets cell content by index from the current notebook and calls a callback to insert it.
 * NOTE: The original function called `this.appendToInput`. This functionality needs
 *       to be provided via the `insertCallback`.
 */
function insertCellContentByIndex(index, insertCallback) {
    try {
        if (!globals_1.globals.notebookTracker || !globals_1.globals.notebookTracker.currentWidget) {
            console.error('No active notebook found');
            return;
        }
        const notebookPanel = globals_1.globals.notebookTracker.currentWidget;
        const model = notebookPanel.content.model;
        if (!model || !model.cells || index < 0 || index >= model.cells.length) {
            console.error(`Invalid cell index: ${index}`);
            return;
        }
        const cell = model.cells.get(index);
        let cellContent = '';
        // Get cell content - handle different ways content might be stored
        if (cell.sharedModel && typeof cell.sharedModel.getSource === 'function') {
            cellContent = cell.sharedModel.getSource();
        }
        else {
            const cellJson = cell.toJSON();
            const source = cellJson === null || cellJson === void 0 ? void 0 : cellJson.source;
            if (typeof source === 'string') {
                cellContent = source;
            }
            else if (Array.isArray(source)) {
                cellContent = source.join('\n');
            }
        }
        // Insert cell reference with content using the callback
        insertCallback(`cell ${cellContent}`);
    }
    catch (error) {
        console.error('Error inserting cell by index:', error);
    }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy4xYzJlNGJiNmVlZDdjNjEwNjMxZi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7Ozs7Ozs7OztBQzdJYjtBQUNiLDhDQUE2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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLEtBQUs7QUFDbEMsYUFBYTtBQUNiO0FBQ0EseUJBQXlCO0FBQ3pCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsWUFBWTtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY2VsbC1jb250ZXh0LXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY29tbWFuZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY29yZS9hcGktY2xpZW50LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NvcmUvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jb3JlL2ljb25zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2hhbmRsZXJzL2hpc3RvcnktaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9pbnB1dC1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2hhbmRsZXJzL21lc3NhZ2UtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9wb3B1cC1tZW51LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvaGFuZGxlcnMvc2V0dGluZ3MtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9oYW5kbGVycy9zaG9ydGN1dC1oYW5kbGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3NpZGViYXItd2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3N0YXRlL2NoYXQtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvc3RhdGUvc2V0dGluZ3Mtc3RhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdWkvZG9tLWVsZW1lbnRzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL2xheW91dC1idWlsZGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3VpL21lc3NhZ2UtcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdWkvc2V0dGluZ3MtbW9kYWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdWkvdWktbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91dGlscy9jbGlwYm9hcmQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdXRpbHMvY29udGVudC1lZGl0YWJsZS11dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi91dGlscy9oaWdobGlnaHRpbmcuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvdXRpbHMvbWFya2Rvd24tY29uZmlnLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL3V0aWxzL25vdGVib29rLWludGVncmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSB2b2lkIDA7XG4vKipcbiAqIFRyYWNrcyBjZWxsIGNvbnRleHQgYW5kIGN1cnNvciBwb3NpdGlvbiB3aXRoaW4gSnVweXRlciBub3RlYm9va3NcbiAqL1xuY2xhc3MgQ2VsbENvbnRleHRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGVkaXRvciBldmVudHMgKGtleWRvd24sIG1vdXNldXApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUVkaXRvckV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbCBmcm9tIHRoZSB0cmFja2VyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGlubmVyIEVkaXRvclZpZXcgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYW5kIHN0b3JlIHRoZSBjdXJzb3IgY29udGV4dFxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gdGhpcy5nZXRDbUNvbnRleHQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZWRpdG9yIGV2ZW50IGhhbmRsZXI6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG4gICAgICAgIHRoaXMuc2V0dXBUcmFja2VycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGhhcyBiZWVuIGRpc3Bvc2VkXG4gICAgICovXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IHRyYWNrZXJzXG4gICAgICovXG4gICAgc2V0dXBUcmFja2VycygpIHtcbiAgICAgICAgLy8gSGFuZGxlIGFjdGl2ZSBjZWxsIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIC8vIEhhbmRsZSBub3RlYm9vayBjaGFuZ2VzXG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmNvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAqL1xuICAgIGhhbmRsZU5vdGVib29rQ2hhbmdlKHRyYWNrZXIsIHBhbmVsKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmIChwYW5lbCAmJiBwYW5lbC5jb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gcGFuZWwuY29udGVudC5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENlbGxMaXN0ZW5lcnModHJhY2tlciwgY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgc2V0dXBDZWxsTGlzdGVuZXJzKF90cmFja2VyLCBjZWxsKSB7XG4gICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKGNlbGwuZWRpdG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxOb2RlID0gY2VsbC5ub2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvck5vZGUgPSBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtRWRpdG9yJykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUucXVlcnlTZWxlY3RvcignLmpwLUlucHV0QXJlYS1lZGl0b3InKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gZWRpdG9yTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyBmb3Iga2V5IGFuZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY2FwdHVyZSBpbW1lZGlhdGUgY29udGV4dCBpZiBFZGl0b3JWaWV3IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gY2VsbC5lZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZXR0aW5nIHVwIGNlbGwgbGlzdGVuZXJzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBhY3RpdmUgY2VsbFxuICAgICAqL1xuICAgIGNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbnRleHQgaW5mb3JtYXRpb24gZnJvbSBDb2RlTWlycm9yIEVkaXRvclZpZXdcbiAgICAgKi9cbiAgICBnZXRDbUNvbnRleHQodmlldykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIGNvbnN0IGZ1bGxUZXh0ID0gc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGluZTogbGluZS5udW1iZXIgLSAxLFxuICAgICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBsaW5lLmZyb20sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0UmFkaXVzID0gMTAwO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIG9mZnNldCAtIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihmdWxsVGV4dC5sZW5ndGgsIG9mZnNldCArIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBjb250ZXh0QmVmb3JlOiBmdWxsVGV4dC5zdWJzdHJpbmcoc3RhcnQsIG9mZnNldCksXG4gICAgICAgICAgICBjb250ZXh0QWZ0ZXI6IGZ1bGxUZXh0LnN1YnN0cmluZyhvZmZzZXQsIGVuZClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBjZWxsIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2VsbENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDZWxsQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgYWxsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGxDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5zZXR1cENlbGxMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuaGFuZGxlTm90ZWJvb2tDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2VsbENvbnRleHRUcmFja2VyID0gQ2VsbENvbnRleHRUcmFja2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnJlZ2lzdGVyQ29tbWFuZHMgPSByZWdpc3RlckNvbW1hbmRzO1xuY29uc3QgdWlfY29tcG9uZW50c18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL3VpLWNvbXBvbmVudHNcIik7IC8vIEltcG9ydCBMYWJJY29uIGlmIG5lZWRlZCBhcyBwbGFjZWhvbGRlclxuLy8gUGxhY2Vob2xkZXIgaWNvbiAocmVwbGFjZSBpZiB5b3UgaGF2ZSBhIHNwZWNpZmljIGljb24pXG5jb25zdCBleHRlbnNpb25JY29uID0gdWlfY29tcG9uZW50c18xLkxhYkljb24ucmVzb2x2ZSh7IGljb246ICd1aS1jb21wb25lbnRzOmp1cHl0ZXJsYWInIH0pOyAvLyBVc2UgcmVzb2x2ZSBmb3IgYnVpbHQtaW5cbi8qKlxuICogUmVnaXN0ZXJzIGNvbW1hbmRzIGZvciB0aGUgZXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29tbWFuZHMoYXBwLCBwYWxldHRlLCBsYXVuY2hlciwgc2lkZWJhcldpZGdldCkge1xuICAgIC8vIEFkZCBjb21tYW5kIHRvIHRvZ2dsZSB0aGUgc2lkZWJhclxuICAgIGFwcC5jb21tYW5kcy5hZGRDb21tYW5kKCdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJywge1xuICAgICAgICBsYWJlbDogJ1RvZ2dsZSBBSSBBc3Npc3RhbnQgU2lkZWJhcicsXG4gICAgICAgIGljb246IGV4dGVuc2lvbkljb24sXG4gICAgICAgIGV4ZWN1dGU6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChzaWRlYmFyV2lkZ2V0LmlzQXR0YWNoZWQpIHtcbiAgICAgICAgICAgICAgICBzaWRlYmFyV2lkZ2V0LnBhcmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhcHAuc2hlbGwuYWRkKHNpZGViYXJXaWRnZXQsICdsZWZ0JywgeyByYW5rOiA5OTk5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIHRoZSBjb21tYW5kIHRvIHRoZSBjb21tYW5kIHBhbGV0dGVcbiAgICBwYWxldHRlLmFkZEl0ZW0oe1xuICAgICAgICBjb21tYW5kOiAnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsXG4gICAgICAgIGNhdGVnb3J5OiAnRXh0ZW5zaW9uJ1xuICAgIH0pO1xuICAgIC8vIEFkZCBhIGxhdW5jaGVyIGl0ZW1cbiAgICBsYXVuY2hlci5hZGQoe1xuICAgICAgICBjb21tYW5kOiAnc2ltcGxlLWV4dGVuc2lvbjp0b2dnbGUtc2lkZWJhcicsXG4gICAgICAgIGNhdGVnb3J5OiAnT3RoZXInLFxuICAgICAgICByYW5rOiA5OTk5XG4gICAgfSk7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBpQ2xpZW50ID0gdm9pZCAwO1xuLyoqXG4gKiBBUEkgY2xpZW50IGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBiYWNrZW5kIExMTSBzZXJ2aWNlXG4gKi9cbmNsYXNzIEFwaUNsaWVudCB7XG4gICAgY29uc3RydWN0b3IoYmFzZVVybCA9ICdodHRwOi8vbG9jYWxob3N0OjgwMDAnKSB7XG4gICAgICAgIHRoaXMuYmFzZVVybCA9IGJhc2VVcmw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0cmVhbSBhIGNoYXQgcmVzcG9uc2UgZnJvbSB0aGUgbW9jayBMTE1cbiAgICAgKiBAcGFyYW0gbWVzc2FnZSBUaGUgdXNlciBtZXNzYWdlIHRvIHNlbmRcbiAgICAgKiBAcGFyYW0gY29udGV4dCBPcHRpb25hbCBjb250ZXh0IGluZm9ybWF0aW9uXG4gICAgICogQHBhcmFtIG9uQ2h1bmsgQ2FsbGJhY2sgZm9yIGVhY2ggdGV4dCBjaHVuayByZWNlaXZlZFxuICAgICAqIEBwYXJhbSBvbkNvbXBsZXRlIENhbGxiYWNrIHdoZW4gc3RyZWFtaW5nIGlzIGNvbXBsZXRlXG4gICAgICogQHBhcmFtIG9uRXJyb3IgQ2FsbGJhY2sgZm9yIGVycm9yc1xuICAgICAqL1xuICAgIGFzeW5jIHN0cmVhbUNoYXQobWVzc2FnZSwgY29udGV4dCA9IG51bGwsIG9uQ2h1bmssIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9jaGF0YCwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFQSSBlcnJvcjogJHtyZXNwb25zZS5zdGF0dXNUZXh0fWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWFkYWJsZVN0cmVhbSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3Nlci4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNldCB1cCBzdHJlYW0gcmVhZGluZ1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gcmVzcG9uc2UuYm9keS5nZXRSZWFkZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lOiByZWFkZXJEb25lIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgICAgICAgIGRvbmUgPSByZWFkZXJEb25lO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaHVuayA9IGRlY29kZXIuZGVjb2RlKHZhbHVlLCB7IHN0cmVhbTogIWRvbmUgfSk7XG4gICAgICAgICAgICAgICAgICAgIG9uQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIG9uRXJyb3IoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciA/IGVycm9yIDogbmV3IEVycm9yKFN0cmluZyhlcnJvcikpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaW1wbGUgaGVhbHRoIGNoZWNrIGZvciB0aGUgQVBJXG4gICAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdHJ1ZSBpZiB0aGUgQVBJIGlzIGhlYWx0aHlcbiAgICAgKi9cbiAgICBhc3luYyBoZWFsdGhDaGVjaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7dGhpcy5iYXNlVXJsfS9oZWFsdGhgKTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5vaztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBoZWFsdGggY2hlY2sgZmFpbGVkOicsIGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQXBpQ2xpZW50ID0gQXBpQ2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdsb2JhbHMgPSB2b2lkIDA7XG5leHBvcnRzLmluaXRHbG9iYWxzID0gaW5pdEdsb2JhbHM7XG4vKipcbiAqIEdsb2JhbCByZWZlcmVuY2VzIHRvIGtleSBjb21wb25lbnRzIGluIHRoZSBhcHBsaWNhdGlvblxuICovXG5leHBvcnRzLmdsb2JhbHMgPSB7fTtcbi8qKlxuICogSW5pdGlhbGl6ZSBnbG9iYWwgcmVmZXJlbmNlc1xuICovXG5mdW5jdGlvbiBpbml0R2xvYmFscyhhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgIGV4cG9ydHMuZ2xvYmFscy5hcHAgPSBhcHA7XG4gICAgZXhwb3J0cy5nbG9iYWxzLm5vdGVib29rVHJhY2tlciA9IG5vdGVib29rVHJhY2tlcjtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5leHRlbnNpb25JY29uID0gdm9pZCAwO1xuY29uc3QgdWlfY29tcG9uZW50c18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL3VpLWNvbXBvbmVudHNcIik7XG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4vLyBJY29uIERlZmluaXRpb25cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbmNvbnN0IGljb25TdmdTdHIgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgZmlsbD1cImN1cnJlbnRDb2xvclwiIGNsYXNzPVwiYmkgYmktY2hhdC1sZWZ0LXRleHRcIiB2aWV3Qm94PVwiMCAwIDE2IDE2XCI+JyArXG4gICAgJzxwYXRoIGQ9XCJNMTQgMWExIDEgMCAwIDEgMSAxdjhhMSAxIDAgMCAxLTEgMUg0LjQxNEEyIDIgMCAwIDAgMyAxMS41ODZsLTIgMlYyYTEgMSAwIDAgMSAxLTFoMTJ6TTIgMGEyIDIgMCAwIDAtMiAydjEyLjc5M2EuNS41IDAgMCAwIC44NTQuMzUzbDIuODUzLTIuODUzQTEgMSAwIDAgMSA0LjQxNCAxMkgxNGEyIDIgMCAwIDAgMi0yVjJhMiAyIDAgMCAwLTItMkgyelwiLz4nICtcbiAgICAnPHBhdGggZD1cIk0zIDMuNWEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlhLjUuNSAwIDAgMS0uNS0uNXpNMyA2YS41LjUgMCAwIDEgLjUtLjVoOWEuNS41IDAgMCAxIDAgMWgtOUEuNS41IDAgMCAxIDMgNnptMCAyLjVhLjUuNSAwIDAgMSAuNS0uNWg1YS41LjUgMCAwIDEgMCAxaC01YS41LjUgMCAwIDEtLjUtLjV6XCIvPicgK1xuICAgICc8L3N2Zz4nO1xuLyoqXG4gKiBJY29uIGZvciB0aGUgQUkgQXNzaXN0YW50IGV4dGVuc2lvblxuICovXG5leHBvcnRzLmV4dGVuc2lvbkljb24gPSBuZXcgdWlfY29tcG9uZW50c18xLkxhYkljb24oe1xuICAgIG5hbWU6ICdzaW1wbGU6aWNvbicsXG4gICAgc3Znc3RyOiBpY29uU3ZnU3RyXG59KTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5IaXN0b3J5SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi91aS9tZXNzYWdlLXJlbmRlcmVyXCIpOyAvLyBBc3N1bWluZyByZW5kZXJlcnMgYXJlIG5lZWRlZFxuLyoqXG4gKiBNYW5hZ2VzIHRoZSBkaXNwbGF5IGFuZCBpbnRlcmFjdGlvbiBsb2dpYyBmb3IgdGhlIGNoYXQgaGlzdG9yeSB2aWV3LlxuICovXG5jbGFzcyBIaXN0b3J5SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoY2hhdFN0YXRlLCB1aU1hbmFnZXIsIGNhbGxiYWNrcywgcmVuZGVyZXJDYWxsYmFja3MpIHtcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY2hhdFN0YXRlID0gY2hhdFN0YXRlO1xuICAgICAgICB0aGlzLnVpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMucmVuZGVyZXJDYWxsYmFja3MgPSByZW5kZXJlckNhbGxiYWNrcztcbiAgICAgICAgLy8gR2V0IHRoZSBoaXN0b3J5IGNvbnRhaW5lciBlbGVtZW50IGZyb20gVUlNYW5hZ2VyXG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lciA9IHRoaXMudWlNYW5hZ2VyLmdldFVJRWxlbWVudHMoKS5oaXN0b3J5Q29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGJldHdlZW4gdGhlIG1haW4gY2hhdCB2aWV3IGFuZCB0aGUgaGlzdG9yeSB2aWV3LlxuICAgICAqL1xuICAgIHRvZ2dsZUhpc3RvcnlWaWV3KCkge1xuICAgICAgICB0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUgPSAhdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlO1xuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBVc2UgVUlNYW5hZ2VyIHRvIGhpZGUgY2hhdCwgc2hvdyBoaXN0b3J5XG4gICAgICAgICAgICB0aGlzLnVpTWFuYWdlci5zaG93SGlzdG9yeVZpZXcoKTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyQ2hhdEhpc3RvcnkoKTsgLy8gUG9wdWxhdGUgdGhlIGhpc3Rvcnkgdmlld1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gVXNlIFVJTWFuYWdlciB0byBzaG93IGNoYXQsIGhpZGUgaGlzdG9yeVxuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2hvd0NoYXRWaWV3KCk7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGNvcnJlY3QgdGl0bGUgaXMgZGlzcGxheWVkIHdoZW4gc3dpdGNoaW5nIGJhY2tcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDaGF0ID0gdGhpcy5jaGF0U3RhdGUuZ2V0Q3VycmVudENoYXQoKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnVwZGF0ZVRpdGxlSW5wdXQoY3VycmVudENoYXQudGl0bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgdGhlIGxpc3Qgb2YgcGFzdCBjaGF0cyBpbiB0aGUgaGlzdG9yeSBjb250YWluZXIuXG4gICAgICovXG4gICAgcmVuZGVyQ2hhdEhpc3RvcnkoKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJzsgLy8gQ2xlYXIgcHJldmlvdXMgbGlzdFxuICAgICAgICBjb25zdCBoaXN0b3J5ID0gdGhpcy5jaGF0U3RhdGUuZ2V0Q2hhdEhpc3RvcnkoKTtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXRJZCA9IHRoaXMuY2hhdFN0YXRlLmdldEN1cnJlbnRDaGF0SWQoKTtcbiAgICAgICAgaWYgKGhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuaW5uZXJIVE1MID0gJzxkaXYgY2xhc3M9XCJqcC1sbG0tZXh0LWhpc3RvcnktZW1wdHlcIj5ObyBjaGF0IGhpc3RvcnkgeWV0LjwvZGl2Pic7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJyk7XG4gICAgICAgIGxpc3QuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1saXN0JztcbiAgICAgICAgaGlzdG9yeS5mb3JFYWNoKGNoYXQgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGlzdEl0ZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgbGlzdEl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtJztcbiAgICAgICAgICAgIGlmIChjaGF0LmlkID09PSBjdXJyZW50Q2hhdElkKSB7XG4gICAgICAgICAgICAgICAgbGlzdEl0ZW0uY2xhc3NMaXN0LmFkZCgnanAtbGxtLWV4dC1hY3RpdmUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNpbXBsZSByZXByZXNlbnRhdGlvbjogVGl0bGVcbiAgICAgICAgICAgIC8vIFRPRE86IEFkZCBwcmV2aWV3LCB0aW1lc3RhbXAsIGRlbGV0ZSBidXR0b24gZXRjLlxuICAgICAgICAgICAgY29uc3QgdGl0bGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRpdGxlRGl2LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktaXRlbS10aXRsZSc7XG4gICAgICAgICAgICB0aXRsZURpdi50ZXh0Q29udGVudCA9IGNoYXQudGl0bGUgfHwgJ1VudGl0bGVkIENoYXQnO1xuICAgICAgICAgICAgbGlzdEl0ZW0uYXBwZW5kQ2hpbGQodGl0bGVEaXYpO1xuICAgICAgICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50IHRvIGxvYWQgdGhlIGNoYXRcbiAgICAgICAgICAgIGxpc3RJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5sb2FkQ2hhdChjaGF0LmlkKSk7XG4gICAgICAgICAgICBsaXN0LmFwcGVuZENoaWxkKGxpc3RJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYSBzcGVjaWZpYyBjaGF0IHNlc3Npb24gZnJvbSBoaXN0b3J5IGludG8gdGhlIG1haW4gdmlldy5cbiAgICAgKi9cbiAgICBsb2FkQ2hhdChjaGF0SWQpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdFN0YXRlLmdldENoYXRCeUlkKGNoYXRJZCk7XG4gICAgICAgIGlmICghY2hhdCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihgQ2hhdCB3aXRoIElEICR7Y2hhdElkfSBub3QgZm91bmQuYCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IHRoaXMgY2hhdCBhcyB0aGUgYWN0aXZlIG9uZSBpbiB0aGUgc3RhdGVcbiAgICAgICAgdGhpcy5jaGF0U3RhdGUuc2V0Q3VycmVudENoYXRJZChjaGF0SWQpO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIG1haW4gVUkgdGl0bGUgaW5wdXRcbiAgICAgICAgdGhpcy5jYWxsYmFja3MudXBkYXRlVGl0bGVJbnB1dChjaGF0LnRpdGxlKTtcbiAgICAgICAgLy8gQ2xlYXIgdGhlIGN1cnJlbnQgbWVzc2FnZSBkaXNwbGF5XG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmNsZWFyTWVzc2FnZUNvbnRhaW5lcigpO1xuICAgICAgICAvLyBSZS1wb3B1bGF0ZSB0aGUgbWVzc2FnZSBjb250YWluZXIgd2l0aCBtZXNzYWdlcyBmcm9tIHRoZSBsb2FkZWQgY2hhdFxuICAgICAgICAvLyBVc2UgdGhlIHJlbmRlcmVyIGZ1bmN0aW9ucyB2aWEgY2FsbGJhY2tzXG4gICAgICAgIGNoYXQubWVzc2FnZXMuZm9yRWFjaCgobXNnKSA9PiB7XG4gICAgICAgICAgICBsZXQgbWVzc2FnZUVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAobXNnLnNlbmRlciA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclVzZXJNZXNzYWdlKShtc2cudGV4dCwgeyBpc01hcmtkb3duOiBtc2cuaXNNYXJrZG93biB9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyAnYm90J1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VFbGVtZW50ID0gKDAsIG1lc3NhZ2VfcmVuZGVyZXJfMS5yZW5kZXJCb3RNZXNzYWdlKShtc2cudGV4dCwgeyBpc01hcmtkb3duOiBtc2cuaXNNYXJrZG93biB9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEFkZCB0aGUgcmVuZGVyZWQgZWxlbWVudCB0byB0aGUgbWVzc2FnZSBjb250YWluZXIgdmlhIGNhbGxiYWNrXG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5hZGRSZW5kZXJlZE1lc3NhZ2UobWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gU3dpdGNoIGJhY2sgdG8gdGhlIGNoYXQgdmlldyBpZiB3ZSB3ZXJlIGluIHRoZSBoaXN0b3J5IHZpZXdcbiAgICAgICAgaWYgKHRoaXMuaXNIaXN0b3J5Vmlld0FjdGl2ZSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVIaXN0b3J5VmlldygpOyAvLyBUaGlzIHdpbGwgY2FsbCB1aU1hbmFnZXIuc2hvd0NoYXRWaWV3KClcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGFscmVhZHkgaW4gY2hhdCB2aWV3LCBlbnN1cmUgc2Nyb2xsaW5nIGlzIGNvcnJlY3RcbiAgICAgICAgICAgIHRoaXMudWlNYW5hZ2VyLnNjcm9sbFRvQm90dG9tKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3B0aW9uYWw6IFJlLXJlbmRlciBoaXN0b3J5IGxpc3QgdG8gdXBkYXRlIHRoZSBhY3RpdmUgaXRlbSBpbmRpY2F0b3JcbiAgICAgICAgLy8gT25seSByZWFsbHkgbmVlZGVkIGlmIG5vdCBzd2l0Y2hpbmcgdmlld3NcbiAgICAgICAgLy8gaWYgKCF0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUpIHsgdGhpcy5yZW5kZXJDaGF0SGlzdG9yeSgpOyB9XG4gICAgfVxufVxuZXhwb3J0cy5IaXN0b3J5SGFuZGxlciA9IEhpc3RvcnlIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0SGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IGNvbnRlbnRfZWRpdGFibGVfdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlscy9jb250ZW50LWVkaXRhYmxlLXV0aWxzXCIpOyAvLyBIZWxwZXIgbmVlZGVkXG4vKipcbiAqIEhhbmRsZXMgZXZlbnRzIGFuZCBsb2dpYyByZWxhdGVkIHRvIHRoZSBjaGF0IGlucHV0IGZpZWxkLlxuICovXG5jbGFzcyBJbnB1dEhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGNoYXRJbnB1dCwgY2FsbGJhY2tzXG4gICAgLy8gdWlNYW5hZ2VyOiBVSU1hbmFnZXIgLy8gUmVtb3ZlZCB1bnVzZWQgcGFyYW1ldGVyXG4gICAgKSB7XG4gICAgICAgIC8vIHByaXZhdGUgdWlNYW5hZ2VyOiBVSU1hbmFnZXI7IC8vIFJlbW92ZWQgdW51c2VkIG1lbWJlclxuICAgICAgICAvLyAtLS0gQ29kZSBSZWZlcmVuY2UgU3RhdGUgLS0tXG4gICAgICAgIHRoaXMuY29kZVJlZk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uZXh0UmVmSWQgPSAxO1xuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzTWFya2Rvd25Nb2RlID0gZmFsc2U7IC8vIEludGVybmFsIHN0YXRlLCBwb3RlbnRpYWxseSBzeW5jZWQgd2l0aCBVSU1hbmFnZXJcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSBmYWxzZTsgLy8gSW50ZXJuYWwgc3RhdGUsIHBvdGVudGlhbGx5IHN5bmNlZCB3aXRoIFVJTWFuYWdlclxuICAgICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgICAgICAvLyAtLS0gUHJpdmF0ZSBFdmVudCBIYW5kbGVycyAtLS1cbiAgICAgICAgdGhpcy5faGFuZGxlS2V5UHJlc3MgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSBFbnRlciBrZXkgcHJlc3MgKHNlbmQgbWVzc2FnZSlcbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IG5ld2xpbmUgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBkaXZcbiAgICAgICAgICAgICAgICBsZXQgbWVzc2FnZSA9IHRoaXMuY2hhdElucHV0LnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLnRyaW0oKTsgLy8gSnVzdCB0cmltIHRoZSByYXcgbWVzc2FnZVxuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UpOyAvLyBQYXNzIHJhdyBtZXNzYWdlIHdpdGggcGxhY2Vob2xkZXJzXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tIEhhbmRsZSBUYWIvRXNjYXBlL0Fycm93cyBmb3IgcG9wdXAgaW50ZXJhY3Rpb24gLS0tXG4gICAgICAgICAgICAvLyBDaGVjayBpZiBwb3B1cCBpcyB2aXNpYmxlIChuZWVkcyBhIHdheSB0byBrbm93LCBtYXliZSB2aWEgY2FsbGJhY2tzIG9yIGRpcmVjdCByZWZlcmVuY2U/KVxuICAgICAgICAgICAgLy8gQXNzdW1pbmcgcG9wdXBNZW51TWFuYWdlciByZWZlcmVuY2UgaXMgYXZhaWxhYmxlIG9yIHN0YXRlIGlzIHRyYWNrZWRcbiAgICAgICAgICAgIC8vIGVsc2UgaWYgKHRoaXMucG9wdXBNZW51TWFuYWdlci5pc1BvcHVwTWVudVZpc2libGUoKSkgeyAvLyBQc2V1ZG8tY29kZVxuICAgICAgICAgICAgLy8gICAgaWYgKGV2ZW50LmtleSA9PT0gJ1RhYicgfHwgZXZlbnQua2V5ID09PSAnRXNjYXBlJyB8fCBldmVudC5rZXkgPT09ICdBcnJvd1VwJyB8fCBldmVudC5rZXkgPT09ICdBcnJvd0Rvd24nKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IGlucHV0IGZpZWxkIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIC8vICAgICAgICAvLyBMZXQgdGhlIFBvcHVwTWVudU1hbmFnZXIncyBkb2N1bWVudCBoYW5kbGVyIG1hbmFnZSB0aGUgZXZlbnRcbiAgICAgICAgICAgIC8vICAgIH1cbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIC8vIC0tLSBFbmQgUG9wdXAgSW50ZXJhY3Rpb24gSGFuZGxpbmcgLS0tXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2hhbmRsZUlucHV0ID0gKCkgPT4ge1xuICAgICAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBkaXZcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgICAgICAvLyAtLS0gVXBkYXRlIENvZGUgUmVmIFBsYWNlaG9sZGVycyAtLS0gXG4gICAgICAgICAgICAvLyBPcHRpb25hbDogSWYgd2Ugd2FudCB2aXN1YWwgcGxhY2Vob2xkZXJzIHRvIHVwZGF0ZSBsaXZlXG4gICAgICAgICAgICAvLyBUaGlzIGNvdWxkIGludm9sdmUgY29tcGxleCBET00gbWFuaXB1bGF0aW9uIG9yIHVzaW5nIGEgbGlicmFyeS5cbiAgICAgICAgICAgIC8vIEZvciBub3csIHdlIHJlc29sdmUgcmVmcyBvbmx5IG9uIHNlbmQuXG4gICAgICAgICAgICAvLyAtLS0gQXQgU3ltYm9sIERldGVjdGlvbiBmb3IgUG9wdXAgLS0tIFxuICAgICAgICAgICAgLy8gVGhpcyBsb2dpYyB3YXMgbW92ZWQgdG8gVUlNYW5hZ2VyLmhhbmRsZUlucHV0Rm9yUmVmZXJlbmNlXG4gICAgICAgICAgICAvLyBiZWNhdXNlIFVJTWFuYWdlciBuZWVkcyB0byBjb29yZGluYXRlIHNob3dpbmcgdGhlIHBvcHVwLlxuICAgICAgICAgICAgLy8gSW5wdXRIYW5kbGVyIG1pZ2h0IHN0aWxsIG5lZWQgdG8ga25vdyAqaWYqIGFuIEAgd2FzIHR5cGVkIHJlY2VudGx5XG4gICAgICAgICAgICAvLyB0byBhZGp1c3QgYmVoYXZpb3IgKGUuZy4sIGhvdyBFbnRlciB3b3JrcyksIGJ1dCBVSU1hbmFnZXIgaGFuZGxlcyB0aGUgcG9wdXAgdHJpZ2dlci5cbiAgICAgICAgICAgIC8vIFNpbXBsZSBjaGVjayBpZiB0ZXh0IGNvbnRhaW5zICdAJyBmb3IgcG90ZW50aWFsIHN0YXRlIG1hbmFnZW1lbnRcbiAgICAgICAgICAgIHRoaXMuaGFzQXRTeW1ib2wgPSBjdXJyZW50VGV4dC5pbmNsdWRlcygnQCcpO1xuICAgICAgICAgICAgLy8gQWRqdXN0IGlucHV0IGhlaWdodCBkeW5hbWljYWxseSBiYXNlZCBvbiBjb250ZW50P1xuICAgICAgICAgICAgLy8gQ2FuIGJlIGNvbXBsZXggd2l0aCBjb250ZW50ZWRpdGFibGUgZGl2cy4gUmVxdWlyZXMgY2FyZWZ1bCBjYWxjdWxhdGlvbi5cbiAgICAgICAgICAgIC8vIHRoaXMuYWRqdXN0SW5wdXRIZWlnaHQoKTsgXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhdElucHV0ID0gY2hhdElucHV0O1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgLy8gdGhpcy51aU1hbmFnZXIgPSB1aU1hbmFnZXI7IC8vIFJlbW92ZWQgdW51c2VkIGFzc2lnbm1lbnRcbiAgICAgICAgLy8gQmluZCBldmVudCBsaXN0ZW5lcnNcbiAgICAgICAgdGhpcy5jaGF0SW5wdXQuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVLZXlQcmVzcyk7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faGFuZGxlSW5wdXQpO1xuICAgICAgICAvLyBOb3RlOiBBY3R1YWwgbWFya2Rvd24gdG9nZ2xlIGFuZCBleHBhbmQgYnV0dG9ucyBhcmUgbGlrZWx5IG1hbmFnZWQgYnkgVUlNYW5hZ2VyLFxuICAgICAgICAvLyB3aGljaCB3b3VsZCB0aGVuIGNhbGwgbWV0aG9kcyBsaWtlIGBzZXRNYXJrZG93bk1vZGVgIG9yIGB0b2dnbGVFeHBhbnNpb25gIG9uIHRoaXMgaGFuZGxlci5cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBldmVudCBsaXN0ZW5lcnMuXG4gICAgICovXG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgdGhpcy5jaGF0SW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0aGlzLl9oYW5kbGVLZXlQcmVzcyk7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2lucHV0JywgdGhpcy5faGFuZGxlSW5wdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIHRleHQgdG8gdGhlIGlucHV0IGZpZWxkLCBwb3RlbnRpYWxseSByZXBsYWNpbmcgYSBwcmVjZWRpbmcgJ0AnIHN5bWJvbC5cbiAgICAgKi9cbiAgICBhcHBlbmRUb0lucHV0KHRleHQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmZvY3VzKCk7IC8vIEVuc3VyZSBmb2N1cyBmaXJzdFxuICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgc2VsZWN0aW9uLnJhbmdlQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdDYW5ub3QgYXBwZW5kIHRvIGlucHV0OiBObyBzZWxlY3Rpb24gZm91bmQuJyk7XG4gICAgICAgICAgICAgICAgLy8gRmFsbGJhY2s6IGFwcGVuZCB0byBlbmRcbiAgICAgICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC50ZXh0Q29udGVudCA9ICh0aGlzLmNoYXRJbnB1dC50ZXh0Q29udGVudCB8fCAnJykgKyB0ZXh0O1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICBjb25zdCB7IHN0YXJ0Q29udGFpbmVyLCBzdGFydE9mZnNldCB9ID0gcmFuZ2U7XG4gICAgICAgICAgICBsZXQgY3VycmVudFRleHRDb250ZW50ID0gdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgfHwgJyc7IC8vIFVzZSB0ZXh0Q29udGVudFxuICAgICAgICAgICAgbGV0IGluc2VydFBvcyA9ICgwLCBjb250ZW50X2VkaXRhYmxlX3V0aWxzXzEuZ2V0Q2FyZXRQb3NpdGlvbikodGhpcy5jaGF0SW5wdXQpOyAvLyBHZXQgbGluZWFyIHBvc2l0aW9uXG4gICAgICAgICAgICAvLyBTaW1wbGUgY2hlY2s6IGlmIHRoZSBjaGFyYWN0ZXIgYmVmb3JlIHRoZSBsaW5lYXIgY2FyZXQgcG9zaXRpb24gaXMgJ0AnXG4gICAgICAgICAgICBpZiAoaW5zZXJ0UG9zID4gMCAmJiBjdXJyZW50VGV4dENvbnRlbnRbaW5zZXJ0UG9zIC0gMV0gPT09ICdAJykge1xuICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlICdAJyAtIG1vcmUgY29tcGxleCB3aXRoIERPTSBtYW5pcHVsYXRpb24sXG4gICAgICAgICAgICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHdlJ2xsIHJlcGxhY2UgaW4gdGV4dENvbnRlbnQgYW5kIHJlc2V0XG4gICAgICAgICAgICAgICAgY29uc3QgYmVmb3JlID0gY3VycmVudFRleHRDb250ZW50LnNsaWNlKDAsIGluc2VydFBvcyAtIDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gY3VycmVudFRleHRDb250ZW50LnNsaWNlKGluc2VydFBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnNvciBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICgwLCBjb250ZW50X2VkaXRhYmxlX3V0aWxzXzEuc2V0Q2FyZXRQb3NpdGlvbikodGhpcy5jaGF0SW5wdXQsIChpbnNlcnRQb3MgLSAxKSArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFN0YW5kYXJkIGluc2VydGlvbiAtIG1vcmUgY29tcGxleCB3aXRoIERPTSBtYW5pcHVsYXRpb25cbiAgICAgICAgICAgICAgICAvLyBGb3Igc2ltcGxpY2l0eSwgd2UnbGwgaW5zZXJ0IGluIHRleHRDb250ZW50IGFuZCByZXNldFxuICAgICAgICAgICAgICAgIGNvbnN0IGJlZm9yZSA9IGN1cnJlbnRUZXh0Q29udGVudC5zbGljZSgwLCBpbnNlcnRQb3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyID0gY3VycmVudFRleHRDb250ZW50LnNsaWNlKGluc2VydFBvcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgPSBiZWZvcmUgKyB0ZXh0ICsgYWZ0ZXI7XG4gICAgICAgICAgICAgICAgLy8gU2V0IGN1cnNvciBwb3NpdGlvbiBhZnRlciB0aGUgaW5zZXJ0ZWQgdGV4dFxuICAgICAgICAgICAgICAgICgwLCBjb250ZW50X2VkaXRhYmxlX3V0aWxzXzEuc2V0Q2FyZXRQb3NpdGlvbikodGhpcy5jaGF0SW5wdXQsIGluc2VydFBvcyArIHRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRyaWdnZXIgaW5wdXQgZXZlbnQgbWFudWFsbHkgc2luY2Ugd2UncmUgY2hhbmdpbmcgdGV4dENvbnRlbnQgZGlyZWN0bHlcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBlbmRpbmcgdG8gaW5wdXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgaW5wdXQgZmllbGQgYW5kIHJlc2V0cyBhc3NvY2lhdGVkIHN0YXRlIGFmdGVyIHNlbmRpbmcuXG4gICAgICovXG4gICAgY2xlYXJJbnB1dCgpIHtcbiAgICAgICAgLy8gVXNlIHRleHRDb250ZW50IGZvciBkaXZcbiAgICAgICAgdGhpcy5jaGF0SW5wdXQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgLy8gRGlyZWN0bHkgcmVzZXQgaW50ZXJuYWwgc3RhdGUgaW5zdGVhZCBvZiByZWx5aW5nIG9uIGNhbGxiYWNrXG4gICAgICAgIHRoaXMucmVzZXRDb2RlUmVmZXJlbmNlcygpO1xuICAgICAgICAvLyBSZW1vdmUgcm93cyBtYW5pcHVsYXRpb25cbiAgICAgICAgLy8gdGhpcy5jaGF0SW5wdXQucm93cyA9IDE7XG4gICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLmhlaWdodCA9ICcnOyAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGZhbHNlOyAvLyBSZXNldCBAIHN0YXRlXG4gICAgICAgIC8vIFJlc2V0IGV4cGFuZCBidXR0b24gc3RhdGUgaWYgaXQgd2FzIGV4cGFuZGVkXG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVJbnB1dEV4cGFuc2lvbihmYWxzZSk7IC8vIENvbGxhcHNlIGlucHV0XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHJpZ2dlciBpbnB1dCBldmVudCBtYW51YWxseSBhZnRlciBjbGVhcmluZ1xuICAgICAgICB0aGlzLmNoYXRJbnB1dC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBtYXJrZG93biBtb2RlIHN0YXRlIGFuZCB1cGRhdGVzIHRoZSBwbGFjZWhvbGRlci5cbiAgICAgKi9cbiAgICBzZXRNYXJrZG93bk1vZGUoaXNNYXJrZG93bikge1xuICAgICAgICB0aGlzLmlzTWFya2Rvd25Nb2RlID0gaXNNYXJrZG93bjtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MudXBkYXRlUGxhY2Vob2xkZXIodGhpcy5pc01hcmtkb3duTW9kZSk7XG4gICAgICAgIC8vIFVwZGF0ZSBwbGFjZWhvbGRlciBkaXJlY3RseSAoYWx0ZXJuYXRpdmUgdG8gY2FsbGJhY2spXG4gICAgICAgIC8vIHRoaXMuY2hhdElucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5pc01hcmtkb3duTW9kZSA/IFxuICAgICAgICAvLyAgICdXcml0ZSBtYXJrZG93biBoZXJlLi4uJyA6IFxuICAgICAgICAvLyAgICdBc2sgbWUgYW55dGhpbmcuLi4nO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBpbnB1dCBleHBhbnNpb24gc3RhdGUgYW5kIHVwZGF0ZXMgVUkuXG4gICAgICovXG4gICAgdG9nZ2xlSW5wdXRFeHBhbnNpb24oZm9yY2VTdGF0ZSkge1xuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9IGZvcmNlU3RhdGUgIT09IHVuZGVmaW5lZCA/IGZvcmNlU3RhdGUgOiAhdGhpcy5pc0lucHV0RXhwYW5kZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgLy8gVXNlIG1heC1oZWlnaHQgb3IgaGVpZ2h0IGZvciBkaXZcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLmhlaWdodCA9ICcyMDBweCc7IC8vIEV4YW1wbGUgaGVpZ2h0XG4gICAgICAgICAgICAvLyBBbGxvdyB2ZXJ0aWNhbCByZXNpemluZyBpZiBkZXNpcmVkLCBvciBrZWVwIGFzICdub25lJ1xuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUucmVzaXplID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLm92ZXJmbG93WSA9ICdhdXRvJzsgLy8gRW5zdXJlIHNjcm9sbGJhciBhcHBlYXJzIGlmIG5lZWRlZFxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUuaGVpZ2h0ID0gJyc7IC8vIFJlc2V0IGhlaWdodFxuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUucmVzaXplID0gJ25vbmUnO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHJvd3MgbWFuaXB1bGF0aW9uXG4gICAgICAgICAgICAvLyB0aGlzLmNoYXRJbnB1dC5yb3dzID0gMTsgLy8gRW5zdXJlIGl0IGNvbGxhcHNlcyBiYWNrIHRvIDEgcm93IGhlaWdodFxuICAgICAgICAgICAgdGhpcy5jaGF0SW5wdXQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7IC8vIEhpZGUgc2Nyb2xsYmFyIHdoZW4gY29sbGFwc2VkXG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90aWZ5IFVJTWFuYWdlci9MYXlvdXRCdWlsZGVyIHRvIHVwZGF0ZSBidXR0b24gYXBwZWFyYW5jZVxuICAgICAgICB0aGlzLmNhbGxiYWNrcy50b2dnbGVJbnB1dEV4cGFuc2lvblVJKHRoaXMuaXNJbnB1dEV4cGFuZGVkKTtcbiAgICB9XG4gICAgLy8gLS0tIENvZGUgUmVmZXJlbmNlIE1ldGhvZHMgLS0tXG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNvZGUgcmVmZXJlbmNlIHRvIHRoZSBpbnRlcm5hbCBtYXAgYW5kIHJldHVybnMgaXRzIElELlxuICAgICAqIEBwYXJhbSBjb2RlIFRoZSBhY3R1YWwgY29kZSBjb250ZW50LlxuICAgICAqIEBwYXJhbSBub3RlYm9va05hbWUgVGhlIG5hbWUgb2YgdGhlIG5vdGVib29rIHRoZSBjb2RlIGlzIGZyb20uXG4gICAgICogQHBhcmFtIGNlbGxJbmRleCBUaGUgaW5kZXggb2YgdGhlIGNlbGwgdGhlIGNvZGUgaXMgZnJvbSAoMC1iYXNlZCkuXG4gICAgICogQHBhcmFtIGxpbmVOdW1iZXIgVGhlIHN0YXJ0aW5nIGxpbmUgbnVtYmVyIG9mIHRoZSBjb2RlIHdpdGhpbiB0aGUgY2VsbCAoMS1iYXNlZCkuXG4gICAgICogQHBhcmFtIGxpbmVFbmROdW1iZXIgVGhlIGVuZGluZyBsaW5lIG51bWJlciBvZiB0aGUgY29kZSB3aXRoaW4gdGhlIGNlbGwgKDEtYmFzZWQpLlxuICAgICAqIEByZXR1cm5zIFRoZSBnZW5lcmF0ZWQgcmVmZXJlbmNlIElEIChlLmcuLCBcInJlZi0xXCIpLlxuICAgICAqL1xuICAgIGFkZENvZGVSZWZlcmVuY2UoY29kZSwgbm90ZWJvb2tOYW1lLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIC8vIFN0YXJ0IGxpbmVcbiAgICBsaW5lRW5kTnVtYmVyIC8vIEVuZCBsaW5lXG4gICAgKSB7XG4gICAgICAgIGNvbnN0IHJlZklkID0gYHJlZi0ke3RoaXMubmV4dFJlZklkKyt9YDtcbiAgICAgICAgLy8gU3RvcmUgYm90aCBzdGFydCBhbmQgZW5kIGxpbmUgbnVtYmVyc1xuICAgICAgICBjb25zdCByZWZEYXRhID0geyBjb2RlLCBub3RlYm9va05hbWUsIGNlbGxJbmRleCwgbGluZU51bWJlciwgbGluZUVuZE51bWJlciB9O1xuICAgICAgICAvLyBTdG9yZSB0aGUgQUNUVUFMIENvZGVSZWZEYXRhIG9iamVjdCBpbiB0aGUgbWFwXG4gICAgICAgIHRoaXMuY29kZVJlZk1hcC5zZXQocmVmSWQsIHJlZkRhdGEpO1xuICAgICAgICAvLyBMb2cgdGhlIGRldGFpbHMgc2VwYXJhdGVseVxuICAgICAgICBjb25zb2xlLmxvZygnQWRkZWQgY29kZSByZWZlcmVuY2U6JywgcmVmSWQsICctPicsIGAoJHtub3RlYm9va05hbWV9LCBDZWxsICR7Y2VsbEluZGV4ICsgMX0sIExpbmUgJHtsaW5lTnVtYmVyfSR7bGluZU51bWJlciAhPT0gbGluZUVuZE51bWJlciA/ICdfJyArIGxpbmVFbmROdW1iZXIgOiAnJ30pIGAgK1xuICAgICAgICAgICAgY29kZS5zdWJzdHJpbmcoMCwgMzApICsgJy4uLicgLy8gTG9nIG1ldGFkYXRhIHRvb1xuICAgICAgICApO1xuICAgICAgICByZXR1cm4gcmVmSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGN1cnJlbnQgbWFwIG9mIGNvZGUgcmVmZXJlbmNlcy5cbiAgICAgKi9cbiAgICBnZXRDb2RlUmVmZXJlbmNlTWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2RlUmVmTWFwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgdGhlIGNvZGUgcmVmZXJlbmNlIG1hcCBhbmQgcmVzZXRzIHRoZSBJRCBjb3VudGVyLlxuICAgICAqL1xuICAgIHJlc2V0Q29kZVJlZmVyZW5jZXMoKSB7XG4gICAgICAgIC8vIC0tLSBERUJVRyBMT0cgLS0tIFxuICAgICAgICBjb25zb2xlLmxvZygnW0lucHV0SGFuZGxlcl0gcmVzZXRDb2RlUmVmZXJlbmNlcyBjYWxsZWQhJywgbmV3IEVycm9yKCkuc3RhY2spOyAvLyBMb2cgY2FsbCBzdGFja1xuICAgICAgICAvLyAtLS0gRU5EIERFQlVHIExPRyAtLS0gXG4gICAgICAgIHRoaXMuY29kZVJlZk1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLm5leHRSZWZJZCA9IDE7XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb2RlIHJlZmVyZW5jZXMgcmVzZXQuJyk7IC8vIERlYnVnIGxvZ1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBjb2RlIHJlZmVyZW5jZSBwbGFjZWhvbGRlcnMgKGUuZy4sIFwiW3JlZi0xXVwiKSBpbiBhIG1lc3NhZ2Ugc3RyaW5nXG4gICAgICogd2l0aCB0aGUgYWN0dWFsIGNvZGUgZnJvbSB0aGUgbWFwLlxuICAgICAqIEBwYXJhbSBtZXNzYWdlIFRoZSBtZXNzYWdlIHN0cmluZyBwb3RlbnRpYWxseSBjb250YWluaW5nIHBsYWNlaG9sZGVycy5cbiAgICAgKiBAcmV0dXJucyBUaGUgbWVzc2FnZSBzdHJpbmcgd2l0aCBwbGFjZWhvbGRlcnMgcmVzb2x2ZWQuXG4gICAgICovXG4gICAgcmVzb2x2ZUNvZGVSZWZlcmVuY2VzKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuY29kZVJlZk1hcC5zaXplID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZTsgLy8gTm8gcmVmZXJlbmNlcyB0byByZXNvbHZlXG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVnZXggdG8gZmluZCBwbGFjZWhvbGRlcnMgbGlrZSBbcmVmLTFdLCBbcmVmLTEyXSwgZXRjLlxuICAgICAgICBjb25zdCBwbGFjZWhvbGRlclJlZ2V4ID0gL1xcWyhyZWYtXFxkKylcXF0vZztcbiAgICAgICAgbGV0IHJlc29sdmVkTWVzc2FnZSA9IG1lc3NhZ2UucmVwbGFjZShwbGFjZWhvbGRlclJlZ2V4LCAobWF0Y2gsIHJlZklkKSA9PiB7XG4gICAgICAgICAgICAvLyBBY2Nlc3MgdGhlIC5jb2RlIHByb3BlcnR5IGZyb20gdGhlIHN0b3JlZCBvYmplY3RcbiAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSB0aGlzLmNvZGVSZWZNYXAuZ2V0KHJlZklkKTtcbiAgICAgICAgICAgIGlmIChyZWZEYXRhKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1Jlc29sdmluZyBjb2RlIHJlZmVyZW5jZTonLCByZWZJZCk7IC8vIERlYnVnIGxvZ1xuICAgICAgICAgICAgICAgIC8vIEFkZCBjb250ZXh0IGFyb3VuZCB0aGUgcmVwbGFjZWQgY29kZVxuICAgICAgICAgICAgICAgIHJldHVybiBgXFxuXFxgXFxgXFxgXFxuJHtyZWZEYXRhLmNvZGV9XFxuXFxgXFxgXFxgXFxuYDsgLy8gVXNlIHJlZkRhdGEuY29kZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBjb2RlIGZvciByZWZlcmVuY2U6JywgcmVmSWQpOyAvLyBXYXJuIGlmIHJlZiBJRCBub3QgZm91bmRcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7IC8vIEtlZXAgdGhlIHBsYWNlaG9sZGVyIGlmIG5vdCBmb3VuZFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc29sdmVkTWVzc2FnZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAvLyBIYW5kbGUgQCBzeW1ib2wgcmVtb3ZhbCB0byBoaWRlIHBvcHVwIHVzaW5nIHNlbGVjdGlvbiBBUElcbiAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgIGlmICghc2VsZWN0aW9uIHx8ICFzZWxlY3Rpb24ucmFuZ2VDb3VudCkgcmV0dXJuO1xuICBcbiAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgaW5wdXQgZmllbGQgY29udGFpbnMgdGhlIHN0YXJ0IG9mIHRoZSByYW5nZVxuICAgICAgaWYgKCF0aGlzLmNoYXRJbnB1dC5jb250YWlucyhyYW5nZS5zdGFydENvbnRhaW5lcikpIHJldHVybjtcbiAgXG4gICAgICBjb25zdCBjdXJzb3JQb3NpdGlvbiA9IGdldENhcmV0UG9zaXRpb24odGhpcy5jaGF0SW5wdXQpOyAvLyBVc2UgaGVscGVyXG4gICAgICBpZiAoY3Vyc29yUG9zaXRpb24gPT09IG51bGwpIHJldHVybjtcbiAgXG4gICAgICBjb25zdCB0ZXh0Q29udGVudCA9IHRoaXMuY2hhdElucHV0LnRleHRDb250ZW50IHx8ICcnO1xuICAgICAgY29uc3QgdGV4dEJlZm9yZUN1cnNvciA9IHRleHRDb250ZW50LnNsaWNlKDAsIGN1cnNvclBvc2l0aW9uKTtcbiAgXG4gICAgICAvLyBDaGVjayBpZiB0aGUgY2hhcmFjdGVyIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY3Vyc29yIGlzICdAJ1xuICAgICAgLy8gYW5kIGlmIGl0J3MgcHJlY2VkZWQgYnkgd2hpdGVzcGFjZSBvciBpcyBhdCB0aGUgc3RhcnQgb2YgdGhlIGlucHV0LlxuICAgICAgY29uc3QgaXNBdFN5bWJvbENvbnRleHQgPSB0ZXh0QmVmb3JlQ3Vyc29yLmVuZHNXaXRoKCdAJykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGN1cnNvclBvc2l0aW9uID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJzb3JQb3NpdGlvbiA+IDEgJiYgL1xccy8udGVzdCh0ZXh0QmVmb3JlQ3Vyc29yW2N1cnNvclBvc2l0aW9uIC0gMl0pKTtcbiAgXG4gICAgICBpZiAodGhpcy5oYXNBdFN5bWJvbCAmJiAhaXNBdFN5bWJvbENvbnRleHQpIHtcbiAgICAgICAgLy8gQCBzeW1ib2wgY29udGV4dCB3YXMgcHJlc2VudCBidXQgbm93IGl0J3MgZ29uZSwgaGlkZSB0aGUgcG9wdXBcbiAgICAgICAgdGhpcy5jYWxsYmFja3MuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgfVxuICAgICAgLy8gVXBkYXRlIHRoZSBzdGF0ZSAqYWZ0ZXIqIGNoZWNraW5nIHRoZSBwcmV2aW91cyBzdGF0ZVxuICAgICAgdGhpcy5oYXNBdFN5bWJvbCA9IGlzQXRTeW1ib2xDb250ZXh0O1xuICBcbiAgICAgIC8vIC0tLSBBdXRvLXJlc2l6ZSBsb2dpYyAob3B0aW9uYWwpIC0tLVxuICAgICAgLy8gU2ltcGxlIGF1dG8tcmVzaXplIGJhc2VkIG9uIHNjcm9sbCBoZWlnaHQgKG1pZ2h0IG5lZWQgcmVmaW5lbWVudClcbiAgICAgIGlmICghdGhpcy5pc0lucHV0RXhwYW5kZWQpIHsgLy8gT25seSBhdXRvLXJlc2l6ZSBpZiBub3QgbWFudWFsbHkgZXhwYW5kZWRcbiAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5zdHlsZS5oZWlnaHQgPSAnYXV0byc7IC8vIFRlbXBvcmFyaWx5IHNocmluayB0byBjb250ZW50XG4gICAgICAgICAgY29uc3Qgc2Nyb2xsSGVpZ2h0ID0gdGhpcy5jaGF0SW5wdXQuc2Nyb2xsSGVpZ2h0O1xuICAgICAgICAgIC8vIFNldCBhIG1heCBoZWlnaHQgdG8gcHJldmVudCBpbmZpbml0ZSBncm93dGgsIGUuZy4sIDE1MHB4XG4gICAgICAgICAgY29uc3QgbWF4SGVpZ2h0ID0gMTUwO1xuICAgICAgICAgIGNvbnN0IG5ld0hlaWdodCA9IE1hdGgubWluKHNjcm9sbEhlaWdodCwgbWF4SGVpZ2h0KTtcbiAgICAgICAgICAgLy8gT25seSB1cGRhdGUgaGVpZ2h0IGlmIGl0IGFjdHVhbGx5IGNoYW5nZXMgdG8gYXZvaWQgZmxpY2tlclxuICAgICAgICAgIGlmICh0aGlzLmNoYXRJbnB1dC5vZmZzZXRIZWlnaHQgPCBuZXdIZWlnaHQpIHtcbiAgICAgICAgICAgICAgIHRoaXMuY2hhdElucHV0LnN0eWxlLmhlaWdodCA9IGAke25ld0hlaWdodH1weGA7XG4gICAgICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5zdHlsZS5vdmVyZmxvd1kgPSBzY3JvbGxIZWlnaHQgPiBtYXhIZWlnaHQgPyAnYXV0bycgOiAnaGlkZGVuJztcbiAgICAgICAgICB9IGVsc2UgaWYgKHNjcm9sbEhlaWdodCA8PSB0aGlzLmNoYXRJbnB1dC5jbGllbnRIZWlnaHQpIHtcbiAgICAgICAgICAgICAgLy8gU2hyaW5rIGlmIGNvbnRlbnQgaGVpZ2h0IGlzIGxlc3MgdGhhbiBjdXJyZW50IGhlaWdodFxuICAgICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5zdHlsZS5oZWlnaHQgPSBgJHtzY3JvbGxIZWlnaHR9cHhgO1xuICAgICAgICAgICAgICB0aGlzLmNoYXRJbnB1dC5zdHlsZS5vdmVyZmxvd1kgPSAnaGlkZGVuJztcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogRXhwbGljaXRseSBzZXRzIHRoZSBoYXNBdFN5bWJvbCBmbGFnLiBDYWxsZWQgYnkgc2hvcnRjdXQgaGFuZGxlci5cbiAgICAgKi9cbiAgICBzZXRIYXNBdFN5bWJvbCh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhhc0F0U3ltYm9sID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGhhc0F0U3ltYm9sIGZsYWcuIENhbGxlZCBieSBzaG9ydGN1dCBoYW5kbGVyLlxuICAgICAqL1xuICAgIGdldEhhc0F0U3ltYm9sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBdFN5bWJvbDtcbiAgICB9XG59XG5leHBvcnRzLklucHV0SGFuZGxlciA9IElucHV0SGFuZGxlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlSGFuZGxlciA9IHZvaWQgMDtcbmNvbnN0IG1lc3NhZ2VfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuLi91aS9tZXNzYWdlLXJlbmRlcmVyXCIpO1xuY29uc3Qgbm90ZWJvb2tfaW50ZWdyYXRpb25fMSA9IHJlcXVpcmUoXCIuLi91dGlscy9ub3RlYm9vay1pbnRlZ3JhdGlvblwiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2dsb2JhbHNcIik7IC8vIEltcG9ydCBnbG9iYWxzIGZvciBub3RlYm9vayB0cmFja2VyXG4vKipcbiAqIEhhbmRsZXMgc2VuZGluZyBtZXNzYWdlcywgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgQVBJLFxuICogbWFuYWdpbmcgc3RyZWFtaW5nIHJlc3BvbnNlcywgYW5kIHVwZGF0aW5nIHRoZSBVSSBhbmQgc3RhdGUuXG4gKi9cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihhcGlDbGllbnQsIGNoYXRTdGF0ZSwgdWlNYW5hZ2VyLCByZW5kZXJlckNhbGxiYWNrcywgaW5wdXRIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gYXBpQ2xpZW50O1xuICAgICAgICB0aGlzLmNoYXRTdGF0ZSA9IGNoYXRTdGF0ZTtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgICAgIHRoaXMucmVuZGVyZXJDYWxsYmFja3MgPSByZW5kZXJlckNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBpbnB1dEhhbmRsZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2Nlc3NlcyBhbmQgc2VuZHMgYSB1c2VyLWluaXRpYXRlZCBtZXNzYWdlLlxuICAgICAqIEFsc28gaGFuZGxlcyBhZGRpbmcgdGhlIHVzZXIgbWVzc2FnZSB0byB0aGUgVUkgYW5kIGNsZWFyaW5nIHRoZSBpbnB1dC5cbiAgICAgKiBBY2NlcHRzIHRoZSBtZXNzYWdlIHRleHQuXG4gICAgICovXG4gICAgaGFuZGxlU2VuZE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBpZiAoIW1lc3NhZ2UudHJpbSgpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zb2xlLmxvZyhgW01lc3NhZ2VIYW5kbGVyXSBIYW5kbGluZyBzZW5kOiBcIiR7bWVzc2FnZX1cImApO1xuICAgICAgICAvLyBBZGQgdXNlciBtZXNzYWdlIHRvIFVJIEZJUlNUXG4gICAgICAgIC8vIEFzc3VtZSB1c2VyIG1lc3NhZ2VzIGFyZW4ndCBtYXJrZG93biB1bmxlc3Mgc3BlY2lmaWMgdG9nZ2xlIGlzIHVzZWQgZWxzZXdoZXJlXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZShtZXNzYWdlLCAndXNlcicpO1xuICAgICAgICAvLyBDbGVhciBpbnB1dCB2aWEgSW5wdXRIYW5kbGVyICh3aGljaCB1c2VzIFVJTWFuYWdlcilcbiAgICAgICAgLy8gUkVNT1ZFRDogdGhpcy5pbnB1dEhhbmRsZXIuY2xlYXJJbnB1dCgpOyAvLyBJbnB1dCBjbGVhcmluZyBpcyBub3cgaGFuZGxlZCBieSBVSU1hbmFnZXIgYWZ0ZXIgdGhlIGNhbGxiYWNrXG4gICAgICAgIC8vIFNlbmQgbWVzc2FnZSB0byBiYWNrZW5kIEFQSSBhbmQgaGFuZGxlIHN0cmVhbWluZyByZXNwb25zZVxuICAgICAgICB0aGlzLnN0cmVhbUFuZFJlbmRlclJlc3BvbnNlKG1lc3NhZ2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhbiBhdXRvbWF0aWMgbWVzc2FnZSAoZS5nLiwgJ2NvbmZpcm1lZCcsICdyZWplY3RlZCcpXG4gICAgICogdG8gdGhlIGJhY2tlbmQgYW5kIGhhbmRsZXMgdGhlIHN0cmVhbWluZyByZXNwb25zZS5cbiAgICAgKiBBbHNvIGFkZHMgdGhlIHVzZXIncyBjb25maXJtYXRpb24vcmVqZWN0aW9uIGFjdGlvbiBhbmQgYSBzZXBhcmF0b3IgdG8gdGhlIFVJLlxuICAgICAqL1xuICAgIGhhbmRsZVNlbmRBdXRvTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGlmICghbWVzc2FnZS50cmltKCkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEFkZCB0aGUgdXNlcidzIGFjdGlvbiAoJ0NvbmZpcm1lZCcgb3IgJ1JlamVjdGVkJykgdG8gdGhlIFVJIGltbWVkaWF0ZWx5XG4gICAgICAgIGNvbnN0IHVzZXJEaXNwbGF5TWVzc2FnZSA9IG1lc3NhZ2UuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBtZXNzYWdlLnNsaWNlKDEpO1xuICAgICAgICAvLyBFeHBsaWNpdGx5IGZhbHNlIGZvciBpc01hcmtkb3duLCB0cnVlIGZvciBpc0F1dG9cbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHVzZXJEaXNwbGF5TWVzc2FnZSwgJ3VzZXInLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHRoZSBzZXBhcmF0b3IgZWxlbWVudFxuICAgICAgICBjb25zb2xlLmxvZygnW01lc3NhZ2VIYW5kbGVyXSBDcmVhdGluZyBhY3Rpb24gc2VwYXJhdG9yIGVsZW1lbnQuLi4nKTsgLy8gRGVidWcgbG9nXG4gICAgICAgIGNvbnN0IHNlcGFyYXRvckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzZXBhcmF0b3JEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYWN0aW9uLXNlcGFyYXRvcic7IC8vIEFkZCBhIGNsYXNzIGZvciBwb3RlbnRpYWwgc3R5bGluZ1xuICAgICAgICBzZXBhcmF0b3JEaXYuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7IC8vIEJhc2ljIHN0eWxpbmdcbiAgICAgICAgc2VwYXJhdG9yRGl2LnN0eWxlLm1hcmdpbiA9ICcxMHB4IDAnOyAvLyBBZGQgc29tZSB2ZXJ0aWNhbCBzcGFjZVxuICAgICAgICBzZXBhcmF0b3JEaXYuc3R5bGUuZm9udFNpemUgPSAnMC45ZW0nO1xuICAgICAgICBzZXBhcmF0b3JEaXYuc3R5bGUuY29sb3IgPSAndmFyKC0tanAtdWktZm9udC1jb2xvcjIsIGdyZXkpJzsgLy8gVXNlIEp1cHl0ZXJMYWIgdGhlbWUgdmFyaWFibGVcbiAgICAgICAgaWYgKG1lc3NhZ2UgPT09ICdjb25maXJtZWQnKSB7XG4gICAgICAgICAgICBzZXBhcmF0b3JEaXYudGV4dENvbnRlbnQgPSAnLS0tLS0tLS3inIUgQ29uZmlybWVkLS0tLS0tLS0nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1lc3NhZ2UgPT09ICdyZWplY3RlZCcpIHtcbiAgICAgICAgICAgIHNlcGFyYXRvckRpdi50ZXh0Q29udGVudCA9ICctLS0tLS0tLeKdjCBSZWplY3RlZC0tLS0tLS0tJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9wdGlvbmFsOiBIYW5kbGUgdW5leHBlY3RlZCBtZXNzYWdlcz8gT3IganVzdCBkb24ndCBhZGQgYSBzZXBhcmF0b3IuXG4gICAgICAgICAgICBzZXBhcmF0b3JEaXYudGV4dENvbnRlbnQgPSBgLS0tLS0tLS0ke3VzZXJEaXNwbGF5TWVzc2FnZX0tLS0tLS0tLWA7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIHRoZSBzZXBhcmF0b3IgZGlyZWN0bHkgdG8gdGhlIFVJIE1hbmFnZXIncyBjb250YWluZXJcbiAgICAgICAgY29uc29sZS5sb2coJ1tNZXNzYWdlSGFuZGxlcl0gQXR0ZW1wdGluZyB0byBhZGQgc2VwYXJhdG9yIGVsZW1lbnQ6Jywgc2VwYXJhdG9yRGl2KTsgLy8gRGVidWcgbG9nXG4gICAgICAgIHRoaXMudWlNYW5hZ2VyLmFkZENoYXRNZXNzYWdlRWxlbWVudChzZXBhcmF0b3JEaXYpO1xuICAgICAgICBjb25zb2xlLmxvZygnW01lc3NhZ2VIYW5kbGVyXSBTZXBhcmF0b3IgZWxlbWVudCBzaG91bGQgYmUgYWRkZWQuJyk7IC8vIERlYnVnIGxvZ1xuICAgICAgICAvLyBTZW5kIHRoZSB0ZWNobmljYWwgbWVzc2FnZSAoJ2NvbmZpcm1lZCcgb3IgJ3JlamVjdGVkJykgdG8gdGhlIGJhY2tlbmRcbiAgICAgICAgLy8gYW5kIGhhbmRsZSB0aGUgc3RyZWFtaW5nIHJlc3BvbnNlIGZyb20gdGhlIGJhY2tlbmQuXG4gICAgICAgIHRoaXMuc3RyZWFtQW5kUmVuZGVyUmVzcG9uc2UobWVzc2FnZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBVSSB2aWEgVUlNYW5hZ2VyIGFuZCBzYXZlcyB0byBDaGF0U3RhdGUuXG4gICAgICovXG4gICAgYWRkTWVzc2FnZSh0ZXh0LCBzZW5kZXIsIGlzTWFya2Rvd24gPSBmYWxzZSwgLy8gRGVmYXVsdCBmYWxzZSwgb3ZlcnJpZGRlbiBiZWxvd1xuICAgIGlzQXV0byA9IGZhbHNlIC8vIEZsYWcgZm9yIGF1dG8gbWVzc2FnZXMgbGlrZSBjb25maXJtL3JlamVjdFxuICAgICkge1xuICAgICAgICBjb25zb2xlLmxvZyhgW01lc3NhZ2VIYW5kbGVyXSBBZGRpbmcgbWVzc2FnZTogU2VuZGVyPSR7c2VuZGVyfSwgTWFya2Rvd249JHtpc01hcmtkb3dufSwgQXV0bz0ke2lzQXV0b31gKTtcbiAgICAgICAgbGV0IG1lc3NhZ2VFbGVtZW50O1xuICAgICAgICAvLyBQcmVwYXJlIGV4dGVuZGVkIGNhbGxiYWNrcyBmb3IgdGhlIHJlbmRlcmVyXG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLnJlbmRlcmVyQ2FsbGJhY2tzKSwgeyBnZXRDb2RlUmVmRGF0YTogKHJlZklkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRIYW5kbGVyLmdldENvZGVSZWZlcmVuY2VNYXAoKS5nZXQocmVmSWQpO1xuICAgICAgICAgICAgfSwgZ2V0Q3VycmVudE5vdGVib29rQ29udGV4dDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudE5vdGVib29rID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vdGVib29rID09PSBudWxsIHx8IGN1cnJlbnROb3RlYm9vayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3VycmVudE5vdGVib29rLmNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0aCA9IGN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSAoKF9iID0gcGF0aC5zcGxpdCgnLycpLnBvcCgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc3BsaXQoJy4nKVswXSkgfHwgJ25vdGVib29rJztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbmFtZSwgcGF0aCB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSB9KTtcbiAgICAgICAgaWYgKHNlbmRlciA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBpc01hcmtkb3duIG9wdGlvbiBhbmQgZXh0ZW5kZWQgY2FsbGJhY2tzIHRvIHRoZSByZW5kZXJlclxuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlclVzZXJNZXNzYWdlKSh0ZXh0LCB7IGlzTWFya2Rvd24gfSwgZXh0ZW5kZWRDYWxsYmFja3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQm90IG1lc3NhZ2VzIHVzdWFsbHkgYXJlIG1hcmtkb3duIHVubGVzcyBzcGVjaWZpZWQgb3RoZXJ3aXNlXG4gICAgICAgICAgICAvLyBIYW5kbGUgYXV0byBtZXNzYWdlcyBzcGVjaWZpY2FsbHkgaWYgdGhleSBzaG91bGRuJ3QgYmUgcGFyc2VkIGFzIG1hcmtkb3duXG4gICAgICAgICAgICBjb25zdCBib3RJc01hcmtkb3duID0gIWlzQXV0bzsgLy8gQXNzdW1lIGF1dG8gbWVzc2FnZXMgYXJlbid0IG1hcmtkb3duXG4gICAgICAgICAgICAvLyBQYXNzIGV4dGVuZGVkIGNhbGxiYWNrcyB0byBib3QgbWVzc2FnZSByZW5kZXJlciB0b28sIGluIGNhc2UgaXQgbmVlZHMgdGhlbSBsYXRlclxuICAgICAgICAgICAgbWVzc2FnZUVsZW1lbnQgPSAoMCwgbWVzc2FnZV9yZW5kZXJlcl8xLnJlbmRlckJvdE1lc3NhZ2UpKHRleHQsIHsgaXNNYXJrZG93bjogYm90SXNNYXJrZG93biB9LCBleHRlbmRlZENhbGxiYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51aU1hbmFnZXIuYWRkQ2hhdE1lc3NhZ2VFbGVtZW50KG1lc3NhZ2VFbGVtZW50KTtcbiAgICAgICAgLy8gRG9uJ3Qgc2F2ZSBpbnRlcm5hbCAnY29uZmlybWVkJy8ncmVqZWN0ZWQnIG1lc3NhZ2VzIHRvIGhpc3RvcnlcbiAgICAgICAgaWYgKCFpc0F1dG8pIHtcbiAgICAgICAgICAgIC8vIEFkZCBpc01hcmtkb3duIGJhY2sgdG8gdGhlIHNhdmVkIG1lc3NhZ2Ugc3RhdGVcbiAgICAgICAgICAgIGNvbnN0IGNoYXRNZXNzYWdlID0geyBzZW5kZXIsIHRleHQsIGlzTWFya2Rvd24gfTtcbiAgICAgICAgICAgIHRoaXMuY2hhdFN0YXRlLmFkZE1lc3NhZ2VUb0N1cnJlbnRDaGF0KGNoYXRNZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb3JlIGxvZ2ljIGZvciBzZW5kaW5nIGEgbWVzc2FnZSB0byB0aGUgQVBJLCBoYW5kbGluZyB0aGUgc3RyZWFtLFxuICAgICAqIHJlbmRlcmluZyB0aGUgcmVzcG9uc2UsIGFuZCBzYXZpbmcgdGhlIGZpbmFsIGJvdCBtZXNzYWdlLlxuICAgICAqL1xuICAgIHN0cmVhbUFuZFJlbmRlclJlc3BvbnNlKG1lc3NhZ2VUb1NlbmQpIHtcbiAgICAgICAgLy8gLS0tIFByZXBhcmUgc3RyZWFtaW5nIFVJIGVsZW1lbnRzIChtYW5hZ2VkIGJ5IFVJTWFuYWdlcikgLS0tXG4gICAgICAgIC8vIFVJTWFuYWdlciBzaG91bGQgcHJvdmlkZSBhIG1ldGhvZCB0byBjcmVhdGUvZ2V0IHRoZXNlIGVsZW1lbnRzXG4gICAgICAgIGNvbnN0IHsgc3RyZWFtaW5nRGl2LCBjb250ZW50RGl2IH0gPSB0aGlzLnVpTWFuYWdlci5jcmVhdGVCb3RNZXNzYWdlQ29udGFpbmVyKCk7XG4gICAgICAgIGxldCBjb21wbGV0ZVJlc3BvbnNlID0gJyc7XG4gICAgICAgIGNvbnN0IGNlbGxDb250ZXh0ID0gKDAsIG5vdGVib29rX2ludGVncmF0aW9uXzEuZ2V0Q3VycmVudENlbGxDb250ZW50KSgpOyAvLyBVc2UgdXRpbGl0eVxuICAgICAgICAvLyBTdHJlYW0gcmVzcG9uc2UgZnJvbSBBUElcbiAgICAgICAgdGhpcy5hcGlDbGllbnQuc3RyZWFtQ2hhdChtZXNzYWdlVG9TZW5kLCB7IGNlbGxDb250ZXh0IH0sIFxuICAgICAgICAvLyBPbiBjaHVuayByZWNlaXZlZFxuICAgICAgICAoY2h1bmspID0+IHtcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UgKz0gY2h1bms7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHRlbXBvcmFyeSBzdHJlYW1pbmcgZGl2XG4gICAgICAgICAgICBzdHJlYW1pbmdEaXYudGV4dENvbnRlbnQgPSBjb21wbGV0ZVJlc3BvbnNlO1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIE9uIGNvbXBsZXRlXG4gICAgICAgICgpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIEhpZGUgc3RyZWFtaW5nIGRpdiwgc2hvdyBmaW5hbCBjb250ZW50IGRpdlxuICAgICAgICAgICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBjb250ZW50RGl2LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBjb21wbGV0ZSByZXNwb25zZSB1c2luZyB0aGUgcmVuZGVyZXIgZnVuY3Rpb25cbiAgICAgICAgICAgIGNvbnN0IHJlbmRlcmVkQ29udGVudCA9ICgwLCBtZXNzYWdlX3JlbmRlcmVyXzEucmVuZGVyQm90TWVzc2FnZSkoY29tcGxldGVSZXNwb25zZSwgeyBpc01hcmtkb3duOiB0cnVlIH0sIHRoaXMucmVuZGVyZXJDYWxsYmFja3MpO1xuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSAnJzsgLy8gQ2xlYXIgcGxhY2Vob2xkZXIvcHJldmlvdXMgY29udGVudFxuICAgICAgICAgICAgLy8gQXBwZW5kIHJlbmRlcmVkIG5vZGVzLCBza2lwcGluZyBhbnkgcG90ZW50aWFsIHdyYXBwZXIvaW5kaWNhdG9yIGFkZGVkIGJ5IHJlbmRlckJvdE1lc3NhZ2UgaXRzZWxmXG4gICAgICAgICAgICB3aGlsZSAocmVuZGVyZWRDb250ZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBpcyB0aGUgc3BlY2lmaWMgbWFya2Rvd24gaW5kaWNhdG9yIHdlIG1pZ2h0IGFkZC9yZW1vdmVcbiAgICAgICAgICAgICAgICAvLyBPciBqdXN0IGFwcGVuZCBldmVyeXRoaW5nIGlmIHJlbmRlckJvdE1lc3NhZ2UgcmV0dXJucyB0aGUgcHVyZSBjb250ZW50XG4gICAgICAgICAgICAgICAgaWYgKCEoKF9hID0gcmVuZGVyZWRDb250ZW50LmZpcnN0Q2hpbGQuY2xhc3NMaXN0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29udGFpbnMoJ21hcmtkb3duLWluZGljYXRvcicpKSkge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50RGl2LmFwcGVuZENoaWxkKHJlbmRlcmVkQ29udGVudC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgaW5kaWNhdG9yIGlmIGl0IHdhcyBwYXJ0IG9mIHRoZSByZXR1cm5lZCBmcmFnbWVudFxuICAgICAgICAgICAgICAgICAgICByZW5kZXJlZENvbnRlbnQucmVtb3ZlQ2hpbGQocmVuZGVyZWRDb250ZW50LmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNhdmUgZmluYWwgYm90IHJlc3BvbnNlIHRvIGhpc3RvcnkgdmlhIENoYXRTdGF0ZVxuICAgICAgICAgICAgY29uc3QgaXNJbWFnZSA9IGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJyk7IC8vIFNpbXBsZSBjaGVja1xuICAgICAgICAgICAgY29uc3QgYm90TWVzc2FnZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogY29tcGxldGVSZXNwb25zZSxcbiAgICAgICAgICAgICAgICBzZW5kZXI6ICdib3QnLFxuICAgICAgICAgICAgICAgIGlzTWFya2Rvd246ICFpc0ltYWdlIC8vIFNhdmUgYXMgbWFya2Rvd24gdW5sZXNzIGl0J3MgYW4gaW1hZ2UgVVJMXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5jaGF0U3RhdGUuYWRkTWVzc2FnZVRvQ3VycmVudENoYXQoYm90TWVzc2FnZURhdGEpO1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2Nyb2xsVG9Cb3R0b20oKTtcbiAgICAgICAgfSwgXG4gICAgICAgIC8vIE9uIGVycm9yXG4gICAgICAgIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IGZpbmFsIGNvbnRlbnQgZGl2IHdpdGggZXJyb3JcbiAgICAgICAgICAgIHN0cmVhbWluZ0Rpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICAgIC8vIFVzZSBhIGRlZGljYXRlZCBlcnJvciByZW5kZXJpbmcgc3R5bGUvY29tcG9uZW50IGlmIGF2YWlsYWJsZVxuICAgICAgICAgICAgY29udGVudERpdi5pbm5lckhUTUwgPSBgPGRpdiBjbGFzcz1cImpwLWxsbS1leHQtZXJyb3ItbWVzc2FnZVwiPkVycm9yOiAke2Vycm9yLm1lc3NhZ2V9PC9kaXY+YDtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0FQSSBFcnJvcjonLCBlcnJvcik7XG4gICAgICAgICAgICB0aGlzLnVpTWFuYWdlci5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gTWVzc2FnZUhhbmRsZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IHZvaWQgMDtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL2dsb2JhbHNcIik7XG4vKipcbiAqIE1hbmFnZXMgdGhlIHN0YXRlIGFuZCBpbnRlcmFjdGlvbnMgb2YgdGhlIG11bHRpLWxldmVsIHBvcHVwIG1lbnUuXG4gKi9cbmNsYXNzIFBvcHVwTWVudU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIsIHdpZGdldE5vZGUsIGNhbGxiYWNrcykge1xuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJztcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSAnJztcbiAgICAgICAgdGhpcy5tZW51SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnROb3RlYm9vayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7IC8vIFRyYWNrIGN1cnJlbnRseSBzZWxlY3RlZCBtZW51IGl0ZW1cbiAgICAgICAgdGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQgPSBmYWxzZTsgLy8gRmxhZyB0byBwcmV2ZW50IHJlY3Vyc2l2ZSByZW5kZXJzXG4gICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSAnJzsgLy8gVHJhY2sgbGFzdCBzZWFyY2ggdGVybSB0byBhdm9pZCB1bm5lY2Vzc2FyeSByZS1yZW5kZXJzXG4gICAgICAgIHRoaXMuYWxsb3dlZEV4dGVuc2lvbnMgPSBbJy5weScsICcuaXB5bmInLCAnLm1kJywgJy5qc29uJywgJy50eHQnLCAnLmNzdiddO1xuICAgICAgICB0aGlzLmZpbGVDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICAgICAgdGhpcy53aWRnZXROb2RlID0gd2lkZ2V0Tm9kZTtcbiAgICAgICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgLy8gQXR0YWNoIHRvIHRoZSB3aWRnZXQgbm9kZSBpbnN0ZWFkIG9mIHRoZSBib2R5XG4gICAgICAgIHRoaXMud2lkZ2V0Tm9kZS5hcHBlbmRDaGlsZCh0aGlzLnBvcHVwTWVudUNvbnRhaW5lcik7XG4gICAgICAgIC8vIENyZWF0ZSBzZWFyY2ggaW5wdXRcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5wbGFjZWhvbGRlciA9ICdTZWFyY2guLi4nO1xuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtc2VhcmNoJzsgLy8gQWRkIGNsYXNzIGZvciBzdHlsaW5nXG4gICAgICAgIC8vIFVzZSAnaW5wdXQnIGV2ZW50IGluc3RlYWQgb2YgZGlyZWN0bHkgcmUtcmVuZGVyaW5nIG9uIGV2ZXJ5IGtleXN0cm9rZVxuICAgICAgICB0aGlzLnNlYXJjaElucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2lucHV0JywgKCkgPT4ge1xuICAgICAgICAgICAgLy8gT25seSByZS1yZW5kZXIgaWYgdGhlIHNlYXJjaCB0ZXJtIGhhcyBhY3R1YWxseSBjaGFuZ2VkXG4gICAgICAgICAgICBpZiAodGhpcy5zZWFyY2hJbnB1dC52YWx1ZSAhPT0gdGhpcy5sYXN0U2VhcmNoVGVybSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEhhbmRsZSBrZXlkb3duIGluIHNlYXJjaCBpbnB1dCB0byBzdG9wIHByb3BhZ2F0aW9uIGZvciBuYXZpZ2F0aW9uIGtleXNcbiAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgU2VhcmNoIEtleURvd246IEtleT0nJHtldmVudC5rZXl9J2ApO1xuICAgICAgICAgICAgLy8gSU1QT1JUQU5UOiBQcmV2ZW50IHRoZXNlIGtleXMgZnJvbSBiZWluZyBjYXB0dXJlZCBieSB0aGUgZG9jdW1lbnQgaGFuZGxlclxuICAgICAgICAgICAgaWYgKFsnQXJyb3dVcCcsICdBcnJvd0Rvd24nLCAnRW50ZXInLCAnVGFiJywgJ0VzY2FwZSddLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVAgKFNlYXJjaCBJbnB1dCk6IFN0b3BwaW5nIHByb3BhZ2F0aW9uIGZvciBuYXZpZ2F0aW9uIGtleTonLCBldmVudC5rZXkpO1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBFc2NhcGUgZGlyZWN0bHkgaGVyZVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHNlbGVjdCBmaXJzdCBpdGVtIG9uIEVudGVyP1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IGFjdGl2YXRlIHRoZSBpdGVtOlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWVudUl0ZW1zWzBdLmNsaWNrKCk7IFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gJ0Fycm93RG93bicgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dVcCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTW92ZSB0byBmaXJzdC9sYXN0IG1lbnUgaXRlbVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmx1cigpIHdpbGwgYmUgaGFuZGxlZCBieSBtYWluIGtleSBoYW5kbGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ1JJVElDQUw6IERPIE5PVCBzdG9wIHByb3BhZ2F0aW9uIGZvciBCYWNrc3BhY2Ugb3Igb3RoZXIgdGV4dCBlZGl0aW5nIGtleXNcbiAgICAgICAgICAgIC8vIFRoaXMgYWxsb3dzIGRlZmF1bHQgYmVoYXZpb3IgdG8gd29yayBwcm9wZXJseVxuICAgICAgICB9LCB0cnVlKTsgLy8gVXNlIGNhcHR1cmUgcGhhc2VcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2suYmluZCh0aGlzKSwgdHJ1ZSk7XG4gICAgICAgIC8vIElNUE9SVEFOVDogVXNlIGEgc2VwYXJhdGUgYm91bmQgZnVuY3Rpb24gZm9yIHRoZSBkb2N1bWVudCBrZXlkb3duXG4gICAgICAgIC8vIHNvIHdlIGNhbiByZW1vdmUgdGhlIGV4YWN0IHNhbWUgbGlzdGVuZXIgbGF0ZXJcbiAgICAgICAgdGhpcy5ib3VuZEhhbmRsZUtleURvd24gPSB0aGlzLmhhbmRsZUtleURvd24uYmluZCh0aGlzKTtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgICAgICAgaWYgKGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldDtcbiAgICAgICAgICAgIGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5jb25uZWN0KChzZW5kZXIsIG5vdGVib29rKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Tm90ZWJvb2sgPSBub3RlYm9vaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrLmJpbmQodGhpcyksIHRydWUpO1xuICAgICAgICAvLyBSZW1vdmUgdXNpbmcgdGhlIGV4YWN0IHNhbWUgYm91bmQgZnVuY3Rpb25cbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuYm91bmRIYW5kbGVLZXlEb3duLCB0cnVlKTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gd2lkZ2V0Tm9kZSBpZiBhdHRhY2hlZFxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIucGFyZW50Tm9kZSA9PT0gdGhpcy53aWRnZXROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoYW5kbGVEb2N1bWVudENsaWNrKGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScgJiYgIXRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGF0QnV0dG9uID0gdGhpcy53aWRnZXROb2RlLnF1ZXJ5U2VsZWN0b3IoJyNqcC1sbG0tZXh0LWF0LWJ1dHRvbicpO1xuICAgICAgICAgICAgaWYgKGF0QnV0dG9uICYmIGF0QnV0dG9uLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IENsaWNrIHdhcyBvbiB0aGUgQCBidXR0b24sIG5vdCBoaWRpbmcuJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBDbGljayBkZXRlY3RlZCBvdXRzaWRlIHRoZSBtZW51LicpO1xuICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2hvd1BvcHVwTWVudSh4LCB5KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogU2hvd2luZyBtZW51IGF0ICgke3h9LCAke3l9KWApO1xuICAgICAgICAvLyBTdG9yZSB0aGUgaW5pdGlhbCBhbmNob3IgcG9pbnQgZm9yIHBvc2l0aW9uaW5nXG4gICAgICAgIHRoaXMuX2FuY2hvclggPSB4O1xuICAgICAgICB0aGlzLl9hbmNob3JZID0geTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50TWVudUxldmVsID0gJ3RvcCc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tZW51SGlzdG9yeSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBDbGVhciBzZWFyY2ggb24gc2hvd1xuICAgICAgICAgICAgdGhpcy5sYXN0U2VhcmNoVGVybSA9ICcnOyAvLyBSZXNldCBsYXN0IHNlYXJjaCB0ZXJtXG4gICAgICAgICAgICBhd2FpdCB0aGlzLnNldEN1cnJlbnREaXJlY3RvcnlQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpO1xuICAgICAgICAvLyBFbnN1cmUgaXQncyBhdHRhY2hlZCB0byB0aGUgd2lkZ2V0IG5vZGUgaWYgc29tZWhvdyBkZXRhY2hlZFxuICAgICAgICB0aGlzLndpZGdldE5vZGUuYXBwZW5kQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICAvLyBQb3NpdGlvbiB0aGUgcG9wdXAgbWVudSAtIERFRkVSIGNhbGN1bGF0aW9uIHNsaWdodGx5XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQT1BVUDogRGVmZXJyZWQgdXBkYXRlUG9wdXBQb3NpdGlvbiBjYWxsLlwiKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVQb3B1cFBvc2l0aW9uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiUE9QVVA6IEVycm9yIGR1cmluZyBkZWZlcnJlZCB1cGRhdGVQb3B1cFBvc2l0aW9uOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb2N1cyB0aGUgc2VhcmNoIGlucHV0ICphZnRlciogcG9zaXRpb25pbmcgaWYgaW4gZmlsZS9kaXIgdmlld1xuICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBmb2N1cyBmaXJzdCBtZW51IGl0ZW1cbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRm9jdXNlZCBzZWFyY2ggaW5wdXQgYWZ0ZXIgZGVmZXJyZWQgcG9zaXRpb25pbmcuJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTsgLy8gRG9uJ3Qgc2VsZWN0IGFuIGl0ZW0gaWYgc2VhcmNoIGlzIGZvY3VzZWRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBUb3AgbGV2ZWwgb3IgY2VsbHNcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0TmV4dE1lbnVJdGVtKCk7IC8vIFNlbGVjdCBmaXJzdCBpdGVtXG4gICAgICAgICAgICAgICAgLy8gT3B0aW9uYWxseSBmb2N1cyB0aGUgZmlyc3QgaXRlbSBmb3IgaW1tZWRpYXRlIGtleWJvYXJkIG5hdlxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgLy8gaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSBtZW51SXRlbXNbMF0uZm9jdXMoKTsgXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDApOyAvLyAwbXMgZGVsYXkgaXMgdXN1YWxseSBzdWZmaWNpZW50XG4gICAgfVxuICAgIGhpZGVQb3B1cE1lbnUoKSB7XG4gICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogSGlkaW5nIG1lbnUuIENhbGxlZCBmcm9tOicsIG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSAndG9wJzsgLy8gUmVzZXQgbGV2ZWxcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyByZW5kZXJNZW51Q29udGVudCgpIHtcbiAgICAgICAgLy8gUHJldmVudCByZWN1cnNpdmUgcmVuZGVyc1xuICAgICAgICBpZiAodGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogU2tpcHBpbmcgcmVuZGVyIC0gYWxyZWFkeSByZW5kZXJpbmcnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzUmVuZGVyaW5nQ29udGVudCA9IHRydWU7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBDbGVhciBleGlzdGluZyBjb250ZW50XG4gICAgICAgICAgICB3aGlsZSAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSBhZGQgc2VhcmNoIGlucHV0IGlmIE5PVCBhdCB0b3AgbGV2ZWxcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09ICd0b3AnKSB7XG4gICAgICAgICAgICAgICAgLy8gQWRkIHNlYXJjaCBpbnB1dCBhdCB0aGUgdG9wIG9mIHRoZSBtZW51XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5zZWFyY2hJbnB1dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnOyAvLyBDbGVhciBmb3IgZmlsZS9kaXIvY2VsbCBsZXZlbHNcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RTZWFyY2hUZXJtID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZW5kZXIgZGlmZmVyZW50IG1lbnUgY29udGVudCBiYXNlZCBvbiBjdXJyZW50IGxldmVsXG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuY3VycmVudE1lbnVMZXZlbCkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3RvcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyVG9wTGV2ZWxJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmaWxlcyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlyZWN0b3JpZXMnOlxuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjZWxscyc6XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVuZGVyQ2VsbEl0ZW1zKCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVzZXQgc2VsZWN0aW9uIGFmdGVyIHJlbmRlcmluZ1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHBvc2l0aW9uIChtaWdodCBoYXZlIGNoYW5nZWQgZHVlIHRvIGNvbnRlbnQgcmVuZGVyaW5nKVxuICAgICAgICAgICAgY29uc29sZS5sb2coXCJQT1BVUDogPT09PiBBYm91dCB0byBjYWxsIHVwZGF0ZVBvcHVwUG9zaXRpb24gYWZ0ZXIgcmVuZGVyTWVudUNvbnRlbnRcIik7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlUG9wdXBQb3NpdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJQT1BVUDogRXJyb3IgY2FsbGluZyB1cGRhdGVQb3B1cFBvc2l0aW9uIGFmdGVyIHJlbmRlcjpcIiwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBFcnJvciByZW5kZXJpbmcgbWVudSBjb250ZW50JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5pc1JlbmRlcmluZ0NvbnRlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZW5kZXJUb3BMZXZlbEl0ZW1zKCkge1xuICAgICAgICBjb25zdCB0b3BMZXZlbENvbW1hbmRzID0gW1xuICAgICAgICAgICAgeyBsYWJlbDogJ0NvZGUnLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnaW5zZXJ0LWNvZGUnIH0sXG4gICAgICAgICAgICB7IGxhYmVsOiAnQ2VsbHMnLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWNlbGxzJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0ZpbGUnLCBkZXNjcmlwdGlvbjogJycsIGFjdGlvbklkOiAnYnJvd3NlLWZpbGVzJyB9LFxuICAgICAgICAgICAgeyBsYWJlbDogJ0RpcmVjdG9yeScsIGRlc2NyaXB0aW9uOiAnJywgYWN0aW9uSWQ6ICdicm93c2UtZGlyZWN0b3JpZXMnIH1cbiAgICAgICAgXTtcbiAgICAgICAgdG9wTGV2ZWxDb21tYW5kcy5mb3JFYWNoKGNtZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShjbWQubGFiZWwsIGNtZC5hY3Rpb25JZCwgJycsIGNtZC5kZXNjcmlwdGlvbik7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChpdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHJlbmRlckRpcmVjdG9yeUJyb3dzZXJJdGVtcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBHZXQgc2VhcmNoIHRlcm1cbiAgICAgICAgY29uc3Qgc2VhcmNoVGVybSA9IHRoaXMuc2VhcmNoSW5wdXQudmFsdWUudG9Mb3dlckNhc2UoKS50cmltKCk7XG4gICAgICAgIGNvbnN0IGxvYWRpbmdJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTG9hZGluZy4uLicsICdsb2FkaW5nJywgJycsICcnKTtcbiAgICAgICAgbG9hZGluZ0l0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgLy8gVGVtcG9yYXJpbHkgYWRkIGxvYWRpbmcgaXRlbSBiZWxvdyBzZWFyY2gvcGF0aFxuICAgICAgICBjb25zdCBpbnNlcnRpb25Qb2ludCA9IChfYSA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCcpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV4dFNpYmxpbmc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmluc2VydEJlZm9yZShsb2FkaW5nSXRlbSwgaW5zZXJ0aW9uUG9pbnQgfHwgbnVsbCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBJZiBjb250ZW50cyB3ZXJlIGFscmVhZHkgZmV0Y2hlZCByZWNlbnRseSBhbmQgd2UncmUganVzdCBmaWx0ZXJpbmcgYWdhaW4sXG4gICAgICAgICAgICAvLyB3ZSBjb3VsZCBwb3RlbnRpYWxseSBjYWNoZSB0aGUgcmVzdWx0cyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBBUEkgY2FsbHNcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlclR5cGUgPSB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgPyAnZmlsZScgOiAnZGlyZWN0b3J5JztcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgdGhpcy5saXN0Q3VycmVudERpcmVjdG9yeUNvbnRlbnRzKHRoaXMuY3VycmVudE1lbnVQYXRoLCBmaWx0ZXJUeXBlKTtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHN0aWxsIGluIERPTSBiZWZvcmUgdHJ5aW5nIHRvIHJlbW92ZVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb250ZW50cyAmJiBjb250ZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLy8gRmlsdGVyIGJhc2VkIG9uIHNlYXJjaCB0ZXJtXG4gICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyZWRDb250ZW50cyA9IGNvbnRlbnRzLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGl0ZW0ubmFtZS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0pIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLnJlbGF0aXZlUGF0aC50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKHNlYXJjaFRlcm0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJlZENvbnRlbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsdGVyZWRDb250ZW50cy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXRlbU5hbWUgPSBpdGVtLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpdGVtVHlwZSA9IGl0ZW0udHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1QYXRoID0gaXRlbS5wYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVQYXRoID0gaXRlbS5yZWxhdGl2ZVBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpY29uID0gaXRlbVR5cGUgPT09ICdkaXJlY3RvcnknID8gJ/Cfk4EnIDogJ/Cfk4QnO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGFjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1UeXBlID09PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbklkID0gdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ3NlbGVjdC1kaXJlY3RvcnktbmF2aWdhdGUnIDogJ3NlbGVjdC1kaXJlY3RvcnktY2FsbGJhY2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7IC8vIGl0ZW1UeXBlID09PSAnZmlsZSdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb25JZCA9ICdzZWxlY3QtZmlsZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oYCR7aWNvbn0gJHtpdGVtTmFtZX1gLCBhY3Rpb25JZCwgaXRlbVBhdGgsIHJlbGF0aXZlUGF0aCAhPT0gJy4nID8gcmVsYXRpdmVQYXRoIDogJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQobWVudUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oc2VhcmNoVGVybSA/ICdObyBtYXRjaGVzIGZvdW5kJyA6IGBObyAke2ZpbHRlclR5cGV9cyBmb3VuZGAsICdlbXB0eScsICcnLCAnJyk7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5SXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oYE5vIGl0ZW1zIGZvdW5kIGluIHRoaXMgZGlyZWN0b3J5YCwgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmNvbnRhaW5zKGxvYWRpbmdJdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnJlbW92ZUNoaWxkKGxvYWRpbmdJdGVtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVycm9ySXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oYEVycm9yOiAke2Vycm9yfWAsICdlcnJvcicsICcnLCAnJyk7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUuY29sb3IgPSAncmVkJztcbiAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoZXJyb3JJdGVtKTtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBFcnJvciBsb2FkaW5nL2ZpbHRlcmluZyBkaXJlY3RvcnkgY29udGVudHM6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmRlcnMgYWxsIGNlbGxzIGZyb20gdGhlIGN1cnJlbnQgbm90ZWJvb2tcbiAgICAgKi9cbiAgICBhc3luYyByZW5kZXJDZWxsSXRlbXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIEdldCBzZWFyY2ggdGVybSBmb3IgZmlsdGVyaW5nXG4gICAgICAgIGNvbnN0IHNlYXJjaFRlcm0gPSB0aGlzLnNlYXJjaElucHV0LnZhbHVlLnRvTG93ZXJDYXNlKCkudHJpbSgpO1xuICAgICAgICAvLyBDcmVhdGUgYSBsb2FkaW5nIGluZGljYXRvclxuICAgICAgICBjb25zdCBsb2FkaW5nSXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ0xvYWRpbmcgY2VsbHMuLi4nLCAnbG9hZGluZycsICcnLCAnJyk7XG4gICAgICAgIGxvYWRpbmdJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgIGNvbnN0IGluc2VydGlvblBvaW50ID0gKF9hID0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIucXVlcnlTZWxlY3RvcignLmpwLWxsbS1leHQtcG9wdXAtbWVudS1wYXRoJykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXh0U2libGluZztcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuaW5zZXJ0QmVmb3JlKGxvYWRpbmdJdGVtLCBpbnNlcnRpb25Qb2ludCB8fCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIGhhdmUgYW4gYWN0aXZlIG5vdGVib29rXG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudE5vdGVib29rIHx8ICF0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50IHx8ICF0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZW50Lm1vZGVsKSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGxvYWRpbmcgaXRlbVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIucmVtb3ZlQ2hpbGQobG9hZGluZ0l0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdObyBhY3RpdmUgbm90ZWJvb2sgZm91bmQnLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5jb2xvciA9ICdyZWQnO1xuICAgICAgICAgICAgICAgIGVycm9ySXRlbS5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm90ZWJvb2tNb2RlbCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRlbnQubW9kZWw7XG4gICAgICAgICAgICBjb25zdCBjZWxscyA9IG5vdGVib29rTW9kZWwuY2VsbHM7XG4gICAgICAgICAgICAvLyBSZW1vdmUgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNlbGxzIHx8IGNlbGxzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVtcHR5SXRlbSA9IHRoaXMuY3JlYXRlTWVudUl0ZW0oJ05vIGNlbGxzIGluIG5vdGVib29rJywgJ2VtcHR5JywgJycsICcnKTtcbiAgICAgICAgICAgICAgICBlbXB0eUl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eUl0ZW0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYW5kIGRpc3BsYXkgZWFjaCBjZWxsXG4gICAgICAgICAgICBsZXQgZmlsdGVyZWRDZWxsQ291bnQgPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjZWxscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGwgPSBjZWxscy5nZXQoaSk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbFR5cGUgPSBjZWxsLnR5cGU7XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSBjZWxsLnNoYXJlZE1vZGVsID8gY2VsbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKSA6XG4gICAgICAgICAgICAgICAgICAgICgoKF9iID0gY2VsbC50b0pTT04oKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNvdXJjZSkgfHwgJycpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSB0eXBlIGNhc3RpbmcgdG8gYXZvaWQgVHlwZVNjcmlwdCBlcnJvcnNcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRpb25Db3VudCA9IGNlbGxUeXBlID09PSAnY29kZScgP1xuICAgICAgICAgICAgICAgICAgICAoY2VsbC5leGVjdXRpb25Db3VudCAhPT0gdW5kZWZpbmVkICYmIGNlbGwuZXhlY3V0aW9uQ291bnQgIT09IG51bGwgP1xuICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5leGVjdXRpb25Db3VudCA6ICcqJykgOlxuICAgICAgICAgICAgICAgICAgICAnJztcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgYSBwcmV2aWV3IG9mIHRoZSBjZWxsIGNvbnRlbnQgKHRydW5jYXRlIGlmIG5lZWRlZClcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50UHJldmlldyA9IHR5cGVvZiBjZWxsQ29udGVudCA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA6XG4gICAgICAgICAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNlbGxDb250ZW50KSA/IGNlbGxDb250ZW50LmpvaW4oJ1xcbicpIDogJycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpcnN0TGluZSA9IGNvbnRlbnRQcmV2aWV3LnNwbGl0KCdcXG4nKVswXSB8fCAnJztcbiAgICAgICAgICAgICAgICBjb25zdCB0cnVuY2F0ZWRDb250ZW50ID0gZmlyc3RMaW5lLmxlbmd0aCA+IDMwID9cbiAgICAgICAgICAgICAgICAgICAgZmlyc3RMaW5lLnN1YnN0cmluZygwLCAzMCkgKyAnLi4uJyA6XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0TGluZTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgY2VsbCBsYWJlbCB3aXRoIHN0eWxlZCB0eXBlIGluZGljYXRvclxuICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVJbmRpY2F0b3IgPSBjZWxsVHlwZSA9PT0gJ21hcmtkb3duJyA/ICdNJyA6ICdDJztcbiAgICAgICAgICAgICAgICBjb25zdCBleGVjdXRpb25EaXNwbGF5ID0gZXhlY3V0aW9uQ291bnQgIT09ICcnID8gYFske2V4ZWN1dGlvbkNvdW50fV1gIDogJyc7XG4gICAgICAgICAgICAgICAgLy8gQ3JlYXRlIG1lbnUgaXRlbSBmb3IgdGhpcyBjZWxsXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCcnLCAvLyBFbXB0eSB0ZXh0LCB3aWxsIGJlIGFkZGVkIGFzIEhUTUxcbiAgICAgICAgICAgICAgICAnc2VsZWN0LWNlbGwnLCBpLnRvU3RyaW5nKCkgLy8gU3RvcmUgY2VsbCBpbmRleCBpbiBwYXRoXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICAvLyBDcmVhdGUgc3R5bGVkIGNvbnRlbnQgd2l0aCBIVE1MIGVsZW1lbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZVNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgdHlwZVNwYW4uY2xhc3NOYW1lID0gYGNlbGwtdHlwZS1pbmRpY2F0b3IgY2VsbC10eXBlLSR7Y2VsbFR5cGUgPT09ICdtYXJrZG93bicgPyAnbWQnIDogJ2NvZGUnfWA7XG4gICAgICAgICAgICAgICAgdHlwZVNwYW4udGV4dENvbnRlbnQgPSB0eXBlSW5kaWNhdG9yO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWNTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGV4ZWNTcGFuLmNsYXNzTmFtZSA9ICdjZWxsLWV4ZWMtY291bnQnO1xuICAgICAgICAgICAgICAgIGV4ZWNTcGFuLnRleHRDb250ZW50ID0gZXhlY3V0aW9uRGlzcGxheTtcbiAgICAgICAgICAgICAgICBleGVjU3Bhbi5zdHlsZS5tYXJnaW5SaWdodCA9ICc4cHgnO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRTcGFuLmNsYXNzTmFtZSA9ICdjZWxsLWNvbnRlbnQtcHJldmlldyc7XG4gICAgICAgICAgICAgICAgY29udGVudFNwYW4udGV4dENvbnRlbnQgPSB0cnVuY2F0ZWRDb250ZW50O1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbGFiZWwgc3BhbiAoZmlyc3QgY2hpbGQgb2YgdGhlIG1lbnUgaXRlbSlcbiAgICAgICAgICAgICAgICBjb25zdCBsYWJlbFNwYW4gPSBjZWxsSXRlbS5xdWVyeVNlbGVjdG9yKCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsU3Bhbikge1xuICAgICAgICAgICAgICAgICAgICBsYWJlbFNwYW4udGV4dENvbnRlbnQgPSAnJzsgLy8gQ2xlYXIgZXhpc3RpbmcgdGV4dFxuICAgICAgICAgICAgICAgICAgICBsYWJlbFNwYW4uYXBwZW5kQ2hpbGQodHlwZVNwYW4pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXhlY3V0aW9uRGlzcGxheSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWxTcGFuLmFwcGVuZENoaWxkKGV4ZWNTcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsYWJlbFNwYW4uYXBwZW5kQ2hpbGQoY29udGVudFNwYW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgZnVsbCBzZWFyY2hhYmxlIHRleHRcbiAgICAgICAgICAgICAgICBjb25zdCBzZWFyY2hhYmxlVGV4dCA9IGAke3R5cGVJbmRpY2F0b3J9ICR7ZXhlY3V0aW9uRGlzcGxheX0gJHt0cnVuY2F0ZWRDb250ZW50fWAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAvLyBGaWx0ZXIgYnkgc2VhcmNoIHRlcm0gaWYgb25lIGlzIHByb3ZpZGVkXG4gICAgICAgICAgICAgICAgaWYgKHNlYXJjaFRlcm0gJiYgIXNlYXJjaGFibGVUZXh0LmluY2x1ZGVzKHNlYXJjaFRlcm0pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChjZWxsSXRlbSk7XG4gICAgICAgICAgICAgICAgZmlsdGVyZWRDZWxsQ291bnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWx0ZXJlZENlbGxDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vTWF0Y2hJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbSgnTm8gbWF0Y2hpbmcgY2VsbHMgZm91bmQnLCAnZW1wdHknLCAnJywgJycpO1xuICAgICAgICAgICAgICAgIG5vTWF0Y2hJdGVtLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQobm9NYXRjaEl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgbG9hZGluZyBpbmRpY2F0b3JcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhsb2FkaW5nSXRlbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5yZW1vdmVDaGlsZChsb2FkaW5nSXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlcnJvckl0ZW0gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKGBFcnJvcjogJHtlcnJvcn1gLCAnZXJyb3InLCAnJywgJycpO1xuICAgICAgICAgICAgZXJyb3JJdGVtLnN0eWxlLmNvbG9yID0gJ3JlZCc7XG4gICAgICAgICAgICBlcnJvckl0ZW0uc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGVycm9ySXRlbSk7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogRXJyb3IgbG9hZGluZyBub3RlYm9vayBjZWxsczonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlTWVudUl0ZW0odGV4dCwgYWN0aW9uSWQsIHBhdGggPSAnJywgZGVzY3JpcHRpb24gPSAnJykge1xuICAgICAgICBjb25zdCBpdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGl0ZW0uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtJztcbiAgICAgICAgaXRlbS5kYXRhc2V0LmFjdGlvbklkID0gYWN0aW9uSWQ7XG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICBpdGVtLmRhdGFzZXQucGF0aCA9IHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS5vbmNsaWNrID0gKGV2ZW50KSA9PiB0aGlzLmhhbmRsZU1lbnVDbGljayhldmVudCk7XG4gICAgICAgIGNvbnN0IGxhYmVsU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgbGFiZWxTcGFuLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChsYWJlbFNwYW4pO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgcGF0aFNwYW4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1wYXRoLWluZGljYXRvcic7XG4gICAgICAgICAgICBwYXRoU3Bhbi50ZXh0Q29udGVudCA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgcGF0aFNwYW4uc3R5bGUuZm9udFNpemUgPSAnMC44NWVtJztcbiAgICAgICAgICAgIHBhdGhTcGFuLnN0eWxlLmNvbG9yID0gJ3ZhcigtLWpwLXVpLWZvbnQtY29sb3IyKSc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5tYXJnaW5MZWZ0ID0gJzhweCc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5vcGFjaXR5ID0gJzAuOCc7XG4gICAgICAgICAgICBwYXRoU3Bhbi5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7IC8vIEVuc3VyZSB0aGUgcGF0aCBpcyBhbHdheXMgZGlzcGxheWVkXG4gICAgICAgICAgICBpdGVtLmFwcGVuZENoaWxkKHBhdGhTcGFuKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXRlbTtcbiAgICB9XG4gICAgYXN5bmMgaGFuZGxlTWVudUNsaWNrKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQuY3VycmVudFRhcmdldDtcbiAgICAgICAgY29uc3QgYWN0aW9uSWQgPSB0YXJnZXQuZGF0YXNldC5hY3Rpb25JZDtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRhcmdldC5kYXRhc2V0LnBhdGggfHwgJyc7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogTWVudSBpdGVtIGNsaWNrZWQuIEFjdGlvbjogJHthY3Rpb25JZH0sIFBhdGg6ICR7cGF0aH1gKTtcbiAgICAgICAgc3dpdGNoIChhY3Rpb25JZCkge1xuICAgICAgICAgICAgY2FzZSAnbmF2aWdhdGUtYmFjayc6XG4gICAgICAgICAgICAgICAgdGhpcy5uYXZpZ2F0ZUJhY2tNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdpbnNlcnQtY29kZSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSB0aGlzLmNhbGxiYWNrcy5nZXRTZWxlY3RlZFRleHQgPyB0aGlzLmNhbGxiYWNrcy5nZXRTZWxlY3RlZFRleHQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHNlbGVjdGVkVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBTaG93IHN1Ym1lbnUgZm9yIGNvZGUgaW5zZXJ0aW9uIG9wdGlvbnNcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VibWVudUl0ZW1zID0gW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBsYWJlbDogJ0luc2VydCBhcyBwbGFpbiBjb2RlJywgYWN0aW9uSWQ6ICdpbnNlcnQtcGxhaW4tY29kZScsIGRhdGE6IHNlbGVjdGVkVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBsYWJlbDogJ0luc2VydCBhcyBjb2xsYXBzZWQgcmVmZXJlbmNlJywgYWN0aW9uSWQ6ICdjb2xsYXBzZS1jb2RlLXJlZicsIGRhdGE6IHNlbGVjdGVkVGV4dCB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgY3VycmVudCBtZW51IHdpdGggc3VibWVudSBvcHRpb25zXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xuICAgICAgICAgICAgICAgICAgICBzdWJtZW51SXRlbXMuZm9yRWFjaChpdGVtID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lbnVJdGVtID0gdGhpcy5jcmVhdGVNZW51SXRlbShpdGVtLmxhYmVsLCBpdGVtLmFjdGlvbklkLCBpdGVtLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQobWVudUl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGJhY2sgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJhY2tCdXR0b24gPSB0aGlzLmNyZWF0ZU1lbnVJdGVtKCdCYWNrJywgJ25hdmlnYXRlLWJhY2snKTtcbiAgICAgICAgICAgICAgICAgICAgYmFja0J1dHRvbi5zdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkIHZhcigtLWpwLWJvcmRlci1jb2xvcjEpJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuYXBwZW5kQ2hpbGQoYmFja0J1dHRvbik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjsgLy8gRG9uJ3QgaGlkZSBtZW51LCB3YWl0IGZvciBzdWJtZW51IHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbENvbnRlbnQgPSB0aGlzLmNhbGxiYWNrcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQgPyB0aGlzLmNhbGxiYWNrcy5nZXRDdXJyZW50Q2VsbENvbnRlbnQoKSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShjZWxsQ29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdpbnNlcnQtcGxhaW4tY29kZSc6IHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2RlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjb2xsYXBzZS1jb2RlLXJlZic6IHtcbiAgICAgICAgICAgICAgICBpZiAocGF0aCAmJiB0aGlzLmN1cnJlbnROb3RlYm9vaykge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2V0IG5vdGVib29rIGZpbGUgbmFtZSAod2l0aG91dCBleHRlbnNpb24pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RlYm9va1BhdGggPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3RlYm9va05hbWUgPSAoKF9hID0gbm90ZWJvb2tQYXRoLnNwbGl0KCcvJykucG9wKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zcGxpdCgnLicpWzBdKSB8fCAnbm90ZWJvb2snO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmluZCBjdXJyZW50IGNlbGwgaW5kZXggYW5kIGFwcHJveGltYXRlIGxpbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbCA9IHRoaXMuY3VycmVudE5vdGVib29rLmNvbnRlbnQuYWN0aXZlQ2VsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY3VycmVudENlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGFjdGl2ZSBjZWxsIGZvdW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgY3VycmVudCBjZWxsIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50Q2VsbEluZGV4ID0gdGhpcy5jdXJyZW50Tm90ZWJvb2suY29udGVudC5hY3RpdmVDZWxsSW5kZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBFc3RpbWF0ZSBsaW5lIG51bWJlciBmcm9tIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAxOyAvLyBEZWZhdWx0IHRvIGxpbmUgMVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRDZWxsLmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IGN1cnJlbnRDZWxsLmVkaXRvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBjdXJzb3IubGluZSArIDE7IC8vIENvbnZlcnQgdG8gMS1pbmRleGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW52b2tlIHRoZSBjYWxsYmFjayB3aXRoIGFsbCB0aGUgaW5mb3JtYXRpb24gbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnRDb2xsYXBzZWRDb2RlUmVmKHBhdGgsIGN1cnJlbnRDZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGNvbGxhcHNlZCBjb2RlIHJlZmVyZW5jZTonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayB0byBpbnNlcnRpbmcgY29kZSBkaXJlY3RseVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q29kZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiBzb21ldGhpbmcgd2VudCB3cm9uZyBvciBubyBwYXRoIHByb3ZpZGVkLCBqdXN0IGluc2VydCBhcyByZWd1bGFyIGNvZGVcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmluc2VydENvZGUocGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWNlbGxzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnY2VsbHMnLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWZpbGVzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnZmlsZXMnLCB0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgc2VhcmNoIHdoZW4gY2hhbmdpbmcgdmlldyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnYnJvd3NlLWRpcmVjdG9yaWVzJzpcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudSgnZGlyZWN0b3JpZXMnLCB0aGlzLmN1cnJlbnRNZW51UGF0aCB8fCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgc2VhcmNoIHdoZW4gY2hhbmdpbmcgdmlldyB0eXBlXG4gICAgICAgICAgICAgICAgdGhpcy5zZWFyY2hJbnB1dC52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnc2VsZWN0LWNlbGwnOlxuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxJbmRleCA9IHBhcnNlSW50KHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzTmFOKGNlbGxJbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgcmVmZXJlbmNlIHRleHQgKGUuZy4sIFwiQENlbGwgM1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcmVmVGV4dCA9IGBAQ2VsbCAke2NlbGxJbmRleCArIDF9YDsgLy8gVXNlIDEtYmFzZWQgaW5kZXggZm9yIGRpc3BsYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKFwiVE9ETzogSW1wbGVtZW50IGNlbGwgcmVmZXJlbmNlIGluc2VydGlvbjogXCIsIHJlZlRleHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0Q2VsbEJ5SW5kZXgoY2VsbEluZGV4KTsgLy8gQ2FsbCB0aGUgYXBwcm9wcmlhdGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEludmFsaWQgY2VsbCBpbmRleC4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IENlbGwgc2VsZWN0ZWQgYnV0IGluZGV4IChwYXRoKSBpcyBtaXNzaW5nLicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbGVjdC1maWxlJzpcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHJlZmVyZW5jZSB0ZXh0IChlLmcuLCBcIkBmaWxlIHBhdGgvdG8vZmlsZS5weVwiKVxuICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCByZWZUZXh0ID0gYEBmaWxlICR7cGF0aH1gO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRPRE86IEltcGxlbWVudCBmaWxlIHJlZmVyZW5jZSBpbnNlcnRpb246IFwiLCByZWZUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaW5zZXJ0RmlsZVBhdGgocGF0aCk7IC8vIENhbGwgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignUE9QVVA6IEZpbGUgc2VsZWN0ZWQgYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LW5hdmlnYXRlJzogLy8gTmV3IGFjdGlvbiB0byBuYXZpZ2F0ZSBpbnRvIGRpciB3aGVuIGluIGZpbGUgdmlld1xuICAgICAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBmaWxlIGNhY2hlIGZvciB0aGUgc3BlY2lmaWMgZGlyZWN0b3J5IHRvIGZvcmNlIGEgcmVmcmVzaFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYWNoZUtleSA9IGAke3BhdGh9OiR7dGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSd9YDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWxlQ2FjaGUuZGVsZXRlKGNhY2hlS2V5KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHdlJ3JlIHBhc3NpbmcgdGhlIGNvcnJlY3QgbGV2ZWwgdHlwZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZXZlbCA9ICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdmaWxlcycgfHwgdGhpcy5jdXJyZW50TWVudUxldmVsID09PSAnZGlyZWN0b3JpZXMnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgOiAnZmlsZXMnO1xuICAgICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLm5hdmlnYXRlTWVudShsZXZlbCwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gQ2xlYXIgc2VhcmNoIG9uIG5hdmlnYXRpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIG5hdmlnYXRpb24gYnV0IHBhdGggaXMgbWlzc2luZy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdzZWxlY3QtZGlyZWN0b3J5LWNhbGxiYWNrJzogLy8gTmV3IGFjdGlvbiB0byBzZWxlY3QgZGlyIHdoZW4gaW4gZGlyZWN0b3J5IHZpZXdcbiAgICAgICAgICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgdGhlIHJlZmVyZW5jZSB0ZXh0IChlLmcuLCBcIkBkaXIgcGF0aC90by9kaXJlY3RvcnlcIilcbiAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgcmVmVGV4dCA9IGBAZGlyICR7cGF0aH1gO1xuICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIlRPRE86IEltcGxlbWVudCBkaXJlY3RvcnkgcmVmZXJlbmNlIGluc2VydGlvbjogXCIsIHJlZlRleHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5pbnNlcnREaXJlY3RvcnlQYXRoKHBhdGgpOyAvLyBDYWxsIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BPUFVQOiBEaXJlY3Rvcnkgc2VsZWN0ZWQgZm9yIGNhbGxiYWNrIGJ1dCBwYXRoIGlzIG1pc3NpbmcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAncGxhY2Vob2xkZXItYWN0aW9uJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUGxhY2Vob2xkZXIgYWN0aW9uIHRyaWdnZXJlZC4nKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xvYWRpbmcnOlxuICAgICAgICAgICAgY2FzZSAnZW1wdHknOlxuICAgICAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Vua25vd24gbWVudSBhY3Rpb246JywgYWN0aW9uSWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICBhc3luYyBuYXZpZ2F0ZU1lbnUobGV2ZWwsIHBhdGgpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBOYXZpZ2F0aW5nIHRvIGxldmVsOiAke2xldmVsfSwgcGF0aDogJHtwYXRofWApO1xuICAgICAgICAvLyBPbmx5IHB1c2ggaGlzdG9yeSBpZiB3ZSBhcmUgYWN0dWFsbHkgbW92aW5nIHRvIGEgbmV3IHN0YXRlXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRNZW51TGV2ZWwgIT09IGxldmVsIHx8IHRoaXMuY3VycmVudE1lbnVQYXRoICE9PSBwYXRoKSB7XG4gICAgICAgICAgICB0aGlzLm1lbnVIaXN0b3J5LnB1c2goeyBsZXZlbDogdGhpcy5jdXJyZW50TWVudUxldmVsLCBwYXRoOiB0aGlzLmN1cnJlbnRNZW51UGF0aCB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBwYXRoO1xuICAgICAgICAvLyBEb24ndCBjbGVhciBzZWFyY2ggb24gcHJvZ3JhbW1hdGljIG5hdmlnYXRpb24gKGxpa2UgYmFjayBidXR0b24pXG4gICAgICAgIC8vIHRoaXMuc2VhcmNoSW5wdXQudmFsdWUgPSAnJzsgLy8gTWF5YmUga2VlcCBzZWFyY2ggdGVybT9cbiAgICAgICAgYXdhaXQgdGhpcy5yZW5kZXJNZW51Q29udGVudCgpO1xuICAgICAgICAvLyBGb2N1cyBzZWFyY2ggaW5wdXQgYWZ0ZXIgbmF2aWdhdGluZyB0byBmaWxlL2RpciB2aWV3XG4gICAgICAgIGlmIChsZXZlbCA9PT0gJ2ZpbGVzJyB8fCBsZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCksIDApO1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTsgLy8gUmVzZXQgc2VsZWN0aW9uXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTZWxlY3QgZmlyc3QgaXRlbSBpZiBuYXZpZ2F0aW5nIGJhY2sgdG8gdG9wIGxldmVsXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xO1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlbGVjdE5leHRNZW51SXRlbSgpLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBuYXZpZ2F0ZUJhY2tNZW51KCkge1xuICAgICAgICBjb25zdCBwcmV2aW91c1N0YXRlID0gdGhpcy5tZW51SGlzdG9yeS5wb3AoKTtcbiAgICAgICAgaWYgKHByZXZpb3VzU3RhdGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogTmF2aWdhdGluZyBiYWNrIHRvIGxldmVsOiAke3ByZXZpb3VzU3RhdGUubGV2ZWx9LCBwYXRoOiAke3ByZXZpb3VzU3RhdGUucGF0aH1gKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVMZXZlbCA9IHByZXZpb3VzU3RhdGUubGV2ZWw7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRNZW51UGF0aCA9IHByZXZpb3VzU3RhdGUucGF0aDtcbiAgICAgICAgICAgIC8vIERvbid0IGNsZWFyIHNlYXJjaCBvbiBiYWNrIG5hdmlnYXRpb25cbiAgICAgICAgICAgIHRoaXMucmVuZGVyTWVudUNvbnRlbnQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBGb2N1cyBzZWFyY2ggaW5wdXQgaWYgZ29pbmcgYmFjayB0byBmaWxlL2RpciB2aWV3XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2ZpbGVzJyB8fCB0aGlzLmN1cnJlbnRNZW51TGV2ZWwgPT09ICdkaXJlY3RvcmllcycpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLnNlYXJjaElucHV0LmZvY3VzKCksIDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IC0xOyAvLyBSZXNldCBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbGVjdCBmaXJzdCBpdGVtIGlmIGdvaW5nIGJhY2sgdG8gdG9wIGxldmVsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gLTE7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKSwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEFscmVhZHkgYXQgdGhlIHRvcCBsZXZlbC4nKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGxpc3RDdXJyZW50RGlyZWN0b3J5Q29udGVudHMoYmFzZVBhdGgsIGZpbHRlclR5cGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBMaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50cyBmb3IgcGF0aDogJyR7YmFzZVBhdGh9JywgZmlsdGVyOiAke2ZpbHRlclR5cGUgfHwgJ2FsbCd9YCk7XG4gICAgICAgIC8vIENoZWNrIGNhY2hlIGZpcnN0XG4gICAgICAgIGNvbnN0IGNhY2hlS2V5ID0gYCR7YmFzZVBhdGh9OiR7ZmlsdGVyVHlwZSB8fCAnYWxsJ31gO1xuICAgICAgICBpZiAodGhpcy5maWxlQ2FjaGUuaGFzKGNhY2hlS2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBVc2luZyBjYWNoZWQgZGlyZWN0b3J5IGNvbnRlbnRzJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5maWxlQ2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBlZmZlY3RpdmVQYXRoID0gYmFzZVBhdGggPT09ICcvJyA/ICcnIDogYmFzZVBhdGg7XG4gICAgICAgICAgICAvLyBFbnN1cmUgdHJhaWxpbmcgc2xhc2ggcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgdW5sZXNzIGl0J3Mgcm9vdFxuICAgICAgICAgICAgY29uc3QgcGF0aEZvckFwaSA9IGVmZmVjdGl2ZVBhdGguZW5kc1dpdGgoJy8nKSAmJiBlZmZlY3RpdmVQYXRoLmxlbmd0aCA+IDEgPyBlZmZlY3RpdmVQYXRoLnNsaWNlKDAsIC0xKSA6IGVmZmVjdGl2ZVBhdGg7XG4gICAgICAgICAgICAvLyBSZXN1bHQgYXJyYXkgdGhhdCB3aWxsIGhvbGQgYWxsIGZpbGVzIGFuZCBkaXJlY3Rvcmllc1xuICAgICAgICAgICAgbGV0IGFsbFJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgYmFzZSBkaXJlY3RvcnkgY29udGVudHMgKG5vbi1yZWN1cnNpdmUpXG4gICAgICAgICAgICBjb25zdCBiYXNlQ29udGVudHMgPSBhd2FpdCB0aGlzLmRvY01hbmFnZXIuc2VydmljZXMuY29udGVudHMuZ2V0KHBhdGhGb3JBcGkgfHwgJycpO1xuICAgICAgICAgICAgaWYgKGJhc2VDb250ZW50cy50eXBlICE9PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1BhdGggaXMgbm90IGEgZGlyZWN0b3J5OicsIGJhc2VQYXRoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgYmFzZSBkaXJlY3RvcnkgaXRlbXNcbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBiYXNlQ29udGVudHMuY29udGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1UeXBlID0gaXRlbS50eXBlID09PSAnZGlyZWN0b3J5JyA/ICdkaXJlY3RvcnknIDogJ2ZpbGUnO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBkaXJlY3RvcmllcyBpZiB3ZSdyZSBsaXN0aW5nIGRpcmVjdG9yaWVzIG9yIGJvdGhcbiAgICAgICAgICAgICAgICBpZiAoaXRlbVR5cGUgPT09ICdkaXJlY3RvcnknICYmIChmaWx0ZXJUeXBlID09PSAnZGlyZWN0b3J5JyB8fCBmaWx0ZXJUeXBlID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbFJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiBpdGVtLnBhdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZGlyZWN0b3J5JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGF0aDogYC4vJHtpdGVtLm5hbWV9YFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIGZpbGVzIGlmIHdlJ3JlIGxpc3RpbmcgZmlsZXMgYW5kIHRoZSBleHRlbnNpb24gaXMgYWxsb3dlZFxuICAgICAgICAgICAgICAgIGlmIChpdGVtVHlwZSA9PT0gJ2ZpbGUnICYmIChmaWx0ZXJUeXBlID09PSAnZmlsZScgfHwgZmlsdGVyVHlwZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWxlRXh0ID0gYC4ke2l0ZW0ubmFtZS5zcGxpdCgnLicpLnBvcCgpfWAudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dlZEV4dGVuc2lvbnMuaW5jbHVkZXMoZmlsZUV4dCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbFJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogaXRlbS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGl0ZW0ucGF0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZmlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmVQYXRoOiBgLi8ke2l0ZW0ubmFtZX1gXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNvcnQgdGhlIHJlc3VsdHMgYXBwcm9wcmlhdGVseVxuICAgICAgICAgICAgYWxsUmVzdWx0cyA9IGFsbFJlc3VsdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgICAgIC8vIElmIGxpc3RpbmcgZGlyZWN0b3JpZXMgb25seSwgc29ydCBhbHBoYWJldGljYWxseVxuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJUeXBlID09PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgbGlzdGluZyBmaWxlcyBvbmx5LCBzb3J0IGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlclR5cGUgPT09ICdmaWxlJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSWYgbGlzdGluZyBib3RoLCBzb3J0IGRpcmVjdG9yaWVzIGZpcnN0LCB0aGVuIGZpbGVzIGFscGhhYmV0aWNhbGx5XG4gICAgICAgICAgICAgICAgaWYgKGEudHlwZSA9PT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlICE9PSAnZGlyZWN0b3J5JylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgICAgIGlmIChhLnR5cGUgIT09ICdkaXJlY3RvcnknICYmIGIudHlwZSA9PT0gJ2RpcmVjdG9yeScpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBDYWNoZSB0aGUgcmVzdWx0cyBmb3IgZnV0dXJlIHVzZVxuICAgICAgICAgICAgdGhpcy5maWxlQ2FjaGUuc2V0KGNhY2hlS2V5LCBhbGxSZXN1bHRzKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogRm91bmQgJHthbGxSZXN1bHRzLmxlbmd0aH0gaXRlbXMgZm9yIHBhdGggJyR7YmFzZVBhdGh9J2ApO1xuICAgICAgICAgICAgcmV0dXJuIGFsbFJlc3VsdHM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBQT1BVUDogRXJyb3IgbGlzdGluZyBkaXJlY3RvcnkgY29udGVudHMgZm9yICcke2Jhc2VQYXRofSc6YCwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgc2V0Q3VycmVudERpcmVjdG9yeVBhdGgoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGRpclBhdGggPSBudWxsO1xuICAgICAgICBjb25zdCBhcHAgPSBnbG9iYWxzXzEuZ2xvYmFscy5hcHA7XG4gICAgICAgIGlmICghYXBwKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdQT1BVUDogQXBwbGljYXRpb24gcmVmZXJlbmNlIG5vdCBhdmFpbGFibGUnKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudE1lbnVQYXRoID0gJyc7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFNoZWxsV2lkZ2V0ID0gYXBwLnNoZWxsLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgIGlmIChjdXJyZW50U2hlbGxXaWRnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldENvbnRleHQgPSB0aGlzLmRvY01hbmFnZXIuY29udGV4dEZvcldpZGdldChjdXJyZW50U2hlbGxXaWRnZXQpO1xuICAgICAgICAgICAgaWYgKHdpZGdldENvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoID0gd2lkZ2V0Q29udGV4dC5wYXRoO1xuICAgICAgICAgICAgICAgIGRpclBhdGggPSB0aGlzLmdldFBhcmVudERpcmVjdG9yeShwYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBhdGggZnJvbSBjdXJyZW50IHdpZGdldCBjb250ZXh0OiAke3BhdGh9IC0+ICR7ZGlyUGF0aH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZGlyUGF0aCA9PT0gbnVsbCAmJiB0aGlzLmN1cnJlbnROb3RlYm9vayAmJiB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBub3RlYm9va1BhdGggPSB0aGlzLmN1cnJlbnROb3RlYm9vay5jb250ZXh0LnBhdGg7XG4gICAgICAgICAgICBpZiAodHlwZW9mIG5vdGVib29rUGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBkaXJQYXRoID0gdGhpcy5nZXRQYXJlbnREaXJlY3Rvcnkobm90ZWJvb2tQYXRoKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFBhdGggZnJvbSBhY3RpdmUgbm90ZWJvb2s6ICR7bm90ZWJvb2tQYXRofSAtPiAke2RpclBhdGh9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVmdFdpZGdldHMgPSBBcnJheS5mcm9tKGFwcC5zaGVsbC53aWRnZXRzKCdsZWZ0JykpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVCcm93c2VyV2lkZ2V0ID0gbGVmdFdpZGdldHMuZmluZCh3aWRnZXQgPT4gd2lkZ2V0LmlkID09PSAnZmlsZWJyb3dzZXInKTtcbiAgICAgICAgICAgICAgICBpZiAoZmlsZUJyb3dzZXJXaWRnZXQgJiYgdHlwZW9mICgoX2EgPSBmaWxlQnJvd3NlcldpZGdldC5tb2RlbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdGgpID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBkaXJQYXRoID0gZmlsZUJyb3dzZXJXaWRnZXQubW9kZWwucGF0aDtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFBPUFVQOiBQYXRoIGZyb20gZmlsZSBicm93c2VyIHdpZGdldCBtb2RlbDogJHtkaXJQYXRofWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBGaWxlIGJyb3dzZXIgd2lkZ2V0IHBhdGggbm90IGRpcmVjdGx5IGFjY2Vzc2libGUuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BPUFVQOiBDb3VsZCBub3QgZ2V0IHBhdGggZnJvbSBmaWxlIGJyb3dzZXIuJywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRpclBhdGggPT09IG51bGwpIHtcbiAgICAgICAgICAgIGRpclBhdGggPSAnJztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogRmFsbGluZyBiYWNrIHRvIHNlcnZlciByb290IHBhdGguJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50TWVudVBhdGggPSBkaXJQYXRoO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IEluaXRpYWwgY3VycmVudCBtZW51IHBhdGggc2V0IHRvOiAnJHt0aGlzLmN1cnJlbnRNZW51UGF0aH0nYCk7XG4gICAgfVxuICAgIGdldFBhcmVudERpcmVjdG9yeShwYXRoKSB7XG4gICAgICAgIGlmICghcGF0aClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY29uc3QgbGFzdFNsYXNoID0gTWF0aC5tYXgocGF0aC5sYXN0SW5kZXhPZignLycpLCBwYXRoLmxhc3RJbmRleE9mKCdcXFxcJykpO1xuICAgICAgICBpZiAobGFzdFNsYXNoID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnJzsgLy8gTm8gZGlyZWN0b3J5IHBhcnQsIGxpa2VseSByb290IG9yIGp1c3QgYSBmaWxlbmFtZVxuICAgICAgICByZXR1cm4gcGF0aC5zdWJzdHJpbmcoMCwgbGFzdFNsYXNoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGtleWJvYXJkIG5hdmlnYXRpb24gd2hlbiB0aGUgcG9wdXAgbWVudSBpcyBzaG93blxuICAgICAqL1xuICAgIGhhbmRsZUtleURvd24oZXZlbnQpIHtcbiAgICAgICAgLy8gT25seSBoYW5kbGUga2V5cyBpZiB0aGUgcG9wdXAgaXMgdmlzaWJsZVxuICAgICAgICBpZiAoIXRoaXMuaXNQb3B1cE1lbnVWaXNpYmxlKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVAgRG9jdW1lbnQgS2V5RG93bjogS2V5PScke2V2ZW50LmtleX0nLCBUYXJnZXQ9YCwgZXZlbnQudGFyZ2V0KTtcbiAgICAgICAgLy8gQWxsb3cgZGVmYXVsdCBicm93c2VyIHNlYXJjaCBiZWhhdmlvciAoZS5nLiwgQ21kK0YpXG4gICAgICAgIGlmIChldmVudC5tZXRhS2V5IHx8IGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBmb2N1cyBpcyBpbnNpZGUgdGhlIHNlYXJjaCBpbnB1dCwgbGV0IGl0cyBoYW5kbGVyIG1hbmFnZSBuYXZpZ2F0aW9uIGtleXNcbiAgICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5zZWFyY2hJbnB1dCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQIChEb2N1bWVudCk6IEtleSBldmVudCB0YXJnZXQgaXMgc2VhcmNoIGlucHV0LCBza2lwcGluZyBkb2N1bWVudCBoYW5kbGVyLicpO1xuICAgICAgICAgICAgLy8gQWxsb3cgQmFja3NwYWNlIGV0Yy4gdG8gd29yayBuYXR1cmFsbHkgaW4gc2VhcmNoIGlucHV0XG4gICAgICAgICAgICBpZiAoWydBcnJvd1VwJywgJ0Fycm93RG93bicsICdFbnRlcicsICdUYWInLCAnRXNjYXBlJ10uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgICAgIC8vIExldCB0aGUgc2VhcmNoIGlucHV0J3Mga2V5ZG93biBoYW5kbGUgRXNjYXBlLCBzdG9wIHByb3BhZ2F0aW9uXG4gICAgICAgICAgICAgICAgLy8gQnV0IGxldCB0aGUgbWFpbiBoYW5kbGVyIHByb2Nlc3MgVXAvRG93bi9FbnRlci9UYWIgYnkgYmx1cnJpbmdcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnQXJyb3dVcCcgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcmlnZ2VyIGJsdXIgdG8gc2hpZnQgZm9jdXMgdG8gbWVudSBpdGVtc1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCBkZWZhdWx0IHNjcm9sbGluZyBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIHRoZSBrZXkgZXZlbnQgbm93IGluIHRoZSBtZW51IGNvbnRleHRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzTWVudU5hdmlnYXRpb24oZXZlbnQua2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZXZlbnQua2V5ID09PSAnRW50ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VhcmNoSW5wdXQuYmx1cigpO1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb2Nlc3NNZW51TmF2aWdhdGlvbihldmVudC5rZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdUYWInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRhYmJpbmcgYXdheSAob3IgbWF5YmUgY3ljbGUgZm9jdXM/KVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlYXJjaElucHV0LmJsdXIoKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG9uJ3QgcHJldmVudCBkZWZhdWx0IC0gYWxsb3cgdGFiYmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09ICdFc2NhcGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEFscmVhZHkgaGFuZGxlZCBieSBzZWFyY2hJbnB1dCdzIGxpc3RlbmVyLCBqdXN0IHN0b3AgcHJvcGFnYXRpb25cbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gQWxsb3cgb3RoZXIga2V5cyAodHlwaW5nKSBpbiB0aGUgc2VhcmNoIGlucHV0XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRm9jdXMgaXMgTk9UIGluIHRoZSBzZWFyY2ggaW5wdXQsIHByb2Nlc3Mgbm9ybWFsbHlcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc01lbnVOYXZpZ2F0aW9uKGV2ZW50LmtleSk7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IGRlZmF1bHQgYnJvd3NlciBhY3Rpb25zIGZvciB0aGVzZSBrZXlzIHdoZW4gbWVudSBpcyBhY3RpdmVcbiAgICAgICAgICAgIGlmIChbJ0Fycm93VXAnLCAnQXJyb3dEb3duJywgJ0VudGVyJywgJ1RhYicsICdFc2NhcGUnXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwcm9jZXNzTWVudU5hdmlnYXRpb24oa2V5KSB7XG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQXJyb3cgRG93biBwcmVzc2VkJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3ROZXh0TWVudUl0ZW0oKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0Fycm93VXAnOlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQT1BVUDogQXJyb3cgVXAgcHJlc3NlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0UHJldmlvdXNNZW51SXRlbSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRW50ZXInOlxuICAgICAgICAgICAgY2FzZSAnVGFiJzogLy8gVHJlYXQgVGFiIGxpa2UgRW50ZXIgZm9yIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogJHtrZXl9IHByZXNzZWRgKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVudUl0ZW1zW3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBTaW11bGF0aW5nIGNsaWNrIG9uIHNlbGVjdGVkIGl0ZW06JywgbWVudUl0ZW1zW3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4XS50ZXh0Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW11bGF0ZSBjbGljayB0byB0cmlnZ2VyIGhhbmRsZU1lbnVDbGlja1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW1zW3RoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4XS5jbGljaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1BPUFVQOiBTZWxlY3RlZCBpbmRleCBvdXQgb2YgYm91bmRzPycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEVudGVyL1RhYiBwcmVzc2VkIGJ1dCBubyBpdGVtIHNlbGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIG5vIGl0ZW0gaXMgc2VsZWN0ZWQsIG1heWJlIHNlbGVjdCB0aGUgZmlyc3Qgb25lIGFuZCBhY3RpdmF0ZT9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVudUl0ZW1zID0gdGhpcy5nZXRNZW51SXRlbXMoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbnVJdGVtcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZW51SXRlbXNbMF0uY2xpY2soKTsgLy8gQWN0aXZhdGUgZmlyc3QgaXRlbVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRXNjYXBlJzpcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUE9QVVA6IEVzY2FwZSBwcmVzc2VkJyk7XG4gICAgICAgICAgICAgICAgLy8gSWYgaW4gYSBzdWJtZW51LCBuYXZpZ2F0ZSBiYWNrOyBvdGhlcndpc2UsIGhpZGUuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMubWVudUhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5hdmlnYXRlQmFja01lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVTZWxlY3Rpb25IaWdobGlnaHQoKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY2xhc3NMaXN0LmFkZCgnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0tc2VsZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAvLyBTY3JvbGwgaW50byB2aWV3IGlmIG5lY2Vzc2FyeVxuICAgICAgICAgICAgICAgIGl0ZW0uc2Nyb2xsSW50b1ZpZXcoeyBibG9jazogJ25lYXJlc3QnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbS1zZWxlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGVzZWxlY3RBbGxNZW51SXRlbXMoKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIG1lbnVJdGVtcy5mb3JFYWNoKGl0ZW0gPT4ge1xuICAgICAgICAgICAgaXRlbS5jbGFzc0xpc3QucmVtb3ZlKCdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbS1zZWxlY3RlZCcpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPSAtMTtcbiAgICB9XG4gICAgc2VsZWN0TmV4dE1lbnVJdGVtKCkge1xuICAgICAgICBjb25zdCBtZW51SXRlbXMgPSB0aGlzLmdldE1lbnVJdGVtcygpO1xuICAgICAgICBpZiAobWVudUl0ZW1zLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXgrKztcbiAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID49IG1lbnVJdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRNZW51SXRlbUluZGV4ID0gMDsgLy8gV3JhcCBhcm91bmRcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnVwZGF0ZVNlbGVjdGlvbkhpZ2hsaWdodCgpO1xuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNlbGVjdGVkIGl0ZW0gaW5kZXg6ICR7dGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXh9YCk7XG4gICAgfVxuICAgIHNlbGVjdFByZXZpb3VzTWVudUl0ZW0oKSB7XG4gICAgICAgIGNvbnN0IG1lbnVJdGVtcyA9IHRoaXMuZ2V0TWVudUl0ZW1zKCk7XG4gICAgICAgIGlmIChtZW51SXRlbXMubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleC0tO1xuICAgICAgICBpZiAodGhpcy5zZWxlY3RlZE1lbnVJdGVtSW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleCA9IG1lbnVJdGVtcy5sZW5ndGggLSAxOyAvLyBXcmFwIGFyb3VuZFxuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlU2VsZWN0aW9uSGlnaGxpZ2h0KCk7XG4gICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogU2VsZWN0ZWQgaXRlbSBpbmRleDogJHt0aGlzLnNlbGVjdGVkTWVudUl0ZW1JbmRleH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGFsbCBpbnRlcmFjdGl2ZSBtZW51IGl0ZW1zIGN1cnJlbnRseSBkaXNwbGF5ZWRcbiAgICAgKi9cbiAgICBnZXRNZW51SXRlbXMoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnF1ZXJ5U2VsZWN0b3JBbGwoJy5qcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbScpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvcHVwIG1lbnUgYmFzZWQgb24gdGhlIGFjdGl2ZSByZWZlcmVuY2UgcmFuZ2VcbiAgICAgKiBvciB0aGUgaW5pdGlhbCBhbmNob3IgcG9pbnQuIFRyaWVzIHRvIHBvc2l0aW9uIHRoZSBCT1RUT00gb2YgdGhlIG1lbnVcbiAgICAgKiBqdXN0IEFCT1ZFIHRoZSByYW5nZS9hbmNob3IuXG4gICAgICovXG4gICAgdXBkYXRlUG9wdXBQb3NpdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLndpZGdldE5vZGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHdpZGdldFJlY3QgPSB0aGlzLndpZGdldE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGxldCB0YXJnZXRUb3A7XG4gICAgICAgIGxldCB0YXJnZXRMZWZ0O1xuICAgICAgICAvLyBVc2UgdGhlIGFuY2hvciBjb29yZGluYXRlcyBwcm92aWRlZCAobm93IGZyb20gdGhlIHJlbGlhYmxlIHRlbXAgc3BhbilcbiAgICAgICAgaWYgKHRoaXMuX2FuY2hvclggIT09IHVuZGVmaW5lZCAmJiB0aGlzLl9hbmNob3JZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBQT1BVUDogUG9zaXRpb25pbmcgYmFzZWQgb24gYW5jaG9yIHBvaW50OiAoJHt0aGlzLl9hbmNob3JYfSwgJHt0aGlzLl9hbmNob3JZfSlgKTtcbiAgICAgICAgICAgIC8vIFRhcmdldCBwb3NpdGlvbiByZWxhdGl2ZSB0byB2aWV3cG9ydFxuICAgICAgICAgICAgdGFyZ2V0VG9wID0gdGhpcy5fYW5jaG9yWTtcbiAgICAgICAgICAgIHRhcmdldExlZnQgPSB0aGlzLl9hbmNob3JYO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiUE9QVVA6IENhbm5vdCB1cGRhdGUgcG9zaXRpb24gLSBubyBhbmNob3IgcG9pbnQgcHJvdmlkZWQuXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgcG9wdXAgaXMgdmlzaWJsZSBhbmQgcmVuZGVyZWQgdG8gZ2V0IGl0cyBoZWlnaHRcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nOyAvLyBLZWVwIGl0IGhpZGRlbiB3aGlsZSBjYWxjdWxhdGluZ1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgY29uc3QgcG9wdXBIZWlnaHQgPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5vZmZzZXRIZWlnaHQ7XG4gICAgICAgIGNvbnN0IHBvcHVwV2lkdGggPSB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5vZmZzZXRXaWR0aDtcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRlc2lyZWQgJ3RvcCcgc3R5bGUgcmVsYXRpdmUgdG8gdGhlIHdpZGdldE5vZGVcbiAgICAgICAgLy8gUG9zaXRpb24gdGhlIGJvdHRvbSBvZiB0aGUgcG9wdXAganVzdCBhYm92ZSB0aGUgdGFyZ2V0J3MgdG9wXG4gICAgICAgIGxldCB0b3AgPSAodGFyZ2V0VG9wIC0gd2lkZ2V0UmVjdC50b3ApIC0gcG9wdXBIZWlnaHQ7XG4gICAgICAgIC8vIENhbGN1bGF0ZSBkZXNpcmVkICdsZWZ0JyBzdHlsZSByZWxhdGl2ZSB0byB0aGUgd2lkZ2V0Tm9kZVxuICAgICAgICBsZXQgbGVmdCA9IHRhcmdldExlZnQgLSB3aWRnZXRSZWN0LmxlZnQ7XG4gICAgICAgIC8vIC0tLSBCb3VuZGFyeSBjaGVja3MgKHJlbGF0aXZlIHRvIHdpZGdldCkgLS0tXG4gICAgICAgIGNvbnN0IHdpZGdldENsaWVudFdpZHRoID0gdGhpcy53aWRnZXROb2RlLmNsaWVudFdpZHRoOyAvLyBVc2UgY2xpZW50V2lkdGggZm9yIGlubmVyIHdpZHRoXG4gICAgICAgIGNvbnN0IHdpZGdldENsaWVudEhlaWdodCA9IHRoaXMud2lkZ2V0Tm9kZS5jbGllbnRIZWlnaHQ7XG4gICAgICAgIC8vIFByZXZlbnQgZ29pbmcgb2ZmIHRoZSBsZWZ0IGVkZ2Ugb2YgdGhlIHdpZGdldFxuICAgICAgICBpZiAobGVmdCA8IDApIHtcbiAgICAgICAgICAgIGxlZnQgPSA1OyAvLyBTbWFsbCBwYWRkaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBPUFVQIEFkanVzdDogQ29ycmVjdGVkIGxlZnQgZWRnZVwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQcmV2ZW50IGdvaW5nIG9mZiB0aGUgcmlnaHQgZWRnZSBvZiB0aGUgd2lkZ2V0XG4gICAgICAgIGlmIChsZWZ0ICsgcG9wdXBXaWR0aCA+IHdpZGdldENsaWVudFdpZHRoKSB7XG4gICAgICAgICAgICBsZWZ0ID0gd2lkZ2V0Q2xpZW50V2lkdGggLSBwb3B1cFdpZHRoIC0gNTsgLy8gQWRqdXN0IGxlZnQsIGFkZCBwYWRkaW5nXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBPUFVQIEFkanVzdDogQ29ycmVjdGVkIHJpZ2h0IGVkZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCBnb2luZyBvZmYgdGhlIHRvcCBlZGdlIG9mIHRoZSB3aWRnZXRcbiAgICAgICAgaWYgKHRvcCA8IDApIHtcbiAgICAgICAgICAgIC8vIElmIGl0IGdvZXMgb2ZmIHRoZSB0b3AsIHRyeSBwb3NpdGlvbmluZyBpdCAqYmVsb3cqIHRoZSB0YXJnZXQgaW5zdGVhZFxuICAgICAgICAgICAgY29uc3Qgc3BhY2VCZWxvdyA9IHdpZGdldENsaWVudEhlaWdodCAtICh0YXJnZXRUb3AgLSB3aWRnZXRSZWN0LnRvcCArIDEwKTsgLy8gU3BhY2UgYmVsb3cgdGFyZ2V0XG4gICAgICAgICAgICBpZiAoc3BhY2VCZWxvdyA+PSBwb3B1cEhlaWdodCkge1xuICAgICAgICAgICAgICAgIHRvcCA9ICh0YXJnZXRUb3AgLSB3aWRnZXRSZWN0LnRvcCkgKyAxMDsgLy8gUG9zaXRpb24gYmVsb3cgdGFyZ2V0IHdpdGggcGFkZGluZ1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUE9QVVAgQWRqdXN0OiBGbGlwcGluZyBiZWxvdyB0YXJnZXQgKHdhcyBvZmYgdG9wKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdCBlbm91Z2ggc3BhY2UgYmVsb3cgZWl0aGVyLCBjbGFtcCB0byB0b3BcbiAgICAgICAgICAgICAgICB0b3AgPSA1OyAvLyBTbWFsbCBwYWRkaW5nIGZyb20gdG9wXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJQT1BVUCBBZGp1c3Q6IENsYW1wZWQgdG8gdG9wIGVkZ2UgKG5vIHNwYWNlIGJlbG93KVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLmxvZyhgUE9QVVA6IFNldHRpbmcgcG9zaXRpb24gLSBUb3A6ICR7dG9wfXB4LCBMZWZ0OiAke2xlZnR9cHggKFJlbGF0aXZlIHRvIFdpZGdldClgKTtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUudG9wID0gYCR7dG9wfXB4YDtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUubGVmdCA9IGAke2xlZnR9cHhgO1xuICAgICAgICAvLyBNYWtlIGl0IHZpc2libGUgYWdhaW5cbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgcG9wdXAgbWVudSBpcyBjdXJyZW50bHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc1BvcHVwTWVudVZpc2libGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ICE9PSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgbGV2ZWwgb2YgdGhlIHBvcHVwIG1lbnUuXG4gICAgICovXG4gICAgZ2V0Q3VycmVudE1lbnVMZXZlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudE1lbnVMZXZlbDtcbiAgICB9XG59XG5leHBvcnRzLlBvcHVwTWVudU1hbmFnZXIgPSBQb3B1cE1lbnVNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNldHRpbmdzSGFuZGxlciA9IHZvaWQgMDtcbi8qKlxuICogSGFuZGxlcyB0aGUgbG9naWMgcmVsYXRlZCB0byB0aGUgc2V0dGluZ3MgbW9kYWw6XG4gKiBkaXNwbGF5aW5nLCBoaWRpbmcsIHBvcHVsYXRpbmcsIHNhdmluZywgYW5kIHNob3dpbmcgZmVlZGJhY2suXG4gKi9cbmNsYXNzIFNldHRpbmdzSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUsIHNldHRpbmdzTW9kYWxDb250YWluZXIsIHVpTWFuYWdlciAvLyBQYXNzIFVJTWFuYWdlciBmb3Igbm90aWZpY2F0aW9uc1xuICAgICkge1xuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciA9IHNldHRpbmdzTW9kYWxDb250YWluZXI7XG4gICAgICAgIHRoaXMudWlNYW5hZ2VyID0gdWlNYW5hZ2VyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQb3B1bGF0ZXMgdGhlIHNldHRpbmdzIGZvcm0gd2l0aCBjdXJyZW50IHZhbHVlcyBhbmQgZGlzcGxheXMgdGhlIG1vZGFsLlxuICAgICAqL1xuICAgIHNob3dNb2RhbCgpIHtcbiAgICAgICAgY29uc3QgY3VycmVudFNldHRpbmdzID0gdGhpcy5zdGF0ZS5nZXRTZXR0aW5ncygpO1xuICAgICAgICBpZiAoY3VycmVudFNldHRpbmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIFF1ZXJ5IGVsZW1lbnRzIHdpdGhpbiB0aGUgbW9kYWwgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1wcm92aWRlcicpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLnByb3ZpZGVyO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLWtleScpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLmFwaUtleTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucXVlcnlTZWxlY3RvcignI3NldHRpbmdzLWFwaS11cmwnKS52YWx1ZSA9IGN1cnJlbnRTZXR0aW5ncy5hcGlVcmw7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1ydWxlcycpLnZhbHVlID0gY3VycmVudFNldHRpbmdzLnJ1bGVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcG9wdWxhdGluZyBzZXR0aW5ncyBmb3JtOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAvLyBPcHRpb25hbGx5IHNob3cgYW4gZXJyb3IgdG8gdGhlIHVzZXJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHNldHRpbmdzIG1vZGFsLlxuICAgICAqL1xuICAgIGhpZGVNb2RhbCgpIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlYWRzIHZhbHVlcyBmcm9tIHRoZSBmb3JtLCBzYXZlcyB0aGVtIHVzaW5nIFNldHRpbmdzU3RhdGUsXG4gICAgICogdXBkYXRlcyB0aGUgQXBpQ2xpZW50LCBoaWRlcyB0aGUgbW9kYWwsIGFuZCBzaG93cyBhIHN1Y2Nlc3Mgbm90aWZpY2F0aW9uLlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGludGVuZGVkIHRvIGJlIGNhbGxlZCBieSB0aGUgbW9kYWwncyBzYXZlIGJ1dHRvbiBsaXN0ZW5lci5cbiAgICAgKi9cbiAgICBzYXZlU2V0dGluZ3MoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgLy8gR2V0IHZhbHVlcyBmcm9tIGZvcm0gZmllbGRzIHdpdGhpbiB0aGUgbW9kYWwgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gKF9hID0gdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1wcm92aWRlcicpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWU7XG4gICAgICAgIGNvbnN0IGtleSA9IChfYiA9IHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLWtleScpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmFsdWU7XG4gICAgICAgIGNvbnN0IHVybCA9IChfYyA9IHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5xdWVyeVNlbGVjdG9yKCcjc2V0dGluZ3MtYXBpLXVybCcpKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MudmFsdWU7XG4gICAgICAgIGNvbnN0IHJ1bGVzID0gKF9kID0gdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnF1ZXJ5U2VsZWN0b3IoJyNzZXR0aW5ncy1ydWxlcycpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudmFsdWU7XG4gICAgICAgIC8vIEJhc2ljIHZhbGlkYXRpb25cbiAgICAgICAgaWYgKHByb3ZpZGVyID09PSB1bmRlZmluZWQgfHwga2V5ID09PSB1bmRlZmluZWQgfHwgdXJsID09PSB1bmRlZmluZWQgfHwgcnVsZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkNvdWxkIG5vdCBmaW5kIGFsbCBzZXR0aW5ncyBpbnB1dCBlbGVtZW50cy5cIik7XG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24oJ0Vycm9yOiBDb3VsZCBub3Qgc2F2ZSBzZXR0aW5ncy4gSW5wdXQgZWxlbWVudHMgbWlzc2luZy4nLCAnZXJyb3InKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHsgcHJvdmlkZXIsIGFwaUtleToga2V5LCBhcGlVcmw6IHVybCwgcnVsZXMgfTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFNhdmUgc2V0dGluZ3MgdXNpbmcgU2V0dGluZ3NTdGF0ZVxuICAgICAgICAgICAgdGhpcy5zdGF0ZS5zYXZlU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIHNhdmVkIHZpYSBTZXR0aW5nc1N0YXRlOicsIHNldHRpbmdzKTtcbiAgICAgICAgICAgIC8vIFJlY29uZmlndXJlIEFwaUNsaWVudCBpbnN0YW5jZVxuICAgICAgICAgICAgLy8gVE9ETzogVGhlIEFwaUNsaWVudCBzaG91bGQgaWRlYWxseSBvYnNlcnZlIHRoZSBTZXR0aW5nc1N0YXRlIFxuICAgICAgICAgICAgLy8gb3IgaGF2ZSBhIGRlZGljYXRlZCB1cGRhdGUgbWV0aG9kIGluc3RlYWQgb2YgY3JlYXRpbmcgYSBuZXcgaW5zdGFuY2UuXG4gICAgICAgICAgICAvLyBGb3Igbm93LCB3ZSBhc3N1bWUgdGhlIG1haW4gd2lkZ2V0IHdpbGwgcmVjcmVhdGUvdXBkYXRlIHRoZSBBcGlDbGllbnQgXG4gICAgICAgICAgICAvLyBvciBwYXNzIGFuIHVwZGF0ZSBjYWxsYmFjay5cbiAgICAgICAgICAgIC8vIEV4YW1wbGU6IHRoaXMuYXBpQ2xpZW50LnVwZGF0ZUNvbmZpZyhzZXR0aW5ncy5hcGlVcmwgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBUEkgQ2xpZW50IG5lZWRzIHJlY29uZmlndXJhdGlvbiB3aXRoIG5ldyBzZXR0aW5ncy4nKTtcbiAgICAgICAgICAgIHRoaXMuaGlkZU1vZGFsKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24oJ1NldHRpbmdzIHNhdmVkIHN1Y2Nlc3NmdWxseScsICdzdWNjZXNzJyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzYXZpbmcgc2V0dGluZ3M6JywgZXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5zaG93Tm90aWZpY2F0aW9uKGBFcnJvciBzYXZpbmcgc2V0dGluZ3M6ICR7ZXJyb3J9YCwgJ2Vycm9yJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYSB0ZW1wb3Jhcnkgbm90aWZpY2F0aW9uIG1lc3NhZ2UuXG4gICAgICogUmVsaWVzIG9uIFVJTWFuYWdlciB0byBwcm92aWRlIHRoZSBhY3R1YWwgbm90aWZpY2F0aW9uIG1lY2hhbmlzbS5cbiAgICAgKi9cbiAgICBzaG93Tm90aWZpY2F0aW9uKG1lc3NhZ2UsIHR5cGUpIHtcbiAgICAgICAgLy8gRGVsZWdhdGUgbm90aWZpY2F0aW9uIGRpc3BsYXkgdG8gVUlNYW5hZ2VyIG9yIGEgZGVkaWNhdGVkIG5vdGlmaWNhdGlvbiBzZXJ2aWNlXG4gICAgICAgIGlmICh0aGlzLnVpTWFuYWdlciAmJiB0eXBlb2YgdGhpcy51aU1hbmFnZXIuc2hvd05vdGlmaWNhdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy51aU1hbmFnZXIuc2hvd05vdGlmaWNhdGlvbihtZXNzYWdlLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9yIGxvZyBpZiBVSU1hbmFnZXIgZG9lc24ndCBzdXBwb3J0IG5vdGlmaWNhdGlvbnMgeWV0XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgTm90aWZpY2F0aW9uICgke3R5cGV9KTogJHttZXNzYWdlfWApO1xuICAgICAgICAgICAgLy8gVGhlIG9sZCBwb3BTYXZlU3VjY2VzcyBsb2dpYyByZXF1aXJlcyBkaXJlY3QgYWNjZXNzIHRvIHRoZSB3aWRnZXQgbm9kZSxcbiAgICAgICAgICAgIC8vIHdoaWNoIHRoaXMgaGFuZGxlciBzaG91bGRuJ3QgaGF2ZS4gVGhpcyBuZWVkcyB0byBiZSBoYW5kbGVkIGJ5IHRoZSBVSSBsYXllci5cbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2V0dGluZ3NIYW5kbGVyID0gU2V0dGluZ3NIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNldHVwU2hvcnRjdXRzID0gc2V0dXBTaG9ydGN1dHM7XG5leHBvcnRzLnJlbW92ZVNob3J0Y3V0cyA9IHJlbW92ZVNob3J0Y3V0cztcbmNvbnN0IG5vdGVib29rX2ludGVncmF0aW9uXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb25cIik7XG5sZXQgX2hhbmRsZUtleURvd24gPSBudWxsO1xuLyoqXG4gKiBTZXRzIHVwIGdsb2JhbCBrZXlib2FyZCBzaG9ydGN1dHMgZm9yIHRoZSBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIGlucHV0SGFuZGxlciBJbnN0YW5jZSBvZiBJbnB1dEhhbmRsZXIgdG8gaW50ZXJhY3Qgd2l0aCBpbnB1dCBzdGF0ZS9tZXRob2RzLlxuICogQHBhcmFtIHBvcHVwTWVudU1hbmFnZXIgSW5zdGFuY2Ugb2YgUG9wdXBNZW51TWFuYWdlci5cbiAqIEBwYXJhbSBjYWxsYmFja3MgT2JqZWN0IGNvbnRhaW5pbmcgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBVSSBpbnRlcmFjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHNldHVwU2hvcnRjdXRzKGlucHV0SGFuZGxlciwgLy8gUGFzcyBJbnB1dEhhbmRsZXIgaW5zdGFuY2UgZGlyZWN0bHlcbnBvcHVwTWVudU1hbmFnZXIsIGNhbGxiYWNrcykge1xuICAgIGlmIChfaGFuZGxlS2V5RG93bikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ1Nob3J0Y3V0cyBhbHJlYWR5IHNldCB1cC4gUmVtb3ZpbmcgcHJldmlvdXMgbGlzdGVuZXIuJyk7XG4gICAgICAgIHJlbW92ZVNob3J0Y3V0cygpO1xuICAgIH1cbiAgICBfaGFuZGxlS2V5RG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHNob3dJbmRpY2F0b3IsIGFwcGVuZFRvSW5wdXQsIHNob3dXaWRnZXQsIGZvY3VzSW5wdXQgfSA9IGNhbGxiYWNrcztcbiAgICAgICAgLy8gQ2hlY2sgZm9yIEAga2V5IC0gZXZlbnQua2V5IHNob3VsZCBjb3JyZWN0bHkgcmVwb3J0ICdAJyBldmVuIHdpdGggU2hpZnRcbiAgICAgICAgLy8gQWxzbyBjaGVjayBmb3IgU0hJRlQrMiBhcyBhbiBhbHRlcm5hdGl2ZSB3YXkgdG8gdHJpZ2dlciAnQCdcbiAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0AnIHx8IChldmVudC5zaGlmdEtleSAmJiBldmVudC5rZXkgPT09ICcyJykpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogJ0AnIGtleSBvciBTSElGVCsyIGRldGVjdGVkXCIpO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRGaWVsZCA9IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG4gICAgICAgICAgICBjb25zdCBpc0NvbnRlbnRFZGl0YWJsZUlucHV0ID0gaW5wdXRGaWVsZCAmJlxuICAgICAgICAgICAgICAgIGlucHV0RmllbGQuZ2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnKSA9PT0gJ3RydWUnICYmXG4gICAgICAgICAgICAgICAgaW5wdXRGaWVsZC5jbGFzc0xpc3QuY29udGFpbnMoJ2pwLWxsbS1leHQtaW5wdXQtZmllbGQnKTtcbiAgICAgICAgICAgIC8vIEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgaW5wdXQgZmllbGQgaXMgTk9UIHRoZSBhY3RpdmUgZWxlbWVudCBmaXJzdFxuICAgICAgICAgICAgaWYgKGlzQ29udGVudEVkaXRhYmxlSW5wdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNIT1JUQ1VUIEhBTkRMRVI6IElucHV0IGZpZWxkIElTIGFjdGl2ZSBlbGVtZW50LiBMZXR0aW5nIGRlZmF1bHQgYmVoYXZpb3IgcHJvY2VlZC5cIik7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90IGluIG91ciBpbnB1dCBmaWVsZCwgcHJldmVudCBkZWZhdWx0LCBzaG93IHdpZGdldCwgZm9jdXMsIGluc2VydCAnQCcsIGFuZCBzaG93IHBvcHVwLlxuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgc2hvd1dpZGdldCgpO1xuICAgICAgICAgICAgICAgIGZvY3VzSW5wdXQoKTtcbiAgICAgICAgICAgICAgICAvLyBBZnRlciBmb2N1cywgc2hvdyBwb3B1cCB2aWEgd2luZG93LnNldFRpbWVvdXQgdG8gZW5zdXJlIGlucHV0IGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnB1dEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1pbnB1dC1maWVsZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXRFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uKSB7IC8vIENoZWNrIGlmIHNlbGVjdGlvbiBleGlzdHMgKGV2ZW4gaWYgcmFuZ2VDb3VudCBpcyAwIGluaXRpYWxseSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFbnN1cmUgdGhlIGlucHV0IGZpZWxkIGhhcyBmb2N1cyAqYmVmb3JlKiBtYW5pcHVsYXRpbmcgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgIT09IGlucHV0RWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dEVsZW1lbnQuZm9jdXMoKTsgLy8gUmUtZm9jdXMganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBvciBnZXQgdGhlIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJhbmdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb24ucmFuZ2VDb3VudCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRG91YmxlLWNoZWNrIGlmIHRoZSBmb2N1cyBpcyBub3cgY29ycmVjdGx5IGluc2lkZSB0aGUgaW5wdXQgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlucHV0RWxlbWVudC5jb250YWlucyhyYW5nZS5jb21tb25BbmNlc3RvckNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogUmFuZ2UgaXMgbm90IGluc2lkZSB0aGUgaW5wdXQgZmllbGQgYWZ0ZXIgZm9jdXMuIENyZWF0aW5nIG5ldyByYW5nZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiByYW5nZSBpcyBub3QgaW5zaWRlLCBjcmVhdGUgYSBuZXcgb25lIGNvbGxhcHNlZCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoaW5wdXRFbGVtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTsgLy8gQ29sbGFwc2UgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbm8gcmFuZ2UgZXhpc3RzLCBjcmVhdGUgb25lIGNvbGxhcHNlZCBhdCB0aGUgZW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogTm8gcmFuZ2UgZm91bmQgYWZ0ZXIgZm9jdXMuIENyZWF0aW5nIG5ldyByYW5nZS5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlID0gZG9jdW1lbnQuY3JlYXRlUmFuZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2VsZWN0Tm9kZUNvbnRlbnRzKGlucHV0RWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTsgLy8gQ29sbGFwc2UgdG8gdGhlIGVuZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5hZGRSYW5nZShyYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1hbnVhbGx5IGluc2VydCAnQCcgc2luY2Ugd2UgcHJldmVudGVkIGRlZmF1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnQCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhbmdlLmRlbGV0ZUNvbnRlbnRzKCk7IC8vIENsZWFyIGFueSBzZWxlY3Rpb24ganVzdCBpbiBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShhdE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1vdmUgY3Vyc29yIGFmdGVyIHRoZSBpbnNlcnRlZCAnQCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydEFmdGVyKGF0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIoYXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7IC8vIFVwZGF0ZSBzZWxlY3Rpb24gdG8gdGhlIG5ldyBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vICoqTkVTVEVEIFRJTUVPVVQ6KiogR2l2ZSBicm93c2VyIHRpbWUgdG8gcmVuZGVyIGJlZm9yZSBnZXR0aW5nIHJhbmdlIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNIT1JUQ1VUIEhBTkRMRVI6IFNob3dpbmcgcG9wdXAgYWZ0ZXIgZm9jdXNpbmcsIGluc2VydGluZyAnQCcsIGFuZCBuZXN0ZWQgdGltZW91dC5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBnZXQgdGhlIG1vc3QgdXAtdG8tZGF0ZSByYW5nZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTZWxlY3Rpb24gJiYgY3VycmVudFNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycmVudFJhbmdlID0gY3VycmVudFNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLS0tIEluc2VydCB0ZW1wb3Jhcnkgc3BhbiB0byBnZXQgcmVsaWFibGUgY29vcmRzIC0tLSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBBbmNob3JJZCA9ICdqcC1sbG0tc2hvcnRjdXQtcG9wdXAtYW5jaG9yJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCB0ZW1wU3BhbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBBbmNob3JJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGVtcFNwYW4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4ucmVtb3ZlKCk7IC8vIENsZWFuIHVwIHByZXZpb3VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGFuLmlkID0gdGVtcEFuY2hvcklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4uc3R5bGUud2lkdGggPSAnMCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcFNwYW4udGV4dENvbnRlbnQgPSAnXFx1MjAwQic7IC8vIFplcm8td2lkdGggc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSYW5nZS5pbnNlcnROb2RlKHRlbXBTcGFuKTsgLy8gSW5zZXJ0IGF0IGN1cnNvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BhblJlY3QgPSB0ZW1wU3Bhbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBTcGFuLnJlbW92ZSgpOyAvLyBSZW1vdmUgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0tLSBFbmQgdGVtcG9yYXJ5IHNwYW4gbG9naWMgLS0tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3BhblJlY3QudG9wID09PSAwICYmIHNwYW5SZWN0LmxlZnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU0hPUlRDVVQgSEFORExFUjogRmFpbGVkIHRvIGdldCB2YWxpZCBjb29yZGluYXRlcyBmcm9tIHRlbXAgYW5jaG9yIHNwYW4uXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFNIT1JUQ1VUIEhBTkRMRVI6IEFuY2hvciBjb29yZHMgZnJvbSB0ZW1wIHNwYW46IFRvcD0ke3NwYW5SZWN0LnRvcH0sIExlZnQ9JHtzcGFuUmVjdC5sZWZ0fWApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcHVwTWVudU1hbmFnZXIuc2hvd1BvcHVwTWVudShzcGFuUmVjdC5sZWZ0LCBzcGFuUmVjdC50b3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJbmRpY2F0b3IoJ0Jyb3dzaW5nIHJlZmVyZW5jZXMuLi4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJTSE9SVENVVCBIQU5ETEVSOiBDb3VsZCBub3QgZ2V0IHJhbmdlIGltbWVkaWF0ZWx5IGJlZm9yZSBzaG93aW5nIHBvcHVwLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApOyAvLyAwbXMgZGVsYXkgaXMgb2Z0ZW4gc3VmZmljaWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJTSE9SVENVVCBIQU5ETEVSOiBObyBzZWxlY3Rpb24gb2JqZWN0IGFmdGVyIGZvY3VzLCBjYW5ub3QgaW5zZXJ0ICdAJyBvciBzaG93IHBvcHVwIHJlbGlhYmx5LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogQ291bGQgbm90IGZpbmQgaW5wdXQgZWxlbWVudCBhZnRlciB0aW1lb3V0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDUwKTsgLy8gT3V0ZXIgdGltZW91dCByZW1haW5zIDUwbXNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiU0hPUlRDVVQgSEFORExFUjogSW5wdXQgZmllbGQgaXMgTk9UIGFjdGl2ZSBlbGVtZW50LiBIYW5kbGluZyAnQCcgZ2xvYmFsbHkuXCIpO1xuICAgICAgICAgICAgICAgIC8vIElmIHRoZSBpbnB1dCBmaWVsZCBpcyBhbHJlYWR5IGZvY3VzZWQsIERPIE5PVEhJTkcgaGVyZS5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZGVmYXVsdCBicm93c2VyIGJlaGF2aW9yIHdpbGwgaW5zZXJ0IHRoZSAnQCcuXG4gICAgICAgICAgICAgICAgLy8gVGhlICdpbnB1dCcgZXZlbnQgbGlzdGVuZXIgaW4gVUlNYW5hZ2VyIHdpbGwgdGhlbiBkZXRlY3QgdGhlICdAJ1xuICAgICAgICAgICAgICAgIC8vIGFuZCB0cmlnZ2VyIHRoZSBwb3B1cCB2aWEgaGFuZGxlSW5wdXRGb3JSZWZlcmVuY2UuXG4gICAgICAgICAgICAgICAgLy8gV2UgZG8gTk9UIHByZXZlbnREZWZhdWx0IG9yIHN0b3BQcm9wYWdhdGlvbi5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayBmb3IgQ3RybCtMIChpbnNlcnQgc2VsZWN0aW9uIG9yIGNlbGwpXG4gICAgICAgIGVsc2UgaWYgKGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQua2V5LnRvTG93ZXJDYXNlKCkgPT09ICdsJykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSAoMCwgbm90ZWJvb2tfaW50ZWdyYXRpb25fMS5nZXRTZWxlY3RlZFRleHQpKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBhcHBlbmRUb0lucHV0KGBAY29kZSAke3NlbGVjdGVkfWApOyAvLyBVc2UgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBzaG93SW5kaWNhdG9yKCdTZWxlY3RlZCBjb2RlIGluc2VydGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjZWxsQ29udGVudCA9ICgwLCBub3RlYm9va19pbnRlZ3JhdGlvbl8xLmdldEN1cnJlbnRDZWxsQ29udGVudCkoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2VsbENvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwZW5kVG9JbnB1dChgQGNlbGwgJHtjZWxsQ29udGVudH1gKTsgLy8gVXNlIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIHNob3dJbmRpY2F0b3IoJ0NlbGwgY29udGVudCBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgc2lkZWJhciBpcyB2aXNpYmxlIGFuZCBpbnB1dCBpcyBmb2N1c2VkXG4gICAgICAgICAgICBzaG93V2lkZ2V0KCk7IC8vIFVzZSBjYWxsYmFja1xuICAgICAgICAgICAgZm9jdXNJbnB1dCgpOyAvLyBVc2UgY2FsbGJhY2tcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gQWRkIHRoZSBldmVudCBsaXN0ZW5lciB0byB0aGUgZG9jdW1lbnRcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgX2hhbmRsZUtleURvd24pO1xufVxuLyoqXG4gKiBSZW1vdmVzIHRoZSBnbG9iYWwga2V5Ym9hcmQgc2hvcnRjdXQgbGlzdGVuZXIuXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVNob3J0Y3V0cygpIHtcbiAgICBpZiAoX2hhbmRsZUtleURvd24pIHtcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIF9oYW5kbGVLZXlEb3duKTtcbiAgICAgICAgX2hhbmRsZUtleURvd24gPSBudWxsO1xuICAgICAgICBjb25zb2xlLmxvZygnUmVtb3ZlZCBrZXlib2FyZCBzaG9ydGN1dHMuJyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0F0dGVtcHRlZCB0byByZW1vdmUgc2hvcnRjdXRzLCBidXQgbm9uZSB3ZXJlIGFjdGl2ZS4nKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBpQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgbGF1bmNoZXJfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9sYXVuY2hlclwiKTtcbmNvbnN0IGFwcHV0aWxzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvYXBwdXRpbHNcIik7XG5jb25zdCBub3RlYm9va18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL25vdGVib29rXCIpO1xuY29uc3QgZG9jbWFuYWdlcl8xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2RvY21hbmFnZXJcIik7XG5jb25zdCBzaWRlYmFyX3dpZGdldF8xID0gcmVxdWlyZShcIi4vc2lkZWJhci13aWRnZXRcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi9jb3JlL2dsb2JhbHNcIik7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIi4vY29tbWFuZHNcIik7XG5jb25zdCBjZWxsX2NvbnRleHRfdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vY2VsbC1jb250ZXh0LXRyYWNrZXJcIik7XG4vLyBpbXBvcnQgeyBBcGlDbGllbnQgfSBmcm9tICcuL2FwaS1jbGllbnQnO1xuLy8gSW1wb3J0IHRoZSBtYWluIENTUyBmaWxlXG5yZXF1aXJlKFwiLi4vc3R5bGUvaW5kZXguY3NzXCIpO1xuLy8gRXhwb3J0IEFwaUNsaWVudCBmb3IgdXNlIGJ5IG90aGVyIGNvbXBvbmVudHNcbnZhciBhcGlfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jb3JlL2FwaS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcGlDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwaV9jbGllbnRfMS5BcGlDbGllbnQ7IH0gfSk7XG4vKipcbiAqIEluaXRpYWxpemF0aW9uIGRhdGEgZm9yIHRoZSBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gZXh0ZW5zaW9uLlxuICovXG5jb25zdCBwbHVnaW4gPSB7XG4gICAgaWQ6ICdqdXB5dGVyLXNpbXBsZS1leHRlbnNpb246cGx1Z2luJyxcbiAgICBhdXRvU3RhcnQ6IHRydWUsXG4gICAgcmVxdWlyZXM6IFtsYXVuY2hlcl8xLklMYXVuY2hlciwgYXBwdXRpbHNfMS5JQ29tbWFuZFBhbGV0dGUsIG5vdGVib29rXzEuSU5vdGVib29rVHJhY2tlciwgZG9jbWFuYWdlcl8xLklEb2N1bWVudE1hbmFnZXJdLFxuICAgIGFjdGl2YXRlOiAoanVweXRlckFwcCwgbGF1bmNoZXIsIHBhbGV0dGUsIHRyYWNrZXIsIGRvY01hbmFnZXIpID0+IHtcbiAgICAgICAgY29uc29sZS5sb2coJ0p1cHl0ZXJMYWIgZXh0ZW5zaW9uIGp1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbiBpcyBhY3RpdmF0ZWQhJyk7XG4gICAgICAgIC8vIEluaXRpYWxpemUgZ2xvYmFsIHJlZmVyZW5jZXNcbiAgICAgICAgKDAsIGdsb2JhbHNfMS5pbml0R2xvYmFscykoanVweXRlckFwcCwgdHJhY2tlcik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgY2VsbCBjb250ZXh0IHRyYWNrZXJcbiAgICAgICAgZ2xvYmFsc18xLmdsb2JhbHMuY2VsbENvbnRleHRUcmFja2VyID0gbmV3IGNlbGxfY29udGV4dF90cmFja2VyXzEuQ2VsbENvbnRleHRUcmFja2VyKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBDcmVhdGUgYW5kIGFkZCBzaWRlYmFyIHdpZGdldFxuICAgICAgICBjb25zdCBzaWRlYmFyV2lkZ2V0ID0gbmV3IHNpZGViYXJfd2lkZ2V0XzEuU2ltcGxlU2lkZWJhcldpZGdldChkb2NNYW5hZ2VyKTtcbiAgICAgICAganVweXRlckFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGNvbW1hbmRzXG4gICAgICAgICgwLCBjb21tYW5kc18xLnJlZ2lzdGVyQ29tbWFuZHMpKGp1cHl0ZXJBcHAsIHBhbGV0dGUsIGxhdW5jaGVyLCBzaWRlYmFyV2lkZ2V0KTtcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gcGx1Z2luO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSB2b2lkIDA7XG5jb25zdCB3aWRnZXRzXzEgPSByZXF1aXJlKFwiQGx1bWluby93aWRnZXRzXCIpO1xuY29uc3QgaWNvbnNfMSA9IHJlcXVpcmUoXCIuL2NvcmUvaWNvbnNcIik7XG5jb25zdCBhcGlfY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jb3JlL2FwaS1jbGllbnRcIik7XG5jb25zdCBwb3B1cF9tZW51X21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL3BvcHVwLW1lbnUtbWFuYWdlclwiKTtcbmNvbnN0IHNob3J0Y3V0X2hhbmRsZXJfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL3Nob3J0Y3V0LWhhbmRsZXJcIik7XG5jb25zdCBsYXlvdXRfYnVpbGRlcl8xID0gcmVxdWlyZShcIi4vdWkvbGF5b3V0LWJ1aWxkZXJcIik7XG5jb25zdCBzZXR0aW5nc19tb2RhbF8xID0gcmVxdWlyZShcIi4vdWkvc2V0dGluZ3MtbW9kYWxcIik7XG5jb25zdCBjaGF0X3N0YXRlXzEgPSByZXF1aXJlKFwiLi9zdGF0ZS9jaGF0LXN0YXRlXCIpO1xuY29uc3Qgc2V0dGluZ3Nfc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3N0YXRlL3NldHRpbmdzLXN0YXRlXCIpO1xuY29uc3QgaW5wdXRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvaW5wdXQtaGFuZGxlclwiKTtcbmNvbnN0IG1lc3NhZ2VfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvbWVzc2FnZS1oYW5kbGVyXCIpO1xuY29uc3QgaGlzdG9yeV9oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9oaXN0b3J5LWhhbmRsZXJcIik7XG5jb25zdCBzZXR0aW5nc19oYW5kbGVyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9zZXR0aW5ncy1oYW5kbGVyXCIpO1xuY29uc3QgdWlfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vdWkvdWktbWFuYWdlclwiKTtcbmNvbnN0IHVpX2NvbXBvbmVudHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi91aS1jb21wb25lbnRzXCIpO1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4vY29yZS9nbG9iYWxzXCIpO1xuLy8gLS0tIEltcG9ydCBVdGlsaXR5IEZ1bmN0aW9ucyAtLS1cbmNvbnN0IGNsaXBib2FyZF8xID0gcmVxdWlyZShcIi4vdXRpbHMvY2xpcGJvYXJkXCIpO1xuY29uc3Qgbm90ZWJvb2tfaW50ZWdyYXRpb25fMSA9IHJlcXVpcmUoXCIuL3V0aWxzL25vdGVib29rLWludGVncmF0aW9uXCIpO1xuLyoqXG4gKiBNYWluIHNpZGViYXIgd2lkZ2V0IGZvciB0aGUgQUkgY2hhdCBpbnRlcmZhY2UgLSBOb3cgYWN0cyBhcyBhbiBvcmNoZXN0cmF0b3IuXG4gKi9cbmNsYXNzIFNpbXBsZVNpZGViYXJXaWRnZXQgZXh0ZW5kcyB3aWRnZXRzXzEuV2lkZ2V0IHtcbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmVwbGFjZSBhIHRleHQgcmFuZ2Ugd2l0aCBhIG5vbi1lZGl0YWJsZSB3aWRnZXQgc3Bhbi5cbiAgICAgKi9cbiAgICBjcmVhdGVXaWRnZXRTcGFuKHJhbmdlLCByZWZUZXh0KSB7XG4gICAgICAgIGlmICghcmFuZ2UpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIEV4dHJhY3QgYSBkaXNwbGF5LWZyaWVuZGx5IHZlcnNpb24gKGUuZy4sIGZpbGVuYW1lIGZyb20gcGF0aClcbiAgICAgICAgbGV0IGRpc3BsYXlMYWJlbCA9IHJlZlRleHQ7XG4gICAgICAgIGlmIChyZWZUZXh0LnN0YXJ0c1dpdGgoJ0BmaWxlICcpIHx8IHJlZlRleHQuc3RhcnRzV2l0aCgnQGRpciAnKSkge1xuICAgICAgICAgICAgY29uc3QgcGFydHMgPSByZWZUZXh0LnNwbGl0KCcgJyk7XG4gICAgICAgICAgICBpZiAocGFydHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhQYXJ0cyA9IHBhcnRzWzFdLnNwbGl0KC9bXFxcXC9dLyk7XG4gICAgICAgICAgICAgICAgZGlzcGxheUxhYmVsID0gcGF0aFBhcnRzW3BhdGhQYXJ0cy5sZW5ndGggLSAxXSB8fCBwYXJ0c1sxXTsgLy8gVXNlIGxhc3QgcGFydCBvZiBwYXRoIG9yIGZ1bGwgcGF0aFxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlZlRleHQuc3RhcnRzV2l0aCgnQENlbGwgJykpIHtcbiAgICAgICAgICAgIGRpc3BsYXlMYWJlbCA9IHJlZlRleHQuc3Vic3RyaW5nKDEpOyAvLyBSZW1vdmUgbGVhZGluZyAnQCdcbiAgICAgICAgfSAvLyBBZGQgbW9yZSBjb25kaXRpb25zIGZvciBvdGhlciB0eXBlcyBpZiBuZWVkZWRcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSB3aWRnZXQgc3BhblxuICAgICAgICBjb25zdCBzcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXJlZi13aWRnZXQnOyAvLyBDbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJywgJ2ZhbHNlJyk7IC8vIE1ha2UgaXQgbm9uLWVkaXRhYmxlXG4gICAgICAgIHNwYW4uc2V0QXR0cmlidXRlKCdkYXRhLXJlZi10ZXh0JywgcmVmVGV4dCk7IC8vIFN0b3JlIG9yaWdpbmFsIHRleHQgZm9yIHNlcmlhbGl6YXRpb25cbiAgICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IGRpc3BsYXlMYWJlbDsgLy8gU2V0IHZpc2libGUgdGV4dFxuICAgICAgICAvLyBSZXBsYWNlIHRoZSByYW5nZSBjb250ZW50IHdpdGggdGhlIHNwYW5cbiAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTtcbiAgICAgICAgcmFuZ2UuaW5zZXJ0Tm9kZShzcGFuKTtcbiAgICAgICAgLy8gTW92ZSBjdXJzb3IgYWZ0ZXIgdGhlIGluc2VydGVkIHNwYW5cbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdSYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgICAgICAgICBuZXdSYW5nZS5zZXRTdGFydEFmdGVyKHNwYW4pO1xuICAgICAgICAgICAgbmV3UmFuZ2Uuc2V0RW5kQWZ0ZXIoc3Bhbik7XG4gICAgICAgICAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UobmV3UmFuZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gUGxhY2Vob2xkZXIgZm9yIGhhbmRsZXIgbWV0aG9kcyB1c2VkIGluIFVJTWFuYWdlciBjYWxsYmFja3NcbiAgICAgICAgdGhpcy5oYW5kbGVOZXdDaGF0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0hhbmRsZSBOZXcgQ2hhdCBjbGlja2VkJyk7XG4gICAgICAgICAgICBjb25zdCBuZXdDaGF0ID0gdGhpcy5jaGF0U3RhdGUuY3JlYXRlTmV3Q2hhdCgpO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5oaXN0b3J5SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvYWRDaGF0KG5ld0NoYXQuaWQpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVRvZ2dsZUhpc3RvcnkgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFRvZ2dsZSBIaXN0b3J5IGNsaWNrZWQnKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZXIudG9nZ2xlSGlzdG9yeVZpZXcoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVTZW5kTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAvLyAxLiBHZXQgdGhlIGN1cnJlbnQgdGV4dCBmcm9tIHRoZSBpbnB1dCBmaWVsZCB2aWEgVUlNYW5hZ2VyIG9yIExheW91dEVsZW1lbnRzXG4gICAgICAgICAgICAvLyBjb25zdCB0ZXh0ID0gdGhpcy5sYXlvdXRFbGVtZW50cy5pbnB1dEZpZWxkLnZhbHVlOyAvLyBObyBsb25nZXIgbmVlZGVkLCB0ZXh0IGlzIHBhc3NlZCBpblxuICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnRyaW0oKSlcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIERvbid0IHNlbmQgZW1wdHkgbWVzc2FnZXMgKGNoZWNrIHRoZSBwYXNzZWQgbWVzc2FnZSlcbiAgICAgICAgICAgIC8vIDIuIEdldCB0aGUgbWFya2Rvd24gc3RhdGUgZnJvbSBVSU1hbmFnZXIgLSBSRU1PVkVEXG4gICAgICAgICAgICAvLyBjb25zdCBpc01hcmtkb3duID0gdGhpcy51aU1hbmFnZXIuZ2V0SXNNYXJrZG93bk1vZGUoKTsgXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW1dpZGdldF0gaGFuZGxlU2VuZE1lc3NhZ2U6IFRleHQ9JyR7bWVzc2FnZX0nYCk7IC8vIERlYnVnIGxvZyB1c2luZyBwYXNzZWQgbWVzc2FnZVxuICAgICAgICAgICAgLy8gMy4gQ2FsbCB0aGUgTWVzc2FnZUhhbmRsZXIncyBzZW5kIG1ldGhvZCB3aXRoIHRleHQgYW5kIHN0YXRlXG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyLmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UpOyAvLyBQYXNzIHRoZSByZWNlaXZlZCBtZXNzYWdlIC0gUkVNT1ZFRCBpc01hcmtkb3duXG4gICAgICAgICAgICAvLyBOT1RFOiBJbnB1dCBjbGVhcmluZyBpcyBub3cgaGFuZGxlZCBieSBVSU1hbmFnZXIgYWZ0ZXIgdGhpcyBjYWxsYmFjayByZXR1cm5zLlxuICAgICAgICAgICAgLy8gRG8gTk9UIGNsZWFyIGlucHV0IGhlcmUgb3IgaW4gTWVzc2FnZUhhbmRsZXIuXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2hvd1NldHRpbmdzID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFNob3cgU2V0dGluZ3MgY2xpY2tlZCcpO1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc0hhbmRsZXIuc2hvd01vZGFsKCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGFuZGxlU2hvd1BvcHVwTWVudSA9IChldmVudCwgdGFyZ2V0QnV0dG9uKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnSGFuZGxlIFNob3cgUG9wdXAgTWVudSBjbGlja2VkJyk7XG4gICAgICAgICAgICBjb25zdCByZWN0ID0gdGFyZ2V0QnV0dG9uLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLnNob3dQb3B1cE1lbnUocmVjdC5sZWZ0LCByZWN0LmJvdHRvbSArIDUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVVwZGF0ZVRpdGxlID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbmV3VGl0bGUgPSAoKF9hID0gdGhpcy5sYXlvdXRFbGVtZW50cy50aXRsZUlucHV0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudmFsdWUpIHx8ICdDaGF0JztcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdIYW5kbGUgVXBkYXRlIFRpdGxlIGNhbGxlZDonLCBuZXdUaXRsZSk7XG4gICAgICAgICAgICB0aGlzLmNoYXRTdGF0ZS51cGRhdGVDdXJyZW50Q2hhdFRpdGxlKG5ld1RpdGxlKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICAgICAgdGhpcy5pZCA9ICdzaW1wbGUtc2lkZWJhcic7XG4gICAgICAgIHRoaXMudGl0bGUubGFiZWwgPSAnJztcbiAgICAgICAgdGhpcy50aXRsZS5jYXB0aW9uID0gJ0FJIENoYXQgSW50ZXJmYWNlJztcbiAgICAgICAgdGhpcy50aXRsZS5pY29uID0gaWNvbnNfMS5leHRlbnNpb25JY29uO1xuICAgICAgICB0aGlzLnRpdGxlLmNsb3NhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5hZGRDbGFzcygnanAtbGxtLWV4dC1zaWRlYmFyJyk7XG4gICAgICAgIC8vIC0tLSAxLiBJbml0aWFsaXplIENvcmUgQ29tcG9uZW50cyAmIFN0YXRlIC0tLVxuICAgICAgICB0aGlzLnNldHRpbmdzU3RhdGUgPSBuZXcgc2V0dGluZ3Nfc3RhdGVfMS5TZXR0aW5nc1N0YXRlKCk7XG4gICAgICAgIGNvbnN0IGluaXRpYWxTZXR0aW5ncyA9IHRoaXMuc2V0dGluZ3NTdGF0ZS5nZXRTZXR0aW5ncygpO1xuICAgICAgICB0aGlzLmFwaUNsaWVudCA9IG5ldyBhcGlfY2xpZW50XzEuQXBpQ2xpZW50KChpbml0aWFsU2V0dGluZ3MgPT09IG51bGwgfHwgaW5pdGlhbFNldHRpbmdzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBpbml0aWFsU2V0dGluZ3MuYXBpVXJsKSB8fCB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmNoYXRTdGF0ZSA9IG5ldyBjaGF0X3N0YXRlXzEuQ2hhdFN0YXRlKCk7XG4gICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlciA9IG5ldyBwb3B1cF9tZW51X21hbmFnZXJfMS5Qb3B1cE1lbnVNYW5hZ2VyKHRoaXMuZG9jTWFuYWdlciwgdGhpcy5ub2RlLCB7XG4gICAgICAgICAgICBpbnNlcnRDb2RlOiAoY29kZSkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5pbnB1dEhhbmRsZXIgfHwgIWdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb3RlYm9va1BhbmVsID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQ7XG4gICAgICAgICAgICAgICAgaWYgKCFjdXJyZW50Tm90ZWJvb2tQYW5lbCB8fCAhY3VycmVudE5vdGVib29rUGFuZWwuY29udGV4dCB8fCAhY3VycmVudE5vdGVib29rUGFuZWwuY29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBnZXQgbm90ZWJvb2sgY29udGV4dCBmb3IgY29kZSByZWZlcmVuY2UsIGluc2VydGluZyByYXcgY29kZSBhcyBmYWxsYmFjay4nKTtcbiAgICAgICAgICAgICAgICAgICAgKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KGNvZGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5vdGVib29rUGF0aCA9IGN1cnJlbnROb3RlYm9va1BhbmVsLmNvbnRleHQucGF0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBub3RlYm9va05hbWUgPSAoKF9iID0gbm90ZWJvb2tQYXRoLnNwbGl0KCcvJykucG9wKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zcGxpdCgnLicpWzBdKSB8fCAnbm90ZWJvb2snO1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRDZWxsID0gY3VycmVudE5vdGVib29rUGFuZWwuY29udGVudC5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgICAgIGlmICghY3VycmVudENlbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZ2V0IGFjdGl2ZSBjZWxsIGZvciBjb2RlIHJlZmVyZW5jZSwgaW5zZXJ0aW5nIHJhdyBjb2RlIGFzIGZhbGxiYWNrLicpO1xuICAgICAgICAgICAgICAgICAgICAoX2MgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmFwcGVuZFRvSW5wdXQoY29kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbEluZGV4ID0gY3VycmVudE5vdGVib29rUGFuZWwuY29udGVudC5hY3RpdmVDZWxsSW5kZXg7XG4gICAgICAgICAgICAgICAgbGV0IGxpbmVOdW1iZXIgPSAxOyAvLyBEZWZhdWx0IGxpbmUgbnVtYmVyXG4gICAgICAgICAgICAgICAgbGV0IGxpbmVFbmROdW1iZXIgPSAxOyAvLyBEZWZhdWx0IGVuZCBsaW5lIG51bWJlclxuICAgICAgICAgICAgICAgIC8vIC0tLSBERUJVRyBMT0cgLS0tIFxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdBcmUgd2UgY3VycmVudGx5IGluIGEgY29kZSBjZWxsPycpO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIGN1cnJlbnRDZWxsIGlzIGluIGVkaXRvciBcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhjdXJyZW50Q2VsbC5lZGl0b3IpO1xuICAgICAgICAgICAgICAgIC8vIC0tLSBFTkQgREVCVUcgTE9HIC0tLVxuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50Q2VsbC5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY3VycmVudENlbGwuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjbUVkaXRvciA9IGVkaXRvci5lZGl0b3I7IC8vIEFjY2VzcyBDb2RlTWlycm9yIGVkaXRvciBpbnN0YW5jZSAoRWRpdG9yVmlldylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNtRWRpdG9yICYmIGNtRWRpdG9yLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGF0ZSA9IGNtRWRpdG9yLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gc3RhdGUuc2VsZWN0aW9uLm1haW47XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNlbGVjdGlvbi5lbXB0eSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBzdGF0ZS5kb2MubGluZUF0KHNlbGVjdGlvbi5mcm9tKS5udW1iZXI7IC8vIDEtYmFzZWQgc3RhcnQgbGluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVFbmROdW1iZXIgPSBzdGF0ZS5kb2MubGluZUF0KHNlbGVjdGlvbi50bykubnVtYmVyOyAvLyAxLWJhc2VkIGVuZCBsaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWxsYmFjayBmb3IgY3Vyc29yIHBvc2l0aW9uIGlmIG5vIHNlbGVjdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjdXJzb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlciA9IGN1cnNvci5saW5lICsgMTsgLy8gMS1iYXNlZCBsaW5lIG51bWJlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lRW5kTnVtYmVyID0gbGluZU51bWJlcjsgLy8gU3RhcnQgYW5kIGVuZCBhcmUgdGhlIHNhbWUgZm9yIGN1cnNvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIGlmIGNtRWRpdG9yIG9yIHN0YXRlIGlzIG5vdCBhdmFpbGFibGUgKHNob3VsZCBub3QgaGFwcGVuIG9mdGVuKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgYWNjZXNzIENvZGVNaXJyb3Igc3RhdGUgZm9yIGxpbmUgbnVtYmVycy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnNvciA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnNvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXIgPSBjdXJzb3IubGluZSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGluZUVuZE51bWJlciA9IGxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IGFjY2VzcyBjZWxsIGVkaXRvciBmb3IgbGluZSBudW1iZXJzLicpO1xuICAgICAgICAgICAgICAgICAgICAvLyBLZWVwIGRlZmF1bHQgbGluZSBudW1iZXJzIDEsIDEgaWYgZWRpdG9yIGlzIG5vdCBhdmFpbGFibGVcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gLS0tIERFQlVHIExPRyAtLS0gXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFtTaW1wbGVTaWRlYmFyV2lkZ2V0Lmluc2VydENvZGVdIERldGVybWluZWQgbGluZXM6IFN0YXJ0PSR7bGluZU51bWJlcn0sIEVuZD0ke2xpbmVFbmROdW1iZXJ9YCk7XG4gICAgICAgICAgICAgICAgLy8gLS0tIEVORCBERUJVRyBMT0cgLS0tXG4gICAgICAgICAgICAgICAgLy8gUGFzcyBib3RoIHN0YXJ0IGFuZCBlbmQgbGluZSBudW1iZXJzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVmSWQgPSB0aGlzLmlucHV0SGFuZGxlci5hZGRDb2RlUmVmZXJlbmNlKGNvZGUsIG5vdGVib29rTmFtZSwgY2VsbEluZGV4LCBsaW5lTnVtYmVyLCBsaW5lRW5kTnVtYmVyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IGBAY29kZVske3JlZklkfV1gO1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLmFwcGVuZFRvSW5wdXQocGxhY2Vob2xkZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydENlbGw6IChjb250ZW50KSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kVG9JbnB1dChgQGNlbGwgJHtjb250ZW50fWApOyB9LFxuICAgICAgICAgICAgaW5zZXJ0RmlsZVBhdGg6IChwYXRoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kVG9JbnB1dChgQGZpbGVbJHtwYXRofV1gKTsgfSxcbiAgICAgICAgICAgIGluc2VydERpcmVjdG9yeVBhdGg6IChwYXRoKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kVG9JbnB1dChgQGRpclske3BhdGh9XWApOyB9LFxuICAgICAgICAgICAgZ2V0U2VsZWN0ZWRUZXh0OiBub3RlYm9va19pbnRlZ3JhdGlvbl8xLmdldFNlbGVjdGVkVGV4dCxcbiAgICAgICAgICAgIGdldEN1cnJlbnRDZWxsQ29udGVudDogbm90ZWJvb2tfaW50ZWdyYXRpb25fMS5nZXRDdXJyZW50Q2VsbENvbnRlbnQsXG4gICAgICAgICAgICBpbnNlcnRDZWxsQnlJbmRleDogKGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uZUJhc2VkSW5kZXggPSBpbmRleCArIDE7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmVGV4dCA9IGBAQ2VsbFske29uZUJhc2VkSW5kZXh9XWA7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hcHBlbmRUb0lucHV0KHJlZlRleHQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGluc2VydENvbGxhcHNlZENvZGVSZWY6IChjb2RlLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIG5vdGVib29rTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSByZWZlcmVuY2UgZnJvbSBjdXJzb3IgcG9zaXRpb24gKGFzc3VtZSBzdGFydC9lbmQgbGluZSBhcmUgdGhlIHNhbWUpXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlucHV0SGFuZGxlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxpbmVFbmROdW1iZXIgPSBsaW5lTnVtYmVyOyAvLyBTdGFydCBhbmQgZW5kIGFyZSB0aGUgc2FtZSBmb3IgYSBzaW5nbGUgbGluZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICBjb25zdCByZWZJZCA9IHRoaXMuaW5wdXRIYW5kbGVyLmFkZENvZGVSZWZlcmVuY2UoY29kZSwgbm90ZWJvb2tOYW1lLCBjZWxsSW5kZXgsIGxpbmVOdW1iZXIsIGxpbmVFbmROdW1iZXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0gYEBjb2RlWyR7cmVmSWR9XWA7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIuYXBwZW5kVG9JbnB1dChwbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAtLS0gMi4gRGVmaW5lIENhbGxiYWNrcyAodXNlZCBieSBidWlsZExheW91dCBhbmQgSGFuZGxlcnMpIC0tLVxuICAgICAgICAvLyBDYWxsYmFja3MgZm9yIFVJIGFjdGlvbnMgKHBhc3NlZCB0byBidWlsZExheW91dClcbiAgICAgICAgY29uc3QgY3JlYXRlTmV3Q2hhdENhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHRoaXMuY2hhdFN0YXRlLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaGlzdG9yeUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2FkQ2hhdChuZXdDaGF0LmlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdG9nZ2xlSGlzdG9yeUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5oaXN0b3J5SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3dTZXR0aW5nc0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5zZXR0aW5nc0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zaG93TW9kYWwoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdXBkYXRlVGl0bGVDYWxsYmFjayA9IChuZXdUaXRsZSkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgdGhpcy5jaGF0U3RhdGUudXBkYXRlQ3VycmVudENoYXRUaXRsZShuZXdUaXRsZSk7XG4gICAgICAgICAgICAoX2EgPSB0aGlzLnVpTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNob3dOb3RpZmljYXRpb24oJ0NoYXQgdGl0bGUgdXBkYXRlZCcsICdpbmZvJyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNob3dQb3B1cE1lbnVDYWxsYmFjayA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVjdCA9IGV2ZW50LnRhcmdldC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KHJlY3QubGVmdCArIDYwLCByZWN0LnRvcCAtIDIwKTtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2VuZE1lc3NhZ2VWaWFCdXR0b25DYWxsYmFjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0RWxlbWVudCA9IHRoaXMubGF5b3V0RWxlbWVudHMuaW5wdXRGaWVsZDtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEtleWJvYXJkRXZlbnQoJ2tleXByZXNzJywgeyBrZXk6ICdFbnRlcicsIGJ1YmJsZXM6IHRydWUgfSk7XG4gICAgICAgICAgICBpbnB1dEVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHRvZ2dsZU1hcmtkb3duTW9kZUNhbGxiYWNrID0gKGlzTWFya2Rvd24pID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0TWFya2Rvd25Nb2RlKGlzTWFya2Rvd24pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB0b2dnbGVFeHBhbmRJbnB1dENhbGxiYWNrID0gKGJ1dHRvbikgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50b2dnbGVJbnB1dEV4cGFuc2lvbigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBDYWxsYmFja3MgZm9yIE1lc3NhZ2UgUmVuZGVyaW5nIChwYXNzZWQgdG8gTWVzc2FnZUhhbmRsZXIgLT4gVUlNYW5hZ2VyIC0+IHJlbmRlcmVycylcbiAgICAgICAgY29uc3QgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgc2hvd0NvcHlGZWVkYmFjazogKGJ1dHRvbiwgc3VjY2VzcyA9IHRydWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEhUTUwgPSBidXR0b24uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBzdWNjZXNzID8gJ0NvcGllZCEnIDogJ0ZhaWxlZCEnO1xuICAgICAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5pbm5lckhUTUwgPSBvcmlnaW5hbEhUTUw7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbi5kaXNhYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZE1lc3NhZ2VUb0NlbGw6IG5vdGVib29rX2ludGVncmF0aW9uXzEuYWRkTWVzc2FnZVRvQ2VsbCxcbiAgICAgICAgICAgIGNvcHlUb0NsaXBib2FyZDogKHRleHQsIGZlZWRiYWNrQ2IpID0+IHtcbiAgICAgICAgICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKCgpID0+IGZlZWRiYWNrQ2IgPT09IG51bGwgfHwgZmVlZGJhY2tDYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYigpKS5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSB0ZXh0OiAnLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICBmZWVkYmFja0NiID09PSBudWxsIHx8IGZlZWRiYWNrQ2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2IoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3B5SW1hZ2VUb0NsaXBib2FyZDogKGltYWdlVXJsLCBmZWVkYmFja0NiKSA9PiB7XG4gICAgICAgICAgICAgICAgKDAsIGNsaXBib2FyZF8xLmNvcHlJbWFnZVRvQ2xpcGJvYXJkKShpbWFnZVVybCwgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2tDYiA9PT0gbnVsbCB8fCBmZWVkYmFja0NiID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NiKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29weU1lc3NhZ2VUb0NsaXBib2FyZDogKHRleHQsIGZlZWRiYWNrQ2IpID0+IHtcbiAgICAgICAgICAgICAgICAoMCwgY2xpcGJvYXJkXzEuY29weU1lc3NhZ2VUb0NsaXBib2FyZCkodGV4dCwgKHN1Y2Nlc3MpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZmVlZGJhY2tDYigpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGhhbmRsZUNvbmZpcm1JbnRlcnJ1cHQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5tZXNzYWdlSGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhhbmRsZVNlbmRBdXRvTWVzc2FnZSgnY29uZmlybWVkJyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGFuZGxlUmVqZWN0SW50ZXJydXB0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIChfYSA9IHRoaXMubWVzc2FnZUhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVTZW5kQXV0b01lc3NhZ2UoJ3JlamVjdGVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNldHRpbmdzTW9kYWxDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICBoYW5kbGVTYXZlOiAoKSA9PiB7IHZhciBfYTsgKF9hID0gdGhpcy5zZXR0aW5nc0hhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zYXZlU2V0dGluZ3MoKTsgfSxcbiAgICAgICAgICAgIGhhbmRsZUNhbmNlbDogKCkgPT4geyB2YXIgX2E7IChfYSA9IHRoaXMuc2V0dGluZ3NIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGlkZU1vZGFsKCk7IH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaGlzdG9yeUhhbmRsZXJDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICB1cGRhdGVUaXRsZUlucHV0OiAodGl0bGUpID0+IHRoaXMudWlNYW5hZ2VyLnVwZGF0ZVRpdGxlSW5wdXQodGl0bGUpLFxuICAgICAgICAgICAgY2xlYXJNZXNzYWdlQ29udGFpbmVyOiAoKSA9PiB0aGlzLnVpTWFuYWdlci5jbGVhck1lc3NhZ2VDb250YWluZXIoKSxcbiAgICAgICAgICAgIGFkZFJlbmRlcmVkTWVzc2FnZTogKG1lc3NhZ2VFbGVtZW50KSA9PiB0aGlzLnVpTWFuYWdlci5hZGRDaGF0TWVzc2FnZUVsZW1lbnQobWVzc2FnZUVsZW1lbnQpXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGlucHV0SGFuZGxlckNhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIGhhbmRsZVNlbmRNZXNzYWdlOiAobWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuaGFuZGxlU2VuZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNZXNzYWdlSGFuZGxlciBub3QgaW5pdGlhbGl6ZWQgd2hlbiB0cnlpbmcgdG8gc2VuZCBtZXNzYWdlIGZyb20gSW5wdXRIYW5kbGVyJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dQb3B1cE1lbnU6IChsZWZ0LCB0b3ApID0+IHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KGxlZnQsIHRvcCksXG4gICAgICAgICAgICBoaWRlUG9wdXBNZW51OiAoKSA9PiB0aGlzLnBvcHVwTWVudU1hbmFnZXIuaGlkZVBvcHVwTWVudSgpLFxuICAgICAgICAgICAgdXBkYXRlUGxhY2Vob2xkZXI6IChpc01hcmtkb3duKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVXNlIGRhdGFzZXQgZm9yIGRhdGEtcGxhY2Vob2xkZXIgYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cy5pbnB1dEZpZWxkLmRhdGFzZXQucGxhY2Vob2xkZXIgPSBpc01hcmtkb3duID8gJ0VudGVyIG1hcmtkb3duLi4uJyA6ICdBc2sgYW55dGhpbmcuLi4nO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZUlucHV0RXhwYW5zaW9uVUk6IChpc0V4cGFuZGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYnV0dG9uID0gdGhpcy5sYXlvdXRFbGVtZW50cy5leHBhbmRCdXR0b247XG4gICAgICAgICAgICAgICAgLy8gQ2xlYXIgZXhpc3RpbmcgY29udGVudCAodGV4dCBvciBvbGQgaWNvbilcbiAgICAgICAgICAgICAgICB3aGlsZSAoYnV0dG9uLmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnJlbW92ZUNoaWxkKGJ1dHRvbi5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBhcHByb3ByaWF0ZSBpY29uIHVzaW5nIExhYkljb24ucmVzb2x2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGljb24gPSBpc0V4cGFuZGVkXG4gICAgICAgICAgICAgICAgICAgID8gdWlfY29tcG9uZW50c18xLkxhYkljb24ucmVzb2x2ZSh7IGljb246ICd1aS1jb21wb25lbnRzOmNhcmV0LXVwJyB9KVxuICAgICAgICAgICAgICAgICAgICA6IHVpX2NvbXBvbmVudHNfMS5MYWJJY29uLnJlc29sdmUoeyBpY29uOiAndWktY29tcG9uZW50czpjYXJldC1kb3duJyB9KTtcbiAgICAgICAgICAgICAgICBpY29uLmVsZW1lbnQoeyBjb250YWluZXI6IGJ1dHRvbiwgdGFnOiAnc3BhbicgfSk7IC8vIEFkZCBpY29uIHRvIGJ1dHRvblxuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aXRsZSBmb3IgYWNjZXNzaWJpbGl0eVxuICAgICAgICAgICAgICAgIGJ1dHRvbi50aXRsZSA9IGlzRXhwYW5kZWQgPyAnQ29sbGFwc2UgaW5wdXQnIDogJ0V4cGFuZCBpbnB1dCc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Q29kZVJlZk1hcDogKCkgPT4geyB2YXIgX2E7IHJldHVybiAoKF9hID0gdGhpcy5pbnB1dEhhbmRsZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRDb2RlUmVmZXJlbmNlTWFwKCkpIHx8IG5ldyBNYXAoKTsgfSxcbiAgICAgICAgICAgIHJlc2V0Q29kZVJlZk1hcDogKCkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSB0aGlzLmlucHV0SGFuZGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc2V0Q29kZVJlZmVyZW5jZXMoKTsgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzaG9ydGN1dENhbGxiYWNrcyA9IHtcbiAgICAgICAgICAgIHNob3dJbmRpY2F0b3I6ICh0ZXh0KSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMudWlNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2hvd0luZGljYXRvcih0ZXh0KTsgfSxcbiAgICAgICAgICAgIGFwcGVuZFRvSW5wdXQ6ICh0ZXh0KSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYXBwZW5kVG9JbnB1dCh0ZXh0KTsgfSxcbiAgICAgICAgICAgIHNob3dXaWRnZXQ6ICgpID0+IHsgaWYgKHRoaXMuaXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgICAgIH0gfSxcbiAgICAgICAgICAgIGZvY3VzSW5wdXQ6ICgpID0+IHsgdmFyIF9hLCBfYjsgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMubGF5b3V0RWxlbWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbnB1dEZpZWxkKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZm9jdXMoKTsgfVxuICAgICAgICB9O1xuICAgICAgICAvLyAtLS0gMy4gQnVpbGQgVUkgTGF5b3V0IC0tLVxuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzID0gKDAsIGxheW91dF9idWlsZGVyXzEuYnVpbGRMYXlvdXQpKHtcbiAgICAgICAgICAgIG9uTmV3Q2hhdENsaWNrOiBjcmVhdGVOZXdDaGF0Q2FsbGJhY2ssXG4gICAgICAgICAgICBvbkhpc3RvcnlUb2dnbGVDbGljazogdG9nZ2xlSGlzdG9yeUNhbGxiYWNrLFxuICAgICAgICAgICAgb25TZXR0aW5nc0NsaWNrOiBzaG93U2V0dGluZ3NDYWxsYmFjayxcbiAgICAgICAgICAgIG9uVGl0bGVDaGFuZ2U6IHVwZGF0ZVRpdGxlQ2FsbGJhY2ssXG4gICAgICAgICAgICBvbkF0QnV0dG9uQ2xpY2s6IHNob3dQb3B1cE1lbnVDYWxsYmFjayxcbiAgICAgICAgICAgIG9uU2VuZE1lc3NhZ2VDbGljazogc2VuZE1lc3NhZ2VWaWFCdXR0b25DYWxsYmFjayxcbiAgICAgICAgICAgIG9uTWFya2Rvd25Ub2dnbGVDaGFuZ2U6IHRvZ2dsZU1hcmtkb3duTW9kZUNhbGxiYWNrLFxuICAgICAgICAgICAgb25FeHBhbmRUb2dnbGVDbGljazogdG9nZ2xlRXhwYW5kSW5wdXRDYWxsYmFjayxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciA9ICgwLCBzZXR0aW5nc19tb2RhbF8xLmNyZWF0ZVNldHRpbmdzTW9kYWxFbGVtZW50KShzZXR0aW5nc01vZGFsQ2FsbGJhY2tzKTtcbiAgICAgICAgLy8gLS0tIEluaXRpYWxpemUgU3RhdGUgTWFuYWdlcnMgLS0tXG4gICAgICAgIHRoaXMuY2hhdFN0YXRlID0gbmV3IGNoYXRfc3RhdGVfMS5DaGF0U3RhdGUoKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1N0YXRlID0gbmV3IHNldHRpbmdzX3N0YXRlXzEuU2V0dGluZ3NTdGF0ZSgpO1xuICAgICAgICAvLyAtLS0gSW5pdGlhbGl6ZSBDb3JlIENvbXBvbmVudHMgLS0tXG4gICAgICAgIHRoaXMuYXBpQ2xpZW50ID0gbmV3IGFwaV9jbGllbnRfMS5BcGlDbGllbnQoKTtcbiAgICAgICAgLy8gLS0tIEluaXRpYWxpemUgVUkgTWFuYWdlciAobmVlZHMgZGVwZW5kZW5jaWVzKSAtLS1cbiAgICAgICAgY29uc3QgdWlNYW5hZ2VyQ2FsbGJhY2tzID0ge1xuICAgICAgICAgICAgaGFuZGxlTmV3Q2hhdDogdGhpcy5oYW5kbGVOZXdDaGF0LFxuICAgICAgICAgICAgaGFuZGxlVG9nZ2xlSGlzdG9yeTogdGhpcy5oYW5kbGVUb2dnbGVIaXN0b3J5LFxuICAgICAgICAgICAgaGFuZGxlU2VuZE1lc3NhZ2U6IHRoaXMuaGFuZGxlU2VuZE1lc3NhZ2UsXG4gICAgICAgICAgICBoYW5kbGVTaG93U2V0dGluZ3M6IHRoaXMuaGFuZGxlU2hvd1NldHRpbmdzLFxuICAgICAgICAgICAgaGFuZGxlU2hvd1BvcHVwTWVudTogdGhpcy5oYW5kbGVTaG93UG9wdXBNZW51LFxuICAgICAgICAgICAgaGFuZGxlVXBkYXRlVGl0bGU6IHRoaXMuaGFuZGxlVXBkYXRlVGl0bGVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy51aU1hbmFnZXIgPSBuZXcgdWlfbWFuYWdlcl8xLlVJTWFuYWdlcih0aGlzLnBvcHVwTWVudU1hbmFnZXIsIHVpTWFuYWdlckNhbGxiYWNrcywgdGhpcy5sYXlvdXRFbGVtZW50cyk7XG4gICAgICAgIC8vIC0tLSA0LiBJbml0aWFsaXplIEhhbmRsZXJzICh1c2luZyBVSSBlbGVtZW50cyBhbmQgY29yZSBjb21wb25lbnRzKSAtLS1cbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIgPSBuZXcgaW5wdXRfaGFuZGxlcl8xLklucHV0SGFuZGxlcih0aGlzLmxheW91dEVsZW1lbnRzLmlucHV0RmllbGQsIGlucHV0SGFuZGxlckNhbGxiYWNrcyk7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIgPSBuZXcgbWVzc2FnZV9oYW5kbGVyXzEuTWVzc2FnZUhhbmRsZXIodGhpcy5hcGlDbGllbnQsIHRoaXMuY2hhdFN0YXRlLCB0aGlzLnVpTWFuYWdlciwgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzLCB0aGlzLmlucHV0SGFuZGxlcik7XG4gICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZXIgPSBuZXcgaGlzdG9yeV9oYW5kbGVyXzEuSGlzdG9yeUhhbmRsZXIodGhpcy5jaGF0U3RhdGUsIHRoaXMudWlNYW5hZ2VyLCBoaXN0b3J5SGFuZGxlckNhbGxiYWNrcywgbWVzc2FnZVJlbmRlcmVyQ2FsbGJhY2tzKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc0hhbmRsZXIgPSBuZXcgc2V0dGluZ3NfaGFuZGxlcl8xLlNldHRpbmdzSGFuZGxlcih0aGlzLnNldHRpbmdzU3RhdGUsIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lciwgdGhpcy51aU1hbmFnZXIpO1xuICAgICAgICAvLyAtLS0gNS4gRmluYWwgU2V0dXAgKEF0dGFjaCBldmVudCBsaXN0ZW5lcnMsIGNvbm5lY3Qgc2lnbmFscywgZXRjLikgLS0tXG4gICAgICAgIGNvbnN0IGluaXRpYWxDaGF0SWQgPSB0aGlzLmNoYXRTdGF0ZS5nZXRDdXJyZW50Q2hhdElkKCk7XG4gICAgICAgIGlmIChpbml0aWFsQ2hhdElkKSB7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlIYW5kbGVyLmxvYWRDaGF0KGluaXRpYWxDaGF0SWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHRoaXMuY2hhdFN0YXRlLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgICAgIHRoaXMuaGlzdG9yeUhhbmRsZXIubG9hZENoYXQobmV3Q2hhdC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0dXAgZ2xvYmFsIGtleWJvYXJkIHNob3J0Y3V0cyB3aXRoIHRoZSBVSU1hbmFnZXIgZm9yIHByb3BlciBAIGtleSBoYW5kbGluZ1xuICAgICAgICAoMCwgc2hvcnRjdXRfaGFuZGxlcl8xLnNldHVwU2hvcnRjdXRzKSh0aGlzLmlucHV0SGFuZGxlciwgdGhpcy5wb3B1cE1lbnVNYW5hZ2VyLCBzaG9ydGN1dENhbGxiYWNrcyk7XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmxheW91dEVsZW1lbnRzLm1haW5FbGVtZW50KTtcbiAgICAgICAgdGhpcy5ub2RlLmFwcGVuZENoaWxkKHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAodGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHNob3J0Y3V0X2hhbmRsZXJfMS5yZW1vdmVTaG9ydGN1dHMpKCk7XG4gICAgICAgIChfYSA9IHRoaXMuaW5wdXRIYW5kbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlzcG9zZSgpO1xuICAgICAgICAoX2IgPSB0aGlzLnBvcHVwTWVudU1hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kaXNwb3NlKCk7XG4gICAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG59IC8vIEVuZCBvZiBTaW1wbGVTaWRlYmFyV2lkZ2V0IGNsYXNzXG5leHBvcnRzLlNpbXBsZVNpZGViYXJXaWRnZXQgPSBTaW1wbGVTaWRlYmFyV2lkZ2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNoYXRTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IHV1aWRfMSA9IHJlcXVpcmUoXCJ1dWlkXCIpO1xuLyoqXG4gKiBNYW5hZ2VzIHRoZSBzdGF0ZSBvZiBjaGF0IGhpc3RvcnkgYW5kIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gKi9cbmNsYXNzIENoYXRTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeSA9IFtdO1xuICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBudWxsO1xuICAgICAgICAvLyBQb3RlbnRpYWw6IExvYWQgaW5pdGlhbCBzdGF0ZSBmcm9tIHN0b3JhZ2UgaWYgcGVyc2lzdGVuY2UgaXMgYWRkZWQgbGF0ZXJcbiAgICAgICAgaWYgKHRoaXMuY2hhdEhpc3RvcnkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU5ld0NoYXQoJ1dlbGNvbWUgQ2hhdCcpOyAvLyBDcmVhdGUgYW4gaW5pdGlhbCBjaGF0IGlmIG5vbmUgZXhpc3RzXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSAoKF9hID0gdGhpcy5jaGF0SGlzdG9yeVswXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlkKSB8fCBudWxsOyAvLyBTZXQgY3VycmVudCBjaGF0IHRvIHRoZSBmaXJzdCBvbmVcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvbiBhbmQgc2V0cyBpdCBhcyB0aGUgY3VycmVudCBjaGF0LlxuICAgICAqIEBwYXJhbSB0aXRsZSAtIFRoZSBpbml0aWFsIHRpdGxlIGZvciB0aGUgbmV3IGNoYXQuXG4gICAgICogQHJldHVybnMgVGhlIG5ld2x5IGNyZWF0ZWQgY2hhdCBpdGVtLlxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQodGl0bGUgPSAnTmV3IENoYXQnKSB7XG4gICAgICAgIGNvbnN0IGNoYXRJZCA9IGBjaGF0LSR7KDAsIHV1aWRfMS52NCkoKX1gOyAvLyBVc2UgVVVJRCBmb3IgYmV0dGVyIHVuaXF1ZW5lc3NcbiAgICAgICAgY29uc3QgbmV3Q2hhdCA9IHtcbiAgICAgICAgICAgIGlkOiBjaGF0SWQsXG4gICAgICAgICAgICB0aXRsZTogdGl0bGUsXG4gICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICAvLyBPcHRpb25hbDogQWRkIHRpbWVzdGFtcCBvciBvdGhlciBtZXRhZGF0YSBpZiBuZWVkZWQgbGF0ZXJcbiAgICAgICAgICAgIC8vIGNyZWF0ZWRBdDogRGF0ZTsgXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhdElkID0gY2hhdElkO1xuICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRlZCBuZXcgY2hhdDonLCBuZXdDaGF0KTtcbiAgICAgICAgcmV0dXJuIG5ld0NoYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGN1cnJlbnRseSBhY3RpdmUgY2hhdCBJRC5cbiAgICAgKiBAcGFyYW0gY2hhdElkIC0gVGhlIElEIG9mIHRoZSBjaGF0IHRvIHNldCBhcyBjdXJyZW50LlxuICAgICAqL1xuICAgIHNldEN1cnJlbnRDaGF0SWQoY2hhdElkKSB7XG4gICAgICAgIGlmICh0aGlzLmNoYXRIaXN0b3J5LnNvbWUoY2hhdCA9PiBjaGF0LmlkID09PSBjaGF0SWQpKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYENoYXQgSUQgJHtjaGF0SWR9IG5vdCBmb3VuZCBpbiBoaXN0b3J5LmApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIElEIG9mIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgY2hhdCBJRCBvciBudWxsIGlmIG5vbmUgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRDaGF0SWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHJpZXZlcyBhIHNwZWNpZmljIGNoYXQgYnkgaXRzIElELlxuICAgICAqIEBwYXJhbSBjaGF0SWQgLSBUaGUgSUQgb2YgdGhlIGNoYXQgdG8gcmV0cmlldmUuXG4gICAgICogQHJldHVybnMgVGhlIGNoYXQgaXRlbSBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldENoYXRCeUlkKGNoYXRJZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGNoYXQgPT4gY2hhdC5pZCA9PT0gY2hhdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0cmlldmVzIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQgaXRlbS5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBjaGF0IGl0ZW0gb3IgdW5kZWZpbmVkIGlmIG5vIGNoYXQgaXMgYWN0aXZlIG9yIGZvdW5kLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0KCkge1xuICAgICAgICBpZiAoIXRoaXMuY3VycmVudENoYXRJZCkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDaGF0QnlJZCh0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudGx5IGFjdGl2ZSBjaGF0LlxuICAgICAqIEBwYXJhbSBuZXdUaXRsZSAtIFRoZSBuZXcgdGl0bGUgZm9yIHRoZSBjaGF0LlxuICAgICAqL1xuICAgIHVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUobmV3VGl0bGUpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXQgPSB0aGlzLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgY3VycmVudENoYXQudGl0bGUgPSBuZXdUaXRsZTtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVcGRhdGVkIHRpdGxlIGZvciBjaGF0ICR7dGhpcy5jdXJyZW50Q2hhdElkfSB0byBcIiR7bmV3VGl0bGV9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IHVwZGF0ZSB0aXRsZTogTm8gY3VycmVudCBjaGF0IHNlbGVjdGVkLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBtZXNzYWdlIHRvIHRoZSBjdXJyZW50bHkgYWN0aXZlIGNoYXQuXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSBvYmplY3QgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2VUb0N1cnJlbnRDaGF0KG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgY3VycmVudENoYXQgPSB0aGlzLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIGlmIChjdXJyZW50Q2hhdCkge1xuICAgICAgICAgICAgY3VycmVudENoYXQubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignQ2Fubm90IGFkZCBtZXNzYWdlOiBObyBjdXJyZW50IGNoYXQgc2VsZWN0ZWQuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgY3VycmVudGx5IGFjdGl2ZSBjaGF0LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG1lc3NhZ2VzIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vIGNoYXQgaXMgYWN0aXZlLlxuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0TWVzc2FnZXMoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRDaGF0ID0gdGhpcy5nZXRDdXJyZW50Q2hhdCgpO1xuICAgICAgICByZXR1cm4gY3VycmVudENoYXQgPyBjdXJyZW50Q2hhdC5tZXNzYWdlcyA6IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBlbnRpcmUgY2hhdCBoaXN0b3J5LlxuICAgICAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGFsbCBjaGF0IGhpc3RvcnkgaXRlbXMuXG4gICAgICovXG4gICAgZ2V0Q2hhdEhpc3RvcnkoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5jaGF0SGlzdG9yeV07IC8vIFJldHVybiBhIGNvcHkgdG8gcHJldmVudCBkaXJlY3QgbW9kaWZpY2F0aW9uXG4gICAgfVxufVxuZXhwb3J0cy5DaGF0U3RhdGUgPSBDaGF0U3RhdGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2V0dGluZ3NTdGF0ZSA9IHZvaWQgMDtcbmNvbnN0IFNFVFRJTkdTX1NUT1JBR0VfS0VZID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MnO1xuLyoqXG4gKiBNYW5hZ2VzIGxvYWRpbmcgYW5kIHNhdmluZyBhcHBsaWNhdGlvbiBzZXR0aW5ncyB0byBsb2NhbFN0b3JhZ2UuXG4gKi9cbmNsYXNzIFNldHRpbmdzU3RhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXR0aW5ncyA9IG51bGw7XG4gICAgICAgIHRoaXMuY3VycmVudFNldHRpbmdzID0gdGhpcy5sb2FkU2V0dGluZ3MoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgc2V0dGluZ3MgZnJvbSBsb2NhbFN0b3JhZ2UuXG4gICAgICogQHJldHVybnMgVGhlIGxvYWRlZCBzZXR0aW5ncyBvciBudWxsIGlmIG5vbmUgYXJlIHNhdmVkIG9yIGFuIGVycm9yIG9jY3Vycy5cbiAgICAgKi9cbiAgICBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IHNhdmVkU2V0dGluZ3MgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShTRVRUSU5HU19TVE9SQUdFX0tFWSk7XG4gICAgICAgIGlmIChzYXZlZFNldHRpbmdzKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNldHRpbmdzID0gSlNPTi5wYXJzZShzYXZlZFNldHRpbmdzKTtcbiAgICAgICAgICAgICAgICAvLyBCYXNpYyB2YWxpZGF0aW9uIChjYW4gYmUgZXhwYW5kZWQpXG4gICAgICAgICAgICAgICAgaWYgKHNldHRpbmdzICYmIHNldHRpbmdzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFNldHRpbmdzID0gc2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdMb2FkZWQgc2V0dGluZ3M6JywgdGhpcy5jdXJyZW50U2V0dGluZ3MpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2V0dGluZ3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgbG9hZGluZyBzYXZlZCBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgbG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0oU0VUVElOR1NfU1RPUkFHRV9LRVkpOyAvLyBDbGVhciBjb3JydXB0ZWQgZGF0YVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyB2YWxpZCBzZXR0aW5ncyBmb3VuZCBpbiBsb2NhbFN0b3JhZ2UuJyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTYXZlcyB0aGUgcHJvdmlkZWQgc2V0dGluZ3MgdG8gbG9jYWxTdG9yYWdlLlxuICAgICAqIEBwYXJhbSBzZXR0aW5ncyAtIFRoZSBzZXR0aW5ncyBvYmplY3QgdG8gc2F2ZS5cbiAgICAgKi9cbiAgICBzYXZlU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKFNFVFRJTkdTX1NUT1JBR0VfS0VZLCBKU09OLnN0cmluZ2lmeShzZXR0aW5ncykpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50U2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBzZXR0aW5ncyk7IC8vIFVwZGF0ZSBpbnRlcm5hbCBzdGF0ZVxuICAgICAgICAgICAgY29uc29sZS5sb2coJ1NldHRpbmdzIHNhdmVkOicsIHRoaXMuY3VycmVudFNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHNhdmluZyBzZXR0aW5nczonLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBPcHRpb25hbDogTm90aWZ5IHVzZXIgb2Ygc2F2ZSBmYWlsdXJlXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudGx5IGxvYWRlZCBzZXR0aW5ncy5cbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBzZXR0aW5ncyBvYmplY3Qgb3IgbnVsbCBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldFNldHRpbmdzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U2V0dGluZ3MgPyBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmN1cnJlbnRTZXR0aW5ncykgOiBudWxsOyAvLyBSZXR1cm4gYSBjb3B5XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBzcGVjaWZpYyBzZXR0aW5nIHZhbHVlLlxuICAgICAqIEBwYXJhbSBrZXkgLSBUaGUga2V5IG9mIHRoZSBzZXR0aW5nIHRvIHJldHJpZXZlLlxuICAgICAqIEByZXR1cm5zIFRoZSB2YWx1ZSBvZiB0aGUgc2V0dGluZyBvciB1bmRlZmluZWQgaWYgbm90IGZvdW5kLlxuICAgICAqL1xuICAgIGdldFNldHRpbmcoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRTZXR0aW5ncyA/IHRoaXMuY3VycmVudFNldHRpbmdzW2tleV0gOiB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0cy5TZXR0aW5nc1N0YXRlID0gU2V0dGluZ3NTdGF0ZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jcmVhdGVEaXYgPSBjcmVhdGVEaXY7XG5leHBvcnRzLmNyZWF0ZUJ1dHRvbiA9IGNyZWF0ZUJ1dHRvbjtcbmV4cG9ydHMuY3JlYXRlU3BhbiA9IGNyZWF0ZVNwYW47XG5leHBvcnRzLmNyZWF0ZVRleHRBcmVhID0gY3JlYXRlVGV4dEFyZWE7XG5leHBvcnRzLmNyZWF0ZUlucHV0RWxlbWVudCA9IGNyZWF0ZUlucHV0RWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlSW1hZ2VFbGVtZW50ID0gY3JlYXRlSW1hZ2VFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVBbmNob3JFbGVtZW50ID0gY3JlYXRlQW5jaG9yRWxlbWVudDtcbmV4cG9ydHMuY3JlYXRlTGFiZWxFbGVtZW50ID0gY3JlYXRlTGFiZWxFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVGb3JtRWxlbWVudCA9IGNyZWF0ZUZvcm1FbGVtZW50O1xuLyoqXG4gKiBHZW5lcmljIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhbiBIVE1MRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0gdGFnTmFtZSAtIFRoZSBIVE1MIHRhZyBuYW1lIChlLmcuLCAnZGl2JywgJ2J1dHRvbicpLlxuICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIGZvciB0aGUgZWxlbWVudC5cbiAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIEhUTUxFbGVtZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZ05hbWUsIG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZ05hbWUpO1xuICAgIGlmIChvcHRpb25zLmlkKSB7XG4gICAgICAgIGVsZW1lbnQuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbGFzc2VzKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNUb0FkZCA9IEFycmF5LmlzQXJyYXkob3B0aW9ucy5jbGFzc2VzKVxuICAgICAgICAgICAgPyBvcHRpb25zLmNsYXNzZXNcbiAgICAgICAgICAgIDogb3B0aW9ucy5jbGFzc2VzLnNwbGl0KCcgJykuZmlsdGVyKGMgPT4gYyk7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZCguLi5jbGFzc2VzVG9BZGQpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy50ZXh0KSB7XG4gICAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSBvcHRpb25zLnRleHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaHRtbCkge1xuICAgICAgICBlbGVtZW50LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbDsgLy8gQmUgY2F1dGlvdXMgd2l0aCBIVE1MIGluamVjdGlvblxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIG9wdGlvbnMuYXR0cmlidXRlcykge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoa2V5LCBvcHRpb25zLmF0dHJpYnV0ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuc3R5bGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb3B0aW9ucy5zdHlsZSkge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3R5bGUuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGVba2V5XSA9IG9wdGlvbnMuc3R5bGVba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgICBvcHRpb25zLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xufVxuLyoqIENyZWF0ZXMgYSA8ZGl2PiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlRGl2KG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdkaXYnLCBvcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGEgPGJ1dHRvbj4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvbihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnYnV0dG9uJywgb3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhIDxzcGFuPiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlU3BhbihvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnc3BhbicsIG9wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYSA8dGV4dGFyZWE+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVUZXh0QXJlYShvcHRpb25zID0ge30pIHtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnLCBvcHRpb25zKTtcbn1cbi8qKiBDcmVhdGVzIGFuIDxpbnB1dD4gZWxlbWVudC4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0RWxlbWVudChvcHRpb25zID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gRW5zdXJlIHR5cGUgaXMgc2V0IGlmIHByb3ZpZGVkIGluIGF0dHJpYnV0ZXMsIG90aGVyd2lzZSBkZWZhdWx0IG9yIGxlYXZlIHVuc2V0XG4gICAgaWYgKChfYSA9IG9wdGlvbnMuYXR0cmlidXRlcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnR5cGUpIHtcbiAgICAgICAgLy8gVHlwZSBpcyBhbHJlYWR5IHNldCBpbiBhdHRyaWJ1dGVzLCBkbyBub3RoaW5nIGV4dHJhXG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMpIHtcbiAgICAgICAgb3B0aW9ucy5hdHRyaWJ1dGVzID0geyB0eXBlOiAndGV4dCcgfTsgLy8gRGVmYXVsdCB0byB0ZXh0IGlmIG5vIGF0dHJpYnV0ZXMgc3BlY2lmaWVkXG4gICAgfVxuICAgIGVsc2UgaWYgKCFvcHRpb25zLmF0dHJpYnV0ZXMudHlwZSkge1xuICAgICAgICBvcHRpb25zLmF0dHJpYnV0ZXMudHlwZSA9ICd0ZXh0JzsgLy8gRGVmYXVsdCB0byB0ZXh0IGlmIHR5cGUgaXMgbm90IGluIGF0dHJpYnV0ZXNcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2lucHV0Jywgb3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhbiA8aW1nPiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlSW1hZ2VFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBpbWdPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgaW1nT3B0aW9ucy5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmF0dHJpYnV0ZXMpLCB7IHNyYzogb3B0aW9ucy5zcmMgfSk7XG4gICAgaWYgKG9wdGlvbnMuYWx0KSB7XG4gICAgICAgIGltZ09wdGlvbnMuYXR0cmlidXRlcy5hbHQgPSBvcHRpb25zLmFsdDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2ltZycsIGltZ09wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYW4gPGE+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVBbmNob3JFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBhbmNob3JPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyk7XG4gICAgYW5jaG9yT3B0aW9ucy5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLmF0dHJpYnV0ZXMpLCB7IGhyZWY6IG9wdGlvbnMuaHJlZiB9KTtcbiAgICByZXR1cm4gY3JlYXRlRWxlbWVudCgnYScsIGFuY2hvck9wdGlvbnMpO1xufVxuLyoqIENyZWF0ZXMgYSA8bGFiZWw+IGVsZW1lbnQuICovXG5mdW5jdGlvbiBjcmVhdGVMYWJlbEVsZW1lbnQob3B0aW9ucykge1xuICAgIGNvbnN0IGxhYmVsT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpO1xuICAgIGlmIChvcHRpb25zLmh0bWxGb3IpIHtcbiAgICAgICAgbGFiZWxPcHRpb25zLmF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMuYXR0cmlidXRlcyksIHsgZm9yOiBvcHRpb25zLmh0bWxGb3IgfSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdsYWJlbCcsIGxhYmVsT3B0aW9ucyk7XG59XG4vKiogQ3JlYXRlcyBhIDxmb3JtPiBlbGVtZW50LiAqL1xuZnVuY3Rpb24gY3JlYXRlRm9ybUVsZW1lbnQob3B0aW9ucyA9IHt9KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2Zvcm0nLCBvcHRpb25zKTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5idWlsZExheW91dCA9IGJ1aWxkTGF5b3V0O1xuY29uc3QgZG9tX2VsZW1lbnRzXzEgPSByZXF1aXJlKFwiLi9kb20tZWxlbWVudHNcIik7XG4vKipcbiAqIEJ1aWxkcyB0aGUgbWFpbiBIVE1MIHN0cnVjdHVyZSBmb3IgdGhlIHNpZGViYXIgd2lkZ2V0LlxuICpcbiAqIEBwYXJhbSBjYWxsYmFja3MgLSBBbiBvYmplY3QgY29udGFpbmluZyBjYWxsYmFjayBmdW5jdGlvbnMgZm9yIHZhcmlvdXMgVUkgaW50ZXJhY3Rpb25zLlxuICogQHJldHVybnMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIG1haW4gd2lkZ2V0IEhUTUxFbGVtZW50IGFuZCByZWZlcmVuY2VzIHRvIGtleSBpbnRlcmFjdGl2ZSBlbGVtZW50cy5cbiAqL1xuZnVuY3Rpb24gYnVpbGRMYXlvdXQoY2FsbGJhY2tzID0ge30pIHtcbiAgICAvLyAtLS0gTWFpbiBDb250ZW50IFdyYXBwZXIgLS0tXG4gICAgY29uc3QgbWFpbkVsZW1lbnQgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7XG4gICAgICAgIGNsYXNzZXM6ICdqcC1sbG0tZXh0LWNvbnRlbnQtd3JhcHBlcidcbiAgICB9KTtcbiAgICAvLyAtLS0gVGl0bGUgQmFyIC0tLVxuICAgIGNvbnN0IHRpdGxlQ29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC10aXRsZS1jb250YWluZXInIH0pO1xuICAgIGNvbnN0IHRpdGxlSW5wdXQgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlSW5wdXRFbGVtZW50KSh7XG4gICAgICAgIGlkOiAnY2hhdC10aXRsZS1pbnB1dCcsXG4gICAgICAgIGNsYXNzZXM6ICdjaGF0LXRpdGxlLWlucHV0JyxcbiAgICAgICAgYXR0cmlidXRlczogeyB0eXBlOiAndGV4dCcsIHBsYWNlaG9sZGVyOiAnQ2hhdCB0aXRsZScsIHZhbHVlOiAnTmV3IENoYXQnIH1cbiAgICB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uVGl0bGVDaGFuZ2UpIHtcbiAgICAgICAgdGl0bGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiBjYWxsYmFja3Mub25UaXRsZUNoYW5nZSh0aXRsZUlucHV0LnZhbHVlKSk7XG4gICAgfVxuICAgIHRpdGxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlSW5wdXQpO1xuICAgIC8vIC0tLSBNZXNzYWdlICYgSGlzdG9yeSBDb250YWluZXJzIC0tLVxuICAgIGNvbnN0IG1lc3NhZ2VDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LW1lc3NhZ2UtY29udGFpbmVyJyB9KTtcbiAgICBjb25zdCBoaXN0b3J5Q29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoe1xuICAgICAgICBjbGFzc2VzOiAnanAtbGxtLWV4dC1oaXN0b3J5LWNvbnRhaW5lcicsXG4gICAgICAgIHN0eWxlOiB7IGRpc3BsYXk6ICdub25lJyB9IC8vIEhpZGRlbiBieSBkZWZhdWx0XG4gICAgfSk7XG4gICAgLy8gLS0tIEJvdHRvbSBCYXIgQXJlYSAtLS1cbiAgICBjb25zdCBib3R0b21CYXJDb250YWluZXIgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItY29udGFpbmVyJyB9KTtcbiAgICAvLyBSb3cgMTogQ29udHJvbHMgKE1hcmtkb3duIFRvZ2dsZSwgQCwgRXhwYW5kLCBTZXR0aW5ncylcbiAgICBjb25zdCBjb250cm9sc1JvdyA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtYm90dG9tLWJhci1yb3cganAtbGxtLWV4dC1jb250cm9scy1yb3cnIH0pO1xuICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC1jb250cm9scy1jb250YWluZXInIH0pO1xuICAgIC8vIE1hcmtkb3duIFRvZ2dsZVxuICAgIGNvbnN0IHRvZ2dsZUNvbnRhaW5lciA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHsgY2xhc3NlczogJ2pwLWxsbS1leHQtdG9nZ2xlLWNvbnRhaW5lcicgfSk7XG4gICAgY29uc3QgbWFya2Rvd25Ub2dnbGVCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlSW5wdXRFbGVtZW50KSh7XG4gICAgICAgIGlkOiAnbWFya2Rvd24tdG9nZ2xlJyxcbiAgICAgICAgYXR0cmlidXRlczogeyB0eXBlOiAnY2hlY2tib3gnIH1cbiAgICB9KTtcbiAgICBjb25zdCB0b2dnbGVMYWJlbCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVMYWJlbEVsZW1lbnQpKHtcbiAgICAgICAgdGV4dDogJ01hcmtkb3duIG1vZGUnLFxuICAgICAgICBodG1sRm9yOiAnbWFya2Rvd24tdG9nZ2xlJ1xuICAgIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25NYXJrZG93blRvZ2dsZUNoYW5nZSkge1xuICAgICAgICBtYXJrZG93blRvZ2dsZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBjYWxsYmFja3Mub25NYXJrZG93blRvZ2dsZUNoYW5nZShtYXJrZG93blRvZ2dsZUJ1dHRvbi5jaGVja2VkKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvZ2dsZUNvbnRhaW5lci5hcHBlbmRDaGlsZChtYXJrZG93blRvZ2dsZUJ1dHRvbik7XG4gICAgdG9nZ2xlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRvZ2dsZUxhYmVsKTtcbiAgICAvLyBBY3Rpb24gQnV0dG9ucyAoQCwgRXhwYW5kLCBTZXR0aW5ncylcbiAgICBjb25zdCBhY3Rpb25CdXR0b25zQ29udGFpbmVyID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC1hY3Rpb24tYnV0dG9ucy1jb250YWluZXInIH0pO1xuICAgIGNvbnN0IGF0QnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoeyB0ZXh0OiAnQCcsIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdCcm93c2UgY2VsbHMsIGNvZGUsIGZpbGVzLCBhbmQgbW9yZScgfSwgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25BdEJ1dHRvbkNsaWNrKSB7XG4gICAgICAgIGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FsbGJhY2tzLm9uQXRCdXR0b25DbGljayk7XG4gICAgfVxuICAgIGNvbnN0IGV4cGFuZEJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVCdXR0b24pKHsgdGV4dDogJ+KkoicsIGF0dHJpYnV0ZXM6IHsgdGl0bGU6ICdFeHBhbmQgaW5wdXQnIH0sIGNsYXNzZXM6ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJyB9KTtcbiAgICBpZiAoY2FsbGJhY2tzLm9uRXhwYW5kVG9nZ2xlQ2xpY2spIHtcbiAgICAgICAgZXhwYW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gY2FsbGJhY2tzLm9uRXhwYW5kVG9nZ2xlQ2xpY2soZXhwYW5kQnV0dG9uKSk7XG4gICAgfVxuICAgIGNvbnN0IHNldHRpbmdzQnV0dG9uID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZUJ1dHRvbikoeyB0ZXh0OiAn4pqZ77iPJywgYXR0cmlidXRlczogeyB0aXRsZTogJ1NldHRpbmdzJyB9LCBjbGFzc2VzOiAnanAtQnV0dG9uIGpwLWxsbS1leHQtYWN0aW9uLWJ1dHRvbicgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vblNldHRpbmdzQ2xpY2spIHtcbiAgICAgICAgc2V0dGluZ3NCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFja3Mub25TZXR0aW5nc0NsaWNrKTtcbiAgICB9XG4gICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhdEJ1dHRvbik7XG4gICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChleHBhbmRCdXR0b24pO1xuICAgIGFjdGlvbkJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoc2V0dGluZ3NCdXR0b24pO1xuICAgIGNvbnRyb2xzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRvZ2dsZUNvbnRhaW5lcik7XG4gICAgY29udHJvbHNDb250YWluZXIuYXBwZW5kQ2hpbGQoYWN0aW9uQnV0dG9uc0NvbnRhaW5lcik7XG4gICAgY29udHJvbHNSb3cuYXBwZW5kQ2hpbGQoY29udHJvbHNDb250YWluZXIpO1xuICAgIC8vIFJvdyAyOiBJbnB1dCBGaWVsZFxuICAgIGNvbnN0IGlucHV0Um93ID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoeyBjbGFzc2VzOiAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWlucHV0LXJvdycgfSk7XG4gICAgY29uc3QgaW5wdXRGaWVsZCA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ2pwLWxsbS1leHQtaW5wdXQtZmllbGQnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBjb250ZW50ZWRpdGFibGU6ICd0cnVlJyxcbiAgICAgICAgICAgIHJvbGU6ICd0ZXh0Ym94JyxcbiAgICAgICAgICAgICdhcmlhLW11bHRpbGluZSc6ICd0cnVlJyxcbiAgICAgICAgICAgICdkYXRhLXBsYWNlaG9sZGVyJzogJ0FzayBtZSBhbnl0aGluZy4uLidcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHsgbWluSGVpZ2h0OiAnMjBweCcsIG92ZXJmbG93WTogJ2hpZGRlbicgfVxuICAgIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25JbnB1dEZpZWxkS2V5UHJlc3MpIHtcbiAgICAgICAgaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGNhbGxiYWNrcy5vbklucHV0RmllbGRLZXlQcmVzcyk7XG4gICAgfVxuICAgIGlmIChjYWxsYmFja3Mub25JbnB1dEZpZWxkVmFsdWVDaGFuZ2UpIHtcbiAgICAgICAgaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdpbnB1dCcsICgpID0+IGNhbGxiYWNrcy5vbklucHV0RmllbGRWYWx1ZUNoYW5nZShpbnB1dEZpZWxkLnRleHRDb250ZW50IHx8ICcnKSk7XG4gICAgfVxuICAgIGlucHV0Um93LmFwcGVuZENoaWxkKGlucHV0RmllbGQpO1xuICAgIC8vIFJvdyAzOiBNYWluIEJ1dHRvbnMgKFNlbmQsIE5ldyBDaGF0LCBIaXN0b3J5KVxuICAgIGNvbnN0IGJ1dHRvbnNSb3cgPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlRGl2KSh7IGNsYXNzZXM6ICdqcC1sbG0tZXh0LWJvdHRvbS1iYXItcm93IGpwLWxsbS1leHQtYnV0dG9ucy1yb3cnIH0pO1xuICAgIGNvbnN0IHNlbmRCdXR0b24gPSAoMCwgZG9tX2VsZW1lbnRzXzEuY3JlYXRlQnV0dG9uKSh7XG4gICAgICAgIHRleHQ6ICdTZW5kJyxcbiAgICAgICAgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LXNlbmQtYnV0dG9uJ1xuICAgIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25TZW5kTWVzc2FnZUNsaWNrKSB7XG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjYWxsYmFja3Mub25TZW5kTWVzc2FnZUNsaWNrKTtcbiAgICB9XG4gICAgY29uc3QgbmV3Q2hhdEJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVCdXR0b24pKHtcbiAgICAgICAgdGV4dDogJysgTmV3IENoYXQnLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IHRpdGxlOiAnU3RhcnQgYSBuZXcgY2hhdCcgfSxcbiAgICAgICAgY2xhc3NlczogJ2pwLUJ1dHRvbiBqcC1sbG0tZXh0LWFjdGlvbi1idXR0b24nXG4gICAgfSk7XG4gICAgaWYgKGNhbGxiYWNrcy5vbk5ld0NoYXRDbGljaykge1xuICAgICAgICBuZXdDaGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2FsbGJhY2tzLm9uTmV3Q2hhdENsaWNrKTtcbiAgICB9XG4gICAgY29uc3QgaGlzdG9yeUJ1dHRvbiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVCdXR0b24pKHtcbiAgICAgICAgdGV4dDogJ0hpc3RvcnknLFxuICAgICAgICBhdHRyaWJ1dGVzOiB7IHRpdGxlOiAnVmlldyBjaGF0IGhpc3RvcnknIH0sXG4gICAgICAgIGNsYXNzZXM6ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJ1xuICAgIH0pO1xuICAgIGlmIChjYWxsYmFja3Mub25IaXN0b3J5VG9nZ2xlQ2xpY2spIHtcbiAgICAgICAgaGlzdG9yeUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNhbGxiYWNrcy5vbkhpc3RvcnlUb2dnbGVDbGljayk7XG4gICAgfVxuICAgIGJ1dHRvbnNSb3cuYXBwZW5kQ2hpbGQoc2VuZEJ1dHRvbik7XG4gICAgYnV0dG9uc1Jvdy5hcHBlbmRDaGlsZChuZXdDaGF0QnV0dG9uKTtcbiAgICBidXR0b25zUm93LmFwcGVuZENoaWxkKGhpc3RvcnlCdXR0b24pO1xuICAgIC8vIEFzc2VtYmxlIEJvdHRvbSBCYXJcbiAgICBib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoY29udHJvbHNSb3cpO1xuICAgIGJvdHRvbUJhckNvbnRhaW5lci5hcHBlbmRDaGlsZChpbnB1dFJvdyk7XG4gICAgYm90dG9tQmFyQ29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbnNSb3cpO1xuICAgIC8vIC0tLSBBc3NlbWJsZSBNYWluIEVsZW1lbnQgLS0tXG4gICAgbWFpbkVsZW1lbnQuYXBwZW5kQ2hpbGQodGl0bGVDb250YWluZXIpO1xuICAgIG1haW5FbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VDb250YWluZXIpO1xuICAgIG1haW5FbGVtZW50LmFwcGVuZENoaWxkKGhpc3RvcnlDb250YWluZXIpO1xuICAgIG1haW5FbGVtZW50LmFwcGVuZENoaWxkKGJvdHRvbUJhckNvbnRhaW5lcik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWFpbkVsZW1lbnQsXG4gICAgICAgIHRpdGxlSW5wdXQsXG4gICAgICAgIG1lc3NhZ2VDb250YWluZXIsXG4gICAgICAgIGhpc3RvcnlDb250YWluZXIsXG4gICAgICAgIGlucHV0RmllbGQsXG4gICAgICAgIGJvdHRvbUJhckNvbnRhaW5lcixcbiAgICAgICAgc2VuZEJ1dHRvbixcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbixcbiAgICAgICAgaGlzdG9yeUJ1dHRvbixcbiAgICAgICAgbWFya2Rvd25Ub2dnbGVCdXR0b24sXG4gICAgICAgIGV4cGFuZEJ1dHRvbixcbiAgICAgICAgYXRCdXR0b24sXG4gICAgICAgIHNldHRpbmdzQnV0dG9uXG4gICAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NZXNzYWdlUmVuZGVyZXIgPSB2b2lkIDA7XG5leHBvcnRzLnJlbmRlclVzZXJNZXNzYWdlID0gcmVuZGVyVXNlck1lc3NhZ2U7XG5leHBvcnRzLnJlbmRlckJvdE1lc3NhZ2UgPSByZW5kZXJCb3RNZXNzYWdlO1xuZXhwb3J0cy5yZW5kZXJCb3RNZXNzYWdlU3RyZWFtaW5nU3RhcnQgPSByZW5kZXJCb3RNZXNzYWdlU3RyZWFtaW5nU3RhcnQ7XG5leHBvcnRzLnJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdVcGRhdGUgPSByZW5kZXJCb3RNZXNzYWdlU3RyZWFtaW5nVXBkYXRlO1xuZXhwb3J0cy5yZW5kZXJCb3RNZXNzYWdlRmluYWwgPSByZW5kZXJCb3RNZXNzYWdlRmluYWw7XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG5jb25zdCBkb21wdXJpZnlfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZG9tcHVyaWZ5XCIpKTtcbi8vIGltcG9ydCBobGpzIGZyb20gJ2hpZ2hsaWdodC5qcyc7IC8vIFJlbW92ZWQgdW51c2VkIGltcG9ydFxuY29uc3QgZG9tX2VsZW1lbnRzXzEgPSByZXF1aXJlKFwiLi9kb20tZWxlbWVudHNcIik7XG5jb25zdCBnbG9iYWxzXzEgPSByZXF1aXJlKFwiLi4vY29yZS9nbG9iYWxzXCIpOyAvLyBJbXBvcnQgZ2xvYmFsc1xuLy8gUmVtb3ZlZCB1bnVzZWQgaW1wb3J0IGJsb2NrIGZvciBjbGlwYm9hcmQgdXRpbHMgKHVzZWQgdmlhIGNhbGxiYWNrcylcbi8vIGltcG9ydCB7IGNvcHlUb0NsaXBib2FyZCwgY29weUltYWdlVG9DbGlwYm9hcmQsIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQgfSBmcm9tICcuLi91dGlscy9jbGlwYm9hcmQnO1xuLy8gUmVtb3ZlZCB1bnVzZWQgaW1wb3J0ICh1c2VkIHZpYSBjYWxsYmFja3MpXG4vLyBpbXBvcnQgeyBhZGRNZXNzYWdlVG9DZWxsIH0gZnJvbSAnLi4vdXRpbHMvbm90ZWJvb2staW50ZWdyYXRpb24nO1xuY29uc3QgaGlnaGxpZ2h0aW5nXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvaGlnaGxpZ2h0aW5nXCIpO1xuY29uc3QgbWFya2Rvd25fY29uZmlnXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvbWFya2Rvd24tY29uZmlnXCIpO1xuLyoqXG4gKiBCYXNlIGZ1bmN0aW9uIHRvIGNyZWF0ZSBhIG1lc3NhZ2UgY29udGFpbmVyIGRpdi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlTWVzc2FnZURpdihzZW5kZXIpIHtcbiAgICBjb25zdCBtZXNzYWdlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbWVzc2FnZURpdi5jbGFzc05hbWUgPSBzZW5kZXIgPT09ICd1c2VyJyA/ICdqcC1sbG0tZXh0LXVzZXItbWVzc2FnZScgOiAnanAtbGxtLWV4dC1ib3QtbWVzc2FnZSc7XG4gICAgcmV0dXJuIG1lc3NhZ2VEaXY7XG59XG4vKipcbiAqIFJlbmRlcnMgYSB1c2VyIG1lc3NhZ2UuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclVzZXJNZXNzYWdlKHRleHQsIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2tzID0ge30pIHtcbiAgICBjb25zdCBtZXNzYWdlRGl2ID0gY3JlYXRlTWVzc2FnZURpdigndXNlcicpO1xuICAgIGlmIChvcHRpb25zLmlzTWFya2Rvd24pIHtcbiAgICAgICAgLy8gVE9ETzogSW50ZWdyYXRlIENvZGUgUmVmZXJlbmNlIHJlbmRlcmluZyBwcm9wZXJseSBoZXJlXG4gICAgICAgIC8vIEZvciBub3csIHJlbmRlciB0aGUgd2hvbGUgYm9keSBhcyBNYXJrZG93blxuICAgICAgICBjb25zdCBjb250ZW50RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIC8vIFVzZSAnbWFya2Rvd24tY29udGVudCcgY2xhc3MgZm9yIGNvbnNpc3RlbnQgc3R5bGluZ1xuICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFByZXByb2Nlc3MsIHBhcnNlLCBhbmQgc2FuaXRpemUgbGlrZSBpbiBib3QgbWVzc2FnZXNcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKSh0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRIdG1sID0gZG9tcHVyaWZ5XzEuZGVmYXVsdC5zYW5pdGl6ZShyYXdIdG1sKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgIC8vIEVuaGFuY2UgY29kZSBibG9ja3MgaWYgdXNlciBtZXNzYWdlcyBjYW4gY29udGFpbiB0aGVtXG4gICAgICAgICAgICBjb25zdCBjb2RlQmxvY2tzID0gY29udGVudERpdi5xdWVyeVNlbGVjdG9yQWxsKCdwcmUgY29kZScpO1xuICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKGJsb2NrID0+IHtcbiAgICAgICAgICAgICAgICAvLyBQYXNzIG9ubHkgcmVsZXZhbnQgY2FsbGJhY2tzIGlmIG5lZWRlZCBmb3IgdXNlciBjb2RlIGJsb2Nrc1xuICAgICAgICAgICAgICAgIGVuaGFuY2VDb2RlQmxvY2soYmxvY2ssIHtcbiAgICAgICAgICAgICAgICAvLyBlLmcuLCBzaG93Q29weUZlZWRiYWNrOiBjYWxsYmFja3Muc2hvd0NvcHlGZWVkYmFjayBcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlbmRlciB1c2VyIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIHBsYWluIHRleHQgaWYgTWFya2Rvd24gcmVuZGVyaW5nIGZhaWxzXG4gICAgICAgICAgICBjb250ZW50RGl2LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gTm9uLU1hcmtkb3duIHVzZXIgbWVzc2FnZSAocGxhaW4gdGV4dClcbiAgICAgICAgLy8gUmVwbGFjZSBzaW1wbGUgdGV4dENvbnRlbnQgYXNzaWdubWVudCB3aXRoIHJlZi1hd2FyZSByZW5kZXJpbmdcbiAgICAgICAgLy8gbWVzc2FnZURpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIHJlbmRlck1lc3NhZ2VDb250ZW50V2l0aFJlZnMobWVzc2FnZURpdiwgdGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgLy8gVE9ETzogQWRkIHVzZXIgbWVzc2FnZSBzcGVjaWZpYyBhY3Rpb25zIGlmIG5lZWRlZCAoZS5nLiwgY29weSB0ZXh0KVxuICAgIHJldHVybiBtZXNzYWdlRGl2O1xufVxuLyoqXG4gKiBORVc6IFJlbmRlcnMgbWVzc2FnZSBjb250ZW50LCByZXBsYWNpbmcgQHJlZmVyZW5jZXMgd2l0aCB3aWRnZXRzLlxuICovXG5mdW5jdGlvbiByZW5kZXJNZXNzYWdlQ29udGVudFdpdGhSZWZzKGNvbnRhaW5lciwgdGV4dCwgY2FsbGJhY2tzKSB7XG4gICAgLy8gLS0tIERFQlVHIExPRyAtLS0gXG4gICAgY29uc29sZS5sb2coJ1tyZW5kZXJNZXNzYWdlQ29udGVudFdpdGhSZWZzXSBQcm9jZXNzaW5nIHRleHQ6JywgSlNPTi5zdHJpbmdpZnkodGV4dCkpOyAvLyBMb2cgZXhhY3QgdGV4dFxuICAgIC8vIC0tLSBFTkQgREVCVUcgTE9HIC0tLVxuICAgIC8vIFJlZ2V4IHRvIGZpbmQgQGZpbGUsIEBkaXIsIEBDZWxsLCBAY29kZSByZWZlcmVuY2VzICh3aXRoIG9wdGlvbmFsIHN1cnJvdW5kaW5nIHdoaXRlc3BhY2UpXG4gICAgY29uc3QgcmVmUmVnZXggPSAvXFxzKihAKGZpbGV8ZGlyfENlbGx8Y29kZSlcXFsoW15cXF1dKz8pXFxdKVxccyovZztcbiAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICBsZXQgbWF0Y2g7XG4gICAgLy8gUmVzZXQgcmVnZXggc3RhdGUganVzdCBpbiBjYXNlXG4gICAgcmVmUmVnZXgubGFzdEluZGV4ID0gMDtcbiAgICB3aGlsZSAoKG1hdGNoID0gcmVmUmVnZXguZXhlYyh0ZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQXBwZW5kIHRleHQgYmVmb3JlIHRoZSBtYXRjaFxuICAgICAgICBpZiAobWF0Y2guaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0LnN1YnN0cmluZyhsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgdGhlIG1hdGNoZWQgcmVmZXJlbmNlXG4gICAgICAgIGNvbnN0IGZ1bGxNYXRjaFdpdGhXaGl0ZXNwYWNlID0gbWF0Y2hbMF07IC8vIEluY2x1ZGVzIHBvdGVudGlhbCB3aGl0ZXNwYWNlXG4gICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IG1hdGNoWzFdOyAvLyBUaGUgYWN0dWFsIEB0eXBlW3ZhbHVlXSBwYXJ0XG4gICAgICAgIGNvbnN0IHR5cGUgPSBtYXRjaFsyXTtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBtYXRjaFszXTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHdpZGdldCA9IGNyZWF0ZVJlZldpZGdldCh0eXBlLCB2YWx1ZSwgZnVsbE1hdGNoLCBjYWxsYmFja3MpOyAvLyBQYXNzIHRoZSBjbGVhbiBtYXRjaFxuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHdpZGdldCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHdpZGdldCBmb3IgcmVmZXJlbmNlOiAke2Z1bGxNYXRjaH1gLCBlcnJvcik7XG4gICAgICAgICAgICAvLyBGYWxsYmFjazogYXBwZW5kIHRoZSBvcmlnaW5hbCByZWZlcmVuY2UgdGV4dCAod2l0aCBwb3RlbnRpYWwgd2hpdGVzcGFjZSlcbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShmdWxsTWF0Y2hXaXRoV2hpdGVzcGFjZSkpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RJbmRleCA9IHJlZlJlZ2V4Lmxhc3RJbmRleDtcbiAgICB9XG4gICAgLy8gQXBwZW5kIGFueSByZW1haW5pbmcgdGV4dCBhZnRlciB0aGUgbGFzdCBtYXRjaFxuICAgIGlmIChsYXN0SW5kZXggPCB0ZXh0Lmxlbmd0aCkge1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dC5zdWJzdHJpbmcobGFzdEluZGV4KSkpO1xuICAgIH1cbn1cbi8qKlxuICogTkVXOiBDcmVhdGVzIGEgcmVmZXJlbmNlIHdpZGdldCBzcGFuLlxuICovXG5mdW5jdGlvbiBjcmVhdGVSZWZXaWRnZXQodHlwZSwgdmFsdWUsIG9yaWdpbmFsUmVmVGV4dCwgLy8gVGhlIGZ1bGwgQHR5cGVbdmFsdWVdIHN0cmluZ1xuY2FsbGJhY2tzKSB7XG4gICAgY29uc3Qgd2lkZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHdpZGdldC5jbGFzc05hbWUgPSBganAtbGxtLWV4dC1yZWYtd2lkZ2V0IHJlZi0ke3R5cGUudG9Mb3dlckNhc2UoKX1gO1xuICAgIHdpZGdldC5zZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScsICdmYWxzZScpO1xuICAgIHdpZGdldC5kYXRhc2V0LnJlZlRleHQgPSBvcmlnaW5hbFJlZlRleHQ7IC8vIFN0b3JlIHRoZSBvcmlnaW5hbCByZWZlcmVuY2VcbiAgICBsZXQgZGlzcGxheVRleHQgPSAnJztcbiAgICBsZXQgdGl0bGVUZXh0ID0gb3JpZ2luYWxSZWZUZXh0OyAvLyBEZWZhdWx0IHRvb2x0aXBcbiAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnZmlsZSc6XG4gICAgICAgICAgICBkaXNwbGF5VGV4dCA9IHZhbHVlLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgfHwgdmFsdWU7IC8vIEV4dHJhY3QgZmlsZW5hbWVcbiAgICAgICAgICAgIHRpdGxlVGV4dCA9IGBGaWxlOiAke3ZhbHVlfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZGlyJzpcbiAgICAgICAgICAgIGRpc3BsYXlUZXh0ID0gdmFsdWUuc3BsaXQoL1tcXFxcL10vKS5wb3AoKSB8fCB2YWx1ZSB8fCAnLyc7IC8vIEV4dHJhY3QgZGlybmFtZSwgaGFuZGxlIHJvb3RcbiAgICAgICAgICAgIHRpdGxlVGV4dCA9IGBEaXJlY3Rvcnk6ICR7dmFsdWV9YDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdDZWxsJzoge1xuICAgICAgICAgICAgY29uc3QgY2VsbEluZGV4ID0gcGFyc2VJbnQodmFsdWUpIC0gMTsgLy8gQ29udmVydCBiYWNrIHRvIDAtYmFzZWQgaW5kZXhcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rQ29udGV4dCA9IGNhbGxiYWNrcy5nZXRDdXJyZW50Tm90ZWJvb2tDb250ZXh0ID8gY2FsbGJhY2tzLmdldEN1cnJlbnROb3RlYm9va0NvbnRleHQoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIC0tLSBERUJVRyBMT0cgLS0tIFxuICAgICAgICAgICAgY29uc29sZS5sb2coYFtjcmVhdGVSZWZXaWRnZXQgQENlbGxdIElucHV0IFZhbHVlOiAke3ZhbHVlfSwgUGFyc2VkIEluZGV4OiAke2NlbGxJbmRleH0sIE5vdGVib29rIENvbnRleHQ6YCwgbm90ZWJvb2tDb250ZXh0KTtcbiAgICAgICAgICAgIC8vIC0tLSBFTkQgREVCVUcgTE9HIC0tLSBcbiAgICAgICAgICAgIGNvbnN0IG5vdGVib29rTmFtZSA9IChub3RlYm9va0NvbnRleHQgPT09IG51bGwgfHwgbm90ZWJvb2tDb250ZXh0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub3RlYm9va0NvbnRleHQubmFtZSkgfHwgJ25vdGVib29rJztcbiAgICAgICAgICAgIGxldCBjZWxsVHlwZUNoYXIgPSAnPyc7XG4gICAgICAgICAgICBpZiAobm90ZWJvb2tDb250ZXh0ICYmIGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROb3RlYm9va1BhbmVsID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmZpbmQod2lkZ2V0ID0+IHdpZGdldC5jb250ZXh0LnBhdGggPT09IG5vdGVib29rQ29udGV4dC5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudE5vdGVib29rUGFuZWwgJiYgY3VycmVudE5vdGVib29rUGFuZWwubW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbE1vZGVsID0gY3VycmVudE5vdGVib29rUGFuZWwubW9kZWwuY2VsbHMuZ2V0KGNlbGxJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjZWxsTW9kZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbGxUeXBlQ2hhciA9IGNlbGxNb2RlbC50eXBlID09PSAnbWFya2Rvd24nID8gJ00nIDogJ0MnO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGlzcGxheVRleHQgPSBgJHtub3RlYm9va05hbWV9LSR7Y2VsbFR5cGVDaGFyfS0ke3ZhbHVlfWA7IC8vIHZhbHVlIGlzIDEtYmFzZWQgaW5kZXhcbiAgICAgICAgICAgIHRpdGxlVGV4dCA9IGBDZWxsICR7dmFsdWV9ICgke2NlbGxUeXBlQ2hhciA9PT0gJ00nID8gJ01hcmtkb3duJyA6ICdDb2RlJ30pIGluICR7bm90ZWJvb2tOYW1lfWA7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlICdjb2RlJzoge1xuICAgICAgICAgICAgY29uc3QgcmVmSWQgPSB2YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJlZkRhdGEgPSBjYWxsYmFja3MuZ2V0Q29kZVJlZkRhdGEgPyBjYWxsYmFja3MuZ2V0Q29kZVJlZkRhdGEocmVmSWQpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgLy8gLS0tIERFQlVHIExPRyAtLS0gXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgW2NyZWF0ZVJlZldpZGdldCBAY29kZV0gSW5wdXQgVmFsdWUgKHJlZklkKTogJHtyZWZJZH0sIFJlZiBEYXRhIEZvdW5kOmAsIHJlZkRhdGEpO1xuICAgICAgICAgICAgLy8gLS0tIEVORCBERUJVRyBMT0cgLS0tIFxuICAgICAgICAgICAgaWYgKHJlZkRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBDb25zdHJ1Y3QgZGlzcGxheSB0ZXh0IHVzaW5nIHN0YXJ0IGFuZCBlbmQgbGluZXNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSByZWZEYXRhLmxpbmVOdW1iZXI7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kTGluZSA9IHJlZkRhdGEubGluZUVuZE51bWJlcjtcbiAgICAgICAgICAgICAgICBjb25zdCBsaW5lUGFydCA9IHN0YXJ0TGluZSA9PT0gZW5kTGluZSA/IGAke3N0YXJ0TGluZX1gIDogYCR7c3RhcnRMaW5lfV8ke2VuZExpbmV9YDtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VGV4dCA9IGAke3JlZkRhdGEubm90ZWJvb2tOYW1lfS0ke3JlZkRhdGEuY2VsbEluZGV4ICsgMX0tJHtsaW5lUGFydH1gO1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aXRsZSB0ZXh0IGFzIHdlbGxcbiAgICAgICAgICAgICAgICBjb25zdCB0aXRsZUxpbmVQYXJ0ID0gc3RhcnRMaW5lID09PSBlbmRMaW5lID8gYExpbmUgJHtzdGFydExpbmV9YCA6IGBMaW5lcyAke3N0YXJ0TGluZX0tJHtlbmRMaW5lfWA7XG4gICAgICAgICAgICAgICAgdGl0bGVUZXh0ID0gYENvZGUgUmVmZXJlbmNlOiAke3JlZkRhdGEubm90ZWJvb2tOYW1lfSwgQ2VsbCAke3JlZkRhdGEuY2VsbEluZGV4ICsgMX0sICR7dGl0bGVMaW5lUGFydH1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGlzcGxheVRleHQgPSBgY29kZS1yZWYtJHtyZWZJZH1gOyAvLyBGYWxsYmFjayBkaXNwbGF5XG4gICAgICAgICAgICAgICAgdGl0bGVUZXh0ID0gYENvZGUgUmVmZXJlbmNlIElEOiAke3JlZklkfSAoRGF0YSBub3QgZm91bmQpYDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdpZGdldC50ZXh0Q29udGVudCA9IGRpc3BsYXlUZXh0O1xuICAgIHdpZGdldC50aXRsZSA9IHRpdGxlVGV4dDsgLy8gQWRkIHRvb2x0aXBcbiAgICByZXR1cm4gd2lkZ2V0O1xufVxuLyoqXG4gKiBORVc6IFJlY3Vyc2l2ZWx5IGZpbmRzIGFuZCByZXBsYWNlcyBAcmVmZXJlbmNlcyB3aXRoaW4gdGV4dCBub2RlcyBvZiBhbiBlbGVtZW50LlxuICovXG5mdW5jdGlvbiByZW5kZXJSZWZzSW5FbGVtZW50KGVsZW1lbnQsIGNhbGxiYWNrcykge1xuICAgIC8vIFVzZSB0aGUgc2FtZSB1cGRhdGVkIHJlZ2V4IGhlcmVcbiAgICBjb25zdCByZWZSZWdleCA9IC9cXHMqKEAoZmlsZXxkaXJ8Q2VsbHxjb2RlKVxcWyhbXlxcXV0rPylcXF0pXFxzKi9nO1xuICAgIGNvbnN0IHdhbGtlciA9IGRvY3VtZW50LmNyZWF0ZVRyZWVXYWxrZXIoZWxlbWVudCwgTm9kZUZpbHRlci5TSE9XX1RFWFQsIG51bGwpO1xuICAgIGxldCBub2RlO1xuICAgIGNvbnN0IG5vZGVzVG9Qcm9jZXNzID0gW107XG4gICAgd2hpbGUgKChub2RlID0gd2Fsa2VyLm5leHROb2RlKCkpKSB7XG4gICAgICAgIGlmIChub2RlIGluc3RhbmNlb2YgVGV4dCAmJlxuICAgICAgICAgICAgbm9kZS50ZXh0Q29udGVudCAmJlxuICAgICAgICAgICAgIShub2RlLnBhcmVudEVsZW1lbnQgJiYgbm9kZS5wYXJlbnRFbGVtZW50LmNsb3Nlc3QoJy5qcC1sbG0tZXh0LXJlZi13aWRnZXQnKSkpIHtcbiAgICAgICAgICAgIC8vIFRlc3Qgd2l0aCB0aGUgc3BlY2lmaWMgcmVnZXggYmVmb3JlIGFkZGluZ1xuICAgICAgICAgICAgcmVmUmVnZXgubGFzdEluZGV4ID0gMDsgLy8gUmVzZXQgYmVmb3JlIHRlc3RcbiAgICAgICAgICAgIGlmIChyZWZSZWdleC50ZXN0KG5vZGUudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgbm9kZXNUb1Byb2Nlc3MucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBOb3csIHByb2Nlc3MgdGhlIGNvbGxlY3RlZCB0ZXh0IG5vZGVzXG4gICAgbm9kZXNUb1Byb2Nlc3MuZm9yRWFjaCh0ZXh0Tm9kZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRleHROb2RlLnBhcmVudE5vZGU7XG4gICAgICAgIGlmICghcGFyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB0ZXh0ID0gdGV4dE5vZGUudGV4dENvbnRlbnQgfHwgJyc7XG4gICAgICAgIGNvbnN0IGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgICAgbGV0IG1hdGNoO1xuICAgICAgICByZWZSZWdleC5sYXN0SW5kZXggPSAwOyAvLyBSZXNldCByZWdleCBzdGF0ZSBmb3IgZWFjaCBub2RlXG4gICAgICAgIHdoaWxlICgobWF0Y2ggPSByZWZSZWdleC5leGVjKHRleHQpKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQXBwZW5kIHRleHQgYmVmb3JlIHRoZSBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoLmluZGV4ID4gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGV4dC5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaC5pbmRleCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFByb2Nlc3MgdGhlIG1hdGNoZWQgcmVmZXJlbmNlXG4gICAgICAgICAgICBjb25zdCBmdWxsTWF0Y2hXaXRoV2hpdGVzcGFjZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgY29uc3QgZnVsbE1hdGNoID0gbWF0Y2hbMV07XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gbWF0Y2hbMl07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCB3aWRnZXQgPSBjcmVhdGVSZWZXaWRnZXQodHlwZSwgdmFsdWUsIGZ1bGxNYXRjaCwgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgICAgICBmcmFnbWVudC5hcHBlbmRDaGlsZCh3aWRnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSB3aWRnZXQgZm9yIHJlZmVyZW5jZTogJHtmdWxsTWF0Y2h9YCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGZ1bGxNYXRjaFdpdGhXaGl0ZXNwYWNlKSk7IC8vIEZhbGxiYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0SW5kZXggPSByZWZSZWdleC5sYXN0SW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXBwZW5kIGFueSByZW1haW5pbmcgdGV4dCBhZnRlciB0aGUgbGFzdCBtYXRjaFxuICAgICAgICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRleHQuc3Vic3RyaW5nKGxhc3RJbmRleCkpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBvcmlnaW5hbCB0ZXh0IG5vZGUgd2l0aCB0aGUgZnJhZ21lbnRcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChmcmFnbWVudCwgdGV4dE5vZGUpO1xuICAgIH0pO1xufVxuLyoqXG4gKiBSZW5kZXJzIGEgYm90IG1lc3NhZ2UgKHRleHQsIG1hcmtkb3duLCBpbWFnZXMsIGNvZGUgYmxvY2tzKS5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyQm90TWVzc2FnZSh0ZXh0LCBvcHRpb25zID0geyBpc01hcmtkb3duOiB0cnVlIH0sIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgY29uc3QgbWVzc2FnZURpdiA9IGNyZWF0ZU1lc3NhZ2VEaXYoJ2JvdCcpO1xuICAgIC8vIENoZWNrIGlmIHRoZSBtZXNzYWdlIGlzIGFuIGltYWdlIFVSTFxuICAgIGNvbnN0IGlzSW1hZ2VVcmwgPSB0ZXh0LnRyaW0oKS5zdGFydHNXaXRoKCcvaW1hZ2VzLycpICYmXG4gICAgICAgICh0ZXh0LnRyaW0oKS5lbmRzV2l0aCgnLnBuZycpIHx8XG4gICAgICAgICAgICB0ZXh0LnRyaW0oKS5lbmRzV2l0aCgnLmpwZycpIHx8XG4gICAgICAgICAgICB0ZXh0LnRyaW0oKS5lbmRzV2l0aCgnLmpwZWcnKSB8fFxuICAgICAgICAgICAgdGV4dC50cmltKCkuZW5kc1dpdGgoJy5naWYnKSk7XG4gICAgaWYgKGlzSW1hZ2VVcmwpIHtcbiAgICAgICAgLy8gQ29uc3RydWN0IGZ1bGwgVVJMIChUT0RPOiBNYWtlIGJhc2UgVVJMIGNvbmZpZ3VyYWJsZSlcbiAgICAgICAgY29uc3QgZnVsbEltYWdlVXJsID0gYGh0dHA6Ly8xMjcuMC4wLjE6ODAwMCR7dGV4dC50cmltKCl9YDtcbiAgICAgICAgLy8gQ2FsbCBkZWRpY2F0ZWQgaW1hZ2UgcmVuZGVyaW5nIGZ1bmN0aW9uXG4gICAgICAgIHJlbmRlckltYWdlTWVzc2FnZShtZXNzYWdlRGl2LCBmdWxsSW1hZ2VVcmwsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKG9wdGlvbnMuaXNNYXJrZG93bikge1xuICAgICAgICAvLyBSZW5kZXIgYXMgbWFya2Rvd24gKGxvZ2ljIGZyb20gYWRkTWVzc2FnZSlcbiAgICAgICAgY29uc3QgbWFya2Rvd25JbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWFya2Rvd25JbmRpY2F0b3IudGV4dENvbnRlbnQgPSBcIk1EXCI7XG4gICAgICAgIG1hcmtkb3duSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdtYXJrZG93bi1pbmRpY2F0b3InO1xuICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKG1hcmtkb3duSW5kaWNhdG9yKTtcbiAgICAgICAgY29uc3QgY29udGVudERpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBjb250ZW50RGl2LmNsYXNzTmFtZSA9ICdtYXJrZG93bi1jb250ZW50JztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKSh0ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRIdG1sID0gZG9tcHVyaWZ5XzEuZGVmYXVsdC5zYW5pdGl6ZShyYXdIdG1sKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgIC8vIC0tLSBORVc6IFJlbmRlciByZWZlcmVuY2VzIHdpdGhpbiB0aGUgc2FuaXRpemVkIEhUTUwgLS0tIFxuICAgICAgICAgICAgcmVuZGVyUmVmc0luRWxlbWVudChjb250ZW50RGl2LCBjYWxsYmFja3MpO1xuICAgICAgICAgICAgLy8gLS0tIEVuZCBORVcgLS0tXG4gICAgICAgICAgICAvLyBFbmhhbmNlIGNvZGUgYmxvY2tzIGFmdGVyIHNldHRpbmcgaW5uZXJIVE1MIGFuZCByZW5kZXJpbmcgcmVmc1xuICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgIGNvZGVCbG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgZW5oYW5jZUNvZGVCbG9jayhibG9jaywgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFuZCByZW5kZXIgaW50ZXJydXB0IGJ1dHRvbnNcbiAgICAgICAgICAgIGNvbnN0IGlzSW50ZXJydXB0ID0gdGV4dC5zdGFydHNXaXRoKCcqKltJTlRFUlJVUFRdKionKTtcbiAgICAgICAgICAgIGlmIChpc0ludGVycnVwdCkge1xuICAgICAgICAgICAgICAgIHJlbmRlckludGVycnVwdEJ1dHRvbnMoY29udGVudERpdiwgY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSB0ZXh0OyAvLyBGYWxsYmFjayB0byBwbGFpbiB0ZXh0XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gcmVuZGVyIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlRGl2LmFwcGVuZENoaWxkKGNvbnRlbnREaXYpO1xuICAgICAgICAvLyBBZGQgb3ZlcmFsbCBtZXNzYWdlIGFjdGlvbiBidXR0b25zIEFGVEVSIGNvbnRlbnQgaXMgYWRkZWRcbiAgICAgICAgYWRkQm90TWVzc2FnZUFjdGlvbnMobWVzc2FnZURpdiwgdGV4dCwgY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIFJlbmRlciBhcyBwbGFpbiB0ZXh0XG4gICAgICAgIG1lc3NhZ2VEaXYudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICAvLyBBZGQgb3ZlcmFsbCBtZXNzYWdlIGFjdGlvbiBidXR0b25zIGV2ZW4gZm9yIHBsYWluIHRleHQgYm90IG1lc3NhZ2VzXG4gICAgICAgIGFkZEJvdE1lc3NhZ2VBY3Rpb25zKG1lc3NhZ2VEaXYsIHRleHQsIGNhbGxiYWNrcyk7XG4gICAgfVxuICAgIHJldHVybiBtZXNzYWdlRGl2O1xufVxuLy8gRGVmaW5lIGNyZWF0ZU1lc3NhZ2VXcmFwcGVyIGJhc2VkIG9uIGNyZWF0ZU1lc3NhZ2VEaXZcbmZ1bmN0aW9uIGNyZWF0ZU1lc3NhZ2VXcmFwcGVyKHNlbmRlcikge1xuICAgIHJldHVybiBjcmVhdGVNZXNzYWdlRGl2KHNlbmRlcik7XG59XG4vLyAtLS0gTW9yZSBzcGVjaWZpYyByZW5kZXJpbmcgZnVuY3Rpb25zIG9yIGhlbHBlcnMgY2FuIGJlIGFkZGVkIGJlbG93IC0tLVxuLyoqXG4gKiBSZW5kZXJzIGFuIGltYWdlIG1lc3NhZ2Ugd2l0aCBhY3Rpb24gYnV0dG9ucyBpbnNpZGUgYSBjb250YWluZXIuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciBUaGUgcGFyZW50IEhUTUwgZWxlbWVudCB0byBhcHBlbmQgdGhlIGltYWdlIG1lc3NhZ2UgdG8uXG4gKiBAcGFyYW0gaW1hZ2VVcmwgVGhlIGZ1bGwgVVJMIG9mIHRoZSBpbWFnZSB0byByZW5kZXIuXG4gKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgYWN0aW9ucyBsaWtlIGNvcHkgaW1hZ2UsIGFkZCBwYXRoLlxuICovXG5mdW5jdGlvbiByZW5kZXJJbWFnZU1lc3NhZ2UoY29udGFpbmVyLCBpbWFnZVVybCwgY2FsbGJhY2tzID0ge30pIHtcbiAgICAvLyBDcmVhdGUgYSBjb250YWluZXIgZm9yIHRoZSBpbWFnZSB0aGF0IGFsbG93cyBwb3NpdGlvbmluZyB0aGUgYnV0dG9uc1xuICAgIGNvbnN0IGltYWdlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgaW1hZ2VDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW1hZ2UtY29udGFpbmVyJztcbiAgICBpbWFnZUNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XG4gICAgLy8gUmVuZGVyIGFzIGFuIGltYWdlIHRhZ1xuICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuICAgIGltZy5zcmMgPSBpbWFnZVVybDtcbiAgICBpbWcuYWx0ID0gJ0ltYWdlIGZyb20gYm90JztcbiAgICBpbWcuc3R5bGUubWF4V2lkdGggPSAnMTAwJSc7IC8vIEVuc3VyZSBpbWFnZSBmaXRzIHdpdGhpbiB0aGUgY29udGFpbmVyXG4gICAgaW1nLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcbiAgICBpbWFnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWcpO1xuICAgIC8vIEFkZCBhY3Rpb24gYnV0dG9ucyBmb3IgdGhlIGltYWdlXG4gICAgY29uc3QgaW1nQWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGltZ0FjdGlvbnNEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW1hZ2UtYWN0aW9ucyc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5ib3R0b20gPSAnMTBweCc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5yaWdodCA9ICcxMHB4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5nYXAgPSAnOHB4JztcbiAgICBpbWdBY3Rpb25zRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDI1NSwgMjU1LCAyNTUsIDAuNiknOyAvLyBBZGRlZCBzbGlnaHQgYmFja2dyb3VuZCBmb3IgdmlzaWJpbGl0eVxuICAgIGltZ0FjdGlvbnNEaXYuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzRweCc7XG4gICAgaW1nQWN0aW9uc0Rpdi5zdHlsZS5wYWRkaW5nID0gJzRweCc7XG4gICAgLy8gQ29weSBpbWFnZSBidXR0b24gKHVzaW5nIGNhbGxiYWNrKVxuICAgIGlmIChjYWxsYmFja3MuY29weUltYWdlVG9DbGlwYm9hcmQgJiYgY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2spIHtcbiAgICAgICAgY29uc3QgY29weUltZ0J0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5SW1nQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWltYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBjb3B5SW1nQnRuLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBjb3B5SW1nQnRuLnRpdGxlID0gJ0NvcHkgaW1hZ2UgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgY29uc3QgZmVlZGJhY2tDYiA9ICgpID0+IGNhbGxiYWNrcy5zaG93Q29weUZlZWRiYWNrKGNvcHlJbWdCdG4pO1xuICAgICAgICBjb3B5SW1nQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5jb3B5SW1hZ2VUb0NsaXBib2FyZChpbWFnZVVybCwgZmVlZGJhY2tDYik7XG4gICAgICAgIH0pO1xuICAgICAgICBpbWdBY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlJbWdCdG4pO1xuICAgIH1cbiAgICAvLyBBZGQgZmlsZSBwYXRoIGJ1dHRvbiAodXNpbmcgY2FsbGJhY2spXG4gICAgaWYgKGNhbGxiYWNrcy5hZGRNZXNzYWdlVG9DZWxsKSB7XG4gICAgICAgIGNvbnN0IGFkZFBhdGhCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkUGF0aEJ0bi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1pbWFnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgYWRkUGF0aEJ0bi5pbm5lckhUTUwgPSAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCIgd2lkdGg9XCIxNlwiIGhlaWdodD1cIjE2XCIgdmlld0JveD1cIjAgMCAyNCAyNFwiIGZpbGw9XCJub25lXCIgc3Ryb2tlPVwiY3VycmVudENvbG9yXCIgc3Ryb2tlLXdpZHRoPVwiMlwiIHN0cm9rZS1saW5lY2FwPVwicm91bmRcIiBzdHJva2UtbGluZWpvaW49XCJyb3VuZFwiPjxwYXRoIGQ9XCJNMTYgNGgyYTIgMiAwIDAgMSAyIDJ2MTRhMiAyIDAgMCAxLTIgMkg2YTIgMiAwIDAgMS0yLTJWNmEyIDIgMCAwIDEgMi0yaDJcIj48L3BhdGg+PHJlY3QgeD1cIjhcIiB5PVwiMlwiIHdpZHRoPVwiOFwiIGhlaWdodD1cIjRcIiByeD1cIjFcIiByeT1cIjFcIj48L3JlY3Q+PHBhdGggZD1cIk0xMiAxMXY2XCI+PC9wYXRoPjxwYXRoIGQ9XCJNOSAxNGg2XCI+PC9wYXRoPjwvc3ZnPic7XG4gICAgICAgIGFkZFBhdGhCdG4udGl0bGUgPSAnQWRkIGltYWdlIHBhdGggdG8gY3VycmVudCBjZWxsJztcbiAgICAgICAgYWRkUGF0aEJ0bi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAvLyBQYXNzIHRoZSBpbWFnZSBVUkwgKHdoaWNoIGlzIHRoZSBtZXNzYWdlIHRleHQgaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwoaW1hZ2VVcmwpO1xuICAgICAgICB9KTtcbiAgICAgICAgaW1nQWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRQYXRoQnRuKTtcbiAgICB9XG4gICAgLy8gT25seSBhZGQgdGhlIGFjdGlvbnMgZGl2IGlmIGl0IGhhcyBidXR0b25zXG4gICAgaWYgKGltZ0FjdGlvbnNEaXYuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIGltYWdlQ29udGFpbmVyLmFwcGVuZENoaWxkKGltZ0FjdGlvbnNEaXYpO1xuICAgIH1cbiAgICAvLyBBZGQgdGhlIGltYWdlIGNvbnRhaW5lciB0byB0aGUgbWFpbiBtZXNzYWdlIGRpdlxuICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChpbWFnZUNvbnRhaW5lcik7XG59XG4vKipcbiAqIENyZWF0ZXMgdGhlIGluaXRpYWwgc3RydWN0dXJlIGZvciBhIGJvdCBtZXNzYWdlIHRoYXQgd2lsbCByZWNlaXZlIHN0cmVhbWluZyBjb250ZW50LlxuICpcbiAqIEByZXR1cm5zIE9iamVjdCBjb250YWluaW5nIHRoZSB3cmFwcGVyLCBzdHJlYW1pbmcgZGl2LCBhbmQgZmluYWwgY29udGVudCBkaXYuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdTdGFydCgpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gY3JlYXRlTWVzc2FnZVdyYXBwZXIoJ2JvdCcpO1xuICAgIGNvbnN0IG1hcmtkb3duSW5kaWNhdG9yID0gKDAsIGRvbV9lbGVtZW50c18xLmNyZWF0ZURpdikoe1xuICAgICAgICB0ZXh0OiAnTUQnLFxuICAgICAgICBjbGFzc2VzOiAnbWFya2Rvd24taW5kaWNhdG9yJ1xuICAgIH0pO1xuICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQobWFya2Rvd25JbmRpY2F0b3IpO1xuICAgIGNvbnN0IHN0cmVhbWluZ0RpdiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ3N0cmVhbWluZy1jb250ZW50JyxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICAgIHdoaXRlU3BhY2U6ICdwcmUtd3JhcCcsXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnbW9ub3NwYWNlJyxcbiAgICAgICAgICAgIGZvbnRTaXplOiAnMC45ZW0nXG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3cmFwcGVyLmFwcGVuZENoaWxkKHN0cmVhbWluZ0Rpdik7XG4gICAgY29uc3QgY29udGVudERpdiA9ICgwLCBkb21fZWxlbWVudHNfMS5jcmVhdGVEaXYpKHtcbiAgICAgICAgY2xhc3NlczogJ21hcmtkb3duLWNvbnRlbnQnLFxuICAgICAgICBzdHlsZTogeyBkaXNwbGF5OiAnbm9uZScgfSAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgfSk7XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICByZXR1cm4geyB3cmFwcGVyLCBzdHJlYW1pbmdEaXYsIGNvbnRlbnREaXYgfTtcbn1cbi8qKlxuICogVXBkYXRlcyB0aGUgc3RyZWFtaW5nIGRpdiB3aXRoIGEgbmV3IGNodW5rIG9mIHRleHQuXG4gKlxuICogQHBhcmFtIHN0cmVhbWluZ0RpdiAtIFRoZSBkaXYgZGlzcGxheWluZyBzdHJlYW1pbmcgY29udGVudC5cbiAqIEBwYXJhbSBjaHVuayAtIFRoZSBuZXcgdGV4dCBjaHVuayB0byBhcHBlbmQuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckJvdE1lc3NhZ2VTdHJlYW1pbmdVcGRhdGUoc3RyZWFtaW5nRGl2LCBjaHVuaykge1xuICAgIC8vIFNpbXBsZSBhcHBlbmQsIG1pZ2h0IG5lZWQgcmVmaW5lbWVudCBmb3IgY29tcGxleCBzdHJlYW1zXG4gICAgc3RyZWFtaW5nRGl2LnRleHRDb250ZW50ICs9IGNodW5rO1xufVxuLyoqXG4gKiBSZW5kZXJzIHRoZSBmaW5hbCBjb250ZW50IG9mIGEgYm90IG1lc3NhZ2UgYWZ0ZXIgc3RyZWFtaW5nIGlzIGNvbXBsZXRlLlxuICogSGFuZGxlcyBtYXJrZG93biwgaW1hZ2VzLCBjb2RlIGJsb2NrcywgYW5kIGludGVycnVwdHMuXG4gKlxuICogQHBhcmFtIGNvbnRlbnREaXYgLSBUaGUgZGl2IHdoZXJlIHRoZSBmaW5hbCBjb250ZW50IHNob3VsZCBiZSByZW5kZXJlZC5cbiAqIEBwYXJhbSBzdHJlYW1pbmdEaXYgLSBUaGUgZGl2IHRoYXQgd2FzIHVzZWQgZm9yIHN0cmVhbWluZyAod2lsbCBiZSBoaWRkZW4pLlxuICogQHBhcmFtIGNvbXBsZXRlUmVzcG9uc2UgLSBUaGUgZnVsbCB0ZXh0IGNvbnRlbnQgZnJvbSB0aGUgYm90LlxuICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucyBpbmNsdWRpbmcgY2FsbGJhY2tzIGZvciBhY3Rpb25zLlxuICogQHJldHVybnMgVGhlIHBvcHVsYXRlZCBjb250ZW50RGl2LlxuICovXG5mdW5jdGlvbiByZW5kZXJCb3RNZXNzYWdlRmluYWwoY29udGVudERpdiwgc3RyZWFtaW5nRGl2LCBjb21wbGV0ZVJlc3BvbnNlLCBvcHRpb25zID0ge30sIGNhbGxiYWNrcyA9IHt9KSB7XG4gICAgLy8gSGlkZSBzdHJlYW1pbmcgZGl2LCBzaG93IGZpbmFsIGNvbnRlbnQgZGl2XG4gICAgc3RyZWFtaW5nRGl2LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAvLyBDb25zb2xpZGF0ZSBjYWxsYmFja3MgYWNjZXNzXG4gICAgY29uc3QgZWZmZWN0aXZlQ2FsbGJhY2tzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKSwgY2FsbGJhY2tzKTtcbiAgICAvLyAtLS0gSW1hZ2UgSGFuZGxpbmcgLS0tXG4gICAgY29uc3QgaXNJbWFnZVVybCA9IGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLnN0YXJ0c1dpdGgoJy9pbWFnZXMvJykgJiZcbiAgICAgICAgKGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcucG5nJykgfHxcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcuanBnJykgfHxcbiAgICAgICAgICAgIGNvbXBsZXRlUmVzcG9uc2UudHJpbSgpLmVuZHNXaXRoKCcuanBlZycpIHx8XG4gICAgICAgICAgICBjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKS5lbmRzV2l0aCgnLmdpZicpKTtcbiAgICBpZiAoaXNJbWFnZVVybCkge1xuICAgICAgICBjb25zdCBmdWxsSW1hZ2VVcmwgPSBgaHR0cDovLzEyNy4wLjAuMTo4MDAwJHtjb21wbGV0ZVJlc3BvbnNlLnRyaW0oKX1gOyAvLyBUT0RPOiBNYWtlIGJhc2UgVVJMIGNvbmZpZ3VyYWJsZVxuICAgICAgICByZW5kZXJJbWFnZU1lc3NhZ2UoY29udGVudERpdiwgZnVsbEltYWdlVXJsLCBlZmZlY3RpdmVDYWxsYmFja3MpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gLS0tIE1hcmtkb3duICYgQ29kZSBCbG9jayBIYW5kbGluZyAtLS1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZFRleHQgPSAoMCwgbWFya2Rvd25fY29uZmlnXzEucHJlcHJvY2Vzc01hcmtkb3duKShjb21wbGV0ZVJlc3BvbnNlKTtcbiAgICAgICAgICAgIGNvbnN0IHJhd0h0bWwgPSBtYXJrZWRfMS5tYXJrZWQucGFyc2UocHJvY2Vzc2VkVGV4dCk7XG4gICAgICAgICAgICBjb25zdCBzYW5pdGl6ZWRIdG1sID0gZG9tcHVyaWZ5XzEuZGVmYXVsdC5zYW5pdGl6ZShyYXdIdG1sKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYuaW5uZXJIVE1MID0gc2FuaXRpemVkSHRtbDtcbiAgICAgICAgICAgIC8vIC0tLSBORVc6IFJlbmRlciByZWZlcmVuY2VzIHdpdGhpbiB0aGUgc2FuaXRpemVkIEhUTUwgLS0tIFxuICAgICAgICAgICAgcmVuZGVyUmVmc0luRWxlbWVudChjb250ZW50RGl2LCBlZmZlY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgLy8gLS0tIEVuZCBORVcgLS0tXG4gICAgICAgICAgICAvLyAtLS0gSW50ZXJydXB0IEhhbmRsaW5nIC0tLVxuICAgICAgICAgICAgY29uc3QgaXNJbnRlcnJ1cHQgPSBjb21wbGV0ZVJlc3BvbnNlLnN0YXJ0c1dpdGgoJyoqW0lOVEVSUlVQVF0qKicpO1xuICAgICAgICAgICAgaWYgKGlzSW50ZXJydXB0KSB7XG4gICAgICAgICAgICAgICAgcmVuZGVySW50ZXJydXB0QnV0dG9ucyhjb250ZW50RGl2LCBlZmZlY3RpdmVDYWxsYmFja3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gLS0tIENvZGUgQmxvY2sgRW5oYW5jZW1lbnRzIC0tLVxuICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IGNvbnRlbnREaXYucXVlcnlTZWxlY3RvckFsbCgncHJlIGNvZGUnKTtcbiAgICAgICAgICAgIGNvZGVCbG9ja3MuZm9yRWFjaChibG9jayA9PiB7XG4gICAgICAgICAgICAgICAgZW5oYW5jZUNvZGVCbG9jayhibG9jaywgZWZmZWN0aXZlQ2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuZGVyaW5nIG1hcmtkb3duOicsIGVycm9yKTtcbiAgICAgICAgICAgIGNvbnRlbnREaXYudGV4dENvbnRlbnQgPSBjb21wbGV0ZVJlc3BvbnNlOyAvLyBGYWxsYmFjayB0byBwbGFpbiB0ZXh0XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnREaXY7XG59XG4vKipcbiAqIEVuaGFuY2VzIGEgY29kZSBibG9jayBlbGVtZW50IHdpdGggaGlnaGxpZ2h0aW5nIGFuZCBhY3Rpb24gYnV0dG9ucy5cbiAqXG4gKiBAcGFyYW0gY29kZUJsb2NrRWxlbWVudCBUaGUgPGNvZGU+IGVsZW1lbnQgd2l0aGluIGEgPHByZT4uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgYWN0aW9ucyBsaWtlIGNvcHkgY29kZSwgYWRkIHRvIGNlbGwuXG4gKi9cbmZ1bmN0aW9uIGVuaGFuY2VDb2RlQmxvY2soY29kZUJsb2NrRWxlbWVudCwgY2FsbGJhY2tzID0ge30pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcHJlRWxlbWVudCA9IGNvZGVCbG9ja0VsZW1lbnQucGFyZW50RWxlbWVudDtcbiAgICBpZiAoIXByZUVsZW1lbnQgfHwgcHJlRWxlbWVudC50YWdOYW1lICE9PSAnUFJFJykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0NvZGUgYmxvY2sgZW5oYW5jZW1lbnQgY2FsbGVkIG9uIGVsZW1lbnQgbm90IHdpdGhpbiBhIDxwcmU+IHRhZy4nKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBZGQgc3RhbmRhcmQgSnVweXRlckxhYiBjbGFzc2VzIGZvciBjb25zaXN0ZW5jeVxuICAgIGNvZGVCbG9ja0VsZW1lbnQuY2xhc3NMaXN0LmFkZCgnanAtUmVuZGVyZWRUZXh0Jyk7XG4gICAgcHJlRWxlbWVudC5jbGFzc0xpc3QuYWRkKCdqcC1SZW5kZXJlZEhUTUxDb21tb24nKTtcbiAgICAvLyBHZXQgY29kZSBjb250ZW50XG4gICAgY29uc3QgY29kZUNvbnRlbnQgPSBjb2RlQmxvY2tFbGVtZW50LnRleHRDb250ZW50IHx8ICcnO1xuICAgIC8vIENyZWF0ZSBjb2RlIGJsb2NrIGhlYWRlciBmb3IgYnV0dG9ucyBhbmQgbGFuZ3VhZ2UgaW5kaWNhdG9yXG4gICAgY29uc3QgY29kZUhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvZGVIZWFkZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1oZWFkZXInO1xuICAgIC8vIEFkZCBsYW5ndWFnZSBpbmRpY2F0b3IgaWYgZGV0ZWN0ZWRcbiAgICBjb25zdCBsYW5ndWFnZSA9ICgwLCBoaWdobGlnaHRpbmdfMS5kZXRlY3RMYW5ndWFnZSkoY29kZUNvbnRlbnQpOyAvLyBVc2UgaW1wb3J0ZWQgdXRpbFxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgICBjb25zdCBsYW5nSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICBsYW5nSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvZGUtbGFuZ3VhZ2UnO1xuICAgICAgICBsYW5nSW5kaWNhdG9yLnRleHRDb250ZW50ID0gbGFuZ3VhZ2U7XG4gICAgICAgIGNvZGVIZWFkZXIuYXBwZW5kQ2hpbGQobGFuZ0luZGljYXRvcik7XG4gICAgICAgIGNvZGVCbG9ja0VsZW1lbnQuY2xhc3NMaXN0LmFkZChgbGFuZ3VhZ2UtJHtsYW5ndWFnZX1gKTtcbiAgICB9XG4gICAgLy8gQXBwbHkgc3ludGF4IGhpZ2hsaWdodGluZ1xuICAgIHRyeSB7XG4gICAgICAgIC8vIFVzZSBpbXBvcnRlZCB1dGlsIChoYW5kbGVzIGF1dG8tZGV0ZWN0aW9uIGlmIGxhbmd1YWdlIGlzIGVtcHR5KVxuICAgICAgICBjb2RlQmxvY2tFbGVtZW50LmlubmVySFRNTCA9ICgwLCBoaWdobGlnaHRpbmdfMS5oaWdobGlnaHRDb2RlKShjb2RlQ29udGVudCwgbGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYXBwbHlpbmcgc3ludGF4IGhpZ2hsaWdodGluZzonLCBlcnJvcik7XG4gICAgICAgIC8vIGNvZGVCbG9ja0VsZW1lbnQgbWlnaHQgY29udGFpbiBvcmlnaW5hbCB0ZXh0IG9yIHBhcnRpYWxseSBoaWdobGlnaHRlZFxuICAgIH1cbiAgICAvLyBBZGQgYWN0aW9uIGJ1dHRvbnMgdG8gdGhlIGNvZGUgaGVhZGVyXG4gICAgY29uc3QgYWN0aW9uc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGFjdGlvbnNEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1hY3Rpb25zJztcbiAgICAvLyBDb3B5IGJ1dHRvblxuICAgIGlmIChjYWxsYmFja3MuY29weVRvQ2xpcGJvYXJkICYmIGNhbGxiYWNrcy5zaG93Q29weUZlZWRiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNvcHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY29weUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb2RlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBjb3B5QnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE0XCIgaGVpZ2h0PVwiMTRcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBjb3B5QnV0dG9uLnRpdGxlID0gJ0NvcHkgY29kZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICBjb25zdCBmZWVkYmFja0NiID0gKCkgPT4gY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2soY29weUJ1dHRvbik7XG4gICAgICAgIGNvcHlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLmNvcHlUb0NsaXBib2FyZChjb2RlQ29udGVudCwgZmVlZGJhY2tDYik7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGNvcHlCdXR0b24pO1xuICAgIH1cbiAgICAvLyBBZGQgdG8gY2VsbCBidXR0b25cbiAgICBpZiAoY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwpIHtcbiAgICAgICAgY29uc3QgYWRkVG9CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgYWRkVG9CdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29kZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgYWRkVG9CdXR0b24uaW5uZXJIVE1MID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTRcIiBoZWlnaHQ9XCIxNFwiIHZpZXdCb3g9XCIwIDAgMjQgMjRcIiBmaWxsPVwibm9uZVwiIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiIHN0cm9rZS13aWR0aD1cIjJcIiBzdHJva2UtbGluZWNhcD1cInJvdW5kXCIgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIj48cGF0aCBkPVwiTTE2IDRoMmEyIDIgMCAwIDEgMiAydjE0YTIgMiAwIDAgMS0yIDJINmEyIDIgMCAwIDEtMi0yVjZhMiAyIDAgMCAxIDItMmgyXCI+PC9wYXRoPjxyZWN0IHg9XCI4XCIgeT1cIjJcIiB3aWR0aD1cIjhcIiBoZWlnaHQ9XCI0XCIgcng9XCIxXCIgcnk9XCIxXCI+PC9yZWN0PjxwYXRoIGQ9XCJNMTIgMTF2NlwiPjwvcGF0aD48cGF0aCBkPVwiTTkgMTRoNlwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBhZGRUb0J1dHRvbi50aXRsZSA9ICdBZGQgY29kZSB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICBhZGRUb0J1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBjYWxsYmFja3MuYWRkTWVzc2FnZVRvQ2VsbChjb2RlQ29udGVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zRGl2LmFwcGVuZENoaWxkKGFkZFRvQnV0dG9uKTtcbiAgICB9XG4gICAgLy8gQWRkIHRoZSBhY3Rpb25zIHRvIHRoZSBoZWFkZXIsIGFuZCBpbnNlcnQgaGVhZGVyIGJlZm9yZSB0aGUgPHByZT5cbiAgICBpZiAoYWN0aW9uc0Rpdi5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgY29kZUhlYWRlci5hcHBlbmRDaGlsZChhY3Rpb25zRGl2KTtcbiAgICB9XG4gICAgaWYgKGNvZGVIZWFkZXIuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIChfYSA9IHByZUVsZW1lbnQucGFyZW50Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmluc2VydEJlZm9yZShjb2RlSGVhZGVyLCBwcmVFbGVtZW50KTtcbiAgICB9XG59XG4vKipcbiAqIFJlbmRlcnMgQ29uZmlybS9SZWplY3QgYnV0dG9ucyBmb3IgYW4gaW50ZXJydXB0IG1lc3NhZ2UuXG4gKlxuICogQHBhcmFtIGNvbnRhaW5lciBUaGUgcGFyZW50IEhUTUwgZWxlbWVudCAobWVzc2FnZSBjb250ZW50IGRpdikgdG8gYXBwZW5kIGJ1dHRvbnMgdG8uXG4gKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgY29uZmlybSBhbmQgcmVqZWN0IGFjdGlvbnMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckludGVycnVwdEJ1dHRvbnMoY29udGFpbmVyLCBjYWxsYmFja3MgPSB7fSkge1xuICAgIGlmICghY2FsbGJhY2tzLmhhbmRsZUNvbmZpcm1JbnRlcnJ1cHQgfHwgIWNhbGxiYWNrcy5oYW5kbGVSZWplY3RJbnRlcnJ1cHQpIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdJbnRlcnJ1cHQgbWVzc2FnZSBuZWVkcyBjb25maXJtL3JlamVjdCBjYWxsYmFja3MuJyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgYnV0dG9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGJ1dHRvbnNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW50ZXJydXB0LWJ1dHRvbnMnO1xuICAgIGJ1dHRvbnNDb250YWluZXIuc3R5bGUubWFyZ2luVG9wID0gJzEycHgnO1xuICAgIGJ1dHRvbnNDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICBidXR0b25zQ29udGFpbmVyLnN0eWxlLmdhcCA9ICc4cHgnO1xuICAgIC8vIENyZWF0ZSBjb25maXJtIGJ1dHRvblxuICAgIGNvbnN0IGNvbmZpcm1CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICBjb25maXJtQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbmZpcm0tYnV0dG9uJztcbiAgICBjb25maXJtQnV0dG9uLnRleHRDb250ZW50ID0gJ0NvbmZpcm0nO1xuICAgIC8vIEFwcGx5IHNwZWNpZmljIHN0eWxpbmcgKGNhbiBiZSBtb3ZlZCB0byBDU1MpXG4gICAgY29uZmlybUJ1dHRvbi5zdHlsZS5wYWRkaW5nID0gJzZweCAxMnB4JztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmJhY2tncm91bmQgPSAnIzRDQUY1MCc7XG4gICAgY29uZmlybUJ1dHRvbi5zdHlsZS5jb2xvciA9ICd3aGl0ZSc7XG4gICAgY29uZmlybUJ1dHRvbi5zdHlsZS5ib3JkZXIgPSAnbm9uZSc7XG4gICAgY29uZmlybUJ1dHRvbi5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICBjb25maXJtQnV0dG9uLnN0eWxlLmZvbnRXZWlnaHQgPSAnYm9sZCc7XG4gICAgLy8gQ3JlYXRlIHJlamVjdCBidXR0b25cbiAgICBjb25zdCByZWplY3RCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICByZWplY3RCdXR0b24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcmVqZWN0LWJ1dHRvbic7XG4gICAgcmVqZWN0QnV0dG9uLnRleHRDb250ZW50ID0gJ1JlamVjdCc7XG4gICAgLy8gQXBwbHkgc3BlY2lmaWMgc3R5bGluZyAoY2FuIGJlIG1vdmVkIHRvIENTUylcbiAgICByZWplY3RCdXR0b24uc3R5bGUucGFkZGluZyA9ICc2cHggMTJweCc7XG4gICAgcmVqZWN0QnV0dG9uLnN0eWxlLmJhY2tncm91bmQgPSAnI0Y0NDMzNic7XG4gICAgcmVqZWN0QnV0dG9uLnN0eWxlLmNvbG9yID0gJ3doaXRlJztcbiAgICByZWplY3RCdXR0b24uc3R5bGUuYm9yZGVyID0gJ25vbmUnO1xuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5ib3JkZXJSYWRpdXMgPSAnNHB4JztcbiAgICByZWplY3RCdXR0b24uc3R5bGUuY3Vyc29yID0gJ3BvaW50ZXInO1xuICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgIC8vIEFkZCBldmVudCBsaXN0ZW5lcnNcbiAgICBjb25maXJtQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBjb25maXJtQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIGNhbGxiYWNrcy5oYW5kbGVDb25maXJtSW50ZXJydXB0KCk7XG4gICAgfSk7XG4gICAgcmVqZWN0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICBjb25maXJtQnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0QnV0dG9uLmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgY29uZmlybUJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIHJlamVjdEJ1dHRvbi5zdHlsZS5vcGFjaXR5ID0gJzAuNSc7XG4gICAgICAgIGNhbGxiYWNrcy5oYW5kbGVSZWplY3RJbnRlcnJ1cHQoKTtcbiAgICB9KTtcbiAgICAvLyBBZGQgYnV0dG9ucyB0byBjb250YWluZXIgYW5kIGNvbnRhaW5lciB0byBtZXNzYWdlXG4gICAgYnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChjb25maXJtQnV0dG9uKTtcbiAgICBidXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlamVjdEJ1dHRvbik7XG4gICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGJ1dHRvbnNDb250YWluZXIpO1xufVxuLyoqXG4gKiBBZGRzIG92ZXJhbGwgYWN0aW9uIGJ1dHRvbnMgKENvcHksIEFkZCB0byBDZWxsKSB0byBhIGJvdCBtZXNzYWdlIGNvbnRhaW5lci5cbiAqXG4gKiBAcGFyYW0gbWVzc2FnZURpdiBUaGUgbWFpbiBkaXYgY29udGFpbmVyIGZvciB0aGUgYm90IG1lc3NhZ2UuXG4gKiBAcGFyYW0gbWVzc2FnZVRleHQgVGhlIHJhdyB0ZXh0IGNvbnRlbnQgb2YgdGhlIG1lc3NhZ2UuXG4gKiBAcGFyYW0gY2FsbGJhY2tzIENhbGxiYWNrcyBmb3IgYWN0aW9ucyBsaWtlIGNvcHkgbWVzc2FnZSwgYWRkIHRvIGNlbGwuXG4gKi9cbmZ1bmN0aW9uIGFkZEJvdE1lc3NhZ2VBY3Rpb25zKG1lc3NhZ2VEaXYsIG1lc3NhZ2VUZXh0LCBjYWxsYmFja3MgPSB7fSkge1xuICAgIC8vIE9ubHkgYWRkIGFjdGlvbnMgaWYgY29ycmVzcG9uZGluZyBjYWxsYmFja3MgYXJlIHByb3ZpZGVkXG4gICAgaWYgKCFjYWxsYmFja3MuY29weU1lc3NhZ2VUb0NsaXBib2FyZCAmJiAhY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZygnQWRkaW5nIGFjdGlvbiBidXR0b25zIHRvIGJvdCBtZXNzYWdlJyk7IC8vIEtlZXAgZGVidWcgbG9nIGZvciBub3dcbiAgICBjb25zdCBhY3Rpb25zRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYWN0aW9uc0Rpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbnMnO1xuICAgIC8vIGFjdGlvbnNEaXYuc3R5bGUuZGlzcGxheSA9ICdmbGV4JzsgLy8gRW5zdXJlIGRpc3BsYXkgdmlhIENTUyBpZiBuZWVkZWRcbiAgICAvLyBDb3B5IE1lc3NhZ2UgYnV0dG9uXG4gICAgaWYgKGNhbGxiYWNrcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkICYmIGNhbGxiYWNrcy5zaG93Q29weUZlZWRiYWNrKSB7XG4gICAgICAgIGNvbnN0IGNvcHlCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgICAgY29weUJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBjb3B5QnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHJlY3QgeD1cIjlcIiB5PVwiOVwiIHdpZHRoPVwiMTNcIiBoZWlnaHQ9XCIxM1wiIHJ4PVwiMlwiIHJ5PVwiMlwiPjwvcmVjdD48cGF0aCBkPVwiTTUgMTVINGEyIDIgMCAwIDEtMi0yVjRhMiAyIDAgMCAxIDItMmg5YTIgMiAwIDAgMSAyIDJ2MVwiPjwvcGF0aD48L3N2Zz4nO1xuICAgICAgICBjb3B5QnV0dG9uLnRpdGxlID0gJ0NvcHkgbWVzc2FnZSB0byBjbGlwYm9hcmQnO1xuICAgICAgICBjb25zdCBmZWVkYmFja0NiID0gKCkgPT4gY2FsbGJhY2tzLnNob3dDb3B5RmVlZGJhY2soY29weUJ1dHRvbik7XG4gICAgICAgIGNvcHlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLmNvcHlNZXNzYWdlVG9DbGlwYm9hcmQobWVzc2FnZVRleHQsIGZlZWRiYWNrQ2IpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChjb3B5QnV0dG9uKTtcbiAgICB9XG4gICAgLy8gQWRkIHRvIENlbGwgYnV0dG9uXG4gICAgaWYgKGNhbGxiYWNrcy5hZGRNZXNzYWdlVG9DZWxsKSB7XG4gICAgICAgIGNvbnN0IGFkZFRvQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGFkZFRvQnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtYWN0aW9uLWJ1dHRvbic7XG4gICAgICAgIGFkZFRvQnV0dG9uLmlubmVySFRNTCA9ICc8c3ZnIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIiB3aWR0aD1cIjE2XCIgaGVpZ2h0PVwiMTZcIiB2aWV3Qm94PVwiMCAwIDI0IDI0XCIgZmlsbD1cIm5vbmVcIiBzdHJva2U9XCJjdXJyZW50Q29sb3JcIiBzdHJva2Utd2lkdGg9XCIyXCIgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiIHN0cm9rZS1saW5lam9pbj1cInJvdW5kXCI+PHBhdGggZD1cIk0xNiA0aDJhMiAyIDAgMCAxIDIgMnYxNGEyIDIgMCAwIDEtMiAySDZhMiAyIDAgMCAxLTItMlY2YTIgMiAwIDAgMSAyLTJoMlwiPjwvcGF0aD48cmVjdCB4PVwiOFwiIHk9XCIyXCIgd2lkdGg9XCI4XCIgaGVpZ2h0PVwiNFwiIHJ4PVwiMVwiIHJ5PVwiMVwiPjwvcmVjdD48cGF0aCBkPVwiTTEyIDExdjZcIj48L3BhdGg+PHBhdGggZD1cIk05IDE0aDZcIj48L3BhdGg+PC9zdmc+JztcbiAgICAgICAgYWRkVG9CdXR0b24udGl0bGUgPSAnQWRkIG1lc3NhZ2UgdG8gY3VycmVudCBjZWxsJztcbiAgICAgICAgYWRkVG9CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgY2FsbGJhY2tzLmFkZE1lc3NhZ2VUb0NlbGwobWVzc2FnZVRleHQpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aW9uc0Rpdi5hcHBlbmRDaGlsZChhZGRUb0J1dHRvbik7XG4gICAgfVxuICAgIC8vIEFwcGVuZCB0aGUgYWN0aW9ucyBjb250YWluZXIgaWYgaXQgaGFzIGFueSBidXR0b25zXG4gICAgaWYgKGFjdGlvbnNEaXYuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgIG1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoYWN0aW9uc0Rpdik7XG4gICAgICAgIGNvbnNvbGUubG9nKCdBY3Rpb24gYnV0dG9ucyBhZGRlZCB0byBib3QgbWVzc2FnZTonLCBhY3Rpb25zRGl2KTsgLy8gS2VlcCBkZWJ1ZyBsb2dcbiAgICB9XG59XG4vLyBQb3RlbnRpYWwgZnV0dXJlIGFkZGl0aW9uczpcbi8vIC0gcmVuZGVyRXJyb3JNZXNzYWdlXG4vLyAtIHJlbmRlclN5c3RlbU1lc3NhZ2Vcbi8vIC0gQSBtYWluIHJlbmRlck1lc3NhZ2UgZnVuY3Rpb24gdGhhdCBkZWxlZ2F0ZXMgYmFzZWQgb24gdHlwZT8gXG4vKipcbiAqIEhhbmRsZXMgcmVuZGVyaW5nIGluZGl2aWR1YWwgbWVzc2FnZXMgKHVzZXIsIGJvdCwgc3lzdGVtKSBpbnRvIEhUTUwgZWxlbWVudHMuXG4gKi9cbmNsYXNzIE1lc3NhZ2VSZW5kZXJlciB7XG4gICAgLy8gcHJpdmF0ZSBjYWxsYmFja3M6IE1lc3NhZ2VSZW5kZXJlckNhbGxiYWNrczsgLy8gUmVtb3ZlZCB1bnVzZWQgbWVtYmVyXG4gICAgLy8gcHJpdmF0ZSB1aU1hbmFnZXI6IFVJTWFuYWdlcjsgLy8gTWlnaHQgbm90IGJlIG5lZWRlZCBkaXJlY3RseSBpZiBjYWxsYmFja3MgaGFuZGxlIFVJIHVwZGF0ZXNcbiAgICBjb25zdHJ1Y3RvciggLyogY2FsbGJhY2tzOiBNZXNzYWdlUmVuZGVyZXJDYWxsYmFja3MgKi8gLyogLCB1aU1hbmFnZXI6IFVJTWFuYWdlciAqLykge1xuICAgICAgICAvLyB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrczsgLy8gUmVtb3ZlZCB1bnVzZWQgYXNzaWdubWVudFxuICAgICAgICAvLyB0aGlzLnVpTWFuYWdlciA9IHVpTWFuYWdlcjtcbiAgICB9XG59XG5leHBvcnRzLk1lc3NhZ2VSZW5kZXJlciA9IE1lc3NhZ2VSZW5kZXJlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXR0aW5nc01vZGFsID0gdm9pZCAwO1xuZXhwb3J0cy5jcmVhdGVTZXR0aW5nc01vZGFsRWxlbWVudCA9IGNyZWF0ZVNldHRpbmdzTW9kYWxFbGVtZW50O1xuLyoqXG4gKiBDcmVhdGVzIHRoZSBIVE1MIGVsZW1lbnQgZm9yIHRoZSBzZXR0aW5ncyBtb2RhbC5cbiAqIEBwYXJhbSBjYWxsYmFja3MgQ2FsbGJhY2tzIGZvciBzYXZlIGFuZCBjYW5jZWwgYWN0aW9ucy5cbiAqIEByZXR1cm5zIFRoZSBtYWluIG1vZGFsIEhUTUxFbGVtZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVTZXR0aW5nc01vZGFsRWxlbWVudChjYWxsYmFja3MpIHtcbiAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIG1vZGFsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLW1vZGFsJztcbiAgICBtb2RhbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgY29uc3QgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNvbnRlbnQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtY29udGVudCc7XG4gICAgY29uc3QgdGl0bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoMicpO1xuICAgIHRpdGxlLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLXRpdGxlJztcbiAgICB0aXRsZS50ZXh0Q29udGVudCA9ICdTZXR0aW5ncyc7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvcm0nKTtcbiAgICBmb3JtLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWZvcm0nO1xuICAgIC8vIFByb3ZpZGVyIHNlbGVjdGlvblxuICAgIGNvbnN0IHByb3ZpZGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIHByb3ZpZGVyTGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgIHByb3ZpZGVyTGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIFByb3ZpZGVyOic7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChwcm92aWRlckxhYmVsKTtcbiAgICBjb25zdCBwcm92aWRlclNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgIHByb3ZpZGVyU2VsZWN0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLXNlbGVjdCc7XG4gICAgcHJvdmlkZXJTZWxlY3QuaWQgPSAnc2V0dGluZ3MtcHJvdmlkZXInOyAvLyBLZWVwIElEIGZvciByZXRyaWV2YWxcbiAgICBbJ09wZW5BSScsICdIdWdnaW5nRmFjZScsICdMb2NhbCddLmZvckVhY2gob3B0ID0+IHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgIG9wdGlvbi52YWx1ZSA9IG9wdDtcbiAgICAgICAgb3B0aW9uLnRleHRDb250ZW50ID0gb3B0O1xuICAgICAgICBwcm92aWRlclNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgIH0pO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQocHJvdmlkZXJTZWxlY3QpO1xuICAgIC8vIEFQSSBLZXkgaW5wdXRcbiAgICBjb25zdCBhcGlLZXlMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgYXBpS2V5TGFiZWwuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtbGFiZWwnO1xuICAgIGFwaUtleUxhYmVsLnRleHRDb250ZW50ID0gJ0FQSSBLZXk6JztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFwaUtleUxhYmVsKTtcbiAgICBjb25zdCBhcGlLZXlJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgYXBpS2V5SW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtaW5wdXQnO1xuICAgIGFwaUtleUlucHV0LnR5cGUgPSAncGFzc3dvcmQnO1xuICAgIGFwaUtleUlucHV0LmlkID0gJ3NldHRpbmdzLWFwaS1rZXknOyAvLyBLZWVwIElEIGZvciByZXRyaWV2YWxcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFwaUtleUlucHV0KTtcbiAgICAvLyBBUEkgVVJMIGlucHV0XG4gICAgY29uc3QgYXBpVXJsTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgIGFwaVVybExhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWxhYmVsJztcbiAgICBhcGlVcmxMYWJlbC50ZXh0Q29udGVudCA9ICdBUEkgVVJMIChvcHRpb25hbCk6JztcbiAgICBmb3JtLmFwcGVuZENoaWxkKGFwaVVybExhYmVsKTtcbiAgICBjb25zdCBhcGlVcmxJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgYXBpVXJsSW5wdXQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtaW5wdXQnO1xuICAgIGFwaVVybElucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgYXBpVXJsSW5wdXQuaWQgPSAnc2V0dGluZ3MtYXBpLXVybCc7IC8vIEtlZXAgSUQgZm9yIHJldHJpZXZhbFxuICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXBpVXJsSW5wdXQpO1xuICAgIC8vIFJ1bGVzIGlucHV0XG4gICAgY29uc3QgcnVsZXNMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgcnVsZXNMYWJlbC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy1sYWJlbCc7XG4gICAgcnVsZXNMYWJlbC50ZXh0Q29udGVudCA9ICdDdXN0b20gUnVsZXMgKG9wdGlvbmFsKTonO1xuICAgIGZvcm0uYXBwZW5kQ2hpbGQocnVsZXNMYWJlbCk7XG4gICAgY29uc3QgcnVsZXNJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgcnVsZXNJbnB1dC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1zZXR0aW5ncy10ZXh0YXJlYSc7XG4gICAgcnVsZXNJbnB1dC5pZCA9ICdzZXR0aW5ncy1ydWxlcyc7IC8vIEtlZXAgSUQgZm9yIHJldHJpZXZhbFxuICAgIGZvcm0uYXBwZW5kQ2hpbGQocnVsZXNJbnB1dCk7XG4gICAgLy8gQnV0dG9ucyBjb250YWluZXJcbiAgICBjb25zdCBidG5Db250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBidG5Db250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtYnV0dG9ucyc7XG4gICAgY29uc3Qgc2F2ZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIHNhdmVCdG4uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc2V0dGluZ3MtYnV0dG9uIGpwLWxsbS1leHQtc2V0dGluZ3Mtc2F2ZS1idXR0b24nO1xuICAgIHNhdmVCdG4udGV4dENvbnRlbnQgPSAnU2F2ZSc7XG4gICAgc2F2ZUJ0bi50eXBlID0gJ2J1dHRvbic7IC8vIFByZXZlbnQgZGVmYXVsdCBmb3JtIHN1Ym1pc3Npb25cbiAgICBzYXZlQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIC8vIFRoZSBjYWxsYmFjayBpbXBsZW1lbnRhdGlvbiB3aWxsIGhhbmRsZSByZWFkaW5nIHZhbHVlcyBhbmQgc2F2aW5nXG4gICAgICAgIGNvbnN0IHNldHRpbmdzID0ge1xuICAgICAgICAgICAgYXBpS2V5OiBhcGlLZXlJbnB1dC52YWx1ZSxcbiAgICAgICAgICAgIGFwaVVybDogYXBpVXJsSW5wdXQudmFsdWUsXG4gICAgICAgICAgICBydWxlczogcnVsZXNJbnB1dC52YWx1ZSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiBwcm92aWRlclNlbGVjdC52YWx1ZVxuICAgICAgICB9O1xuICAgICAgICBjYWxsYmFja3MuaGFuZGxlU2F2ZShzZXR0aW5ncyk7XG4gICAgfSk7XG4gICAgY29uc3QgY2FuY2VsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgY2FuY2VsQnRuLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNldHRpbmdzLWJ1dHRvbiBqcC1sbG0tZXh0LXNldHRpbmdzLWNhbmNlbC1idXR0b24nO1xuICAgIGNhbmNlbEJ0bi50ZXh0Q29udGVudCA9ICdDYW5jZWwnO1xuICAgIGNhbmNlbEJ0bi50eXBlID0gJ2J1dHRvbic7IC8vIFByZXZlbnQgZGVmYXVsdCBmb3JtIHN1Ym1pc3Npb25cbiAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgY2FsbGJhY2tzLmhhbmRsZUNhbmNlbCgpO1xuICAgIH0pO1xuICAgIGJ0bkNvbnRhaW5lci5hcHBlbmRDaGlsZChzYXZlQnRuKTtcbiAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoY2FuY2VsQnRuKTtcbiAgICBmb3JtLmFwcGVuZENoaWxkKGJ0bkNvbnRhaW5lcik7XG4gICAgY29udGVudC5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICBtb2RhbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICByZXR1cm4gbW9kYWw7XG59XG4vKipcbiAqIENyZWF0ZXMgYW5kIG1hbmFnZXMgdGhlIHNldHRpbmdzIG1vZGFsIGRpYWxvZy5cbiAqL1xuY2xhc3MgU2V0dGluZ3NNb2RhbCB7XG4gICAgLy8gcHJpdmF0ZSBtb2RhbEVsZW1lbnQ6IEhUTUxEaXZFbGVtZW50OyAvLyBDb21tZW50ZWQgb3V0IC0gdW51c2VkXG4gICAgLy8gcHJpdmF0ZSBzZXR0aW5nczogQXBwU2V0dGluZ3M7IC8vIENvbW1lbnRlZCBvdXQgLSB1bnVzZWRcbiAgICBjb25zdHJ1Y3RvcihjYWxsYmFja3MpIHtcbiAgICAgICAgLy8gdGhpcy5tb2RhbEVsZW1lbnQgPSBjcmVhdGVTZXR0aW5nc01vZGFsRWxlbWVudChjYWxsYmFja3MpOyAvLyBDb21tZW50ZWQgb3V0IC0gdW51c2VkIGFzc2lnbm1lbnRcbiAgICAgICAgLy8gdGhpcy5zZXR0aW5ncyA9IHsgLy8gQ29tbWVudGVkIG91dCAtIHVudXNlZCBpbml0aWFsaXphdGlvblxuICAgICAgICAvLyAgICAgcHJvdmlkZXI6ICcnLCBcbiAgICAgICAgLy8gICAgIGFwaUtleTogJycsIFxuICAgICAgICAvLyAgICAgYXBpVXJsOiAnJywgXG4gICAgICAgIC8vICAgICBydWxlczogJycgXG4gICAgICAgIC8vIH07IFxuICAgIH1cbn1cbmV4cG9ydHMuU2V0dGluZ3NNb2RhbCA9IFNldHRpbmdzTW9kYWw7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVUlNYW5hZ2VyID0gdm9pZCAwO1xuLyoqXG4gKiBNYW5hZ2VzIFVJIGVsZW1lbnRzIGFuZCB0cmFuc2l0aW9ucyBmb3IgdGhlIGNoYXQgaW50ZXJmYWNlLlxuICogVGhpcyBhY3RzIGFzIGEgY2VudHJhbCBwb2ludCBmb3IgVUkgbWFuaXB1bGF0aW9ucywgc2ltcGxpZnlpbmcgZGVwZW5kZW5jaWVzIGZvciBoYW5kbGVycy5cbiAqL1xuY2xhc3MgVUlNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cE1lbnVNYW5hZ2VyLCBjYWxsYmFja3MsIGxheW91dEVsZW1lbnRzKSB7XG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uVGltZW91dCA9IG51bGw7IC8vIFRpbWVvdXQgZm9yIHRoZSBzaG9ydGN1dCBpbmRpY2F0b3JcbiAgICAgICAgLy8gSW50ZXJuYWwgVUkgc3RhdGVcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc01hcmtkb3duTW9kZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIgPSBwb3B1cE1lbnVNYW5hZ2VyO1xuICAgICAgICB0aGlzLmNhbGxiYWNrcyA9IGNhbGxiYWNrcztcbiAgICAgICAgdGhpcy5sYXlvdXRFbGVtZW50cyA9IGxheW91dEVsZW1lbnRzOyAvLyBTdG9yZSB0aGUgbGF5b3V0IGVsZW1lbnRzIHBhc3NlZCBpblxuICAgICAgICAvLyBBc3NpZ24gY2xhc3MgcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBwYXNzZWQgbGF5b3V0RWxlbWVudHNcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gbGF5b3V0RWxlbWVudHMuaW5wdXRGaWVsZDsgLy8gVXNlIHByb3ZpZGVkIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lciA9IGxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXI7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lciA9IGxheW91dEVsZW1lbnRzLmhpc3RvcnlDb250YWluZXI7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dCA9IGxheW91dEVsZW1lbnRzLnRpdGxlSW5wdXQ7XG4gICAgICAgIHRoaXMuYm90dG9tQmFyQ29udGFpbmVyID0gbGF5b3V0RWxlbWVudHMuYm90dG9tQmFyQ29udGFpbmVyO1xuICAgICAgICAvLyBJbml0aWFsaXplIGFuZCBhcHBlbmQgdGhlIGtleWJvYXJkIHNob3J0Y3V0IGluZGljYXRvclxuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXNob3J0Y3V0LWluZGljYXRvcic7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBIaWRkZW4gYnkgZGVmYXVsdFxuICAgICAgICAvLyBBcHBlbmQgdGhlIGluZGljYXRvciB0byB0aGUgbWFpbiBsYXlvdXQgb3IgYW5vdGhlciBhcHByb3ByaWF0ZSBwbGFjZVxuICAgICAgICAvLyBFbnN1cmUgdGhlIG5lY2Vzc2FyeSBlbGVtZW50IChlLmcuLCBib3R0b21CYXJDb250YWluZXIpIGV4aXN0cyBiZWZvcmUgYXBwZW5kaW5nXG4gICAgICAgIGlmICh0aGlzLmJvdHRvbUJhckNvbnRhaW5lcikgeyAvLyBDaGVjayBpZiBib3R0b21CYXJDb250YWluZXIgZXhpc3RzIGZyb20gbGF5b3V0RWxlbWVudHNcbiAgICAgICAgICAgIC8vIFByZXBlbmQgd2l0aGluIHRoZSBtYWluIGNvbnRlbnQgd3JhcHBlciwgYmVmb3JlIG90aGVyIGVsZW1lbnRzXG4gICAgICAgICAgICAvLyBPciBhcHBlbmQgdG8gYm90dG9tIGJhciwgZGVwZW5kaW5nIG9uIGRlc2lyZWQgcG9zaXRpb25cbiAgICAgICAgICAgIC8vIEFwcGVuZGluZyBhZnRlciBib3R0b21CYXJDb250YWluZXIgc2VlbXMgcmVhc29uYWJsZVxuICAgICAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIuaW5zZXJ0QWRqYWNlbnRFbGVtZW50KCdhZnRlcmVuZCcsIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBJZiBib3R0b21CYXJDb250YWluZXIgaXMgbm90IGF2YWlsYWJsZSwgbWF5YmUgYXBwZW5kIHRvIG1haW5FbGVtZW50PyBcbiAgICAgICAgICAgIC8vIE9yIGxvZyBhbiBlcnJvciBpZiBpdCdzIGVzc2VudGlhbC5cbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1VJTWFuYWdlcjogYm90dG9tQmFyQ29udGFpbmVyIGVsZW1lbnQgbm90IGZvdW5kIGR1cmluZyBpbmRpY2F0b3IgaW5pdGlhbGl6YXRpb24uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY29yZSBsYXlvdXQgZWxlbWVudHMuXG4gICAgICovXG4gICAgZ2V0VUlFbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGF5b3V0RWxlbWVudHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIG1haW4gbGF5b3V0IHN0cnVjdHVyZSBmb3IgdGhlIHNpZGViYXIuXG4gICAgICogQHJldHVybnMgUmVmZXJlbmNlcyB0byBrZXkgRE9NIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtYWluQ29udGVudC5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1jb250ZW50LXdyYXBwZXInO1xuICAgICAgICAvLyAtLS0gVGl0bGUgQ29udGFpbmVyIC0tLVxuICAgICAgICBjb25zdCB0aXRsZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aXRsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10aXRsZS1jb250YWluZXInO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQuY2xhc3NOYW1lID0gJ2NoYXQtdGl0bGUtaW5wdXQnO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnBsYWNlaG9sZGVyID0gJ0NoYXQgdGl0bGUnO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSAnTmV3IENoYXQnOyAvLyBEZWZhdWx0IHZhbHVlLCB3aWRnZXQgbWlnaHQgdXBkYXRlIGxhdGVyXG4gICAgICAgIHRoaXMudGl0bGVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB0aGlzLmNhbGxiYWNrcy5oYW5kbGVVcGRhdGVUaXRsZSk7XG4gICAgICAgIHRpdGxlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMudGl0bGVJbnB1dCk7XG4gICAgICAgIC8vIC0tLSBNZXNzYWdlICYgSGlzdG9yeSBDb250YWluZXJzIC0tLVxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LW1lc3NhZ2UtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWNvbnRhaW5lcic7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBJbml0aWFsbHkgaGlkZGVuXG4gICAgICAgIC8vIC0tLSBCb3R0b20gQmFyIC0tLVxuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmJvdHRvbUJhckNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENvbnRyb2xzIFJvdyAoTWFya2Rvd24gVG9nZ2xlLCBBY3Rpb24gQnV0dG9ucylcbiAgICAgICAgY29uc3QgdG9wUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvcFJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWNvbnRyb2xzLXJvdyc7XG4gICAgICAgIGNvbnN0IGNvbnRyb2xzQ29udGFpbmVyID0gdGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpOyAvLyBDcmVhdGVzIG1hcmtkb3duIHRvZ2dsZSwgQCwgZXhwYW5kLCBzZXR0aW5nc1xuICAgICAgICB0b3BSb3cuYXBwZW5kQ2hpbGQoY29udHJvbHNDb250YWluZXIpO1xuICAgICAgICAvLyBJbnB1dCBSb3dcbiAgICAgICAgY29uc3QgbWlkZGxlUm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1pZGRsZVJvdy5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3R0b20tYmFyLXJvdyBqcC1sbG0tZXh0LWlucHV0LXJvdyc7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdjb250ZW50ZWRpdGFibGUnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ3RleHRib3gnKTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1tdWx0aWxpbmUnLCAndHJ1ZScpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuc2V0QXR0cmlidXRlKCdkYXRhLXBsYWNlaG9sZGVyJywgJ0FzayBtZSBhbnl0aGluZy4uLicpO1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtZmllbGQnO1xuICAgICAgICAvLyAtLS0gSW5wdXQgRXZlbnQgTGlzdGVuZXIgZm9yIEAgZGV0ZWN0aW9uIC0tLVxuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlSW5wdXRGb3JSZWZlcmVuY2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIC0tLSBFbmQgSW5wdXQgRXZlbnQgTGlzdGVuZXIgLS0tXG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgVUlfTUFOQUdFUiBLZXlEb3duOiBLZXk9JyR7ZXZlbnQua2V5fScsIFNoaWZ0PScke2V2ZW50LnNoaWZ0S2V5fScsIENvZGU9JyR7ZXZlbnQuY29kZX0nYCk7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAvLyAtLS0gQmFja3NwYWNlIGhhbmRsaW5nIGZvciB3aWRnZXRzIC0tLVxuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0JhY2tzcGFjZScgJiYgc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5pc0NvbGxhcHNlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZUJlZm9yZSA9IHJhbmdlLnN0YXJ0Q29udGFpbmVyLmNoaWxkTm9kZXNbcmFuZ2Uuc3RhcnRPZmZzZXQgLSAxXSB8fCByYW5nZS5zdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgLy8gQ2hlY2sgbm9kZUJlZm9yZSBtb3JlIGNhcmVmdWxseVxuICAgICAgICAgICAgICAgIGxldCBwb3RlbnRpYWxXaWRnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChyYW5nZS5zdGFydE9mZnNldCA+IDAgJiYgcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlcy5sZW5ndGggPj0gcmFuZ2Uuc3RhcnRPZmZzZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsV2lkZ2V0ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIuY2hpbGROb2Rlc1tyYW5nZS5zdGFydE9mZnNldCAtIDFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5zdGFydE9mZnNldCA9PT0gMCAmJiByYW5nZS5zdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsV2lkZ2V0ID0gcmFuZ2Uuc3RhcnRDb250YWluZXIucHJldmlvdXNTaWJsaW5nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyYW5nZS5zdGFydENvbnRhaW5lciAhPT0gdGhpcy5pbnB1dEZpZWxkICYmIHJhbmdlLnN0YXJ0Q29udGFpbmVyLnBhcmVudE5vZGUgPT09IHRoaXMuaW5wdXRGaWVsZCAmJiByYW5nZS5zdGFydE9mZnNldCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDdXJzb3IgbWlnaHQgYmUgYXQgdGhlIHN0YXJ0IG9mIGEgdGV4dCBub2RlIGZvbGxvd2luZyBhIHdpZGdldFxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxXaWRnZXQgPSByYW5nZS5zdGFydENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwb3RlbnRpYWxXaWRnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgcG90ZW50aWFsV2lkZ2V0Lm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJlxuICAgICAgICAgICAgICAgICAgICBwb3RlbnRpYWxXaWRnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcC1sbG0tZXh0LXJlZi13aWRnZXQnKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBTdG9wIGRlZmF1bHQgYmFja3NwYWNlXG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFdpZGdldC5yZW1vdmUoKTsgLy8gUmVtb3ZlIHRoZSBlbnRpcmUgd2lkZ2V0IG5vZGVcbiAgICAgICAgICAgICAgICAgICAgLy8gTWFudWFsbHkgdHJpZ2dlciBpbnB1dCBldmVudCBmb3IgY29uc2lzdGVuY3k/XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnLCB7IGJ1YmJsZXM6IHRydWUsIGNhbmNlbGFibGU6IHRydWUgfSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47IC8vIFN0b3AgZnVydGhlciBwcm9jZXNzaW5nIGZvciB0aGlzIGtleWRvd25cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyAtLS0gRW5kIEJhY2tzcGFjZSBoYW5kbGluZyAtLS1cbiAgICAgICAgICAgIC8vIC0tLSBAIEtleSBEaXJlY3QgSGFuZGxpbmcgLS0tXG4gICAgICAgICAgICAvLyBSRU1PVkVEOiBUaGlzIGxvZ2ljIGlzIG5vdyBjZW50cmFsaXplZCBpbiBzaG9ydGN1dC1oYW5kbGVyLnRzXG4gICAgICAgICAgICAvLyAtLS0gRW5kIEAgS2V5IERpcmVjdCBIYW5kbGluZyAtLS1cbiAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdFbnRlcicgJiYgIWV2ZW50LnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IG5ld2xpbmUgaW5zZXJ0aW9uXG4gICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuZ2V0U2VyaWFsaXplZElucHV0KCk7XG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UudHJpbSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFySW5wdXRGaWVsZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLSBOZXc6IEhhbmRsZSBUYWIvRXNjYXBlIGZvciBwb3B1cCBpbnRlcmFjdGlvbiAtLS1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucG9wdXBNZW51TWFuYWdlci5pc1BvcHVwTWVudVZpc2libGUoKSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudC5rZXkgPT09ICdUYWInIHx8IGV2ZW50LmtleSA9PT0gJ0VzY2FwZScgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dVcCcgfHwgZXZlbnQua2V5ID09PSAnQXJyb3dEb3duJyB8fCBldmVudC5rZXkgPT09ICdFbnRlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGV0IHRoZSBQb3B1cE1lbnVNYW5hZ2VyJ3MgZG9jdW1lbnQga2V5ZG93biBoYW5kbGVyIG1hbmFnZSB0aGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBXZSBqdXN0IG5lZWQgdG8gcHJldmVudCB0aGUgZGVmYXVsdCBpbnB1dCBmaWVsZCBiZWhhdmlvclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ICE9PSAnRW50ZXInKSB7IC8vIEFsbG93IEVudGVyIHRvIHBvdGVudGlhbGx5IHdvcmsgaWYgbWVudSBkb2Vzbid0IGhhbmRsZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHN0b3AgcHJvcGFnYXRpb24gaGVyZTsgbGV0IHRoZSBkb2N1bWVudCBoYW5kbGVyIGluIFBvcHVwTWVudU1hbmFnZXIgcmVjZWl2ZSBpdC5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIC0tLSBFbmQgTmV3IC0tLVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gLS0tIENvcHkvUGFzdGUgRXZlbnQgTGlzdGVuZXJzIC0tLVxuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDb3B5KGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5hZGRFdmVudExpc3RlbmVyKCdwYXN0ZScsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXN0ZShldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAtLS0gRW5kIENvcHkvUGFzdGUgLS0tXG4gICAgICAgIG1pZGRsZVJvdy5hcHBlbmRDaGlsZCh0aGlzLmlucHV0RmllbGQpO1xuICAgICAgICAvLyBCdXR0b25zIFJvdyAoU2VuZCwgTmV3IENoYXQsIEhpc3RvcnkpXG4gICAgICAgIGNvbnN0IGJvdHRvbVJvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBib3R0b21Sb3cuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtYm90dG9tLWJhci1yb3cganAtbGxtLWV4dC1idXR0b25zLXJvdyc7XG4gICAgICAgIGNvbnN0IHNlbmRCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbignU2VuZCcsICdTZW5kIG1lc3NhZ2UnKTtcbiAgICAgICAgc2VuZEJ1dHRvbi5jbGFzc0xpc3QuYWRkKCdqcC1sbG0tZXh0LXNlbmQtYnV0dG9uJyk7IC8vIFNwZWNpZmljIGNsYXNzIGZvciBzZW5kXG4gICAgICAgIHNlbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gdGhpcy5nZXRTZXJpYWxpemVkSW5wdXQoKTtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLmhhbmRsZVNlbmRNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbnB1dEZpZWxkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBuZXdDaGF0QnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oJysgTmV3IENoYXQnLCAnU3RhcnQgYSBuZXcgY2hhdCcpO1xuICAgICAgICBuZXdDaGF0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jYWxsYmFja3MuaGFuZGxlTmV3Q2hhdCk7XG4gICAgICAgIGNvbnN0IGhpc3RvcnlCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbignSGlzdG9yeScsICdWaWV3IGNoYXQgaGlzdG9yeScpO1xuICAgICAgICBoaXN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jYWxsYmFja3MuaGFuZGxlVG9nZ2xlSGlzdG9yeSk7XG4gICAgICAgIGJvdHRvbVJvdy5hcHBlbmRDaGlsZChzZW5kQnV0dG9uKTtcbiAgICAgICAgYm90dG9tUm93LmFwcGVuZENoaWxkKG5ld0NoYXRCdXR0b24pO1xuICAgICAgICBib3R0b21Sb3cuYXBwZW5kQ2hpbGQoaGlzdG9yeUJ1dHRvbik7XG4gICAgICAgIC8vIEFzc2VtYmxlIEJvdHRvbSBCYXJcbiAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQodG9wUm93KTtcbiAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQobWlkZGxlUm93KTtcbiAgICAgICAgdGhpcy5ib3R0b21CYXJDb250YWluZXIuYXBwZW5kQ2hpbGQoYm90dG9tUm93KTtcbiAgICAgICAgLy8gLS0tIEFzc2VtYmxlIE1haW4gQ29udGVudCAtLS1cbiAgICAgICAgbWFpbkNvbnRlbnQuYXBwZW5kQ2hpbGQodGl0bGVDb250YWluZXIpO1xuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VDb250YWluZXIpO1xuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmhpc3RvcnlDb250YWluZXIpO1xuICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZCh0aGlzLmJvdHRvbUJhckNvbnRhaW5lcik7XG4gICAgICAgIC8vIFJldHVybiByZWZlcmVuY2VzIHRvIGtleSBlbGVtZW50c1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWFpbkxheW91dDogbWFpbkNvbnRlbnQsXG4gICAgICAgICAgICBtZXNzYWdlQ29udGFpbmVyOiB0aGlzLm1lc3NhZ2VDb250YWluZXIsXG4gICAgICAgICAgICBpbnB1dEZpZWxkOiB0aGlzLmlucHV0RmllbGQsXG4gICAgICAgICAgICB0aXRsZUlucHV0OiB0aGlzLnRpdGxlSW5wdXQsXG4gICAgICAgICAgICBoaXN0b3J5Q29udGFpbmVyOiB0aGlzLmhpc3RvcnlDb250YWluZXIsXG4gICAgICAgICAgICBib3R0b21CYXJDb250YWluZXI6IHRoaXMuYm90dG9tQmFyQ29udGFpbmVyLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBjb250cm9scyBjb250YWluZXIgd2l0aCB0b2dnbGVzIGFuZCBhY3Rpb24gYnV0dG9ucy5cbiAgICAgKi9cbiAgICBjcmVhdGVDb250cm9sc0NvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29udHJvbHMtY29udGFpbmVyJztcbiAgICAgICAgLy8gLS0tIE1hcmtkb3duIFRvZ2dsZSAtLS1cbiAgICAgICAgY29uc3QgdG9nZ2xlQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC10b2dnbGUtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5tYXJrZG93blRvZ2dsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMubWFya2Rvd25Ub2dnbGUudHlwZSA9ICdjaGVja2JveCc7XG4gICAgICAgIHRoaXMubWFya2Rvd25Ub2dnbGUuaWQgPSAnbWFya2Rvd24tdG9nZ2xlJzsgLy8gRW5zdXJlIHVuaXF1ZSBJRCBvciBoYW5kbGUgZGlmZmVyZW50bHlcbiAgICAgICAgdGhpcy5tYXJrZG93blRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCAoZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZS50YXJnZXQ7XG4gICAgICAgICAgICB0aGlzLmlzTWFya2Rvd25Nb2RlID0gdGFyZ2V0LmNoZWNrZWQ7XG4gICAgICAgICAgICBjb25zdCBwbGFjZWhvbGRlclRleHQgPSB0aGlzLmlzTWFya2Rvd25Nb2RlXG4gICAgICAgICAgICAgICAgPyAnV3JpdGUgbWFya2Rvd24gaGVyZS4uLlxcXFxuXFxcXG4jIEV4YW1wbGUgaGVhZGluZ1xcXFxuLSBMaXN0IGl0ZW1cXFxcblxcXFxuYGBgY29kZSBibG9ja2BgYCdcbiAgICAgICAgICAgICAgICA6ICdBc2sgbWUgYW55dGhpbmcuLi4nO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnNldEF0dHJpYnV0ZSgnZGF0YS1wbGFjZWhvbGRlcicsIHBsYWNlaG9sZGVyVGV4dCk7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuYmx1cigpO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0b2dnbGVMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHRvZ2dsZUxhYmVsLmh0bWxGb3IgPSAnbWFya2Rvd24tdG9nZ2xlJztcbiAgICAgICAgdG9nZ2xlTGFiZWwudGV4dENvbnRlbnQgPSAnTWFya2Rvd24gbW9kZSc7XG4gICAgICAgIHRvZ2dsZUNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1hcmtkb3duVG9nZ2xlKTtcbiAgICAgICAgdG9nZ2xlQ29udGFpbmVyLmFwcGVuZENoaWxkKHRvZ2dsZUxhYmVsKTtcbiAgICAgICAgLy8gLS0tIEFjdGlvbiBCdXR0b25zIChALCBFeHBhbmQsIFNldHRpbmdzKSAtLS1cbiAgICAgICAgY29uc3QgYWN0aW9uQnV0dG9uc0NvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWFjdGlvbi1idXR0b25zLWNvbnRhaW5lcic7XG4gICAgICAgIC8vICdAJyBCdXR0b25cbiAgICAgICAgY29uc3QgYXRCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbignQCcsICdCcm93c2UgY2VsbHMsIGNvZGUsIGZpbGVzLCBhbmQgbW9yZScpO1xuICAgICAgICBhdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jYWxsYmFja3MuaGFuZGxlU2hvd1BvcHVwTWVudShldmVudCwgZXZlbnQuY3VycmVudFRhcmdldCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBFeHBhbmQgQnV0dG9uIChzdG9yZSByZWZlcmVuY2UpXG4gICAgICAgIHRoaXMuZXhwYW5kQnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oJ+KkoicsICdFeHBhbmQgaW5wdXQnKTtcbiAgICAgICAgdGhpcy5leHBhbmRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKCkpO1xuICAgICAgICAvLyBTZXR0aW5ncyBCdXR0b25cbiAgICAgICAgY29uc3Qgc2V0dGluZ3NCdXR0b24gPSB0aGlzLmNyZWF0ZUJ1dHRvbign4pqZ77iPJywgJ1NldHRpbmdzJyk7XG4gICAgICAgIHNldHRpbmdzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5jYWxsYmFja3MuaGFuZGxlU2hvd1NldHRpbmdzKTtcbiAgICAgICAgLy8gQWRkIGJ1dHRvbnMgdG8gY29udGFpbmVyXG4gICAgICAgIGFjdGlvbkJ1dHRvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoYXRCdXR0b24pO1xuICAgICAgICBhY3Rpb25CdXR0b25zQ29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZXhwYW5kQnV0dG9uKTtcbiAgICAgICAgYWN0aW9uQnV0dG9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZXR0aW5nc0J1dHRvbik7XG4gICAgICAgIC8vIEFzc2VtYmxlIENvbnRyb2xzIENvbnRhaW5lclxuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZCh0b2dnbGVDb250YWluZXIpO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25CdXR0b25zQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzQ29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSBleHBhbnNpb24gc3RhdGUgb2YgdGhlIGlucHV0IGZpZWxkLlxuICAgICAqL1xuICAgIHRvZ2dsZUlucHV0RXhwYW5zaW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXRGaWVsZCB8fCAhdGhpcy5leHBhbmRCdXR0b24pXG4gICAgICAgICAgICByZXR1cm47IC8vIEVuc3VyZSBlbGVtZW50cyBleGlzdFxuICAgICAgICB0aGlzLmlzSW5wdXRFeHBhbmRlZCA9ICF0aGlzLmlzSW5wdXRFeHBhbmRlZDtcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUuaGVpZ2h0ID0gJzIwMHB4JzsgLy8gS2VlcCBmb3Igbm93LCBjb25zaWRlciBDU1MgY2xhc3Nlc1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLnJlc2l6ZSA9ICd2ZXJ0aWNhbCc7IC8vIFdvcmtzIG9uIGRpdnMgdG9vIChpZiBvdmVyZmxvdyB2aXNpYmxlL2F1dG8pXG4gICAgICAgICAgICB0aGlzLmV4cGFuZEJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKEnO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRCdXR0b24udGl0bGUgPSAnQ29sbGFwc2UgaW5wdXQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcnOyAvLyBSZXNldCBoZWlnaHRcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5yZXNpemUgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmV4cGFuZEJ1dHRvbi50ZXh0Q29udGVudCA9ICfipKInO1xuICAgICAgICAgICAgdGhpcy5leHBhbmRCdXR0b24udGl0bGUgPSAnRXhwYW5kIGlucHV0JztcbiAgICAgICAgfVxuICAgICAgICAvLyBGdXR1cmU6IE5vdGlmeSB3aWRnZXQvaGFuZGxlciBpZiBuZWVkZWQ6IHRoaXMuY2FsbGJhY2tzLmhhbmRsZVRvZ2dsZUV4cGFuc2lvbih0aGlzLmlzSW5wdXRFeHBhbmRlZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgYSBzdHlsZWQgYnV0dG9uLlxuICAgICAqL1xuICAgIGNyZWF0ZUJ1dHRvbih0ZXh0LCB0b29sdGlwKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICBidXR0b24udGl0bGUgPSB0b29sdGlwO1xuICAgICAgICAvLyBBcHBseSBiYXNlIEp1cHl0ZXJMYWIgYnV0dG9uIGNsYXNzIGFuZCBvdXIgc3BlY2lmaWMgY2xhc3NcbiAgICAgICAgYnV0dG9uLmNsYXNzTmFtZSA9ICdqcC1CdXR0b24ganAtbGxtLWV4dC1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyBhIG5ldyBjaGF0IG1lc3NhZ2UgZWxlbWVudCB0byB0aGUgbWVzc2FnZSBjb250YWluZXIgYW5kIHNjcm9sbHMgZG93bi5cbiAgICAgKiBAcGFyYW0gZWxlbWVudCBUaGUgbWVzc2FnZSBlbGVtZW50ICh1c2VyIG9yIGJvdCkgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZENoYXRNZXNzYWdlRWxlbWVudChlbGVtZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm1lc3NhZ2VDb250YWluZXIpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsVG9Cb3R0b20oKTsgLy8gU2Nyb2xsIGFmdGVyIGFkZGluZyB0aGUgbmV3IGVsZW1lbnRcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ01lc3NhZ2UgY29udGFpbmVyIG5vdCBpbml0aWFsaXplZCBpbiBVSU1hbmFnZXIuJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2Nyb2xscyB0aGUgbWVzc2FnZSBjb250YWluZXIgdG8gdGhlIGJvdHRvbS5cbiAgICAgKi9cbiAgICBzY3JvbGxUb0JvdHRvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMubWVzc2FnZUNvbnRhaW5lcikge1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbFRvcCA9IHRoaXMubWVzc2FnZUNvbnRhaW5lci5zY3JvbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdNZXNzYWdlIGNvbnRhaW5lciBub3QgaW5pdGlhbGl6ZWQgaW4gVUlNYW5hZ2VyLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3aXRjaGVzIHRoZSB2aWV3IHRvIHNob3cgdGhlIGNoYXQgaGlzdG9yeS5cbiAgICAgKi9cbiAgICBzaG93SGlzdG9yeVZpZXcoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMubWVzc2FnZUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIC8vIE9wdGlvbmFsbHkgdXBkYXRlIGhlYWRlci90aXRsZSBlbGVtZW50cyBpZiBuZWVkZWRcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3dpdGNoZXMgdGhlIHZpZXcgdG8gc2hvdyB0aGUgbWFpbiBjaGF0IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBzaG93Q2hhdFZpZXcoKSB7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuaGlzdG9yeUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMuYm90dG9tQmFyQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7IC8vIEFzc3VtaW5nIGZsZXggZGlzcGxheVxuICAgICAgICB0aGlzLnNjcm9sbFRvQm90dG9tKCk7IC8vIFNjcm9sbCBkb3duIHdoZW4gc2hvd2luZyBjaGF0XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyBhbGwgbWVzc2FnZXMgZnJvbSB0aGUgbWVzc2FnZSBjb250YWluZXIuXG4gICAgICovXG4gICAgY2xlYXJNZXNzYWdlQ29udGFpbmVyKCkge1xuICAgICAgICB0aGlzLmxheW91dEVsZW1lbnRzLm1lc3NhZ2VDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSB0aXRsZSBpbnB1dCBmaWVsZC5cbiAgICAgKi9cbiAgICB1cGRhdGVUaXRsZUlucHV0KHRpdGxlKSB7XG4gICAgICAgIGlmICh0aGlzLmxheW91dEVsZW1lbnRzLnRpdGxlSW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0RWxlbWVudHMudGl0bGVJbnB1dC52YWx1ZSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSBjb250YWluZXIgc3RydWN0dXJlIGZvciBhIGJvdCBtZXNzYWdlLFxuICAgICAqIGluY2x1ZGluZyBlbGVtZW50cyBmb3Igc3RyZWFtaW5nIHRleHQgYW5kIGZpbmFsIHJlbmRlcmVkIGNvbnRlbnQuXG4gICAgICogVGhpcyBoZWxwcyBtYW5hZ2UgdGhlIHRyYW5zaXRpb24gZnJvbSBzdHJlYW1pbmcgdG8gZmluYWwgbWVzc2FnZSBkaXNwbGF5LlxuICAgICAqL1xuICAgIGNyZWF0ZUJvdE1lc3NhZ2VDb250YWluZXIoKSB7XG4gICAgICAgIGNvbnN0IGJvdE1lc3NhZ2VEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYm90TWVzc2FnZURpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1ib3QtbWVzc2FnZSc7IC8vIEJhc2UgY2xhc3NcbiAgICAgICAgLy8gRGl2IGZvciBzdHJlYW1pbmcgY29udGVudCAoaW5pdGlhbGx5IHZpc2libGUpXG4gICAgICAgIGNvbnN0IHN0cmVhbWluZ0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBzdHJlYW1pbmdEaXYuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtc3RyZWFtaW5nLWNvbnRlbnQnO1xuICAgICAgICBzdHJlYW1pbmdEaXYuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7IC8vIFNob3cgc3RyZWFtaW5nIGluaXRpYWxseVxuICAgICAgICAvLyBEaXYgZm9yIGZpbmFsIHJlbmRlcmVkIGNvbnRlbnQgKGluaXRpYWxseSBoaWRkZW4pXG4gICAgICAgIGNvbnN0IGNvbnRlbnREaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGVudERpdi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1yZW5kZXJlZC1jb250ZW50JztcbiAgICAgICAgY29udGVudERpdi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOyAvLyBIaWRlIGZpbmFsIGNvbnRlbnQgaW5pdGlhbGx5XG4gICAgICAgIGJvdE1lc3NhZ2VEaXYuYXBwZW5kQ2hpbGQoc3RyZWFtaW5nRGl2KTtcbiAgICAgICAgYm90TWVzc2FnZURpdi5hcHBlbmRDaGlsZChjb250ZW50RGl2KTtcbiAgICAgICAgLy8gQWRkIHRoZSB3aG9sZSBjb250YWluZXIgdG8gdGhlIG1lc3NhZ2UgbGlzdCAqYmVmb3JlKiBzdHJlYW1pbmcgc3RhcnRzXG4gICAgICAgIHRoaXMuYWRkQ2hhdE1lc3NhZ2VFbGVtZW50KGJvdE1lc3NhZ2VEaXYpO1xuICAgICAgICByZXR1cm4geyBib3RNZXNzYWdlRGl2LCBzdHJlYW1pbmdEaXYsIGNvbnRlbnREaXYgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgYSB0ZW1wb3Jhcnkgbm90aWZpY2F0aW9uIG1lc3NhZ2UuXG4gICAgICogVE9ETzogSW1wbGVtZW50IGEgbW9yZSByb2J1c3Qgbm90aWZpY2F0aW9uIHN5c3RlbSAoZS5nLiwgdG9hc3QpLlxuICAgICAqL1xuICAgIHNob3dOb3RpZmljYXRpb24obWVzc2FnZSwgdHlwZSwgZHVyYXRpb24gPSAzMDAwKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGBOb3RpZmljYXRpb24gKCR7dHlwZX0pOiAke21lc3NhZ2V9YCk7XG4gICAgICAgIC8vIEJhc2ljIHRlbXBvcmFyeSBpbXBsZW1lbnRhdGlvbiB1c2luZyB0aGUgZXhpc3RpbmcgaW5kaWNhdG9yIGVsZW1lbnRcbiAgICAgICAgY29uc3QgaW5kaWNhdG9yID0gdGhpcy5sYXlvdXRFbGVtZW50cy5tYWluRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcuanAtbGxtLWV4dC1rZXlib2FyZC1zaG9ydGN1dC1pbmRpY2F0b3InKTtcbiAgICAgICAgaWYgKGluZGljYXRvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMubm90aWZpY2F0aW9uVGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQpOyAvLyBDbGVhciBwcmV2aW91cyB0aW1lb3V0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpbmRpY2F0b3IudGV4dENvbnRlbnQgPSBtZXNzYWdlO1xuICAgICAgICAgICAgaW5kaWNhdG9yLmNsYXNzTmFtZSA9IGBqcC1sbG0tZXh0LWtleWJvYXJkLXNob3J0Y3V0LWluZGljYXRvciB2aXNpYmxlIGpwLWxsbS1leHQtbm90aWZpY2F0aW9uLSR7dHlwZX1gOyAvLyBBZGQgdHlwZSBjbGFzc1xuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25UaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGluZGljYXRvci5jbGFzc0xpc3QucmVtb3ZlKCd2aXNpYmxlJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIH0sIGR1cmF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybignTm90aWZpY2F0aW9uIGluZGljYXRvciBlbGVtZW50IG5vdCBmb3VuZCBmb3IgVUlNYW5hZ2VyLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNob3dzIGEgdmlzdWFsIGluZGljYXRvciBmb3Iga2V5Ym9hcmQgc2hvcnRjdXRzLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGRpc3BsYXkgaW4gdGhlIGluZGljYXRvci5cbiAgICAgKi9cbiAgICBzaG93SW5kaWNhdG9yKHRleHQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IpXG4gICAgICAgICAgICByZXR1cm47IC8vIEd1YXJkXG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5jbGFzc0xpc3QuYWRkKCd2aXNpYmxlJyk7XG4gICAgICAgIC8vIENsZWFyIGFueSBleGlzdGluZyB0aW1lb3V0IHRvIHByZXZlbnQgbXVsdGlwbGUgdGltZW91dHMgcnVubmluZ1xuICAgICAgICBpZiAodGhpcy5ub3RpZmljYXRpb25UaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5ub3RpZmljYXRpb25UaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgbmV3IHRpbWVvdXQgdG8gaGlkZSB0aGUgaW5kaWNhdG9yXG4gICAgICAgIHRoaXMubm90aWZpY2F0aW9uVGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IpIHsgLy8gQ2hlY2sgaWYgZWxlbWVudCBzdGlsbCBleGlzdHNcbiAgICAgICAgICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZSgndmlzaWJsZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfSwgMTAwMCk7IC8vIEhpZGUgYWZ0ZXIgMSBzZWNvbmRcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIHRoZSBpbmRpY2F0b3IgaW1tZWRpYXRlbHkgYW5kIGNhbmNlbHMgYW55IHBlbmRpbmcgaGlkZSB0aW1lb3V0LlxuICAgICAqIFVzZWZ1bCBpZiB0aGUgd2lkZ2V0IGlzIGhpZGRlbiB3aGlsZSB0aGUgaW5kaWNhdG9yIGlzIHNob3duLlxuICAgICAqL1xuICAgIGNsZWFySW5kaWNhdG9yKCkge1xuICAgICAgICBpZiAoIXRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLnRleHRDb250ZW50ID0gJyc7XG4gICAgICAgIGlmICh0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLm5vdGlmaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZmljYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVja3MgdGhlIGlucHV0IGZpZWxkIGNvbnRlbnQgYW5kIGN1cnNvciBwb3NpdGlvbiB0byBkZXRlcm1pbmUgaWZcbiAgICAgKiB0aGUgcmVmZXJlbmNlIHN1Z2dlc3Rpb24gcG9wdXAgc2hvdWxkIGJlIHNob3duIG9yIGhpZGRlbi5cbiAgICAgKiBUcmlnZ2VyZWQgb24gJ2lucHV0JyBldmVudHMuXG4gICAgICovXG4gICAgaGFuZGxlSW5wdXRGb3JSZWZlcmVuY2UoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb24gfHwgIXNlbGVjdGlvbi5yYW5nZUNvdW50IHx8ICFzZWxlY3Rpb24uaXNDb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgYSBjb2xsYXBzZWQgc2VsZWN0aW9uIChjdXJzb3IpIGluc2lkZSB0aGUgaW5wdXQgZmllbGRcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmFuZ2UgPSBzZWxlY3Rpb24uZ2V0UmFuZ2VBdCgwKTtcbiAgICAgICAgY29uc3QgY29udGFpbmVyID0gcmFuZ2Uuc3RhcnRDb250YWluZXI7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHJhbmdlLnN0YXJ0T2Zmc2V0O1xuICAgICAgICAvLyBFbnN1cmUgdGhlIGN1cnNvciBpcyB3aXRoaW4gdGhlIGlucHV0IGZpZWxkIGl0c2VsZlxuICAgICAgICBpZiAoIXRoaXMuaW5wdXRGaWVsZC5jb250YWlucyhjb250YWluZXIpKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuaGlkZVBvcHVwTWVudSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIENvbWJpbmUgdGV4dCBjb250ZW50IGZyb20gcHJlY2VkaW5nIHNpYmxpbmdzIGlmIGN1cnNvciBpcyBhdCB0aGUgc3RhcnQgb2YgYSB0ZXh0IG5vZGVcbiAgICAgICAgbGV0IHRleHRCZWZvcmVDdXJzb3IgPSAnJztcbiAgICAgICAgbGV0IGN1cnJlbnRDb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICAgIGxldCBjdXJyZW50T2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICB3aGlsZSAoY3VycmVudENvbnRhaW5lcikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJlZm9yZUN1cnNvciA9ICgoX2EgPSBjdXJyZW50Q29udGFpbmVyLnRleHRDb250ZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3Vic3RyaW5nKDAsIGN1cnJlbnRPZmZzZXQpKSArIHRleHRCZWZvcmVDdXJzb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjdXJyZW50Q29udGFpbmVyLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBjdXJyZW50Q29udGFpbmVyLmNsYXNzTGlzdC5jb250YWlucygnanAtbGxtLWV4dC1yZWYtd2lkZ2V0JykpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBlbmNvdW50ZXIgYSB3aWRnZXQgYmVmb3JlIHRoZSBjdXJzb3IsIHdlIGNhbid0IGJlIHJpZ2h0IGFmdGVyICdAJ1xuICAgICAgICAgICAgICAgIHRleHRCZWZvcmVDdXJzb3IgPSAnW3dpZGdldF0nICsgdGV4dEJlZm9yZUN1cnNvcjsgLy8gQWRkIHBsYWNlaG9sZGVyIHRvIGJyZWFrICdAJyBzZXF1ZW5jZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycmVudENvbnRhaW5lci5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgY3VycmVudENvbnRhaW5lci50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICAgICAgdGV4dEJlZm9yZUN1cnNvciA9ICdcXG4nICsgdGV4dEJlZm9yZUN1cnNvcjsgLy8gVHJlYXQgQlIgYXMgbmV3bGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgcHJldmlvdXMgc2libGluZyBvciBwYXJlbnQncyBwcmV2aW91cyBzaWJsaW5nXG4gICAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gY3VycmVudENvbnRhaW5lci5wcmV2aW91c1NpYmxpbmc7XG4gICAgICAgICAgICAgICAgLy8gSWYgbW92aW5nIHRvIGEgbmV3IG5vZGUsIHRha2UgaXRzIGZ1bGwgY29udGVudFxuICAgICAgICAgICAgICAgIGN1cnJlbnRPZmZzZXQgPSAoY3VycmVudENvbnRhaW5lci50ZXh0Q29udGVudCB8fCAnJykubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gTW92ZSB1cCB0byBwYXJlbnQsIGNvbnRpbnVlIHNlYXJjaCBmcm9tIGJlZm9yZSB0aGUgcGFyZW50XG4gICAgICAgICAgICAgICAgY3VycmVudENvbnRhaW5lciA9IGN1cnJlbnRDb250YWluZXIucGFyZW50Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudENvbnRhaW5lciA9PT0gdGhpcy5pbnB1dEZpZWxkIHx8ICFjdXJyZW50Q29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBTdG9wIGlmIHdlIHJlYWNoZWQgdGhlIGlucHV0IGZpZWxkIG9yIHRvcFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50T2Zmc2V0ID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbCgoKF9iID0gY3VycmVudENvbnRhaW5lci5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2hpbGROb2RlcykgfHwgW10sIGN1cnJlbnRDb250YWluZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKGBVSV9NQU5BR0VSIGhhbmRsZUlucHV0OiBUZXh0IGJlZm9yZSBjdXJzb3I6IFwiJHt0ZXh0QmVmb3JlQ3Vyc29yfVwiYCk7XG4gICAgICAgIC8vIC0tLSBDaGVjayBmb3IgdHJpZ2dlciBjb25kaXRpb25zIC0tLSBcbiAgICAgICAgY29uc3QgZW5kc1dpdGhBdCA9IHRleHRCZWZvcmVDdXJzb3IuZW5kc1dpdGgoJ0AnKTtcbiAgICAgICAgY29uc3QgZW5kc1dpdGhBdFNwYWNlID0gdGV4dEJlZm9yZUN1cnNvci5lbmRzV2l0aCgnQCAnKTtcbiAgICAgICAgaWYgKGVuZHNXaXRoQXQgfHwgZW5kc1dpdGhBdFNwYWNlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVNYW5hZ2VyLmlzUG9wdXBNZW51VmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogSWYgdmlzaWJsZSwgbWF5YmUganVzdCB1cGRhdGUgdGhlIHF1ZXJ5IGluIHRoZSBwb3B1cD9cbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVUlfTUFOQUdFUiBoYW5kbGVJbnB1dDogUG9wdXAgYWxyZWFkeSB2aXNpYmxlLCBza2lwcGluZyBzaG93LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRmluZCB0aGUgc3RhcnQgb2YgdGhlIHF1ZXJ5IChhZnRlciAnQCcgb3IgJ0AgJylcbiAgICAgICAgICAgICAgICBjb25zdCBhdEluZGV4ID0gdGV4dEJlZm9yZUN1cnNvci5sYXN0SW5kZXhPZignQCcpO1xuICAgICAgICAgICAgICAgIGxldCBxdWVyeVN0YXJ0SW5kZXggPSBhdEluZGV4ICsgMTtcbiAgICAgICAgICAgICAgICBpZiAoZW5kc1dpdGhBdFNwYWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHF1ZXJ5U3RhcnRJbmRleCA9IGF0SW5kZXggKyAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBxdWVyeSA9IHRleHRCZWZvcmVDdXJzb3Iuc3Vic3RyaW5nKHF1ZXJ5U3RhcnRJbmRleCk7XG4gICAgICAgICAgICAgICAgLy8gLS0tIEluc2VydCB0ZW1wb3Jhcnkgc3BhbiB0byBnZXQgcmVsaWFibGUgY29vcmRpbmF0ZXMgLS0tIFxuICAgICAgICAgICAgICAgIGNvbnN0IHRlbXBBbmNob3JJZCA9ICdqcC1sbG0tdGVtcC1wb3B1cC1hbmNob3InO1xuICAgICAgICAgICAgICAgIGxldCB0ZW1wU3BhbiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRlbXBBbmNob3JJZCk7XG4gICAgICAgICAgICAgICAgaWYgKHRlbXBTcGFuKVxuICAgICAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5yZW1vdmUoKTsgLy8gQ2xlYW4gdXAgcHJldmlvdXMgaWYgYW55XG4gICAgICAgICAgICAgICAgdGVtcFNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgdGVtcFNwYW4uaWQgPSB0ZW1wQW5jaG9ySWQ7XG4gICAgICAgICAgICAgICAgLy8gU3R5bGUgdG8gYmUgaW52aXNpYmxlIGFuZCB0YWtlIG5vIHNwYWNlXG4gICAgICAgICAgICAgICAgdGVtcFNwYW4uc3R5bGUudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHRlbXBTcGFuLnN0eWxlLndpZHRoID0gJzAnO1xuICAgICAgICAgICAgICAgIHRlbXBTcGFuLnN0eWxlLmhlaWdodCA9ICcwJztcbiAgICAgICAgICAgICAgICB0ZW1wU3Bhbi5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAgICAgICAgIHRlbXBTcGFuLnRleHRDb250ZW50ID0gJ1xcdTIwMEInOyAvLyBaZXJvLXdpZHRoIHNwYWNlIG1pZ2h0IGhlbHAgcmVuZGVyaW5nXG4gICAgICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSBzcGFuIGF0IHRoZSBjdXJyZW50IGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgICAgIHJhbmdlLmluc2VydE5vZGUodGVtcFNwYW4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNwYW5SZWN0ID0gdGVtcFNwYW4uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGVtcFNwYW4ucmVtb3ZlKCk7IC8vIFJlbW92ZSBpbW1lZGlhdGVseSBhZnRlciBnZXR0aW5nIGNvb3Jkc1xuICAgICAgICAgICAgICAgIC8vIC0tLSBFbmQgdGVtcG9yYXJ5IHNwYW4gbG9naWMgLS0tXG4gICAgICAgICAgICAgICAgaWYgKHNwYW5SZWN0LnRvcCA9PT0gMCAmJiBzcGFuUmVjdC5sZWZ0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJVSV9NQU5BR0VSIGhhbmRsZUlucHV0OiBGYWlsZWQgdG8gZ2V0IHZhbGlkIGNvb3JkaW5hdGVzIGZyb20gdGVtcCBhbmNob3Igc3Bhbi5cIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGxiYWNrIG9yIGFsdGVybmF0aXZlIHBvc2l0aW9uaW5nIG1pZ2h0IGJlIG5lZWRlZCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIE1heWJlIHBvc2l0aW9uIHJlbGF0aXZlIHRvIGlucHV0IGZpZWxkIGJvdHRvbS1sZWZ0P1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuaGlkZVBvcHVwTWVudSgpOyAvLyBEb24ndCBzaG93IGlmIGNvb3JkcyBhcmUgYmFkXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgVUlfTUFOQUdFUiBoYW5kbGVJbnB1dDogQW5jaG9yIGNvb3JkcyBmcm9tIHRlbXAgc3BhbjogVG9wPSR7c3BhblJlY3QudG9wfSwgTGVmdD0ke3NwYW5SZWN0LmxlZnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNob3cgdGhlIFRPUCBMRVZFTCBzdWdnZXN0aW9ucyB1c2luZyB0aGUgcmVsaWFibGUgY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgLy8gUGFzcyB0aGUgY29vcmRpbmF0ZXMgZGlyZWN0bHkgdG8gc2hvd1BvcHVwTWVudVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIuc2hvd1BvcHVwTWVudShzcGFuUmVjdC50b3AsIHNwYW5SZWN0LmxlZnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIHRleHQgZG9lc24ndCBlbmQgd2l0aCBAIG9yIEAtc3BhY2UsIGhpZGUgdGhlIHBvcHVwXG4gICAgICAgICAgICAvLyBPbmx5IGhpZGUgaWYgaXQgd2FzIHByZXZpb3VzbHkgc2hvd2luZyB0aGUgJ3RvcCcgb3IgJ3JlZmVyZW5jZXMnIG1lbnUgdHJpZ2dlcmVkIGJ5ICdAJ1xuICAgICAgICAgICAgLy8gQXZvaWQgaGlkaW5nIG1lbnVzIHRyaWdnZXJlZCBieSB0aGUgYnV0dG9uIGNsaWNrIHVubmVjZXNzYXJpbHlcbiAgICAgICAgICAgIGlmICh0aGlzLnBvcHVwTWVudU1hbmFnZXIuaXNQb3B1cE1lbnVWaXNpYmxlKCkpIHsgLy8gJiYgKHRoaXMucG9wdXBNZW51TWFuYWdlci5nZXRDdXJyZW50TWVudUxldmVsKCkgPT09ICdyZWZlcmVuY2VzJyB8fCAvKiBOZWVkIHdheSB0byBrbm93IGlmIHRyaWdnZXJlZCBieSBAICovICkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnVUlfTUFOQUdFUiBoYW5kbGVJbnB1dDogSGlkaW5nIHBvcHVwLCB0cmlnZ2VyIGNvbmRpdGlvbiBubyBsb25nZXIgbWV0LicpO1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogVXBkYXRlIHBvcHVwIHF1ZXJ5IGlmIGl0J3MgYWxyZWFkeSB2aXNpYmxlIGFuZCB0aGUgdGV4dCBhZnRlciBAIGNoYW5nZXNcbiAgICAgICAgLy8gKE5lZWQgbW9yZSByb2J1c3QgbG9naWMgaGVyZSwgY29uc2lkZXJpbmcgYmFja3NwYWNlLCBldGMuKVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemVzIHRoZSBjb250ZW50IG9mIHRoZSBpbnB1dCBmaWVsZCwgY29udmVydGluZyBrbm93biB3aWRnZXRzXG4gICAgICogYmFjayB0byB0aGVpciByZWZlcmVuY2Ugc3RyaW5ncyAoZS5nLiwgQGZpbGU6cGF0aC90by9maWxlLnR4dCkuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGN1cnJlbnRseSB1c2VzIGEgc2ltcGxlIHRleHQgc2VyaWFsaXphdGlvbi4gRm9yIGZ1bGwgZmlkZWxpdHlcbiAgICAgKiBwcmVzZXJ2aW5nIHN0cnVjdHVyZSAobGlrZSBtdWx0aXBsZSBwYXJhZ3JhcGhzKSwgYSBtb3JlIGNvbXBsZXggYXBwcm9hY2hcbiAgICAgKiAoZS5nLiwgSFRNTCBwcm9jZXNzaW5nIG9yIGEgZGVkaWNhdGVkIGVkaXRvciBtb2RlbCkgd291bGQgYmUgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHNlcmlhbGl6ZWQgcGxhaW4gdGV4dCBjb250ZW50IG9mIHRoZSBpbnB1dCBmaWVsZC5cbiAgICAgKi9cbiAgICBnZXRTZXJpYWxpemVkSW5wdXQoKSB7XG4gICAgICAgIGxldCBzZXJpYWxpemVkID0gJyc7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5pbnB1dEZpZWxkLmNoaWxkTm9kZXM7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLlRFWFRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gbm9kZS50ZXh0Q29udGVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWxlbWVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdqcC1sbG0tZXh0LXJlZi13aWRnZXQnKSAmJiBlbGVtZW50LmRhdGFzZXQucmVmZXJlbmNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJlZmVyZW5jZSB0ZXh0IHN0b3JlZCBpbiB0aGUgZGF0YSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBlbGVtZW50LmRhdGFzZXQucmVmZXJlbmNlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENvbnZlcnQgQlIgdGFncyBiYWNrIHRvIG5ld2xpbmVzXG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0RJVicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIERJViBlbGVtZW50cyAobWlnaHQgYmUgaW5zZXJ0ZWQgYnkgYnJvd3NlciBvbiBwYXN0ZS9lbnRlcilcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIG5ld2xpbmUgYmVmb3JlIGlmIG5lZWRlZCwgdGhlbiBzZXJpYWxpemUgY2hpbGRyZW4gcmVjdXJzaXZlbHk/XG4gICAgICAgICAgICAgICAgICAgIGlmIChpID4gMCkgeyAvLyBBZGQgbmV3bGluZSBvbmx5IGlmIG5vdCB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSAnXFxuJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9IHRoaXMuc2VyaWFsaXplTm9kZUNoaWxkcmVuKGVsZW1lbnQpOyAvLyBSZWN1cnNpdmVseSBzZXJpYWxpemUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEluY2x1ZGUgdGV4dCBjb250ZW50IG9mIG90aGVyIHVuZXhwZWN0ZWQgZWxlbWVudHMsIGJ1dCBsb2cgYSB3YXJuaW5nXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignVUlNYW5hZ2VyIGdldFNlcmlhbGl6ZWRJbnB1dDogRW5jb3VudGVyZWQgdW5leHBlY3RlZCBlbGVtZW50OicsIGVsZW1lbnQudGFnTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IC8vIElnbm9yZSBvdGhlciBub2RlIHR5cGVzIChjb21tZW50cywgZXRjLilcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZC50cmltKCk7IC8vIFRyaW0gbGVhZGluZy90cmFpbGluZyB3aGl0ZXNwYWNlXG4gICAgfVxuICAgIC8vIEhlbHBlciB0byBzZXJpYWxpemUgY2hpbGRyZW4gb2YgYSBub2RlIChlLmcuLCBmb3IgRElWcylcbiAgICBzZXJpYWxpemVOb2RlQ2hpbGRyZW4ocGFyZW50Tm9kZSkge1xuICAgICAgICBsZXQgY29udGVudCA9ICcnO1xuICAgICAgICBjb25zdCBub2RlcyA9IHBhcmVudE5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCArPSBub2RlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gbm9kZTtcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoJ2pwLWxsbS1leHQtcmVmLXdpZGdldCcpICYmIGVsZW1lbnQuZGF0YXNldC5yZWZlcmVuY2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgKz0gZWxlbWVudC5kYXRhc2V0LnJlZmVyZW5jZVRleHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0JSJykge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9ICdcXG4nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVjdXJzaXZlbHkgaGFuZGxlIG5lc3RlZCBlbGVtZW50cyBpZiBuZWNlc3NhcnksIG9yIGp1c3QgZ2V0IHRleHQgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50ICs9IHRoaXMuc2VyaWFsaXplTm9kZUNoaWxkcmVuKGVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgY2xlYXJJbnB1dEZpZWxkKCkge1xuICAgICAgICB0aGlzLmlucHV0RmllbGQuaW5uZXJIVE1MID0gJyc7IC8vIENsZWFyIGFsbCBjb250ZW50XG4gICAgICAgIC8vIFJlc2V0IGV4cGFuc2lvbiBzdGF0ZSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHRoaXMuaXNJbnB1dEV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUlucHV0RXhwYW5zaW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5zdXJlIHBsYWNlaG9sZGVyIHJlYXBwZWFycyBpZiB1c2luZyBDU1MgZm9yIGl0XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnaW5wdXQnKSk7IC8vIFRyaWdnZXIgZXZlbnQgdG8gdXBkYXRlIFVJIHN0YXRlIGlmIG5lY2Vzc2FyeVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSAnY29weScgZXZlbnQgdG8gcHV0IHNlcmlhbGl6ZWQgcGxhaW4gdGV4dCBvbnRvIHRoZSBjbGlwYm9hcmQuXG4gICAgICovXG4gICAgaGFuZGxlQ29weShldmVudCkge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5pc0NvbGxhcHNlZCB8fCAhZXZlbnQuY2xpcGJvYXJkRGF0YSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBOb3RoaW5nIHNlbGVjdGVkIG9yIG5vIGNsaXBib2FyZCBkYXRhIG9iamVjdFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2VsZWN0aW9uIGlzIHdpdGhpbiBvdXIgaW5wdXQgZmllbGRcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0RmllbGQuY29udGFpbnMocmFuZ2UuY29tbW9uQW5jZXN0b3JDb250YWluZXIpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5zZXJpYWxpemVSYW5nZUNvbnRlbnQocmFuZ2UpO1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpOyAvLyBQcmV2ZW50IGRlZmF1bHQgY29weSBiZWhhdmlvclxuICAgICAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoJ3RleHQvcGxhaW4nLCBzZWxlY3RlZFRleHQpO1xuICAgICAgICBjb25zb2xlLmxvZygnVUlNYW5hZ2VyIGhhbmRsZUNvcHk6IENvcGllZCBzZXJpYWxpemVkIHRleHQ6Jywgc2VsZWN0ZWRUZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgJ3Bhc3RlJyBldmVudCB0byBpbnNlcnQgcGxhaW4gdGV4dCBjb250ZW50LlxuICAgICAqL1xuICAgIGhhbmRsZVBhc3RlKGV2ZW50KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCFldmVudC5jbGlwYm9hcmREYXRhKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGV4dCA9IGV2ZW50LmNsaXBib2FyZERhdGEuZ2V0RGF0YSgndGV4dC9wbGFpbicpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTsgLy8gUHJldmVudCBkZWZhdWx0IHBhc3RlIGJlaGF2aW9yXG4gICAgICAgICAgICAvLyBJbnNlcnQgdGhlIHBsYWluIHRleHQgYXQgdGhlIGN1cnJlbnQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICYmIHNlbGVjdGlvbi5yYW5nZUNvdW50ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gc2VsZWN0aW9uLmdldFJhbmdlQXQoMCk7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZGVsZXRlQ29udGVudHMoKTsgLy8gRGVsZXRlIHNlbGVjdGVkIGNvbnRlbnQgaWYgYW55XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KTtcbiAgICAgICAgICAgICAgICByYW5nZS5pbnNlcnROb2RlKHRleHROb2RlKTtcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGN1cnNvciBhZnRlciBpbnNlcnRlZCB0ZXh0XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRBZnRlcih0ZXh0Tm9kZSk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kQWZ0ZXIodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5yZW1vdmVBbGxSYW5nZXMoKTtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgICAgIC8vIEVuc3VyZSBzY3JvbGwgaW50byB2aWV3IGFuZCB0cmlnZ2VyIGlucHV0IGV2ZW50IGZvciBwb3RlbnRpYWwgdXBkYXRlc1xuICAgICAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5mb2N1cygpO1xuICAgICAgICAgICAgICAgIChfYSA9IHRleHROb2RlLnBhcmVudEVsZW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zY3JvbGxJbnRvVmlldyh7IGJsb2NrOiAnbmVhcmVzdCcgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KCdpbnB1dCcsIHsgYnViYmxlczogdHJ1ZSwgY2FuY2VsYWJsZTogdHJ1ZSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnVUlNYW5hZ2VyIGhhbmRsZVBhc3RlOiBQYXN0ZWQgdGV4dDonLCB0ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAtLS0gTWV0aG9kcyBmb3IgdXBkYXRpbmcgVUkgZWxlbWVudHMgd2lsbCBiZSBhZGRlZCBsYXRlciAtLS1cbiAgICAvLyBlLmcuLCB1cGRhdGVNZXNzYWdlQ29udGFpbmVyKGh0bWw6IHN0cmluZyksIHNob3dIaXN0b3J5VmlldygpLCBzaG93Q2hhdFZpZXcoKVxuICAgIC8vIC0tLSBQb3RlbnRpYWxseSBhZGQgbWV0aG9kcyB0byBnZXQgZWxlbWVudCByZWZlcmVuY2VzIGlmIG5lZWRlZCBleHRlcm5hbGx5IC0tLVxuICAgIC8vIHB1YmxpYyBnZXRJbnB1dEZpZWxkKCk6IEhUTUxUZXh0QXJlYUVsZW1lbnQgeyByZXR1cm4gdGhpcy5pbnB1dEZpZWxkOyB9XG4gICAgLy8gZXRjLlxuICAgIC8vIEhlbHBlciB0byBzZXJpYWxpemUgYSByYW5nZSAobmVlZGVkIGZvciBjb3B5KVxuICAgIHNlcmlhbGl6ZVJhbmdlQ29udGVudChyYW5nZSkge1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHJhbmdlLmNsb25lQ29udGVudHMoKTtcbiAgICAgICAgbGV0IHRlbXBEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGVtcERpdi5hcHBlbmRDaGlsZChmcmFnbWVudCk7XG4gICAgICAgIC8vIE5vdywgc2VyaWFsaXplIHRlbXBEaXYncyBjb250ZW50IGxpa2Ugd2UgZG8gZm9yIGdldFNlcmlhbGl6ZWRJbnB1dFxuICAgICAgICBsZXQgc2VyaWFsaXplZCA9ICcnO1xuICAgICAgICBjb25zdCBub2RlcyA9IHRlbXBEaXYuY2hpbGROb2RlcztcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplTm9kZSA9IChub2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gTm9kZS5URVhUX05PREUpIHtcbiAgICAgICAgICAgICAgICBzZXJpYWxpemVkICs9IG5vZGUudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnanAtbGxtLWV4dC1yZWYtd2lkZ2V0JykgJiYgZWxlbWVudC5kYXRhc2V0LnJlZmVyZW5jZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXplZCArPSBlbGVtZW50LmRhdGFzZXQucmVmZXJlbmNlVGV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZWxlbWVudC50YWdOYW1lID09PSAnQlInKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZWQgKz0gJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBGb3Igb3RoZXIgZWxlbWVudHMgKGxpa2UgRElWcyBwb3RlbnRpYWxseSBpbiBmcmFnbWVudCksIHNlcmlhbGl6ZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGlsZE5vZGVzID0gZWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNoaWxkTm9kZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6ZU5vZGUoY2hpbGROb2Rlc1tqXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZU5vZGUobm9kZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbn1cbmV4cG9ydHMuVUlNYW5hZ2VyID0gVUlNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmNvcHlUb0NsaXBib2FyZCA9IGNvcHlUb0NsaXBib2FyZDtcbmV4cG9ydHMuY29weU1lc3NhZ2VUb0NsaXBib2FyZCA9IGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQ7XG5leHBvcnRzLmNvcHlJbWFnZVRvQ2xpcGJvYXJkID0gY29weUltYWdlVG9DbGlwYm9hcmQ7XG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjb3B5IHRleHQgdG8gY2xpcGJvYXJkLlxuICogUHJvdmlkZXMgdmlzdWFsIGZlZWRiYWNrIHZpYSBjb25zb2xlIGxvZ3MgYW5kIG9wdGlvbmFsbHkgYSBjYWxsYmFjay5cbiAqL1xuZnVuY3Rpb24gY29weVRvQ2xpcGJvYXJkKHRleHQsIGZlZWRiYWNrQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdDb250ZW50IGNvcGllZCB0byBjbGlwYm9hcmQnKTtcbiAgICAgICAgICAgIGZlZWRiYWNrQ2FsbGJhY2sgPT09IG51bGwgfHwgZmVlZGJhY2tDYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYWxsYmFjaygpOyAvLyBDYWxsIG9wdGlvbmFsIGZlZWRiYWNrIGNhbGxiYWNrXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSB0ZXh0OiAnLCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNvcHlpbmcgdGV4dCB0byBjbGlwYm9hcmQ6JywgZXJyb3IpO1xuICAgIH1cbn1cbi8qKlxuICogQ29waWVzIG1lc3NhZ2UgY29udGVudCB0byBjbGlwYm9hcmQuXG4gKiBQcm92aWRlcyB2aXN1YWwgZmVlZGJhY2sgdmlhIGNvbnNvbGUgbG9ncyBhbmQgb3B0aW9uYWxseSBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBjb3B5TWVzc2FnZVRvQ2xpcGJvYXJkKHRleHQsIGZlZWRiYWNrQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICBuYXZpZ2F0b3IuY2xpcGJvYXJkLndyaXRlVGV4dCh0ZXh0KS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdNZXNzYWdlIGNvbnRlbnQgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKHRydWUpOyAvLyBJbmRpY2F0ZSBzdWNjZXNzXG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSBtZXNzYWdlIHRleHQ6ICcsIGVycik7XG4gICAgICAgICAgICBmZWVkYmFja0NhbGxiYWNrID09PSBudWxsIHx8IGZlZWRiYWNrQ2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZlZWRiYWNrQ2FsbGJhY2soZmFsc2UpOyAvLyBJbmRpY2F0ZSBmYWlsdXJlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgY29weWluZyBtZXNzYWdlIHRvIGNsaXBib2FyZDonLCBlcnJvcik7XG4gICAgICAgIGZlZWRiYWNrQ2FsbGJhY2sgPT09IG51bGwgfHwgZmVlZGJhY2tDYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYWxsYmFjayhmYWxzZSk7IC8vIEluZGljYXRlIGZhaWx1cmVcbiAgICB9XG59XG4vKipcbiAqIENvcGllcyBhbiBpbWFnZSB0byB0aGUgY2xpcGJvYXJkIGZyb20gYSBnaXZlbiBVUkwuXG4gKiBQcm92aWRlcyB2aXN1YWwgZmVlZGJhY2sgdmlhIGNvbnNvbGUgbG9ncyBhbmQgb3B0aW9uYWxseSBhIGNhbGxiYWNrLlxuICovXG5mdW5jdGlvbiBjb3B5SW1hZ2VUb0NsaXBib2FyZChpbWFnZVVybCwgZmVlZGJhY2tDYWxsYmFjaykge1xuICAgIHRyeSB7XG4gICAgICAgIGZldGNoKGltYWdlVXJsKVxuICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgICAgICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGZldGNoIGltYWdlOiAke3Jlc3BvbnNlLnN0YXR1c1RleHR9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oYmxvYiA9PiB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSBDbGlwYm9hcmRJdGVtIHdpdGggdGhlIGltYWdlIGJsb2JcbiAgICAgICAgICAgIC8vIE5vdGU6IENsaXBib2FyZEl0ZW0gbWlnaHQgbm90IGJlIGRlZmluZWQgaW4gYWxsIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gWW91IG1pZ2h0IG5lZWQgdG8gYWRkIGBcImRvbS5pdGVyYWJsZVwiYCB0byB0c2NvbmZpZyBsaWIgb3IgaGFuZGxlIGFwcHJvcHJpYXRlbHkuXG4gICAgICAgICAgICBjb25zdCBpdGVtID0gbmV3IENsaXBib2FyZEl0ZW0oeyBbYmxvYi50eXBlXTogYmxvYiB9KTtcbiAgICAgICAgICAgIG5hdmlnYXRvci5jbGlwYm9hcmQud3JpdGUoW2l0ZW1dKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnSW1hZ2UgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgICAgIGZlZWRiYWNrQ2FsbGJhY2sgPT09IG51bGwgfHwgZmVlZGJhY2tDYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmVlZGJhY2tDYWxsYmFjayh0cnVlKTsgLy8gSW5kaWNhdGUgc3VjY2Vzc1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSBpbWFnZSB0byBjbGlwYm9hcmQ6ICcsIGVycik7XG4gICAgICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBjb3B5IGltYWdlOiAnICsgZXJyLm1lc3NhZ2UpOyAvLyBLZWVwIGFsZXJ0IGZvciBjcml0aWNhbCB1c2VyIGZlZWRiYWNrXG4gICAgICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKGZhbHNlKTsgLy8gSW5kaWNhdGUgZmFpbHVyZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBmZXRjaCBvciBwcm9jZXNzIGltYWdlOiAnLCBlcnIpO1xuICAgICAgICAgICAgYWxlcnQoJ0ZhaWxlZCB0byBmZXRjaCBpbWFnZTogJyArIGVyci5tZXNzYWdlKTsgLy8gS2VlcCBhbGVydCBmb3IgY3JpdGljYWwgdXNlciBmZWVkYmFja1xuICAgICAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKGZhbHNlKTsgLy8gSW5kaWNhdGUgZmFpbHVyZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHByZXBhcmluZyBpbWFnZSBjb3B5OicsIGVycm9yKTtcbiAgICAgICAgYWxlcnQoJ0Vycm9yIGNvcHlpbmcgaW1hZ2U6ICcgKyBlcnJvcik7IC8vIEtlZXAgYWxlcnQgZm9yIGNyaXRpY2FsIHVzZXIgZmVlZGJhY2tcbiAgICAgICAgZmVlZGJhY2tDYWxsYmFjayA9PT0gbnVsbCB8fCBmZWVkYmFja0NhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmZWVkYmFja0NhbGxiYWNrKGZhbHNlKTsgLy8gSW5kaWNhdGUgZmFpbHVyZVxuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZXRDYXJldFBvc2l0aW9uID0gZ2V0Q2FyZXRQb3NpdGlvbjtcbmV4cG9ydHMuc2V0Q2FyZXRQb3NpdGlvbiA9IHNldENhcmV0UG9zaXRpb247XG4vKipcbiAqIEdldHMgdGhlIGNhcmV0IHBvc2l0aW9uIHdpdGhpbiBhIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50LlxuICogUmV0dXJucyB0aGUgbGluZWFyIG9mZnNldCBmcm9tIHRoZSBzdGFydCBvZiB0aGUgZWxlbWVudCdzIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0Q2FyZXRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgY29uc3Qgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgIGlmICghc2VsZWN0aW9uIHx8IHNlbGVjdGlvbi5yYW5nZUNvdW50ID09PSAwIHx8ICFlbGVtZW50LmNvbnRhaW5zKHNlbGVjdGlvbi5hbmNob3JOb2RlKSkge1xuICAgICAgICAvLyBDaGVjayBpZiBzZWxlY3Rpb24gaXMgd2l0aGluIHRoZSBlbGVtZW50XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuICAgIC8vIENyZWF0ZSBhIHJhbmdlIHRoYXQgc3BhbnMgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBlbGVtZW50IHRvIHRoZSBjYXJldFxuICAgIGNvbnN0IHByZUNhcmV0UmFuZ2UgPSByYW5nZS5jbG9uZVJhbmdlKCk7XG4gICAgcHJlQ2FyZXRSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgcHJlQ2FyZXRSYW5nZS5zZXRFbmQocmFuZ2Uuc3RhcnRDb250YWluZXIsIHJhbmdlLnN0YXJ0T2Zmc2V0KTtcbiAgICAvLyBUaGUgbGVuZ3RoIG9mIHRoZSB0ZXh0IGNvbnRlbnQgd2l0aGluIHRoaXMgcHJlLWNhcmV0IHJhbmdlIGlzIHRoZSBwb3NpdGlvblxuICAgIC8vIFVzaW5nIHRvU3RyaW5nKCkgaXMgZ2VuZXJhbGx5IG1vcmUgcmVsaWFibGUgdGhhbiB0ZXh0Q29udGVudCBmb3IgcmFuZ2UgbGVuZ3RoXG4gICAgcmV0dXJuIHByZUNhcmV0UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG59XG4vKipcbiAqIFNldHMgdGhlIGNhcmV0IHBvc2l0aW9uIHdpdGhpbiBhIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50LlxuICogQHBhcmFtIGVsZW1lbnQgVGhlIGNvbnRlbnRlZGl0YWJsZSBlbGVtZW50LlxuICogQHBhcmFtIHBvc2l0aW9uIFRoZSBkZXNpcmVkIGxpbmVhciBvZmZzZXQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHRleHQgY29udGVudC5cbiAqL1xuZnVuY3Rpb24gc2V0Q2FyZXRQb3NpdGlvbihlbGVtZW50LCBwb3NpdGlvbikge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gICAgbGV0IGNoYXJDb3VudCA9IDA7XG4gICAgbGV0IGZvdW5kTm9kZSA9IGZhbHNlO1xuICAgIGxldCBub2RlU3RhY2sgPSBbZWxlbWVudF07IC8vIFVzZSBhIHN0YWNrIGZvciBERlMgdHJhdmVyc2FsXG4gICAgLy8gRGVwdGgtZmlyc3Qgc2VhcmNoIHRvIGZpbmQgdGhlIGNvcnJlY3QgdGV4dCBub2RlIGFuZCBvZmZzZXRcbiAgICB3aGlsZSAobm9kZVN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKG5vZGUubm9kZVR5cGUgPT09IE5vZGUuVEVYVF9OT0RFKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVuZ3RoID0gKChfYSA9IG5vZGUudGV4dENvbnRlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sZW5ndGgpIHx8IDA7XG4gICAgICAgICAgICBpZiAocG9zaXRpb24gPj0gY2hhckNvdW50ICYmIHBvc2l0aW9uIDw9IGNoYXJDb3VudCArIHRleHRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByYW5nZS5zZXRTdGFydChub2RlLCBwb3NpdGlvbiAtIGNoYXJDb3VudCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uuc2V0RW5kKG5vZGUsIHBvc2l0aW9uIC0gY2hhckNvdW50KTtcbiAgICAgICAgICAgICAgICBmb3VuZE5vZGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrOyAvLyBGb3VuZCB0aGUgbm9kZSwgZXhpdCBsb29wXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFyQ291bnQgKz0gdGV4dExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChub2RlLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgY29uc3QgZWxlbWVudE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgaWYgKGVsZW1lbnROb2RlLnRhZ05hbWUgPT09ICdCUicpIHtcbiAgICAgICAgICAgICAgICBpZiAocG9zaXRpb24gPT09IGNoYXJDb3VudCkgeyAvLyBQb3NpdGlvbiBpcyByaWdodCBiZWZvcmUgQlJcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2Uuc2V0U3RhcnRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldEVuZEJlZm9yZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgZm91bmROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoYXJDb3VudCArPSAxOyAvLyBUcmVhdCBCUiBhcyBvbmUgY2hhcmFjdGVyXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbGVtZW50Tm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpID09PSAnZmFsc2UnKSB7XG4gICAgICAgICAgICAgICAgLy8gVHJlYXQgbm9uLWVkaXRhYmxlIGVsZW1lbnRzIChsaWtlIG91ciB3aWRnZXRzKSBhcyBzaW5nbGUgY2hhcmFjdGVyc1xuICAgICAgICAgICAgICAgIGlmIChwb3NpdGlvbiA9PT0gY2hhckNvdW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFBvc2l0aW9uIGlzIHJpZ2h0IGJlZm9yZSB0aGUgd2lkZ2V0XG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLnNldFN0YXJ0QmVmb3JlKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zZXRFbmRCZWZvcmUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGZvdW5kTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjaGFyQ291bnQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEFkZCBjaGlsZCBub2RlcyB0byB0aGUgc3RhY2sgaW4gcmV2ZXJzZSBvcmRlciBmb3IgY29ycmVjdCBERlNcbiAgICAgICAgICAgICAgICBjb25zdCBjaGlsZHJlbiA9IG5vZGUuY2hpbGROb2RlcztcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZVN0YWNrLnB1c2goY2hpbGRyZW5baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgcG9zaXRpb24gaXMgYmV5b25kIHRoZSBjb250ZW50IG9yIHdhc24ndCBmb3VuZCwgcGxhY2UgY3Vyc29yIGF0IHRoZSBlbmRcbiAgICBpZiAoIWZvdW5kTm9kZSkge1xuICAgICAgICByYW5nZS5zZWxlY3ROb2RlQ29udGVudHMoZWxlbWVudCk7XG4gICAgICAgIHJhbmdlLmNvbGxhcHNlKGZhbHNlKTsgLy8gQ29sbGFwc2UgdG8gdGhlIGVuZFxuICAgIH1cbiAgICBzZWxlY3Rpb24ucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgc2VsZWN0aW9uLmFkZFJhbmdlKHJhbmdlKTtcbiAgICAvLyBSZXN0b3JlIGZvY3VzIG9ubHkgaWYgdGhlIGVsZW1lbnQgd2FzIHByZXZpb3VzbHkgZm9jdXNlZCBvciBpcyB0aGUgdGFyZ2V0XG4gICAgLy8gVGhpcyBhdm9pZHMgc3RlYWxpbmcgZm9jdXMgdW5uZWNlc3NhcmlseVxuICAgIGlmIChkb2N1bWVudC5hY3RpdmVFbGVtZW50ICE9PSBlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZm9jdXMoeyBwcmV2ZW50U2Nyb2xsOiB0cnVlIH0pOyAvLyBwcmV2ZW50U2Nyb2xsIGhlbHBzIGF2b2lkIGp1bXBpbmdcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGV0ZWN0TGFuZ3VhZ2UgPSBkZXRlY3RMYW5ndWFnZTtcbmV4cG9ydHMuaGlnaGxpZ2h0Q29kZSA9IGhpZ2hsaWdodENvZGU7XG5jb25zdCBoaWdobGlnaHRfanNfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiaGlnaGxpZ2h0LmpzXCIpKTtcbi8qKlxuICogRGV0ZWN0cyB0aGUgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2UgZnJvbSBjb2RlIGJsb2NrIGNvbnRlbnQgdXNpbmcgaGlnaGxpZ2h0LmpzXG4gKiBhbmQgY3VzdG9tIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIGNvbW1vbiBsYW5ndWFnZXMuXG4gKi9cbmZ1bmN0aW9uIGRldGVjdExhbmd1YWdlKGNvZGUpIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBUcnkgYXV0byBkZXRlY3Rpb24gZmlyc3Qgd2l0aCBhIGxpbWl0ZWQgc2V0IG9mIGNvbW1vbiBsYW5ndWFnZXNcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaGlnaGxpZ2h0X2pzXzEuZGVmYXVsdC5oaWdobGlnaHRBdXRvKGNvZGUsIFtcbiAgICAgICAgICAgICdweXRob24nLCAnamF2YXNjcmlwdCcsICd0eXBlc2NyaXB0JywgJ2phdmEnLFxuICAgICAgICAgICAgJ2h0bWwnLCAnY3NzJywgJ2NwcCcsICdjc2hhcnAnLCAnc3FsJywgJ3J1c3QnLFxuICAgICAgICAgICAgJ3BocCcsICdiYXNoJywgJ2pzb24nLCAneG1sJywgJ21hcmtkb3duJ1xuICAgICAgICBdKTtcbiAgICAgICAgLy8gSWYgY29uZmlkZW5jZSBpcyByZWFzb25hYmx5IGhpZ2gsIHVzZSB0aGF0IGxhbmd1YWdlXG4gICAgICAgIGlmIChyZXN1bHQucmVsZXZhbmNlID4gNSAmJiByZXN1bHQubGFuZ3VhZ2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGJhc2ljIHBhdHRlcm4gbWF0Y2hpbmcgZm9yIGJldHRlciBhY2N1cmFjeSBvbiBhbWJpZ3VvdXMgY2FzZXNcbiAgICAgICAgaWYgKC9eKD86XFxzKik/KD86aW1wb3J0XFxzK1teO10rO3xwYWNrYWdlXFxzK1teO10rO3xwdWJsaWNcXHMrY2xhc3MpLy50ZXN0KGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2phdmEnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KGltcG9ydHxmcm9tfGRlZnxjbGFzc3xpZiBfX25hbWVfXykvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAncHl0aG9uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OmZ1bmN0aW9ufGNvbnN0fGxldHx2YXJ8aW1wb3J0fGV4cG9ydHw9PikvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIEJyb2FkZXIgY2hlY2sgZm9yIEpTL1RTXG4gICAgICAgICAgICBpZiAoL14oPzpcXHMqKT8oPzppbXBvcnRcXHMuK3xleHBvcnRcXHMuK3xpbnRlcmZhY2V8dHlwZXxlbnVtfGRlY2xhcmV8OnxcXHM8KS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndHlwZXNjcmlwdCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJ2phdmFzY3JpcHQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86PCFET0NUWVBFfDxodG1sfDxoZWFkfDxib2R5KS9pLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnaHRtbCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL14oPzpcXHMqKT8jaW5jbHVkZS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdjcHAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86dXNpbmdcXHMrU3lzdGVtfG5hbWVzcGFjZXxwdWJsaWNcXHMrc3RhdGljXFxzK3ZvaWRcXHMrTWFpbikvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnY3NoYXJwJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OlNFTEVDVHxJTlNFUlR8VVBEQVRFfERFTEVURXxDUkVBVEV8QUxURVIpXFxzL2kudGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdzcWwnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86Zm58bGV0fHN0cnVjdHxlbnVtfHRyYWl0fGltcGx8bW9kKVxccy8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdydXN0JztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgvXig/OlxccyopPyg/OjxcXD9waHB8dXNlXFxzK1tcXHdcXFxcXSs7KS8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuICdwaHAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eKD86XFxzKik/KD86I1xccyohXFwvYmluXFwvKD86YmFzaHxzaHx6c2gpfFxcJCkvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnYmFzaCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL15cXHMqXFx7Ly50ZXN0KGNvZGUpICYmIC9cXH1cXHMqJC8udGVzdChjb2RlKSkge1xuICAgICAgICAgICAgLy8gU2ltcGxlIGNoZWNrIGZvciBKU09OLWxpa2Ugc3RydWN0dXJlXG4gICAgICAgICAgICByZXR1cm4gJ2pzb24nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKC9eXFxzKjxcXD94bWwvLnRlc3QoY29kZSkgfHwgL15cXHMqPFxcdysvLnRlc3QoY29kZSkpIHtcbiAgICAgICAgICAgIC8vIFNpbXBsZSBjaGVjayBmb3IgWE1ML0hUTUwgbGlrZSBzdHJ1Y3R1cmVcbiAgICAgICAgICAgIHJldHVybiAneG1sJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBzcGVjaWZpYyBsYW5ndWFnZSBkZXRlY3RlZCwgcmV0dXJuIGVtcHR5IHN0cmluZyBmb3IgZGVmYXVsdCBoYW5kbGluZ1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBkZXRlY3RpbmcgbGFuZ3VhZ2U6JywgZXJyb3IpO1xuICAgICAgICByZXR1cm4gJyc7IC8vIFJldHVybiBlbXB0eSBvbiBlcnJvclxuICAgIH1cbn1cbi8qKlxuICogSGlnaGxpZ2h0cyBjb2RlIHVzaW5nIGhpZ2hsaWdodC5qcy5cbiAqIEZhbGxzIGJhY2sgdG8gYXV0by1kZXRlY3Rpb24gaWYgdGhlIHNwZWNpZmllZCBsYW5ndWFnZSBpcyBub3Qgc3VwcG9ydGVkLlxuICovXG5mdW5jdGlvbiBoaWdobGlnaHRDb2RlKGNvZGUsIGxhbmd1YWdlKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKGxhbmd1YWdlICYmIGhpZ2hsaWdodF9qc18xLmRlZmF1bHQuZ2V0TGFuZ3VhZ2UobGFuZ3VhZ2UpKSB7XG4gICAgICAgICAgICByZXR1cm4gaGlnaGxpZ2h0X2pzXzEuZGVmYXVsdC5oaWdobGlnaHQoY29kZSwgeyBsYW5ndWFnZSwgaWdub3JlSWxsZWdhbHM6IHRydWUgfSkudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBhdXRvLWRldGVjdGlvbiBpZiBsYW5ndWFnZSBpcyBlbXB0eSBvciBub3QgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgcmV0dXJuIGhpZ2hsaWdodF9qc18xLmRlZmF1bHQuaGlnaGxpZ2h0QXV0byhjb2RlKS52YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaGlnaGxpZ2h0aW5nIGNvZGUgKGxhbmd1YWdlOiAke2xhbmd1YWdlIHx8ICdhdXRvJ30pOmAsIGVycm9yKTtcbiAgICAgICAgLy8gUmV0dXJuIG9yaWdpbmFsIGNvZGUgZXNjYXBlZCBmb3Igc2FmZXR5IG9uIGVycm9yXG4gICAgICAgIHJldHVybiBjb2RlLnJlcGxhY2UoLzwvZywgXCImbHQ7XCIpLnJlcGxhY2UoLz4vZywgXCImZ3Q7XCIpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jb25maWd1cmVNYXJrZWQgPSBjb25maWd1cmVNYXJrZWQ7XG5leHBvcnRzLnByZXByb2Nlc3NNYXJrZG93biA9IHByZXByb2Nlc3NNYXJrZG93bjtcbmNvbnN0IG1hcmtlZF8xID0gcmVxdWlyZShcIm1hcmtlZFwiKTtcbi8qKlxuICogQ29uZmlndXJlIG1hcmtlZCB3aXRoIGJldHRlciByZW5kZXJpbmcgb3B0aW9ucyBmb3IgY29kZSBibG9ja3NcbiAqL1xuZnVuY3Rpb24gY29uZmlndXJlTWFya2VkKCkge1xuICAgIC8vIENvbmZpZ3VyZSBtYXJrZWQgb3B0aW9uc1xuICAgIG1hcmtlZF8xLm1hcmtlZC5zZXRPcHRpb25zKHtcbiAgICAgICAgZ2ZtOiB0cnVlLCAvLyBFbmFibGUgR2l0SHViIEZsYXZvcmVkIE1hcmtkb3duXG4gICAgICAgIGJyZWFrczogdHJ1ZSwgLy8gQWRkIDxicj4gb24gc2luZ2xlIGxpbmUgYnJlYWtzXG4gICAgICAgIHBlZGFudGljOiBmYWxzZSwgLy8gQ29uZm9ybSB0byBvcmlnaW5hbCBtYXJrZG93biBzcGVjXG4gICAgICAgIGFzeW5jOiBmYWxzZSwgLy8gRGlzYWJsZSBhc3luYyByZW5kZXJpbmdcbiAgICAgICAgc2lsZW50OiBmYWxzZSAvLyBFbmFibGUgZXJyb3IgcmVwb3J0aW5nXG4gICAgfSk7XG59XG4vKipcbiAqIFByZS1wcm9jZXNzIG1hcmtkb3duIHRleHQgdG8gZml4IGNvbW1vbiBpc3N1ZXMgd2l0aCBzdHJlYW1pbmcgY29udGVudFxuICovXG5mdW5jdGlvbiBwcmVwcm9jZXNzTWFya2Rvd24odGV4dCkge1xuICAgIC8vIE5vcm1hbGl6ZSBsaW5lIGVuZGluZ3NcbiAgICBjb25zdCBub3JtYWxpemVkVGV4dCA9IHRleHQucmVwbGFjZSgvXFxyXFxuL2csICdcXG4nKTtcbiAgICAvLyBIYW5kbGUgY29kZSBibG9ja3MgZmlyc3RcbiAgICBsZXQgaW5Db2RlQmxvY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsaW5lcyA9IG5vcm1hbGl6ZWRUZXh0LnNwbGl0KCdcXG4nKTtcbiAgICBjb25zdCBwcm9jZXNzZWRMaW5lcyA9IGxpbmVzLm1hcCgobGluZSwgaSkgPT4ge1xuICAgICAgICAvLyBDaGVjayBmb3IgY29kZSBibG9jayBtYXJrZXJzXG4gICAgICAgIGlmIChsaW5lLnRyaW0oKS5zdGFydHNXaXRoKCdgYGAnKSkge1xuICAgICAgICAgICAgaW5Db2RlQmxvY2sgPSAhaW5Db2RlQmxvY2s7XG4gICAgICAgICAgICAvLyBQcmVzZXJ2ZSBsYW5ndWFnZSBzcGVjaWZpY2F0aW9uXG4gICAgICAgICAgICByZXR1cm4gbGluZS50cmltKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UncmUgaW4gYSBjb2RlIGJsb2NrLCBwcmVzZXJ2ZSB0aGUgbGluZSBhcyBpc1xuICAgICAgICBpZiAoaW5Db2RlQmxvY2spIHtcbiAgICAgICAgICAgIHJldHVybiBsaW5lO1xuICAgICAgICB9XG4gICAgICAgIC8vIE91dHNpZGUgY29kZSBibG9ja3M6XG4gICAgICAgIC8vIDEuIEhhbmRsZSBsaXN0IGl0ZW1zIHdpdGggcHJvcGVyIHNwYWNpbmdcbiAgICAgICAgLy8gMi4gVHJpbSBleGNlc3NpdmUgd2hpdGVzcGFjZSBhdCBzdGFydCBhbmQgZW5kLCBidXQgcHJlc2VydmUgaW5kZW50YXRpb24gd2l0aGluIGxpbmVzXG4gICAgICAgIGxldCBwcm9jZXNzZWQgPSBsaW5lO1xuICAgICAgICAvLyBIYW5kbGUgZGFzaCBsaXN0IGl0ZW1zIGJ5IGVuc3VyaW5nIHRoZXkgaGF2ZSBhIHNwYWNlIGFmdGVyIHRoZSBkYXNoXG4gICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC8oXFxzKiktKFxcUykvZywgJyQxLSAkMicpO1xuICAgICAgICAvLyBIYW5kbGUgbWl4ZWQgc3BhY2UvZGFzaCBpc3N1ZXMgLSBlbnN1cmUgcHJvcGVyIG5ld2xpbmVzIGJlZm9yZSBsaXN0IGl0ZW1zXG4gICAgICAgIHByb2Nlc3NlZCA9IHByb2Nlc3NlZC5yZXBsYWNlKC8oW15cXG5cXHNdKS1cXHMvZywgJyQxXFxuLSAnKTtcbiAgICAgICAgcmV0dXJuIHByb2Nlc3NlZDtcbiAgICB9KTtcbiAgICAvLyBKb2luIGxpbmVzIGFuZCBlbnN1cmUgY29kZSBibG9ja3MgYXJlIHByb3Blcmx5IGZvcm1hdHRlZFxuICAgIGxldCByZXN1bHQgPSBwcm9jZXNzZWRMaW5lcy5qb2luKCdcXG4nKTtcbiAgICAvLyBIYW5kbGUgZW1wdHkgY29kZSBibG9ja3MgKGFkZCBhIHNwYWNlIHNvIHRoZXkgcmVuZGVyIHByb3Blcmx5KVxuICAgIHJlc3VsdCA9IHJlc3VsdC5yZXBsYWNlKC9gYGAoLiopXFxuYGBgL2csICdgYGAkMVxcbiBcXG5gYGAnKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZE1lc3NhZ2VUb0NlbGwgPSBhZGRNZXNzYWdlVG9DZWxsO1xuZXhwb3J0cy5nZXRTZWxlY3RlZFRleHQgPSBnZXRTZWxlY3RlZFRleHQ7XG5leHBvcnRzLmdldEN1cnJlbnRDZWxsQ29udGVudCA9IGdldEN1cnJlbnRDZWxsQ29udGVudDtcbmV4cG9ydHMuaW5zZXJ0Q2VsbENvbnRlbnRCeUluZGV4ID0gaW5zZXJ0Q2VsbENvbnRlbnRCeUluZGV4O1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2NvcmUvZ2xvYmFsc1wiKTtcbi8qKlxuICogQWRkcyBtZXNzYWdlIGNvbnRlbnQgdG8gdGhlIGN1cnJlbnQgY2VsbCBpbiB0aGUgYWN0aXZlIG5vdGVib29rLlxuICovXG5mdW5jdGlvbiBhZGRNZXNzYWdlVG9DZWxsKHRleHQpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgY2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcikge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Nhbm5vdCBhZGQgbWVzc2FnZTogTm8gYWN0aXZlIGNlbGwgb3IgZWRpdG9yIGZvdW5kLicpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICAvLyBBY2Nlc3MgdGhlIHVuZGVybHlpbmcgQ29kZU1pcnJvciBlZGl0b3IgdmlldyAoYWRqdXN0IGlmIHVzaW5nIGEgZGlmZmVyZW50IGVkaXRvcilcbiAgICAgICAgY29uc3QgdmlldyA9IGVkaXRvci5lZGl0b3I7XG4gICAgICAgIGlmICghdmlldykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCdDYW5ub3QgYWRkIG1lc3NhZ2U6IENvZGVNaXJyb3IgdmlldyBub3QgYWNjZXNzaWJsZS4nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgY3VycmVudCBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgY29uc3Qgc3RhdGUgPSB2aWV3LnN0YXRlO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb247XG4gICAgICAgIGNvbnN0IGN1cnNvclBvcyA9IHNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIC8vIEluc2VydCBuZXdsaW5lIGFuZCBtZXNzYWdlIGNvbnRlbnQgYXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gc3RhdGUudXBkYXRlKHtcbiAgICAgICAgICAgIGNoYW5nZXM6IHtcbiAgICAgICAgICAgICAgICBmcm9tOiBjdXJzb3JQb3MsXG4gICAgICAgICAgICAgICAgaW5zZXJ0OiBgXFxuJHt0ZXh0fWBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBPcHRpb25hbGx5IG1vdmUgY3Vyc29yIHRvIGVuZCBvZiBpbnNlcnRlZCB0ZXh0XG4gICAgICAgICAgICBzZWxlY3Rpb246IHsgYW5jaG9yOiBjdXJzb3JQb3MgKyB0ZXh0Lmxlbmd0aCArIDEgfVxuICAgICAgICB9KTtcbiAgICAgICAgdmlldy5kaXNwYXRjaCh0cmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhZGRpbmcgbWVzc2FnZSB0byBjZWxsOicsIGVycm9yKTtcbiAgICB9XG59XG4vKipcbiAqIEdldHMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCB0ZXh0IGZyb20gdGhlIGFjdGl2ZSBub3RlYm9vayBjZWxsIG9yIHRleHQgZWRpdG9yLlxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3RlZFRleHQoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgY29uc3QgY2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgaWYgKGNlbGwgPT09IG51bGwgfHwgY2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbC5lZGl0b3IpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgIGNvbnN0IGNtRWRpdG9yID0gZWRpdG9yLmVkaXRvcjsgLy8gQWNjZXNzIENvZGVNaXJyb3IgZWRpdG9yIGluc3RhbmNlXG4gICAgICAgIGlmIChjbUVkaXRvciAmJiBjbUVkaXRvci5zdGF0ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjbUVkaXRvci5zdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbiA9IHN0YXRlLnNlbGVjdGlvbi5tYWluO1xuICAgICAgICAgICAgcmV0dXJuIHNlbGVjdGlvbi5lbXB0eSA/IG51bGwgOiBzdGF0ZS5kb2Muc2xpY2VTdHJpbmcoc2VsZWN0aW9uLmZyb20sIHNlbGVjdGlvbi50byk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc29sZS53YXJuKFwiQ291bGQgbm90IGFjY2VzcyBDb2RlTWlycm9yIHN0YXRlIHRvIGdldCBzZWxlY3Rpb24uXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIEZhbGxiYWNrIGZvciBub24tbm90ZWJvb2sgZWRpdG9ycyAoZS5nLiwgdGV4dCBlZGl0b3IpXG4gICAgICAgIGNvbnN0IGFjdGl2ZVdpZGdldCA9IChfYyA9IChfYiA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoZWxsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudFdpZGdldDtcbiAgICAgICAgaWYgKGFjdGl2ZVdpZGdldCAmJiAnY29udGVudCcgaW4gYWN0aXZlV2lkZ2V0ICYmIGFjdGl2ZVdpZGdldC5jb250ZW50LmVkaXRvcikge1xuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gYWN0aXZlV2lkZ2V0LmNvbnRlbnQuZWRpdG9yO1xuICAgICAgICAgICAgY29uc3QgY21FZGl0b3IgPSBlZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgaWYgKGNtRWRpdG9yICYmIGNtRWRpdG9yLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBjbUVkaXRvci5zdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBzdGF0ZS5zZWxlY3Rpb24ubWFpbjtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0aW9uLmVtcHR5ID8gbnVsbCA6IHN0YXRlLmRvYy5zbGljZVN0cmluZyhzZWxlY3Rpb24uZnJvbSwgc2VsZWN0aW9uLnRvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIkNvdWxkIG5vdCBhY2Nlc3MgQ29kZU1pcnJvciBzdGF0ZSBmb3Igbm9uLW5vdGVib29rIGVkaXRvciBzZWxlY3Rpb24uXCIpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdldHMgdGhlIGNvbnRlbnQgb2YgdGhlIGN1cnJlbnRseSBhY3RpdmUgbm90ZWJvb2sgY2VsbCBvciB0ZXh0IGVkaXRvci5cbiAqL1xuZnVuY3Rpb24gZ2V0Q3VycmVudENlbGxDb250ZW50KCkge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgY29uc3QgYWN0aXZlQ2VsbCA9IChfYSA9IGdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZUNlbGw7XG4gICAgaWYgKGFjdGl2ZUNlbGwgPT09IG51bGwgfHwgYWN0aXZlQ2VsbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWN0aXZlQ2VsbC5tb2RlbCkge1xuICAgICAgICAvLyBUcnkgdXNpbmcgc2hhcmVkTW9kZWwgZmlyc3QgKG1vcmUgcm9idXN0KVxuICAgICAgICBpZiAoYWN0aXZlQ2VsbC5tb2RlbC5zaGFyZWRNb2RlbCAmJiB0eXBlb2YgYWN0aXZlQ2VsbC5tb2RlbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHJldHVybiBhY3RpdmVDZWxsLm1vZGVsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZhbGxiYWNrOiBUcnkgdXNpbmcgdG9KU09OKCkuc291cmNlXG4gICAgICAgIGNvbnN0IGNlbGxKc29uID0gYWN0aXZlQ2VsbC5tb2RlbC50b0pTT04oKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gY2VsbEpzb24gPT09IG51bGwgfHwgY2VsbEpzb24gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNlbGxKc29uLnNvdXJjZTtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICByZXR1cm4gc291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNvdXJjZS5qb2luKCdcXG4nKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zb2xlLndhcm4oXCJDb3VsZCBub3QgZ2V0IGNlbGwgY29udGVudCB2aWEgc2hhcmVkTW9kZWwgb3IgdG9KU09OKCkuc291cmNlXCIpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1ub3RlYm9vayBlZGl0b3JzIGlmIG5lZWRlZFxuICAgIGNvbnN0IGFjdGl2ZVdpZGdldCA9IChfYyA9IChfYiA9IGdsb2JhbHNfMS5nbG9iYWxzLmFwcCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNoZWxsKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY3VycmVudFdpZGdldDtcbiAgICBpZiAoYWN0aXZlV2lkZ2V0ICYmICdjb250ZW50JyBpbiBhY3RpdmVXaWRnZXQgJiYgYWN0aXZlV2lkZ2V0LmNvbnRlbnQubW9kZWwpIHtcbiAgICAgICAgLy8gQXNzdW1pbmcgbW9kZWwudmFsdWUudGV4dCBmb3IgZ2VuZXJpYyB0ZXh0IGVkaXRvcnNcbiAgICAgICAgcmV0dXJuIChfZSA9IChfZCA9IGFjdGl2ZVdpZGdldC5jb250ZW50Lm1vZGVsLnZhbHVlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudGV4dCkgIT09IG51bGwgJiYgX2UgIT09IHZvaWQgMCA/IF9lIDogbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG4vKipcbiAqIEdldHMgY2VsbCBjb250ZW50IGJ5IGluZGV4IGZyb20gdGhlIGN1cnJlbnQgbm90ZWJvb2sgYW5kIGNhbGxzIGEgY2FsbGJhY2sgdG8gaW5zZXJ0IGl0LlxuICogTk9URTogVGhlIG9yaWdpbmFsIGZ1bmN0aW9uIGNhbGxlZCBgdGhpcy5hcHBlbmRUb0lucHV0YC4gVGhpcyBmdW5jdGlvbmFsaXR5IG5lZWRzXG4gKiAgICAgICB0byBiZSBwcm92aWRlZCB2aWEgdGhlIGBpbnNlcnRDYWxsYmFja2AuXG4gKi9cbmZ1bmN0aW9uIGluc2VydENlbGxDb250ZW50QnlJbmRleChpbmRleCwgaW5zZXJ0Q2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAoIWdsb2JhbHNfMS5nbG9iYWxzLm5vdGVib29rVHJhY2tlciB8fCAhZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRXaWRnZXQpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGFjdGl2ZSBub3RlYm9vayBmb3VuZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdGVib29rUGFuZWwgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIuY3VycmVudFdpZGdldDtcbiAgICAgICAgY29uc3QgbW9kZWwgPSBub3RlYm9va1BhbmVsLmNvbnRlbnQubW9kZWw7XG4gICAgICAgIGlmICghbW9kZWwgfHwgIW1vZGVsLmNlbGxzIHx8IGluZGV4IDwgMCB8fCBpbmRleCA+PSBtb2RlbC5jZWxscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEludmFsaWQgY2VsbCBpbmRleDogJHtpbmRleH1gKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjZWxsID0gbW9kZWwuY2VsbHMuZ2V0KGluZGV4KTtcbiAgICAgICAgbGV0IGNlbGxDb250ZW50ID0gJyc7XG4gICAgICAgIC8vIEdldCBjZWxsIGNvbnRlbnQgLSBoYW5kbGUgZGlmZmVyZW50IHdheXMgY29udGVudCBtaWdodCBiZSBzdG9yZWRcbiAgICAgICAgaWYgKGNlbGwuc2hhcmVkTW9kZWwgJiYgdHlwZW9mIGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjZWxsQ29udGVudCA9IGNlbGwuc2hhcmVkTW9kZWwuZ2V0U291cmNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsSnNvbiA9IGNlbGwudG9KU09OKCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBjZWxsSnNvbiA9PT0gbnVsbCB8fCBjZWxsSnNvbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2VsbEpzb24uc291cmNlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY2VsbENvbnRlbnQgPSBzb3VyY2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgICAgICAgICAgICBjZWxsQ29udGVudCA9IHNvdXJjZS5qb2luKCdcXG4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJbnNlcnQgY2VsbCByZWZlcmVuY2Ugd2l0aCBjb250ZW50IHVzaW5nIHRoZSBjYWxsYmFja1xuICAgICAgICBpbnNlcnRDYWxsYmFjayhgY2VsbCAke2NlbGxDb250ZW50fWApO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5zZXJ0aW5nIGNlbGwgYnkgaW5kZXg6JywgZXJyb3IpO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==