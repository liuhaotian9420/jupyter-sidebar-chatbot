"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["node_modules_codemirror_legacy-modes_mode_tiki_js"],{

/***/ "./node_modules/@codemirror/legacy-modes/mode/tiki.js":
/*!************************************************************!*\
  !*** ./node_modules/@codemirror/legacy-modes/mode/tiki.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   tiki: () => (/* binding */ tiki)
/* harmony export */ });
function inBlock(style, terminator, returnTokenizer) {
  return function(stream, state) {
    while (!stream.eol()) {
      if (stream.match(terminator)) {
        state.tokenize = inText;
        break;
      }
      stream.next();
    }

    if (returnTokenizer) state.tokenize = returnTokenizer;

    return style;
  };
}

function inLine(style) {
  return function(stream, state) {
    while(!stream.eol()) {
      stream.next();
    }
    state.tokenize = inText;
    return style;
  };
}

function inText(stream, state) {
  function chain(parser) {
    state.tokenize = parser;
    return parser(stream, state);
  }

  var sol = stream.sol();
  var ch = stream.next();

  //non start of line
  switch (ch) { //switch is generally much faster than if, so it is used here
  case "{": //plugin
    stream.eat("/");
    stream.eatSpace();
    stream.eatWhile(/[^\s\u00a0=\"\'\/?(}]/);
    state.tokenize = inPlugin;
    return "tag";
  case "_": //bold
    if (stream.eat("_"))
      return chain(inBlock("strong", "__", inText));
    break;
  case "'": //italics
    if (stream.eat("'"))
      return chain(inBlock("em", "''", inText));
    break;
  case "(":// Wiki Link
    if (stream.eat("("))
      return chain(inBlock("link", "))", inText));
    break;
  case "[":// Weblink
    return chain(inBlock("url", "]", inText));
    break;
  case "|": //table
    if (stream.eat("|"))
      return chain(inBlock("comment", "||"));
    break;
  case "-":
    if (stream.eat("=")) {//titleBar
      return chain(inBlock("header string", "=-", inText));
    } else if (stream.eat("-")) {//deleted
      return chain(inBlock("error tw-deleted", "--", inText));
    }
    break;
  case "=": //underline
    if (stream.match("=="))
      return chain(inBlock("tw-underline", "===", inText));
    break;
  case ":":
    if (stream.eat(":"))
      return chain(inBlock("comment", "::"));
    break;
  case "^": //box
    return chain(inBlock("tw-box", "^"));
    break;
  case "~": //np
    if (stream.match("np~"))
      return chain(inBlock("meta", "~/np~"));
    break;
  }

  //start of line types
  if (sol) {
    switch (ch) {
    case "!": //header at start of line
      if (stream.match('!!!!!')) {
        return chain(inLine("header string"));
      } else if (stream.match('!!!!')) {
        return chain(inLine("header string"));
      } else if (stream.match('!!!')) {
        return chain(inLine("header string"));
      } else if (stream.match('!!')) {
        return chain(inLine("header string"));
      } else {
        return chain(inLine("header string"));
      }
      break;
    case "*": //unordered list line item, or <li /> at start of line
    case "#": //ordered list line item, or <li /> at start of line
    case "+": //ordered list line item, or <li /> at start of line
      return chain(inLine("tw-listitem bracket"));
      break;
    }
  }

  //stream.eatWhile(/[&{]/); was eating up plugins, turned off to act less like html and more like tiki
  return null;
}

// Return variables for tokenizers
var pluginName, type;
function inPlugin(stream, state) {
  var ch = stream.next();
  var peek = stream.peek();

  if (ch == "}") {
    state.tokenize = inText;
    //type = ch == ")" ? "endPlugin" : "selfclosePlugin"; inPlugin
    return "tag";
  } else if (ch == "(" || ch == ")") {
    return "bracket";
  } else if (ch == "=") {
    type = "equals";

    if (peek == ">") {
      stream.next();
      peek = stream.peek();
    }

    //here we detect values directly after equal character with no quotes
    if (!/[\'\"]/.test(peek)) {
      state.tokenize = inAttributeNoQuote();
    }
    //end detect values

    return "operator";
  } else if (/[\'\"]/.test(ch)) {
    state.tokenize = inAttribute(ch);
    return state.tokenize(stream, state);
  } else {
    stream.eatWhile(/[^\s\u00a0=\"\'\/?]/);
    return "keyword";
  }
}

function inAttribute(quote) {
  return function(stream, state) {
    while (!stream.eol()) {
      if (stream.next() == quote) {
        state.tokenize = inPlugin;
        break;
      }
    }
    return "string";
  };
}

function inAttributeNoQuote() {
  return function(stream, state) {
    while (!stream.eol()) {
      var ch = stream.next();
      var peek = stream.peek();
      if (ch == " " || ch == "," || /[ )}]/.test(peek)) {
        state.tokenize = inPlugin;
        break;
      }
    }
    return "string";
  };
}

var curState, setStyle;
function pass() {
  for (var i = arguments.length - 1; i >= 0; i--) curState.cc.push(arguments[i]);
}

function cont() {
  pass.apply(null, arguments);
  return true;
}

function pushContext(pluginName, startOfLine) {
  var noIndent = curState.context && curState.context.noIndent;
  curState.context = {
    prev: curState.context,
    pluginName: pluginName,
    indent: curState.indented,
    startOfLine: startOfLine,
    noIndent: noIndent
  };
}

function popContext() {
  if (curState.context) curState.context = curState.context.prev;
}

function element(type) {
  if (type == "openPlugin") {curState.pluginName = pluginName; return cont(attributes, endplugin(curState.startOfLine));}
  else if (type == "closePlugin") {
    var err = false;
    if (curState.context) {
      err = curState.context.pluginName != pluginName;
      popContext();
    } else {
      err = true;
    }
    if (err) setStyle = "error";
    return cont(endcloseplugin(err));
  }
  else if (type == "string") {
    if (!curState.context || curState.context.name != "!cdata") pushContext("!cdata");
    if (curState.tokenize == inText) popContext();
    return cont();
  }
  else return cont();
}

function endplugin(startOfLine) {
  return function(type) {
    if (
      type == "selfclosePlugin" ||
        type == "endPlugin"
    )
      return cont();
    if (type == "endPlugin") {pushContext(curState.pluginName, startOfLine); return cont();}
    return cont();
  };
}

function endcloseplugin(err) {
  return function(type) {
    if (err) setStyle = "error";
    if (type == "endPlugin") return cont();
    return pass();
  };
}

function attributes(type) {
  if (type == "keyword") {setStyle = "attribute"; return cont(attributes);}
  if (type == "equals") return cont(attvalue, attributes);
  return pass();
}
function attvalue(type) {
  if (type == "keyword") {setStyle = "string"; return cont();}
  if (type == "string") return cont(attvaluemaybe);
  return pass();
}
function attvaluemaybe(type) {
  if (type == "string") return cont(attvaluemaybe);
  else return pass();
}
const tiki = {
  name: "tiki",
  startState: function() {
    return {tokenize: inText, cc: [], indented: 0, startOfLine: true, pluginName: null, context: null};
  },
  token: function(stream, state) {
    if (stream.sol()) {
      state.startOfLine = true;
      state.indented = stream.indentation();
    }
    if (stream.eatSpace()) return null;

    setStyle = type = pluginName = null;
    var style = state.tokenize(stream, state);
    if ((style || type) && style != "comment") {
      curState = state;
      while (true) {
        var comb = state.cc.pop() || element;
        if (comb(type || style)) break;
      }
    }
    state.startOfLine = false;
    return setStyle || style;
  },
  indent: function(state, textAfter, cx) {
    var context = state.context;
    if (context && context.noIndent) return 0;
    if (context && /^{\//.test(textAfter))
      context = context.prev;
    while (context && !context.startOfLine)
      context = context.prev;
    if (context) return context.indent + cx.unit;
    else return 0;
  }
};


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZV9tb2R1bGVzX2NvZGVtaXJyb3JfbGVnYWN5LW1vZGVzX21vZGVfdGlraV9qcy44OGNkZTdkZTk2ZDM5ZGY2ZmI2ZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCO0FBQ2hCLFNBQVM7QUFDVDtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0EsTUFBTSwyQkFBMkI7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQSwwREFBMEQ7QUFDMUQ7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QiwrQ0FBK0M7QUFDN0U7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLHdCQUF3QjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxQkFBcUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxZQUFZO0FBQ1osR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY29kZW1pcnJvci9sZWdhY3ktbW9kZXMvbW9kZS90aWtpLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGluQmxvY2soc3R5bGUsIHRlcm1pbmF0b3IsIHJldHVyblRva2VuaXplcikge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHdoaWxlICghc3RyZWFtLmVvbCgpKSB7XG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKHRlcm1pbmF0b3IpKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuXG4gICAgaWYgKHJldHVyblRva2VuaXplcikgc3RhdGUudG9rZW5pemUgPSByZXR1cm5Ub2tlbml6ZXI7XG5cbiAgICByZXR1cm4gc3R5bGU7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluTGluZShzdHlsZSkge1xuICByZXR1cm4gZnVuY3Rpb24oc3RyZWFtLCBzdGF0ZSkge1xuICAgIHdoaWxlKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHN0cmVhbS5uZXh0KCk7XG4gICAgfVxuICAgIHN0YXRlLnRva2VuaXplID0gaW5UZXh0O1xuICAgIHJldHVybiBzdHlsZTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5UZXh0KHN0cmVhbSwgc3RhdGUpIHtcbiAgZnVuY3Rpb24gY2hhaW4ocGFyc2VyKSB7XG4gICAgc3RhdGUudG9rZW5pemUgPSBwYXJzZXI7XG4gICAgcmV0dXJuIHBhcnNlcihzdHJlYW0sIHN0YXRlKTtcbiAgfVxuXG4gIHZhciBzb2wgPSBzdHJlYW0uc29sKCk7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG5cbiAgLy9ub24gc3RhcnQgb2YgbGluZVxuICBzd2l0Y2ggKGNoKSB7IC8vc3dpdGNoIGlzIGdlbmVyYWxseSBtdWNoIGZhc3RlciB0aGFuIGlmLCBzbyBpdCBpcyB1c2VkIGhlcmVcbiAgY2FzZSBcIntcIjogLy9wbHVnaW5cbiAgICBzdHJlYW0uZWF0KFwiL1wiKTtcbiAgICBzdHJlYW0uZWF0U3BhY2UoKTtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxzXFx1MDBhMD1cXFwiXFwnXFwvPyh9XS8pO1xuICAgIHN0YXRlLnRva2VuaXplID0gaW5QbHVnaW47XG4gICAgcmV0dXJuIFwidGFnXCI7XG4gIGNhc2UgXCJfXCI6IC8vYm9sZFxuICAgIGlmIChzdHJlYW0uZWF0KFwiX1wiKSlcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwic3Ryb25nXCIsIFwiX19cIiwgaW5UZXh0KSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCInXCI6IC8vaXRhbGljc1xuICAgIGlmIChzdHJlYW0uZWF0KFwiJ1wiKSlcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiZW1cIiwgXCInJ1wiLCBpblRleHQpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIihcIjovLyBXaWtpIExpbmtcbiAgICBpZiAoc3RyZWFtLmVhdChcIihcIikpXG4gICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcImxpbmtcIiwgXCIpKVwiLCBpblRleHQpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIltcIjovLyBXZWJsaW5rXG4gICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJ1cmxcIiwgXCJdXCIsIGluVGV4dCkpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwifFwiOiAvL3RhYmxlXG4gICAgaWYgKHN0cmVhbS5lYXQoXCJ8XCIpKVxuICAgICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJjb21tZW50XCIsIFwifHxcIikpO1xuICAgIGJyZWFrO1xuICBjYXNlIFwiLVwiOlxuICAgIGlmIChzdHJlYW0uZWF0KFwiPVwiKSkgey8vdGl0bGVCYXJcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiaGVhZGVyIHN0cmluZ1wiLCBcIj0tXCIsIGluVGV4dCkpO1xuICAgIH0gZWxzZSBpZiAoc3RyZWFtLmVhdChcIi1cIikpIHsvL2RlbGV0ZWRcbiAgICAgIHJldHVybiBjaGFpbihpbkJsb2NrKFwiZXJyb3IgdHctZGVsZXRlZFwiLCBcIi0tXCIsIGluVGV4dCkpO1xuICAgIH1cbiAgICBicmVhaztcbiAgY2FzZSBcIj1cIjogLy91bmRlcmxpbmVcbiAgICBpZiAoc3RyZWFtLm1hdGNoKFwiPT1cIikpXG4gICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcInR3LXVuZGVybGluZVwiLCBcIj09PVwiLCBpblRleHQpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIjpcIjpcbiAgICBpZiAoc3RyZWFtLmVhdChcIjpcIikpXG4gICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcImNvbW1lbnRcIiwgXCI6OlwiKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgXCJeXCI6IC8vYm94XG4gICAgcmV0dXJuIGNoYWluKGluQmxvY2soXCJ0dy1ib3hcIiwgXCJeXCIpKTtcbiAgICBicmVhaztcbiAgY2FzZSBcIn5cIjogLy9ucFxuICAgIGlmIChzdHJlYW0ubWF0Y2goXCJucH5cIikpXG4gICAgICByZXR1cm4gY2hhaW4oaW5CbG9jayhcIm1ldGFcIiwgXCJ+L25wflwiKSk7XG4gICAgYnJlYWs7XG4gIH1cblxuICAvL3N0YXJ0IG9mIGxpbmUgdHlwZXNcbiAgaWYgKHNvbCkge1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlIFwiIVwiOiAvL2hlYWRlciBhdCBzdGFydCBvZiBsaW5lXG4gICAgICBpZiAoc3RyZWFtLm1hdGNoKCchISEhIScpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJoZWFkZXIgc3RyaW5nXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCchISEhJykpIHtcbiAgICAgICAgcmV0dXJuIGNoYWluKGluTGluZShcImhlYWRlciBzdHJpbmdcIikpO1xuICAgICAgfSBlbHNlIGlmIChzdHJlYW0ubWF0Y2goJyEhIScpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJoZWFkZXIgc3RyaW5nXCIpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RyZWFtLm1hdGNoKCchIScpKSB7XG4gICAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJoZWFkZXIgc3RyaW5nXCIpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBjaGFpbihpbkxpbmUoXCJoZWFkZXIgc3RyaW5nXCIpKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCIqXCI6IC8vdW5vcmRlcmVkIGxpc3QgbGluZSBpdGVtLCBvciA8bGkgLz4gYXQgc3RhcnQgb2YgbGluZVxuICAgIGNhc2UgXCIjXCI6IC8vb3JkZXJlZCBsaXN0IGxpbmUgaXRlbSwgb3IgPGxpIC8+IGF0IHN0YXJ0IG9mIGxpbmVcbiAgICBjYXNlIFwiK1wiOiAvL29yZGVyZWQgbGlzdCBsaW5lIGl0ZW0sIG9yIDxsaSAvPiBhdCBzdGFydCBvZiBsaW5lXG4gICAgICByZXR1cm4gY2hhaW4oaW5MaW5lKFwidHctbGlzdGl0ZW0gYnJhY2tldFwiKSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICAvL3N0cmVhbS5lYXRXaGlsZSgvWyZ7XS8pOyB3YXMgZWF0aW5nIHVwIHBsdWdpbnMsIHR1cm5lZCBvZmYgdG8gYWN0IGxlc3MgbGlrZSBodG1sIGFuZCBtb3JlIGxpa2UgdGlraVxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gUmV0dXJuIHZhcmlhYmxlcyBmb3IgdG9rZW5pemVyc1xudmFyIHBsdWdpbk5hbWUsIHR5cGU7XG5mdW5jdGlvbiBpblBsdWdpbihzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gIHZhciBwZWVrID0gc3RyZWFtLnBlZWsoKTtcblxuICBpZiAoY2ggPT0gXCJ9XCIpIHtcbiAgICBzdGF0ZS50b2tlbml6ZSA9IGluVGV4dDtcbiAgICAvL3R5cGUgPSBjaCA9PSBcIilcIiA/IFwiZW5kUGx1Z2luXCIgOiBcInNlbGZjbG9zZVBsdWdpblwiOyBpblBsdWdpblxuICAgIHJldHVybiBcInRhZ1wiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiKFwiIHx8IGNoID09IFwiKVwiKSB7XG4gICAgcmV0dXJuIFwiYnJhY2tldFwiO1xuICB9IGVsc2UgaWYgKGNoID09IFwiPVwiKSB7XG4gICAgdHlwZSA9IFwiZXF1YWxzXCI7XG5cbiAgICBpZiAocGVlayA9PSBcIj5cIikge1xuICAgICAgc3RyZWFtLm5leHQoKTtcbiAgICAgIHBlZWsgPSBzdHJlYW0ucGVlaygpO1xuICAgIH1cblxuICAgIC8vaGVyZSB3ZSBkZXRlY3QgdmFsdWVzIGRpcmVjdGx5IGFmdGVyIGVxdWFsIGNoYXJhY3RlciB3aXRoIG5vIHF1b3Rlc1xuICAgIGlmICghL1tcXCdcXFwiXS8udGVzdChwZWVrKSkge1xuICAgICAgc3RhdGUudG9rZW5pemUgPSBpbkF0dHJpYnV0ZU5vUXVvdGUoKTtcbiAgICB9XG4gICAgLy9lbmQgZGV0ZWN0IHZhbHVlc1xuXG4gICAgcmV0dXJuIFwib3BlcmF0b3JcIjtcbiAgfSBlbHNlIGlmICgvW1xcJ1xcXCJdLy50ZXN0KGNoKSkge1xuICAgIHN0YXRlLnRva2VuaXplID0gaW5BdHRyaWJ1dGUoY2gpO1xuICAgIHJldHVybiBzdGF0ZS50b2tlbml6ZShzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZWF0V2hpbGUoL1teXFxzXFx1MDBhMD1cXFwiXFwnXFwvP10vKTtcbiAgICByZXR1cm4gXCJrZXl3b3JkXCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5BdHRyaWJ1dGUocXVvdGUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICB3aGlsZSAoIXN0cmVhbS5lb2woKSkge1xuICAgICAgaWYgKHN0cmVhbS5uZXh0KCkgPT0gcXVvdGUpIHtcbiAgICAgICAgc3RhdGUudG9rZW5pemUgPSBpblBsdWdpbjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBcInN0cmluZ1wiO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbkF0dHJpYnV0ZU5vUXVvdGUoKSB7XG4gIHJldHVybiBmdW5jdGlvbihzdHJlYW0sIHN0YXRlKSB7XG4gICAgd2hpbGUgKCFzdHJlYW0uZW9sKCkpIHtcbiAgICAgIHZhciBjaCA9IHN0cmVhbS5uZXh0KCk7XG4gICAgICB2YXIgcGVlayA9IHN0cmVhbS5wZWVrKCk7XG4gICAgICBpZiAoY2ggPT0gXCIgXCIgfHwgY2ggPT0gXCIsXCIgfHwgL1sgKX1dLy50ZXN0KHBlZWspKSB7XG4gICAgICAgIHN0YXRlLnRva2VuaXplID0gaW5QbHVnaW47XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfTtcbn1cblxudmFyIGN1clN0YXRlLCBzZXRTdHlsZTtcbmZ1bmN0aW9uIHBhc3MoKSB7XG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIGN1clN0YXRlLmNjLnB1c2goYXJndW1lbnRzW2ldKTtcbn1cblxuZnVuY3Rpb24gY29udCgpIHtcbiAgcGFzcy5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcHVzaENvbnRleHQocGx1Z2luTmFtZSwgc3RhcnRPZkxpbmUpIHtcbiAgdmFyIG5vSW5kZW50ID0gY3VyU3RhdGUuY29udGV4dCAmJiBjdXJTdGF0ZS5jb250ZXh0Lm5vSW5kZW50O1xuICBjdXJTdGF0ZS5jb250ZXh0ID0ge1xuICAgIHByZXY6IGN1clN0YXRlLmNvbnRleHQsXG4gICAgcGx1Z2luTmFtZTogcGx1Z2luTmFtZSxcbiAgICBpbmRlbnQ6IGN1clN0YXRlLmluZGVudGVkLFxuICAgIHN0YXJ0T2ZMaW5lOiBzdGFydE9mTGluZSxcbiAgICBub0luZGVudDogbm9JbmRlbnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gcG9wQ29udGV4dCgpIHtcbiAgaWYgKGN1clN0YXRlLmNvbnRleHQpIGN1clN0YXRlLmNvbnRleHQgPSBjdXJTdGF0ZS5jb250ZXh0LnByZXY7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnQodHlwZSkge1xuICBpZiAodHlwZSA9PSBcIm9wZW5QbHVnaW5cIikge2N1clN0YXRlLnBsdWdpbk5hbWUgPSBwbHVnaW5OYW1lOyByZXR1cm4gY29udChhdHRyaWJ1dGVzLCBlbmRwbHVnaW4oY3VyU3RhdGUuc3RhcnRPZkxpbmUpKTt9XG4gIGVsc2UgaWYgKHR5cGUgPT0gXCJjbG9zZVBsdWdpblwiKSB7XG4gICAgdmFyIGVyciA9IGZhbHNlO1xuICAgIGlmIChjdXJTdGF0ZS5jb250ZXh0KSB7XG4gICAgICBlcnIgPSBjdXJTdGF0ZS5jb250ZXh0LnBsdWdpbk5hbWUgIT0gcGx1Z2luTmFtZTtcbiAgICAgIHBvcENvbnRleHQoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVycikgc2V0U3R5bGUgPSBcImVycm9yXCI7XG4gICAgcmV0dXJuIGNvbnQoZW5kY2xvc2VwbHVnaW4oZXJyKSk7XG4gIH1cbiAgZWxzZSBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgaWYgKCFjdXJTdGF0ZS5jb250ZXh0IHx8IGN1clN0YXRlLmNvbnRleHQubmFtZSAhPSBcIiFjZGF0YVwiKSBwdXNoQ29udGV4dChcIiFjZGF0YVwiKTtcbiAgICBpZiAoY3VyU3RhdGUudG9rZW5pemUgPT0gaW5UZXh0KSBwb3BDb250ZXh0KCk7XG4gICAgcmV0dXJuIGNvbnQoKTtcbiAgfVxuICBlbHNlIHJldHVybiBjb250KCk7XG59XG5cbmZ1bmN0aW9uIGVuZHBsdWdpbihzdGFydE9mTGluZSkge1xuICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmIChcbiAgICAgIHR5cGUgPT0gXCJzZWxmY2xvc2VQbHVnaW5cIiB8fFxuICAgICAgICB0eXBlID09IFwiZW5kUGx1Z2luXCJcbiAgICApXG4gICAgICByZXR1cm4gY29udCgpO1xuICAgIGlmICh0eXBlID09IFwiZW5kUGx1Z2luXCIpIHtwdXNoQ29udGV4dChjdXJTdGF0ZS5wbHVnaW5OYW1lLCBzdGFydE9mTGluZSk7IHJldHVybiBjb250KCk7fVxuICAgIHJldHVybiBjb250KCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGVuZGNsb3NlcGx1Z2luKGVycikge1xuICByZXR1cm4gZnVuY3Rpb24odHlwZSkge1xuICAgIGlmIChlcnIpIHNldFN0eWxlID0gXCJlcnJvclwiO1xuICAgIGlmICh0eXBlID09IFwiZW5kUGx1Z2luXCIpIHJldHVybiBjb250KCk7XG4gICAgcmV0dXJuIHBhc3MoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gYXR0cmlidXRlcyh0eXBlKSB7XG4gIGlmICh0eXBlID09IFwia2V5d29yZFwiKSB7c2V0U3R5bGUgPSBcImF0dHJpYnV0ZVwiOyByZXR1cm4gY29udChhdHRyaWJ1dGVzKTt9XG4gIGlmICh0eXBlID09IFwiZXF1YWxzXCIpIHJldHVybiBjb250KGF0dHZhbHVlLCBhdHRyaWJ1dGVzKTtcbiAgcmV0dXJuIHBhc3MoKTtcbn1cbmZ1bmN0aW9uIGF0dHZhbHVlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gXCJrZXl3b3JkXCIpIHtzZXRTdHlsZSA9IFwic3RyaW5nXCI7IHJldHVybiBjb250KCk7fVxuICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udChhdHR2YWx1ZW1heWJlKTtcbiAgcmV0dXJuIHBhc3MoKTtcbn1cbmZ1bmN0aW9uIGF0dHZhbHVlbWF5YmUodHlwZSkge1xuICBpZiAodHlwZSA9PSBcInN0cmluZ1wiKSByZXR1cm4gY29udChhdHR2YWx1ZW1heWJlKTtcbiAgZWxzZSByZXR1cm4gcGFzcygpO1xufVxuZXhwb3J0IGNvbnN0IHRpa2kgPSB7XG4gIG5hbWU6IFwidGlraVwiLFxuICBzdGFydFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4ge3Rva2VuaXplOiBpblRleHQsIGNjOiBbXSwgaW5kZW50ZWQ6IDAsIHN0YXJ0T2ZMaW5lOiB0cnVlLCBwbHVnaW5OYW1lOiBudWxsLCBjb250ZXh0OiBudWxsfTtcbiAgfSxcbiAgdG9rZW46IGZ1bmN0aW9uKHN0cmVhbSwgc3RhdGUpIHtcbiAgICBpZiAoc3RyZWFtLnNvbCgpKSB7XG4gICAgICBzdGF0ZS5zdGFydE9mTGluZSA9IHRydWU7XG4gICAgICBzdGF0ZS5pbmRlbnRlZCA9IHN0cmVhbS5pbmRlbnRhdGlvbigpO1xuICAgIH1cbiAgICBpZiAoc3RyZWFtLmVhdFNwYWNlKCkpIHJldHVybiBudWxsO1xuXG4gICAgc2V0U3R5bGUgPSB0eXBlID0gcGx1Z2luTmFtZSA9IG51bGw7XG4gICAgdmFyIHN0eWxlID0gc3RhdGUudG9rZW5pemUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKChzdHlsZSB8fCB0eXBlKSAmJiBzdHlsZSAhPSBcImNvbW1lbnRcIikge1xuICAgICAgY3VyU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIHZhciBjb21iID0gc3RhdGUuY2MucG9wKCkgfHwgZWxlbWVudDtcbiAgICAgICAgaWYgKGNvbWIodHlwZSB8fCBzdHlsZSkpIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0ZS5zdGFydE9mTGluZSA9IGZhbHNlO1xuICAgIHJldHVybiBzZXRTdHlsZSB8fCBzdHlsZTtcbiAgfSxcbiAgaW5kZW50OiBmdW5jdGlvbihzdGF0ZSwgdGV4dEFmdGVyLCBjeCkge1xuICAgIHZhciBjb250ZXh0ID0gc3RhdGUuY29udGV4dDtcbiAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0Lm5vSW5kZW50KSByZXR1cm4gMDtcbiAgICBpZiAoY29udGV4dCAmJiAvXntcXC8vLnRlc3QodGV4dEFmdGVyKSlcbiAgICAgIGNvbnRleHQgPSBjb250ZXh0LnByZXY7XG4gICAgd2hpbGUgKGNvbnRleHQgJiYgIWNvbnRleHQuc3RhcnRPZkxpbmUpXG4gICAgICBjb250ZXh0ID0gY29udGV4dC5wcmV2O1xuICAgIGlmIChjb250ZXh0KSByZXR1cm4gY29udGV4dC5pbmRlbnQgKyBjeC51bml0O1xuICAgIGVsc2UgcmV0dXJuIDA7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=