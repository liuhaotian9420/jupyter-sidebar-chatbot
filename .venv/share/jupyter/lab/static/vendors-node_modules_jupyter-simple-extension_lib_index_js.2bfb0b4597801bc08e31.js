"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_jupyter-simple-extension_lib_index_js"],{

/***/ "./node_modules/jupyter-simple-extension/lib/api-client.js":
/*!*****************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/api-client.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
/**
 * API client for interacting with the backend LLM service
 */
class ApiClient {
    constructor(baseUrl = 'http://localhost:8000') {
        this.baseUrl = baseUrl;
    }
    /**
     * Stream a chat response from the mock LLM
     * @param message The user message to send
     * @param context Optional context information
     * @param onChunk Callback for each text chunk received
     * @param onComplete Callback when streaming is complete
     * @param onError Callback for errors
     */
    async streamChat(message, context = null, onChunk, onComplete, onError) {
        try {
            const response = await fetch(`${this.baseUrl}/chat`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    message,
                    context
                })
            });
            if (!response.ok) {
                throw new Error(`API error: ${response.statusText}`);
            }
            if (!response.body) {
                throw new Error('ReadableStream not supported in this browser.');
            }
            // Set up stream reading
            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let done = false;
            while (!done) {
                const { value, done: readerDone } = await reader.read();
                done = readerDone;
                if (value) {
                    const chunk = decoder.decode(value, { stream: !done });
                    onChunk(chunk);
                }
            }
            onComplete();
        }
        catch (error) {
            onError(error instanceof Error ? error : new Error(String(error)));
        }
    }
    /**
     * Simple health check for the API
     * @returns A promise that resolves to true if the API is healthy
     */
    async healthCheck() {
        try {
            const response = await fetch(`${this.baseUrl}/health`);
            return response.ok;
        }
        catch (error) {
            console.error('API health check failed:', error);
            return false;
        }
    }
}
exports.ApiClient = ApiClient;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js":
/*!***************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CellContextTracker = void 0;
/**
 * Tracks cell context and cursor position within Jupyter notebooks
 */
class CellContextTracker {
    constructor(app, notebookTracker) {
        this.activeCellEditorNode = null;
        this.lastCellContext = null;
        this._isDisposed = false;
        /**
         * Handles editor events (keydown, mouseup)
         */
        this.handleEditorEvent = (event) => {
            try {
                // Get the current active cell from the tracker
                const cell = this.notebookTracker.activeCell;
                if (!cell || !cell.editor)
                    return;
                // Find the inner EditorView instance
                const editor = cell.editor;
                const view = editor.editor;
                if (!view)
                    return;
                // Get and store the cursor context
                this.lastCellContext = this.getCmContext(view);
            }
            catch (error) {
                console.error("Error in editor event handler:", error);
            }
        };
        this.notebookTracker = notebookTracker;
        this.setupTrackers();
    }
    /**
     * Whether this object has been disposed
     */
    get isDisposed() {
        return this._isDisposed;
    }
    /**
     * Sets up all the necessary event trackers
     */
    setupTrackers() {
        // Handle active cell changes
        this.notebookTracker.activeCellChanged.connect(this.setupCellListeners, this);
        // Handle notebook changes
        this.notebookTracker.currentChanged.connect(this.handleNotebookChange, this);
    }
    /**
     * Handles notebook changes
     */
    handleNotebookChange(tracker, panel) {
        this.cleanupPreviousListeners();
        if (panel && panel.content) {
            const cell = panel.content.activeCell;
            this.setupCellListeners(tracker, cell);
        }
    }
    /**
     * Sets up event listeners on the active cell
     */
    setupCellListeners(_tracker, cell) {
        if (!cell)
            return;
        this.cleanupPreviousListeners();
        if (cell.editor) {
            try {
                const cellNode = cell.node;
                const editorNode = cellNode.querySelector('.jp-Editor') ||
                    cellNode.querySelector('.jp-InputArea-editor');
                if (editorNode) {
                    this.activeCellEditorNode = editorNode;
                    // Add event listeners for key and mouse events
                    editorNode.addEventListener('keydown', this.handleEditorEvent);
                    editorNode.addEventListener('mouseup', this.handleEditorEvent);
                    // Try to capture immediate context if EditorView available
                    const view = cell.editor.editor;
                    if (view) {
                        this.lastCellContext = this.getCmContext(view);
                    }
                }
            }
            catch (error) {
                console.error("Error setting up cell listeners:", error);
            }
        }
    }
    /**
     * Cleans up event listeners from the previous active cell
     */
    cleanupPreviousListeners() {
        if (this.activeCellEditorNode) {
            this.activeCellEditorNode.removeEventListener('keydown', this.handleEditorEvent);
            this.activeCellEditorNode.removeEventListener('mouseup', this.handleEditorEvent);
            this.activeCellEditorNode = null;
        }
    }
    /**
     * Gets context information from CodeMirror EditorView
     */
    getCmContext(view) {
        const state = view.state;
        const offset = state.selection.main.head;
        const fullText = state.doc.toString();
        const line = state.doc.lineAt(offset);
        const position = {
            line: line.number - 1,
            column: offset - line.from,
            offset: offset
        };
        const contextRadius = 100;
        const start = Math.max(0, offset - contextRadius);
        const end = Math.min(fullText.length, offset + contextRadius);
        return {
            text: fullText,
            position: position,
            contextBefore: fullText.substring(start, offset),
            contextAfter: fullText.substring(offset, end)
        };
    }
    /**
     * Gets the current cell context
     */
    getCurrentCellContext() {
        return this.lastCellContext;
    }
    /**
     * Disposes all resources
     */
    dispose() {
        if (this._isDisposed) {
            return;
        }
        this._isDisposed = true;
        this.cleanupPreviousListeners();
        this.notebookTracker.activeCellChanged.disconnect(this.setupCellListeners, this);
        this.notebookTracker.currentChanged.disconnect(this.handleNotebookChange, this);
    }
}
exports.CellContextTracker = CellContextTracker;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/chat-history-manager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/chat-history-manager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Manages chat history functionality
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChatHistoryManager = void 0;
/**
 * Manages chat history storage, retrieval, and manipulation
 */
class ChatHistoryManager {
    constructor() {
        this.chatHistory = [];
        this.currentChatId = '';
    }
    /**
     * Creates a new chat session
     * @returns The ID of the newly created chat
     */
    createNewChat() {
        // Generate a unique ID for the chat
        const chatId = `chat-${Date.now()}`;
        // Create a new chat item
        const newChat = {
            id: chatId,
            title: `Chat ${this.chatHistory.length + 1}`,
            messages: []
        };
        // Add to history and set as current
        this.chatHistory.push(newChat);
        this.currentChatId = chatId;
        return chatId;
    }
    /**
     * Adds a message to the current chat
     * @param text Message text
     * @param sender Message sender
     * @param isMarkdown Whether the message is in markdown format
     */
    addMessage(text, sender, isMarkdown = false) {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            const message = {
                text,
                sender,
                isMarkdown
            };
            chat.messages.push(message);
        }
    }
    /**
     * Gets the current chat
     * @returns The current chat or undefined if none exists
     */
    getCurrentChat() {
        return this.chatHistory.find(c => c.id === this.currentChatId);
    }
    /**
     * Gets all chat history
     * @returns Array of all chat history items
     */
    getAllChats() {
        return [...this.chatHistory];
    }
    /**
     * Loads a chat by ID
     * @param chatId The ID of the chat to load
     * @returns The loaded chat or undefined if not found
     */
    loadChat(chatId) {
        const chat = this.chatHistory.find(c => c.id === chatId);
        if (chat) {
            this.currentChatId = chatId;
            return chat;
        }
        return undefined;
    }
    /**
     * Updates the title of the current chat
     * @param title The new title
     */
    updateCurrentChatTitle(title) {
        const chat = this.chatHistory.find(c => c.id === this.currentChatId);
        if (chat) {
            chat.title = title;
        }
    }
    /**
     * Gets the current chat ID
     * @returns The current chat ID
     */
    getCurrentChatId() {
        return this.currentChatId;
    }
}
exports.ChatHistoryManager = ChatHistoryManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/file-browser-manager.js":
/*!********************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/file-browser-manager.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Manages file and directory browsing functionality
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileBrowserManager = void 0;
/**
 * Manages file and directory browsing operations
 */
class FileBrowserManager {
    constructor(docManager) {
        this.currentPath = '';
        this.docManager = docManager;
    }
    /**
     * Lists the contents of the current directory
     * @param filterType Optional parameter to filter results by type ('all', 'file', or 'directory')
     * @returns A promise resolving to an array of item names or null on error
     */
    async listCurrentDirectoryContents(filterType = 'all') {
        console.log('LIST DIR: Starting directory listing process...', { filterType });
        try {
            // Ensure we have a current path
            if (!this.currentPath) {
                await this.setCurrentDirectoryPath();
            }
            console.log('LIST DIR: Current path:', this.currentPath);
            // Get directory contents using the document manager
            const dirContents = await this.docManager.services.contents.get(this.currentPath, { content: true });
            if (!dirContents) {
                console.error('LIST DIR: Failed to get directory contents');
                return null;
            }
            console.log('LIST DIR: Got directory contents:', dirContents);
            // Filter contents based on filterType
            let filteredContents = dirContents.content || [];
            if (filterType === 'file') {
                filteredContents = filteredContents.filter((item) => item.type !== 'directory');
            }
            else if (filterType === 'directory') {
                filteredContents = filteredContents.filter((item) => item.type === 'directory');
            }
            // Sort directories first, then files
            filteredContents.sort((a, b) => {
                if (a.type === 'directory' && b.type !== 'directory') {
                    return -1;
                }
                if (a.type !== 'directory' && b.type === 'directory') {
                    return 1;
                }
                return a.name.localeCompare(b.name);
            });
            // Extract names
            const names = filteredContents.map((item) => {
                if (item.type === 'directory') {
                    return `\ud83d\udcc1 ${item.name}`;
                }
                else {
                    return `\ud83d\udcc4 ${item.name}`;
                }
            });
            console.log('LIST DIR: Filtered and sorted names:', names);
            return names;
        }
        catch (error) {
            console.error('LIST DIR: Error listing directory contents:', error);
            return null;
        }
    }
    /**
     * Sets the current directory path based on context
     */
    async setCurrentDirectoryPath() {
        // If we already have a path, keep using it
        if (this.currentPath) {
            return;
        }
        try {
            // Just use empty path for now as a fallback
            // In a real implementation, we would try to get the current directory from the document manager
            this.currentPath = '';
            console.log('DIR PATH: Using empty path as fallback');
        }
        catch (error) {
            console.error('DIR PATH: Error setting directory path:', error);
            this.currentPath = '';
        }
    }
    /**
     * Navigates to a subdirectory
     * @param dirName The name of the subdirectory to navigate to
     */
    navigateToSubdirectory(dirName) {
        // Remove the folder emoji if present
        const cleanDirName = dirName.replace('\ud83d\udcc1 ', '');
        // Update the current path
        if (this.currentPath) {
            this.currentPath = `${this.currentPath}/${cleanDirName}`;
        }
        else {
            this.currentPath = cleanDirName;
        }
        // Normalize the path
        this.currentPath = this.currentPath.replace(/\/+/g, '/');
        console.log('DIR NAV: Navigated to:', this.currentPath);
    }
    /**
     * Navigates to the parent directory
     * @returns True if navigation was successful, false otherwise
     */
    navigateToParentDirectory() {
        // Check if we're already at the root
        if (!this.currentPath || this.currentPath === '') {
            return false;
        }
        // Get the parent path
        const parts = this.currentPath.split('/');
        parts.pop(); // Remove the last part
        this.currentPath = parts.join('/');
        console.log('DIR NAV: Navigated to parent:', this.currentPath);
        return true;
    }
    /**
     * Gets the current directory path
     * @returns The current directory path
     */
    getCurrentPath() {
        return this.currentPath;
    }
    /**
     * Sets the current directory path
     * @param path The new path to set
     */
    setCurrentPath(path) {
        this.currentPath = path;
    }
}
exports.FileBrowserManager = FileBrowserManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/input-handler.js":
/*!*************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/input-handler.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Handles input field functionality
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InputHandler = void 0;
/**
 * Manages input field behavior and interactions
 */
class InputHandler {
    constructor(inputField, _inputContainer, // Prefix with underscore to indicate it's not used
    onSendMessage) {
        this.isInputExpanded = false;
        this.isMarkdownMode = false;
        this.inputField = inputField;
        this.onSendMessage = onSendMessage;
        // Set up input field event listeners
        this.setupInputFieldEvents();
    }
    /**
     * Sets up event listeners for the input field
     */
    setupInputFieldEvents() {
        // Handle Enter key to send message
        this.inputField.addEventListener('keydown', (event) => {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                this.onSendMessage();
            }
        });
    }
    /**
     * Toggles the expansion state of the input field
     * @param button The button element that triggered the toggle
     */
    toggleInputExpansion(button) {
        this.isInputExpanded = !this.isInputExpanded;
        if (this.isInputExpanded) {
            this.inputField.style.height = '150px';
            this.inputField.style.resize = 'vertical';
            button.textContent = '\u25bc';
        }
        else {
            this.inputField.style.height = '50px';
            this.inputField.style.resize = 'none';
            button.textContent = '\u25b2';
        }
    }
    /**
     * Toggles markdown mode
     * @param button The button element that triggered the toggle
     */
    toggleMarkdownMode(button) {
        this.isMarkdownMode = !this.isMarkdownMode;
        if (this.isMarkdownMode) {
            button.textContent = 'MD';
            button.classList.add('active');
        }
        else {
            button.textContent = 'MD';
            button.classList.remove('active');
        }
    }
    /**
     * Gets the current input text
     * @returns The current input text
     */
    getInputText() {
        return this.inputField.value;
    }
    /**
     * Clears the input field
     */
    clearInput() {
        this.inputField.value = '';
    }
    /**
     * Appends text to the input field with proper spacing
     * @param text The text to append
     */
    appendToInput(text) {
        try {
            const currentText = this.inputField.value;
            const cursorPosition = this.inputField.selectionStart;
            // Check if we need to add a space before the text
            const needsLeadingSpace = cursorPosition > 0 &&
                currentText.charAt(cursorPosition - 1) !== ' ' &&
                currentText.charAt(cursorPosition - 1) !== '\n';
            // Check if we need to add a space after the text
            const needsTrailingSpace = cursorPosition < currentText.length &&
                currentText.charAt(cursorPosition) !== ' ' &&
                currentText.charAt(cursorPosition) !== '\n';
            // Build the text to insert
            let insertText = '';
            if (needsLeadingSpace)
                insertText += ' ';
            insertText += text;
            if (needsTrailingSpace)
                insertText += ' ';
            // Insert the text at the cursor position
            const newText = currentText.substring(0, cursorPosition) +
                insertText +
                currentText.substring(cursorPosition);
            this.inputField.value = newText;
            // Set focus back to the input field
            this.inputField.focus();
        }
        catch (error) {
            console.error('Error appending to input:', error);
        }
    }
    /**
     * Checks if markdown mode is enabled
     * @returns True if markdown mode is enabled, false otherwise
     */
    isMarkdownEnabled() {
        return this.isMarkdownMode;
    }
}
exports.InputHandler = InputHandler;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/message-renderer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/message-renderer.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


/**
 * Handles rendering and managing chat messages
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageRenderer = void 0;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
const dompurify_1 = __importDefault(__webpack_require__(/*! dompurify */ "webpack/sharing/consume/default/dompurify/dompurify"));
const markdown_config_1 = __webpack_require__(/*! ../markdown-config */ "./node_modules/jupyter-simple-extension/lib/markdown-config.js");
/**
 * Handles rendering and managing chat messages in the UI
 */
class MessageRenderer {
    constructor(messageContainer, onCopyMessage, onAddToCell) {
        this.messageContainer = messageContainer;
        this.onCopyMessage = onCopyMessage;
        this.onAddToCell = onAddToCell;
    }
    /**
     * Renders a message in the UI
     * @param text The text content of the message
     * @param sender The sender of the message ('user' or 'bot')
     * @param isMarkdown Whether the message is in Markdown format
     * @returns The created message element
     */
    renderMessage(text, sender, isMarkdown = false) {
        console.log('Rendering message:', { sender, isMarkdown }); // Debug log
        // Create message container
        const messageElement = document.createElement('div');
        messageElement.className = `chat-message ${sender}-message`;
        // Create message header with sender info
        const messageHeader = document.createElement('div');
        messageHeader.className = 'message-header';
        messageHeader.textContent = sender === 'user' ? 'You' : 'AI';
        messageElement.appendChild(messageHeader);
        // Create message content
        const messageContent = document.createElement('div');
        messageContent.className = 'message-content';
        // Process and render the message content
        if (isMarkdown) {
            try {
                // Preprocess markdown to handle special syntax
                const processedMarkdown = (0, markdown_config_1.preprocessMarkdown)(text);
                // Convert markdown to HTML
                const rawHtml = marked_1.marked.parse(processedMarkdown);
                // Sanitize HTML (cast to string to fix type issue)
                const sanitizedHtml = dompurify_1.default.sanitize(rawHtml);
                // Set the HTML content
                messageContent.innerHTML = sanitizedHtml;
                // Add syntax highlighting to code blocks
                const codeBlocks = messageContent.querySelectorAll('pre code');
                codeBlocks.forEach((block) => {
                    var _a, _b;
                    // Add a class for styling
                    (_a = block.parentElement) === null || _a === void 0 ? void 0 : _a.classList.add('highlighted-code');
                    // Add copy button to code blocks
                    const copyButton = document.createElement('button');
                    copyButton.className = 'code-copy-button';
                    copyButton.textContent = 'Copy';
                    copyButton.addEventListener('click', () => {
                        const codeText = block.innerText;
                        this.onCopyMessage(codeText);
                        copyButton.textContent = 'Copied!';
                        setTimeout(() => {
                            copyButton.textContent = 'Copy';
                        }, 2000);
                    });
                    // Add the copy button to the pre element
                    (_b = block.parentElement) === null || _b === void 0 ? void 0 : _b.appendChild(copyButton);
                });
            }
            catch (error) {
                console.error('Error rendering markdown:', error);
                messageContent.textContent = text;
            }
        }
        else {
            // Plain text rendering
            messageContent.textContent = text;
        }
        messageElement.appendChild(messageContent);
        // Create message actions
        const messageActions = document.createElement('div');
        messageActions.className = 'message-actions';
        // Add copy button
        const copyButton = document.createElement('button');
        copyButton.className = 'message-action-button';
        copyButton.textContent = 'Copy';
        copyButton.title = 'Copy to clipboard';
        copyButton.addEventListener('click', () => {
            this.onCopyMessage(text);
            copyButton.textContent = 'Copied!';
            setTimeout(() => {
                copyButton.textContent = 'Copy';
            }, 2000);
        });
        messageActions.appendChild(copyButton);
        // Add "Add to Cell" button
        const addToCellButton = document.createElement('button');
        addToCellButton.className = 'message-action-button';
        addToCellButton.textContent = 'Add to Cell';
        addToCellButton.title = 'Add to current cell';
        addToCellButton.addEventListener('click', () => {
            this.onAddToCell(text);
            addToCellButton.textContent = 'Added!';
            setTimeout(() => {
                addToCellButton.textContent = 'Add to Cell';
            }, 2000);
        });
        messageActions.appendChild(addToCellButton);
        messageElement.appendChild(messageActions);
        // Add to message container
        this.messageContainer.appendChild(messageElement);
        // Scroll to the bottom
        this.messageContainer.scrollTop = this.messageContainer.scrollHeight;
        return messageElement;
    }
    /**
     * Clears all messages from the container
     */
    clearMessages() {
        this.messageContainer.innerHTML = '';
    }
    /**
     * Renders a list of messages
     * @param messages The messages to render
     */
    renderMessages(messages) {
        this.clearMessages();
        messages.forEach(message => {
            this.renderMessage(message.text, message.sender, message.isMarkdown);
        });
    }
}
exports.MessageRenderer = MessageRenderer;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/popup-menu-manager.js":
/*!******************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/popup-menu-manager.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Manages popup menu functionality
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PopupMenuManager = void 0;
/**
 * Manages popup menu creation, display, and interaction
 */
class PopupMenuManager {
    constructor(fileBrowserManager, onItemSelected) {
        /**
         * Handles document click events to close the menu when clicking outside
         */
        this.handleDocumentClick = (event) => {
            // Check if the click is outside the popup menu container
            if (this.popupMenuContainer.style.display !== 'none' &&
                !this.popupMenuContainer.contains(event.target)) {
                this.hidePopupMenu();
            }
        };
        this.fileBrowserManager = fileBrowserManager;
        this.onItemSelected = onItemSelected;
        // Initialize menu state
        this.menuState = {
            currentMenuLevel: 'top',
            currentMenuPath: '',
            menuHistory: []
        };
        // Create popup menu container
        this.popupMenuContainer = document.createElement('div');
        this.popupMenuContainer.className = 'jp-llm-ext-popup-menu-container';
        this.popupMenuContainer.style.display = 'none';
        document.body.appendChild(this.popupMenuContainer);
        // Add click event listener to close menu when clicking outside
        document.addEventListener('click', this.handleDocumentClick);
    }
    /**
     * Shows the popup menu at the specified position
     * @param x The x-coordinate of the popup menu
     * @param y The y-coordinate of the popup menu
     */
    showPopupMenu(x, y) {
        // Clear previous menu items
        this.popupMenuContainer.innerHTML = '';
        // Reset menu state for top level
        this.menuState.currentMenuLevel = 'top';
        this.menuState.menuHistory = [];
        // Create top-level menu items
        const commands = [
            {
                label: 'Code',
                description: 'Insert selected code',
                action: () => {
                    this.hidePopupMenu();
                    this.handleCodeCommand();
                }
            },
            {
                label: 'Cell',
                description: 'Insert entire cell content',
                action: () => {
                    this.hidePopupMenu();
                    this.handleCellCommand();
                }
            },
            {
                label: 'Files',
                description: 'Browse and insert file content',
                action: () => {
                    this.menuState.currentMenuLevel = 'files';
                    this.menuState.menuHistory.push({ level: 'top', path: '' });
                    this.loadDirectoryContents(x, y);
                }
            },
            {
                label: 'Directories',
                description: 'Browse and reference directories',
                action: () => {
                    this.menuState.currentMenuLevel = 'directories';
                    this.menuState.menuHistory.push({ level: 'top', path: '' });
                    this.loadDirectoryContents(x, y);
                }
            }
        ];
        this.createMenuItems(commands);
        // Position and show the menu
        this.positionMenu(x, y);
    }
    /**
     * Creates menu items from commands and appends them to the popup menu container
     * @param commands The array of commands to create menu items for
     */
    createMenuItems(commands) {
        commands.forEach(command => {
            const item = document.createElement('div');
            item.className = 'jp-llm-ext-popup-menu-item';
            const label = document.createElement('div');
            label.className = 'jp-llm-ext-popup-menu-item-label';
            label.textContent = command.label;
            const description = document.createElement('div');
            description.className = 'jp-llm-ext-popup-menu-item-description';
            description.textContent = command.description;
            item.appendChild(label);
            item.appendChild(description);
            item.addEventListener('click', (e) => {
                e.stopPropagation();
                command.action();
            });
            this.popupMenuContainer.appendChild(item);
        });
    }
    /**
     * Loads and displays directory contents in the popup menu
     * @param x The x-coordinate of the popup menu
     * @param y The y-coordinate of the popup menu
     */
    async loadDirectoryContents(x, y) {
        // Show loading indicator
        this.popupMenuContainer.innerHTML = '<div class="jp-llm-ext-popup-menu-loading">Loading...</div>';
        // Determine filter type based on menu level
        const filterType = this.menuState.currentMenuLevel === 'files' ? 'file' : 'directory';
        // Get directory contents
        const contents = await this.fileBrowserManager.listCurrentDirectoryContents(filterType);
        // Clear the menu
        this.popupMenuContainer.innerHTML = '';
        // Add back button if we have history
        if (this.menuState.menuHistory.length > 0) {
            const backCommand = {
                label: '⬅️ Back',
                description: 'Go back to previous menu',
                action: () => {
                    // Pop the last item from history
                    const previous = this.menuState.menuHistory.pop();
                    if (previous) {
                        // Restore previous state
                        this.menuState.currentMenuLevel = previous.level;
                        // If going back to top level
                        if (previous.level === 'top') {
                            this.showPopupMenu(x, y);
                        }
                        else {
                            // If going back to a directory level, we need to go up one directory
                            this.fileBrowserManager.navigateToParentDirectory();
                            this.loadDirectoryContents(x, y);
                        }
                    }
                }
            };
            this.createMenuItems([backCommand]);
            // Add current path indicator
            const pathIndicator = document.createElement('div');
            pathIndicator.className = 'jp-llm-ext-popup-menu-path';
            pathIndicator.textContent = `Path: ${this.fileBrowserManager.getCurrentPath() || '/'}`;
            this.popupMenuContainer.appendChild(pathIndicator);
        }
        // If no contents or error
        if (!contents || contents.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'jp-llm-ext-popup-menu-empty';
            emptyMessage.textContent = 'No items found';
            this.popupMenuContainer.appendChild(emptyMessage);
        }
        else {
            // Create commands for each item
            const commands = contents.map(item => {
                return {
                    label: item,
                    description: '',
                    action: () => {
                        // Handle directory navigation
                        if (item.startsWith('📁') && this.menuState.currentMenuLevel === 'directories') {
                            // Navigate to subdirectory
                            this.fileBrowserManager.navigateToSubdirectory(item);
                            this.menuState.menuHistory.push({
                                level: this.menuState.currentMenuLevel,
                                path: this.fileBrowserManager.getCurrentPath()
                            });
                            this.loadDirectoryContents(x, y);
                        }
                        else {
                            // Handle file selection
                            this.hidePopupMenu();
                            this.onItemSelected(item);
                        }
                    }
                };
            });
            this.createMenuItems(commands);
        }
        // Reposition the menu
        this.positionMenu(x, y);
    }
    /**
     * Positions the popup menu at the specified coordinates
     * @param x The x-coordinate
     * @param y The y-coordinate
     */
    positionMenu(x, y) {
        // Get viewport dimensions
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        // Get menu dimensions
        const menuWidth = this.popupMenuContainer.offsetWidth;
        const menuHeight = this.popupMenuContainer.offsetHeight;
        // Adjust position to ensure menu stays within viewport
        let adjustedX = x;
        let adjustedY = y;
        if (x + menuWidth > viewportWidth) {
            adjustedX = viewportWidth - menuWidth - 10;
        }
        if (y + menuHeight > viewportHeight) {
            adjustedY = viewportHeight - menuHeight - 10;
        }
        // Set position
        this.popupMenuContainer.style.left = `${adjustedX}px`;
        this.popupMenuContainer.style.top = `${adjustedY}px`;
        this.popupMenuContainer.style.display = 'block';
    }
    /**
     * Hides the popup menu
     */
    hidePopupMenu() {
        // Only act if the menu is currently displayed
        if (this.popupMenuContainer.style.display !== 'none') {
            this.popupMenuContainer.style.display = 'none';
            this.popupMenuContainer.innerHTML = '';
        }
    }
    /**
     * Handles the code command - inserts selected code
     * Placeholder for implementation in SimpleSidebarWidget
     */
    handleCodeCommand() {
        // This will be implemented by the SimpleSidebarWidget
        console.log('Code command selected');
    }
    /**
     * Handles the cell command - inserts entire cell content
     * Placeholder for implementation in SimpleSidebarWidget
     */
    handleCellCommand() {
        // This will be implemented by the SimpleSidebarWidget
        console.log('Cell command selected');
    }
    /**
     * Cleans up resources
     */
    dispose() {
        document.removeEventListener('click', this.handleDocumentClick);
        if (this.popupMenuContainer.parentNode) {
            this.popupMenuContainer.parentNode.removeChild(this.popupMenuContainer);
        }
    }
}
exports.PopupMenuManager = PopupMenuManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/settings-manager.js":
/*!****************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/settings-manager.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


/**
 * Manages settings and configuration for the chat interface
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SettingsManager = void 0;
/**
 * Manages settings and configuration for the chat interface
 */
class SettingsManager {
    constructor() {
        this.defaultSettings = {
            provider: 'OpenAI',
            apiKey: '',
            apiBaseUrl: '',
            rules: ''
        };
        this.currentSettings = Object.assign({}, this.defaultSettings);
        this.settingsModalContainer = this.createSettingsModal();
        document.body.appendChild(this.settingsModalContainer);
    }
    /**
     * Creates the settings modal
     * @returns The created modal container
     */
    createSettingsModal() {
        const modal = document.createElement('div');
        modal.style.position = 'fixed';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.display = 'none';
        modal.style.justifyContent = 'center';
        modal.style.alignItems = 'center';
        modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)';
        modal.style.zIndex = '1000';
        const content = document.createElement('div');
        content.style.backgroundColor = '#fff';
        content.style.padding = '20px';
        content.style.borderRadius = '5px';
        content.style.width = '400px';
        const title = document.createElement('h3');
        title.textContent = 'Settings';
        content.appendChild(title);
        const providerLabel = document.createElement('label');
        providerLabel.htmlFor = 'settings-provider';
        providerLabel.textContent = 'LLM Provider:';
        content.appendChild(providerLabel);
        const providerSelect = document.createElement('select');
        providerSelect.id = 'settings-provider';
        ['OpenAI', 'HuggingFace', 'Local'].forEach(opt => {
            const option = document.createElement('option');
            option.value = opt;
            option.textContent = opt;
            providerSelect.appendChild(option);
        });
        content.appendChild(providerSelect);
        content.appendChild(document.createElement('br'));
        const keyLabel = document.createElement('label');
        keyLabel.htmlFor = 'settings-api-key';
        keyLabel.textContent = 'API Key:';
        content.appendChild(keyLabel);
        const keyInput = document.createElement('input');
        keyInput.id = 'settings-api-key';
        keyInput.type = 'text';
        keyInput.style.width = '100%';
        content.appendChild(keyInput);
        content.appendChild(document.createElement('br'));
        const urlLabel = document.createElement('label');
        urlLabel.htmlFor = 'settings-api-base-url';
        urlLabel.textContent = 'API Base URL (optional):';
        content.appendChild(urlLabel);
        const urlInput = document.createElement('input');
        urlInput.id = 'settings-api-base-url';
        urlInput.type = 'text';
        urlInput.style.width = '100%';
        content.appendChild(urlInput);
        content.appendChild(document.createElement('br'));
        const rulesLabel = document.createElement('label');
        rulesLabel.htmlFor = 'settings-rules';
        rulesLabel.textContent = 'Rules:';
        content.appendChild(rulesLabel);
        const rulesTextarea = document.createElement('textarea');
        rulesTextarea.id = 'settings-rules';
        rulesTextarea.style.width = '100%';
        rulesTextarea.style.height = '100px';
        content.appendChild(rulesTextarea);
        content.appendChild(document.createElement('br'));
        const btnContainer = document.createElement('div');
        btnContainer.style.textAlign = 'right';
        btnContainer.style.marginTop = '10px';
        const saveBtn = document.createElement('button');
        saveBtn.textContent = 'Save';
        saveBtn.addEventListener('click', () => {
            const provider = document.getElementById('settings-provider').value;
            const key = document.getElementById('settings-api-key').value;
            const url = document.getElementById('settings-api-base-url').value;
            const rules = document.getElementById('settings-rules').value;
            this.currentSettings = {
                provider,
                apiKey: key,
                apiBaseUrl: url,
                rules
            };
            console.log('Settings saved:', this.currentSettings);
            this.hideSettingsModal();
        });
        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = 'Cancel';
        cancelBtn.style.marginLeft = '10px';
        cancelBtn.addEventListener('click', () => this.hideSettingsModal());
        btnContainer.appendChild(saveBtn);
        btnContainer.appendChild(cancelBtn);
        content.appendChild(btnContainer);
        modal.appendChild(content);
        return modal;
    }
    /**
     * Shows the settings modal
     */
    showSettingsModal() {
        // Update form fields with current settings
        document.getElementById('settings-provider').value = this.currentSettings.provider;
        document.getElementById('settings-api-key').value = this.currentSettings.apiKey;
        document.getElementById('settings-api-base-url').value = this.currentSettings.apiBaseUrl;
        document.getElementById('settings-rules').value = this.currentSettings.rules;
        this.settingsModalContainer.style.display = 'flex';
    }
    /**
     * Hides the settings modal
     */
    hideSettingsModal() {
        this.settingsModalContainer.style.display = 'none';
    }
    /**
     * Gets the current settings
     * @returns The current settings
     */
    getSettings() {
        return Object.assign({}, this.currentSettings);
    }
    /**
     * Cleans up resources
     */
    dispose() {
        if (this.settingsModalContainer.parentNode) {
            this.settingsModalContainer.parentNode.removeChild(this.settingsModalContainer);
        }
    }
}
exports.SettingsManager = SettingsManager;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/chat/sidebar-widget.js":
/*!**************************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/chat/sidebar-widget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


/**
 * Main sidebar widget for the AI chat interface in JupyterLab
 */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSidebarWidget = void 0;
const widgets_1 = __webpack_require__(/*! @lumino/widgets */ "webpack/sharing/consume/default/@lumino/widgets/@lumino/widgets");
const icons_1 = __webpack_require__(/*! ../icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
const globals_1 = __webpack_require__(/*! ../globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
__webpack_require__(/*! ../../style/index.css */ "./node_modules/jupyter-simple-extension/style/index.css"); // Add this line
// Import modular components
const chat_history_manager_1 = __webpack_require__(/*! ./chat-history-manager */ "./node_modules/jupyter-simple-extension/lib/chat/chat-history-manager.js");
const file_browser_manager_1 = __webpack_require__(/*! ./file-browser-manager */ "./node_modules/jupyter-simple-extension/lib/chat/file-browser-manager.js");
const popup_menu_manager_1 = __webpack_require__(/*! ./popup-menu-manager */ "./node_modules/jupyter-simple-extension/lib/chat/popup-menu-manager.js");
const message_renderer_1 = __webpack_require__(/*! ./message-renderer */ "./node_modules/jupyter-simple-extension/lib/chat/message-renderer.js");
const settings_manager_1 = __webpack_require__(/*! ./settings-manager */ "./node_modules/jupyter-simple-extension/lib/chat/settings-manager.js");
const input_handler_1 = __webpack_require__(/*! ./input-handler */ "./node_modules/jupyter-simple-extension/lib/chat/input-handler.js");
/**
 * Main sidebar widget for the AI chat interface in JupyterLab.
 * This widget provides a comprehensive chat-based interface for interacting with AI assistants,
 * supporting text input, Markdown rendering, file and directory browsing through a multi-level
 * pop-up menu, and chat history management. It integrates with JupyterLab's APIs to interact
 * with notebooks and manage document contexts.
 */
class SimpleSidebarWidget extends widgets_1.Widget {
    /**
     * Constructor for the SimpleSidebarWidget class.
     * Initializes the widget with the provided document manager and sets up the basic UI components.
     * @param docManager The document manager instance for interacting with JupyterLab documents.
     */
    constructor(docManager) {
        super();
        this.isHistoryViewActive = false;
        /**
         * Handles keyboard shortcuts for improved user experience.
         * Currently supports Ctrl+L for inserting selected code or cell content.
         * @param event The keyboard event triggered by the user.
         */
        this.handleKeyDown = (event) => {
            // Check for Ctrl+L (for selected code)
            if (event.ctrlKey && event.key === 'l') {
                event.preventDefault();
                this.handleCodeCommand();
                this.showKeyboardShortcutIndicator('Selected code inserted');
            }
        };
        this.docManager = docManager;
        this.id = 'simple-sidebar';
        this.title.label = '';
        this.title.caption = 'AI Chat Interface';
        this.title.icon = icons_1.extensionIcon;
        this.title.closable = true;
        // Initialize container elements before creating layout
        this.messageContainer = document.createElement('div');
        this.inputContainer = document.createElement('div');
        this.inputField = document.createElement('textarea');
        this.titleInput = document.createElement('input');
        this.historyContainer = document.createElement('div');
        // Create keyboard shortcut indicator for user feedback
        this.keyboardShortcutIndicator = document.createElement('div');
        this.keyboardShortcutIndicator.className = 'keyboard-shortcut-indicator';
        document.body.appendChild(this.keyboardShortcutIndicator);
        // Initialize modular components
        this.initializeModularComponents();
        // Create a new chat on start
        this.chatHistoryManager.createNewChat();
        this.updateCurrentChatTitle();
        // Create and add the main layout
        this.node.appendChild(this.createLayout());
        // Add keyboard shortcut listener for improved UX
        document.addEventListener('keydown', this.handleKeyDown);
    }
    /**
     * Initializes all modular components
     */
    initializeModularComponents() {
        // Initialize chat history manager
        this.chatHistoryManager = new chat_history_manager_1.ChatHistoryManager();
        // Initialize file browser manager
        this.fileBrowserManager = new file_browser_manager_1.FileBrowserManager(this.docManager);
        // Initialize message renderer
        this.messageRenderer = new message_renderer_1.MessageRenderer(this.messageContainer, this.copyMessageToClipboard.bind(this), this.addMessageToCell.bind(this));
        // Initialize input handler
        this.inputHandler = new input_handler_1.InputHandler(this.inputField, this.inputContainer, this.handleSendMessage.bind(this));
        // Initialize popup menu manager
        this.popupMenuManager = new popup_menu_manager_1.PopupMenuManager(this.fileBrowserManager, this.appendToInput.bind(this));
        // Initialize settings manager
        this.settingsManager = new settings_manager_1.SettingsManager();
    }
    /**
     * Shows a visual indicator for keyboard shortcuts.
     * @param text The text to display in the indicator.
     */
    showKeyboardShortcutIndicator(text) {
        this.keyboardShortcutIndicator.textContent = text;
        this.keyboardShortcutIndicator.classList.add('visible');
        // Hide after 1 second
        setTimeout(() => {
            this.keyboardShortcutIndicator.classList.remove('visible');
        }, 1000);
    }
    /**
     * Disposes all resources when the widget is closed.
     */
    dispose() {
        // Remove keyboard shortcut listener
        document.removeEventListener('keydown', this.handleKeyDown);
        // Remove keyboard shortcut indicator
        if (this.keyboardShortcutIndicator.parentNode) {
            this.keyboardShortcutIndicator.parentNode.removeChild(this.keyboardShortcutIndicator);
        }
        // Dispose modular components
        this.popupMenuManager.dispose();
        this.settingsManager.dispose();
        super.dispose();
    }
    /**
     * Creates the main layout for the sidebar widget.
     * Includes the title input, message container, history container, input field, and controls.
     * @returns The main content element of the widget.
     */
    createLayout() {
        // Create the main container
        const container = document.createElement('div');
        container.className = 'jp-llm-ext-container';
        // Create title input container
        const titleContainer = document.createElement('div');
        titleContainer.className = 'jp-llm-ext-title-container';
        this.titleInput.className = 'jp-llm-ext-title-input';
        this.titleInput.placeholder = 'Chat Title';
        this.titleInput.addEventListener('change', () => {
            this.chatHistoryManager.updateCurrentChatTitle(this.titleInput.value);
        });
        titleContainer.appendChild(this.titleInput);
        container.appendChild(titleContainer);
        // Configure message container
        this.messageContainer.className = 'jp-llm-ext-message-container';
        container.appendChild(this.messageContainer);
        // Configure history container
        this.historyContainer.className = 'jp-llm-ext-history-container';
        this.historyContainer.style.display = 'none'; // Initially hidden
        container.appendChild(this.historyContainer);
        // Create input area
        const inputArea = document.createElement('div');
        inputArea.className = 'jp-llm-ext-input-area';
        // Configure input container and field
        this.inputContainer.className = 'jp-llm-ext-input-container';
        this.inputField.className = 'jp-llm-ext-input-field';
        this.inputField.placeholder = 'Type your message here...';
        this.inputContainer.appendChild(this.inputField);
        inputArea.appendChild(this.inputContainer);
        // Add controls container
        inputArea.appendChild(this.createControlsContainer());
        container.appendChild(inputArea);
        return container;
    }
    /**
     * Creates the controls container with toggles and action buttons.
     * Includes the Markdown toggle, expand input button, settings button, and popup menu button.
     * @returns The controls container element.
     */
    createControlsContainer() {
        const controlsContainer = document.createElement('div');
        controlsContainer.className = 'jp-llm-ext-controls-container';
        // Create toggle buttons container
        const togglesContainer = document.createElement('div');
        togglesContainer.className = 'jp-llm-ext-toggles-container';
        // Add Markdown toggle button
        const markdownToggle = this.createButton('MD', 'Toggle Markdown mode');
        markdownToggle.addEventListener('click', () => {
            this.inputHandler.toggleMarkdownMode(markdownToggle);
        });
        togglesContainer.appendChild(markdownToggle);
        // Add expand input button
        const expandButton = this.createButton('\u25b2', 'Expand input field');
        expandButton.addEventListener('click', () => {
            this.inputHandler.toggleInputExpansion(expandButton);
        });
        togglesContainer.appendChild(expandButton);
        controlsContainer.appendChild(togglesContainer);
        // Create action buttons container
        const actionsContainer = document.createElement('div');
        actionsContainer.className = 'jp-llm-ext-actions-container';
        // Add history toggle button
        const historyButton = this.createButton('\ud83d\udcc3', 'Toggle chat history');
        historyButton.addEventListener('click', () => {
            this.toggleHistoryView();
        });
        actionsContainer.appendChild(historyButton);
        // Add settings button
        const settingsButton = this.createButton('\u2699\ufe0f', 'Settings');
        settingsButton.addEventListener('click', () => {
            this.settingsManager.showSettingsModal();
        });
        actionsContainer.appendChild(settingsButton);
        // Add send button
        const sendButton = this.createButton('\u27a4', 'Send message');
        sendButton.addEventListener('click', this.handleSendMessage.bind(this));
        actionsContainer.appendChild(sendButton);
        // Add popup menu button ("@" button)
        const popupMenuButton = this.createButton('@', 'Insert context');
        popupMenuButton.addEventListener('click', (event) => {
            // Get button position
            const rect = popupMenuButton.getBoundingClientRect();
            // Show popup menu at button position
            this.popupMenuManager.showPopupMenu(rect.left, rect.bottom);
        });
        actionsContainer.appendChild(popupMenuButton);
        controlsContainer.appendChild(actionsContainer);
        return controlsContainer;
    }
    /**
     * Helper function to create a button with given text and tooltip.
     * @param text The text to display on the button.
     * @param tooltip The tooltip text to display on hover.
     * @returns The created button element.
     */
    createButton(text, tooltip) {
        const button = document.createElement('button');
        button.textContent = text;
        button.title = tooltip;
        return button;
    }
    /**
     * Toggles between chat view and history view.
     * Updates the UI to show either the chat messages or the chat history list.
     */
    toggleHistoryView() {
        this.isHistoryViewActive = !this.isHistoryViewActive;
        if (this.isHistoryViewActive) {
            // Show history view
            this.messageContainer.style.display = 'none';
            this.historyContainer.style.display = 'block';
            this.renderChatHistory();
        }
        else {
            // Show chat view
            this.messageContainer.style.display = 'block';
            this.historyContainer.style.display = 'none';
        }
    }
    /**
     * Renders the chat history in the history container.
     * Creates a list of chat history items and populates the history container.
     */
    renderChatHistory() {
        this.historyContainer.innerHTML = '';
        const chats = this.chatHistoryManager.getAllChats();
        // Create new chat button
        const newChatButton = document.createElement('div');
        newChatButton.className = 'jp-llm-ext-history-item jp-llm-ext-new-chat';
        newChatButton.textContent = '+ New Chat';
        newChatButton.addEventListener('click', () => {
            this.createNewChat();
            this.toggleHistoryView(); // Switch back to chat view
        });
        this.historyContainer.appendChild(newChatButton);
        if (chats.length === 0) {
            const emptyMessage = document.createElement('div');
            emptyMessage.className = 'jp-llm-ext-history-empty';
            emptyMessage.textContent = 'No chat history yet';
            this.historyContainer.appendChild(emptyMessage);
            return;
        }
        // Create a list item for each chat
        chats.forEach(chat => {
            const chatItem = document.createElement('div');
            chatItem.className = 'jp-llm-ext-history-item';
            if (chat.id === this.chatHistoryManager.getCurrentChatId()) {
                chatItem.classList.add('jp-llm-ext-history-item-active');
            }
            const chatTitle = document.createElement('div');
            chatTitle.className = 'jp-llm-ext-history-item-title';
            chatTitle.textContent = chat.title;
            chatItem.appendChild(chatTitle);
            const chatInfo = document.createElement('div');
            chatInfo.className = 'jp-llm-ext-history-item-info';
            chatInfo.textContent = `${chat.messages.length} messages`;
            chatItem.appendChild(chatInfo);
            chatItem.addEventListener('click', () => {
                this.loadChat(chat.id);
                this.toggleHistoryView(); // Switch back to chat view
            });
            this.historyContainer.appendChild(chatItem);
        });
    }
    /**
     * Creates a new chat session.
     * Generates a unique ID, creates a new chat item, adds it to history, and updates the UI.
     */
    createNewChat() {
        // Create new chat using the manager
        this.chatHistoryManager.createNewChat();
        // Update UI
        this.updateCurrentChatTitle();
        this.messageRenderer.clearMessages();
        // Add welcome message
        this.addMessage('Welcome to the AI Chat Interface. How can I help you today?', 'bot', true, false // Don't save welcome message to history
        );
    }
    /**
     * Loads a chat from history.
     * Updates the UI to show the selected chat's messages and title.
     * @param chatId The ID of the chat to load.
     */
    loadChat(chatId) {
        const chat = this.chatHistoryManager.loadChat(chatId);
        if (chat) {
            // Update UI
            this.updateCurrentChatTitle();
            this.messageRenderer.renderMessages(chat.messages);
        }
    }
    /**
     * Updates the title of the current chat.
     * Updates the title input field with the new title.
     */
    updateCurrentChatTitle() {
        const chat = this.chatHistoryManager.getCurrentChat();
        if (chat) {
            this.titleInput.value = chat.title;
        }
    }
    /**
     * Handles sending a message from the input field.
     * Sends the message to the API, updates the UI with the response, and saves the message to chat history.
     */
    handleSendMessage() {
        const message = this.inputHandler.getInputText().trim();
        if (!message)
            return;
        // Add user message to UI
        this.addMessage(message, 'user', false);
        // Clear input field
        this.inputHandler.clearInput();
        // Add temporary "thinking" message
        const thinkingMessage = this.addMessage('Thinking...', 'bot', false, false);
        // Send message to API (mock implementation for now)
        this.mockSendMessage(message)
            .then((response) => {
            // Remove thinking message
            if (thinkingMessage && thinkingMessage.parentNode) {
                thinkingMessage.parentNode.removeChild(thinkingMessage);
            }
            // Add bot response
            this.addMessage(response, 'bot', true);
        })
            .catch((error) => {
            console.error('Error sending message:', error);
            // Remove thinking message
            if (thinkingMessage && thinkingMessage.parentNode) {
                thinkingMessage.parentNode.removeChild(thinkingMessage);
            }
            // Add error message
            this.addMessage('Sorry, there was an error processing your request. Please try again.', 'bot', false);
        });
    }
    /**
     * Mock implementation of sending a message to the API
     * @param message The message to send
     * @returns A promise that resolves to the response
     */
    mockSendMessage(message) {
        return new Promise((resolve) => {
            // Simulate a delay
            setTimeout(() => {
                resolve(`I received your message: "${message}". This is a mock response.`);
            }, 1000);
        });
    }
    /**
     * Adds a message to the chat interface.
     * Creates a new message element and appends it to the message container.
     * @param text The text content of the message.
     * @param sender The sender of the message ('user' or 'bot').
     * @param isMarkdown Whether the message is in Markdown format.
     * @param saveToHistory Whether to save the message to chat history.
     * @returns The created message element.
     */
    addMessage(text, sender, isMarkdown = false, saveToHistory = true) {
        // Save to chat history if needed
        if (saveToHistory) {
            this.chatHistoryManager.addMessage(text, sender, isMarkdown);
        }
        // Render the message
        return this.messageRenderer.renderMessage(text, sender, isMarkdown);
    }
    /**
     * Copies message content to clipboard.
     * @param text The text content to copy.
     */
    copyMessageToClipboard(text) {
        try {
            navigator.clipboard.writeText(text)
                .then(() => {
                console.log('Text copied to clipboard');
            })
                .catch(err => {
                console.error('Failed to copy text: ', err);
                this.fallbackCopyToClipboard(text);
            });
        }
        catch (error) {
            console.error('Copy to clipboard error:', error);
            this.fallbackCopyToClipboard(text);
        }
    }
    /**
     * Fallback method for copying to clipboard using a temporary textarea element.
     * @param text The text to copy.
     */
    fallbackCopyToClipboard(text) {
        try {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            document.execCommand('copy');
            document.body.removeChild(textArea);
            console.log('Fallback: Text copied to clipboard');
        }
        catch (error) {
            console.error('Fallback: Could not copy text: ', error);
        }
    }
    /**
     * Adds message content to the current cell.
     * @param text The text content to add.
     */
    addMessageToCell(text) {
        var _a;
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell) {
            console.error('No active cell found');
            return;
        }
        try {
            // Get current content and cursor position
            const editor = cell.editor;
            if (!editor) {
                console.error('No editor found in cell');
                return;
            }
            const position = editor.getCursorPosition();
            const currentText = editor.model.sharedModel.getSource();
            // Insert text at cursor position
            const beforeCursor = currentText.substring(0, position.column);
            const afterCursor = currentText.substring(position.column);
            // Determine if we need to add newlines
            const needsLeadingNewline = beforeCursor.length > 0 && !beforeCursor.endsWith('\n');
            const needsTrailingNewline = afterCursor.length > 0 && !afterCursor.startsWith('\n');
            let insertText = '';
            if (needsLeadingNewline)
                insertText += '\n';
            insertText += text;
            if (needsTrailingNewline)
                insertText += '\n';
            // Set the new text
            editor.model.sharedModel.setSource(beforeCursor + insertText + afterCursor);
        }
        catch (error) {
            console.error('Error adding text to cell:', error);
        }
    }
    /**
     * Appends text to the input field with proper spacing.
     * @param text The text to append.
     */
    appendToInput(text) {
        this.inputHandler.appendToInput(text);
    }
    /**
     * Gets the selected text from cell context.
     * @returns The selected text or an empty string if no selection.
     */
    getSelectedText() {
        var _a;
        // Get the current active cell from the tracker
        const cell = (_a = globals_1.globals.notebookTracker) === null || _a === void 0 ? void 0 : _a.activeCell;
        if (!cell)
            return '';
        // Get the selected text from the editor
        const editor = cell.editor;
        if (!editor)
            return '';
        const selection = editor.getSelection();
        if (!selection)
            return '';
        // Extract the selected text
        const { start, end } = selection;
        const text = editor.model.sharedModel.getSource();
        const lines = text.split('\n');
        // If selection is within a single line
        if (start.line === end.line) {
            return lines[start.line].substring(start.column, end.column);
        }
        // If selection spans multiple lines
        let selectedText = lines[start.line].substring(start.column) + '\n';
        for (let i = start.line + 1; i < end.line; i++) {
            selectedText += lines[i] + '\n';
        }
        selectedText += lines[end.line].substring(0, end.column);
        return selectedText;
    }
    /**
     * Handles the code command - inserts selected code.
     */
    handleCodeCommand() {
        const selectedText = this.getSelectedText();
        if (selectedText) {
            this.appendToInput(selectedText);
        }
        else {
            console.log('No code selected');
        }
    }
}
exports.SimpleSidebarWidget = SimpleSidebarWidget;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/commands.js":
/*!***************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/commands.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.registerCommands = registerCommands;
const icons_1 = __webpack_require__(/*! ./icons */ "./node_modules/jupyter-simple-extension/lib/icons.js");
/**
 * Registers commands for the extension
 */
function registerCommands(app, palette, launcher, sidebarWidget) {
    // Add command to toggle the sidebar
    app.commands.addCommand('simple-extension:toggle-sidebar', {
        label: 'Toggle AI Assistant Sidebar',
        icon: icons_1.extensionIcon,
        execute: () => {
            if (sidebarWidget.isAttached) {
                sidebarWidget.parent = null;
            }
            else {
                app.shell.add(sidebarWidget, 'left', { rank: 9999 });
            }
        }
    });
    // Add the command to the command palette
    palette.addItem({
        command: 'simple-extension:toggle-sidebar',
        category: 'Extension'
    });
    // Add a launcher item
    launcher.add({
        command: 'simple-extension:toggle-sidebar',
        category: 'Other',
        rank: 9999
    });
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/globals.js":
/*!**************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/globals.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.globals = void 0;
exports.initGlobals = initGlobals;
/**
 * Global references to key components in the application
 */
exports.globals = {};
/**
 * Initialize global references
 */
function initGlobals(app, notebookTracker) {
    exports.globals.app = app;
    exports.globals.notebookTracker = notebookTracker;
}


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/icons.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/icons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.extensionIcon = void 0;
const ui_components_1 = __webpack_require__(/*! @jupyterlab/ui-components */ "webpack/sharing/consume/default/@jupyterlab/ui-components/@jupyterlab/ui-components");
// ===============================
// Icon Definition
// ===============================
const iconSvgStr = '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-chat-left-text" viewBox="0 0 16 16">' +
    '<path d="M14 1a1 1 0 0 1 1 1v8a1 1 0 0 1-1 1H4.414A2 2 0 0 0 3 11.586l-2 2V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12.793a.5.5 0 0 0 .854.353l2.853-2.853A1 1 0 0 1 4.414 12H14a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"/>' +
    '<path d="M3 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5zM3 6a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9A.5.5 0 0 1 3 6zm0 2.5a.5.5 0 0 1 .5-.5h5a.5.5 0 0 1 0 1h-5a.5.5 0 0 1-.5-.5z"/>' +
    '</svg>';
/**
 * Icon for the AI Assistant extension
 */
exports.extensionIcon = new ui_components_1.LabIcon({
    name: 'simple:icon',
    svgstr: iconSvgStr
});


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/index.js":
/*!************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/index.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApiClient = void 0;
const launcher_1 = __webpack_require__(/*! @jupyterlab/launcher */ "webpack/sharing/consume/default/@jupyterlab/launcher/@jupyterlab/launcher");
const apputils_1 = __webpack_require__(/*! @jupyterlab/apputils */ "webpack/sharing/consume/default/@jupyterlab/apputils/@jupyterlab/apputils");
const notebook_1 = __webpack_require__(/*! @jupyterlab/notebook */ "webpack/sharing/consume/default/@jupyterlab/notebook/@jupyterlab/notebook");
const docmanager_1 = __webpack_require__(/*! @jupyterlab/docmanager */ "webpack/sharing/consume/default/@jupyterlab/docmanager/@jupyterlab/docmanager");
// Import the modularized SimpleSidebarWidget from the new location
const sidebar_widget_1 = __webpack_require__(/*! ./chat/sidebar-widget */ "./node_modules/jupyter-simple-extension/lib/chat/sidebar-widget.js");
const globals_1 = __webpack_require__(/*! ./globals */ "./node_modules/jupyter-simple-extension/lib/globals.js");
const commands_1 = __webpack_require__(/*! ./commands */ "./node_modules/jupyter-simple-extension/lib/commands.js");
const cell_context_tracker_1 = __webpack_require__(/*! ./cell-context-tracker */ "./node_modules/jupyter-simple-extension/lib/cell-context-tracker.js");
// Export ApiClient for use by other components
var api_client_1 = __webpack_require__(/*! ./api-client */ "./node_modules/jupyter-simple-extension/lib/api-client.js");
Object.defineProperty(exports, "ApiClient", ({ enumerable: true, get: function () { return api_client_1.ApiClient; } }));
/**
 * Initialization data for the jupyter-simple-extension extension.
 * This plugin integrates a custom sidebar with JupyterLab for enhanced functionality.
 */
const plugin = {
    id: 'jupyter-simple-extension:plugin',
    autoStart: true,
    requires: [launcher_1.ILauncher, apputils_1.ICommandPalette, notebook_1.INotebookTracker, docmanager_1.IDocumentManager],
    activate: (jupyterApp, launcher, palette, tracker, docManager) => {
        console.log('JupyterLab extension jupyter-simple-extension is activated!');
        // Initialize global references for app and notebook tracking
        (0, globals_1.initGlobals)(jupyterApp, tracker);
        // Initialize cell context tracker to monitor active cells and contexts
        globals_1.globals.cellContextTracker = new cell_context_tracker_1.CellContextTracker(jupyterApp, tracker);
        // Create and add sidebar widget for user interaction and context insertion
        const sidebarWidget = new sidebar_widget_1.SimpleSidebarWidget(docManager);
        jupyterApp.shell.add(sidebarWidget, 'left', { rank: 9999 });
        // Register commands for interacting with the extension via command palette and launcher
        (0, commands_1.registerCommands)(jupyterApp, palette, launcher, sidebarWidget);
    }
};
exports["default"] = plugin;


/***/ }),

/***/ "./node_modules/jupyter-simple-extension/lib/markdown-config.js":
/*!**********************************************************************!*\
  !*** ./node_modules/jupyter-simple-extension/lib/markdown-config.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.configureMarked = configureMarked;
exports.preprocessMarkdown = preprocessMarkdown;
const marked_1 = __webpack_require__(/*! marked */ "webpack/sharing/consume/default/marked/marked");
/**
 * Configure marked with better rendering options for code blocks
 */
function configureMarked() {
    // Configure marked options
    marked_1.marked.setOptions({
        gfm: true, // Enable GitHub Flavored Markdown
        breaks: true, // Add <br> on single line breaks
        pedantic: false, // Conform to original markdown spec
        async: false, // Disable async rendering
        silent: false // Enable error reporting
    });
}
/**
 * Pre-process markdown text to fix common issues with streaming content
 */
function preprocessMarkdown(text) {
    // Handle code blocks first
    let inCodeBlock = false;
    const lines = text.split('\n');
    const processedLines = lines.map((line, i) => {
        // Check for code block markers
        if (line.trim().startsWith('```')) {
            inCodeBlock = !inCodeBlock;
            // Preserve language specification
            return line.trim();
        }
        // If we're in a code block, preserve the line as is
        if (inCodeBlock) {
            return line;
        }
        // Outside code blocks, handle list items
        return line.replace(/([^\n\s])-\s/g, '$1\n- ');
    });
    return processedLines.join('\n');
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uX2xpYl9pbmRleF9qcy4yYmZiMGI0NTk3ODAxYmMwOGUzMS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxhQUFhO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0EsOENBQThDLG9CQUFvQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMEJBQTBCO0FBQ2xEO0FBQ0E7QUFDQSwwREFBMEQsZUFBZTtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsYUFBYTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOzs7Ozs7Ozs7OztBQ3JFSjtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCOzs7Ozs7Ozs7OztBQzdJYjtBQUNiO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixXQUFXO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw0QkFBNEI7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHNCQUFzQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUMsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsUUFBUTtBQUM3RCxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNB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QkFBMEI7QUFDMUIsaUJBQWlCLG1CQUFPLENBQUMsNkRBQVE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2FwaS1jbGllbnQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY2VsbC1jb250ZXh0LXRyYWNrZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY2hhdC9jaGF0LWhpc3RvcnktbWFuYWdlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jaGF0L2ZpbGUtYnJvd3Nlci1tYW5hZ2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NoYXQvaW5wdXQtaGFuZGxlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9jaGF0L21lc3NhZ2UtcmVuZGVyZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY2hhdC9wb3B1cC1tZW51LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY2hhdC9zZXR0aW5ncy1tYW5hZ2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9qdXB5dGVyLXNpbXBsZS1leHRlbnNpb24vbGliL2NoYXQvc2lkZWJhci13aWRnZXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvY29tbWFuZHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2p1cHl0ZXItc2ltcGxlLWV4dGVuc2lvbi9saWIvZ2xvYmFscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9pY29ucy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uL2xpYi9tYXJrZG93bi1jb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFwaUNsaWVudCA9IHZvaWQgMDtcbi8qKlxuICogQVBJIGNsaWVudCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgYmFja2VuZCBMTE0gc2VydmljZVxuICovXG5jbGFzcyBBcGlDbGllbnQge1xuICAgIGNvbnN0cnVjdG9yKGJhc2VVcmwgPSAnaHR0cDovL2xvY2FsaG9zdDo4MDAwJykge1xuICAgICAgICB0aGlzLmJhc2VVcmwgPSBiYXNlVXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdHJlYW0gYSBjaGF0IHJlc3BvbnNlIGZyb20gdGhlIG1vY2sgTExNXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIHVzZXIgbWVzc2FnZSB0byBzZW5kXG4gICAgICogQHBhcmFtIGNvbnRleHQgT3B0aW9uYWwgY29udGV4dCBpbmZvcm1hdGlvblxuICAgICAqIEBwYXJhbSBvbkNodW5rIENhbGxiYWNrIGZvciBlYWNoIHRleHQgY2h1bmsgcmVjZWl2ZWRcbiAgICAgKiBAcGFyYW0gb25Db21wbGV0ZSBDYWxsYmFjayB3aGVuIHN0cmVhbWluZyBpcyBjb21wbGV0ZVxuICAgICAqIEBwYXJhbSBvbkVycm9yIENhbGxiYWNrIGZvciBlcnJvcnNcbiAgICAgKi9cbiAgICBhc3luYyBzdHJlYW1DaGF0KG1lc3NhZ2UsIGNvbnRleHQgPSBudWxsLCBvbkNodW5rLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vY2hhdGAsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHRcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBUEkgZXJyb3I6ICR7cmVzcG9uc2Uuc3RhdHVzVGV4dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVhZGFibGVTdHJlYW0gbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXIuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgdXAgc3RyZWFtIHJlYWRpbmdcbiAgICAgICAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgd2hpbGUgKCFkb25lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZTogcmVhZGVyRG9uZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICAgICAgICBkb25lID0gcmVhZGVyRG9uZTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2h1bmsgPSBkZWNvZGVyLmRlY29kZSh2YWx1ZSwgeyBzdHJlYW06ICFkb25lIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkNodW5rKGNodW5rKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvbkVycm9yKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihTdHJpbmcoZXJyb3IpKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2ltcGxlIGhlYWx0aCBjaGVjayBmb3IgdGhlIEFQSVxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRydWUgaWYgdGhlIEFQSSBpcyBoZWFsdGh5XG4gICAgICovXG4gICAgYXN5bmMgaGVhbHRoQ2hlY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke3RoaXMuYmFzZVVybH0vaGVhbHRoYCk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2Uub2s7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBUEkgaGVhbHRoIGNoZWNrIGZhaWxlZDonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkFwaUNsaWVudCA9IEFwaUNsaWVudDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DZWxsQ29udGV4dFRyYWNrZXIgPSB2b2lkIDA7XG4vKipcbiAqIFRyYWNrcyBjZWxsIGNvbnRleHQgYW5kIGN1cnNvciBwb3NpdGlvbiB3aXRoaW4gSnVweXRlciBub3RlYm9va3NcbiAqL1xuY2xhc3MgQ2VsbENvbnRleHRUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcihhcHAsIG5vdGVib29rVHJhY2tlcikge1xuICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGVkaXRvciBldmVudHMgKGtleWRvd24sIG1vdXNldXApXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZUVkaXRvckV2ZW50ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgY3VycmVudCBhY3RpdmUgY2VsbCBmcm9tIHRoZSB0cmFja2VyXG4gICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGw7XG4gICAgICAgICAgICAgICAgaWYgKCFjZWxsIHx8ICFjZWxsLmVkaXRvcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIC8vIEZpbmQgdGhlIGlubmVyIEVkaXRvclZpZXcgaW5zdGFuY2VcbiAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBjZWxsLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZWRpdG9yLmVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoIXZpZXcpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAvLyBHZXQgYW5kIHN0b3JlIHRoZSBjdXJzb3IgY29udGV4dFxuICAgICAgICAgICAgICAgIHRoaXMubGFzdENlbGxDb250ZXh0ID0gdGhpcy5nZXRDbUNvbnRleHQodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3IgaW4gZWRpdG9yIGV2ZW50IGhhbmRsZXI6XCIsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG4gICAgICAgIHRoaXMuc2V0dXBUcmFja2VycygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoaXMgb2JqZWN0IGhhcyBiZWVuIGRpc3Bvc2VkXG4gICAgICovXG4gICAgZ2V0IGlzRGlzcG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0Rpc3Bvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGFsbCB0aGUgbmVjZXNzYXJ5IGV2ZW50IHRyYWNrZXJzXG4gICAgICovXG4gICAgc2V0dXBUcmFja2VycygpIHtcbiAgICAgICAgLy8gSGFuZGxlIGFjdGl2ZSBjZWxsIGNoYW5nZXNcbiAgICAgICAgdGhpcy5ub3RlYm9va1RyYWNrZXIuYWN0aXZlQ2VsbENoYW5nZWQuY29ubmVjdCh0aGlzLnNldHVwQ2VsbExpc3RlbmVycywgdGhpcyk7XG4gICAgICAgIC8vIEhhbmRsZSBub3RlYm9vayBjaGFuZ2VzXG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmN1cnJlbnRDaGFuZ2VkLmNvbm5lY3QodGhpcy5oYW5kbGVOb3RlYm9va0NoYW5nZSwgdGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgbm90ZWJvb2sgY2hhbmdlc1xuICAgICAqL1xuICAgIGhhbmRsZU5vdGVib29rQ2hhbmdlKHRyYWNrZXIsIHBhbmVsKSB7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIGlmIChwYW5lbCAmJiBwYW5lbC5jb250ZW50KSB7XG4gICAgICAgICAgICBjb25zdCBjZWxsID0gcGFuZWwuY29udGVudC5hY3RpdmVDZWxsO1xuICAgICAgICAgICAgdGhpcy5zZXR1cENlbGxMaXN0ZW5lcnModHJhY2tlciwgY2VsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMgb24gdGhlIGFjdGl2ZSBjZWxsXG4gICAgICovXG4gICAgc2V0dXBDZWxsTGlzdGVuZXJzKF90cmFja2VyLCBjZWxsKSB7XG4gICAgICAgIGlmICghY2VsbClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5jbGVhbnVwUHJldmlvdXNMaXN0ZW5lcnMoKTtcbiAgICAgICAgaWYgKGNlbGwuZWRpdG9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNlbGxOb2RlID0gY2VsbC5ub2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvck5vZGUgPSBjZWxsTm9kZS5xdWVyeVNlbGVjdG9yKCcuanAtRWRpdG9yJykgfHxcbiAgICAgICAgICAgICAgICAgICAgY2VsbE5vZGUucXVlcnlTZWxlY3RvcignLmpwLUlucHV0QXJlYS1lZGl0b3InKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gZWRpdG9yTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGV2ZW50IGxpc3RlbmVycyBmb3Iga2V5IGFuZCBtb3VzZSBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgZWRpdG9yTm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRvck5vZGUuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdG8gY2FwdHVyZSBpbW1lZGlhdGUgY29udGV4dCBpZiBFZGl0b3JWaWV3IGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gY2VsbC5lZGl0b3IuZWRpdG9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAodmlldykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0Q2VsbENvbnRleHQgPSB0aGlzLmdldENtQ29udGV4dCh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBzZXR0aW5nIHVwIGNlbGwgbGlzdGVuZXJzOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBwcmV2aW91cyBhY3RpdmUgY2VsbFxuICAgICAqL1xuICAgIGNsZWFudXBQcmV2aW91c0xpc3RlbmVycygpIHtcbiAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2VsbEVkaXRvck5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlRWRpdG9yRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVDZWxsRWRpdG9yTm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5oYW5kbGVFZGl0b3JFdmVudCk7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZUNlbGxFZGl0b3JOb2RlID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGNvbnRleHQgaW5mb3JtYXRpb24gZnJvbSBDb2RlTWlycm9yIEVkaXRvclZpZXdcbiAgICAgKi9cbiAgICBnZXRDbUNvbnRleHQodmlldykge1xuICAgICAgICBjb25zdCBzdGF0ZSA9IHZpZXcuc3RhdGU7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHN0YXRlLnNlbGVjdGlvbi5tYWluLmhlYWQ7XG4gICAgICAgIGNvbnN0IGZ1bGxUZXh0ID0gc3RhdGUuZG9jLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxpbmUgPSBzdGF0ZS5kb2MubGluZUF0KG9mZnNldCk7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgbGluZTogbGluZS5udW1iZXIgLSAxLFxuICAgICAgICAgICAgY29sdW1uOiBvZmZzZXQgLSBsaW5lLmZyb20sXG4gICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjb250ZXh0UmFkaXVzID0gMTAwO1xuICAgICAgICBjb25zdCBzdGFydCA9IE1hdGgubWF4KDAsIG9mZnNldCAtIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICBjb25zdCBlbmQgPSBNYXRoLm1pbihmdWxsVGV4dC5sZW5ndGgsIG9mZnNldCArIGNvbnRleHRSYWRpdXMpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGV4dDogZnVsbFRleHQsXG4gICAgICAgICAgICBwb3NpdGlvbjogcG9zaXRpb24sXG4gICAgICAgICAgICBjb250ZXh0QmVmb3JlOiBmdWxsVGV4dC5zdWJzdHJpbmcoc3RhcnQsIG9mZnNldCksXG4gICAgICAgICAgICBjb250ZXh0QWZ0ZXI6IGZ1bGxUZXh0LnN1YnN0cmluZyhvZmZzZXQsIGVuZClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgY3VycmVudCBjZWxsIGNvbnRleHRcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2VsbENvbnRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RDZWxsQ29udGV4dDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzcG9zZXMgYWxsIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuY2xlYW51cFByZXZpb3VzTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMubm90ZWJvb2tUcmFja2VyLmFjdGl2ZUNlbGxDaGFuZ2VkLmRpc2Nvbm5lY3QodGhpcy5zZXR1cENlbGxMaXN0ZW5lcnMsIHRoaXMpO1xuICAgICAgICB0aGlzLm5vdGVib29rVHJhY2tlci5jdXJyZW50Q2hhbmdlZC5kaXNjb25uZWN0KHRoaXMuaGFuZGxlTm90ZWJvb2tDaGFuZ2UsIHRoaXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2VsbENvbnRleHRUcmFja2VyID0gQ2VsbENvbnRleHRUcmFja2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIE1hbmFnZXMgY2hhdCBoaXN0b3J5IGZ1bmN0aW9uYWxpdHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaGF0SGlzdG9yeU1hbmFnZXIgPSB2b2lkIDA7XG4vKipcbiAqIE1hbmFnZXMgY2hhdCBoaXN0b3J5IHN0b3JhZ2UsIHJldHJpZXZhbCwgYW5kIG1hbmlwdWxhdGlvblxuICovXG5jbGFzcyBDaGF0SGlzdG9yeU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5ID0gW107XG4gICAgICAgIHRoaXMuY3VycmVudENoYXRJZCA9ICcnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGNoYXQgc2Vzc2lvblxuICAgICAqIEByZXR1cm5zIFRoZSBJRCBvZiB0aGUgbmV3bHkgY3JlYXRlZCBjaGF0XG4gICAgICovXG4gICAgY3JlYXRlTmV3Q2hhdCgpIHtcbiAgICAgICAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHRoZSBjaGF0XG4gICAgICAgIGNvbnN0IGNoYXRJZCA9IGBjaGF0LSR7RGF0ZS5ub3coKX1gO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgY2hhdCBpdGVtXG4gICAgICAgIGNvbnN0IG5ld0NoYXQgPSB7XG4gICAgICAgICAgICBpZDogY2hhdElkLFxuICAgICAgICAgICAgdGl0bGU6IGBDaGF0ICR7dGhpcy5jaGF0SGlzdG9yeS5sZW5ndGggKyAxfWAsXG4gICAgICAgICAgICBtZXNzYWdlczogW11cbiAgICAgICAgfTtcbiAgICAgICAgLy8gQWRkIHRvIGhpc3RvcnkgYW5kIHNldCBhcyBjdXJyZW50XG4gICAgICAgIHRoaXMuY2hhdEhpc3RvcnkucHVzaChuZXdDaGF0KTtcbiAgICAgICAgdGhpcy5jdXJyZW50Q2hhdElkID0gY2hhdElkO1xuICAgICAgICByZXR1cm4gY2hhdElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbWVzc2FnZSB0byB0aGUgY3VycmVudCBjaGF0XG4gICAgICogQHBhcmFtIHRleHQgTWVzc2FnZSB0ZXh0XG4gICAgICogQHBhcmFtIHNlbmRlciBNZXNzYWdlIHNlbmRlclxuICAgICAqIEBwYXJhbSBpc01hcmtkb3duIFdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgaW4gbWFya2Rvd24gZm9ybWF0XG4gICAgICovXG4gICAgYWRkTWVzc2FnZSh0ZXh0LCBzZW5kZXIsIGlzTWFya2Rvd24gPSBmYWxzZSkge1xuICAgICAgICBjb25zdCBjaGF0ID0gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICAgICAgaWYgKGNoYXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgdGV4dCxcbiAgICAgICAgICAgICAgICBzZW5kZXIsXG4gICAgICAgICAgICAgICAgaXNNYXJrZG93blxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNoYXQubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGNoYXRcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBjaGF0IG9yIHVuZGVmaW5lZCBpZiBub25lIGV4aXN0c1xuICAgICAqL1xuICAgIGdldEN1cnJlbnRDaGF0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGF0SGlzdG9yeS5maW5kKGMgPT4gYy5pZCA9PT0gdGhpcy5jdXJyZW50Q2hhdElkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgY2hhdCBoaXN0b3J5XG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgYWxsIGNoYXQgaGlzdG9yeSBpdGVtc1xuICAgICAqL1xuICAgIGdldEFsbENoYXRzKCkge1xuICAgICAgICByZXR1cm4gWy4uLnRoaXMuY2hhdEhpc3RvcnldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGNoYXQgYnkgSURcbiAgICAgKiBAcGFyYW0gY2hhdElkIFRoZSBJRCBvZiB0aGUgY2hhdCB0byBsb2FkXG4gICAgICogQHJldHVybnMgVGhlIGxvYWRlZCBjaGF0IG9yIHVuZGVmaW5lZCBpZiBub3QgZm91bmRcbiAgICAgKi9cbiAgICBsb2FkQ2hhdChjaGF0SWQpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnkuZmluZChjID0+IGMuaWQgPT09IGNoYXRJZCk7XG4gICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRDaGF0SWQgPSBjaGF0SWQ7XG4gICAgICAgICAgICByZXR1cm4gY2hhdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBvZiB0aGUgY3VycmVudCBjaGF0XG4gICAgICogQHBhcmFtIHRpdGxlIFRoZSBuZXcgdGl0bGVcbiAgICAgKi9cbiAgICB1cGRhdGVDdXJyZW50Q2hhdFRpdGxlKHRpdGxlKSB7XG4gICAgICAgIGNvbnN0IGNoYXQgPSB0aGlzLmNoYXRIaXN0b3J5LmZpbmQoYyA9PiBjLmlkID09PSB0aGlzLmN1cnJlbnRDaGF0SWQpO1xuICAgICAgICBpZiAoY2hhdCkge1xuICAgICAgICAgICAgY2hhdC50aXRsZSA9IHRpdGxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgY2hhdCBJRFxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGNoYXQgSURcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50Q2hhdElkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50Q2hhdElkO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hhdEhpc3RvcnlNYW5hZ2VyID0gQ2hhdEhpc3RvcnlNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIE1hbmFnZXMgZmlsZSBhbmQgZGlyZWN0b3J5IGJyb3dzaW5nIGZ1bmN0aW9uYWxpdHlcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlQnJvd3Nlck1hbmFnZXIgPSB2b2lkIDA7XG4vKipcbiAqIE1hbmFnZXMgZmlsZSBhbmQgZGlyZWN0b3J5IGJyb3dzaW5nIG9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgRmlsZUJyb3dzZXJNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihkb2NNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSAnJztcbiAgICAgICAgdGhpcy5kb2NNYW5hZ2VyID0gZG9jTWFuYWdlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdHMgdGhlIGNvbnRlbnRzIG9mIHRoZSBjdXJyZW50IGRpcmVjdG9yeVxuICAgICAqIEBwYXJhbSBmaWx0ZXJUeXBlIE9wdGlvbmFsIHBhcmFtZXRlciB0byBmaWx0ZXIgcmVzdWx0cyBieSB0eXBlICgnYWxsJywgJ2ZpbGUnLCBvciAnZGlyZWN0b3J5JylcbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgcmVzb2x2aW5nIHRvIGFuIGFycmF5IG9mIGl0ZW0gbmFtZXMgb3IgbnVsbCBvbiBlcnJvclxuICAgICAqL1xuICAgIGFzeW5jIGxpc3RDdXJyZW50RGlyZWN0b3J5Q29udGVudHMoZmlsdGVyVHlwZSA9ICdhbGwnKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdMSVNUIERJUjogU3RhcnRpbmcgZGlyZWN0b3J5IGxpc3RpbmcgcHJvY2Vzcy4uLicsIHsgZmlsdGVyVHlwZSB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB3ZSBoYXZlIGEgY3VycmVudCBwYXRoXG4gICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudFBhdGgpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnNldEN1cnJlbnREaXJlY3RvcnlQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IEN1cnJlbnQgcGF0aDonLCB0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgICAgIC8vIEdldCBkaXJlY3RvcnkgY29udGVudHMgdXNpbmcgdGhlIGRvY3VtZW50IG1hbmFnZXJcbiAgICAgICAgICAgIGNvbnN0IGRpckNvbnRlbnRzID0gYXdhaXQgdGhpcy5kb2NNYW5hZ2VyLnNlcnZpY2VzLmNvbnRlbnRzLmdldCh0aGlzLmN1cnJlbnRQYXRoLCB7IGNvbnRlbnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBpZiAoIWRpckNvbnRlbnRzKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTElTVCBESVI6IEZhaWxlZCB0byBnZXQgZGlyZWN0b3J5IGNvbnRlbnRzJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTElTVCBESVI6IEdvdCBkaXJlY3RvcnkgY29udGVudHM6JywgZGlyQ29udGVudHMpO1xuICAgICAgICAgICAgLy8gRmlsdGVyIGNvbnRlbnRzIGJhc2VkIG9uIGZpbHRlclR5cGVcbiAgICAgICAgICAgIGxldCBmaWx0ZXJlZENvbnRlbnRzID0gZGlyQ29udGVudHMuY29udGVudCB8fCBbXTtcbiAgICAgICAgICAgIGlmIChmaWx0ZXJUeXBlID09PSAnZmlsZScpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvbnRlbnRzID0gZmlsdGVyZWRDb250ZW50cy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udHlwZSAhPT0gJ2RpcmVjdG9yeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsdGVyVHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICBmaWx0ZXJlZENvbnRlbnRzID0gZmlsdGVyZWRDb250ZW50cy5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0udHlwZSA9PT0gJ2RpcmVjdG9yeScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU29ydCBkaXJlY3RvcmllcyBmaXJzdCwgdGhlbiBmaWxlc1xuICAgICAgICAgICAgZmlsdGVyZWRDb250ZW50cy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGEudHlwZSA9PT0gJ2RpcmVjdG9yeScgJiYgYi50eXBlICE9PSAnZGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhLnR5cGUgIT09ICdkaXJlY3RvcnknICYmIGIudHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhLm5hbWUubG9jYWxlQ29tcGFyZShiLm5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBFeHRyYWN0IG5hbWVzXG4gICAgICAgICAgICBjb25zdCBuYW1lcyA9IGZpbHRlcmVkQ29udGVudHMubWFwKChpdGVtKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gJ2RpcmVjdG9yeScpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXHVkODNkXFx1ZGNjMSAke2l0ZW0ubmFtZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGBcXHVkODNkXFx1ZGNjNCAke2l0ZW0ubmFtZX1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ0xJU1QgRElSOiBGaWx0ZXJlZCBhbmQgc29ydGVkIG5hbWVzOicsIG5hbWVzKTtcbiAgICAgICAgICAgIHJldHVybiBuYW1lcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0xJU1QgRElSOiBFcnJvciBsaXN0aW5nIGRpcmVjdG9yeSBjb250ZW50czonLCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjdXJyZW50IGRpcmVjdG9yeSBwYXRoIGJhc2VkIG9uIGNvbnRleHRcbiAgICAgKi9cbiAgICBhc3luYyBzZXRDdXJyZW50RGlyZWN0b3J5UGF0aCgpIHtcbiAgICAgICAgLy8gSWYgd2UgYWxyZWFkeSBoYXZlIGEgcGF0aCwga2VlcCB1c2luZyBpdFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBKdXN0IHVzZSBlbXB0eSBwYXRoIGZvciBub3cgYXMgYSBmYWxsYmFja1xuICAgICAgICAgICAgLy8gSW4gYSByZWFsIGltcGxlbWVudGF0aW9uLCB3ZSB3b3VsZCB0cnkgdG8gZ2V0IHRoZSBjdXJyZW50IGRpcmVjdG9yeSBmcm9tIHRoZSBkb2N1bWVudCBtYW5hZ2VyXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gJyc7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRElSIFBBVEg6IFVzaW5nIGVtcHR5IHBhdGggYXMgZmFsbGJhY2snKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0RJUiBQQVRIOiBFcnJvciBzZXR0aW5nIGRpcmVjdG9yeSBwYXRoOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSAnJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBOYXZpZ2F0ZXMgdG8gYSBzdWJkaXJlY3RvcnlcbiAgICAgKiBAcGFyYW0gZGlyTmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ViZGlyZWN0b3J5IHRvIG5hdmlnYXRlIHRvXG4gICAgICovXG4gICAgbmF2aWdhdGVUb1N1YmRpcmVjdG9yeShkaXJOYW1lKSB7XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgZm9sZGVyIGVtb2ppIGlmIHByZXNlbnRcbiAgICAgICAgY29uc3QgY2xlYW5EaXJOYW1lID0gZGlyTmFtZS5yZXBsYWNlKCdcXHVkODNkXFx1ZGNjMSAnLCAnJyk7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgY3VycmVudCBwYXRoXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gYCR7dGhpcy5jdXJyZW50UGF0aH0vJHtjbGVhbkRpck5hbWV9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBjbGVhbkRpck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSB0aGlzLmN1cnJlbnRQYXRoLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbiAgICAgICAgY29uc29sZS5sb2coJ0RJUiBOQVY6IE5hdmlnYXRlZCB0bzonLCB0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTmF2aWdhdGVzIHRvIHRoZSBwYXJlbnQgZGlyZWN0b3J5XG4gICAgICogQHJldHVybnMgVHJ1ZSBpZiBuYXZpZ2F0aW9uIHdhcyBzdWNjZXNzZnVsLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBuYXZpZ2F0ZVRvUGFyZW50RGlyZWN0b3J5KCkge1xuICAgICAgICAvLyBDaGVjayBpZiB3ZSdyZSBhbHJlYWR5IGF0IHRoZSByb290XG4gICAgICAgIGlmICghdGhpcy5jdXJyZW50UGF0aCB8fCB0aGlzLmN1cnJlbnRQYXRoID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCB0aGUgcGFyZW50IHBhdGhcbiAgICAgICAgY29uc3QgcGFydHMgPSB0aGlzLmN1cnJlbnRQYXRoLnNwbGl0KCcvJyk7XG4gICAgICAgIHBhcnRzLnBvcCgpOyAvLyBSZW1vdmUgdGhlIGxhc3QgcGFydFxuICAgICAgICB0aGlzLmN1cnJlbnRQYXRoID0gcGFydHMuam9pbignLycpO1xuICAgICAgICBjb25zb2xlLmxvZygnRElSIE5BVjogTmF2aWdhdGVkIHRvIHBhcmVudDonLCB0aGlzLmN1cnJlbnRQYXRoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgZGlyZWN0b3J5IHBhdGhcbiAgICAgKiBAcmV0dXJucyBUaGUgY3VycmVudCBkaXJlY3RvcnkgcGF0aFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50UGF0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY3VycmVudCBkaXJlY3RvcnkgcGF0aFxuICAgICAqIEBwYXJhbSBwYXRoIFRoZSBuZXcgcGF0aCB0byBzZXRcbiAgICAgKi9cbiAgICBzZXRDdXJyZW50UGF0aChwYXRoKSB7XG4gICAgICAgIHRoaXMuY3VycmVudFBhdGggPSBwYXRoO1xuICAgIH1cbn1cbmV4cG9ydHMuRmlsZUJyb3dzZXJNYW5hZ2VyID0gRmlsZUJyb3dzZXJNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEhhbmRsZXMgaW5wdXQgZmllbGQgZnVuY3Rpb25hbGl0eVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLklucHV0SGFuZGxlciA9IHZvaWQgMDtcbi8qKlxuICogTWFuYWdlcyBpbnB1dCBmaWVsZCBiZWhhdmlvciBhbmQgaW50ZXJhY3Rpb25zXG4gKi9cbmNsYXNzIElucHV0SGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoaW5wdXRGaWVsZCwgX2lucHV0Q29udGFpbmVyLCAvLyBQcmVmaXggd2l0aCB1bmRlcnNjb3JlIHRvIGluZGljYXRlIGl0J3Mgbm90IHVzZWRcbiAgICBvblNlbmRNZXNzYWdlKSB7XG4gICAgICAgIHRoaXMuaXNJbnB1dEV4cGFuZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkID0gaW5wdXRGaWVsZDtcbiAgICAgICAgdGhpcy5vblNlbmRNZXNzYWdlID0gb25TZW5kTWVzc2FnZTtcbiAgICAgICAgLy8gU2V0IHVwIGlucHV0IGZpZWxkIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB0aGlzLnNldHVwSW5wdXRGaWVsZEV2ZW50cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycyBmb3IgdGhlIGlucHV0IGZpZWxkXG4gICAgICovXG4gICAgc2V0dXBJbnB1dEZpZWxkRXZlbnRzKCkge1xuICAgICAgICAvLyBIYW5kbGUgRW50ZXIga2V5IHRvIHNlbmQgbWVzc2FnZVxuICAgICAgICB0aGlzLmlucHV0RmllbGQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VudGVyJyAmJiAhZXZlbnQuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIHRoaXMub25TZW5kTWVzc2FnZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgZXhwYW5zaW9uIHN0YXRlIG9mIHRoZSBpbnB1dCBmaWVsZFxuICAgICAqIEBwYXJhbSBidXR0b24gVGhlIGJ1dHRvbiBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSB0b2dnbGVcbiAgICAgKi9cbiAgICB0b2dnbGVJbnB1dEV4cGFuc2lvbihidXR0b24pIHtcbiAgICAgICAgdGhpcy5pc0lucHV0RXhwYW5kZWQgPSAhdGhpcy5pc0lucHV0RXhwYW5kZWQ7XG4gICAgICAgIGlmICh0aGlzLmlzSW5wdXRFeHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnN0eWxlLmhlaWdodCA9ICcxNTBweCc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUucmVzaXplID0gJ3ZlcnRpY2FsJztcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICdcXHUyNWJjJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRGaWVsZC5zdHlsZS5oZWlnaHQgPSAnNTBweCc7XG4gICAgICAgICAgICB0aGlzLmlucHV0RmllbGQuc3R5bGUucmVzaXplID0gJ25vbmUnO1xuICAgICAgICAgICAgYnV0dG9uLnRleHRDb250ZW50ID0gJ1xcdTI1YjInO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRvZ2dsZXMgbWFya2Rvd24gbW9kZVxuICAgICAqIEBwYXJhbSBidXR0b24gVGhlIGJ1dHRvbiBlbGVtZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSB0b2dnbGVcbiAgICAgKi9cbiAgICB0b2dnbGVNYXJrZG93bk1vZGUoYnV0dG9uKSB7XG4gICAgICAgIHRoaXMuaXNNYXJrZG93bk1vZGUgPSAhdGhpcy5pc01hcmtkb3duTW9kZTtcbiAgICAgICAgaWYgKHRoaXMuaXNNYXJrZG93bk1vZGUpIHtcbiAgICAgICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9ICdNRCc7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NMaXN0LmFkZCgnYWN0aXZlJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSAnTUQnO1xuICAgICAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoJ2FjdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgaW5wdXQgdGV4dFxuICAgICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IGlucHV0IHRleHRcbiAgICAgKi9cbiAgICBnZXRJbnB1dFRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0RmllbGQudmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFycyB0aGUgaW5wdXQgZmllbGRcbiAgICAgKi9cbiAgICBjbGVhcklucHV0KCkge1xuICAgICAgICB0aGlzLmlucHV0RmllbGQudmFsdWUgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0ZXh0IHRvIHRoZSBpbnB1dCBmaWVsZCB3aXRoIHByb3BlciBzcGFjaW5nXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgdG8gYXBwZW5kXG4gICAgICovXG4gICAgYXBwZW5kVG9JbnB1dCh0ZXh0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50VGV4dCA9IHRoaXMuaW5wdXRGaWVsZC52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnNvclBvc2l0aW9uID0gdGhpcy5pbnB1dEZpZWxkLnNlbGVjdGlvblN0YXJ0O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgbmVlZCB0byBhZGQgYSBzcGFjZSBiZWZvcmUgdGhlIHRleHRcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzTGVhZGluZ1NwYWNlID0gY3Vyc29yUG9zaXRpb24gPiAwICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQuY2hhckF0KGN1cnNvclBvc2l0aW9uIC0gMSkgIT09ICcgJyAmJlxuICAgICAgICAgICAgICAgIGN1cnJlbnRUZXh0LmNoYXJBdChjdXJzb3JQb3NpdGlvbiAtIDEpICE9PSAnXFxuJztcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHdlIG5lZWQgdG8gYWRkIGEgc3BhY2UgYWZ0ZXIgdGhlIHRleHRcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzVHJhaWxpbmdTcGFjZSA9IGN1cnNvclBvc2l0aW9uIDwgY3VycmVudFRleHQubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQuY2hhckF0KGN1cnNvclBvc2l0aW9uKSAhPT0gJyAnICYmXG4gICAgICAgICAgICAgICAgY3VycmVudFRleHQuY2hhckF0KGN1cnNvclBvc2l0aW9uKSAhPT0gJ1xcbic7XG4gICAgICAgICAgICAvLyBCdWlsZCB0aGUgdGV4dCB0byBpbnNlcnRcbiAgICAgICAgICAgIGxldCBpbnNlcnRUZXh0ID0gJyc7XG4gICAgICAgICAgICBpZiAobmVlZHNMZWFkaW5nU3BhY2UpXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCArPSAnICc7XG4gICAgICAgICAgICBpbnNlcnRUZXh0ICs9IHRleHQ7XG4gICAgICAgICAgICBpZiAobmVlZHNUcmFpbGluZ1NwYWNlKVxuICAgICAgICAgICAgICAgIGluc2VydFRleHQgKz0gJyAnO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRoZSB0ZXh0IGF0IHRoZSBjdXJzb3IgcG9zaXRpb25cbiAgICAgICAgICAgIGNvbnN0IG5ld1RleHQgPSBjdXJyZW50VGV4dC5zdWJzdHJpbmcoMCwgY3Vyc29yUG9zaXRpb24pICtcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0ICtcbiAgICAgICAgICAgICAgICBjdXJyZW50VGV4dC5zdWJzdHJpbmcoY3Vyc29yUG9zaXRpb24pO1xuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnZhbHVlID0gbmV3VGV4dDtcbiAgICAgICAgICAgIC8vIFNldCBmb2N1cyBiYWNrIHRvIHRoZSBpbnB1dCBmaWVsZFxuICAgICAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBhcHBlbmRpbmcgdG8gaW5wdXQ6JywgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBtYXJrZG93biBtb2RlIGlzIGVuYWJsZWRcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIG1hcmtkb3duIG1vZGUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlXG4gICAgICovXG4gICAgaXNNYXJrZG93bkVuYWJsZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzTWFya2Rvd25Nb2RlO1xuICAgIH1cbn1cbmV4cG9ydHMuSW5wdXRIYW5kbGVyID0gSW5wdXRIYW5kbGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIEhhbmRsZXMgcmVuZGVyaW5nIGFuZCBtYW5hZ2luZyBjaGF0IG1lc3NhZ2VzXG4gKi9cbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTWVzc2FnZVJlbmRlcmVyID0gdm9pZCAwO1xuY29uc3QgbWFya2VkXzEgPSByZXF1aXJlKFwibWFya2VkXCIpO1xuY29uc3QgZG9tcHVyaWZ5XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRvbXB1cmlmeVwiKSk7XG5jb25zdCBtYXJrZG93bl9jb25maWdfMSA9IHJlcXVpcmUoXCIuLi9tYXJrZG93bi1jb25maWdcIik7XG4vKipcbiAqIEhhbmRsZXMgcmVuZGVyaW5nIGFuZCBtYW5hZ2luZyBjaGF0IG1lc3NhZ2VzIGluIHRoZSBVSVxuICovXG5jbGFzcyBNZXNzYWdlUmVuZGVyZXIge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2VDb250YWluZXIsIG9uQ29weU1lc3NhZ2UsIG9uQWRkVG9DZWxsKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lciA9IG1lc3NhZ2VDb250YWluZXI7XG4gICAgICAgIHRoaXMub25Db3B5TWVzc2FnZSA9IG9uQ29weU1lc3NhZ2U7XG4gICAgICAgIHRoaXMub25BZGRUb0NlbGwgPSBvbkFkZFRvQ2VsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIG1lc3NhZ2UgaW4gdGhlIFVJXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgY29udGVudCBvZiB0aGUgbWVzc2FnZVxuICAgICAqIEBwYXJhbSBzZW5kZXIgVGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZSAoJ3VzZXInIG9yICdib3QnKVxuICAgICAqIEBwYXJhbSBpc01hcmtkb3duIFdoZXRoZXIgdGhlIG1lc3NhZ2UgaXMgaW4gTWFya2Rvd24gZm9ybWF0XG4gICAgICogQHJldHVybnMgVGhlIGNyZWF0ZWQgbWVzc2FnZSBlbGVtZW50XG4gICAgICovXG4gICAgcmVuZGVyTWVzc2FnZSh0ZXh0LCBzZW5kZXIsIGlzTWFya2Rvd24gPSBmYWxzZSkge1xuICAgICAgICBjb25zb2xlLmxvZygnUmVuZGVyaW5nIG1lc3NhZ2U6JywgeyBzZW5kZXIsIGlzTWFya2Rvd24gfSk7IC8vIERlYnVnIGxvZ1xuICAgICAgICAvLyBDcmVhdGUgbWVzc2FnZSBjb250YWluZXJcbiAgICAgICAgY29uc3QgbWVzc2FnZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWVzc2FnZUVsZW1lbnQuY2xhc3NOYW1lID0gYGNoYXQtbWVzc2FnZSAke3NlbmRlcn0tbWVzc2FnZWA7XG4gICAgICAgIC8vIENyZWF0ZSBtZXNzYWdlIGhlYWRlciB3aXRoIHNlbmRlciBpbmZvXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VIZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbWVzc2FnZUhlYWRlci5jbGFzc05hbWUgPSAnbWVzc2FnZS1oZWFkZXInO1xuICAgICAgICBtZXNzYWdlSGVhZGVyLnRleHRDb250ZW50ID0gc2VuZGVyID09PSAndXNlcicgPyAnWW91JyA6ICdBSSc7XG4gICAgICAgIG1lc3NhZ2VFbGVtZW50LmFwcGVuZENoaWxkKG1lc3NhZ2VIZWFkZXIpO1xuICAgICAgICAvLyBDcmVhdGUgbWVzc2FnZSBjb250ZW50XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VDb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1lc3NhZ2VDb250ZW50LmNsYXNzTmFtZSA9ICdtZXNzYWdlLWNvbnRlbnQnO1xuICAgICAgICAvLyBQcm9jZXNzIGFuZCByZW5kZXIgdGhlIG1lc3NhZ2UgY29udGVudFxuICAgICAgICBpZiAoaXNNYXJrZG93bikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBQcmVwcm9jZXNzIG1hcmtkb3duIHRvIGhhbmRsZSBzcGVjaWFsIHN5bnRheFxuICAgICAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZE1hcmtkb3duID0gKDAsIG1hcmtkb3duX2NvbmZpZ18xLnByZXByb2Nlc3NNYXJrZG93bikodGV4dCk7XG4gICAgICAgICAgICAgICAgLy8gQ29udmVydCBtYXJrZG93biB0byBIVE1MXG4gICAgICAgICAgICAgICAgY29uc3QgcmF3SHRtbCA9IG1hcmtlZF8xLm1hcmtlZC5wYXJzZShwcm9jZXNzZWRNYXJrZG93bik7XG4gICAgICAgICAgICAgICAgLy8gU2FuaXRpemUgSFRNTCAoY2FzdCB0byBzdHJpbmcgdG8gZml4IHR5cGUgaXNzdWUpXG4gICAgICAgICAgICAgICAgY29uc3Qgc2FuaXRpemVkSHRtbCA9IGRvbXB1cmlmeV8xLmRlZmF1bHQuc2FuaXRpemUocmF3SHRtbCk7XG4gICAgICAgICAgICAgICAgLy8gU2V0IHRoZSBIVE1MIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBtZXNzYWdlQ29udGVudC5pbm5lckhUTUwgPSBzYW5pdGl6ZWRIdG1sO1xuICAgICAgICAgICAgICAgIC8vIEFkZCBzeW50YXggaGlnaGxpZ2h0aW5nIHRvIGNvZGUgYmxvY2tzXG4gICAgICAgICAgICAgICAgY29uc3QgY29kZUJsb2NrcyA9IG1lc3NhZ2VDb250ZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3ByZSBjb2RlJyk7XG4gICAgICAgICAgICAgICAgY29kZUJsb2Nrcy5mb3JFYWNoKChibG9jaykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgYSBjbGFzcyBmb3Igc3R5bGluZ1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSBibG9jay5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xhc3NMaXN0LmFkZCgnaGlnaGxpZ2h0ZWQtY29kZScpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgY29weSBidXR0b24gdG8gY29kZSBibG9ja3NcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdjb2RlLWNvcHktYnV0dG9uJztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi50ZXh0Q29udGVudCA9ICdDb3B5JztcbiAgICAgICAgICAgICAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVUZXh0ID0gYmxvY2suaW5uZXJUZXh0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNvcHlNZXNzYWdlKGNvZGVUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcHlCdXR0b24udGV4dENvbnRlbnQgPSAnQ29waWVkISc7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLnRleHRDb250ZW50ID0gJ0NvcHknO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvcHkgYnV0dG9uIHRvIHRoZSBwcmUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAoX2IgPSBibG9jay5wYXJlbnRFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuYXBwZW5kQ2hpbGQoY29weUJ1dHRvbik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZW5kZXJpbmcgbWFya2Rvd246JywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIG1lc3NhZ2VDb250ZW50LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFBsYWluIHRleHQgcmVuZGVyaW5nXG4gICAgICAgICAgICBtZXNzYWdlQ29udGVudC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZUVsZW1lbnQuYXBwZW5kQ2hpbGQobWVzc2FnZUNvbnRlbnQpO1xuICAgICAgICAvLyBDcmVhdGUgbWVzc2FnZSBhY3Rpb25zXG4gICAgICAgIGNvbnN0IG1lc3NhZ2VBY3Rpb25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIG1lc3NhZ2VBY3Rpb25zLmNsYXNzTmFtZSA9ICdtZXNzYWdlLWFjdGlvbnMnO1xuICAgICAgICAvLyBBZGQgY29weSBidXR0b25cbiAgICAgICAgY29uc3QgY29weUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBjb3B5QnV0dG9uLmNsYXNzTmFtZSA9ICdtZXNzYWdlLWFjdGlvbi1idXR0b24nO1xuICAgICAgICBjb3B5QnV0dG9uLnRleHRDb250ZW50ID0gJ0NvcHknO1xuICAgICAgICBjb3B5QnV0dG9uLnRpdGxlID0gJ0NvcHkgdG8gY2xpcGJvYXJkJztcbiAgICAgICAgY29weUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25Db3B5TWVzc2FnZSh0ZXh0KTtcbiAgICAgICAgICAgIGNvcHlCdXR0b24udGV4dENvbnRlbnQgPSAnQ29waWVkISc7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjb3B5QnV0dG9uLnRleHRDb250ZW50ID0gJ0NvcHknO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlQWN0aW9ucy5hcHBlbmRDaGlsZChjb3B5QnV0dG9uKTtcbiAgICAgICAgLy8gQWRkIFwiQWRkIHRvIENlbGxcIiBidXR0b25cbiAgICAgICAgY29uc3QgYWRkVG9DZWxsQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGFkZFRvQ2VsbEJ1dHRvbi5jbGFzc05hbWUgPSAnbWVzc2FnZS1hY3Rpb24tYnV0dG9uJztcbiAgICAgICAgYWRkVG9DZWxsQnV0dG9uLnRleHRDb250ZW50ID0gJ0FkZCB0byBDZWxsJztcbiAgICAgICAgYWRkVG9DZWxsQnV0dG9uLnRpdGxlID0gJ0FkZCB0byBjdXJyZW50IGNlbGwnO1xuICAgICAgICBhZGRUb0NlbGxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uQWRkVG9DZWxsKHRleHQpO1xuICAgICAgICAgICAgYWRkVG9DZWxsQnV0dG9uLnRleHRDb250ZW50ID0gJ0FkZGVkISc7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBhZGRUb0NlbGxCdXR0b24udGV4dENvbnRlbnQgPSAnQWRkIHRvIENlbGwnO1xuICAgICAgICAgICAgfSwgMjAwMCk7XG4gICAgICAgIH0pO1xuICAgICAgICBtZXNzYWdlQWN0aW9ucy5hcHBlbmRDaGlsZChhZGRUb0NlbGxCdXR0b24pO1xuICAgICAgICBtZXNzYWdlRWxlbWVudC5hcHBlbmRDaGlsZChtZXNzYWdlQWN0aW9ucyk7XG4gICAgICAgIC8vIEFkZCB0byBtZXNzYWdlIGNvbnRhaW5lclxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuYXBwZW5kQ2hpbGQobWVzc2FnZUVsZW1lbnQpO1xuICAgICAgICAvLyBTY3JvbGwgdG8gdGhlIGJvdHRvbVxuICAgICAgICB0aGlzLm1lc3NhZ2VDb250YWluZXIuc2Nyb2xsVG9wID0gdGhpcy5tZXNzYWdlQ29udGFpbmVyLnNjcm9sbEhlaWdodDtcbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VFbGVtZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgYWxsIG1lc3NhZ2VzIGZyb20gdGhlIGNvbnRhaW5lclxuICAgICAqL1xuICAgIGNsZWFyTWVzc2FnZXMoKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyBhIGxpc3Qgb2YgbWVzc2FnZXNcbiAgICAgKiBAcGFyYW0gbWVzc2FnZXMgVGhlIG1lc3NhZ2VzIHRvIHJlbmRlclxuICAgICAqL1xuICAgIHJlbmRlck1lc3NhZ2VzKG1lc3NhZ2VzKSB7XG4gICAgICAgIHRoaXMuY2xlYXJNZXNzYWdlcygpO1xuICAgICAgICBtZXNzYWdlcy5mb3JFYWNoKG1lc3NhZ2UgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJNZXNzYWdlKG1lc3NhZ2UudGV4dCwgbWVzc2FnZS5zZW5kZXIsIG1lc3NhZ2UuaXNNYXJrZG93bik7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuTWVzc2FnZVJlbmRlcmVyID0gTWVzc2FnZVJlbmRlcmVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIE1hbmFnZXMgcG9wdXAgbWVudSBmdW5jdGlvbmFsaXR5XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9wdXBNZW51TWFuYWdlciA9IHZvaWQgMDtcbi8qKlxuICogTWFuYWdlcyBwb3B1cCBtZW51IGNyZWF0aW9uLCBkaXNwbGF5LCBhbmQgaW50ZXJhY3Rpb25cbiAqL1xuY2xhc3MgUG9wdXBNZW51TWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoZmlsZUJyb3dzZXJNYW5hZ2VyLCBvbkl0ZW1TZWxlY3RlZCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFuZGxlcyBkb2N1bWVudCBjbGljayBldmVudHMgdG8gY2xvc2UgdGhlIG1lbnUgd2hlbiBjbGlja2luZyBvdXRzaWRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhhbmRsZURvY3VtZW50Q2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjbGljayBpcyBvdXRzaWRlIHRoZSBwb3B1cCBtZW51IGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgIT09ICdub25lJyAmJlxuICAgICAgICAgICAgICAgICF0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5jb250YWlucyhldmVudC50YXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlsZUJyb3dzZXJNYW5hZ2VyID0gZmlsZUJyb3dzZXJNYW5hZ2VyO1xuICAgICAgICB0aGlzLm9uSXRlbVNlbGVjdGVkID0gb25JdGVtU2VsZWN0ZWQ7XG4gICAgICAgIC8vIEluaXRpYWxpemUgbWVudSBzdGF0ZVxuICAgICAgICB0aGlzLm1lbnVTdGF0ZSA9IHtcbiAgICAgICAgICAgIGN1cnJlbnRNZW51TGV2ZWw6ICd0b3AnLFxuICAgICAgICAgICAgY3VycmVudE1lbnVQYXRoOiAnJyxcbiAgICAgICAgICAgIG1lbnVIaXN0b3J5OiBbXVxuICAgICAgICB9O1xuICAgICAgICAvLyBDcmVhdGUgcG9wdXAgbWVudSBjb250YWluZXJcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1jb250YWluZXInO1xuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHRoaXMucG9wdXBNZW51Q29udGFpbmVyKTtcbiAgICAgICAgLy8gQWRkIGNsaWNrIGV2ZW50IGxpc3RlbmVyIHRvIGNsb3NlIG1lbnUgd2hlbiBjbGlja2luZyBvdXRzaWRlXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIHBvcHVwIG1lbnUgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB4IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHBvcHVwIG1lbnVcbiAgICAgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3B1cCBtZW51XG4gICAgICovXG4gICAgc2hvd1BvcHVwTWVudSh4LCB5KSB7XG4gICAgICAgIC8vIENsZWFyIHByZXZpb3VzIG1lbnUgaXRlbXNcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIC8vIFJlc2V0IG1lbnUgc3RhdGUgZm9yIHRvcCBsZXZlbFxuICAgICAgICB0aGlzLm1lbnVTdGF0ZS5jdXJyZW50TWVudUxldmVsID0gJ3RvcCc7XG4gICAgICAgIHRoaXMubWVudVN0YXRlLm1lbnVIaXN0b3J5ID0gW107XG4gICAgICAgIC8vIENyZWF0ZSB0b3AtbGV2ZWwgbWVudSBpdGVtc1xuICAgICAgICBjb25zdCBjb21tYW5kcyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBsYWJlbDogJ0NvZGUnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5zZXJ0IHNlbGVjdGVkIGNvZGUnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVDb2RlQ29tbWFuZCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICdDZWxsJyxcbiAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0luc2VydCBlbnRpcmUgY2VsbCBjb250ZW50JyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oaWRlUG9wdXBNZW51KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2VsbENvbW1hbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnRmlsZXMnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQnJvd3NlIGFuZCBpbnNlcnQgZmlsZSBjb250ZW50JyxcbiAgICAgICAgICAgICAgICBhY3Rpb246ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51U3RhdGUuY3VycmVudE1lbnVMZXZlbCA9ICdmaWxlcyc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVudVN0YXRlLm1lbnVIaXN0b3J5LnB1c2goeyBsZXZlbDogJ3RvcCcsIHBhdGg6ICcnIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWREaXJlY3RvcnlDb250ZW50cyh4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGxhYmVsOiAnRGlyZWN0b3JpZXMnLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQnJvd3NlIGFuZCByZWZlcmVuY2UgZGlyZWN0b3JpZXMnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVTdGF0ZS5jdXJyZW50TWVudUxldmVsID0gJ2RpcmVjdG9yaWVzJztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51U3RhdGUubWVudUhpc3RvcnkucHVzaCh7IGxldmVsOiAndG9wJywgcGF0aDogJycgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9hZERpcmVjdG9yeUNvbnRlbnRzKHgsIHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5jcmVhdGVNZW51SXRlbXMoY29tbWFuZHMpO1xuICAgICAgICAvLyBQb3NpdGlvbiBhbmQgc2hvdyB0aGUgbWVudVxuICAgICAgICB0aGlzLnBvc2l0aW9uTWVudSh4LCB5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBtZW51IGl0ZW1zIGZyb20gY29tbWFuZHMgYW5kIGFwcGVuZHMgdGhlbSB0byB0aGUgcG9wdXAgbWVudSBjb250YWluZXJcbiAgICAgKiBAcGFyYW0gY29tbWFuZHMgVGhlIGFycmF5IG9mIGNvbW1hbmRzIHRvIGNyZWF0ZSBtZW51IGl0ZW1zIGZvclxuICAgICAqL1xuICAgIGNyZWF0ZU1lbnVJdGVtcyhjb21tYW5kcykge1xuICAgICAgICBjb21tYW5kcy5mb3JFYWNoKGNvbW1hbmQgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaXRlbS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWl0ZW0nO1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGxhYmVsLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtaXRlbS1sYWJlbCc7XG4gICAgICAgICAgICBsYWJlbC50ZXh0Q29udGVudCA9IGNvbW1hbmQubGFiZWw7XG4gICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZGVzY3JpcHRpb24uY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtcG9wdXAtbWVudS1pdGVtLWRlc2NyaXB0aW9uJztcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uLnRleHRDb250ZW50ID0gY29tbWFuZC5kZXNjcmlwdGlvbjtcbiAgICAgICAgICAgIGl0ZW0uYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICAgICAgaXRlbS5hcHBlbmRDaGlsZChkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBpdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgIGNvbW1hbmQuYWN0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZHMgYW5kIGRpc3BsYXlzIGRpcmVjdG9yeSBjb250ZW50cyBpbiB0aGUgcG9wdXAgbWVudVxuICAgICAqIEBwYXJhbSB4IFRoZSB4LWNvb3JkaW5hdGUgb2YgdGhlIHBvcHVwIG1lbnVcbiAgICAgKiBAcGFyYW0geSBUaGUgeS1jb29yZGluYXRlIG9mIHRoZSBwb3B1cCBtZW51XG4gICAgICovXG4gICAgYXN5bmMgbG9hZERpcmVjdG9yeUNvbnRlbnRzKHgsIHkpIHtcbiAgICAgICAgLy8gU2hvdyBsb2FkaW5nIGluZGljYXRvclxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImpwLWxsbS1leHQtcG9wdXAtbWVudS1sb2FkaW5nXCI+TG9hZGluZy4uLjwvZGl2Pic7XG4gICAgICAgIC8vIERldGVybWluZSBmaWx0ZXIgdHlwZSBiYXNlZCBvbiBtZW51IGxldmVsXG4gICAgICAgIGNvbnN0IGZpbHRlclR5cGUgPSB0aGlzLm1lbnVTdGF0ZS5jdXJyZW50TWVudUxldmVsID09PSAnZmlsZXMnID8gJ2ZpbGUnIDogJ2RpcmVjdG9yeSc7XG4gICAgICAgIC8vIEdldCBkaXJlY3RvcnkgY29udGVudHNcbiAgICAgICAgY29uc3QgY29udGVudHMgPSBhd2FpdCB0aGlzLmZpbGVCcm93c2VyTWFuYWdlci5saXN0Q3VycmVudERpcmVjdG9yeUNvbnRlbnRzKGZpbHRlclR5cGUpO1xuICAgICAgICAvLyBDbGVhciB0aGUgbWVudVxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgLy8gQWRkIGJhY2sgYnV0dG9uIGlmIHdlIGhhdmUgaGlzdG9yeVxuICAgICAgICBpZiAodGhpcy5tZW51U3RhdGUubWVudUhpc3RvcnkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgYmFja0NvbW1hbmQgPSB7XG4gICAgICAgICAgICAgICAgbGFiZWw6ICfirIXvuI8gQmFjaycsXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRpb246ICdHbyBiYWNrIHRvIHByZXZpb3VzIG1lbnUnLFxuICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBQb3AgdGhlIGxhc3QgaXRlbSBmcm9tIGhpc3RvcnlcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSB0aGlzLm1lbnVTdGF0ZS5tZW51SGlzdG9yeS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXN0b3JlIHByZXZpb3VzIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm1lbnVTdGF0ZS5jdXJyZW50TWVudUxldmVsID0gcHJldmlvdXMubGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBnb2luZyBiYWNrIHRvIHRvcCBsZXZlbFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHByZXZpb3VzLmxldmVsID09PSAndG9wJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd1BvcHVwTWVudSh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIElmIGdvaW5nIGJhY2sgdG8gYSBkaXJlY3RvcnkgbGV2ZWwsIHdlIG5lZWQgdG8gZ28gdXAgb25lIGRpcmVjdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZUJyb3dzZXJNYW5hZ2VyLm5hdmlnYXRlVG9QYXJlbnREaXJlY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxvYWREaXJlY3RvcnlDb250ZW50cyh4LCB5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU1lbnVJdGVtcyhbYmFja0NvbW1hbmRdKTtcbiAgICAgICAgICAgIC8vIEFkZCBjdXJyZW50IHBhdGggaW5kaWNhdG9yXG4gICAgICAgICAgICBjb25zdCBwYXRoSW5kaWNhdG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBwYXRoSW5kaWNhdG9yLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXBvcHVwLW1lbnUtcGF0aCc7XG4gICAgICAgICAgICBwYXRoSW5kaWNhdG9yLnRleHRDb250ZW50ID0gYFBhdGg6ICR7dGhpcy5maWxlQnJvd3Nlck1hbmFnZXIuZ2V0Q3VycmVudFBhdGgoKSB8fCAnLyd9YDtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLmFwcGVuZENoaWxkKHBhdGhJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIG5vIGNvbnRlbnRzIG9yIGVycm9yXG4gICAgICAgIGlmICghY29udGVudHMgfHwgY29udGVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCBlbXB0eU1lc3NhZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGVtcHR5TWVzc2FnZS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1wb3B1cC1tZW51LWVtcHR5JztcbiAgICAgICAgICAgIGVtcHR5TWVzc2FnZS50ZXh0Q29udGVudCA9ICdObyBpdGVtcyBmb3VuZCc7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5hcHBlbmRDaGlsZChlbXB0eU1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3JlYXRlIGNvbW1hbmRzIGZvciBlYWNoIGl0ZW1cbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmRzID0gY29udGVudHMubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBpdGVtLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogJycsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGRpcmVjdG9yeSBuYXZpZ2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5zdGFydHNXaXRoKCfwn5OBJykgJiYgdGhpcy5tZW51U3RhdGUuY3VycmVudE1lbnVMZXZlbCA9PT0gJ2RpcmVjdG9yaWVzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5hdmlnYXRlIHRvIHN1YmRpcmVjdG9yeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZUJyb3dzZXJNYW5hZ2VyLm5hdmlnYXRlVG9TdWJkaXJlY3RvcnkoaXRlbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tZW51U3RhdGUubWVudUhpc3RvcnkucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldmVsOiB0aGlzLm1lbnVTdGF0ZS5jdXJyZW50TWVudUxldmVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXRoOiB0aGlzLmZpbGVCcm93c2VyTWFuYWdlci5nZXRDdXJyZW50UGF0aCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2FkRGlyZWN0b3J5Q29udGVudHMoeCwgeSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBIYW5kbGUgZmlsZSBzZWxlY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhpZGVQb3B1cE1lbnUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uSXRlbVNlbGVjdGVkKGl0ZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVNZW51SXRlbXMoY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlcG9zaXRpb24gdGhlIG1lbnVcbiAgICAgICAgdGhpcy5wb3NpdGlvbk1lbnUoeCwgeSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBvc2l0aW9ucyB0aGUgcG9wdXAgbWVudSBhdCB0aGUgc3BlY2lmaWVkIGNvb3JkaW5hdGVzXG4gICAgICogQHBhcmFtIHggVGhlIHgtY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB5IFRoZSB5LWNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBwb3NpdGlvbk1lbnUoeCwgeSkge1xuICAgICAgICAvLyBHZXQgdmlld3BvcnQgZGltZW5zaW9uc1xuICAgICAgICBjb25zdCB2aWV3cG9ydFdpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgICAgIGNvbnN0IHZpZXdwb3J0SGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICAvLyBHZXQgbWVudSBkaW1lbnNpb25zXG4gICAgICAgIGNvbnN0IG1lbnVXaWR0aCA9IHRoaXMucG9wdXBNZW51Q29udGFpbmVyLm9mZnNldFdpZHRoO1xuICAgICAgICBjb25zdCBtZW51SGVpZ2h0ID0gdGhpcy5wb3B1cE1lbnVDb250YWluZXIub2Zmc2V0SGVpZ2h0O1xuICAgICAgICAvLyBBZGp1c3QgcG9zaXRpb24gdG8gZW5zdXJlIG1lbnUgc3RheXMgd2l0aGluIHZpZXdwb3J0XG4gICAgICAgIGxldCBhZGp1c3RlZFggPSB4O1xuICAgICAgICBsZXQgYWRqdXN0ZWRZID0geTtcbiAgICAgICAgaWYgKHggKyBtZW51V2lkdGggPiB2aWV3cG9ydFdpZHRoKSB7XG4gICAgICAgICAgICBhZGp1c3RlZFggPSB2aWV3cG9ydFdpZHRoIC0gbWVudVdpZHRoIC0gMTA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgKyBtZW51SGVpZ2h0ID4gdmlld3BvcnRIZWlnaHQpIHtcbiAgICAgICAgICAgIGFkanVzdGVkWSA9IHZpZXdwb3J0SGVpZ2h0IC0gbWVudUhlaWdodCAtIDEwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBwb3NpdGlvblxuICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7YWRqdXN0ZWRYfXB4YDtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUudG9wID0gYCR7YWRqdXN0ZWRZfXB4YDtcbiAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhpZGVzIHRoZSBwb3B1cCBtZW51XG4gICAgICovXG4gICAgaGlkZVBvcHVwTWVudSgpIHtcbiAgICAgICAgLy8gT25seSBhY3QgaWYgdGhlIG1lbnUgaXMgY3VycmVudGx5IGRpc3BsYXllZFxuICAgICAgICBpZiAodGhpcy5wb3B1cE1lbnVDb250YWluZXIuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnKSB7XG4gICAgICAgICAgICB0aGlzLnBvcHVwTWVudUNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgdGhpcy5wb3B1cE1lbnVDb250YWluZXIuaW5uZXJIVE1MID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY29kZSBjb21tYW5kIC0gaW5zZXJ0cyBzZWxlY3RlZCBjb2RlXG4gICAgICogUGxhY2Vob2xkZXIgZm9yIGltcGxlbWVudGF0aW9uIGluIFNpbXBsZVNpZGViYXJXaWRnZXRcbiAgICAgKi9cbiAgICBoYW5kbGVDb2RlQ29tbWFuZCgpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBTaW1wbGVTaWRlYmFyV2lkZ2V0XG4gICAgICAgIGNvbnNvbGUubG9nKCdDb2RlIGNvbW1hbmQgc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyB0aGUgY2VsbCBjb21tYW5kIC0gaW5zZXJ0cyBlbnRpcmUgY2VsbCBjb250ZW50XG4gICAgICogUGxhY2Vob2xkZXIgZm9yIGltcGxlbWVudGF0aW9uIGluIFNpbXBsZVNpZGViYXJXaWRnZXRcbiAgICAgKi9cbiAgICBoYW5kbGVDZWxsQ29tbWFuZCgpIHtcbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIGltcGxlbWVudGVkIGJ5IHRoZSBTaW1wbGVTaWRlYmFyV2lkZ2V0XG4gICAgICAgIGNvbnNvbGUubG9nKCdDZWxsIGNvbW1hbmQgc2VsZWN0ZWQnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVEb2N1bWVudENsaWNrKTtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51Q29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5wb3B1cE1lbnVDb250YWluZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5Qb3B1cE1lbnVNYW5hZ2VyID0gUG9wdXBNZW51TWFuYWdlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBNYW5hZ2VzIHNldHRpbmdzIGFuZCBjb25maWd1cmF0aW9uIGZvciB0aGUgY2hhdCBpbnRlcmZhY2VcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXR0aW5nc01hbmFnZXIgPSB2b2lkIDA7XG4vKipcbiAqIE1hbmFnZXMgc2V0dGluZ3MgYW5kIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjaGF0IGludGVyZmFjZVxuICovXG5jbGFzcyBTZXR0aW5nc01hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRlZmF1bHRTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiAnT3BlbkFJJyxcbiAgICAgICAgICAgIGFwaUtleTogJycsXG4gICAgICAgICAgICBhcGlCYXNlVXJsOiAnJyxcbiAgICAgICAgICAgIHJ1bGVzOiAnJ1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmN1cnJlbnRTZXR0aW5ncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZGVmYXVsdFNldHRpbmdzKTtcbiAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyID0gdGhpcy5jcmVhdGVTZXR0aW5nc01vZGFsKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyB0aGUgc2V0dGluZ3MgbW9kYWxcbiAgICAgKiBAcmV0dXJucyBUaGUgY3JlYXRlZCBtb2RhbCBjb250YWluZXJcbiAgICAgKi9cbiAgICBjcmVhdGVTZXR0aW5nc01vZGFsKCkge1xuICAgICAgICBjb25zdCBtb2RhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBtb2RhbC5zdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIG1vZGFsLnN0eWxlLnRvcCA9ICcwJztcbiAgICAgICAgbW9kYWwuc3R5bGUubGVmdCA9ICcwJztcbiAgICAgICAgbW9kYWwuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIG1vZGFsLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgbW9kYWwuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgbW9kYWwuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSAnY2VudGVyJztcbiAgICAgICAgbW9kYWwuc3R5bGUuYWxpZ25JdGVtcyA9ICdjZW50ZXInO1xuICAgICAgICBtb2RhbC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAncmdiYSgwLCAwLCAwLCAwLjUpJztcbiAgICAgICAgbW9kYWwuc3R5bGUuekluZGV4ID0gJzEwMDAnO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuICAgICAgICBjb250ZW50LnN0eWxlLnBhZGRpbmcgPSAnMjBweCc7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUuYm9yZGVyUmFkaXVzID0gJzVweCc7XG4gICAgICAgIGNvbnRlbnQuc3R5bGUud2lkdGggPSAnNDAwcHgnO1xuICAgICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJyk7XG4gICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gJ1NldHRpbmdzJztcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpO1xuICAgICAgICBwcm92aWRlckxhYmVsLmh0bWxGb3IgPSAnc2V0dGluZ3MtcHJvdmlkZXInO1xuICAgICAgICBwcm92aWRlckxhYmVsLnRleHRDb250ZW50ID0gJ0xMTSBQcm92aWRlcjonO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHByb3ZpZGVyTGFiZWwpO1xuICAgICAgICBjb25zdCBwcm92aWRlclNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NlbGVjdCcpO1xuICAgICAgICBwcm92aWRlclNlbGVjdC5pZCA9ICdzZXR0aW5ncy1wcm92aWRlcic7XG4gICAgICAgIFsnT3BlbkFJJywgJ0h1Z2dpbmdGYWNlJywgJ0xvY2FsJ10uZm9yRWFjaChvcHQgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnb3B0aW9uJyk7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBvcHQ7XG4gICAgICAgICAgICBvcHRpb24udGV4dENvbnRlbnQgPSBvcHQ7XG4gICAgICAgICAgICBwcm92aWRlclNlbGVjdC5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChwcm92aWRlclNlbGVjdCk7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnInKSk7XG4gICAgICAgIGNvbnN0IGtleUxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAga2V5TGFiZWwuaHRtbEZvciA9ICdzZXR0aW5ncy1hcGkta2V5JztcbiAgICAgICAga2V5TGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIEtleTonO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGtleUxhYmVsKTtcbiAgICAgICAgY29uc3Qga2V5SW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICBrZXlJbnB1dC5pZCA9ICdzZXR0aW5ncy1hcGkta2V5JztcbiAgICAgICAga2V5SW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAga2V5SW5wdXQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoa2V5SW5wdXQpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgICBjb25zdCB1cmxMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG4gICAgICAgIHVybExhYmVsLmh0bWxGb3IgPSAnc2V0dGluZ3MtYXBpLWJhc2UtdXJsJztcbiAgICAgICAgdXJsTGFiZWwudGV4dENvbnRlbnQgPSAnQVBJIEJhc2UgVVJMIChvcHRpb25hbCk6JztcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZCh1cmxMYWJlbCk7XG4gICAgICAgIGNvbnN0IHVybElucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgdXJsSW5wdXQuaWQgPSAnc2V0dGluZ3MtYXBpLWJhc2UtdXJsJztcbiAgICAgICAgdXJsSW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgdXJsSW5wdXQuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodXJsSW5wdXQpO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2JyJykpO1xuICAgICAgICBjb25zdCBydWxlc0xhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKTtcbiAgICAgICAgcnVsZXNMYWJlbC5odG1sRm9yID0gJ3NldHRpbmdzLXJ1bGVzJztcbiAgICAgICAgcnVsZXNMYWJlbC50ZXh0Q29udGVudCA9ICdSdWxlczonO1xuICAgICAgICBjb250ZW50LmFwcGVuZENoaWxkKHJ1bGVzTGFiZWwpO1xuICAgICAgICBjb25zdCBydWxlc1RleHRhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKTtcbiAgICAgICAgcnVsZXNUZXh0YXJlYS5pZCA9ICdzZXR0aW5ncy1ydWxlcyc7XG4gICAgICAgIHJ1bGVzVGV4dGFyZWEuc3R5bGUud2lkdGggPSAnMTAwJSc7XG4gICAgICAgIHJ1bGVzVGV4dGFyZWEuc3R5bGUuaGVpZ2h0ID0gJzEwMHB4JztcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChydWxlc1RleHRhcmVhKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdicicpKTtcbiAgICAgICAgY29uc3QgYnRuQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJ0bkNvbnRhaW5lci5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuICAgICAgICBidG5Db250YWluZXIuc3R5bGUubWFyZ2luVG9wID0gJzEwcHgnO1xuICAgICAgICBjb25zdCBzYXZlQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIHNhdmVCdG4udGV4dENvbnRlbnQgPSAnU2F2ZSc7XG4gICAgICAgIHNhdmVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm92aWRlciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1wcm92aWRlcicpLnZhbHVlO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLWFwaS1rZXknKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzZXR0aW5ncy1hcGktYmFzZS11cmwnKS52YWx1ZTtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NldHRpbmdzLXJ1bGVzJykudmFsdWU7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcixcbiAgICAgICAgICAgICAgICBhcGlLZXk6IGtleSxcbiAgICAgICAgICAgICAgICBhcGlCYXNlVXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgcnVsZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnU2V0dGluZ3Mgc2F2ZWQ6JywgdGhpcy5jdXJyZW50U2V0dGluZ3MpO1xuICAgICAgICAgICAgdGhpcy5oaWRlU2V0dGluZ3NNb2RhbCgpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuY2VsQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYnV0dG9uJyk7XG4gICAgICAgIGNhbmNlbEJ0bi50ZXh0Q29udGVudCA9ICdDYW5jZWwnO1xuICAgICAgICBjYW5jZWxCdG4uc3R5bGUubWFyZ2luTGVmdCA9ICcxMHB4JztcbiAgICAgICAgY2FuY2VsQnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gdGhpcy5oaWRlU2V0dGluZ3NNb2RhbCgpKTtcbiAgICAgICAgYnRuQ29udGFpbmVyLmFwcGVuZENoaWxkKHNhdmVCdG4pO1xuICAgICAgICBidG5Db250YWluZXIuYXBwZW5kQ2hpbGQoY2FuY2VsQnRuKTtcbiAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChidG5Db250YWluZXIpO1xuICAgICAgICBtb2RhbC5hcHBlbmRDaGlsZChjb250ZW50KTtcbiAgICAgICAgcmV0dXJuIG1vZGFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyB0aGUgc2V0dGluZ3MgbW9kYWxcbiAgICAgKi9cbiAgICBzaG93U2V0dGluZ3NNb2RhbCgpIHtcbiAgICAgICAgLy8gVXBkYXRlIGZvcm0gZmllbGRzIHdpdGggY3VycmVudCBzZXR0aW5nc1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcHJvdmlkZXInKS52YWx1ZSA9IHRoaXMuY3VycmVudFNldHRpbmdzLnByb3ZpZGVyO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtYXBpLWtleScpLnZhbHVlID0gdGhpcy5jdXJyZW50U2V0dGluZ3MuYXBpS2V5O1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtYXBpLWJhc2UtdXJsJykudmFsdWUgPSB0aGlzLmN1cnJlbnRTZXR0aW5ncy5hcGlCYXNlVXJsO1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2V0dGluZ3MtcnVsZXMnKS52YWx1ZSA9IHRoaXMuY3VycmVudFNldHRpbmdzLnJ1bGVzO1xuICAgICAgICB0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdmbGV4JztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIHNldHRpbmdzIG1vZGFsXG4gICAgICovXG4gICAgaGlkZVNldHRpbmdzTW9kYWwoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNb2RhbENvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHNldHRpbmdzXG4gICAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc2V0dGluZ3NcbiAgICAgKi9cbiAgICBnZXRTZXR0aW5ncygpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHRoaXMuY3VycmVudFNldHRpbmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLnNldHRpbmdzTW9kYWxDb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcy5zZXR0aW5nc01vZGFsQ29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2V0dGluZ3NNYW5hZ2VyID0gU2V0dGluZ3NNYW5hZ2VyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqIE1haW4gc2lkZWJhciB3aWRnZXQgZm9yIHRoZSBBSSBjaGF0IGludGVyZmFjZSBpbiBKdXB5dGVyTGFiXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU2ltcGxlU2lkZWJhcldpZGdldCA9IHZvaWQgMDtcbmNvbnN0IHdpZGdldHNfMSA9IHJlcXVpcmUoXCJAbHVtaW5vL3dpZGdldHNcIik7XG5jb25zdCBpY29uc18xID0gcmVxdWlyZShcIi4uL2ljb25zXCIpO1xuY29uc3QgZ2xvYmFsc18xID0gcmVxdWlyZShcIi4uL2dsb2JhbHNcIik7XG5yZXF1aXJlKFwiLi4vLi4vc3R5bGUvaW5kZXguY3NzXCIpOyAvLyBBZGQgdGhpcyBsaW5lXG4vLyBJbXBvcnQgbW9kdWxhciBjb21wb25lbnRzXG5jb25zdCBjaGF0X2hpc3RvcnlfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vY2hhdC1oaXN0b3J5LW1hbmFnZXJcIik7XG5jb25zdCBmaWxlX2Jyb3dzZXJfbWFuYWdlcl8xID0gcmVxdWlyZShcIi4vZmlsZS1icm93c2VyLW1hbmFnZXJcIik7XG5jb25zdCBwb3B1cF9tZW51X21hbmFnZXJfMSA9IHJlcXVpcmUoXCIuL3BvcHVwLW1lbnUtbWFuYWdlclwiKTtcbmNvbnN0IG1lc3NhZ2VfcmVuZGVyZXJfMSA9IHJlcXVpcmUoXCIuL21lc3NhZ2UtcmVuZGVyZXJcIik7XG5jb25zdCBzZXR0aW5nc19tYW5hZ2VyXzEgPSByZXF1aXJlKFwiLi9zZXR0aW5ncy1tYW5hZ2VyXCIpO1xuY29uc3QgaW5wdXRfaGFuZGxlcl8xID0gcmVxdWlyZShcIi4vaW5wdXQtaGFuZGxlclwiKTtcbi8qKlxuICogTWFpbiBzaWRlYmFyIHdpZGdldCBmb3IgdGhlIEFJIGNoYXQgaW50ZXJmYWNlIGluIEp1cHl0ZXJMYWIuXG4gKiBUaGlzIHdpZGdldCBwcm92aWRlcyBhIGNvbXByZWhlbnNpdmUgY2hhdC1iYXNlZCBpbnRlcmZhY2UgZm9yIGludGVyYWN0aW5nIHdpdGggQUkgYXNzaXN0YW50cyxcbiAqIHN1cHBvcnRpbmcgdGV4dCBpbnB1dCwgTWFya2Rvd24gcmVuZGVyaW5nLCBmaWxlIGFuZCBkaXJlY3RvcnkgYnJvd3NpbmcgdGhyb3VnaCBhIG11bHRpLWxldmVsXG4gKiBwb3AtdXAgbWVudSwgYW5kIGNoYXQgaGlzdG9yeSBtYW5hZ2VtZW50LiBJdCBpbnRlZ3JhdGVzIHdpdGggSnVweXRlckxhYidzIEFQSXMgdG8gaW50ZXJhY3RcbiAqIHdpdGggbm90ZWJvb2tzIGFuZCBtYW5hZ2UgZG9jdW1lbnQgY29udGV4dHMuXG4gKi9cbmNsYXNzIFNpbXBsZVNpZGViYXJXaWRnZXQgZXh0ZW5kcyB3aWRnZXRzXzEuV2lkZ2V0IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgdGhlIFNpbXBsZVNpZGViYXJXaWRnZXQgY2xhc3MuXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHdpZGdldCB3aXRoIHRoZSBwcm92aWRlZCBkb2N1bWVudCBtYW5hZ2VyIGFuZCBzZXRzIHVwIHRoZSBiYXNpYyBVSSBjb21wb25lbnRzLlxuICAgICAqIEBwYXJhbSBkb2NNYW5hZ2VyIFRoZSBkb2N1bWVudCBtYW5hZ2VyIGluc3RhbmNlIGZvciBpbnRlcmFjdGluZyB3aXRoIEp1cHl0ZXJMYWIgZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGRvY01hbmFnZXIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlID0gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIYW5kbGVzIGtleWJvYXJkIHNob3J0Y3V0cyBmb3IgaW1wcm92ZWQgdXNlciBleHBlcmllbmNlLlxuICAgICAgICAgKiBDdXJyZW50bHkgc3VwcG9ydHMgQ3RybCtMIGZvciBpbnNlcnRpbmcgc2VsZWN0ZWQgY29kZSBvciBjZWxsIGNvbnRlbnQuXG4gICAgICAgICAqIEBwYXJhbSBldmVudCBUaGUga2V5Ym9hcmQgZXZlbnQgdHJpZ2dlcmVkIGJ5IHRoZSB1c2VyLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVLZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgQ3RybCtMIChmb3Igc2VsZWN0ZWQgY29kZSlcbiAgICAgICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIGV2ZW50LmtleSA9PT0gJ2wnKSB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNvZGVDb21tYW5kKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaG93S2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvcignU2VsZWN0ZWQgY29kZSBpbnNlcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmRvY01hbmFnZXIgPSBkb2NNYW5hZ2VyO1xuICAgICAgICB0aGlzLmlkID0gJ3NpbXBsZS1zaWRlYmFyJztcbiAgICAgICAgdGhpcy50aXRsZS5sYWJlbCA9ICcnO1xuICAgICAgICB0aGlzLnRpdGxlLmNhcHRpb24gPSAnQUkgQ2hhdCBJbnRlcmZhY2UnO1xuICAgICAgICB0aGlzLnRpdGxlLmljb24gPSBpY29uc18xLmV4dGVuc2lvbkljb247XG4gICAgICAgIHRoaXMudGl0bGUuY2xvc2FibGUgPSB0cnVlO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNvbnRhaW5lciBlbGVtZW50cyBiZWZvcmUgY3JlYXRpbmcgbGF5b3V0XG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRoaXMuaW5wdXRGaWVsZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgIHRoaXMudGl0bGVJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAvLyBDcmVhdGUga2V5Ym9hcmQgc2hvcnRjdXQgaW5kaWNhdG9yIGZvciB1c2VyIGZlZWRiYWNrXG4gICAgICAgIHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NOYW1lID0gJ2tleWJvYXJkLXNob3J0Y3V0LWluZGljYXRvcic7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBtb2R1bGFyIGNvbXBvbmVudHNcbiAgICAgICAgdGhpcy5pbml0aWFsaXplTW9kdWxhckNvbXBvbmVudHMoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IGNoYXQgb24gc3RhcnRcbiAgICAgICAgdGhpcy5jaGF0SGlzdG9yeU1hbmFnZXIuY3JlYXRlTmV3Q2hhdCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUoKTtcbiAgICAgICAgLy8gQ3JlYXRlIGFuZCBhZGQgdGhlIG1haW4gbGF5b3V0XG4gICAgICAgIHRoaXMubm9kZS5hcHBlbmRDaGlsZCh0aGlzLmNyZWF0ZUxheW91dCgpKTtcbiAgICAgICAgLy8gQWRkIGtleWJvYXJkIHNob3J0Y3V0IGxpc3RlbmVyIGZvciBpbXByb3ZlZCBVWFxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5oYW5kbGVLZXlEb3duKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYWxsIG1vZHVsYXIgY29tcG9uZW50c1xuICAgICAqL1xuICAgIGluaXRpYWxpemVNb2R1bGFyQ29tcG9uZW50cygpIHtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBjaGF0IGhpc3RvcnkgbWFuYWdlclxuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5TWFuYWdlciA9IG5ldyBjaGF0X2hpc3RvcnlfbWFuYWdlcl8xLkNoYXRIaXN0b3J5TWFuYWdlcigpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGZpbGUgYnJvd3NlciBtYW5hZ2VyXG4gICAgICAgIHRoaXMuZmlsZUJyb3dzZXJNYW5hZ2VyID0gbmV3IGZpbGVfYnJvd3Nlcl9tYW5hZ2VyXzEuRmlsZUJyb3dzZXJNYW5hZ2VyKHRoaXMuZG9jTWFuYWdlcik7XG4gICAgICAgIC8vIEluaXRpYWxpemUgbWVzc2FnZSByZW5kZXJlclxuICAgICAgICB0aGlzLm1lc3NhZ2VSZW5kZXJlciA9IG5ldyBtZXNzYWdlX3JlbmRlcmVyXzEuTWVzc2FnZVJlbmRlcmVyKHRoaXMubWVzc2FnZUNvbnRhaW5lciwgdGhpcy5jb3B5TWVzc2FnZVRvQ2xpcGJvYXJkLmJpbmQodGhpcyksIHRoaXMuYWRkTWVzc2FnZVRvQ2VsbC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBpbnB1dCBoYW5kbGVyXG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyID0gbmV3IGlucHV0X2hhbmRsZXJfMS5JbnB1dEhhbmRsZXIodGhpcy5pbnB1dEZpZWxkLCB0aGlzLmlucHV0Q29udGFpbmVyLCB0aGlzLmhhbmRsZVNlbmRNZXNzYWdlLmJpbmQodGhpcykpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHBvcHVwIG1lbnUgbWFuYWdlclxuICAgICAgICB0aGlzLnBvcHVwTWVudU1hbmFnZXIgPSBuZXcgcG9wdXBfbWVudV9tYW5hZ2VyXzEuUG9wdXBNZW51TWFuYWdlcih0aGlzLmZpbGVCcm93c2VyTWFuYWdlciwgdGhpcy5hcHBlbmRUb0lucHV0LmJpbmQodGhpcykpO1xuICAgICAgICAvLyBJbml0aWFsaXplIHNldHRpbmdzIG1hbmFnZXJcbiAgICAgICAgdGhpcy5zZXR0aW5nc01hbmFnZXIgPSBuZXcgc2V0dGluZ3NfbWFuYWdlcl8xLlNldHRpbmdzTWFuYWdlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTaG93cyBhIHZpc3VhbCBpbmRpY2F0b3IgZm9yIGtleWJvYXJkIHNob3J0Y3V0cy5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBkaXNwbGF5IGluIHRoZSBpbmRpY2F0b3IuXG4gICAgICovXG4gICAgc2hvd0tleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IodGV4dCkge1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IudGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyBIaWRlIGFmdGVyIDEgc2Vjb25kXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5rZXlib2FyZFNob3J0Y3V0SW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoJ3Zpc2libGUnKTtcbiAgICAgICAgfSwgMTAwMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3Bvc2VzIGFsbCByZXNvdXJjZXMgd2hlbiB0aGUgd2lkZ2V0IGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICAvLyBSZW1vdmUga2V5Ym9hcmQgc2hvcnRjdXQgbGlzdGVuZXJcbiAgICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHRoaXMuaGFuZGxlS2V5RG93bik7XG4gICAgICAgIC8vIFJlbW92ZSBrZXlib2FyZCBzaG9ydGN1dCBpbmRpY2F0b3JcbiAgICAgICAgaWYgKHRoaXMua2V5Ym9hcmRTaG9ydGN1dEluZGljYXRvci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmtleWJvYXJkU2hvcnRjdXRJbmRpY2F0b3IpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERpc3Bvc2UgbW9kdWxhciBjb21wb25lbnRzXG4gICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5kaXNwb3NlKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3NNYW5hZ2VyLmRpc3Bvc2UoKTtcbiAgICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHRoZSBtYWluIGxheW91dCBmb3IgdGhlIHNpZGViYXIgd2lkZ2V0LlxuICAgICAqIEluY2x1ZGVzIHRoZSB0aXRsZSBpbnB1dCwgbWVzc2FnZSBjb250YWluZXIsIGhpc3RvcnkgY29udGFpbmVyLCBpbnB1dCBmaWVsZCwgYW5kIGNvbnRyb2xzLlxuICAgICAqIEByZXR1cm5zIFRoZSBtYWluIGNvbnRlbnQgZWxlbWVudCBvZiB0aGUgd2lkZ2V0LlxuICAgICAqL1xuICAgIGNyZWF0ZUxheW91dCgpIHtcbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBtYWluIGNvbnRhaW5lclxuICAgICAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWNvbnRhaW5lcic7XG4gICAgICAgIC8vIENyZWF0ZSB0aXRsZSBpbnB1dCBjb250YWluZXJcbiAgICAgICAgY29uc3QgdGl0bGVDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdGl0bGUtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LXRpdGxlLWlucHV0JztcbiAgICAgICAgdGhpcy50aXRsZUlucHV0LnBsYWNlaG9sZGVyID0gJ0NoYXQgVGl0bGUnO1xuICAgICAgICB0aGlzLnRpdGxlSW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGF0SGlzdG9yeU1hbmFnZXIudXBkYXRlQ3VycmVudENoYXRUaXRsZSh0aGlzLnRpdGxlSW5wdXQudmFsdWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGl0bGVDb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy50aXRsZUlucHV0KTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRpdGxlQ29udGFpbmVyKTtcbiAgICAgICAgLy8gQ29uZmlndXJlIG1lc3NhZ2UgY29udGFpbmVyXG4gICAgICAgIHRoaXMubWVzc2FnZUNvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1tZXNzYWdlLWNvbnRhaW5lcic7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLm1lc3NhZ2VDb250YWluZXIpO1xuICAgICAgICAvLyBDb25maWd1cmUgaGlzdG9yeSBjb250YWluZXJcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7IC8vIEluaXRpYWxseSBoaWRkZW5cbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaGlzdG9yeUNvbnRhaW5lcik7XG4gICAgICAgIC8vIENyZWF0ZSBpbnB1dCBhcmVhXG4gICAgICAgIGNvbnN0IGlucHV0QXJlYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICBpbnB1dEFyZWEuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtYXJlYSc7XG4gICAgICAgIC8vIENvbmZpZ3VyZSBpbnB1dCBjb250YWluZXIgYW5kIGZpZWxkXG4gICAgICAgIHRoaXMuaW5wdXRDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaW5wdXQtY29udGFpbmVyJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWlucHV0LWZpZWxkJztcbiAgICAgICAgdGhpcy5pbnB1dEZpZWxkLnBsYWNlaG9sZGVyID0gJ1R5cGUgeW91ciBtZXNzYWdlIGhlcmUuLi4nO1xuICAgICAgICB0aGlzLmlucHV0Q29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuaW5wdXRGaWVsZCk7XG4gICAgICAgIGlucHV0QXJlYS5hcHBlbmRDaGlsZCh0aGlzLmlucHV0Q29udGFpbmVyKTtcbiAgICAgICAgLy8gQWRkIGNvbnRyb2xzIGNvbnRhaW5lclxuICAgICAgICBpbnB1dEFyZWEuYXBwZW5kQ2hpbGQodGhpcy5jcmVhdGVDb250cm9sc0NvbnRhaW5lcigpKTtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGlucHV0QXJlYSk7XG4gICAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIGNvbnRyb2xzIGNvbnRhaW5lciB3aXRoIHRvZ2dsZXMgYW5kIGFjdGlvbiBidXR0b25zLlxuICAgICAqIEluY2x1ZGVzIHRoZSBNYXJrZG93biB0b2dnbGUsIGV4cGFuZCBpbnB1dCBidXR0b24sIHNldHRpbmdzIGJ1dHRvbiwgYW5kIHBvcHVwIG1lbnUgYnV0dG9uLlxuICAgICAqIEByZXR1cm5zIFRoZSBjb250cm9scyBjb250YWluZXIgZWxlbWVudC5cbiAgICAgKi9cbiAgICBjcmVhdGVDb250cm9sc0NvbnRhaW5lcigpIHtcbiAgICAgICAgY29uc3QgY29udHJvbHNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udHJvbHNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtY29udHJvbHMtY29udGFpbmVyJztcbiAgICAgICAgLy8gQ3JlYXRlIHRvZ2dsZSBidXR0b25zIGNvbnRhaW5lclxuICAgICAgICBjb25zdCB0b2dnbGVzQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIHRvZ2dsZXNDb250YWluZXIuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtdG9nZ2xlcy1jb250YWluZXInO1xuICAgICAgICAvLyBBZGQgTWFya2Rvd24gdG9nZ2xlIGJ1dHRvblxuICAgICAgICBjb25zdCBtYXJrZG93blRvZ2dsZSA9IHRoaXMuY3JlYXRlQnV0dG9uKCdNRCcsICdUb2dnbGUgTWFya2Rvd24gbW9kZScpO1xuICAgICAgICBtYXJrZG93blRvZ2dsZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLnRvZ2dsZU1hcmtkb3duTW9kZShtYXJrZG93blRvZ2dsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVzQ29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmtkb3duVG9nZ2xlKTtcbiAgICAgICAgLy8gQWRkIGV4cGFuZCBpbnB1dCBidXR0b25cbiAgICAgICAgY29uc3QgZXhwYW5kQnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oJ1xcdTI1YjInLCAnRXhwYW5kIGlucHV0IGZpZWxkJyk7XG4gICAgICAgIGV4cGFuZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLnRvZ2dsZUlucHV0RXhwYW5zaW9uKGV4cGFuZEJ1dHRvbik7XG4gICAgICAgIH0pO1xuICAgICAgICB0b2dnbGVzQ29udGFpbmVyLmFwcGVuZENoaWxkKGV4cGFuZEJ1dHRvbik7XG4gICAgICAgIGNvbnRyb2xzQ29udGFpbmVyLmFwcGVuZENoaWxkKHRvZ2dsZXNDb250YWluZXIpO1xuICAgICAgICAvLyBDcmVhdGUgYWN0aW9uIGJ1dHRvbnMgY29udGFpbmVyXG4gICAgICAgIGNvbnN0IGFjdGlvbnNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgYWN0aW9uc0NvbnRhaW5lci5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1hY3Rpb25zLWNvbnRhaW5lcic7XG4gICAgICAgIC8vIEFkZCBoaXN0b3J5IHRvZ2dsZSBidXR0b25cbiAgICAgICAgY29uc3QgaGlzdG9yeUJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKCdcXHVkODNkXFx1ZGNjMycsICdUb2dnbGUgY2hhdCBoaXN0b3J5Jyk7XG4gICAgICAgIGhpc3RvcnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRvZ2dsZUhpc3RvcnlWaWV3KCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhY3Rpb25zQ29udGFpbmVyLmFwcGVuZENoaWxkKGhpc3RvcnlCdXR0b24pO1xuICAgICAgICAvLyBBZGQgc2V0dGluZ3MgYnV0dG9uXG4gICAgICAgIGNvbnN0IHNldHRpbmdzQnV0dG9uID0gdGhpcy5jcmVhdGVCdXR0b24oJ1xcdTI2OTlcXHVmZTBmJywgJ1NldHRpbmdzJyk7XG4gICAgICAgIHNldHRpbmdzQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXR0aW5nc01hbmFnZXIuc2hvd1NldHRpbmdzTW9kYWwoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGFjdGlvbnNDb250YWluZXIuYXBwZW5kQ2hpbGQoc2V0dGluZ3NCdXR0b24pO1xuICAgICAgICAvLyBBZGQgc2VuZCBidXR0b25cbiAgICAgICAgY29uc3Qgc2VuZEJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKCdcXHUyN2E0JywgJ1NlbmQgbWVzc2FnZScpO1xuICAgICAgICBzZW5kQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5oYW5kbGVTZW5kTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgYWN0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZW5kQnV0dG9uKTtcbiAgICAgICAgLy8gQWRkIHBvcHVwIG1lbnUgYnV0dG9uIChcIkBcIiBidXR0b24pXG4gICAgICAgIGNvbnN0IHBvcHVwTWVudUJ1dHRvbiA9IHRoaXMuY3JlYXRlQnV0dG9uKCdAJywgJ0luc2VydCBjb250ZXh0Jyk7XG4gICAgICAgIHBvcHVwTWVudUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgLy8gR2V0IGJ1dHRvbiBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgcmVjdCA9IHBvcHVwTWVudUJ1dHRvbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIC8vIFNob3cgcG9wdXAgbWVudSBhdCBidXR0b24gcG9zaXRpb25cbiAgICAgICAgICAgIHRoaXMucG9wdXBNZW51TWFuYWdlci5zaG93UG9wdXBNZW51KHJlY3QubGVmdCwgcmVjdC5ib3R0b20pO1xuICAgICAgICB9KTtcbiAgICAgICAgYWN0aW9uc0NvbnRhaW5lci5hcHBlbmRDaGlsZChwb3B1cE1lbnVCdXR0b24pO1xuICAgICAgICBjb250cm9sc0NvbnRhaW5lci5hcHBlbmRDaGlsZChhY3Rpb25zQ29udGFpbmVyKTtcbiAgICAgICAgcmV0dXJuIGNvbnRyb2xzQ29udGFpbmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlIGEgYnV0dG9uIHdpdGggZ2l2ZW4gdGV4dCBhbmQgdG9vbHRpcC5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCB0byBkaXNwbGF5IG9uIHRoZSBidXR0b24uXG4gICAgICogQHBhcmFtIHRvb2x0aXAgVGhlIHRvb2x0aXAgdGV4dCB0byBkaXNwbGF5IG9uIGhvdmVyLlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIGJ1dHRvbiBlbGVtZW50LlxuICAgICAqL1xuICAgIGNyZWF0ZUJ1dHRvbih0ZXh0LCB0b29sdGlwKSB7XG4gICAgICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICBidXR0b24udGV4dENvbnRlbnQgPSB0ZXh0O1xuICAgICAgICBidXR0b24udGl0bGUgPSB0b29sdGlwO1xuICAgICAgICByZXR1cm4gYnV0dG9uO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIGJldHdlZW4gY2hhdCB2aWV3IGFuZCBoaXN0b3J5IHZpZXcuXG4gICAgICogVXBkYXRlcyB0aGUgVUkgdG8gc2hvdyBlaXRoZXIgdGhlIGNoYXQgbWVzc2FnZXMgb3IgdGhlIGNoYXQgaGlzdG9yeSBsaXN0LlxuICAgICAqL1xuICAgIHRvZ2dsZUhpc3RvcnlWaWV3KCkge1xuICAgICAgICB0aGlzLmlzSGlzdG9yeVZpZXdBY3RpdmUgPSAhdGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlO1xuICAgICAgICBpZiAodGhpcy5pc0hpc3RvcnlWaWV3QWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBTaG93IGhpc3Rvcnkgdmlld1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckNoYXRIaXN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBTaG93IGNoYXQgdmlld1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlQ29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVuZGVycyB0aGUgY2hhdCBoaXN0b3J5IGluIHRoZSBoaXN0b3J5IGNvbnRhaW5lci5cbiAgICAgKiBDcmVhdGVzIGEgbGlzdCBvZiBjaGF0IGhpc3RvcnkgaXRlbXMgYW5kIHBvcHVsYXRlcyB0aGUgaGlzdG9yeSBjb250YWluZXIuXG4gICAgICovXG4gICAgcmVuZGVyQ2hhdEhpc3RvcnkoKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeUNvbnRhaW5lci5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgY29uc3QgY2hhdHMgPSB0aGlzLmNoYXRIaXN0b3J5TWFuYWdlci5nZXRBbGxDaGF0cygpO1xuICAgICAgICAvLyBDcmVhdGUgbmV3IGNoYXQgYnV0dG9uXG4gICAgICAgIGNvbnN0IG5ld0NoYXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgbmV3Q2hhdEJ1dHRvbi5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWl0ZW0ganAtbGxtLWV4dC1uZXctY2hhdCc7XG4gICAgICAgIG5ld0NoYXRCdXR0b24udGV4dENvbnRlbnQgPSAnKyBOZXcgQ2hhdCc7XG4gICAgICAgIG5ld0NoYXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZU5ld0NoYXQoKTtcbiAgICAgICAgICAgIHRoaXMudG9nZ2xlSGlzdG9yeVZpZXcoKTsgLy8gU3dpdGNoIGJhY2sgdG8gY2hhdCB2aWV3XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmhpc3RvcnlDb250YWluZXIuYXBwZW5kQ2hpbGQobmV3Q2hhdEJ1dHRvbik7XG4gICAgICAgIGlmIChjaGF0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGNvbnN0IGVtcHR5TWVzc2FnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgZW1wdHlNZXNzYWdlLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktZW1wdHknO1xuICAgICAgICAgICAgZW1wdHlNZXNzYWdlLnRleHRDb250ZW50ID0gJ05vIGNoYXQgaGlzdG9yeSB5ZXQnO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmFwcGVuZENoaWxkKGVtcHR5TWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbGlzdCBpdGVtIGZvciBlYWNoIGNoYXRcbiAgICAgICAgY2hhdHMuZm9yRWFjaChjaGF0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNoYXRJdGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjaGF0SXRlbS5jbGFzc05hbWUgPSAnanAtbGxtLWV4dC1oaXN0b3J5LWl0ZW0nO1xuICAgICAgICAgICAgaWYgKGNoYXQuaWQgPT09IHRoaXMuY2hhdEhpc3RvcnlNYW5hZ2VyLmdldEN1cnJlbnRDaGF0SWQoKSkge1xuICAgICAgICAgICAgICAgIGNoYXRJdGVtLmNsYXNzTGlzdC5hZGQoJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtLWFjdGl2ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhdFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICBjaGF0VGl0bGUuY2xhc3NOYW1lID0gJ2pwLWxsbS1leHQtaGlzdG9yeS1pdGVtLXRpdGxlJztcbiAgICAgICAgICAgIGNoYXRUaXRsZS50ZXh0Q29udGVudCA9IGNoYXQudGl0bGU7XG4gICAgICAgICAgICBjaGF0SXRlbS5hcHBlbmRDaGlsZChjaGF0VGl0bGUpO1xuICAgICAgICAgICAgY29uc3QgY2hhdEluZm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGNoYXRJbmZvLmNsYXNzTmFtZSA9ICdqcC1sbG0tZXh0LWhpc3RvcnktaXRlbS1pbmZvJztcbiAgICAgICAgICAgIGNoYXRJbmZvLnRleHRDb250ZW50ID0gYCR7Y2hhdC5tZXNzYWdlcy5sZW5ndGh9IG1lc3NhZ2VzYDtcbiAgICAgICAgICAgIGNoYXRJdGVtLmFwcGVuZENoaWxkKGNoYXRJbmZvKTtcbiAgICAgICAgICAgIGNoYXRJdGVtLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMubG9hZENoYXQoY2hhdC5pZCk7XG4gICAgICAgICAgICAgICAgdGhpcy50b2dnbGVIaXN0b3J5VmlldygpOyAvLyBTd2l0Y2ggYmFjayB0byBjaGF0IHZpZXdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5Q29udGFpbmVyLmFwcGVuZENoaWxkKGNoYXRJdGVtKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgY2hhdCBzZXNzaW9uLlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRCwgY3JlYXRlcyBhIG5ldyBjaGF0IGl0ZW0sIGFkZHMgaXQgdG8gaGlzdG9yeSwgYW5kIHVwZGF0ZXMgdGhlIFVJLlxuICAgICAqL1xuICAgIGNyZWF0ZU5ld0NoYXQoKSB7XG4gICAgICAgIC8vIENyZWF0ZSBuZXcgY2hhdCB1c2luZyB0aGUgbWFuYWdlclxuICAgICAgICB0aGlzLmNoYXRIaXN0b3J5TWFuYWdlci5jcmVhdGVOZXdDaGF0KCk7XG4gICAgICAgIC8vIFVwZGF0ZSBVSVxuICAgICAgICB0aGlzLnVwZGF0ZUN1cnJlbnRDaGF0VGl0bGUoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlUmVuZGVyZXIuY2xlYXJNZXNzYWdlcygpO1xuICAgICAgICAvLyBBZGQgd2VsY29tZSBtZXNzYWdlXG4gICAgICAgIHRoaXMuYWRkTWVzc2FnZSgnV2VsY29tZSB0byB0aGUgQUkgQ2hhdCBJbnRlcmZhY2UuIEhvdyBjYW4gSSBoZWxwIHlvdSB0b2RheT8nLCAnYm90JywgdHJ1ZSwgZmFsc2UgLy8gRG9uJ3Qgc2F2ZSB3ZWxjb21lIG1lc3NhZ2UgdG8gaGlzdG9yeVxuICAgICAgICApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2FkcyBhIGNoYXQgZnJvbSBoaXN0b3J5LlxuICAgICAqIFVwZGF0ZXMgdGhlIFVJIHRvIHNob3cgdGhlIHNlbGVjdGVkIGNoYXQncyBtZXNzYWdlcyBhbmQgdGl0bGUuXG4gICAgICogQHBhcmFtIGNoYXRJZCBUaGUgSUQgb2YgdGhlIGNoYXQgdG8gbG9hZC5cbiAgICAgKi9cbiAgICBsb2FkQ2hhdChjaGF0SWQpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnlNYW5hZ2VyLmxvYWRDaGF0KGNoYXRJZCk7XG4gICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICAvLyBVcGRhdGUgVUlcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQ3VycmVudENoYXRUaXRsZSgpO1xuICAgICAgICAgICAgdGhpcy5tZXNzYWdlUmVuZGVyZXIucmVuZGVyTWVzc2FnZXMoY2hhdC5tZXNzYWdlcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgdGl0bGUgb2YgdGhlIGN1cnJlbnQgY2hhdC5cbiAgICAgKiBVcGRhdGVzIHRoZSB0aXRsZSBpbnB1dCBmaWVsZCB3aXRoIHRoZSBuZXcgdGl0bGUuXG4gICAgICovXG4gICAgdXBkYXRlQ3VycmVudENoYXRUaXRsZSgpIHtcbiAgICAgICAgY29uc3QgY2hhdCA9IHRoaXMuY2hhdEhpc3RvcnlNYW5hZ2VyLmdldEN1cnJlbnRDaGF0KCk7XG4gICAgICAgIGlmIChjaGF0KSB7XG4gICAgICAgICAgICB0aGlzLnRpdGxlSW5wdXQudmFsdWUgPSBjaGF0LnRpdGxlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgc2VuZGluZyBhIG1lc3NhZ2UgZnJvbSB0aGUgaW5wdXQgZmllbGQuXG4gICAgICogU2VuZHMgdGhlIG1lc3NhZ2UgdG8gdGhlIEFQSSwgdXBkYXRlcyB0aGUgVUkgd2l0aCB0aGUgcmVzcG9uc2UsIGFuZCBzYXZlcyB0aGUgbWVzc2FnZSB0byBjaGF0IGhpc3RvcnkuXG4gICAgICovXG4gICAgaGFuZGxlU2VuZE1lc3NhZ2UoKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLmlucHV0SGFuZGxlci5nZXRJbnB1dFRleHQoKS50cmltKCk7XG4gICAgICAgIGlmICghbWVzc2FnZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gQWRkIHVzZXIgbWVzc2FnZSB0byBVSVxuICAgICAgICB0aGlzLmFkZE1lc3NhZ2UobWVzc2FnZSwgJ3VzZXInLCBmYWxzZSk7XG4gICAgICAgIC8vIENsZWFyIGlucHV0IGZpZWxkXG4gICAgICAgIHRoaXMuaW5wdXRIYW5kbGVyLmNsZWFySW5wdXQoKTtcbiAgICAgICAgLy8gQWRkIHRlbXBvcmFyeSBcInRoaW5raW5nXCIgbWVzc2FnZVxuICAgICAgICBjb25zdCB0aGlua2luZ01lc3NhZ2UgPSB0aGlzLmFkZE1lc3NhZ2UoJ1RoaW5raW5nLi4uJywgJ2JvdCcsIGZhbHNlLCBmYWxzZSk7XG4gICAgICAgIC8vIFNlbmQgbWVzc2FnZSB0byBBUEkgKG1vY2sgaW1wbGVtZW50YXRpb24gZm9yIG5vdylcbiAgICAgICAgdGhpcy5tb2NrU2VuZE1lc3NhZ2UobWVzc2FnZSlcbiAgICAgICAgICAgIC50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaW5raW5nIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmICh0aGlua2luZ01lc3NhZ2UgJiYgdGhpbmtpbmdNZXNzYWdlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlua2luZ01lc3NhZ2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlua2luZ01lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGJvdCByZXNwb25zZVxuICAgICAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHJlc3BvbnNlLCAnYm90JywgdHJ1ZSk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBzZW5kaW5nIG1lc3NhZ2U6JywgZXJyb3IpO1xuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoaW5raW5nIG1lc3NhZ2VcbiAgICAgICAgICAgIGlmICh0aGlua2luZ01lc3NhZ2UgJiYgdGhpbmtpbmdNZXNzYWdlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlua2luZ01lc3NhZ2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlua2luZ01lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZSgnU29ycnksIHRoZXJlIHdhcyBhbiBlcnJvciBwcm9jZXNzaW5nIHlvdXIgcmVxdWVzdC4gUGxlYXNlIHRyeSBhZ2Fpbi4nLCAnYm90JywgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9jayBpbXBsZW1lbnRhdGlvbiBvZiBzZW5kaW5nIGEgbWVzc2FnZSB0byB0aGUgQVBJXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIHRoZSByZXNwb25zZVxuICAgICAqL1xuICAgIG1vY2tTZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgLy8gU2ltdWxhdGUgYSBkZWxheVxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShgSSByZWNlaXZlZCB5b3VyIG1lc3NhZ2U6IFwiJHttZXNzYWdlfVwiLiBUaGlzIGlzIGEgbW9jayByZXNwb25zZS5gKTtcbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG1lc3NhZ2UgdG8gdGhlIGNoYXQgaW50ZXJmYWNlLlxuICAgICAqIENyZWF0ZXMgYSBuZXcgbWVzc2FnZSBlbGVtZW50IGFuZCBhcHBlbmRzIGl0IHRvIHRoZSBtZXNzYWdlIGNvbnRhaW5lci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgdGV4dCBjb250ZW50IG9mIHRoZSBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSBzZW5kZXIgVGhlIHNlbmRlciBvZiB0aGUgbWVzc2FnZSAoJ3VzZXInIG9yICdib3QnKS5cbiAgICAgKiBAcGFyYW0gaXNNYXJrZG93biBXaGV0aGVyIHRoZSBtZXNzYWdlIGlzIGluIE1hcmtkb3duIGZvcm1hdC5cbiAgICAgKiBAcGFyYW0gc2F2ZVRvSGlzdG9yeSBXaGV0aGVyIHRvIHNhdmUgdGhlIG1lc3NhZ2UgdG8gY2hhdCBoaXN0b3J5LlxuICAgICAqIEByZXR1cm5zIFRoZSBjcmVhdGVkIG1lc3NhZ2UgZWxlbWVudC5cbiAgICAgKi9cbiAgICBhZGRNZXNzYWdlKHRleHQsIHNlbmRlciwgaXNNYXJrZG93biA9IGZhbHNlLCBzYXZlVG9IaXN0b3J5ID0gdHJ1ZSkge1xuICAgICAgICAvLyBTYXZlIHRvIGNoYXQgaGlzdG9yeSBpZiBuZWVkZWRcbiAgICAgICAgaWYgKHNhdmVUb0hpc3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuY2hhdEhpc3RvcnlNYW5hZ2VyLmFkZE1lc3NhZ2UodGV4dCwgc2VuZGVyLCBpc01hcmtkb3duKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5kZXIgdGhlIG1lc3NhZ2VcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVJlbmRlcmVyLnJlbmRlck1lc3NhZ2UodGV4dCwgc2VuZGVyLCBpc01hcmtkb3duKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29waWVzIG1lc3NhZ2UgY29udGVudCB0byBjbGlwYm9hcmQuXG4gICAgICogQHBhcmFtIHRleHQgVGhlIHRleHQgY29udGVudCB0byBjb3B5LlxuICAgICAqL1xuICAgIGNvcHlNZXNzYWdlVG9DbGlwYm9hcmQodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmF2aWdhdG9yLmNsaXBib2FyZC53cml0ZVRleHQodGV4dClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1RleHQgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdGYWlsZWQgdG8gY29weSB0ZXh0OiAnLCBlcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tDb3B5VG9DbGlwYm9hcmQodGV4dCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0NvcHkgdG8gY2xpcGJvYXJkIGVycm9yOicsIGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMuZmFsbGJhY2tDb3B5VG9DbGlwYm9hcmQodGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRmFsbGJhY2sgbWV0aG9kIGZvciBjb3B5aW5nIHRvIGNsaXBib2FyZCB1c2luZyBhIHRlbXBvcmFyeSB0ZXh0YXJlYSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGNvcHkuXG4gICAgICovXG4gICAgZmFsbGJhY2tDb3B5VG9DbGlwYm9hcmQodGV4dCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgdGV4dEFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICAgICAgdGV4dEFyZWEudmFsdWUgPSB0ZXh0O1xuICAgICAgICAgICAgdGV4dEFyZWEuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0ZXh0QXJlYSk7XG4gICAgICAgICAgICB0ZXh0QXJlYS5mb2N1cygpO1xuICAgICAgICAgICAgdGV4dEFyZWEuc2VsZWN0KCk7XG4gICAgICAgICAgICBkb2N1bWVudC5leGVjQ29tbWFuZCgnY29weScpO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZCh0ZXh0QXJlYSk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnRmFsbGJhY2s6IFRleHQgY29waWVkIHRvIGNsaXBib2FyZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFsbGJhY2s6IENvdWxkIG5vdCBjb3B5IHRleHQ6ICcsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIG1lc3NhZ2UgY29udGVudCB0byB0aGUgY3VycmVudCBjZWxsLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IGNvbnRlbnQgdG8gYWRkLlxuICAgICAqL1xuICAgIGFkZE1lc3NhZ2VUb0NlbGwodGV4dCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNlbGwgPSAoX2EgPSBnbG9iYWxzXzEuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5hY3RpdmVDZWxsO1xuICAgICAgICBpZiAoIWNlbGwpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGFjdGl2ZSBjZWxsIGZvdW5kJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIEdldCBjdXJyZW50IGNvbnRlbnQgYW5kIGN1cnNvciBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gY2VsbC5lZGl0b3I7XG4gICAgICAgICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGVkaXRvciBmb3VuZCBpbiBjZWxsJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcG9zaXRpb24gPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRUZXh0ID0gZWRpdG9yLm1vZGVsLnNoYXJlZE1vZGVsLmdldFNvdXJjZSgpO1xuICAgICAgICAgICAgLy8gSW5zZXJ0IHRleHQgYXQgY3Vyc29yIHBvc2l0aW9uXG4gICAgICAgICAgICBjb25zdCBiZWZvcmVDdXJzb3IgPSBjdXJyZW50VGV4dC5zdWJzdHJpbmcoMCwgcG9zaXRpb24uY29sdW1uKTtcbiAgICAgICAgICAgIGNvbnN0IGFmdGVyQ3Vyc29yID0gY3VycmVudFRleHQuc3Vic3RyaW5nKHBvc2l0aW9uLmNvbHVtbik7XG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgd2UgbmVlZCB0byBhZGQgbmV3bGluZXNcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzTGVhZGluZ05ld2xpbmUgPSBiZWZvcmVDdXJzb3IubGVuZ3RoID4gMCAmJiAhYmVmb3JlQ3Vyc29yLmVuZHNXaXRoKCdcXG4nKTtcbiAgICAgICAgICAgIGNvbnN0IG5lZWRzVHJhaWxpbmdOZXdsaW5lID0gYWZ0ZXJDdXJzb3IubGVuZ3RoID4gMCAmJiAhYWZ0ZXJDdXJzb3Iuc3RhcnRzV2l0aCgnXFxuJyk7XG4gICAgICAgICAgICBsZXQgaW5zZXJ0VGV4dCA9ICcnO1xuICAgICAgICAgICAgaWYgKG5lZWRzTGVhZGluZ05ld2xpbmUpXG4gICAgICAgICAgICAgICAgaW5zZXJ0VGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIGluc2VydFRleHQgKz0gdGV4dDtcbiAgICAgICAgICAgIGlmIChuZWVkc1RyYWlsaW5nTmV3bGluZSlcbiAgICAgICAgICAgICAgICBpbnNlcnRUZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgLy8gU2V0IHRoZSBuZXcgdGV4dFxuICAgICAgICAgICAgZWRpdG9yLm1vZGVsLnNoYXJlZE1vZGVsLnNldFNvdXJjZShiZWZvcmVDdXJzb3IgKyBpbnNlcnRUZXh0ICsgYWZ0ZXJDdXJzb3IpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHRleHQgdG8gY2VsbDonLCBlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwZW5kcyB0ZXh0IHRvIHRoZSBpbnB1dCBmaWVsZCB3aXRoIHByb3BlciBzcGFjaW5nLlxuICAgICAqIEBwYXJhbSB0ZXh0IFRoZSB0ZXh0IHRvIGFwcGVuZC5cbiAgICAgKi9cbiAgICBhcHBlbmRUb0lucHV0KHRleHQpIHtcbiAgICAgICAgdGhpcy5pbnB1dEhhbmRsZXIuYXBwZW5kVG9JbnB1dCh0ZXh0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc2VsZWN0ZWQgdGV4dCBmcm9tIGNlbGwgY29udGV4dC5cbiAgICAgKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgdGV4dCBvciBhbiBlbXB0eSBzdHJpbmcgaWYgbm8gc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGVkVGV4dCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBHZXQgdGhlIGN1cnJlbnQgYWN0aXZlIGNlbGwgZnJvbSB0aGUgdHJhY2tlclxuICAgICAgICBjb25zdCBjZWxsID0gKF9hID0gZ2xvYmFsc18xLmdsb2JhbHMubm90ZWJvb2tUcmFja2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWN0aXZlQ2VsbDtcbiAgICAgICAgaWYgKCFjZWxsKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAvLyBHZXQgdGhlIHNlbGVjdGVkIHRleHQgZnJvbSB0aGUgZWRpdG9yXG4gICAgICAgIGNvbnN0IGVkaXRvciA9IGNlbGwuZWRpdG9yO1xuICAgICAgICBpZiAoIWVkaXRvcilcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbilcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgLy8gRXh0cmFjdCB0aGUgc2VsZWN0ZWQgdGV4dFxuICAgICAgICBjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlbGVjdGlvbjtcbiAgICAgICAgY29uc3QgdGV4dCA9IGVkaXRvci5tb2RlbC5zaGFyZWRNb2RlbC5nZXRTb3VyY2UoKTtcbiAgICAgICAgY29uc3QgbGluZXMgPSB0ZXh0LnNwbGl0KCdcXG4nKTtcbiAgICAgICAgLy8gSWYgc2VsZWN0aW9uIGlzIHdpdGhpbiBhIHNpbmdsZSBsaW5lXG4gICAgICAgIGlmIChzdGFydC5saW5lID09PSBlbmQubGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmVzW3N0YXJ0LmxpbmVdLnN1YnN0cmluZyhzdGFydC5jb2x1bW4sIGVuZC5jb2x1bW4pO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHNlbGVjdGlvbiBzcGFucyBtdWx0aXBsZSBsaW5lc1xuICAgICAgICBsZXQgc2VsZWN0ZWRUZXh0ID0gbGluZXNbc3RhcnQubGluZV0uc3Vic3RyaW5nKHN0YXJ0LmNvbHVtbikgKyAnXFxuJztcbiAgICAgICAgZm9yIChsZXQgaSA9IHN0YXJ0LmxpbmUgKyAxOyBpIDwgZW5kLmxpbmU7IGkrKykge1xuICAgICAgICAgICAgc2VsZWN0ZWRUZXh0ICs9IGxpbmVzW2ldICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgICAgc2VsZWN0ZWRUZXh0ICs9IGxpbmVzW2VuZC5saW5lXS5zdWJzdHJpbmcoMCwgZW5kLmNvbHVtbik7XG4gICAgICAgIHJldHVybiBzZWxlY3RlZFRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgdGhlIGNvZGUgY29tbWFuZCAtIGluc2VydHMgc2VsZWN0ZWQgY29kZS5cbiAgICAgKi9cbiAgICBoYW5kbGVDb2RlQ29tbWFuZCgpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gdGhpcy5nZXRTZWxlY3RlZFRleHQoKTtcbiAgICAgICAgaWYgKHNlbGVjdGVkVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5hcHBlbmRUb0lucHV0KHNlbGVjdGVkVGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gY29kZSBzZWxlY3RlZCcpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TaW1wbGVTaWRlYmFyV2lkZ2V0ID0gU2ltcGxlU2lkZWJhcldpZGdldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWdpc3RlckNvbW1hbmRzID0gcmVnaXN0ZXJDb21tYW5kcztcbmNvbnN0IGljb25zXzEgPSByZXF1aXJlKFwiLi9pY29uc1wiKTtcbi8qKlxuICogUmVnaXN0ZXJzIGNvbW1hbmRzIGZvciB0aGUgZXh0ZW5zaW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQ29tbWFuZHMoYXBwLCBwYWxldHRlLCBsYXVuY2hlciwgc2lkZWJhcldpZGdldCkge1xuICAgIC8vIEFkZCBjb21tYW5kIHRvIHRvZ2dsZSB0aGUgc2lkZWJhclxuICAgIGFwcC5jb21tYW5kcy5hZGRDb21tYW5kKCdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJywge1xuICAgICAgICBsYWJlbDogJ1RvZ2dsZSBBSSBBc3Npc3RhbnQgU2lkZWJhcicsXG4gICAgICAgIGljb246IGljb25zXzEuZXh0ZW5zaW9uSWNvbixcbiAgICAgICAgZXhlY3V0ZTogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHNpZGViYXJXaWRnZXQuaXNBdHRhY2hlZCkge1xuICAgICAgICAgICAgICAgIHNpZGViYXJXaWRnZXQucGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBBZGQgdGhlIGNvbW1hbmQgdG8gdGhlIGNvbW1hbmQgcGFsZXR0ZVxuICAgIHBhbGV0dGUuYWRkSXRlbSh7XG4gICAgICAgIGNvbW1hbmQ6ICdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdFeHRlbnNpb24nXG4gICAgfSk7XG4gICAgLy8gQWRkIGEgbGF1bmNoZXIgaXRlbVxuICAgIGxhdW5jaGVyLmFkZCh7XG4gICAgICAgIGNvbW1hbmQ6ICdzaW1wbGUtZXh0ZW5zaW9uOnRvZ2dsZS1zaWRlYmFyJyxcbiAgICAgICAgY2F0ZWdvcnk6ICdPdGhlcicsXG4gICAgICAgIHJhbms6IDk5OTlcbiAgICB9KTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nbG9iYWxzID0gdm9pZCAwO1xuZXhwb3J0cy5pbml0R2xvYmFscyA9IGluaXRHbG9iYWxzO1xuLyoqXG4gKiBHbG9iYWwgcmVmZXJlbmNlcyB0byBrZXkgY29tcG9uZW50cyBpbiB0aGUgYXBwbGljYXRpb25cbiAqL1xuZXhwb3J0cy5nbG9iYWxzID0ge307XG4vKipcbiAqIEluaXRpYWxpemUgZ2xvYmFsIHJlZmVyZW5jZXNcbiAqL1xuZnVuY3Rpb24gaW5pdEdsb2JhbHMoYXBwLCBub3RlYm9va1RyYWNrZXIpIHtcbiAgICBleHBvcnRzLmdsb2JhbHMuYXBwID0gYXBwO1xuICAgIGV4cG9ydHMuZ2xvYmFscy5ub3RlYm9va1RyYWNrZXIgPSBub3RlYm9va1RyYWNrZXI7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXh0ZW5zaW9uSWNvbiA9IHZvaWQgMDtcbmNvbnN0IHVpX2NvbXBvbmVudHNfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi91aS1jb21wb25lbnRzXCIpO1xuLy8gPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gSWNvbiBEZWZpbml0aW9uXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG5jb25zdCBpY29uU3ZnU3RyID0gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiIHdpZHRoPVwiMTZcIiBoZWlnaHQ9XCIxNlwiIGZpbGw9XCJjdXJyZW50Q29sb3JcIiBjbGFzcz1cImJpIGJpLWNoYXQtbGVmdC10ZXh0XCIgdmlld0JveD1cIjAgMCAxNiAxNlwiPicgK1xuICAgICc8cGF0aCBkPVwiTTE0IDFhMSAxIDAgMCAxIDEgMXY4YTEgMSAwIDAgMS0xIDFINC40MTRBMiAyIDAgMCAwIDMgMTEuNTg2bC0yIDJWMmExIDEgMCAwIDEgMS0xaDEyek0yIDBhMiAyIDAgMCAwLTIgMnYxMi43OTNhLjUuNSAwIDAgMCAuODU0LjM1M2wyLjg1My0yLjg1M0ExIDEgMCAwIDEgNC40MTQgMTJIMTRhMiAyIDAgMCAwIDItMlYyYTIgMiAwIDAgMC0yLTJIMnpcIi8+JyArXG4gICAgJzxwYXRoIGQ9XCJNMyAzLjVhLjUuNSAwIDAgMSAuNS0uNWg5YS41LjUgMCAwIDEgMCAxaC05YS41LjUgMCAwIDEtLjUtLjV6TTMgNmEuNS41IDAgMCAxIC41LS41aDlhLjUuNSAwIDAgMSAwIDFoLTlBLjUuNSAwIDAgMSAzIDZ6bTAgMi41YS41LjUgMCAwIDEgLjUtLjVoNWEuNS41IDAgMCAxIDAgMWgtNWEuNS41IDAgMCAxLS41LS41elwiLz4nICtcbiAgICAnPC9zdmc+Jztcbi8qKlxuICogSWNvbiBmb3IgdGhlIEFJIEFzc2lzdGFudCBleHRlbnNpb25cbiAqL1xuZXhwb3J0cy5leHRlbnNpb25JY29uID0gbmV3IHVpX2NvbXBvbmVudHNfMS5MYWJJY29uKHtcbiAgICBuYW1lOiAnc2ltcGxlOmljb24nLFxuICAgIHN2Z3N0cjogaWNvblN2Z1N0clxufSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQXBpQ2xpZW50ID0gdm9pZCAwO1xuY29uc3QgbGF1bmNoZXJfMSA9IHJlcXVpcmUoXCJAanVweXRlcmxhYi9sYXVuY2hlclwiKTtcbmNvbnN0IGFwcHV0aWxzXzEgPSByZXF1aXJlKFwiQGp1cHl0ZXJsYWIvYXBwdXRpbHNcIik7XG5jb25zdCBub3RlYm9va18xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL25vdGVib29rXCIpO1xuY29uc3QgZG9jbWFuYWdlcl8xID0gcmVxdWlyZShcIkBqdXB5dGVybGFiL2RvY21hbmFnZXJcIik7XG4vLyBJbXBvcnQgdGhlIG1vZHVsYXJpemVkIFNpbXBsZVNpZGViYXJXaWRnZXQgZnJvbSB0aGUgbmV3IGxvY2F0aW9uXG5jb25zdCBzaWRlYmFyX3dpZGdldF8xID0gcmVxdWlyZShcIi4vY2hhdC9zaWRlYmFyLXdpZGdldFwiKTtcbmNvbnN0IGdsb2JhbHNfMSA9IHJlcXVpcmUoXCIuL2dsb2JhbHNcIik7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIi4vY29tbWFuZHNcIik7XG5jb25zdCBjZWxsX2NvbnRleHRfdHJhY2tlcl8xID0gcmVxdWlyZShcIi4vY2VsbC1jb250ZXh0LXRyYWNrZXJcIik7XG4vLyBFeHBvcnQgQXBpQ2xpZW50IGZvciB1c2UgYnkgb3RoZXIgY29tcG9uZW50c1xudmFyIGFwaV9jbGllbnRfMSA9IHJlcXVpcmUoXCIuL2FwaS1jbGllbnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBcGlDbGllbnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGFwaV9jbGllbnRfMS5BcGlDbGllbnQ7IH0gfSk7XG4vKipcbiAqIEluaXRpYWxpemF0aW9uIGRhdGEgZm9yIHRoZSBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gZXh0ZW5zaW9uLlxuICogVGhpcyBwbHVnaW4gaW50ZWdyYXRlcyBhIGN1c3RvbSBzaWRlYmFyIHdpdGggSnVweXRlckxhYiBmb3IgZW5oYW5jZWQgZnVuY3Rpb25hbGl0eS5cbiAqL1xuY29uc3QgcGx1Z2luID0ge1xuICAgIGlkOiAnanVweXRlci1zaW1wbGUtZXh0ZW5zaW9uOnBsdWdpbicsXG4gICAgYXV0b1N0YXJ0OiB0cnVlLFxuICAgIHJlcXVpcmVzOiBbbGF1bmNoZXJfMS5JTGF1bmNoZXIsIGFwcHV0aWxzXzEuSUNvbW1hbmRQYWxldHRlLCBub3RlYm9va18xLklOb3RlYm9va1RyYWNrZXIsIGRvY21hbmFnZXJfMS5JRG9jdW1lbnRNYW5hZ2VyXSxcbiAgICBhY3RpdmF0ZTogKGp1cHl0ZXJBcHAsIGxhdW5jaGVyLCBwYWxldHRlLCB0cmFja2VyLCBkb2NNYW5hZ2VyKSA9PiB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdKdXB5dGVyTGFiIGV4dGVuc2lvbiBqdXB5dGVyLXNpbXBsZS1leHRlbnNpb24gaXMgYWN0aXZhdGVkIScpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGdsb2JhbCByZWZlcmVuY2VzIGZvciBhcHAgYW5kIG5vdGVib29rIHRyYWNraW5nXG4gICAgICAgICgwLCBnbG9iYWxzXzEuaW5pdEdsb2JhbHMpKGp1cHl0ZXJBcHAsIHRyYWNrZXIpO1xuICAgICAgICAvLyBJbml0aWFsaXplIGNlbGwgY29udGV4dCB0cmFja2VyIHRvIG1vbml0b3IgYWN0aXZlIGNlbGxzIGFuZCBjb250ZXh0c1xuICAgICAgICBnbG9iYWxzXzEuZ2xvYmFscy5jZWxsQ29udGV4dFRyYWNrZXIgPSBuZXcgY2VsbF9jb250ZXh0X3RyYWNrZXJfMS5DZWxsQ29udGV4dFRyYWNrZXIoanVweXRlckFwcCwgdHJhY2tlcik7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgYWRkIHNpZGViYXIgd2lkZ2V0IGZvciB1c2VyIGludGVyYWN0aW9uIGFuZCBjb250ZXh0IGluc2VydGlvblxuICAgICAgICBjb25zdCBzaWRlYmFyV2lkZ2V0ID0gbmV3IHNpZGViYXJfd2lkZ2V0XzEuU2ltcGxlU2lkZWJhcldpZGdldChkb2NNYW5hZ2VyKTtcbiAgICAgICAganVweXRlckFwcC5zaGVsbC5hZGQoc2lkZWJhcldpZGdldCwgJ2xlZnQnLCB7IHJhbms6IDk5OTkgfSk7XG4gICAgICAgIC8vIFJlZ2lzdGVyIGNvbW1hbmRzIGZvciBpbnRlcmFjdGluZyB3aXRoIHRoZSBleHRlbnNpb24gdmlhIGNvbW1hbmQgcGFsZXR0ZSBhbmQgbGF1bmNoZXJcbiAgICAgICAgKDAsIGNvbW1hbmRzXzEucmVnaXN0ZXJDb21tYW5kcykoanVweXRlckFwcCwgcGFsZXR0ZSwgbGF1bmNoZXIsIHNpZGViYXJXaWRnZXQpO1xuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBwbHVnaW47XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuY29uZmlndXJlTWFya2VkID0gY29uZmlndXJlTWFya2VkO1xuZXhwb3J0cy5wcmVwcm9jZXNzTWFya2Rvd24gPSBwcmVwcm9jZXNzTWFya2Rvd247XG5jb25zdCBtYXJrZWRfMSA9IHJlcXVpcmUoXCJtYXJrZWRcIik7XG4vKipcbiAqIENvbmZpZ3VyZSBtYXJrZWQgd2l0aCBiZXR0ZXIgcmVuZGVyaW5nIG9wdGlvbnMgZm9yIGNvZGUgYmxvY2tzXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZU1hcmtlZCgpIHtcbiAgICAvLyBDb25maWd1cmUgbWFya2VkIG9wdGlvbnNcbiAgICBtYXJrZWRfMS5tYXJrZWQuc2V0T3B0aW9ucyh7XG4gICAgICAgIGdmbTogdHJ1ZSwgLy8gRW5hYmxlIEdpdEh1YiBGbGF2b3JlZCBNYXJrZG93blxuICAgICAgICBicmVha3M6IHRydWUsIC8vIEFkZCA8YnI+IG9uIHNpbmdsZSBsaW5lIGJyZWFrc1xuICAgICAgICBwZWRhbnRpYzogZmFsc2UsIC8vIENvbmZvcm0gdG8gb3JpZ2luYWwgbWFya2Rvd24gc3BlY1xuICAgICAgICBhc3luYzogZmFsc2UsIC8vIERpc2FibGUgYXN5bmMgcmVuZGVyaW5nXG4gICAgICAgIHNpbGVudDogZmFsc2UgLy8gRW5hYmxlIGVycm9yIHJlcG9ydGluZ1xuICAgIH0pO1xufVxuLyoqXG4gKiBQcmUtcHJvY2VzcyBtYXJrZG93biB0ZXh0IHRvIGZpeCBjb21tb24gaXNzdWVzIHdpdGggc3RyZWFtaW5nIGNvbnRlbnRcbiAqL1xuZnVuY3Rpb24gcHJlcHJvY2Vzc01hcmtkb3duKHRleHQpIHtcbiAgICAvLyBIYW5kbGUgY29kZSBibG9ja3MgZmlyc3RcbiAgICBsZXQgaW5Db2RlQmxvY2sgPSBmYWxzZTtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoJ1xcbicpO1xuICAgIGNvbnN0IHByb2Nlc3NlZExpbmVzID0gbGluZXMubWFwKChsaW5lLCBpKSA9PiB7XG4gICAgICAgIC8vIENoZWNrIGZvciBjb2RlIGJsb2NrIG1hcmtlcnNcbiAgICAgICAgaWYgKGxpbmUudHJpbSgpLnN0YXJ0c1dpdGgoJ2BgYCcpKSB7XG4gICAgICAgICAgICBpbkNvZGVCbG9jayA9ICFpbkNvZGVCbG9jaztcbiAgICAgICAgICAgIC8vIFByZXNlcnZlIGxhbmd1YWdlIHNwZWNpZmljYXRpb25cbiAgICAgICAgICAgIHJldHVybiBsaW5lLnRyaW0oKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSBpbiBhIGNvZGUgYmxvY2ssIHByZXNlcnZlIHRoZSBsaW5lIGFzIGlzXG4gICAgICAgIGlmIChpbkNvZGVCbG9jaykge1xuICAgICAgICAgICAgcmV0dXJuIGxpbmU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3V0c2lkZSBjb2RlIGJsb2NrcywgaGFuZGxlIGxpc3QgaXRlbXNcbiAgICAgICAgcmV0dXJuIGxpbmUucmVwbGFjZSgvKFteXFxuXFxzXSktXFxzL2csICckMVxcbi0gJyk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByb2Nlc3NlZExpbmVzLmpvaW4oJ1xcbicpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9