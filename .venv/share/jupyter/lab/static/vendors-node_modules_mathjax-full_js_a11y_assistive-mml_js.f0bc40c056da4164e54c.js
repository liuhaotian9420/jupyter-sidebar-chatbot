"use strict";
(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mathjax-full_js_a11y_assistive-mml_js"],{

/***/ "./node_modules/mathjax-full/js/a11y/assistive-mml.js":
/*!************************************************************!*\
  !*** ./node_modules/mathjax-full/js/a11y/assistive-mml.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssistiveMmlHandler = exports.AssistiveMmlMathDocumentMixin = exports.AssistiveMmlMathItemMixin = exports.LimitedMmlVisitor = void 0;
var MathItem_js_1 = __webpack_require__(/*! ../core/MathItem.js */ "./node_modules/mathjax-full/js/core/MathItem.js");
var SerializedMmlVisitor_js_1 = __webpack_require__(/*! ../core/MmlTree/SerializedMmlVisitor.js */ "./node_modules/mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js");
var Options_js_1 = __webpack_require__(/*! ../util/Options.js */ "./node_modules/mathjax-full/js/util/Options.js");
var LimitedMmlVisitor = (function (_super) {
    __extends(LimitedMmlVisitor, _super);
    function LimitedMmlVisitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LimitedMmlVisitor.prototype.getAttributes = function (node) {
        return _super.prototype.getAttributes.call(this, node).replace(/ ?id=".*?"/, '');
    };
    return LimitedMmlVisitor;
}(SerializedMmlVisitor_js_1.SerializedMmlVisitor));
exports.LimitedMmlVisitor = LimitedMmlVisitor;
(0, MathItem_js_1.newState)('ASSISTIVEMML', 153);
function AssistiveMmlMathItemMixin(BaseMathItem) {
    return (function (_super) {
        __extends(class_1, _super);
        function class_1() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        class_1.prototype.assistiveMml = function (document, force) {
            if (force === void 0) { force = false; }
            if (this.state() >= MathItem_js_1.STATE.ASSISTIVEMML)
                return;
            if (!this.isEscaped && (document.options.enableAssistiveMml || force)) {
                var adaptor = document.adaptor;
                var mml = document.toMML(this.root).replace(/\n */g, '').replace(/<!--.*?-->/g, '');
                var mmlNodes = adaptor.firstChild(adaptor.body(adaptor.parse(mml, 'text/html')));
                var node = adaptor.node('mjx-assistive-mml', {
                    unselectable: 'on', display: (this.display ? 'block' : 'inline')
                }, [mmlNodes]);
                adaptor.setAttribute(adaptor.firstChild(this.typesetRoot), 'aria-hidden', 'true');
                adaptor.setStyle(this.typesetRoot, 'position', 'relative');
                adaptor.append(this.typesetRoot, node);
            }
            this.state(MathItem_js_1.STATE.ASSISTIVEMML);
        };
        return class_1;
    }(BaseMathItem));
}
exports.AssistiveMmlMathItemMixin = AssistiveMmlMathItemMixin;
function AssistiveMmlMathDocumentMixin(BaseDocument) {
    var _a;
    return _a = (function (_super) {
            __extends(BaseClass, _super);
            function BaseClass() {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                var _this = _super.apply(this, __spreadArray([], __read(args), false)) || this;
                var CLASS = _this.constructor;
                var ProcessBits = CLASS.ProcessBits;
                if (!ProcessBits.has('assistive-mml')) {
                    ProcessBits.allocate('assistive-mml');
                }
                _this.visitor = new LimitedMmlVisitor(_this.mmlFactory);
                _this.options.MathItem =
                    AssistiveMmlMathItemMixin(_this.options.MathItem);
                if ('addStyles' in _this) {
                    _this.addStyles(CLASS.assistiveStyles);
                }
                return _this;
            }
            BaseClass.prototype.toMML = function (node) {
                return this.visitor.visitTree(node);
            };
            BaseClass.prototype.assistiveMml = function () {
                var e_1, _a;
                if (!this.processed.isSet('assistive-mml')) {
                    try {
                        for (var _b = __values(this.math), _c = _b.next(); !_c.done; _c = _b.next()) {
                            var math = _c.value;
                            math.assistiveMml(this);
                        }
                    }
                    catch (e_1_1) { e_1 = { error: e_1_1 }; }
                    finally {
                        try {
                            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                        }
                        finally { if (e_1) throw e_1.error; }
                    }
                    this.processed.set('assistive-mml');
                }
                return this;
            };
            BaseClass.prototype.state = function (state, restore) {
                if (restore === void 0) { restore = false; }
                _super.prototype.state.call(this, state, restore);
                if (state < MathItem_js_1.STATE.ASSISTIVEMML) {
                    this.processed.clear('assistive-mml');
                }
                return this;
            };
            return BaseClass;
        }(BaseDocument)),
        _a.OPTIONS = __assign(__assign({}, BaseDocument.OPTIONS), { enableAssistiveMml: true, renderActions: (0, Options_js_1.expandable)(__assign(__assign({}, BaseDocument.OPTIONS.renderActions), { assistiveMml: [MathItem_js_1.STATE.ASSISTIVEMML] })) }),
        _a.assistiveStyles = {
            'mjx-assistive-mml': {
                position: 'absolute !important',
                top: '0px', left: '0px',
                clip: 'rect(1px, 1px, 1px, 1px)',
                padding: '1px 0px 0px 0px !important',
                border: '0px !important',
                display: 'block !important',
                width: 'auto !important',
                overflow: 'hidden !important',
                '-webkit-touch-callout': 'none',
                '-webkit-user-select': 'none',
                '-khtml-user-select': 'none',
                '-moz-user-select': 'none',
                '-ms-user-select': 'none',
                'user-select': 'none'
            },
            'mjx-assistive-mml[display="block"]': {
                width: '100% !important'
            }
        },
        _a;
}
exports.AssistiveMmlMathDocumentMixin = AssistiveMmlMathDocumentMixin;
function AssistiveMmlHandler(handler) {
    handler.documentClass =
        AssistiveMmlMathDocumentMixin(handler.documentClass);
    return handler;
}
exports.AssistiveMmlHandler = AssistiveMmlHandler;
//# sourceMappingURL=assistive-mml.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/MmlTree/MmlVisitor.js":
/*!*****************************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/MmlTree/MmlVisitor.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MmlVisitor = void 0;
var MmlFactory_js_1 = __webpack_require__(/*! ./MmlFactory.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlFactory.js");
var Visitor_js_1 = __webpack_require__(/*! ../Tree/Visitor.js */ "./node_modules/mathjax-full/js/core/Tree/Visitor.js");
var MmlVisitor = (function (_super) {
    __extends(MmlVisitor, _super);
    function MmlVisitor(factory) {
        if (factory === void 0) { factory = null; }
        if (!factory) {
            factory = new MmlFactory_js_1.MmlFactory();
        }
        return _super.call(this, factory) || this;
    }
    MmlVisitor.prototype.visitTextNode = function (_node) {
        var _args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _args[_i - 1] = arguments[_i];
        }
    };
    MmlVisitor.prototype.visitXMLNode = function (_node) {
        var _args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            _args[_i - 1] = arguments[_i];
        }
    };
    return MmlVisitor;
}(Visitor_js_1.AbstractVisitor));
exports.MmlVisitor = MmlVisitor;
//# sourceMappingURL=MmlVisitor.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/MmlTree/SerializedMmlVisitor.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SerializedMmlVisitor = exports.toEntity = exports.DATAMJX = void 0;
var MmlVisitor_js_1 = __webpack_require__(/*! ./MmlVisitor.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlVisitor.js");
var MmlNode_js_1 = __webpack_require__(/*! ./MmlNode.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNode.js");
var mi_js_1 = __webpack_require__(/*! ./MmlNodes/mi.js */ "./node_modules/mathjax-full/js/core/MmlTree/MmlNodes/mi.js");
exports.DATAMJX = 'data-mjx-';
var toEntity = function (c) { return '&#x' + c.codePointAt(0).toString(16).toUpperCase() + ';'; };
exports.toEntity = toEntity;
var SerializedMmlVisitor = (function (_super) {
    __extends(SerializedMmlVisitor, _super);
    function SerializedMmlVisitor() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    SerializedMmlVisitor.prototype.visitTree = function (node) {
        return this.visitNode(node, '');
    };
    SerializedMmlVisitor.prototype.visitTextNode = function (node, _space) {
        return this.quoteHTML(node.getText());
    };
    SerializedMmlVisitor.prototype.visitXMLNode = function (node, space) {
        return space + node.getSerializedXML();
    };
    SerializedMmlVisitor.prototype.visitInferredMrowNode = function (node, space) {
        var e_1, _a;
        var mml = [];
        try {
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                mml.push(this.visitNode(child, space));
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return mml.join('\n');
    };
    SerializedMmlVisitor.prototype.visitTeXAtomNode = function (node, space) {
        var children = this.childNodeMml(node, space + '  ', '\n');
        var mml = space + '<mrow' + this.getAttributes(node) + '>' +
            (children.match(/\S/) ? '\n' + children + space : '') + '</mrow>';
        return mml;
    };
    SerializedMmlVisitor.prototype.visitAnnotationNode = function (node, space) {
        return space + '<annotation' + this.getAttributes(node) + '>'
            + this.childNodeMml(node, '', '')
            + '</annotation>';
    };
    SerializedMmlVisitor.prototype.visitDefault = function (node, space) {
        var kind = node.kind;
        var _a = __read((node.isToken || node.childNodes.length === 0 ? ['', ''] : ['\n', space]), 2), nl = _a[0], endspace = _a[1];
        var children = this.childNodeMml(node, space + '  ', nl);
        return space + '<' + kind + this.getAttributes(node) + '>'
            + (children.match(/\S/) ? nl + children + endspace : '')
            + '</' + kind + '>';
    };
    SerializedMmlVisitor.prototype.childNodeMml = function (node, space, nl) {
        var e_2, _a;
        var mml = '';
        try {
            for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                var child = _c.value;
                mml += this.visitNode(child, space) + nl;
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return mml;
    };
    SerializedMmlVisitor.prototype.getAttributes = function (node) {
        var e_3, _a;
        var attr = [];
        var defaults = this.constructor.defaultAttributes[node.kind] || {};
        var attributes = Object.assign({}, defaults, this.getDataAttributes(node), node.attributes.getAllAttributes());
        var variants = this.constructor.variants;
        if (attributes.hasOwnProperty('mathvariant') && variants.hasOwnProperty(attributes.mathvariant)) {
            attributes.mathvariant = variants[attributes.mathvariant];
        }
        try {
            for (var _b = __values(Object.keys(attributes)), _c = _b.next(); !_c.done; _c = _b.next()) {
                var name_1 = _c.value;
                var value = String(attributes[name_1]);
                if (value === undefined)
                    continue;
                attr.push(name_1 + '="' + this.quoteHTML(value) + '"');
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return attr.length ? ' ' + attr.join(' ') : '';
    };
    SerializedMmlVisitor.prototype.getDataAttributes = function (node) {
        var data = {};
        var variant = node.attributes.getExplicit('mathvariant');
        var variants = this.constructor.variants;
        variant && variants.hasOwnProperty(variant) && this.setDataAttribute(data, 'variant', variant);
        node.getProperty('variantForm') && this.setDataAttribute(data, 'alternate', '1');
        node.getProperty('pseudoscript') && this.setDataAttribute(data, 'pseudoscript', 'true');
        node.getProperty('autoOP') === false && this.setDataAttribute(data, 'auto-op', 'false');
        var scriptalign = node.getProperty('scriptalign');
        scriptalign && this.setDataAttribute(data, 'script-align', scriptalign);
        var texclass = node.getProperty('texClass');
        if (texclass !== undefined) {
            var setclass = true;
            if (texclass === MmlNode_js_1.TEXCLASS.OP && node.isKind('mi')) {
                var name_2 = node.getText();
                setclass = !(name_2.length > 1 && name_2.match(mi_js_1.MmlMi.operatorName));
            }
            setclass && this.setDataAttribute(data, 'texclass', texclass < 0 ? 'NONE' : MmlNode_js_1.TEXCLASSNAMES[texclass]);
        }
        node.getProperty('scriptlevel') && node.getProperty('useHeight') === false &&
            this.setDataAttribute(data, 'smallmatrix', 'true');
        return data;
    };
    SerializedMmlVisitor.prototype.setDataAttribute = function (data, name, value) {
        data[exports.DATAMJX + name] = value;
    };
    SerializedMmlVisitor.prototype.quoteHTML = function (value) {
        return value
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;').replace(/>/g, '&gt;')
            .replace(/\"/g, '&quot;')
            .replace(/[\uD800-\uDBFF]./g, exports.toEntity)
            .replace(/[\u0080-\uD7FF\uE000-\uFFFF]/g, exports.toEntity);
    };
    SerializedMmlVisitor.variants = {
        '-tex-calligraphic': 'script',
        '-tex-bold-calligraphic': 'bold-script',
        '-tex-oldstyle': 'normal',
        '-tex-bold-oldstyle': 'bold',
        '-tex-mathit': 'italic'
    };
    SerializedMmlVisitor.defaultAttributes = {
        math: {
            xmlns: 'http://www.w3.org/1998/Math/MathML'
        }
    };
    return SerializedMmlVisitor;
}(MmlVisitor_js_1.MmlVisitor));
exports.SerializedMmlVisitor = SerializedMmlVisitor;
//# sourceMappingURL=SerializedMmlVisitor.js.map

/***/ }),

/***/ "./node_modules/mathjax-full/js/core/Tree/Visitor.js":
/*!***********************************************************!*\
  !*** ./node_modules/mathjax-full/js/core/Tree/Visitor.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {


var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractVisitor = void 0;
var Node_js_1 = __webpack_require__(/*! ./Node.js */ "./node_modules/mathjax-full/js/core/Tree/Node.js");
var AbstractVisitor = (function () {
    function AbstractVisitor(factory) {
        var e_1, _a;
        this.nodeHandlers = new Map();
        try {
            for (var _b = __values(factory.getKinds()), _c = _b.next(); !_c.done; _c = _b.next()) {
                var kind = _c.value;
                var method = this[AbstractVisitor.methodName(kind)];
                if (method) {
                    this.nodeHandlers.set(kind, method);
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
    }
    AbstractVisitor.methodName = function (kind) {
        return 'visit' + (kind.charAt(0).toUpperCase() + kind.substr(1)).replace(/[^a-z0-9_]/ig, '_') + 'Node';
    };
    AbstractVisitor.prototype.visitTree = function (tree) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return this.visitNode.apply(this, __spreadArray([tree], __read(args), false));
    };
    AbstractVisitor.prototype.visitNode = function (node) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        var handler = this.nodeHandlers.get(node.kind) || this.visitDefault;
        return handler.call.apply(handler, __spreadArray([this, node], __read(args), false));
    };
    AbstractVisitor.prototype.visitDefault = function (node) {
        var e_2, _a;
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (node instanceof Node_js_1.AbstractNode) {
            try {
                for (var _b = __values(node.childNodes), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var child = _c.value;
                    this.visitNode.apply(this, __spreadArray([child], __read(args), false));
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    AbstractVisitor.prototype.setNodeHandler = function (kind, handler) {
        this.nodeHandlers.set(kind, handler);
    };
    AbstractVisitor.prototype.removeNodeHandler = function (kind) {
        this.nodeHandlers.delete(kind);
    };
    return AbstractVisitor;
}());
exports.AbstractVisitor = AbstractVisitor;
//# sourceMappingURL=Visitor.js.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWF0aGpheC1mdWxsX2pzX2ExMXlfYXNzaXN0aXZlLW1tbF9qcy5mMGJjNDBjMDU2ZGE0MTY0ZTU0Yy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWUsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDdkYsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSxPQUFPO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDJCQUEyQixHQUFHLHFDQUFxQyxHQUFHLGlDQUFpQyxHQUFHLHlCQUF5QjtBQUNuSSxvQkFBb0IsbUJBQU8sQ0FBQyw0RUFBcUI7QUFDakQsZ0NBQWdDLG1CQUFPLENBQUMsb0hBQXlDO0FBQ2pGLG1CQUFtQixtQkFBTyxDQUFDLDBFQUFvQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FB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QixnQkFBZ0IsbUJBQU8sQ0FBQyxtRUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLFVBQVU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1QkFBdUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLHVCQUF1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlFQUF5RSxVQUFVO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCO0FBQ3ZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9hMTF5L2Fzc2lzdGl2ZS1tbWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL21hdGhqYXgtZnVsbC9qcy9jb3JlL01tbFRyZWUvTW1sVmlzaXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvTW1sVHJlZS9TZXJpYWxpemVkTW1sVmlzaXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWF0aGpheC1mdWxsL2pzL2NvcmUvVHJlZS9WaXNpdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbnZhciBfX2Fzc2lnbiA9ICh0aGlzICYmIHRoaXMuX19hc3NpZ24pIHx8IGZ1bmN0aW9uICgpIHtcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24odCkge1xuICAgICAgICBmb3IgKHZhciBzLCBpID0gMSwgbiA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBuOyBpKyspIHtcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpXG4gICAgICAgICAgICAgICAgdFtwXSA9IHNbcF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHQ7XG4gICAgfTtcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG52YXIgX19zcHJlYWRBcnJheSA9ICh0aGlzICYmIHRoaXMuX19zcHJlYWRBcnJheSkgfHwgZnVuY3Rpb24gKHRvLCBmcm9tLCBwYWNrKSB7XG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcbn07XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFzc2lzdGl2ZU1tbEhhbmRsZXIgPSBleHBvcnRzLkFzc2lzdGl2ZU1tbE1hdGhEb2N1bWVudE1peGluID0gZXhwb3J0cy5Bc3Npc3RpdmVNbWxNYXRoSXRlbU1peGluID0gZXhwb3J0cy5MaW1pdGVkTW1sVmlzaXRvciA9IHZvaWQgMDtcbnZhciBNYXRoSXRlbV9qc18xID0gcmVxdWlyZShcIi4uL2NvcmUvTWF0aEl0ZW0uanNcIik7XG52YXIgU2VyaWFsaXplZE1tbFZpc2l0b3JfanNfMSA9IHJlcXVpcmUoXCIuLi9jb3JlL01tbFRyZWUvU2VyaWFsaXplZE1tbFZpc2l0b3IuanNcIik7XG52YXIgT3B0aW9uc19qc18xID0gcmVxdWlyZShcIi4uL3V0aWwvT3B0aW9ucy5qc1wiKTtcbnZhciBMaW1pdGVkTW1sVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKExpbWl0ZWRNbWxWaXNpdG9yLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIExpbWl0ZWRNbWxWaXNpdG9yKCkge1xuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgfVxuICAgIExpbWl0ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS5nZXRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcy5jYWxsKHRoaXMsIG5vZGUpLnJlcGxhY2UoLyA/aWQ9XCIuKj9cIi8sICcnKTtcbiAgICB9O1xuICAgIHJldHVybiBMaW1pdGVkTW1sVmlzaXRvcjtcbn0oU2VyaWFsaXplZE1tbFZpc2l0b3JfanNfMS5TZXJpYWxpemVkTW1sVmlzaXRvcikpO1xuZXhwb3J0cy5MaW1pdGVkTW1sVmlzaXRvciA9IExpbWl0ZWRNbWxWaXNpdG9yO1xuKDAsIE1hdGhJdGVtX2pzXzEubmV3U3RhdGUpKCdBU1NJU1RJVkVNTUwnLCAxNTMpO1xuZnVuY3Rpb24gQXNzaXN0aXZlTW1sTWF0aEl0ZW1NaXhpbihCYXNlTWF0aEl0ZW0pIHtcbiAgICByZXR1cm4gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICAgICAgX19leHRlbmRzKGNsYXNzXzEsIF9zdXBlcik7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xhc3NfMS5wcm90b3R5cGUuYXNzaXN0aXZlTW1sID0gZnVuY3Rpb24gKGRvY3VtZW50LCBmb3JjZSkge1xuICAgICAgICAgICAgaWYgKGZvcmNlID09PSB2b2lkIDApIHsgZm9yY2UgPSBmYWxzZTsgfVxuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUoKSA+PSBNYXRoSXRlbV9qc18xLlNUQVRFLkFTU0lTVElWRU1NTClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFc2NhcGVkICYmIChkb2N1bWVudC5vcHRpb25zLmVuYWJsZUFzc2lzdGl2ZU1tbCB8fCBmb3JjZSkpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWRhcHRvciA9IGRvY3VtZW50LmFkYXB0b3I7XG4gICAgICAgICAgICAgICAgdmFyIG1tbCA9IGRvY3VtZW50LnRvTU1MKHRoaXMucm9vdCkucmVwbGFjZSgvXFxuICovZywgJycpLnJlcGxhY2UoLzwhLS0uKj8tLT4vZywgJycpO1xuICAgICAgICAgICAgICAgIHZhciBtbWxOb2RlcyA9IGFkYXB0b3IuZmlyc3RDaGlsZChhZGFwdG9yLmJvZHkoYWRhcHRvci5wYXJzZShtbWwsICd0ZXh0L2h0bWwnKSkpO1xuICAgICAgICAgICAgICAgIHZhciBub2RlID0gYWRhcHRvci5ub2RlKCdtangtYXNzaXN0aXZlLW1tbCcsIHtcbiAgICAgICAgICAgICAgICAgICAgdW5zZWxlY3RhYmxlOiAnb24nLCBkaXNwbGF5OiAodGhpcy5kaXNwbGF5ID8gJ2Jsb2NrJyA6ICdpbmxpbmUnKVxuICAgICAgICAgICAgICAgIH0sIFttbWxOb2Rlc10pO1xuICAgICAgICAgICAgICAgIGFkYXB0b3Iuc2V0QXR0cmlidXRlKGFkYXB0b3IuZmlyc3RDaGlsZCh0aGlzLnR5cGVzZXRSb290KSwgJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICBhZGFwdG9yLnNldFN0eWxlKHRoaXMudHlwZXNldFJvb3QsICdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICAgICAgICAgIGFkYXB0b3IuYXBwZW5kKHRoaXMudHlwZXNldFJvb3QsIG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zdGF0ZShNYXRoSXRlbV9qc18xLlNUQVRFLkFTU0lTVElWRU1NTCk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oQmFzZU1hdGhJdGVtKSk7XG59XG5leHBvcnRzLkFzc2lzdGl2ZU1tbE1hdGhJdGVtTWl4aW4gPSBBc3Npc3RpdmVNbWxNYXRoSXRlbU1peGluO1xuZnVuY3Rpb24gQXNzaXN0aXZlTW1sTWF0aERvY3VtZW50TWl4aW4oQmFzZURvY3VtZW50KSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBfYSA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgICAgICAgICBfX2V4dGVuZHMoQmFzZUNsYXNzLCBfc3VwZXIpO1xuICAgICAgICAgICAgZnVuY3Rpb24gQmFzZUNsYXNzKCkge1xuICAgICAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpIHx8IHRoaXM7XG4gICAgICAgICAgICAgICAgdmFyIENMQVNTID0gX3RoaXMuY29uc3RydWN0b3I7XG4gICAgICAgICAgICAgICAgdmFyIFByb2Nlc3NCaXRzID0gQ0xBU1MuUHJvY2Vzc0JpdHM7XG4gICAgICAgICAgICAgICAgaWYgKCFQcm9jZXNzQml0cy5oYXMoJ2Fzc2lzdGl2ZS1tbWwnKSkge1xuICAgICAgICAgICAgICAgICAgICBQcm9jZXNzQml0cy5hbGxvY2F0ZSgnYXNzaXN0aXZlLW1tbCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy52aXNpdG9yID0gbmV3IExpbWl0ZWRNbWxWaXNpdG9yKF90aGlzLm1tbEZhY3RvcnkpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMuTWF0aEl0ZW0gPVxuICAgICAgICAgICAgICAgICAgICBBc3Npc3RpdmVNbWxNYXRoSXRlbU1peGluKF90aGlzLm9wdGlvbnMuTWF0aEl0ZW0pO1xuICAgICAgICAgICAgICAgIGlmICgnYWRkU3R5bGVzJyBpbiBfdGhpcykge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hZGRTdHlsZXMoQ0xBU1MuYXNzaXN0aXZlU3R5bGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQmFzZUNsYXNzLnByb3RvdHlwZS50b01NTCA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRvci52aXNpdFRyZWUobm9kZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgQmFzZUNsYXNzLnByb3RvdHlwZS5hc3Npc3RpdmVNbWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVfMSwgX2E7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb2Nlc3NlZC5pc1NldCgnYXNzaXN0aXZlLW1tbCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKHRoaXMubWF0aCksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbWF0aCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGguYXNzaXN0aXZlTW1sKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlXzFfMSkgeyBlXzEgPSB7IGVycm9yOiBlXzFfMSB9OyB9XG4gICAgICAgICAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX2MgJiYgIV9jLmRvbmUgJiYgKF9hID0gX2IucmV0dXJuKSkgX2EuY2FsbChfYik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yOyB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuc2V0KCdhc3Npc3RpdmUtbW1sJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIEJhc2VDbGFzcy5wcm90b3R5cGUuc3RhdGUgPSBmdW5jdGlvbiAoc3RhdGUsIHJlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdG9yZSA9PT0gdm9pZCAwKSB7IHJlc3RvcmUgPSBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIF9zdXBlci5wcm90b3R5cGUuc3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgcmVzdG9yZSk7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlIDwgTWF0aEl0ZW1fanNfMS5TVEFURS5BU1NJU1RJVkVNTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzZWQuY2xlYXIoJ2Fzc2lzdGl2ZS1tbWwnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIEJhc2VDbGFzcztcbiAgICAgICAgfShCYXNlRG9jdW1lbnQpKSxcbiAgICAgICAgX2EuT1BUSU9OUyA9IF9fYXNzaWduKF9fYXNzaWduKHt9LCBCYXNlRG9jdW1lbnQuT1BUSU9OUyksIHsgZW5hYmxlQXNzaXN0aXZlTW1sOiB0cnVlLCByZW5kZXJBY3Rpb25zOiAoMCwgT3B0aW9uc19qc18xLmV4cGFuZGFibGUpKF9fYXNzaWduKF9fYXNzaWduKHt9LCBCYXNlRG9jdW1lbnQuT1BUSU9OUy5yZW5kZXJBY3Rpb25zKSwgeyBhc3Npc3RpdmVNbWw6IFtNYXRoSXRlbV9qc18xLlNUQVRFLkFTU0lTVElWRU1NTF0gfSkpIH0pLFxuICAgICAgICBfYS5hc3Npc3RpdmVTdHlsZXMgPSB7XG4gICAgICAgICAgICAnbWp4LWFzc2lzdGl2ZS1tbWwnOiB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICB0b3A6ICcwcHgnLCBsZWZ0OiAnMHB4JyxcbiAgICAgICAgICAgICAgICBjbGlwOiAncmVjdCgxcHgsIDFweCwgMXB4LCAxcHgpJyxcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMXB4IDBweCAwcHggMHB4ICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzBweCAhaW1wb3J0YW50JyxcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2sgIWltcG9ydGFudCcsXG4gICAgICAgICAgICAgICAgd2lkdGg6ICdhdXRvICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuICFpbXBvcnRhbnQnLFxuICAgICAgICAgICAgICAgICctd2Via2l0LXRvdWNoLWNhbGxvdXQnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJy13ZWJraXQtdXNlci1zZWxlY3QnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgJy1raHRtbC11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnLW1vei11c2VyLXNlbGVjdCc6ICdub25lJyxcbiAgICAgICAgICAgICAgICAnLW1zLXVzZXItc2VsZWN0JzogJ25vbmUnLFxuICAgICAgICAgICAgICAgICd1c2VyLXNlbGVjdCc6ICdub25lJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdtangtYXNzaXN0aXZlLW1tbFtkaXNwbGF5PVwiYmxvY2tcIl0nOiB7XG4gICAgICAgICAgICAgICAgd2lkdGg6ICcxMDAlICFpbXBvcnRhbnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9hO1xufVxuZXhwb3J0cy5Bc3Npc3RpdmVNbWxNYXRoRG9jdW1lbnRNaXhpbiA9IEFzc2lzdGl2ZU1tbE1hdGhEb2N1bWVudE1peGluO1xuZnVuY3Rpb24gQXNzaXN0aXZlTW1sSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaGFuZGxlci5kb2N1bWVudENsYXNzID1cbiAgICAgICAgQXNzaXN0aXZlTW1sTWF0aERvY3VtZW50TWl4aW4oaGFuZGxlci5kb2N1bWVudENsYXNzKTtcbiAgICByZXR1cm4gaGFuZGxlcjtcbn1cbmV4cG9ydHMuQXNzaXN0aXZlTW1sSGFuZGxlciA9IEFzc2lzdGl2ZU1tbEhhbmRsZXI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3Npc3RpdmUtbW1sLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fZXh0ZW5kcyA9ICh0aGlzICYmIHRoaXMuX19leHRlbmRzKSB8fCAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxuICAgICAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxuICAgICAgICAgICAgZnVuY3Rpb24gKGQsIGIpIHsgZm9yICh2YXIgcCBpbiBiKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIHApKSBkW3BdID0gYltwXTsgfTtcbiAgICAgICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGQsIGIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBiICE9PSBcImZ1bmN0aW9uXCIgJiYgYiAhPT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcbiAgICAgICAgZnVuY3Rpb24gX18oKSB7IHRoaXMuY29uc3RydWN0b3IgPSBkOyB9XG4gICAgICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcbiAgICB9O1xufSkoKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTW1sVmlzaXRvciA9IHZvaWQgMDtcbnZhciBNbWxGYWN0b3J5X2pzXzEgPSByZXF1aXJlKFwiLi9NbWxGYWN0b3J5LmpzXCIpO1xudmFyIFZpc2l0b3JfanNfMSA9IHJlcXVpcmUoXCIuLi9UcmVlL1Zpc2l0b3IuanNcIik7XG52YXIgTW1sVmlzaXRvciA9IChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgX19leHRlbmRzKE1tbFZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gTW1sVmlzaXRvcihmYWN0b3J5KSB7XG4gICAgICAgIGlmIChmYWN0b3J5ID09PSB2b2lkIDApIHsgZmFjdG9yeSA9IG51bGw7IH1cbiAgICAgICAgaWYgKCFmYWN0b3J5KSB7XG4gICAgICAgICAgICBmYWN0b3J5ID0gbmV3IE1tbEZhY3RvcnlfanNfMS5NbWxGYWN0b3J5KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9zdXBlci5jYWxsKHRoaXMsIGZhY3RvcnkpIHx8IHRoaXM7XG4gICAgfVxuICAgIE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VGV4dE5vZGUgPSBmdW5jdGlvbiAoX25vZGUpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBfYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTW1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRYTUxOb2RlID0gZnVuY3Rpb24gKF9ub2RlKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgX2FyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBNbWxWaXNpdG9yO1xufShWaXNpdG9yX2pzXzEuQWJzdHJhY3RWaXNpdG9yKSk7XG5leHBvcnRzLk1tbFZpc2l0b3IgPSBNbWxWaXNpdG9yO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TW1sVmlzaXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2V4dGVuZHMgPSAodGhpcyAmJiB0aGlzLl9fZXh0ZW5kcykgfHwgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZXh0ZW5kU3RhdGljcyA9IGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHxcbiAgICAgICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcbiAgICAgICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XG4gICAgICAgIHJldHVybiBleHRlbmRTdGF0aWNzKGQsIGIpO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChkLCBiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2xhc3MgZXh0ZW5kcyB2YWx1ZSBcIiArIFN0cmluZyhiKSArIFwiIGlzIG5vdCBhIGNvbnN0cnVjdG9yIG9yIG51bGxcIik7XG4gICAgICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XG4gICAgICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XG4gICAgfTtcbn0pKCk7XG52YXIgX192YWx1ZXMgPSAodGhpcyAmJiB0aGlzLl9fdmFsdWVzKSB8fCBmdW5jdGlvbihvKSB7XG4gICAgdmFyIHMgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgU3ltYm9sLml0ZXJhdG9yLCBtID0gcyAmJiBvW3NdLCBpID0gMDtcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XG4gICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcbn07XG52YXIgX19yZWFkID0gKHRoaXMgJiYgdGhpcy5fX3JlYWQpIHx8IGZ1bmN0aW9uIChvLCBuKSB7XG4gICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdO1xuICAgIGlmICghbSkgcmV0dXJuIG87XG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XG4gICAgdHJ5IHtcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyBlID0geyBlcnJvcjogZXJyb3IgfTsgfVxuICAgIGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHIgJiYgIXIuZG9uZSAmJiAobSA9IGlbXCJyZXR1cm5cIl0pKSBtLmNhbGwoaSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XG4gICAgfVxuICAgIHJldHVybiBhcjtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcmlhbGl6ZWRNbWxWaXNpdG9yID0gZXhwb3J0cy50b0VudGl0eSA9IGV4cG9ydHMuREFUQU1KWCA9IHZvaWQgMDtcbnZhciBNbWxWaXNpdG9yX2pzXzEgPSByZXF1aXJlKFwiLi9NbWxWaXNpdG9yLmpzXCIpO1xudmFyIE1tbE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuL01tbE5vZGUuanNcIik7XG52YXIgbWlfanNfMSA9IHJlcXVpcmUoXCIuL01tbE5vZGVzL21pLmpzXCIpO1xuZXhwb3J0cy5EQVRBTUpYID0gJ2RhdGEtbWp4LSc7XG52YXIgdG9FbnRpdHkgPSBmdW5jdGlvbiAoYykgeyByZXR1cm4gJyYjeCcgKyBjLmNvZGVQb2ludEF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICsgJzsnOyB9O1xuZXhwb3J0cy50b0VudGl0eSA9IHRvRW50aXR5O1xudmFyIFNlcmlhbGl6ZWRNbWxWaXNpdG9yID0gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICBfX2V4dGVuZHMoU2VyaWFsaXplZE1tbFZpc2l0b3IsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU2VyaWFsaXplZE1tbFZpc2l0b3IoKSB7XG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcbiAgICB9XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0VHJlZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0Tm9kZShub2RlLCAnJyk7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZXh0Tm9kZSA9IGZ1bmN0aW9uIChub2RlLCBfc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVvdGVIVE1MKG5vZGUuZ2V0VGV4dCgpKTtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdFhNTE5vZGUgPSBmdW5jdGlvbiAobm9kZSwgc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHNwYWNlICsgbm9kZS5nZXRTZXJpYWxpemVkWE1MKCk7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRJbmZlcnJlZE1yb3dOb2RlID0gZnVuY3Rpb24gKG5vZGUsIHNwYWNlKSB7XG4gICAgICAgIHZhciBlXzEsIF9hO1xuICAgICAgICB2YXIgbW1sID0gW107XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKG5vZGUuY2hpbGROb2RlcyksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICBtbWwucHVzaCh0aGlzLnZpc2l0Tm9kZShjaGlsZCwgc3BhY2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtbWwuam9pbignXFxuJyk7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUudmlzaXRUZVhBdG9tTm9kZSA9IGZ1bmN0aW9uIChub2RlLCBzcGFjZSkge1xuICAgICAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLmNoaWxkTm9kZU1tbChub2RlLCBzcGFjZSArICcgICcsICdcXG4nKTtcbiAgICAgICAgdmFyIG1tbCA9IHNwYWNlICsgJzxtcm93JyArIHRoaXMuZ2V0QXR0cmlidXRlcyhub2RlKSArICc+JyArXG4gICAgICAgICAgICAoY2hpbGRyZW4ubWF0Y2goL1xcUy8pID8gJ1xcbicgKyBjaGlsZHJlbiArIHNwYWNlIDogJycpICsgJzwvbXJvdz4nO1xuICAgICAgICByZXR1cm4gbW1sO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLnZpc2l0QW5ub3RhdGlvbk5vZGUgPSBmdW5jdGlvbiAobm9kZSwgc3BhY2UpIHtcbiAgICAgICAgcmV0dXJuIHNwYWNlICsgJzxhbm5vdGF0aW9uJyArIHRoaXMuZ2V0QXR0cmlidXRlcyhub2RlKSArICc+J1xuICAgICAgICAgICAgKyB0aGlzLmNoaWxkTm9kZU1tbChub2RlLCAnJywgJycpXG4gICAgICAgICAgICArICc8L2Fubm90YXRpb24+JztcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSwgc3BhY2UpIHtcbiAgICAgICAgdmFyIGtpbmQgPSBub2RlLmtpbmQ7XG4gICAgICAgIHZhciBfYSA9IF9fcmVhZCgobm9kZS5pc1Rva2VuIHx8IG5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPT09IDAgPyBbJycsICcnXSA6IFsnXFxuJywgc3BhY2VdKSwgMiksIG5sID0gX2FbMF0sIGVuZHNwYWNlID0gX2FbMV07XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuY2hpbGROb2RlTW1sKG5vZGUsIHNwYWNlICsgJyAgJywgbmwpO1xuICAgICAgICByZXR1cm4gc3BhY2UgKyAnPCcgKyBraW5kICsgdGhpcy5nZXRBdHRyaWJ1dGVzKG5vZGUpICsgJz4nXG4gICAgICAgICAgICArIChjaGlsZHJlbi5tYXRjaCgvXFxTLykgPyBubCArIGNoaWxkcmVuICsgZW5kc3BhY2UgOiAnJylcbiAgICAgICAgICAgICsgJzwvJyArIGtpbmQgKyAnPic7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUuY2hpbGROb2RlTW1sID0gZnVuY3Rpb24gKG5vZGUsIHNwYWNlLCBubCkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdmFyIG1tbCA9ICcnO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2IgPSBfX3ZhbHVlcyhub2RlLmNoaWxkTm9kZXMpLCBfYyA9IF9iLm5leHQoKTsgIV9jLmRvbmU7IF9jID0gX2IubmV4dCgpKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gX2MudmFsdWU7XG4gICAgICAgICAgICAgICAgbW1sICs9IHRoaXMudmlzaXROb2RlKGNoaWxkLCBzcGFjZSkgKyBubDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8yXzEpIHsgZV8yID0geyBlcnJvcjogZV8yXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtbWw7XG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5wcm90b3R5cGUuZ2V0QXR0cmlidXRlcyA9IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIHZhciBlXzMsIF9hO1xuICAgICAgICB2YXIgYXR0ciA9IFtdO1xuICAgICAgICB2YXIgZGVmYXVsdHMgPSB0aGlzLmNvbnN0cnVjdG9yLmRlZmF1bHRBdHRyaWJ1dGVzW25vZGUua2luZF0gfHwge307XG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdHMsIHRoaXMuZ2V0RGF0YUF0dHJpYnV0ZXMobm9kZSksIG5vZGUuYXR0cmlidXRlcy5nZXRBbGxBdHRyaWJ1dGVzKCkpO1xuICAgICAgICB2YXIgdmFyaWFudHMgPSB0aGlzLmNvbnN0cnVjdG9yLnZhcmlhbnRzO1xuICAgICAgICBpZiAoYXR0cmlidXRlcy5oYXNPd25Qcm9wZXJ0eSgnbWF0aHZhcmlhbnQnKSAmJiB2YXJpYW50cy5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVzLm1hdGh2YXJpYW50KSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5tYXRodmFyaWFudCA9IHZhcmlhbnRzW2F0dHJpYnV0ZXMubWF0aHZhcmlhbnRdO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lXzEgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBTdHJpbmcoYXR0cmlidXRlc1tuYW1lXzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgYXR0ci5wdXNoKG5hbWVfMSArICc9XCInICsgdGhpcy5xdW90ZUhUTUwodmFsdWUpICsgJ1wiJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVfM18xKSB7IGVfMyA9IHsgZXJyb3I6IGVfM18xIH07IH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkgeyBpZiAoZV8zKSB0aHJvdyBlXzMuZXJyb3I7IH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXR0ci5sZW5ndGggPyAnICcgKyBhdHRyLmpvaW4oJyAnKSA6ICcnO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IucHJvdG90eXBlLmdldERhdGFBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgdmFyIHZhcmlhbnQgPSBub2RlLmF0dHJpYnV0ZXMuZ2V0RXhwbGljaXQoJ21hdGh2YXJpYW50Jyk7XG4gICAgICAgIHZhciB2YXJpYW50cyA9IHRoaXMuY29uc3RydWN0b3IudmFyaWFudHM7XG4gICAgICAgIHZhcmlhbnQgJiYgdmFyaWFudHMuaGFzT3duUHJvcGVydHkodmFyaWFudCkgJiYgdGhpcy5zZXREYXRhQXR0cmlidXRlKGRhdGEsICd2YXJpYW50JywgdmFyaWFudCk7XG4gICAgICAgIG5vZGUuZ2V0UHJvcGVydHkoJ3ZhcmlhbnRGb3JtJykgJiYgdGhpcy5zZXREYXRhQXR0cmlidXRlKGRhdGEsICdhbHRlcm5hdGUnLCAnMScpO1xuICAgICAgICBub2RlLmdldFByb3BlcnR5KCdwc2V1ZG9zY3JpcHQnKSAmJiB0aGlzLnNldERhdGFBdHRyaWJ1dGUoZGF0YSwgJ3BzZXVkb3NjcmlwdCcsICd0cnVlJyk7XG4gICAgICAgIG5vZGUuZ2V0UHJvcGVydHkoJ2F1dG9PUCcpID09PSBmYWxzZSAmJiB0aGlzLnNldERhdGFBdHRyaWJ1dGUoZGF0YSwgJ2F1dG8tb3AnLCAnZmFsc2UnKTtcbiAgICAgICAgdmFyIHNjcmlwdGFsaWduID0gbm9kZS5nZXRQcm9wZXJ0eSgnc2NyaXB0YWxpZ24nKTtcbiAgICAgICAgc2NyaXB0YWxpZ24gJiYgdGhpcy5zZXREYXRhQXR0cmlidXRlKGRhdGEsICdzY3JpcHQtYWxpZ24nLCBzY3JpcHRhbGlnbik7XG4gICAgICAgIHZhciB0ZXhjbGFzcyA9IG5vZGUuZ2V0UHJvcGVydHkoJ3RleENsYXNzJyk7XG4gICAgICAgIGlmICh0ZXhjbGFzcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgc2V0Y2xhc3MgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRleGNsYXNzID09PSBNbWxOb2RlX2pzXzEuVEVYQ0xBU1MuT1AgJiYgbm9kZS5pc0tpbmQoJ21pJykpIHtcbiAgICAgICAgICAgICAgICB2YXIgbmFtZV8yID0gbm9kZS5nZXRUZXh0KCk7XG4gICAgICAgICAgICAgICAgc2V0Y2xhc3MgPSAhKG5hbWVfMi5sZW5ndGggPiAxICYmIG5hbWVfMi5tYXRjaChtaV9qc18xLk1tbE1pLm9wZXJhdG9yTmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0Y2xhc3MgJiYgdGhpcy5zZXREYXRhQXR0cmlidXRlKGRhdGEsICd0ZXhjbGFzcycsIHRleGNsYXNzIDwgMCA/ICdOT05FJyA6IE1tbE5vZGVfanNfMS5URVhDTEFTU05BTUVTW3RleGNsYXNzXSk7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZS5nZXRQcm9wZXJ0eSgnc2NyaXB0bGV2ZWwnKSAmJiBub2RlLmdldFByb3BlcnR5KCd1c2VIZWlnaHQnKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YUF0dHJpYnV0ZShkYXRhLCAnc21hbGxtYXRyaXgnLCAndHJ1ZScpO1xuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS5zZXREYXRhQXR0cmlidXRlID0gZnVuY3Rpb24gKGRhdGEsIG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIGRhdGFbZXhwb3J0cy5EQVRBTUpYICsgbmFtZV0gPSB2YWx1ZTtcbiAgICB9O1xuICAgIFNlcmlhbGl6ZWRNbWxWaXNpdG9yLnByb3RvdHlwZS5xdW90ZUhUTUwgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAucmVwbGFjZSgvJi9nLCAnJmFtcDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKS5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXFwiL2csICcmcXVvdDsnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHVEODAwLVxcdURCRkZdLi9nLCBleHBvcnRzLnRvRW50aXR5KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUwMDgwLVxcdUQ3RkZcXHVFMDAwLVxcdUZGRkZdL2csIGV4cG9ydHMudG9FbnRpdHkpO1xuICAgIH07XG4gICAgU2VyaWFsaXplZE1tbFZpc2l0b3IudmFyaWFudHMgPSB7XG4gICAgICAgICctdGV4LWNhbGxpZ3JhcGhpYyc6ICdzY3JpcHQnLFxuICAgICAgICAnLXRleC1ib2xkLWNhbGxpZ3JhcGhpYyc6ICdib2xkLXNjcmlwdCcsXG4gICAgICAgICctdGV4LW9sZHN0eWxlJzogJ25vcm1hbCcsXG4gICAgICAgICctdGV4LWJvbGQtb2xkc3R5bGUnOiAnYm9sZCcsXG4gICAgICAgICctdGV4LW1hdGhpdCc6ICdpdGFsaWMnXG4gICAgfTtcbiAgICBTZXJpYWxpemVkTW1sVmlzaXRvci5kZWZhdWx0QXR0cmlidXRlcyA9IHtcbiAgICAgICAgbWF0aDoge1xuICAgICAgICAgICAgeG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk4L01hdGgvTWF0aE1MJ1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gU2VyaWFsaXplZE1tbFZpc2l0b3I7XG59KE1tbFZpc2l0b3JfanNfMS5NbWxWaXNpdG9yKSk7XG5leHBvcnRzLlNlcmlhbGl6ZWRNbWxWaXNpdG9yID0gU2VyaWFsaXplZE1tbFZpc2l0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZXJpYWxpemVkTW1sVmlzaXRvci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX3ZhbHVlcyA9ICh0aGlzICYmIHRoaXMuX192YWx1ZXMpIHx8IGZ1bmN0aW9uKG8pIHtcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xuICAgIGlmIChtKSByZXR1cm4gbS5jYWxsKG8pO1xuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKG8gJiYgaSA+PSBvLmxlbmd0aCkgbyA9IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xufTtcbnZhciBfX3JlYWQgPSAodGhpcyAmJiB0aGlzLl9fcmVhZCkgfHwgZnVuY3Rpb24gKG8sIG4pIHtcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XG4gICAgaWYgKCFtKSByZXR1cm4gbztcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcbiAgICB0cnkge1xuICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XG4gICAgZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cbiAgICB9XG4gICAgcmV0dXJuIGFyO1xufTtcbnZhciBfX3NwcmVhZEFycmF5ID0gKHRoaXMgJiYgdGhpcy5fX3NwcmVhZEFycmF5KSB8fCBmdW5jdGlvbiAodG8sIGZyb20sIHBhY2spIHtcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQWJzdHJhY3RWaXNpdG9yID0gdm9pZCAwO1xudmFyIE5vZGVfanNfMSA9IHJlcXVpcmUoXCIuL05vZGUuanNcIik7XG52YXIgQWJzdHJhY3RWaXNpdG9yID0gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBYnN0cmFjdFZpc2l0b3IoZmFjdG9yeSkge1xuICAgICAgICB2YXIgZV8xLCBfYTtcbiAgICAgICAgdGhpcy5ub2RlSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKHZhciBfYiA9IF9fdmFsdWVzKGZhY3RvcnkuZ2V0S2luZHMoKSksIF9jID0gX2IubmV4dCgpOyAhX2MuZG9uZTsgX2MgPSBfYi5uZXh0KCkpIHtcbiAgICAgICAgICAgICAgICB2YXIga2luZCA9IF9jLnZhbHVlO1xuICAgICAgICAgICAgICAgIHZhciBtZXRob2QgPSB0aGlzW0Fic3RyYWN0VmlzaXRvci5tZXRob2ROYW1lKGtpbmQpXTtcbiAgICAgICAgICAgICAgICBpZiAobWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZUhhbmRsZXJzLnNldChraW5kLCBtZXRob2QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZV8xXzEpIHsgZV8xID0geyBlcnJvcjogZV8xXzEgfTsgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKF9jICYmICFfYy5kb25lICYmIChfYSA9IF9iLnJldHVybikpIF9hLmNhbGwoX2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzEpIHRocm93IGVfMS5lcnJvcjsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIEFic3RyYWN0VmlzaXRvci5tZXRob2ROYW1lID0gZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgICAgcmV0dXJuICd2aXNpdCcgKyAoa2luZC5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtpbmQuc3Vic3RyKDEpKS5yZXBsYWNlKC9bXmEtejAtOV9dL2lnLCAnXycpICsgJ05vZGUnO1xuICAgIH07XG4gICAgQWJzdHJhY3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdFRyZWUgPSBmdW5jdGlvbiAodHJlZSkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaSAtIDFdID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aXNpdE5vZGUuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbdHJlZV0sIF9fcmVhZChhcmdzKSwgZmFsc2UpKTtcbiAgICB9O1xuICAgIEFic3RyYWN0VmlzaXRvci5wcm90b3R5cGUudmlzaXROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGhhbmRsZXIgPSB0aGlzLm5vZGVIYW5kbGVycy5nZXQobm9kZS5raW5kKSB8fCB0aGlzLnZpc2l0RGVmYXVsdDtcbiAgICAgICAgcmV0dXJuIGhhbmRsZXIuY2FsbC5hcHBseShoYW5kbGVyLCBfX3NwcmVhZEFycmF5KFt0aGlzLCBub2RlXSwgX19yZWFkKGFyZ3MpLCBmYWxzZSkpO1xuICAgIH07XG4gICAgQWJzdHJhY3RWaXNpdG9yLnByb3RvdHlwZS52aXNpdERlZmF1bHQgPSBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICB2YXIgZV8yLCBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOb2RlX2pzXzEuQWJzdHJhY3ROb2RlKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9iID0gX192YWx1ZXMobm9kZS5jaGlsZE5vZGVzKSwgX2MgPSBfYi5uZXh0KCk7ICFfYy5kb25lOyBfYyA9IF9iLm5leHQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hpbGQgPSBfYy52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy52aXNpdE5vZGUuYXBwbHkodGhpcywgX19zcHJlYWRBcnJheShbY2hpbGRdLCBfX3JlYWQoYXJncyksIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVfMl8xKSB7IGVfMiA9IHsgZXJyb3I6IGVfMl8xIH07IH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfYyAmJiAhX2MuZG9uZSAmJiAoX2EgPSBfYi5yZXR1cm4pKSBfYS5jYWxsKF9iKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7IGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjsgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBBYnN0cmFjdFZpc2l0b3IucHJvdG90eXBlLnNldE5vZGVIYW5kbGVyID0gZnVuY3Rpb24gKGtpbmQsIGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5ub2RlSGFuZGxlcnMuc2V0KGtpbmQsIGhhbmRsZXIpO1xuICAgIH07XG4gICAgQWJzdHJhY3RWaXNpdG9yLnByb3RvdHlwZS5yZW1vdmVOb2RlSGFuZGxlciA9IGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICAgIHRoaXMubm9kZUhhbmRsZXJzLmRlbGV0ZShraW5kKTtcbiAgICB9O1xuICAgIHJldHVybiBBYnN0cmFjdFZpc2l0b3I7XG59KCkpO1xuZXhwb3J0cy5BYnN0cmFjdFZpc2l0b3IgPSBBYnN0cmFjdFZpc2l0b3I7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1WaXNpdG9yLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==