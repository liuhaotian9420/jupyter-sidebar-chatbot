(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_rjsf_core_lib_index_js-node_modules_react-dom_client_js-node_modules_typ-d5450b"],{

/***/ "./node_modules/@rjsf/core/lib/components/Form.js":
/*!********************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/Form.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Form)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/pick */ "./node_modules/lodash/pick.js");
/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_pick__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_toPath__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/toPath */ "./node_modules/lodash/toPath.js");
/* harmony import */ var lodash_toPath__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_toPath__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _getDefaultRegistry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../getDefaultRegistry */ "./node_modules/@rjsf/core/lib/getDefaultRegistry.js");








/** The `Form` component renders the outer form and all the fields defined in the `schema` */
class Form extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    /** Constructs the `Form` from the `props`. Will setup the initial state from the props. It will also call the
     * `onChange` handler if the initially provided `formData` is modified to add missing default values as part of the
     * state construction.
     *
     * @param props - The initial props for the `Form`
     */
    constructor(props) {
        super(props);
        /** Returns the `formData` with only the elements specified in the `fields` list
         *
         * @param formData - The data for the `Form`
         * @param fields - The fields to keep while filtering
         */
        this.getUsedFormData = (formData, fields) => {
            // For the case of a single input form
            if (fields.length === 0 && typeof formData !== 'object') {
                return formData;
            }
            // _pick has incorrect type definition, it works with string[][], because lodash/hasIn supports it
            const data = lodash_pick__WEBPACK_IMPORTED_MODULE_5___default()(formData, fields);
            if (Array.isArray(formData)) {
                return Object.keys(data).map((key) => data[key]);
            }
            return data;
        };
        /** Returns the list of field names from inspecting the `pathSchema` as well as using the `formData`
         *
         * @param pathSchema - The `PathSchema` object for the form
         * @param [formData] - The form data to use while checking for empty objects/arrays
         */
        this.getFieldNames = (pathSchema, formData) => {
            const getAllPaths = (_obj, acc = [], paths = [[]]) => {
                Object.keys(_obj).forEach((key) => {
                    if (typeof _obj[key] === 'object') {
                        const newPaths = paths.map((path) => [...path, key]);
                        // If an object is marked with additionalProperties, all its keys are valid
                        if (_obj[key][_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.RJSF_ADDITONAL_PROPERTIES_FLAG] && _obj[key][_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.NAME_KEY] !== '') {
                            acc.push(_obj[key][_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.NAME_KEY]);
                        }
                        else {
                            getAllPaths(_obj[key], acc, newPaths);
                        }
                    }
                    else if (key === _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.NAME_KEY && _obj[key] !== '') {
                        paths.forEach((path) => {
                            const formValue = lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(formData, path);
                            // adds path to fieldNames if it points to a value
                            // or an empty object/array
                            if (typeof formValue !== 'object' || lodash_isEmpty__WEBPACK_IMPORTED_MODULE_4___default()(formValue)) {
                                acc.push(path);
                            }
                        });
                    }
                });
                return acc;
            };
            return getAllPaths(pathSchema);
        };
        /** Function to handle changes made to a field in the `Form`. This handler receives an entirely new copy of the
         * `formData` along with a new `ErrorSchema`. It will first update the `formData` with any missing default fields and
         * then, if `omitExtraData` and `liveOmit` are turned on, the `formData` will be filterer to remove any extra data not
         * in a form field. Then, the resulting formData will be validated if required. The state will be updated with the new
         * updated (potentially filtered) `formData`, any errors that resulted from validation. Finally the `onChange`
         * callback will be called if specified with the updated state.
         *
         * @param formData - The new form data from a change to a field
         * @param newErrorSchema - The new `ErrorSchema` based on the field change
         * @param id - The id of the field that caused the change
         */
        this.onChange = (formData, newErrorSchema, id) => {
            const { extraErrors, omitExtraData, liveOmit, noValidate, liveValidate, onChange } = this.props;
            const { schemaUtils, schema, retrievedSchema } = this.state;
            if ((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.isObject)(formData) || Array.isArray(formData)) {
                const newState = this.getStateFromProps(this.props, formData, retrievedSchema);
                formData = newState.formData;
            }
            const mustValidate = !noValidate && liveValidate;
            let state = { formData, schema };
            let newFormData = formData;
            let _retrievedSchema;
            if (omitExtraData === true && liveOmit === true) {
                _retrievedSchema = schemaUtils.retrieveSchema(schema, formData);
                const pathSchema = schemaUtils.toPathSchema(_retrievedSchema, '', formData);
                const fieldNames = this.getFieldNames(pathSchema, formData);
                newFormData = this.getUsedFormData(formData, fieldNames);
                state = {
                    formData: newFormData,
                };
            }
            if (mustValidate) {
                const schemaValidation = this.validate(newFormData, schema, schemaUtils, retrievedSchema);
                let errors = schemaValidation.errors;
                let errorSchema = schemaValidation.errorSchema;
                const schemaValidationErrors = errors;
                const schemaValidationErrorSchema = errorSchema;
                if (extraErrors) {
                    const merged = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.validationDataMerge)(schemaValidation, extraErrors);
                    errorSchema = merged.errorSchema;
                    errors = merged.errors;
                }
                state = {
                    formData: newFormData,
                    errors,
                    errorSchema,
                    schemaValidationErrors,
                    schemaValidationErrorSchema,
                };
            }
            else if (!noValidate && newErrorSchema) {
                const errorSchema = extraErrors
                    ? (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.mergeObjects)(newErrorSchema, extraErrors, 'preventDuplicates')
                    : newErrorSchema;
                state = {
                    formData: newFormData,
                    errorSchema: errorSchema,
                    errors: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.toErrorList)(errorSchema),
                };
            }
            if (_retrievedSchema) {
                state.retrievedSchema = _retrievedSchema;
            }
            this.setState(state, () => onChange && onChange({ ...this.state, ...state }, id));
        };
        /**
         * Callback function to handle reset form data.
         * - Reset all fields with default values.
         * - Reset validations and errors
         *
         */
        this.reset = () => {
            const { onChange } = this.props;
            const newState = this.getStateFromProps(this.props, undefined);
            const newFormData = newState.formData;
            const state = {
                formData: newFormData,
                errorSchema: {},
                errors: [],
                schemaValidationErrors: [],
                schemaValidationErrorSchema: {},
            };
            this.setState(state, () => onChange && onChange({ ...this.state, ...state }));
        };
        /** Callback function to handle when a field on the form is blurred. Calls the `onBlur` callback for the `Form` if it
         * was provided.
         *
         * @param id - The unique `id` of the field that was blurred
         * @param data - The data associated with the field that was blurred
         */
        this.onBlur = (id, data) => {
            const { onBlur } = this.props;
            if (onBlur) {
                onBlur(id, data);
            }
        };
        /** Callback function to handle when a field on the form is focused. Calls the `onFocus` callback for the `Form` if it
         * was provided.
         *
         * @param id - The unique `id` of the field that was focused
         * @param data - The data associated with the field that was focused
         */
        this.onFocus = (id, data) => {
            const { onFocus } = this.props;
            if (onFocus) {
                onFocus(id, data);
            }
        };
        /** Callback function to handle when the form is submitted. First, it prevents the default event behavior. Nothing
         * happens if the target and currentTarget of the event are not the same. It will omit any extra data in the
         * `formData` in the state if `omitExtraData` is true. It will validate the resulting `formData`, reporting errors
         * via the `onError()` callback unless validation is disabled. Finally, it will add in any `extraErrors` and then call
         * back the `onSubmit` callback if it was provided.
         *
         * @param event - The submit HTML form event
         */
        this.onSubmit = (event) => {
            event.preventDefault();
            if (event.target !== event.currentTarget) {
                return;
            }
            event.persist();
            const { omitExtraData, extraErrors, noValidate, onSubmit } = this.props;
            let { formData: newFormData } = this.state;
            const { schema, schemaUtils } = this.state;
            if (omitExtraData === true) {
                const retrievedSchema = schemaUtils.retrieveSchema(schema, newFormData);
                const pathSchema = schemaUtils.toPathSchema(retrievedSchema, '', newFormData);
                const fieldNames = this.getFieldNames(pathSchema, newFormData);
                newFormData = this.getUsedFormData(newFormData, fieldNames);
            }
            if (noValidate || this.validateForm()) {
                // There are no errors generated through schema validation.
                // Check for user provided errors and update state accordingly.
                const errorSchema = extraErrors || {};
                const errors = extraErrors ? (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.toErrorList)(extraErrors) : [];
                this.setState({
                    formData: newFormData,
                    errors,
                    errorSchema,
                    schemaValidationErrors: [],
                    schemaValidationErrorSchema: {},
                }, () => {
                    if (onSubmit) {
                        onSubmit({ ...this.state, formData: newFormData, status: 'submitted' }, event);
                    }
                });
            }
        };
        if (!props.validator) {
            throw new Error('A validator is required for Form functionality to work');
        }
        this.state = this.getStateFromProps(props, props.formData);
        if (this.props.onChange && !(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.deepEquals)(this.state.formData, this.props.formData)) {
            this.props.onChange(this.state);
        }
        this.formElement = (0,react__WEBPACK_IMPORTED_MODULE_1__.createRef)();
    }
    /**
     * `getSnapshotBeforeUpdate` is a React lifecycle method that is invoked right before the most recently rendered
     * output is committed to the DOM. It enables your component to capture current values (e.g., scroll position) before
     * they are potentially changed.
     *
     * In this case, it checks if the props have changed since the last render. If they have, it computes the next state
     * of the component using `getStateFromProps` method and returns it along with a `shouldUpdate` flag set to `true` IF
     * the `nextState` and `prevState` are different, otherwise `false`. This ensures that we have the most up-to-date
     * state ready to be applied in `componentDidUpdate`.
     *
     * If `formData` hasn't changed, it simply returns an object with `shouldUpdate` set to `false`, indicating that a
     * state update is not necessary.
     *
     * @param prevProps - The previous set of props before the update.
     * @param prevState - The previous state before the update.
     * @returns Either an object containing the next state and a flag indicating that an update should occur, or an object
     *        with a flag indicating that an update is not necessary.
     */
    getSnapshotBeforeUpdate(prevProps, prevState) {
        if (!(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.deepEquals)(this.props, prevProps)) {
            const nextState = this.getStateFromProps(this.props, this.props.formData, prevProps.schema !== this.props.schema ? undefined : this.state.retrievedSchema);
            const shouldUpdate = !(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.deepEquals)(nextState, prevState);
            return { nextState, shouldUpdate };
        }
        return { shouldUpdate: false };
    }
    /**
     * `componentDidUpdate` is a React lifecycle method that is invoked immediately after updating occurs. This method is
     * not called for the initial render.
     *
     * Here, it checks if an update is necessary based on the `shouldUpdate` flag received from `getSnapshotBeforeUpdate`.
     * If an update is required, it applies the next state and, if needed, triggers the `onChange` handler to inform about
     * changes.
     *
     * This method effectively replaces the deprecated `UNSAFE_componentWillReceiveProps`, providing a safer alternative
     * to handle prop changes and state updates.
     *
     * @param _ - The previous set of props.
     * @param prevState - The previous state of the component before the update.
     * @param snapshot - The value returned from `getSnapshotBeforeUpdate`.
     */
    componentDidUpdate(_, prevState, snapshot) {
        if (snapshot.shouldUpdate) {
            const { nextState } = snapshot;
            if (!(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.deepEquals)(nextState.formData, this.props.formData) &&
                !(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.deepEquals)(nextState.formData, prevState.formData) &&
                this.props.onChange) {
                this.props.onChange(nextState);
            }
            this.setState(nextState);
        }
    }
    /** Extracts the updated state from the given `props` and `inputFormData`. As part of this process, the
     * `inputFormData` is first processed to add any missing required defaults. After that, the data is run through the
     * validation process IF required by the `props`.
     *
     * @param props - The props passed to the `Form`
     * @param inputFormData - The new or current data for the `Form`
     * @returns - The new state for the `Form`
     */
    getStateFromProps(props, inputFormData, retrievedSchema) {
        const state = this.state || {};
        const schema = 'schema' in props ? props.schema : this.props.schema;
        const uiSchema = ('uiSchema' in props ? props.uiSchema : this.props.uiSchema) || {};
        const edit = typeof inputFormData !== 'undefined';
        const liveValidate = 'liveValidate' in props ? props.liveValidate : this.props.liveValidate;
        const mustValidate = edit && !props.noValidate && liveValidate;
        const rootSchema = schema;
        const experimental_defaultFormStateBehavior = 'experimental_defaultFormStateBehavior' in props
            ? props.experimental_defaultFormStateBehavior
            : this.props.experimental_defaultFormStateBehavior;
        let schemaUtils = state.schemaUtils;
        if (!schemaUtils ||
            schemaUtils.doesSchemaUtilsDiffer(props.validator, rootSchema, experimental_defaultFormStateBehavior)) {
            schemaUtils = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.createSchemaUtils)(props.validator, rootSchema, experimental_defaultFormStateBehavior);
        }
        const formData = schemaUtils.getDefaultFormState(schema, inputFormData);
        const _retrievedSchema = retrievedSchema !== null && retrievedSchema !== void 0 ? retrievedSchema : schemaUtils.retrieveSchema(schema, formData);
        const getCurrentErrors = () => {
            if (props.noValidate) {
                return { errors: [], errorSchema: {} };
            }
            else if (!props.liveValidate) {
                return {
                    errors: state.schemaValidationErrors || [],
                    errorSchema: state.schemaValidationErrorSchema || {},
                };
            }
            return {
                errors: state.errors || [],
                errorSchema: state.errorSchema || {},
            };
        };
        let errors;
        let errorSchema;
        let schemaValidationErrors = state.schemaValidationErrors;
        let schemaValidationErrorSchema = state.schemaValidationErrorSchema;
        if (mustValidate) {
            const schemaValidation = this.validate(formData, schema, schemaUtils, _retrievedSchema);
            errors = schemaValidation.errors;
            errorSchema = schemaValidation.errorSchema;
            schemaValidationErrors = errors;
            schemaValidationErrorSchema = errorSchema;
        }
        else {
            const currentErrors = getCurrentErrors();
            errors = currentErrors.errors;
            errorSchema = currentErrors.errorSchema;
        }
        if (props.extraErrors) {
            const merged = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.validationDataMerge)({ errorSchema, errors }, props.extraErrors);
            errorSchema = merged.errorSchema;
            errors = merged.errors;
        }
        const idSchema = schemaUtils.toIdSchema(_retrievedSchema, uiSchema['ui:rootFieldId'], formData, props.idPrefix, props.idSeparator);
        const nextState = {
            schemaUtils,
            schema,
            uiSchema,
            idSchema,
            formData,
            edit,
            errors,
            errorSchema,
            schemaValidationErrors,
            schemaValidationErrorSchema,
            retrievedSchema: _retrievedSchema,
        };
        return nextState;
    }
    /** React lifecycle method that is used to determine whether component should be updated.
     *
     * @param nextProps - The next version of the props
     * @param nextState - The next version of the state
     * @returns - True if the component should be updated, false otherwise
     */
    shouldComponentUpdate(nextProps, nextState) {
        return (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.shouldRender)(this, nextProps, nextState);
    }
    /** Validates the `formData` against the `schema` using the `altSchemaUtils` (if provided otherwise it uses the
     * `schemaUtils` in the state), returning the results.
     *
     * @param formData - The new form data to validate
     * @param schema - The schema used to validate against
     * @param altSchemaUtils - The alternate schemaUtils to use for validation
     */
    validate(formData, schema = this.props.schema, altSchemaUtils, retrievedSchema) {
        const schemaUtils = altSchemaUtils ? altSchemaUtils : this.state.schemaUtils;
        const { customValidate, transformErrors, uiSchema } = this.props;
        const resolvedSchema = retrievedSchema !== null && retrievedSchema !== void 0 ? retrievedSchema : schemaUtils.retrieveSchema(schema, formData);
        return schemaUtils
            .getValidator()
            .validateFormData(formData, resolvedSchema, customValidate, transformErrors, uiSchema);
    }
    /** Renders any errors contained in the `state` in using the `ErrorList`, if not disabled by `showErrorList`. */
    renderErrors(registry) {
        const { errors, errorSchema, schema, uiSchema } = this.state;
        const { formContext } = this.props;
        const options = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema);
        const ErrorListTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('ErrorListTemplate', registry, options);
        if (errors && errors.length) {
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ErrorListTemplate, { errors: errors, errorSchema: errorSchema || {}, schema: schema, uiSchema: uiSchema, formContext: formContext, registry: registry }));
        }
        return null;
    }
    /** Returns the registry for the form */
    getRegistry() {
        var _a;
        const { translateString: customTranslateString, uiSchema = {} } = this.props;
        const { schemaUtils } = this.state;
        const { fields, templates, widgets, formContext, translateString } = (0,_getDefaultRegistry__WEBPACK_IMPORTED_MODULE_7__["default"])();
        return {
            fields: { ...fields, ...this.props.fields },
            templates: {
                ...templates,
                ...this.props.templates,
                ButtonTemplates: {
                    ...templates.ButtonTemplates,
                    ...(_a = this.props.templates) === null || _a === void 0 ? void 0 : _a.ButtonTemplates,
                },
            },
            widgets: { ...widgets, ...this.props.widgets },
            rootSchema: this.props.schema,
            formContext: this.props.formContext || formContext,
            schemaUtils,
            translateString: customTranslateString || translateString,
            globalUiOptions: uiSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.UI_GLOBAL_OPTIONS_KEY],
        };
    }
    /** Provides a function that can be used to programmatically submit the `Form` */
    submit() {
        if (this.formElement.current) {
            this.formElement.current.dispatchEvent(new CustomEvent('submit', {
                cancelable: true,
            }));
            this.formElement.current.requestSubmit();
        }
    }
    /** Attempts to focus on the field associated with the `error`. Uses the `property` field to compute path of the error
     * field, then, using the `idPrefix` and `idSeparator` converts that path into an id. Then the input element with that
     * id is attempted to be found using the `formElement` ref. If it is located, then it is focused.
     *
     * @param error - The error on which to focus
     */
    focusOnError(error) {
        const { idPrefix = 'root', idSeparator = '_' } = this.props;
        const { property } = error;
        const path = lodash_toPath__WEBPACK_IMPORTED_MODULE_6___default()(property);
        if (path[0] === '') {
            // Most of the time the `.foo` property results in the first element being empty, so replace it with the idPrefix
            path[0] = idPrefix;
        }
        else {
            // Otherwise insert the idPrefix into the first location using unshift
            path.unshift(idPrefix);
        }
        const elementId = path.join(idSeparator);
        let field = this.formElement.current.elements[elementId];
        if (!field) {
            // if not an exact match, try finding an input starting with the element id (like radio buttons or checkboxes)
            field = this.formElement.current.querySelector(`input[id^=${elementId}`);
        }
        if (field && field.length) {
            // If we got a list with length > 0
            field = field[0];
        }
        if (field) {
            field.focus();
        }
    }
    /** Programmatically validate the form. If `onError` is provided, then it will be called with the list of errors the
     * same way as would happen on form submission.
     *
     * @returns - True if the form is valid, false otherwise.
     */
    validateForm() {
        const { extraErrors, extraErrorsBlockSubmit, focusOnFirstError, onError } = this.props;
        const { formData, errors: prevErrors } = this.state;
        const schemaValidation = this.validate(formData);
        let errors = schemaValidation.errors;
        let errorSchema = schemaValidation.errorSchema;
        const schemaValidationErrors = errors;
        const schemaValidationErrorSchema = errorSchema;
        const hasError = errors.length > 0 || (extraErrors && extraErrorsBlockSubmit);
        if (hasError) {
            if (extraErrors) {
                const merged = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.validationDataMerge)(schemaValidation, extraErrors);
                errorSchema = merged.errorSchema;
                errors = merged.errors;
            }
            if (focusOnFirstError) {
                if (typeof focusOnFirstError === 'function') {
                    focusOnFirstError(errors[0]);
                }
                else {
                    this.focusOnError(errors[0]);
                }
            }
            this.setState({
                errors,
                errorSchema,
                schemaValidationErrors,
                schemaValidationErrorSchema,
            }, () => {
                if (onError) {
                    onError(errors);
                }
                else {
                    console.error('Form validation failed', errors);
                }
            });
        }
        else if (prevErrors.length > 0) {
            this.setState({
                errors: [],
                errorSchema: {},
                schemaValidationErrors: [],
                schemaValidationErrorSchema: {},
            });
        }
        return !hasError;
    }
    /** Renders the `Form` fields inside the <form> | `tagName` or `_internalFormWrapper`, rendering any errors if
     * needed along with the submit button or any children of the form.
     */
    render() {
        const { children, id, idPrefix, idSeparator, className = '', tagName, name, method, target, action, autoComplete, enctype, acceptcharset, noHtml5Validate = false, disabled = false, readonly = false, formContext, showErrorList = 'top', _internalFormWrapper, } = this.props;
        const { schema, uiSchema, formData, errorSchema, idSchema } = this.state;
        const registry = this.getRegistry();
        const { SchemaField: _SchemaField } = registry.fields;
        const { SubmitButton } = registry.templates.ButtonTemplates;
        // The `semantic-ui` and `material-ui` themes have `_internalFormWrapper`s that take an `as` prop that is the
        // PropTypes.elementType to use for the inner tag, so we'll need to pass `tagName` along if it is provided.
        // NOTE, the `as` prop is native to `semantic-ui` and is emulated in the `material-ui` theme
        const as = _internalFormWrapper ? tagName : undefined;
        const FormTag = _internalFormWrapper || tagName || 'form';
        let { [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.SUBMIT_BTN_OPTIONS_KEY]: submitOptions = {} } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema);
        if (disabled) {
            submitOptions = { ...submitOptions, props: { ...submitOptions.props, disabled: true } };
        }
        const submitUiSchema = { [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.UI_OPTIONS_KEY]: { [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.SUBMIT_BTN_OPTIONS_KEY]: submitOptions } };
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(FormTag, { className: className ? className : 'rjsf', id: id, name: name, method: method, target: target, action: action, autoComplete: autoComplete, encType: enctype, acceptCharset: acceptcharset, noValidate: noHtml5Validate, onSubmit: this.onSubmit, as: as, ref: this.formElement, children: [showErrorList === 'top' && this.renderErrors(registry), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_SchemaField, { name: '', schema: schema, uiSchema: uiSchema, errorSchema: errorSchema, idSchema: idSchema, idPrefix: idPrefix, idSeparator: idSeparator, formContext: formContext, formData: formData, onChange: this.onChange, onBlur: this.onBlur, onFocus: this.onFocus, registry: registry, disabled: disabled, readonly: readonly }), children ? children : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SubmitButton, { uiSchema: submitUiSchema, registry: registry }), showErrorList === 'bottom' && this.renderErrors(registry)] }));
    }
}
//# sourceMappingURL=Form.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/ArrayField.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/ArrayField.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/cloneDeep */ "./node_modules/lodash/cloneDeep.js");
/* harmony import */ var lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/set */ "./node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var nanoid__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! nanoid */ "./node_modules/nanoid/index.browser.js");








/** Used to generate a unique ID for an element in a row */
function generateRowId() {
    return (0,nanoid__WEBPACK_IMPORTED_MODULE_7__.nanoid)();
}
/** Converts the `formData` into `KeyedFormDataType` data, using the `generateRowId()` function to create the key
 *
 * @param formData - The data for the form
 * @returns - The `formData` converted into a `KeyedFormDataType` element
 */
function generateKeyedFormData(formData) {
    return !Array.isArray(formData)
        ? []
        : formData.map((item) => {
            return {
                key: generateRowId(),
                item,
            };
        });
}
/** Converts `KeyedFormDataType` data into the inner `formData`
 *
 * @param keyedFormData - The `KeyedFormDataType` to be converted
 * @returns - The inner `formData` item(s) in the `keyedFormData`
 */
function keyedToPlainFormData(keyedFormData) {
    if (Array.isArray(keyedFormData)) {
        return keyedFormData.map((keyedItem) => keyedItem.item);
    }
    return [];
}
/** The `ArrayField` component is used to render a field in the schema that is of type `array`. It supports both normal
 * and fixed array, allowing user to add and remove elements from the array data.
 */
class ArrayField extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    /** Constructs an `ArrayField` from the `props`, generating the initial keyed data from the `formData`
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(props) {
        super(props);
        /** Returns the default form information for an item based on the schema for that item. Deals with the possibility
         * that the schema is fixed and allows additional items.
         */
        this._getNewFormDataRow = () => {
            const { schema, registry } = this.props;
            const { schemaUtils } = registry;
            let itemSchema = schema.items;
            if ((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.isFixedItems)(schema) && (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.allowAdditionalItems)(schema)) {
                itemSchema = schema.additionalItems;
            }
            // Cast this as a T to work around schema utils being for T[] caused by the FieldProps<T[], S, F> call on the class
            return schemaUtils.getDefaultFormState(itemSchema);
        };
        /** Callback handler for when the user clicks on the add button. Creates a new row of keyed form data at the end of
         * the list, adding it into the state, and then returning `onChange()` with the plain form data converted from the
         * keyed data
         *
         * @param event - The event for the click
         */
        this.onAddClick = (event) => {
            this._handleAddClick(event);
        };
        /** Callback handler for when the user clicks on the add button on an existing array element. Creates a new row of
         * keyed form data inserted at the `index`, adding it into the state, and then returning `onChange()` with the plain
         * form data converted from the keyed data
         *
         * @param index - The index at which the add button is clicked
         */
        this.onAddIndexClick = (index) => {
            return (event) => {
                this._handleAddClick(event, index);
            };
        };
        /** Callback handler for when the user clicks on the copy button on an existing array element. Clones the row of
         * keyed form data at the `index` into the next position in the state, and then returning `onChange()` with the plain
         * form data converted from the keyed data
         *
         * @param index - The index at which the copy button is clicked
         */
        this.onCopyIndexClick = (index) => {
            return (event) => {
                if (event) {
                    event.preventDefault();
                }
                const { onChange, errorSchema } = this.props;
                const { keyedFormData } = this.state;
                // refs #195: revalidate to ensure properly reindexing errors
                let newErrorSchema;
                if (errorSchema) {
                    newErrorSchema = {};
                    for (const idx in errorSchema) {
                        const i = parseInt(idx);
                        if (i <= index) {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [i], errorSchema[idx]);
                        }
                        else if (i > index) {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [i + 1], errorSchema[idx]);
                        }
                    }
                }
                const newKeyedFormDataRow = {
                    key: generateRowId(),
                    item: lodash_cloneDeep__WEBPACK_IMPORTED_MODULE_3___default()(keyedFormData[index].item),
                };
                const newKeyedFormData = [...keyedFormData];
                if (index !== undefined) {
                    newKeyedFormData.splice(index + 1, 0, newKeyedFormDataRow);
                }
                else {
                    newKeyedFormData.push(newKeyedFormDataRow);
                }
                this.setState({
                    keyedFormData: newKeyedFormData,
                    updatedKeyedFormData: true,
                }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));
            };
        };
        /** Callback handler for when the user clicks on the remove button on an existing array element. Removes the row of
         * keyed form data at the `index` in the state, and then returning `onChange()` with the plain form data converted
         * from the keyed data
         *
         * @param index - The index at which the remove button is clicked
         */
        this.onDropIndexClick = (index) => {
            return (event) => {
                if (event) {
                    event.preventDefault();
                }
                const { onChange, errorSchema } = this.props;
                const { keyedFormData } = this.state;
                // refs #195: revalidate to ensure properly reindexing errors
                let newErrorSchema;
                if (errorSchema) {
                    newErrorSchema = {};
                    for (const idx in errorSchema) {
                        const i = parseInt(idx);
                        if (i < index) {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [i], errorSchema[idx]);
                        }
                        else if (i > index) {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [i - 1], errorSchema[idx]);
                        }
                    }
                }
                const newKeyedFormData = keyedFormData.filter((_, i) => i !== index);
                this.setState({
                    keyedFormData: newKeyedFormData,
                    updatedKeyedFormData: true,
                }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));
            };
        };
        /** Callback handler for when the user clicks on one of the move item buttons on an existing array element. Moves the
         * row of keyed form data at the `index` to the `newIndex` in the state, and then returning `onChange()` with the
         * plain form data converted from the keyed data
         *
         * @param index - The index of the item to move
         * @param newIndex - The index to where the item is to be moved
         */
        this.onReorderClick = (index, newIndex) => {
            return (event) => {
                if (event) {
                    event.preventDefault();
                    event.currentTarget.blur();
                }
                const { onChange, errorSchema } = this.props;
                let newErrorSchema;
                if (errorSchema) {
                    newErrorSchema = {};
                    for (const idx in errorSchema) {
                        const i = parseInt(idx);
                        if (i == index) {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [newIndex], errorSchema[index]);
                        }
                        else if (i == newIndex) {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [index], errorSchema[newIndex]);
                        }
                        else {
                            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [idx], errorSchema[i]);
                        }
                    }
                }
                const { keyedFormData } = this.state;
                function reOrderArray() {
                    // Copy item
                    const _newKeyedFormData = keyedFormData.slice();
                    // Moves item from index to newIndex
                    _newKeyedFormData.splice(index, 1);
                    _newKeyedFormData.splice(newIndex, 0, keyedFormData[index]);
                    return _newKeyedFormData;
                }
                const newKeyedFormData = reOrderArray();
                this.setState({
                    keyedFormData: newKeyedFormData,
                }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));
            };
        };
        /** Callback handler used to deal with changing the value of the data in the array at the `index`. Calls the
         * `onChange` callback with the updated form data
         *
         * @param index - The index of the item being changed
         */
        this.onChangeForIndex = (index) => {
            return (value, newErrorSchema, id) => {
                const { formData, onChange, errorSchema } = this.props;
                const arrayData = Array.isArray(formData) ? formData : [];
                const newFormData = arrayData.map((item, i) => {
                    // We need to treat undefined items as nulls to have validation.
                    // See https://github.com/tdegrunt/jsonschema/issues/206
                    const jsonValue = typeof value === 'undefined' ? null : value;
                    return index === i ? jsonValue : item;
                });
                onChange(newFormData, errorSchema &&
                    errorSchema && {
                    ...errorSchema,
                    [index]: newErrorSchema,
                }, id);
            };
        };
        /** Callback handler used to change the value for a checkbox */
        this.onSelectChange = (value) => {
            const { onChange, idSchema } = this.props;
            onChange(value, undefined, idSchema && idSchema.$id);
        };
        const { formData = [] } = props;
        const keyedFormData = generateKeyedFormData(formData);
        this.state = {
            keyedFormData,
            updatedKeyedFormData: false,
        };
    }
    /** React lifecycle method that is called when the props are about to change allowing the state to be updated. It
     * regenerates the keyed form data and returns it
     *
     * @param nextProps - The next set of props data
     * @param prevState - The previous set of state data
     */
    static getDerivedStateFromProps(nextProps, prevState) {
        // Don't call getDerivedStateFromProps if keyed formdata was just updated.
        if (prevState.updatedKeyedFormData) {
            return {
                updatedKeyedFormData: false,
            };
        }
        const nextFormData = Array.isArray(nextProps.formData) ? nextProps.formData : [];
        const previousKeyedFormData = prevState.keyedFormData || [];
        const newKeyedFormData = nextFormData.length === previousKeyedFormData.length
            ? previousKeyedFormData.map((previousKeyedFormDatum, index) => {
                return {
                    key: previousKeyedFormDatum.key,
                    item: nextFormData[index],
                };
            })
            : generateKeyedFormData(nextFormData);
        return {
            keyedFormData: newKeyedFormData,
        };
    }
    /** Returns the appropriate title for an item by getting first the title from the schema.items, then falling back to
     * the description from the schema.items, and finally the string "Item"
     */
    get itemTitle() {
        const { schema, registry } = this.props;
        const { translateString } = registry;
        return lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(schema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY, 'title'], lodash_get__WEBPACK_IMPORTED_MODULE_4___default()(schema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY, 'description'], translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.ArrayItemTitle)));
    }
    /** Determines whether the item described in the schema is always required, which is determined by whether any item
     * may be null.
     *
     * @param itemSchema - The schema for the item
     * @return - True if the item schema type does not contain the "null" type
     */
    isItemRequired(itemSchema) {
        if (Array.isArray(itemSchema.type)) {
            // While we don't yet support composite/nullable jsonschema types, it's
            // future-proof to check for requirement against these.
            return !itemSchema.type.includes('null');
        }
        // All non-null array item types are inherently required by design
        return itemSchema.type !== 'null';
    }
    /** Determines whether more items can be added to the array. If the uiSchema indicates the array doesn't allow adding
     * then false is returned. Otherwise, if the schema indicates that there are a maximum number of items and the
     * `formData` matches that value, then false is returned, otherwise true is returned.
     *
     * @param formItems - The list of items in the form
     * @returns - True if the item is addable otherwise false
     */
    canAddItem(formItems) {
        const { schema, uiSchema, registry } = this.props;
        let { addable } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, registry.globalUiOptions);
        if (addable !== false) {
            // if ui:options.addable was not explicitly set to false, we can add
            // another item if we have not exceeded maxItems yet
            if (schema.maxItems !== undefined) {
                addable = formItems.length < schema.maxItems;
            }
            else {
                addable = true;
            }
        }
        return addable;
    }
    /** Callback handler for when the user clicks on the add or add at index buttons. Creates a new row of keyed form data
     * either at the end of the list (when index is not specified) or inserted at the `index` when it is, adding it into
     * the state, and then returning `onChange()` with the plain form data converted from the keyed data
     *
     * @param event - The event for the click
     * @param [index] - The optional index at which to add the new data
     */
    _handleAddClick(event, index) {
        if (event) {
            event.preventDefault();
        }
        const { onChange, errorSchema } = this.props;
        const { keyedFormData } = this.state;
        // refs #195: revalidate to ensure properly reindexing errors
        let newErrorSchema;
        if (errorSchema) {
            newErrorSchema = {};
            for (const idx in errorSchema) {
                const i = parseInt(idx);
                if (index === undefined || i < index) {
                    lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [i], errorSchema[idx]);
                }
                else if (i >= index) {
                    lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newErrorSchema, [i + 1], errorSchema[idx]);
                }
            }
        }
        const newKeyedFormDataRow = {
            key: generateRowId(),
            item: this._getNewFormDataRow(),
        };
        const newKeyedFormData = [...keyedFormData];
        if (index !== undefined) {
            newKeyedFormData.splice(index, 0, newKeyedFormDataRow);
        }
        else {
            newKeyedFormData.push(newKeyedFormDataRow);
        }
        this.setState({
            keyedFormData: newKeyedFormData,
            updatedKeyedFormData: true,
        }, () => onChange(keyedToPlainFormData(newKeyedFormData), newErrorSchema));
    }
    /** Renders the `ArrayField` depending on the specific needs of the schema and uischema elements
     */
    render() {
        const { schema, uiSchema, idSchema, registry } = this.props;
        const { schemaUtils, translateString } = registry;
        if (!(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ITEMS_KEY in schema)) {
            const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema);
            const UnsupportedFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('UnsupportedFieldTemplate', registry, uiOptions);
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnsupportedFieldTemplate, { schema: schema, idSchema: idSchema, reason: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.MissingItems), registry: registry }));
        }
        if (schemaUtils.isMultiSelect(schema)) {
            // If array has enum or uniqueItems set to true, call renderMultiSelect() to render the default multiselect widget or a custom widget, if specified.
            return this.renderMultiSelect();
        }
        if ((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.isCustomWidget)(uiSchema)) {
            return this.renderCustomWidget();
        }
        if ((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.isFixedItems)(schema)) {
            return this.renderFixedArray();
        }
        if (schemaUtils.isFilesArray(schema, uiSchema)) {
            return this.renderFiles();
        }
        return this.renderNormalArray();
    }
    /** Renders a normal array without any limitations of length
     */
    renderNormalArray() {
        const { schema, uiSchema = {}, errorSchema, idSchema, name, disabled = false, readonly = false, autofocus = false, required = false, registry, onBlur, onFocus, idPrefix, idSeparator = '_', rawErrors, } = this.props;
        const { keyedFormData } = this.state;
        const title = schema.title === undefined ? name : schema.title;
        const { schemaUtils, formContext } = registry;
        const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema);
        const _schemaItems = lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default()(schema.items) ? schema.items : {};
        const itemsSchema = schemaUtils.retrieveSchema(_schemaItems);
        const formData = keyedToPlainFormData(this.state.keyedFormData);
        const canAdd = this.canAddItem(formData);
        const arrayProps = {
            canAdd,
            items: keyedFormData.map((keyedItem, index) => {
                const { key, item } = keyedItem;
                // While we are actually dealing with a single item of type T, the types require a T[], so cast
                const itemCast = item;
                const itemSchema = schemaUtils.retrieveSchema(_schemaItems, itemCast);
                const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;
                const itemIdPrefix = idSchema.$id + idSeparator + index;
                const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);
                return this.renderArrayFieldItem({
                    key,
                    index,
                    name: name && `${name}-${index}`,
                    canAdd,
                    canMoveUp: index > 0,
                    canMoveDown: index < formData.length - 1,
                    itemSchema,
                    itemIdSchema,
                    itemErrorSchema,
                    itemData: itemCast,
                    itemUiSchema: uiSchema.items,
                    autofocus: autofocus && index === 0,
                    onBlur,
                    onFocus,
                    rawErrors,
                    totalItems: keyedFormData.length,
                });
            }),
            className: `field field-array field-array-of-${itemsSchema.type}`,
            disabled,
            idSchema,
            uiSchema,
            onAddClick: this.onAddClick,
            readonly,
            required,
            schema,
            title,
            formContext,
            formData,
            rawErrors,
            registry,
        };
        const Template = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('ArrayFieldTemplate', registry, uiOptions);
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Template, { ...arrayProps });
    }
    /** Renders an array using the custom widget provided by the user in the `uiSchema`
     */
    renderCustomWidget() {
        var _a;
        const { schema, idSchema, uiSchema, disabled = false, readonly = false, autofocus = false, required = false, hideError, placeholder, onBlur, onFocus, formData: items = [], registry, rawErrors, name, } = this.props;
        const { widgets, formContext, globalUiOptions, schemaUtils } = registry;
        const { widget, title: uiTitle, ...options } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, globalUiOptions);
        const Widget = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getWidget)(schema, widget, widgets);
        const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : schema.title) !== null && _a !== void 0 ? _a : name;
        const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Widget, { id: idSchema.$id, name: name, multiple: true, onChange: this.onSelectChange, onBlur: onBlur, onFocus: onFocus, options: options, schema: schema, uiSchema: uiSchema, registry: registry, value: items, disabled: disabled, readonly: readonly, hideError: hideError, required: required, label: label, hideLabel: !displayLabel, placeholder: placeholder, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors }));
    }
    /** Renders an array as a set of checkboxes
     */
    renderMultiSelect() {
        var _a;
        const { schema, idSchema, uiSchema, formData: items = [], disabled = false, readonly = false, autofocus = false, required = false, placeholder, onBlur, onFocus, registry, rawErrors, name, } = this.props;
        const { widgets, schemaUtils, formContext, globalUiOptions } = registry;
        const itemsSchema = schemaUtils.retrieveSchema(schema.items, items);
        const enumOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.optionsList)(itemsSchema);
        const { widget = 'select', title: uiTitle, ...options } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, globalUiOptions);
        const Widget = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getWidget)(schema, widget, widgets);
        const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : schema.title) !== null && _a !== void 0 ? _a : name;
        const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Widget, { id: idSchema.$id, name: name, multiple: true, onChange: this.onSelectChange, onBlur: onBlur, onFocus: onFocus, options: { ...options, enumOptions }, schema: schema, uiSchema: uiSchema, registry: registry, value: items, disabled: disabled, readonly: readonly, required: required, label: label, hideLabel: !displayLabel, placeholder: placeholder, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors }));
    }
    /** Renders an array of files using the `FileWidget`
     */
    renderFiles() {
        var _a;
        const { schema, uiSchema, idSchema, name, disabled = false, readonly = false, autofocus = false, required = false, onBlur, onFocus, registry, formData: items = [], rawErrors, } = this.props;
        const { widgets, formContext, globalUiOptions, schemaUtils } = registry;
        const { widget = 'files', title: uiTitle, ...options } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, globalUiOptions);
        const Widget = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getWidget)(schema, widget, widgets);
        const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : schema.title) !== null && _a !== void 0 ? _a : name;
        const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Widget, { options: options, id: idSchema.$id, name: name, multiple: true, onChange: this.onSelectChange, onBlur: onBlur, onFocus: onFocus, schema: schema, uiSchema: uiSchema, value: items, disabled: disabled, readonly: readonly, required: required, registry: registry, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors, label: label, hideLabel: !displayLabel }));
    }
    /** Renders an array that has a maximum limit of items
     */
    renderFixedArray() {
        const { schema, uiSchema = {}, formData = [], errorSchema, idPrefix, idSeparator = '_', idSchema, name, disabled = false, readonly = false, autofocus = false, required = false, registry, onBlur, onFocus, rawErrors, } = this.props;
        const { keyedFormData } = this.state;
        let { formData: items = [] } = this.props;
        const title = schema.title || name;
        const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema);
        const { schemaUtils, formContext } = registry;
        const _schemaItems = lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default()(schema.items) ? schema.items : [];
        const itemSchemas = _schemaItems.map((item, index) => schemaUtils.retrieveSchema(item, formData[index]));
        const additionalSchema = lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default()(schema.additionalItems)
            ? schemaUtils.retrieveSchema(schema.additionalItems, formData)
            : null;
        if (!items || items.length < itemSchemas.length) {
            // to make sure at least all fixed items are generated
            items = items || [];
            items = items.concat(new Array(itemSchemas.length - items.length));
        }
        // These are the props passed into the render function
        const canAdd = this.canAddItem(items) && !!additionalSchema;
        const arrayProps = {
            canAdd,
            className: 'field field-array field-array-fixed-items',
            disabled,
            idSchema,
            formData,
            items: keyedFormData.map((keyedItem, index) => {
                const { key, item } = keyedItem;
                // While we are actually dealing with a single item of type T, the types require a T[], so cast
                const itemCast = item;
                const additional = index >= itemSchemas.length;
                const itemSchema = (additional && lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default()(schema.additionalItems)
                    ? schemaUtils.retrieveSchema(schema.additionalItems, itemCast)
                    : itemSchemas[index]) || {};
                const itemIdPrefix = idSchema.$id + idSeparator + index;
                const itemIdSchema = schemaUtils.toIdSchema(itemSchema, itemIdPrefix, itemCast, idPrefix, idSeparator);
                const itemUiSchema = additional
                    ? uiSchema.additionalItems || {}
                    : Array.isArray(uiSchema.items)
                        ? uiSchema.items[index]
                        : uiSchema.items || {};
                const itemErrorSchema = errorSchema ? errorSchema[index] : undefined;
                return this.renderArrayFieldItem({
                    key,
                    index,
                    name: name && `${name}-${index}`,
                    canAdd,
                    canRemove: additional,
                    canMoveUp: index >= itemSchemas.length + 1,
                    canMoveDown: additional && index < items.length - 1,
                    itemSchema,
                    itemData: itemCast,
                    itemUiSchema,
                    itemIdSchema,
                    itemErrorSchema,
                    autofocus: autofocus && index === 0,
                    onBlur,
                    onFocus,
                    rawErrors,
                    totalItems: keyedFormData.length,
                });
            }),
            onAddClick: this.onAddClick,
            readonly,
            required,
            registry,
            schema,
            uiSchema,
            title,
            formContext,
            rawErrors,
        };
        const Template = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('ArrayFieldTemplate', registry, uiOptions);
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Template, { ...arrayProps });
    }
    /** Renders the individual array item using a `SchemaField` along with the additional properties required to be send
     * back to the `ArrayFieldItemTemplate`.
     *
     * @param props - The props for the individual array item to be rendered
     */
    renderArrayFieldItem(props) {
        const { key, index, name, canAdd, canRemove = true, canMoveUp, canMoveDown, itemSchema, itemData, itemUiSchema, itemIdSchema, itemErrorSchema, autofocus, onBlur, onFocus, rawErrors, totalItems, } = props;
        const { disabled, hideError, idPrefix, idSeparator, readonly, uiSchema, registry, formContext } = this.props;
        const { fields: { ArraySchemaField, SchemaField }, globalUiOptions, } = registry;
        const ItemSchemaField = ArraySchemaField || SchemaField;
        const { orderable = true, removable = true, copyable = false } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, globalUiOptions);
        const has = {
            moveUp: orderable && canMoveUp,
            moveDown: orderable && canMoveDown,
            copy: copyable && canAdd,
            remove: removable && canRemove,
            toolbar: false,
        };
        has.toolbar = Object.keys(has).some((key) => has[key]);
        return {
            children: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ItemSchemaField, { name: name, index: index, schema: itemSchema, uiSchema: itemUiSchema, formData: itemData, formContext: formContext, errorSchema: itemErrorSchema, idPrefix: idPrefix, idSeparator: idSeparator, idSchema: itemIdSchema, required: this.isItemRequired(itemSchema), onChange: this.onChangeForIndex(index), onBlur: onBlur, onFocus: onFocus, registry: registry, disabled: disabled, readonly: readonly, hideError: hideError, autofocus: autofocus, rawErrors: rawErrors })),
            className: 'array-item',
            disabled,
            canAdd,
            hasCopy: has.copy,
            hasToolbar: has.toolbar,
            hasMoveUp: has.moveUp,
            hasMoveDown: has.moveDown,
            hasRemove: has.remove,
            index,
            totalItems,
            key,
            onAddIndexClick: this.onAddIndexClick,
            onCopyIndexClick: this.onCopyIndexClick,
            onDropIndexClick: this.onDropIndexClick,
            onReorderClick: this.onReorderClick,
            readonly,
            registry,
            schema: itemSchema,
            uiSchema: itemUiSchema,
        };
    }
}
/** `ArrayField` is `React.ComponentType<FieldProps<T[], S, F>>` (necessarily) but the `registry` requires things to be a
 * `Field` which is defined as `React.ComponentType<FieldProps<T, S, F>>`, so cast it to make `registry` happy.
 */
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ArrayField);
//# sourceMappingURL=ArrayField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/BooleanField.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/BooleanField.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_2__);



/** The `BooleanField` component is used to render a field in the schema is boolean. It constructs `enumOptions` for the
 * two boolean values based on the various alternatives in the schema.
 *
 * @param props - The `FieldProps` for this template
 */
function BooleanField(props) {
    var _a, _b;
    const { schema, name, uiSchema, idSchema, formData, registry, required, disabled, readonly, hideError, autofocus, onChange, onFocus, onBlur, rawErrors, } = props;
    const { title } = schema;
    const { widgets, formContext, translateString, globalUiOptions } = registry;
    const { widget = 'checkbox', title: uiTitle, 
    // Unlike the other fields, don't use `getDisplayLabel()` since it always returns false for the boolean type
    label: displayLabel = true, ...options } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema, globalUiOptions);
    const Widget = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getWidget)(schema, widget, widgets);
    const yes = translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.YesLabel);
    const no = translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.NoLabel);
    let enumOptions;
    const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : title) !== null && _a !== void 0 ? _a : name;
    if (Array.isArray(schema.oneOf)) {
        enumOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.optionsList)({
            oneOf: schema.oneOf
                .map((option) => {
                if (lodash_isObject__WEBPACK_IMPORTED_MODULE_2___default()(option)) {
                    return {
                        ...option,
                        title: option.title || (option.const === true ? yes : no),
                    };
                }
                return undefined;
            })
                .filter((o) => o), // cast away the error that typescript can't grok is fixed
        });
    }
    else {
        // We deprecated enumNames in v5. It's intentionally omitted from RSJFSchema type, so we need to cast here.
        const schemaWithEnumNames = schema;
        const enums = (_b = schema.enum) !== null && _b !== void 0 ? _b : [true, false];
        if (!schemaWithEnumNames.enumNames && enums.length === 2 && enums.every((v) => typeof v === 'boolean')) {
            enumOptions = [
                {
                    value: enums[0],
                    label: enums[0] ? yes : no,
                },
                {
                    value: enums[1],
                    label: enums[1] ? yes : no,
                },
            ];
        }
        else {
            enumOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.optionsList)({
                enum: enums,
                // NOTE: enumNames is deprecated, but still supported for now.
                enumNames: schemaWithEnumNames.enumNames,
            });
        }
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Widget, { options: { ...options, enumOptions }, schema: schema, uiSchema: uiSchema, id: idSchema.$id, name: name, onChange: onChange, onFocus: onFocus, onBlur: onBlur, label: label, hideLabel: !displayLabel, value: formData, required: required, disabled: disabled, readonly: readonly, hideError: hideError, registry: registry, formContext: formContext, autofocus: autofocus, rawErrors: rawErrors }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (BooleanField);
//# sourceMappingURL=BooleanField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isEmpty */ "./node_modules/lodash/isEmpty.js");
/* harmony import */ var lodash_isEmpty__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isEmpty__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit */ "./node_modules/lodash/omit.js");
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__);






/** The `AnyOfField` component is used to render a field in the schema that is an `anyOf`, `allOf` or `oneOf`. It tracks
 * the currently selected option and cleans up any irrelevant data in `formData`.
 *
 * @param props - The `FieldProps` for this template
 */
class AnyOfField extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    /** Constructs an `AnyOfField` with the given `props` to initialize the initially selected option in state
     *
     * @param props - The `FieldProps` for this template
     */
    constructor(props) {
        super(props);
        /** Callback handler to remember what the currently selected option is. In addition to that the `formData` is updated
         * to remove properties that are not part of the newly selected option schema, and then the updated data is passed to
         * the `onChange` handler.
         *
         * @param option - The new option value being selected
         */
        this.onOptionChange = (option) => {
            const { selectedOption, retrievedOptions } = this.state;
            const { formData, onChange, registry } = this.props;
            const { schemaUtils } = registry;
            const intOption = option !== undefined ? parseInt(option, 10) : -1;
            if (intOption === selectedOption) {
                return;
            }
            const newOption = intOption >= 0 ? retrievedOptions[intOption] : undefined;
            const oldOption = selectedOption >= 0 ? retrievedOptions[selectedOption] : undefined;
            let newFormData = schemaUtils.sanitizeDataForNewSchema(newOption, oldOption, formData);
            if (newFormData && newOption) {
                // Call getDefaultFormState to make sure defaults are populated on change. Pass "excludeObjectChildren"
                // so that only the root objects themselves are created without adding undefined children properties
                newFormData = schemaUtils.getDefaultFormState(newOption, newFormData, 'excludeObjectChildren');
            }
            onChange(newFormData, undefined, this.getFieldId());
            this.setState({ selectedOption: intOption });
        };
        const { formData, options, registry: { schemaUtils }, } = this.props;
        // cache the retrieved options in state in case they have $refs to save doing it later
        const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
        this.state = {
            retrievedOptions,
            selectedOption: this.getMatchingOption(0, formData, retrievedOptions),
        };
    }
    /** React lifecycle method that is called when the props and/or state for this component is updated. It recomputes the
     * currently selected option based on the overall `formData`
     *
     * @param prevProps - The previous `FieldProps` for this template
     * @param prevState - The previous `AnyOfFieldState` for this template
     */
    componentDidUpdate(prevProps, prevState) {
        const { formData, options, idSchema } = this.props;
        const { selectedOption } = this.state;
        let newState = this.state;
        if (!(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.deepEquals)(prevProps.options, options)) {
            const { registry: { schemaUtils }, } = this.props;
            // re-cache the retrieved options in state in case they have $refs to save doing it later
            const retrievedOptions = options.map((opt) => schemaUtils.retrieveSchema(opt, formData));
            newState = { selectedOption, retrievedOptions };
        }
        if (!(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.deepEquals)(formData, prevProps.formData) && idSchema.$id === prevProps.idSchema.$id) {
            const { retrievedOptions } = newState;
            const matchingOption = this.getMatchingOption(selectedOption, formData, retrievedOptions);
            if (prevState && matchingOption !== selectedOption) {
                newState = { selectedOption: matchingOption, retrievedOptions };
            }
        }
        if (newState !== this.state) {
            this.setState(newState);
        }
    }
    /** Determines the best matching option for the given `formData` and `options`.
     *
     * @param formData - The new formData
     * @param options - The list of options to choose from
     * @return - The index of the `option` that best matches the `formData`
     */
    getMatchingOption(selectedOption, formData, options) {
        const { schema, registry: { schemaUtils }, } = this.props;
        const discriminator = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.getDiscriminatorFieldFromSchema)(schema);
        const option = schemaUtils.getClosestMatchingOption(formData, options, selectedOption, discriminator);
        return option;
    }
    getFieldId() {
        const { idSchema, schema } = this.props;
        return `${idSchema.$id}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`;
    }
    /** Renders the `AnyOfField` selector along with a `SchemaField` for the value of the `formData`
     */
    render() {
        const { name, disabled = false, errorSchema = {}, formContext, onBlur, onFocus, registry, schema, uiSchema, } = this.props;
        const { widgets, fields, translateString, globalUiOptions, schemaUtils } = registry;
        const { SchemaField: _SchemaField } = fields;
        const { selectedOption, retrievedOptions } = this.state;
        const { widget = 'select', placeholder, autofocus, autocomplete, title = schema.title, ...uiOptions } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.getUiOptions)(uiSchema, globalUiOptions);
        const Widget = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.getWidget)({ type: 'number' }, widget, widgets);
        const rawErrors = lodash_get__WEBPACK_IMPORTED_MODULE_2___default()(errorSchema, _rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.ERRORS_KEY, []);
        const fieldErrorSchema = lodash_omit__WEBPACK_IMPORTED_MODULE_4___default()(errorSchema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.ERRORS_KEY]);
        const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
        const option = selectedOption >= 0 ? retrievedOptions[selectedOption] || null : null;
        let optionSchema;
        if (option) {
            // merge top level required field
            const { required } = schema;
            // Merge in all the non-oneOf/anyOf properties and also skip the special ADDITIONAL_PROPERTY_FLAG property
            optionSchema = required ? (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.mergeSchemas)({ required }, option) : option;
        }
        const translateEnum = title
            ? _rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.TranslatableString.TitleOptionPrefix
            : _rjsf_utils__WEBPACK_IMPORTED_MODULE_5__.TranslatableString.OptionPrefix;
        const translateParams = title ? [title] : [];
        const enumOptions = retrievedOptions.map((opt, index) => ({
            label: opt.title || translateString(translateEnum, translateParams.concat(String(index + 1))),
            value: index,
        }));
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'panel panel-default panel-body', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'form-group', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Widget, { id: this.getFieldId(), name: `${name}${schema.oneOf ? '__oneof_select' : '__anyof_select'}`, schema: { type: 'number', default: 0 }, onChange: this.onOptionChange, onBlur: onBlur, onFocus: onFocus, disabled: disabled || lodash_isEmpty__WEBPACK_IMPORTED_MODULE_3___default()(enumOptions), multiple: false, rawErrors: rawErrors, errorSchema: fieldErrorSchema, value: selectedOption >= 0 ? selectedOption : undefined, options: { enumOptions, ...uiOptions }, registry: registry, formContext: formContext, placeholder: placeholder, autocomplete: autocomplete, autofocus: autofocus, label: title !== null && title !== void 0 ? title : name, hideLabel: !displayLabel }) }), option !== null && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_SchemaField, { ...this.props, schema: optionSchema })] }));
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AnyOfField);
//# sourceMappingURL=MultiSchemaField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/NullField.js":
/*!********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/NullField.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);

/** The `NullField` component is used to render a field in the schema is null. It also ensures that the `formData` is
 * also set to null if it has no value.
 *
 * @param props - The `FieldProps` for this template
 */
function NullField(props) {
    const { formData, onChange } = props;
    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {
        if (formData === undefined) {
            onChange(null);
        }
    }, [formData, onChange]);
    return null;
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NullField);
//# sourceMappingURL=NullField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/NumberField.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/NumberField.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



// Matches a string that ends in a . character, optionally followed by a sequence of
// digits followed by any number of 0 characters up until the end of the line.
// Ensuring that there is at least one prefixed character is important so that
// you don't incorrectly match against "0".
const trailingCharMatcherWithPrefix = /\.([0-9]*0)*$/;
// This is used for trimming the trailing 0 and . characters without affecting
// the rest of the string. Its possible to use one RegEx with groups for this
// functionality, but it is fairly complex compared to simply defining two
// different matchers.
const trailingCharMatcher = /[0.]0*$/;
/**
 * The NumberField class has some special handling for dealing with trailing
 * decimal points and/or zeroes. This logic is designed to allow trailing values
 * to be visible in the input element, but not be represented in the
 * corresponding form data.
 *
 * The algorithm is as follows:
 *
 * 1. When the input value changes the value is cached in the component state
 *
 * 2. The value is then normalized, removing trailing decimal points and zeros,
 *    then passed to the "onChange" callback
 *
 * 3. When the component is rendered, the formData value is checked against the
 *    value cached in the state. If it matches the cached value, the cached
 *    value is passed to the input instead of the formData value
 */
function NumberField(props) {
    const { registry, onChange, formData, value: initialValue } = props;
    const [lastValue, setLastValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialValue);
    const { StringField } = registry.fields;
    let value = formData;
    /** Handle the change from the `StringField` to properly convert to a number
     *
     * @param value - The current value for the change occurring
     */
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value) => {
        // Cache the original value in component state
        setLastValue(value);
        // Normalize decimals that don't start with a zero character in advance so
        // that the rest of the normalization logic is simpler
        if (`${value}`.charAt(0) === '.') {
            value = `0${value}`;
        }
        // Check that the value is a string (this can happen if the widget used is a
        // <select>, due to an enum declaration etc) then, if the value ends in a
        // trailing decimal point or multiple zeroes, strip the trailing values
        const processed = typeof value === 'string' && value.match(trailingCharMatcherWithPrefix)
            ? (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.asNumber)(value.replace(trailingCharMatcher, ''))
            : (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.asNumber)(value);
        onChange(processed);
    }, [onChange]);
    if (typeof lastValue === 'string' && typeof value === 'number') {
        // Construct a regular expression that checks for a string that consists
        // of the formData value suffixed with zero or one '.' characters and zero
        // or more '0' characters
        const re = new RegExp(`${value}`.replace('.', '\\.') + '\\.?0*$');
        // If the cached "lastValue" is a match, use that instead of the formData
        // value to prevent the input value from changing in the UI
        if (lastValue.match(re)) {
            value = lastValue;
        }
    }
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StringField, { ...props, formData: value, onChange: handleChange });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (NumberField);
//# sourceMappingURL=NumberField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/ObjectField.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/ObjectField.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var markdown_to_jsx__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! markdown-to-jsx */ "./node_modules/markdown-to-jsx/dist/index.modern.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/get */ "./node_modules/lodash/get.js");
/* harmony import */ var lodash_get__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_get__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/has */ "./node_modules/lodash/has.js");
/* harmony import */ var lodash_has__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_has__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash/set */ "./node_modules/lodash/set.js");
/* harmony import */ var lodash_set__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(lodash_set__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var lodash_unset__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash/unset */ "./node_modules/lodash/unset.js");
/* harmony import */ var lodash_unset__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(lodash_unset__WEBPACK_IMPORTED_MODULE_7__);









/** The `ObjectField` component is used to render a field in the schema that is of type `object`. It tracks whether an
 * additional property key was modified and what it was modified to
 *
 * @param props - The `FieldProps` for this template
 */
class ObjectField extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    constructor() {
        super(...arguments);
        /** Set up the initial state */
        this.state = {
            wasPropertyKeyModified: false,
            additionalProperties: {},
        };
        /** Returns the `onPropertyChange` handler for the `name` field. Handles the special case where a user is attempting
         * to clear the data for a field added as an additional property. Calls the `onChange()` handler with the updated
         * formData.
         *
         * @param name - The name of the property
         * @param addedByAdditionalProperties - Flag indicating whether this property is an additional property
         * @returns - The onPropertyChange callback for the `name` property
         */
        this.onPropertyChange = (name, addedByAdditionalProperties = false) => {
            return (value, newErrorSchema, id) => {
                const { formData, onChange, errorSchema } = this.props;
                if (value === undefined && addedByAdditionalProperties) {
                    // Don't set value = undefined for fields added by
                    // additionalProperties. Doing so removes them from the
                    // formData, which causes them to completely disappear
                    // (including the input field for the property name). Unlike
                    // fields which are "mandated" by the schema, these fields can
                    // be set to undefined by clicking a "delete field" button, so
                    // set empty values to the empty string.
                    value = '';
                }
                const newFormData = { ...formData, [name]: value };
                onChange(newFormData, errorSchema &&
                    errorSchema && {
                    ...errorSchema,
                    [name]: newErrorSchema,
                }, id);
            };
        };
        /** Returns a callback to handle the onDropPropertyClick event for the given `key` which removes the old `key` data
         * and calls the `onChange` callback with it
         *
         * @param key - The key for which the drop callback is desired
         * @returns - The drop property click callback
         */
        this.onDropPropertyClick = (key) => {
            return (event) => {
                event.preventDefault();
                const { onChange, formData } = this.props;
                const copiedFormData = { ...formData };
                lodash_unset__WEBPACK_IMPORTED_MODULE_7___default()(copiedFormData, key);
                onChange(copiedFormData);
            };
        };
        /** Computes the next available key name from the `preferredKey`, indexing through the already existing keys until one
         * that is already not assigned is found.
         *
         * @param preferredKey - The preferred name of a new key
         * @param [formData] - The form data in which to check if the desired key already exists
         * @returns - The name of the next available key from `preferredKey`
         */
        this.getAvailableKey = (preferredKey, formData) => {
            const { uiSchema, registry } = this.props;
            const { duplicateKeySuffixSeparator = '-' } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, registry.globalUiOptions);
            let index = 0;
            let newKey = preferredKey;
            while (lodash_has__WEBPACK_IMPORTED_MODULE_4___default()(formData, newKey)) {
                newKey = `${preferredKey}${duplicateKeySuffixSeparator}${++index}`;
            }
            return newKey;
        };
        /** Returns a callback function that deals with the rename of a key for an additional property for a schema. That
         * callback will attempt to rename the key and move the existing data to that key, calling `onChange` when it does.
         *
         * @param oldValue - The old value of a field
         * @returns - The key change callback function
         */
        this.onKeyChange = (oldValue) => {
            return (value, newErrorSchema) => {
                if (oldValue === value) {
                    return;
                }
                const { formData, onChange, errorSchema } = this.props;
                value = this.getAvailableKey(value, formData);
                const newFormData = {
                    ...formData,
                };
                const newKeys = { [oldValue]: value };
                const keyValues = Object.keys(newFormData).map((key) => {
                    const newKey = newKeys[key] || key;
                    return { [newKey]: newFormData[key] };
                });
                const renamedObj = Object.assign({}, ...keyValues);
                this.setState({ wasPropertyKeyModified: true });
                onChange(renamedObj, errorSchema &&
                    errorSchema && {
                    ...errorSchema,
                    [value]: newErrorSchema,
                });
            };
        };
        /** Handles the adding of a new additional property on the given `schema`. Calls the `onChange` callback once the new
         * default data for that field has been added to the formData.
         *
         * @param schema - The schema element to which the new property is being added
         */
        this.handleAddClick = (schema) => () => {
            if (!schema.additionalProperties) {
                return;
            }
            const { formData, onChange, registry } = this.props;
            const newFormData = { ...formData };
            let type = undefined;
            if (lodash_isObject__WEBPACK_IMPORTED_MODULE_5___default()(schema.additionalProperties)) {
                type = schema.additionalProperties.type;
                let apSchema = schema.additionalProperties;
                if (_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.REF_KEY in apSchema) {
                    const { schemaUtils } = registry;
                    apSchema = schemaUtils.retrieveSchema({ $ref: apSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.REF_KEY] }, formData);
                    type = apSchema.type;
                }
                if (!type && (_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ANY_OF_KEY in apSchema || _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ONE_OF_KEY in apSchema)) {
                    type = 'object';
                }
            }
            const newKey = this.getAvailableKey('newKey', newFormData);
            // Cast this to make the `set` work properly
            lodash_set__WEBPACK_IMPORTED_MODULE_6___default()(newFormData, newKey, this.getDefaultValue(type));
            onChange(newFormData);
        };
    }
    /** Returns a flag indicating whether the `name` field is required in the object schema
     *
     * @param name - The name of the field to check for required-ness
     * @returns - True if the field `name` is required, false otherwise
     */
    isRequired(name) {
        const { schema } = this.props;
        return Array.isArray(schema.required) && schema.required.indexOf(name) !== -1;
    }
    /** Returns a default value to be used for a new additional schema property of the given `type`
     *
     * @param type - The type of the new additional schema property
     */
    getDefaultValue(type) {
        const { registry: { translateString }, } = this.props;
        switch (type) {
            case 'array':
                return [];
            case 'boolean':
                return false;
            case 'null':
                return null;
            case 'number':
                return 0;
            case 'object':
                return {};
            case 'string':
            default:
                // We don't have a datatype for some reason (perhaps additionalProperties was true)
                return translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.NewStringDefault);
        }
    }
    /** Renders the `ObjectField` from the given props
     */
    render() {
        var _a, _b, _c;
        const { schema: rawSchema, uiSchema = {}, formData, errorSchema, idSchema, name, required = false, disabled = false, readonly = false, hideError, idPrefix, idSeparator, onBlur, onFocus, registry, } = this.props;
        const { fields, formContext, schemaUtils, translateString, globalUiOptions } = registry;
        const { SchemaField } = fields;
        const schema = schemaUtils.retrieveSchema(rawSchema, formData);
        const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, globalUiOptions);
        const { properties: schemaProperties = {} } = schema;
        const title = (_b = (_a = uiOptions.title) !== null && _a !== void 0 ? _a : schema.title) !== null && _b !== void 0 ? _b : name;
        const description = (_c = uiOptions.description) !== null && _c !== void 0 ? _c : schema.description;
        let orderedProperties;
        try {
            const properties = Object.keys(schemaProperties);
            orderedProperties = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.orderProperties)(properties, uiOptions.order);
        }
        catch (err) {
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { className: 'config-error', style: { color: 'red' }, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(markdown_to_jsx__WEBPACK_IMPORTED_MODULE_8__["default"], { children: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.InvalidObjectField, [name || 'root', err.message]) }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("pre", { children: JSON.stringify(schema) })] }));
        }
        const Template = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('ObjectFieldTemplate', registry, uiOptions);
        const templateProps = {
            // getDisplayLabel() always returns false for object types, so just check the `uiOptions.label`
            title: uiOptions.label === false ? '' : title,
            description: uiOptions.label === false ? undefined : description,
            properties: orderedProperties.map((name) => {
                const addedByAdditionalProperties = lodash_has__WEBPACK_IMPORTED_MODULE_4___default()(schema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, name, _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ADDITIONAL_PROPERTY_FLAG]);
                const fieldUiSchema = addedByAdditionalProperties ? uiSchema.additionalProperties : uiSchema[name];
                const hidden = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(fieldUiSchema).widget === 'hidden';
                const fieldIdSchema = lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(idSchema, [name], {});
                return {
                    content: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SchemaField, { name: name, required: this.isRequired(name), schema: lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(schema, [_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.PROPERTIES_KEY, name], {}), uiSchema: fieldUiSchema, errorSchema: lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(errorSchema, name), idSchema: fieldIdSchema, idPrefix: idPrefix, idSeparator: idSeparator, formData: lodash_get__WEBPACK_IMPORTED_MODULE_3___default()(formData, name), formContext: formContext, wasPropertyKeyModified: this.state.wasPropertyKeyModified, onKeyChange: this.onKeyChange(name), onChange: this.onPropertyChange(name, addedByAdditionalProperties), onBlur: onBlur, onFocus: onFocus, registry: registry, disabled: disabled, readonly: readonly, hideError: hideError, onDropPropertyClick: this.onDropPropertyClick }, name)),
                    name,
                    readonly,
                    disabled,
                    required,
                    hidden,
                };
            }),
            readonly,
            disabled,
            required,
            idSchema,
            uiSchema,
            errorSchema,
            schema,
            formData,
            formContext,
            registry,
        };
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Template, { ...templateProps, onAddClick: this.handleAddClick });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ObjectField);
//# sourceMappingURL=ObjectField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/SchemaField.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/SchemaField.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash/isObject */ "./node_modules/lodash/isObject.js");
/* harmony import */ var lodash_isObject__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(lodash_isObject__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash/omit */ "./node_modules/lodash/omit.js");
/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var markdown_to_jsx__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! markdown-to-jsx */ "./node_modules/markdown-to-jsx/dist/index.modern.js");






/** The map of component type to FieldName */
const COMPONENT_TYPES = {
    array: 'ArrayField',
    boolean: 'BooleanField',
    integer: 'NumberField',
    number: 'NumberField',
    object: 'ObjectField',
    string: 'StringField',
    null: 'NullField',
};
/** Computes and returns which `Field` implementation to return in order to render the field represented by the
 * `schema`. The `uiOptions` are used to alter what potential `Field` implementation is actually returned. If no
 * appropriate `Field` implementation can be found then a wrapper around `UnsupportedFieldTemplate` is used.
 *
 * @param schema - The schema from which to obtain the type
 * @param uiOptions - The UI Options that may affect the component decision
 * @param idSchema - The id that is passed to the `UnsupportedFieldTemplate`
 * @param registry - The registry from which fields and templates are obtained
 * @returns - The `Field` component that is used to render the actual field data
 */
function getFieldComponent(schema, uiOptions, idSchema, registry) {
    const field = uiOptions.field;
    const { fields, translateString } = registry;
    if (typeof field === 'function') {
        return field;
    }
    if (typeof field === 'string' && field in fields) {
        return fields[field];
    }
    const schemaType = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getSchemaType)(schema);
    const type = Array.isArray(schemaType) ? schemaType[0] : schemaType || '';
    const schemaId = schema.$id;
    let componentName = COMPONENT_TYPES[type];
    if (schemaId && schemaId in fields) {
        componentName = schemaId;
    }
    // If the type is not defined and the schema uses 'anyOf' or 'oneOf', don't
    // render a field and let the MultiSchemaField component handle the form display
    if (!componentName && (schema.anyOf || schema.oneOf)) {
        return () => null;
    }
    return componentName in fields
        ? fields[componentName]
        : () => {
            const UnsupportedFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('UnsupportedFieldTemplate', registry, uiOptions);
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnsupportedFieldTemplate, { schema: schema, idSchema: idSchema, reason: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.UnknownFieldType, [String(schema.type)]), registry: registry }));
        };
}
/** The `SchemaFieldRender` component is the work-horse of react-jsonschema-form, determining what kind of real field to
 * render based on the `schema`, `uiSchema` and all the other props. It also deals with rendering the `anyOf` and
 * `oneOf` fields.
 *
 * @param props - The `FieldProps` for this component
 */
function SchemaFieldRender(props) {
    const { schema: _schema, idSchema: _idSchema, uiSchema, formData, errorSchema, idPrefix, idSeparator, name, onChange, onKeyChange, onDropPropertyClick, required, registry, wasPropertyKeyModified = false, } = props;
    const { formContext, schemaUtils, globalUiOptions } = registry;
    const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getUiOptions)(uiSchema, globalUiOptions);
    const FieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('FieldTemplate', registry, uiOptions);
    const DescriptionFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('DescriptionFieldTemplate', registry, uiOptions);
    const FieldHelpTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('FieldHelpTemplate', registry, uiOptions);
    const FieldErrorTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('FieldErrorTemplate', registry, uiOptions);
    const schema = schemaUtils.retrieveSchema(_schema, formData);
    const fieldId = _idSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ID_KEY];
    const idSchema = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.mergeObjects)(schemaUtils.toIdSchema(schema, fieldId, formData, idPrefix, idSeparator), _idSchema);
    /** Intermediary `onChange` handler for field components that will inject the `id` of the current field into the
     * `onChange` chain if it is not already being provided from a deeper level in the hierarchy
     */
    const handleFieldComponentChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((formData, newErrorSchema, id) => {
        const theId = id || fieldId;
        return onChange(formData, newErrorSchema, theId);
    }, [fieldId, onChange]);
    const FieldComponent = getFieldComponent(schema, uiOptions, idSchema, registry);
    const disabled = Boolean(props.disabled || uiOptions.disabled);
    const readonly = Boolean(props.readonly || uiOptions.readonly || props.schema.readOnly || schema.readOnly);
    const uiSchemaHideError = uiOptions.hideError;
    // Set hideError to the value provided in the uiSchema, otherwise stick with the prop to propagate to children
    const hideError = uiSchemaHideError === undefined ? props.hideError : Boolean(uiSchemaHideError);
    const autofocus = Boolean(props.autofocus || uiOptions.autofocus);
    if (Object.keys(schema).length === 0) {
        return null;
    }
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const { __errors, ...fieldErrorSchema } = errorSchema || {};
    // See #439: uiSchema: Don't pass consumed class names or style to child components
    const fieldUiSchema = lodash_omit__WEBPACK_IMPORTED_MODULE_4___default()(uiSchema, ['ui:classNames', 'classNames', 'ui:style']);
    if (_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.UI_OPTIONS_KEY in fieldUiSchema) {
        fieldUiSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.UI_OPTIONS_KEY] = lodash_omit__WEBPACK_IMPORTED_MODULE_4___default()(fieldUiSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.UI_OPTIONS_KEY], ['classNames', 'style']);
    }
    const field = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FieldComponent, { ...props, onChange: handleFieldComponentChange, idSchema: idSchema, schema: schema, uiSchema: fieldUiSchema, disabled: disabled, readonly: readonly, hideError: hideError, autofocus: autofocus, errorSchema: fieldErrorSchema, formContext: formContext, rawErrors: __errors }));
    const id = idSchema[_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ID_KEY];
    // If this schema has a title defined, but the user has set a new key/label, retain their input.
    let label;
    if (wasPropertyKeyModified) {
        label = name;
    }
    else {
        label = _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ADDITIONAL_PROPERTY_FLAG in schema ? name : uiOptions.title || props.schema.title || schema.title || name;
    }
    const description = uiOptions.description || props.schema.description || schema.description || '';
    const richDescription = uiOptions.enableMarkdownInDescription ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(markdown_to_jsx__WEBPACK_IMPORTED_MODULE_5__["default"], { children: description }) : description;
    const help = uiOptions.help;
    const hidden = uiOptions.widget === 'hidden';
    const classNames = ['form-group', 'field', `field-${(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getSchemaType)(schema)}`];
    if (!hideError && __errors && __errors.length > 0) {
        classNames.push('field-error has-error has-danger');
    }
    if (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema.classNames) {
        if (true) {
            console.warn("'uiSchema.classNames' is deprecated and may be removed in a major release; Use 'ui:classNames' instead.");
        }
        classNames.push(uiSchema.classNames);
    }
    if (uiOptions.classNames) {
        classNames.push(uiOptions.classNames);
    }
    const helpComponent = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FieldHelpTemplate, { help: help, idSchema: idSchema, schema: schema, uiSchema: uiSchema, hasErrors: !hideError && __errors && __errors.length > 0, registry: registry }));
    /*
     * AnyOf/OneOf errors handled by child schema
     * unless it can be rendered as select control
     */
    const errorsComponent = hideError || ((schema.anyOf || schema.oneOf) && !schemaUtils.isSelect(schema)) ? undefined : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FieldErrorTemplate, { errors: __errors, errorSchema: errorSchema, idSchema: idSchema, schema: schema, uiSchema: uiSchema, registry: registry }));
    const fieldProps = {
        description: ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DescriptionFieldTemplate, { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.descriptionId)(id), description: richDescription, schema: schema, uiSchema: uiSchema, registry: registry })),
        rawDescription: description,
        help: helpComponent,
        rawHelp: typeof help === 'string' ? help : undefined,
        errors: errorsComponent,
        rawErrors: hideError ? undefined : __errors,
        id,
        label,
        hidden,
        onChange,
        onKeyChange,
        onDropPropertyClick,
        required,
        disabled,
        readonly,
        hideError,
        displayLabel,
        classNames: classNames.join(' ').trim(),
        style: uiOptions.style,
        formContext,
        formData,
        schema,
        uiSchema,
        registry,
    };
    const _AnyOfField = registry.fields.AnyOfField;
    const _OneOfField = registry.fields.OneOfField;
    const isReplacingAnyOrOneOf = (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema['ui:field']) && (uiSchema === null || uiSchema === void 0 ? void 0 : uiSchema['ui:fieldReplacesAnyOrOneOf']) === true;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FieldTemplate, { ...fieldProps, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [field, schema.anyOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_AnyOfField, { name: name, disabled: disabled, readonly: readonly, hideError: hideError, errorSchema: errorSchema, formData: formData, formContext: formContext, idPrefix: idPrefix, idSchema: idSchema, idSeparator: idSeparator, onBlur: props.onBlur, onChange: props.onChange, onFocus: props.onFocus, options: schema.anyOf.map((_schema) => schemaUtils.retrieveSchema(lodash_isObject__WEBPACK_IMPORTED_MODULE_3___default()(_schema) ? _schema : {}, formData)), registry: registry, schema: schema, uiSchema: uiSchema })), schema.oneOf && !isReplacingAnyOrOneOf && !schemaUtils.isSelect(schema) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_OneOfField, { name: name, disabled: disabled, readonly: readonly, hideError: hideError, errorSchema: errorSchema, formData: formData, formContext: formContext, idPrefix: idPrefix, idSchema: idSchema, idSeparator: idSeparator, onBlur: props.onBlur, onChange: props.onChange, onFocus: props.onFocus, options: schema.oneOf.map((_schema) => schemaUtils.retrieveSchema(lodash_isObject__WEBPACK_IMPORTED_MODULE_3___default()(_schema) ? _schema : {}, formData)), registry: registry, schema: schema, uiSchema: uiSchema }))] }) }));
}
/** The `SchemaField` component determines whether it is necessary to rerender the component based on any props changes
 * and if so, calls the `SchemaFieldRender` component with the props.
 */
class SchemaField extends react__WEBPACK_IMPORTED_MODULE_1__.Component {
    shouldComponentUpdate(nextProps) {
        return !(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.deepEquals)(this.props, nextProps);
    }
    render() {
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SchemaFieldRender, { ...this.props });
    }
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SchemaField);
//# sourceMappingURL=SchemaField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/StringField.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/StringField.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `StringField` component is used to render a schema field that represents a string type
 *
 * @param props - The `FieldProps` for this template
 */
function StringField(props) {
    var _a;
    const { schema, name, uiSchema, idSchema, formData, required, disabled = false, readonly = false, autofocus = false, onChange, onBlur, onFocus, registry, rawErrors, hideError, } = props;
    const { title, format } = schema;
    const { widgets, formContext, schemaUtils, globalUiOptions } = registry;
    const enumOptions = schemaUtils.isSelect(schema) ? (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.optionsList)(schema) : undefined;
    let defaultWidget = enumOptions ? 'select' : 'text';
    if (format && (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.hasWidget)(schema, format, widgets)) {
        defaultWidget = format;
    }
    const { widget = defaultWidget, placeholder = '', title: uiTitle, ...options } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema);
    const displayLabel = schemaUtils.getDisplayLabel(schema, uiSchema, globalUiOptions);
    const label = (_a = uiTitle !== null && uiTitle !== void 0 ? uiTitle : title) !== null && _a !== void 0 ? _a : name;
    const Widget = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getWidget)(schema, widget, widgets);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Widget, { options: { ...options, enumOptions }, schema: schema, uiSchema: uiSchema, id: idSchema.$id, name: name, label: label, hideLabel: !displayLabel, hideError: hideError, value: formData, onChange: onChange, onBlur: onBlur, onFocus: onFocus, required: required, disabled: disabled, readonly: readonly, formContext: formContext, autofocus: autofocus, registry: registry, placeholder: placeholder, rawErrors: rawErrors }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (StringField);
//# sourceMappingURL=StringField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/fields/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/fields/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ArrayField__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArrayField */ "./node_modules/@rjsf/core/lib/components/fields/ArrayField.js");
/* harmony import */ var _BooleanField__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./BooleanField */ "./node_modules/@rjsf/core/lib/components/fields/BooleanField.js");
/* harmony import */ var _MultiSchemaField__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MultiSchemaField */ "./node_modules/@rjsf/core/lib/components/fields/MultiSchemaField.js");
/* harmony import */ var _NumberField__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./NumberField */ "./node_modules/@rjsf/core/lib/components/fields/NumberField.js");
/* harmony import */ var _ObjectField__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ObjectField */ "./node_modules/@rjsf/core/lib/components/fields/ObjectField.js");
/* harmony import */ var _SchemaField__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./SchemaField */ "./node_modules/@rjsf/core/lib/components/fields/SchemaField.js");
/* harmony import */ var _StringField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./StringField */ "./node_modules/@rjsf/core/lib/components/fields/StringField.js");
/* harmony import */ var _NullField__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./NullField */ "./node_modules/@rjsf/core/lib/components/fields/NullField.js");








function fields() {
    return {
        AnyOfField: _MultiSchemaField__WEBPACK_IMPORTED_MODULE_2__["default"],
        ArrayField: _ArrayField__WEBPACK_IMPORTED_MODULE_0__["default"],
        // ArrayField falls back to SchemaField if ArraySchemaField is not defined, which it isn't by default
        BooleanField: _BooleanField__WEBPACK_IMPORTED_MODULE_1__["default"],
        NumberField: _NumberField__WEBPACK_IMPORTED_MODULE_3__["default"],
        ObjectField: _ObjectField__WEBPACK_IMPORTED_MODULE_4__["default"],
        OneOfField: _MultiSchemaField__WEBPACK_IMPORTED_MODULE_2__["default"],
        SchemaField: _SchemaField__WEBPACK_IMPORTED_MODULE_5__["default"],
        StringField: _StringField__WEBPACK_IMPORTED_MODULE_6__["default"],
        NullField: _NullField__WEBPACK_IMPORTED_MODULE_7__["default"],
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (fields);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayFieldDescriptionTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `ArrayFieldDescriptionTemplate` component renders a `DescriptionFieldTemplate` with an `id` derived from
 * the `idSchema`.
 *
 * @param props - The `ArrayFieldDescriptionProps` for the component
 */
function ArrayFieldDescriptionTemplate(props) {
    const { idSchema, description, registry, schema, uiSchema } = props;
    const options = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema, registry.globalUiOptions);
    const { label: displayLabel = true } = options;
    if (!description || !displayLabel) {
        return null;
    }
    const DescriptionFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('DescriptionFieldTemplate', registry, options);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DescriptionFieldTemplate, { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.descriptionId)(idSchema), description: description, schema: schema, uiSchema: uiSchema, registry: registry }));
}
//# sourceMappingURL=ArrayFieldDescriptionTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayFieldItemTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

/** The `ArrayFieldItemTemplate` component is the template used to render an items of an array.
 *
 * @param props - The `ArrayFieldTemplateItemType` props for the component
 */
function ArrayFieldItemTemplate(props) {
    const { children, className, disabled, hasToolbar, hasMoveDown, hasMoveUp, hasRemove, hasCopy, index, onCopyIndexClick, onDropIndexClick, onReorderClick, readonly, registry, uiSchema, } = props;
    const { CopyButton, MoveDownButton, MoveUpButton, RemoveButton } = registry.templates.ButtonTemplates;
    const btnStyle = {
        flex: 1,
        paddingLeft: 6,
        paddingRight: 6,
        fontWeight: 'bold',
    };
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: className, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: hasToolbar ? 'col-xs-9' : 'col-xs-12', children: children }), hasToolbar && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'col-xs-3 array-item-toolbox', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'btn-group', style: {
                        display: 'flex',
                        justifyContent: 'space-around',
                    }, children: [(hasMoveUp || hasMoveDown) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MoveUpButton, { style: btnStyle, disabled: disabled || readonly || !hasMoveUp, onClick: onReorderClick(index, index - 1), uiSchema: uiSchema, registry: registry })), (hasMoveUp || hasMoveDown) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MoveDownButton, { style: btnStyle, disabled: disabled || readonly || !hasMoveDown, onClick: onReorderClick(index, index + 1), uiSchema: uiSchema, registry: registry })), hasCopy && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CopyButton, { style: btnStyle, disabled: disabled || readonly, onClick: onCopyIndexClick(index), uiSchema: uiSchema, registry: registry })), hasRemove && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RemoveButton, { style: btnStyle, disabled: disabled || readonly, onClick: onDropIndexClick(index), uiSchema: uiSchema, registry: registry }))] }) }))] }));
}
//# sourceMappingURL=ArrayFieldItemTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayFieldTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `ArrayFieldTemplate` component is the template used to render all items in an array.
 *
 * @param props - The `ArrayFieldTemplateItemType` props for the component
 */
function ArrayFieldTemplate(props) {
    const { canAdd, className, disabled, idSchema, uiSchema, items, onAddClick, readonly, registry, required, schema, title, } = props;
    const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema);
    const ArrayFieldDescriptionTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('ArrayFieldDescriptionTemplate', registry, uiOptions);
    const ArrayFieldItemTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('ArrayFieldItemTemplate', registry, uiOptions);
    const ArrayFieldTitleTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('ArrayFieldTitleTemplate', registry, uiOptions);
    // Button templates are not overridden in the uiSchema
    const { ButtonTemplates: { AddButton }, } = registry.templates;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("fieldset", { className: className, id: idSchema.$id, children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ArrayFieldTitleTemplate, { idSchema: idSchema, title: uiOptions.title || title, required: required, schema: schema, uiSchema: uiSchema, registry: registry }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ArrayFieldDescriptionTemplate, { idSchema: idSchema, description: uiOptions.description || schema.description, schema: schema, uiSchema: uiSchema, registry: registry }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'row array-item-list', children: items &&
                    items.map(({ key, ...itemProps }) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ArrayFieldItemTemplate, { ...itemProps }, key))) }), canAdd && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AddButton, { className: 'array-item-add', onClick: onAddClick, disabled: disabled || readonly, uiSchema: uiSchema, registry: registry }))] }));
}
//# sourceMappingURL=ArrayFieldTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ArrayFieldTitleTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `ArrayFieldTitleTemplate` component renders a `TitleFieldTemplate` with an `id` derived from
 * the `idSchema`.
 *
 * @param props - The `ArrayFieldTitleProps` for the component
 */
function ArrayFieldTitleTemplate(props) {
    const { idSchema, title, schema, uiSchema, required, registry } = props;
    const options = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema, registry.globalUiOptions);
    const { label: displayLabel = true } = options;
    if (!title || !displayLabel) {
        return null;
    }
    const TitleFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('TitleFieldTemplate', registry, options);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TitleFieldTemplate, { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.titleId)(idSchema), title: title, required: required, schema: schema, uiSchema: uiSchema, registry: registry }));
}
//# sourceMappingURL=ArrayFieldTitleTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ BaseInputTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `BaseInputTemplate` is the template to use to render the basic `<input>` component for the `core` theme.
 * It is used as the template for rendering many of the <input> based widgets that differ by `type` and callbacks only.
 * It can be customized/overridden for other themes or individual implementations as needed.
 *
 * @param props - The `WidgetProps` for this template
 */
function BaseInputTemplate(props) {
    const { id, name, // remove this from ...rest
    value, readonly, disabled, autofocus, onBlur, onFocus, onChange, onChangeOverride, options, schema, uiSchema, formContext, registry, rawErrors, type, hideLabel, // remove this from ...rest
    hideError, // remove this from ...rest
    ...rest } = props;
    // Note: since React 15.2.0 we can't forward unknown element attributes, so we
    // exclude the "options" and "schema" ones here.
    if (!id) {
        console.log('No id for', props);
        throw new Error(`no id for props ${JSON.stringify(props)}`);
    }
    const inputProps = {
        ...rest,
        ...(0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getInputProps)(schema, type, options),
    };
    let inputValue;
    if (inputProps.type === 'number' || inputProps.type === 'integer') {
        inputValue = value || value === 0 ? value : '';
    }
    else {
        inputValue = value == null ? '' : value;
    }
    const _onChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onChange(value === '' ? options.emptyValue : value), [onChange, options]);
    const _onBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onBlur(id, value), [onBlur, id]);
    const _onFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onFocus(id, value), [onFocus, id]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { id: id, name: id, className: 'form-control', readOnly: readonly, disabled: disabled, autoFocus: autofocus, value: inputValue, ...inputProps, list: schema.examples ? (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.examplesId)(id) : undefined, onChange: onChangeOverride || _onChange, onBlur: _onBlur, onFocus: _onFocus, "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(id, !!schema.examples) }), Array.isArray(schema.examples) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("datalist", { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.examplesId)(id), children: schema.examples
                    .concat(schema.default && !schema.examples.includes(schema.default) ? [schema.default] : [])
                    .map((example) => {
                    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: example }, example);
                }) }, `datalist_${id}`))] }));
}
//# sourceMappingURL=BaseInputTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ AddButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _IconButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IconButton */ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js");



/** The `AddButton` renders a button that represent the `Add` action on a form
 */
function AddButton({ className, onClick, disabled, registry, }) {
    const { translateString } = registry;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'row', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { className: `col-xs-3 col-xs-offset-9 text-right ${className}`, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_IconButton__WEBPACK_IMPORTED_MODULE_2__["default"], { iconType: 'info', icon: 'plus', className: 'btn-add col-xs-12', title: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.AddButton), onClick: onClick, disabled: disabled, registry: registry }) }) }));
}
//# sourceMappingURL=AddButton.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CopyButton: () => (/* binding */ CopyButton),
/* harmony export */   MoveDownButton: () => (/* binding */ MoveDownButton),
/* harmony export */   MoveUpButton: () => (/* binding */ MoveUpButton),
/* harmony export */   RemoveButton: () => (/* binding */ RemoveButton),
/* harmony export */   "default": () => (/* binding */ IconButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


function IconButton(props) {
    const { iconType = 'default', icon, className, uiSchema, registry, ...otherProps } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: 'button', className: `btn btn-${iconType} ${className}`, ...otherProps, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("i", { className: `glyphicon glyphicon-${icon}` }) }));
}
function CopyButton(props) {
    const { registry: { translateString }, } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(IconButton, { title: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.CopyButton), className: 'array-item-copy', ...props, icon: 'copy' }));
}
function MoveDownButton(props) {
    const { registry: { translateString }, } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(IconButton, { title: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.MoveDownButton), className: 'array-item-move-down', ...props, icon: 'arrow-down' }));
}
function MoveUpButton(props) {
    const { registry: { translateString }, } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(IconButton, { title: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.MoveUpButton), className: 'array-item-move-up', ...props, icon: 'arrow-up' }));
}
function RemoveButton(props) {
    const { registry: { translateString }, } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(IconButton, { title: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.RemoveButton), className: 'array-item-remove', ...props, iconType: 'danger', icon: 'remove' }));
}
//# sourceMappingURL=IconButton.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SubmitButton)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `SubmitButton` renders a button that represent the `Submit` action on a form
 */
function SubmitButton({ uiSchema }) {
    const { submitText, norender, props: submitButtonProps = {} } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getSubmitButtonOptions)(uiSchema);
    if (norender) {
        return null;
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("button", { type: 'submit', ...submitButtonProps, className: `btn btn-info ${submitButtonProps.className || ''}`, children: submitText }) }));
}
//# sourceMappingURL=SubmitButton.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SubmitButton__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SubmitButton */ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/SubmitButton.js");
/* harmony import */ var _AddButton__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AddButton */ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/AddButton.js");
/* harmony import */ var _IconButton__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./IconButton */ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/IconButton.js");



function buttonTemplates() {
    return {
        SubmitButton: _SubmitButton__WEBPACK_IMPORTED_MODULE_0__["default"],
        AddButton: _AddButton__WEBPACK_IMPORTED_MODULE_1__["default"],
        CopyButton: _IconButton__WEBPACK_IMPORTED_MODULE_2__.CopyButton,
        MoveDownButton: _IconButton__WEBPACK_IMPORTED_MODULE_2__.MoveDownButton,
        MoveUpButton: _IconButton__WEBPACK_IMPORTED_MODULE_2__.MoveUpButton,
        RemoveButton: _IconButton__WEBPACK_IMPORTED_MODULE_2__.RemoveButton,
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (buttonTemplates);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/DescriptionField.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/DescriptionField.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DescriptionField)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

/** The `DescriptionField` is the template to use to render the description of a field
 *
 * @param props - The `DescriptionFieldProps` for this component
 */
function DescriptionField(props) {
    const { id, description } = props;
    if (!description) {
        return null;
    }
    if (typeof description === 'string') {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { id: id, className: 'field-description', children: description }));
    }
    else {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { id: id, className: 'field-description', children: description }));
    }
}
//# sourceMappingURL=DescriptionField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ErrorList.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ErrorList.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ErrorList)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `ErrorList` component is the template that renders the all the errors associated with the fields in the `Form`
 *
 * @param props - The `ErrorListProps` for this component
 */
function ErrorList({ errors, registry, }) {
    const { translateString } = registry;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'panel panel-danger errors', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'panel-heading', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("h3", { className: 'panel-title', children: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.ErrorsLabel) }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { className: 'list-group', children: errors.map((error, i) => {
                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { className: 'list-group-item text-danger', children: error.stack }, i));
                }) })] }));
}
//# sourceMappingURL=ErrorList.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FieldErrorTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `FieldErrorTemplate` component renders the errors local to the particular field
 *
 * @param props - The `FieldErrorProps` for the errors being rendered
 */
function FieldErrorTemplate(props) {
    const { errors = [], idSchema } = props;
    if (errors.length === 0) {
        return null;
    }
    const id = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.errorId)(idSchema);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { id: id, className: 'error-detail bs-callout bs-callout-info', children: errors
                .filter((elem) => !!elem)
                .map((error, index) => {
                return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { className: 'text-danger', children: error }, index));
            }) }) }));
}
//# sourceMappingURL=FieldErrorTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FieldHelpTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `FieldHelpTemplate` component renders any help desired for a field
 *
 * @param props - The `FieldHelpProps` to be rendered
 */
function FieldHelpTemplate(props) {
    const { idSchema, help } = props;
    if (!help) {
        return null;
    }
    const id = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.helpId)(idSchema);
    if (typeof help === 'string') {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { id: id, className: 'help-block', children: help }));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { id: id, className: 'help-block', children: help }));
}
//# sourceMappingURL=FieldHelpTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ FieldTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Label__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Label */ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js");



/** The `FieldTemplate` component is the template used by `SchemaField` to render any field. It renders the field
 * content, (label, description, children, errors and help) inside of a `WrapIfAdditional` component.
 *
 * @param props - The `FieldTemplateProps` for this component
 */
function FieldTemplate(props) {
    const { id, label, children, errors, help, description, hidden, required, displayLabel, registry, uiSchema } = props;
    const uiOptions = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema);
    const WrapIfAdditionalTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('WrapIfAdditionalTemplate', registry, uiOptions);
    if (hidden) {
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'hidden', children: children });
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(WrapIfAdditionalTemplate, { ...props, children: [displayLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_Label__WEBPACK_IMPORTED_MODULE_2__["default"], { label: label, required: required, id: id }), displayLabel && description ? description : null, children, errors, help] }));
}
//# sourceMappingURL=FieldTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ Label)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

const REQUIRED_FIELD_SYMBOL = '*';
/** Renders a label for a field
 *
 * @param props - The `LabelProps` for this component
 */
function Label(props) {
    const { label, required, id } = props;
    if (!label) {
        return null;
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { className: 'control-label', htmlFor: id, children: [label, required && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: 'required', children: REQUIRED_FIELD_SYMBOL })] }));
}
//# sourceMappingURL=Label.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _FieldTemplate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./FieldTemplate */ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/FieldTemplate.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_FieldTemplate__WEBPACK_IMPORTED_MODULE_0__["default"]);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ObjectFieldTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `ObjectFieldTemplate` is the template to use to render all the inner properties of an object along with the
 * title and description if available. If the object is expandable, then an `AddButton` is also rendered after all
 * the properties.
 *
 * @param props - The `ObjectFieldTemplateProps` for this component
 */
function ObjectFieldTemplate(props) {
    const { description, disabled, formData, idSchema, onAddClick, properties, readonly, registry, required, schema, title, uiSchema, } = props;
    const options = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getUiOptions)(uiSchema);
    const TitleFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('TitleFieldTemplate', registry, options);
    const DescriptionFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('DescriptionFieldTemplate', registry, options);
    // Button templates are not overridden in the uiSchema
    const { ButtonTemplates: { AddButton }, } = registry.templates;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("fieldset", { id: idSchema.$id, children: [title && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(TitleFieldTemplate, { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.titleId)(idSchema), title: title, required: required, schema: schema, uiSchema: uiSchema, registry: registry })), description && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DescriptionFieldTemplate, { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.descriptionId)(idSchema), description: description, schema: schema, uiSchema: uiSchema, registry: registry })), properties.map((prop) => prop.content), (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.canExpand)(schema, uiSchema, formData) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AddButton, { className: 'object-property-expand', onClick: onAddClick(schema), disabled: disabled || readonly, uiSchema: uiSchema, registry: registry }))] }));
}
//# sourceMappingURL=ObjectFieldTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/TitleField.js":
/*!************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/TitleField.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TitleField)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

const REQUIRED_FIELD_SYMBOL = '*';
/** The `TitleField` is the template to use to render the title of a field
 *
 * @param props - The `TitleFieldProps` for this component
 */
function TitleField(props) {
    const { id, title, required } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("legend", { id: id, children: [title, required && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: 'required', children: REQUIRED_FIELD_SYMBOL })] }));
}
//# sourceMappingURL=TitleField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var markdown_to_jsx__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! markdown-to-jsx */ "./node_modules/markdown-to-jsx/dist/index.modern.js");



/** The `UnsupportedField` component is used to render a field in the schema is one that is not supported by
 * react-jsonschema-form.
 *
 * @param props - The `FieldProps` for this template
 */
function UnsupportedField(props) {
    const { schema, idSchema, reason, registry } = props;
    const { translateString } = registry;
    let translateEnum = _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.UnsupportedField;
    const translateParams = [];
    if (idSchema && idSchema.$id) {
        translateEnum = _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.UnsupportedFieldWithId;
        translateParams.push(idSchema.$id);
    }
    if (reason) {
        translateEnum =
            translateEnum === _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.UnsupportedField
                ? _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.UnsupportedFieldWithReason
                : _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.UnsupportedFieldWithIdAndReason;
        translateParams.push(reason);
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'unsupported-field', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("p", { children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(markdown_to_jsx__WEBPACK_IMPORTED_MODULE_2__["default"], { children: translateString(translateEnum, translateParams) }) }), schema && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("pre", { children: JSON.stringify(schema, null, 2) })] }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UnsupportedField);
//# sourceMappingURL=UnsupportedField.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ WrapIfAdditionalTemplate)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _FieldTemplate_Label__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./FieldTemplate/Label */ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/Label.js");



/** The `WrapIfAdditional` component is used by the `FieldTemplate` to rename, or remove properties that are
 * part of an `additionalProperties` part of a schema.
 *
 * @param props - The `WrapIfAdditionalProps` for this component
 */
function WrapIfAdditionalTemplate(props) {
    const { id, classNames, style, disabled, label, onKeyChange, onDropPropertyClick, readonly, required, schema, children, uiSchema, registry, } = props;
    const { templates, translateString } = registry;
    // Button templates are not overridden in the uiSchema
    const { RemoveButton } = templates.ButtonTemplates;
    const keyLabel = translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.TranslatableString.KeyLabel, [label]);
    const additional = _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.ADDITIONAL_PROPERTY_FLAG in schema;
    if (!additional) {
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: classNames, style: style, children: children }));
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: classNames, style: style, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'row', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'col-xs-5 form-additional', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'form-group', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_FieldTemplate_Label__WEBPACK_IMPORTED_MODULE_2__["default"], { label: keyLabel, required: required, id: `${id}-key` }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { className: 'form-control', type: 'text', id: `${id}-key`, onBlur: (event) => onKeyChange(event.target.value), defaultValue: label })] }) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'form-additional form-group col-xs-5', children: children }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'col-xs-2', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(RemoveButton, { className: 'array-item-remove btn-block', style: { border: '0' }, disabled: disabled || readonly, onClick: onDropPropertyClick(label), uiSchema: uiSchema, registry: registry }) })] }) }));
}
//# sourceMappingURL=WrapIfAdditionalTemplate.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/templates/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/templates/index.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _ArrayFieldDescriptionTemplate__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ArrayFieldDescriptionTemplate */ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldDescriptionTemplate.js");
/* harmony import */ var _ArrayFieldItemTemplate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ArrayFieldItemTemplate */ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldItemTemplate.js");
/* harmony import */ var _ArrayFieldTemplate__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ArrayFieldTemplate */ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldTemplate.js");
/* harmony import */ var _ArrayFieldTitleTemplate__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ArrayFieldTitleTemplate */ "./node_modules/@rjsf/core/lib/components/templates/ArrayFieldTitleTemplate.js");
/* harmony import */ var _BaseInputTemplate__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./BaseInputTemplate */ "./node_modules/@rjsf/core/lib/components/templates/BaseInputTemplate.js");
/* harmony import */ var _ButtonTemplates__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ButtonTemplates */ "./node_modules/@rjsf/core/lib/components/templates/ButtonTemplates/index.js");
/* harmony import */ var _DescriptionField__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DescriptionField */ "./node_modules/@rjsf/core/lib/components/templates/DescriptionField.js");
/* harmony import */ var _ErrorList__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ErrorList */ "./node_modules/@rjsf/core/lib/components/templates/ErrorList.js");
/* harmony import */ var _FieldTemplate__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./FieldTemplate */ "./node_modules/@rjsf/core/lib/components/templates/FieldTemplate/index.js");
/* harmony import */ var _FieldErrorTemplate__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./FieldErrorTemplate */ "./node_modules/@rjsf/core/lib/components/templates/FieldErrorTemplate.js");
/* harmony import */ var _FieldHelpTemplate__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./FieldHelpTemplate */ "./node_modules/@rjsf/core/lib/components/templates/FieldHelpTemplate.js");
/* harmony import */ var _ObjectFieldTemplate__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./ObjectFieldTemplate */ "./node_modules/@rjsf/core/lib/components/templates/ObjectFieldTemplate.js");
/* harmony import */ var _TitleField__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./TitleField */ "./node_modules/@rjsf/core/lib/components/templates/TitleField.js");
/* harmony import */ var _UnsupportedField__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./UnsupportedField */ "./node_modules/@rjsf/core/lib/components/templates/UnsupportedField.js");
/* harmony import */ var _WrapIfAdditionalTemplate__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./WrapIfAdditionalTemplate */ "./node_modules/@rjsf/core/lib/components/templates/WrapIfAdditionalTemplate.js");















function templates() {
    return {
        ArrayFieldDescriptionTemplate: _ArrayFieldDescriptionTemplate__WEBPACK_IMPORTED_MODULE_0__["default"],
        ArrayFieldItemTemplate: _ArrayFieldItemTemplate__WEBPACK_IMPORTED_MODULE_1__["default"],
        ArrayFieldTemplate: _ArrayFieldTemplate__WEBPACK_IMPORTED_MODULE_2__["default"],
        ArrayFieldTitleTemplate: _ArrayFieldTitleTemplate__WEBPACK_IMPORTED_MODULE_3__["default"],
        ButtonTemplates: (0,_ButtonTemplates__WEBPACK_IMPORTED_MODULE_5__["default"])(),
        BaseInputTemplate: _BaseInputTemplate__WEBPACK_IMPORTED_MODULE_4__["default"],
        DescriptionFieldTemplate: _DescriptionField__WEBPACK_IMPORTED_MODULE_6__["default"],
        ErrorListTemplate: _ErrorList__WEBPACK_IMPORTED_MODULE_7__["default"],
        FieldTemplate: _FieldTemplate__WEBPACK_IMPORTED_MODULE_8__["default"],
        FieldErrorTemplate: _FieldErrorTemplate__WEBPACK_IMPORTED_MODULE_9__["default"],
        FieldHelpTemplate: _FieldHelpTemplate__WEBPACK_IMPORTED_MODULE_10__["default"],
        ObjectFieldTemplate: _ObjectFieldTemplate__WEBPACK_IMPORTED_MODULE_11__["default"],
        TitleFieldTemplate: _TitleField__WEBPACK_IMPORTED_MODULE_12__["default"],
        UnsupportedFieldTemplate: _UnsupportedField__WEBPACK_IMPORTED_MODULE_13__["default"],
        WrapIfAdditionalTemplate: _WrapIfAdditionalTemplate__WEBPACK_IMPORTED_MODULE_14__["default"],
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (templates);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

/** The `AltDateTimeWidget` is an alternative widget for rendering datetime properties.
 *  It uses the AltDateWidget for rendering, with the `time` prop set to true by default.
 *
 * @param props - The `WidgetProps` for this component
 */
function AltDateTimeWidget({ time = true, ...props }) {
    const { AltDateWidget } = props.registry.widgets;
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AltDateWidget, { time: time, ...props });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltDateTimeWidget);
//# sourceMappingURL=AltDateTimeWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



function rangeOptions(start, stop) {
    const options = [];
    for (let i = start; i <= stop; i++) {
        options.push({ value: i, label: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.pad)(i, 2) });
    }
    return options;
}
function readyForChange(state) {
    return Object.values(state).every((value) => value !== -1);
}
function dateElementProps(state, time, yearsRange = [1900, new Date().getFullYear() + 2]) {
    const { year, month, day, hour, minute, second } = state;
    const data = [
        {
            type: 'year',
            range: yearsRange,
            value: year,
        },
        { type: 'month', range: [1, 12], value: month },
        { type: 'day', range: [1, 31], value: day },
    ];
    if (time) {
        data.push({ type: 'hour', range: [0, 23], value: hour }, { type: 'minute', range: [0, 59], value: minute }, { type: 'second', range: [0, 59], value: second });
    }
    return data;
}
function DateElement({ type, range, value, select, rootId, name, disabled, readonly, autofocus, registry, onBlur, onFocus, }) {
    const id = rootId + '_' + type;
    const { SelectWidget } = registry.widgets;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectWidget, { schema: { type: 'integer' }, id: id, name: name, className: 'form-control', options: { enumOptions: rangeOptions(range[0], range[1]) }, placeholder: type, value: value, disabled: disabled, readonly: readonly, autofocus: autofocus, onChange: (value) => select(type, value), onBlur: onBlur, onFocus: onFocus, registry: registry, label: '', "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(rootId) }));
}
/** The `AltDateWidget` is an alternative widget for rendering date properties.
 * @param props - The `WidgetProps` for this component
 */
function AltDateWidget({ time = false, disabled = false, readonly = false, autofocus = false, options, id, name, registry, onBlur, onFocus, onChange, value, }) {
    const { translateString } = registry;
    const [lastValue, setLastValue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(value);
    const [state, setState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useReducer)((state, action) => {
        return { ...state, ...action };
    }, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.parseDateString)(value, time));
    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(() => {
        const stateValue = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.toDateString)(state, time);
        if (readyForChange(state) && stateValue !== value) {
            // The user changed the date to a new valid data via the comboboxes, so call onChange
            onChange(stateValue);
        }
        else if (lastValue !== value) {
            // We got a new value in the props
            setLastValue(value);
            setState((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.parseDateString)(value, time));
        }
    }, [time, value, onChange, state, lastValue]);
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((property, value) => {
        setState({ [property]: value });
    }, []);
    const handleSetNow = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {
        event.preventDefault();
        if (disabled || readonly) {
            return;
        }
        const nextState = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.parseDateString)(new Date().toJSON(), time);
        onChange((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.toDateString)(nextState, time));
    }, [disabled, readonly, time]);
    const handleClear = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {
        event.preventDefault();
        if (disabled || readonly) {
            return;
        }
        onChange(undefined);
    }, [disabled, readonly, onChange]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("ul", { className: 'list-inline', children: [dateElementProps(state, time, options.yearsRange).map((elemProps, i) => ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { className: 'list-inline-item', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DateElement, { rootId: id, name: name, select: handleChange, ...elemProps, disabled: disabled, readonly: readonly, registry: registry, onBlur: onBlur, onFocus: onFocus, autofocus: autofocus && i === 0 }) }, i))), (options.hideNowButton !== 'undefined' ? !options.hideNowButton : true) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { className: 'list-inline-item', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", { href: '#', className: 'btn btn-info btn-now', onClick: handleSetNow, children: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.NowLabel) }) })), (options.hideClearButton !== 'undefined' ? !options.hideClearButton : true) && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("li", { className: 'list-inline-item', children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", { href: '#', className: 'btn btn-warning btn-clear', onClick: handleClear, children: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.ClearLabel) }) }))] }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (AltDateWidget);
//# sourceMappingURL=AltDateWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `CheckBoxWidget` is a widget for rendering boolean properties.
 *  It is typically used to represent a boolean.
 *
 * @param props - The `WidgetProps` for this component
 */
function CheckboxWidget({ schema, uiSchema, options, id, value, disabled, readonly, label, hideLabel, autofocus = false, onBlur, onFocus, onChange, registry, }) {
    var _a;
    const DescriptionFieldTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('DescriptionFieldTemplate', registry, options);
    // Because an unchecked checkbox will cause html5 validation to fail, only add
    // the "required" attribute if the field value must be "true", due to the
    // "const" or "enum" keywords
    const required = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.schemaRequiresTrueValue)(schema);
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => onChange(event.target.checked), [onChange]);
    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => onBlur(id, event.target.checked), [onBlur, id]);
    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => onFocus(id, event.target.checked), [onFocus, id]);
    const description = (_a = options.description) !== null && _a !== void 0 ? _a : schema.description;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: `checkbox ${disabled || readonly ? 'disabled' : ''}`, children: [!hideLabel && !!description && ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DescriptionFieldTemplate, { id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.descriptionId)(id), description: description, schema: schema, uiSchema: uiSchema, registry: registry })), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("label", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: 'checkbox', id: id, name: id, checked: typeof value === 'undefined' ? false : value, required: required, disabled: disabled || readonly, autoFocus: autofocus, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(id) }), (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.labelValue)((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: label }), hideLabel)] })] }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckboxWidget);
//# sourceMappingURL=CheckboxWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `CheckboxesWidget` is a widget for rendering checkbox groups.
 *  It is typically used to represent an array of enums.
 *
 * @param props - The `WidgetProps` for this component
 */
function CheckboxesWidget({ id, disabled, options: { inline = false, enumOptions, enumDisabled, emptyValue }, value, autofocus = false, readonly, onChange, onBlur, onFocus, }) {
    const checkboxesValues = Array.isArray(value) ? value : [value];
    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onBlur(id, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(value, enumOptions, emptyValue)), [onBlur, id]);
    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onFocus(id, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(value, enumOptions, emptyValue)), [onFocus, id]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'checkboxes', id: id, children: Array.isArray(enumOptions) &&
            enumOptions.map((option, index) => {
                const checked = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsIsSelected)(option.value, checkboxesValues);
                const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
                const disabledCls = disabled || itemDisabled || readonly ? 'disabled' : '';
                const handleChange = (event) => {
                    if (event.target.checked) {
                        onChange((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsSelectValue)(index, checkboxesValues, enumOptions));
                    }
                    else {
                        onChange((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsDeselectValue)(index, checkboxesValues, enumOptions));
                    }
                };
                const checkbox = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: 'checkbox', id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.optionId)(id, index), name: id, checked: checked, value: String(index), disabled: disabled || itemDisabled || readonly, autoFocus: autofocus && index === 0, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(id) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: option.label })] }));
                return inline ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { className: `checkbox-inline ${disabledCls}`, children: checkbox }, index)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: `checkbox ${disabledCls}`, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: checkbox }) }, index));
            }) }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (CheckboxesWidget);
//# sourceMappingURL=CheckboxesWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ColorWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `ColorWidget` component uses the `BaseInputTemplate` changing the type to `color` and disables it when it is
 * either disabled or readonly.
 *
 * @param props - The `WidgetProps` for this component
 */
function ColorWidget(props) {
    const { disabled, readonly, options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'color', ...props, disabled: disabled || readonly });
}
//# sourceMappingURL=ColorWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DateTimeWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `DateTimeWidget` component uses the `BaseInputTemplate` changing the type to `datetime-local` and transforms
 * the value to/from utc using the appropriate utility functions.
 *
 * @param props - The `WidgetProps` for this component
 */
function DateTimeWidget(props) {
    const { onChange, value, options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'datetime-local', ...props, value: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.utcToLocal)(value), onChange: (value) => onChange((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.localToUTC)(value)) }));
}
//# sourceMappingURL=DateTimeWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/DateWidget.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/DateWidget.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ DateWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `DateWidget` component uses the `BaseInputTemplate` changing the type to `date` and transforms
 * the value to undefined when it is falsy during the `onChange` handling.
 *
 * @param props - The `WidgetProps` for this component
 */
function DateWidget(props) {
    const { onChange, options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('BaseInputTemplate', registry, options);
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value) => onChange(value || undefined), [onChange]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'date', ...props, onChange: handleChange });
}
//# sourceMappingURL=DateWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ EmailWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `EmailWidget` component uses the `BaseInputTemplate` changing the type to `email`.
 *
 * @param props - The `WidgetProps` for this component
 */
function EmailWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'email', ...props });
}
//# sourceMappingURL=EmailWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/FileWidget.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/FileWidget.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var markdown_to_jsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! markdown-to-jsx */ "./node_modules/markdown-to-jsx/dist/index.modern.js");




function addNameToDataURL(dataURL, name) {
    if (dataURL === null) {
        return null;
    }
    return dataURL.replace(';base64', `;name=${encodeURIComponent(name)};base64`);
}
function processFile(file) {
    const { name, size, type } = file;
    return new Promise((resolve, reject) => {
        const reader = new window.FileReader();
        reader.onerror = reject;
        reader.onload = (event) => {
            var _a;
            if (typeof ((_a = event.target) === null || _a === void 0 ? void 0 : _a.result) === 'string') {
                resolve({
                    dataURL: addNameToDataURL(event.target.result, name),
                    name,
                    size,
                    type,
                });
            }
            else {
                resolve({
                    dataURL: null,
                    name,
                    size,
                    type,
                });
            }
        };
        reader.readAsDataURL(file);
    });
}
function processFiles(files) {
    return Promise.all(Array.from(files).map(processFile));
}
function FileInfoPreview({ fileInfo, registry, }) {
    const { translateString } = registry;
    const { dataURL, type, name } = fileInfo;
    if (!dataURL) {
        return null;
    }
    if (type.indexOf('image') !== -1) {
        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("img", { src: dataURL, style: { maxWidth: '100%' }, className: 'file-preview' });
    }
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, { children: [' ', (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("a", { download: `preview-${name}`, href: dataURL, className: 'file-download', children: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.PreviewLabel) })] }));
}
function FilesInfo({ filesInfo, registry, preview, }) {
    if (filesInfo.length === 0) {
        return null;
    }
    const { translateString } = registry;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("ul", { className: 'file-info', children: filesInfo.map((fileInfo, key) => {
            const { name, size, type } = fileInfo;
            return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("li", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(markdown_to_jsx__WEBPACK_IMPORTED_MODULE_3__["default"], { children: translateString(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.TranslatableString.FilesInfo, [name, type, String(size)]) }), preview && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FileInfoPreview, { fileInfo: fileInfo, registry: registry })] }, key));
        }) }));
}
function extractFileInfo(dataURLs) {
    return dataURLs
        .filter((dataURL) => dataURL)
        .map((dataURL) => {
        const { blob, name } = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.dataURItoBlob)(dataURL);
        return {
            dataURL,
            name: name,
            size: blob.size,
            type: blob.type,
        };
    });
}
/**
 *  The `FileWidget` is a widget for rendering file upload fields.
 *  It is typically used with a string property with data-url format.
 */
function FileWidget(props) {
    const { disabled, readonly, required, multiple, onChange, value, options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('BaseInputTemplate', registry, options);
    const [filesInfo, setFilesInfo] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(Array.isArray(value) ? extractFileInfo(value) : extractFileInfo([value]));
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {
        if (!event.target.files) {
            return;
        }
        // Due to variances in themes, dealing with multiple files for the array case now happens one file at a time.
        // This is because we don't pass `multiple` into the `BaseInputTemplate` anymore. Instead, we deal with the single
        // file in each event and concatenate them together ourselves
        processFiles(event.target.files).then((filesInfoEvent) => {
            const newValue = filesInfoEvent.map((fileInfo) => fileInfo.dataURL);
            if (multiple) {
                setFilesInfo(filesInfo.concat(filesInfoEvent[0]));
                onChange(value.concat(newValue[0]));
            }
            else {
                setFilesInfo(filesInfoEvent);
                onChange(newValue[0]);
            }
        });
    }, [multiple, value, filesInfo, onChange]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { ...props, disabled: disabled || readonly, type: 'file', required: value ? false : required, onChangeOverride: handleChange, value: '', accept: options.accept ? String(options.accept) : undefined }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FilesInfo, { filesInfo: filesInfo, registry: registry, preview: options.filePreview })] }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (FileWidget);
//# sourceMappingURL=FileWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js":
/*!************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

/** The `HiddenWidget` is a widget for rendering a hidden input field.
 *  It is typically used by setting type to "hidden".
 *
 * @param props - The `WidgetProps` for this component
 */
function HiddenWidget({ id, value, }) {
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: 'hidden', id: id, name: id, value: typeof value === 'undefined' ? '' : value });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HiddenWidget);
//# sourceMappingURL=HiddenWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ PasswordWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `PasswordWidget` component uses the `BaseInputTemplate` changing the type to `password`.
 *
 * @param props - The `WidgetProps` for this component
 */
function PasswordWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'password', ...props });
}
//# sourceMappingURL=PasswordWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `RadioWidget` is a widget for rendering a radio group.
 *  It is typically used with a string property constrained with enum options.
 *
 * @param props - The `WidgetProps` for this component
 */
function RadioWidget({ options, value, required, disabled, readonly, autofocus = false, onBlur, onFocus, onChange, id, }) {
    const { enumOptions, enumDisabled, inline, emptyValue } = options;
    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onBlur(id, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(value, enumOptions, emptyValue)), [onBlur, id]);
    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onFocus(id, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(value, enumOptions, emptyValue)), [onFocus, id]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: 'field-radio-group', id: id, children: Array.isArray(enumOptions) &&
            enumOptions.map((option, i) => {
                const checked = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsIsSelected)(option.value, value);
                const itemDisabled = Array.isArray(enumDisabled) && enumDisabled.indexOf(option.value) !== -1;
                const disabledCls = disabled || itemDisabled || readonly ? 'disabled' : '';
                const handleChange = () => onChange(option.value);
                const radio = ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("span", { children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("input", { type: 'radio', id: (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.optionId)(id, i), checked: checked, name: id, required: required, value: String(i), disabled: disabled || itemDisabled || readonly, autoFocus: autofocus && i === 0, onChange: handleChange, onBlur: handleBlur, onFocus: handleFocus, "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(id) }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { children: option.label })] }));
                return inline ? ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { className: `radio-inline ${disabledCls}`, children: radio }, i)) : ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("div", { className: `radio ${disabledCls}`, children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("label", { children: radio }) }, i));
            }) }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (RadioWidget);
//# sourceMappingURL=RadioWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RangeWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");

/** The `RangeWidget` component uses the `BaseInputTemplate` changing the type to `range` and wrapping the result
 * in a div, with the value along side it.
 *
 * @param props - The `WidgetProps` for this component
 */
function RangeWidget(props) {
    const { value, registry: { templates: { BaseInputTemplate }, }, } = props;
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("div", { className: 'field-range-wrapper', children: [(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'range', ...props }), (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("span", { className: 'range-view', children: value })] }));
}
//# sourceMappingURL=RangeWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js":
/*!************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



function getValue(event, multiple) {
    if (multiple) {
        return Array.from(event.target.options)
            .slice()
            .filter((o) => o.selected)
            .map((o) => o.value);
    }
    return event.target.value;
}
/** The `SelectWidget` is a widget for rendering dropdowns.
 *  It is typically used with string properties constrained with enum options.
 *
 * @param props - The `WidgetProps` for this component
 */
function SelectWidget({ schema, id, options, value, required, disabled, readonly, multiple = false, autofocus = false, onChange, onBlur, onFocus, placeholder, }) {
    const { enumOptions, enumDisabled, emptyValue: optEmptyVal } = options;
    const emptyValue = multiple ? [] : '';
    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {
        const newValue = getValue(event, multiple);
        return onFocus(id, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(newValue, enumOptions, optEmptyVal));
    }, [onFocus, id, schema, multiple, options]);
    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {
        const newValue = getValue(event, multiple);
        return onBlur(id, (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(newValue, enumOptions, optEmptyVal));
    }, [onBlur, id, schema, multiple, options]);
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((event) => {
        const newValue = getValue(event, multiple);
        return onChange((0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsValueForIndex)(newValue, enumOptions, optEmptyVal));
    }, [onChange, schema, multiple, options]);
    const selectedIndexes = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.enumOptionsIndexForValue)(value, enumOptions, multiple);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)("select", { id: id, name: id, multiple: multiple, className: 'form-control', value: typeof selectedIndexes === 'undefined' ? emptyValue : selectedIndexes, required: required, disabled: disabled || readonly, autoFocus: autofocus, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(id), children: [!multiple && schema.default === undefined && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: '', children: placeholder }), Array.isArray(enumOptions) &&
                enumOptions.map(({ value, label }, i) => {
                    const disabled = enumDisabled && enumDisabled.indexOf(value) !== -1;
                    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("option", { value: String(i), disabled: disabled, children: label }, i));
                })] }));
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (SelectWidget);
//# sourceMappingURL=SelectWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/TextWidget.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/TextWidget.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TextWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `TextWidget` component uses the `BaseInputTemplate`.
 *
 * @param props - The `WidgetProps` for this component
 */
function TextWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { ...props });
}
//# sourceMappingURL=TextWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `TextareaWidget` is a widget for rendering input fields as textarea.
 *
 * @param props - The `WidgetProps` for this component
 */
function TextareaWidget({ id, options = {}, placeholder, value, required, disabled, readonly, autofocus = false, onChange, onBlur, onFocus, }) {
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onChange(value === '' ? options.emptyValue : value), [onChange, options.emptyValue]);
    const handleBlur = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onBlur(id, value), [onBlur, id]);
    const handleFocus = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(({ target: { value } }) => onFocus(id, value), [id, onFocus]);
    return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)("textarea", { id: id, name: id, className: 'form-control', value: value ? value : '', placeholder: placeholder, required: required, disabled: disabled, readOnly: readonly, autoFocus: autofocus, rows: options.rows, onBlur: handleBlur, onFocus: handleFocus, onChange: handleChange, "aria-describedby": (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.ariaDescribedByIds)(id) }));
}
TextareaWidget.defaultProps = {
    autofocus: false,
    options: {},
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (TextareaWidget);
//# sourceMappingURL=TextareaWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ TimeWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__);



/** The `TimeWidget` component uses the `BaseInputTemplate` changing the type to `time` and transforms
 * the value to undefined when it is falsy during the `onChange` handling.
 *
 * @param props - The `WidgetProps` for this component
 */
function TimeWidget(props) {
    const { onChange, options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_2__.getTemplate)('BaseInputTemplate', registry, options);
    const handleChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)((value) => onChange(value ? `${value}:00` : undefined), [onChange]);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'time', ...props, onChange: handleChange });
}
//# sourceMappingURL=TimeWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/URLWidget.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/URLWidget.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ URLWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `URLWidget` component uses the `BaseInputTemplate` changing the type to `url`.
 *
 * @param props - The `WidgetProps` for this component
 */
function URLWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'url', ...props });
}
//# sourceMappingURL=URLWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js":
/*!************************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ UpDownWidget)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__);


/** The `UpDownWidget` component uses the `BaseInputTemplate` changing the type to `number`.
 *
 * @param props - The `WidgetProps` for this component
 */
function UpDownWidget(props) {
    const { options, registry } = props;
    const BaseInputTemplate = (0,_rjsf_utils__WEBPACK_IMPORTED_MODULE_1__.getTemplate)('BaseInputTemplate', registry, options);
    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseInputTemplate, { type: 'number', ...props });
}
//# sourceMappingURL=UpDownWidget.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/components/widgets/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/components/widgets/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _AltDateWidget__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AltDateWidget */ "./node_modules/@rjsf/core/lib/components/widgets/AltDateWidget.js");
/* harmony import */ var _AltDateTimeWidget__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./AltDateTimeWidget */ "./node_modules/@rjsf/core/lib/components/widgets/AltDateTimeWidget.js");
/* harmony import */ var _CheckboxWidget__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./CheckboxWidget */ "./node_modules/@rjsf/core/lib/components/widgets/CheckboxWidget.js");
/* harmony import */ var _CheckboxesWidget__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./CheckboxesWidget */ "./node_modules/@rjsf/core/lib/components/widgets/CheckboxesWidget.js");
/* harmony import */ var _ColorWidget__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ColorWidget */ "./node_modules/@rjsf/core/lib/components/widgets/ColorWidget.js");
/* harmony import */ var _DateWidget__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./DateWidget */ "./node_modules/@rjsf/core/lib/components/widgets/DateWidget.js");
/* harmony import */ var _DateTimeWidget__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./DateTimeWidget */ "./node_modules/@rjsf/core/lib/components/widgets/DateTimeWidget.js");
/* harmony import */ var _EmailWidget__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./EmailWidget */ "./node_modules/@rjsf/core/lib/components/widgets/EmailWidget.js");
/* harmony import */ var _FileWidget__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./FileWidget */ "./node_modules/@rjsf/core/lib/components/widgets/FileWidget.js");
/* harmony import */ var _HiddenWidget__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./HiddenWidget */ "./node_modules/@rjsf/core/lib/components/widgets/HiddenWidget.js");
/* harmony import */ var _PasswordWidget__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./PasswordWidget */ "./node_modules/@rjsf/core/lib/components/widgets/PasswordWidget.js");
/* harmony import */ var _RadioWidget__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./RadioWidget */ "./node_modules/@rjsf/core/lib/components/widgets/RadioWidget.js");
/* harmony import */ var _RangeWidget__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./RangeWidget */ "./node_modules/@rjsf/core/lib/components/widgets/RangeWidget.js");
/* harmony import */ var _SelectWidget__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./SelectWidget */ "./node_modules/@rjsf/core/lib/components/widgets/SelectWidget.js");
/* harmony import */ var _TextareaWidget__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./TextareaWidget */ "./node_modules/@rjsf/core/lib/components/widgets/TextareaWidget.js");
/* harmony import */ var _TextWidget__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./TextWidget */ "./node_modules/@rjsf/core/lib/components/widgets/TextWidget.js");
/* harmony import */ var _TimeWidget__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./TimeWidget */ "./node_modules/@rjsf/core/lib/components/widgets/TimeWidget.js");
/* harmony import */ var _URLWidget__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./URLWidget */ "./node_modules/@rjsf/core/lib/components/widgets/URLWidget.js");
/* harmony import */ var _UpDownWidget__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./UpDownWidget */ "./node_modules/@rjsf/core/lib/components/widgets/UpDownWidget.js");



















function widgets() {
    return {
        AltDateWidget: _AltDateWidget__WEBPACK_IMPORTED_MODULE_0__["default"],
        AltDateTimeWidget: _AltDateTimeWidget__WEBPACK_IMPORTED_MODULE_1__["default"],
        CheckboxWidget: _CheckboxWidget__WEBPACK_IMPORTED_MODULE_2__["default"],
        CheckboxesWidget: _CheckboxesWidget__WEBPACK_IMPORTED_MODULE_3__["default"],
        ColorWidget: _ColorWidget__WEBPACK_IMPORTED_MODULE_4__["default"],
        DateWidget: _DateWidget__WEBPACK_IMPORTED_MODULE_5__["default"],
        DateTimeWidget: _DateTimeWidget__WEBPACK_IMPORTED_MODULE_6__["default"],
        EmailWidget: _EmailWidget__WEBPACK_IMPORTED_MODULE_7__["default"],
        FileWidget: _FileWidget__WEBPACK_IMPORTED_MODULE_8__["default"],
        HiddenWidget: _HiddenWidget__WEBPACK_IMPORTED_MODULE_9__["default"],
        PasswordWidget: _PasswordWidget__WEBPACK_IMPORTED_MODULE_10__["default"],
        RadioWidget: _RadioWidget__WEBPACK_IMPORTED_MODULE_11__["default"],
        RangeWidget: _RangeWidget__WEBPACK_IMPORTED_MODULE_12__["default"],
        SelectWidget: _SelectWidget__WEBPACK_IMPORTED_MODULE_13__["default"],
        TextWidget: _TextWidget__WEBPACK_IMPORTED_MODULE_15__["default"],
        TextareaWidget: _TextareaWidget__WEBPACK_IMPORTED_MODULE_14__["default"],
        TimeWidget: _TimeWidget__WEBPACK_IMPORTED_MODULE_16__["default"],
        UpDownWidget: _UpDownWidget__WEBPACK_IMPORTED_MODULE_18__["default"],
        URLWidget: _URLWidget__WEBPACK_IMPORTED_MODULE_17__["default"],
    };
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (widgets);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/getDefaultRegistry.js":
/*!***********************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/getDefaultRegistry.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ getDefaultRegistry)
/* harmony export */ });
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @rjsf/utils */ "webpack/sharing/consume/default/@rjsf/utils/@rjsf/utils");
/* harmony import */ var _rjsf_utils__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_rjsf_utils__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _components_fields__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./components/fields */ "./node_modules/@rjsf/core/lib/components/fields/index.js");
/* harmony import */ var _components_templates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/templates */ "./node_modules/@rjsf/core/lib/components/templates/index.js");
/* harmony import */ var _components_widgets__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/widgets */ "./node_modules/@rjsf/core/lib/components/widgets/index.js");




/** The default registry consists of all the fields, templates and widgets provided in the core implementation,
 * plus an empty `rootSchema` and `formContext. We omit schemaUtils here because it cannot be defaulted without a
 * rootSchema and validator. It will be added into the computed registry later in the Form.
 */
function getDefaultRegistry() {
    return {
        fields: (0,_components_fields__WEBPACK_IMPORTED_MODULE_1__["default"])(),
        templates: (0,_components_templates__WEBPACK_IMPORTED_MODULE_2__["default"])(),
        widgets: (0,_components_widgets__WEBPACK_IMPORTED_MODULE_3__["default"])(),
        rootSchema: {},
        formContext: {},
        translateString: _rjsf_utils__WEBPACK_IMPORTED_MODULE_0__.englishStringTranslator,
    };
}
//# sourceMappingURL=getDefaultRegistry.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@rjsf/core/lib/index.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   getDefaultRegistry: () => (/* reexport safe */ _getDefaultRegistry__WEBPACK_IMPORTED_MODULE_2__["default"]),
/* harmony export */   withTheme: () => (/* reexport safe */ _withTheme__WEBPACK_IMPORTED_MODULE_1__["default"])
/* harmony export */ });
/* harmony import */ var _components_Form__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./components/Form */ "./node_modules/@rjsf/core/lib/components/Form.js");
/* harmony import */ var _withTheme__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./withTheme */ "./node_modules/@rjsf/core/lib/withTheme.js");
/* harmony import */ var _getDefaultRegistry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./getDefaultRegistry */ "./node_modules/@rjsf/core/lib/getDefaultRegistry.js");




/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_components_Form__WEBPACK_IMPORTED_MODULE_0__["default"]);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@rjsf/core/lib/withTheme.js":
/*!**************************************************!*\
  !*** ./node_modules/@rjsf/core/lib/withTheme.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ withTheme)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _components_Form__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/Form */ "./node_modules/@rjsf/core/lib/components/Form.js");



/** A Higher-Order component that creates a wrapper around a `Form` with the overrides from the `WithThemeProps` */
function withTheme(themeProps) {
    return (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ fields, widgets, templates, ...directProps }, ref) => {
        var _a;
        fields = { ...themeProps === null || themeProps === void 0 ? void 0 : themeProps.fields, ...fields };
        widgets = { ...themeProps === null || themeProps === void 0 ? void 0 : themeProps.widgets, ...widgets };
        templates = {
            ...themeProps === null || themeProps === void 0 ? void 0 : themeProps.templates,
            ...templates,
            ButtonTemplates: {
                ...(_a = themeProps === null || themeProps === void 0 ? void 0 : themeProps.templates) === null || _a === void 0 ? void 0 : _a.ButtonTemplates,
                ...templates === null || templates === void 0 ? void 0 : templates.ButtonTemplates,
            },
        };
        return ((0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(_components_Form__WEBPACK_IMPORTED_MODULE_2__["default"], { ...themeProps, ...directProps, fields: fields, widgets: widgets, templates: templates, ref: ref }));
    });
}
//# sourceMappingURL=withTheme.js.map

/***/ }),

/***/ "./node_modules/free-style/dist.es2015/index.js":
/*!******************************************************!*\
  !*** ./node_modules/free-style/dist.es2015/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Cache: () => (/* binding */ Cache),
/* harmony export */   FreeStyle: () => (/* binding */ FreeStyle),
/* harmony export */   Rule: () => (/* binding */ Rule),
/* harmony export */   Selector: () => (/* binding */ Selector),
/* harmony export */   Style: () => (/* binding */ Style),
/* harmony export */   create: () => (/* binding */ create)
/* harmony export */ });
/**
 * The unique id is used for unique hashes.
 */
let uniqueId = 0;
/**
 * Quick dictionary lookup for unit-less numbers.
 */
const CSS_NUMBER = Object.create(null);
/**
 * CSS properties that are valid unit-less numbers.
 *
 * Ref: https://github.com/facebook/react/blob/master/packages/react-dom/src/shared/CSSProperty.js
 */
const CSS_NUMBER_KEYS = [
    "animation-iteration-count",
    "border-image-outset",
    "border-image-slice",
    "border-image-width",
    "box-flex",
    "box-flex-group",
    "box-ordinal-group",
    "column-count",
    "columns",
    "counter-increment",
    "counter-reset",
    "flex",
    "flex-grow",
    "flex-positive",
    "flex-shrink",
    "flex-negative",
    "flex-order",
    "font-weight",
    "grid-area",
    "grid-column",
    "grid-column-end",
    "grid-column-span",
    "grid-column-start",
    "grid-row",
    "grid-row-end",
    "grid-row-span",
    "grid-row-start",
    "line-clamp",
    "line-height",
    "opacity",
    "order",
    "orphans",
    "tab-size",
    "widows",
    "z-index",
    "zoom",
    // SVG properties.
    "fill-opacity",
    "flood-opacity",
    "stop-opacity",
    "stroke-dasharray",
    "stroke-dashoffset",
    "stroke-miterlimit",
    "stroke-opacity",
    "stroke-width"
];
// Add vendor prefixes to all unit-less properties.
for (const property of CSS_NUMBER_KEYS) {
    for (const prefix of ["-webkit-", "-ms-", "-moz-", "-o-", ""]) {
        CSS_NUMBER[prefix + property] = true;
    }
}
/**
 * Escape a CSS class name.
 */
function escape(str) {
    return str.replace(/[ !#$%&()*+,./;<=>?@[\]^`{|}~"'\\]/g, "\\$&");
}
/**
 * Transform a JavaScript property into a CSS property.
 */
function hyphenate(propertyName) {
    return propertyName
        .replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`)
        .replace(/^ms-/, "-ms-"); // Internet Explorer vendor prefix.
}
/**
 * Generate a hash value from a string.
 */
function stringHash(str) {
    let value = 5381;
    let len = str.length;
    while (len--)
        value = (value * 33) ^ str.charCodeAt(len);
    return (value >>> 0).toString(36);
}
/**
 * Transform a style string to a CSS string.
 */
function styleToString(key, value) {
    if (value && typeof value === "number" && !CSS_NUMBER[key]) {
        return `${key}:${value}px`;
    }
    return `${key}:${value}`;
}
/**
 * Sort an array of tuples by first value.
 */
function sortTuples(value) {
    return value.sort((a, b) => (a[0] > b[0] ? 1 : -1));
}
/**
 * Categorize user styles.
 */
function parseStyles(styles, hasNestedStyles) {
    const properties = [];
    const nestedStyles = [];
    // Sort keys before adding to styles.
    for (const key of Object.keys(styles)) {
        const name = key.trim();
        const value = styles[key];
        if (name.charCodeAt(0) !== 36 /* $ */ && value != null) {
            if (typeof value === "object" && !Array.isArray(value)) {
                nestedStyles.push([name, value]);
            }
            else {
                properties.push([hyphenate(name), value]);
            }
        }
    }
    return {
        style: stringifyProperties(sortTuples(properties)),
        nested: hasNestedStyles ? nestedStyles : sortTuples(nestedStyles),
        isUnique: !!styles.$unique
    };
}
/**
 * Stringify an array of property tuples.
 */
function stringifyProperties(properties) {
    return properties
        .map(([name, value]) => {
        if (!Array.isArray(value))
            return styleToString(name, value);
        return value.map(x => styleToString(name, x)).join(";");
    })
        .join(";");
}
/**
 * Interpolate CSS selectors.
 */
function interpolate(selector, parent) {
    if (selector.indexOf("&") === -1)
        return `${parent} ${selector}`;
    return selector.replace(/&/g, parent);
}
/**
 * Recursive loop building styles with deferred selectors.
 */
function stylize(selector, styles, rulesList, stylesList, parent) {
    const { style, nested, isUnique } = parseStyles(styles, selector !== "");
    let pid = style;
    if (selector.charCodeAt(0) === 64 /* @ */) {
        const child = {
            selector,
            styles: [],
            rules: [],
            style: parent ? "" : style
        };
        rulesList.push(child);
        // Nested styles support (e.g. `.foo > @media > .bar`).
        if (style && parent) {
            child.styles.push({ selector: parent, style, isUnique });
        }
        for (const [name, value] of nested) {
            pid += name + stylize(name, value, child.rules, child.styles, parent);
        }
    }
    else {
        const key = parent ? interpolate(selector, parent) : selector;
        if (style)
            stylesList.push({ selector: key, style, isUnique });
        for (const [name, value] of nested) {
            pid += name + stylize(name, value, rulesList, stylesList, key);
        }
    }
    return pid;
}
/**
 * Transform `stylize` tree into style objects.
 */
function composeStylize(cache, pid, rulesList, stylesList, className, isStyle) {
    for (const { selector, style, isUnique } of stylesList) {
        const key = isStyle ? interpolate(selector, className) : selector;
        const id = isUnique
            ? `u\0${(++uniqueId).toString(36)}`
            : `s\0${pid}\0${style}`;
        const item = new Style(style, id);
        item.add(new Selector(key, `k\0${pid}\0${key}`));
        cache.add(item);
    }
    for (const { selector, style, rules, styles } of rulesList) {
        const item = new Rule(selector, style, `r\0${pid}\0${selector}\0${style}`);
        composeStylize(item, pid, rules, styles, className, isStyle);
        cache.add(item);
    }
}
/**
 * Cache to list to styles.
 */
function join(arr) {
    let res = "";
    for (let i = 0; i < arr.length; i++)
        res += arr[i];
    return res;
}
/**
 * Noop changes.
 */
const noopChanges = {
    add: () => undefined,
    change: () => undefined,
    remove: () => undefined
};
/**
 * Implement a cache/event emitter.
 */
class Cache {
    constructor(changes = noopChanges) {
        this.changes = changes;
        this.sheet = [];
        this.changeId = 0;
        this._keys = [];
        this._children = Object.create(null);
        this._counters = Object.create(null);
    }
    add(style) {
        const count = this._counters[style.id] || 0;
        const item = this._children[style.id] || style.clone();
        this._counters[style.id] = count + 1;
        if (count === 0) {
            this._children[item.id] = item;
            this._keys.push(item.id);
            this.sheet.push(item.getStyles());
            this.changeId++;
            this.changes.add(item, this._keys.length - 1);
        }
        else if (item instanceof Cache && style instanceof Cache) {
            const curIndex = this._keys.indexOf(style.id);
            const prevItemChangeId = item.changeId;
            item.merge(style);
            if (item.changeId !== prevItemChangeId) {
                this.sheet.splice(curIndex, 1, item.getStyles());
                this.changeId++;
                this.changes.change(item, curIndex, curIndex);
            }
        }
    }
    remove(style) {
        const count = this._counters[style.id];
        if (count) {
            this._counters[style.id] = count - 1;
            const item = this._children[style.id];
            const index = this._keys.indexOf(item.id);
            if (count === 1) {
                delete this._counters[style.id];
                delete this._children[style.id];
                this._keys.splice(index, 1);
                this.sheet.splice(index, 1);
                this.changeId++;
                this.changes.remove(item, index);
            }
            else if (item instanceof Cache && style instanceof Cache) {
                const prevChangeId = item.changeId;
                item.unmerge(style);
                if (item.changeId !== prevChangeId) {
                    this.sheet.splice(index, 1, item.getStyles());
                    this.changeId++;
                    this.changes.change(item, index, index);
                }
            }
        }
    }
    values() {
        return this._keys.map(key => this._children[key]);
    }
    merge(cache) {
        for (const item of cache.values())
            this.add(item);
        return this;
    }
    unmerge(cache) {
        for (const item of cache.values())
            this.remove(item);
        return this;
    }
    clone() {
        return new Cache().merge(this);
    }
}
/**
 * Selector is a dumb class made to represent nested CSS selectors.
 */
class Selector {
    constructor(selector, id) {
        this.selector = selector;
        this.id = id;
    }
    getStyles() {
        return this.selector;
    }
    clone() {
        return this;
    }
}
/**
 * The style container registers a style string with selectors.
 */
class Style extends Cache {
    constructor(style, id) {
        super();
        this.style = style;
        this.id = id;
    }
    getStyles() {
        return `${this.sheet.join(",")}{${this.style}}`;
    }
    clone() {
        return new Style(this.style, this.id).merge(this);
    }
}
/**
 * Implement rule logic for style output.
 */
class Rule extends Cache {
    constructor(rule, style, id) {
        super();
        this.rule = rule;
        this.style = style;
        this.id = id;
    }
    getStyles() {
        return `${this.rule}{${this.style}${join(this.sheet)}}`;
    }
    clone() {
        return new Rule(this.rule, this.style, this.id).merge(this);
    }
}
function key(pid, styles) {
    const key = `f${stringHash(pid)}`;
    if ( false || !styles.$displayName)
        return key;
    return `${styles.$displayName}_${key}`;
}
/**
 * The FreeStyle class implements the API for everything else.
 */
class FreeStyle extends Cache {
    constructor(id, changes) {
        super(changes);
        this.id = id;
    }
    registerStyle(styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("&", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `.${ false ? 0 : escape(id)}`;
        composeStylize(this, pid, rulesList, stylesList, selector, true);
        return id;
    }
    registerKeyframes(keyframes) {
        return this.registerHashRule("@keyframes", keyframes);
    }
    registerHashRule(prefix, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize("", styles, rulesList, stylesList);
        const id = key(pid, styles);
        const selector = `${prefix} ${ false ? 0 : escape(id)}`;
        const rule = new Rule(selector, "", `h\0${pid}\0${prefix}`);
        composeStylize(rule, pid, rulesList, stylesList, "", false);
        this.add(rule);
        return id;
    }
    registerRule(rule, styles) {
        const rulesList = [];
        const stylesList = [];
        const pid = stylize(rule, styles, rulesList, stylesList);
        composeStylize(this, pid, rulesList, stylesList, "", false);
    }
    registerCss(styles) {
        return this.registerRule("", styles);
    }
    getStyles() {
        return join(this.sheet);
    }
    clone() {
        return new FreeStyle(this.id, this.changes).merge(this);
    }
}
/**
 * Exports a simple function to create a new instance.
 */
function create(changes) {
    return new FreeStyle(`f${(++uniqueId).toString(36)}`, changes);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/lodash/_basePick.js":
/*!******************************************!*\
  !*** ./node_modules/lodash/_basePick.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePickBy = __webpack_require__(/*! ./_basePickBy */ "./node_modules/lodash/_basePickBy.js"),
    hasIn = __webpack_require__(/*! ./hasIn */ "./node_modules/lodash/hasIn.js");

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, paths) {
  return basePickBy(object, paths, function(value, path) {
    return hasIn(object, path);
  });
}

module.exports = basePick;


/***/ }),

/***/ "./node_modules/lodash/_basePickBy.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_basePickBy.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGet = __webpack_require__(/*! ./_baseGet */ "./node_modules/lodash/_baseGet.js"),
    baseSet = __webpack_require__(/*! ./_baseSet */ "./node_modules/lodash/_baseSet.js"),
    castPath = __webpack_require__(/*! ./_castPath */ "./node_modules/lodash/_castPath.js");

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} paths The property paths to pick.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, paths, predicate) {
  var index = -1,
      length = paths.length,
      result = {};

  while (++index < length) {
    var path = paths[index],
        value = baseGet(object, path);

    if (predicate(value, path)) {
      baseSet(result, castPath(path, object), value);
    }
  }
  return result;
}

module.exports = basePickBy;


/***/ }),

/***/ "./node_modules/lodash/pick.js":
/*!*************************************!*\
  !*** ./node_modules/lodash/pick.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var basePick = __webpack_require__(/*! ./_basePick */ "./node_modules/lodash/_basePick.js"),
    flatRest = __webpack_require__(/*! ./_flatRest */ "./node_modules/lodash/_flatRest.js");

/**
 * Creates an object composed of the picked `object` properties.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [paths] The property paths to pick.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pick(object, ['a', 'c']);
 * // => { 'a': 1, 'c': 3 }
 */
var pick = flatRest(function(object, paths) {
  return object == null ? {} : basePick(object, paths);
});

module.exports = pick;


/***/ }),

/***/ "./node_modules/lodash/unset.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/unset.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseUnset = __webpack_require__(/*! ./_baseUnset */ "./node_modules/lodash/_baseUnset.js");

/**
 * Removes the property at `path` of `object`.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
 * _.unset(object, 'a[0].b.c');
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 *
 * _.unset(object, ['a', '0', 'b', 'c']);
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 */
function unset(object, path) {
  return object == null ? true : baseUnset(object, path);
}

module.exports = unset;


/***/ }),

/***/ "./node_modules/markdown-to-jsx/dist/index.modern.js":
/*!***********************************************************!*\
  !*** ./node_modules/markdown-to-jsx/dist/index.modern.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RuleType: () => (/* binding */ r),
/* harmony export */   compiler: () => (/* binding */ Ze),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   sanitizer: () => (/* binding */ Ue),
/* harmony export */   slugify: () => (/* binding */ Ce)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "webpack/sharing/consume/default/react/react");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);
function t(){return t=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e},t.apply(this,arguments)}const n=["children","options"],r={blockQuote:"0",breakLine:"1",breakThematic:"2",codeBlock:"3",codeFenced:"4",codeInline:"5",footnote:"6",footnoteReference:"7",gfmTask:"8",heading:"9",headingSetext:"10",htmlBlock:"11",htmlComment:"12",htmlSelfClosing:"13",image:"14",link:"15",linkAngleBraceStyleDetector:"16",linkBareUrlDetector:"17",linkMailtoDetector:"18",newlineCoalescer:"19",orderedList:"20",paragraph:"21",ref:"22",refImage:"23",refLink:"24",table:"25",tableSeparator:"26",text:"27",textBolded:"28",textEmphasized:"29",textEscaped:"30",textMarked:"31",textStrikethroughed:"32",unorderedList:"33"};var i;!function(e){e[e.MAX=0]="MAX",e[e.HIGH=1]="HIGH",e[e.MED=2]="MED",e[e.LOW=3]="LOW",e[e.MIN=4]="MIN"}(i||(i={}));const l=["allowFullScreen","allowTransparency","autoComplete","autoFocus","autoPlay","cellPadding","cellSpacing","charSet","className","classId","colSpan","contentEditable","contextMenu","crossOrigin","encType","formAction","formEncType","formMethod","formNoValidate","formTarget","frameBorder","hrefLang","inputMode","keyParams","keyType","marginHeight","marginWidth","maxLength","mediaGroup","minLength","noValidate","radioGroup","readOnly","rowSpan","spellCheck","srcDoc","srcLang","srcSet","tabIndex","useMap"].reduce((e,t)=>(e[t.toLowerCase()]=t,e),{for:"htmlFor"}),a={amp:"&",apos:"'",gt:">",lt:"<",nbsp:" ",quot:"“"},o=["style","script"],c=/([-A-Z0-9_:]+)(?:\s*=\s*(?:(?:"((?:\\.|[^"])*)")|(?:'((?:\\.|[^'])*)')|(?:\{((?:\\.|{[^}]*?}|[^}])*)\})))?/gi,s=/mailto:/i,d=/\n{2,}$/,u=/^(\s*>[\s\S]*?)(?=\n{2,})/,p=/^ *> ?/gm,f=/^ {2,}\n/,h=/^(?:( *[-*_])){3,} *(?:\n *)+\n/,m=/^\s*(`{3,}|~{3,}) *(\S+)?([^\n]*?)?\n([\s\S]+?)\s*\1 *(?:\n *)*\n?/,g=/^(?: {4}[^\n]+\n*)+(?:\n *)+\n?/,y=/^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,k=/^(?:\n *)*\n/,x=/\r\n?/g,b=/^\[\^([^\]]+)](:(.*)((\n+ {4,}.*)|(\n(?!\[\^).+))*)/,v=/^\[\^([^\]]+)]/,S=/\f/g,E=/^---[ \t]*\n(.|\n)*\n---[ \t]*\n/,$=/^\s*?\[(x|\s)\]/,w=/^ *(#{1,6}) *([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/,C=/^ *(#{1,6}) +([^\n]+?)(?: +#*)?(?:\n *)*(?:\n|$)/,z=/^([^\n]+)\n *(=|-){3,} *(?:\n *)+\n/,L=/^ *(?!<[a-z][^ >/]* ?\/>)<([a-z][^ >/]*) ?((?:[^>]*[^/])?)>\n?(\s*(?:<\1[^>]*?>[\s\S]*?<\/\1>|(?!<\1\b)[\s\S])*?)<\/\1>(?!<\/\1>)\n*/i,A=/&([a-z0-9]+|#[0-9]{1,6}|#x[0-9a-fA-F]{1,6});/gi,T=/^<!--[\s\S]*?(?:-->)/,O=/^(data|aria|x)-[a-z_][a-z\d_.-]*$/,B=/^ *<([a-z][a-z0-9:]*)(?:\s+((?:<.*?>|[^>])*))?\/?>(?!<\/\1>)(\s*\n)?/i,M=/^\{.*\}$/,R=/^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,I=/^<([^ >]+@[^ >]+)>/,U=/^<([^ >]+:\/[^ >]+)>/,D=/-([a-z])?/gi,j=/^(.*\|.*)\n(?: *(\|? *[-:]+ *\|[-| :]*)\n((?:.*\|.*\n)*))?\n?/,N=/^\[([^\]]*)\]:\s+<?([^\s>]+)>?\s*("([^"]*)")?/,H=/^!\[([^\]]*)\] ?\[([^\]]*)\]/,F=/^\[([^\]]*)\] ?\[([^\]]*)\]/,P=/(\[|\])/g,_=/(\n|^[-*]\s|^#|^ {2,}|^-{2,}|^>\s)/,W=/\t/g,G=/(^ *\||\| *$)/g,Z=/^ *:-+: *$/,q=/^ *:-+ *$/,Q=/^ *-+: *$/,V="((?:\\[.*?\\][([].*?[)\\]]|<.*?>(?:.*?<.*?>)?|`.*?`|~~.*?~~|==.*?==|.|\\n)*?)",X=new RegExp(`^([*_])\\1${V}\\1\\1(?!\\1)`),J=new RegExp(`^([*_])${V}\\1(?!\\1|\\w)`),K=new RegExp(`^==${V}==`),Y=new RegExp(`^~~${V}~~`),ee=/^\\([^0-9A-Za-z\s])/,te=/^[\s\S]+?(?=[^0-9A-Z\s\u00c0-\uffff&#;.()'"]|\d+\.|\n\n| {2,}\n|\w+:\S|$)/i,ne=/^\n+/,re=/^([ \t]*)/,ie=/\\([^\\])/g,le=/ *\n+$/,ae=/(?:^|\n)( *)$/,oe="(?:\\d+\\.)",ce="(?:[*+-])";function se(e){return"( *)("+(1===e?oe:ce)+") +"}const de=se(1),ue=se(2);function pe(e){return new RegExp("^"+(1===e?de:ue))}const fe=pe(1),he=pe(2);function me(e){return new RegExp("^"+(1===e?de:ue)+"[^\\n]*(?:\\n(?!\\1"+(1===e?oe:ce)+" )[^\\n]*)*(\\n|$)","gm")}const ge=me(1),ye=me(2);function ke(e){const t=1===e?oe:ce;return new RegExp("^( *)("+t+") [\\s\\S]+?(?:\\n{2,}(?! )(?!\\1"+t+" (?!"+t+" ))\\n*|\\s*\\n*$)")}const xe=ke(1),be=ke(2);function ve(e,t){const n=1===t,i=n?xe:be,l=n?ge:ye,a=n?fe:he;return{match(e,t,n){const r=ae.exec(n);return r&&(t.list||!t.inline&&!t.simple)?i.exec(e=r[1]+e):null},order:1,parse(e,t,r){const i=n?+e[2]:void 0,o=e[0].replace(d,"\n").match(l);let c=!1;return{items:o.map(function(e,n){const i=a.exec(e)[0].length,l=new RegExp("^ {1,"+i+"}","gm"),s=e.replace(l,"").replace(a,""),d=n===o.length-1,u=-1!==s.indexOf("\n\n")||d&&c;c=u;const p=r.inline,f=r.list;let h;r.list=!0,u?(r.inline=!1,h=s.replace(le,"\n\n")):(r.inline=!0,h=s.replace(le,""));const m=t(h,r);return r.inline=p,r.list=f,m}),ordered:n,start:i}},render:(t,n,i)=>e(t.ordered?"ol":"ul",{key:i.key,start:t.type===r.orderedList?t.start:void 0},t.items.map(function(t,r){return e("li",{key:r},n(t,i))}))}}const Se=new RegExp("^\\[((?:\\[[^\\]]*\\]|[^\\[\\]]|\\](?=[^\\[]*\\]))*)\\]\\(\\s*<?((?:\\([^)]*\\)|[^\\s\\\\]|\\\\.)*?)>?(?:\\s+['\"]([\\s\\S]*?)['\"])?\\s*\\)"),Ee=/^!\[(.*?)\]\( *((?:\([^)]*\)|[^() ])*) *"?([^)"]*)?"?\)/,$e=[u,m,g,w,z,C,T,j,ge,xe,ye,be],we=[...$e,/^[^\n]+(?:  \n|\n{2,})/,L,B];function Ce(e){return e.replace(/[ÀÁÂÃÄÅàáâãäåæÆ]/g,"a").replace(/[çÇ]/g,"c").replace(/[ðÐ]/g,"d").replace(/[ÈÉÊËéèêë]/g,"e").replace(/[ÏïÎîÍíÌì]/g,"i").replace(/[Ññ]/g,"n").replace(/[øØœŒÕõÔôÓóÒò]/g,"o").replace(/[ÜüÛûÚúÙù]/g,"u").replace(/[ŸÿÝý]/g,"y").replace(/[^a-z0-9- ]/gi,"").replace(/ /gi,"-").toLowerCase()}function ze(e){return Q.test(e)?"right":Z.test(e)?"center":q.test(e)?"left":null}function Le(e,t,n,i){const l=n.inTable;n.inTable=!0;let a=e.trim().split(/( *(?:`[^`]*`|<.*?>.*?<\/.*?>(?!<\/.*?>)|\\\||\|) *)/).reduce((e,l)=>("|"===l.trim()?e.push(i?{type:r.tableSeparator}:{type:r.text,text:l}):""!==l&&e.push.apply(e,t(l,n)),e),[]);n.inTable=l;let o=[[]];return a.forEach(function(e,t){e.type===r.tableSeparator?0!==t&&t!==a.length-1&&o.push([]):(e.type!==r.text||null!=a[t+1]&&a[t+1].type!==r.tableSeparator||(e.text=e.text.trimEnd()),o[o.length-1].push(e))}),o}function Ae(e,t,n){n.inline=!0;const i=e[2]?e[2].replace(G,"").split("|").map(ze):[],l=e[3]?function(e,t,n){return e.trim().split("\n").map(function(e){return Le(e,t,n,!0)})}(e[3],t,n):[],a=Le(e[1],t,n,!!l.length);return n.inline=!1,l.length?{align:i,cells:l,header:a,type:r.table}:{children:a,type:r.paragraph}}function Te(e,t){return null==e.align[t]?{}:{textAlign:e.align[t]}}function Oe(e){return function(t,n){return n.inline?e.exec(t):null}}function Be(e){return function(t,n){return n.inline||n.simple?e.exec(t):null}}function Me(e){return function(t,n){return n.inline||n.simple?null:e.exec(t)}}function Re(e){return function(t){return e.exec(t)}}function Ie(e,t,n){if(t.inline||t.simple)return null;if(n&&!n.endsWith("\n"))return null;let r="";e.split("\n").every(e=>!$e.some(t=>t.test(e))&&(r+=e+"\n",e.trim()));const i=r.trimEnd();return""==i?null:[r,i]}function Ue(e){try{if(decodeURIComponent(e).replace(/[^A-Za-z0-9/:]/g,"").match(/^\s*(javascript|vbscript|data(?!:image)):/i))return null}catch(e){return null}return e}function De(e){return e.replace(ie,"$1")}function je(e,t,n){const r=n.inline||!1,i=n.simple||!1;n.inline=!0,n.simple=!0;const l=e(t,n);return n.inline=r,n.simple=i,l}function Ne(e,t,n){const r=n.inline||!1,i=n.simple||!1;n.inline=!1,n.simple=!0;const l=e(t,n);return n.inline=r,n.simple=i,l}function He(e,t,n){const r=n.inline||!1;n.inline=!1;const i=e(t,n);return n.inline=r,i}const Fe=(e,t,n)=>({children:je(t,e[1],n)});function Pe(){return{}}function _e(){return null}function We(...e){return e.filter(Boolean).join(" ")}function Ge(e,t,n){let r=e;const i=t.split(".");for(;i.length&&(r=r[i[0]],void 0!==r);)i.shift();return r||n}function Ze(n="",i={}){function d(e,n,...r){const l=Ge(i.overrides,`${e}.props`,{});return i.createElement(function(e,t){const n=Ge(t,e);return n?"function"==typeof n||"object"==typeof n&&"render"in n?n:Ge(t,`${e}.component`,e):e}(e,i.overrides),t({},n,l,{className:We(null==n?void 0:n.className,l.className)||void 0}),...r)}function G(t){t=t.replace(E,"");let n=!1;i.forceInline?n=!0:i.forceBlock||(n=!1===_.test(t));const r=le(ie(n?t:`${t.trimEnd().replace(ne,"")}\n\n`,{inline:n}));for(;"string"==typeof r[r.length-1]&&!r[r.length-1].trim();)r.pop();if(null===i.wrapper)return r;const l=i.wrapper||(n?"span":"div");let a;if(r.length>1||i.forceWrapper)a=r;else{if(1===r.length)return a=r[0],"string"==typeof a?d("span",{key:"outer"},a):a;a=null}return react__WEBPACK_IMPORTED_MODULE_0__.createElement(l,{key:"outer"},a)}function Z(t,n){const r=n.match(c);return r?r.reduce(function(n,r,a){const o=r.indexOf("=");if(-1!==o){const c=function(e){return-1!==e.indexOf("-")&&null===e.match(O)&&(e=e.replace(D,function(e,t){return t.toUpperCase()})),e}(r.slice(0,o)).trim(),s=function(e){const t=e[0];return('"'===t||"'"===t)&&e.length>=2&&e[e.length-1]===t?e.slice(1,-1):e}(r.slice(o+1).trim()),d=l[c]||c,u=n[d]=function(e,t,n,r){return"style"===t?n.split(/;\s?/).reduce(function(e,t){const n=t.slice(0,t.indexOf(":"));return e[n.trim().replace(/(-[a-z])/g,e=>e[1].toUpperCase())]=t.slice(n.length+1).trim(),e},{}):"href"===t||"src"===t?r(n,e,t):(n.match(M)&&(n=n.slice(1,n.length-1)),"true"===n||"false"!==n&&n)}(t,c,s,i.sanitizer);"string"==typeof u&&(L.test(u)||B.test(u))&&(n[d]=react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(G(u.trim()),{key:a}))}else"style"!==r&&(n[l[r]||r]=!0);return n},{}):null}i.overrides=i.overrides||{},i.sanitizer=i.sanitizer||Ue,i.slugify=i.slugify||Ce,i.namedCodesToUnicode=i.namedCodesToUnicode?t({},a,i.namedCodesToUnicode):a,i.createElement=i.createElement||react__WEBPACK_IMPORTED_MODULE_0__.createElement;const q=[],Q={},V={[r.blockQuote]:{match:Me(u),order:1,parse:(e,t,n)=>({children:t(e[0].replace(p,""),n)}),render:(e,t,n)=>d("blockquote",{key:n.key},t(e.children,n))},[r.breakLine]:{match:Re(f),order:1,parse:Pe,render:(e,t,n)=>d("br",{key:n.key})},[r.breakThematic]:{match:Me(h),order:1,parse:Pe,render:(e,t,n)=>d("hr",{key:n.key})},[r.codeBlock]:{match:Me(g),order:0,parse:e=>({lang:void 0,text:e[0].replace(/^ {4}/gm,"").replace(/\n+$/,"")}),render:(e,n,r)=>d("pre",{key:r.key},d("code",t({},e.attrs,{className:e.lang?`lang-${e.lang}`:""}),e.text))},[r.codeFenced]:{match:Me(m),order:0,parse:e=>({attrs:Z("code",e[3]||""),lang:e[2]||void 0,text:e[4],type:r.codeBlock})},[r.codeInline]:{match:Be(y),order:3,parse:e=>({text:e[2]}),render:(e,t,n)=>d("code",{key:n.key},e.text)},[r.footnote]:{match:Me(b),order:0,parse:e=>(q.push({footnote:e[2],identifier:e[1]}),{}),render:_e},[r.footnoteReference]:{match:Oe(v),order:1,parse:e=>({target:`#${i.slugify(e[1],Ce)}`,text:e[1]}),render:(e,t,n)=>d("a",{key:n.key,href:i.sanitizer(e.target,"a","href")},d("sup",{key:n.key},e.text))},[r.gfmTask]:{match:Oe($),order:1,parse:e=>({completed:"x"===e[1].toLowerCase()}),render:(e,t,n)=>d("input",{checked:e.completed,key:n.key,readOnly:!0,type:"checkbox"})},[r.heading]:{match:Me(i.enforceAtxHeadings?C:w),order:1,parse:(e,t,n)=>({children:je(t,e[2],n),id:i.slugify(e[2],Ce),level:e[1].length}),render:(e,t,n)=>d(`h${e.level}`,{id:e.id,key:n.key},t(e.children,n))},[r.headingSetext]:{match:Me(z),order:0,parse:(e,t,n)=>({children:je(t,e[1],n),level:"="===e[2]?1:2,type:r.heading})},[r.htmlBlock]:{match:Re(L),order:1,parse(e,t,n){const[,r]=e[3].match(re),i=new RegExp(`^${r}`,"gm"),l=e[3].replace(i,""),a=(c=l,we.some(e=>e.test(c))?He:je);var c;const s=e[1].toLowerCase(),d=-1!==o.indexOf(s),u=(d?s:e[1]).trim(),p={attrs:Z(u,e[2]),noInnerParse:d,tag:u};return n.inAnchor=n.inAnchor||"a"===s,d?p.text=e[3]:p.children=a(t,l,n),n.inAnchor=!1,p},render:(e,n,r)=>d(e.tag,t({key:r.key},e.attrs),e.text||n(e.children,r))},[r.htmlSelfClosing]:{match:Re(B),order:1,parse(e){const t=e[1].trim();return{attrs:Z(t,e[2]||""),tag:t}},render:(e,n,r)=>d(e.tag,t({},e.attrs,{key:r.key}))},[r.htmlComment]:{match:Re(T),order:1,parse:()=>({}),render:_e},[r.image]:{match:Be(Ee),order:1,parse:e=>({alt:e[1],target:De(e[2]),title:e[3]}),render:(e,t,n)=>d("img",{key:n.key,alt:e.alt||void 0,title:e.title||void 0,src:i.sanitizer(e.target,"img","src")})},[r.link]:{match:Oe(Se),order:3,parse:(e,t,n)=>({children:Ne(t,e[1],n),target:De(e[2]),title:e[3]}),render:(e,t,n)=>d("a",{key:n.key,href:i.sanitizer(e.target,"a","href"),title:e.title},t(e.children,n))},[r.linkAngleBraceStyleDetector]:{match:Oe(U),order:0,parse:e=>({children:[{text:e[1],type:r.text}],target:e[1],type:r.link})},[r.linkBareUrlDetector]:{match:(e,t)=>t.inAnchor?null:Oe(R)(e,t),order:0,parse:e=>({children:[{text:e[1],type:r.text}],target:e[1],title:void 0,type:r.link})},[r.linkMailtoDetector]:{match:Oe(I),order:0,parse(e){let t=e[1],n=e[1];return s.test(n)||(n="mailto:"+n),{children:[{text:t.replace("mailto:",""),type:r.text}],target:n,type:r.link}}},[r.orderedList]:ve(d,1),[r.unorderedList]:ve(d,2),[r.newlineCoalescer]:{match:Me(k),order:3,parse:Pe,render:()=>"\n"},[r.paragraph]:{match:Ie,order:3,parse:Fe,render:(e,t,n)=>d("p",{key:n.key},t(e.children,n))},[r.ref]:{match:Oe(N),order:0,parse:e=>(Q[e[1]]={target:e[2],title:e[4]},{}),render:_e},[r.refImage]:{match:Be(H),order:0,parse:e=>({alt:e[1]||void 0,ref:e[2]}),render:(e,t,n)=>Q[e.ref]?d("img",{key:n.key,alt:e.alt,src:i.sanitizer(Q[e.ref].target,"img","src"),title:Q[e.ref].title}):null},[r.refLink]:{match:Oe(F),order:0,parse:(e,t,n)=>({children:t(e[1],n),fallbackChildren:t(e[0].replace(P,"\\$1"),n),ref:e[2]}),render:(e,t,n)=>Q[e.ref]?d("a",{key:n.key,href:i.sanitizer(Q[e.ref].target,"a","href"),title:Q[e.ref].title},t(e.children,n)):d("span",{key:n.key},t(e.fallbackChildren,n))},[r.table]:{match:Me(j),order:1,parse:Ae,render(e,t,n){const r=e;return d("table",{key:n.key},d("thead",null,d("tr",null,r.header.map(function(e,i){return d("th",{key:i,style:Te(r,i)},t(e,n))}))),d("tbody",null,r.cells.map(function(e,i){return d("tr",{key:i},e.map(function(e,i){return d("td",{key:i,style:Te(r,i)},t(e,n))}))})))}},[r.text]:{match:Re(te),order:4,parse:e=>({text:e[0].replace(A,(e,t)=>i.namedCodesToUnicode[t]?i.namedCodesToUnicode[t]:e)}),render:e=>e.text},[r.textBolded]:{match:Be(X),order:2,parse:(e,t,n)=>({children:t(e[2],n)}),render:(e,t,n)=>d("strong",{key:n.key},t(e.children,n))},[r.textEmphasized]:{match:Be(J),order:3,parse:(e,t,n)=>({children:t(e[2],n)}),render:(e,t,n)=>d("em",{key:n.key},t(e.children,n))},[r.textEscaped]:{match:Be(ee),order:1,parse:e=>({text:e[1],type:r.text})},[r.textMarked]:{match:Be(K),order:3,parse:Fe,render:(e,t,n)=>d("mark",{key:n.key},t(e.children,n))},[r.textStrikethroughed]:{match:Be(Y),order:3,parse:Fe,render:(e,t,n)=>d("del",{key:n.key},t(e.children,n))}};!0===i.disableParsingRawHTML&&(delete V[r.htmlBlock],delete V[r.htmlSelfClosing]);const ie=function(e){let t=Object.keys(e);function n(r,i){let l=[],a="";for(;r;){let o=0;for(;o<t.length;){const c=t[o],s=e[c],d=s.match(r,i,a);if(d){const e=d[0];r=r.substring(e.length);const t=s.parse(d,n,i);null==t.type&&(t.type=c),l.push(t),a=e;break}o++}}return l}return t.sort(function(t,n){let r=e[t].order,i=e[n].order;return r!==i?r-i:t<n?-1:1}),function(e,t){return n(function(e){return e.replace(x,"\n").replace(S,"").replace(W,"    ")}(e),t)}}(V),le=(ae=function(e,t){return function(n,r,i){const l=e[n.type].render;return t?t(()=>l(n,r,i),n,r,i):l(n,r,i)}}(V,i.renderRule),function e(t,n={}){if(Array.isArray(t)){const r=n.key,i=[];let l=!1;for(let r=0;r<t.length;r++){n.key=r;const a=e(t[r],n),o="string"==typeof a;o&&l?i[i.length-1]+=a:null!==a&&i.push(a),l=o}return n.key=r,i}return ae(t,e,n)});var ae;const oe=G(n);return q.length?d("div",null,oe,d("footer",{key:"footer"},q.map(function(e){return d("div",{id:i.slugify(e.identifier,Ce),key:e.identifier},e.identifier,le(ie(e.footnote,{inline:!0})))}))):oe}/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (t=>{let{children:r="",options:i}=t,l=function(e,t){if(null==e)return{};var n,r,i={},l=Object.keys(e);for(r=0;r<l.length;r++)t.indexOf(n=l[r])>=0||(i[n]=e[n]);return i}(t,n);return react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(Ze(r,i),l)});
//# sourceMappingURL=index.modern.js.map


/***/ }),

/***/ "./node_modules/nanoid/index.browser.js":
/*!**********************************************!*\
  !*** ./node_modules/nanoid/index.browser.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   customAlphabet: () => (/* binding */ customAlphabet),
/* harmony export */   customRandom: () => (/* binding */ customRandom),
/* harmony export */   nanoid: () => (/* binding */ nanoid),
/* harmony export */   random: () => (/* binding */ random),
/* harmony export */   urlAlphabet: () => (/* reexport safe */ _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__.urlAlphabet)
/* harmony export */ });
/* harmony import */ var _url_alphabet_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-alphabet/index.js */ "./node_modules/nanoid/url-alphabet/index.js");
// This file replaces `index.js` in bundlers like webpack or Rollup,
// according to `browser` config in `package.json`.



let random = bytes => crypto.getRandomValues(new Uint8Array(bytes))

let customRandom = (alphabet, defaultSize, getRandom) => {
  // First, a bitmask is necessary to generate the ID. The bitmask makes bytes
  // values closer to the alphabet size. The bitmask calculates the closest
  // `2^31 - 1` number, which exceeds the alphabet size.
  // For example, the bitmask for the alphabet size 30 is 31 (00011111).
  // `Math.clz32` is not used, because it is not available in browsers.
  let mask = (2 << (Math.log(alphabet.length - 1) / Math.LN2)) - 1
  // Though, the bitmask solution is not perfect since the bytes exceeding
  // the alphabet size are refused. Therefore, to reliably generate the ID,
  // the random bytes redundancy has to be satisfied.

  // Note: every hardware random generator call is performance expensive,
  // because the system call for entropy collection takes a lot of time.
  // So, to avoid additional system calls, extra bytes are requested in advance.

  // Next, a step determines how many random bytes to generate.
  // The number of random bytes gets decided upon the ID size, mask,
  // alphabet size, and magic number 1.6 (using 1.6 peaks at performance
  // according to benchmarks).

  // `-~f => Math.ceil(f)` if f is a float
  // `-~i => i + 1` if i is an integer
  let step = -~((1.6 * mask * defaultSize) / alphabet.length)

  return (size = defaultSize) => {
    let id = ''
    while (true) {
      let bytes = getRandom(step)
      // A compact alternative for `for (var i = 0; i < step; i++)`.
      let j = step | 0
      while (j--) {
        // Adding `|| ''` refuses a random byte that exceeds the alphabet size.
        id += alphabet[bytes[j] & mask] || ''
        if (id.length === size) return id
      }
    }
  }
}

let customAlphabet = (alphabet, size = 21) =>
  customRandom(alphabet, size, random)

let nanoid = (size = 21) =>
  crypto.getRandomValues(new Uint8Array(size)).reduce((id, byte) => {
    // It is incorrect to use bytes exceeding the alphabet size.
    // The following mask reduces the random byte in the 0-255 value
    // range to the 0-63 value range. Therefore, adding hacks, such
    // as empty string fallback or magic numbers, is unneccessary because
    // the bitmask trims bytes down to the alphabet size.
    byte &= 63
    if (byte < 36) {
      // `0-9a-z`
      id += byte.toString(36)
    } else if (byte < 62) {
      // `A-Z`
      id += (byte - 26).toString(36).toUpperCase()
    } else if (byte > 62) {
      id += '-'
    } else {
      id += '_'
    }
    return id
  }, '')




/***/ }),

/***/ "./node_modules/nanoid/url-alphabet/index.js":
/*!***************************************************!*\
  !*** ./node_modules/nanoid/url-alphabet/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   urlAlphabet: () => (/* binding */ urlAlphabet)
/* harmony export */ });
// This alphabet uses `A-Za-z0-9_-` symbols.
// The order of characters is optimized for better gzip and brotli compression.
// Same as in non-secure/index.js
let urlAlphabet =
  'useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict'




/***/ }),

/***/ "./node_modules/react-dom/client.js":
/*!******************************************!*\
  !*** ./node_modules/react-dom/client.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


var m = __webpack_require__(/*! react-dom */ "webpack/sharing/consume/default/react-dom/react-dom");
if (false) {} else {
  var i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
  exports.createRoot = function(c, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.createRoot(c, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
  exports.hydrateRoot = function(c, h, o) {
    i.usingClientEntryPoint = true;
    try {
      return m.hydrateRoot(c, h, o);
    } finally {
      i.usingClientEntryPoint = false;
    }
  };
}


/***/ }),

/***/ "./node_modules/typestyle/lib/index.js":
/*!*********************************************!*\
  !*** ./node_modules/typestyle/lib/index.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var typestyle_1 = __webpack_require__(/*! ./internal/typestyle */ "./node_modules/typestyle/lib/internal/typestyle.js");
exports.TypeStyle = typestyle_1.TypeStyle;
/**
 * All the CSS types in the 'types' namespace
 */
var types = __webpack_require__(/*! ./types */ "./node_modules/typestyle/lib/types.js");
exports.types = types;
/**
 * Export certain utilities
 */
var utilities_1 = __webpack_require__(/*! ./internal/utilities */ "./node_modules/typestyle/lib/internal/utilities.js");
exports.extend = utilities_1.extend;
exports.classes = utilities_1.classes;
exports.media = utilities_1.media;
/** Zero configuration, default instance of TypeStyle */
var ts = new typestyle_1.TypeStyle({ autoGenerateTag: true });
/** Sets the target tag where we write the css on style updates */
exports.setStylesTarget = ts.setStylesTarget;
/**
 * Insert `raw` CSS as a string. This is useful for e.g.
 * - third party CSS that you are customizing with template strings
 * - generating raw CSS in JavaScript
 * - reset libraries like normalize.css that you can use without loaders
 */
exports.cssRaw = ts.cssRaw;
/**
 * Takes CSSProperties and registers it to a global selector (body, html, etc.)
 */
exports.cssRule = ts.cssRule;
/**
 * Renders styles to the singleton tag imediately
 * NOTE: You should only call it on initial render to prevent any non CSS flash.
 * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
 **/
exports.forceRenderStyles = ts.forceRenderStyles;
/**
 * Utility function to register an @font-face
 */
exports.fontFace = ts.fontFace;
/**
 * Allows use to use the stylesheet in a node.js environment
 */
exports.getStyles = ts.getStyles;
/**
 * Takes keyframes and returns a generated animationName
 */
exports.keyframes = ts.keyframes;
/**
 * Helps with testing. Reinitializes FreeStyle + raw
 */
exports.reinit = ts.reinit;
/**
 * Takes CSSProperties and return a generated className you can use on your component
 */
exports.style = ts.style;
/**
 * Takes an object where property names are ideal class names and property values are CSSProperties, and
 * returns an object where property names are the same ideal class names and the property values are
 * the actual generated class names using the ideal class name as the $debugName
 */
exports.stylesheet = ts.stylesheet;
/**
 * Creates a new instance of TypeStyle separate from the default instance.
 *
 * - Use this for creating a different typestyle instance for a shadow dom component.
 * - Use this if you don't want an auto tag generated and you just want to collect the CSS.
 *
 * NOTE: styles aren't shared between different instances.
 */
function createTypeStyle(target) {
    var instance = new typestyle_1.TypeStyle({ autoGenerateTag: false });
    if (target) {
        instance.setStylesTarget(target);
    }
    return instance;
}
exports.createTypeStyle = createTypeStyle;


/***/ }),

/***/ "./node_modules/typestyle/lib/internal/formatting.js":
/*!***********************************************************!*\
  !*** ./node_modules/typestyle/lib/internal/formatting.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/**
 * We need to do the following to *our* objects before passing to freestyle:
 * - For any `$nest` directive move up to FreeStyle style nesting
 * - For any `$unique` directive map to FreeStyle Unique
 * - For any `$debugName` directive return the debug name
 */
function convertToStyles(object) {
    /** The final result we will return */
    var styles = {};
    for (var key in object) {
        /** Grab the value upfront */
        var val = object[key];
        /** TypeStyle configuration options */
        if (key === '$nest') {
            var nested = val;
            for (var selector in nested) {
                var subproperties = nested[selector];
                styles[selector] = convertToStyles(subproperties);
            }
        }
        else if (key === '$debugName') {
            styles.$displayName = val;
        }
        else {
            styles[key] = val;
        }
    }
    return styles;
}
exports.convertToStyles = convertToStyles;
// todo: better name here
function convertToKeyframes(frames) {
    var result = {};
    for (var offset in frames) {
        if (offset !== '$debugName') {
            result[offset] = frames[offset];
        }
    }
    if (frames.$debugName) {
        result.$displayName = frames.$debugName;
    }
    return result;
}
exports.convertToKeyframes = convertToKeyframes;


/***/ }),

/***/ "./node_modules/typestyle/lib/internal/typestyle.js":
/*!**********************************************************!*\
  !*** ./node_modules/typestyle/lib/internal/typestyle.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
var FreeStyle = __webpack_require__(/*! free-style */ "./node_modules/free-style/dist.es2015/index.js");
var formatting_1 = __webpack_require__(/*! ./formatting */ "./node_modules/typestyle/lib/internal/formatting.js");
var utilities_1 = __webpack_require__(/*! ./utilities */ "./node_modules/typestyle/lib/internal/utilities.js");
/**
 * Creates an instance of free style with our options
 */
var createFreeStyle = function () { return FreeStyle.create(); };
/**
 * Maintains a single stylesheet and keeps it in sync with requested styles
 */
var TypeStyle = /** @class */ (function () {
    function TypeStyle(_a) {
        var _this = this;
        var autoGenerateTag = _a.autoGenerateTag;
        /**
         * Insert `raw` CSS as a string. This is useful for e.g.
         * - third party CSS that you are customizing with template strings
         * - generating raw CSS in JavaScript
         * - reset libraries like normalize.css that you can use without loaders
         */
        this.cssRaw = function (mustBeValidCSS) {
            if (!mustBeValidCSS) {
                return;
            }
            _this._raw += mustBeValidCSS || '';
            _this._pendingRawChange = true;
            _this._styleUpdated();
        };
        /**
         * Takes CSSProperties and registers it to a global selector (body, html, etc.)
         */
        this.cssRule = function (selector) {
            var objects = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                objects[_i - 1] = arguments[_i];
            }
            var styles = formatting_1.convertToStyles(utilities_1.extend.apply(void 0, objects));
            _this._freeStyle.registerRule(selector, styles);
            _this._styleUpdated();
            return;
        };
        /**
         * Renders styles to the singleton tag imediately
         * NOTE: You should only call it on initial render to prevent any non CSS flash.
         * After that it is kept sync using `requestAnimationFrame` and we haven't noticed any bad flashes.
         **/
        this.forceRenderStyles = function () {
            var target = _this._getTag();
            if (!target) {
                return;
            }
            target.textContent = _this.getStyles();
        };
        /**
         * Utility function to register an @font-face
         */
        this.fontFace = function () {
            var fontFace = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                fontFace[_i] = arguments[_i];
            }
            var freeStyle = _this._freeStyle;
            for (var _a = 0, _b = fontFace; _a < _b.length; _a++) {
                var face = _b[_a];
                freeStyle.registerRule('@font-face', face);
            }
            _this._styleUpdated();
            return;
        };
        /**
         * Allows use to use the stylesheet in a node.js environment
         */
        this.getStyles = function () {
            return (_this._raw || '') + _this._freeStyle.getStyles();
        };
        /**
         * Takes keyframes and returns a generated animationName
         */
        this.keyframes = function (frames) {
            var keyframes = formatting_1.convertToKeyframes(frames);
            // TODO: replace $debugName with display name
            var animationName = _this._freeStyle.registerKeyframes(keyframes);
            _this._styleUpdated();
            return animationName;
        };
        /**
         * Helps with testing. Reinitializes FreeStyle + raw
         */
        this.reinit = function () {
            /** reinit freestyle */
            var freeStyle = createFreeStyle();
            _this._freeStyle = freeStyle;
            _this._lastFreeStyleChangeId = freeStyle.changeId;
            /** reinit raw */
            _this._raw = '';
            _this._pendingRawChange = false;
            /** Clear any styles that were flushed */
            var target = _this._getTag();
            if (target) {
                target.textContent = '';
            }
        };
        /** Sets the target tag where we write the css on style updates */
        this.setStylesTarget = function (tag) {
            /** Clear any data in any previous tag */
            if (_this._tag) {
                _this._tag.textContent = '';
            }
            _this._tag = tag;
            /** This special time buffer immediately */
            _this.forceRenderStyles();
        };
        /**
         * Takes an object where property names are ideal class names and property values are CSSProperties, and
         * returns an object where property names are the same ideal class names and the property values are
         * the actual generated class names using the ideal class name as the $debugName
         */
        this.stylesheet = function (classes) {
            var classNames = Object.getOwnPropertyNames(classes);
            var result = {};
            for (var _i = 0, classNames_1 = classNames; _i < classNames_1.length; _i++) {
                var className = classNames_1[_i];
                var classDef = classes[className];
                if (classDef) {
                    classDef.$debugName = className;
                    result[className] = _this.style(classDef);
                }
            }
            return result;
        };
        var freeStyle = createFreeStyle();
        this._autoGenerateTag = autoGenerateTag;
        this._freeStyle = freeStyle;
        this._lastFreeStyleChangeId = freeStyle.changeId;
        this._pending = 0;
        this._pendingRawChange = false;
        this._raw = '';
        this._tag = undefined;
        // rebind prototype to TypeStyle.  It might be better to do a function() { return this.style.apply(this, arguments)}
        this.style = this.style.bind(this);
    }
    /**
     * Only calls cb all sync operations settle
     */
    TypeStyle.prototype._afterAllSync = function (cb) {
        var _this = this;
        this._pending++;
        var pending = this._pending;
        utilities_1.raf(function () {
            if (pending !== _this._pending) {
                return;
            }
            cb();
        });
    };
    TypeStyle.prototype._getTag = function () {
        if (this._tag) {
            return this._tag;
        }
        if (this._autoGenerateTag) {
            var tag = typeof window === 'undefined'
                ? { textContent: '' }
                : document.createElement('style');
            if (typeof document !== 'undefined') {
                document.head.appendChild(tag);
            }
            this._tag = tag;
            return tag;
        }
        return undefined;
    };
    /** Checks if the style tag needs updating and if so queues up the change */
    TypeStyle.prototype._styleUpdated = function () {
        var _this = this;
        var changeId = this._freeStyle.changeId;
        var lastChangeId = this._lastFreeStyleChangeId;
        if (!this._pendingRawChange && changeId === lastChangeId) {
            return;
        }
        this._lastFreeStyleChangeId = changeId;
        this._pendingRawChange = false;
        this._afterAllSync(function () { return _this.forceRenderStyles(); });
    };
    TypeStyle.prototype.style = function () {
        var className = this._freeStyle.registerStyle(formatting_1.convertToStyles(utilities_1.extend.apply(undefined, arguments)));
        this._styleUpdated();
        return className;
    };
    return TypeStyle;
}());
exports.TypeStyle = TypeStyle;


/***/ }),

/***/ "./node_modules/typestyle/lib/internal/utilities.js":
/*!**********************************************************!*\
  !*** ./node_modules/typestyle/lib/internal/utilities.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
/** Raf for node + browser */
exports.raf = typeof requestAnimationFrame === 'undefined'
    /**
     * Make sure setTimeout is always invoked with
     * `this` set to `window` or `global` automatically
     **/
    ? function (cb) { return setTimeout(cb); }
    /**
     * Make sure window.requestAnimationFrame is always invoked with `this` window
     * We might have raf without window in case of `raf/polyfill` (recommended by React)
     **/
    : typeof window === 'undefined'
        ? requestAnimationFrame
        : requestAnimationFrame.bind(window);
/**
 * Utility to join classes conditionally
 */
function classes() {
    var classes = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        classes[_i] = arguments[_i];
    }
    return classes
        .map(function (c) { return c && typeof c === 'object' ? Object.keys(c).map(function (key) { return !!c[key] && key; }) : [c]; })
        .reduce(function (flattened, c) { return flattened.concat(c); }, [])
        .filter(function (c) { return !!c; })
        .join(' ');
}
exports.classes = classes;
/**
 * Merges various styles into a single style object.
 * Note: if two objects have the same property the last one wins
 */
function extend() {
    var objects = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        objects[_i] = arguments[_i];
    }
    /** The final result we will return */
    var result = {};
    for (var _a = 0, objects_1 = objects; _a < objects_1.length; _a++) {
        var object = objects_1[_a];
        if (object == null || object === false) {
            continue;
        }
        for (var key in object) {
            /** Falsy values except a explicit 0 is ignored */
            var val = object[key];
            if (!val && val !== 0) {
                continue;
            }
            /** if nested media or pseudo selector */
            if (key === '$nest' && val) {
                result[key] = result['$nest'] ? extend(result['$nest'], val) : val;
            }
            /** if freestyle sub key that needs merging. We come here due to our recursive calls */
            else if ((key.indexOf('&') !== -1 || key.indexOf('@media') === 0)) {
                result[key] = result[key] ? extend(result[key], val) : val;
            }
            else {
                result[key] = val;
            }
        }
    }
    return result;
}
exports.extend = extend;
/**
 * Utility to help customize styles with media queries. e.g.
 * ```
 * style(
 *  media({maxWidth:500}, {color:'red'})
 * )
 * ```
 */
exports.media = function (mediaQuery) {
    var _a;
    var objects = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        objects[_i - 1] = arguments[_i];
    }
    var mediaQuerySections = [];
    if (mediaQuery.type)
        mediaQuerySections.push(mediaQuery.type);
    if (mediaQuery.orientation)
        mediaQuerySections.push("(orientation: " + mediaQuery.orientation + ")");
    if (mediaQuery.minWidth)
        mediaQuerySections.push("(min-width: " + mediaLength(mediaQuery.minWidth) + ")");
    if (mediaQuery.maxWidth)
        mediaQuerySections.push("(max-width: " + mediaLength(mediaQuery.maxWidth) + ")");
    if (mediaQuery.minHeight)
        mediaQuerySections.push("(min-height: " + mediaLength(mediaQuery.minHeight) + ")");
    if (mediaQuery.maxHeight)
        mediaQuerySections.push("(max-height: " + mediaLength(mediaQuery.maxHeight) + ")");
    if (mediaQuery.prefersColorScheme)
        mediaQuerySections.push("(prefers-color-scheme: " + mediaQuery.prefersColorScheme + ")");
    var stringMediaQuery = "@media " + mediaQuerySections.join(' and ');
    var object = {
        $nest: (_a = {},
            _a[stringMediaQuery] = extend.apply(void 0, objects),
            _a)
    };
    return object;
};
var mediaLength = function (value) {
    return typeof value === 'string' ? value : value + "px";
};


/***/ }),

/***/ "./node_modules/typestyle/lib/types.js":
/*!*********************************************!*\
  !*** ./node_modules/typestyle/lib/types.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcmpzZl9jb3JlX2xpYl9pbmRleF9qcy1ub2RlX21vZHVsZXNfcmVhY3QtZG9tX2NsaWVudF9qcy1ub2RlX21vZHVsZXNfdHlwLWQ1NDUwYi40ZTU4MWRmYjM4ZjM4ZmQ2MDkzMy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0Q7QUFDbEI7QUFDNE47QUFDM087QUFDUTtBQUNOO0FBQ0k7QUFDbUI7QUFDdkQ7QUFDZSxtQkFBbUIsNENBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0RBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsdUVBQThCLGVBQWUsaURBQVE7QUFDM0YsK0NBQStDLGlEQUFRO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsaURBQVE7QUFDN0M7QUFDQSw4Q0FBOEMsaURBQUk7QUFDbEQ7QUFDQTtBQUNBLGlFQUFpRSxxREFBUTtBQUN6RTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJFQUEyRTtBQUMvRixvQkFBb0IsdUNBQXVDO0FBQzNELGdCQUFnQixxREFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Ly4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvRm9ybS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy9maWVsZHMvQXJyYXlGaWVsZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy9maWVsZHMvQm9vbGVhbkZpZWxkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL2ZpZWxkcy9NdWx0aVNjaGVtYUZpZWxkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL2ZpZWxkcy9OdWxsRmllbGQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvZmllbGRzL051bWJlckZpZWxkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL2ZpZWxkcy9PYmplY3RGaWVsZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy9maWVsZHMvU2NoZW1hRmllbGQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvZmllbGRzL1N0cmluZ0ZpZWxkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL2ZpZWxkcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvQXJyYXlGaWVsZERlc2NyaXB0aW9uVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvdGVtcGxhdGVzL0FycmF5RmllbGRJdGVtVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvdGVtcGxhdGVzL0FycmF5RmllbGRUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvQXJyYXlGaWVsZFRpdGxlVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvdGVtcGxhdGVzL0Jhc2VJbnB1dFRlbXBsYXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3RlbXBsYXRlcy9CdXR0b25UZW1wbGF0ZXMvQWRkQnV0dG9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3RlbXBsYXRlcy9CdXR0b25UZW1wbGF0ZXMvSWNvbkJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvQnV0dG9uVGVtcGxhdGVzL1N1Ym1pdEJ1dHRvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvQnV0dG9uVGVtcGxhdGVzL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3RlbXBsYXRlcy9EZXNjcmlwdGlvbkZpZWxkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3RlbXBsYXRlcy9FcnJvckxpc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvdGVtcGxhdGVzL0ZpZWxkRXJyb3JUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvRmllbGRIZWxwVGVtcGxhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvdGVtcGxhdGVzL0ZpZWxkVGVtcGxhdGUvRmllbGRUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvRmllbGRUZW1wbGF0ZS9MYWJlbC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvRmllbGRUZW1wbGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvT2JqZWN0RmllbGRUZW1wbGF0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvVGl0bGVGaWVsZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvVW5zdXBwb3J0ZWRGaWVsZC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy90ZW1wbGF0ZXMvV3JhcElmQWRkaXRpb25hbFRlbXBsYXRlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3RlbXBsYXRlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL0FsdERhdGVUaW1lV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvQWx0RGF0ZVdpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL0NoZWNrYm94V2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvQ2hlY2tib3hlc1dpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL0NvbG9yV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvRGF0ZVRpbWVXaWRnZXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvd2lkZ2V0cy9EYXRlV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvRW1haWxXaWRnZXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvd2lkZ2V0cy9GaWxlV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvSGlkZGVuV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvUGFzc3dvcmRXaWRnZXQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2NvbXBvbmVudHMvd2lkZ2V0cy9SYWRpb1dpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL1JhbmdlV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvU2VsZWN0V2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvVGV4dFdpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL1RleHRhcmVhV2lkZ2V0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9jb21wb25lbnRzL3dpZGdldHMvVGltZVdpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL1VSTFdpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL1VwRG93bldpZGdldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQHJqc2YvY29yZS9saWIvY29tcG9uZW50cy93aWRnZXRzL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi9nZXREZWZhdWx0UmVnaXN0cnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0ByanNmL2NvcmUvbGliL2luZGV4LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AcmpzZi9jb3JlL2xpYi93aXRoVGhlbWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2ZyZWUtc3R5bGUvZGlzdC5lczIwMTUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2suanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC9fYmFzZVBpY2tCeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoL3BpY2suanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC91bnNldC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24tdG8tanN4L2Rpc3QvaW5kZXgubW9kZXJuLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9uYW5vaWQvaW5kZXguYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbmFub2lkL3VybC1hbHBoYWJldC9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvcmVhY3QtZG9tL2NsaWVudC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi9pbnRlcm5hbC9mb3JtYXR0aW5nLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy90eXBlc3R5bGUvbGliL2ludGVybmFsL3R5cGVzdHlsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdHlwZXN0eWxlL2xpYi9pbnRlcm5hbC91dGlsaXRpZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3R5cGVzdHlsZS9saWIvdHlwZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IENvbXBvbmVudCwgY3JlYXRlUmVmIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgY3JlYXRlU2NoZW1hVXRpbHMsIGRlZXBFcXVhbHMsIGdldFRlbXBsYXRlLCBnZXRVaU9wdGlvbnMsIGlzT2JqZWN0LCBtZXJnZU9iamVjdHMsIE5BTUVfS0VZLCBSSlNGX0FERElUT05BTF9QUk9QRVJUSUVTX0ZMQUcsIHNob3VsZFJlbmRlciwgU1VCTUlUX0JUTl9PUFRJT05TX0tFWSwgdG9FcnJvckxpc3QsIFVJX0dMT0JBTF9PUFRJT05TX0tFWSwgVUlfT1BUSU9OU19LRVksIHZhbGlkYXRpb25EYXRhTWVyZ2UsIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuaW1wb3J0IF9nZXQgZnJvbSAnbG9kYXNoL2dldCc7XG5pbXBvcnQgX2lzRW1wdHkgZnJvbSAnbG9kYXNoL2lzRW1wdHknO1xuaW1wb3J0IF9waWNrIGZyb20gJ2xvZGFzaC9waWNrJztcbmltcG9ydCBfdG9QYXRoIGZyb20gJ2xvZGFzaC90b1BhdGgnO1xuaW1wb3J0IGdldERlZmF1bHRSZWdpc3RyeSBmcm9tICcuLi9nZXREZWZhdWx0UmVnaXN0cnknO1xuLyoqIFRoZSBgRm9ybWAgY29tcG9uZW50IHJlbmRlcnMgdGhlIG91dGVyIGZvcm0gYW5kIGFsbCB0aGUgZmllbGRzIGRlZmluZWQgaW4gdGhlIGBzY2hlbWFgICovXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGb3JtIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAvKiogQ29uc3RydWN0cyB0aGUgYEZvcm1gIGZyb20gdGhlIGBwcm9wc2AuIFdpbGwgc2V0dXAgdGhlIGluaXRpYWwgc3RhdGUgZnJvbSB0aGUgcHJvcHMuIEl0IHdpbGwgYWxzbyBjYWxsIHRoZVxuICAgICAqIGBvbkNoYW5nZWAgaGFuZGxlciBpZiB0aGUgaW5pdGlhbGx5IHByb3ZpZGVkIGBmb3JtRGF0YWAgaXMgbW9kaWZpZWQgdG8gYWRkIG1pc3NpbmcgZGVmYXVsdCB2YWx1ZXMgYXMgcGFydCBvZiB0aGVcbiAgICAgKiBzdGF0ZSBjb25zdHJ1Y3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcHMgLSBUaGUgaW5pdGlhbCBwcm9wcyBmb3IgdGhlIGBGb3JtYFxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgICAgIHN1cGVyKHByb3BzKTtcbiAgICAgICAgLyoqIFJldHVybnMgdGhlIGBmb3JtRGF0YWAgd2l0aCBvbmx5IHRoZSBlbGVtZW50cyBzcGVjaWZpZWQgaW4gdGhlIGBmaWVsZHNgIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIGRhdGEgZm9yIHRoZSBgRm9ybWBcbiAgICAgICAgICogQHBhcmFtIGZpZWxkcyAtIFRoZSBmaWVsZHMgdG8ga2VlcCB3aGlsZSBmaWx0ZXJpbmdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0VXNlZEZvcm1EYXRhID0gKGZvcm1EYXRhLCBmaWVsZHMpID0+IHtcbiAgICAgICAgICAgIC8vIEZvciB0aGUgY2FzZSBvZiBhIHNpbmdsZSBpbnB1dCBmb3JtXG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA9PT0gMCAmJiB0eXBlb2YgZm9ybURhdGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1EYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gX3BpY2sgaGFzIGluY29ycmVjdCB0eXBlIGRlZmluaXRpb24sIGl0IHdvcmtzIHdpdGggc3RyaW5nW11bXSwgYmVjYXVzZSBsb2Rhc2gvaGFzSW4gc3VwcG9ydHMgaXRcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBfcGljayhmb3JtRGF0YSwgZmllbGRzKTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5tYXAoKGtleSkgPT4gZGF0YVtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9O1xuICAgICAgICAvKiogUmV0dXJucyB0aGUgbGlzdCBvZiBmaWVsZCBuYW1lcyBmcm9tIGluc3BlY3RpbmcgdGhlIGBwYXRoU2NoZW1hYCBhcyB3ZWxsIGFzIHVzaW5nIHRoZSBgZm9ybURhdGFgXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwYXRoU2NoZW1hIC0gVGhlIGBQYXRoU2NoZW1hYCBvYmplY3QgZm9yIHRoZSBmb3JtXG4gICAgICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGZvcm0gZGF0YSB0byB1c2Ugd2hpbGUgY2hlY2tpbmcgZm9yIGVtcHR5IG9iamVjdHMvYXJyYXlzXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldEZpZWxkTmFtZXMgPSAocGF0aFNjaGVtYSwgZm9ybURhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdldEFsbFBhdGhzID0gKF9vYmosIGFjYyA9IFtdLCBwYXRocyA9IFtbXV0pID0+IHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhfb2JqKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBfb2JqW2tleV0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdQYXRocyA9IHBhdGhzLm1hcCgocGF0aCkgPT4gWy4uLnBhdGgsIGtleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgYW4gb2JqZWN0IGlzIG1hcmtlZCB3aXRoIGFkZGl0aW9uYWxQcm9wZXJ0aWVzLCBhbGwgaXRzIGtleXMgYXJlIHZhbGlkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX29ialtrZXldW1JKU0ZfQURESVRPTkFMX1BST1BFUlRJRVNfRkxBR10gJiYgX29ialtrZXldW05BTUVfS0VZXSAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2MucHVzaChfb2JqW2tleV1bTkFNRV9LRVldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldEFsbFBhdGhzKF9vYmpba2V5XSwgYWNjLCBuZXdQYXRocyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoa2V5ID09PSBOQU1FX0tFWSAmJiBfb2JqW2tleV0gIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRocy5mb3JFYWNoKChwYXRoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybVZhbHVlID0gX2dldChmb3JtRGF0YSwgcGF0aCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkcyBwYXRoIHRvIGZpZWxkTmFtZXMgaWYgaXQgcG9pbnRzIHRvIGEgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvciBhbiBlbXB0eSBvYmplY3QvYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZvcm1WYWx1ZSAhPT0gJ29iamVjdCcgfHwgX2lzRW1wdHkoZm9ybVZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY2MucHVzaChwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGdldEFsbFBhdGhzKHBhdGhTY2hlbWEpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogRnVuY3Rpb24gdG8gaGFuZGxlIGNoYW5nZXMgbWFkZSB0byBhIGZpZWxkIGluIHRoZSBgRm9ybWAuIFRoaXMgaGFuZGxlciByZWNlaXZlcyBhbiBlbnRpcmVseSBuZXcgY29weSBvZiB0aGVcbiAgICAgICAgICogYGZvcm1EYXRhYCBhbG9uZyB3aXRoIGEgbmV3IGBFcnJvclNjaGVtYWAuIEl0IHdpbGwgZmlyc3QgdXBkYXRlIHRoZSBgZm9ybURhdGFgIHdpdGggYW55IG1pc3NpbmcgZGVmYXVsdCBmaWVsZHMgYW5kXG4gICAgICAgICAqIHRoZW4sIGlmIGBvbWl0RXh0cmFEYXRhYCBhbmQgYGxpdmVPbWl0YCBhcmUgdHVybmVkIG9uLCB0aGUgYGZvcm1EYXRhYCB3aWxsIGJlIGZpbHRlcmVyIHRvIHJlbW92ZSBhbnkgZXh0cmEgZGF0YSBub3RcbiAgICAgICAgICogaW4gYSBmb3JtIGZpZWxkLiBUaGVuLCB0aGUgcmVzdWx0aW5nIGZvcm1EYXRhIHdpbGwgYmUgdmFsaWRhdGVkIGlmIHJlcXVpcmVkLiBUaGUgc3RhdGUgd2lsbCBiZSB1cGRhdGVkIHdpdGggdGhlIG5ld1xuICAgICAgICAgKiB1cGRhdGVkIChwb3RlbnRpYWxseSBmaWx0ZXJlZCkgYGZvcm1EYXRhYCwgYW55IGVycm9ycyB0aGF0IHJlc3VsdGVkIGZyb20gdmFsaWRhdGlvbi4gRmluYWxseSB0aGUgYG9uQ2hhbmdlYFxuICAgICAgICAgKiBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBpZiBzcGVjaWZpZWQgd2l0aCB0aGUgdXBkYXRlZCBzdGF0ZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIG5ldyBmb3JtIGRhdGEgZnJvbSBhIGNoYW5nZSB0byBhIGZpZWxkXG4gICAgICAgICAqIEBwYXJhbSBuZXdFcnJvclNjaGVtYSAtIFRoZSBuZXcgYEVycm9yU2NoZW1hYCBiYXNlZCBvbiB0aGUgZmllbGQgY2hhbmdlXG4gICAgICAgICAqIEBwYXJhbSBpZCAtIFRoZSBpZCBvZiB0aGUgZmllbGQgdGhhdCBjYXVzZWQgdGhlIGNoYW5nZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZSA9IChmb3JtRGF0YSwgbmV3RXJyb3JTY2hlbWEsIGlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGV4dHJhRXJyb3JzLCBvbWl0RXh0cmFEYXRhLCBsaXZlT21pdCwgbm9WYWxpZGF0ZSwgbGl2ZVZhbGlkYXRlLCBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IHsgc2NoZW1hVXRpbHMsIHNjaGVtYSwgcmV0cmlldmVkU2NoZW1hIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKGlzT2JqZWN0KGZvcm1EYXRhKSB8fCBBcnJheS5pc0FycmF5KGZvcm1EYXRhKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5nZXRTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCBmb3JtRGF0YSwgcmV0cmlldmVkU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YSA9IG5ld1N0YXRlLmZvcm1EYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbXVzdFZhbGlkYXRlID0gIW5vVmFsaWRhdGUgJiYgbGl2ZVZhbGlkYXRlO1xuICAgICAgICAgICAgbGV0IHN0YXRlID0geyBmb3JtRGF0YSwgc2NoZW1hIH07XG4gICAgICAgICAgICBsZXQgbmV3Rm9ybURhdGEgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgIGxldCBfcmV0cmlldmVkU2NoZW1hO1xuICAgICAgICAgICAgaWYgKG9taXRFeHRyYURhdGEgPT09IHRydWUgJiYgbGl2ZU9taXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBfcmV0cmlldmVkU2NoZW1hID0gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEoc2NoZW1hLCBmb3JtRGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0aFNjaGVtYSA9IHNjaGVtYVV0aWxzLnRvUGF0aFNjaGVtYShfcmV0cmlldmVkU2NoZW1hLCAnJywgZm9ybURhdGEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkTmFtZXMgPSB0aGlzLmdldEZpZWxkTmFtZXMocGF0aFNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICAgICAgICAgIG5ld0Zvcm1EYXRhID0gdGhpcy5nZXRVc2VkRm9ybURhdGEoZm9ybURhdGEsIGZpZWxkTmFtZXMpO1xuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YTogbmV3Rm9ybURhdGEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtdXN0VmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFWYWxpZGF0aW9uID0gdGhpcy52YWxpZGF0ZShuZXdGb3JtRGF0YSwgc2NoZW1hLCBzY2hlbWFVdGlscywgcmV0cmlldmVkU2NoZW1hKTtcbiAgICAgICAgICAgICAgICBsZXQgZXJyb3JzID0gc2NoZW1hVmFsaWRhdGlvbi5lcnJvcnM7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yU2NoZW1hID0gc2NoZW1hVmFsaWRhdGlvbi5lcnJvclNjaGVtYTtcbiAgICAgICAgICAgICAgICBjb25zdCBzY2hlbWFWYWxpZGF0aW9uRXJyb3JzID0gZXJyb3JzO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYVZhbGlkYXRpb25FcnJvclNjaGVtYSA9IGVycm9yU2NoZW1hO1xuICAgICAgICAgICAgICAgIGlmIChleHRyYUVycm9ycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtZXJnZWQgPSB2YWxpZGF0aW9uRGF0YU1lcmdlKHNjaGVtYVZhbGlkYXRpb24sIGV4dHJhRXJyb3JzKTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTY2hlbWEgPSBtZXJnZWQuZXJyb3JTY2hlbWE7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IG1lcmdlZC5lcnJvcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXRlID0ge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YTogbmV3Rm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYVZhbGlkYXRpb25FcnJvclNjaGVtYSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIW5vVmFsaWRhdGUgJiYgbmV3RXJyb3JTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvclNjaGVtYSA9IGV4dHJhRXJyb3JzXG4gICAgICAgICAgICAgICAgICAgID8gbWVyZ2VPYmplY3RzKG5ld0Vycm9yU2NoZW1hLCBleHRyYUVycm9ycywgJ3ByZXZlbnREdXBsaWNhdGVzJylcbiAgICAgICAgICAgICAgICAgICAgOiBuZXdFcnJvclNjaGVtYTtcbiAgICAgICAgICAgICAgICBzdGF0ZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGE6IG5ld0Zvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBlcnJvclNjaGVtYTogZXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yczogdG9FcnJvckxpc3QoZXJyb3JTY2hlbWEpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3JldHJpZXZlZFNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnJldHJpZXZlZFNjaGVtYSA9IF9yZXRyaWV2ZWRTY2hlbWE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHN0YXRlLCAoKSA9PiBvbkNoYW5nZSAmJiBvbkNoYW5nZSh7IC4uLnRoaXMuc3RhdGUsIC4uLnN0YXRlIH0sIGlkKSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsYmFjayBmdW5jdGlvbiB0byBoYW5kbGUgcmVzZXQgZm9ybSBkYXRhLlxuICAgICAgICAgKiAtIFJlc2V0IGFsbCBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAgICAgICAgICogLSBSZXNldCB2YWxpZGF0aW9ucyBhbmQgZXJyb3JzXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2V0ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvbkNoYW5nZSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IG5ld1N0YXRlID0gdGhpcy5nZXRTdGF0ZUZyb21Qcm9wcyh0aGlzLnByb3BzLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgY29uc3QgbmV3Rm9ybURhdGEgPSBuZXdTdGF0ZS5mb3JtRGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhOiBuZXdGb3JtRGF0YSxcbiAgICAgICAgICAgICAgICBlcnJvclNjaGVtYToge30sXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFWYWxpZGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBzY2hlbWFWYWxpZGF0aW9uRXJyb3JTY2hlbWE6IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoc3RhdGUsICgpID0+IG9uQ2hhbmdlICYmIG9uQ2hhbmdlKHsgLi4udGhpcy5zdGF0ZSwgLi4uc3RhdGUgfSkpO1xuICAgICAgICB9O1xuICAgICAgICAvKiogQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIHdoZW4gYSBmaWVsZCBvbiB0aGUgZm9ybSBpcyBibHVycmVkLiBDYWxscyB0aGUgYG9uQmx1cmAgY2FsbGJhY2sgZm9yIHRoZSBgRm9ybWAgaWYgaXRcbiAgICAgICAgICogd2FzIHByb3ZpZGVkLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaWQgLSBUaGUgdW5pcXVlIGBpZGAgb2YgdGhlIGZpZWxkIHRoYXQgd2FzIGJsdXJyZWRcbiAgICAgICAgICogQHBhcmFtIGRhdGEgLSBUaGUgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGZpZWxkIHRoYXQgd2FzIGJsdXJyZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25CbHVyID0gKGlkLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uQmx1ciB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvbkJsdXIpIHtcbiAgICAgICAgICAgICAgICBvbkJsdXIoaWQsIGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvKiogQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIHdoZW4gYSBmaWVsZCBvbiB0aGUgZm9ybSBpcyBmb2N1c2VkLiBDYWxscyB0aGUgYG9uRm9jdXNgIGNhbGxiYWNrIGZvciB0aGUgYEZvcm1gIGlmIGl0XG4gICAgICAgICAqIHdhcyBwcm92aWRlZC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGlkIC0gVGhlIHVuaXF1ZSBgaWRgIG9mIHRoZSBmaWVsZCB0aGF0IHdhcyBmb2N1c2VkXG4gICAgICAgICAqIEBwYXJhbSBkYXRhIC0gVGhlIGRhdGEgYXNzb2NpYXRlZCB3aXRoIHRoZSBmaWVsZCB0aGF0IHdhcyBmb2N1c2VkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRm9jdXMgPSAoaWQsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25Gb2N1cyB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGlmIChvbkZvY3VzKSB7XG4gICAgICAgICAgICAgICAgb25Gb2N1cyhpZCwgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDYWxsYmFjayBmdW5jdGlvbiB0byBoYW5kbGUgd2hlbiB0aGUgZm9ybSBpcyBzdWJtaXR0ZWQuIEZpcnN0LCBpdCBwcmV2ZW50cyB0aGUgZGVmYXVsdCBldmVudCBiZWhhdmlvci4gTm90aGluZ1xuICAgICAgICAgKiBoYXBwZW5zIGlmIHRoZSB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXQgb2YgdGhlIGV2ZW50IGFyZSBub3QgdGhlIHNhbWUuIEl0IHdpbGwgb21pdCBhbnkgZXh0cmEgZGF0YSBpbiB0aGVcbiAgICAgICAgICogYGZvcm1EYXRhYCBpbiB0aGUgc3RhdGUgaWYgYG9taXRFeHRyYURhdGFgIGlzIHRydWUuIEl0IHdpbGwgdmFsaWRhdGUgdGhlIHJlc3VsdGluZyBgZm9ybURhdGFgLCByZXBvcnRpbmcgZXJyb3JzXG4gICAgICAgICAqIHZpYSB0aGUgYG9uRXJyb3IoKWAgY2FsbGJhY2sgdW5sZXNzIHZhbGlkYXRpb24gaXMgZGlzYWJsZWQuIEZpbmFsbHksIGl0IHdpbGwgYWRkIGluIGFueSBgZXh0cmFFcnJvcnNgIGFuZCB0aGVuIGNhbGxcbiAgICAgICAgICogYmFjayB0aGUgYG9uU3VibWl0YCBjYWxsYmFjayBpZiBpdCB3YXMgcHJvdmlkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBldmVudCAtIFRoZSBzdWJtaXQgSFRNTCBmb3JtIGV2ZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uU3VibWl0ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldCAhPT0gZXZlbnQuY3VycmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LnBlcnNpc3QoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb21pdEV4dHJhRGF0YSwgZXh0cmFFcnJvcnMsIG5vVmFsaWRhdGUsIG9uU3VibWl0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgbGV0IHsgZm9ybURhdGE6IG5ld0Zvcm1EYXRhIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEsIHNjaGVtYVV0aWxzIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKG9taXRFeHRyYURhdGEgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXRyaWV2ZWRTY2hlbWEgPSBzY2hlbWFVdGlscy5yZXRyaWV2ZVNjaGVtYShzY2hlbWEsIG5ld0Zvcm1EYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXRoU2NoZW1hID0gc2NoZW1hVXRpbHMudG9QYXRoU2NoZW1hKHJldHJpZXZlZFNjaGVtYSwgJycsIG5ld0Zvcm1EYXRhKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gdGhpcy5nZXRGaWVsZE5hbWVzKHBhdGhTY2hlbWEsIG5ld0Zvcm1EYXRhKTtcbiAgICAgICAgICAgICAgICBuZXdGb3JtRGF0YSA9IHRoaXMuZ2V0VXNlZEZvcm1EYXRhKG5ld0Zvcm1EYXRhLCBmaWVsZE5hbWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub1ZhbGlkYXRlIHx8IHRoaXMudmFsaWRhdGVGb3JtKCkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGVyZSBhcmUgbm8gZXJyb3JzIGdlbmVyYXRlZCB0aHJvdWdoIHNjaGVtYSB2YWxpZGF0aW9uLlxuICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciB1c2VyIHByb3ZpZGVkIGVycm9ycyBhbmQgdXBkYXRlIHN0YXRlIGFjY29yZGluZ2x5LlxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yU2NoZW1hID0gZXh0cmFFcnJvcnMgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZXh0cmFFcnJvcnMgPyB0b0Vycm9yTGlzdChleHRyYUVycm9ycykgOiBbXTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGE6IG5ld0Zvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWFWYWxpZGF0aW9uRXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hVmFsaWRhdGlvbkVycm9yU2NoZW1hOiB7fSxcbiAgICAgICAgICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWJtaXQoeyAuLi50aGlzLnN0YXRlLCBmb3JtRGF0YTogbmV3Rm9ybURhdGEsIHN0YXR1czogJ3N1Ym1pdHRlZCcgfSwgZXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICghcHJvcHMudmFsaWRhdG9yKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdmFsaWRhdG9yIGlzIHJlcXVpcmVkIGZvciBGb3JtIGZ1bmN0aW9uYWxpdHkgdG8gd29yaycpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLmdldFN0YXRlRnJvbVByb3BzKHByb3BzLCBwcm9wcy5mb3JtRGF0YSk7XG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uQ2hhbmdlICYmICFkZWVwRXF1YWxzKHRoaXMuc3RhdGUuZm9ybURhdGEsIHRoaXMucHJvcHMuZm9ybURhdGEpKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMuc3RhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZm9ybUVsZW1lbnQgPSBjcmVhdGVSZWYoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGdldFNuYXBzaG90QmVmb3JlVXBkYXRlYCBpcyBhIFJlYWN0IGxpZmVjeWNsZSBtZXRob2QgdGhhdCBpcyBpbnZva2VkIHJpZ2h0IGJlZm9yZSB0aGUgbW9zdCByZWNlbnRseSByZW5kZXJlZFxuICAgICAqIG91dHB1dCBpcyBjb21taXR0ZWQgdG8gdGhlIERPTS4gSXQgZW5hYmxlcyB5b3VyIGNvbXBvbmVudCB0byBjYXB0dXJlIGN1cnJlbnQgdmFsdWVzIChlLmcuLCBzY3JvbGwgcG9zaXRpb24pIGJlZm9yZVxuICAgICAqIHRoZXkgYXJlIHBvdGVudGlhbGx5IGNoYW5nZWQuXG4gICAgICpcbiAgICAgKiBJbiB0aGlzIGNhc2UsIGl0IGNoZWNrcyBpZiB0aGUgcHJvcHMgaGF2ZSBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHJlbmRlci4gSWYgdGhleSBoYXZlLCBpdCBjb21wdXRlcyB0aGUgbmV4dCBzdGF0ZVxuICAgICAqIG9mIHRoZSBjb21wb25lbnQgdXNpbmcgYGdldFN0YXRlRnJvbVByb3BzYCBtZXRob2QgYW5kIHJldHVybnMgaXQgYWxvbmcgd2l0aCBhIGBzaG91bGRVcGRhdGVgIGZsYWcgc2V0IHRvIGB0cnVlYCBJRlxuICAgICAqIHRoZSBgbmV4dFN0YXRlYCBhbmQgYHByZXZTdGF0ZWAgYXJlIGRpZmZlcmVudCwgb3RoZXJ3aXNlIGBmYWxzZWAuIFRoaXMgZW5zdXJlcyB0aGF0IHdlIGhhdmUgdGhlIG1vc3QgdXAtdG8tZGF0ZVxuICAgICAqIHN0YXRlIHJlYWR5IHRvIGJlIGFwcGxpZWQgaW4gYGNvbXBvbmVudERpZFVwZGF0ZWAuXG4gICAgICpcbiAgICAgKiBJZiBgZm9ybURhdGFgIGhhc24ndCBjaGFuZ2VkLCBpdCBzaW1wbHkgcmV0dXJucyBhbiBvYmplY3Qgd2l0aCBgc2hvdWxkVXBkYXRlYCBzZXQgdG8gYGZhbHNlYCwgaW5kaWNhdGluZyB0aGF0IGFcbiAgICAgKiBzdGF0ZSB1cGRhdGUgaXMgbm90IG5lY2Vzc2FyeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmV2UHJvcHMgLSBUaGUgcHJldmlvdXMgc2V0IG9mIHByb3BzIGJlZm9yZSB0aGUgdXBkYXRlLlxuICAgICAqIEBwYXJhbSBwcmV2U3RhdGUgLSBUaGUgcHJldmlvdXMgc3RhdGUgYmVmb3JlIHRoZSB1cGRhdGUuXG4gICAgICogQHJldHVybnMgRWl0aGVyIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZXh0IHN0YXRlIGFuZCBhIGZsYWcgaW5kaWNhdGluZyB0aGF0IGFuIHVwZGF0ZSBzaG91bGQgb2NjdXIsIG9yIGFuIG9iamVjdFxuICAgICAqICAgICAgICB3aXRoIGEgZmxhZyBpbmRpY2F0aW5nIHRoYXQgYW4gdXBkYXRlIGlzIG5vdCBuZWNlc3NhcnkuXG4gICAgICovXG4gICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWxzKHRoaXMucHJvcHMsIHByZXZQcm9wcykpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHRoaXMuZ2V0U3RhdGVGcm9tUHJvcHModGhpcy5wcm9wcywgdGhpcy5wcm9wcy5mb3JtRGF0YSwgcHJldlByb3BzLnNjaGVtYSAhPT0gdGhpcy5wcm9wcy5zY2hlbWEgPyB1bmRlZmluZWQgOiB0aGlzLnN0YXRlLnJldHJpZXZlZFNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRVcGRhdGUgPSAhZGVlcEVxdWFscyhuZXh0U3RhdGUsIHByZXZTdGF0ZSk7XG4gICAgICAgICAgICByZXR1cm4geyBuZXh0U3RhdGUsIHNob3VsZFVwZGF0ZSB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNob3VsZFVwZGF0ZTogZmFsc2UgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogYGNvbXBvbmVudERpZFVwZGF0ZWAgaXMgYSBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgaXMgaW52b2tlZCBpbW1lZGlhdGVseSBhZnRlciB1cGRhdGluZyBvY2N1cnMuIFRoaXMgbWV0aG9kIGlzXG4gICAgICogbm90IGNhbGxlZCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAqXG4gICAgICogSGVyZSwgaXQgY2hlY2tzIGlmIGFuIHVwZGF0ZSBpcyBuZWNlc3NhcnkgYmFzZWQgb24gdGhlIGBzaG91bGRVcGRhdGVgIGZsYWcgcmVjZWl2ZWQgZnJvbSBgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVgLlxuICAgICAqIElmIGFuIHVwZGF0ZSBpcyByZXF1aXJlZCwgaXQgYXBwbGllcyB0aGUgbmV4dCBzdGF0ZSBhbmQsIGlmIG5lZWRlZCwgdHJpZ2dlcnMgdGhlIGBvbkNoYW5nZWAgaGFuZGxlciB0byBpbmZvcm0gYWJvdXRcbiAgICAgKiBjaGFuZ2VzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZWZmZWN0aXZlbHkgcmVwbGFjZXMgdGhlIGRlcHJlY2F0ZWQgYFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzYCwgcHJvdmlkaW5nIGEgc2FmZXIgYWx0ZXJuYXRpdmVcbiAgICAgKiB0byBoYW5kbGUgcHJvcCBjaGFuZ2VzIGFuZCBzdGF0ZSB1cGRhdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIF8gLSBUaGUgcHJldmlvdXMgc2V0IG9mIHByb3BzLlxuICAgICAqIEBwYXJhbSBwcmV2U3RhdGUgLSBUaGUgcHJldmlvdXMgc3RhdGUgb2YgdGhlIGNvbXBvbmVudCBiZWZvcmUgdGhlIHVwZGF0ZS5cbiAgICAgKiBAcGFyYW0gc25hcHNob3QgLSBUaGUgdmFsdWUgcmV0dXJuZWQgZnJvbSBgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGVgLlxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZShfLCBwcmV2U3RhdGUsIHNuYXBzaG90KSB7XG4gICAgICAgIGlmIChzbmFwc2hvdC5zaG91bGRVcGRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbmV4dFN0YXRlIH0gPSBzbmFwc2hvdDtcbiAgICAgICAgICAgIGlmICghZGVlcEVxdWFscyhuZXh0U3RhdGUuZm9ybURhdGEsIHRoaXMucHJvcHMuZm9ybURhdGEpICYmXG4gICAgICAgICAgICAgICAgIWRlZXBFcXVhbHMobmV4dFN0YXRlLmZvcm1EYXRhLCBwcmV2U3RhdGUuZm9ybURhdGEpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25DaGFuZ2UobmV4dFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUobmV4dFN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRXh0cmFjdHMgdGhlIHVwZGF0ZWQgc3RhdGUgZnJvbSB0aGUgZ2l2ZW4gYHByb3BzYCBhbmQgYGlucHV0Rm9ybURhdGFgLiBBcyBwYXJ0IG9mIHRoaXMgcHJvY2VzcywgdGhlXG4gICAgICogYGlucHV0Rm9ybURhdGFgIGlzIGZpcnN0IHByb2Nlc3NlZCB0byBhZGQgYW55IG1pc3NpbmcgcmVxdWlyZWQgZGVmYXVsdHMuIEFmdGVyIHRoYXQsIHRoZSBkYXRhIGlzIHJ1biB0aHJvdWdoIHRoZVxuICAgICAqIHZhbGlkYXRpb24gcHJvY2VzcyBJRiByZXF1aXJlZCBieSB0aGUgYHByb3BzYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGBGb3JtYFxuICAgICAqIEBwYXJhbSBpbnB1dEZvcm1EYXRhIC0gVGhlIG5ldyBvciBjdXJyZW50IGRhdGEgZm9yIHRoZSBgRm9ybWBcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBuZXcgc3RhdGUgZm9yIHRoZSBgRm9ybWBcbiAgICAgKi9cbiAgICBnZXRTdGF0ZUZyb21Qcm9wcyhwcm9wcywgaW5wdXRGb3JtRGF0YSwgcmV0cmlldmVkU2NoZW1hKSB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGF0ZSB8fCB7fTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gJ3NjaGVtYScgaW4gcHJvcHMgPyBwcm9wcy5zY2hlbWEgOiB0aGlzLnByb3BzLnNjaGVtYTtcbiAgICAgICAgY29uc3QgdWlTY2hlbWEgPSAoJ3VpU2NoZW1hJyBpbiBwcm9wcyA/IHByb3BzLnVpU2NoZW1hIDogdGhpcy5wcm9wcy51aVNjaGVtYSkgfHwge307XG4gICAgICAgIGNvbnN0IGVkaXQgPSB0eXBlb2YgaW5wdXRGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCc7XG4gICAgICAgIGNvbnN0IGxpdmVWYWxpZGF0ZSA9ICdsaXZlVmFsaWRhdGUnIGluIHByb3BzID8gcHJvcHMubGl2ZVZhbGlkYXRlIDogdGhpcy5wcm9wcy5saXZlVmFsaWRhdGU7XG4gICAgICAgIGNvbnN0IG11c3RWYWxpZGF0ZSA9IGVkaXQgJiYgIXByb3BzLm5vVmFsaWRhdGUgJiYgbGl2ZVZhbGlkYXRlO1xuICAgICAgICBjb25zdCByb290U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICBjb25zdCBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yID0gJ2V4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3InIGluIHByb3BzXG4gICAgICAgICAgICA/IHByb3BzLmV4cGVyaW1lbnRhbF9kZWZhdWx0Rm9ybVN0YXRlQmVoYXZpb3JcbiAgICAgICAgICAgIDogdGhpcy5wcm9wcy5leHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yO1xuICAgICAgICBsZXQgc2NoZW1hVXRpbHMgPSBzdGF0ZS5zY2hlbWFVdGlscztcbiAgICAgICAgaWYgKCFzY2hlbWFVdGlscyB8fFxuICAgICAgICAgICAgc2NoZW1hVXRpbHMuZG9lc1NjaGVtYVV0aWxzRGlmZmVyKHByb3BzLnZhbGlkYXRvciwgcm9vdFNjaGVtYSwgZXhwZXJpbWVudGFsX2RlZmF1bHRGb3JtU3RhdGVCZWhhdmlvcikpIHtcbiAgICAgICAgICAgIHNjaGVtYVV0aWxzID0gY3JlYXRlU2NoZW1hVXRpbHMocHJvcHMudmFsaWRhdG9yLCByb290U2NoZW1hLCBleHBlcmltZW50YWxfZGVmYXVsdEZvcm1TdGF0ZUJlaGF2aW9yKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtRGF0YSA9IHNjaGVtYVV0aWxzLmdldERlZmF1bHRGb3JtU3RhdGUoc2NoZW1hLCBpbnB1dEZvcm1EYXRhKTtcbiAgICAgICAgY29uc3QgX3JldHJpZXZlZFNjaGVtYSA9IHJldHJpZXZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXRyaWV2ZWRTY2hlbWEgIT09IHZvaWQgMCA/IHJldHJpZXZlZFNjaGVtYSA6IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKHNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICBjb25zdCBnZXRDdXJyZW50RXJyb3JzID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3BzLm5vVmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBlcnJvcnM6IFtdLCBlcnJvclNjaGVtYToge30gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcm9wcy5saXZlVmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IHN0YXRlLnNjaGVtYVZhbGlkYXRpb25FcnJvcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2NoZW1hOiBzdGF0ZS5zY2hlbWFWYWxpZGF0aW9uRXJyb3JTY2hlbWEgfHwge30sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3JzOiBzdGF0ZS5lcnJvcnMgfHwgW10sXG4gICAgICAgICAgICAgICAgZXJyb3JTY2hlbWE6IHN0YXRlLmVycm9yU2NoZW1hIHx8IHt9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IGVycm9ycztcbiAgICAgICAgbGV0IGVycm9yU2NoZW1hO1xuICAgICAgICBsZXQgc2NoZW1hVmFsaWRhdGlvbkVycm9ycyA9IHN0YXRlLnNjaGVtYVZhbGlkYXRpb25FcnJvcnM7XG4gICAgICAgIGxldCBzY2hlbWFWYWxpZGF0aW9uRXJyb3JTY2hlbWEgPSBzdGF0ZS5zY2hlbWFWYWxpZGF0aW9uRXJyb3JTY2hlbWE7XG4gICAgICAgIGlmIChtdXN0VmFsaWRhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaGVtYVZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKGZvcm1EYXRhLCBzY2hlbWEsIHNjaGVtYVV0aWxzLCBfcmV0cmlldmVkU2NoZW1hKTtcbiAgICAgICAgICAgIGVycm9ycyA9IHNjaGVtYVZhbGlkYXRpb24uZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JTY2hlbWEgPSBzY2hlbWFWYWxpZGF0aW9uLmVycm9yU2NoZW1hO1xuICAgICAgICAgICAgc2NoZW1hVmFsaWRhdGlvbkVycm9ycyA9IGVycm9ycztcbiAgICAgICAgICAgIHNjaGVtYVZhbGlkYXRpb25FcnJvclNjaGVtYSA9IGVycm9yU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEVycm9ycyA9IGdldEN1cnJlbnRFcnJvcnMoKTtcbiAgICAgICAgICAgIGVycm9ycyA9IGN1cnJlbnRFcnJvcnMuZXJyb3JzO1xuICAgICAgICAgICAgZXJyb3JTY2hlbWEgPSBjdXJyZW50RXJyb3JzLmVycm9yU2NoZW1hO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5leHRyYUVycm9ycykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gdmFsaWRhdGlvbkRhdGFNZXJnZSh7IGVycm9yU2NoZW1hLCBlcnJvcnMgfSwgcHJvcHMuZXh0cmFFcnJvcnMpO1xuICAgICAgICAgICAgZXJyb3JTY2hlbWEgPSBtZXJnZWQuZXJyb3JTY2hlbWE7XG4gICAgICAgICAgICBlcnJvcnMgPSBtZXJnZWQuZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlkU2NoZW1hID0gc2NoZW1hVXRpbHMudG9JZFNjaGVtYShfcmV0cmlldmVkU2NoZW1hLCB1aVNjaGVtYVsndWk6cm9vdEZpZWxkSWQnXSwgZm9ybURhdGEsIHByb3BzLmlkUHJlZml4LCBwcm9wcy5pZFNlcGFyYXRvcik7XG4gICAgICAgIGNvbnN0IG5leHRTdGF0ZSA9IHtcbiAgICAgICAgICAgIHNjaGVtYVV0aWxzLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgdWlTY2hlbWEsXG4gICAgICAgICAgICBpZFNjaGVtYSxcbiAgICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgICAgZWRpdCxcbiAgICAgICAgICAgIGVycm9ycyxcbiAgICAgICAgICAgIGVycm9yU2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hVmFsaWRhdGlvbkVycm9ycyxcbiAgICAgICAgICAgIHNjaGVtYVZhbGlkYXRpb25FcnJvclNjaGVtYSxcbiAgICAgICAgICAgIHJldHJpZXZlZFNjaGVtYTogX3JldHJpZXZlZFNjaGVtYSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICB9XG4gICAgLyoqIFJlYWN0IGxpZmVjeWNsZSBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIGRldGVybWluZSB3aGV0aGVyIGNvbXBvbmVudCBzaG91bGQgYmUgdXBkYXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuZXh0UHJvcHMgLSBUaGUgbmV4dCB2ZXJzaW9uIG9mIHRoZSBwcm9wc1xuICAgICAqIEBwYXJhbSBuZXh0U3RhdGUgLSBUaGUgbmV4dCB2ZXJzaW9uIG9mIHRoZSBzdGF0ZVxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzLCBuZXh0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHNob3VsZFJlbmRlcih0aGlzLCBuZXh0UHJvcHMsIG5leHRTdGF0ZSk7XG4gICAgfVxuICAgIC8qKiBWYWxpZGF0ZXMgdGhlIGBmb3JtRGF0YWAgYWdhaW5zdCB0aGUgYHNjaGVtYWAgdXNpbmcgdGhlIGBhbHRTY2hlbWFVdGlsc2AgKGlmIHByb3ZpZGVkIG90aGVyd2lzZSBpdCB1c2VzIHRoZVxuICAgICAqIGBzY2hlbWFVdGlsc2AgaW4gdGhlIHN0YXRlKSwgcmV0dXJuaW5nIHRoZSByZXN1bHRzLlxuICAgICAqXG4gICAgICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIG5ldyBmb3JtIGRhdGEgdG8gdmFsaWRhdGVcbiAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSB1c2VkIHRvIHZhbGlkYXRlIGFnYWluc3RcbiAgICAgKiBAcGFyYW0gYWx0U2NoZW1hVXRpbHMgLSBUaGUgYWx0ZXJuYXRlIHNjaGVtYVV0aWxzIHRvIHVzZSBmb3IgdmFsaWRhdGlvblxuICAgICAqL1xuICAgIHZhbGlkYXRlKGZvcm1EYXRhLCBzY2hlbWEgPSB0aGlzLnByb3BzLnNjaGVtYSwgYWx0U2NoZW1hVXRpbHMsIHJldHJpZXZlZFNjaGVtYSkge1xuICAgICAgICBjb25zdCBzY2hlbWFVdGlscyA9IGFsdFNjaGVtYVV0aWxzID8gYWx0U2NoZW1hVXRpbHMgOiB0aGlzLnN0YXRlLnNjaGVtYVV0aWxzO1xuICAgICAgICBjb25zdCB7IGN1c3RvbVZhbGlkYXRlLCB0cmFuc2Zvcm1FcnJvcnMsIHVpU2NoZW1hIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCByZXNvbHZlZFNjaGVtYSA9IHJldHJpZXZlZFNjaGVtYSAhPT0gbnVsbCAmJiByZXRyaWV2ZWRTY2hlbWEgIT09IHZvaWQgMCA/IHJldHJpZXZlZFNjaGVtYSA6IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKHNjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICByZXR1cm4gc2NoZW1hVXRpbHNcbiAgICAgICAgICAgIC5nZXRWYWxpZGF0b3IoKVxuICAgICAgICAgICAgLnZhbGlkYXRlRm9ybURhdGEoZm9ybURhdGEsIHJlc29sdmVkU2NoZW1hLCBjdXN0b21WYWxpZGF0ZSwgdHJhbnNmb3JtRXJyb3JzLCB1aVNjaGVtYSk7XG4gICAgfVxuICAgIC8qKiBSZW5kZXJzIGFueSBlcnJvcnMgY29udGFpbmVkIGluIHRoZSBgc3RhdGVgIGluIHVzaW5nIHRoZSBgRXJyb3JMaXN0YCwgaWYgbm90IGRpc2FibGVkIGJ5IGBzaG93RXJyb3JMaXN0YC4gKi9cbiAgICByZW5kZXJFcnJvcnMocmVnaXN0cnkpIHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMsIGVycm9yU2NoZW1hLCBzY2hlbWEsIHVpU2NoZW1hIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IGZvcm1Db250ZXh0IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgICAgICAgY29uc3QgRXJyb3JMaXN0VGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnRXJyb3JMaXN0VGVtcGxhdGUnLCByZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgICAgIGlmIChlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuIChfanN4KEVycm9yTGlzdFRlbXBsYXRlLCB7IGVycm9yczogZXJyb3JzLCBlcnJvclNjaGVtYTogZXJyb3JTY2hlbWEgfHwge30sIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEsIGZvcm1Db250ZXh0OiBmb3JtQ29udGV4dCwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIHJlZ2lzdHJ5IGZvciB0aGUgZm9ybSAqL1xuICAgIGdldFJlZ2lzdHJ5KCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgdHJhbnNsYXRlU3RyaW5nOiBjdXN0b21UcmFuc2xhdGVTdHJpbmcsIHVpU2NoZW1hID0ge30gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hVXRpbHMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHsgZmllbGRzLCB0ZW1wbGF0ZXMsIHdpZGdldHMsIGZvcm1Db250ZXh0LCB0cmFuc2xhdGVTdHJpbmcgfSA9IGdldERlZmF1bHRSZWdpc3RyeSgpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmllbGRzOiB7IC4uLmZpZWxkcywgLi4udGhpcy5wcm9wcy5maWVsZHMgfSxcbiAgICAgICAgICAgIHRlbXBsYXRlczoge1xuICAgICAgICAgICAgICAgIC4uLnRlbXBsYXRlcyxcbiAgICAgICAgICAgICAgICAuLi50aGlzLnByb3BzLnRlbXBsYXRlcyxcbiAgICAgICAgICAgICAgICBCdXR0b25UZW1wbGF0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udGVtcGxhdGVzLkJ1dHRvblRlbXBsYXRlcyxcbiAgICAgICAgICAgICAgICAgICAgLi4uKF9hID0gdGhpcy5wcm9wcy50ZW1wbGF0ZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5CdXR0b25UZW1wbGF0ZXMsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aWRnZXRzOiB7IC4uLndpZGdldHMsIC4uLnRoaXMucHJvcHMud2lkZ2V0cyB9LFxuICAgICAgICAgICAgcm9vdFNjaGVtYTogdGhpcy5wcm9wcy5zY2hlbWEsXG4gICAgICAgICAgICBmb3JtQ29udGV4dDogdGhpcy5wcm9wcy5mb3JtQ29udGV4dCB8fCBmb3JtQ29udGV4dCxcbiAgICAgICAgICAgIHNjaGVtYVV0aWxzLFxuICAgICAgICAgICAgdHJhbnNsYXRlU3RyaW5nOiBjdXN0b21UcmFuc2xhdGVTdHJpbmcgfHwgdHJhbnNsYXRlU3RyaW5nLFxuICAgICAgICAgICAgZ2xvYmFsVWlPcHRpb25zOiB1aVNjaGVtYVtVSV9HTE9CQUxfT1BUSU9OU19LRVldLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKiogUHJvdmlkZXMgYSBmdW5jdGlvbiB0aGF0IGNhbiBiZSB1c2VkIHRvIHByb2dyYW1tYXRpY2FsbHkgc3VibWl0IHRoZSBgRm9ybWAgKi9cbiAgICBzdWJtaXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmZvcm1FbGVtZW50LmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZm9ybUVsZW1lbnQuY3VycmVudC5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudCgnc3VibWl0Jywge1xuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB0aGlzLmZvcm1FbGVtZW50LmN1cnJlbnQucmVxdWVzdFN1Ym1pdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKiBBdHRlbXB0cyB0byBmb2N1cyBvbiB0aGUgZmllbGQgYXNzb2NpYXRlZCB3aXRoIHRoZSBgZXJyb3JgLiBVc2VzIHRoZSBgcHJvcGVydHlgIGZpZWxkIHRvIGNvbXB1dGUgcGF0aCBvZiB0aGUgZXJyb3JcbiAgICAgKiBmaWVsZCwgdGhlbiwgdXNpbmcgdGhlIGBpZFByZWZpeGAgYW5kIGBpZFNlcGFyYXRvcmAgY29udmVydHMgdGhhdCBwYXRoIGludG8gYW4gaWQuIFRoZW4gdGhlIGlucHV0IGVsZW1lbnQgd2l0aCB0aGF0XG4gICAgICogaWQgaXMgYXR0ZW1wdGVkIHRvIGJlIGZvdW5kIHVzaW5nIHRoZSBgZm9ybUVsZW1lbnRgIHJlZi4gSWYgaXQgaXMgbG9jYXRlZCwgdGhlbiBpdCBpcyBmb2N1c2VkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGVycm9yIC0gVGhlIGVycm9yIG9uIHdoaWNoIHRvIGZvY3VzXG4gICAgICovXG4gICAgZm9jdXNPbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IHsgaWRQcmVmaXggPSAncm9vdCcsIGlkU2VwYXJhdG9yID0gJ18nIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByb3BlcnR5IH0gPSBlcnJvcjtcbiAgICAgICAgY29uc3QgcGF0aCA9IF90b1BhdGgocHJvcGVydHkpO1xuICAgICAgICBpZiAocGF0aFswXSA9PT0gJycpIHtcbiAgICAgICAgICAgIC8vIE1vc3Qgb2YgdGhlIHRpbWUgdGhlIGAuZm9vYCBwcm9wZXJ0eSByZXN1bHRzIGluIHRoZSBmaXJzdCBlbGVtZW50IGJlaW5nIGVtcHR5LCBzbyByZXBsYWNlIGl0IHdpdGggdGhlIGlkUHJlZml4XG4gICAgICAgICAgICBwYXRoWzBdID0gaWRQcmVmaXg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBPdGhlcndpc2UgaW5zZXJ0IHRoZSBpZFByZWZpeCBpbnRvIHRoZSBmaXJzdCBsb2NhdGlvbiB1c2luZyB1bnNoaWZ0XG4gICAgICAgICAgICBwYXRoLnVuc2hpZnQoaWRQcmVmaXgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnRJZCA9IHBhdGguam9pbihpZFNlcGFyYXRvcik7XG4gICAgICAgIGxldCBmaWVsZCA9IHRoaXMuZm9ybUVsZW1lbnQuY3VycmVudC5lbGVtZW50c1tlbGVtZW50SWRdO1xuICAgICAgICBpZiAoIWZpZWxkKSB7XG4gICAgICAgICAgICAvLyBpZiBub3QgYW4gZXhhY3QgbWF0Y2gsIHRyeSBmaW5kaW5nIGFuIGlucHV0IHN0YXJ0aW5nIHdpdGggdGhlIGVsZW1lbnQgaWQgKGxpa2UgcmFkaW8gYnV0dG9ucyBvciBjaGVja2JveGVzKVxuICAgICAgICAgICAgZmllbGQgPSB0aGlzLmZvcm1FbGVtZW50LmN1cnJlbnQucXVlcnlTZWxlY3RvcihgaW5wdXRbaWRePSR7ZWxlbWVudElkfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZCAmJiBmaWVsZC5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGdvdCBhIGxpc3Qgd2l0aCBsZW5ndGggPiAwXG4gICAgICAgICAgICBmaWVsZCA9IGZpZWxkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgZmllbGQuZm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUHJvZ3JhbW1hdGljYWxseSB2YWxpZGF0ZSB0aGUgZm9ybS4gSWYgYG9uRXJyb3JgIGlzIHByb3ZpZGVkLCB0aGVuIGl0IHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGxpc3Qgb2YgZXJyb3JzIHRoZVxuICAgICAqIHNhbWUgd2F5IGFzIHdvdWxkIGhhcHBlbiBvbiBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRydWUgaWYgdGhlIGZvcm0gaXMgdmFsaWQsIGZhbHNlIG90aGVyd2lzZS5cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUZvcm0oKSB7XG4gICAgICAgIGNvbnN0IHsgZXh0cmFFcnJvcnMsIGV4dHJhRXJyb3JzQmxvY2tTdWJtaXQsIGZvY3VzT25GaXJzdEVycm9yLCBvbkVycm9yIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IGZvcm1EYXRhLCBlcnJvcnM6IHByZXZFcnJvcnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGNvbnN0IHNjaGVtYVZhbGlkYXRpb24gPSB0aGlzLnZhbGlkYXRlKGZvcm1EYXRhKTtcbiAgICAgICAgbGV0IGVycm9ycyA9IHNjaGVtYVZhbGlkYXRpb24uZXJyb3JzO1xuICAgICAgICBsZXQgZXJyb3JTY2hlbWEgPSBzY2hlbWFWYWxpZGF0aW9uLmVycm9yU2NoZW1hO1xuICAgICAgICBjb25zdCBzY2hlbWFWYWxpZGF0aW9uRXJyb3JzID0gZXJyb3JzO1xuICAgICAgICBjb25zdCBzY2hlbWFWYWxpZGF0aW9uRXJyb3JTY2hlbWEgPSBlcnJvclNjaGVtYTtcbiAgICAgICAgY29uc3QgaGFzRXJyb3IgPSBlcnJvcnMubGVuZ3RoID4gMCB8fCAoZXh0cmFFcnJvcnMgJiYgZXh0cmFFcnJvcnNCbG9ja1N1Ym1pdCk7XG4gICAgICAgIGlmIChoYXNFcnJvcikge1xuICAgICAgICAgICAgaWYgKGV4dHJhRXJyb3JzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gdmFsaWRhdGlvbkRhdGFNZXJnZShzY2hlbWFWYWxpZGF0aW9uLCBleHRyYUVycm9ycyk7XG4gICAgICAgICAgICAgICAgZXJyb3JTY2hlbWEgPSBtZXJnZWQuZXJyb3JTY2hlbWE7XG4gICAgICAgICAgICAgICAgZXJyb3JzID0gbWVyZ2VkLmVycm9ycztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmb2N1c09uRmlyc3RFcnJvcikge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm9jdXNPbkZpcnN0RXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9jdXNPbkZpcnN0RXJyb3IoZXJyb3JzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9jdXNPbkVycm9yKGVycm9yc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXJyb3JzLFxuICAgICAgICAgICAgICAgIGVycm9yU2NoZW1hLFxuICAgICAgICAgICAgICAgIHNjaGVtYVZhbGlkYXRpb25FcnJvcnMsXG4gICAgICAgICAgICAgICAgc2NoZW1hVmFsaWRhdGlvbkVycm9yU2NoZW1hLFxuICAgICAgICAgICAgfSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IoZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Zvcm0gdmFsaWRhdGlvbiBmYWlsZWQnLCBlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByZXZFcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgZXJyb3JzOiBbXSxcbiAgICAgICAgICAgICAgICBlcnJvclNjaGVtYToge30sXG4gICAgICAgICAgICAgICAgc2NoZW1hVmFsaWRhdGlvbkVycm9yczogW10sXG4gICAgICAgICAgICAgICAgc2NoZW1hVmFsaWRhdGlvbkVycm9yU2NoZW1hOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhaGFzRXJyb3I7XG4gICAgfVxuICAgIC8qKiBSZW5kZXJzIHRoZSBgRm9ybWAgZmllbGRzIGluc2lkZSB0aGUgPGZvcm0+IHwgYHRhZ05hbWVgIG9yIGBfaW50ZXJuYWxGb3JtV3JhcHBlcmAsIHJlbmRlcmluZyBhbnkgZXJyb3JzIGlmXG4gICAgICogbmVlZGVkIGFsb25nIHdpdGggdGhlIHN1Ym1pdCBidXR0b24gb3IgYW55IGNoaWxkcmVuIG9mIHRoZSBmb3JtLlxuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiwgaWQsIGlkUHJlZml4LCBpZFNlcGFyYXRvciwgY2xhc3NOYW1lID0gJycsIHRhZ05hbWUsIG5hbWUsIG1ldGhvZCwgdGFyZ2V0LCBhY3Rpb24sIGF1dG9Db21wbGV0ZSwgZW5jdHlwZSwgYWNjZXB0Y2hhcnNldCwgbm9IdG1sNVZhbGlkYXRlID0gZmFsc2UsIGRpc2FibGVkID0gZmFsc2UsIHJlYWRvbmx5ID0gZmFsc2UsIGZvcm1Db250ZXh0LCBzaG93RXJyb3JMaXN0ID0gJ3RvcCcsIF9pbnRlcm5hbEZvcm1XcmFwcGVyLCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHVpU2NoZW1hLCBmb3JtRGF0YSwgZXJyb3JTY2hlbWEsIGlkU2NoZW1hIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCByZWdpc3RyeSA9IHRoaXMuZ2V0UmVnaXN0cnkoKTtcbiAgICAgICAgY29uc3QgeyBTY2hlbWFGaWVsZDogX1NjaGVtYUZpZWxkIH0gPSByZWdpc3RyeS5maWVsZHM7XG4gICAgICAgIGNvbnN0IHsgU3VibWl0QnV0dG9uIH0gPSByZWdpc3RyeS50ZW1wbGF0ZXMuQnV0dG9uVGVtcGxhdGVzO1xuICAgICAgICAvLyBUaGUgYHNlbWFudGljLXVpYCBhbmQgYG1hdGVyaWFsLXVpYCB0aGVtZXMgaGF2ZSBgX2ludGVybmFsRm9ybVdyYXBwZXJgcyB0aGF0IHRha2UgYW4gYGFzYCBwcm9wIHRoYXQgaXMgdGhlXG4gICAgICAgIC8vIFByb3BUeXBlcy5lbGVtZW50VHlwZSB0byB1c2UgZm9yIHRoZSBpbm5lciB0YWcsIHNvIHdlJ2xsIG5lZWQgdG8gcGFzcyBgdGFnTmFtZWAgYWxvbmcgaWYgaXQgaXMgcHJvdmlkZWQuXG4gICAgICAgIC8vIE5PVEUsIHRoZSBgYXNgIHByb3AgaXMgbmF0aXZlIHRvIGBzZW1hbnRpYy11aWAgYW5kIGlzIGVtdWxhdGVkIGluIHRoZSBgbWF0ZXJpYWwtdWlgIHRoZW1lXG4gICAgICAgIGNvbnN0IGFzID0gX2ludGVybmFsRm9ybVdyYXBwZXIgPyB0YWdOYW1lIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBGb3JtVGFnID0gX2ludGVybmFsRm9ybVdyYXBwZXIgfHwgdGFnTmFtZSB8fCAnZm9ybSc7XG4gICAgICAgIGxldCB7IFtTVUJNSVRfQlROX09QVElPTlNfS0VZXTogc3VibWl0T3B0aW9ucyA9IHt9IH0gPSBnZXRVaU9wdGlvbnModWlTY2hlbWEpO1xuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIHN1Ym1pdE9wdGlvbnMgPSB7IC4uLnN1Ym1pdE9wdGlvbnMsIHByb3BzOiB7IC4uLnN1Ym1pdE9wdGlvbnMucHJvcHMsIGRpc2FibGVkOiB0cnVlIH0gfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJtaXRVaVNjaGVtYSA9IHsgW1VJX09QVElPTlNfS0VZXTogeyBbU1VCTUlUX0JUTl9PUFRJT05TX0tFWV06IHN1Ym1pdE9wdGlvbnMgfSB9O1xuICAgICAgICByZXR1cm4gKF9qc3hzKEZvcm1UYWcsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUgPyBjbGFzc05hbWUgOiAncmpzZicsIGlkOiBpZCwgbmFtZTogbmFtZSwgbWV0aG9kOiBtZXRob2QsIHRhcmdldDogdGFyZ2V0LCBhY3Rpb246IGFjdGlvbiwgYXV0b0NvbXBsZXRlOiBhdXRvQ29tcGxldGUsIGVuY1R5cGU6IGVuY3R5cGUsIGFjY2VwdENoYXJzZXQ6IGFjY2VwdGNoYXJzZXQsIG5vVmFsaWRhdGU6IG5vSHRtbDVWYWxpZGF0ZSwgb25TdWJtaXQ6IHRoaXMub25TdWJtaXQsIGFzOiBhcywgcmVmOiB0aGlzLmZvcm1FbGVtZW50LCBjaGlsZHJlbjogW3Nob3dFcnJvckxpc3QgPT09ICd0b3AnICYmIHRoaXMucmVuZGVyRXJyb3JzKHJlZ2lzdHJ5KSwgX2pzeChfU2NoZW1hRmllbGQsIHsgbmFtZTogJycsIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEsIGVycm9yU2NoZW1hOiBlcnJvclNjaGVtYSwgaWRTY2hlbWE6IGlkU2NoZW1hLCBpZFByZWZpeDogaWRQcmVmaXgsIGlkU2VwYXJhdG9yOiBpZFNlcGFyYXRvciwgZm9ybUNvbnRleHQ6IGZvcm1Db250ZXh0LCBmb3JtRGF0YTogZm9ybURhdGEsIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlLCBvbkJsdXI6IHRoaXMub25CbHVyLCBvbkZvY3VzOiB0aGlzLm9uRm9jdXMsIHJlZ2lzdHJ5OiByZWdpc3RyeSwgZGlzYWJsZWQ6IGRpc2FibGVkLCByZWFkb25seTogcmVhZG9ubHkgfSksIGNoaWxkcmVuID8gY2hpbGRyZW4gOiBfanN4KFN1Ym1pdEJ1dHRvbiwgeyB1aVNjaGVtYTogc3VibWl0VWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSwgc2hvd0Vycm9yTGlzdCA9PT0gJ2JvdHRvbScgJiYgdGhpcy5yZW5kZXJFcnJvcnMocmVnaXN0cnkpXSB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9ybS5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUsIGdldFdpZGdldCwgZ2V0VWlPcHRpb25zLCBpc0ZpeGVkSXRlbXMsIGFsbG93QWRkaXRpb25hbEl0ZW1zLCBpc0N1c3RvbVdpZGdldCwgb3B0aW9uc0xpc3QsIFRyYW5zbGF0YWJsZVN0cmluZywgSVRFTVNfS0VZLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmltcG9ydCBjbG9uZURlZXAgZnJvbSAnbG9kYXNoL2Nsb25lRGVlcCc7XG5pbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJ2xvZGFzaC9pc09iamVjdCc7XG5pbXBvcnQgc2V0IGZyb20gJ2xvZGFzaC9zZXQnO1xuaW1wb3J0IHsgbmFub2lkIH0gZnJvbSAnbmFub2lkJztcbi8qKiBVc2VkIHRvIGdlbmVyYXRlIGEgdW5pcXVlIElEIGZvciBhbiBlbGVtZW50IGluIGEgcm93ICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJvd0lkKCkge1xuICAgIHJldHVybiBuYW5vaWQoKTtcbn1cbi8qKiBDb252ZXJ0cyB0aGUgYGZvcm1EYXRhYCBpbnRvIGBLZXllZEZvcm1EYXRhVHlwZWAgZGF0YSwgdXNpbmcgdGhlIGBnZW5lcmF0ZVJvd0lkKClgIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUga2V5XG4gKlxuICogQHBhcmFtIGZvcm1EYXRhIC0gVGhlIGRhdGEgZm9yIHRoZSBmb3JtXG4gKiBAcmV0dXJucyAtIFRoZSBgZm9ybURhdGFgIGNvbnZlcnRlZCBpbnRvIGEgYEtleWVkRm9ybURhdGFUeXBlYCBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdlbmVyYXRlS2V5ZWRGb3JtRGF0YShmb3JtRGF0YSkge1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShmb3JtRGF0YSlcbiAgICAgICAgPyBbXVxuICAgICAgICA6IGZvcm1EYXRhLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXk6IGdlbmVyYXRlUm93SWQoKSxcbiAgICAgICAgICAgICAgICBpdGVtLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG59XG4vKiogQ29udmVydHMgYEtleWVkRm9ybURhdGFUeXBlYCBkYXRhIGludG8gdGhlIGlubmVyIGBmb3JtRGF0YWBcbiAqXG4gKiBAcGFyYW0ga2V5ZWRGb3JtRGF0YSAtIFRoZSBgS2V5ZWRGb3JtRGF0YVR5cGVgIHRvIGJlIGNvbnZlcnRlZFxuICogQHJldHVybnMgLSBUaGUgaW5uZXIgYGZvcm1EYXRhYCBpdGVtKHMpIGluIHRoZSBga2V5ZWRGb3JtRGF0YWBcbiAqL1xuZnVuY3Rpb24ga2V5ZWRUb1BsYWluRm9ybURhdGEoa2V5ZWRGb3JtRGF0YSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleWVkRm9ybURhdGEpKSB7XG4gICAgICAgIHJldHVybiBrZXllZEZvcm1EYXRhLm1hcCgoa2V5ZWRJdGVtKSA9PiBrZXllZEl0ZW0uaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8qKiBUaGUgYEFycmF5RmllbGRgIGNvbXBvbmVudCBpcyB1c2VkIHRvIHJlbmRlciBhIGZpZWxkIGluIHRoZSBzY2hlbWEgdGhhdCBpcyBvZiB0eXBlIGBhcnJheWAuIEl0IHN1cHBvcnRzIGJvdGggbm9ybWFsXG4gKiBhbmQgZml4ZWQgYXJyYXksIGFsbG93aW5nIHVzZXIgdG8gYWRkIGFuZCByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYXJyYXkgZGF0YS5cbiAqL1xuY2xhc3MgQXJyYXlGaWVsZCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLyoqIENvbnN0cnVjdHMgYW4gYEFycmF5RmllbGRgIGZyb20gdGhlIGBwcm9wc2AsIGdlbmVyYXRpbmcgdGhlIGluaXRpYWwga2V5ZWQgZGF0YSBmcm9tIHRoZSBgZm9ybURhdGFgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEZpZWxkUHJvcHNgIGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAvKiogUmV0dXJucyB0aGUgZGVmYXVsdCBmb3JtIGluZm9ybWF0aW9uIGZvciBhbiBpdGVtIGJhc2VkIG9uIHRoZSBzY2hlbWEgZm9yIHRoYXQgaXRlbS4gRGVhbHMgd2l0aCB0aGUgcG9zc2liaWxpdHlcbiAgICAgICAgICogdGhhdCB0aGUgc2NoZW1hIGlzIGZpeGVkIGFuZCBhbGxvd3MgYWRkaXRpb25hbCBpdGVtcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dldE5ld0Zvcm1EYXRhUm93ID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWEsIHJlZ2lzdHJ5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFVdGlscyB9ID0gcmVnaXN0cnk7XG4gICAgICAgICAgICBsZXQgaXRlbVNjaGVtYSA9IHNjaGVtYS5pdGVtcztcbiAgICAgICAgICAgIGlmIChpc0ZpeGVkSXRlbXMoc2NoZW1hKSAmJiBhbGxvd0FkZGl0aW9uYWxJdGVtcyhzY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgaXRlbVNjaGVtYSA9IHNjaGVtYS5hZGRpdGlvbmFsSXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDYXN0IHRoaXMgYXMgYSBUIHRvIHdvcmsgYXJvdW5kIHNjaGVtYSB1dGlscyBiZWluZyBmb3IgVFtdIGNhdXNlZCBieSB0aGUgRmllbGRQcm9wczxUW10sIFMsIEY+IGNhbGwgb24gdGhlIGNsYXNzXG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hVXRpbHMuZ2V0RGVmYXVsdEZvcm1TdGF0ZShpdGVtU2NoZW1hKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIENhbGxiYWNrIGhhbmRsZXIgZm9yIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBhZGQgYnV0dG9uLiBDcmVhdGVzIGEgbmV3IHJvdyBvZiBrZXllZCBmb3JtIGRhdGEgYXQgdGhlIGVuZCBvZlxuICAgICAgICAgKiB0aGUgbGlzdCwgYWRkaW5nIGl0IGludG8gdGhlIHN0YXRlLCBhbmQgdGhlbiByZXR1cm5pbmcgYG9uQ2hhbmdlKClgIHdpdGggdGhlIHBsYWluIGZvcm0gZGF0YSBjb252ZXJ0ZWQgZnJvbSB0aGVcbiAgICAgICAgICoga2V5ZWQgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZXZlbnQgLSBUaGUgZXZlbnQgZm9yIHRoZSBjbGlja1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkFkZENsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVBZGRDbGljayhldmVudCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgYWRkIGJ1dHRvbiBvbiBhbiBleGlzdGluZyBhcnJheSBlbGVtZW50LiBDcmVhdGVzIGEgbmV3IHJvdyBvZlxuICAgICAgICAgKiBrZXllZCBmb3JtIGRhdGEgaW5zZXJ0ZWQgYXQgdGhlIGBpbmRleGAsIGFkZGluZyBpdCBpbnRvIHRoZSBzdGF0ZSwgYW5kIHRoZW4gcmV0dXJuaW5nIGBvbkNoYW5nZSgpYCB3aXRoIHRoZSBwbGFpblxuICAgICAgICAgKiBmb3JtIGRhdGEgY29udmVydGVkIGZyb20gdGhlIGtleWVkIGRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRoZSBhZGQgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25BZGRJbmRleENsaWNrID0gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlQWRkQ2xpY2soZXZlbnQsIGluZGV4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgY29weSBidXR0b24gb24gYW4gZXhpc3RpbmcgYXJyYXkgZWxlbWVudC4gQ2xvbmVzIHRoZSByb3cgb2ZcbiAgICAgICAgICoga2V5ZWQgZm9ybSBkYXRhIGF0IHRoZSBgaW5kZXhgIGludG8gdGhlIG5leHQgcG9zaXRpb24gaW4gdGhlIHN0YXRlLCBhbmQgdGhlbiByZXR1cm5pbmcgYG9uQ2hhbmdlKClgIHdpdGggdGhlIHBsYWluXG4gICAgICAgICAqIGZvcm0gZGF0YSBjb252ZXJ0ZWQgZnJvbSB0aGUga2V5ZWQgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggYXQgd2hpY2ggdGhlIGNvcHkgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Db3B5SW5kZXhDbGljayA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCBlcnJvclNjaGVtYSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleWVkRm9ybURhdGEgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgLy8gcmVmcyAjMTk1OiByZXZhbGlkYXRlIHRvIGVuc3VyZSBwcm9wZXJseSByZWluZGV4aW5nIGVycm9yc1xuICAgICAgICAgICAgICAgIGxldCBuZXdFcnJvclNjaGVtYTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXJyb3JTY2hlbWEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gZXJyb3JTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBwYXJzZUludChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPD0gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQobmV3RXJyb3JTY2hlbWEsIFtpXSwgZXJyb3JTY2hlbWFbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChpID4gaW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQobmV3RXJyb3JTY2hlbWEsIFtpICsgMV0sIGVycm9yU2NoZW1hW2lkeF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0tleWVkRm9ybURhdGFSb3cgPSB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogZ2VuZXJhdGVSb3dJZCgpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtOiBjbG9uZURlZXAoa2V5ZWRGb3JtRGF0YVtpbmRleF0uaXRlbSksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdLZXllZEZvcm1EYXRhID0gWy4uLmtleWVkRm9ybURhdGFdO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0tleWVkRm9ybURhdGEuc3BsaWNlKGluZGV4ICsgMSwgMCwgbmV3S2V5ZWRGb3JtRGF0YVJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBuZXdLZXllZEZvcm1EYXRhLnB1c2gobmV3S2V5ZWRGb3JtRGF0YVJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICBrZXllZEZvcm1EYXRhOiBuZXdLZXllZEZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICB1cGRhdGVkS2V5ZWRGb3JtRGF0YTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9LCAoKSA9PiBvbkNoYW5nZShrZXllZFRvUGxhaW5Gb3JtRGF0YShuZXdLZXllZEZvcm1EYXRhKSwgbmV3RXJyb3JTY2hlbWEpKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDYWxsYmFjayBoYW5kbGVyIGZvciB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgcmVtb3ZlIGJ1dHRvbiBvbiBhbiBleGlzdGluZyBhcnJheSBlbGVtZW50LiBSZW1vdmVzIHRoZSByb3cgb2ZcbiAgICAgICAgICoga2V5ZWQgZm9ybSBkYXRhIGF0IHRoZSBgaW5kZXhgIGluIHRoZSBzdGF0ZSwgYW5kIHRoZW4gcmV0dXJuaW5nIGBvbkNoYW5nZSgpYCB3aXRoIHRoZSBwbGFpbiBmb3JtIGRhdGEgY29udmVydGVkXG4gICAgICAgICAqIGZyb20gdGhlIGtleWVkIGRhdGFcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IGF0IHdoaWNoIHRoZSByZW1vdmUgYnV0dG9uIGlzIGNsaWNrZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Ecm9wSW5kZXhDbGljayA9IChpbmRleCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCBlcnJvclNjaGVtYSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleWVkRm9ybURhdGEgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgLy8gcmVmcyAjMTk1OiByZXZhbGlkYXRlIHRvIGVuc3VyZSBwcm9wZXJseSByZWluZGV4aW5nIGVycm9yc1xuICAgICAgICAgICAgICAgIGxldCBuZXdFcnJvclNjaGVtYTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3JTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3RXJyb3JTY2hlbWEgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBpZHggaW4gZXJyb3JTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBwYXJzZUludChpZHgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChuZXdFcnJvclNjaGVtYSwgW2ldLCBlcnJvclNjaGVtYVtpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGkgPiBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChuZXdFcnJvclNjaGVtYSwgW2kgLSAxXSwgZXJyb3JTY2hlbWFbaWR4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3S2V5ZWRGb3JtRGF0YSA9IGtleWVkRm9ybURhdGEuZmlsdGVyKChfLCBpKSA9PiBpICE9PSBpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGtleWVkRm9ybURhdGE6IG5ld0tleWVkRm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZWRLZXllZEZvcm1EYXRhOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sICgpID0+IG9uQ2hhbmdlKGtleWVkVG9QbGFpbkZvcm1EYXRhKG5ld0tleWVkRm9ybURhdGEpLCBuZXdFcnJvclNjaGVtYSkpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIENhbGxiYWNrIGhhbmRsZXIgZm9yIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIG9uZSBvZiB0aGUgbW92ZSBpdGVtIGJ1dHRvbnMgb24gYW4gZXhpc3RpbmcgYXJyYXkgZWxlbWVudC4gTW92ZXMgdGhlXG4gICAgICAgICAqIHJvdyBvZiBrZXllZCBmb3JtIGRhdGEgYXQgdGhlIGBpbmRleGAgdG8gdGhlIGBuZXdJbmRleGAgaW4gdGhlIHN0YXRlLCBhbmQgdGhlbiByZXR1cm5pbmcgYG9uQ2hhbmdlKClgIHdpdGggdGhlXG4gICAgICAgICAqIHBsYWluIGZvcm0gZGF0YSBjb252ZXJ0ZWQgZnJvbSB0aGUga2V5ZWQgZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gdG8gbW92ZVxuICAgICAgICAgKiBAcGFyYW0gbmV3SW5kZXggLSBUaGUgaW5kZXggdG8gd2hlcmUgdGhlIGl0ZW0gaXMgdG8gYmUgbW92ZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25SZW9yZGVyQ2xpY2sgPSAoaW5kZXgsIG5ld0luZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmN1cnJlbnRUYXJnZXQuYmx1cigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCBlcnJvclNjaGVtYSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBsZXQgbmV3RXJyb3JTY2hlbWE7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Vycm9yU2NoZW1hID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGVycm9yU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpID0gcGFyc2VJbnQoaWR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpID09IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KG5ld0Vycm9yU2NoZW1hLCBbbmV3SW5kZXhdLCBlcnJvclNjaGVtYVtpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA9PSBuZXdJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChuZXdFcnJvclNjaGVtYSwgW2luZGV4XSwgZXJyb3JTY2hlbWFbbmV3SW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChuZXdFcnJvclNjaGVtYSwgW2lkeF0sIGVycm9yU2NoZW1hW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IGtleWVkRm9ybURhdGEgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVPcmRlckFycmF5KCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDb3B5IGl0ZW1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgX25ld0tleWVkRm9ybURhdGEgPSBrZXllZEZvcm1EYXRhLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vdmVzIGl0ZW0gZnJvbSBpbmRleCB0byBuZXdJbmRleFxuICAgICAgICAgICAgICAgICAgICBfbmV3S2V5ZWRGb3JtRGF0YS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBfbmV3S2V5ZWRGb3JtRGF0YS5zcGxpY2UobmV3SW5kZXgsIDAsIGtleWVkRm9ybURhdGFbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9uZXdLZXllZEZvcm1EYXRhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuZXdLZXllZEZvcm1EYXRhID0gcmVPcmRlckFycmF5KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGtleWVkRm9ybURhdGE6IG5ld0tleWVkRm9ybURhdGEsXG4gICAgICAgICAgICAgICAgfSwgKCkgPT4gb25DaGFuZ2Uoa2V5ZWRUb1BsYWluRm9ybURhdGEobmV3S2V5ZWRGb3JtRGF0YSksIG5ld0Vycm9yU2NoZW1hKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQ2FsbGJhY2sgaGFuZGxlciB1c2VkIHRvIGRlYWwgd2l0aCBjaGFuZ2luZyB0aGUgdmFsdWUgb2YgdGhlIGRhdGEgaW4gdGhlIGFycmF5IGF0IHRoZSBgaW5kZXhgLiBDYWxscyB0aGVcbiAgICAgICAgICogYG9uQ2hhbmdlYCBjYWxsYmFjayB3aXRoIHRoZSB1cGRhdGVkIGZvcm0gZGF0YVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGl0ZW0gYmVpbmcgY2hhbmdlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbkNoYW5nZUZvckluZGV4ID0gKGluZGV4KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKHZhbHVlLCBuZXdFcnJvclNjaGVtYSwgaWQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGZvcm1EYXRhLCBvbkNoYW5nZSwgZXJyb3JTY2hlbWEgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyYXlEYXRhID0gQXJyYXkuaXNBcnJheShmb3JtRGF0YSkgPyBmb3JtRGF0YSA6IFtdO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0Zvcm1EYXRhID0gYXJyYXlEYXRhLm1hcCgoaXRlbSwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHRyZWF0IHVuZGVmaW5lZCBpdGVtcyBhcyBudWxscyB0byBoYXZlIHZhbGlkYXRpb24uXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdGRlZ3J1bnQvanNvbnNjaGVtYS9pc3N1ZXMvMjA2XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpbmRleCA9PT0gaSA/IGpzb25WYWx1ZSA6IGl0ZW07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3Rm9ybURhdGEsIGVycm9yU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2NoZW1hICYmIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIFtpbmRleF06IG5ld0Vycm9yU2NoZW1hLFxuICAgICAgICAgICAgICAgIH0sIGlkKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBDYWxsYmFjayBoYW5kbGVyIHVzZWQgdG8gY2hhbmdlIHRoZSB2YWx1ZSBmb3IgYSBjaGVja2JveCAqL1xuICAgICAgICB0aGlzLm9uU2VsZWN0Q2hhbmdlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCBpZFNjaGVtYSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIG9uQ2hhbmdlKHZhbHVlLCB1bmRlZmluZWQsIGlkU2NoZW1hICYmIGlkU2NoZW1hLiRpZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgZm9ybURhdGEgPSBbXSB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IGtleWVkRm9ybURhdGEgPSBnZW5lcmF0ZUtleWVkRm9ybURhdGEoZm9ybURhdGEpO1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAga2V5ZWRGb3JtRGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZWRLZXllZEZvcm1EYXRhOiBmYWxzZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFJlYWN0IGxpZmVjeWNsZSBtZXRob2QgdGhhdCBpcyBjYWxsZWQgd2hlbiB0aGUgcHJvcHMgYXJlIGFib3V0IHRvIGNoYW5nZSBhbGxvd2luZyB0aGUgc3RhdGUgdG8gYmUgdXBkYXRlZC4gSXRcbiAgICAgKiByZWdlbmVyYXRlcyB0aGUga2V5ZWQgZm9ybSBkYXRhIGFuZCByZXR1cm5zIGl0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmV4dFByb3BzIC0gVGhlIG5leHQgc2V0IG9mIHByb3BzIGRhdGFcbiAgICAgKiBAcGFyYW0gcHJldlN0YXRlIC0gVGhlIHByZXZpb3VzIHNldCBvZiBzdGF0ZSBkYXRhXG4gICAgICovXG4gICAgc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICAvLyBEb24ndCBjYWxsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpZiBrZXllZCBmb3JtZGF0YSB3YXMganVzdCB1cGRhdGVkLlxuICAgICAgICBpZiAocHJldlN0YXRlLnVwZGF0ZWRLZXllZEZvcm1EYXRhKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZWRLZXllZEZvcm1EYXRhOiBmYWxzZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dEZvcm1EYXRhID0gQXJyYXkuaXNBcnJheShuZXh0UHJvcHMuZm9ybURhdGEpID8gbmV4dFByb3BzLmZvcm1EYXRhIDogW107XG4gICAgICAgIGNvbnN0IHByZXZpb3VzS2V5ZWRGb3JtRGF0YSA9IHByZXZTdGF0ZS5rZXllZEZvcm1EYXRhIHx8IFtdO1xuICAgICAgICBjb25zdCBuZXdLZXllZEZvcm1EYXRhID0gbmV4dEZvcm1EYXRhLmxlbmd0aCA9PT0gcHJldmlvdXNLZXllZEZvcm1EYXRhLmxlbmd0aFxuICAgICAgICAgICAgPyBwcmV2aW91c0tleWVkRm9ybURhdGEubWFwKChwcmV2aW91c0tleWVkRm9ybURhdHVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGtleTogcHJldmlvdXNLZXllZEZvcm1EYXR1bS5rZXksXG4gICAgICAgICAgICAgICAgICAgIGl0ZW06IG5leHRGb3JtRGF0YVtpbmRleF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICA6IGdlbmVyYXRlS2V5ZWRGb3JtRGF0YShuZXh0Rm9ybURhdGEpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5ZWRGb3JtRGF0YTogbmV3S2V5ZWRGb3JtRGF0YSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgdGhlIGFwcHJvcHJpYXRlIHRpdGxlIGZvciBhbiBpdGVtIGJ5IGdldHRpbmcgZmlyc3QgdGhlIHRpdGxlIGZyb20gdGhlIHNjaGVtYS5pdGVtcywgdGhlbiBmYWxsaW5nIGJhY2sgdG9cbiAgICAgKiB0aGUgZGVzY3JpcHRpb24gZnJvbSB0aGUgc2NoZW1hLml0ZW1zLCBhbmQgZmluYWxseSB0aGUgc3RyaW5nIFwiSXRlbVwiXG4gICAgICovXG4gICAgZ2V0IGl0ZW1UaXRsZSgpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHJlZ2lzdHJ5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHRyYW5zbGF0ZVN0cmluZyB9ID0gcmVnaXN0cnk7XG4gICAgICAgIHJldHVybiBnZXQoc2NoZW1hLCBbSVRFTVNfS0VZLCAndGl0bGUnXSwgZ2V0KHNjaGVtYSwgW0lURU1TX0tFWSwgJ2Rlc2NyaXB0aW9uJ10sIHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuQXJyYXlJdGVtVGl0bGUpKSk7XG4gICAgfVxuICAgIC8qKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGl0ZW0gZGVzY3JpYmVkIGluIHRoZSBzY2hlbWEgaXMgYWx3YXlzIHJlcXVpcmVkLCB3aGljaCBpcyBkZXRlcm1pbmVkIGJ5IHdoZXRoZXIgYW55IGl0ZW1cbiAgICAgKiBtYXkgYmUgbnVsbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpdGVtU2NoZW1hIC0gVGhlIHNjaGVtYSBmb3IgdGhlIGl0ZW1cbiAgICAgKiBAcmV0dXJuIC0gVHJ1ZSBpZiB0aGUgaXRlbSBzY2hlbWEgdHlwZSBkb2VzIG5vdCBjb250YWluIHRoZSBcIm51bGxcIiB0eXBlXG4gICAgICovXG4gICAgaXNJdGVtUmVxdWlyZWQoaXRlbVNjaGVtYSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtU2NoZW1hLnR5cGUpKSB7XG4gICAgICAgICAgICAvLyBXaGlsZSB3ZSBkb24ndCB5ZXQgc3VwcG9ydCBjb21wb3NpdGUvbnVsbGFibGUganNvbnNjaGVtYSB0eXBlcywgaXQnc1xuICAgICAgICAgICAgLy8gZnV0dXJlLXByb29mIHRvIGNoZWNrIGZvciByZXF1aXJlbWVudCBhZ2FpbnN0IHRoZXNlLlxuICAgICAgICAgICAgcmV0dXJuICFpdGVtU2NoZW1hLnR5cGUuaW5jbHVkZXMoJ251bGwnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbGwgbm9uLW51bGwgYXJyYXkgaXRlbSB0eXBlcyBhcmUgaW5oZXJlbnRseSByZXF1aXJlZCBieSBkZXNpZ25cbiAgICAgICAgcmV0dXJuIGl0ZW1TY2hlbWEudHlwZSAhPT0gJ251bGwnO1xuICAgIH1cbiAgICAvKiogRGV0ZXJtaW5lcyB3aGV0aGVyIG1vcmUgaXRlbXMgY2FuIGJlIGFkZGVkIHRvIHRoZSBhcnJheS4gSWYgdGhlIHVpU2NoZW1hIGluZGljYXRlcyB0aGUgYXJyYXkgZG9lc24ndCBhbGxvdyBhZGRpbmdcbiAgICAgKiB0aGVuIGZhbHNlIGlzIHJldHVybmVkLiBPdGhlcndpc2UsIGlmIHRoZSBzY2hlbWEgaW5kaWNhdGVzIHRoYXQgdGhlcmUgYXJlIGEgbWF4aW11bSBudW1iZXIgb2YgaXRlbXMgYW5kIHRoZVxuICAgICAqIGBmb3JtRGF0YWAgbWF0Y2hlcyB0aGF0IHZhbHVlLCB0aGVuIGZhbHNlIGlzIHJldHVybmVkLCBvdGhlcndpc2UgdHJ1ZSBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmb3JtSXRlbXMgLSBUaGUgbGlzdCBvZiBpdGVtcyBpbiB0aGUgZm9ybVxuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgaXRlbSBpcyBhZGRhYmxlIG90aGVyd2lzZSBmYWxzZVxuICAgICAqL1xuICAgIGNhbkFkZEl0ZW0oZm9ybUl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCB1aVNjaGVtYSwgcmVnaXN0cnkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGxldCB7IGFkZGFibGUgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgcmVnaXN0cnkuZ2xvYmFsVWlPcHRpb25zKTtcbiAgICAgICAgaWYgKGFkZGFibGUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAvLyBpZiB1aTpvcHRpb25zLmFkZGFibGUgd2FzIG5vdCBleHBsaWNpdGx5IHNldCB0byBmYWxzZSwgd2UgY2FuIGFkZFxuICAgICAgICAgICAgLy8gYW5vdGhlciBpdGVtIGlmIHdlIGhhdmUgbm90IGV4Y2VlZGVkIG1heEl0ZW1zIHlldFxuICAgICAgICAgICAgaWYgKHNjaGVtYS5tYXhJdGVtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWRkYWJsZSA9IGZvcm1JdGVtcy5sZW5ndGggPCBzY2hlbWEubWF4SXRlbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWRkYWJsZTtcbiAgICB9XG4gICAgLyoqIENhbGxiYWNrIGhhbmRsZXIgZm9yIHdoZW4gdGhlIHVzZXIgY2xpY2tzIG9uIHRoZSBhZGQgb3IgYWRkIGF0IGluZGV4IGJ1dHRvbnMuIENyZWF0ZXMgYSBuZXcgcm93IG9mIGtleWVkIGZvcm0gZGF0YVxuICAgICAqIGVpdGhlciBhdCB0aGUgZW5kIG9mIHRoZSBsaXN0ICh3aGVuIGluZGV4IGlzIG5vdCBzcGVjaWZpZWQpIG9yIGluc2VydGVkIGF0IHRoZSBgaW5kZXhgIHdoZW4gaXQgaXMsIGFkZGluZyBpdCBpbnRvXG4gICAgICogdGhlIHN0YXRlLCBhbmQgdGhlbiByZXR1cm5pbmcgYG9uQ2hhbmdlKClgIHdpdGggdGhlIHBsYWluIGZvcm0gZGF0YSBjb252ZXJ0ZWQgZnJvbSB0aGUga2V5ZWQgZGF0YVxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gVGhlIGV2ZW50IGZvciB0aGUgY2xpY2tcbiAgICAgKiBAcGFyYW0gW2luZGV4XSAtIFRoZSBvcHRpb25hbCBpbmRleCBhdCB3aGljaCB0byBhZGQgdGhlIG5ldyBkYXRhXG4gICAgICovXG4gICAgX2hhbmRsZUFkZENsaWNrKGV2ZW50LCBpbmRleCkge1xuICAgICAgICBpZiAoZXZlbnQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvbkNoYW5nZSwgZXJyb3JTY2hlbWEgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsga2V5ZWRGb3JtRGF0YSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgLy8gcmVmcyAjMTk1OiByZXZhbGlkYXRlIHRvIGVuc3VyZSBwcm9wZXJseSByZWluZGV4aW5nIGVycm9yc1xuICAgICAgICBsZXQgbmV3RXJyb3JTY2hlbWE7XG4gICAgICAgIGlmIChlcnJvclNjaGVtYSkge1xuICAgICAgICAgICAgbmV3RXJyb3JTY2hlbWEgPSB7fTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgaWR4IGluIGVycm9yU2NoZW1hKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaSA9IHBhcnNlSW50KGlkeCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHwgaSA8IGluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIHNldChuZXdFcnJvclNjaGVtYSwgW2ldLCBlcnJvclNjaGVtYVtpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaSA+PSBpbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBzZXQobmV3RXJyb3JTY2hlbWEsIFtpICsgMV0sIGVycm9yU2NoZW1hW2lkeF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdLZXllZEZvcm1EYXRhUm93ID0ge1xuICAgICAgICAgICAga2V5OiBnZW5lcmF0ZVJvd0lkKCksXG4gICAgICAgICAgICBpdGVtOiB0aGlzLl9nZXROZXdGb3JtRGF0YVJvdygpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXdLZXllZEZvcm1EYXRhID0gWy4uLmtleWVkRm9ybURhdGFdO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3S2V5ZWRGb3JtRGF0YS5zcGxpY2UoaW5kZXgsIDAsIG5ld0tleWVkRm9ybURhdGFSb3cpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbmV3S2V5ZWRGb3JtRGF0YS5wdXNoKG5ld0tleWVkRm9ybURhdGFSb3cpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgICAgICAga2V5ZWRGb3JtRGF0YTogbmV3S2V5ZWRGb3JtRGF0YSxcbiAgICAgICAgICAgIHVwZGF0ZWRLZXllZEZvcm1EYXRhOiB0cnVlLFxuICAgICAgICB9LCAoKSA9PiBvbkNoYW5nZShrZXllZFRvUGxhaW5Gb3JtRGF0YShuZXdLZXllZEZvcm1EYXRhKSwgbmV3RXJyb3JTY2hlbWEpKTtcbiAgICB9XG4gICAgLyoqIFJlbmRlcnMgdGhlIGBBcnJheUZpZWxkYCBkZXBlbmRpbmcgb24gdGhlIHNwZWNpZmljIG5lZWRzIG9mIHRoZSBzY2hlbWEgYW5kIHVpc2NoZW1hIGVsZW1lbnRzXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgdWlTY2hlbWEsIGlkU2NoZW1hLCByZWdpc3RyeSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzY2hlbWFVdGlscywgdHJhbnNsYXRlU3RyaW5nIH0gPSByZWdpc3RyeTtcbiAgICAgICAgaWYgKCEoSVRFTVNfS0VZIGluIHNjaGVtYSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHVpT3B0aW9ucyA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBVbnN1cHBvcnRlZEZpZWxkVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnVW5zdXBwb3J0ZWRGaWVsZFRlbXBsYXRlJywgcmVnaXN0cnksIHVpT3B0aW9ucyk7XG4gICAgICAgICAgICByZXR1cm4gKF9qc3goVW5zdXBwb3J0ZWRGaWVsZFRlbXBsYXRlLCB7IHNjaGVtYTogc2NoZW1hLCBpZFNjaGVtYTogaWRTY2hlbWEsIHJlYXNvbjogdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5NaXNzaW5nSXRlbXMpLCByZWdpc3RyeTogcmVnaXN0cnkgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY2hlbWFVdGlscy5pc011bHRpU2VsZWN0KHNjaGVtYSkpIHtcbiAgICAgICAgICAgIC8vIElmIGFycmF5IGhhcyBlbnVtIG9yIHVuaXF1ZUl0ZW1zIHNldCB0byB0cnVlLCBjYWxsIHJlbmRlck11bHRpU2VsZWN0KCkgdG8gcmVuZGVyIHRoZSBkZWZhdWx0IG11bHRpc2VsZWN0IHdpZGdldCBvciBhIGN1c3RvbSB3aWRnZXQsIGlmIHNwZWNpZmllZC5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbmRlck11bHRpU2VsZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQ3VzdG9tV2lkZ2V0KHVpU2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQ3VzdG9tV2lkZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzRml4ZWRJdGVtcyhzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJGaXhlZEFycmF5KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNjaGVtYVV0aWxzLmlzRmlsZXNBcnJheShzY2hlbWEsIHVpU2NoZW1hKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyRmlsZXMoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5yZW5kZXJOb3JtYWxBcnJheSgpO1xuICAgIH1cbiAgICAvKiogUmVuZGVycyBhIG5vcm1hbCBhcnJheSB3aXRob3V0IGFueSBsaW1pdGF0aW9ucyBvZiBsZW5ndGhcbiAgICAgKi9cbiAgICByZW5kZXJOb3JtYWxBcnJheSgpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHVpU2NoZW1hID0ge30sIGVycm9yU2NoZW1hLCBpZFNjaGVtYSwgbmFtZSwgZGlzYWJsZWQgPSBmYWxzZSwgcmVhZG9ubHkgPSBmYWxzZSwgYXV0b2ZvY3VzID0gZmFsc2UsIHJlcXVpcmVkID0gZmFsc2UsIHJlZ2lzdHJ5LCBvbkJsdXIsIG9uRm9jdXMsIGlkUHJlZml4LCBpZFNlcGFyYXRvciA9ICdfJywgcmF3RXJyb3JzLCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBrZXllZEZvcm1EYXRhIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB0aXRsZSA9IHNjaGVtYS50aXRsZSA9PT0gdW5kZWZpbmVkID8gbmFtZSA6IHNjaGVtYS50aXRsZTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWFVdGlscywgZm9ybUNvbnRleHQgfSA9IHJlZ2lzdHJ5O1xuICAgICAgICBjb25zdCB1aU9wdGlvbnMgPSBnZXRVaU9wdGlvbnModWlTY2hlbWEpO1xuICAgICAgICBjb25zdCBfc2NoZW1hSXRlbXMgPSBpc09iamVjdChzY2hlbWEuaXRlbXMpID8gc2NoZW1hLml0ZW1zIDoge307XG4gICAgICAgIGNvbnN0IGl0ZW1zU2NoZW1hID0gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEoX3NjaGVtYUl0ZW1zKTtcbiAgICAgICAgY29uc3QgZm9ybURhdGEgPSBrZXllZFRvUGxhaW5Gb3JtRGF0YSh0aGlzLnN0YXRlLmtleWVkRm9ybURhdGEpO1xuICAgICAgICBjb25zdCBjYW5BZGQgPSB0aGlzLmNhbkFkZEl0ZW0oZm9ybURhdGEpO1xuICAgICAgICBjb25zdCBhcnJheVByb3BzID0ge1xuICAgICAgICAgICAgY2FuQWRkLFxuICAgICAgICAgICAgaXRlbXM6IGtleWVkRm9ybURhdGEubWFwKChrZXllZEl0ZW0sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBrZXksIGl0ZW0gfSA9IGtleWVkSXRlbTtcbiAgICAgICAgICAgICAgICAvLyBXaGlsZSB3ZSBhcmUgYWN0dWFsbHkgZGVhbGluZyB3aXRoIGEgc2luZ2xlIGl0ZW0gb2YgdHlwZSBULCB0aGUgdHlwZXMgcmVxdWlyZSBhIFRbXSwgc28gY2FzdFxuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1DYXN0ID0gaXRlbTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEoX3NjaGVtYUl0ZW1zLCBpdGVtQ2FzdCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUVycm9yU2NoZW1hID0gZXJyb3JTY2hlbWEgPyBlcnJvclNjaGVtYVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlkUHJlZml4ID0gaWRTY2hlbWEuJGlkICsgaWRTZXBhcmF0b3IgKyBpbmRleDtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtSWRTY2hlbWEgPSBzY2hlbWFVdGlscy50b0lkU2NoZW1hKGl0ZW1TY2hlbWEsIGl0ZW1JZFByZWZpeCwgaXRlbUNhc3QsIGlkUHJlZml4LCBpZFNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQXJyYXlGaWVsZEl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICYmIGAke25hbWV9LSR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICAgICAgY2FuQWRkLFxuICAgICAgICAgICAgICAgICAgICBjYW5Nb3ZlVXA6IGluZGV4ID4gMCxcbiAgICAgICAgICAgICAgICAgICAgY2FuTW92ZURvd246IGluZGV4IDwgZm9ybURhdGEubGVuZ3RoIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbVNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1EYXRhOiBpdGVtQ2FzdCxcbiAgICAgICAgICAgICAgICAgICAgaXRlbVVpU2NoZW1hOiB1aVNjaGVtYS5pdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgYXV0b2ZvY3VzOiBhdXRvZm9jdXMgJiYgaW5kZXggPT09IDAsXG4gICAgICAgICAgICAgICAgICAgIG9uQmx1cixcbiAgICAgICAgICAgICAgICAgICAgb25Gb2N1cyxcbiAgICAgICAgICAgICAgICAgICAgcmF3RXJyb3JzLFxuICAgICAgICAgICAgICAgICAgICB0b3RhbEl0ZW1zOiBrZXllZEZvcm1EYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgY2xhc3NOYW1lOiBgZmllbGQgZmllbGQtYXJyYXkgZmllbGQtYXJyYXktb2YtJHtpdGVtc1NjaGVtYS50eXBlfWAsXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIGlkU2NoZW1hLFxuICAgICAgICAgICAgdWlTY2hlbWEsXG4gICAgICAgICAgICBvbkFkZENsaWNrOiB0aGlzLm9uQWRkQ2xpY2ssXG4gICAgICAgICAgICByZWFkb25seSxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBmb3JtQ29udGV4dCxcbiAgICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgICAgcmF3RXJyb3JzLFxuICAgICAgICAgICAgcmVnaXN0cnksXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0FycmF5RmllbGRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCB1aU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gX2pzeChUZW1wbGF0ZSwgeyAuLi5hcnJheVByb3BzIH0pO1xuICAgIH1cbiAgICAvKiogUmVuZGVycyBhbiBhcnJheSB1c2luZyB0aGUgY3VzdG9tIHdpZGdldCBwcm92aWRlZCBieSB0aGUgdXNlciBpbiB0aGUgYHVpU2NoZW1hYFxuICAgICAqL1xuICAgIHJlbmRlckN1c3RvbVdpZGdldCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCB7IHNjaGVtYSwgaWRTY2hlbWEsIHVpU2NoZW1hLCBkaXNhYmxlZCA9IGZhbHNlLCByZWFkb25seSA9IGZhbHNlLCBhdXRvZm9jdXMgPSBmYWxzZSwgcmVxdWlyZWQgPSBmYWxzZSwgaGlkZUVycm9yLCBwbGFjZWhvbGRlciwgb25CbHVyLCBvbkZvY3VzLCBmb3JtRGF0YTogaXRlbXMgPSBbXSwgcmVnaXN0cnksIHJhd0Vycm9ycywgbmFtZSwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsgd2lkZ2V0cywgZm9ybUNvbnRleHQsIGdsb2JhbFVpT3B0aW9ucywgc2NoZW1hVXRpbHMgfSA9IHJlZ2lzdHJ5O1xuICAgICAgICBjb25zdCB7IHdpZGdldCwgdGl0bGU6IHVpVGl0bGUsIC4uLm9wdGlvbnMgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgZ2xvYmFsVWlPcHRpb25zKTtcbiAgICAgICAgY29uc3QgV2lkZ2V0ID0gZ2V0V2lkZ2V0KHNjaGVtYSwgd2lkZ2V0LCB3aWRnZXRzKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSAoX2EgPSB1aVRpdGxlICE9PSBudWxsICYmIHVpVGl0bGUgIT09IHZvaWQgMCA/IHVpVGl0bGUgOiBzY2hlbWEudGl0bGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IG5hbWU7XG4gICAgICAgIGNvbnN0IGRpc3BsYXlMYWJlbCA9IHNjaGVtYVV0aWxzLmdldERpc3BsYXlMYWJlbChzY2hlbWEsIHVpU2NoZW1hLCBnbG9iYWxVaU9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gKF9qc3goV2lkZ2V0LCB7IGlkOiBpZFNjaGVtYS4kaWQsIG5hbWU6IG5hbWUsIG11bHRpcGxlOiB0cnVlLCBvbkNoYW5nZTogdGhpcy5vblNlbGVjdENoYW5nZSwgb25CbHVyOiBvbkJsdXIsIG9uRm9jdXM6IG9uRm9jdXMsIG9wdGlvbnM6IG9wdGlvbnMsIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSwgdmFsdWU6IGl0ZW1zLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgaGlkZUVycm9yOiBoaWRlRXJyb3IsIHJlcXVpcmVkOiByZXF1aXJlZCwgbGFiZWw6IGxhYmVsLCBoaWRlTGFiZWw6ICFkaXNwbGF5TGFiZWwsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgZm9ybUNvbnRleHQ6IGZvcm1Db250ZXh0LCBhdXRvZm9jdXM6IGF1dG9mb2N1cywgcmF3RXJyb3JzOiByYXdFcnJvcnMgfSkpO1xuICAgIH1cbiAgICAvKiogUmVuZGVycyBhbiBhcnJheSBhcyBhIHNldCBvZiBjaGVja2JveGVzXG4gICAgICovXG4gICAgcmVuZGVyTXVsdGlTZWxlY3QoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIGlkU2NoZW1hLCB1aVNjaGVtYSwgZm9ybURhdGE6IGl0ZW1zID0gW10sIGRpc2FibGVkID0gZmFsc2UsIHJlYWRvbmx5ID0gZmFsc2UsIGF1dG9mb2N1cyA9IGZhbHNlLCByZXF1aXJlZCA9IGZhbHNlLCBwbGFjZWhvbGRlciwgb25CbHVyLCBvbkZvY3VzLCByZWdpc3RyeSwgcmF3RXJyb3JzLCBuYW1lLCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyB3aWRnZXRzLCBzY2hlbWFVdGlscywgZm9ybUNvbnRleHQsIGdsb2JhbFVpT3B0aW9ucyB9ID0gcmVnaXN0cnk7XG4gICAgICAgIGNvbnN0IGl0ZW1zU2NoZW1hID0gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEoc2NoZW1hLml0ZW1zLCBpdGVtcyk7XG4gICAgICAgIGNvbnN0IGVudW1PcHRpb25zID0gb3B0aW9uc0xpc3QoaXRlbXNTY2hlbWEpO1xuICAgICAgICBjb25zdCB7IHdpZGdldCA9ICdzZWxlY3QnLCB0aXRsZTogdWlUaXRsZSwgLi4ub3B0aW9ucyB9ID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hLCBnbG9iYWxVaU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBXaWRnZXQgPSBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHdpZGdldHMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IChfYSA9IHVpVGl0bGUgIT09IG51bGwgJiYgdWlUaXRsZSAhPT0gdm9pZCAwID8gdWlUaXRsZSA6IHNjaGVtYS50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmFtZTtcbiAgICAgICAgY29uc3QgZGlzcGxheUxhYmVsID0gc2NoZW1hVXRpbHMuZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIGdsb2JhbFVpT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoX2pzeChXaWRnZXQsIHsgaWQ6IGlkU2NoZW1hLiRpZCwgbmFtZTogbmFtZSwgbXVsdGlwbGU6IHRydWUsIG9uQ2hhbmdlOiB0aGlzLm9uU2VsZWN0Q2hhbmdlLCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb25Gb2N1cywgb3B0aW9uczogeyAuLi5vcHRpb25zLCBlbnVtT3B0aW9ucyB9LCBzY2hlbWE6IHNjaGVtYSwgdWlTY2hlbWE6IHVpU2NoZW1hLCByZWdpc3RyeTogcmVnaXN0cnksIHZhbHVlOiBpdGVtcywgZGlzYWJsZWQ6IGRpc2FibGVkLCByZWFkb25seTogcmVhZG9ubHksIHJlcXVpcmVkOiByZXF1aXJlZCwgbGFiZWw6IGxhYmVsLCBoaWRlTGFiZWw6ICFkaXNwbGF5TGFiZWwsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgZm9ybUNvbnRleHQ6IGZvcm1Db250ZXh0LCBhdXRvZm9jdXM6IGF1dG9mb2N1cywgcmF3RXJyb3JzOiByYXdFcnJvcnMgfSkpO1xuICAgIH1cbiAgICAvKiogUmVuZGVycyBhbiBhcnJheSBvZiBmaWxlcyB1c2luZyB0aGUgYEZpbGVXaWRnZXRgXG4gICAgICovXG4gICAgcmVuZGVyRmlsZXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHVpU2NoZW1hLCBpZFNjaGVtYSwgbmFtZSwgZGlzYWJsZWQgPSBmYWxzZSwgcmVhZG9ubHkgPSBmYWxzZSwgYXV0b2ZvY3VzID0gZmFsc2UsIHJlcXVpcmVkID0gZmFsc2UsIG9uQmx1ciwgb25Gb2N1cywgcmVnaXN0cnksIGZvcm1EYXRhOiBpdGVtcyA9IFtdLCByYXdFcnJvcnMsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHdpZGdldHMsIGZvcm1Db250ZXh0LCBnbG9iYWxVaU9wdGlvbnMsIHNjaGVtYVV0aWxzIH0gPSByZWdpc3RyeTtcbiAgICAgICAgY29uc3QgeyB3aWRnZXQgPSAnZmlsZXMnLCB0aXRsZTogdWlUaXRsZSwgLi4ub3B0aW9ucyB9ID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hLCBnbG9iYWxVaU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBXaWRnZXQgPSBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHdpZGdldHMpO1xuICAgICAgICBjb25zdCBsYWJlbCA9IChfYSA9IHVpVGl0bGUgIT09IG51bGwgJiYgdWlUaXRsZSAhPT0gdm9pZCAwID8gdWlUaXRsZSA6IHNjaGVtYS50aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmFtZTtcbiAgICAgICAgY29uc3QgZGlzcGxheUxhYmVsID0gc2NoZW1hVXRpbHMuZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIGdsb2JhbFVpT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoX2pzeChXaWRnZXQsIHsgb3B0aW9uczogb3B0aW9ucywgaWQ6IGlkU2NoZW1hLiRpZCwgbmFtZTogbmFtZSwgbXVsdGlwbGU6IHRydWUsIG9uQ2hhbmdlOiB0aGlzLm9uU2VsZWN0Q2hhbmdlLCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb25Gb2N1cywgc2NoZW1hOiBzY2hlbWEsIHVpU2NoZW1hOiB1aVNjaGVtYSwgdmFsdWU6IGl0ZW1zLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgcmVxdWlyZWQ6IHJlcXVpcmVkLCByZWdpc3RyeTogcmVnaXN0cnksIGZvcm1Db250ZXh0OiBmb3JtQ29udGV4dCwgYXV0b2ZvY3VzOiBhdXRvZm9jdXMsIHJhd0Vycm9yczogcmF3RXJyb3JzLCBsYWJlbDogbGFiZWwsIGhpZGVMYWJlbDogIWRpc3BsYXlMYWJlbCB9KSk7XG4gICAgfVxuICAgIC8qKiBSZW5kZXJzIGFuIGFycmF5IHRoYXQgaGFzIGEgbWF4aW11bSBsaW1pdCBvZiBpdGVtc1xuICAgICAqL1xuICAgIHJlbmRlckZpeGVkQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hLCB1aVNjaGVtYSA9IHt9LCBmb3JtRGF0YSA9IFtdLCBlcnJvclNjaGVtYSwgaWRQcmVmaXgsIGlkU2VwYXJhdG9yID0gJ18nLCBpZFNjaGVtYSwgbmFtZSwgZGlzYWJsZWQgPSBmYWxzZSwgcmVhZG9ubHkgPSBmYWxzZSwgYXV0b2ZvY3VzID0gZmFsc2UsIHJlcXVpcmVkID0gZmFsc2UsIHJlZ2lzdHJ5LCBvbkJsdXIsIG9uRm9jdXMsIHJhd0Vycm9ycywgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHsga2V5ZWRGb3JtRGF0YSB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IHsgZm9ybURhdGE6IGl0ZW1zID0gW10gfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gc2NoZW1hLnRpdGxlIHx8IG5hbWU7XG4gICAgICAgIGNvbnN0IHVpT3B0aW9ucyA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSk7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hVXRpbHMsIGZvcm1Db250ZXh0IH0gPSByZWdpc3RyeTtcbiAgICAgICAgY29uc3QgX3NjaGVtYUl0ZW1zID0gaXNPYmplY3Qoc2NoZW1hLml0ZW1zKSA/IHNjaGVtYS5pdGVtcyA6IFtdO1xuICAgICAgICBjb25zdCBpdGVtU2NoZW1hcyA9IF9zY2hlbWFJdGVtcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiBzY2hlbWFVdGlscy5yZXRyaWV2ZVNjaGVtYShpdGVtLCBmb3JtRGF0YVtpbmRleF0pKTtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbFNjaGVtYSA9IGlzT2JqZWN0KHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMpXG4gICAgICAgICAgICA/IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKHNjaGVtYS5hZGRpdGlvbmFsSXRlbXMsIGZvcm1EYXRhKVxuICAgICAgICAgICAgOiBudWxsO1xuICAgICAgICBpZiAoIWl0ZW1zIHx8IGl0ZW1zLmxlbmd0aCA8IGl0ZW1TY2hlbWFzLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gdG8gbWFrZSBzdXJlIGF0IGxlYXN0IGFsbCBmaXhlZCBpdGVtcyBhcmUgZ2VuZXJhdGVkXG4gICAgICAgICAgICBpdGVtcyA9IGl0ZW1zIHx8IFtdO1xuICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQobmV3IEFycmF5KGl0ZW1TY2hlbWFzLmxlbmd0aCAtIGl0ZW1zLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZXNlIGFyZSB0aGUgcHJvcHMgcGFzc2VkIGludG8gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgICAgICBjb25zdCBjYW5BZGQgPSB0aGlzLmNhbkFkZEl0ZW0oaXRlbXMpICYmICEhYWRkaXRpb25hbFNjaGVtYTtcbiAgICAgICAgY29uc3QgYXJyYXlQcm9wcyA9IHtcbiAgICAgICAgICAgIGNhbkFkZCxcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ2ZpZWxkIGZpZWxkLWFycmF5IGZpZWxkLWFycmF5LWZpeGVkLWl0ZW1zJyxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgaWRTY2hlbWEsXG4gICAgICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgICAgIGl0ZW1zOiBrZXllZEZvcm1EYXRhLm1hcCgoa2V5ZWRJdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsga2V5LCBpdGVtIH0gPSBrZXllZEl0ZW07XG4gICAgICAgICAgICAgICAgLy8gV2hpbGUgd2UgYXJlIGFjdHVhbGx5IGRlYWxpbmcgd2l0aCBhIHNpbmdsZSBpdGVtIG9mIHR5cGUgVCwgdGhlIHR5cGVzIHJlcXVpcmUgYSBUW10sIHNvIGNhc3RcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtQ2FzdCA9IGl0ZW07XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkaXRpb25hbCA9IGluZGV4ID49IGl0ZW1TY2hlbWFzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtU2NoZW1hID0gKGFkZGl0aW9uYWwgJiYgaXNPYmplY3Qoc2NoZW1hLmFkZGl0aW9uYWxJdGVtcylcbiAgICAgICAgICAgICAgICAgICAgPyBzY2hlbWFVdGlscy5yZXRyaWV2ZVNjaGVtYShzY2hlbWEuYWRkaXRpb25hbEl0ZW1zLCBpdGVtQ2FzdClcbiAgICAgICAgICAgICAgICAgICAgOiBpdGVtU2NoZW1hc1tpbmRleF0pIHx8IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1JZFByZWZpeCA9IGlkU2NoZW1hLiRpZCArIGlkU2VwYXJhdG9yICsgaW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUlkU2NoZW1hID0gc2NoZW1hVXRpbHMudG9JZFNjaGVtYShpdGVtU2NoZW1hLCBpdGVtSWRQcmVmaXgsIGl0ZW1DYXN0LCBpZFByZWZpeCwgaWRTZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1VaVNjaGVtYSA9IGFkZGl0aW9uYWxcbiAgICAgICAgICAgICAgICAgICAgPyB1aVNjaGVtYS5hZGRpdGlvbmFsSXRlbXMgfHwge31cbiAgICAgICAgICAgICAgICAgICAgOiBBcnJheS5pc0FycmF5KHVpU2NoZW1hLml0ZW1zKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyB1aVNjaGVtYS5pdGVtc1tpbmRleF1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdWlTY2hlbWEuaXRlbXMgfHwge307XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbUVycm9yU2NoZW1hID0gZXJyb3JTY2hlbWEgPyBlcnJvclNjaGVtYVtpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyQXJyYXlGaWVsZEl0ZW0oe1xuICAgICAgICAgICAgICAgICAgICBrZXksXG4gICAgICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lICYmIGAke25hbWV9LSR7aW5kZXh9YCxcbiAgICAgICAgICAgICAgICAgICAgY2FuQWRkLFxuICAgICAgICAgICAgICAgICAgICBjYW5SZW1vdmU6IGFkZGl0aW9uYWwsXG4gICAgICAgICAgICAgICAgICAgIGNhbk1vdmVVcDogaW5kZXggPj0gaXRlbVNjaGVtYXMubGVuZ3RoICsgMSxcbiAgICAgICAgICAgICAgICAgICAgY2FuTW92ZURvd246IGFkZGl0aW9uYWwgJiYgaW5kZXggPCBpdGVtcy5sZW5ndGggLSAxLFxuICAgICAgICAgICAgICAgICAgICBpdGVtU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRGF0YTogaXRlbUNhc3QsXG4gICAgICAgICAgICAgICAgICAgIGl0ZW1VaVNjaGVtYSxcbiAgICAgICAgICAgICAgICAgICAgaXRlbUlkU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIGF1dG9mb2N1czogYXV0b2ZvY3VzICYmIGluZGV4ID09PSAwLFxuICAgICAgICAgICAgICAgICAgICBvbkJsdXIsXG4gICAgICAgICAgICAgICAgICAgIG9uRm9jdXMsXG4gICAgICAgICAgICAgICAgICAgIHJhd0Vycm9ycyxcbiAgICAgICAgICAgICAgICAgICAgdG90YWxJdGVtczoga2V5ZWRGb3JtRGF0YS5sZW5ndGgsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIG9uQWRkQ2xpY2s6IHRoaXMub25BZGRDbGljayxcbiAgICAgICAgICAgIHJlYWRvbmx5LFxuICAgICAgICAgICAgcmVxdWlyZWQsXG4gICAgICAgICAgICByZWdpc3RyeSxcbiAgICAgICAgICAgIHNjaGVtYSxcbiAgICAgICAgICAgIHVpU2NoZW1hLFxuICAgICAgICAgICAgdGl0bGUsXG4gICAgICAgICAgICBmb3JtQ29udGV4dCxcbiAgICAgICAgICAgIHJhd0Vycm9ycyxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnQXJyYXlGaWVsZFRlbXBsYXRlJywgcmVnaXN0cnksIHVpT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBfanN4KFRlbXBsYXRlLCB7IC4uLmFycmF5UHJvcHMgfSk7XG4gICAgfVxuICAgIC8qKiBSZW5kZXJzIHRoZSBpbmRpdmlkdWFsIGFycmF5IGl0ZW0gdXNpbmcgYSBgU2NoZW1hRmllbGRgIGFsb25nIHdpdGggdGhlIGFkZGl0aW9uYWwgcHJvcGVydGllcyByZXF1aXJlZCB0byBiZSBzZW5kXG4gICAgICogYmFjayB0byB0aGUgYEFycmF5RmllbGRJdGVtVGVtcGxhdGVgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHByb3BzIC0gVGhlIHByb3BzIGZvciB0aGUgaW5kaXZpZHVhbCBhcnJheSBpdGVtIHRvIGJlIHJlbmRlcmVkXG4gICAgICovXG4gICAgcmVuZGVyQXJyYXlGaWVsZEl0ZW0ocHJvcHMpIHtcbiAgICAgICAgY29uc3QgeyBrZXksIGluZGV4LCBuYW1lLCBjYW5BZGQsIGNhblJlbW92ZSA9IHRydWUsIGNhbk1vdmVVcCwgY2FuTW92ZURvd24sIGl0ZW1TY2hlbWEsIGl0ZW1EYXRhLCBpdGVtVWlTY2hlbWEsIGl0ZW1JZFNjaGVtYSwgaXRlbUVycm9yU2NoZW1hLCBhdXRvZm9jdXMsIG9uQmx1ciwgb25Gb2N1cywgcmF3RXJyb3JzLCB0b3RhbEl0ZW1zLCB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHsgZGlzYWJsZWQsIGhpZGVFcnJvciwgaWRQcmVmaXgsIGlkU2VwYXJhdG9yLCByZWFkb25seSwgdWlTY2hlbWEsIHJlZ2lzdHJ5LCBmb3JtQ29udGV4dCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBmaWVsZHM6IHsgQXJyYXlTY2hlbWFGaWVsZCwgU2NoZW1hRmllbGQgfSwgZ2xvYmFsVWlPcHRpb25zLCB9ID0gcmVnaXN0cnk7XG4gICAgICAgIGNvbnN0IEl0ZW1TY2hlbWFGaWVsZCA9IEFycmF5U2NoZW1hRmllbGQgfHwgU2NoZW1hRmllbGQ7XG4gICAgICAgIGNvbnN0IHsgb3JkZXJhYmxlID0gdHJ1ZSwgcmVtb3ZhYmxlID0gdHJ1ZSwgY29weWFibGUgPSBmYWxzZSB9ID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hLCBnbG9iYWxVaU9wdGlvbnMpO1xuICAgICAgICBjb25zdCBoYXMgPSB7XG4gICAgICAgICAgICBtb3ZlVXA6IG9yZGVyYWJsZSAmJiBjYW5Nb3ZlVXAsXG4gICAgICAgICAgICBtb3ZlRG93bjogb3JkZXJhYmxlICYmIGNhbk1vdmVEb3duLFxuICAgICAgICAgICAgY29weTogY29weWFibGUgJiYgY2FuQWRkLFxuICAgICAgICAgICAgcmVtb3ZlOiByZW1vdmFibGUgJiYgY2FuUmVtb3ZlLFxuICAgICAgICAgICAgdG9vbGJhcjogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIGhhcy50b29sYmFyID0gT2JqZWN0LmtleXMoaGFzKS5zb21lKChrZXkpID0+IGhhc1trZXldKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiAoX2pzeChJdGVtU2NoZW1hRmllbGQsIHsgbmFtZTogbmFtZSwgaW5kZXg6IGluZGV4LCBzY2hlbWE6IGl0ZW1TY2hlbWEsIHVpU2NoZW1hOiBpdGVtVWlTY2hlbWEsIGZvcm1EYXRhOiBpdGVtRGF0YSwgZm9ybUNvbnRleHQ6IGZvcm1Db250ZXh0LCBlcnJvclNjaGVtYTogaXRlbUVycm9yU2NoZW1hLCBpZFByZWZpeDogaWRQcmVmaXgsIGlkU2VwYXJhdG9yOiBpZFNlcGFyYXRvciwgaWRTY2hlbWE6IGl0ZW1JZFNjaGVtYSwgcmVxdWlyZWQ6IHRoaXMuaXNJdGVtUmVxdWlyZWQoaXRlbVNjaGVtYSksIG9uQ2hhbmdlOiB0aGlzLm9uQ2hhbmdlRm9ySW5kZXgoaW5kZXgpLCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb25Gb2N1cywgcmVnaXN0cnk6IHJlZ2lzdHJ5LCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgaGlkZUVycm9yOiBoaWRlRXJyb3IsIGF1dG9mb2N1czogYXV0b2ZvY3VzLCByYXdFcnJvcnM6IHJhd0Vycm9ycyB9KSksXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdhcnJheS1pdGVtJyxcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgY2FuQWRkLFxuICAgICAgICAgICAgaGFzQ29weTogaGFzLmNvcHksXG4gICAgICAgICAgICBoYXNUb29sYmFyOiBoYXMudG9vbGJhcixcbiAgICAgICAgICAgIGhhc01vdmVVcDogaGFzLm1vdmVVcCxcbiAgICAgICAgICAgIGhhc01vdmVEb3duOiBoYXMubW92ZURvd24sXG4gICAgICAgICAgICBoYXNSZW1vdmU6IGhhcy5yZW1vdmUsXG4gICAgICAgICAgICBpbmRleCxcbiAgICAgICAgICAgIHRvdGFsSXRlbXMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBvbkFkZEluZGV4Q2xpY2s6IHRoaXMub25BZGRJbmRleENsaWNrLFxuICAgICAgICAgICAgb25Db3B5SW5kZXhDbGljazogdGhpcy5vbkNvcHlJbmRleENsaWNrLFxuICAgICAgICAgICAgb25Ecm9wSW5kZXhDbGljazogdGhpcy5vbkRyb3BJbmRleENsaWNrLFxuICAgICAgICAgICAgb25SZW9yZGVyQ2xpY2s6IHRoaXMub25SZW9yZGVyQ2xpY2ssXG4gICAgICAgICAgICByZWFkb25seSxcbiAgICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICAgICAgc2NoZW1hOiBpdGVtU2NoZW1hLFxuICAgICAgICAgICAgdWlTY2hlbWE6IGl0ZW1VaVNjaGVtYSxcbiAgICAgICAgfTtcbiAgICB9XG59XG4vKiogYEFycmF5RmllbGRgIGlzIGBSZWFjdC5Db21wb25lbnRUeXBlPEZpZWxkUHJvcHM8VFtdLCBTLCBGPj5gIChuZWNlc3NhcmlseSkgYnV0IHRoZSBgcmVnaXN0cnlgIHJlcXVpcmVzIHRoaW5ncyB0byBiZSBhXG4gKiBgRmllbGRgIHdoaWNoIGlzIGRlZmluZWQgYXMgYFJlYWN0LkNvbXBvbmVudFR5cGU8RmllbGRQcm9wczxULCBTLCBGPj5gLCBzbyBjYXN0IGl0IHRvIG1ha2UgYHJlZ2lzdHJ5YCBoYXBweS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgQXJyYXlGaWVsZDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5RmllbGQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGdldFdpZGdldCwgZ2V0VWlPcHRpb25zLCBvcHRpb25zTGlzdCwgVHJhbnNsYXRhYmxlU3RyaW5nLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmltcG9ydCBpc09iamVjdCBmcm9tICdsb2Rhc2gvaXNPYmplY3QnO1xuLyoqIFRoZSBgQm9vbGVhbkZpZWxkYCBjb21wb25lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBmaWVsZCBpbiB0aGUgc2NoZW1hIGlzIGJvb2xlYW4uIEl0IGNvbnN0cnVjdHMgYGVudW1PcHRpb25zYCBmb3IgdGhlXG4gKiB0d28gYm9vbGVhbiB2YWx1ZXMgYmFzZWQgb24gdGhlIHZhcmlvdXMgYWx0ZXJuYXRpdmVzIGluIHRoZSBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBGaWVsZFByb3BzYCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiBCb29sZWFuRmllbGQocHJvcHMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgc2NoZW1hLCBuYW1lLCB1aVNjaGVtYSwgaWRTY2hlbWEsIGZvcm1EYXRhLCByZWdpc3RyeSwgcmVxdWlyZWQsIGRpc2FibGVkLCByZWFkb25seSwgaGlkZUVycm9yLCBhdXRvZm9jdXMsIG9uQ2hhbmdlLCBvbkZvY3VzLCBvbkJsdXIsIHJhd0Vycm9ycywgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdGl0bGUgfSA9IHNjaGVtYTtcbiAgICBjb25zdCB7IHdpZGdldHMsIGZvcm1Db250ZXh0LCB0cmFuc2xhdGVTdHJpbmcsIGdsb2JhbFVpT3B0aW9ucyB9ID0gcmVnaXN0cnk7XG4gICAgY29uc3QgeyB3aWRnZXQgPSAnY2hlY2tib3gnLCB0aXRsZTogdWlUaXRsZSwgXG4gICAgLy8gVW5saWtlIHRoZSBvdGhlciBmaWVsZHMsIGRvbid0IHVzZSBgZ2V0RGlzcGxheUxhYmVsKClgIHNpbmNlIGl0IGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciB0aGUgYm9vbGVhbiB0eXBlXG4gICAgbGFiZWw6IGRpc3BsYXlMYWJlbCA9IHRydWUsIC4uLm9wdGlvbnMgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgZ2xvYmFsVWlPcHRpb25zKTtcbiAgICBjb25zdCBXaWRnZXQgPSBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHdpZGdldHMpO1xuICAgIGNvbnN0IHllcyA9IHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuWWVzTGFiZWwpO1xuICAgIGNvbnN0IG5vID0gdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5Ob0xhYmVsKTtcbiAgICBsZXQgZW51bU9wdGlvbnM7XG4gICAgY29uc3QgbGFiZWwgPSAoX2EgPSB1aVRpdGxlICE9PSBudWxsICYmIHVpVGl0bGUgIT09IHZvaWQgMCA/IHVpVGl0bGUgOiB0aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmFtZTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEub25lT2YpKSB7XG4gICAgICAgIGVudW1PcHRpb25zID0gb3B0aW9uc0xpc3Qoe1xuICAgICAgICAgICAgb25lT2Y6IHNjaGVtYS5vbmVPZlxuICAgICAgICAgICAgICAgIC5tYXAoKG9wdGlvbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc09iamVjdChvcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogb3B0aW9uLnRpdGxlIHx8IChvcHRpb24uY29uc3QgPT09IHRydWUgPyB5ZXMgOiBubyksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG8pID0+IG8pLCAvLyBjYXN0IGF3YXkgdGhlIGVycm9yIHRoYXQgdHlwZXNjcmlwdCBjYW4ndCBncm9rIGlzIGZpeGVkXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gV2UgZGVwcmVjYXRlZCBlbnVtTmFtZXMgaW4gdjUuIEl0J3MgaW50ZW50aW9uYWxseSBvbWl0dGVkIGZyb20gUlNKRlNjaGVtYSB0eXBlLCBzbyB3ZSBuZWVkIHRvIGNhc3QgaGVyZS5cbiAgICAgICAgY29uc3Qgc2NoZW1hV2l0aEVudW1OYW1lcyA9IHNjaGVtYTtcbiAgICAgICAgY29uc3QgZW51bXMgPSAoX2IgPSBzY2hlbWEuZW51bSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogW3RydWUsIGZhbHNlXTtcbiAgICAgICAgaWYgKCFzY2hlbWFXaXRoRW51bU5hbWVzLmVudW1OYW1lcyAmJiBlbnVtcy5sZW5ndGggPT09IDIgJiYgZW51bXMuZXZlcnkoKHYpID0+IHR5cGVvZiB2ID09PSAnYm9vbGVhbicpKSB7XG4gICAgICAgICAgICBlbnVtT3B0aW9ucyA9IFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbnVtc1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGVudW1zWzBdID8geWVzIDogbm8sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBlbnVtc1sxXSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGVudW1zWzFdID8geWVzIDogbm8sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlbnVtT3B0aW9ucyA9IG9wdGlvbnNMaXN0KHtcbiAgICAgICAgICAgICAgICBlbnVtOiBlbnVtcyxcbiAgICAgICAgICAgICAgICAvLyBOT1RFOiBlbnVtTmFtZXMgaXMgZGVwcmVjYXRlZCwgYnV0IHN0aWxsIHN1cHBvcnRlZCBmb3Igbm93LlxuICAgICAgICAgICAgICAgIGVudW1OYW1lczogc2NoZW1hV2l0aEVudW1OYW1lcy5lbnVtTmFtZXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKF9qc3goV2lkZ2V0LCB7IG9wdGlvbnM6IHsgLi4ub3B0aW9ucywgZW51bU9wdGlvbnMgfSwgc2NoZW1hOiBzY2hlbWEsIHVpU2NoZW1hOiB1aVNjaGVtYSwgaWQ6IGlkU2NoZW1hLiRpZCwgbmFtZTogbmFtZSwgb25DaGFuZ2U6IG9uQ2hhbmdlLCBvbkZvY3VzOiBvbkZvY3VzLCBvbkJsdXI6IG9uQmx1ciwgbGFiZWw6IGxhYmVsLCBoaWRlTGFiZWw6ICFkaXNwbGF5TGFiZWwsIHZhbHVlOiBmb3JtRGF0YSwgcmVxdWlyZWQ6IHJlcXVpcmVkLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgaGlkZUVycm9yOiBoaWRlRXJyb3IsIHJlZ2lzdHJ5OiByZWdpc3RyeSwgZm9ybUNvbnRleHQ6IGZvcm1Db250ZXh0LCBhdXRvZm9jdXM6IGF1dG9mb2N1cywgcmF3RXJyb3JzOiByYXdFcnJvcnMgfSkpO1xufVxuZXhwb3J0IGRlZmF1bHQgQm9vbGVhbkZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Qm9vbGVhbkZpZWxkLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgZ2V0IGZyb20gJ2xvZGFzaC9nZXQnO1xuaW1wb3J0IGlzRW1wdHkgZnJvbSAnbG9kYXNoL2lzRW1wdHknO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoL29taXQnO1xuaW1wb3J0IHsgZGVlcEVxdWFscywgRVJST1JTX0tFWSwgZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYSwgZ2V0VWlPcHRpb25zLCBnZXRXaWRnZXQsIG1lcmdlU2NoZW1hcywgVHJhbnNsYXRhYmxlU3RyaW5nLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYEFueU9mRmllbGRgIGNvbXBvbmVudCBpcyB1c2VkIHRvIHJlbmRlciBhIGZpZWxkIGluIHRoZSBzY2hlbWEgdGhhdCBpcyBhbiBgYW55T2ZgLCBgYWxsT2ZgIG9yIGBvbmVPZmAuIEl0IHRyYWNrc1xuICogdGhlIGN1cnJlbnRseSBzZWxlY3RlZCBvcHRpb24gYW5kIGNsZWFucyB1cCBhbnkgaXJyZWxldmFudCBkYXRhIGluIGBmb3JtRGF0YWAuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBGaWVsZFByb3BzYCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICovXG5jbGFzcyBBbnlPZkZpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICAvKiogQ29uc3RydWN0cyBhbiBgQW55T2ZGaWVsZGAgd2l0aCB0aGUgZ2l2ZW4gYHByb3BzYCB0byBpbml0aWFsaXplIHRoZSBpbml0aWFsbHkgc2VsZWN0ZWQgb3B0aW9uIGluIHN0YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEZpZWxkUHJvcHNgIGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocHJvcHMpIHtcbiAgICAgICAgc3VwZXIocHJvcHMpO1xuICAgICAgICAvKiogQ2FsbGJhY2sgaGFuZGxlciB0byByZW1lbWJlciB3aGF0IHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uIGlzLiBJbiBhZGRpdGlvbiB0byB0aGF0IHRoZSBgZm9ybURhdGFgIGlzIHVwZGF0ZWRcbiAgICAgICAgICogdG8gcmVtb3ZlIHByb3BlcnRpZXMgdGhhdCBhcmUgbm90IHBhcnQgb2YgdGhlIG5ld2x5IHNlbGVjdGVkIG9wdGlvbiBzY2hlbWEsIGFuZCB0aGVuIHRoZSB1cGRhdGVkIGRhdGEgaXMgcGFzc2VkIHRvXG4gICAgICAgICAqIHRoZSBgb25DaGFuZ2VgIGhhbmRsZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBvcHRpb24gLSBUaGUgbmV3IG9wdGlvbiB2YWx1ZSBiZWluZyBzZWxlY3RlZFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vbk9wdGlvbkNoYW5nZSA9IChvcHRpb24pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2VsZWN0ZWRPcHRpb24sIHJldHJpZXZlZE9wdGlvbnMgfSA9IHRoaXMuc3RhdGU7XG4gICAgICAgICAgICBjb25zdCB7IGZvcm1EYXRhLCBvbkNoYW5nZSwgcmVnaXN0cnkgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgICAgICBjb25zdCB7IHNjaGVtYVV0aWxzIH0gPSByZWdpc3RyeTtcbiAgICAgICAgICAgIGNvbnN0IGludE9wdGlvbiA9IG9wdGlvbiAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQob3B0aW9uLCAxMCkgOiAtMTtcbiAgICAgICAgICAgIGlmIChpbnRPcHRpb24gPT09IHNlbGVjdGVkT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3T3B0aW9uID0gaW50T3B0aW9uID49IDAgPyByZXRyaWV2ZWRPcHRpb25zW2ludE9wdGlvbl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBvbGRPcHRpb24gPSBzZWxlY3RlZE9wdGlvbiA+PSAwID8gcmV0cmlldmVkT3B0aW9uc1tzZWxlY3RlZE9wdGlvbl0gOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsZXQgbmV3Rm9ybURhdGEgPSBzY2hlbWFVdGlscy5zYW5pdGl6ZURhdGFGb3JOZXdTY2hlbWEobmV3T3B0aW9uLCBvbGRPcHRpb24sIGZvcm1EYXRhKTtcbiAgICAgICAgICAgIGlmIChuZXdGb3JtRGF0YSAmJiBuZXdPcHRpb24pIHtcbiAgICAgICAgICAgICAgICAvLyBDYWxsIGdldERlZmF1bHRGb3JtU3RhdGUgdG8gbWFrZSBzdXJlIGRlZmF1bHRzIGFyZSBwb3B1bGF0ZWQgb24gY2hhbmdlLiBQYXNzIFwiZXhjbHVkZU9iamVjdENoaWxkcmVuXCJcbiAgICAgICAgICAgICAgICAvLyBzbyB0aGF0IG9ubHkgdGhlIHJvb3Qgb2JqZWN0cyB0aGVtc2VsdmVzIGFyZSBjcmVhdGVkIHdpdGhvdXQgYWRkaW5nIHVuZGVmaW5lZCBjaGlsZHJlbiBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgbmV3Rm9ybURhdGEgPSBzY2hlbWFVdGlscy5nZXREZWZhdWx0Rm9ybVN0YXRlKG5ld09wdGlvbiwgbmV3Rm9ybURhdGEsICdleGNsdWRlT2JqZWN0Q2hpbGRyZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0Zvcm1EYXRhLCB1bmRlZmluZWQsIHRoaXMuZ2V0RmllbGRJZCgpKTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoeyBzZWxlY3RlZE9wdGlvbjogaW50T3B0aW9uIH0pO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGZvcm1EYXRhLCBvcHRpb25zLCByZWdpc3RyeTogeyBzY2hlbWFVdGlscyB9LCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgLy8gY2FjaGUgdGhlIHJldHJpZXZlZCBvcHRpb25zIGluIHN0YXRlIGluIGNhc2UgdGhleSBoYXZlICRyZWZzIHRvIHNhdmUgZG9pbmcgaXQgbGF0ZXJcbiAgICAgICAgY29uc3QgcmV0cmlldmVkT3B0aW9ucyA9IG9wdGlvbnMubWFwKChvcHQpID0+IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKG9wdCwgZm9ybURhdGEpKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgICAgIHJldHJpZXZlZE9wdGlvbnMsXG4gICAgICAgICAgICBzZWxlY3RlZE9wdGlvbjogdGhpcy5nZXRNYXRjaGluZ09wdGlvbigwLCBmb3JtRGF0YSwgcmV0cmlldmVkT3B0aW9ucyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKiBSZWFjdCBsaWZlY3ljbGUgbWV0aG9kIHRoYXQgaXMgY2FsbGVkIHdoZW4gdGhlIHByb3BzIGFuZC9vciBzdGF0ZSBmb3IgdGhpcyBjb21wb25lbnQgaXMgdXBkYXRlZC4gSXQgcmVjb21wdXRlcyB0aGVcbiAgICAgKiBjdXJyZW50bHkgc2VsZWN0ZWQgb3B0aW9uIGJhc2VkIG9uIHRoZSBvdmVyYWxsIGBmb3JtRGF0YWBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwcmV2UHJvcHMgLSBUaGUgcHJldmlvdXMgYEZpZWxkUHJvcHNgIGZvciB0aGlzIHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHByZXZTdGF0ZSAtIFRoZSBwcmV2aW91cyBgQW55T2ZGaWVsZFN0YXRlYCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICAgICAqL1xuICAgIGNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSkge1xuICAgICAgICBjb25zdCB7IGZvcm1EYXRhLCBvcHRpb25zLCBpZFNjaGVtYSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBzZWxlY3RlZE9wdGlvbiB9ID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgbGV0IG5ld1N0YXRlID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKCFkZWVwRXF1YWxzKHByZXZQcm9wcy5vcHRpb25zLCBvcHRpb25zKSkge1xuICAgICAgICAgICAgY29uc3QgeyByZWdpc3RyeTogeyBzY2hlbWFVdGlscyB9LCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIC8vIHJlLWNhY2hlIHRoZSByZXRyaWV2ZWQgb3B0aW9ucyBpbiBzdGF0ZSBpbiBjYXNlIHRoZXkgaGF2ZSAkcmVmcyB0byBzYXZlIGRvaW5nIGl0IGxhdGVyXG4gICAgICAgICAgICBjb25zdCByZXRyaWV2ZWRPcHRpb25zID0gb3B0aW9ucy5tYXAoKG9wdCkgPT4gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEob3B0LCBmb3JtRGF0YSkpO1xuICAgICAgICAgICAgbmV3U3RhdGUgPSB7IHNlbGVjdGVkT3B0aW9uLCByZXRyaWV2ZWRPcHRpb25zIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWVwRXF1YWxzKGZvcm1EYXRhLCBwcmV2UHJvcHMuZm9ybURhdGEpICYmIGlkU2NoZW1hLiRpZCA9PT0gcHJldlByb3BzLmlkU2NoZW1hLiRpZCkge1xuICAgICAgICAgICAgY29uc3QgeyByZXRyaWV2ZWRPcHRpb25zIH0gPSBuZXdTdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nT3B0aW9uID0gdGhpcy5nZXRNYXRjaGluZ09wdGlvbihzZWxlY3RlZE9wdGlvbiwgZm9ybURhdGEsIHJldHJpZXZlZE9wdGlvbnMpO1xuICAgICAgICAgICAgaWYgKHByZXZTdGF0ZSAmJiBtYXRjaGluZ09wdGlvbiAhPT0gc2VsZWN0ZWRPcHRpb24pIHtcbiAgICAgICAgICAgICAgICBuZXdTdGF0ZSA9IHsgc2VsZWN0ZWRPcHRpb246IG1hdGNoaW5nT3B0aW9uLCByZXRyaWV2ZWRPcHRpb25zIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKG5ld1N0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogRGV0ZXJtaW5lcyB0aGUgYmVzdCBtYXRjaGluZyBvcHRpb24gZm9yIHRoZSBnaXZlbiBgZm9ybURhdGFgIGFuZCBgb3B0aW9uc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZm9ybURhdGEgLSBUaGUgbmV3IGZvcm1EYXRhXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgbGlzdCBvZiBvcHRpb25zIHRvIGNob29zZSBmcm9tXG4gICAgICogQHJldHVybiAtIFRoZSBpbmRleCBvZiB0aGUgYG9wdGlvbmAgdGhhdCBiZXN0IG1hdGNoZXMgdGhlIGBmb3JtRGF0YWBcbiAgICAgKi9cbiAgICBnZXRNYXRjaGluZ09wdGlvbihzZWxlY3RlZE9wdGlvbiwgZm9ybURhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEsIHJlZ2lzdHJ5OiB7IHNjaGVtYVV0aWxzIH0sIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBkaXNjcmltaW5hdG9yID0gZ2V0RGlzY3JpbWluYXRvckZpZWxkRnJvbVNjaGVtYShzY2hlbWEpO1xuICAgICAgICBjb25zdCBvcHRpb24gPSBzY2hlbWFVdGlscy5nZXRDbG9zZXN0TWF0Y2hpbmdPcHRpb24oZm9ybURhdGEsIG9wdGlvbnMsIHNlbGVjdGVkT3B0aW9uLCBkaXNjcmltaW5hdG9yKTtcbiAgICAgICAgcmV0dXJuIG9wdGlvbjtcbiAgICB9XG4gICAgZ2V0RmllbGRJZCgpIHtcbiAgICAgICAgY29uc3QgeyBpZFNjaGVtYSwgc2NoZW1hIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICByZXR1cm4gYCR7aWRTY2hlbWEuJGlkfSR7c2NoZW1hLm9uZU9mID8gJ19fb25lb2Zfc2VsZWN0JyA6ICdfX2FueW9mX3NlbGVjdCd9YDtcbiAgICB9XG4gICAgLyoqIFJlbmRlcnMgdGhlIGBBbnlPZkZpZWxkYCBzZWxlY3RvciBhbG9uZyB3aXRoIGEgYFNjaGVtYUZpZWxkYCBmb3IgdGhlIHZhbHVlIG9mIHRoZSBgZm9ybURhdGFgXG4gICAgICovXG4gICAgcmVuZGVyKCkge1xuICAgICAgICBjb25zdCB7IG5hbWUsIGRpc2FibGVkID0gZmFsc2UsIGVycm9yU2NoZW1hID0ge30sIGZvcm1Db250ZXh0LCBvbkJsdXIsIG9uRm9jdXMsIHJlZ2lzdHJ5LCBzY2hlbWEsIHVpU2NoZW1hLCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyB3aWRnZXRzLCBmaWVsZHMsIHRyYW5zbGF0ZVN0cmluZywgZ2xvYmFsVWlPcHRpb25zLCBzY2hlbWFVdGlscyB9ID0gcmVnaXN0cnk7XG4gICAgICAgIGNvbnN0IHsgU2NoZW1hRmllbGQ6IF9TY2hlbWFGaWVsZCB9ID0gZmllbGRzO1xuICAgICAgICBjb25zdCB7IHNlbGVjdGVkT3B0aW9uLCByZXRyaWV2ZWRPcHRpb25zIH0gPSB0aGlzLnN0YXRlO1xuICAgICAgICBjb25zdCB7IHdpZGdldCA9ICdzZWxlY3QnLCBwbGFjZWhvbGRlciwgYXV0b2ZvY3VzLCBhdXRvY29tcGxldGUsIHRpdGxlID0gc2NoZW1hLnRpdGxlLCAuLi51aU9wdGlvbnMgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgZ2xvYmFsVWlPcHRpb25zKTtcbiAgICAgICAgY29uc3QgV2lkZ2V0ID0gZ2V0V2lkZ2V0KHsgdHlwZTogJ251bWJlcicgfSwgd2lkZ2V0LCB3aWRnZXRzKTtcbiAgICAgICAgY29uc3QgcmF3RXJyb3JzID0gZ2V0KGVycm9yU2NoZW1hLCBFUlJPUlNfS0VZLCBbXSk7XG4gICAgICAgIGNvbnN0IGZpZWxkRXJyb3JTY2hlbWEgPSBvbWl0KGVycm9yU2NoZW1hLCBbRVJST1JTX0tFWV0pO1xuICAgICAgICBjb25zdCBkaXNwbGF5TGFiZWwgPSBzY2hlbWFVdGlscy5nZXREaXNwbGF5TGFiZWwoc2NoZW1hLCB1aVNjaGVtYSwgZ2xvYmFsVWlPcHRpb25zKTtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0ZWRPcHRpb24gPj0gMCA/IHJldHJpZXZlZE9wdGlvbnNbc2VsZWN0ZWRPcHRpb25dIHx8IG51bGwgOiBudWxsO1xuICAgICAgICBsZXQgb3B0aW9uU2NoZW1hO1xuICAgICAgICBpZiAob3B0aW9uKSB7XG4gICAgICAgICAgICAvLyBtZXJnZSB0b3AgbGV2ZWwgcmVxdWlyZWQgZmllbGRcbiAgICAgICAgICAgIGNvbnN0IHsgcmVxdWlyZWQgfSA9IHNjaGVtYTtcbiAgICAgICAgICAgIC8vIE1lcmdlIGluIGFsbCB0aGUgbm9uLW9uZU9mL2FueU9mIHByb3BlcnRpZXMgYW5kIGFsc28gc2tpcCB0aGUgc3BlY2lhbCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcgcHJvcGVydHlcbiAgICAgICAgICAgIG9wdGlvblNjaGVtYSA9IHJlcXVpcmVkID8gbWVyZ2VTY2hlbWFzKHsgcmVxdWlyZWQgfSwgb3B0aW9uKSA6IG9wdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2xhdGVFbnVtID0gdGl0bGVcbiAgICAgICAgICAgID8gVHJhbnNsYXRhYmxlU3RyaW5nLlRpdGxlT3B0aW9uUHJlZml4XG4gICAgICAgICAgICA6IFRyYW5zbGF0YWJsZVN0cmluZy5PcHRpb25QcmVmaXg7XG4gICAgICAgIGNvbnN0IHRyYW5zbGF0ZVBhcmFtcyA9IHRpdGxlID8gW3RpdGxlXSA6IFtdO1xuICAgICAgICBjb25zdCBlbnVtT3B0aW9ucyA9IHJldHJpZXZlZE9wdGlvbnMubWFwKChvcHQsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgbGFiZWw6IG9wdC50aXRsZSB8fCB0cmFuc2xhdGVTdHJpbmcodHJhbnNsYXRlRW51bSwgdHJhbnNsYXRlUGFyYW1zLmNvbmNhdChTdHJpbmcoaW5kZXggKyAxKSkpLFxuICAgICAgICAgICAgdmFsdWU6IGluZGV4LFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybiAoX2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdwYW5lbCBwYW5lbC1kZWZhdWx0IHBhbmVsLWJvZHknLCBjaGlsZHJlbjogW19qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6ICdmb3JtLWdyb3VwJywgY2hpbGRyZW46IF9qc3goV2lkZ2V0LCB7IGlkOiB0aGlzLmdldEZpZWxkSWQoKSwgbmFtZTogYCR7bmFtZX0ke3NjaGVtYS5vbmVPZiA/ICdfX29uZW9mX3NlbGVjdCcgOiAnX19hbnlvZl9zZWxlY3QnfWAsIHNjaGVtYTogeyB0eXBlOiAnbnVtYmVyJywgZGVmYXVsdDogMCB9LCBvbkNoYW5nZTogdGhpcy5vbk9wdGlvbkNoYW5nZSwgb25CbHVyOiBvbkJsdXIsIG9uRm9jdXM6IG9uRm9jdXMsIGRpc2FibGVkOiBkaXNhYmxlZCB8fCBpc0VtcHR5KGVudW1PcHRpb25zKSwgbXVsdGlwbGU6IGZhbHNlLCByYXdFcnJvcnM6IHJhd0Vycm9ycywgZXJyb3JTY2hlbWE6IGZpZWxkRXJyb3JTY2hlbWEsIHZhbHVlOiBzZWxlY3RlZE9wdGlvbiA+PSAwID8gc2VsZWN0ZWRPcHRpb24gOiB1bmRlZmluZWQsIG9wdGlvbnM6IHsgZW51bU9wdGlvbnMsIC4uLnVpT3B0aW9ucyB9LCByZWdpc3RyeTogcmVnaXN0cnksIGZvcm1Db250ZXh0OiBmb3JtQ29udGV4dCwgcGxhY2Vob2xkZXI6IHBsYWNlaG9sZGVyLCBhdXRvY29tcGxldGU6IGF1dG9jb21wbGV0ZSwgYXV0b2ZvY3VzOiBhdXRvZm9jdXMsIGxhYmVsOiB0aXRsZSAhPT0gbnVsbCAmJiB0aXRsZSAhPT0gdm9pZCAwID8gdGl0bGUgOiBuYW1lLCBoaWRlTGFiZWw6ICFkaXNwbGF5TGFiZWwgfSkgfSksIG9wdGlvbiAhPT0gbnVsbCAmJiBfanN4KF9TY2hlbWFGaWVsZCwgeyAuLi50aGlzLnByb3BzLCBzY2hlbWE6IG9wdGlvblNjaGVtYSB9KV0gfSkpO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IEFueU9mRmllbGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1NdWx0aVNjaGVtYUZpZWxkLmpzLm1hcCIsImltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0Jztcbi8qKiBUaGUgYE51bGxGaWVsZGAgY29tcG9uZW50IGlzIHVzZWQgdG8gcmVuZGVyIGEgZmllbGQgaW4gdGhlIHNjaGVtYSBpcyBudWxsLiBJdCBhbHNvIGVuc3VyZXMgdGhhdCB0aGUgYGZvcm1EYXRhYCBpc1xuICogYWxzbyBzZXQgdG8gbnVsbCBpZiBpdCBoYXMgbm8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBGaWVsZFByb3BzYCBmb3IgdGhpcyB0ZW1wbGF0ZVxuICovXG5mdW5jdGlvbiBOdWxsRmllbGQocHJvcHMpIHtcbiAgICBjb25zdCB7IGZvcm1EYXRhLCBvbkNoYW5nZSB9ID0gcHJvcHM7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGZvcm1EYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlKG51bGwpO1xuICAgICAgICB9XG4gICAgfSwgW2Zvcm1EYXRhLCBvbkNoYW5nZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGRlZmF1bHQgTnVsbEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVsbEZpZWxkLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhc051bWJlciB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8vIE1hdGNoZXMgYSBzdHJpbmcgdGhhdCBlbmRzIGluIGEgLiBjaGFyYWN0ZXIsIG9wdGlvbmFsbHkgZm9sbG93ZWQgYnkgYSBzZXF1ZW5jZSBvZlxuLy8gZGlnaXRzIGZvbGxvd2VkIGJ5IGFueSBudW1iZXIgb2YgMCBjaGFyYWN0ZXJzIHVwIHVudGlsIHRoZSBlbmQgb2YgdGhlIGxpbmUuXG4vLyBFbnN1cmluZyB0aGF0IHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwcmVmaXhlZCBjaGFyYWN0ZXIgaXMgaW1wb3J0YW50IHNvIHRoYXRcbi8vIHlvdSBkb24ndCBpbmNvcnJlY3RseSBtYXRjaCBhZ2FpbnN0IFwiMFwiLlxuY29uc3QgdHJhaWxpbmdDaGFyTWF0Y2hlcldpdGhQcmVmaXggPSAvXFwuKFswLTldKjApKiQvO1xuLy8gVGhpcyBpcyB1c2VkIGZvciB0cmltbWluZyB0aGUgdHJhaWxpbmcgMCBhbmQgLiBjaGFyYWN0ZXJzIHdpdGhvdXQgYWZmZWN0aW5nXG4vLyB0aGUgcmVzdCBvZiB0aGUgc3RyaW5nLiBJdHMgcG9zc2libGUgdG8gdXNlIG9uZSBSZWdFeCB3aXRoIGdyb3VwcyBmb3IgdGhpc1xuLy8gZnVuY3Rpb25hbGl0eSwgYnV0IGl0IGlzIGZhaXJseSBjb21wbGV4IGNvbXBhcmVkIHRvIHNpbXBseSBkZWZpbmluZyB0d29cbi8vIGRpZmZlcmVudCBtYXRjaGVycy5cbmNvbnN0IHRyYWlsaW5nQ2hhck1hdGNoZXIgPSAvWzAuXTAqJC87XG4vKipcbiAqIFRoZSBOdW1iZXJGaWVsZCBjbGFzcyBoYXMgc29tZSBzcGVjaWFsIGhhbmRsaW5nIGZvciBkZWFsaW5nIHdpdGggdHJhaWxpbmdcbiAqIGRlY2ltYWwgcG9pbnRzIGFuZC9vciB6ZXJvZXMuIFRoaXMgbG9naWMgaXMgZGVzaWduZWQgdG8gYWxsb3cgdHJhaWxpbmcgdmFsdWVzXG4gKiB0byBiZSB2aXNpYmxlIGluIHRoZSBpbnB1dCBlbGVtZW50LCBidXQgbm90IGJlIHJlcHJlc2VudGVkIGluIHRoZVxuICogY29ycmVzcG9uZGluZyBmb3JtIGRhdGEuXG4gKlxuICogVGhlIGFsZ29yaXRobSBpcyBhcyBmb2xsb3dzOlxuICpcbiAqIDEuIFdoZW4gdGhlIGlucHV0IHZhbHVlIGNoYW5nZXMgdGhlIHZhbHVlIGlzIGNhY2hlZCBpbiB0aGUgY29tcG9uZW50IHN0YXRlXG4gKlxuICogMi4gVGhlIHZhbHVlIGlzIHRoZW4gbm9ybWFsaXplZCwgcmVtb3ZpbmcgdHJhaWxpbmcgZGVjaW1hbCBwb2ludHMgYW5kIHplcm9zLFxuICogICAgdGhlbiBwYXNzZWQgdG8gdGhlIFwib25DaGFuZ2VcIiBjYWxsYmFja1xuICpcbiAqIDMuIFdoZW4gdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCwgdGhlIGZvcm1EYXRhIHZhbHVlIGlzIGNoZWNrZWQgYWdhaW5zdCB0aGVcbiAqICAgIHZhbHVlIGNhY2hlZCBpbiB0aGUgc3RhdGUuIElmIGl0IG1hdGNoZXMgdGhlIGNhY2hlZCB2YWx1ZSwgdGhlIGNhY2hlZFxuICogICAgdmFsdWUgaXMgcGFzc2VkIHRvIHRoZSBpbnB1dCBpbnN0ZWFkIG9mIHRoZSBmb3JtRGF0YSB2YWx1ZVxuICovXG5mdW5jdGlvbiBOdW1iZXJGaWVsZChwcm9wcykge1xuICAgIGNvbnN0IHsgcmVnaXN0cnksIG9uQ2hhbmdlLCBmb3JtRGF0YSwgdmFsdWU6IGluaXRpYWxWYWx1ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgW2xhc3RWYWx1ZSwgc2V0TGFzdFZhbHVlXSA9IHVzZVN0YXRlKGluaXRpYWxWYWx1ZSk7XG4gICAgY29uc3QgeyBTdHJpbmdGaWVsZCB9ID0gcmVnaXN0cnkuZmllbGRzO1xuICAgIGxldCB2YWx1ZSA9IGZvcm1EYXRhO1xuICAgIC8qKiBIYW5kbGUgdGhlIGNoYW5nZSBmcm9tIHRoZSBgU3RyaW5nRmllbGRgIHRvIHByb3Blcmx5IGNvbnZlcnQgdG8gYSBudW1iZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSAtIFRoZSBjdXJyZW50IHZhbHVlIGZvciB0aGUgY2hhbmdlIG9jY3VycmluZ1xuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBDYWNoZSB0aGUgb3JpZ2luYWwgdmFsdWUgaW4gY29tcG9uZW50IHN0YXRlXG4gICAgICAgIHNldExhc3RWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSBkZWNpbWFscyB0aGF0IGRvbid0IHN0YXJ0IHdpdGggYSB6ZXJvIGNoYXJhY3RlciBpbiBhZHZhbmNlIHNvXG4gICAgICAgIC8vIHRoYXQgdGhlIHJlc3Qgb2YgdGhlIG5vcm1hbGl6YXRpb24gbG9naWMgaXMgc2ltcGxlclxuICAgICAgICBpZiAoYCR7dmFsdWV9YC5jaGFyQXQoMCkgPT09ICcuJykge1xuICAgICAgICAgICAgdmFsdWUgPSBgMCR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhIHN0cmluZyAodGhpcyBjYW4gaGFwcGVuIGlmIHRoZSB3aWRnZXQgdXNlZCBpcyBhXG4gICAgICAgIC8vIDxzZWxlY3Q+LCBkdWUgdG8gYW4gZW51bSBkZWNsYXJhdGlvbiBldGMpIHRoZW4sIGlmIHRoZSB2YWx1ZSBlbmRzIGluIGFcbiAgICAgICAgLy8gdHJhaWxpbmcgZGVjaW1hbCBwb2ludCBvciBtdWx0aXBsZSB6ZXJvZXMsIHN0cmlwIHRoZSB0cmFpbGluZyB2YWx1ZXNcbiAgICAgICAgY29uc3QgcHJvY2Vzc2VkID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiB2YWx1ZS5tYXRjaCh0cmFpbGluZ0NoYXJNYXRjaGVyV2l0aFByZWZpeClcbiAgICAgICAgICAgID8gYXNOdW1iZXIodmFsdWUucmVwbGFjZSh0cmFpbGluZ0NoYXJNYXRjaGVyLCAnJykpXG4gICAgICAgICAgICA6IGFzTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgb25DaGFuZ2UocHJvY2Vzc2VkKTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbiAgICBpZiAodHlwZW9mIGxhc3RWYWx1ZSA9PT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICAvLyBDb25zdHJ1Y3QgYSByZWd1bGFyIGV4cHJlc3Npb24gdGhhdCBjaGVja3MgZm9yIGEgc3RyaW5nIHRoYXQgY29uc2lzdHNcbiAgICAgICAgLy8gb2YgdGhlIGZvcm1EYXRhIHZhbHVlIHN1ZmZpeGVkIHdpdGggemVybyBvciBvbmUgJy4nIGNoYXJhY3RlcnMgYW5kIHplcm9cbiAgICAgICAgLy8gb3IgbW9yZSAnMCcgY2hhcmFjdGVyc1xuICAgICAgICBjb25zdCByZSA9IG5ldyBSZWdFeHAoYCR7dmFsdWV9YC5yZXBsYWNlKCcuJywgJ1xcXFwuJykgKyAnXFxcXC4/MCokJyk7XG4gICAgICAgIC8vIElmIHRoZSBjYWNoZWQgXCJsYXN0VmFsdWVcIiBpcyBhIG1hdGNoLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBmb3JtRGF0YVxuICAgICAgICAvLyB2YWx1ZSB0byBwcmV2ZW50IHRoZSBpbnB1dCB2YWx1ZSBmcm9tIGNoYW5naW5nIGluIHRoZSBVSVxuICAgICAgICBpZiAobGFzdFZhbHVlLm1hdGNoKHJlKSkge1xuICAgICAgICAgICAgdmFsdWUgPSBsYXN0VmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9qc3goU3RyaW5nRmllbGQsIHsgLi4ucHJvcHMsIGZvcm1EYXRhOiB2YWx1ZSwgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSB9KTtcbn1cbmV4cG9ydCBkZWZhdWx0IE51bWJlckZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TnVtYmVyRmllbGQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldFRlbXBsYXRlLCBnZXRVaU9wdGlvbnMsIG9yZGVyUHJvcGVydGllcywgVHJhbnNsYXRhYmxlU3RyaW5nLCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcsIFBST1BFUlRJRVNfS0VZLCBSRUZfS0VZLCBBTllfT0ZfS0VZLCBPTkVfT0ZfS0VZLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmltcG9ydCBNYXJrZG93biBmcm9tICdtYXJrZG93bi10by1qc3gnO1xuaW1wb3J0IGdldCBmcm9tICdsb2Rhc2gvZ2V0JztcbmltcG9ydCBoYXMgZnJvbSAnbG9kYXNoL2hhcyc7XG5pbXBvcnQgaXNPYmplY3QgZnJvbSAnbG9kYXNoL2lzT2JqZWN0JztcbmltcG9ydCBzZXQgZnJvbSAnbG9kYXNoL3NldCc7XG5pbXBvcnQgdW5zZXQgZnJvbSAnbG9kYXNoL3Vuc2V0Jztcbi8qKiBUaGUgYE9iamVjdEZpZWxkYCBjb21wb25lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBmaWVsZCBpbiB0aGUgc2NoZW1hIHRoYXQgaXMgb2YgdHlwZSBgb2JqZWN0YC4gSXQgdHJhY2tzIHdoZXRoZXIgYW5cbiAqIGFkZGl0aW9uYWwgcHJvcGVydHkga2V5IHdhcyBtb2RpZmllZCBhbmQgd2hhdCBpdCB3YXMgbW9kaWZpZWQgdG9cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEZpZWxkUHJvcHNgIGZvciB0aGlzIHRlbXBsYXRlXG4gKi9cbmNsYXNzIE9iamVjdEZpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgLyoqIFNldCB1cCB0aGUgaW5pdGlhbCBzdGF0ZSAqL1xuICAgICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICAgICAgd2FzUHJvcGVydHlLZXlNb2RpZmllZDogZmFsc2UsXG4gICAgICAgICAgICBhZGRpdGlvbmFsUHJvcGVydGllczoge30sXG4gICAgICAgIH07XG4gICAgICAgIC8qKiBSZXR1cm5zIHRoZSBgb25Qcm9wZXJ0eUNoYW5nZWAgaGFuZGxlciBmb3IgdGhlIGBuYW1lYCBmaWVsZC4gSGFuZGxlcyB0aGUgc3BlY2lhbCBjYXNlIHdoZXJlIGEgdXNlciBpcyBhdHRlbXB0aW5nXG4gICAgICAgICAqIHRvIGNsZWFyIHRoZSBkYXRhIGZvciBhIGZpZWxkIGFkZGVkIGFzIGFuIGFkZGl0aW9uYWwgcHJvcGVydHkuIENhbGxzIHRoZSBgb25DaGFuZ2UoKWAgaGFuZGxlciB3aXRoIHRoZSB1cGRhdGVkXG4gICAgICAgICAqIGZvcm1EYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wZXJ0eVxuICAgICAgICAgKiBAcGFyYW0gYWRkZWRCeUFkZGl0aW9uYWxQcm9wZXJ0aWVzIC0gRmxhZyBpbmRpY2F0aW5nIHdoZXRoZXIgdGhpcyBwcm9wZXJ0eSBpcyBhbiBhZGRpdGlvbmFsIHByb3BlcnR5XG4gICAgICAgICAqIEByZXR1cm5zIC0gVGhlIG9uUHJvcGVydHlDaGFuZ2UgY2FsbGJhY2sgZm9yIHRoZSBgbmFtZWAgcHJvcGVydHlcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25Qcm9wZXJ0eUNoYW5nZSA9IChuYW1lLCBhZGRlZEJ5QWRkaXRpb25hbFByb3BlcnRpZXMgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICh2YWx1ZSwgbmV3RXJyb3JTY2hlbWEsIGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBmb3JtRGF0YSwgb25DaGFuZ2UsIGVycm9yU2NoZW1hIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGFkZGVkQnlBZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBzZXQgdmFsdWUgPSB1bmRlZmluZWQgZm9yIGZpZWxkcyBhZGRlZCBieVxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsUHJvcGVydGllcy4gRG9pbmcgc28gcmVtb3ZlcyB0aGVtIGZyb20gdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvcm1EYXRhLCB3aGljaCBjYXVzZXMgdGhlbSB0byBjb21wbGV0ZWx5IGRpc2FwcGVhclxuICAgICAgICAgICAgICAgICAgICAvLyAoaW5jbHVkaW5nIHRoZSBpbnB1dCBmaWVsZCBmb3IgdGhlIHByb3BlcnR5IG5hbWUpLiBVbmxpa2VcbiAgICAgICAgICAgICAgICAgICAgLy8gZmllbGRzIHdoaWNoIGFyZSBcIm1hbmRhdGVkXCIgYnkgdGhlIHNjaGVtYSwgdGhlc2UgZmllbGRzIGNhblxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBzZXQgdG8gdW5kZWZpbmVkIGJ5IGNsaWNraW5nIGEgXCJkZWxldGUgZmllbGRcIiBidXR0b24sIHNvXG4gICAgICAgICAgICAgICAgICAgIC8vIHNldCBlbXB0eSB2YWx1ZXMgdG8gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Rm9ybURhdGEgPSB7IC4uLmZvcm1EYXRhLCBbbmFtZV06IHZhbHVlIH07XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UobmV3Rm9ybURhdGEsIGVycm9yU2NoZW1hICYmXG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2NoZW1hICYmIHtcbiAgICAgICAgICAgICAgICAgICAgLi4uZXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgICAgIFtuYW1lXTogbmV3RXJyb3JTY2hlbWEsXG4gICAgICAgICAgICAgICAgfSwgaWQpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFJldHVybnMgYSBjYWxsYmFjayB0byBoYW5kbGUgdGhlIG9uRHJvcFByb3BlcnR5Q2xpY2sgZXZlbnQgZm9yIHRoZSBnaXZlbiBga2V5YCB3aGljaCByZW1vdmVzIHRoZSBvbGQgYGtleWAgZGF0YVxuICAgICAgICAgKiBhbmQgY2FsbHMgdGhlIGBvbkNoYW5nZWAgY2FsbGJhY2sgd2l0aCBpdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ga2V5IC0gVGhlIGtleSBmb3Igd2hpY2ggdGhlIGRyb3AgY2FsbGJhY2sgaXMgZGVzaXJlZFxuICAgICAgICAgKiBAcmV0dXJucyAtIFRoZSBkcm9wIHByb3BlcnR5IGNsaWNrIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm9uRHJvcFByb3BlcnR5Q2xpY2sgPSAoa2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG9uQ2hhbmdlLCBmb3JtRGF0YSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICBjb25zdCBjb3BpZWRGb3JtRGF0YSA9IHsgLi4uZm9ybURhdGEgfTtcbiAgICAgICAgICAgICAgICB1bnNldChjb3BpZWRGb3JtRGF0YSwga2V5KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZShjb3BpZWRGb3JtRGF0YSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKiogQ29tcHV0ZXMgdGhlIG5leHQgYXZhaWxhYmxlIGtleSBuYW1lIGZyb20gdGhlIGBwcmVmZXJyZWRLZXlgLCBpbmRleGluZyB0aHJvdWdoIHRoZSBhbHJlYWR5IGV4aXN0aW5nIGtleXMgdW50aWwgb25lXG4gICAgICAgICAqIHRoYXQgaXMgYWxyZWFkeSBub3QgYXNzaWduZWQgaXMgZm91bmQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBwcmVmZXJyZWRLZXkgLSBUaGUgcHJlZmVycmVkIG5hbWUgb2YgYSBuZXcga2V5XG4gICAgICAgICAqIEBwYXJhbSBbZm9ybURhdGFdIC0gVGhlIGZvcm0gZGF0YSBpbiB3aGljaCB0byBjaGVjayBpZiB0aGUgZGVzaXJlZCBrZXkgYWxyZWFkeSBleGlzdHNcbiAgICAgICAgICogQHJldHVybnMgLSBUaGUgbmFtZSBvZiB0aGUgbmV4dCBhdmFpbGFibGUga2V5IGZyb20gYHByZWZlcnJlZEtleWBcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZ2V0QXZhaWxhYmxlS2V5ID0gKHByZWZlcnJlZEtleSwgZm9ybURhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgdWlTY2hlbWEsIHJlZ2lzdHJ5IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICAgICAgY29uc3QgeyBkdXBsaWNhdGVLZXlTdWZmaXhTZXBhcmF0b3IgPSAnLScgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgcmVnaXN0cnkuZ2xvYmFsVWlPcHRpb25zKTtcbiAgICAgICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgICAgICBsZXQgbmV3S2V5ID0gcHJlZmVycmVkS2V5O1xuICAgICAgICAgICAgd2hpbGUgKGhhcyhmb3JtRGF0YSwgbmV3S2V5KSkge1xuICAgICAgICAgICAgICAgIG5ld0tleSA9IGAke3ByZWZlcnJlZEtleX0ke2R1cGxpY2F0ZUtleVN1ZmZpeFNlcGFyYXRvcn0keysraW5kZXh9YDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdLZXk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZWFscyB3aXRoIHRoZSByZW5hbWUgb2YgYSBrZXkgZm9yIGFuIGFkZGl0aW9uYWwgcHJvcGVydHkgZm9yIGEgc2NoZW1hLiBUaGF0XG4gICAgICAgICAqIGNhbGxiYWNrIHdpbGwgYXR0ZW1wdCB0byByZW5hbWUgdGhlIGtleSBhbmQgbW92ZSB0aGUgZXhpc3RpbmcgZGF0YSB0byB0aGF0IGtleSwgY2FsbGluZyBgb25DaGFuZ2VgIHdoZW4gaXQgZG9lcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG9sZFZhbHVlIC0gVGhlIG9sZCB2YWx1ZSBvZiBhIGZpZWxkXG4gICAgICAgICAqIEByZXR1cm5zIC0gVGhlIGtleSBjaGFuZ2UgY2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMub25LZXlDaGFuZ2UgPSAob2xkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUsIG5ld0Vycm9yU2NoZW1hKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG9sZFZhbHVlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZm9ybURhdGEsIG9uQ2hhbmdlLCBlcnJvclNjaGVtYSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0QXZhaWxhYmxlS2V5KHZhbHVlLCBmb3JtRGF0YSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3Rm9ybURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1EYXRhLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3S2V5cyA9IHsgW29sZFZhbHVlXTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlWYWx1ZXMgPSBPYmplY3Qua2V5cyhuZXdGb3JtRGF0YSkubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3S2V5ID0gbmV3S2V5c1trZXldIHx8IGtleTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgW25ld0tleV06IG5ld0Zvcm1EYXRhW2tleV0gfTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5hbWVkT2JqID0gT2JqZWN0LmFzc2lnbih7fSwgLi4ua2V5VmFsdWVzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHsgd2FzUHJvcGVydHlLZXlNb2RpZmllZDogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZShyZW5hbWVkT2JqLCBlcnJvclNjaGVtYSAmJlxuICAgICAgICAgICAgICAgICAgICBlcnJvclNjaGVtYSAmJiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmVycm9yU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBbdmFsdWVdOiBuZXdFcnJvclNjaGVtYSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIC8qKiBIYW5kbGVzIHRoZSBhZGRpbmcgb2YgYSBuZXcgYWRkaXRpb25hbCBwcm9wZXJ0eSBvbiB0aGUgZ2l2ZW4gYHNjaGVtYWAuIENhbGxzIHRoZSBgb25DaGFuZ2VgIGNhbGxiYWNrIG9uY2UgdGhlIG5ld1xuICAgICAgICAgKiBkZWZhdWx0IGRhdGEgZm9yIHRoYXQgZmllbGQgaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZvcm1EYXRhLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gc2NoZW1hIC0gVGhlIHNjaGVtYSBlbGVtZW50IHRvIHdoaWNoIHRoZSBuZXcgcHJvcGVydHkgaXMgYmVpbmcgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFuZGxlQWRkQ2xpY2sgPSAoc2NoZW1hKSA9PiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYS5hZGRpdGlvbmFsUHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybURhdGEsIG9uQ2hhbmdlLCByZWdpc3RyeSB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgICAgIGNvbnN0IG5ld0Zvcm1EYXRhID0geyAuLi5mb3JtRGF0YSB9O1xuICAgICAgICAgICAgbGV0IHR5cGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoaXNPYmplY3Qoc2NoZW1hLmFkZGl0aW9uYWxQcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgICAgIHR5cGUgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMudHlwZTtcbiAgICAgICAgICAgICAgICBsZXQgYXBTY2hlbWEgPSBzY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgaWYgKFJFRl9LRVkgaW4gYXBTY2hlbWEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBzY2hlbWFVdGlscyB9ID0gcmVnaXN0cnk7XG4gICAgICAgICAgICAgICAgICAgIGFwU2NoZW1hID0gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEoeyAkcmVmOiBhcFNjaGVtYVtSRUZfS0VZXSB9LCBmb3JtRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHR5cGUgPSBhcFNjaGVtYS50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXR5cGUgJiYgKEFOWV9PRl9LRVkgaW4gYXBTY2hlbWEgfHwgT05FX09GX0tFWSBpbiBhcFNjaGVtYSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZSA9ICdvYmplY3QnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5ld0tleSA9IHRoaXMuZ2V0QXZhaWxhYmxlS2V5KCduZXdLZXknLCBuZXdGb3JtRGF0YSk7XG4gICAgICAgICAgICAvLyBDYXN0IHRoaXMgdG8gbWFrZSB0aGUgYHNldGAgd29yayBwcm9wZXJseVxuICAgICAgICAgICAgc2V0KG5ld0Zvcm1EYXRhLCBuZXdLZXksIHRoaXMuZ2V0RGVmYXVsdFZhbHVlKHR5cGUpKTtcbiAgICAgICAgICAgIG9uQ2hhbmdlKG5ld0Zvcm1EYXRhKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqIFJldHVybnMgYSBmbGFnIGluZGljYXRpbmcgd2hldGhlciB0aGUgYG5hbWVgIGZpZWxkIGlzIHJlcXVpcmVkIGluIHRoZSBvYmplY3Qgc2NoZW1hXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBmaWVsZCB0byBjaGVjayBmb3IgcmVxdWlyZWQtbmVzc1xuICAgICAqIEByZXR1cm5zIC0gVHJ1ZSBpZiB0aGUgZmllbGQgYG5hbWVgIGlzIHJlcXVpcmVkLCBmYWxzZSBvdGhlcndpc2VcbiAgICAgKi9cbiAgICBpc1JlcXVpcmVkKG5hbWUpIHtcbiAgICAgICAgY29uc3QgeyBzY2hlbWEgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHNjaGVtYS5yZXF1aXJlZCkgJiYgc2NoZW1hLnJlcXVpcmVkLmluZGV4T2YobmFtZSkgIT09IC0xO1xuICAgIH1cbiAgICAvKiogUmV0dXJucyBhIGRlZmF1bHQgdmFsdWUgdG8gYmUgdXNlZCBmb3IgYSBuZXcgYWRkaXRpb25hbCBzY2hlbWEgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGB0eXBlYFxuICAgICAqXG4gICAgICogQHBhcmFtIHR5cGUgLSBUaGUgdHlwZSBvZiB0aGUgbmV3IGFkZGl0aW9uYWwgc2NoZW1hIHByb3BlcnR5XG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFZhbHVlKHR5cGUpIHtcbiAgICAgICAgY29uc3QgeyByZWdpc3RyeTogeyB0cmFuc2xhdGVTdHJpbmcgfSwgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXJyYXknOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBhIGRhdGF0eXBlIGZvciBzb21lIHJlYXNvbiAocGVyaGFwcyBhZGRpdGlvbmFsUHJvcGVydGllcyB3YXMgdHJ1ZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5OZXdTdHJpbmdEZWZhdWx0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiogUmVuZGVycyB0aGUgYE9iamVjdEZpZWxkYCBmcm9tIHRoZSBnaXZlbiBwcm9wc1xuICAgICAqL1xuICAgIHJlbmRlcigpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IHsgc2NoZW1hOiByYXdTY2hlbWEsIHVpU2NoZW1hID0ge30sIGZvcm1EYXRhLCBlcnJvclNjaGVtYSwgaWRTY2hlbWEsIG5hbWUsIHJlcXVpcmVkID0gZmFsc2UsIGRpc2FibGVkID0gZmFsc2UsIHJlYWRvbmx5ID0gZmFsc2UsIGhpZGVFcnJvciwgaWRQcmVmaXgsIGlkU2VwYXJhdG9yLCBvbkJsdXIsIG9uRm9jdXMsIHJlZ2lzdHJ5LCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgY29uc3QgeyBmaWVsZHMsIGZvcm1Db250ZXh0LCBzY2hlbWFVdGlscywgdHJhbnNsYXRlU3RyaW5nLCBnbG9iYWxVaU9wdGlvbnMgfSA9IHJlZ2lzdHJ5O1xuICAgICAgICBjb25zdCB7IFNjaGVtYUZpZWxkIH0gPSBmaWVsZHM7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKHJhd1NjaGVtYSwgZm9ybURhdGEpO1xuICAgICAgICBjb25zdCB1aU9wdGlvbnMgPSBnZXRVaU9wdGlvbnModWlTY2hlbWEsIGdsb2JhbFVpT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHsgcHJvcGVydGllczogc2NoZW1hUHJvcGVydGllcyA9IHt9IH0gPSBzY2hlbWE7XG4gICAgICAgIGNvbnN0IHRpdGxlID0gKF9iID0gKF9hID0gdWlPcHRpb25zLnRpdGxlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzY2hlbWEudGl0bGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG5hbWU7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gKF9jID0gdWlPcHRpb25zLmRlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgICAgIGxldCBvcmRlcmVkUHJvcGVydGllcztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBPYmplY3Qua2V5cyhzY2hlbWFQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIG9yZGVyZWRQcm9wZXJ0aWVzID0gb3JkZXJQcm9wZXJ0aWVzKHByb3BlcnRpZXMsIHVpT3B0aW9ucy5vcmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIChfanN4cyhcImRpdlwiLCB7IGNoaWxkcmVuOiBbX2pzeChcInBcIiwgeyBjbGFzc05hbWU6ICdjb25maWctZXJyb3InLCBzdHlsZTogeyBjb2xvcjogJ3JlZCcgfSwgY2hpbGRyZW46IF9qc3goTWFya2Rvd24sIHsgY2hpbGRyZW46IHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuSW52YWxpZE9iamVjdEZpZWxkLCBbbmFtZSB8fCAncm9vdCcsIGVyci5tZXNzYWdlXSkgfSkgfSksIF9qc3goXCJwcmVcIiwgeyBjaGlsZHJlbjogSlNPTi5zdHJpbmdpZnkoc2NoZW1hKSB9KV0gfSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ09iamVjdEZpZWxkVGVtcGxhdGUnLCByZWdpc3RyeSwgdWlPcHRpb25zKTtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVQcm9wcyA9IHtcbiAgICAgICAgICAgIC8vIGdldERpc3BsYXlMYWJlbCgpIGFsd2F5cyByZXR1cm5zIGZhbHNlIGZvciBvYmplY3QgdHlwZXMsIHNvIGp1c3QgY2hlY2sgdGhlIGB1aU9wdGlvbnMubGFiZWxgXG4gICAgICAgICAgICB0aXRsZTogdWlPcHRpb25zLmxhYmVsID09PSBmYWxzZSA/ICcnIDogdGl0bGUsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdWlPcHRpb25zLmxhYmVsID09PSBmYWxzZSA/IHVuZGVmaW5lZCA6IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgcHJvcGVydGllczogb3JkZXJlZFByb3BlcnRpZXMubWFwKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkZWRCeUFkZGl0aW9uYWxQcm9wZXJ0aWVzID0gaGFzKHNjaGVtYSwgW1BST1BFUlRJRVNfS0VZLCBuYW1lLCBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUddKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFVpU2NoZW1hID0gYWRkZWRCeUFkZGl0aW9uYWxQcm9wZXJ0aWVzID8gdWlTY2hlbWEuYWRkaXRpb25hbFByb3BlcnRpZXMgOiB1aVNjaGVtYVtuYW1lXTtcbiAgICAgICAgICAgICAgICBjb25zdCBoaWRkZW4gPSBnZXRVaU9wdGlvbnMoZmllbGRVaVNjaGVtYSkud2lkZ2V0ID09PSAnaGlkZGVuJztcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZElkU2NoZW1hID0gZ2V0KGlkU2NoZW1hLCBbbmFtZV0sIHt9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAoX2pzeChTY2hlbWFGaWVsZCwgeyBuYW1lOiBuYW1lLCByZXF1aXJlZDogdGhpcy5pc1JlcXVpcmVkKG5hbWUpLCBzY2hlbWE6IGdldChzY2hlbWEsIFtQUk9QRVJUSUVTX0tFWSwgbmFtZV0sIHt9KSwgdWlTY2hlbWE6IGZpZWxkVWlTY2hlbWEsIGVycm9yU2NoZW1hOiBnZXQoZXJyb3JTY2hlbWEsIG5hbWUpLCBpZFNjaGVtYTogZmllbGRJZFNjaGVtYSwgaWRQcmVmaXg6IGlkUHJlZml4LCBpZFNlcGFyYXRvcjogaWRTZXBhcmF0b3IsIGZvcm1EYXRhOiBnZXQoZm9ybURhdGEsIG5hbWUpLCBmb3JtQ29udGV4dDogZm9ybUNvbnRleHQsIHdhc1Byb3BlcnR5S2V5TW9kaWZpZWQ6IHRoaXMuc3RhdGUud2FzUHJvcGVydHlLZXlNb2RpZmllZCwgb25LZXlDaGFuZ2U6IHRoaXMub25LZXlDaGFuZ2UobmFtZSksIG9uQ2hhbmdlOiB0aGlzLm9uUHJvcGVydHlDaGFuZ2UobmFtZSwgYWRkZWRCeUFkZGl0aW9uYWxQcm9wZXJ0aWVzKSwgb25CbHVyOiBvbkJsdXIsIG9uRm9jdXM6IG9uRm9jdXMsIHJlZ2lzdHJ5OiByZWdpc3RyeSwgZGlzYWJsZWQ6IGRpc2FibGVkLCByZWFkb25seTogcmVhZG9ubHksIGhpZGVFcnJvcjogaGlkZUVycm9yLCBvbkRyb3BQcm9wZXJ0eUNsaWNrOiB0aGlzLm9uRHJvcFByb3BlcnR5Q2xpY2sgfSwgbmFtZSkpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICByZWFkb25seSxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZWQsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgICAgICAgICBoaWRkZW4sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgcmVhZG9ubHksXG4gICAgICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgICAgIHJlcXVpcmVkLFxuICAgICAgICAgICAgaWRTY2hlbWEsXG4gICAgICAgICAgICB1aVNjaGVtYSxcbiAgICAgICAgICAgIGVycm9yU2NoZW1hLFxuICAgICAgICAgICAgc2NoZW1hLFxuICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICBmb3JtQ29udGV4dCxcbiAgICAgICAgICAgIHJlZ2lzdHJ5LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX2pzeChUZW1wbGF0ZSwgeyAuLi50ZW1wbGF0ZVByb3BzLCBvbkFkZENsaWNrOiB0aGlzLmhhbmRsZUFkZENsaWNrIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBkZWZhdWx0IE9iamVjdEZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9T2JqZWN0RmllbGQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3gsIEZyYWdtZW50IGFzIF9GcmFnbWVudCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIENvbXBvbmVudCB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IEFERElUSU9OQUxfUFJPUEVSVFlfRkxBRywgZGVlcEVxdWFscywgZGVzY3JpcHRpb25JZCwgZ2V0U2NoZW1hVHlwZSwgZ2V0VGVtcGxhdGUsIGdldFVpT3B0aW9ucywgSURfS0VZLCBtZXJnZU9iamVjdHMsIFRyYW5zbGF0YWJsZVN0cmluZywgVUlfT1BUSU9OU19LRVksIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuaW1wb3J0IGlzT2JqZWN0IGZyb20gJ2xvZGFzaC9pc09iamVjdCc7XG5pbXBvcnQgb21pdCBmcm9tICdsb2Rhc2gvb21pdCc7XG5pbXBvcnQgTWFya2Rvd24gZnJvbSAnbWFya2Rvd24tdG8tanN4Jztcbi8qKiBUaGUgbWFwIG9mIGNvbXBvbmVudCB0eXBlIHRvIEZpZWxkTmFtZSAqL1xuY29uc3QgQ09NUE9ORU5UX1RZUEVTID0ge1xuICAgIGFycmF5OiAnQXJyYXlGaWVsZCcsXG4gICAgYm9vbGVhbjogJ0Jvb2xlYW5GaWVsZCcsXG4gICAgaW50ZWdlcjogJ051bWJlckZpZWxkJyxcbiAgICBudW1iZXI6ICdOdW1iZXJGaWVsZCcsXG4gICAgb2JqZWN0OiAnT2JqZWN0RmllbGQnLFxuICAgIHN0cmluZzogJ1N0cmluZ0ZpZWxkJyxcbiAgICBudWxsOiAnTnVsbEZpZWxkJyxcbn07XG4vKiogQ29tcHV0ZXMgYW5kIHJldHVybnMgd2hpY2ggYEZpZWxkYCBpbXBsZW1lbnRhdGlvbiB0byByZXR1cm4gaW4gb3JkZXIgdG8gcmVuZGVyIHRoZSBmaWVsZCByZXByZXNlbnRlZCBieSB0aGVcbiAqIGBzY2hlbWFgLiBUaGUgYHVpT3B0aW9uc2AgYXJlIHVzZWQgdG8gYWx0ZXIgd2hhdCBwb3RlbnRpYWwgYEZpZWxkYCBpbXBsZW1lbnRhdGlvbiBpcyBhY3R1YWxseSByZXR1cm5lZC4gSWYgbm9cbiAqIGFwcHJvcHJpYXRlIGBGaWVsZGAgaW1wbGVtZW50YXRpb24gY2FuIGJlIGZvdW5kIHRoZW4gYSB3cmFwcGVyIGFyb3VuZCBgVW5zdXBwb3J0ZWRGaWVsZFRlbXBsYXRlYCBpcyB1c2VkLlxuICpcbiAqIEBwYXJhbSBzY2hlbWEgLSBUaGUgc2NoZW1hIGZyb20gd2hpY2ggdG8gb2J0YWluIHRoZSB0eXBlXG4gKiBAcGFyYW0gdWlPcHRpb25zIC0gVGhlIFVJIE9wdGlvbnMgdGhhdCBtYXkgYWZmZWN0IHRoZSBjb21wb25lbnQgZGVjaXNpb25cbiAqIEBwYXJhbSBpZFNjaGVtYSAtIFRoZSBpZCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgYFVuc3VwcG9ydGVkRmllbGRUZW1wbGF0ZWBcbiAqIEBwYXJhbSByZWdpc3RyeSAtIFRoZSByZWdpc3RyeSBmcm9tIHdoaWNoIGZpZWxkcyBhbmQgdGVtcGxhdGVzIGFyZSBvYnRhaW5lZFxuICogQHJldHVybnMgLSBUaGUgYEZpZWxkYCBjb21wb25lbnQgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgYWN0dWFsIGZpZWxkIGRhdGFcbiAqL1xuZnVuY3Rpb24gZ2V0RmllbGRDb21wb25lbnQoc2NoZW1hLCB1aU9wdGlvbnMsIGlkU2NoZW1hLCByZWdpc3RyeSkge1xuICAgIGNvbnN0IGZpZWxkID0gdWlPcHRpb25zLmZpZWxkO1xuICAgIGNvbnN0IHsgZmllbGRzLCB0cmFuc2xhdGVTdHJpbmcgfSA9IHJlZ2lzdHJ5O1xuICAgIGlmICh0eXBlb2YgZmllbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGZpZWxkID09PSAnc3RyaW5nJyAmJiBmaWVsZCBpbiBmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIGZpZWxkc1tmaWVsZF07XG4gICAgfVxuICAgIGNvbnN0IHNjaGVtYVR5cGUgPSBnZXRTY2hlbWFUeXBlKHNjaGVtYSk7XG4gICAgY29uc3QgdHlwZSA9IEFycmF5LmlzQXJyYXkoc2NoZW1hVHlwZSkgPyBzY2hlbWFUeXBlWzBdIDogc2NoZW1hVHlwZSB8fCAnJztcbiAgICBjb25zdCBzY2hlbWFJZCA9IHNjaGVtYS4kaWQ7XG4gICAgbGV0IGNvbXBvbmVudE5hbWUgPSBDT01QT05FTlRfVFlQRVNbdHlwZV07XG4gICAgaWYgKHNjaGVtYUlkICYmIHNjaGVtYUlkIGluIGZpZWxkcykge1xuICAgICAgICBjb21wb25lbnROYW1lID0gc2NoZW1hSWQ7XG4gICAgfVxuICAgIC8vIElmIHRoZSB0eXBlIGlzIG5vdCBkZWZpbmVkIGFuZCB0aGUgc2NoZW1hIHVzZXMgJ2FueU9mJyBvciAnb25lT2YnLCBkb24ndFxuICAgIC8vIHJlbmRlciBhIGZpZWxkIGFuZCBsZXQgdGhlIE11bHRpU2NoZW1hRmllbGQgY29tcG9uZW50IGhhbmRsZSB0aGUgZm9ybSBkaXNwbGF5XG4gICAgaWYgKCFjb21wb25lbnROYW1lICYmIChzY2hlbWEuYW55T2YgfHwgc2NoZW1hLm9uZU9mKSkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudE5hbWUgaW4gZmllbGRzXG4gICAgICAgID8gZmllbGRzW2NvbXBvbmVudE5hbWVdXG4gICAgICAgIDogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgVW5zdXBwb3J0ZWRGaWVsZFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ1Vuc3VwcG9ydGVkRmllbGRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCB1aU9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIChfanN4KFVuc3VwcG9ydGVkRmllbGRUZW1wbGF0ZSwgeyBzY2hlbWE6IHNjaGVtYSwgaWRTY2hlbWE6IGlkU2NoZW1hLCByZWFzb246IHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuVW5rbm93bkZpZWxkVHlwZSwgW1N0cmluZyhzY2hlbWEudHlwZSldKSwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKTtcbiAgICAgICAgfTtcbn1cbi8qKiBUaGUgYFNjaGVtYUZpZWxkUmVuZGVyYCBjb21wb25lbnQgaXMgdGhlIHdvcmstaG9yc2Ugb2YgcmVhY3QtanNvbnNjaGVtYS1mb3JtLCBkZXRlcm1pbmluZyB3aGF0IGtpbmQgb2YgcmVhbCBmaWVsZCB0b1xuICogcmVuZGVyIGJhc2VkIG9uIHRoZSBgc2NoZW1hYCwgYHVpU2NoZW1hYCBhbmQgYWxsIHRoZSBvdGhlciBwcm9wcy4gSXQgYWxzbyBkZWFscyB3aXRoIHJlbmRlcmluZyB0aGUgYGFueU9mYCBhbmRcbiAqIGBvbmVPZmAgZmllbGRzLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgRmllbGRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFNjaGVtYUZpZWxkUmVuZGVyKHByb3BzKSB7XG4gICAgY29uc3QgeyBzY2hlbWE6IF9zY2hlbWEsIGlkU2NoZW1hOiBfaWRTY2hlbWEsIHVpU2NoZW1hLCBmb3JtRGF0YSwgZXJyb3JTY2hlbWEsIGlkUHJlZml4LCBpZFNlcGFyYXRvciwgbmFtZSwgb25DaGFuZ2UsIG9uS2V5Q2hhbmdlLCBvbkRyb3BQcm9wZXJ0eUNsaWNrLCByZXF1aXJlZCwgcmVnaXN0cnksIHdhc1Byb3BlcnR5S2V5TW9kaWZpZWQgPSBmYWxzZSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgZm9ybUNvbnRleHQsIHNjaGVtYVV0aWxzLCBnbG9iYWxVaU9wdGlvbnMgfSA9IHJlZ2lzdHJ5O1xuICAgIGNvbnN0IHVpT3B0aW9ucyA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSwgZ2xvYmFsVWlPcHRpb25zKTtcbiAgICBjb25zdCBGaWVsZFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0ZpZWxkVGVtcGxhdGUnLCByZWdpc3RyeSwgdWlPcHRpb25zKTtcbiAgICBjb25zdCBEZXNjcmlwdGlvbkZpZWxkVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnRGVzY3JpcHRpb25GaWVsZFRlbXBsYXRlJywgcmVnaXN0cnksIHVpT3B0aW9ucyk7XG4gICAgY29uc3QgRmllbGRIZWxwVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnRmllbGRIZWxwVGVtcGxhdGUnLCByZWdpc3RyeSwgdWlPcHRpb25zKTtcbiAgICBjb25zdCBGaWVsZEVycm9yVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnRmllbGRFcnJvclRlbXBsYXRlJywgcmVnaXN0cnksIHVpT3B0aW9ucyk7XG4gICAgY29uc3Qgc2NoZW1hID0gc2NoZW1hVXRpbHMucmV0cmlldmVTY2hlbWEoX3NjaGVtYSwgZm9ybURhdGEpO1xuICAgIGNvbnN0IGZpZWxkSWQgPSBfaWRTY2hlbWFbSURfS0VZXTtcbiAgICBjb25zdCBpZFNjaGVtYSA9IG1lcmdlT2JqZWN0cyhzY2hlbWFVdGlscy50b0lkU2NoZW1hKHNjaGVtYSwgZmllbGRJZCwgZm9ybURhdGEsIGlkUHJlZml4LCBpZFNlcGFyYXRvciksIF9pZFNjaGVtYSk7XG4gICAgLyoqIEludGVybWVkaWFyeSBgb25DaGFuZ2VgIGhhbmRsZXIgZm9yIGZpZWxkIGNvbXBvbmVudHMgdGhhdCB3aWxsIGluamVjdCB0aGUgYGlkYCBvZiB0aGUgY3VycmVudCBmaWVsZCBpbnRvIHRoZVxuICAgICAqIGBvbkNoYW5nZWAgY2hhaW4gaWYgaXQgaXMgbm90IGFscmVhZHkgYmVpbmcgcHJvdmlkZWQgZnJvbSBhIGRlZXBlciBsZXZlbCBpbiB0aGUgaGllcmFyY2h5XG4gICAgICovXG4gICAgY29uc3QgaGFuZGxlRmllbGRDb21wb25lbnRDaGFuZ2UgPSB1c2VDYWxsYmFjaygoZm9ybURhdGEsIG5ld0Vycm9yU2NoZW1hLCBpZCkgPT4ge1xuICAgICAgICBjb25zdCB0aGVJZCA9IGlkIHx8IGZpZWxkSWQ7XG4gICAgICAgIHJldHVybiBvbkNoYW5nZShmb3JtRGF0YSwgbmV3RXJyb3JTY2hlbWEsIHRoZUlkKTtcbiAgICB9LCBbZmllbGRJZCwgb25DaGFuZ2VdKTtcbiAgICBjb25zdCBGaWVsZENvbXBvbmVudCA9IGdldEZpZWxkQ29tcG9uZW50KHNjaGVtYSwgdWlPcHRpb25zLCBpZFNjaGVtYSwgcmVnaXN0cnkpO1xuICAgIGNvbnN0IGRpc2FibGVkID0gQm9vbGVhbihwcm9wcy5kaXNhYmxlZCB8fCB1aU9wdGlvbnMuZGlzYWJsZWQpO1xuICAgIGNvbnN0IHJlYWRvbmx5ID0gQm9vbGVhbihwcm9wcy5yZWFkb25seSB8fCB1aU9wdGlvbnMucmVhZG9ubHkgfHwgcHJvcHMuc2NoZW1hLnJlYWRPbmx5IHx8IHNjaGVtYS5yZWFkT25seSk7XG4gICAgY29uc3QgdWlTY2hlbWFIaWRlRXJyb3IgPSB1aU9wdGlvbnMuaGlkZUVycm9yO1xuICAgIC8vIFNldCBoaWRlRXJyb3IgdG8gdGhlIHZhbHVlIHByb3ZpZGVkIGluIHRoZSB1aVNjaGVtYSwgb3RoZXJ3aXNlIHN0aWNrIHdpdGggdGhlIHByb3AgdG8gcHJvcGFnYXRlIHRvIGNoaWxkcmVuXG4gICAgY29uc3QgaGlkZUVycm9yID0gdWlTY2hlbWFIaWRlRXJyb3IgPT09IHVuZGVmaW5lZCA/IHByb3BzLmhpZGVFcnJvciA6IEJvb2xlYW4odWlTY2hlbWFIaWRlRXJyb3IpO1xuICAgIGNvbnN0IGF1dG9mb2N1cyA9IEJvb2xlYW4ocHJvcHMuYXV0b2ZvY3VzIHx8IHVpT3B0aW9ucy5hdXRvZm9jdXMpO1xuICAgIGlmIChPYmplY3Qua2V5cyhzY2hlbWEpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGlzcGxheUxhYmVsID0gc2NoZW1hVXRpbHMuZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIGdsb2JhbFVpT3B0aW9ucyk7XG4gICAgY29uc3QgeyBfX2Vycm9ycywgLi4uZmllbGRFcnJvclNjaGVtYSB9ID0gZXJyb3JTY2hlbWEgfHwge307XG4gICAgLy8gU2VlICM0Mzk6IHVpU2NoZW1hOiBEb24ndCBwYXNzIGNvbnN1bWVkIGNsYXNzIG5hbWVzIG9yIHN0eWxlIHRvIGNoaWxkIGNvbXBvbmVudHNcbiAgICBjb25zdCBmaWVsZFVpU2NoZW1hID0gb21pdCh1aVNjaGVtYSwgWyd1aTpjbGFzc05hbWVzJywgJ2NsYXNzTmFtZXMnLCAndWk6c3R5bGUnXSk7XG4gICAgaWYgKFVJX09QVElPTlNfS0VZIGluIGZpZWxkVWlTY2hlbWEpIHtcbiAgICAgICAgZmllbGRVaVNjaGVtYVtVSV9PUFRJT05TX0tFWV0gPSBvbWl0KGZpZWxkVWlTY2hlbWFbVUlfT1BUSU9OU19LRVldLCBbJ2NsYXNzTmFtZXMnLCAnc3R5bGUnXSk7XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkID0gKF9qc3goRmllbGRDb21wb25lbnQsIHsgLi4ucHJvcHMsIG9uQ2hhbmdlOiBoYW5kbGVGaWVsZENvbXBvbmVudENoYW5nZSwgaWRTY2hlbWE6IGlkU2NoZW1hLCBzY2hlbWE6IHNjaGVtYSwgdWlTY2hlbWE6IGZpZWxkVWlTY2hlbWEsIGRpc2FibGVkOiBkaXNhYmxlZCwgcmVhZG9ubHk6IHJlYWRvbmx5LCBoaWRlRXJyb3I6IGhpZGVFcnJvciwgYXV0b2ZvY3VzOiBhdXRvZm9jdXMsIGVycm9yU2NoZW1hOiBmaWVsZEVycm9yU2NoZW1hLCBmb3JtQ29udGV4dDogZm9ybUNvbnRleHQsIHJhd0Vycm9yczogX19lcnJvcnMgfSkpO1xuICAgIGNvbnN0IGlkID0gaWRTY2hlbWFbSURfS0VZXTtcbiAgICAvLyBJZiB0aGlzIHNjaGVtYSBoYXMgYSB0aXRsZSBkZWZpbmVkLCBidXQgdGhlIHVzZXIgaGFzIHNldCBhIG5ldyBrZXkvbGFiZWwsIHJldGFpbiB0aGVpciBpbnB1dC5cbiAgICBsZXQgbGFiZWw7XG4gICAgaWYgKHdhc1Byb3BlcnR5S2V5TW9kaWZpZWQpIHtcbiAgICAgICAgbGFiZWwgPSBuYW1lO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbGFiZWwgPSBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcgaW4gc2NoZW1hID8gbmFtZSA6IHVpT3B0aW9ucy50aXRsZSB8fCBwcm9wcy5zY2hlbWEudGl0bGUgfHwgc2NoZW1hLnRpdGxlIHx8IG5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdWlPcHRpb25zLmRlc2NyaXB0aW9uIHx8IHByb3BzLnNjaGVtYS5kZXNjcmlwdGlvbiB8fCBzY2hlbWEuZGVzY3JpcHRpb24gfHwgJyc7XG4gICAgY29uc3QgcmljaERlc2NyaXB0aW9uID0gdWlPcHRpb25zLmVuYWJsZU1hcmtkb3duSW5EZXNjcmlwdGlvbiA/IF9qc3goTWFya2Rvd24sIHsgY2hpbGRyZW46IGRlc2NyaXB0aW9uIH0pIDogZGVzY3JpcHRpb247XG4gICAgY29uc3QgaGVscCA9IHVpT3B0aW9ucy5oZWxwO1xuICAgIGNvbnN0IGhpZGRlbiA9IHVpT3B0aW9ucy53aWRnZXQgPT09ICdoaWRkZW4nO1xuICAgIGNvbnN0IGNsYXNzTmFtZXMgPSBbJ2Zvcm0tZ3JvdXAnLCAnZmllbGQnLCBgZmllbGQtJHtnZXRTY2hlbWFUeXBlKHNjaGVtYSl9YF07XG4gICAgaWYgKCFoaWRlRXJyb3IgJiYgX19lcnJvcnMgJiYgX19lcnJvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2goJ2ZpZWxkLWVycm9yIGhhcy1lcnJvciBoYXMtZGFuZ2VyJyk7XG4gICAgfVxuICAgIGlmICh1aVNjaGVtYSA9PT0gbnVsbCB8fCB1aVNjaGVtYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdWlTY2hlbWEuY2xhc3NOYW1lcykge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFwiJ3VpU2NoZW1hLmNsYXNzTmFtZXMnIGlzIGRlcHJlY2F0ZWQgYW5kIG1heSBiZSByZW1vdmVkIGluIGEgbWFqb3IgcmVsZWFzZTsgVXNlICd1aTpjbGFzc05hbWVzJyBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBjbGFzc05hbWVzLnB1c2godWlTY2hlbWEuY2xhc3NOYW1lcyk7XG4gICAgfVxuICAgIGlmICh1aU9wdGlvbnMuY2xhc3NOYW1lcykge1xuICAgICAgICBjbGFzc05hbWVzLnB1c2godWlPcHRpb25zLmNsYXNzTmFtZXMpO1xuICAgIH1cbiAgICBjb25zdCBoZWxwQ29tcG9uZW50ID0gKF9qc3goRmllbGRIZWxwVGVtcGxhdGUsIHsgaGVscDogaGVscCwgaWRTY2hlbWE6IGlkU2NoZW1hLCBzY2hlbWE6IHNjaGVtYSwgdWlTY2hlbWE6IHVpU2NoZW1hLCBoYXNFcnJvcnM6ICFoaWRlRXJyb3IgJiYgX19lcnJvcnMgJiYgX19lcnJvcnMubGVuZ3RoID4gMCwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKTtcbiAgICAvKlxuICAgICAqIEFueU9mL09uZU9mIGVycm9ycyBoYW5kbGVkIGJ5IGNoaWxkIHNjaGVtYVxuICAgICAqIHVubGVzcyBpdCBjYW4gYmUgcmVuZGVyZWQgYXMgc2VsZWN0IGNvbnRyb2xcbiAgICAgKi9cbiAgICBjb25zdCBlcnJvcnNDb21wb25lbnQgPSBoaWRlRXJyb3IgfHwgKChzY2hlbWEuYW55T2YgfHwgc2NoZW1hLm9uZU9mKSAmJiAhc2NoZW1hVXRpbHMuaXNTZWxlY3Qoc2NoZW1hKSkgPyB1bmRlZmluZWQgOiAoX2pzeChGaWVsZEVycm9yVGVtcGxhdGUsIHsgZXJyb3JzOiBfX2Vycm9ycywgZXJyb3JTY2hlbWE6IGVycm9yU2NoZW1hLCBpZFNjaGVtYTogaWRTY2hlbWEsIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSk7XG4gICAgY29uc3QgZmllbGRQcm9wcyA9IHtcbiAgICAgICAgZGVzY3JpcHRpb246IChfanN4KERlc2NyaXB0aW9uRmllbGRUZW1wbGF0ZSwgeyBpZDogZGVzY3JpcHRpb25JZChpZCksIGRlc2NyaXB0aW9uOiByaWNoRGVzY3JpcHRpb24sIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSksXG4gICAgICAgIHJhd0Rlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbixcbiAgICAgICAgaGVscDogaGVscENvbXBvbmVudCxcbiAgICAgICAgcmF3SGVscDogdHlwZW9mIGhlbHAgPT09ICdzdHJpbmcnID8gaGVscCA6IHVuZGVmaW5lZCxcbiAgICAgICAgZXJyb3JzOiBlcnJvcnNDb21wb25lbnQsXG4gICAgICAgIHJhd0Vycm9yczogaGlkZUVycm9yID8gdW5kZWZpbmVkIDogX19lcnJvcnMsXG4gICAgICAgIGlkLFxuICAgICAgICBsYWJlbCxcbiAgICAgICAgaGlkZGVuLFxuICAgICAgICBvbkNoYW5nZSxcbiAgICAgICAgb25LZXlDaGFuZ2UsXG4gICAgICAgIG9uRHJvcFByb3BlcnR5Q2xpY2ssXG4gICAgICAgIHJlcXVpcmVkLFxuICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgcmVhZG9ubHksXG4gICAgICAgIGhpZGVFcnJvcixcbiAgICAgICAgZGlzcGxheUxhYmVsLFxuICAgICAgICBjbGFzc05hbWVzOiBjbGFzc05hbWVzLmpvaW4oJyAnKS50cmltKCksXG4gICAgICAgIHN0eWxlOiB1aU9wdGlvbnMuc3R5bGUsXG4gICAgICAgIGZvcm1Db250ZXh0LFxuICAgICAgICBmb3JtRGF0YSxcbiAgICAgICAgc2NoZW1hLFxuICAgICAgICB1aVNjaGVtYSxcbiAgICAgICAgcmVnaXN0cnksXG4gICAgfTtcbiAgICBjb25zdCBfQW55T2ZGaWVsZCA9IHJlZ2lzdHJ5LmZpZWxkcy5BbnlPZkZpZWxkO1xuICAgIGNvbnN0IF9PbmVPZkZpZWxkID0gcmVnaXN0cnkuZmllbGRzLk9uZU9mRmllbGQ7XG4gICAgY29uc3QgaXNSZXBsYWNpbmdBbnlPck9uZU9mID0gKHVpU2NoZW1hID09PSBudWxsIHx8IHVpU2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1aVNjaGVtYVsndWk6ZmllbGQnXSkgJiYgKHVpU2NoZW1hID09PSBudWxsIHx8IHVpU2NoZW1hID09PSB2b2lkIDAgPyB2b2lkIDAgOiB1aVNjaGVtYVsndWk6ZmllbGRSZXBsYWNlc0FueU9yT25lT2YnXSkgPT09IHRydWU7XG4gICAgcmV0dXJuIChfanN4KEZpZWxkVGVtcGxhdGUsIHsgLi4uZmllbGRQcm9wcywgY2hpbGRyZW46IF9qc3hzKF9GcmFnbWVudCwgeyBjaGlsZHJlbjogW2ZpZWxkLCBzY2hlbWEuYW55T2YgJiYgIWlzUmVwbGFjaW5nQW55T3JPbmVPZiAmJiAhc2NoZW1hVXRpbHMuaXNTZWxlY3Qoc2NoZW1hKSAmJiAoX2pzeChfQW55T2ZGaWVsZCwgeyBuYW1lOiBuYW1lLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgaGlkZUVycm9yOiBoaWRlRXJyb3IsIGVycm9yU2NoZW1hOiBlcnJvclNjaGVtYSwgZm9ybURhdGE6IGZvcm1EYXRhLCBmb3JtQ29udGV4dDogZm9ybUNvbnRleHQsIGlkUHJlZml4OiBpZFByZWZpeCwgaWRTY2hlbWE6IGlkU2NoZW1hLCBpZFNlcGFyYXRvcjogaWRTZXBhcmF0b3IsIG9uQmx1cjogcHJvcHMub25CbHVyLCBvbkNoYW5nZTogcHJvcHMub25DaGFuZ2UsIG9uRm9jdXM6IHByb3BzLm9uRm9jdXMsIG9wdGlvbnM6IHNjaGVtYS5hbnlPZi5tYXAoKF9zY2hlbWEpID0+IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKGlzT2JqZWN0KF9zY2hlbWEpID8gX3NjaGVtYSA6IHt9LCBmb3JtRGF0YSkpLCByZWdpc3RyeTogcmVnaXN0cnksIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEgfSkpLCBzY2hlbWEub25lT2YgJiYgIWlzUmVwbGFjaW5nQW55T3JPbmVPZiAmJiAhc2NoZW1hVXRpbHMuaXNTZWxlY3Qoc2NoZW1hKSAmJiAoX2pzeChfT25lT2ZGaWVsZCwgeyBuYW1lOiBuYW1lLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgaGlkZUVycm9yOiBoaWRlRXJyb3IsIGVycm9yU2NoZW1hOiBlcnJvclNjaGVtYSwgZm9ybURhdGE6IGZvcm1EYXRhLCBmb3JtQ29udGV4dDogZm9ybUNvbnRleHQsIGlkUHJlZml4OiBpZFByZWZpeCwgaWRTY2hlbWE6IGlkU2NoZW1hLCBpZFNlcGFyYXRvcjogaWRTZXBhcmF0b3IsIG9uQmx1cjogcHJvcHMub25CbHVyLCBvbkNoYW5nZTogcHJvcHMub25DaGFuZ2UsIG9uRm9jdXM6IHByb3BzLm9uRm9jdXMsIG9wdGlvbnM6IHNjaGVtYS5vbmVPZi5tYXAoKF9zY2hlbWEpID0+IHNjaGVtYVV0aWxzLnJldHJpZXZlU2NoZW1hKGlzT2JqZWN0KF9zY2hlbWEpID8gX3NjaGVtYSA6IHt9LCBmb3JtRGF0YSkpLCByZWdpc3RyeTogcmVnaXN0cnksIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEgfSkpXSB9KSB9KSk7XG59XG4vKiogVGhlIGBTY2hlbWFGaWVsZGAgY29tcG9uZW50IGRldGVybWluZXMgd2hldGhlciBpdCBpcyBuZWNlc3NhcnkgdG8gcmVyZW5kZXIgdGhlIGNvbXBvbmVudCBiYXNlZCBvbiBhbnkgcHJvcHMgY2hhbmdlc1xuICogYW5kIGlmIHNvLCBjYWxscyB0aGUgYFNjaGVtYUZpZWxkUmVuZGVyYCBjb21wb25lbnQgd2l0aCB0aGUgcHJvcHMuXG4gKi9cbmNsYXNzIFNjaGVtYUZpZWxkIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBzaG91bGRDb21wb25lbnRVcGRhdGUobmV4dFByb3BzKSB7XG4gICAgICAgIHJldHVybiAhZGVlcEVxdWFscyh0aGlzLnByb3BzLCBuZXh0UHJvcHMpO1xuICAgIH1cbiAgICByZW5kZXIoKSB7XG4gICAgICAgIHJldHVybiBfanN4KFNjaGVtYUZpZWxkUmVuZGVyLCB7IC4uLnRoaXMucHJvcHMgfSk7XG4gICAgfVxufVxuZXhwb3J0IGRlZmF1bHQgU2NoZW1hRmllbGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TY2hlbWFGaWVsZC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZ2V0V2lkZ2V0LCBnZXRVaU9wdGlvbnMsIG9wdGlvbnNMaXN0LCBoYXNXaWRnZXQsIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgU3RyaW5nRmllbGRgIGNvbXBvbmVudCBpcyB1c2VkIHRvIHJlbmRlciBhIHNjaGVtYSBmaWVsZCB0aGF0IHJlcHJlc2VudHMgYSBzdHJpbmcgdHlwZVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgRmllbGRQcm9wc2AgZm9yIHRoaXMgdGVtcGxhdGVcbiAqL1xuZnVuY3Rpb24gU3RyaW5nRmllbGQocHJvcHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBzY2hlbWEsIG5hbWUsIHVpU2NoZW1hLCBpZFNjaGVtYSwgZm9ybURhdGEsIHJlcXVpcmVkLCBkaXNhYmxlZCA9IGZhbHNlLCByZWFkb25seSA9IGZhbHNlLCBhdXRvZm9jdXMgPSBmYWxzZSwgb25DaGFuZ2UsIG9uQmx1ciwgb25Gb2N1cywgcmVnaXN0cnksIHJhd0Vycm9ycywgaGlkZUVycm9yLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgeyB0aXRsZSwgZm9ybWF0IH0gPSBzY2hlbWE7XG4gICAgY29uc3QgeyB3aWRnZXRzLCBmb3JtQ29udGV4dCwgc2NoZW1hVXRpbHMsIGdsb2JhbFVpT3B0aW9ucyB9ID0gcmVnaXN0cnk7XG4gICAgY29uc3QgZW51bU9wdGlvbnMgPSBzY2hlbWFVdGlscy5pc1NlbGVjdChzY2hlbWEpID8gb3B0aW9uc0xpc3Qoc2NoZW1hKSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgZGVmYXVsdFdpZGdldCA9IGVudW1PcHRpb25zID8gJ3NlbGVjdCcgOiAndGV4dCc7XG4gICAgaWYgKGZvcm1hdCAmJiBoYXNXaWRnZXQoc2NoZW1hLCBmb3JtYXQsIHdpZGdldHMpKSB7XG4gICAgICAgIGRlZmF1bHRXaWRnZXQgPSBmb3JtYXQ7XG4gICAgfVxuICAgIGNvbnN0IHsgd2lkZ2V0ID0gZGVmYXVsdFdpZGdldCwgcGxhY2Vob2xkZXIgPSAnJywgdGl0bGU6IHVpVGl0bGUsIC4uLm9wdGlvbnMgfSA9IGdldFVpT3B0aW9ucyh1aVNjaGVtYSk7XG4gICAgY29uc3QgZGlzcGxheUxhYmVsID0gc2NoZW1hVXRpbHMuZ2V0RGlzcGxheUxhYmVsKHNjaGVtYSwgdWlTY2hlbWEsIGdsb2JhbFVpT3B0aW9ucyk7XG4gICAgY29uc3QgbGFiZWwgPSAoX2EgPSB1aVRpdGxlICE9PSBudWxsICYmIHVpVGl0bGUgIT09IHZvaWQgMCA/IHVpVGl0bGUgOiB0aXRsZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbmFtZTtcbiAgICBjb25zdCBXaWRnZXQgPSBnZXRXaWRnZXQoc2NoZW1hLCB3aWRnZXQsIHdpZGdldHMpO1xuICAgIHJldHVybiAoX2pzeChXaWRnZXQsIHsgb3B0aW9uczogeyAuLi5vcHRpb25zLCBlbnVtT3B0aW9ucyB9LCBzY2hlbWE6IHNjaGVtYSwgdWlTY2hlbWE6IHVpU2NoZW1hLCBpZDogaWRTY2hlbWEuJGlkLCBuYW1lOiBuYW1lLCBsYWJlbDogbGFiZWwsIGhpZGVMYWJlbDogIWRpc3BsYXlMYWJlbCwgaGlkZUVycm9yOiBoaWRlRXJyb3IsIHZhbHVlOiBmb3JtRGF0YSwgb25DaGFuZ2U6IG9uQ2hhbmdlLCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb25Gb2N1cywgcmVxdWlyZWQ6IHJlcXVpcmVkLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgZm9ybUNvbnRleHQ6IGZvcm1Db250ZXh0LCBhdXRvZm9jdXM6IGF1dG9mb2N1cywgcmVnaXN0cnk6IHJlZ2lzdHJ5LCBwbGFjZWhvbGRlcjogcGxhY2Vob2xkZXIsIHJhd0Vycm9yczogcmF3RXJyb3JzIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFN0cmluZ0ZpZWxkO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3RyaW5nRmllbGQuanMubWFwIiwiaW1wb3J0IEFycmF5RmllbGQgZnJvbSAnLi9BcnJheUZpZWxkJztcbmltcG9ydCBCb29sZWFuRmllbGQgZnJvbSAnLi9Cb29sZWFuRmllbGQnO1xuaW1wb3J0IE11bHRpU2NoZW1hRmllbGQgZnJvbSAnLi9NdWx0aVNjaGVtYUZpZWxkJztcbmltcG9ydCBOdW1iZXJGaWVsZCBmcm9tICcuL051bWJlckZpZWxkJztcbmltcG9ydCBPYmplY3RGaWVsZCBmcm9tICcuL09iamVjdEZpZWxkJztcbmltcG9ydCBTY2hlbWFGaWVsZCBmcm9tICcuL1NjaGVtYUZpZWxkJztcbmltcG9ydCBTdHJpbmdGaWVsZCBmcm9tICcuL1N0cmluZ0ZpZWxkJztcbmltcG9ydCBOdWxsRmllbGQgZnJvbSAnLi9OdWxsRmllbGQnO1xuZnVuY3Rpb24gZmllbGRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIEFueU9mRmllbGQ6IE11bHRpU2NoZW1hRmllbGQsXG4gICAgICAgIEFycmF5RmllbGQ6IEFycmF5RmllbGQsXG4gICAgICAgIC8vIEFycmF5RmllbGQgZmFsbHMgYmFjayB0byBTY2hlbWFGaWVsZCBpZiBBcnJheVNjaGVtYUZpZWxkIGlzIG5vdCBkZWZpbmVkLCB3aGljaCBpdCBpc24ndCBieSBkZWZhdWx0XG4gICAgICAgIEJvb2xlYW5GaWVsZCxcbiAgICAgICAgTnVtYmVyRmllbGQsXG4gICAgICAgIE9iamVjdEZpZWxkLFxuICAgICAgICBPbmVPZkZpZWxkOiBNdWx0aVNjaGVtYUZpZWxkLFxuICAgICAgICBTY2hlbWFGaWVsZCxcbiAgICAgICAgU3RyaW5nRmllbGQsXG4gICAgICAgIE51bGxGaWVsZCxcbiAgICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgZmllbGRzO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGRlc2NyaXB0aW9uSWQsIGdldFRlbXBsYXRlLCBnZXRVaU9wdGlvbnMsIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgQXJyYXlGaWVsZERlc2NyaXB0aW9uVGVtcGxhdGVgIGNvbXBvbmVudCByZW5kZXJzIGEgYERlc2NyaXB0aW9uRmllbGRUZW1wbGF0ZWAgd2l0aCBhbiBgaWRgIGRlcml2ZWQgZnJvbVxuICogdGhlIGBpZFNjaGVtYWAuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBBcnJheUZpZWxkRGVzY3JpcHRpb25Qcm9wc2AgZm9yIHRoZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXJyYXlGaWVsZERlc2NyaXB0aW9uVGVtcGxhdGUocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkU2NoZW1hLCBkZXNjcmlwdGlvbiwgcmVnaXN0cnksIHNjaGVtYSwgdWlTY2hlbWEgfSA9IHByb3BzO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRVaU9wdGlvbnModWlTY2hlbWEsIHJlZ2lzdHJ5Lmdsb2JhbFVpT3B0aW9ucyk7XG4gICAgY29uc3QgeyBsYWJlbDogZGlzcGxheUxhYmVsID0gdHJ1ZSB9ID0gb3B0aW9ucztcbiAgICBpZiAoIWRlc2NyaXB0aW9uIHx8ICFkaXNwbGF5TGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IERlc2NyaXB0aW9uRmllbGRUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdEZXNjcmlwdGlvbkZpZWxkVGVtcGxhdGUnLCByZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIChfanN4KERlc2NyaXB0aW9uRmllbGRUZW1wbGF0ZSwgeyBpZDogZGVzY3JpcHRpb25JZChpZFNjaGVtYSksIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiwgc2NoZW1hOiBzY2hlbWEsIHVpU2NoZW1hOiB1aVNjaGVtYSwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5RmllbGREZXNjcmlwdGlvblRlbXBsYXRlLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG4vKiogVGhlIGBBcnJheUZpZWxkSXRlbVRlbXBsYXRlYCBjb21wb25lbnQgaXMgdGhlIHRlbXBsYXRlIHVzZWQgdG8gcmVuZGVyIGFuIGl0ZW1zIG9mIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgQXJyYXlGaWVsZFRlbXBsYXRlSXRlbVR5cGVgIHByb3BzIGZvciB0aGUgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFycmF5RmllbGRJdGVtVGVtcGxhdGUocHJvcHMpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUsIGRpc2FibGVkLCBoYXNUb29sYmFyLCBoYXNNb3ZlRG93biwgaGFzTW92ZVVwLCBoYXNSZW1vdmUsIGhhc0NvcHksIGluZGV4LCBvbkNvcHlJbmRleENsaWNrLCBvbkRyb3BJbmRleENsaWNrLCBvblJlb3JkZXJDbGljaywgcmVhZG9ubHksIHJlZ2lzdHJ5LCB1aVNjaGVtYSwgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgQ29weUJ1dHRvbiwgTW92ZURvd25CdXR0b24sIE1vdmVVcEJ1dHRvbiwgUmVtb3ZlQnV0dG9uIH0gPSByZWdpc3RyeS50ZW1wbGF0ZXMuQnV0dG9uVGVtcGxhdGVzO1xuICAgIGNvbnN0IGJ0blN0eWxlID0ge1xuICAgICAgICBmbGV4OiAxLFxuICAgICAgICBwYWRkaW5nTGVmdDogNixcbiAgICAgICAgcGFkZGluZ1JpZ2h0OiA2LFxuICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgfTtcbiAgICByZXR1cm4gKF9qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGNoaWxkcmVuOiBbX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogaGFzVG9vbGJhciA/ICdjb2wteHMtOScgOiAnY29sLXhzLTEyJywgY2hpbGRyZW46IGNoaWxkcmVuIH0pLCBoYXNUb29sYmFyICYmIChfanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnY29sLXhzLTMgYXJyYXktaXRlbS10b29sYm94JywgY2hpbGRyZW46IF9qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnYnRuLWdyb3VwJywgc3R5bGU6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnc3BhY2UtYXJvdW5kJyxcbiAgICAgICAgICAgICAgICAgICAgfSwgY2hpbGRyZW46IFsoaGFzTW92ZVVwIHx8IGhhc01vdmVEb3duKSAmJiAoX2pzeChNb3ZlVXBCdXR0b24sIHsgc3R5bGU6IGJ0blN0eWxlLCBkaXNhYmxlZDogZGlzYWJsZWQgfHwgcmVhZG9ubHkgfHwgIWhhc01vdmVVcCwgb25DbGljazogb25SZW9yZGVyQ2xpY2soaW5kZXgsIGluZGV4IC0gMSksIHVpU2NoZW1hOiB1aVNjaGVtYSwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKSwgKGhhc01vdmVVcCB8fCBoYXNNb3ZlRG93bikgJiYgKF9qc3goTW92ZURvd25CdXR0b24sIHsgc3R5bGU6IGJ0blN0eWxlLCBkaXNhYmxlZDogZGlzYWJsZWQgfHwgcmVhZG9ubHkgfHwgIWhhc01vdmVEb3duLCBvbkNsaWNrOiBvblJlb3JkZXJDbGljayhpbmRleCwgaW5kZXggKyAxKSwgdWlTY2hlbWE6IHVpU2NoZW1hLCByZWdpc3RyeTogcmVnaXN0cnkgfSkpLCBoYXNDb3B5ICYmIChfanN4KENvcHlCdXR0b24sIHsgc3R5bGU6IGJ0blN0eWxlLCBkaXNhYmxlZDogZGlzYWJsZWQgfHwgcmVhZG9ubHksIG9uQ2xpY2s6IG9uQ29weUluZGV4Q2xpY2soaW5kZXgpLCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSksIGhhc1JlbW92ZSAmJiAoX2pzeChSZW1vdmVCdXR0b24sIHsgc3R5bGU6IGJ0blN0eWxlLCBkaXNhYmxlZDogZGlzYWJsZWQgfHwgcmVhZG9ubHksIG9uQ2xpY2s6IG9uRHJvcEluZGV4Q2xpY2soaW5kZXgpLCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSldIH0pIH0pKV0gfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXJyYXlGaWVsZEl0ZW1UZW1wbGF0ZS5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUsIGdldFVpT3B0aW9ucywgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBBcnJheUZpZWxkVGVtcGxhdGVgIGNvbXBvbmVudCBpcyB0aGUgdGVtcGxhdGUgdXNlZCB0byByZW5kZXIgYWxsIGl0ZW1zIGluIGFuIGFycmF5LlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgQXJyYXlGaWVsZFRlbXBsYXRlSXRlbVR5cGVgIHByb3BzIGZvciB0aGUgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFycmF5RmllbGRUZW1wbGF0ZShwcm9wcykge1xuICAgIGNvbnN0IHsgY2FuQWRkLCBjbGFzc05hbWUsIGRpc2FibGVkLCBpZFNjaGVtYSwgdWlTY2hlbWEsIGl0ZW1zLCBvbkFkZENsaWNrLCByZWFkb25seSwgcmVnaXN0cnksIHJlcXVpcmVkLCBzY2hlbWEsIHRpdGxlLCB9ID0gcHJvcHM7XG4gICAgY29uc3QgdWlPcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgICBjb25zdCBBcnJheUZpZWxkRGVzY3JpcHRpb25UZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdBcnJheUZpZWxkRGVzY3JpcHRpb25UZW1wbGF0ZScsIHJlZ2lzdHJ5LCB1aU9wdGlvbnMpO1xuICAgIGNvbnN0IEFycmF5RmllbGRJdGVtVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnQXJyYXlGaWVsZEl0ZW1UZW1wbGF0ZScsIHJlZ2lzdHJ5LCB1aU9wdGlvbnMpO1xuICAgIGNvbnN0IEFycmF5RmllbGRUaXRsZVRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0FycmF5RmllbGRUaXRsZVRlbXBsYXRlJywgcmVnaXN0cnksIHVpT3B0aW9ucyk7XG4gICAgLy8gQnV0dG9uIHRlbXBsYXRlcyBhcmUgbm90IG92ZXJyaWRkZW4gaW4gdGhlIHVpU2NoZW1hXG4gICAgY29uc3QgeyBCdXR0b25UZW1wbGF0ZXM6IHsgQWRkQnV0dG9uIH0sIH0gPSByZWdpc3RyeS50ZW1wbGF0ZXM7XG4gICAgcmV0dXJuIChfanN4cyhcImZpZWxkc2V0XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWUsIGlkOiBpZFNjaGVtYS4kaWQsIGNoaWxkcmVuOiBbX2pzeChBcnJheUZpZWxkVGl0bGVUZW1wbGF0ZSwgeyBpZFNjaGVtYTogaWRTY2hlbWEsIHRpdGxlOiB1aU9wdGlvbnMudGl0bGUgfHwgdGl0bGUsIHJlcXVpcmVkOiByZXF1aXJlZCwgc2NoZW1hOiBzY2hlbWEsIHVpU2NoZW1hOiB1aVNjaGVtYSwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pLCBfanN4KEFycmF5RmllbGREZXNjcmlwdGlvblRlbXBsYXRlLCB7IGlkU2NoZW1hOiBpZFNjaGVtYSwgZGVzY3JpcHRpb246IHVpT3B0aW9ucy5kZXNjcmlwdGlvbiB8fCBzY2hlbWEuZGVzY3JpcHRpb24sIHNjaGVtYTogc2NoZW1hLCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSwgX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ3JvdyBhcnJheS1pdGVtLWxpc3QnLCBjaGlsZHJlbjogaXRlbXMgJiZcbiAgICAgICAgICAgICAgICAgICAgaXRlbXMubWFwKCh7IGtleSwgLi4uaXRlbVByb3BzIH0pID0+IChfanN4KEFycmF5RmllbGRJdGVtVGVtcGxhdGUsIHsgLi4uaXRlbVByb3BzIH0sIGtleSkpKSB9KSwgY2FuQWRkICYmIChfanN4KEFkZEJ1dHRvbiwgeyBjbGFzc05hbWU6ICdhcnJheS1pdGVtLWFkZCcsIG9uQ2xpY2s6IG9uQWRkQ2xpY2ssIGRpc2FibGVkOiBkaXNhYmxlZCB8fCByZWFkb25seSwgdWlTY2hlbWE6IHVpU2NoZW1hLCByZWdpc3RyeTogcmVnaXN0cnkgfSkpXSB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BcnJheUZpZWxkVGVtcGxhdGUuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGdldFRlbXBsYXRlLCBnZXRVaU9wdGlvbnMsIHRpdGxlSWQsIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgQXJyYXlGaWVsZFRpdGxlVGVtcGxhdGVgIGNvbXBvbmVudCByZW5kZXJzIGEgYFRpdGxlRmllbGRUZW1wbGF0ZWAgd2l0aCBhbiBgaWRgIGRlcml2ZWQgZnJvbVxuICogdGhlIGBpZFNjaGVtYWAuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBBcnJheUZpZWxkVGl0bGVQcm9wc2AgZm9yIHRoZSBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXJyYXlGaWVsZFRpdGxlVGVtcGxhdGUocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkU2NoZW1hLCB0aXRsZSwgc2NoZW1hLCB1aVNjaGVtYSwgcmVxdWlyZWQsIHJlZ2lzdHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hLCByZWdpc3RyeS5nbG9iYWxVaU9wdGlvbnMpO1xuICAgIGNvbnN0IHsgbGFiZWw6IGRpc3BsYXlMYWJlbCA9IHRydWUgfSA9IG9wdGlvbnM7XG4gICAgaWYgKCF0aXRsZSB8fCAhZGlzcGxheUxhYmVsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBUaXRsZUZpZWxkVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnVGl0bGVGaWVsZFRlbXBsYXRlJywgcmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIHJldHVybiAoX2pzeChUaXRsZUZpZWxkVGVtcGxhdGUsIHsgaWQ6IHRpdGxlSWQoaWRTY2hlbWEpLCB0aXRsZTogdGl0bGUsIHJlcXVpcmVkOiByZXF1aXJlZCwgc2NoZW1hOiBzY2hlbWEsIHVpU2NoZW1hOiB1aVNjaGVtYSwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFycmF5RmllbGRUaXRsZVRlbXBsYXRlLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXJpYURlc2NyaWJlZEJ5SWRzLCBleGFtcGxlc0lkLCBnZXRJbnB1dFByb3BzLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYEJhc2VJbnB1dFRlbXBsYXRlYCBpcyB0aGUgdGVtcGxhdGUgdG8gdXNlIHRvIHJlbmRlciB0aGUgYmFzaWMgYDxpbnB1dD5gIGNvbXBvbmVudCBmb3IgdGhlIGBjb3JlYCB0aGVtZS5cbiAqIEl0IGlzIHVzZWQgYXMgdGhlIHRlbXBsYXRlIGZvciByZW5kZXJpbmcgbWFueSBvZiB0aGUgPGlucHV0PiBiYXNlZCB3aWRnZXRzIHRoYXQgZGlmZmVyIGJ5IGB0eXBlYCBhbmQgY2FsbGJhY2tzIG9ubHkuXG4gKiBJdCBjYW4gYmUgY3VzdG9taXplZC9vdmVycmlkZGVuIGZvciBvdGhlciB0aGVtZXMgb3IgaW5kaXZpZHVhbCBpbXBsZW1lbnRhdGlvbnMgYXMgbmVlZGVkLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIHRlbXBsYXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEJhc2VJbnB1dFRlbXBsYXRlKHByb3BzKSB7XG4gICAgY29uc3QgeyBpZCwgbmFtZSwgLy8gcmVtb3ZlIHRoaXMgZnJvbSAuLi5yZXN0XG4gICAgdmFsdWUsIHJlYWRvbmx5LCBkaXNhYmxlZCwgYXV0b2ZvY3VzLCBvbkJsdXIsIG9uRm9jdXMsIG9uQ2hhbmdlLCBvbkNoYW5nZU92ZXJyaWRlLCBvcHRpb25zLCBzY2hlbWEsIHVpU2NoZW1hLCBmb3JtQ29udGV4dCwgcmVnaXN0cnksIHJhd0Vycm9ycywgdHlwZSwgaGlkZUxhYmVsLCAvLyByZW1vdmUgdGhpcyBmcm9tIC4uLnJlc3RcbiAgICBoaWRlRXJyb3IsIC8vIHJlbW92ZSB0aGlzIGZyb20gLi4ucmVzdFxuICAgIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIC8vIE5vdGU6IHNpbmNlIFJlYWN0IDE1LjIuMCB3ZSBjYW4ndCBmb3J3YXJkIHVua25vd24gZWxlbWVudCBhdHRyaWJ1dGVzLCBzbyB3ZVxuICAgIC8vIGV4Y2x1ZGUgdGhlIFwib3B0aW9uc1wiIGFuZCBcInNjaGVtYVwiIG9uZXMgaGVyZS5cbiAgICBpZiAoIWlkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdObyBpZCBmb3InLCBwcm9wcyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gaWQgZm9yIHByb3BzICR7SlNPTi5zdHJpbmdpZnkocHJvcHMpfWApO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dFByb3BzID0ge1xuICAgICAgICAuLi5yZXN0LFxuICAgICAgICAuLi5nZXRJbnB1dFByb3BzKHNjaGVtYSwgdHlwZSwgb3B0aW9ucyksXG4gICAgfTtcbiAgICBsZXQgaW5wdXRWYWx1ZTtcbiAgICBpZiAoaW5wdXRQcm9wcy50eXBlID09PSAnbnVtYmVyJyB8fCBpbnB1dFByb3BzLnR5cGUgPT09ICdpbnRlZ2VyJykge1xuICAgICAgICBpbnB1dFZhbHVlID0gdmFsdWUgfHwgdmFsdWUgPT09IDAgPyB2YWx1ZSA6ICcnO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaW5wdXRWYWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBfb25DaGFuZ2UgPSB1c2VDYWxsYmFjaygoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiBvbkNoYW5nZSh2YWx1ZSA9PT0gJycgPyBvcHRpb25zLmVtcHR5VmFsdWUgOiB2YWx1ZSksIFtvbkNoYW5nZSwgb3B0aW9uc10pO1xuICAgIGNvbnN0IF9vbkJsdXIgPSB1c2VDYWxsYmFjaygoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiBvbkJsdXIoaWQsIHZhbHVlKSwgW29uQmx1ciwgaWRdKTtcbiAgICBjb25zdCBfb25Gb2N1cyA9IHVzZUNhbGxiYWNrKCh7IHRhcmdldDogeyB2YWx1ZSB9IH0pID0+IG9uRm9jdXMoaWQsIHZhbHVlKSwgW29uRm9jdXMsIGlkXSk7XG4gICAgcmV0dXJuIChfanN4cyhfRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtfanN4KFwiaW5wdXRcIiwgeyBpZDogaWQsIG5hbWU6IGlkLCBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCByZWFkT25seTogcmVhZG9ubHksIGRpc2FibGVkOiBkaXNhYmxlZCwgYXV0b0ZvY3VzOiBhdXRvZm9jdXMsIHZhbHVlOiBpbnB1dFZhbHVlLCAuLi5pbnB1dFByb3BzLCBsaXN0OiBzY2hlbWEuZXhhbXBsZXMgPyBleGFtcGxlc0lkKGlkKSA6IHVuZGVmaW5lZCwgb25DaGFuZ2U6IG9uQ2hhbmdlT3ZlcnJpZGUgfHwgX29uQ2hhbmdlLCBvbkJsdXI6IF9vbkJsdXIsIG9uRm9jdXM6IF9vbkZvY3VzLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5SWRzKGlkLCAhIXNjaGVtYS5leGFtcGxlcykgfSksIEFycmF5LmlzQXJyYXkoc2NoZW1hLmV4YW1wbGVzKSAmJiAoX2pzeChcImRhdGFsaXN0XCIsIHsgaWQ6IGV4YW1wbGVzSWQoaWQpLCBjaGlsZHJlbjogc2NoZW1hLmV4YW1wbGVzXG4gICAgICAgICAgICAgICAgICAgIC5jb25jYXQoc2NoZW1hLmRlZmF1bHQgJiYgIXNjaGVtYS5leGFtcGxlcy5pbmNsdWRlcyhzY2hlbWEuZGVmYXVsdCkgPyBbc2NoZW1hLmRlZmF1bHRdIDogW10pXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGV4YW1wbGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9qc3goXCJvcHRpb25cIiwgeyB2YWx1ZTogZXhhbXBsZSB9LCBleGFtcGxlKTtcbiAgICAgICAgICAgICAgICB9KSB9LCBgZGF0YWxpc3RfJHtpZH1gKSldIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJhc2VJbnB1dFRlbXBsYXRlLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBUcmFuc2xhdGFibGVTdHJpbmcgfSBmcm9tICdAcmpzZi91dGlscyc7XG5pbXBvcnQgSWNvbkJ1dHRvbiBmcm9tICcuL0ljb25CdXR0b24nO1xuLyoqIFRoZSBgQWRkQnV0dG9uYCByZW5kZXJzIGEgYnV0dG9uIHRoYXQgcmVwcmVzZW50IHRoZSBgQWRkYCBhY3Rpb24gb24gYSBmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFkZEJ1dHRvbih7IGNsYXNzTmFtZSwgb25DbGljaywgZGlzYWJsZWQsIHJlZ2lzdHJ5LCB9KSB7XG4gICAgY29uc3QgeyB0cmFuc2xhdGVTdHJpbmcgfSA9IHJlZ2lzdHJ5O1xuICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ3JvdycsIGNoaWxkcmVuOiBfanN4KFwicFwiLCB7IGNsYXNzTmFtZTogYGNvbC14cy0zIGNvbC14cy1vZmZzZXQtOSB0ZXh0LXJpZ2h0ICR7Y2xhc3NOYW1lfWAsIGNoaWxkcmVuOiBfanN4KEljb25CdXR0b24sIHsgaWNvblR5cGU6ICdpbmZvJywgaWNvbjogJ3BsdXMnLCBjbGFzc05hbWU6ICdidG4tYWRkIGNvbC14cy0xMicsIHRpdGxlOiB0cmFuc2xhdGVTdHJpbmcoVHJhbnNsYXRhYmxlU3RyaW5nLkFkZEJ1dHRvbiksIG9uQ2xpY2s6IG9uQ2xpY2ssIGRpc2FibGVkOiBkaXNhYmxlZCwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pIH0pIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFkZEJ1dHRvbi5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgVHJhbnNsYXRhYmxlU3RyaW5nIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSWNvbkJ1dHRvbihwcm9wcykge1xuICAgIGNvbnN0IHsgaWNvblR5cGUgPSAnZGVmYXVsdCcsIGljb24sIGNsYXNzTmFtZSwgdWlTY2hlbWEsIHJlZ2lzdHJ5LCAuLi5vdGhlclByb3BzIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKF9qc3goXCJidXR0b25cIiwgeyB0eXBlOiAnYnV0dG9uJywgY2xhc3NOYW1lOiBgYnRuIGJ0bi0ke2ljb25UeXBlfSAke2NsYXNzTmFtZX1gLCAuLi5vdGhlclByb3BzLCBjaGlsZHJlbjogX2pzeChcImlcIiwgeyBjbGFzc05hbWU6IGBnbHlwaGljb24gZ2x5cGhpY29uLSR7aWNvbn1gIH0pIH0pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBDb3B5QnV0dG9uKHByb3BzKSB7XG4gICAgY29uc3QgeyByZWdpc3RyeTogeyB0cmFuc2xhdGVTdHJpbmcgfSwgfSA9IHByb3BzO1xuICAgIHJldHVybiAoX2pzeChJY29uQnV0dG9uLCB7IHRpdGxlOiB0cmFuc2xhdGVTdHJpbmcoVHJhbnNsYXRhYmxlU3RyaW5nLkNvcHlCdXR0b24pLCBjbGFzc05hbWU6ICdhcnJheS1pdGVtLWNvcHknLCAuLi5wcm9wcywgaWNvbjogJ2NvcHknIH0pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBNb3ZlRG93bkJ1dHRvbihwcm9wcykge1xuICAgIGNvbnN0IHsgcmVnaXN0cnk6IHsgdHJhbnNsYXRlU3RyaW5nIH0sIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKF9qc3goSWNvbkJ1dHRvbiwgeyB0aXRsZTogdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5Nb3ZlRG93bkJ1dHRvbiksIGNsYXNzTmFtZTogJ2FycmF5LWl0ZW0tbW92ZS1kb3duJywgLi4ucHJvcHMsIGljb246ICdhcnJvdy1kb3duJyB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gTW92ZVVwQnV0dG9uKHByb3BzKSB7XG4gICAgY29uc3QgeyByZWdpc3RyeTogeyB0cmFuc2xhdGVTdHJpbmcgfSwgfSA9IHByb3BzO1xuICAgIHJldHVybiAoX2pzeChJY29uQnV0dG9uLCB7IHRpdGxlOiB0cmFuc2xhdGVTdHJpbmcoVHJhbnNsYXRhYmxlU3RyaW5nLk1vdmVVcEJ1dHRvbiksIGNsYXNzTmFtZTogJ2FycmF5LWl0ZW0tbW92ZS11cCcsIC4uLnByb3BzLCBpY29uOiAnYXJyb3ctdXAnIH0pKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBSZW1vdmVCdXR0b24ocHJvcHMpIHtcbiAgICBjb25zdCB7IHJlZ2lzdHJ5OiB7IHRyYW5zbGF0ZVN0cmluZyB9LCB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChfanN4KEljb25CdXR0b24sIHsgdGl0bGU6IHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuUmVtb3ZlQnV0dG9uKSwgY2xhc3NOYW1lOiAnYXJyYXktaXRlbS1yZW1vdmUnLCAuLi5wcm9wcywgaWNvblR5cGU6ICdkYW5nZXInLCBpY29uOiAncmVtb3ZlJyB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uQnV0dG9uLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBnZXRTdWJtaXRCdXR0b25PcHRpb25zIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgU3VibWl0QnV0dG9uYCByZW5kZXJzIGEgYnV0dG9uIHRoYXQgcmVwcmVzZW50IHRoZSBgU3VibWl0YCBhY3Rpb24gb24gYSBmb3JtXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFN1Ym1pdEJ1dHRvbih7IHVpU2NoZW1hIH0pIHtcbiAgICBjb25zdCB7IHN1Ym1pdFRleHQsIG5vcmVuZGVyLCBwcm9wczogc3VibWl0QnV0dG9uUHJvcHMgPSB7fSB9ID0gZ2V0U3VibWl0QnV0dG9uT3B0aW9ucyh1aVNjaGVtYSk7XG4gICAgaWYgKG5vcmVuZGVyKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKF9qc3goXCJkaXZcIiwgeyBjaGlsZHJlbjogX2pzeChcImJ1dHRvblwiLCB7IHR5cGU6ICdzdWJtaXQnLCAuLi5zdWJtaXRCdXR0b25Qcm9wcywgY2xhc3NOYW1lOiBgYnRuIGJ0bi1pbmZvICR7c3VibWl0QnV0dG9uUHJvcHMuY2xhc3NOYW1lIHx8ICcnfWAsIGNoaWxkcmVuOiBzdWJtaXRUZXh0IH0pIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVN1Ym1pdEJ1dHRvbi5qcy5tYXAiLCJpbXBvcnQgU3VibWl0QnV0dG9uIGZyb20gJy4vU3VibWl0QnV0dG9uJztcbmltcG9ydCBBZGRCdXR0b24gZnJvbSAnLi9BZGRCdXR0b24nO1xuaW1wb3J0IHsgQ29weUJ1dHRvbiwgTW92ZURvd25CdXR0b24sIE1vdmVVcEJ1dHRvbiwgUmVtb3ZlQnV0dG9uIH0gZnJvbSAnLi9JY29uQnV0dG9uJztcbmZ1bmN0aW9uIGJ1dHRvblRlbXBsYXRlcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBTdWJtaXRCdXR0b24sXG4gICAgICAgIEFkZEJ1dHRvbixcbiAgICAgICAgQ29weUJ1dHRvbixcbiAgICAgICAgTW92ZURvd25CdXR0b24sXG4gICAgICAgIE1vdmVVcEJ1dHRvbixcbiAgICAgICAgUmVtb3ZlQnV0dG9uLFxuICAgIH07XG59XG5leHBvcnQgZGVmYXVsdCBidXR0b25UZW1wbGF0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuLyoqIFRoZSBgRGVzY3JpcHRpb25GaWVsZGAgaXMgdGhlIHRlbXBsYXRlIHRvIHVzZSB0byByZW5kZXIgdGhlIGRlc2NyaXB0aW9uIG9mIGEgZmllbGRcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYERlc2NyaXB0aW9uRmllbGRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERlc2NyaXB0aW9uRmllbGQocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkLCBkZXNjcmlwdGlvbiB9ID0gcHJvcHM7XG4gICAgaWYgKCFkZXNjcmlwdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkZXNjcmlwdGlvbiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIChfanN4KFwicFwiLCB7IGlkOiBpZCwgY2xhc3NOYW1lOiAnZmllbGQtZGVzY3JpcHRpb24nLCBjaGlsZHJlbjogZGVzY3JpcHRpb24gfSkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChfanN4KFwiZGl2XCIsIHsgaWQ6IGlkLCBjbGFzc05hbWU6ICdmaWVsZC1kZXNjcmlwdGlvbicsIGNoaWxkcmVuOiBkZXNjcmlwdGlvbiB9KSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGVzY3JpcHRpb25GaWVsZC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgVHJhbnNsYXRhYmxlU3RyaW5nLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYEVycm9yTGlzdGAgY29tcG9uZW50IGlzIHRoZSB0ZW1wbGF0ZSB0aGF0IHJlbmRlcnMgdGhlIGFsbCB0aGUgZXJyb3JzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZmllbGRzIGluIHRoZSBgRm9ybWBcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEVycm9yTGlzdFByb3BzYCBmb3IgdGhpcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRXJyb3JMaXN0KHsgZXJyb3JzLCByZWdpc3RyeSwgfSkge1xuICAgIGNvbnN0IHsgdHJhbnNsYXRlU3RyaW5nIH0gPSByZWdpc3RyeTtcbiAgICByZXR1cm4gKF9qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAncGFuZWwgcGFuZWwtZGFuZ2VyIGVycm9ycycsIGNoaWxkcmVuOiBbX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ3BhbmVsLWhlYWRpbmcnLCBjaGlsZHJlbjogX2pzeChcImgzXCIsIHsgY2xhc3NOYW1lOiAncGFuZWwtdGl0bGUnLCBjaGlsZHJlbjogdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5FcnJvcnNMYWJlbCkgfSkgfSksIF9qc3goXCJ1bFwiLCB7IGNsYXNzTmFtZTogJ2xpc3QtZ3JvdXAnLCBjaGlsZHJlbjogZXJyb3JzLm1hcCgoZXJyb3IsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfanN4KFwibGlcIiwgeyBjbGFzc05hbWU6ICdsaXN0LWdyb3VwLWl0ZW0gdGV4dC1kYW5nZXInLCBjaGlsZHJlbjogZXJyb3Iuc3RhY2sgfSwgaSkpO1xuICAgICAgICAgICAgICAgIH0pIH0pXSB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1FcnJvckxpc3QuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGVycm9ySWQgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBGaWVsZEVycm9yVGVtcGxhdGVgIGNvbXBvbmVudCByZW5kZXJzIHRoZSBlcnJvcnMgbG9jYWwgdG8gdGhlIHBhcnRpY3VsYXIgZmllbGRcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEZpZWxkRXJyb3JQcm9wc2AgZm9yIHRoZSBlcnJvcnMgYmVpbmcgcmVuZGVyZWRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmllbGRFcnJvclRlbXBsYXRlKHByb3BzKSB7XG4gICAgY29uc3QgeyBlcnJvcnMgPSBbXSwgaWRTY2hlbWEgfSA9IHByb3BzO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGVycm9ySWQoaWRTY2hlbWEpO1xuICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNoaWxkcmVuOiBfanN4KFwidWxcIiwgeyBpZDogaWQsIGNsYXNzTmFtZTogJ2Vycm9yLWRldGFpbCBicy1jYWxsb3V0IGJzLWNhbGxvdXQtaW5mbycsIGNoaWxkcmVuOiBlcnJvcnNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChlbGVtKSA9PiAhIWVsZW0pXG4gICAgICAgICAgICAgICAgLm1hcCgoZXJyb3IsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChfanN4KFwibGlcIiwgeyBjbGFzc05hbWU6ICd0ZXh0LWRhbmdlcicsIGNoaWxkcmVuOiBlcnJvciB9LCBpbmRleCkpO1xuICAgICAgICAgICAgfSkgfSkgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RmllbGRFcnJvclRlbXBsYXRlLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBoZWxwSWQgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBGaWVsZEhlbHBUZW1wbGF0ZWAgY29tcG9uZW50IHJlbmRlcnMgYW55IGhlbHAgZGVzaXJlZCBmb3IgYSBmaWVsZFxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgRmllbGRIZWxwUHJvcHNgIHRvIGJlIHJlbmRlcmVkXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZpZWxkSGVscFRlbXBsYXRlKHByb3BzKSB7XG4gICAgY29uc3QgeyBpZFNjaGVtYSwgaGVscCB9ID0gcHJvcHM7XG4gICAgaWYgKCFoZWxwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGhlbHBJZChpZFNjaGVtYSk7XG4gICAgaWYgKHR5cGVvZiBoZWxwID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gKF9qc3goXCJwXCIsIHsgaWQ6IGlkLCBjbGFzc05hbWU6ICdoZWxwLWJsb2NrJywgY2hpbGRyZW46IGhlbHAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gKF9qc3goXCJkaXZcIiwgeyBpZDogaWQsIGNsYXNzTmFtZTogJ2hlbHAtYmxvY2snLCBjaGlsZHJlbjogaGVscCB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWVsZEhlbHBUZW1wbGF0ZS5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUsIGdldFVpT3B0aW9ucywgfSBmcm9tICdAcmpzZi91dGlscyc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi9MYWJlbCc7XG4vKiogVGhlIGBGaWVsZFRlbXBsYXRlYCBjb21wb25lbnQgaXMgdGhlIHRlbXBsYXRlIHVzZWQgYnkgYFNjaGVtYUZpZWxkYCB0byByZW5kZXIgYW55IGZpZWxkLiBJdCByZW5kZXJzIHRoZSBmaWVsZFxuICogY29udGVudCwgKGxhYmVsLCBkZXNjcmlwdGlvbiwgY2hpbGRyZW4sIGVycm9ycyBhbmQgaGVscCkgaW5zaWRlIG9mIGEgYFdyYXBJZkFkZGl0aW9uYWxgIGNvbXBvbmVudC5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEZpZWxkVGVtcGxhdGVQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZpZWxkVGVtcGxhdGUocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkLCBsYWJlbCwgY2hpbGRyZW4sIGVycm9ycywgaGVscCwgZGVzY3JpcHRpb24sIGhpZGRlbiwgcmVxdWlyZWQsIGRpc3BsYXlMYWJlbCwgcmVnaXN0cnksIHVpU2NoZW1hIH0gPSBwcm9wcztcbiAgICBjb25zdCB1aU9wdGlvbnMgPSBnZXRVaU9wdGlvbnModWlTY2hlbWEpO1xuICAgIGNvbnN0IFdyYXBJZkFkZGl0aW9uYWxUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdXcmFwSWZBZGRpdGlvbmFsVGVtcGxhdGUnLCByZWdpc3RyeSwgdWlPcHRpb25zKTtcbiAgICBpZiAoaGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBfanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnaGlkZGVuJywgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xuICAgIH1cbiAgICByZXR1cm4gKF9qc3hzKFdyYXBJZkFkZGl0aW9uYWxUZW1wbGF0ZSwgeyAuLi5wcm9wcywgY2hpbGRyZW46IFtkaXNwbGF5TGFiZWwgJiYgX2pzeChMYWJlbCwgeyBsYWJlbDogbGFiZWwsIHJlcXVpcmVkOiByZXF1aXJlZCwgaWQ6IGlkIH0pLCBkaXNwbGF5TGFiZWwgJiYgZGVzY3JpcHRpb24gPyBkZXNjcmlwdGlvbiA6IG51bGwsIGNoaWxkcmVuLCBlcnJvcnMsIGhlbHBdIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZpZWxkVGVtcGxhdGUuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IFJFUVVJUkVEX0ZJRUxEX1NZTUJPTCA9ICcqJztcbi8qKiBSZW5kZXJzIGEgbGFiZWwgZm9yIGEgZmllbGRcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYExhYmVsUHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBMYWJlbChwcm9wcykge1xuICAgIGNvbnN0IHsgbGFiZWwsIHJlcXVpcmVkLCBpZCB9ID0gcHJvcHM7XG4gICAgaWYgKCFsYWJlbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChfanN4cyhcImxhYmVsXCIsIHsgY2xhc3NOYW1lOiAnY29udHJvbC1sYWJlbCcsIGh0bWxGb3I6IGlkLCBjaGlsZHJlbjogW2xhYmVsLCByZXF1aXJlZCAmJiBfanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ3JlcXVpcmVkJywgY2hpbGRyZW46IFJFUVVJUkVEX0ZJRUxEX1NZTUJPTCB9KV0gfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TGFiZWwuanMubWFwIiwiaW1wb3J0IEZpZWxkVGVtcGxhdGUgZnJvbSAnLi9GaWVsZFRlbXBsYXRlJztcbmV4cG9ydCBkZWZhdWx0IEZpZWxkVGVtcGxhdGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgY2FuRXhwYW5kLCBkZXNjcmlwdGlvbklkLCBnZXRUZW1wbGF0ZSwgZ2V0VWlPcHRpb25zLCB0aXRsZUlkLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYE9iamVjdEZpZWxkVGVtcGxhdGVgIGlzIHRoZSB0ZW1wbGF0ZSB0byB1c2UgdG8gcmVuZGVyIGFsbCB0aGUgaW5uZXIgcHJvcGVydGllcyBvZiBhbiBvYmplY3QgYWxvbmcgd2l0aCB0aGVcbiAqIHRpdGxlIGFuZCBkZXNjcmlwdGlvbiBpZiBhdmFpbGFibGUuIElmIHRoZSBvYmplY3QgaXMgZXhwYW5kYWJsZSwgdGhlbiBhbiBgQWRkQnV0dG9uYCBpcyBhbHNvIHJlbmRlcmVkIGFmdGVyIGFsbFxuICogdGhlIHByb3BlcnRpZXMuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBPYmplY3RGaWVsZFRlbXBsYXRlUHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBPYmplY3RGaWVsZFRlbXBsYXRlKHByb3BzKSB7XG4gICAgY29uc3QgeyBkZXNjcmlwdGlvbiwgZGlzYWJsZWQsIGZvcm1EYXRhLCBpZFNjaGVtYSwgb25BZGRDbGljaywgcHJvcGVydGllcywgcmVhZG9ubHksIHJlZ2lzdHJ5LCByZXF1aXJlZCwgc2NoZW1hLCB0aXRsZSwgdWlTY2hlbWEsIH0gPSBwcm9wcztcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0VWlPcHRpb25zKHVpU2NoZW1hKTtcbiAgICBjb25zdCBUaXRsZUZpZWxkVGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnVGl0bGVGaWVsZFRlbXBsYXRlJywgcmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIGNvbnN0IERlc2NyaXB0aW9uRmllbGRUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdEZXNjcmlwdGlvbkZpZWxkVGVtcGxhdGUnLCByZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgLy8gQnV0dG9uIHRlbXBsYXRlcyBhcmUgbm90IG92ZXJyaWRkZW4gaW4gdGhlIHVpU2NoZW1hXG4gICAgY29uc3QgeyBCdXR0b25UZW1wbGF0ZXM6IHsgQWRkQnV0dG9uIH0sIH0gPSByZWdpc3RyeS50ZW1wbGF0ZXM7XG4gICAgcmV0dXJuIChfanN4cyhcImZpZWxkc2V0XCIsIHsgaWQ6IGlkU2NoZW1hLiRpZCwgY2hpbGRyZW46IFt0aXRsZSAmJiAoX2pzeChUaXRsZUZpZWxkVGVtcGxhdGUsIHsgaWQ6IHRpdGxlSWQoaWRTY2hlbWEpLCB0aXRsZTogdGl0bGUsIHJlcXVpcmVkOiByZXF1aXJlZCwgc2NoZW1hOiBzY2hlbWEsIHVpU2NoZW1hOiB1aVNjaGVtYSwgcmVnaXN0cnk6IHJlZ2lzdHJ5IH0pKSwgZGVzY3JpcHRpb24gJiYgKF9qc3goRGVzY3JpcHRpb25GaWVsZFRlbXBsYXRlLCB7IGlkOiBkZXNjcmlwdGlvbklkKGlkU2NoZW1hKSwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBzY2hlbWE6IHNjaGVtYSwgdWlTY2hlbWE6IHVpU2NoZW1hLCByZWdpc3RyeTogcmVnaXN0cnkgfSkpLCBwcm9wZXJ0aWVzLm1hcCgocHJvcCkgPT4gcHJvcC5jb250ZW50KSwgY2FuRXhwYW5kKHNjaGVtYSwgdWlTY2hlbWEsIGZvcm1EYXRhKSAmJiAoX2pzeChBZGRCdXR0b24sIHsgY2xhc3NOYW1lOiAnb2JqZWN0LXByb3BlcnR5LWV4cGFuZCcsIG9uQ2xpY2s6IG9uQWRkQ2xpY2soc2NoZW1hKSwgZGlzYWJsZWQ6IGRpc2FibGVkIHx8IHJlYWRvbmx5LCB1aVNjaGVtYTogdWlTY2hlbWEsIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KSldIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPU9iamVjdEZpZWxkVGVtcGxhdGUuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmNvbnN0IFJFUVVJUkVEX0ZJRUxEX1NZTUJPTCA9ICcqJztcbi8qKiBUaGUgYFRpdGxlRmllbGRgIGlzIHRoZSB0ZW1wbGF0ZSB0byB1c2UgdG8gcmVuZGVyIHRoZSB0aXRsZSBvZiBhIGZpZWxkXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBUaXRsZUZpZWxkUHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBUaXRsZUZpZWxkKHByb3BzKSB7XG4gICAgY29uc3QgeyBpZCwgdGl0bGUsIHJlcXVpcmVkIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKF9qc3hzKFwibGVnZW5kXCIsIHsgaWQ6IGlkLCBjaGlsZHJlbjogW3RpdGxlLCByZXF1aXJlZCAmJiBfanN4KFwic3BhblwiLCB7IGNsYXNzTmFtZTogJ3JlcXVpcmVkJywgY2hpbGRyZW46IFJFUVVJUkVEX0ZJRUxEX1NZTUJPTCB9KV0gfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VGl0bGVGaWVsZC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgVHJhbnNsYXRhYmxlU3RyaW5nIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuaW1wb3J0IE1hcmtkb3duIGZyb20gJ21hcmtkb3duLXRvLWpzeCc7XG4vKiogVGhlIGBVbnN1cHBvcnRlZEZpZWxkYCBjb21wb25lbnQgaXMgdXNlZCB0byByZW5kZXIgYSBmaWVsZCBpbiB0aGUgc2NoZW1hIGlzIG9uZSB0aGF0IGlzIG5vdCBzdXBwb3J0ZWQgYnlcbiAqIHJlYWN0LWpzb25zY2hlbWEtZm9ybS5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYEZpZWxkUHJvcHNgIGZvciB0aGlzIHRlbXBsYXRlXG4gKi9cbmZ1bmN0aW9uIFVuc3VwcG9ydGVkRmllbGQocHJvcHMpIHtcbiAgICBjb25zdCB7IHNjaGVtYSwgaWRTY2hlbWEsIHJlYXNvbiwgcmVnaXN0cnkgfSA9IHByb3BzO1xuICAgIGNvbnN0IHsgdHJhbnNsYXRlU3RyaW5nIH0gPSByZWdpc3RyeTtcbiAgICBsZXQgdHJhbnNsYXRlRW51bSA9IFRyYW5zbGF0YWJsZVN0cmluZy5VbnN1cHBvcnRlZEZpZWxkO1xuICAgIGNvbnN0IHRyYW5zbGF0ZVBhcmFtcyA9IFtdO1xuICAgIGlmIChpZFNjaGVtYSAmJiBpZFNjaGVtYS4kaWQpIHtcbiAgICAgICAgdHJhbnNsYXRlRW51bSA9IFRyYW5zbGF0YWJsZVN0cmluZy5VbnN1cHBvcnRlZEZpZWxkV2l0aElkO1xuICAgICAgICB0cmFuc2xhdGVQYXJhbXMucHVzaChpZFNjaGVtYS4kaWQpO1xuICAgIH1cbiAgICBpZiAocmVhc29uKSB7XG4gICAgICAgIHRyYW5zbGF0ZUVudW0gPVxuICAgICAgICAgICAgdHJhbnNsYXRlRW51bSA9PT0gVHJhbnNsYXRhYmxlU3RyaW5nLlVuc3VwcG9ydGVkRmllbGRcbiAgICAgICAgICAgICAgICA/IFRyYW5zbGF0YWJsZVN0cmluZy5VbnN1cHBvcnRlZEZpZWxkV2l0aFJlYXNvblxuICAgICAgICAgICAgICAgIDogVHJhbnNsYXRhYmxlU3RyaW5nLlVuc3VwcG9ydGVkRmllbGRXaXRoSWRBbmRSZWFzb247XG4gICAgICAgIHRyYW5zbGF0ZVBhcmFtcy5wdXNoKHJlYXNvbik7XG4gICAgfVxuICAgIHJldHVybiAoX2pzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6ICd1bnN1cHBvcnRlZC1maWVsZCcsIGNoaWxkcmVuOiBbX2pzeChcInBcIiwgeyBjaGlsZHJlbjogX2pzeChNYXJrZG93biwgeyBjaGlsZHJlbjogdHJhbnNsYXRlU3RyaW5nKHRyYW5zbGF0ZUVudW0sIHRyYW5zbGF0ZVBhcmFtcykgfSkgfSksIHNjaGVtYSAmJiBfanN4KFwicHJlXCIsIHsgY2hpbGRyZW46IEpTT04uc3RyaW5naWZ5KHNjaGVtYSwgbnVsbCwgMikgfSldIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IFVuc3VwcG9ydGVkRmllbGQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VbnN1cHBvcnRlZEZpZWxkLmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcsIFRyYW5zbGF0YWJsZVN0cmluZywgfSBmcm9tICdAcmpzZi91dGlscyc7XG5pbXBvcnQgTGFiZWwgZnJvbSAnLi9GaWVsZFRlbXBsYXRlL0xhYmVsJztcbi8qKiBUaGUgYFdyYXBJZkFkZGl0aW9uYWxgIGNvbXBvbmVudCBpcyB1c2VkIGJ5IHRoZSBgRmllbGRUZW1wbGF0ZWAgdG8gcmVuYW1lLCBvciByZW1vdmUgcHJvcGVydGllcyB0aGF0IGFyZVxuICogcGFydCBvZiBhbiBgYWRkaXRpb25hbFByb3BlcnRpZXNgIHBhcnQgb2YgYSBzY2hlbWEuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXcmFwSWZBZGRpdGlvbmFsUHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBXcmFwSWZBZGRpdGlvbmFsVGVtcGxhdGUocHJvcHMpIHtcbiAgICBjb25zdCB7IGlkLCBjbGFzc05hbWVzLCBzdHlsZSwgZGlzYWJsZWQsIGxhYmVsLCBvbktleUNoYW5nZSwgb25Ecm9wUHJvcGVydHlDbGljaywgcmVhZG9ubHksIHJlcXVpcmVkLCBzY2hlbWEsIGNoaWxkcmVuLCB1aVNjaGVtYSwgcmVnaXN0cnksIH0gPSBwcm9wcztcbiAgICBjb25zdCB7IHRlbXBsYXRlcywgdHJhbnNsYXRlU3RyaW5nIH0gPSByZWdpc3RyeTtcbiAgICAvLyBCdXR0b24gdGVtcGxhdGVzIGFyZSBub3Qgb3ZlcnJpZGRlbiBpbiB0aGUgdWlTY2hlbWFcbiAgICBjb25zdCB7IFJlbW92ZUJ1dHRvbiB9ID0gdGVtcGxhdGVzLkJ1dHRvblRlbXBsYXRlcztcbiAgICBjb25zdCBrZXlMYWJlbCA9IHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuS2V5TGFiZWwsIFtsYWJlbF0pO1xuICAgIGNvbnN0IGFkZGl0aW9uYWwgPSBBRERJVElPTkFMX1BST1BFUlRZX0ZMQUcgaW4gc2NoZW1hO1xuICAgIGlmICghYWRkaXRpb25hbCkge1xuICAgICAgICByZXR1cm4gKF9qc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIChfanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBfanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogJ3JvdycsIGNoaWxkcmVuOiBbX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2NvbC14cy01IGZvcm0tYWRkaXRpb25hbCcsIGNoaWxkcmVuOiBfanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2Zvcm0tZ3JvdXAnLCBjaGlsZHJlbjogW19qc3goTGFiZWwsIHsgbGFiZWw6IGtleUxhYmVsLCByZXF1aXJlZDogcmVxdWlyZWQsIGlkOiBgJHtpZH0ta2V5YCB9KSwgX2pzeChcImlucHV0XCIsIHsgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgdHlwZTogJ3RleHQnLCBpZDogYCR7aWR9LWtleWAsIG9uQmx1cjogKGV2ZW50KSA9PiBvbktleUNoYW5nZShldmVudC50YXJnZXQudmFsdWUpLCBkZWZhdWx0VmFsdWU6IGxhYmVsIH0pXSB9KSB9KSwgX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2Zvcm0tYWRkaXRpb25hbCBmb3JtLWdyb3VwIGNvbC14cy01JywgY2hpbGRyZW46IGNoaWxkcmVuIH0pLCBfanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnY29sLXhzLTInLCBjaGlsZHJlbjogX2pzeChSZW1vdmVCdXR0b24sIHsgY2xhc3NOYW1lOiAnYXJyYXktaXRlbS1yZW1vdmUgYnRuLWJsb2NrJywgc3R5bGU6IHsgYm9yZGVyOiAnMCcgfSwgZGlzYWJsZWQ6IGRpc2FibGVkIHx8IHJlYWRvbmx5LCBvbkNsaWNrOiBvbkRyb3BQcm9wZXJ0eUNsaWNrKGxhYmVsKSwgdWlTY2hlbWE6IHVpU2NoZW1hLCByZWdpc3RyeTogcmVnaXN0cnkgfSkgfSldIH0pIH0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVdyYXBJZkFkZGl0aW9uYWxUZW1wbGF0ZS5qcy5tYXAiLCJpbXBvcnQgQXJyYXlGaWVsZERlc2NyaXB0aW9uVGVtcGxhdGUgZnJvbSAnLi9BcnJheUZpZWxkRGVzY3JpcHRpb25UZW1wbGF0ZSc7XG5pbXBvcnQgQXJyYXlGaWVsZEl0ZW1UZW1wbGF0ZSBmcm9tICcuL0FycmF5RmllbGRJdGVtVGVtcGxhdGUnO1xuaW1wb3J0IEFycmF5RmllbGRUZW1wbGF0ZSBmcm9tICcuL0FycmF5RmllbGRUZW1wbGF0ZSc7XG5pbXBvcnQgQXJyYXlGaWVsZFRpdGxlVGVtcGxhdGUgZnJvbSAnLi9BcnJheUZpZWxkVGl0bGVUZW1wbGF0ZSc7XG5pbXBvcnQgQmFzZUlucHV0VGVtcGxhdGUgZnJvbSAnLi9CYXNlSW5wdXRUZW1wbGF0ZSc7XG5pbXBvcnQgQnV0dG9uVGVtcGxhdGVzIGZyb20gJy4vQnV0dG9uVGVtcGxhdGVzJztcbmltcG9ydCBEZXNjcmlwdGlvbkZpZWxkIGZyb20gJy4vRGVzY3JpcHRpb25GaWVsZCc7XG5pbXBvcnQgRXJyb3JMaXN0IGZyb20gJy4vRXJyb3JMaXN0JztcbmltcG9ydCBGaWVsZFRlbXBsYXRlIGZyb20gJy4vRmllbGRUZW1wbGF0ZSc7XG5pbXBvcnQgRmllbGRFcnJvclRlbXBsYXRlIGZyb20gJy4vRmllbGRFcnJvclRlbXBsYXRlJztcbmltcG9ydCBGaWVsZEhlbHBUZW1wbGF0ZSBmcm9tICcuL0ZpZWxkSGVscFRlbXBsYXRlJztcbmltcG9ydCBPYmplY3RGaWVsZFRlbXBsYXRlIGZyb20gJy4vT2JqZWN0RmllbGRUZW1wbGF0ZSc7XG5pbXBvcnQgVGl0bGVGaWVsZCBmcm9tICcuL1RpdGxlRmllbGQnO1xuaW1wb3J0IFVuc3VwcG9ydGVkRmllbGQgZnJvbSAnLi9VbnN1cHBvcnRlZEZpZWxkJztcbmltcG9ydCBXcmFwSWZBZGRpdGlvbmFsVGVtcGxhdGUgZnJvbSAnLi9XcmFwSWZBZGRpdGlvbmFsVGVtcGxhdGUnO1xuZnVuY3Rpb24gdGVtcGxhdGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIEFycmF5RmllbGREZXNjcmlwdGlvblRlbXBsYXRlLFxuICAgICAgICBBcnJheUZpZWxkSXRlbVRlbXBsYXRlLFxuICAgICAgICBBcnJheUZpZWxkVGVtcGxhdGUsXG4gICAgICAgIEFycmF5RmllbGRUaXRsZVRlbXBsYXRlLFxuICAgICAgICBCdXR0b25UZW1wbGF0ZXM6IEJ1dHRvblRlbXBsYXRlcygpLFxuICAgICAgICBCYXNlSW5wdXRUZW1wbGF0ZSxcbiAgICAgICAgRGVzY3JpcHRpb25GaWVsZFRlbXBsYXRlOiBEZXNjcmlwdGlvbkZpZWxkLFxuICAgICAgICBFcnJvckxpc3RUZW1wbGF0ZTogRXJyb3JMaXN0LFxuICAgICAgICBGaWVsZFRlbXBsYXRlLFxuICAgICAgICBGaWVsZEVycm9yVGVtcGxhdGUsXG4gICAgICAgIEZpZWxkSGVscFRlbXBsYXRlLFxuICAgICAgICBPYmplY3RGaWVsZFRlbXBsYXRlLFxuICAgICAgICBUaXRsZUZpZWxkVGVtcGxhdGU6IFRpdGxlRmllbGQsXG4gICAgICAgIFVuc3VwcG9ydGVkRmllbGRUZW1wbGF0ZTogVW5zdXBwb3J0ZWRGaWVsZCxcbiAgICAgICAgV3JhcElmQWRkaXRpb25hbFRlbXBsYXRlLFxuICAgIH07XG59XG5leHBvcnQgZGVmYXVsdCB0ZW1wbGF0ZXM7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuLyoqIFRoZSBgQWx0RGF0ZVRpbWVXaWRnZXRgIGlzIGFuIGFsdGVybmF0aXZlIHdpZGdldCBmb3IgcmVuZGVyaW5nIGRhdGV0aW1lIHByb3BlcnRpZXMuXG4gKiAgSXQgdXNlcyB0aGUgQWx0RGF0ZVdpZGdldCBmb3IgcmVuZGVyaW5nLCB3aXRoIHRoZSBgdGltZWAgcHJvcCBzZXQgdG8gdHJ1ZSBieSBkZWZhdWx0LlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBBbHREYXRlVGltZVdpZGdldCh7IHRpbWUgPSB0cnVlLCAuLi5wcm9wcyB9KSB7XG4gICAgY29uc3QgeyBBbHREYXRlV2lkZ2V0IH0gPSBwcm9wcy5yZWdpc3RyeS53aWRnZXRzO1xuICAgIHJldHVybiBfanN4KEFsdERhdGVXaWRnZXQsIHsgdGltZTogdGltZSwgLi4ucHJvcHMgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBBbHREYXRlVGltZVdpZGdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFsdERhdGVUaW1lV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0LCB1c2VSZWR1Y2VyLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFyaWFEZXNjcmliZWRCeUlkcywgcGFyc2VEYXRlU3RyaW5nLCB0b0RhdGVTdHJpbmcsIHBhZCwgVHJhbnNsYXRhYmxlU3RyaW5nLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmZ1bmN0aW9uIHJhbmdlT3B0aW9ucyhzdGFydCwgc3RvcCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPD0gc3RvcDsgaSsrKSB7XG4gICAgICAgIG9wdGlvbnMucHVzaCh7IHZhbHVlOiBpLCBsYWJlbDogcGFkKGksIDIpIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmZ1bmN0aW9uIHJlYWR5Rm9yQ2hhbmdlKHN0YXRlKSB7XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoc3RhdGUpLmV2ZXJ5KCh2YWx1ZSkgPT4gdmFsdWUgIT09IC0xKTtcbn1cbmZ1bmN0aW9uIGRhdGVFbGVtZW50UHJvcHMoc3RhdGUsIHRpbWUsIHllYXJzUmFuZ2UgPSBbMTkwMCwgbmV3IERhdGUoKS5nZXRGdWxsWWVhcigpICsgMl0pIHtcbiAgICBjb25zdCB7IHllYXIsIG1vbnRoLCBkYXksIGhvdXIsIG1pbnV0ZSwgc2Vjb25kIH0gPSBzdGF0ZTtcbiAgICBjb25zdCBkYXRhID0gW1xuICAgICAgICB7XG4gICAgICAgICAgICB0eXBlOiAneWVhcicsXG4gICAgICAgICAgICByYW5nZTogeWVhcnNSYW5nZSxcbiAgICAgICAgICAgIHZhbHVlOiB5ZWFyLFxuICAgICAgICB9LFxuICAgICAgICB7IHR5cGU6ICdtb250aCcsIHJhbmdlOiBbMSwgMTJdLCB2YWx1ZTogbW9udGggfSxcbiAgICAgICAgeyB0eXBlOiAnZGF5JywgcmFuZ2U6IFsxLCAzMV0sIHZhbHVlOiBkYXkgfSxcbiAgICBdO1xuICAgIGlmICh0aW1lKSB7XG4gICAgICAgIGRhdGEucHVzaCh7IHR5cGU6ICdob3VyJywgcmFuZ2U6IFswLCAyM10sIHZhbHVlOiBob3VyIH0sIHsgdHlwZTogJ21pbnV0ZScsIHJhbmdlOiBbMCwgNTldLCB2YWx1ZTogbWludXRlIH0sIHsgdHlwZTogJ3NlY29uZCcsIHJhbmdlOiBbMCwgNTldLCB2YWx1ZTogc2Vjb25kIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbmZ1bmN0aW9uIERhdGVFbGVtZW50KHsgdHlwZSwgcmFuZ2UsIHZhbHVlLCBzZWxlY3QsIHJvb3RJZCwgbmFtZSwgZGlzYWJsZWQsIHJlYWRvbmx5LCBhdXRvZm9jdXMsIHJlZ2lzdHJ5LCBvbkJsdXIsIG9uRm9jdXMsIH0pIHtcbiAgICBjb25zdCBpZCA9IHJvb3RJZCArICdfJyArIHR5cGU7XG4gICAgY29uc3QgeyBTZWxlY3RXaWRnZXQgfSA9IHJlZ2lzdHJ5LndpZGdldHM7XG4gICAgcmV0dXJuIChfanN4KFNlbGVjdFdpZGdldCwgeyBzY2hlbWE6IHsgdHlwZTogJ2ludGVnZXInIH0sIGlkOiBpZCwgbmFtZTogbmFtZSwgY2xhc3NOYW1lOiAnZm9ybS1jb250cm9sJywgb3B0aW9uczogeyBlbnVtT3B0aW9uczogcmFuZ2VPcHRpb25zKHJhbmdlWzBdLCByYW5nZVsxXSkgfSwgcGxhY2Vob2xkZXI6IHR5cGUsIHZhbHVlOiB2YWx1ZSwgZGlzYWJsZWQ6IGRpc2FibGVkLCByZWFkb25seTogcmVhZG9ubHksIGF1dG9mb2N1czogYXV0b2ZvY3VzLCBvbkNoYW5nZTogKHZhbHVlKSA9PiBzZWxlY3QodHlwZSwgdmFsdWUpLCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb25Gb2N1cywgcmVnaXN0cnk6IHJlZ2lzdHJ5LCBsYWJlbDogJycsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBhcmlhRGVzY3JpYmVkQnlJZHMocm9vdElkKSB9KSk7XG59XG4vKiogVGhlIGBBbHREYXRlV2lkZ2V0YCBpcyBhbiBhbHRlcm5hdGl2ZSB3aWRnZXQgZm9yIHJlbmRlcmluZyBkYXRlIHByb3BlcnRpZXMuXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYFdpZGdldFByb3BzYCBmb3IgdGhpcyBjb21wb25lbnRcbiAqL1xuZnVuY3Rpb24gQWx0RGF0ZVdpZGdldCh7IHRpbWUgPSBmYWxzZSwgZGlzYWJsZWQgPSBmYWxzZSwgcmVhZG9ubHkgPSBmYWxzZSwgYXV0b2ZvY3VzID0gZmFsc2UsIG9wdGlvbnMsIGlkLCBuYW1lLCByZWdpc3RyeSwgb25CbHVyLCBvbkZvY3VzLCBvbkNoYW5nZSwgdmFsdWUsIH0pIHtcbiAgICBjb25zdCB7IHRyYW5zbGF0ZVN0cmluZyB9ID0gcmVnaXN0cnk7XG4gICAgY29uc3QgW2xhc3RWYWx1ZSwgc2V0TGFzdFZhbHVlXSA9IHVzZVN0YXRlKHZhbHVlKTtcbiAgICBjb25zdCBbc3RhdGUsIHNldFN0YXRlXSA9IHVzZVJlZHVjZXIoKHN0YXRlLCBhY3Rpb24pID0+IHtcbiAgICAgICAgcmV0dXJuIHsgLi4uc3RhdGUsIC4uLmFjdGlvbiB9O1xuICAgIH0sIHBhcnNlRGF0ZVN0cmluZyh2YWx1ZSwgdGltZSkpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlVmFsdWUgPSB0b0RhdGVTdHJpbmcoc3RhdGUsIHRpbWUpO1xuICAgICAgICBpZiAocmVhZHlGb3JDaGFuZ2Uoc3RhdGUpICYmIHN0YXRlVmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBUaGUgdXNlciBjaGFuZ2VkIHRoZSBkYXRlIHRvIGEgbmV3IHZhbGlkIGRhdGEgdmlhIHRoZSBjb21ib2JveGVzLCBzbyBjYWxsIG9uQ2hhbmdlXG4gICAgICAgICAgICBvbkNoYW5nZShzdGF0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsYXN0VmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICAgICAgICAvLyBXZSBnb3QgYSBuZXcgdmFsdWUgaW4gdGhlIHByb3BzXG4gICAgICAgICAgICBzZXRMYXN0VmFsdWUodmFsdWUpO1xuICAgICAgICAgICAgc2V0U3RhdGUocGFyc2VEYXRlU3RyaW5nKHZhbHVlLCB0aW1lKSk7XG4gICAgICAgIH1cbiAgICB9LCBbdGltZSwgdmFsdWUsIG9uQ2hhbmdlLCBzdGF0ZSwgbGFzdFZhbHVlXSk7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHByb3BlcnR5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBzZXRTdGF0ZSh7IFtwcm9wZXJ0eV06IHZhbHVlIH0pO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBoYW5kbGVTZXROb3cgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgaWYgKGRpc2FibGVkIHx8IHJlYWRvbmx5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFN0YXRlID0gcGFyc2VEYXRlU3RyaW5nKG5ldyBEYXRlKCkudG9KU09OKCksIHRpbWUpO1xuICAgICAgICBvbkNoYW5nZSh0b0RhdGVTdHJpbmcobmV4dFN0YXRlLCB0aW1lKSk7XG4gICAgfSwgW2Rpc2FibGVkLCByZWFkb25seSwgdGltZV0pO1xuICAgIGNvbnN0IGhhbmRsZUNsZWFyID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIGlmIChkaXNhYmxlZCB8fCByZWFkb25seSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9uQ2hhbmdlKHVuZGVmaW5lZCk7XG4gICAgfSwgW2Rpc2FibGVkLCByZWFkb25seSwgb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gKF9qc3hzKFwidWxcIiwgeyBjbGFzc05hbWU6ICdsaXN0LWlubGluZScsIGNoaWxkcmVuOiBbZGF0ZUVsZW1lbnRQcm9wcyhzdGF0ZSwgdGltZSwgb3B0aW9ucy55ZWFyc1JhbmdlKS5tYXAoKGVsZW1Qcm9wcywgaSkgPT4gKF9qc3goXCJsaVwiLCB7IGNsYXNzTmFtZTogJ2xpc3QtaW5saW5lLWl0ZW0nLCBjaGlsZHJlbjogX2pzeChEYXRlRWxlbWVudCwgeyByb290SWQ6IGlkLCBuYW1lOiBuYW1lLCBzZWxlY3Q6IGhhbmRsZUNoYW5nZSwgLi4uZWxlbVByb3BzLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRvbmx5OiByZWFkb25seSwgcmVnaXN0cnk6IHJlZ2lzdHJ5LCBvbkJsdXI6IG9uQmx1ciwgb25Gb2N1czogb25Gb2N1cywgYXV0b2ZvY3VzOiBhdXRvZm9jdXMgJiYgaSA9PT0gMCB9KSB9LCBpKSkpLCAob3B0aW9ucy5oaWRlTm93QnV0dG9uICE9PSAndW5kZWZpbmVkJyA/ICFvcHRpb25zLmhpZGVOb3dCdXR0b24gOiB0cnVlKSAmJiAoX2pzeChcImxpXCIsIHsgY2xhc3NOYW1lOiAnbGlzdC1pbmxpbmUtaXRlbScsIGNoaWxkcmVuOiBfanN4KFwiYVwiLCB7IGhyZWY6ICcjJywgY2xhc3NOYW1lOiAnYnRuIGJ0bi1pbmZvIGJ0bi1ub3cnLCBvbkNsaWNrOiBoYW5kbGVTZXROb3csIGNoaWxkcmVuOiB0cmFuc2xhdGVTdHJpbmcoVHJhbnNsYXRhYmxlU3RyaW5nLk5vd0xhYmVsKSB9KSB9KSksIChvcHRpb25zLmhpZGVDbGVhckJ1dHRvbiAhPT0gJ3VuZGVmaW5lZCcgPyAhb3B0aW9ucy5oaWRlQ2xlYXJCdXR0b24gOiB0cnVlKSAmJiAoX2pzeChcImxpXCIsIHsgY2xhc3NOYW1lOiAnbGlzdC1pbmxpbmUtaXRlbScsIGNoaWxkcmVuOiBfanN4KFwiYVwiLCB7IGhyZWY6ICcjJywgY2xhc3NOYW1lOiAnYnRuIGJ0bi13YXJuaW5nIGJ0bi1jbGVhcicsIG9uQ2xpY2s6IGhhbmRsZUNsZWFyLCBjaGlsZHJlbjogdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5DbGVhckxhYmVsKSB9KSB9KSldIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEFsdERhdGVXaWRnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1BbHREYXRlV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGFyaWFEZXNjcmliZWRCeUlkcywgZGVzY3JpcHRpb25JZCwgZ2V0VGVtcGxhdGUsIGxhYmVsVmFsdWUsIHNjaGVtYVJlcXVpcmVzVHJ1ZVZhbHVlLCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYENoZWNrQm94V2lkZ2V0YCBpcyBhIHdpZGdldCBmb3IgcmVuZGVyaW5nIGJvb2xlYW4gcHJvcGVydGllcy5cbiAqICBJdCBpcyB0eXBpY2FsbHkgdXNlZCB0byByZXByZXNlbnQgYSBib29sZWFuLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBDaGVja2JveFdpZGdldCh7IHNjaGVtYSwgdWlTY2hlbWEsIG9wdGlvbnMsIGlkLCB2YWx1ZSwgZGlzYWJsZWQsIHJlYWRvbmx5LCBsYWJlbCwgaGlkZUxhYmVsLCBhdXRvZm9jdXMgPSBmYWxzZSwgb25CbHVyLCBvbkZvY3VzLCBvbkNoYW5nZSwgcmVnaXN0cnksIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgRGVzY3JpcHRpb25GaWVsZFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0Rlc2NyaXB0aW9uRmllbGRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICAvLyBCZWNhdXNlIGFuIHVuY2hlY2tlZCBjaGVja2JveCB3aWxsIGNhdXNlIGh0bWw1IHZhbGlkYXRpb24gdG8gZmFpbCwgb25seSBhZGRcbiAgICAvLyB0aGUgXCJyZXF1aXJlZFwiIGF0dHJpYnV0ZSBpZiB0aGUgZmllbGQgdmFsdWUgbXVzdCBiZSBcInRydWVcIiwgZHVlIHRvIHRoZVxuICAgIC8vIFwiY29uc3RcIiBvciBcImVudW1cIiBrZXl3b3Jkc1xuICAgIGNvbnN0IHJlcXVpcmVkID0gc2NoZW1hUmVxdWlyZXNUcnVlVmFsdWUoc2NoZW1hKTtcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IG9uQ2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKSwgW29uQ2hhbmdlXSk7XG4gICAgY29uc3QgaGFuZGxlQmx1ciA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4gb25CbHVyKGlkLCBldmVudC50YXJnZXQuY2hlY2tlZCksIFtvbkJsdXIsIGlkXSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IG9uRm9jdXMoaWQsIGV2ZW50LnRhcmdldC5jaGVja2VkKSwgW29uRm9jdXMsIGlkXSk7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSAoX2EgPSBvcHRpb25zLmRlc2NyaXB0aW9uKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBzY2hlbWEuZGVzY3JpcHRpb247XG4gICAgcmV0dXJuIChfanN4cyhcImRpdlwiLCB7IGNsYXNzTmFtZTogYGNoZWNrYm94ICR7ZGlzYWJsZWQgfHwgcmVhZG9ubHkgPyAnZGlzYWJsZWQnIDogJyd9YCwgY2hpbGRyZW46IFshaGlkZUxhYmVsICYmICEhZGVzY3JpcHRpb24gJiYgKF9qc3goRGVzY3JpcHRpb25GaWVsZFRlbXBsYXRlLCB7IGlkOiBkZXNjcmlwdGlvbklkKGlkKSwgZGVzY3JpcHRpb246IGRlc2NyaXB0aW9uLCBzY2hlbWE6IHNjaGVtYSwgdWlTY2hlbWE6IHVpU2NoZW1hLCByZWdpc3RyeTogcmVnaXN0cnkgfSkpLCBfanN4cyhcImxhYmVsXCIsIHsgY2hpbGRyZW46IFtfanN4KFwiaW5wdXRcIiwgeyB0eXBlOiAnY2hlY2tib3gnLCBpZDogaWQsIG5hbWU6IGlkLCBjaGVja2VkOiB0eXBlb2YgdmFsdWUgPT09ICd1bmRlZmluZWQnID8gZmFsc2UgOiB2YWx1ZSwgcmVxdWlyZWQ6IHJlcXVpcmVkLCBkaXNhYmxlZDogZGlzYWJsZWQgfHwgcmVhZG9ubHksIGF1dG9Gb2N1czogYXV0b2ZvY3VzLCBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLCBvbkJsdXI6IGhhbmRsZUJsdXIsIG9uRm9jdXM6IGhhbmRsZUZvY3VzLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5SWRzKGlkKSB9KSwgbGFiZWxWYWx1ZShfanN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiBsYWJlbCB9KSwgaGlkZUxhYmVsKV0gfSldIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IENoZWNrYm94V2lkZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hlY2tib3hXaWRnZXQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXJpYURlc2NyaWJlZEJ5SWRzLCBlbnVtT3B0aW9uc0Rlc2VsZWN0VmFsdWUsIGVudW1PcHRpb25zSXNTZWxlY3RlZCwgZW51bU9wdGlvbnNTZWxlY3RWYWx1ZSwgZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4LCBvcHRpb25JZCwgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBDaGVja2JveGVzV2lkZ2V0YCBpcyBhIHdpZGdldCBmb3IgcmVuZGVyaW5nIGNoZWNrYm94IGdyb3Vwcy5cbiAqICBJdCBpcyB0eXBpY2FsbHkgdXNlZCB0byByZXByZXNlbnQgYW4gYXJyYXkgb2YgZW51bXMuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIENoZWNrYm94ZXNXaWRnZXQoeyBpZCwgZGlzYWJsZWQsIG9wdGlvbnM6IHsgaW5saW5lID0gZmFsc2UsIGVudW1PcHRpb25zLCBlbnVtRGlzYWJsZWQsIGVtcHR5VmFsdWUgfSwgdmFsdWUsIGF1dG9mb2N1cyA9IGZhbHNlLCByZWFkb25seSwgb25DaGFuZ2UsIG9uQmx1ciwgb25Gb2N1cywgfSkge1xuICAgIGNvbnN0IGNoZWNrYm94ZXNWYWx1ZXMgPSBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soKHsgdGFyZ2V0OiB7IHZhbHVlIH0gfSkgPT4gb25CbHVyKGlkLCBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgodmFsdWUsIGVudW1PcHRpb25zLCBlbXB0eVZhbHVlKSksIFtvbkJsdXIsIGlkXSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjaygoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiBvbkZvY3VzKGlkLCBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgodmFsdWUsIGVudW1PcHRpb25zLCBlbXB0eVZhbHVlKSksIFtvbkZvY3VzLCBpZF0pO1xuICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2NoZWNrYm94ZXMnLCBpZDogaWQsIGNoaWxkcmVuOiBBcnJheS5pc0FycmF5KGVudW1PcHRpb25zKSAmJlxuICAgICAgICAgICAgZW51bU9wdGlvbnMubWFwKChvcHRpb24sIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVudW1PcHRpb25zSXNTZWxlY3RlZChvcHRpb24udmFsdWUsIGNoZWNrYm94ZXNWYWx1ZXMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW1EaXNhYmxlZCA9IEFycmF5LmlzQXJyYXkoZW51bURpc2FibGVkKSAmJiBlbnVtRGlzYWJsZWQuaW5kZXhPZihvcHRpb24udmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXNhYmxlZENscyA9IGRpc2FibGVkIHx8IGl0ZW1EaXNhYmxlZCB8fCByZWFkb25seSA/ICdkaXNhYmxlZCcgOiAnJztcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhcmdldC5jaGVja2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNoYW5nZShlbnVtT3B0aW9uc1NlbGVjdFZhbHVlKGluZGV4LCBjaGVja2JveGVzVmFsdWVzLCBlbnVtT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DaGFuZ2UoZW51bU9wdGlvbnNEZXNlbGVjdFZhbHVlKGluZGV4LCBjaGVja2JveGVzVmFsdWVzLCBlbnVtT3B0aW9ucykpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGVja2JveCA9IChfanN4cyhcInNwYW5cIiwgeyBjaGlsZHJlbjogW19qc3goXCJpbnB1dFwiLCB7IHR5cGU6ICdjaGVja2JveCcsIGlkOiBvcHRpb25JZChpZCwgaW5kZXgpLCBuYW1lOiBpZCwgY2hlY2tlZDogY2hlY2tlZCwgdmFsdWU6IFN0cmluZyhpbmRleCksIGRpc2FibGVkOiBkaXNhYmxlZCB8fCBpdGVtRGlzYWJsZWQgfHwgcmVhZG9ubHksIGF1dG9Gb2N1czogYXV0b2ZvY3VzICYmIGluZGV4ID09PSAwLCBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlLCBvbkJsdXI6IGhhbmRsZUJsdXIsIG9uRm9jdXM6IGhhbmRsZUZvY3VzLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5SWRzKGlkKSB9KSwgX2pzeChcInNwYW5cIiwgeyBjaGlsZHJlbjogb3B0aW9uLmxhYmVsIH0pXSB9KSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlubGluZSA/IChfanN4KFwibGFiZWxcIiwgeyBjbGFzc05hbWU6IGBjaGVja2JveC1pbmxpbmUgJHtkaXNhYmxlZENsc31gLCBjaGlsZHJlbjogY2hlY2tib3ggfSwgaW5kZXgpKSA6IChfanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBgY2hlY2tib3ggJHtkaXNhYmxlZENsc31gLCBjaGlsZHJlbjogX2pzeChcImxhYmVsXCIsIHsgY2hpbGRyZW46IGNoZWNrYm94IH0pIH0sIGluZGV4KSk7XG4gICAgICAgICAgICB9KSB9KSk7XG59XG5leHBvcnQgZGVmYXVsdCBDaGVja2JveGVzV2lkZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2hlY2tib3hlc1dpZGdldC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBDb2xvcldpZGdldGAgY29tcG9uZW50IHVzZXMgdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAgY2hhbmdpbmcgdGhlIHR5cGUgdG8gYGNvbG9yYCBhbmQgZGlzYWJsZXMgaXQgd2hlbiBpdCBpc1xuICogZWl0aGVyIGRpc2FibGVkIG9yIHJlYWRvbmx5LlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb2xvcldpZGdldChwcm9wcykge1xuICAgIGNvbnN0IHsgZGlzYWJsZWQsIHJlYWRvbmx5LCBvcHRpb25zLCByZWdpc3RyeSB9ID0gcHJvcHM7XG4gICAgY29uc3QgQmFzZUlucHV0VGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnQmFzZUlucHV0VGVtcGxhdGUnLCByZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIF9qc3goQmFzZUlucHV0VGVtcGxhdGUsIHsgdHlwZTogJ2NvbG9yJywgLi4ucHJvcHMsIGRpc2FibGVkOiBkaXNhYmxlZCB8fCByZWFkb25seSB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZSwgbG9jYWxUb1VUQywgdXRjVG9Mb2NhbCwgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBEYXRlVGltZVdpZGdldGAgY29tcG9uZW50IHVzZXMgdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAgY2hhbmdpbmcgdGhlIHR5cGUgdG8gYGRhdGV0aW1lLWxvY2FsYCBhbmQgdHJhbnNmb3Jtc1xuICogdGhlIHZhbHVlIHRvL2Zyb20gdXRjIHVzaW5nIHRoZSBhcHByb3ByaWF0ZSB1dGlsaXR5IGZ1bmN0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYFdpZGdldFByb3BzYCBmb3IgdGhpcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRGF0ZVRpbWVXaWRnZXQocHJvcHMpIHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCB2YWx1ZSwgb3B0aW9ucywgcmVnaXN0cnkgfSA9IHByb3BzO1xuICAgIGNvbnN0IEJhc2VJbnB1dFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0Jhc2VJbnB1dFRlbXBsYXRlJywgcmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIHJldHVybiAoX2pzeChCYXNlSW5wdXRUZW1wbGF0ZSwgeyB0eXBlOiAnZGF0ZXRpbWUtbG9jYWwnLCAuLi5wcm9wcywgdmFsdWU6IHV0Y1RvTG9jYWwodmFsdWUpLCBvbkNoYW5nZTogKHZhbHVlKSA9PiBvbkNoYW5nZShsb2NhbFRvVVRDKHZhbHVlKSkgfSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0ZVRpbWVXaWRnZXQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBEYXRlV2lkZ2V0YCBjb21wb25lbnQgdXNlcyB0aGUgYEJhc2VJbnB1dFRlbXBsYXRlYCBjaGFuZ2luZyB0aGUgdHlwZSB0byBgZGF0ZWAgYW5kIHRyYW5zZm9ybXNcbiAqIHRoZSB2YWx1ZSB0byB1bmRlZmluZWQgd2hlbiBpdCBpcyBmYWxzeSBkdXJpbmcgdGhlIGBvbkNoYW5nZWAgaGFuZGxpbmcuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIERhdGVXaWRnZXQocHJvcHMpIHtcbiAgICBjb25zdCB7IG9uQ2hhbmdlLCBvcHRpb25zLCByZWdpc3RyeSB9ID0gcHJvcHM7XG4gICAgY29uc3QgQmFzZUlucHV0VGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnQmFzZUlucHV0VGVtcGxhdGUnLCByZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHZhbHVlKSA9PiBvbkNoYW5nZSh2YWx1ZSB8fCB1bmRlZmluZWQpLCBbb25DaGFuZ2VdKTtcbiAgICByZXR1cm4gX2pzeChCYXNlSW5wdXRUZW1wbGF0ZSwgeyB0eXBlOiAnZGF0ZScsIC4uLnByb3BzLCBvbkNoYW5nZTogaGFuZGxlQ2hhbmdlIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RGF0ZVdpZGdldC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBFbWFpbFdpZGdldGAgY29tcG9uZW50IHVzZXMgdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAgY2hhbmdpbmcgdGhlIHR5cGUgdG8gYGVtYWlsYC5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYFdpZGdldFByb3BzYCBmb3IgdGhpcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRW1haWxXaWRnZXQocHJvcHMpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHJlZ2lzdHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCBCYXNlSW5wdXRUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdCYXNlSW5wdXRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX2pzeChCYXNlSW5wdXRUZW1wbGF0ZSwgeyB0eXBlOiAnZW1haWwnLCAuLi5wcm9wcyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUVtYWlsV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBGcmFnbWVudCBhcyBfRnJhZ21lbnQsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGRhdGFVUkl0b0Jsb2IsIGdldFRlbXBsYXRlLCBUcmFuc2xhdGFibGVTdHJpbmcsIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuaW1wb3J0IE1hcmtkb3duIGZyb20gJ21hcmtkb3duLXRvLWpzeCc7XG5mdW5jdGlvbiBhZGROYW1lVG9EYXRhVVJMKGRhdGFVUkwsIG5hbWUpIHtcbiAgICBpZiAoZGF0YVVSTCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGFVUkwucmVwbGFjZSgnO2Jhc2U2NCcsIGA7bmFtZT0ke2VuY29kZVVSSUNvbXBvbmVudChuYW1lKX07YmFzZTY0YCk7XG59XG5mdW5jdGlvbiBwcm9jZXNzRmlsZShmaWxlKSB7XG4gICAgY29uc3QgeyBuYW1lLCBzaXplLCB0eXBlIH0gPSBmaWxlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyB3aW5kb3cuRmlsZVJlYWRlcigpO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoKF9hID0gZXZlbnQudGFyZ2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzdWx0KSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVVSTDogYWRkTmFtZVRvRGF0YVVSTChldmVudC50YXJnZXQucmVzdWx0LCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc29sdmUoe1xuICAgICAgICAgICAgICAgICAgICBkYXRhVVJMOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHByb2Nlc3NGaWxlcyhmaWxlcykge1xuICAgIHJldHVybiBQcm9taXNlLmFsbChBcnJheS5mcm9tKGZpbGVzKS5tYXAocHJvY2Vzc0ZpbGUpKTtcbn1cbmZ1bmN0aW9uIEZpbGVJbmZvUHJldmlldyh7IGZpbGVJbmZvLCByZWdpc3RyeSwgfSkge1xuICAgIGNvbnN0IHsgdHJhbnNsYXRlU3RyaW5nIH0gPSByZWdpc3RyeTtcbiAgICBjb25zdCB7IGRhdGFVUkwsIHR5cGUsIG5hbWUgfSA9IGZpbGVJbmZvO1xuICAgIGlmICghZGF0YVVSTCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGUuaW5kZXhPZignaW1hZ2UnKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIF9qc3goXCJpbWdcIiwgeyBzcmM6IGRhdGFVUkwsIHN0eWxlOiB7IG1heFdpZHRoOiAnMTAwJScgfSwgY2xhc3NOYW1lOiAnZmlsZS1wcmV2aWV3JyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIChfanN4cyhfRnJhZ21lbnQsIHsgY2hpbGRyZW46IFsnICcsIF9qc3goXCJhXCIsIHsgZG93bmxvYWQ6IGBwcmV2aWV3LSR7bmFtZX1gLCBocmVmOiBkYXRhVVJMLCBjbGFzc05hbWU6ICdmaWxlLWRvd25sb2FkJywgY2hpbGRyZW46IHRyYW5zbGF0ZVN0cmluZyhUcmFuc2xhdGFibGVTdHJpbmcuUHJldmlld0xhYmVsKSB9KV0gfSkpO1xufVxuZnVuY3Rpb24gRmlsZXNJbmZvKHsgZmlsZXNJbmZvLCByZWdpc3RyeSwgcHJldmlldywgfSkge1xuICAgIGlmIChmaWxlc0luZm8ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCB7IHRyYW5zbGF0ZVN0cmluZyB9ID0gcmVnaXN0cnk7XG4gICAgcmV0dXJuIChfanN4KFwidWxcIiwgeyBjbGFzc05hbWU6ICdmaWxlLWluZm8nLCBjaGlsZHJlbjogZmlsZXNJbmZvLm1hcCgoZmlsZUluZm8sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBuYW1lLCBzaXplLCB0eXBlIH0gPSBmaWxlSW5mbztcbiAgICAgICAgICAgIHJldHVybiAoX2pzeHMoXCJsaVwiLCB7IGNoaWxkcmVuOiBbX2pzeChNYXJrZG93biwgeyBjaGlsZHJlbjogdHJhbnNsYXRlU3RyaW5nKFRyYW5zbGF0YWJsZVN0cmluZy5GaWxlc0luZm8sIFtuYW1lLCB0eXBlLCBTdHJpbmcoc2l6ZSldKSB9KSwgcHJldmlldyAmJiBfanN4KEZpbGVJbmZvUHJldmlldywgeyBmaWxlSW5mbzogZmlsZUluZm8sIHJlZ2lzdHJ5OiByZWdpc3RyeSB9KV0gfSwga2V5KSk7XG4gICAgICAgIH0pIH0pKTtcbn1cbmZ1bmN0aW9uIGV4dHJhY3RGaWxlSW5mbyhkYXRhVVJMcykge1xuICAgIHJldHVybiBkYXRhVVJMc1xuICAgICAgICAuZmlsdGVyKChkYXRhVVJMKSA9PiBkYXRhVVJMKVxuICAgICAgICAubWFwKChkYXRhVVJMKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYmxvYiwgbmFtZSB9ID0gZGF0YVVSSXRvQmxvYihkYXRhVVJMKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGFVUkwsXG4gICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgc2l6ZTogYmxvYi5zaXplLFxuICAgICAgICAgICAgdHlwZTogYmxvYi50eXBlLFxuICAgICAgICB9O1xuICAgIH0pO1xufVxuLyoqXG4gKiAgVGhlIGBGaWxlV2lkZ2V0YCBpcyBhIHdpZGdldCBmb3IgcmVuZGVyaW5nIGZpbGUgdXBsb2FkIGZpZWxkcy5cbiAqICBJdCBpcyB0eXBpY2FsbHkgdXNlZCB3aXRoIGEgc3RyaW5nIHByb3BlcnR5IHdpdGggZGF0YS11cmwgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBGaWxlV2lkZ2V0KHByb3BzKSB7XG4gICAgY29uc3QgeyBkaXNhYmxlZCwgcmVhZG9ubHksIHJlcXVpcmVkLCBtdWx0aXBsZSwgb25DaGFuZ2UsIHZhbHVlLCBvcHRpb25zLCByZWdpc3RyeSB9ID0gcHJvcHM7XG4gICAgY29uc3QgQmFzZUlucHV0VGVtcGxhdGUgPSBnZXRUZW1wbGF0ZSgnQmFzZUlucHV0VGVtcGxhdGUnLCByZWdpc3RyeSwgb3B0aW9ucyk7XG4gICAgY29uc3QgW2ZpbGVzSW5mbywgc2V0RmlsZXNJbmZvXSA9IHVzZVN0YXRlKEFycmF5LmlzQXJyYXkodmFsdWUpID8gZXh0cmFjdEZpbGVJbmZvKHZhbHVlKSA6IGV4dHJhY3RGaWxlSW5mbyhbdmFsdWVdKSk7XG4gICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmICghZXZlbnQudGFyZ2V0LmZpbGVzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gRHVlIHRvIHZhcmlhbmNlcyBpbiB0aGVtZXMsIGRlYWxpbmcgd2l0aCBtdWx0aXBsZSBmaWxlcyBmb3IgdGhlIGFycmF5IGNhc2Ugbm93IGhhcHBlbnMgb25lIGZpbGUgYXQgYSB0aW1lLlxuICAgICAgICAvLyBUaGlzIGlzIGJlY2F1c2Ugd2UgZG9uJ3QgcGFzcyBgbXVsdGlwbGVgIGludG8gdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAgYW55bW9yZS4gSW5zdGVhZCwgd2UgZGVhbCB3aXRoIHRoZSBzaW5nbGVcbiAgICAgICAgLy8gZmlsZSBpbiBlYWNoIGV2ZW50IGFuZCBjb25jYXRlbmF0ZSB0aGVtIHRvZ2V0aGVyIG91cnNlbHZlc1xuICAgICAgICBwcm9jZXNzRmlsZXMoZXZlbnQudGFyZ2V0LmZpbGVzKS50aGVuKChmaWxlc0luZm9FdmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBmaWxlc0luZm9FdmVudC5tYXAoKGZpbGVJbmZvKSA9PiBmaWxlSW5mby5kYXRhVVJMKTtcbiAgICAgICAgICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICAgICAgICAgIHNldEZpbGVzSW5mbyhmaWxlc0luZm8uY29uY2F0KGZpbGVzSW5mb0V2ZW50WzBdKSk7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2UodmFsdWUuY29uY2F0KG5ld1ZhbHVlWzBdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRGaWxlc0luZm8oZmlsZXNJbmZvRXZlbnQpO1xuICAgICAgICAgICAgICAgIG9uQ2hhbmdlKG5ld1ZhbHVlWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSwgW211bHRpcGxlLCB2YWx1ZSwgZmlsZXNJbmZvLCBvbkNoYW5nZV0pO1xuICAgIHJldHVybiAoX2pzeHMoXCJkaXZcIiwgeyBjaGlsZHJlbjogW19qc3goQmFzZUlucHV0VGVtcGxhdGUsIHsgLi4ucHJvcHMsIGRpc2FibGVkOiBkaXNhYmxlZCB8fCByZWFkb25seSwgdHlwZTogJ2ZpbGUnLCByZXF1aXJlZDogdmFsdWUgPyBmYWxzZSA6IHJlcXVpcmVkLCBvbkNoYW5nZU92ZXJyaWRlOiBoYW5kbGVDaGFuZ2UsIHZhbHVlOiAnJywgYWNjZXB0OiBvcHRpb25zLmFjY2VwdCA/IFN0cmluZyhvcHRpb25zLmFjY2VwdCkgOiB1bmRlZmluZWQgfSksIF9qc3goRmlsZXNJbmZvLCB7IGZpbGVzSW5mbzogZmlsZXNJbmZvLCByZWdpc3RyeTogcmVnaXN0cnksIHByZXZpZXc6IG9wdGlvbnMuZmlsZVByZXZpZXcgfSldIH0pKTtcbn1cbmV4cG9ydCBkZWZhdWx0IEZpbGVXaWRnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1GaWxlV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG4vKiogVGhlIGBIaWRkZW5XaWRnZXRgIGlzIGEgd2lkZ2V0IGZvciByZW5kZXJpbmcgYSBoaWRkZW4gaW5wdXQgZmllbGQuXG4gKiAgSXQgaXMgdHlwaWNhbGx5IHVzZWQgYnkgc2V0dGluZyB0eXBlIHRvIFwiaGlkZGVuXCIuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIEhpZGRlbldpZGdldCh7IGlkLCB2YWx1ZSwgfSkge1xuICAgIHJldHVybiBfanN4KFwiaW5wdXRcIiwgeyB0eXBlOiAnaGlkZGVuJywgaWQ6IGlkLCBuYW1lOiBpZCwgdmFsdWU6IHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6IHZhbHVlIH0pO1xufVxuZXhwb3J0IGRlZmF1bHQgSGlkZGVuV2lkZ2V0O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SGlkZGVuV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZSB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYFBhc3N3b3JkV2lkZ2V0YCBjb21wb25lbnQgdXNlcyB0aGUgYEJhc2VJbnB1dFRlbXBsYXRlYCBjaGFuZ2luZyB0aGUgdHlwZSB0byBgcGFzc3dvcmRgLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBQYXNzd29yZFdpZGdldChwcm9wcykge1xuICAgIGNvbnN0IHsgb3B0aW9ucywgcmVnaXN0cnkgfSA9IHByb3BzO1xuICAgIGNvbnN0IEJhc2VJbnB1dFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0Jhc2VJbnB1dFRlbXBsYXRlJywgcmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIHJldHVybiBfanN4KEJhc2VJbnB1dFRlbXBsYXRlLCB7IHR5cGU6ICdwYXNzd29yZCcsIC4uLnByb3BzIH0pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UGFzc3dvcmRXaWRnZXQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3gsIGpzeHMgYXMgX2pzeHMgfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXJpYURlc2NyaWJlZEJ5SWRzLCBlbnVtT3B0aW9uc0lzU2VsZWN0ZWQsIGVudW1PcHRpb25zVmFsdWVGb3JJbmRleCwgb3B0aW9uSWQsIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgUmFkaW9XaWRnZXRgIGlzIGEgd2lkZ2V0IGZvciByZW5kZXJpbmcgYSByYWRpbyBncm91cC5cbiAqICBJdCBpcyB0eXBpY2FsbHkgdXNlZCB3aXRoIGEgc3RyaW5nIHByb3BlcnR5IGNvbnN0cmFpbmVkIHdpdGggZW51bSBvcHRpb25zLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBSYWRpb1dpZGdldCh7IG9wdGlvbnMsIHZhbHVlLCByZXF1aXJlZCwgZGlzYWJsZWQsIHJlYWRvbmx5LCBhdXRvZm9jdXMgPSBmYWxzZSwgb25CbHVyLCBvbkZvY3VzLCBvbkNoYW5nZSwgaWQsIH0pIHtcbiAgICBjb25zdCB7IGVudW1PcHRpb25zLCBlbnVtRGlzYWJsZWQsIGlubGluZSwgZW1wdHlWYWx1ZSB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soKHsgdGFyZ2V0OiB7IHZhbHVlIH0gfSkgPT4gb25CbHVyKGlkLCBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgodmFsdWUsIGVudW1PcHRpb25zLCBlbXB0eVZhbHVlKSksIFtvbkJsdXIsIGlkXSk7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjaygoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiBvbkZvY3VzKGlkLCBlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgodmFsdWUsIGVudW1PcHRpb25zLCBlbXB0eVZhbHVlKSksIFtvbkZvY3VzLCBpZF0pO1xuICAgIHJldHVybiAoX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogJ2ZpZWxkLXJhZGlvLWdyb3VwJywgaWQ6IGlkLCBjaGlsZHJlbjogQXJyYXkuaXNBcnJheShlbnVtT3B0aW9ucykgJiZcbiAgICAgICAgICAgIGVudW1PcHRpb25zLm1hcCgob3B0aW9uLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hlY2tlZCA9IGVudW1PcHRpb25zSXNTZWxlY3RlZChvcHRpb24udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtRGlzYWJsZWQgPSBBcnJheS5pc0FycmF5KGVudW1EaXNhYmxlZCkgJiYgZW51bURpc2FibGVkLmluZGV4T2Yob3B0aW9uLnZhbHVlKSAhPT0gLTE7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZWRDbHMgPSBkaXNhYmxlZCB8fCBpdGVtRGlzYWJsZWQgfHwgcmVhZG9ubHkgPyAnZGlzYWJsZWQnIDogJyc7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlQ2hhbmdlID0gKCkgPT4gb25DaGFuZ2Uob3B0aW9uLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBjb25zdCByYWRpbyA9IChfanN4cyhcInNwYW5cIiwgeyBjaGlsZHJlbjogW19qc3goXCJpbnB1dFwiLCB7IHR5cGU6ICdyYWRpbycsIGlkOiBvcHRpb25JZChpZCwgaSksIGNoZWNrZWQ6IGNoZWNrZWQsIG5hbWU6IGlkLCByZXF1aXJlZDogcmVxdWlyZWQsIHZhbHVlOiBTdHJpbmcoaSksIGRpc2FibGVkOiBkaXNhYmxlZCB8fCBpdGVtRGlzYWJsZWQgfHwgcmVhZG9ubHksIGF1dG9Gb2N1czogYXV0b2ZvY3VzICYmIGkgPT09IDAsIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsIG9uQmx1cjogaGFuZGxlQmx1ciwgb25Gb2N1czogaGFuZGxlRm9jdXMsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBhcmlhRGVzY3JpYmVkQnlJZHMoaWQpIH0pLCBfanN4KFwic3BhblwiLCB7IGNoaWxkcmVuOiBvcHRpb24ubGFiZWwgfSldIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5saW5lID8gKF9qc3goXCJsYWJlbFwiLCB7IGNsYXNzTmFtZTogYHJhZGlvLWlubGluZSAke2Rpc2FibGVkQ2xzfWAsIGNoaWxkcmVuOiByYWRpbyB9LCBpKSkgOiAoX2pzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogYHJhZGlvICR7ZGlzYWJsZWRDbHN9YCwgY2hpbGRyZW46IF9qc3goXCJsYWJlbFwiLCB7IGNoaWxkcmVuOiByYWRpbyB9KSB9LCBpKSk7XG4gICAgICAgICAgICB9KSB9KSk7XG59XG5leHBvcnQgZGVmYXVsdCBSYWRpb1dpZGdldDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVJhZGlvV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4LCBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG4vKiogVGhlIGBSYW5nZVdpZGdldGAgY29tcG9uZW50IHVzZXMgdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAgY2hhbmdpbmcgdGhlIHR5cGUgdG8gYHJhbmdlYCBhbmQgd3JhcHBpbmcgdGhlIHJlc3VsdFxuICogaW4gYSBkaXYsIHdpdGggdGhlIHZhbHVlIGFsb25nIHNpZGUgaXQuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJhbmdlV2lkZ2V0KHByb3BzKSB7XG4gICAgY29uc3QgeyB2YWx1ZSwgcmVnaXN0cnk6IHsgdGVtcGxhdGVzOiB7IEJhc2VJbnB1dFRlbXBsYXRlIH0sIH0sIH0gPSBwcm9wcztcbiAgICByZXR1cm4gKF9qc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiAnZmllbGQtcmFuZ2Utd3JhcHBlcicsIGNoaWxkcmVuOiBbX2pzeChCYXNlSW5wdXRUZW1wbGF0ZSwgeyB0eXBlOiAncmFuZ2UnLCAuLi5wcm9wcyB9KSwgX2pzeChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdyYW5nZS12aWV3JywgY2hpbGRyZW46IHZhbHVlIH0pXSB9KSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SYW5nZVdpZGdldC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCwganN4cyBhcyBfanN4cyB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhcmlhRGVzY3JpYmVkQnlJZHMsIGVudW1PcHRpb25zSW5kZXhGb3JWYWx1ZSwgZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4LCB9IGZyb20gJ0ByanNmL3V0aWxzJztcbmZ1bmN0aW9uIGdldFZhbHVlKGV2ZW50LCBtdWx0aXBsZSkge1xuICAgIGlmIChtdWx0aXBsZSkge1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbShldmVudC50YXJnZXQub3B0aW9ucylcbiAgICAgICAgICAgIC5zbGljZSgpXG4gICAgICAgICAgICAuZmlsdGVyKChvKSA9PiBvLnNlbGVjdGVkKVxuICAgICAgICAgICAgLm1hcCgobykgPT4gby52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBldmVudC50YXJnZXQudmFsdWU7XG59XG4vKiogVGhlIGBTZWxlY3RXaWRnZXRgIGlzIGEgd2lkZ2V0IGZvciByZW5kZXJpbmcgZHJvcGRvd25zLlxuICogIEl0IGlzIHR5cGljYWxseSB1c2VkIHdpdGggc3RyaW5nIHByb3BlcnRpZXMgY29uc3RyYWluZWQgd2l0aCBlbnVtIG9wdGlvbnMuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmZ1bmN0aW9uIFNlbGVjdFdpZGdldCh7IHNjaGVtYSwgaWQsIG9wdGlvbnMsIHZhbHVlLCByZXF1aXJlZCwgZGlzYWJsZWQsIHJlYWRvbmx5LCBtdWx0aXBsZSA9IGZhbHNlLCBhdXRvZm9jdXMgPSBmYWxzZSwgb25DaGFuZ2UsIG9uQmx1ciwgb25Gb2N1cywgcGxhY2Vob2xkZXIsIH0pIHtcbiAgICBjb25zdCB7IGVudW1PcHRpb25zLCBlbnVtRGlzYWJsZWQsIGVtcHR5VmFsdWU6IG9wdEVtcHR5VmFsIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGVtcHR5VmFsdWUgPSBtdWx0aXBsZSA/IFtdIDogJyc7XG4gICAgY29uc3QgaGFuZGxlRm9jdXMgPSB1c2VDYWxsYmFjaygoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgbmV3VmFsdWUgPSBnZXRWYWx1ZShldmVudCwgbXVsdGlwbGUpO1xuICAgICAgICByZXR1cm4gb25Gb2N1cyhpZCwgZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4KG5ld1ZhbHVlLCBlbnVtT3B0aW9ucywgb3B0RW1wdHlWYWwpKTtcbiAgICB9LCBbb25Gb2N1cywgaWQsIHNjaGVtYSwgbXVsdGlwbGUsIG9wdGlvbnNdKTtcbiAgICBjb25zdCBoYW5kbGVCbHVyID0gdXNlQ2FsbGJhY2soKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gZ2V0VmFsdWUoZXZlbnQsIG11bHRpcGxlKTtcbiAgICAgICAgcmV0dXJuIG9uQmx1cihpZCwgZW51bU9wdGlvbnNWYWx1ZUZvckluZGV4KG5ld1ZhbHVlLCBlbnVtT3B0aW9ucywgb3B0RW1wdHlWYWwpKTtcbiAgICB9LCBbb25CbHVyLCBpZCwgc2NoZW1hLCBtdWx0aXBsZSwgb3B0aW9uc10pO1xuICAgIGNvbnN0IGhhbmRsZUNoYW5nZSA9IHVzZUNhbGxiYWNrKChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCBuZXdWYWx1ZSA9IGdldFZhbHVlKGV2ZW50LCBtdWx0aXBsZSk7XG4gICAgICAgIHJldHVybiBvbkNoYW5nZShlbnVtT3B0aW9uc1ZhbHVlRm9ySW5kZXgobmV3VmFsdWUsIGVudW1PcHRpb25zLCBvcHRFbXB0eVZhbCkpO1xuICAgIH0sIFtvbkNoYW5nZSwgc2NoZW1hLCBtdWx0aXBsZSwgb3B0aW9uc10pO1xuICAgIGNvbnN0IHNlbGVjdGVkSW5kZXhlcyA9IGVudW1PcHRpb25zSW5kZXhGb3JWYWx1ZSh2YWx1ZSwgZW51bU9wdGlvbnMsIG11bHRpcGxlKTtcbiAgICByZXR1cm4gKF9qc3hzKFwic2VsZWN0XCIsIHsgaWQ6IGlkLCBuYW1lOiBpZCwgbXVsdGlwbGU6IG11bHRpcGxlLCBjbGFzc05hbWU6ICdmb3JtLWNvbnRyb2wnLCB2YWx1ZTogdHlwZW9mIHNlbGVjdGVkSW5kZXhlcyA9PT0gJ3VuZGVmaW5lZCcgPyBlbXB0eVZhbHVlIDogc2VsZWN0ZWRJbmRleGVzLCByZXF1aXJlZDogcmVxdWlyZWQsIGRpc2FibGVkOiBkaXNhYmxlZCB8fCByZWFkb25seSwgYXV0b0ZvY3VzOiBhdXRvZm9jdXMsIG9uQmx1cjogaGFuZGxlQmx1ciwgb25Gb2N1czogaGFuZGxlRm9jdXMsIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBhcmlhRGVzY3JpYmVkQnlJZHMoaWQpLCBjaGlsZHJlbjogWyFtdWx0aXBsZSAmJiBzY2hlbWEuZGVmYXVsdCA9PT0gdW5kZWZpbmVkICYmIF9qc3goXCJvcHRpb25cIiwgeyB2YWx1ZTogJycsIGNoaWxkcmVuOiBwbGFjZWhvbGRlciB9KSwgQXJyYXkuaXNBcnJheShlbnVtT3B0aW9ucykgJiZcbiAgICAgICAgICAgICAgICBlbnVtT3B0aW9ucy5tYXAoKHsgdmFsdWUsIGxhYmVsIH0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGlzYWJsZWQgPSBlbnVtRGlzYWJsZWQgJiYgZW51bURpc2FibGVkLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChfanN4KFwib3B0aW9uXCIsIHsgdmFsdWU6IFN0cmluZyhpKSwgZGlzYWJsZWQ6IGRpc2FibGVkLCBjaGlsZHJlbjogbGFiZWwgfSwgaSkpO1xuICAgICAgICAgICAgICAgIH0pXSB9KSk7XG59XG5leHBvcnQgZGVmYXVsdCBTZWxlY3RXaWRnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1TZWxlY3RXaWRnZXQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IGdldFRlbXBsYXRlIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgVGV4dFdpZGdldGAgY29tcG9uZW50IHVzZXMgdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFRleHRXaWRnZXQocHJvcHMpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHJlZ2lzdHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCBCYXNlSW5wdXRUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdCYXNlSW5wdXRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX2pzeChCYXNlSW5wdXRUZW1wbGF0ZSwgeyAuLi5wcm9wcyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVRleHRXaWRnZXQuanMubWFwIiwiaW1wb3J0IHsganN4IGFzIF9qc3ggfSBmcm9tIFwicmVhY3QvanN4LXJ1bnRpbWVcIjtcbmltcG9ydCB7IHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXJpYURlc2NyaWJlZEJ5SWRzIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuLyoqIFRoZSBgVGV4dGFyZWFXaWRnZXRgIGlzIGEgd2lkZ2V0IGZvciByZW5kZXJpbmcgaW5wdXQgZmllbGRzIGFzIHRleHRhcmVhLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5mdW5jdGlvbiBUZXh0YXJlYVdpZGdldCh7IGlkLCBvcHRpb25zID0ge30sIHBsYWNlaG9sZGVyLCB2YWx1ZSwgcmVxdWlyZWQsIGRpc2FibGVkLCByZWFkb25seSwgYXV0b2ZvY3VzID0gZmFsc2UsIG9uQ2hhbmdlLCBvbkJsdXIsIG9uRm9jdXMsIH0pIHtcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygoeyB0YXJnZXQ6IHsgdmFsdWUgfSB9KSA9PiBvbkNoYW5nZSh2YWx1ZSA9PT0gJycgPyBvcHRpb25zLmVtcHR5VmFsdWUgOiB2YWx1ZSksIFtvbkNoYW5nZSwgb3B0aW9ucy5lbXB0eVZhbHVlXSk7XG4gICAgY29uc3QgaGFuZGxlQmx1ciA9IHVzZUNhbGxiYWNrKCh7IHRhcmdldDogeyB2YWx1ZSB9IH0pID0+IG9uQmx1cihpZCwgdmFsdWUpLCBbb25CbHVyLCBpZF0pO1xuICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gdXNlQ2FsbGJhY2soKHsgdGFyZ2V0OiB7IHZhbHVlIH0gfSkgPT4gb25Gb2N1cyhpZCwgdmFsdWUpLCBbaWQsIG9uRm9jdXNdKTtcbiAgICByZXR1cm4gKF9qc3goXCJ0ZXh0YXJlYVwiLCB7IGlkOiBpZCwgbmFtZTogaWQsIGNsYXNzTmFtZTogJ2Zvcm0tY29udHJvbCcsIHZhbHVlOiB2YWx1ZSA/IHZhbHVlIDogJycsIHBsYWNlaG9sZGVyOiBwbGFjZWhvbGRlciwgcmVxdWlyZWQ6IHJlcXVpcmVkLCBkaXNhYmxlZDogZGlzYWJsZWQsIHJlYWRPbmx5OiByZWFkb25seSwgYXV0b0ZvY3VzOiBhdXRvZm9jdXMsIHJvd3M6IG9wdGlvbnMucm93cywgb25CbHVyOiBoYW5kbGVCbHVyLCBvbkZvY3VzOiBoYW5kbGVGb2N1cywgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRCeUlkcyhpZCkgfSkpO1xufVxuVGV4dGFyZWFXaWRnZXQuZGVmYXVsdFByb3BzID0ge1xuICAgIGF1dG9mb2N1czogZmFsc2UsXG4gICAgb3B0aW9uczoge30sXG59O1xuZXhwb3J0IGRlZmF1bHQgVGV4dGFyZWFXaWRnZXQ7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UZXh0YXJlYVdpZGdldC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZSB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYFRpbWVXaWRnZXRgIGNvbXBvbmVudCB1c2VzIHRoZSBgQmFzZUlucHV0VGVtcGxhdGVgIGNoYW5naW5nIHRoZSB0eXBlIHRvIGB0aW1lYCBhbmQgdHJhbnNmb3Jtc1xuICogdGhlIHZhbHVlIHRvIHVuZGVmaW5lZCB3aGVuIGl0IGlzIGZhbHN5IGR1cmluZyB0aGUgYG9uQ2hhbmdlYCBoYW5kbGluZy5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgYFdpZGdldFByb3BzYCBmb3IgdGhpcyBjb21wb25lbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gVGltZVdpZGdldChwcm9wcykge1xuICAgIGNvbnN0IHsgb25DaGFuZ2UsIG9wdGlvbnMsIHJlZ2lzdHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCBCYXNlSW5wdXRUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdCYXNlSW5wdXRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICBjb25zdCBoYW5kbGVDaGFuZ2UgPSB1c2VDYWxsYmFjaygodmFsdWUpID0+IG9uQ2hhbmdlKHZhbHVlID8gYCR7dmFsdWV9OjAwYCA6IHVuZGVmaW5lZCksIFtvbkNoYW5nZV0pO1xuICAgIHJldHVybiBfanN4KEJhc2VJbnB1dFRlbXBsYXRlLCB7IHR5cGU6ICd0aW1lJywgLi4ucHJvcHMsIG9uQ2hhbmdlOiBoYW5kbGVDaGFuZ2UgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1UaW1lV2lkZ2V0LmpzLm1hcCIsImltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBnZXRUZW1wbGF0ZSB9IGZyb20gJ0ByanNmL3V0aWxzJztcbi8qKiBUaGUgYFVSTFdpZGdldGAgY29tcG9uZW50IHVzZXMgdGhlIGBCYXNlSW5wdXRUZW1wbGF0ZWAgY2hhbmdpbmcgdGhlIHR5cGUgdG8gYHVybGAuXG4gKlxuICogQHBhcmFtIHByb3BzIC0gVGhlIGBXaWRnZXRQcm9wc2AgZm9yIHRoaXMgY29tcG9uZW50XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFVSTFdpZGdldChwcm9wcykge1xuICAgIGNvbnN0IHsgb3B0aW9ucywgcmVnaXN0cnkgfSA9IHByb3BzO1xuICAgIGNvbnN0IEJhc2VJbnB1dFRlbXBsYXRlID0gZ2V0VGVtcGxhdGUoJ0Jhc2VJbnB1dFRlbXBsYXRlJywgcmVnaXN0cnksIG9wdGlvbnMpO1xuICAgIHJldHVybiBfanN4KEJhc2VJbnB1dFRlbXBsYXRlLCB7IHR5cGU6ICd1cmwnLCAuLi5wcm9wcyB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVVSTFdpZGdldC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZ2V0VGVtcGxhdGUgfSBmcm9tICdAcmpzZi91dGlscyc7XG4vKiogVGhlIGBVcERvd25XaWRnZXRgIGNvbXBvbmVudCB1c2VzIHRoZSBgQmFzZUlucHV0VGVtcGxhdGVgIGNoYW5naW5nIHRoZSB0eXBlIHRvIGBudW1iZXJgLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBgV2lkZ2V0UHJvcHNgIGZvciB0aGlzIGNvbXBvbmVudFxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBVcERvd25XaWRnZXQocHJvcHMpIHtcbiAgICBjb25zdCB7IG9wdGlvbnMsIHJlZ2lzdHJ5IH0gPSBwcm9wcztcbiAgICBjb25zdCBCYXNlSW5wdXRUZW1wbGF0ZSA9IGdldFRlbXBsYXRlKCdCYXNlSW5wdXRUZW1wbGF0ZScsIHJlZ2lzdHJ5LCBvcHRpb25zKTtcbiAgICByZXR1cm4gX2pzeChCYXNlSW5wdXRUZW1wbGF0ZSwgeyB0eXBlOiAnbnVtYmVyJywgLi4ucHJvcHMgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1VcERvd25XaWRnZXQuanMubWFwIiwiaW1wb3J0IEFsdERhdGVXaWRnZXQgZnJvbSAnLi9BbHREYXRlV2lkZ2V0JztcbmltcG9ydCBBbHREYXRlVGltZVdpZGdldCBmcm9tICcuL0FsdERhdGVUaW1lV2lkZ2V0JztcbmltcG9ydCBDaGVja2JveFdpZGdldCBmcm9tICcuL0NoZWNrYm94V2lkZ2V0JztcbmltcG9ydCBDaGVja2JveGVzV2lkZ2V0IGZyb20gJy4vQ2hlY2tib3hlc1dpZGdldCc7XG5pbXBvcnQgQ29sb3JXaWRnZXQgZnJvbSAnLi9Db2xvcldpZGdldCc7XG5pbXBvcnQgRGF0ZVdpZGdldCBmcm9tICcuL0RhdGVXaWRnZXQnO1xuaW1wb3J0IERhdGVUaW1lV2lkZ2V0IGZyb20gJy4vRGF0ZVRpbWVXaWRnZXQnO1xuaW1wb3J0IEVtYWlsV2lkZ2V0IGZyb20gJy4vRW1haWxXaWRnZXQnO1xuaW1wb3J0IEZpbGVXaWRnZXQgZnJvbSAnLi9GaWxlV2lkZ2V0JztcbmltcG9ydCBIaWRkZW5XaWRnZXQgZnJvbSAnLi9IaWRkZW5XaWRnZXQnO1xuaW1wb3J0IFBhc3N3b3JkV2lkZ2V0IGZyb20gJy4vUGFzc3dvcmRXaWRnZXQnO1xuaW1wb3J0IFJhZGlvV2lkZ2V0IGZyb20gJy4vUmFkaW9XaWRnZXQnO1xuaW1wb3J0IFJhbmdlV2lkZ2V0IGZyb20gJy4vUmFuZ2VXaWRnZXQnO1xuaW1wb3J0IFNlbGVjdFdpZGdldCBmcm9tICcuL1NlbGVjdFdpZGdldCc7XG5pbXBvcnQgVGV4dGFyZWFXaWRnZXQgZnJvbSAnLi9UZXh0YXJlYVdpZGdldCc7XG5pbXBvcnQgVGV4dFdpZGdldCBmcm9tICcuL1RleHRXaWRnZXQnO1xuaW1wb3J0IFRpbWVXaWRnZXQgZnJvbSAnLi9UaW1lV2lkZ2V0JztcbmltcG9ydCBVUkxXaWRnZXQgZnJvbSAnLi9VUkxXaWRnZXQnO1xuaW1wb3J0IFVwRG93bldpZGdldCBmcm9tICcuL1VwRG93bldpZGdldCc7XG5mdW5jdGlvbiB3aWRnZXRzKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIEFsdERhdGVXaWRnZXQsXG4gICAgICAgIEFsdERhdGVUaW1lV2lkZ2V0LFxuICAgICAgICBDaGVja2JveFdpZGdldCxcbiAgICAgICAgQ2hlY2tib3hlc1dpZGdldCxcbiAgICAgICAgQ29sb3JXaWRnZXQsXG4gICAgICAgIERhdGVXaWRnZXQsXG4gICAgICAgIERhdGVUaW1lV2lkZ2V0LFxuICAgICAgICBFbWFpbFdpZGdldCxcbiAgICAgICAgRmlsZVdpZGdldCxcbiAgICAgICAgSGlkZGVuV2lkZ2V0LFxuICAgICAgICBQYXNzd29yZFdpZGdldCxcbiAgICAgICAgUmFkaW9XaWRnZXQsXG4gICAgICAgIFJhbmdlV2lkZ2V0LFxuICAgICAgICBTZWxlY3RXaWRnZXQsXG4gICAgICAgIFRleHRXaWRnZXQsXG4gICAgICAgIFRleHRhcmVhV2lkZ2V0LFxuICAgICAgICBUaW1lV2lkZ2V0LFxuICAgICAgICBVcERvd25XaWRnZXQsXG4gICAgICAgIFVSTFdpZGdldCxcbiAgICB9O1xufVxuZXhwb3J0IGRlZmF1bHQgd2lkZ2V0cztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImltcG9ydCB7IGVuZ2xpc2hTdHJpbmdUcmFuc2xhdG9yIH0gZnJvbSAnQHJqc2YvdXRpbHMnO1xuaW1wb3J0IGZpZWxkcyBmcm9tICcuL2NvbXBvbmVudHMvZmllbGRzJztcbmltcG9ydCB0ZW1wbGF0ZXMgZnJvbSAnLi9jb21wb25lbnRzL3RlbXBsYXRlcyc7XG5pbXBvcnQgd2lkZ2V0cyBmcm9tICcuL2NvbXBvbmVudHMvd2lkZ2V0cyc7XG4vKiogVGhlIGRlZmF1bHQgcmVnaXN0cnkgY29uc2lzdHMgb2YgYWxsIHRoZSBmaWVsZHMsIHRlbXBsYXRlcyBhbmQgd2lkZ2V0cyBwcm92aWRlZCBpbiB0aGUgY29yZSBpbXBsZW1lbnRhdGlvbixcbiAqIHBsdXMgYW4gZW1wdHkgYHJvb3RTY2hlbWFgIGFuZCBgZm9ybUNvbnRleHQuIFdlIG9taXQgc2NoZW1hVXRpbHMgaGVyZSBiZWNhdXNlIGl0IGNhbm5vdCBiZSBkZWZhdWx0ZWQgd2l0aG91dCBhXG4gKiByb290U2NoZW1hIGFuZCB2YWxpZGF0b3IuIEl0IHdpbGwgYmUgYWRkZWQgaW50byB0aGUgY29tcHV0ZWQgcmVnaXN0cnkgbGF0ZXIgaW4gdGhlIEZvcm0uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldERlZmF1bHRSZWdpc3RyeSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZHM6IGZpZWxkcygpLFxuICAgICAgICB0ZW1wbGF0ZXM6IHRlbXBsYXRlcygpLFxuICAgICAgICB3aWRnZXRzOiB3aWRnZXRzKCksXG4gICAgICAgIHJvb3RTY2hlbWE6IHt9LFxuICAgICAgICBmb3JtQ29udGV4dDoge30sXG4gICAgICAgIHRyYW5zbGF0ZVN0cmluZzogZW5nbGlzaFN0cmluZ1RyYW5zbGF0b3IsXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldERlZmF1bHRSZWdpc3RyeS5qcy5tYXAiLCJpbXBvcnQgRm9ybSBmcm9tICcuL2NvbXBvbmVudHMvRm9ybSc7XG5pbXBvcnQgd2l0aFRoZW1lIGZyb20gJy4vd2l0aFRoZW1lJztcbmltcG9ydCBnZXREZWZhdWx0UmVnaXN0cnkgZnJvbSAnLi9nZXREZWZhdWx0UmVnaXN0cnknO1xuZXhwb3J0IHsgd2l0aFRoZW1lLCBnZXREZWZhdWx0UmVnaXN0cnkgfTtcbmV4cG9ydCBkZWZhdWx0IEZvcm07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJpbXBvcnQgeyBqc3ggYXMgX2pzeCB9IGZyb20gXCJyZWFjdC9qc3gtcnVudGltZVwiO1xuaW1wb3J0IHsgZm9yd2FyZFJlZiB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCBGb3JtIGZyb20gJy4vY29tcG9uZW50cy9Gb3JtJztcbi8qKiBBIEhpZ2hlci1PcmRlciBjb21wb25lbnQgdGhhdCBjcmVhdGVzIGEgd3JhcHBlciBhcm91bmQgYSBgRm9ybWAgd2l0aCB0aGUgb3ZlcnJpZGVzIGZyb20gdGhlIGBXaXRoVGhlbWVQcm9wc2AgKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdpdGhUaGVtZSh0aGVtZVByb3BzKSB7XG4gICAgcmV0dXJuIGZvcndhcmRSZWYoKHsgZmllbGRzLCB3aWRnZXRzLCB0ZW1wbGF0ZXMsIC4uLmRpcmVjdFByb3BzIH0sIHJlZikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGZpZWxkcyA9IHsgLi4udGhlbWVQcm9wcyA9PT0gbnVsbCB8fCB0aGVtZVByb3BzID09PSB2b2lkIDAgPyB2b2lkIDAgOiB0aGVtZVByb3BzLmZpZWxkcywgLi4uZmllbGRzIH07XG4gICAgICAgIHdpZGdldHMgPSB7IC4uLnRoZW1lUHJvcHMgPT09IG51bGwgfHwgdGhlbWVQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhlbWVQcm9wcy53aWRnZXRzLCAuLi53aWRnZXRzIH07XG4gICAgICAgIHRlbXBsYXRlcyA9IHtcbiAgICAgICAgICAgIC4uLnRoZW1lUHJvcHMgPT09IG51bGwgfHwgdGhlbWVQcm9wcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhlbWVQcm9wcy50ZW1wbGF0ZXMsXG4gICAgICAgICAgICAuLi50ZW1wbGF0ZXMsXG4gICAgICAgICAgICBCdXR0b25UZW1wbGF0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi4oX2EgPSB0aGVtZVByb3BzID09PSBudWxsIHx8IHRoZW1lUHJvcHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRoZW1lUHJvcHMudGVtcGxhdGVzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuQnV0dG9uVGVtcGxhdGVzLFxuICAgICAgICAgICAgICAgIC4uLnRlbXBsYXRlcyA9PT0gbnVsbCB8fCB0ZW1wbGF0ZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRlbXBsYXRlcy5CdXR0b25UZW1wbGF0ZXMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gKF9qc3goRm9ybSwgeyAuLi50aGVtZVByb3BzLCAuLi5kaXJlY3RQcm9wcywgZmllbGRzOiBmaWVsZHMsIHdpZGdldHM6IHdpZGdldHMsIHRlbXBsYXRlczogdGVtcGxhdGVzLCByZWY6IHJlZiB9KSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13aXRoVGhlbWUuanMubWFwIiwiLyoqXG4gKiBUaGUgdW5pcXVlIGlkIGlzIHVzZWQgZm9yIHVuaXF1ZSBoYXNoZXMuXG4gKi9cbmxldCB1bmlxdWVJZCA9IDA7XG4vKipcbiAqIFF1aWNrIGRpY3Rpb25hcnkgbG9va3VwIGZvciB1bml0LWxlc3MgbnVtYmVycy5cbiAqL1xuY29uc3QgQ1NTX05VTUJFUiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4vKipcbiAqIENTUyBwcm9wZXJ0aWVzIHRoYXQgYXJlIHZhbGlkIHVuaXQtbGVzcyBudW1iZXJzLlxuICpcbiAqIFJlZjogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2Jsb2IvbWFzdGVyL3BhY2thZ2VzL3JlYWN0LWRvbS9zcmMvc2hhcmVkL0NTU1Byb3BlcnR5LmpzXG4gKi9cbmNvbnN0IENTU19OVU1CRVJfS0VZUyA9IFtcbiAgICBcImFuaW1hdGlvbi1pdGVyYXRpb24tY291bnRcIixcbiAgICBcImJvcmRlci1pbWFnZS1vdXRzZXRcIixcbiAgICBcImJvcmRlci1pbWFnZS1zbGljZVwiLFxuICAgIFwiYm9yZGVyLWltYWdlLXdpZHRoXCIsXG4gICAgXCJib3gtZmxleFwiLFxuICAgIFwiYm94LWZsZXgtZ3JvdXBcIixcbiAgICBcImJveC1vcmRpbmFsLWdyb3VwXCIsXG4gICAgXCJjb2x1bW4tY291bnRcIixcbiAgICBcImNvbHVtbnNcIixcbiAgICBcImNvdW50ZXItaW5jcmVtZW50XCIsXG4gICAgXCJjb3VudGVyLXJlc2V0XCIsXG4gICAgXCJmbGV4XCIsXG4gICAgXCJmbGV4LWdyb3dcIixcbiAgICBcImZsZXgtcG9zaXRpdmVcIixcbiAgICBcImZsZXgtc2hyaW5rXCIsXG4gICAgXCJmbGV4LW5lZ2F0aXZlXCIsXG4gICAgXCJmbGV4LW9yZGVyXCIsXG4gICAgXCJmb250LXdlaWdodFwiLFxuICAgIFwiZ3JpZC1hcmVhXCIsXG4gICAgXCJncmlkLWNvbHVtblwiLFxuICAgIFwiZ3JpZC1jb2x1bW4tZW5kXCIsXG4gICAgXCJncmlkLWNvbHVtbi1zcGFuXCIsXG4gICAgXCJncmlkLWNvbHVtbi1zdGFydFwiLFxuICAgIFwiZ3JpZC1yb3dcIixcbiAgICBcImdyaWQtcm93LWVuZFwiLFxuICAgIFwiZ3JpZC1yb3ctc3BhblwiLFxuICAgIFwiZ3JpZC1yb3ctc3RhcnRcIixcbiAgICBcImxpbmUtY2xhbXBcIixcbiAgICBcImxpbmUtaGVpZ2h0XCIsXG4gICAgXCJvcGFjaXR5XCIsXG4gICAgXCJvcmRlclwiLFxuICAgIFwib3JwaGFuc1wiLFxuICAgIFwidGFiLXNpemVcIixcbiAgICBcIndpZG93c1wiLFxuICAgIFwiei1pbmRleFwiLFxuICAgIFwiem9vbVwiLFxuICAgIC8vIFNWRyBwcm9wZXJ0aWVzLlxuICAgIFwiZmlsbC1vcGFjaXR5XCIsXG4gICAgXCJmbG9vZC1vcGFjaXR5XCIsXG4gICAgXCJzdG9wLW9wYWNpdHlcIixcbiAgICBcInN0cm9rZS1kYXNoYXJyYXlcIixcbiAgICBcInN0cm9rZS1kYXNob2Zmc2V0XCIsXG4gICAgXCJzdHJva2UtbWl0ZXJsaW1pdFwiLFxuICAgIFwic3Ryb2tlLW9wYWNpdHlcIixcbiAgICBcInN0cm9rZS13aWR0aFwiXG5dO1xuLy8gQWRkIHZlbmRvciBwcmVmaXhlcyB0byBhbGwgdW5pdC1sZXNzIHByb3BlcnRpZXMuXG5mb3IgKGNvbnN0IHByb3BlcnR5IG9mIENTU19OVU1CRVJfS0VZUykge1xuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIFtcIi13ZWJraXQtXCIsIFwiLW1zLVwiLCBcIi1tb3otXCIsIFwiLW8tXCIsIFwiXCJdKSB7XG4gICAgICAgIENTU19OVU1CRVJbcHJlZml4ICsgcHJvcGVydHldID0gdHJ1ZTtcbiAgICB9XG59XG4vKipcbiAqIEVzY2FwZSBhIENTUyBjbGFzcyBuYW1lLlxuICovXG5mdW5jdGlvbiBlc2NhcGUoc3RyKSB7XG4gICAgcmV0dXJuIHN0ci5yZXBsYWNlKC9bICEjJCUmKCkqKywuLzs8PT4/QFtcXF1eYHt8fX5cIidcXFxcXS9nLCBcIlxcXFwkJlwiKTtcbn1cbi8qKlxuICogVHJhbnNmb3JtIGEgSmF2YVNjcmlwdCBwcm9wZXJ0eSBpbnRvIGEgQ1NTIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBoeXBoZW5hdGUocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIHByb3BlcnR5TmFtZVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgKG0pID0+IGAtJHttLnRvTG93ZXJDYXNlKCl9YClcbiAgICAgICAgLnJlcGxhY2UoL15tcy0vLCBcIi1tcy1cIik7IC8vIEludGVybmV0IEV4cGxvcmVyIHZlbmRvciBwcmVmaXguXG59XG4vKipcbiAqIEdlbmVyYXRlIGEgaGFzaCB2YWx1ZSBmcm9tIGEgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHJpbmdIYXNoKHN0cikge1xuICAgIGxldCB2YWx1ZSA9IDUzODE7XG4gICAgbGV0IGxlbiA9IHN0ci5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbi0tKVxuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSAqIDMzKSBeIHN0ci5jaGFyQ29kZUF0KGxlbik7XG4gICAgcmV0dXJuICh2YWx1ZSA+Pj4gMCkudG9TdHJpbmcoMzYpO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBzdHlsZSBzdHJpbmcgdG8gYSBDU1Mgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBzdHlsZVRvU3RyaW5nKGtleSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiICYmICFDU1NfTlVNQkVSW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGAke2tleX06JHt2YWx1ZX1weGA7XG4gICAgfVxuICAgIHJldHVybiBgJHtrZXl9OiR7dmFsdWV9YDtcbn1cbi8qKlxuICogU29ydCBhbiBhcnJheSBvZiB0dXBsZXMgYnkgZmlyc3QgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIHNvcnRUdXBsZXModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUuc29ydCgoYSwgYikgPT4gKGFbMF0gPiBiWzBdID8gMSA6IC0xKSk7XG59XG4vKipcbiAqIENhdGVnb3JpemUgdXNlciBzdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlU3R5bGVzKHN0eWxlcywgaGFzTmVzdGVkU3R5bGVzKSB7XG4gICAgY29uc3QgcHJvcGVydGllcyA9IFtdO1xuICAgIGNvbnN0IG5lc3RlZFN0eWxlcyA9IFtdO1xuICAgIC8vIFNvcnQga2V5cyBiZWZvcmUgYWRkaW5nIHRvIHN0eWxlcy5cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzdHlsZXMpKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBrZXkudHJpbSgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHN0eWxlc1trZXldO1xuICAgICAgICBpZiAobmFtZS5jaGFyQ29kZUF0KDApICE9PSAzNiAvKiAkICovICYmIHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgbmVzdGVkU3R5bGVzLnB1c2goW25hbWUsIHZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLnB1c2goW2h5cGhlbmF0ZShuYW1lKSwgdmFsdWVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZTogc3RyaW5naWZ5UHJvcGVydGllcyhzb3J0VHVwbGVzKHByb3BlcnRpZXMpKSxcbiAgICAgICAgbmVzdGVkOiBoYXNOZXN0ZWRTdHlsZXMgPyBuZXN0ZWRTdHlsZXMgOiBzb3J0VHVwbGVzKG5lc3RlZFN0eWxlcyksXG4gICAgICAgIGlzVW5pcXVlOiAhIXN0eWxlcy4kdW5pcXVlXG4gICAgfTtcbn1cbi8qKlxuICogU3RyaW5naWZ5IGFuIGFycmF5IG9mIHByb3BlcnR5IHR1cGxlcy5cbiAqL1xuZnVuY3Rpb24gc3RyaW5naWZ5UHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHByb3BlcnRpZXNcbiAgICAgICAgLm1hcCgoW25hbWUsIHZhbHVlXSkgPT4ge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKVxuICAgICAgICAgICAgcmV0dXJuIHN0eWxlVG9TdHJpbmcobmFtZSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKHggPT4gc3R5bGVUb1N0cmluZyhuYW1lLCB4KSkuam9pbihcIjtcIik7XG4gICAgfSlcbiAgICAgICAgLmpvaW4oXCI7XCIpO1xufVxuLyoqXG4gKiBJbnRlcnBvbGF0ZSBDU1Mgc2VsZWN0b3JzLlxuICovXG5mdW5jdGlvbiBpbnRlcnBvbGF0ZShzZWxlY3RvciwgcGFyZW50KSB7XG4gICAgaWYgKHNlbGVjdG9yLmluZGV4T2YoXCImXCIpID09PSAtMSlcbiAgICAgICAgcmV0dXJuIGAke3BhcmVudH0gJHtzZWxlY3Rvcn1gO1xuICAgIHJldHVybiBzZWxlY3Rvci5yZXBsYWNlKC8mL2csIHBhcmVudCk7XG59XG4vKipcbiAqIFJlY3Vyc2l2ZSBsb29wIGJ1aWxkaW5nIHN0eWxlcyB3aXRoIGRlZmVycmVkIHNlbGVjdG9ycy5cbiAqL1xuZnVuY3Rpb24gc3R5bGl6ZShzZWxlY3Rvciwgc3R5bGVzLCBydWxlc0xpc3QsIHN0eWxlc0xpc3QsIHBhcmVudCkge1xuICAgIGNvbnN0IHsgc3R5bGUsIG5lc3RlZCwgaXNVbmlxdWUgfSA9IHBhcnNlU3R5bGVzKHN0eWxlcywgc2VsZWN0b3IgIT09IFwiXCIpO1xuICAgIGxldCBwaWQgPSBzdHlsZTtcbiAgICBpZiAoc2VsZWN0b3IuY2hhckNvZGVBdCgwKSA9PT0gNjQgLyogQCAqLykge1xuICAgICAgICBjb25zdCBjaGlsZCA9IHtcbiAgICAgICAgICAgIHNlbGVjdG9yLFxuICAgICAgICAgICAgc3R5bGVzOiBbXSxcbiAgICAgICAgICAgIHJ1bGVzOiBbXSxcbiAgICAgICAgICAgIHN0eWxlOiBwYXJlbnQgPyBcIlwiIDogc3R5bGVcbiAgICAgICAgfTtcbiAgICAgICAgcnVsZXNMaXN0LnB1c2goY2hpbGQpO1xuICAgICAgICAvLyBOZXN0ZWQgc3R5bGVzIHN1cHBvcnQgKGUuZy4gYC5mb28gPiBAbWVkaWEgPiAuYmFyYCkuXG4gICAgICAgIGlmIChzdHlsZSAmJiBwYXJlbnQpIHtcbiAgICAgICAgICAgIGNoaWxkLnN0eWxlcy5wdXNoKHsgc2VsZWN0b3I6IHBhcmVudCwgc3R5bGUsIGlzVW5pcXVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBuZXN0ZWQpIHtcbiAgICAgICAgICAgIHBpZCArPSBuYW1lICsgc3R5bGl6ZShuYW1lLCB2YWx1ZSwgY2hpbGQucnVsZXMsIGNoaWxkLnN0eWxlcywgcGFyZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3Qga2V5ID0gcGFyZW50ID8gaW50ZXJwb2xhdGUoc2VsZWN0b3IsIHBhcmVudCkgOiBzZWxlY3RvcjtcbiAgICAgICAgaWYgKHN0eWxlKVxuICAgICAgICAgICAgc3R5bGVzTGlzdC5wdXNoKHsgc2VsZWN0b3I6IGtleSwgc3R5bGUsIGlzVW5pcXVlIH0pO1xuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgbmVzdGVkKSB7XG4gICAgICAgICAgICBwaWQgKz0gbmFtZSArIHN0eWxpemUobmFtZSwgdmFsdWUsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGlkO1xufVxuLyoqXG4gKiBUcmFuc2Zvcm0gYHN0eWxpemVgIHRyZWUgaW50byBzdHlsZSBvYmplY3RzLlxuICovXG5mdW5jdGlvbiBjb21wb3NlU3R5bGl6ZShjYWNoZSwgcGlkLCBydWxlc0xpc3QsIHN0eWxlc0xpc3QsIGNsYXNzTmFtZSwgaXNTdHlsZSkge1xuICAgIGZvciAoY29uc3QgeyBzZWxlY3Rvciwgc3R5bGUsIGlzVW5pcXVlIH0gb2Ygc3R5bGVzTGlzdCkge1xuICAgICAgICBjb25zdCBrZXkgPSBpc1N0eWxlID8gaW50ZXJwb2xhdGUoc2VsZWN0b3IsIGNsYXNzTmFtZSkgOiBzZWxlY3RvcjtcbiAgICAgICAgY29uc3QgaWQgPSBpc1VuaXF1ZVxuICAgICAgICAgICAgPyBgdVxcMCR7KCsrdW5pcXVlSWQpLnRvU3RyaW5nKDM2KX1gXG4gICAgICAgICAgICA6IGBzXFwwJHtwaWR9XFwwJHtzdHlsZX1gO1xuICAgICAgICBjb25zdCBpdGVtID0gbmV3IFN0eWxlKHN0eWxlLCBpZCk7XG4gICAgICAgIGl0ZW0uYWRkKG5ldyBTZWxlY3RvcihrZXksIGBrXFwwJHtwaWR9XFwwJHtrZXl9YCkpO1xuICAgICAgICBjYWNoZS5hZGQoaXRlbSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgeyBzZWxlY3Rvciwgc3R5bGUsIHJ1bGVzLCBzdHlsZXMgfSBvZiBydWxlc0xpc3QpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IG5ldyBSdWxlKHNlbGVjdG9yLCBzdHlsZSwgYHJcXDAke3BpZH1cXDAke3NlbGVjdG9yfVxcMCR7c3R5bGV9YCk7XG4gICAgICAgIGNvbXBvc2VTdHlsaXplKGl0ZW0sIHBpZCwgcnVsZXMsIHN0eWxlcywgY2xhc3NOYW1lLCBpc1N0eWxlKTtcbiAgICAgICAgY2FjaGUuYWRkKGl0ZW0pO1xuICAgIH1cbn1cbi8qKlxuICogQ2FjaGUgdG8gbGlzdCB0byBzdHlsZXMuXG4gKi9cbmZ1bmN0aW9uIGpvaW4oYXJyKSB7XG4gICAgbGV0IHJlcyA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspXG4gICAgICAgIHJlcyArPSBhcnJbaV07XG4gICAgcmV0dXJuIHJlcztcbn1cbi8qKlxuICogTm9vcCBjaGFuZ2VzLlxuICovXG5jb25zdCBub29wQ2hhbmdlcyA9IHtcbiAgICBhZGQ6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBjaGFuZ2U6ICgpID0+IHVuZGVmaW5lZCxcbiAgICByZW1vdmU6ICgpID0+IHVuZGVmaW5lZFxufTtcbi8qKlxuICogSW1wbGVtZW50IGEgY2FjaGUvZXZlbnQgZW1pdHRlci5cbiAqL1xuZXhwb3J0IGNsYXNzIENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFuZ2VzID0gbm9vcENoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5jaGFuZ2VzID0gY2hhbmdlcztcbiAgICAgICAgdGhpcy5zaGVldCA9IFtdO1xuICAgICAgICB0aGlzLmNoYW5nZUlkID0gMDtcbiAgICAgICAgdGhpcy5fa2V5cyA9IFtdO1xuICAgICAgICB0aGlzLl9jaGlsZHJlbiA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2NvdW50ZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgYWRkKHN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRlcnNbc3R5bGUuaWRdIHx8IDA7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9jaGlsZHJlbltzdHlsZS5pZF0gfHwgc3R5bGUuY2xvbmUoKTtcbiAgICAgICAgdGhpcy5fY291bnRlcnNbc3R5bGUuaWRdID0gY291bnQgKyAxO1xuICAgICAgICBpZiAoY291bnQgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2NoaWxkcmVuW2l0ZW0uaWRdID0gaXRlbTtcbiAgICAgICAgICAgIHRoaXMuX2tleXMucHVzaChpdGVtLmlkKTtcbiAgICAgICAgICAgIHRoaXMuc2hlZXQucHVzaChpdGVtLmdldFN0eWxlcygpKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlSWQrKztcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5hZGQoaXRlbSwgdGhpcy5fa2V5cy5sZW5ndGggLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgQ2FjaGUgJiYgc3R5bGUgaW5zdGFuY2VvZiBDYWNoZSkge1xuICAgICAgICAgICAgY29uc3QgY3VySW5kZXggPSB0aGlzLl9rZXlzLmluZGV4T2Yoc3R5bGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgcHJldkl0ZW1DaGFuZ2VJZCA9IGl0ZW0uY2hhbmdlSWQ7XG4gICAgICAgICAgICBpdGVtLm1lcmdlKHN0eWxlKTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNoYW5nZUlkICE9PSBwcmV2SXRlbUNoYW5nZUlkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGVldC5zcGxpY2UoY3VySW5kZXgsIDEsIGl0ZW0uZ2V0U3R5bGVzKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMuY2hhbmdlKGl0ZW0sIGN1ckluZGV4LCBjdXJJbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVtb3ZlKHN0eWxlKSB7XG4gICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5fY291bnRlcnNbc3R5bGUuaWRdO1xuICAgICAgICBpZiAoY291bnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvdW50ZXJzW3N0eWxlLmlkXSA9IGNvdW50IC0gMTtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLl9jaGlsZHJlbltzdHlsZS5pZF07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuX2tleXMuaW5kZXhPZihpdGVtLmlkKTtcbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb3VudGVyc1tzdHlsZS5pZF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NoaWxkcmVuW3N0eWxlLmlkXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGVldC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlSWQrKztcbiAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZXMucmVtb3ZlKGl0ZW0sIGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0gaW5zdGFuY2VvZiBDYWNoZSAmJiBzdHlsZSBpbnN0YW5jZW9mIENhY2hlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkNoYW5nZUlkID0gaXRlbS5jaGFuZ2VJZDtcbiAgICAgICAgICAgICAgICBpdGVtLnVubWVyZ2Uoc3R5bGUpO1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLmNoYW5nZUlkICE9PSBwcmV2Q2hhbmdlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaGVldC5zcGxpY2UoaW5kZXgsIDEsIGl0ZW0uZ2V0U3R5bGVzKCkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoYW5nZUlkKys7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlcy5jaGFuZ2UoaXRlbSwgaW5kZXgsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2V5cy5tYXAoa2V5ID0+IHRoaXMuX2NoaWxkcmVuW2tleV0pO1xuICAgIH1cbiAgICBtZXJnZShjYWNoZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY2FjaGUudmFsdWVzKCkpXG4gICAgICAgICAgICB0aGlzLmFkZChpdGVtKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHVubWVyZ2UoY2FjaGUpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGNhY2hlLnZhbHVlcygpKVxuICAgICAgICAgICAgdGhpcy5yZW1vdmUoaXRlbSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjbG9uZSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDYWNoZSgpLm1lcmdlKHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogU2VsZWN0b3IgaXMgYSBkdW1iIGNsYXNzIG1hZGUgdG8gcmVwcmVzZW50IG5lc3RlZCBDU1Mgc2VsZWN0b3JzLlxuICovXG5leHBvcnQgY2xhc3MgU2VsZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlbGVjdG9yLCBpZCkge1xuICAgICAgICB0aGlzLnNlbGVjdG9yID0gc2VsZWN0b3I7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICB9XG4gICAgZ2V0U3R5bGVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RvcjtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbi8qKlxuICogVGhlIHN0eWxlIGNvbnRhaW5lciByZWdpc3RlcnMgYSBzdHlsZSBzdHJpbmcgd2l0aCBzZWxlY3RvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBTdHlsZSBleHRlbmRzIENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihzdHlsZSwgaWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIGdldFN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuc2hlZXQuam9pbihcIixcIil9eyR7dGhpcy5zdHlsZX19YDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3R5bGUodGhpcy5zdHlsZSwgdGhpcy5pZCkubWVyZ2UodGhpcyk7XG4gICAgfVxufVxuLyoqXG4gKiBJbXBsZW1lbnQgcnVsZSBsb2dpYyBmb3Igc3R5bGUgb3V0cHV0LlxuICovXG5leHBvcnQgY2xhc3MgUnVsZSBleHRlbmRzIENhY2hlIHtcbiAgICBjb25zdHJ1Y3RvcihydWxlLCBzdHlsZSwgaWQpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICAgICAgdGhpcy5zdHlsZSA9IHN0eWxlO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIGdldFN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMucnVsZX17JHt0aGlzLnN0eWxlfSR7am9pbih0aGlzLnNoZWV0KX19YDtcbiAgICB9XG4gICAgY2xvbmUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgUnVsZSh0aGlzLnJ1bGUsIHRoaXMuc3R5bGUsIHRoaXMuaWQpLm1lcmdlKHRoaXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGtleShwaWQsIHN0eWxlcykge1xuICAgIGNvbnN0IGtleSA9IGBmJHtzdHJpbmdIYXNoKHBpZCl9YDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwicHJvZHVjdGlvblwiIHx8ICFzdHlsZXMuJGRpc3BsYXlOYW1lKVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgIHJldHVybiBgJHtzdHlsZXMuJGRpc3BsYXlOYW1lfV8ke2tleX1gO1xufVxuLyoqXG4gKiBUaGUgRnJlZVN0eWxlIGNsYXNzIGltcGxlbWVudHMgdGhlIEFQSSBmb3IgZXZlcnl0aGluZyBlbHNlLlxuICovXG5leHBvcnQgY2xhc3MgRnJlZVN0eWxlIGV4dGVuZHMgQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGlkLCBjaGFuZ2VzKSB7XG4gICAgICAgIHN1cGVyKGNoYW5nZXMpO1xuICAgICAgICB0aGlzLmlkID0gaWQ7XG4gICAgfVxuICAgIHJlZ2lzdGVyU3R5bGUoc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBzdHlsZXNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IHBpZCA9IHN0eWxpemUoXCImXCIsIHN0eWxlcywgcnVsZXNMaXN0LCBzdHlsZXNMaXN0KTtcbiAgICAgICAgY29uc3QgaWQgPSBrZXkocGlkLCBzdHlsZXMpO1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGAuJHtwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpZCA6IGVzY2FwZShpZCl9YDtcbiAgICAgICAgY29tcG9zZVN0eWxpemUodGhpcywgcGlkLCBydWxlc0xpc3QsIHN0eWxlc0xpc3QsIHNlbGVjdG9yLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICByZWdpc3RlcktleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJIYXNoUnVsZShcIkBrZXlmcmFtZXNcIiwga2V5ZnJhbWVzKTtcbiAgICB9XG4gICAgcmVnaXN0ZXJIYXNoUnVsZShwcmVmaXgsIHN0eWxlcykge1xuICAgICAgICBjb25zdCBydWxlc0xpc3QgPSBbXTtcbiAgICAgICAgY29uc3Qgc3R5bGVzTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBwaWQgPSBzdHlsaXplKFwiXCIsIHN0eWxlcywgcnVsZXNMaXN0LCBzdHlsZXNMaXN0KTtcbiAgICAgICAgY29uc3QgaWQgPSBrZXkocGlkLCBzdHlsZXMpO1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IGAke3ByZWZpeH0gJHtwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJwcm9kdWN0aW9uXCIgPyBpZCA6IGVzY2FwZShpZCl9YDtcbiAgICAgICAgY29uc3QgcnVsZSA9IG5ldyBSdWxlKHNlbGVjdG9yLCBcIlwiLCBgaFxcMCR7cGlkfVxcMCR7cHJlZml4fWApO1xuICAgICAgICBjb21wb3NlU3R5bGl6ZShydWxlLCBwaWQsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCwgXCJcIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLmFkZChydWxlKTtcbiAgICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICByZWdpc3RlclJ1bGUocnVsZSwgc3R5bGVzKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVzTGlzdCA9IFtdO1xuICAgICAgICBjb25zdCBzdHlsZXNMaXN0ID0gW107XG4gICAgICAgIGNvbnN0IHBpZCA9IHN0eWxpemUocnVsZSwgc3R5bGVzLCBydWxlc0xpc3QsIHN0eWxlc0xpc3QpO1xuICAgICAgICBjb21wb3NlU3R5bGl6ZSh0aGlzLCBwaWQsIHJ1bGVzTGlzdCwgc3R5bGVzTGlzdCwgXCJcIiwgZmFsc2UpO1xuICAgIH1cbiAgICByZWdpc3RlckNzcyhzdHlsZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJSdWxlKFwiXCIsIHN0eWxlcyk7XG4gICAgfVxuICAgIGdldFN0eWxlcygpIHtcbiAgICAgICAgcmV0dXJuIGpvaW4odGhpcy5zaGVldCk7XG4gICAgfVxuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IEZyZWVTdHlsZSh0aGlzLmlkLCB0aGlzLmNoYW5nZXMpLm1lcmdlKHRoaXMpO1xuICAgIH1cbn1cbi8qKlxuICogRXhwb3J0cyBhIHNpbXBsZSBmdW5jdGlvbiB0byBjcmVhdGUgYSBuZXcgaW5zdGFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGUoY2hhbmdlcykge1xuICAgIHJldHVybiBuZXcgRnJlZVN0eWxlKGBmJHsoKyt1bmlxdWVJZCkudG9TdHJpbmcoMzYpfWAsIGNoYW5nZXMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwidmFyIGJhc2VQaWNrQnkgPSByZXF1aXJlKCcuL19iYXNlUGlja0J5JyksXG4gICAgaGFzSW4gPSByZXF1aXJlKCcuL2hhc0luJyk7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gKiBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gYmFzZVBpY2sob2JqZWN0LCBwYXRocykge1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBoYXNJbihvYmplY3QsIHBhdGgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGljaztcbiIsInZhciBiYXNlR2V0ID0gcmVxdWlyZSgnLi9fYmFzZUdldCcpLFxuICAgIGJhc2VTZXQgPSByZXF1aXJlKCcuL19iYXNlU2V0JyksXG4gICAgY2FzdFBhdGggPSByZXF1aXJlKCcuL19jYXN0UGF0aCcpO1xuXG4vKipcbiAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGJhc2VQaWNrQnkob2JqZWN0LCBwYXRocywgcHJlZGljYXRlKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gcGF0aHMubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0ge307XG5cbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgcGF0aCA9IHBhdGhzW2luZGV4XSxcbiAgICAgICAgdmFsdWUgPSBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG5cbiAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgYmFzZVNldChyZXN1bHQsIGNhc3RQYXRoKHBhdGgsIG9iamVjdCksIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiYXNlUGlja0J5O1xuIiwidmFyIGJhc2VQaWNrID0gcmVxdWlyZSgnLi9fYmFzZVBpY2snKSxcbiAgICBmbGF0UmVzdCA9IHJlcXVpcmUoJy4vX2ZsYXRSZXN0Jyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBzaW5jZSAwLjEuMFxuICogQG1lbWJlck9mIF9cbiAqIEBjYXRlZ29yeSBPYmplY3RcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrKG9iamVjdCwgWydhJywgJ2MnXSk7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIHBpY2sgPSBmbGF0UmVzdChmdW5jdGlvbihvYmplY3QsIHBhdGhzKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHt9IDogYmFzZVBpY2sob2JqZWN0LCBwYXRocyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBwaWNrO1xuIiwidmFyIGJhc2VVbnNldCA9IHJlcXVpcmUoJy4vX2Jhc2VVbnNldCcpO1xuXG4vKipcbiAqIFJlbW92ZXMgdGhlIHByb3BlcnR5IGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAqXG4gKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgT2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIHVuc2V0LlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gKiBfLnVuc2V0KG9iamVjdCwgJ2FbMF0uYi5jJyk7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAqIC8vID0+IHsgJ2EnOiBbeyAnYic6IHt9IH1dIH07XG4gKlxuICogXy51bnNldChvYmplY3QsIFsnYScsICcwJywgJ2InLCAnYyddKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBjb25zb2xlLmxvZyhvYmplY3QpO1xuICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAqL1xuZnVuY3Rpb24gdW5zZXQob2JqZWN0LCBwYXRoKSB7XG4gIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHRydWUgOiBiYXNlVW5zZXQob2JqZWN0LCBwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB1bnNldDtcbiIsImltcG9ydCphcyBlIGZyb21cInJlYWN0XCI7ZnVuY3Rpb24gdCgpe3JldHVybiB0PU9iamVjdC5hc3NpZ24/T2JqZWN0LmFzc2lnbi5iaW5kKCk6ZnVuY3Rpb24oZSl7Zm9yKHZhciB0PTE7dDxhcmd1bWVudHMubGVuZ3RoO3QrKyl7dmFyIG49YXJndW1lbnRzW3RdO2Zvcih2YXIgciBpbiBuKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLHIpJiYoZVtyXT1uW3JdKX1yZXR1cm4gZX0sdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9Y29uc3Qgbj1bXCJjaGlsZHJlblwiLFwib3B0aW9uc1wiXSxyPXtibG9ja1F1b3RlOlwiMFwiLGJyZWFrTGluZTpcIjFcIixicmVha1RoZW1hdGljOlwiMlwiLGNvZGVCbG9jazpcIjNcIixjb2RlRmVuY2VkOlwiNFwiLGNvZGVJbmxpbmU6XCI1XCIsZm9vdG5vdGU6XCI2XCIsZm9vdG5vdGVSZWZlcmVuY2U6XCI3XCIsZ2ZtVGFzazpcIjhcIixoZWFkaW5nOlwiOVwiLGhlYWRpbmdTZXRleHQ6XCIxMFwiLGh0bWxCbG9jazpcIjExXCIsaHRtbENvbW1lbnQ6XCIxMlwiLGh0bWxTZWxmQ2xvc2luZzpcIjEzXCIsaW1hZ2U6XCIxNFwiLGxpbms6XCIxNVwiLGxpbmtBbmdsZUJyYWNlU3R5bGVEZXRlY3RvcjpcIjE2XCIsbGlua0JhcmVVcmxEZXRlY3RvcjpcIjE3XCIsbGlua01haWx0b0RldGVjdG9yOlwiMThcIixuZXdsaW5lQ29hbGVzY2VyOlwiMTlcIixvcmRlcmVkTGlzdDpcIjIwXCIscGFyYWdyYXBoOlwiMjFcIixyZWY6XCIyMlwiLHJlZkltYWdlOlwiMjNcIixyZWZMaW5rOlwiMjRcIix0YWJsZTpcIjI1XCIsdGFibGVTZXBhcmF0b3I6XCIyNlwiLHRleHQ6XCIyN1wiLHRleHRCb2xkZWQ6XCIyOFwiLHRleHRFbXBoYXNpemVkOlwiMjlcIix0ZXh0RXNjYXBlZDpcIjMwXCIsdGV4dE1hcmtlZDpcIjMxXCIsdGV4dFN0cmlrZXRocm91Z2hlZDpcIjMyXCIsdW5vcmRlcmVkTGlzdDpcIjMzXCJ9O3ZhciBpOyFmdW5jdGlvbihlKXtlW2UuTUFYPTBdPVwiTUFYXCIsZVtlLkhJR0g9MV09XCJISUdIXCIsZVtlLk1FRD0yXT1cIk1FRFwiLGVbZS5MT1c9M109XCJMT1dcIixlW2UuTUlOPTRdPVwiTUlOXCJ9KGl8fChpPXt9KSk7Y29uc3QgbD1bXCJhbGxvd0Z1bGxTY3JlZW5cIixcImFsbG93VHJhbnNwYXJlbmN5XCIsXCJhdXRvQ29tcGxldGVcIixcImF1dG9Gb2N1c1wiLFwiYXV0b1BsYXlcIixcImNlbGxQYWRkaW5nXCIsXCJjZWxsU3BhY2luZ1wiLFwiY2hhclNldFwiLFwiY2xhc3NOYW1lXCIsXCJjbGFzc0lkXCIsXCJjb2xTcGFuXCIsXCJjb250ZW50RWRpdGFibGVcIixcImNvbnRleHRNZW51XCIsXCJjcm9zc09yaWdpblwiLFwiZW5jVHlwZVwiLFwiZm9ybUFjdGlvblwiLFwiZm9ybUVuY1R5cGVcIixcImZvcm1NZXRob2RcIixcImZvcm1Ob1ZhbGlkYXRlXCIsXCJmb3JtVGFyZ2V0XCIsXCJmcmFtZUJvcmRlclwiLFwiaHJlZkxhbmdcIixcImlucHV0TW9kZVwiLFwia2V5UGFyYW1zXCIsXCJrZXlUeXBlXCIsXCJtYXJnaW5IZWlnaHRcIixcIm1hcmdpbldpZHRoXCIsXCJtYXhMZW5ndGhcIixcIm1lZGlhR3JvdXBcIixcIm1pbkxlbmd0aFwiLFwibm9WYWxpZGF0ZVwiLFwicmFkaW9Hcm91cFwiLFwicmVhZE9ubHlcIixcInJvd1NwYW5cIixcInNwZWxsQ2hlY2tcIixcInNyY0RvY1wiLFwic3JjTGFuZ1wiLFwic3JjU2V0XCIsXCJ0YWJJbmRleFwiLFwidXNlTWFwXCJdLnJlZHVjZSgoZSx0KT0+KGVbdC50b0xvd2VyQ2FzZSgpXT10LGUpLHtmb3I6XCJodG1sRm9yXCJ9KSxhPXthbXA6XCImXCIsYXBvczpcIidcIixndDpcIj5cIixsdDpcIjxcIixuYnNwOlwiwqBcIixxdW90Olwi4oCcXCJ9LG89W1wic3R5bGVcIixcInNjcmlwdFwiXSxjPS8oWy1BLVowLTlfOl0rKSg/Olxccyo9XFxzKig/Oig/OlwiKCg/OlxcXFwufFteXCJdKSopXCIpfCg/OicoKD86XFxcXC58W14nXSkqKScpfCg/OlxceygoPzpcXFxcLnx7W159XSo/fXxbXn1dKSopXFx9KSkpPy9naSxzPS9tYWlsdG86L2ksZD0vXFxuezIsfSQvLHU9L14oXFxzKj5bXFxzXFxTXSo/KSg/PVxcbnsyLH0pLyxwPS9eICo+ID8vZ20sZj0vXiB7Mix9XFxuLyxoPS9eKD86KCAqWy0qX10pKXszLH0gKig/OlxcbiAqKStcXG4vLG09L15cXHMqKGB7Myx9fH57Myx9KSAqKFxcUyspPyhbXlxcbl0qPyk/XFxuKFtcXHNcXFNdKz8pXFxzKlxcMSAqKD86XFxuICopKlxcbj8vLGc9L14oPzogezR9W15cXG5dK1xcbiopKyg/OlxcbiAqKStcXG4/Lyx5PS9eKGArKVxccyooW1xcc1xcU10qP1teYF0pXFxzKlxcMSg/IWApLyxrPS9eKD86XFxuICopKlxcbi8seD0vXFxyXFxuPy9nLGI9L15cXFtcXF4oW15cXF1dKyldKDooLiopKChcXG4rIHs0LH0uKil8KFxcbig/IVxcW1xcXikuKykpKikvLHY9L15cXFtcXF4oW15cXF1dKyldLyxTPS9cXGYvZyxFPS9eLS0tWyBcXHRdKlxcbigufFxcbikqXFxuLS0tWyBcXHRdKlxcbi8sJD0vXlxccyo/XFxbKHh8XFxzKVxcXS8sdz0vXiAqKCN7MSw2fSkgKihbXlxcbl0rPykoPzogKyMqKT8oPzpcXG4gKikqKD86XFxufCQpLyxDPS9eICooI3sxLDZ9KSArKFteXFxuXSs/KSg/OiArIyopPyg/OlxcbiAqKSooPzpcXG58JCkvLHo9L14oW15cXG5dKylcXG4gKig9fC0pezMsfSAqKD86XFxuICopK1xcbi8sTD0vXiAqKD8hPFthLXpdW14gPi9dKiA/XFwvPik8KFthLXpdW14gPi9dKikgPygoPzpbXj5dKlteL10pPyk+XFxuPyhcXHMqKD86PFxcMVtePl0qPz5bXFxzXFxTXSo/PFxcL1xcMT58KD8hPFxcMVxcYilbXFxzXFxTXSkqPyk8XFwvXFwxPig/ITxcXC9cXDE+KVxcbiovaSxBPS8mKFthLXowLTldK3wjWzAtOV17MSw2fXwjeFswLTlhLWZBLUZdezEsNn0pOy9naSxUPS9ePCEtLVtcXHNcXFNdKj8oPzotLT4pLyxPPS9eKGRhdGF8YXJpYXx4KS1bYS16X11bYS16XFxkXy4tXSokLyxCPS9eICo8KFthLXpdW2EtejAtOTpdKikoPzpcXHMrKCg/OjwuKj8+fFtePl0pKikpP1xcLz8+KD8hPFxcL1xcMT4pKFxccypcXG4pPy9pLE09L15cXHsuKlxcfSQvLFI9L14oaHR0cHM/OlxcL1xcL1teXFxzPF0rW148Liw6O1wiJylcXF1cXHNdKS8sST0vXjwoW14gPl0rQFteID5dKyk+LyxVPS9ePChbXiA+XSs6XFwvW14gPl0rKT4vLEQ9Ly0oW2Etel0pPy9naSxqPS9eKC4qXFx8LiopXFxuKD86ICooXFx8PyAqWy06XSsgKlxcfFstfCA6XSopXFxuKCg/Oi4qXFx8LipcXG4pKikpP1xcbj8vLE49L15cXFsoW15cXF1dKilcXF06XFxzKzw/KFteXFxzPl0rKT4/XFxzKihcIihbXlwiXSopXCIpPy8sSD0vXiFcXFsoW15cXF1dKilcXF0gP1xcWyhbXlxcXV0qKVxcXS8sRj0vXlxcWyhbXlxcXV0qKVxcXSA/XFxbKFteXFxdXSopXFxdLyxQPS8oXFxbfFxcXSkvZyxfPS8oXFxufF5bLSpdXFxzfF4jfF4gezIsfXxeLXsyLH18Xj5cXHMpLyxXPS9cXHQvZyxHPS8oXiAqXFx8fFxcfCAqJCkvZyxaPS9eICo6LSs6ICokLyxxPS9eICo6LSsgKiQvLFE9L14gKi0rOiAqJC8sVj1cIigoPzpcXFxcWy4qP1xcXFxdWyhbXS4qP1spXFxcXF1dfDwuKj8+KD86Lio/PC4qPz4pP3xgLio/YHx+fi4qP35+fD09Lio/PT18LnxcXFxcbikqPylcIixYPW5ldyBSZWdFeHAoYF4oWypfXSlcXFxcMSR7Vn1cXFxcMVxcXFwxKD8hXFxcXDEpYCksSj1uZXcgUmVnRXhwKGBeKFsqX10pJHtWfVxcXFwxKD8hXFxcXDF8XFxcXHcpYCksSz1uZXcgUmVnRXhwKGBePT0ke1Z9PT1gKSxZPW5ldyBSZWdFeHAoYF5+fiR7Vn1+fmApLGVlPS9eXFxcXChbXjAtOUEtWmEtelxcc10pLyx0ZT0vXltcXHNcXFNdKz8oPz1bXjAtOUEtWlxcc1xcdTAwYzAtXFx1ZmZmZiYjOy4oKSdcIl18XFxkK1xcLnxcXG5cXG58IHsyLH1cXG58XFx3KzpcXFN8JCkvaSxuZT0vXlxcbisvLHJlPS9eKFsgXFx0XSopLyxpZT0vXFxcXChbXlxcXFxdKS9nLGxlPS8gKlxcbiskLyxhZT0vKD86XnxcXG4pKCAqKSQvLG9lPVwiKD86XFxcXGQrXFxcXC4pXCIsY2U9XCIoPzpbKistXSlcIjtmdW5jdGlvbiBzZShlKXtyZXR1cm5cIiggKikoXCIrKDE9PT1lP29lOmNlKStcIikgK1wifWNvbnN0IGRlPXNlKDEpLHVlPXNlKDIpO2Z1bmN0aW9uIHBlKGUpe3JldHVybiBuZXcgUmVnRXhwKFwiXlwiKygxPT09ZT9kZTp1ZSkpfWNvbnN0IGZlPXBlKDEpLGhlPXBlKDIpO2Z1bmN0aW9uIG1lKGUpe3JldHVybiBuZXcgUmVnRXhwKFwiXlwiKygxPT09ZT9kZTp1ZSkrXCJbXlxcXFxuXSooPzpcXFxcbig/IVxcXFwxXCIrKDE9PT1lP29lOmNlKStcIiApW15cXFxcbl0qKSooXFxcXG58JClcIixcImdtXCIpfWNvbnN0IGdlPW1lKDEpLHllPW1lKDIpO2Z1bmN0aW9uIGtlKGUpe2NvbnN0IHQ9MT09PWU/b2U6Y2U7cmV0dXJuIG5ldyBSZWdFeHAoXCJeKCAqKShcIit0K1wiKSBbXFxcXHNcXFxcU10rPyg/OlxcXFxuezIsfSg/ISApKD8hXFxcXDFcIit0K1wiICg/IVwiK3QrXCIgKSlcXFxcbip8XFxcXHMqXFxcXG4qJClcIil9Y29uc3QgeGU9a2UoMSksYmU9a2UoMik7ZnVuY3Rpb24gdmUoZSx0KXtjb25zdCBuPTE9PT10LGk9bj94ZTpiZSxsPW4/Z2U6eWUsYT1uP2ZlOmhlO3JldHVybnttYXRjaChlLHQsbil7Y29uc3Qgcj1hZS5leGVjKG4pO3JldHVybiByJiYodC5saXN0fHwhdC5pbmxpbmUmJiF0LnNpbXBsZSk/aS5leGVjKGU9clsxXStlKTpudWxsfSxvcmRlcjoxLHBhcnNlKGUsdCxyKXtjb25zdCBpPW4/K2VbMl06dm9pZCAwLG89ZVswXS5yZXBsYWNlKGQsXCJcXG5cIikubWF0Y2gobCk7bGV0IGM9ITE7cmV0dXJue2l0ZW1zOm8ubWFwKGZ1bmN0aW9uKGUsbil7Y29uc3QgaT1hLmV4ZWMoZSlbMF0ubGVuZ3RoLGw9bmV3IFJlZ0V4cChcIl4gezEsXCIraStcIn1cIixcImdtXCIpLHM9ZS5yZXBsYWNlKGwsXCJcIikucmVwbGFjZShhLFwiXCIpLGQ9bj09PW8ubGVuZ3RoLTEsdT0tMSE9PXMuaW5kZXhPZihcIlxcblxcblwiKXx8ZCYmYztjPXU7Y29uc3QgcD1yLmlubGluZSxmPXIubGlzdDtsZXQgaDtyLmxpc3Q9ITAsdT8oci5pbmxpbmU9ITEsaD1zLnJlcGxhY2UobGUsXCJcXG5cXG5cIikpOihyLmlubGluZT0hMCxoPXMucmVwbGFjZShsZSxcIlwiKSk7Y29uc3QgbT10KGgscik7cmV0dXJuIHIuaW5saW5lPXAsci5saXN0PWYsbX0pLG9yZGVyZWQ6bixzdGFydDppfX0scmVuZGVyOih0LG4saSk9PmUodC5vcmRlcmVkP1wib2xcIjpcInVsXCIse2tleTppLmtleSxzdGFydDp0LnR5cGU9PT1yLm9yZGVyZWRMaXN0P3Quc3RhcnQ6dm9pZCAwfSx0Lml0ZW1zLm1hcChmdW5jdGlvbih0LHIpe3JldHVybiBlKFwibGlcIix7a2V5OnJ9LG4odCxpKSl9KSl9fWNvbnN0IFNlPW5ldyBSZWdFeHAoXCJeXFxcXFsoKD86XFxcXFtbXlxcXFxdXSpcXFxcXXxbXlxcXFxbXFxcXF1dfFxcXFxdKD89W15cXFxcW10qXFxcXF0pKSopXFxcXF1cXFxcKFxcXFxzKjw/KCg/OlxcXFwoW14pXSpcXFxcKXxbXlxcXFxzXFxcXFxcXFxdfFxcXFxcXFxcLikqPyk+Pyg/OlxcXFxzK1snXFxcIl0oW1xcXFxzXFxcXFNdKj8pWydcXFwiXSk/XFxcXHMqXFxcXClcIiksRWU9L14hXFxbKC4qPylcXF1cXCggKigoPzpcXChbXildKlxcKXxbXigpIF0pKikgKlwiPyhbXilcIl0qKT9cIj9cXCkvLCRlPVt1LG0sZyx3LHosQyxULGosZ2UseGUseWUsYmVdLHdlPVsuLi4kZSwvXlteXFxuXSsoPzogIFxcbnxcXG57Mix9KS8sTCxCXTtmdW5jdGlvbiBDZShlKXtyZXR1cm4gZS5yZXBsYWNlKC9bw4DDgcOCw4PDhMOFw6DDocOiw6PDpMOlw6bDhl0vZyxcImFcIikucmVwbGFjZSgvW8Onw4ddL2csXCJjXCIpLnJlcGxhY2UoL1vDsMOQXS9nLFwiZFwiKS5yZXBsYWNlKC9bw4jDicOKw4vDqcOow6rDq10vZyxcImVcIikucmVwbGFjZSgvW8OPw6/DjsOuw43DrcOMw6xdL2csXCJpXCIpLnJlcGxhY2UoL1vDkcOxXS9nLFwiblwiKS5yZXBsYWNlKC9bw7jDmMWTxZLDlcO1w5TDtMOTw7PDksOyXS9nLFwib1wiKS5yZXBsYWNlKC9bw5zDvMObw7vDmsO6w5nDuV0vZyxcInVcIikucmVwbGFjZSgvW8W4w7/DncO9XS9nLFwieVwiKS5yZXBsYWNlKC9bXmEtejAtOS0gXS9naSxcIlwiKS5yZXBsYWNlKC8gL2dpLFwiLVwiKS50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIHplKGUpe3JldHVybiBRLnRlc3QoZSk/XCJyaWdodFwiOloudGVzdChlKT9cImNlbnRlclwiOnEudGVzdChlKT9cImxlZnRcIjpudWxsfWZ1bmN0aW9uIExlKGUsdCxuLGkpe2NvbnN0IGw9bi5pblRhYmxlO24uaW5UYWJsZT0hMDtsZXQgYT1lLnRyaW0oKS5zcGxpdCgvKCAqKD86YFteYF0qYHw8Lio/Pi4qPzxcXC8uKj8+KD8hPFxcLy4qPz4pfFxcXFxcXHx8XFx8KSAqKS8pLnJlZHVjZSgoZSxsKT0+KFwifFwiPT09bC50cmltKCk/ZS5wdXNoKGk/e3R5cGU6ci50YWJsZVNlcGFyYXRvcn06e3R5cGU6ci50ZXh0LHRleHQ6bH0pOlwiXCIhPT1sJiZlLnB1c2guYXBwbHkoZSx0KGwsbikpLGUpLFtdKTtuLmluVGFibGU9bDtsZXQgbz1bW11dO3JldHVybiBhLmZvckVhY2goZnVuY3Rpb24oZSx0KXtlLnR5cGU9PT1yLnRhYmxlU2VwYXJhdG9yPzAhPT10JiZ0IT09YS5sZW5ndGgtMSYmby5wdXNoKFtdKTooZS50eXBlIT09ci50ZXh0fHxudWxsIT1hW3QrMV0mJmFbdCsxXS50eXBlIT09ci50YWJsZVNlcGFyYXRvcnx8KGUudGV4dD1lLnRleHQudHJpbUVuZCgpKSxvW28ubGVuZ3RoLTFdLnB1c2goZSkpfSksb31mdW5jdGlvbiBBZShlLHQsbil7bi5pbmxpbmU9ITA7Y29uc3QgaT1lWzJdP2VbMl0ucmVwbGFjZShHLFwiXCIpLnNwbGl0KFwifFwiKS5tYXAoemUpOltdLGw9ZVszXT9mdW5jdGlvbihlLHQsbil7cmV0dXJuIGUudHJpbSgpLnNwbGl0KFwiXFxuXCIpLm1hcChmdW5jdGlvbihlKXtyZXR1cm4gTGUoZSx0LG4sITApfSl9KGVbM10sdCxuKTpbXSxhPUxlKGVbMV0sdCxuLCEhbC5sZW5ndGgpO3JldHVybiBuLmlubGluZT0hMSxsLmxlbmd0aD97YWxpZ246aSxjZWxsczpsLGhlYWRlcjphLHR5cGU6ci50YWJsZX06e2NoaWxkcmVuOmEsdHlwZTpyLnBhcmFncmFwaH19ZnVuY3Rpb24gVGUoZSx0KXtyZXR1cm4gbnVsbD09ZS5hbGlnblt0XT97fTp7dGV4dEFsaWduOmUuYWxpZ25bdF19fWZ1bmN0aW9uIE9lKGUpe3JldHVybiBmdW5jdGlvbih0LG4pe3JldHVybiBuLmlubGluZT9lLmV4ZWModCk6bnVsbH19ZnVuY3Rpb24gQmUoZSl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4uaW5saW5lfHxuLnNpbXBsZT9lLmV4ZWModCk6bnVsbH19ZnVuY3Rpb24gTWUoZSl7cmV0dXJuIGZ1bmN0aW9uKHQsbil7cmV0dXJuIG4uaW5saW5lfHxuLnNpbXBsZT9udWxsOmUuZXhlYyh0KX19ZnVuY3Rpb24gUmUoZSl7cmV0dXJuIGZ1bmN0aW9uKHQpe3JldHVybiBlLmV4ZWModCl9fWZ1bmN0aW9uIEllKGUsdCxuKXtpZih0LmlubGluZXx8dC5zaW1wbGUpcmV0dXJuIG51bGw7aWYobiYmIW4uZW5kc1dpdGgoXCJcXG5cIikpcmV0dXJuIG51bGw7bGV0IHI9XCJcIjtlLnNwbGl0KFwiXFxuXCIpLmV2ZXJ5KGU9PiEkZS5zb21lKHQ9PnQudGVzdChlKSkmJihyKz1lK1wiXFxuXCIsZS50cmltKCkpKTtjb25zdCBpPXIudHJpbUVuZCgpO3JldHVyblwiXCI9PWk/bnVsbDpbcixpXX1mdW5jdGlvbiBVZShlKXt0cnl7aWYoZGVjb2RlVVJJQ29tcG9uZW50KGUpLnJlcGxhY2UoL1teQS1aYS16MC05LzpdL2csXCJcIikubWF0Y2goL15cXHMqKGphdmFzY3JpcHR8dmJzY3JpcHR8ZGF0YSg/ITppbWFnZSkpOi9pKSlyZXR1cm4gbnVsbH1jYXRjaChlKXtyZXR1cm4gbnVsbH1yZXR1cm4gZX1mdW5jdGlvbiBEZShlKXtyZXR1cm4gZS5yZXBsYWNlKGllLFwiJDFcIil9ZnVuY3Rpb24gamUoZSx0LG4pe2NvbnN0IHI9bi5pbmxpbmV8fCExLGk9bi5zaW1wbGV8fCExO24uaW5saW5lPSEwLG4uc2ltcGxlPSEwO2NvbnN0IGw9ZSh0LG4pO3JldHVybiBuLmlubGluZT1yLG4uc2ltcGxlPWksbH1mdW5jdGlvbiBOZShlLHQsbil7Y29uc3Qgcj1uLmlubGluZXx8ITEsaT1uLnNpbXBsZXx8ITE7bi5pbmxpbmU9ITEsbi5zaW1wbGU9ITA7Y29uc3QgbD1lKHQsbik7cmV0dXJuIG4uaW5saW5lPXIsbi5zaW1wbGU9aSxsfWZ1bmN0aW9uIEhlKGUsdCxuKXtjb25zdCByPW4uaW5saW5lfHwhMTtuLmlubGluZT0hMTtjb25zdCBpPWUodCxuKTtyZXR1cm4gbi5pbmxpbmU9cixpfWNvbnN0IEZlPShlLHQsbik9Pih7Y2hpbGRyZW46amUodCxlWzFdLG4pfSk7ZnVuY3Rpb24gUGUoKXtyZXR1cm57fX1mdW5jdGlvbiBfZSgpe3JldHVybiBudWxsfWZ1bmN0aW9uIFdlKC4uLmUpe3JldHVybiBlLmZpbHRlcihCb29sZWFuKS5qb2luKFwiIFwiKX1mdW5jdGlvbiBHZShlLHQsbil7bGV0IHI9ZTtjb25zdCBpPXQuc3BsaXQoXCIuXCIpO2Zvcig7aS5sZW5ndGgmJihyPXJbaVswXV0sdm9pZCAwIT09cik7KWkuc2hpZnQoKTtyZXR1cm4gcnx8bn1mdW5jdGlvbiBaZShuPVwiXCIsaT17fSl7ZnVuY3Rpb24gZChlLG4sLi4ucil7Y29uc3QgbD1HZShpLm92ZXJyaWRlcyxgJHtlfS5wcm9wc2Ase30pO3JldHVybiBpLmNyZWF0ZUVsZW1lbnQoZnVuY3Rpb24oZSx0KXtjb25zdCBuPUdlKHQsZSk7cmV0dXJuIG4/XCJmdW5jdGlvblwiPT10eXBlb2Ygbnx8XCJvYmplY3RcIj09dHlwZW9mIG4mJlwicmVuZGVyXCJpbiBuP246R2UodCxgJHtlfS5jb21wb25lbnRgLGUpOmV9KGUsaS5vdmVycmlkZXMpLHQoe30sbixsLHtjbGFzc05hbWU6V2UobnVsbD09bj92b2lkIDA6bi5jbGFzc05hbWUsbC5jbGFzc05hbWUpfHx2b2lkIDB9KSwuLi5yKX1mdW5jdGlvbiBHKHQpe3Q9dC5yZXBsYWNlKEUsXCJcIik7bGV0IG49ITE7aS5mb3JjZUlubGluZT9uPSEwOmkuZm9yY2VCbG9ja3x8KG49ITE9PT1fLnRlc3QodCkpO2NvbnN0IHI9bGUoaWUobj90OmAke3QudHJpbUVuZCgpLnJlcGxhY2UobmUsXCJcIil9XFxuXFxuYCx7aW5saW5lOm59KSk7Zm9yKDtcInN0cmluZ1wiPT10eXBlb2YgcltyLmxlbmd0aC0xXSYmIXJbci5sZW5ndGgtMV0udHJpbSgpOylyLnBvcCgpO2lmKG51bGw9PT1pLndyYXBwZXIpcmV0dXJuIHI7Y29uc3QgbD1pLndyYXBwZXJ8fChuP1wic3BhblwiOlwiZGl2XCIpO2xldCBhO2lmKHIubGVuZ3RoPjF8fGkuZm9yY2VXcmFwcGVyKWE9cjtlbHNle2lmKDE9PT1yLmxlbmd0aClyZXR1cm4gYT1yWzBdLFwic3RyaW5nXCI9PXR5cGVvZiBhP2QoXCJzcGFuXCIse2tleTpcIm91dGVyXCJ9LGEpOmE7YT1udWxsfXJldHVybiBlLmNyZWF0ZUVsZW1lbnQobCx7a2V5Olwib3V0ZXJcIn0sYSl9ZnVuY3Rpb24gWih0LG4pe2NvbnN0IHI9bi5tYXRjaChjKTtyZXR1cm4gcj9yLnJlZHVjZShmdW5jdGlvbihuLHIsYSl7Y29uc3Qgbz1yLmluZGV4T2YoXCI9XCIpO2lmKC0xIT09byl7Y29uc3QgYz1mdW5jdGlvbihlKXtyZXR1cm4tMSE9PWUuaW5kZXhPZihcIi1cIikmJm51bGw9PT1lLm1hdGNoKE8pJiYoZT1lLnJlcGxhY2UoRCxmdW5jdGlvbihlLHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9KSksZX0oci5zbGljZSgwLG8pKS50cmltKCkscz1mdW5jdGlvbihlKXtjb25zdCB0PWVbMF07cmV0dXJuKCdcIic9PT10fHxcIidcIj09PXQpJiZlLmxlbmd0aD49MiYmZVtlLmxlbmd0aC0xXT09PXQ/ZS5zbGljZSgxLC0xKTplfShyLnNsaWNlKG8rMSkudHJpbSgpKSxkPWxbY118fGMsdT1uW2RdPWZ1bmN0aW9uKGUsdCxuLHIpe3JldHVyblwic3R5bGVcIj09PXQ/bi5zcGxpdCgvO1xccz8vKS5yZWR1Y2UoZnVuY3Rpb24oZSx0KXtjb25zdCBuPXQuc2xpY2UoMCx0LmluZGV4T2YoXCI6XCIpKTtyZXR1cm4gZVtuLnRyaW0oKS5yZXBsYWNlKC8oLVthLXpdKS9nLGU9PmVbMV0udG9VcHBlckNhc2UoKSldPXQuc2xpY2Uobi5sZW5ndGgrMSkudHJpbSgpLGV9LHt9KTpcImhyZWZcIj09PXR8fFwic3JjXCI9PT10P3IobixlLHQpOihuLm1hdGNoKE0pJiYobj1uLnNsaWNlKDEsbi5sZW5ndGgtMSkpLFwidHJ1ZVwiPT09bnx8XCJmYWxzZVwiIT09biYmbil9KHQsYyxzLGkuc2FuaXRpemVyKTtcInN0cmluZ1wiPT10eXBlb2YgdSYmKEwudGVzdCh1KXx8Qi50ZXN0KHUpKSYmKG5bZF09ZS5jbG9uZUVsZW1lbnQoRyh1LnRyaW0oKSkse2tleTphfSkpfWVsc2VcInN0eWxlXCIhPT1yJiYobltsW3JdfHxyXT0hMCk7cmV0dXJuIG59LHt9KTpudWxsfWkub3ZlcnJpZGVzPWkub3ZlcnJpZGVzfHx7fSxpLnNhbml0aXplcj1pLnNhbml0aXplcnx8VWUsaS5zbHVnaWZ5PWkuc2x1Z2lmeXx8Q2UsaS5uYW1lZENvZGVzVG9Vbmljb2RlPWkubmFtZWRDb2Rlc1RvVW5pY29kZT90KHt9LGEsaS5uYW1lZENvZGVzVG9Vbmljb2RlKTphLGkuY3JlYXRlRWxlbWVudD1pLmNyZWF0ZUVsZW1lbnR8fGUuY3JlYXRlRWxlbWVudDtjb25zdCBxPVtdLFE9e30sVj17W3IuYmxvY2tRdW90ZV06e21hdGNoOk1lKHUpLG9yZGVyOjEscGFyc2U6KGUsdCxuKT0+KHtjaGlsZHJlbjp0KGVbMF0ucmVwbGFjZShwLFwiXCIpLG4pfSkscmVuZGVyOihlLHQsbik9PmQoXCJibG9ja3F1b3RlXCIse2tleTpuLmtleX0sdChlLmNoaWxkcmVuLG4pKX0sW3IuYnJlYWtMaW5lXTp7bWF0Y2g6UmUoZiksb3JkZXI6MSxwYXJzZTpQZSxyZW5kZXI6KGUsdCxuKT0+ZChcImJyXCIse2tleTpuLmtleX0pfSxbci5icmVha1RoZW1hdGljXTp7bWF0Y2g6TWUoaCksb3JkZXI6MSxwYXJzZTpQZSxyZW5kZXI6KGUsdCxuKT0+ZChcImhyXCIse2tleTpuLmtleX0pfSxbci5jb2RlQmxvY2tdOnttYXRjaDpNZShnKSxvcmRlcjowLHBhcnNlOmU9Pih7bGFuZzp2b2lkIDAsdGV4dDplWzBdLnJlcGxhY2UoL14gezR9L2dtLFwiXCIpLnJlcGxhY2UoL1xcbiskLyxcIlwiKX0pLHJlbmRlcjooZSxuLHIpPT5kKFwicHJlXCIse2tleTpyLmtleX0sZChcImNvZGVcIix0KHt9LGUuYXR0cnMse2NsYXNzTmFtZTplLmxhbmc/YGxhbmctJHtlLmxhbmd9YDpcIlwifSksZS50ZXh0KSl9LFtyLmNvZGVGZW5jZWRdOnttYXRjaDpNZShtKSxvcmRlcjowLHBhcnNlOmU9Pih7YXR0cnM6WihcImNvZGVcIixlWzNdfHxcIlwiKSxsYW5nOmVbMl18fHZvaWQgMCx0ZXh0OmVbNF0sdHlwZTpyLmNvZGVCbG9ja30pfSxbci5jb2RlSW5saW5lXTp7bWF0Y2g6QmUoeSksb3JkZXI6MyxwYXJzZTplPT4oe3RleHQ6ZVsyXX0pLHJlbmRlcjooZSx0LG4pPT5kKFwiY29kZVwiLHtrZXk6bi5rZXl9LGUudGV4dCl9LFtyLmZvb3Rub3RlXTp7bWF0Y2g6TWUoYiksb3JkZXI6MCxwYXJzZTplPT4ocS5wdXNoKHtmb290bm90ZTplWzJdLGlkZW50aWZpZXI6ZVsxXX0pLHt9KSxyZW5kZXI6X2V9LFtyLmZvb3Rub3RlUmVmZXJlbmNlXTp7bWF0Y2g6T2Uodiksb3JkZXI6MSxwYXJzZTplPT4oe3RhcmdldDpgIyR7aS5zbHVnaWZ5KGVbMV0sQ2UpfWAsdGV4dDplWzFdfSkscmVuZGVyOihlLHQsbik9PmQoXCJhXCIse2tleTpuLmtleSxocmVmOmkuc2FuaXRpemVyKGUudGFyZ2V0LFwiYVwiLFwiaHJlZlwiKX0sZChcInN1cFwiLHtrZXk6bi5rZXl9LGUudGV4dCkpfSxbci5nZm1UYXNrXTp7bWF0Y2g6T2UoJCksb3JkZXI6MSxwYXJzZTplPT4oe2NvbXBsZXRlZDpcInhcIj09PWVbMV0udG9Mb3dlckNhc2UoKX0pLHJlbmRlcjooZSx0LG4pPT5kKFwiaW5wdXRcIix7Y2hlY2tlZDplLmNvbXBsZXRlZCxrZXk6bi5rZXkscmVhZE9ubHk6ITAsdHlwZTpcImNoZWNrYm94XCJ9KX0sW3IuaGVhZGluZ106e21hdGNoOk1lKGkuZW5mb3JjZUF0eEhlYWRpbmdzP0M6dyksb3JkZXI6MSxwYXJzZTooZSx0LG4pPT4oe2NoaWxkcmVuOmplKHQsZVsyXSxuKSxpZDppLnNsdWdpZnkoZVsyXSxDZSksbGV2ZWw6ZVsxXS5sZW5ndGh9KSxyZW5kZXI6KGUsdCxuKT0+ZChgaCR7ZS5sZXZlbH1gLHtpZDplLmlkLGtleTpuLmtleX0sdChlLmNoaWxkcmVuLG4pKX0sW3IuaGVhZGluZ1NldGV4dF06e21hdGNoOk1lKHopLG9yZGVyOjAscGFyc2U6KGUsdCxuKT0+KHtjaGlsZHJlbjpqZSh0LGVbMV0sbiksbGV2ZWw6XCI9XCI9PT1lWzJdPzE6Mix0eXBlOnIuaGVhZGluZ30pfSxbci5odG1sQmxvY2tdOnttYXRjaDpSZShMKSxvcmRlcjoxLHBhcnNlKGUsdCxuKXtjb25zdFsscl09ZVszXS5tYXRjaChyZSksaT1uZXcgUmVnRXhwKGBeJHtyfWAsXCJnbVwiKSxsPWVbM10ucmVwbGFjZShpLFwiXCIpLGE9KGM9bCx3ZS5zb21lKGU9PmUudGVzdChjKSk/SGU6amUpO3ZhciBjO2NvbnN0IHM9ZVsxXS50b0xvd2VyQ2FzZSgpLGQ9LTEhPT1vLmluZGV4T2YocyksdT0oZD9zOmVbMV0pLnRyaW0oKSxwPXthdHRyczpaKHUsZVsyXSksbm9Jbm5lclBhcnNlOmQsdGFnOnV9O3JldHVybiBuLmluQW5jaG9yPW4uaW5BbmNob3J8fFwiYVwiPT09cyxkP3AudGV4dD1lWzNdOnAuY2hpbGRyZW49YSh0LGwsbiksbi5pbkFuY2hvcj0hMSxwfSxyZW5kZXI6KGUsbixyKT0+ZChlLnRhZyx0KHtrZXk6ci5rZXl9LGUuYXR0cnMpLGUudGV4dHx8bihlLmNoaWxkcmVuLHIpKX0sW3IuaHRtbFNlbGZDbG9zaW5nXTp7bWF0Y2g6UmUoQiksb3JkZXI6MSxwYXJzZShlKXtjb25zdCB0PWVbMV0udHJpbSgpO3JldHVybnthdHRyczpaKHQsZVsyXXx8XCJcIiksdGFnOnR9fSxyZW5kZXI6KGUsbixyKT0+ZChlLnRhZyx0KHt9LGUuYXR0cnMse2tleTpyLmtleX0pKX0sW3IuaHRtbENvbW1lbnRdOnttYXRjaDpSZShUKSxvcmRlcjoxLHBhcnNlOigpPT4oe30pLHJlbmRlcjpfZX0sW3IuaW1hZ2VdOnttYXRjaDpCZShFZSksb3JkZXI6MSxwYXJzZTplPT4oe2FsdDplWzFdLHRhcmdldDpEZShlWzJdKSx0aXRsZTplWzNdfSkscmVuZGVyOihlLHQsbik9PmQoXCJpbWdcIix7a2V5Om4ua2V5LGFsdDplLmFsdHx8dm9pZCAwLHRpdGxlOmUudGl0bGV8fHZvaWQgMCxzcmM6aS5zYW5pdGl6ZXIoZS50YXJnZXQsXCJpbWdcIixcInNyY1wiKX0pfSxbci5saW5rXTp7bWF0Y2g6T2UoU2UpLG9yZGVyOjMscGFyc2U6KGUsdCxuKT0+KHtjaGlsZHJlbjpOZSh0LGVbMV0sbiksdGFyZ2V0OkRlKGVbMl0pLHRpdGxlOmVbM119KSxyZW5kZXI6KGUsdCxuKT0+ZChcImFcIix7a2V5Om4ua2V5LGhyZWY6aS5zYW5pdGl6ZXIoZS50YXJnZXQsXCJhXCIsXCJocmVmXCIpLHRpdGxlOmUudGl0bGV9LHQoZS5jaGlsZHJlbixuKSl9LFtyLmxpbmtBbmdsZUJyYWNlU3R5bGVEZXRlY3Rvcl06e21hdGNoOk9lKFUpLG9yZGVyOjAscGFyc2U6ZT0+KHtjaGlsZHJlbjpbe3RleHQ6ZVsxXSx0eXBlOnIudGV4dH1dLHRhcmdldDplWzFdLHR5cGU6ci5saW5rfSl9LFtyLmxpbmtCYXJlVXJsRGV0ZWN0b3JdOnttYXRjaDooZSx0KT0+dC5pbkFuY2hvcj9udWxsOk9lKFIpKGUsdCksb3JkZXI6MCxwYXJzZTplPT4oe2NoaWxkcmVuOlt7dGV4dDplWzFdLHR5cGU6ci50ZXh0fV0sdGFyZ2V0OmVbMV0sdGl0bGU6dm9pZCAwLHR5cGU6ci5saW5rfSl9LFtyLmxpbmtNYWlsdG9EZXRlY3Rvcl06e21hdGNoOk9lKEkpLG9yZGVyOjAscGFyc2UoZSl7bGV0IHQ9ZVsxXSxuPWVbMV07cmV0dXJuIHMudGVzdChuKXx8KG49XCJtYWlsdG86XCIrbikse2NoaWxkcmVuOlt7dGV4dDp0LnJlcGxhY2UoXCJtYWlsdG86XCIsXCJcIiksdHlwZTpyLnRleHR9XSx0YXJnZXQ6bix0eXBlOnIubGlua319fSxbci5vcmRlcmVkTGlzdF06dmUoZCwxKSxbci51bm9yZGVyZWRMaXN0XTp2ZShkLDIpLFtyLm5ld2xpbmVDb2FsZXNjZXJdOnttYXRjaDpNZShrKSxvcmRlcjozLHBhcnNlOlBlLHJlbmRlcjooKT0+XCJcXG5cIn0sW3IucGFyYWdyYXBoXTp7bWF0Y2g6SWUsb3JkZXI6MyxwYXJzZTpGZSxyZW5kZXI6KGUsdCxuKT0+ZChcInBcIix7a2V5Om4ua2V5fSx0KGUuY2hpbGRyZW4sbikpfSxbci5yZWZdOnttYXRjaDpPZShOKSxvcmRlcjowLHBhcnNlOmU9PihRW2VbMV1dPXt0YXJnZXQ6ZVsyXSx0aXRsZTplWzRdfSx7fSkscmVuZGVyOl9lfSxbci5yZWZJbWFnZV06e21hdGNoOkJlKEgpLG9yZGVyOjAscGFyc2U6ZT0+KHthbHQ6ZVsxXXx8dm9pZCAwLHJlZjplWzJdfSkscmVuZGVyOihlLHQsbik9PlFbZS5yZWZdP2QoXCJpbWdcIix7a2V5Om4ua2V5LGFsdDplLmFsdCxzcmM6aS5zYW5pdGl6ZXIoUVtlLnJlZl0udGFyZ2V0LFwiaW1nXCIsXCJzcmNcIiksdGl0bGU6UVtlLnJlZl0udGl0bGV9KTpudWxsfSxbci5yZWZMaW5rXTp7bWF0Y2g6T2UoRiksb3JkZXI6MCxwYXJzZTooZSx0LG4pPT4oe2NoaWxkcmVuOnQoZVsxXSxuKSxmYWxsYmFja0NoaWxkcmVuOnQoZVswXS5yZXBsYWNlKFAsXCJcXFxcJDFcIiksbikscmVmOmVbMl19KSxyZW5kZXI6KGUsdCxuKT0+UVtlLnJlZl0/ZChcImFcIix7a2V5Om4ua2V5LGhyZWY6aS5zYW5pdGl6ZXIoUVtlLnJlZl0udGFyZ2V0LFwiYVwiLFwiaHJlZlwiKSx0aXRsZTpRW2UucmVmXS50aXRsZX0sdChlLmNoaWxkcmVuLG4pKTpkKFwic3BhblwiLHtrZXk6bi5rZXl9LHQoZS5mYWxsYmFja0NoaWxkcmVuLG4pKX0sW3IudGFibGVdOnttYXRjaDpNZShqKSxvcmRlcjoxLHBhcnNlOkFlLHJlbmRlcihlLHQsbil7Y29uc3Qgcj1lO3JldHVybiBkKFwidGFibGVcIix7a2V5Om4ua2V5fSxkKFwidGhlYWRcIixudWxsLGQoXCJ0clwiLG51bGwsci5oZWFkZXIubWFwKGZ1bmN0aW9uKGUsaSl7cmV0dXJuIGQoXCJ0aFwiLHtrZXk6aSxzdHlsZTpUZShyLGkpfSx0KGUsbikpfSkpKSxkKFwidGJvZHlcIixudWxsLHIuY2VsbHMubWFwKGZ1bmN0aW9uKGUsaSl7cmV0dXJuIGQoXCJ0clwiLHtrZXk6aX0sZS5tYXAoZnVuY3Rpb24oZSxpKXtyZXR1cm4gZChcInRkXCIse2tleTppLHN0eWxlOlRlKHIsaSl9LHQoZSxuKSl9KSl9KSkpfX0sW3IudGV4dF06e21hdGNoOlJlKHRlKSxvcmRlcjo0LHBhcnNlOmU9Pih7dGV4dDplWzBdLnJlcGxhY2UoQSwoZSx0KT0+aS5uYW1lZENvZGVzVG9Vbmljb2RlW3RdP2kubmFtZWRDb2Rlc1RvVW5pY29kZVt0XTplKX0pLHJlbmRlcjplPT5lLnRleHR9LFtyLnRleHRCb2xkZWRdOnttYXRjaDpCZShYKSxvcmRlcjoyLHBhcnNlOihlLHQsbik9Pih7Y2hpbGRyZW46dChlWzJdLG4pfSkscmVuZGVyOihlLHQsbik9PmQoXCJzdHJvbmdcIix7a2V5Om4ua2V5fSx0KGUuY2hpbGRyZW4sbikpfSxbci50ZXh0RW1waGFzaXplZF06e21hdGNoOkJlKEopLG9yZGVyOjMscGFyc2U6KGUsdCxuKT0+KHtjaGlsZHJlbjp0KGVbMl0sbil9KSxyZW5kZXI6KGUsdCxuKT0+ZChcImVtXCIse2tleTpuLmtleX0sdChlLmNoaWxkcmVuLG4pKX0sW3IudGV4dEVzY2FwZWRdOnttYXRjaDpCZShlZSksb3JkZXI6MSxwYXJzZTplPT4oe3RleHQ6ZVsxXSx0eXBlOnIudGV4dH0pfSxbci50ZXh0TWFya2VkXTp7bWF0Y2g6QmUoSyksb3JkZXI6MyxwYXJzZTpGZSxyZW5kZXI6KGUsdCxuKT0+ZChcIm1hcmtcIix7a2V5Om4ua2V5fSx0KGUuY2hpbGRyZW4sbikpfSxbci50ZXh0U3RyaWtldGhyb3VnaGVkXTp7bWF0Y2g6QmUoWSksb3JkZXI6MyxwYXJzZTpGZSxyZW5kZXI6KGUsdCxuKT0+ZChcImRlbFwiLHtrZXk6bi5rZXl9LHQoZS5jaGlsZHJlbixuKSl9fTshMD09PWkuZGlzYWJsZVBhcnNpbmdSYXdIVE1MJiYoZGVsZXRlIFZbci5odG1sQmxvY2tdLGRlbGV0ZSBWW3IuaHRtbFNlbGZDbG9zaW5nXSk7Y29uc3QgaWU9ZnVuY3Rpb24oZSl7bGV0IHQ9T2JqZWN0LmtleXMoZSk7ZnVuY3Rpb24gbihyLGkpe2xldCBsPVtdLGE9XCJcIjtmb3IoO3I7KXtsZXQgbz0wO2Zvcig7bzx0Lmxlbmd0aDspe2NvbnN0IGM9dFtvXSxzPWVbY10sZD1zLm1hdGNoKHIsaSxhKTtpZihkKXtjb25zdCBlPWRbMF07cj1yLnN1YnN0cmluZyhlLmxlbmd0aCk7Y29uc3QgdD1zLnBhcnNlKGQsbixpKTtudWxsPT10LnR5cGUmJih0LnR5cGU9YyksbC5wdXNoKHQpLGE9ZTticmVha31vKyt9fXJldHVybiBsfXJldHVybiB0LnNvcnQoZnVuY3Rpb24odCxuKXtsZXQgcj1lW3RdLm9yZGVyLGk9ZVtuXS5vcmRlcjtyZXR1cm4gciE9PWk/ci1pOnQ8bj8tMToxfSksZnVuY3Rpb24oZSx0KXtyZXR1cm4gbihmdW5jdGlvbihlKXtyZXR1cm4gZS5yZXBsYWNlKHgsXCJcXG5cIikucmVwbGFjZShTLFwiXCIpLnJlcGxhY2UoVyxcIiAgICBcIil9KGUpLHQpfX0oViksbGU9KGFlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGZ1bmN0aW9uKG4scixpKXtjb25zdCBsPWVbbi50eXBlXS5yZW5kZXI7cmV0dXJuIHQ/dCgoKT0+bChuLHIsaSksbixyLGkpOmwobixyLGkpfX0oVixpLnJlbmRlclJ1bGUpLGZ1bmN0aW9uIGUodCxuPXt9KXtpZihBcnJheS5pc0FycmF5KHQpKXtjb25zdCByPW4ua2V5LGk9W107bGV0IGw9ITE7Zm9yKGxldCByPTA7cjx0Lmxlbmd0aDtyKyspe24ua2V5PXI7Y29uc3QgYT1lKHRbcl0sbiksbz1cInN0cmluZ1wiPT10eXBlb2YgYTtvJiZsP2lbaS5sZW5ndGgtMV0rPWE6bnVsbCE9PWEmJmkucHVzaChhKSxsPW99cmV0dXJuIG4ua2V5PXIsaX1yZXR1cm4gYWUodCxlLG4pfSk7dmFyIGFlO2NvbnN0IG9lPUcobik7cmV0dXJuIHEubGVuZ3RoP2QoXCJkaXZcIixudWxsLG9lLGQoXCJmb290ZXJcIix7a2V5OlwiZm9vdGVyXCJ9LHEubWFwKGZ1bmN0aW9uKGUpe3JldHVybiBkKFwiZGl2XCIse2lkOmkuc2x1Z2lmeShlLmlkZW50aWZpZXIsQ2UpLGtleTplLmlkZW50aWZpZXJ9LGUuaWRlbnRpZmllcixsZShpZShlLmZvb3Rub3RlLHtpbmxpbmU6ITB9KSkpfSkpKTpvZX1leHBvcnQgZGVmYXVsdCB0PT57bGV0e2NoaWxkcmVuOnI9XCJcIixvcHRpb25zOml9PXQsbD1mdW5jdGlvbihlLHQpe2lmKG51bGw9PWUpcmV0dXJue307dmFyIG4scixpPXt9LGw9T2JqZWN0LmtleXMoZSk7Zm9yKHI9MDtyPGwubGVuZ3RoO3IrKyl0LmluZGV4T2Yobj1sW3JdKT49MHx8KGlbbl09ZVtuXSk7cmV0dXJuIGl9KHQsbik7cmV0dXJuIGUuY2xvbmVFbGVtZW50KFplKHIsaSksbCl9O2V4cG9ydHtyIGFzIFJ1bGVUeXBlLFplIGFzIGNvbXBpbGVyLFVlIGFzIHNhbml0aXplcixDZSBhcyBzbHVnaWZ5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1vZGVybi5qcy5tYXBcbiIsIi8vIFRoaXMgZmlsZSByZXBsYWNlcyBgaW5kZXguanNgIGluIGJ1bmRsZXJzIGxpa2Ugd2VicGFjayBvciBSb2xsdXAsXG4vLyBhY2NvcmRpbmcgdG8gYGJyb3dzZXJgIGNvbmZpZyBpbiBgcGFja2FnZS5qc29uYC5cblxuaW1wb3J0IHsgdXJsQWxwaGFiZXQgfSBmcm9tICcuL3VybC1hbHBoYWJldC9pbmRleC5qcydcblxubGV0IHJhbmRvbSA9IGJ5dGVzID0+IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoYnl0ZXMpKVxuXG5sZXQgY3VzdG9tUmFuZG9tID0gKGFscGhhYmV0LCBkZWZhdWx0U2l6ZSwgZ2V0UmFuZG9tKSA9PiB7XG4gIC8vIEZpcnN0LCBhIGJpdG1hc2sgaXMgbmVjZXNzYXJ5IHRvIGdlbmVyYXRlIHRoZSBJRC4gVGhlIGJpdG1hc2sgbWFrZXMgYnl0ZXNcbiAgLy8gdmFsdWVzIGNsb3NlciB0byB0aGUgYWxwaGFiZXQgc2l6ZS4gVGhlIGJpdG1hc2sgY2FsY3VsYXRlcyB0aGUgY2xvc2VzdFxuICAvLyBgMl4zMSAtIDFgIG51bWJlciwgd2hpY2ggZXhjZWVkcyB0aGUgYWxwaGFiZXQgc2l6ZS5cbiAgLy8gRm9yIGV4YW1wbGUsIHRoZSBiaXRtYXNrIGZvciB0aGUgYWxwaGFiZXQgc2l6ZSAzMCBpcyAzMSAoMDAwMTExMTEpLlxuICAvLyBgTWF0aC5jbHozMmAgaXMgbm90IHVzZWQsIGJlY2F1c2UgaXQgaXMgbm90IGF2YWlsYWJsZSBpbiBicm93c2Vycy5cbiAgbGV0IG1hc2sgPSAoMiA8PCAoTWF0aC5sb2coYWxwaGFiZXQubGVuZ3RoIC0gMSkgLyBNYXRoLkxOMikpIC0gMVxuICAvLyBUaG91Z2gsIHRoZSBiaXRtYXNrIHNvbHV0aW9uIGlzIG5vdCBwZXJmZWN0IHNpbmNlIHRoZSBieXRlcyBleGNlZWRpbmdcbiAgLy8gdGhlIGFscGhhYmV0IHNpemUgYXJlIHJlZnVzZWQuIFRoZXJlZm9yZSwgdG8gcmVsaWFibHkgZ2VuZXJhdGUgdGhlIElELFxuICAvLyB0aGUgcmFuZG9tIGJ5dGVzIHJlZHVuZGFuY3kgaGFzIHRvIGJlIHNhdGlzZmllZC5cblxuICAvLyBOb3RlOiBldmVyeSBoYXJkd2FyZSByYW5kb20gZ2VuZXJhdG9yIGNhbGwgaXMgcGVyZm9ybWFuY2UgZXhwZW5zaXZlLFxuICAvLyBiZWNhdXNlIHRoZSBzeXN0ZW0gY2FsbCBmb3IgZW50cm9weSBjb2xsZWN0aW9uIHRha2VzIGEgbG90IG9mIHRpbWUuXG4gIC8vIFNvLCB0byBhdm9pZCBhZGRpdGlvbmFsIHN5c3RlbSBjYWxscywgZXh0cmEgYnl0ZXMgYXJlIHJlcXVlc3RlZCBpbiBhZHZhbmNlLlxuXG4gIC8vIE5leHQsIGEgc3RlcCBkZXRlcm1pbmVzIGhvdyBtYW55IHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cbiAgLy8gVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgZ2V0cyBkZWNpZGVkIHVwb24gdGhlIElEIHNpemUsIG1hc2ssXG4gIC8vIGFscGhhYmV0IHNpemUsIGFuZCBtYWdpYyBudW1iZXIgMS42ICh1c2luZyAxLjYgcGVha3MgYXQgcGVyZm9ybWFuY2VcbiAgLy8gYWNjb3JkaW5nIHRvIGJlbmNobWFya3MpLlxuXG4gIC8vIGAtfmYgPT4gTWF0aC5jZWlsKGYpYCBpZiBmIGlzIGEgZmxvYXRcbiAgLy8gYC1+aSA9PiBpICsgMWAgaWYgaSBpcyBhbiBpbnRlZ2VyXG4gIGxldCBzdGVwID0gLX4oKDEuNiAqIG1hc2sgKiBkZWZhdWx0U2l6ZSkgLyBhbHBoYWJldC5sZW5ndGgpXG5cbiAgcmV0dXJuIChzaXplID0gZGVmYXVsdFNpemUpID0+IHtcbiAgICBsZXQgaWQgPSAnJ1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBsZXQgYnl0ZXMgPSBnZXRSYW5kb20oc3RlcClcbiAgICAgIC8vIEEgY29tcGFjdCBhbHRlcm5hdGl2ZSBmb3IgYGZvciAodmFyIGkgPSAwOyBpIDwgc3RlcDsgaSsrKWAuXG4gICAgICBsZXQgaiA9IHN0ZXAgfCAwXG4gICAgICB3aGlsZSAoai0tKSB7XG4gICAgICAgIC8vIEFkZGluZyBgfHwgJydgIHJlZnVzZXMgYSByYW5kb20gYnl0ZSB0aGF0IGV4Y2VlZHMgdGhlIGFscGhhYmV0IHNpemUuXG4gICAgICAgIGlkICs9IGFscGhhYmV0W2J5dGVzW2pdICYgbWFza10gfHwgJydcbiAgICAgICAgaWYgKGlkLmxlbmd0aCA9PT0gc2l6ZSkgcmV0dXJuIGlkXG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmxldCBjdXN0b21BbHBoYWJldCA9IChhbHBoYWJldCwgc2l6ZSA9IDIxKSA9PlxuICBjdXN0b21SYW5kb20oYWxwaGFiZXQsIHNpemUsIHJhbmRvbSlcblxubGV0IG5hbm9pZCA9IChzaXplID0gMjEpID0+XG4gIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQ4QXJyYXkoc2l6ZSkpLnJlZHVjZSgoaWQsIGJ5dGUpID0+IHtcbiAgICAvLyBJdCBpcyBpbmNvcnJlY3QgdG8gdXNlIGJ5dGVzIGV4Y2VlZGluZyB0aGUgYWxwaGFiZXQgc2l6ZS5cbiAgICAvLyBUaGUgZm9sbG93aW5nIG1hc2sgcmVkdWNlcyB0aGUgcmFuZG9tIGJ5dGUgaW4gdGhlIDAtMjU1IHZhbHVlXG4gICAgLy8gcmFuZ2UgdG8gdGhlIDAtNjMgdmFsdWUgcmFuZ2UuIFRoZXJlZm9yZSwgYWRkaW5nIGhhY2tzLCBzdWNoXG4gICAgLy8gYXMgZW1wdHkgc3RyaW5nIGZhbGxiYWNrIG9yIG1hZ2ljIG51bWJlcnMsIGlzIHVubmVjY2Vzc2FyeSBiZWNhdXNlXG4gICAgLy8gdGhlIGJpdG1hc2sgdHJpbXMgYnl0ZXMgZG93biB0byB0aGUgYWxwaGFiZXQgc2l6ZS5cbiAgICBieXRlICY9IDYzXG4gICAgaWYgKGJ5dGUgPCAzNikge1xuICAgICAgLy8gYDAtOWEtemBcbiAgICAgIGlkICs9IGJ5dGUudG9TdHJpbmcoMzYpXG4gICAgfSBlbHNlIGlmIChieXRlIDwgNjIpIHtcbiAgICAgIC8vIGBBLVpgXG4gICAgICBpZCArPSAoYnl0ZSAtIDI2KS50b1N0cmluZygzNikudG9VcHBlckNhc2UoKVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA+IDYyKSB7XG4gICAgICBpZCArPSAnLSdcbiAgICB9IGVsc2Uge1xuICAgICAgaWQgKz0gJ18nXG4gICAgfVxuICAgIHJldHVybiBpZFxuICB9LCAnJylcblxuZXhwb3J0IHsgbmFub2lkLCBjdXN0b21BbHBoYWJldCwgY3VzdG9tUmFuZG9tLCB1cmxBbHBoYWJldCwgcmFuZG9tIH1cbiIsIi8vIFRoaXMgYWxwaGFiZXQgdXNlcyBgQS1aYS16MC05Xy1gIHN5bWJvbHMuXG4vLyBUaGUgb3JkZXIgb2YgY2hhcmFjdGVycyBpcyBvcHRpbWl6ZWQgZm9yIGJldHRlciBnemlwIGFuZCBicm90bGkgY29tcHJlc3Npb24uXG4vLyBTYW1lIGFzIGluIG5vbi1zZWN1cmUvaW5kZXguanNcbmxldCB1cmxBbHBoYWJldCA9XG4gICd1c2VhbmRvbS0yNlQxOTgzNDBQWDc1cHhKQUNLVkVSWU1JTkRCVVNIV09MRl9HUVpiZmdoamtscXZ3eXpyaWN0J1xuXG5leHBvcnQgeyB1cmxBbHBoYWJldCB9XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBtID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBtLmNyZWF0ZVJvb3Q7XG4gIGV4cG9ydHMuaHlkcmF0ZVJvb3QgPSBtLmh5ZHJhdGVSb290O1xufSBlbHNlIHtcbiAgdmFyIGkgPSBtLl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuICBleHBvcnRzLmNyZWF0ZVJvb3QgPSBmdW5jdGlvbihjLCBvKSB7XG4gICAgaS51c2luZ0NsaWVudEVudHJ5UG9pbnQgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbS5jcmVhdGVSb290KGMsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbiAgZXhwb3J0cy5oeWRyYXRlUm9vdCA9IGZ1bmN0aW9uKGMsIGgsIG8pIHtcbiAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IHRydWU7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBtLmh5ZHJhdGVSb290KGMsIGgsIG8pO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpLnVzaW5nQ2xpZW50RW50cnlQb2ludCA9IGZhbHNlO1xuICAgIH1cbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHR5cGVzdHlsZV8xID0gcmVxdWlyZShcIi4vaW50ZXJuYWwvdHlwZXN0eWxlXCIpO1xuZXhwb3J0cy5UeXBlU3R5bGUgPSB0eXBlc3R5bGVfMS5UeXBlU3R5bGU7XG4vKipcbiAqIEFsbCB0aGUgQ1NTIHR5cGVzIGluIHRoZSAndHlwZXMnIG5hbWVzcGFjZVxuICovXG52YXIgdHlwZXMgPSByZXF1aXJlKFwiLi90eXBlc1wiKTtcbmV4cG9ydHMudHlwZXMgPSB0eXBlcztcbi8qKlxuICogRXhwb3J0IGNlcnRhaW4gdXRpbGl0aWVzXG4gKi9cbnZhciB1dGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuL2ludGVybmFsL3V0aWxpdGllc1wiKTtcbmV4cG9ydHMuZXh0ZW5kID0gdXRpbGl0aWVzXzEuZXh0ZW5kO1xuZXhwb3J0cy5jbGFzc2VzID0gdXRpbGl0aWVzXzEuY2xhc3NlcztcbmV4cG9ydHMubWVkaWEgPSB1dGlsaXRpZXNfMS5tZWRpYTtcbi8qKiBaZXJvIGNvbmZpZ3VyYXRpb24sIGRlZmF1bHQgaW5zdGFuY2Ugb2YgVHlwZVN0eWxlICovXG52YXIgdHMgPSBuZXcgdHlwZXN0eWxlXzEuVHlwZVN0eWxlKHsgYXV0b0dlbmVyYXRlVGFnOiB0cnVlIH0pO1xuLyoqIFNldHMgdGhlIHRhcmdldCB0YWcgd2hlcmUgd2Ugd3JpdGUgdGhlIGNzcyBvbiBzdHlsZSB1cGRhdGVzICovXG5leHBvcnRzLnNldFN0eWxlc1RhcmdldCA9IHRzLnNldFN0eWxlc1RhcmdldDtcbi8qKlxuICogSW5zZXJ0IGByYXdgIENTUyBhcyBhIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgZm9yIGUuZy5cbiAqIC0gdGhpcmQgcGFydHkgQ1NTIHRoYXQgeW91IGFyZSBjdXN0b21pemluZyB3aXRoIHRlbXBsYXRlIHN0cmluZ3NcbiAqIC0gZ2VuZXJhdGluZyByYXcgQ1NTIGluIEphdmFTY3JpcHRcbiAqIC0gcmVzZXQgbGlicmFyaWVzIGxpa2Ugbm9ybWFsaXplLmNzcyB0aGF0IHlvdSBjYW4gdXNlIHdpdGhvdXQgbG9hZGVyc1xuICovXG5leHBvcnRzLmNzc1JhdyA9IHRzLmNzc1Jhdztcbi8qKlxuICogVGFrZXMgQ1NTUHJvcGVydGllcyBhbmQgcmVnaXN0ZXJzIGl0IHRvIGEgZ2xvYmFsIHNlbGVjdG9yIChib2R5LCBodG1sLCBldGMuKVxuICovXG5leHBvcnRzLmNzc1J1bGUgPSB0cy5jc3NSdWxlO1xuLyoqXG4gKiBSZW5kZXJzIHN0eWxlcyB0byB0aGUgc2luZ2xldG9uIHRhZyBpbWVkaWF0ZWx5XG4gKiBOT1RFOiBZb3Ugc2hvdWxkIG9ubHkgY2FsbCBpdCBvbiBpbml0aWFsIHJlbmRlciB0byBwcmV2ZW50IGFueSBub24gQ1NTIGZsYXNoLlxuICogQWZ0ZXIgdGhhdCBpdCBpcyBrZXB0IHN5bmMgdXNpbmcgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgYW5kIHdlIGhhdmVuJ3Qgbm90aWNlZCBhbnkgYmFkIGZsYXNoZXMuXG4gKiovXG5leHBvcnRzLmZvcmNlUmVuZGVyU3R5bGVzID0gdHMuZm9yY2VSZW5kZXJTdHlsZXM7XG4vKipcbiAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYW4gQGZvbnQtZmFjZVxuICovXG5leHBvcnRzLmZvbnRGYWNlID0gdHMuZm9udEZhY2U7XG4vKipcbiAqIEFsbG93cyB1c2UgdG8gdXNlIHRoZSBzdHlsZXNoZWV0IGluIGEgbm9kZS5qcyBlbnZpcm9ubWVudFxuICovXG5leHBvcnRzLmdldFN0eWxlcyA9IHRzLmdldFN0eWxlcztcbi8qKlxuICogVGFrZXMga2V5ZnJhbWVzIGFuZCByZXR1cm5zIGEgZ2VuZXJhdGVkIGFuaW1hdGlvbk5hbWVcbiAqL1xuZXhwb3J0cy5rZXlmcmFtZXMgPSB0cy5rZXlmcmFtZXM7XG4vKipcbiAqIEhlbHBzIHdpdGggdGVzdGluZy4gUmVpbml0aWFsaXplcyBGcmVlU3R5bGUgKyByYXdcbiAqL1xuZXhwb3J0cy5yZWluaXQgPSB0cy5yZWluaXQ7XG4vKipcbiAqIFRha2VzIENTU1Byb3BlcnRpZXMgYW5kIHJldHVybiBhIGdlbmVyYXRlZCBjbGFzc05hbWUgeW91IGNhbiB1c2Ugb24geW91ciBjb21wb25lbnRcbiAqL1xuZXhwb3J0cy5zdHlsZSA9IHRzLnN0eWxlO1xuLyoqXG4gKiBUYWtlcyBhbiBvYmplY3Qgd2hlcmUgcHJvcGVydHkgbmFtZXMgYXJlIGlkZWFsIGNsYXNzIG5hbWVzIGFuZCBwcm9wZXJ0eSB2YWx1ZXMgYXJlIENTU1Byb3BlcnRpZXMsIGFuZFxuICogcmV0dXJucyBhbiBvYmplY3Qgd2hlcmUgcHJvcGVydHkgbmFtZXMgYXJlIHRoZSBzYW1lIGlkZWFsIGNsYXNzIG5hbWVzIGFuZCB0aGUgcHJvcGVydHkgdmFsdWVzIGFyZVxuICogdGhlIGFjdHVhbCBnZW5lcmF0ZWQgY2xhc3MgbmFtZXMgdXNpbmcgdGhlIGlkZWFsIGNsYXNzIG5hbWUgYXMgdGhlICRkZWJ1Z05hbWVcbiAqL1xuZXhwb3J0cy5zdHlsZXNoZWV0ID0gdHMuc3R5bGVzaGVldDtcbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUeXBlU3R5bGUgc2VwYXJhdGUgZnJvbSB0aGUgZGVmYXVsdCBpbnN0YW5jZS5cbiAqXG4gKiAtIFVzZSB0aGlzIGZvciBjcmVhdGluZyBhIGRpZmZlcmVudCB0eXBlc3R5bGUgaW5zdGFuY2UgZm9yIGEgc2hhZG93IGRvbSBjb21wb25lbnQuXG4gKiAtIFVzZSB0aGlzIGlmIHlvdSBkb24ndCB3YW50IGFuIGF1dG8gdGFnIGdlbmVyYXRlZCBhbmQgeW91IGp1c3Qgd2FudCB0byBjb2xsZWN0IHRoZSBDU1MuXG4gKlxuICogTk9URTogc3R5bGVzIGFyZW4ndCBzaGFyZWQgYmV0d2VlbiBkaWZmZXJlbnQgaW5zdGFuY2VzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVUeXBlU3R5bGUodGFyZ2V0KSB7XG4gICAgdmFyIGluc3RhbmNlID0gbmV3IHR5cGVzdHlsZV8xLlR5cGVTdHlsZSh7IGF1dG9HZW5lcmF0ZVRhZzogZmFsc2UgfSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgICBpbnN0YW5jZS5zZXRTdHlsZXNUYXJnZXQodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xufVxuZXhwb3J0cy5jcmVhdGVUeXBlU3R5bGUgPSBjcmVhdGVUeXBlU3R5bGU7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogV2UgbmVlZCB0byBkbyB0aGUgZm9sbG93aW5nIHRvICpvdXIqIG9iamVjdHMgYmVmb3JlIHBhc3NpbmcgdG8gZnJlZXN0eWxlOlxuICogLSBGb3IgYW55IGAkbmVzdGAgZGlyZWN0aXZlIG1vdmUgdXAgdG8gRnJlZVN0eWxlIHN0eWxlIG5lc3RpbmdcbiAqIC0gRm9yIGFueSBgJHVuaXF1ZWAgZGlyZWN0aXZlIG1hcCB0byBGcmVlU3R5bGUgVW5pcXVlXG4gKiAtIEZvciBhbnkgYCRkZWJ1Z05hbWVgIGRpcmVjdGl2ZSByZXR1cm4gdGhlIGRlYnVnIG5hbWVcbiAqL1xuZnVuY3Rpb24gY29udmVydFRvU3R5bGVzKG9iamVjdCkge1xuICAgIC8qKiBUaGUgZmluYWwgcmVzdWx0IHdlIHdpbGwgcmV0dXJuICovXG4gICAgdmFyIHN0eWxlcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgLyoqIEdyYWIgdGhlIHZhbHVlIHVwZnJvbnQgKi9cbiAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAvKiogVHlwZVN0eWxlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyAqL1xuICAgICAgICBpZiAoa2V5ID09PSAnJG5lc3QnKSB7XG4gICAgICAgICAgICB2YXIgbmVzdGVkID0gdmFsO1xuICAgICAgICAgICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gbmVzdGVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1YnByb3BlcnRpZXMgPSBuZXN0ZWRbc2VsZWN0b3JdO1xuICAgICAgICAgICAgICAgIHN0eWxlc1tzZWxlY3Rvcl0gPSBjb252ZXJ0VG9TdHlsZXMoc3VicHJvcGVydGllcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnJGRlYnVnTmFtZScpIHtcbiAgICAgICAgICAgIHN0eWxlcy4kZGlzcGxheU5hbWUgPSB2YWw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdHlsZXNba2V5XSA9IHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZXhwb3J0cy5jb252ZXJ0VG9TdHlsZXMgPSBjb252ZXJ0VG9TdHlsZXM7XG4vLyB0b2RvOiBiZXR0ZXIgbmFtZSBoZXJlXG5mdW5jdGlvbiBjb252ZXJ0VG9LZXlmcmFtZXMoZnJhbWVzKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIG9mZnNldCBpbiBmcmFtZXMpIHtcbiAgICAgICAgaWYgKG9mZnNldCAhPT0gJyRkZWJ1Z05hbWUnKSB7XG4gICAgICAgICAgICByZXN1bHRbb2Zmc2V0XSA9IGZyYW1lc1tvZmZzZXRdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChmcmFtZXMuJGRlYnVnTmFtZSkge1xuICAgICAgICByZXN1bHQuJGRpc3BsYXlOYW1lID0gZnJhbWVzLiRkZWJ1Z05hbWU7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbnZlcnRUb0tleWZyYW1lcyA9IGNvbnZlcnRUb0tleWZyYW1lcztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIEZyZWVTdHlsZSA9IHJlcXVpcmUoXCJmcmVlLXN0eWxlXCIpO1xudmFyIGZvcm1hdHRpbmdfMSA9IHJlcXVpcmUoXCIuL2Zvcm1hdHRpbmdcIik7XG52YXIgdXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi91dGlsaXRpZXNcIik7XG4vKipcbiAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgZnJlZSBzdHlsZSB3aXRoIG91ciBvcHRpb25zXG4gKi9cbnZhciBjcmVhdGVGcmVlU3R5bGUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBGcmVlU3R5bGUuY3JlYXRlKCk7IH07XG4vKipcbiAqIE1haW50YWlucyBhIHNpbmdsZSBzdHlsZXNoZWV0IGFuZCBrZWVwcyBpdCBpbiBzeW5jIHdpdGggcmVxdWVzdGVkIHN0eWxlc1xuICovXG52YXIgVHlwZVN0eWxlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFR5cGVTdHlsZShfYSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXV0b0dlbmVyYXRlVGFnID0gX2EuYXV0b0dlbmVyYXRlVGFnO1xuICAgICAgICAvKipcbiAgICAgICAgICogSW5zZXJ0IGByYXdgIENTUyBhcyBhIHN0cmluZy4gVGhpcyBpcyB1c2VmdWwgZm9yIGUuZy5cbiAgICAgICAgICogLSB0aGlyZCBwYXJ0eSBDU1MgdGhhdCB5b3UgYXJlIGN1c3RvbWl6aW5nIHdpdGggdGVtcGxhdGUgc3RyaW5nc1xuICAgICAgICAgKiAtIGdlbmVyYXRpbmcgcmF3IENTUyBpbiBKYXZhU2NyaXB0XG4gICAgICAgICAqIC0gcmVzZXQgbGlicmFyaWVzIGxpa2Ugbm9ybWFsaXplLmNzcyB0aGF0IHlvdSBjYW4gdXNlIHdpdGhvdXQgbG9hZGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jc3NSYXcgPSBmdW5jdGlvbiAobXVzdEJlVmFsaWRDU1MpIHtcbiAgICAgICAgICAgIGlmICghbXVzdEJlVmFsaWRDU1MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcmF3ICs9IG11c3RCZVZhbGlkQ1NTIHx8ICcnO1xuICAgICAgICAgICAgX3RoaXMuX3BlbmRpbmdSYXdDaGFuZ2UgPSB0cnVlO1xuICAgICAgICAgICAgX3RoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMgQ1NTUHJvcGVydGllcyBhbmQgcmVnaXN0ZXJzIGl0IHRvIGEgZ2xvYmFsIHNlbGVjdG9yIChib2R5LCBodG1sLCBldGMuKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jc3NSdWxlID0gZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICAgICAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBvYmplY3RzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlcyA9IGZvcm1hdHRpbmdfMS5jb252ZXJ0VG9TdHlsZXModXRpbGl0aWVzXzEuZXh0ZW5kLmFwcGx5KHZvaWQgMCwgb2JqZWN0cykpO1xuICAgICAgICAgICAgX3RoaXMuX2ZyZWVTdHlsZS5yZWdpc3RlclJ1bGUoc2VsZWN0b3IsIHN0eWxlcyk7XG4gICAgICAgICAgICBfdGhpcy5fc3R5bGVVcGRhdGVkKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5kZXJzIHN0eWxlcyB0byB0aGUgc2luZ2xldG9uIHRhZyBpbWVkaWF0ZWx5XG4gICAgICAgICAqIE5PVEU6IFlvdSBzaG91bGQgb25seSBjYWxsIGl0IG9uIGluaXRpYWwgcmVuZGVyIHRvIHByZXZlbnQgYW55IG5vbiBDU1MgZmxhc2guXG4gICAgICAgICAqIEFmdGVyIHRoYXQgaXQgaXMga2VwdCBzeW5jIHVzaW5nIGByZXF1ZXN0QW5pbWF0aW9uRnJhbWVgIGFuZCB3ZSBoYXZlbid0IG5vdGljZWQgYW55IGJhZCBmbGFzaGVzLlxuICAgICAgICAgKiovXG4gICAgICAgIHRoaXMuZm9yY2VSZW5kZXJTdHlsZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gX3RoaXMuX2dldFRhZygpO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSBfdGhpcy5nZXRTdHlsZXMoKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFV0aWxpdHkgZnVuY3Rpb24gdG8gcmVnaXN0ZXIgYW4gQGZvbnQtZmFjZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mb250RmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBmb250RmFjZSA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICBmb250RmFjZVtfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGZyZWVTdHlsZSA9IF90aGlzLl9mcmVlU3R5bGU7XG4gICAgICAgICAgICBmb3IgKHZhciBfYSA9IDAsIF9iID0gZm9udEZhY2U7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZhY2UgPSBfYltfYV07XG4gICAgICAgICAgICAgICAgZnJlZVN0eWxlLnJlZ2lzdGVyUnVsZSgnQGZvbnQtZmFjZScsIGZhY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWxsb3dzIHVzZSB0byB1c2UgdGhlIHN0eWxlc2hlZXQgaW4gYSBub2RlLmpzIGVudmlyb25tZW50XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFN0eWxlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuX3JhdyB8fCAnJykgKyBfdGhpcy5fZnJlZVN0eWxlLmdldFN0eWxlcygpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGFrZXMga2V5ZnJhbWVzIGFuZCByZXR1cm5zIGEgZ2VuZXJhdGVkIGFuaW1hdGlvbk5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMua2V5ZnJhbWVzID0gZnVuY3Rpb24gKGZyYW1lcykge1xuICAgICAgICAgICAgdmFyIGtleWZyYW1lcyA9IGZvcm1hdHRpbmdfMS5jb252ZXJ0VG9LZXlmcmFtZXMoZnJhbWVzKTtcbiAgICAgICAgICAgIC8vIFRPRE86IHJlcGxhY2UgJGRlYnVnTmFtZSB3aXRoIGRpc3BsYXkgbmFtZVxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbk5hbWUgPSBfdGhpcy5fZnJlZVN0eWxlLnJlZ2lzdGVyS2V5ZnJhbWVzKGtleWZyYW1lcyk7XG4gICAgICAgICAgICBfdGhpcy5fc3R5bGVVcGRhdGVkKCk7XG4gICAgICAgICAgICByZXR1cm4gYW5pbWF0aW9uTmFtZTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEhlbHBzIHdpdGggdGVzdGluZy4gUmVpbml0aWFsaXplcyBGcmVlU3R5bGUgKyByYXdcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVpbml0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyoqIHJlaW5pdCBmcmVlc3R5bGUgKi9cbiAgICAgICAgICAgIHZhciBmcmVlU3R5bGUgPSBjcmVhdGVGcmVlU3R5bGUoKTtcbiAgICAgICAgICAgIF90aGlzLl9mcmVlU3R5bGUgPSBmcmVlU3R5bGU7XG4gICAgICAgICAgICBfdGhpcy5fbGFzdEZyZWVTdHlsZUNoYW5nZUlkID0gZnJlZVN0eWxlLmNoYW5nZUlkO1xuICAgICAgICAgICAgLyoqIHJlaW5pdCByYXcgKi9cbiAgICAgICAgICAgIF90aGlzLl9yYXcgPSAnJztcbiAgICAgICAgICAgIF90aGlzLl9wZW5kaW5nUmF3Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgICAvKiogQ2xlYXIgYW55IHN0eWxlcyB0aGF0IHdlcmUgZmx1c2hlZCAqL1xuICAgICAgICAgICAgdmFyIHRhcmdldCA9IF90aGlzLl9nZXRUYWcoKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQudGV4dENvbnRlbnQgPSAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyoqIFNldHMgdGhlIHRhcmdldCB0YWcgd2hlcmUgd2Ugd3JpdGUgdGhlIGNzcyBvbiBzdHlsZSB1cGRhdGVzICovXG4gICAgICAgIHRoaXMuc2V0U3R5bGVzVGFyZ2V0ID0gZnVuY3Rpb24gKHRhZykge1xuICAgICAgICAgICAgLyoqIENsZWFyIGFueSBkYXRhIGluIGFueSBwcmV2aW91cyB0YWcgKi9cbiAgICAgICAgICAgIGlmIChfdGhpcy5fdGFnKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuX3RhZy50ZXh0Q29udGVudCA9ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX3RhZyA9IHRhZztcbiAgICAgICAgICAgIC8qKiBUaGlzIHNwZWNpYWwgdGltZSBidWZmZXIgaW1tZWRpYXRlbHkgKi9cbiAgICAgICAgICAgIF90aGlzLmZvcmNlUmVuZGVyU3R5bGVzKCk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUYWtlcyBhbiBvYmplY3Qgd2hlcmUgcHJvcGVydHkgbmFtZXMgYXJlIGlkZWFsIGNsYXNzIG5hbWVzIGFuZCBwcm9wZXJ0eSB2YWx1ZXMgYXJlIENTU1Byb3BlcnRpZXMsIGFuZFxuICAgICAgICAgKiByZXR1cm5zIGFuIG9iamVjdCB3aGVyZSBwcm9wZXJ0eSBuYW1lcyBhcmUgdGhlIHNhbWUgaWRlYWwgY2xhc3MgbmFtZXMgYW5kIHRoZSBwcm9wZXJ0eSB2YWx1ZXMgYXJlXG4gICAgICAgICAqIHRoZSBhY3R1YWwgZ2VuZXJhdGVkIGNsYXNzIG5hbWVzIHVzaW5nIHRoZSBpZGVhbCBjbGFzcyBuYW1lIGFzIHRoZSAkZGVidWdOYW1lXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0eWxlc2hlZXQgPSBmdW5jdGlvbiAoY2xhc3Nlcykge1xuICAgICAgICAgICAgdmFyIGNsYXNzTmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhjbGFzc2VzKTtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY2xhc3NOYW1lc18xID0gY2xhc3NOYW1lczsgX2kgPCBjbGFzc05hbWVzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNfMVtfaV07XG4gICAgICAgICAgICAgICAgdmFyIGNsYXNzRGVmID0gY2xhc3Nlc1tjbGFzc05hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChjbGFzc0RlZikge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc0RlZi4kZGVidWdOYW1lID0gY2xhc3NOYW1lO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY2xhc3NOYW1lXSA9IF90aGlzLnN0eWxlKGNsYXNzRGVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9O1xuICAgICAgICB2YXIgZnJlZVN0eWxlID0gY3JlYXRlRnJlZVN0eWxlKCk7XG4gICAgICAgIHRoaXMuX2F1dG9HZW5lcmF0ZVRhZyA9IGF1dG9HZW5lcmF0ZVRhZztcbiAgICAgICAgdGhpcy5fZnJlZVN0eWxlID0gZnJlZVN0eWxlO1xuICAgICAgICB0aGlzLl9sYXN0RnJlZVN0eWxlQ2hhbmdlSWQgPSBmcmVlU3R5bGUuY2hhbmdlSWQ7XG4gICAgICAgIHRoaXMuX3BlbmRpbmcgPSAwO1xuICAgICAgICB0aGlzLl9wZW5kaW5nUmF3Q2hhbmdlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JhdyA9ICcnO1xuICAgICAgICB0aGlzLl90YWcgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8vIHJlYmluZCBwcm90b3R5cGUgdG8gVHlwZVN0eWxlLiAgSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGRvIGEgZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0eWxlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyl9XG4gICAgICAgIHRoaXMuc3R5bGUgPSB0aGlzLnN0eWxlLmJpbmQodGhpcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ubHkgY2FsbHMgY2IgYWxsIHN5bmMgb3BlcmF0aW9ucyBzZXR0bGVcbiAgICAgKi9cbiAgICBUeXBlU3R5bGUucHJvdG90eXBlLl9hZnRlckFsbFN5bmMgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5fcGVuZGluZysrO1xuICAgICAgICB2YXIgcGVuZGluZyA9IHRoaXMuX3BlbmRpbmc7XG4gICAgICAgIHV0aWxpdGllc18xLnJhZihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZyAhPT0gX3RoaXMuX3BlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFR5cGVTdHlsZS5wcm90b3R5cGUuX2dldFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RhZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3RhZztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYXV0b0dlbmVyYXRlVGFnKSB7XG4gICAgICAgICAgICB2YXIgdGFnID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgICA/IHsgdGV4dENvbnRlbnQ6ICcnIH1cbiAgICAgICAgICAgICAgICA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQodGFnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3RhZyA9IHRhZztcbiAgICAgICAgICAgIHJldHVybiB0YWc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICAgIC8qKiBDaGVja3MgaWYgdGhlIHN0eWxlIHRhZyBuZWVkcyB1cGRhdGluZyBhbmQgaWYgc28gcXVldWVzIHVwIHRoZSBjaGFuZ2UgKi9cbiAgICBUeXBlU3R5bGUucHJvdG90eXBlLl9zdHlsZVVwZGF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjaGFuZ2VJZCA9IHRoaXMuX2ZyZWVTdHlsZS5jaGFuZ2VJZDtcbiAgICAgICAgdmFyIGxhc3RDaGFuZ2VJZCA9IHRoaXMuX2xhc3RGcmVlU3R5bGVDaGFuZ2VJZDtcbiAgICAgICAgaWYgKCF0aGlzLl9wZW5kaW5nUmF3Q2hhbmdlICYmIGNoYW5nZUlkID09PSBsYXN0Q2hhbmdlSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9sYXN0RnJlZVN0eWxlQ2hhbmdlSWQgPSBjaGFuZ2VJZDtcbiAgICAgICAgdGhpcy5fcGVuZGluZ1Jhd0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9hZnRlckFsbFN5bmMoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuZm9yY2VSZW5kZXJTdHlsZXMoKTsgfSk7XG4gICAgfTtcbiAgICBUeXBlU3R5bGUucHJvdG90eXBlLnN0eWxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2xhc3NOYW1lID0gdGhpcy5fZnJlZVN0eWxlLnJlZ2lzdGVyU3R5bGUoZm9ybWF0dGluZ18xLmNvbnZlcnRUb1N0eWxlcyh1dGlsaXRpZXNfMS5leHRlbmQuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpKSk7XG4gICAgICAgIHRoaXMuX3N0eWxlVXBkYXRlZCgpO1xuICAgICAgICByZXR1cm4gY2xhc3NOYW1lO1xuICAgIH07XG4gICAgcmV0dXJuIFR5cGVTdHlsZTtcbn0oKSk7XG5leHBvcnRzLlR5cGVTdHlsZSA9IFR5cGVTdHlsZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqIFJhZiBmb3Igbm9kZSArIGJyb3dzZXIgKi9cbmV4cG9ydHMucmFmID0gdHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSA9PT0gJ3VuZGVmaW5lZCdcbiAgICAvKipcbiAgICAgKiBNYWtlIHN1cmUgc2V0VGltZW91dCBpcyBhbHdheXMgaW52b2tlZCB3aXRoXG4gICAgICogYHRoaXNgIHNldCB0byBgd2luZG93YCBvciBgZ2xvYmFsYCBhdXRvbWF0aWNhbGx5XG4gICAgICoqL1xuICAgID8gZnVuY3Rpb24gKGNiKSB7IHJldHVybiBzZXRUaW1lb3V0KGNiKTsgfVxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lIGlzIGFsd2F5cyBpbnZva2VkIHdpdGggYHRoaXNgIHdpbmRvd1xuICAgICAqIFdlIG1pZ2h0IGhhdmUgcmFmIHdpdGhvdXQgd2luZG93IGluIGNhc2Ugb2YgYHJhZi9wb2x5ZmlsbGAgKHJlY29tbWVuZGVkIGJ5IFJlYWN0KVxuICAgICAqKi9cbiAgICA6IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICAgIDogcmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KTtcbi8qKlxuICogVXRpbGl0eSB0byBqb2luIGNsYXNzZXMgY29uZGl0aW9uYWxseVxuICovXG5mdW5jdGlvbiBjbGFzc2VzKCkge1xuICAgIHZhciBjbGFzc2VzID0gW107XG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgY2xhc3Nlc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICByZXR1cm4gY2xhc3Nlc1xuICAgICAgICAubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBjICYmIHR5cGVvZiBjID09PSAnb2JqZWN0JyA/IE9iamVjdC5rZXlzKGMpLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAhIWNba2V5XSAmJiBrZXk7IH0pIDogW2NdOyB9KVxuICAgICAgICAucmVkdWNlKGZ1bmN0aW9uIChmbGF0dGVuZWQsIGMpIHsgcmV0dXJuIGZsYXR0ZW5lZC5jb25jYXQoYyk7IH0sIFtdKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChjKSB7IHJldHVybiAhIWM7IH0pXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5leHBvcnRzLmNsYXNzZXMgPSBjbGFzc2VzO1xuLyoqXG4gKiBNZXJnZXMgdmFyaW91cyBzdHlsZXMgaW50byBhIHNpbmdsZSBzdHlsZSBvYmplY3QuXG4gKiBOb3RlOiBpZiB0d28gb2JqZWN0cyBoYXZlIHRoZSBzYW1lIHByb3BlcnR5IHRoZSBsYXN0IG9uZSB3aW5zXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9iamVjdHNbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICB9XG4gICAgLyoqIFRoZSBmaW5hbCByZXN1bHQgd2Ugd2lsbCByZXR1cm4gKi9cbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgX2EgPSAwLCBvYmplY3RzXzEgPSBvYmplY3RzOyBfYSA8IG9iamVjdHNfMS5sZW5ndGg7IF9hKyspIHtcbiAgICAgICAgdmFyIG9iamVjdCA9IG9iamVjdHNfMVtfYV07XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCB8fCBvYmplY3QgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAvKiogRmFsc3kgdmFsdWVzIGV4Y2VwdCBhIGV4cGxpY2l0IDAgaXMgaWdub3JlZCAqL1xuICAgICAgICAgICAgdmFyIHZhbCA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKCF2YWwgJiYgdmFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogaWYgbmVzdGVkIG1lZGlhIG9yIHBzZXVkbyBzZWxlY3RvciAqL1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gJyRuZXN0JyAmJiB2YWwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IHJlc3VsdFsnJG5lc3QnXSA/IGV4dGVuZChyZXN1bHRbJyRuZXN0J10sIHZhbCkgOiB2YWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiogaWYgZnJlZXN0eWxlIHN1YiBrZXkgdGhhdCBuZWVkcyBtZXJnaW5nLiBXZSBjb21lIGhlcmUgZHVlIHRvIG91ciByZWN1cnNpdmUgY2FsbHMgKi9cbiAgICAgICAgICAgIGVsc2UgaWYgKChrZXkuaW5kZXhPZignJicpICE9PSAtMSB8fCBrZXkuaW5kZXhPZignQG1lZGlhJykgPT09IDApKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSByZXN1bHRba2V5XSA/IGV4dGVuZChyZXN1bHRba2V5XSwgdmFsKSA6IHZhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmV4dGVuZCA9IGV4dGVuZDtcbi8qKlxuICogVXRpbGl0eSB0byBoZWxwIGN1c3RvbWl6ZSBzdHlsZXMgd2l0aCBtZWRpYSBxdWVyaWVzLiBlLmcuXG4gKiBgYGBcbiAqIHN0eWxlKFxuICogIG1lZGlhKHttYXhXaWR0aDo1MDB9LCB7Y29sb3I6J3JlZCd9KVxuICogKVxuICogYGBgXG4gKi9cbmV4cG9ydHMubWVkaWEgPSBmdW5jdGlvbiAobWVkaWFRdWVyeSkge1xuICAgIHZhciBfYTtcbiAgICB2YXIgb2JqZWN0cyA9IFtdO1xuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIG9iamVjdHNbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgfVxuICAgIHZhciBtZWRpYVF1ZXJ5U2VjdGlvbnMgPSBbXTtcbiAgICBpZiAobWVkaWFRdWVyeS50eXBlKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChtZWRpYVF1ZXJ5LnR5cGUpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm9yaWVudGF0aW9uKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihvcmllbnRhdGlvbjogXCIgKyBtZWRpYVF1ZXJ5Lm9yaWVudGF0aW9uICsgXCIpXCIpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm1pbldpZHRoKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihtaW4td2lkdGg6IFwiICsgbWVkaWFMZW5ndGgobWVkaWFRdWVyeS5taW5XaWR0aCkgKyBcIilcIik7XG4gICAgaWYgKG1lZGlhUXVlcnkubWF4V2lkdGgpXG4gICAgICAgIG1lZGlhUXVlcnlTZWN0aW9ucy5wdXNoKFwiKG1heC13aWR0aDogXCIgKyBtZWRpYUxlbmd0aChtZWRpYVF1ZXJ5Lm1heFdpZHRoKSArIFwiKVwiKTtcbiAgICBpZiAobWVkaWFRdWVyeS5taW5IZWlnaHQpXG4gICAgICAgIG1lZGlhUXVlcnlTZWN0aW9ucy5wdXNoKFwiKG1pbi1oZWlnaHQ6IFwiICsgbWVkaWFMZW5ndGgobWVkaWFRdWVyeS5taW5IZWlnaHQpICsgXCIpXCIpO1xuICAgIGlmIChtZWRpYVF1ZXJ5Lm1heEhlaWdodClcbiAgICAgICAgbWVkaWFRdWVyeVNlY3Rpb25zLnB1c2goXCIobWF4LWhlaWdodDogXCIgKyBtZWRpYUxlbmd0aChtZWRpYVF1ZXJ5Lm1heEhlaWdodCkgKyBcIilcIik7XG4gICAgaWYgKG1lZGlhUXVlcnkucHJlZmVyc0NvbG9yU2NoZW1lKVxuICAgICAgICBtZWRpYVF1ZXJ5U2VjdGlvbnMucHVzaChcIihwcmVmZXJzLWNvbG9yLXNjaGVtZTogXCIgKyBtZWRpYVF1ZXJ5LnByZWZlcnNDb2xvclNjaGVtZSArIFwiKVwiKTtcbiAgICB2YXIgc3RyaW5nTWVkaWFRdWVyeSA9IFwiQG1lZGlhIFwiICsgbWVkaWFRdWVyeVNlY3Rpb25zLmpvaW4oJyBhbmQgJyk7XG4gICAgdmFyIG9iamVjdCA9IHtcbiAgICAgICAgJG5lc3Q6IChfYSA9IHt9LFxuICAgICAgICAgICAgX2Fbc3RyaW5nTWVkaWFRdWVyeV0gPSBleHRlbmQuYXBwbHkodm9pZCAwLCBvYmplY3RzKSxcbiAgICAgICAgICAgIF9hKVxuICAgIH07XG4gICAgcmV0dXJuIG9iamVjdDtcbn07XG52YXIgbWVkaWFMZW5ndGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IHZhbHVlIDogdmFsdWUgKyBcInB4XCI7XG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=