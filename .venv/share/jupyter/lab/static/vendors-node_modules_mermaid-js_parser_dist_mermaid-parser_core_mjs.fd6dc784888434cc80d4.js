(self["webpackChunk_jupyterlab_application_top"] = self["webpackChunk_jupyterlab_application_top"] || []).push([["vendors-node_modules_mermaid-js_parser_dist_mermaid-parser_core_mjs"],{

/***/ "./node_modules/@chevrotain/cst-dts-gen/lib/src/api.js":
/*!*************************************************************!*\
  !*** ./node_modules/@chevrotain/cst-dts-gen/lib/src/api.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   generateCstDts: () => (/* binding */ generateCstDts)
/* harmony export */ });
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model.js */ "./node_modules/@chevrotain/cst-dts-gen/lib/src/model.js");
/* harmony import */ var _generate_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generate.js */ "./node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js");


const defaultOptions = {
    includeVisitorInterface: true,
    visitorInterfaceName: "ICstNodeVisitor",
};
function generateCstDts(productions, options) {
    const effectiveOptions = Object.assign(Object.assign({}, defaultOptions), options);
    const model = (0,_model_js__WEBPACK_IMPORTED_MODULE_0__.buildModel)(productions);
    return (0,_generate_js__WEBPACK_IMPORTED_MODULE_1__.genDts)(model, effectiveOptions);
}
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js":
/*!******************************************************************!*\
  !*** ./node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   genDts: () => (/* binding */ genDts)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/uniq.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/upperFirst.js");

function genDts(model, options) {
    let contentParts = [];
    contentParts = contentParts.concat(`import type { CstNode, ICstVisitor, IToken } from "chevrotain";`);
    contentParts = contentParts.concat((0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(model, (node) => genCstNodeTypes(node))));
    if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
    }
    return contentParts.join("\n\n") + "\n";
}
function genCstNodeTypes(node) {
    const nodeCstInterface = genNodeInterface(node);
    const nodeChildrenInterface = genNodeChildrenType(node);
    return [nodeCstInterface, nodeChildrenInterface];
}
function genNodeInterface(node) {
    const nodeInterfaceName = getNodeInterfaceName(node.name);
    const childrenTypeName = getNodeChildrenTypeName(node.name);
    return `export interface ${nodeInterfaceName} extends CstNode {
  name: "${node.name}";
  children: ${childrenTypeName};
}`;
}
function genNodeChildrenType(node) {
    const typeName = getNodeChildrenTypeName(node.name);
    return `export type ${typeName} = {
  ${(0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(node.properties, (property) => genChildProperty(property)).join("\n  ")}
};`;
}
function genChildProperty(prop) {
    const typeName = buildTypeString(prop.type);
    return `${prop.name}${prop.optional ? "?" : ""}: ${typeName}[];`;
}
function genVisitor(name, nodes) {
    return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {
  ${(0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(nodes, (node) => genVisitorFunction(node)).join("\n  ")}
}`;
}
function genVisitorFunction(node) {
    const childrenTypeName = getNodeChildrenTypeName(node.name);
    return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;
}
function buildTypeString(type) {
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(type)) {
        const typeNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(type, (t) => getTypeString(t)));
        const typeString = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(typeNames, (sum, t) => sum + " | " + t);
        return "(" + typeString + ")";
    }
    else {
        return getTypeString(type);
    }
}
function getTypeString(type) {
    if (type.kind === "token") {
        return "IToken";
    }
    return getNodeInterfaceName(type.name);
}
function getNodeInterfaceName(ruleName) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(ruleName) + "CstNode";
}
function getNodeChildrenTypeName(ruleName) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(ruleName) + "CstChildren";
}
//# sourceMappingURL=generate.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/cst-dts-gen/lib/src/model.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chevrotain/cst-dts-gen/lib/src/model.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   buildModel: () => (/* binding */ buildModel)
/* harmony export */ });
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/groupBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/some.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/assign.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");


function buildModel(productions) {
    const generator = new CstNodeDefinitionGenerator();
    const allRules = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(productions);
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(allRules, (rule) => generator.visitRule(rule));
}
class CstNodeDefinitionGenerator extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.GAstVisitor {
    visitRule(node) {
        const rawElements = this.visitEach(node.definition);
        const grouped = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(rawElements, (el) => el.propertyName);
        const properties = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(grouped, (group, propertyName) => {
            const allNullable = !(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(group, (el) => !el.canBeNull);
            // In an alternation with a label a property name can have
            // multiple types.
            let propertyType = group[0].type;
            if (group.length > 1) {
                propertyType = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(group, (g) => g.type);
            }
            return {
                name: propertyName,
                type: propertyType,
                optional: allNullable,
            };
        });
        return {
            name: node.name,
            properties: properties,
        };
    }
    visitAlternative(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitOption(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitRepetition(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitRepetitionMandatory(node) {
        return this.visitEach(node.definition);
    }
    visitRepetitionMandatoryWithSeparator(node) {
        return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator),
        });
    }
    visitRepetitionWithSeparator(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true,
        }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator),
        });
    }
    visitAlternation(node) {
        return this.visitEachAndOverrideWith(node.definition, { canBeNull: true });
    }
    visitTerminal(node) {
        return [
            {
                propertyName: node.label || node.terminalType.name,
                canBeNull: false,
                type: getType(node),
            },
        ];
    }
    visitNonTerminal(node) {
        return [
            {
                propertyName: node.label || node.nonTerminalName,
                canBeNull: false,
                type: getType(node),
            },
        ];
    }
    visitEachAndOverrideWith(definition, override) {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this.visitEach(definition), (definition) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])({}, definition, override));
    }
    visitEach(definition) {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(definition, (definition) => this.visit(definition)));
    }
}
function getType(production) {
    if (production instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
        return {
            kind: "rule",
            name: production.referencedRule.name,
        };
    }
    return { kind: "token" };
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/gast/lib/src/api.js":
/*!******************************************************!*\
  !*** ./node_modules/@chevrotain/gast/lib/src/api.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alternation: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternation),
/* harmony export */   Alternative: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternative),
/* harmony export */   GAstVisitor: () => (/* reexport safe */ _visitor_js__WEBPACK_IMPORTED_MODULE_1__.GAstVisitor),
/* harmony export */   NonTerminal: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.NonTerminal),
/* harmony export */   Option: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.Option),
/* harmony export */   Repetition: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.Repetition),
/* harmony export */   RepetitionMandatory: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory),
/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator),
/* harmony export */   RepetitionWithSeparator: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator),
/* harmony export */   Rule: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.Rule),
/* harmony export */   Terminal: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.Terminal),
/* harmony export */   getProductionDslName: () => (/* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName),
/* harmony export */   isBranchingProd: () => (/* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_2__.isBranchingProd),
/* harmony export */   isOptionalProd: () => (/* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_2__.isOptionalProd),
/* harmony export */   isSequenceProd: () => (/* reexport safe */ _helpers_js__WEBPACK_IMPORTED_MODULE_2__.isSequenceProd),
/* harmony export */   serializeGrammar: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.serializeGrammar),
/* harmony export */   serializeProduction: () => (/* reexport safe */ _model_js__WEBPACK_IMPORTED_MODULE_0__.serializeProduction)
/* harmony export */ });
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model.js */ "./node_modules/@chevrotain/gast/lib/src/model.js");
/* harmony import */ var _visitor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./visitor.js */ "./node_modules/@chevrotain/gast/lib/src/visitor.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@chevrotain/gast/lib/src/helpers.js");



//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/gast/lib/src/helpers.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chevrotain/gast/lib/src/helpers.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   getProductionDslName: () => (/* binding */ getProductionDslName),
/* harmony export */   isBranchingProd: () => (/* binding */ isBranchingProd),
/* harmony export */   isOptionalProd: () => (/* binding */ isOptionalProd),
/* harmony export */   isSequenceProd: () => (/* binding */ isSequenceProd)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/some.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/every.js");
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model.js */ "./node_modules/@chevrotain/gast/lib/src/model.js");


function isSequenceProd(prod) {
    return (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternative ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Option ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Repetition ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Terminal ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Rule);
}
function isOptionalProd(prod, alreadyVisited = []) {
    const isDirectlyOptional = prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Option ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Repetition ||
        prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator;
    if (isDirectlyOptional) {
        return true;
    }
    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
    // empty optional top rule
    // may be indirectly optional ((A?B?C?) | (D?E?F?))
    if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternation) {
        // for OR its enough for just one of the alternatives to be optional
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(prod.definition, (subProd) => {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.NonTerminal && (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(alreadyVisited, prod)) {
        // avoiding stack overflow due to infinite recursion
        return false;
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.AbstractProduction) {
        if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
            alreadyVisited.push(prod);
        }
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(prod.definition, (subProd) => {
            return isOptionalProd(subProd, alreadyVisited);
        });
    }
    else {
        return false;
    }
}
function isBranchingProd(prod) {
    return prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternation;
}
function getProductionDslName(prod) {
    /* istanbul ignore else */
    if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
        return "SUBRULE";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Option) {
        return "OPTION";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternation) {
        return "OR";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {
        return "AT_LEAST_ONE";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {
        return "MANY_SEP";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Repetition) {
        return "MANY";
    }
    else if (prod instanceof _model_js__WEBPACK_IMPORTED_MODULE_0__.Terminal) {
        return "CONSUME";
        /* c8 ignore next 3 */
    }
    else {
        throw Error("non exhaustive match");
    }
}
//# sourceMappingURL=helpers.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/gast/lib/src/model.js":
/*!********************************************************!*\
  !*** ./node_modules/@chevrotain/gast/lib/src/model.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractProduction: () => (/* binding */ AbstractProduction),
/* harmony export */   Alternation: () => (/* binding */ Alternation),
/* harmony export */   Alternative: () => (/* binding */ Alternative),
/* harmony export */   NonTerminal: () => (/* binding */ NonTerminal),
/* harmony export */   Option: () => (/* binding */ Option),
/* harmony export */   Repetition: () => (/* binding */ Repetition),
/* harmony export */   RepetitionMandatory: () => (/* binding */ RepetitionMandatory),
/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* binding */ RepetitionMandatoryWithSeparator),
/* harmony export */   RepetitionWithSeparator: () => (/* binding */ RepetitionWithSeparator),
/* harmony export */   Rule: () => (/* binding */ Rule),
/* harmony export */   Terminal: () => (/* binding */ Terminal),
/* harmony export */   serializeGrammar: () => (/* binding */ serializeGrammar),
/* harmony export */   serializeProduction: () => (/* binding */ serializeProduction)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isString.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/assign.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/pickBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isRegExp.js");

// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?
function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    }
    else {
        return tokType.name;
    }
}
// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?
function hasTokenLabel(obj) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(obj.LABEL) && obj.LABEL !== "";
}
class AbstractProduction {
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
    constructor(_definition) {
        this._definition = _definition;
    }
    accept(visitor) {
        visitor.visit(this);
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(this.definition, (prod) => {
            prod.accept(visitor);
        });
    }
}
class NonTerminal extends AbstractProduction {
    constructor(options) {
        super([]);
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
    set definition(definition) {
        // immutable
    }
    get definition() {
        if (this.referencedRule !== undefined) {
            return this.referencedRule.definition;
        }
        return [];
    }
    accept(visitor) {
        visitor.visit(this);
        // don't visit children of a reference, we will get cyclic infinite loops if we do so
    }
}
class Rule extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.orgText = "";
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class Alternative extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.ignoreAmbiguities = false;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class Option extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class RepetitionMandatory extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class RepetitionMandatoryWithSeparator extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class Repetition extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class RepetitionWithSeparator extends AbstractProduction {
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class Alternation extends AbstractProduction {
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
    constructor(options) {
        super(options.definition);
        this.idx = 1;
        this.ignoreAmbiguities = false;
        this.hasPredicates = false;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
}
class Terminal {
    constructor(options) {
        this.idx = 1;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(this, (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, (v) => v !== undefined));
    }
    accept(visitor) {
        visitor.visit(this);
    }
}
function serializeGrammar(topRules) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(topRules, serializeProduction);
}
function serializeProduction(node) {
    function convertDefinition(definition) {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(definition, serializeProduction);
    }
    /* istanbul ignore else */
    if (node instanceof NonTerminal) {
        const serializedNonTerminal = {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx,
        };
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(node.label)) {
            serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
    }
    else if (node instanceof Alternative) {
        return {
            type: "Alternative",
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof Option) {
        return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof RepetitionMandatory) {
        return {
            type: "RepetitionMandatory",
            idx: node.idx,
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
            type: "RepetitionMandatoryWithSeparator",
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof RepetitionWithSeparator) {
        return {
            type: "RepetitionWithSeparator",
            idx: node.idx,
            separator: (serializeProduction(new Terminal({ terminalType: node.separator }))),
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof Repetition) {
        return {
            type: "Repetition",
            idx: node.idx,
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof Alternation) {
        return {
            type: "Alternation",
            idx: node.idx,
            definition: convertDefinition(node.definition),
        };
    }
    else if (node instanceof Terminal) {
        const serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokenLabel(node.terminalType),
            idx: node.idx,
        };
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(node.label)) {
            serializedTerminal.terminalLabel = node.label;
        }
        const pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(pattern)
                ? pattern.source
                : pattern;
        }
        return serializedTerminal;
    }
    else if (node instanceof Rule) {
        return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition),
        };
        /* c8 ignore next 3 */
    }
    else {
        throw Error("non exhaustive match");
    }
}
//# sourceMappingURL=model.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/gast/lib/src/visitor.js":
/*!**********************************************************!*\
  !*** ./node_modules/@chevrotain/gast/lib/src/visitor.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GAstVisitor: () => (/* binding */ GAstVisitor)
/* harmony export */ });
/* harmony import */ var _model_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./model.js */ "./node_modules/@chevrotain/gast/lib/src/model.js");

class GAstVisitor {
    visit(node) {
        const nodeAny = node;
        switch (nodeAny.constructor) {
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.NonTerminal:
                return this.visitNonTerminal(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternative:
                return this.visitAlternative(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.Option:
                return this.visitOption(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory:
                return this.visitRepetitionMandatory(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator:
                return this.visitRepetitionWithSeparator(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.Repetition:
                return this.visitRepetition(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.Alternation:
                return this.visitAlternation(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.Terminal:
                return this.visitTerminal(nodeAny);
            case _model_js__WEBPACK_IMPORTED_MODULE_0__.Rule:
                return this.visitRule(nodeAny);
            /* c8 ignore next 2 */
            default:
                throw Error("non exhaustive match");
        }
    }
    /* c8 ignore next */
    visitNonTerminal(node) { }
    /* c8 ignore next */
    visitAlternative(node) { }
    /* c8 ignore next */
    visitOption(node) { }
    /* c8 ignore next */
    visitRepetition(node) { }
    /* c8 ignore next */
    visitRepetitionMandatory(node) { }
    /* c8 ignore next 3 */
    visitRepetitionMandatoryWithSeparator(node) { }
    /* c8 ignore next */
    visitRepetitionWithSeparator(node) { }
    /* c8 ignore next */
    visitAlternation(node) { }
    /* c8 ignore next */
    visitTerminal(node) { }
    /* c8 ignore next */
    visitRule(node) { }
}
//# sourceMappingURL=visitor.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js":
/*!***************************************************************!*\
  !*** ./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseRegExpVisitor: () => (/* reexport safe */ _base_regexp_visitor_js__WEBPACK_IMPORTED_MODULE_1__.BaseRegExpVisitor),
/* harmony export */   RegExpParser: () => (/* reexport safe */ _regexp_parser_js__WEBPACK_IMPORTED_MODULE_0__.RegExpParser)
/* harmony export */ });
/* harmony import */ var _regexp_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./regexp-parser.js */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js");
/* harmony import */ var _base_regexp_visitor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base-regexp-visitor.js */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js");


//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BaseRegExpVisitor: () => (/* binding */ BaseRegExpVisitor)
/* harmony export */ });
class BaseRegExpVisitor {
    visitChildren(node) {
        for (const key in node) {
            const child = node[key];
            /* istanbul ignore else */
            if (node.hasOwnProperty(key)) {
                if (child.type !== undefined) {
                    this.visit(child);
                }
                else if (Array.isArray(child)) {
                    child.forEach((subChild) => {
                        this.visit(subChild);
                    }, this);
                }
            }
        }
    }
    visit(node) {
        switch (node.type) {
            case "Pattern":
                this.visitPattern(node);
                break;
            case "Flags":
                this.visitFlags(node);
                break;
            case "Disjunction":
                this.visitDisjunction(node);
                break;
            case "Alternative":
                this.visitAlternative(node);
                break;
            case "StartAnchor":
                this.visitStartAnchor(node);
                break;
            case "EndAnchor":
                this.visitEndAnchor(node);
                break;
            case "WordBoundary":
                this.visitWordBoundary(node);
                break;
            case "NonWordBoundary":
                this.visitNonWordBoundary(node);
                break;
            case "Lookahead":
                this.visitLookahead(node);
                break;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                break;
            case "Character":
                this.visitCharacter(node);
                break;
            case "Set":
                this.visitSet(node);
                break;
            case "Group":
                this.visitGroup(node);
                break;
            case "GroupBackReference":
                this.visitGroupBackReference(node);
                break;
            case "Quantifier":
                this.visitQuantifier(node);
                break;
        }
        this.visitChildren(node);
    }
    visitPattern(node) { }
    visitFlags(node) { }
    visitDisjunction(node) { }
    visitAlternative(node) { }
    // Assertion
    visitStartAnchor(node) { }
    visitEndAnchor(node) { }
    visitWordBoundary(node) { }
    visitNonWordBoundary(node) { }
    visitLookahead(node) { }
    visitNegativeLookahead(node) { }
    // atoms
    visitCharacter(node) { }
    visitSet(node) { }
    visitGroup(node) { }
    visitGroupBackReference(node) { }
    visitQuantifier(node) { }
}
//# sourceMappingURL=base-regexp-visitor.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   digitsCharCodes: () => (/* binding */ digitsCharCodes),
/* harmony export */   whitespaceCodes: () => (/* binding */ whitespaceCodes),
/* harmony export */   wordCharCodes: () => (/* binding */ wordCharCodes)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js");

const digitsCharCodes = [];
for (let i = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("0"); i <= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("9"); i++) {
    digitsCharCodes.push(i);
}
const wordCharCodes = [(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("_")].concat(digitsCharCodes);
for (let i = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("a"); i <= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("z"); i++) {
    wordCharCodes.push(i);
}
for (let i = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("A"); i <= (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("Z"); i++) {
    wordCharCodes.push(i);
}
// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#character-classes
const whitespaceCodes = [
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)(" "),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\f"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\n"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\r"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\t"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\v"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\t"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u00a0"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u1680"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2000"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2001"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2002"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2003"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2004"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2005"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2006"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2007"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2008"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2009"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u200a"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2028"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2029"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u202f"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u205f"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u3000"),
    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\ufeff"),
];
//# sourceMappingURL=character-classes.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RegExpParser: () => (/* binding */ RegExpParser)
/* harmony export */ });
/* harmony import */ var _utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils.js */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js");
/* harmony import */ var _character_classes_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./character-classes.js */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js");


// consts and utilities
const hexDigitPattern = /[0-9a-fA-F]/;
const decimalPattern = /[0-9]/;
const decimalPatternNoZero = /[1-9]/;
// https://hackernoon.com/the-madness-of-parsing-real-world-javascript-regexps-d9ee336df983
// https://www.ecma-international.org/ecma-262/8.0/index.html#prod-Pattern
class RegExpParser {
    constructor() {
        this.idx = 0;
        this.input = "";
        this.groupIdx = 0;
    }
    saveState() {
        return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx,
        };
    }
    restoreState(newState) {
        this.idx = newState.idx;
        this.input = newState.input;
        this.groupIdx = newState.groupIdx;
    }
    pattern(input) {
        // parser state
        this.idx = 0;
        this.input = input;
        this.groupIdx = 0;
        this.consumeChar("/");
        const value = this.disjunction();
        this.consumeChar("/");
        const flags = {
            type: "Flags",
            loc: { begin: this.idx, end: input.length },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false,
        };
        while (this.isRegExpFlag()) {
            switch (this.popChar()) {
                case "g":
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.addFlag)(flags, "global");
                    break;
                case "i":
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.addFlag)(flags, "ignoreCase");
                    break;
                case "m":
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.addFlag)(flags, "multiLine");
                    break;
                case "u":
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.addFlag)(flags, "unicode");
                    break;
                case "y":
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.addFlag)(flags, "sticky");
                    break;
            }
        }
        if (this.idx !== this.input.length) {
            throw Error("Redundant input: " + this.input.substring(this.idx));
        }
        return {
            type: "Pattern",
            flags: flags,
            value: value,
            loc: this.loc(0),
        };
    }
    disjunction() {
        const alts = [];
        const begin = this.idx;
        alts.push(this.alternative());
        while (this.peekChar() === "|") {
            this.consumeChar("|");
            alts.push(this.alternative());
        }
        return { type: "Disjunction", value: alts, loc: this.loc(begin) };
    }
    alternative() {
        const terms = [];
        const begin = this.idx;
        while (this.isTerm()) {
            terms.push(this.term());
        }
        return { type: "Alternative", value: terms, loc: this.loc(begin) };
    }
    term() {
        if (this.isAssertion()) {
            return this.assertion();
        }
        else {
            return this.atom();
        }
    }
    assertion() {
        const begin = this.idx;
        switch (this.popChar()) {
            case "^":
                return {
                    type: "StartAnchor",
                    loc: this.loc(begin),
                };
            case "$":
                return { type: "EndAnchor", loc: this.loc(begin) };
            // '\b' or '\B'
            case "\\":
                switch (this.popChar()) {
                    case "b":
                        return {
                            type: "WordBoundary",
                            loc: this.loc(begin),
                        };
                    case "B":
                        return {
                            type: "NonWordBoundary",
                            loc: this.loc(begin),
                        };
                }
                // istanbul ignore next
                throw Error("Invalid Assertion Escape");
            // '(?=' or '(?!'
            case "(":
                this.consumeChar("?");
                let type;
                switch (this.popChar()) {
                    case "=":
                        type = "Lookahead";
                        break;
                    case "!":
                        type = "NegativeLookahead";
                        break;
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_EXISTS)(type);
                const disjunction = this.disjunction();
                this.consumeChar(")");
                return {
                    type: type,
                    value: disjunction,
                    loc: this.loc(begin),
                };
        }
        // istanbul ignore next
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_NEVER_REACH_HERE)();
    }
    quantifier(isBacktracking = false) {
        let range = undefined;
        const begin = this.idx;
        switch (this.popChar()) {
            case "*":
                range = {
                    atLeast: 0,
                    atMost: Infinity,
                };
                break;
            case "+":
                range = {
                    atLeast: 1,
                    atMost: Infinity,
                };
                break;
            case "?":
                range = {
                    atLeast: 0,
                    atMost: 1,
                };
                break;
            case "{":
                const atLeast = this.integerIncludingZero();
                switch (this.popChar()) {
                    case "}":
                        range = {
                            atLeast: atLeast,
                            atMost: atLeast,
                        };
                        break;
                    case ",":
                        let atMost;
                        if (this.isDigit()) {
                            atMost = this.integerIncludingZero();
                            range = {
                                atLeast: atLeast,
                                atMost: atMost,
                            };
                        }
                        else {
                            range = {
                                atLeast: atLeast,
                                atMost: Infinity,
                            };
                        }
                        this.consumeChar("}");
                        break;
                }
                // throwing exceptions from "ASSERT_EXISTS" during backtracking
                // causes severe performance degradations
                if (isBacktracking === true && range === undefined) {
                    return undefined;
                }
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_EXISTS)(range);
                break;
        }
        // throwing exceptions from "ASSERT_EXISTS" during backtracking
        // causes severe performance degradations
        if (isBacktracking === true && range === undefined) {
            return undefined;
        }
        // istanbul ignore else
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_EXISTS)(range)) {
            if (this.peekChar(0) === "?") {
                this.consumeChar("?");
                range.greedy = false;
            }
            else {
                range.greedy = true;
            }
            range.type = "Quantifier";
            range.loc = this.loc(begin);
            return range;
        }
    }
    atom() {
        let atom;
        const begin = this.idx;
        switch (this.peekChar()) {
            case ".":
                atom = this.dotAll();
                break;
            case "\\":
                atom = this.atomEscape();
                break;
            case "[":
                atom = this.characterClass();
                break;
            case "(":
                atom = this.group();
                break;
        }
        if (atom === undefined && this.isPatternCharacter()) {
            atom = this.patternCharacter();
        }
        // istanbul ignore else
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_EXISTS)(atom)) {
            atom.loc = this.loc(begin);
            if (this.isQuantifier()) {
                atom.quantifier = this.quantifier();
            }
            return atom;
        }
        // istanbul ignore next
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_NEVER_REACH_HERE)();
    }
    dotAll() {
        this.consumeChar(".");
        return {
            type: "Set",
            complement: true,
            value: [(0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\n"), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\r"), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2028"), (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u2029")],
        };
    }
    atomEscape() {
        this.consumeChar("\\");
        switch (this.peekChar()) {
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
                return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
                return this.controlEscapeAtom();
            case "c":
                return this.controlLetterEscapeAtom();
            case "0":
                return this.nulCharacterAtom();
            case "x":
                return this.hexEscapeSequenceAtom();
            case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
            default:
                return this.identityEscapeAtom();
        }
    }
    decimalEscapeAtom() {
        const value = this.positiveInteger();
        return { type: "GroupBackReference", value: value };
    }
    characterClassEscape() {
        let set;
        let complement = false;
        switch (this.popChar()) {
            case "d":
                set = _character_classes_js__WEBPACK_IMPORTED_MODULE_1__.digitsCharCodes;
                break;
            case "D":
                set = _character_classes_js__WEBPACK_IMPORTED_MODULE_1__.digitsCharCodes;
                complement = true;
                break;
            case "s":
                set = _character_classes_js__WEBPACK_IMPORTED_MODULE_1__.whitespaceCodes;
                break;
            case "S":
                set = _character_classes_js__WEBPACK_IMPORTED_MODULE_1__.whitespaceCodes;
                complement = true;
                break;
            case "w":
                set = _character_classes_js__WEBPACK_IMPORTED_MODULE_1__.wordCharCodes;
                break;
            case "W":
                set = _character_classes_js__WEBPACK_IMPORTED_MODULE_1__.wordCharCodes;
                complement = true;
                break;
        }
        // istanbul ignore else
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_EXISTS)(set)) {
            return { type: "Set", value: set, complement: complement };
        }
        // istanbul ignore next
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_NEVER_REACH_HERE)();
    }
    controlEscapeAtom() {
        let escapeCode;
        switch (this.popChar()) {
            case "f":
                escapeCode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\f");
                break;
            case "n":
                escapeCode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\n");
                break;
            case "r":
                escapeCode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\r");
                break;
            case "t":
                escapeCode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\t");
                break;
            case "v":
                escapeCode = (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\v");
                break;
        }
        // istanbul ignore else
        if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_EXISTS)(escapeCode)) {
            return { type: "Character", value: escapeCode };
        }
        // istanbul ignore next
        return (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.ASSERT_NEVER_REACH_HERE)();
    }
    controlLetterEscapeAtom() {
        this.consumeChar("c");
        const letter = this.popChar();
        if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
        }
        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;
        return { type: "Character", value: letterCode };
    }
    nulCharacterAtom() {
        // TODO implement '[lookahead  DecimalDigit]'
        // TODO: for the deprecated octal escape sequence
        this.consumeChar("0");
        return { type: "Character", value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\0") };
    }
    hexEscapeSequenceAtom() {
        this.consumeChar("x");
        return this.parseHexDigits(2);
    }
    regExpUnicodeEscapeSequenceAtom() {
        this.consumeChar("u");
        return this.parseHexDigits(4);
    }
    identityEscapeAtom() {
        // TODO: implement "SourceCharacter but not UnicodeIDContinue"
        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
        const escapedChar = this.popChar();
        return { type: "Character", value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)(escapedChar) };
    }
    classPatternCharacterAtom() {
        switch (this.peekChar()) {
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case "]":
                throw Error("TBD");
            default:
                const nextChar = this.popChar();
                return { type: "Character", value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)(nextChar) };
        }
    }
    characterClass() {
        const set = [];
        let complement = false;
        this.consumeChar("[");
        if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
        }
        while (this.isClassAtom()) {
            const from = this.classAtom();
            const isFromSingleChar = from.type === "Character";
            if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isCharacter)(from) && this.isRangeDash()) {
                this.consumeChar("-");
                const to = this.classAtom();
                const isToSingleChar = to.type === "Character";
                // a range can only be used when both sides are single characters
                if ((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.isCharacter)(to)) {
                    if (to.value < from.value) {
                        throw Error("Range out of order in character class");
                    }
                    set.push({ from: from.value, to: to.value });
                }
                else {
                    // literal dash
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.insertToSet)(from.value, set);
                    set.push((0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("-"));
                    (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.insertToSet)(to.value, set);
                }
            }
            else {
                (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.insertToSet)(from.value, set);
            }
        }
        this.consumeChar("]");
        return { type: "Set", complement: complement, value: set };
    }
    classAtom() {
        switch (this.peekChar()) {
            // istanbul ignore next
            case "]":
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
                throw Error("TBD");
            case "\\":
                return this.classEscape();
            default:
                return this.classPatternCharacterAtom();
        }
    }
    classEscape() {
        this.consumeChar("\\");
        switch (this.peekChar()) {
            // Matches a backspace.
            // (Not to be confused with \b word boundary outside characterClass)
            case "b":
                this.consumeChar("b");
                return { type: "Character", value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)("\u0008") };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
                return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
                return this.controlEscapeAtom();
            case "c":
                return this.controlLetterEscapeAtom();
            case "0":
                return this.nulCharacterAtom();
            case "x":
                return this.hexEscapeSequenceAtom();
            case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
            default:
                return this.identityEscapeAtom();
        }
    }
    group() {
        let capturing = true;
        this.consumeChar("(");
        switch (this.peekChar(0)) {
            case "?":
                this.consumeChar("?");
                this.consumeChar(":");
                capturing = false;
                break;
            default:
                this.groupIdx++;
                break;
        }
        const value = this.disjunction();
        this.consumeChar(")");
        const groupAst = {
            type: "Group",
            capturing: capturing,
            value: value,
        };
        if (capturing) {
            groupAst["idx"] = this.groupIdx;
        }
        return groupAst;
    }
    positiveInteger() {
        let number = this.popChar();
        // istanbul ignore next - can't ever get here due to previous lookahead checks
        // still implementing this error checking in case this ever changes.
        if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
        }
        while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
        }
        return parseInt(number, 10);
    }
    integerIncludingZero() {
        let number = this.popChar();
        if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
        }
        while (decimalPattern.test(this.peekChar(0))) {
            number += this.popChar();
        }
        return parseInt(number, 10);
    }
    patternCharacter() {
        const nextChar = this.popChar();
        switch (nextChar) {
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "^":
            // istanbul ignore next
            case "$":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case ".":
            // istanbul ignore next
            case "*":
            // istanbul ignore next
            case "+":
            // istanbul ignore next
            case "?":
            // istanbul ignore next
            case "(":
            // istanbul ignore next
            case ")":
            // istanbul ignore next
            case "[":
            // istanbul ignore next
            case "|":
                // istanbul ignore next
                throw Error("TBD");
            default:
                return { type: "Character", value: (0,_utils_js__WEBPACK_IMPORTED_MODULE_0__.cc)(nextChar) };
        }
    }
    isRegExpFlag() {
        switch (this.peekChar(0)) {
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
                return true;
            default:
                return false;
        }
    }
    isRangeDash() {
        return this.peekChar() === "-" && this.isClassAtom(1);
    }
    isDigit() {
        return decimalPattern.test(this.peekChar(0));
    }
    isClassAtom(howMuch = 0) {
        switch (this.peekChar(howMuch)) {
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
                return false;
            default:
                return true;
        }
    }
    isTerm() {
        return this.isAtom() || this.isAssertion();
    }
    isAtom() {
        if (this.isPatternCharacter()) {
            return true;
        }
        switch (this.peekChar(0)) {
            case ".":
            case "\\": // atomEscape
            case "[": // characterClass
            // TODO: isAtom must be called before isAssertion - disambiguate
            case "(": // group
                return true;
            default:
                return false;
        }
    }
    isAssertion() {
        switch (this.peekChar(0)) {
            case "^":
            case "$":
                return true;
            // '\b' or '\B'
            case "\\":
                switch (this.peekChar(1)) {
                    case "b":
                    case "B":
                        return true;
                    default:
                        return false;
                }
            // '(?=' or '(?!'
            case "(":
                return (this.peekChar(1) === "?" &&
                    (this.peekChar(2) === "=" || this.peekChar(2) === "!"));
            default:
                return false;
        }
    }
    isQuantifier() {
        const prevState = this.saveState();
        try {
            return this.quantifier(true) !== undefined;
        }
        catch (e) {
            return false;
        }
        finally {
            this.restoreState(prevState);
        }
    }
    isPatternCharacter() {
        switch (this.peekChar()) {
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
                return false;
            default:
                return true;
        }
    }
    parseHexDigits(howMany) {
        let hexString = "";
        for (let i = 0; i < howMany; i++) {
            const hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
                throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
        }
        const charCode = parseInt(hexString, 16);
        return { type: "Character", value: charCode };
    }
    peekChar(howMuch = 0) {
        return this.input[this.idx + howMuch];
    }
    popChar() {
        const nextChar = this.peekChar(0);
        this.consumeChar(undefined);
        return nextChar;
    }
    consumeChar(char) {
        if (char !== undefined && this.input[this.idx] !== char) {
            throw Error("Expected: '" +
                char +
                "' but found: '" +
                this.input[this.idx] +
                "' at offset: " +
                this.idx);
        }
        if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
        }
        this.idx++;
    }
    loc(begin) {
        return { begin: begin, end: this.idx };
    }
}
//# sourceMappingURL=regexp-parser.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ASSERT_EXISTS: () => (/* binding */ ASSERT_EXISTS),
/* harmony export */   ASSERT_NEVER_REACH_HERE: () => (/* binding */ ASSERT_NEVER_REACH_HERE),
/* harmony export */   addFlag: () => (/* binding */ addFlag),
/* harmony export */   cc: () => (/* binding */ cc),
/* harmony export */   insertToSet: () => (/* binding */ insertToSet),
/* harmony export */   isCharacter: () => (/* binding */ isCharacter)
/* harmony export */ });
function cc(char) {
    return char.charCodeAt(0);
}
function insertToSet(item, set) {
    if (Array.isArray(item)) {
        item.forEach(function (subItem) {
            set.push(subItem);
        });
    }
    else {
        set.push(item);
    }
}
function addFlag(flagObj, flagKey) {
    if (flagObj[flagKey] === true) {
        throw "duplicate flag " + flagKey;
    }
    const x = flagObj[flagKey];
    flagObj[flagKey] = true;
}
function ASSERT_EXISTS(obj) {
    // istanbul ignore next
    if (obj === undefined) {
        throw Error("Internal Error - Should never get here!");
    }
    return true;
}
// istanbul ignore next
function ASSERT_NEVER_REACH_HERE() {
    throw Error("Internal Error - Should never get here!");
}
function isCharacter(obj) {
    return obj["type"] === "Character";
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/utils/lib/src/api.js":
/*!*******************************************************!*\
  !*** ./node_modules/@chevrotain/utils/lib/src/api.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PRINT_ERROR: () => (/* reexport safe */ _print_js__WEBPACK_IMPORTED_MODULE_0__.PRINT_ERROR),
/* harmony export */   PRINT_WARNING: () => (/* reexport safe */ _print_js__WEBPACK_IMPORTED_MODULE_0__.PRINT_WARNING),
/* harmony export */   timer: () => (/* reexport safe */ _timer_js__WEBPACK_IMPORTED_MODULE_1__.timer),
/* harmony export */   toFastProperties: () => (/* reexport safe */ _to_fast_properties_js__WEBPACK_IMPORTED_MODULE_2__.toFastProperties)
/* harmony export */ });
/* harmony import */ var _print_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./print.js */ "./node_modules/@chevrotain/utils/lib/src/print.js");
/* harmony import */ var _timer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./timer.js */ "./node_modules/@chevrotain/utils/lib/src/timer.js");
/* harmony import */ var _to_fast_properties_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./to-fast-properties.js */ "./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js");



//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/utils/lib/src/print.js":
/*!*********************************************************!*\
  !*** ./node_modules/@chevrotain/utils/lib/src/print.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PRINT_ERROR: () => (/* binding */ PRINT_ERROR),
/* harmony export */   PRINT_WARNING: () => (/* binding */ PRINT_WARNING)
/* harmony export */ });
function PRINT_ERROR(msg) {
    /* istanbul ignore else - can't override global.console in node.js */
    if (console && console.error) {
        console.error(`Error: ${msg}`);
    }
}
function PRINT_WARNING(msg) {
    /* istanbul ignore else - can't override global.console in node.js*/
    if (console && console.warn) {
        // TODO: modify docs accordingly
        console.warn(`Warning: ${msg}`);
    }
}
//# sourceMappingURL=print.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/utils/lib/src/timer.js":
/*!*********************************************************!*\
  !*** ./node_modules/@chevrotain/utils/lib/src/timer.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   timer: () => (/* binding */ timer)
/* harmony export */ });
function timer(func) {
    const start = new Date().getTime();
    const val = func();
    const end = new Date().getTime();
    const total = end - start;
    return { time: total, value: val };
}
//# sourceMappingURL=timer.js.map

/***/ }),

/***/ "./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@chevrotain/utils/lib/src/to-fast-properties.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   toFastProperties: () => (/* binding */ toFastProperties)
/* harmony export */ });
// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216
function toFastProperties(toBecomeFast) {
    function FakeConstructor() { }
    // If our object is used as a constructor, it would receive
    FakeConstructor.prototype = toBecomeFast;
    const fakeInstance = new FakeConstructor();
    function fakeAccess() {
        return typeof fakeInstance.bar;
    }
    // help V8 understand this is a "real" prototype by actually using
    // the fake instance.
    fakeAccess();
    fakeAccess();
    // Always true condition to suppress the Firefox warning of unreachable
    // code after a return statement.
    if (true)
        return toBecomeFast;
    // Eval prevents optimization of this method (even though this is dead code)
    // - https://esbuild.github.io/content-types/#direct-eval
    /* istanbul ignore next */
    // tslint:disable-next-line
    (0, eval)(toBecomeFast);
}
//# sourceMappingURL=to-fast-properties.js.map

/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GitGraphModule: () => (/* binding */ GitGraphModule),
/* harmony export */   createGitGraphServices: () => (/* binding */ createGitGraphServices)
/* harmony export */ });
/* harmony import */ var _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/default-module.js");


// src/language/gitGraph/module.ts


// src/language/gitGraph/tokenBuilder.ts
var GitGraphTokenBuilder = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidTokenBuilder {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "GitGraphTokenBuilder");
  }
  constructor() {
    super(["gitGraph"]);
  }
};

// src/language/gitGraph/module.ts
var GitGraphModule = {
  parser: {
    TokenBuilder: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new GitGraphTokenBuilder(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.CommonValueConverter(), "ValueConverter")
  }
};
function createGitGraphServices(context = langium__WEBPACK_IMPORTED_MODULE_1__.EmptyFileSystem) {
  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultSharedCoreModule)(context),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.MermaidGeneratedSharedModule
  );
  const GitGraph = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultCoreModule)({ shared }),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.GitGraphGeneratedModule,
    GitGraphModule
  );
  shared.ServiceRegistry.register(GitGraph);
  return { shared, GitGraph };
}
(0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(createGitGraphServices, "createGitGraphServices");




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RadarModule: () => (/* binding */ RadarModule),
/* harmony export */   createRadarServices: () => (/* binding */ createRadarServices)
/* harmony export */ });
/* harmony import */ var _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/default-module.js");


// src/language/radar/module.ts


// src/language/radar/tokenBuilder.ts
var RadarTokenBuilder = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidTokenBuilder {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "RadarTokenBuilder");
  }
  constructor() {
    super(["radar-beta"]);
  }
};

// src/language/radar/module.ts
var RadarModule = {
  parser: {
    TokenBuilder: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new RadarTokenBuilder(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.CommonValueConverter(), "ValueConverter")
  }
};
function createRadarServices(context = langium__WEBPACK_IMPORTED_MODULE_1__.EmptyFileSystem) {
  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultSharedCoreModule)(context),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.MermaidGeneratedSharedModule
  );
  const Radar = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultCoreModule)({ shared }),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.RadarGeneratedModule,
    RadarModule
  );
  shared.ServiceRegistry.register(Radar);
  return { shared, Radar };
}
(0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(createRadarServices, "createRadarServices");




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractMermaidTokenBuilder: () => (/* binding */ AbstractMermaidTokenBuilder),
/* harmony export */   AbstractMermaidValueConverter: () => (/* binding */ AbstractMermaidValueConverter),
/* harmony export */   Architecture: () => (/* binding */ Architecture),
/* harmony export */   ArchitectureGeneratedModule: () => (/* binding */ ArchitectureGeneratedModule),
/* harmony export */   Branch: () => (/* binding */ Branch),
/* harmony export */   Commit: () => (/* binding */ Commit),
/* harmony export */   CommonTokenBuilder: () => (/* binding */ CommonTokenBuilder),
/* harmony export */   CommonValueConverter: () => (/* binding */ CommonValueConverter),
/* harmony export */   GitGraph: () => (/* binding */ GitGraph),
/* harmony export */   GitGraphGeneratedModule: () => (/* binding */ GitGraphGeneratedModule),
/* harmony export */   Info: () => (/* binding */ Info),
/* harmony export */   InfoGeneratedModule: () => (/* binding */ InfoGeneratedModule),
/* harmony export */   Merge: () => (/* binding */ Merge),
/* harmony export */   MermaidGeneratedSharedModule: () => (/* binding */ MermaidGeneratedSharedModule),
/* harmony export */   Packet: () => (/* binding */ Packet),
/* harmony export */   PacketBlock: () => (/* binding */ PacketBlock),
/* harmony export */   PacketGeneratedModule: () => (/* binding */ PacketGeneratedModule),
/* harmony export */   Pie: () => (/* binding */ Pie),
/* harmony export */   PieGeneratedModule: () => (/* binding */ PieGeneratedModule),
/* harmony export */   PieSection: () => (/* binding */ PieSection),
/* harmony export */   Radar: () => (/* binding */ Radar),
/* harmony export */   RadarGeneratedModule: () => (/* binding */ RadarGeneratedModule),
/* harmony export */   Statement: () => (/* binding */ Statement),
/* harmony export */   __name: () => (/* binding */ __name),
/* harmony export */   isArchitecture: () => (/* binding */ isArchitecture),
/* harmony export */   isBranch: () => (/* binding */ isBranch),
/* harmony export */   isCommit: () => (/* binding */ isCommit),
/* harmony export */   isCommon: () => (/* binding */ isCommon),
/* harmony export */   isGitGraph: () => (/* binding */ isGitGraph),
/* harmony export */   isInfo: () => (/* binding */ isInfo),
/* harmony export */   isMerge: () => (/* binding */ isMerge),
/* harmony export */   isPacket: () => (/* binding */ isPacket),
/* harmony export */   isPacketBlock: () => (/* binding */ isPacketBlock),
/* harmony export */   isPie: () => (/* binding */ isPie),
/* harmony export */   isPieSection: () => (/* binding */ isPieSection)
/* harmony export */ });
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/utils/grammar-loader.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/parser/value-converter.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/parser/token-builder.js");
var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/language/generated/ast.ts

var Statement = "Statement";
var Architecture = "Architecture";
function isArchitecture(item) {
  return reflection.isInstance(item, Architecture);
}
__name(isArchitecture, "isArchitecture");
var Axis = "Axis";
var Branch = "Branch";
function isBranch(item) {
  return reflection.isInstance(item, Branch);
}
__name(isBranch, "isBranch");
var Checkout = "Checkout";
var CherryPicking = "CherryPicking";
var Commit = "Commit";
function isCommit(item) {
  return reflection.isInstance(item, Commit);
}
__name(isCommit, "isCommit");
var Common = "Common";
function isCommon(item) {
  return reflection.isInstance(item, Common);
}
__name(isCommon, "isCommon");
var Curve = "Curve";
var Edge = "Edge";
var Entry = "Entry";
var GitGraph = "GitGraph";
function isGitGraph(item) {
  return reflection.isInstance(item, GitGraph);
}
__name(isGitGraph, "isGitGraph");
var Group = "Group";
var Info = "Info";
function isInfo(item) {
  return reflection.isInstance(item, Info);
}
__name(isInfo, "isInfo");
var Junction = "Junction";
var Merge = "Merge";
function isMerge(item) {
  return reflection.isInstance(item, Merge);
}
__name(isMerge, "isMerge");
var Option = "Option";
var Packet = "Packet";
function isPacket(item) {
  return reflection.isInstance(item, Packet);
}
__name(isPacket, "isPacket");
var PacketBlock = "PacketBlock";
function isPacketBlock(item) {
  return reflection.isInstance(item, PacketBlock);
}
__name(isPacketBlock, "isPacketBlock");
var Pie = "Pie";
function isPie(item) {
  return reflection.isInstance(item, Pie);
}
__name(isPie, "isPie");
var PieSection = "PieSection";
function isPieSection(item) {
  return reflection.isInstance(item, PieSection);
}
__name(isPieSection, "isPieSection");
var Radar = "Radar";
var Service = "Service";
var Direction = "Direction";
var MermaidAstReflection = class extends langium__WEBPACK_IMPORTED_MODULE_0__.AbstractAstReflection {
  static {
    __name(this, "MermaidAstReflection");
  }
  getAllTypes() {
    return [Architecture, Axis, Branch, Checkout, CherryPicking, Commit, Common, Curve, Direction, Edge, Entry, GitGraph, Group, Info, Junction, Merge, Option, Packet, PacketBlock, Pie, PieSection, Radar, Service, Statement];
  }
  computeIsSubtype(subtype, supertype) {
    switch (subtype) {
      case Branch:
      case Checkout:
      case CherryPicking:
      case Commit:
      case Merge: {
        return this.isSubtype(Statement, supertype);
      }
      case Direction: {
        return this.isSubtype(GitGraph, supertype);
      }
      default: {
        return false;
      }
    }
  }
  getReferenceType(refInfo) {
    const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
    switch (referenceId) {
      case "Entry:axis": {
        return Axis;
      }
      default: {
        throw new Error(`${referenceId} is not a valid reference id.`);
      }
    }
  }
  getTypeMetaData(type) {
    switch (type) {
      case Architecture: {
        return {
          name: Architecture,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "edges", defaultValue: [] },
            { name: "groups", defaultValue: [] },
            { name: "junctions", defaultValue: [] },
            { name: "services", defaultValue: [] },
            { name: "title" }
          ]
        };
      }
      case Axis: {
        return {
          name: Axis,
          properties: [
            { name: "label" },
            { name: "name" }
          ]
        };
      }
      case Branch: {
        return {
          name: Branch,
          properties: [
            { name: "name" },
            { name: "order" }
          ]
        };
      }
      case Checkout: {
        return {
          name: Checkout,
          properties: [
            { name: "branch" }
          ]
        };
      }
      case CherryPicking: {
        return {
          name: CherryPicking,
          properties: [
            { name: "id" },
            { name: "parent" },
            { name: "tags", defaultValue: [] }
          ]
        };
      }
      case Commit: {
        return {
          name: Commit,
          properties: [
            { name: "id" },
            { name: "message" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      }
      case Common: {
        return {
          name: Common,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" }
          ]
        };
      }
      case Curve: {
        return {
          name: Curve,
          properties: [
            { name: "entries", defaultValue: [] },
            { name: "label" },
            { name: "name" }
          ]
        };
      }
      case Edge: {
        return {
          name: Edge,
          properties: [
            { name: "lhsDir" },
            { name: "lhsGroup", defaultValue: false },
            { name: "lhsId" },
            { name: "lhsInto", defaultValue: false },
            { name: "rhsDir" },
            { name: "rhsGroup", defaultValue: false },
            { name: "rhsId" },
            { name: "rhsInto", defaultValue: false },
            { name: "title" }
          ]
        };
      }
      case Entry: {
        return {
          name: Entry,
          properties: [
            { name: "axis" },
            { name: "value" }
          ]
        };
      }
      case GitGraph: {
        return {
          name: GitGraph,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      }
      case Group: {
        return {
          name: Group,
          properties: [
            { name: "icon" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      }
      case Info: {
        return {
          name: Info,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "title" }
          ]
        };
      }
      case Junction: {
        return {
          name: Junction,
          properties: [
            { name: "id" },
            { name: "in" }
          ]
        };
      }
      case Merge: {
        return {
          name: Merge,
          properties: [
            { name: "branch" },
            { name: "id" },
            { name: "tags", defaultValue: [] },
            { name: "type" }
          ]
        };
      }
      case Option: {
        return {
          name: Option,
          properties: [
            { name: "name" },
            { name: "value", defaultValue: false }
          ]
        };
      }
      case Packet: {
        return {
          name: Packet,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "blocks", defaultValue: [] },
            { name: "title" }
          ]
        };
      }
      case PacketBlock: {
        return {
          name: PacketBlock,
          properties: [
            { name: "end" },
            { name: "label" },
            { name: "start" }
          ]
        };
      }
      case Pie: {
        return {
          name: Pie,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "sections", defaultValue: [] },
            { name: "showData", defaultValue: false },
            { name: "title" }
          ]
        };
      }
      case PieSection: {
        return {
          name: PieSection,
          properties: [
            { name: "label" },
            { name: "value" }
          ]
        };
      }
      case Radar: {
        return {
          name: Radar,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "axes", defaultValue: [] },
            { name: "curves", defaultValue: [] },
            { name: "options", defaultValue: [] },
            { name: "title" }
          ]
        };
      }
      case Service: {
        return {
          name: Service,
          properties: [
            { name: "icon" },
            { name: "iconText" },
            { name: "id" },
            { name: "in" },
            { name: "title" }
          ]
        };
      }
      case Direction: {
        return {
          name: Direction,
          properties: [
            { name: "accDescr" },
            { name: "accTitle" },
            { name: "dir" },
            { name: "statements", defaultValue: [] },
            { name: "title" }
          ]
        };
      }
      default: {
        return {
          name: type,
          properties: []
        };
      }
    }
  }
};
var reflection = new MermaidAstReflection();

// src/language/generated/grammar.ts

var loadedInfoGrammar;
var InfoGrammar = /* @__PURE__ */ __name(() => loadedInfoGrammar ?? (loadedInfoGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_1__.loadGrammarFromJson)('{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}')), "InfoGrammar");
var loadedPacketGrammar;
var PacketGrammar = /* @__PURE__ */ __name(() => loadedPacketGrammar ?? (loadedPacketGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_1__.loadGrammarFromJson)(`{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"packet-beta"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"+"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"?"},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}`)), "PacketGrammar");
var loadedPieGrammar;
var PieGrammar = /* @__PURE__ */ __name(() => loadedPieGrammar ?? (loadedPieGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_1__.loadGrammarFromJson)('{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]},"cardinality":"+"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"PIE_SECTION_LABEL","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]+\\"/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"PIE_SECTION_VALUE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/(0|[1-9][0-9]*)(\\\\.[0-9]+)?/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}')), "PieGrammar");
var loadedArchitectureGrammar;
var ArchitectureGrammar = /* @__PURE__ */ __name(() => loadedArchitectureGrammar ?? (loadedArchitectureGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_1__.loadGrammarFromJson)('{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_ID","definition":{"$type":"RegexToken","regex":"/[\\\\w]+/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TEXT_ICON","definition":{"$type":"RegexToken","regex":"/\\\\(\\"[^\\"]+\\"\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"types":[],"usedGrammars":[]}')), "ArchitectureGrammar");
var loadedGitGraphGrammar;
var GitGraphGrammar = /* @__PURE__ */ __name(() => loadedGitGraphGrammar ?? (loadedGitGraphGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_1__.loadGrammarFromJson)(`{"$type":"Grammar","isDeclared":true,"name":"GitGraph","interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"*"}]}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+(?=\\\\s)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[]}`)), "GitGraphGrammar");
var loadedRadarGrammar;
var RadarGrammar = /* @__PURE__ */ __name(() => loadedRadarGrammar ?? (loadedRadarGrammar = (0,langium__WEBPACK_IMPORTED_MODULE_1__.loadGrammarFromJson)(`{"$type":"Grammar","isDeclared":true,"name":"Radar","interfaces":[{"$type":"Interface","name":"Common","attributes":[{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@12"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@12"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/(0|[1-9][0-9]*)(\\\\.[0-9]+)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9\\\\-_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[]}`)), "RadarGrammar");

// src/language/generated/module.ts
var InfoLanguageMetaData = {
  languageId: "info",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: false,
  mode: "production"
};
var PacketLanguageMetaData = {
  languageId: "packet",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: false,
  mode: "production"
};
var PieLanguageMetaData = {
  languageId: "pie",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: false,
  mode: "production"
};
var ArchitectureLanguageMetaData = {
  languageId: "architecture",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: false,
  mode: "production"
};
var GitGraphLanguageMetaData = {
  languageId: "gitGraph",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: false,
  mode: "production"
};
var RadarLanguageMetaData = {
  languageId: "radar",
  fileExtensions: [".mmd", ".mermaid"],
  caseInsensitive: false,
  mode: "production"
};
var MermaidGeneratedSharedModule = {
  AstReflection: /* @__PURE__ */ __name(() => new MermaidAstReflection(), "AstReflection")
};
var InfoGeneratedModule = {
  Grammar: /* @__PURE__ */ __name(() => InfoGrammar(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ __name(() => InfoLanguageMetaData, "LanguageMetaData"),
  parser: {}
};
var PacketGeneratedModule = {
  Grammar: /* @__PURE__ */ __name(() => PacketGrammar(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ __name(() => PacketLanguageMetaData, "LanguageMetaData"),
  parser: {}
};
var PieGeneratedModule = {
  Grammar: /* @__PURE__ */ __name(() => PieGrammar(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ __name(() => PieLanguageMetaData, "LanguageMetaData"),
  parser: {}
};
var ArchitectureGeneratedModule = {
  Grammar: /* @__PURE__ */ __name(() => ArchitectureGrammar(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ __name(() => ArchitectureLanguageMetaData, "LanguageMetaData"),
  parser: {}
};
var GitGraphGeneratedModule = {
  Grammar: /* @__PURE__ */ __name(() => GitGraphGrammar(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ __name(() => GitGraphLanguageMetaData, "LanguageMetaData"),
  parser: {}
};
var RadarGeneratedModule = {
  Grammar: /* @__PURE__ */ __name(() => RadarGrammar(), "Grammar"),
  LanguageMetaData: /* @__PURE__ */ __name(() => RadarLanguageMetaData, "LanguageMetaData"),
  parser: {}
};

// src/language/common/valueConverter.ts


// src/language/common/matcher.ts
var accessibilityDescrRegex = /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/;
var accessibilityTitleRegex = /accTitle[\t ]*:([^\n\r]*)/;
var titleRegex = /title([\t ][^\n\r]*|)/;

// src/language/common/valueConverter.ts
var rulesRegexes = {
  ACC_DESCR: accessibilityDescrRegex,
  ACC_TITLE: accessibilityTitleRegex,
  TITLE: titleRegex
};
var AbstractMermaidValueConverter = class extends langium__WEBPACK_IMPORTED_MODULE_2__.DefaultValueConverter {
  static {
    __name(this, "AbstractMermaidValueConverter");
  }
  runConverter(rule, input, cstNode) {
    let value = this.runCommonConverter(rule, input, cstNode);
    if (value === void 0) {
      value = this.runCustomConverter(rule, input, cstNode);
    }
    if (value === void 0) {
      return super.runConverter(rule, input, cstNode);
    }
    return value;
  }
  runCommonConverter(rule, input, _cstNode) {
    const regex = rulesRegexes[rule.name];
    if (regex === void 0) {
      return void 0;
    }
    const match = regex.exec(input);
    if (match === null) {
      return void 0;
    }
    if (match[1] !== void 0) {
      return match[1].trim().replace(/[\t ]{2,}/gm, " ");
    }
    if (match[2] !== void 0) {
      return match[2].replace(/^\s*/gm, "").replace(/\s+$/gm, "").replace(/[\t ]{2,}/gm, " ").replace(/[\n\r]{2,}/gm, "\n");
    }
    return void 0;
  }
};
var CommonValueConverter = class extends AbstractMermaidValueConverter {
  static {
    __name(this, "CommonValueConverter");
  }
  runCustomConverter(_rule, _input, _cstNode) {
    return void 0;
  }
};

// src/language/common/tokenBuilder.ts

var AbstractMermaidTokenBuilder = class extends langium__WEBPACK_IMPORTED_MODULE_3__.DefaultTokenBuilder {
  static {
    __name(this, "AbstractMermaidTokenBuilder");
  }
  constructor(keywords) {
    super();
    this.keywords = new Set(keywords);
  }
  buildKeywordTokens(rules, terminalTokens, options) {
    const tokenTypes = super.buildKeywordTokens(rules, terminalTokens, options);
    tokenTypes.forEach((tokenType) => {
      if (this.keywords.has(tokenType.name) && tokenType.PATTERN !== void 0) {
        tokenType.PATTERN = new RegExp(tokenType.PATTERN.toString() + "(?:(?=%%)|(?!\\S))");
      }
    });
    return tokenTypes;
  }
};
var CommonTokenBuilder = class extends AbstractMermaidTokenBuilder {
  static {
    __name(this, "CommonTokenBuilder");
  }
};




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ArchitectureModule: () => (/* binding */ ArchitectureModule),
/* harmony export */   createArchitectureServices: () => (/* binding */ createArchitectureServices)
/* harmony export */ });
/* harmony import */ var _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/default-module.js");


// src/language/architecture/module.ts


// src/language/architecture/tokenBuilder.ts
var ArchitectureTokenBuilder = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidTokenBuilder {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "ArchitectureTokenBuilder");
  }
  constructor() {
    super(["architecture"]);
  }
};

// src/language/architecture/valueConverter.ts
var ArchitectureValueConverter = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidValueConverter {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "ArchitectureValueConverter");
  }
  runCustomConverter(rule, input, _cstNode) {
    if (rule.name === "ARCH_ICON") {
      return input.replace(/[()]/g, "").trim();
    } else if (rule.name === "ARCH_TEXT_ICON") {
      return input.replace(/["()]/g, "");
    } else if (rule.name === "ARCH_TITLE") {
      return input.replace(/[[\]]/g, "").trim();
    }
    return void 0;
  }
};

// src/language/architecture/module.ts
var ArchitectureModule = {
  parser: {
    TokenBuilder: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new ArchitectureTokenBuilder(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new ArchitectureValueConverter(), "ValueConverter")
  }
};
function createArchitectureServices(context = langium__WEBPACK_IMPORTED_MODULE_1__.EmptyFileSystem) {
  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultSharedCoreModule)(context),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.MermaidGeneratedSharedModule
  );
  const Architecture = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultCoreModule)({ shared }),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.ArchitectureGeneratedModule,
    ArchitectureModule
  );
  shared.ServiceRegistry.register(Architecture);
  return { shared, Architecture };
}
(0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(createArchitectureServices, "createArchitectureServices");




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   InfoModule: () => (/* binding */ InfoModule),
/* harmony export */   createInfoServices: () => (/* binding */ createInfoServices)
/* harmony export */ });
/* harmony import */ var _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/default-module.js");


// src/language/info/module.ts


// src/language/info/tokenBuilder.ts
var InfoTokenBuilder = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidTokenBuilder {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "InfoTokenBuilder");
  }
  constructor() {
    super(["info", "showInfo"]);
  }
};

// src/language/info/module.ts
var InfoModule = {
  parser: {
    TokenBuilder: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new InfoTokenBuilder(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.CommonValueConverter(), "ValueConverter")
  }
};
function createInfoServices(context = langium__WEBPACK_IMPORTED_MODULE_1__.EmptyFileSystem) {
  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultSharedCoreModule)(context),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.MermaidGeneratedSharedModule
  );
  const Info = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultCoreModule)({ shared }),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.InfoGeneratedModule,
    InfoModule
  );
  shared.ServiceRegistry.register(Info);
  return { shared, Info };
}
(0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(createInfoServices, "createInfoServices");




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PieModule: () => (/* binding */ PieModule),
/* harmony export */   createPieServices: () => (/* binding */ createPieServices)
/* harmony export */ });
/* harmony import */ var _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/default-module.js");


// src/language/pie/module.ts


// src/language/pie/tokenBuilder.ts
var PieTokenBuilder = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidTokenBuilder {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "PieTokenBuilder");
  }
  constructor() {
    super(["pie", "showData"]);
  }
};

// src/language/pie/valueConverter.ts
var PieValueConverter = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidValueConverter {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "PieValueConverter");
  }
  runCustomConverter(rule, input, _cstNode) {
    if (rule.name !== "PIE_SECTION_LABEL") {
      return void 0;
    }
    return input.replace(/"/g, "").trim();
  }
};

// src/language/pie/module.ts
var PieModule = {
  parser: {
    TokenBuilder: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new PieTokenBuilder(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new PieValueConverter(), "ValueConverter")
  }
};
function createPieServices(context = langium__WEBPACK_IMPORTED_MODULE_1__.EmptyFileSystem) {
  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultSharedCoreModule)(context),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.MermaidGeneratedSharedModule
  );
  const Pie = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultCoreModule)({ shared }),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.PieGeneratedModule,
    PieModule
  );
  shared.ServiceRegistry.register(Pie);
  return { shared, Pie };
}
(0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(createPieServices, "createPieServices");




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs":
/*!********************************************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PacketModule: () => (/* binding */ PacketModule),
/* harmony export */   createPacketServices: () => (/* binding */ createPacketServices)
/* harmony export */ });
/* harmony import */ var _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var langium__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! langium */ "./node_modules/langium/lib/default-module.js");


// src/language/packet/module.ts


// src/language/packet/tokenBuilder.ts
var PacketTokenBuilder = class extends _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.AbstractMermaidTokenBuilder {
  static {
    (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(this, "PacketTokenBuilder");
  }
  constructor() {
    super(["packet-beta"]);
  }
};

// src/language/packet/module.ts
var PacketModule = {
  parser: {
    TokenBuilder: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new PacketTokenBuilder(), "TokenBuilder"),
    ValueConverter: /* @__PURE__ */ (0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(() => new _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.CommonValueConverter(), "ValueConverter")
  }
};
function createPacketServices(context = langium__WEBPACK_IMPORTED_MODULE_1__.EmptyFileSystem) {
  const shared = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultSharedCoreModule)(context),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.MermaidGeneratedSharedModule
  );
  const Packet = (0,langium__WEBPACK_IMPORTED_MODULE_2__.inject)(
    (0,langium__WEBPACK_IMPORTED_MODULE_3__.createDefaultCoreModule)({ shared }),
    _chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.PacketGeneratedModule,
    PacketModule
  );
  shared.ServiceRegistry.register(Packet);
  return { shared, Packet };
}
(0,_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_0__.__name)(createPacketServices, "createPacketServices");




/***/ }),

/***/ "./node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs":
/*!**********************************************************************!*\
  !*** ./node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractMermaidTokenBuilder: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.AbstractMermaidTokenBuilder),
/* harmony export */   AbstractMermaidValueConverter: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.AbstractMermaidValueConverter),
/* harmony export */   Architecture: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Architecture),
/* harmony export */   ArchitectureGeneratedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.ArchitectureGeneratedModule),
/* harmony export */   ArchitectureModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_C4OEIS7N_mjs__WEBPACK_IMPORTED_MODULE_4__.ArchitectureModule),
/* harmony export */   Branch: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Branch),
/* harmony export */   Commit: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Commit),
/* harmony export */   CommonTokenBuilder: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.CommonTokenBuilder),
/* harmony export */   CommonValueConverter: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.CommonValueConverter),
/* harmony export */   GitGraph: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.GitGraph),
/* harmony export */   GitGraphGeneratedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.GitGraphGeneratedModule),
/* harmony export */   GitGraphModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_2NYFTIL2_mjs__WEBPACK_IMPORTED_MODULE_0__.GitGraphModule),
/* harmony export */   Info: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Info),
/* harmony export */   InfoGeneratedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.InfoGeneratedModule),
/* harmony export */   InfoModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_EXZZNE6F_mjs__WEBPACK_IMPORTED_MODULE_1__.InfoModule),
/* harmony export */   Merge: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Merge),
/* harmony export */   MermaidGeneratedSharedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.MermaidGeneratedSharedModule),
/* harmony export */   MermaidParseError: () => (/* binding */ MermaidParseError),
/* harmony export */   Packet: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Packet),
/* harmony export */   PacketBlock: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.PacketBlock),
/* harmony export */   PacketGeneratedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.PacketGeneratedModule),
/* harmony export */   PacketModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_V4Q32G6S_mjs__WEBPACK_IMPORTED_MODULE_2__.PacketModule),
/* harmony export */   Pie: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Pie),
/* harmony export */   PieGeneratedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.PieGeneratedModule),
/* harmony export */   PieModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_ROXG7S4E_mjs__WEBPACK_IMPORTED_MODULE_3__.PieModule),
/* harmony export */   PieSection: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.PieSection),
/* harmony export */   Radar: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Radar),
/* harmony export */   RadarGeneratedModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.RadarGeneratedModule),
/* harmony export */   RadarModule: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_2O5ZK7RR_mjs__WEBPACK_IMPORTED_MODULE_5__.RadarModule),
/* harmony export */   Statement: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.Statement),
/* harmony export */   createArchitectureServices: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_C4OEIS7N_mjs__WEBPACK_IMPORTED_MODULE_4__.createArchitectureServices),
/* harmony export */   createGitGraphServices: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_2NYFTIL2_mjs__WEBPACK_IMPORTED_MODULE_0__.createGitGraphServices),
/* harmony export */   createInfoServices: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_EXZZNE6F_mjs__WEBPACK_IMPORTED_MODULE_1__.createInfoServices),
/* harmony export */   createPacketServices: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_V4Q32G6S_mjs__WEBPACK_IMPORTED_MODULE_2__.createPacketServices),
/* harmony export */   createPieServices: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_ROXG7S4E_mjs__WEBPACK_IMPORTED_MODULE_3__.createPieServices),
/* harmony export */   createRadarServices: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_2O5ZK7RR_mjs__WEBPACK_IMPORTED_MODULE_5__.createRadarServices),
/* harmony export */   isArchitecture: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isArchitecture),
/* harmony export */   isBranch: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isBranch),
/* harmony export */   isCommit: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isCommit),
/* harmony export */   isCommon: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isCommon),
/* harmony export */   isGitGraph: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isGitGraph),
/* harmony export */   isInfo: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isInfo),
/* harmony export */   isMerge: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isMerge),
/* harmony export */   isPacket: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isPacket),
/* harmony export */   isPacketBlock: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isPacketBlock),
/* harmony export */   isPie: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isPie),
/* harmony export */   isPieSection: () => (/* reexport safe */ _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.isPieSection),
/* harmony export */   parse: () => (/* binding */ parse)
/* harmony export */ });
/* harmony import */ var _chunks_mermaid_parser_core_chunk_2NYFTIL2_mjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2NYFTIL2.mjs");
/* harmony import */ var _chunks_mermaid_parser_core_chunk_EXZZNE6F_mjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-EXZZNE6F.mjs");
/* harmony import */ var _chunks_mermaid_parser_core_chunk_V4Q32G6S_mjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-V4Q32G6S.mjs");
/* harmony import */ var _chunks_mermaid_parser_core_chunk_ROXG7S4E_mjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-ROXG7S4E.mjs");
/* harmony import */ var _chunks_mermaid_parser_core_chunk_C4OEIS7N_mjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-C4OEIS7N.mjs");
/* harmony import */ var _chunks_mermaid_parser_core_chunk_2O5ZK7RR_mjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-2O5ZK7RR.mjs");
/* harmony import */ var _chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/chunk-7PKI6E2E.mjs");








// src/parse.ts
var parsers = {};
var initializers = {
  info: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async () => {
    const { createInfoServices: createInfoServices2 } = await __webpack_require__.e(/*! import() */ "node_modules_mermaid-js_parser_dist_chunks_mermaid-parser_core_info-4N47QTOZ_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/mermaid-parser.core/info-4N47QTOZ.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/info-4N47QTOZ.mjs"));
    const parser = createInfoServices2().Info.parser.LangiumParser;
    parsers.info = parser;
  }, "info"),
  packet: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async () => {
    const { createPacketServices: createPacketServices2 } = await __webpack_require__.e(/*! import() */ "node_modules_mermaid-js_parser_dist_chunks_mermaid-parser_core_packet-KVYON367_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/mermaid-parser.core/packet-KVYON367.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/packet-KVYON367.mjs"));
    const parser = createPacketServices2().Packet.parser.LangiumParser;
    parsers.packet = parser;
  }, "packet"),
  pie: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async () => {
    const { createPieServices: createPieServices2 } = await __webpack_require__.e(/*! import() */ "node_modules_mermaid-js_parser_dist_chunks_mermaid-parser_core_pie-R6RNRRYF_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/mermaid-parser.core/pie-R6RNRRYF.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/pie-R6RNRRYF.mjs"));
    const parser = createPieServices2().Pie.parser.LangiumParser;
    parsers.pie = parser;
  }, "pie"),
  architecture: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async () => {
    const { createArchitectureServices: createArchitectureServices2 } = await __webpack_require__.e(/*! import() */ "node_modules_mermaid-js_parser_dist_chunks_mermaid-parser_core_architecture-4AB2E3PP_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/mermaid-parser.core/architecture-4AB2E3PP.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/architecture-4AB2E3PP.mjs"));
    const parser = createArchitectureServices2().Architecture.parser.LangiumParser;
    parsers.architecture = parser;
  }, "architecture"),
  gitGraph: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async () => {
    const { createGitGraphServices: createGitGraphServices2 } = await __webpack_require__.e(/*! import() */ "node_modules_mermaid-js_parser_dist_chunks_mermaid-parser_core_gitGraph-O2Q2CXLX_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/mermaid-parser.core/gitGraph-O2Q2CXLX.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/gitGraph-O2Q2CXLX.mjs"));
    const parser = createGitGraphServices2().GitGraph.parser.LangiumParser;
    parsers.gitGraph = parser;
  }, "gitGraph"),
  radar: /* @__PURE__ */ (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(async () => {
    const { createRadarServices: createRadarServices2 } = await __webpack_require__.e(/*! import() */ "node_modules_mermaid-js_parser_dist_chunks_mermaid-parser_core_radar-MK3ICKWK_mjs").then(__webpack_require__.bind(__webpack_require__, /*! ./chunks/mermaid-parser.core/radar-MK3ICKWK.mjs */ "./node_modules/@mermaid-js/parser/dist/chunks/mermaid-parser.core/radar-MK3ICKWK.mjs"));
    const parser = createRadarServices2().Radar.parser.LangiumParser;
    parsers.radar = parser;
  }, "radar")
};
async function parse(diagramType, text) {
  const initializer = initializers[diagramType];
  if (!initializer) {
    throw new Error(`Unknown diagram type: ${diagramType}`);
  }
  if (!parsers[diagramType]) {
    await initializer();
  }
  const parser = parsers[diagramType];
  const result = parser.parse(text);
  if (result.lexerErrors.length > 0 || result.parserErrors.length > 0) {
    throw new MermaidParseError(result);
  }
  return result.value;
}
(0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(parse, "parse");
var MermaidParseError = class extends Error {
  constructor(result) {
    const lexerErrors = result.lexerErrors.map((err) => err.message).join("\n");
    const parserErrors = result.parserErrors.map((err) => err.message).join("\n");
    super(`Parsing failed: ${lexerErrors} ${parserErrors}`);
    this.result = result;
  }
  static {
    (0,_chunks_mermaid_parser_core_chunk_7PKI6E2E_mjs__WEBPACK_IMPORTED_MODULE_6__.__name)(this, "MermaidParseError");
  }
};



/***/ }),

/***/ "./node_modules/chevrotain-allstar/lib/all-star-lookahead.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/all-star-lookahead.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LLStarLookaheadStrategy: () => (/* binding */ LLStarLookaheadStrategy)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ "./node_modules/chevrotain/lib/src/api.js");
/* harmony import */ var _atn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./atn.js */ "./node_modules/chevrotain-allstar/lib/atn.js");
/* harmony import */ var _dfa_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./dfa.js */ "./node_modules/chevrotain-allstar/lib/dfa.js");
/* harmony import */ var lodash_es_min_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es/min.js */ "./node_modules/lodash-es/min.js");
/* harmony import */ var lodash_es_flatMap_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es/flatMap.js */ "./node_modules/lodash-es/flatMap.js");
/* harmony import */ var lodash_es_uniqBy_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es/uniqBy.js */ "./node_modules/lodash-es/uniqBy.js");
/* harmony import */ var lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es/map.js */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es_flatten_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es/flatten.js */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es/forEach.js */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es_isEmpty_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es/isEmpty.js */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es_reduce_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es/reduce.js */ "./node_modules/lodash-es/reduce.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/











function createDFACache(startState, decision) {
    const map = {};
    return (predicateSet) => {
        const key = predicateSet.toString();
        let existing = map[key];
        if (existing !== undefined) {
            return existing;
        }
        else {
            existing = {
                atnStartState: startState,
                decision,
                states: {}
            };
            map[key] = existing;
            return existing;
        }
    };
}
class PredicateSet {
    constructor() {
        this.predicates = [];
    }
    is(index) {
        return index >= this.predicates.length || this.predicates[index];
    }
    set(index, value) {
        this.predicates[index] = value;
    }
    toString() {
        let value = "";
        const size = this.predicates.length;
        for (let i = 0; i < size; i++) {
            value += this.predicates[i] === true ? "1" : "0";
        }
        return value;
    }
}
const EMPTY_PREDICATES = new PredicateSet();
class LLStarLookaheadStrategy extends chevrotain__WEBPACK_IMPORTED_MODULE_0__.LLkLookaheadStrategy {
    constructor(options) {
        var _a;
        super();
        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : ((message) => console.log(message));
    }
    initialize(options) {
        this.atn = (0,_atn_js__WEBPACK_IMPORTED_MODULE_1__.createATN)(options.rules);
        this.dfas = initATNSimulator(this.atn);
    }
    validateAmbiguousAlternationAlternatives() {
        return [];
    }
    validateEmptyOrAlternatives() {
        return [];
    }
    buildLookaheadForAlternation(options) {
        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;
        const dfas = this.dfas;
        const logging = this.logging;
        const key = (0,_atn_js__WEBPACK_IMPORTED_MODULE_1__.buildATNKey)(rule, 'Alternation', prodOccurrence);
        const decisionState = this.atn.decisionMap[key];
        const decisionIndex = decisionState.decision;
        const partialAlts = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.getLookaheadPaths)({
            maxLookahead: 1,
            occurrence: prodOccurrence,
            prodType: "Alternation",
            rule: rule
        }), (currAlt) => (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])(currAlt, (path) => path[0]));
        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {
            const choiceToAlt = (0,lodash_es_reduce_js__WEBPACK_IMPORTED_MODULE_4__["default"])(partialAlts, (result, currAlt, idx) => {
                (0,lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__["default"])(currAlt, (currTokType) => {
                    if (currTokType) {
                        result[currTokType.tokenTypeIdx] = idx;
                        (0,lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__["default"])(currTokType.categoryMatches, (currExtendingType) => {
                            result[currExtendingType] = idx;
                        });
                    }
                });
                return result;
            }, {});
            if (hasPredicates) {
                return function (orAlts) {
                    var _a;
                    const nextToken = this.LA(1);
                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];
                    if (orAlts !== undefined && prediction !== undefined) {
                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;
                        if (gate !== undefined && gate.call(this) === false) {
                            return undefined;
                        }
                    }
                    return prediction;
                };
            }
            else {
                return function () {
                    const nextToken = this.LA(1);
                    return choiceToAlt[nextToken.tokenTypeIdx];
                };
            }
        }
        else if (hasPredicates) {
            return function (orAlts) {
                const predicates = new PredicateSet();
                const length = orAlts === undefined ? 0 : orAlts.length;
                for (let i = 0; i < length; i++) {
                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;
                    predicates.set(i, gate === undefined || gate.call(this));
                }
                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);
                return typeof result === 'number' ? result : undefined;
            };
        }
        else {
            return function () {
                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
                return typeof result === 'number' ? result : undefined;
            };
        }
    }
    buildLookaheadForOptional(options) {
        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;
        const dfas = this.dfas;
        const logging = this.logging;
        const key = (0,_atn_js__WEBPACK_IMPORTED_MODULE_1__.buildATNKey)(rule, prodType, prodOccurrence);
        const decisionState = this.atn.decisionMap[key];
        const decisionIndex = decisionState.decision;
        const alts = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.getLookaheadPaths)({
            maxLookahead: 1,
            occurrence: prodOccurrence,
            prodType,
            rule
        }), (e) => {
            return (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])(e, (g) => g[0]);
        });
        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {
            const alt = alts[0];
            const singleTokensTypes = (0,lodash_es_flatten_js__WEBPACK_IMPORTED_MODULE_6__["default"])(alt);
            if (singleTokensTypes.length === 1 &&
                (0,lodash_es_isEmpty_js__WEBPACK_IMPORTED_MODULE_7__["default"])(singleTokensTypes[0].categoryMatches)) {
                const expectedTokenType = singleTokensTypes[0];
                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
                return function () {
                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
                };
            }
            else {
                const choiceToAlt = (0,lodash_es_reduce_js__WEBPACK_IMPORTED_MODULE_4__["default"])(singleTokensTypes, (result, currTokType) => {
                    if (currTokType !== undefined) {
                        result[currTokType.tokenTypeIdx] = true;
                        (0,lodash_es_forEach_js__WEBPACK_IMPORTED_MODULE_5__["default"])(currTokType.categoryMatches, (currExtendingType) => {
                            result[currExtendingType] = true;
                        });
                    }
                    return result;
                }, {});
                return function () {
                    const nextToken = this.LA(1);
                    return choiceToAlt[nextToken.tokenTypeIdx] === true;
                };
            }
        }
        return function () {
            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
            return typeof result === "object" ? false : result === 0;
        };
    }
}
function isLL1Sequence(sequences, allowEmpty = true) {
    const fullSet = new Set();
    for (const alt of sequences) {
        const altSet = new Set();
        for (const tokType of alt) {
            if (tokType === undefined) {
                if (allowEmpty) {
                    // Epsilon production encountered
                    break;
                }
                else {
                    return false;
                }
            }
            const indices = [tokType.tokenTypeIdx].concat(tokType.categoryMatches);
            for (const index of indices) {
                if (fullSet.has(index)) {
                    if (!altSet.has(index)) {
                        return false;
                    }
                }
                else {
                    fullSet.add(index);
                    altSet.add(index);
                }
            }
        }
    }
    return true;
}
function initATNSimulator(atn) {
    const decisionLength = atn.decisionStates.length;
    const decisionToDFA = Array(decisionLength);
    for (let i = 0; i < decisionLength; i++) {
        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);
    }
    return decisionToDFA;
}
function adaptivePredict(dfaCaches, decision, predicateSet, logging) {
    const dfa = dfaCaches[decision](predicateSet);
    let start = dfa.start;
    if (start === undefined) {
        const closure = computeStartState(dfa.atnStartState);
        start = addDFAState(dfa, newDFAState(closure));
        dfa.start = start;
    }
    const alt = performLookahead.apply(this, [dfa, start, predicateSet, logging]);
    return alt;
}
function performLookahead(dfa, s0, predicateSet, logging) {
    let previousD = s0;
    let i = 1;
    const path = [];
    let t = this.LA(i++);
    while (true) {
        let d = getExistingTargetState(previousD, t);
        if (d === undefined) {
            d = computeLookaheadTarget.apply(this, [dfa, previousD, t, i, predicateSet, logging]);
        }
        if (d === _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR) {
            return buildAdaptivePredictError(path, previousD, t);
        }
        if (d.isAcceptState === true) {
            return d.prediction;
        }
        previousD = d;
        path.push(t);
        t = this.LA(i++);
    }
}
function computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {
    const reach = computeReachSet(previousD.configs, token, predicateSet);
    if (reach.size === 0) {
        addDFAEdge(dfa, previousD, token, _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR);
        return _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR;
    }
    let newState = newDFAState(reach);
    const predictedAlt = getUniqueAlt(reach, predicateSet);
    if (predictedAlt !== undefined) {
        newState.isAcceptState = true;
        newState.prediction = predictedAlt;
        newState.configs.uniqueAlt = predictedAlt;
    }
    else if (hasConflictTerminatingPrediction(reach)) {
        const prediction = (0,lodash_es_min_js__WEBPACK_IMPORTED_MODULE_8__["default"])(reach.alts);
        newState.isAcceptState = true;
        newState.prediction = prediction;
        newState.configs.uniqueAlt = prediction;
        reportLookaheadAmbiguity.apply(this, [dfa, lookahead, reach.alts, logging]);
    }
    newState = addDFAEdge(dfa, previousD, token, newState);
    return newState;
}
function reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {
    const prefixPath = [];
    for (let i = 1; i <= lookahead; i++) {
        prefixPath.push(this.LA(i).tokenType);
    }
    const atnState = dfa.atnStartState;
    const topLevelRule = atnState.rule;
    const production = atnState.production;
    const message = buildAmbiguityError({
        topLevelRule,
        ambiguityIndices,
        production,
        prefixPath
    });
    logging(message);
}
function buildAmbiguityError(options) {
    const pathMsg = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_3__["default"])(options.prefixPath, (currtok) => (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currtok)).join(", ");
    const occurrence = options.production.idx === 0 ? "" : options.production.idx;
    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(", ")}> in <${getProductionDslName(options.production)}${occurrence}>` +
        ` inside <${options.topLevelRule.name}> Rule,\n` +
        `<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;
    currMessage =
        currMessage +
            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n` +
            `For Further details.`;
    return currMessage;
}
function getProductionDslName(prod) {
    if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
        return "SUBRULE";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Option) {
        return "OPTION";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Alternation) {
        return "OR";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {
        return "AT_LEAST_ONE";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {
        return "AT_LEAST_ONE_SEP";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {
        return "MANY_SEP";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Repetition) {
        return "MANY";
    }
    else if (prod instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Terminal) {
        return "CONSUME";
    }
    else {
        throw Error("non exhaustive match");
    }
}
function buildAdaptivePredictError(path, previous, current) {
    const nextTransitions = (0,lodash_es_flatMap_js__WEBPACK_IMPORTED_MODULE_9__["default"])(previous.configs.elements, (e) => e.state.transitions);
    const nextTokenTypes = (0,lodash_es_uniqBy_js__WEBPACK_IMPORTED_MODULE_10__["default"])(nextTransitions
        .filter((e) => e instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.AtomTransition)
        .map((e) => e.tokenType), (e) => e.tokenTypeIdx);
    return {
        actualToken: current,
        possibleTokenTypes: nextTokenTypes,
        tokenPath: path
    };
}
function getExistingTargetState(state, token) {
    return state.edges[token.tokenTypeIdx];
}
function computeReachSet(configs, token, predicateSet) {
    const intermediate = new _dfa_js__WEBPACK_IMPORTED_MODULE_2__.ATNConfigSet();
    const skippedStopStates = [];
    for (const c of configs.elements) {
        if (predicateSet.is(c.alt) === false) {
            continue;
        }
        if (c.state.type === _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {
            skippedStopStates.push(c);
            continue;
        }
        const transitionLength = c.state.transitions.length;
        for (let i = 0; i < transitionLength; i++) {
            const transition = c.state.transitions[i];
            const target = getReachableTarget(transition, token);
            if (target !== undefined) {
                intermediate.add({
                    state: target,
                    alt: c.alt,
                    stack: c.stack
                });
            }
        }
    }
    let reach;
    if (skippedStopStates.length === 0 && intermediate.size === 1) {
        reach = intermediate;
    }
    if (reach === undefined) {
        reach = new _dfa_js__WEBPACK_IMPORTED_MODULE_2__.ATNConfigSet();
        for (const c of intermediate.elements) {
            closure(c, reach);
        }
    }
    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {
        for (const c of skippedStopStates) {
            reach.add(c);
        }
    }
    return reach;
}
function getReachableTarget(transition, token) {
    if (transition instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.AtomTransition &&
        (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(token, transition.tokenType)) {
        return transition.target;
    }
    return undefined;
}
function getUniqueAlt(configs, predicateSet) {
    let alt;
    for (const c of configs.elements) {
        if (predicateSet.is(c.alt) === true) {
            if (alt === undefined) {
                alt = c.alt;
            }
            else if (alt !== c.alt) {
                return undefined;
            }
        }
    }
    return alt;
}
function newDFAState(closure) {
    return {
        configs: closure,
        edges: {},
        isAcceptState: false,
        prediction: -1
    };
}
function addDFAEdge(dfa, from, token, to) {
    to = addDFAState(dfa, to);
    from.edges[token.tokenTypeIdx] = to;
    return to;
}
function addDFAState(dfa, state) {
    if (state === _dfa_js__WEBPACK_IMPORTED_MODULE_2__.DFA_ERROR) {
        return state;
    }
    // Repetitions have the same config set
    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA
    const mapKey = state.configs.key;
    const existing = dfa.states[mapKey];
    if (existing !== undefined) {
        return existing;
    }
    state.configs.finalize();
    dfa.states[mapKey] = state;
    return state;
}
function computeStartState(atnState) {
    const configs = new _dfa_js__WEBPACK_IMPORTED_MODULE_2__.ATNConfigSet();
    const numberOfTransitions = atnState.transitions.length;
    for (let i = 0; i < numberOfTransitions; i++) {
        const target = atnState.transitions[i].target;
        const config = {
            state: target,
            alt: i,
            stack: []
        };
        closure(config, configs);
    }
    return configs;
}
function closure(config, configs) {
    const p = config.state;
    if (p.type === _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {
        if (config.stack.length > 0) {
            const atnStack = [...config.stack];
            const followState = atnStack.pop();
            const followConfig = {
                state: followState,
                alt: config.alt,
                stack: atnStack
            };
            closure(followConfig, configs);
        }
        else {
            // Dipping into outer context, simply add the config
            // This will stop computation once every config is at the rule stop state
            configs.add(config);
        }
        return;
    }
    if (!p.epsilonOnlyTransitions) {
        configs.add(config);
    }
    const transitionLength = p.transitions.length;
    for (let i = 0; i < transitionLength; i++) {
        const transition = p.transitions[i];
        const c = getEpsilonTarget(config, transition);
        if (c !== undefined) {
            closure(c, configs);
        }
    }
}
function getEpsilonTarget(config, transition) {
    if (transition instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.EpsilonTransition) {
        return {
            state: transition.target,
            alt: config.alt,
            stack: config.stack
        };
    }
    else if (transition instanceof _atn_js__WEBPACK_IMPORTED_MODULE_1__.RuleTransition) {
        const stack = [...config.stack, transition.followState];
        return {
            state: transition.target,
            alt: config.alt,
            stack
        };
    }
    return undefined;
}
function hasConfigInRuleStopState(configs) {
    for (const c of configs.elements) {
        if (c.state.type === _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {
            return true;
        }
    }
    return false;
}
function allConfigsInRuleStopStates(configs) {
    for (const c of configs.elements) {
        if (c.state.type !== _atn_js__WEBPACK_IMPORTED_MODULE_1__.ATN_RULE_STOP) {
            return false;
        }
    }
    return true;
}
function hasConflictTerminatingPrediction(configs) {
    if (allConfigsInRuleStopStates(configs)) {
        return true;
    }
    const altSets = getConflictingAltSets(configs.elements);
    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);
    return heuristic;
}
function getConflictingAltSets(configs) {
    const configToAlts = new Map();
    for (const c of configs) {
        const key = (0,_dfa_js__WEBPACK_IMPORTED_MODULE_2__.getATNConfigKey)(c, false);
        let alts = configToAlts.get(key);
        if (alts === undefined) {
            alts = {};
            configToAlts.set(key, alts);
        }
        alts[c.alt] = true;
    }
    return configToAlts;
}
function hasConflictingAltSet(altSets) {
    for (const value of Array.from(altSets.values())) {
        if (Object.keys(value).length > 1) {
            return true;
        }
    }
    return false;
}
function hasStateAssociatedWithOneAlt(altSets) {
    for (const value of Array.from(altSets.values())) {
        if (Object.keys(value).length === 1) {
            return true;
        }
    }
    return false;
}
//# sourceMappingURL=all-star-lookahead.js.map

/***/ }),

/***/ "./node_modules/chevrotain-allstar/lib/atn.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/atn.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ATN_BASIC: () => (/* binding */ ATN_BASIC),
/* harmony export */   ATN_BLOCK_END: () => (/* binding */ ATN_BLOCK_END),
/* harmony export */   ATN_INVALID_TYPE: () => (/* binding */ ATN_INVALID_TYPE),
/* harmony export */   ATN_LOOP_END: () => (/* binding */ ATN_LOOP_END),
/* harmony export */   ATN_PLUS_BLOCK_START: () => (/* binding */ ATN_PLUS_BLOCK_START),
/* harmony export */   ATN_PLUS_LOOP_BACK: () => (/* binding */ ATN_PLUS_LOOP_BACK),
/* harmony export */   ATN_RULE_START: () => (/* binding */ ATN_RULE_START),
/* harmony export */   ATN_RULE_STOP: () => (/* binding */ ATN_RULE_STOP),
/* harmony export */   ATN_STAR_BLOCK_START: () => (/* binding */ ATN_STAR_BLOCK_START),
/* harmony export */   ATN_STAR_LOOP_BACK: () => (/* binding */ ATN_STAR_LOOP_BACK),
/* harmony export */   ATN_STAR_LOOP_ENTRY: () => (/* binding */ ATN_STAR_LOOP_ENTRY),
/* harmony export */   ATN_TOKEN_START: () => (/* binding */ ATN_TOKEN_START),
/* harmony export */   AbstractTransition: () => (/* binding */ AbstractTransition),
/* harmony export */   AtomTransition: () => (/* binding */ AtomTransition),
/* harmony export */   EpsilonTransition: () => (/* binding */ EpsilonTransition),
/* harmony export */   RuleTransition: () => (/* binding */ RuleTransition),
/* harmony export */   buildATNKey: () => (/* binding */ buildATNKey),
/* harmony export */   createATN: () => (/* binding */ createATN)
/* harmony export */ });
/* harmony import */ var lodash_es_map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es/map.js */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es_filter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es/filter.js */ "./node_modules/lodash-es/filter.js");
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ "./node_modules/chevrotain/lib/src/api.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/



function buildATNKey(rule, type, occurrence) {
    return `${rule.name}_${type}_${occurrence}`;
}
const ATN_INVALID_TYPE = 0;
const ATN_BASIC = 1;
const ATN_RULE_START = 2;
const ATN_PLUS_BLOCK_START = 4;
const ATN_STAR_BLOCK_START = 5;
// Currently unused as the ATN is not used for lexing
const ATN_TOKEN_START = 6;
const ATN_RULE_STOP = 7;
const ATN_BLOCK_END = 8;
const ATN_STAR_LOOP_BACK = 9;
const ATN_STAR_LOOP_ENTRY = 10;
const ATN_PLUS_LOOP_BACK = 11;
const ATN_LOOP_END = 12;
class AbstractTransition {
    constructor(target) {
        this.target = target;
    }
    isEpsilon() {
        return false;
    }
}
class AtomTransition extends AbstractTransition {
    constructor(target, tokenType) {
        super(target);
        this.tokenType = tokenType;
    }
}
class EpsilonTransition extends AbstractTransition {
    constructor(target) {
        super(target);
    }
    isEpsilon() {
        return true;
    }
}
class RuleTransition extends AbstractTransition {
    constructor(ruleStart, rule, followState) {
        super(ruleStart);
        this.rule = rule;
        this.followState = followState;
    }
    isEpsilon() {
        return true;
    }
}
function createATN(rules) {
    const atn = {
        decisionMap: {},
        decisionStates: [],
        ruleToStartState: new Map(),
        ruleToStopState: new Map(),
        states: []
    };
    createRuleStartAndStopATNStates(atn, rules);
    const ruleLength = rules.length;
    for (let i = 0; i < ruleLength; i++) {
        const rule = rules[i];
        const ruleBlock = block(atn, rule, rule);
        if (ruleBlock === undefined) {
            continue;
        }
        buildRuleHandle(atn, rule, ruleBlock);
    }
    return atn;
}
function createRuleStartAndStopATNStates(atn, rules) {
    const ruleLength = rules.length;
    for (let i = 0; i < ruleLength; i++) {
        const rule = rules[i];
        const start = newState(atn, rule, undefined, {
            type: ATN_RULE_START
        });
        const stop = newState(atn, rule, undefined, {
            type: ATN_RULE_STOP
        });
        start.stop = stop;
        atn.ruleToStartState.set(rule, start);
        atn.ruleToStopState.set(rule, stop);
    }
}
function atom(atn, rule, production) {
    if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Terminal) {
        return tokenRef(atn, rule, production.terminalType, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
        return ruleRef(atn, rule, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Alternation) {
        return alternation(atn, rule, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Option) {
        return option(atn, rule, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Repetition) {
        return repetition(atn, rule, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {
        return repetitionSep(atn, rule, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {
        return repetitionMandatory(atn, rule, production);
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {
        return repetitionMandatorySep(atn, rule, production);
    }
    else {
        return block(atn, rule, production);
    }
}
function repetition(atn, rule, repetition) {
    const starState = newState(atn, rule, repetition, {
        type: ATN_STAR_BLOCK_START
    });
    defineDecisionState(atn, starState);
    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));
    return star(atn, rule, repetition, handle);
}
function repetitionSep(atn, rule, repetition) {
    const starState = newState(atn, rule, repetition, {
        type: ATN_STAR_BLOCK_START
    });
    defineDecisionState(atn, starState);
    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));
    const sep = tokenRef(atn, rule, repetition.separator, repetition);
    return star(atn, rule, repetition, handle, sep);
}
function repetitionMandatory(atn, rule, repetition) {
    const plusState = newState(atn, rule, repetition, {
        type: ATN_PLUS_BLOCK_START
    });
    defineDecisionState(atn, plusState);
    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));
    return plus(atn, rule, repetition, handle);
}
function repetitionMandatorySep(atn, rule, repetition) {
    const plusState = newState(atn, rule, repetition, {
        type: ATN_PLUS_BLOCK_START
    });
    defineDecisionState(atn, plusState);
    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));
    const sep = tokenRef(atn, rule, repetition.separator, repetition);
    return plus(atn, rule, repetition, handle, sep);
}
function alternation(atn, rule, alternation) {
    const start = newState(atn, rule, alternation, {
        type: ATN_BASIC
    });
    defineDecisionState(atn, start);
    const alts = (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_1__["default"])(alternation.definition, (e) => atom(atn, rule, e));
    const handle = makeAlts(atn, rule, start, alternation, ...alts);
    return handle;
}
function option(atn, rule, option) {
    const start = newState(atn, rule, option, {
        type: ATN_BASIC
    });
    defineDecisionState(atn, start);
    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));
    return optional(atn, rule, option, handle);
}
function block(atn, rule, block) {
    const handles = (0,lodash_es_filter_js__WEBPACK_IMPORTED_MODULE_2__["default"])((0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_1__["default"])(block.definition, (e) => atom(atn, rule, e)), (e) => e !== undefined);
    if (handles.length === 1) {
        return handles[0];
    }
    else if (handles.length === 0) {
        return undefined;
    }
    else {
        return makeBlock(atn, handles);
    }
}
function plus(atn, rule, plus, handle, sep) {
    const blkStart = handle.left;
    const blkEnd = handle.right;
    const loop = newState(atn, rule, plus, {
        type: ATN_PLUS_LOOP_BACK
    });
    defineDecisionState(atn, loop);
    const end = newState(atn, rule, plus, {
        type: ATN_LOOP_END
    });
    blkStart.loopback = loop;
    end.loopback = loop;
    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;
    epsilon(blkEnd, loop); // block can see loop back
    // Depending on whether we have a separator we put the exit transition at index 1 or 0
    // This influences the chosen option in the lookahead DFA
    if (sep === undefined) {
        epsilon(loop, blkStart); // loop back to start
        epsilon(loop, end); // exit
    }
    else {
        epsilon(loop, end); // exit
        // loop back to start with separator
        epsilon(loop, sep.left);
        epsilon(sep.right, blkStart);
    }
    return {
        left: blkStart,
        right: end
    };
}
function star(atn, rule, star, handle, sep) {
    const start = handle.left;
    const end = handle.right;
    const entry = newState(atn, rule, star, {
        type: ATN_STAR_LOOP_ENTRY
    });
    defineDecisionState(atn, entry);
    const loopEnd = newState(atn, rule, star, {
        type: ATN_LOOP_END
    });
    const loop = newState(atn, rule, star, {
        type: ATN_STAR_LOOP_BACK
    });
    entry.loopback = loop;
    loopEnd.loopback = loop;
    epsilon(entry, start); // loop enter edge (alt 2)
    epsilon(entry, loopEnd); // bypass loop edge (alt 1)
    epsilon(end, loop); // block end hits loop back
    if (sep !== undefined) {
        epsilon(loop, loopEnd); // end loop
        // loop back to start of handle using separator
        epsilon(loop, sep.left);
        epsilon(sep.right, start);
    }
    else {
        epsilon(loop, entry); // loop back to entry/exit decision
    }
    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;
    return {
        left: entry,
        right: loopEnd
    };
}
function optional(atn, rule, optional, handle) {
    const start = handle.left;
    const end = handle.right;
    epsilon(start, end);
    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;
    return handle;
}
function defineDecisionState(atn, state) {
    atn.decisionStates.push(state);
    state.decision = atn.decisionStates.length - 1;
    return state.decision;
}
function makeAlts(atn, rule, start, production, ...alts) {
    const end = newState(atn, rule, production, {
        type: ATN_BLOCK_END,
        start
    });
    start.end = end;
    for (const alt of alts) {
        if (alt !== undefined) {
            // hook alts up to decision block
            epsilon(start, alt.left);
            epsilon(alt.right, end);
        }
        else {
            epsilon(start, end);
        }
    }
    const handle = {
        left: start,
        right: end
    };
    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;
    return handle;
}
function getProdType(production) {
    if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Alternation) {
        return 'Alternation';
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Option) {
        return 'Option';
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.Repetition) {
        return 'Repetition';
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {
        return 'RepetitionWithSeparator';
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {
        return 'RepetitionMandatory';
    }
    else if (production instanceof chevrotain__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {
        return 'RepetitionMandatoryWithSeparator';
    }
    else {
        throw new Error('Invalid production type encountered');
    }
}
function makeBlock(atn, alts) {
    const altsLength = alts.length;
    for (let i = 0; i < altsLength - 1; i++) {
        const handle = alts[i];
        let transition;
        if (handle.left.transitions.length === 1) {
            transition = handle.left.transitions[0];
        }
        const isRuleTransition = transition instanceof RuleTransition;
        const ruleTransition = transition;
        const next = alts[i + 1].left;
        if (handle.left.type === ATN_BASIC &&
            handle.right.type === ATN_BASIC &&
            transition !== undefined &&
            ((isRuleTransition && ruleTransition.followState === handle.right) ||
                transition.target === handle.right)) {
            // we can avoid epsilon edge to next element
            if (isRuleTransition) {
                ruleTransition.followState = next;
            }
            else {
                transition.target = next;
            }
            removeState(atn, handle.right); // we skipped over this state
        }
        else {
            // need epsilon if previous block's right end node is complex
            epsilon(handle.right, next);
        }
    }
    const first = alts[0];
    const last = alts[altsLength - 1];
    return {
        left: first.left,
        right: last.right
    };
}
function tokenRef(atn, rule, tokenType, production) {
    const left = newState(atn, rule, production, {
        type: ATN_BASIC
    });
    const right = newState(atn, rule, production, {
        type: ATN_BASIC
    });
    addTransition(left, new AtomTransition(right, tokenType));
    return {
        left,
        right
    };
}
function ruleRef(atn, currentRule, nonTerminal) {
    const rule = nonTerminal.referencedRule;
    const start = atn.ruleToStartState.get(rule);
    const left = newState(atn, currentRule, nonTerminal, {
        type: ATN_BASIC
    });
    const right = newState(atn, currentRule, nonTerminal, {
        type: ATN_BASIC
    });
    const call = new RuleTransition(start, rule, right);
    addTransition(left, call);
    return {
        left,
        right
    };
}
function buildRuleHandle(atn, rule, block) {
    const start = atn.ruleToStartState.get(rule);
    epsilon(start, block.left);
    const stop = atn.ruleToStopState.get(rule);
    epsilon(block.right, stop);
    const handle = {
        left: start,
        right: stop
    };
    return handle;
}
function epsilon(a, b) {
    const transition = new EpsilonTransition(b);
    addTransition(a, transition);
}
function newState(atn, rule, production, partial) {
    const t = Object.assign({ atn,
        production, epsilonOnlyTransitions: false, rule, transitions: [], nextTokenWithinRule: [], stateNumber: atn.states.length }, partial);
    atn.states.push(t);
    return t;
}
function addTransition(state, transition) {
    // A single ATN state can only contain epsilon transitions or non-epsilon transitions
    // Because they are never mixed, only setting the property for the first transition is fine
    if (state.transitions.length === 0) {
        state.epsilonOnlyTransitions = transition.isEpsilon();
    }
    state.transitions.push(transition);
}
function removeState(atn, state) {
    atn.states.splice(atn.states.indexOf(state), 1);
}
//# sourceMappingURL=atn.js.map

/***/ }),

/***/ "./node_modules/chevrotain-allstar/lib/dfa.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/dfa.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ATNConfigSet: () => (/* binding */ ATNConfigSet),
/* harmony export */   DFA_ERROR: () => (/* binding */ DFA_ERROR),
/* harmony export */   getATNConfigKey: () => (/* binding */ getATNConfigKey)
/* harmony export */ });
/* harmony import */ var lodash_es_map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es/map.js */ "./node_modules/lodash-es/map.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

const DFA_ERROR = {};
class ATNConfigSet {
    constructor() {
        this.map = {};
        this.configs = [];
    }
    get size() {
        return this.configs.length;
    }
    finalize() {
        // Empties the map to free up memory
        this.map = {};
    }
    add(config) {
        const key = getATNConfigKey(config);
        // Only add configs which don't exist in our map already
        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption
        if (!(key in this.map)) {
            this.map[key] = this.configs.length;
            this.configs.push(config);
        }
    }
    get elements() {
        return this.configs;
    }
    get alts() {
        return (0,lodash_es_map_js__WEBPACK_IMPORTED_MODULE_0__["default"])(this.configs, (e) => e.alt);
    }
    get key() {
        let value = "";
        for (const k in this.map) {
            value += k + ":";
        }
        return value;
    }
}
function getATNConfigKey(config, alt = true) {
    return `${alt ? `a${config.alt}` : ""}s${config.state.stateNumber}:${config.stack.map((e) => e.stateNumber.toString()).join("_")}`;
}
//# sourceMappingURL=dfa.js.map

/***/ }),

/***/ "./node_modules/chevrotain-allstar/lib/index.js":
/*!******************************************************!*\
  !*** ./node_modules/chevrotain-allstar/lib/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LLStarLookaheadStrategy: () => (/* reexport safe */ _all_star_lookahead_js__WEBPACK_IMPORTED_MODULE_0__.LLStarLookaheadStrategy)
/* harmony export */ });
/* harmony import */ var _all_star_lookahead_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./all-star-lookahead.js */ "./node_modules/chevrotain-allstar/lib/all-star-lookahead.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/api.js":
/*!************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/api.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Alternation: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.Alternation),
/* harmony export */   Alternative: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.Alternative),
/* harmony export */   CstParser: () => (/* reexport safe */ _parse_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__.CstParser),
/* harmony export */   EMPTY_ALT: () => (/* reexport safe */ _parse_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__.EMPTY_ALT),
/* harmony export */   EOF: () => (/* reexport safe */ _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.EOF),
/* harmony export */   EarlyExitException: () => (/* reexport safe */ _parse_exceptions_public_js__WEBPACK_IMPORTED_MODULE_7__.EarlyExitException),
/* harmony export */   EmbeddedActionsParser: () => (/* reexport safe */ _parse_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__.EmbeddedActionsParser),
/* harmony export */   GAstVisitor: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.GAstVisitor),
/* harmony export */   LLkLookaheadStrategy: () => (/* reexport safe */ _parse_grammar_llk_lookahead_js__WEBPACK_IMPORTED_MODULE_5__.LLkLookaheadStrategy),
/* harmony export */   Lexer: () => (/* reexport safe */ _scan_lexer_public_js__WEBPACK_IMPORTED_MODULE_2__.Lexer),
/* harmony export */   LexerDefinitionErrorType: () => (/* reexport safe */ _scan_lexer_public_js__WEBPACK_IMPORTED_MODULE_2__.LexerDefinitionErrorType),
/* harmony export */   MismatchedTokenException: () => (/* reexport safe */ _parse_exceptions_public_js__WEBPACK_IMPORTED_MODULE_7__.MismatchedTokenException),
/* harmony export */   NoViableAltException: () => (/* reexport safe */ _parse_exceptions_public_js__WEBPACK_IMPORTED_MODULE_7__.NoViableAltException),
/* harmony export */   NonTerminal: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.NonTerminal),
/* harmony export */   NotAllInputParsedException: () => (/* reexport safe */ _parse_exceptions_public_js__WEBPACK_IMPORTED_MODULE_7__.NotAllInputParsedException),
/* harmony export */   Option: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.Option),
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   ParserDefinitionErrorType: () => (/* reexport safe */ _parse_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType),
/* harmony export */   Repetition: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.Repetition),
/* harmony export */   RepetitionMandatory: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.RepetitionMandatory),
/* harmony export */   RepetitionMandatoryWithSeparator: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.RepetitionMandatoryWithSeparator),
/* harmony export */   RepetitionWithSeparator: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.RepetitionWithSeparator),
/* harmony export */   Rule: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.Rule),
/* harmony export */   Terminal: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.Terminal),
/* harmony export */   VERSION: () => (/* reexport safe */ _version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION),
/* harmony export */   clearCache: () => (/* binding */ clearCache),
/* harmony export */   createSyntaxDiagramsCode: () => (/* reexport safe */ _diagrams_render_public_js__WEBPACK_IMPORTED_MODULE_11__.createSyntaxDiagramsCode),
/* harmony export */   createToken: () => (/* reexport safe */ _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.createToken),
/* harmony export */   createTokenInstance: () => (/* reexport safe */ _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.createTokenInstance),
/* harmony export */   defaultLexerErrorProvider: () => (/* reexport safe */ _scan_lexer_errors_public_js__WEBPACK_IMPORTED_MODULE_8__.defaultLexerErrorProvider),
/* harmony export */   defaultParserErrorProvider: () => (/* reexport safe */ _parse_errors_public_js__WEBPACK_IMPORTED_MODULE_6__.defaultParserErrorProvider),
/* harmony export */   generateCstDts: () => (/* reexport safe */ _chevrotain_cst_dts_gen__WEBPACK_IMPORTED_MODULE_10__.generateCstDts),
/* harmony export */   getLookaheadPaths: () => (/* reexport safe */ _parse_grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_4__.getLookaheadPaths),
/* harmony export */   isRecognitionException: () => (/* reexport safe */ _parse_exceptions_public_js__WEBPACK_IMPORTED_MODULE_7__.isRecognitionException),
/* harmony export */   serializeGrammar: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.serializeGrammar),
/* harmony export */   serializeProduction: () => (/* reexport safe */ _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__.serializeProduction),
/* harmony export */   tokenLabel: () => (/* reexport safe */ _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.tokenLabel),
/* harmony export */   tokenMatcher: () => (/* reexport safe */ _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.tokenMatcher),
/* harmony export */   tokenName: () => (/* reexport safe */ _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.tokenName)
/* harmony export */ });
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version.js */ "./node_modules/chevrotain/lib/src/version.js");
/* harmony import */ var _parse_parser_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parse/parser/parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _scan_lexer_public_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./scan/lexer_public.js */ "./node_modules/chevrotain/lib/src/scan/lexer_public.js");
/* harmony import */ var _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scan/tokens_public.js */ "./node_modules/chevrotain/lib/src/scan/tokens_public.js");
/* harmony import */ var _parse_grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parse/grammar/lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js");
/* harmony import */ var _parse_grammar_llk_lookahead_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parse/grammar/llk_lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js");
/* harmony import */ var _parse_errors_public_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parse/errors_public.js */ "./node_modules/chevrotain/lib/src/parse/errors_public.js");
/* harmony import */ var _parse_exceptions_public_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parse/exceptions_public.js */ "./node_modules/chevrotain/lib/src/parse/exceptions_public.js");
/* harmony import */ var _scan_lexer_errors_public_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./scan/lexer_errors_public.js */ "./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");
/* harmony import */ var _chevrotain_cst_dts_gen__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @chevrotain/cst-dts-gen */ "./node_modules/@chevrotain/cst-dts-gen/lib/src/api.js");
/* harmony import */ var _diagrams_render_public_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./diagrams/render_public.js */ "./node_modules/chevrotain/lib/src/diagrams/render_public.js");
/* istanbul ignore file - tricky to import some things from this module during testing */
// semantic version



// Tokens utilities

// Lookahead


// Other Utilities



// grammar reflection API

// GAST Utilities


/* istanbul ignore next */
function clearCache() {
    console.warn("The clearCache function was 'soft' removed from the Chevrotain API." +
        "\n\t It performs no action other than printing this message." +
        "\n\t Please avoid using it as it will be completely removed in the future");
}

class Parser {
    constructor() {
        throw new Error("The Parser class has been deprecated, use CstParser or EmbeddedActionsParser instead.\t\n" +
            "See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_7-0-0");
    }
}
//# sourceMappingURL=api.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/diagrams/render_public.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/diagrams/render_public.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSyntaxDiagramsCode: () => (/* binding */ createSyntaxDiagramsCode)
/* harmony export */ });
/* harmony import */ var _version_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../version.js */ "./node_modules/chevrotain/lib/src/version.js");

function createSyntaxDiagramsCode(grammar, { resourceBase = `https://unpkg.com/chevrotain@${_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION}/diagrams/`, css = `https://unpkg.com/chevrotain@${_version_js__WEBPACK_IMPORTED_MODULE_0__.VERSION}/diagrams/diagrams.css`, } = {}) {
    const header = `
<!-- This is a generated file -->
<!DOCTYPE html>
<meta charset="utf-8">
<style>
  body {
    background-color: hsl(30, 20%, 95%)
  }
</style>

`;
    const cssHtml = `
<link rel='stylesheet' href='${css}'>
`;
    const scripts = `
<script src='${resourceBase}vendor/railroad-diagrams.js'></script>
<script src='${resourceBase}src/diagrams_builder.js'></script>
<script src='${resourceBase}src/diagrams_behavior.js'></script>
<script src='${resourceBase}src/main.js'></script>
`;
    const diagramsDiv = `
<div id="diagrams" align="center"></div>    
`;
    const serializedGrammar = `
<script>
    window.serializedGrammar = ${JSON.stringify(grammar, null, "  ")};
</script>
`;
    const initLogic = `
<script>
    var diagramsDiv = document.getElementById("diagrams");
    main.drawDiagramsFromSerializedGrammar(serializedGrammar, diagramsDiv);
</script>
`;
    return (header + cssHtml + scripts + diagramsDiv + serializedGrammar + initLogic);
}
//# sourceMappingURL=render_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/lang/lang_extensions.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/lang/lang_extensions.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defineNameProp: () => (/* binding */ defineNameProp)
/* harmony export */ });
const NAME = "name";
function defineNameProp(obj, nameValue) {
    Object.defineProperty(obj, NAME, {
        enumerable: false,
        configurable: true,
        writable: false,
        value: nameValue,
    });
}
//# sourceMappingURL=lang_extensions.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/constants.js":
/*!************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/constants.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   IN: () => (/* binding */ IN)
/* harmony export */ });
// TODO: can this be removed? where is it used?
const IN = "_~IN~_";
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/cst/cst.js":
/*!**********************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/cst/cst.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addNoneTerminalToCst: () => (/* binding */ addNoneTerminalToCst),
/* harmony export */   addTerminalToCst: () => (/* binding */ addTerminalToCst),
/* harmony export */   setNodeLocationFull: () => (/* binding */ setNodeLocationFull),
/* harmony export */   setNodeLocationOnlyOffset: () => (/* binding */ setNodeLocationOnlyOffset)
/* harmony export */ });
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationOnlyOffset(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (both start/end offsets exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
    // Once the startOffset has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
    }
}
/**
 * This nodeLocation tracking is not efficient and should only be used
 * when error recovery is enabled or the Token Vector contains virtual Tokens
 * (e.g, Python Indent/Outdent)
 * As it executes the calculation for every single terminal/nonTerminal
 * and does not rely on the fact the token vector is **sorted**
 */
function setNodeLocationFull(currNodeLocation, newLocationInfo) {
    // First (valid) update for this cst node
    if (isNaN(currNodeLocation.startOffset) === true) {
        // assumption1: Token location information is either NaN or a valid number
        // assumption2: Token location information is fully valid if it exist
        // (all start/end props exist and are numbers).
        currNodeLocation.startOffset = newLocationInfo.startOffset;
        currNodeLocation.startColumn = newLocationInfo.startColumn;
        currNodeLocation.startLine = newLocationInfo.startLine;
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
    // Once the start props has been updated with a valid number it should never receive
    // any farther updates as the Token vector is sorted.
    // We still have to check this this condition for every new possible location info
    // because with error recovery enabled we may encounter invalid tokens (NaN location props)
    else if (currNodeLocation.endOffset < newLocationInfo.endOffset === true) {
        currNodeLocation.endOffset = newLocationInfo.endOffset;
        currNodeLocation.endColumn = newLocationInfo.endColumn;
        currNodeLocation.endLine = newLocationInfo.endLine;
    }
}
function addTerminalToCst(node, token, tokenTypeName) {
    if (node.children[tokenTypeName] === undefined) {
        node.children[tokenTypeName] = [token];
    }
    else {
        node.children[tokenTypeName].push(token);
    }
}
function addNoneTerminalToCst(node, ruleName, ruleResult) {
    if (node.children[ruleName] === undefined) {
        node.children[ruleName] = [ruleResult];
    }
    else {
        node.children[ruleName].push(ruleResult);
    }
}
//# sourceMappingURL=cst.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js":
/*!******************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CstVisitorDefinitionError: () => (/* binding */ CstVisitorDefinitionError),
/* harmony export */   createBaseSemanticVisitorConstructor: () => (/* binding */ createBaseSemanticVisitorConstructor),
/* harmony export */   createBaseVisitorConstructorWithDefaults: () => (/* binding */ createBaseVisitorConstructorWithDefaults),
/* harmony export */   defaultVisit: () => (/* binding */ defaultVisit),
/* harmony export */   validateMissingCstMethods: () => (/* binding */ validateMissingCstMethods),
/* harmony export */   validateVisitor: () => (/* binding */ validateVisitor)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/keys.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/filter.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/compact.js");
/* harmony import */ var _lang_lang_extensions_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../lang/lang_extensions.js */ "./node_modules/chevrotain/lib/src/lang/lang_extensions.js");


function defaultVisit(ctx, param) {
    const childrenNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(ctx);
    const childrenNamesLength = childrenNames.length;
    for (let i = 0; i < childrenNamesLength; i++) {
        const currChildName = childrenNames[i];
        const currChildArray = ctx[currChildName];
        const currChildArrayLength = currChildArray.length;
        for (let j = 0; j < currChildArrayLength; j++) {
            const currChild = currChildArray[j];
            // distinction between Tokens Children and CstNode children
            if (currChild.tokenTypeIdx === undefined) {
                this[currChild.name](currChild.children, param);
            }
        }
    }
    // defaultVisit does not support generic out param
}
function createBaseSemanticVisitorConstructor(grammarName, ruleNames) {
    const derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    (0,_lang_lang_extensions_js__WEBPACK_IMPORTED_MODULE_0__.defineNameProp)(derivedConstructor, grammarName + "BaseSemantics");
    const semanticProto = {
        visit: function (cstNode, param) {
            // enables writing more concise visitor methods when CstNode has only a single child
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(cstNode)) {
                // A CST Node's children dictionary can never have empty arrays as values
                // If a key is defined there will be at least one element in the corresponding value array.
                cstNode = cstNode[0];
            }
            // enables passing optional CstNodes concisely.
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(cstNode)) {
                return undefined;
            }
            return this[cstNode.name](cstNode.children, param);
        },
        validateVisitor: function () {
            const semanticDefinitionErrors = validateVisitor(this, ruleNames);
            if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(semanticDefinitionErrors)) {
                const errorMessages = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(semanticDefinitionErrors, (currDefError) => currDefError.msg);
                throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:\n\t` +
                    `${errorMessages.join("\n\n").replace(/\n/g, "\n\t")}`);
            }
        },
    };
    derivedConstructor.prototype = semanticProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    derivedConstructor._RULE_NAMES = ruleNames;
    return derivedConstructor;
}
function createBaseVisitorConstructorWithDefaults(grammarName, ruleNames, baseConstructor) {
    const derivedConstructor = function () { };
    // can be overwritten according to:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/
    // name?redirectlocale=en-US&redirectslug=JavaScript%2FReference%2FGlobal_Objects%2FFunction%2Fname
    (0,_lang_lang_extensions_js__WEBPACK_IMPORTED_MODULE_0__.defineNameProp)(derivedConstructor, grammarName + "BaseSemanticsWithDefaults");
    const withDefaultsProto = Object.create(baseConstructor.prototype);
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(ruleNames, (ruleName) => {
        withDefaultsProto[ruleName] = defaultVisit;
    });
    derivedConstructor.prototype = withDefaultsProto;
    derivedConstructor.prototype.constructor = derivedConstructor;
    return derivedConstructor;
}
var CstVisitorDefinitionError;
(function (CstVisitorDefinitionError) {
    CstVisitorDefinitionError[CstVisitorDefinitionError["REDUNDANT_METHOD"] = 0] = "REDUNDANT_METHOD";
    CstVisitorDefinitionError[CstVisitorDefinitionError["MISSING_METHOD"] = 1] = "MISSING_METHOD";
})(CstVisitorDefinitionError || (CstVisitorDefinitionError = {}));
function validateVisitor(visitorInstance, ruleNames) {
    const missingErrors = validateMissingCstMethods(visitorInstance, ruleNames);
    return missingErrors;
}
function validateMissingCstMethods(visitorInstance, ruleNames) {
    const missingRuleNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(ruleNames, (currRuleName) => {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(visitorInstance[currRuleName]) === false;
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(missingRuleNames, (currRuleName) => {
        return {
            msg: `Missing visitor method: <${currRuleName}> on ${(visitorInstance.constructor.name)} CST Visitor.`,
            type: CstVisitorDefinitionError.MISSING_METHOD,
            methodName: currRuleName,
        };
    });
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(errors);
}
//# sourceMappingURL=cst_visitor.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/errors_public.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/errors_public.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultGrammarResolverErrorProvider: () => (/* binding */ defaultGrammarResolverErrorProvider),
/* harmony export */   defaultGrammarValidatorErrorProvider: () => (/* binding */ defaultGrammarValidatorErrorProvider),
/* harmony export */   defaultParserErrorProvider: () => (/* binding */ defaultParserErrorProvider)
/* harmony export */ });
/* harmony import */ var _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scan/tokens_public.js */ "./node_modules/chevrotain/lib/src/scan/tokens_public.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/head.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");



const defaultParserErrorProvider = {
    buildMismatchTokenMessage({ expected, actual, previous, ruleName }) {
        const hasLabel = (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.hasTokenLabel)(expected);
        const expectedMsg = hasLabel
            ? `--> ${(0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(expected)} <--`
            : `token of type --> ${expected.name} <--`;
        const msg = `Expecting ${expectedMsg} but found --> '${actual.image}' <--`;
        return msg;
    },
    buildNotAllInputParsedMessage({ firstRedundant, ruleName }) {
        return "Redundant input, expecting EOF but found: " + firstRedundant.image;
    },
    buildNoViableAltMessage({ expectedPathsPerAlt, actual, previous, customUserDescription, ruleName, }) {
        const errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        const actualText = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(actual).image;
        const errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            const allLookAheadPaths = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(expectedPathsPerAlt, (result, currAltPaths) => result.concat(currAltPaths), []);
            const nextValidTokenSequences = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(allLookAheadPaths, (currPath) => `[${(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(currPath, (currTokenType) => (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTokenType)).join(", ")}]`);
            const nextValidSequenceItems = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(nextValidTokenSequences, (itemMsg, idx) => `  ${idx + 1}. ${itemMsg}`);
            const calculatedDescription = `one of these possible Token sequences:\n${nextValidSequenceItems.join("\n")}`;
            return errPrefix + calculatedDescription + errSuffix;
        }
    },
    buildEarlyExitMessage({ expectedIterationPaths, actual, customUserDescription, ruleName, }) {
        const errPrefix = "Expecting: ";
        // TODO: issue: No Viable Alternative Error may have incomplete details. #502
        const actualText = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(actual).image;
        const errSuffix = "\nbut found: '" + actualText + "'";
        if (customUserDescription) {
            return errPrefix + customUserDescription + errSuffix;
        }
        else {
            const nextValidTokenSequences = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(expectedIterationPaths, (currPath) => `[${(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(currPath, (currTokenType) => (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTokenType)).join(",")}]`);
            const calculatedDescription = `expecting at least one iteration which starts with one of these possible Token sequences::\n  ` +
                `<${nextValidTokenSequences.join(" ,")}>`;
            return errPrefix + calculatedDescription + errSuffix;
        }
    },
};
Object.freeze(defaultParserErrorProvider);
const defaultGrammarResolverErrorProvider = {
    buildRuleNotFoundError(topLevelRule, undefinedRule) {
        const msg = "Invalid grammar, reference to a rule which is not defined: ->" +
            undefinedRule.nonTerminalName +
            "<-\n" +
            "inside top level rule: ->" +
            topLevelRule.name +
            "<-";
        return msg;
    },
};
const defaultGrammarValidatorErrorProvider = {
    buildDuplicateFoundError(topLevelRule, duplicateProds) {
        function getExtraProductionArgument(prod) {
            if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
                return prod.terminalType.name;
            }
            else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
                return prod.nonTerminalName;
            }
            else {
                return "";
            }
        }
        const topLevelName = topLevelRule.name;
        const duplicateProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(duplicateProds);
        const index = duplicateProd.idx;
        const dslName = (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.getProductionDslName)(duplicateProd);
        const extraArgument = getExtraProductionArgument(duplicateProd);
        const hasExplicitIndex = index > 0;
        let msg = `->${dslName}${hasExplicitIndex ? index : ""}<- ${extraArgument ? `with argument: ->${extraArgument}<-` : ""}
                  appears more than once (${duplicateProds.length} times) in the top level rule: ->${topLevelName}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
        // white space trimming time! better to trim afterwards as it allows to use WELL formatted multi line template strings...
        msg = msg.replace(/[ \t]+/g, " ");
        msg = msg.replace(/\s\s+/g, "\n");
        return msg;
    },
    buildNamespaceConflictError(rule) {
        const errMsg = `Namespace conflict found in grammar.\n` +
            `The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${rule.name}>.\n` +
            `To resolve this make sure each Terminal and Non-Terminal names are unique\n` +
            `This is easy to accomplish by using the convention that Terminal names start with an uppercase letter\n` +
            `and Non-Terminal names start with a lower case letter.`;
        return errMsg;
    },
    buildAlternationPrefixAmbiguityError(options) {
        const pathMsg = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(options.prefixPath, (currTok) => (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currTok)).join(", ");
        const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        const errMsg = `Ambiguous alternatives: <${options.ambiguityIndices.join(" ,")}> due to common lookahead prefix\n` +
            `in <OR${occurrence}> inside <${options.topLevelRule.name}> Rule,\n` +
            `<${pathMsg}> may appears as a prefix path in all these alternatives.\n` +
            `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX\n` +
            `For Further details.`;
        return errMsg;
    },
    buildAlternationAmbiguityError(options) {
        const pathMsg = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(options.prefixPath, (currtok) => (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.tokenLabel)(currtok)).join(", ");
        const occurrence = options.alternation.idx === 0 ? "" : options.alternation.idx;
        let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(" ,")}> in <OR${occurrence}>` +
            ` inside <${options.topLevelRule.name}> Rule,\n` +
            `<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;
        currMessage =
            currMessage +
                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n` +
                `For Further details.`;
        return currMessage;
    },
    buildEmptyRepetitionError(options) {
        let dslName = (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.getProductionDslName)(options.repetition);
        if (options.repetition.idx !== 0) {
            dslName += options.repetition.idx;
        }
        const errMsg = `The repetition <${dslName}> within Rule <${options.topLevelRule.name}> can never consume any tokens.\n` +
            `This could lead to an infinite loop.`;
        return errMsg;
    },
    // TODO: remove - `errors_public` from nyc.config.js exclude
    //       once this method is fully removed from this file
    buildTokenNameError(options) {
        /* istanbul ignore next */
        return "deprecated";
    },
    buildEmptyAlternationError(options) {
        const errMsg = `Ambiguous empty alternative: <${options.emptyChoiceIdx + 1}>` +
            ` in <OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\n` +
            `Only the last alternative may be an empty alternative.`;
        return errMsg;
    },
    buildTooManyAlternativesError(options) {
        const errMsg = `An Alternation cannot have more than 256 alternatives:\n` +
            `<OR${options.alternation.idx}> inside <${options.topLevelRule.name}> Rule.\n has ${options.alternation.definition.length + 1} alternatives.`;
        return errMsg;
    },
    buildLeftRecursionError(options) {
        const ruleName = options.topLevelRule.name;
        const pathNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(options.leftRecursionPath, (currRule) => currRule.name);
        const leftRecursivePath = `${ruleName} --> ${pathNames
            .concat([ruleName])
            .join(" --> ")}`;
        const errMsg = `Left Recursion found in grammar.\n` +
            `rule: <${ruleName}> can be invoked from itself (directly or indirectly)\n` +
            `without consuming any Tokens. The grammar path that causes this is: \n ${leftRecursivePath}\n` +
            ` To fix this refactor your grammar to remove the left recursion.\n` +
            `see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
        return errMsg;
    },
    // TODO: remove - `errors_public` from nyc.config.js exclude
    //       once this method is fully removed from this file
    buildInvalidRuleNameError(options) {
        /* istanbul ignore next */
        return "deprecated";
    },
    buildDuplicateRuleNameError(options) {
        let ruleName;
        if (options.topLevelRule instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Rule) {
            ruleName = options.topLevelRule.name;
        }
        else {
            ruleName = options.topLevelRule;
        }
        const errMsg = `Duplicate definition, rule: ->${ruleName}<- is already defined in the grammar: ->${options.grammarName}<-`;
        return errMsg;
    },
};
//# sourceMappingURL=errors_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/exceptions_public.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/exceptions_public.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EarlyExitException: () => (/* binding */ EarlyExitException),
/* harmony export */   MismatchedTokenException: () => (/* binding */ MismatchedTokenException),
/* harmony export */   NoViableAltException: () => (/* binding */ NoViableAltException),
/* harmony export */   NotAllInputParsedException: () => (/* binding */ NotAllInputParsedException),
/* harmony export */   isRecognitionException: () => (/* binding */ isRecognitionException)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");

const MISMATCHED_TOKEN_EXCEPTION = "MismatchedTokenException";
const NO_VIABLE_ALT_EXCEPTION = "NoViableAltException";
const EARLY_EXIT_EXCEPTION = "EarlyExitException";
const NOT_ALL_INPUT_PARSED_EXCEPTION = "NotAllInputParsedException";
const RECOGNITION_EXCEPTION_NAMES = [
    MISMATCHED_TOKEN_EXCEPTION,
    NO_VIABLE_ALT_EXCEPTION,
    EARLY_EXIT_EXCEPTION,
    NOT_ALL_INPUT_PARSED_EXCEPTION,
];
Object.freeze(RECOGNITION_EXCEPTION_NAMES);
// hacks to bypass no support for custom Errors in javascript/typescript
function isRecognitionException(error) {
    // can't do instanceof on hacked custom js exceptions
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(RECOGNITION_EXCEPTION_NAMES, error.name);
}
class RecognitionException extends Error {
    constructor(message, token) {
        super(message);
        this.token = token;
        this.resyncedTokens = [];
        // fix prototype chain when typescript target is ES5
        Object.setPrototypeOf(this, new.target.prototype);
        /* istanbul ignore next - V8 workaround to remove constructor from stacktrace when typescript target is ES5 */
        if (Error.captureStackTrace) {
            Error.captureStackTrace(this, this.constructor);
        }
    }
}
class MismatchedTokenException extends RecognitionException {
    constructor(message, token, previousToken) {
        super(message, token);
        this.previousToken = previousToken;
        this.name = MISMATCHED_TOKEN_EXCEPTION;
    }
}
class NoViableAltException extends RecognitionException {
    constructor(message, token, previousToken) {
        super(message, token);
        this.previousToken = previousToken;
        this.name = NO_VIABLE_ALT_EXCEPTION;
    }
}
class NotAllInputParsedException extends RecognitionException {
    constructor(message, token) {
        super(message, token);
        this.name = NOT_ALL_INPUT_PARSED_EXCEPTION;
    }
}
class EarlyExitException extends RecognitionException {
    constructor(message, token, previousToken) {
        super(message, token);
        this.previousToken = previousToken;
        this.name = EARLY_EXIT_EXCEPTION;
    }
}
//# sourceMappingURL=exceptions_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/checks.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/checks.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   OccurrenceValidationCollector: () => (/* binding */ OccurrenceValidationCollector),
/* harmony export */   RepetitionCollector: () => (/* binding */ RepetitionCollector),
/* harmony export */   checkPrefixAlternativesAmbiguities: () => (/* binding */ checkPrefixAlternativesAmbiguities),
/* harmony export */   getFirstNoneTerminal: () => (/* binding */ getFirstNoneTerminal),
/* harmony export */   identifyProductionForDuplicates: () => (/* binding */ identifyProductionForDuplicates),
/* harmony export */   validateAmbiguousAlternationAlternatives: () => (/* binding */ validateAmbiguousAlternationAlternatives),
/* harmony export */   validateEmptyOrAlternative: () => (/* binding */ validateEmptyOrAlternative),
/* harmony export */   validateGrammar: () => (/* binding */ validateGrammar),
/* harmony export */   validateLookahead: () => (/* binding */ validateLookahead),
/* harmony export */   validateNoLeftRecursion: () => (/* binding */ validateNoLeftRecursion),
/* harmony export */   validateRuleDoesNotAlreadyExist: () => (/* binding */ validateRuleDoesNotAlreadyExist),
/* harmony export */   validateRuleIsOverridden: () => (/* binding */ validateRuleIsOverridden),
/* harmony export */   validateSomeNonEmptyLookaheadPath: () => (/* binding */ validateSomeNonEmptyLookaheadPath),
/* harmony export */   validateTooManyAlts: () => (/* binding */ validateTooManyAlts)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatMap.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/groupBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/pickBy.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/head.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/difference.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/drop.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/dropRight.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reject.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/compact.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/filter.js");
/* harmony import */ var _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser/parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");
/* harmony import */ var _lookahead_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js");
/* harmony import */ var _interpreter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./interpreter.js */ "./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js");
/* harmony import */ var _scan_tokens_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../scan/tokens.js */ "./node_modules/chevrotain/lib/src/scan/tokens.js");






function validateLookahead(options) {
    const lookaheadValidationErrorMessages = options.lookaheadStrategy.validate({
        rules: options.rules,
        tokenTypes: options.tokenTypes,
        grammarName: options.grammarName,
    });
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(lookaheadValidationErrorMessages, (errorMessage) => (Object.assign({ type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.CUSTOM_LOOKAHEAD_VALIDATION }, errorMessage)));
}
function validateGrammar(topLevels, tokenTypes, errMsgProvider, grammarName) {
    const duplicateErrors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(topLevels, (currTopLevel) => validateDuplicateProductions(currTopLevel, errMsgProvider));
    const termsNamespaceConflictErrors = checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider);
    const tooManyAltsErrors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(topLevels, (curRule) => validateTooManyAlts(curRule, errMsgProvider));
    const duplicateRulesError = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(topLevels, (curRule) => validateRuleDoesNotAlreadyExist(curRule, topLevels, grammarName, errMsgProvider));
    return duplicateErrors.concat(termsNamespaceConflictErrors, tooManyAltsErrors, duplicateRulesError);
}
function validateDuplicateProductions(topLevelRule, errMsgProvider) {
    const collectorVisitor = new OccurrenceValidationCollector();
    topLevelRule.accept(collectorVisitor);
    const allRuleProductions = collectorVisitor.allProductions;
    const productionGroups = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(allRuleProductions, identifyProductionForDuplicates);
    const duplicates = (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(productionGroups, (currGroup) => {
        return currGroup.length > 1;
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(duplicates), (currDuplicates) => {
        const firstProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(currDuplicates);
        const msg = errMsgProvider.buildDuplicateFoundError(topLevelRule, currDuplicates);
        const dslName = (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.getProductionDslName)(firstProd);
        const defError = {
            message: msg,
            type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.DUPLICATE_PRODUCTIONS,
            ruleName: topLevelRule.name,
            dslName: dslName,
            occurrence: firstProd.idx,
        };
        const param = getExtraProductionArgument(firstProd);
        if (param) {
            defError.parameter = param;
        }
        return defError;
    });
    return errors;
}
function identifyProductionForDuplicates(prod) {
    return `${(0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.getProductionDslName)(prod)}_#_${prod.idx}_#_${getExtraProductionArgument(prod)}`;
}
function getExtraProductionArgument(prod) {
    if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
        return prod.terminalType.name;
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
        return prod.nonTerminalName;
    }
    else {
        return "";
    }
}
class OccurrenceValidationCollector extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.GAstVisitor {
    constructor() {
        super(...arguments);
        this.allProductions = [];
    }
    visitNonTerminal(subrule) {
        this.allProductions.push(subrule);
    }
    visitOption(option) {
        this.allProductions.push(option);
    }
    visitRepetitionWithSeparator(manySep) {
        this.allProductions.push(manySep);
    }
    visitRepetitionMandatory(atLeastOne) {
        this.allProductions.push(atLeastOne);
    }
    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    }
    visitRepetition(many) {
        this.allProductions.push(many);
    }
    visitAlternation(or) {
        this.allProductions.push(or);
    }
    visitTerminal(terminal) {
        this.allProductions.push(terminal);
    }
}
function validateRuleDoesNotAlreadyExist(rule, allRules, className, errMsgProvider) {
    const errors = [];
    const occurrences = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(allRules, (result, curRule) => {
        if (curRule.name === rule.name) {
            return result + 1;
        }
        return result;
    }, 0);
    if (occurrences > 1) {
        const errMsg = errMsgProvider.buildDuplicateRuleNameError({
            topLevelRule: rule,
            grammarName: className,
        });
        errors.push({
            message: errMsg,
            type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
            ruleName: rule.name,
        });
    }
    return errors;
}
// TODO: is there anyway to get only the rule names of rules inherited from the super grammars?
// This is not part of the IGrammarErrorProvider because the validation cannot be performed on
// The grammar structure, only at runtime.
function validateRuleIsOverridden(ruleName, definedRulesNames, className) {
    const errors = [];
    let errMsg;
    if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(definedRulesNames, ruleName)) {
        errMsg =
            `Invalid rule override, rule: ->${ruleName}<- cannot be overridden in the grammar: ->${className}<-` +
                `as it is not defined in any of the super grammars `;
        errors.push({
            message: errMsg,
            type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.INVALID_RULE_OVERRIDE,
            ruleName: ruleName,
        });
    }
    return errors;
}
function validateNoLeftRecursion(topRule, currRule, errMsgProvider, path = []) {
    const errors = [];
    const nextNonTerminals = getFirstNoneTerminal(currRule.definition);
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(nextNonTerminals)) {
        return [];
    }
    else {
        const ruleName = topRule.name;
        const foundLeftRecursion = (0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(nextNonTerminals, topRule);
        if (foundLeftRecursion) {
            errors.push({
                message: errMsgProvider.buildLeftRecursionError({
                    topLevelRule: topRule,
                    leftRecursionPath: path,
                }),
                type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.LEFT_RECURSION,
                ruleName: ruleName,
            });
        }
        // we are only looking for cyclic paths leading back to the specific topRule
        // other cyclic paths are ignored, we still need this difference to avoid infinite loops...
        const validNextSteps = (0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(nextNonTerminals, path.concat([topRule]));
        const errorsFromNextSteps = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(validNextSteps, (currRefRule) => {
            const newPath = (0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(path);
            newPath.push(currRefRule);
            return validateNoLeftRecursion(topRule, currRefRule, errMsgProvider, newPath);
        });
        return errors.concat(errorsFromNextSteps);
    }
}
function getFirstNoneTerminal(definition) {
    let result = [];
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(definition)) {
        return result;
    }
    const firstProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(definition);
    /* istanbul ignore else */
    if (firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.NonTerminal) {
        result.push(firstProd.referencedRule);
    }
    else if (firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Alternative ||
        firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Option ||
        firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatory ||
        firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.RepetitionMandatoryWithSeparator ||
        firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.RepetitionWithSeparator ||
        firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Repetition) {
        result = result.concat(getFirstNoneTerminal(firstProd.definition));
    }
    else if (firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Alternation) {
        // each sub definition in alternation is a FLAT
        result = (0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(firstProd.definition, (currSubDef) => getFirstNoneTerminal(currSubDef.definition)));
    }
    else if (firstProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.Terminal) {
        // nothing to see, move along
    }
    else {
        throw Error("non exhaustive match");
    }
    const isFirstOptional = (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.isOptionalProd)(firstProd);
    const hasMore = definition.length > 1;
    if (isFirstOptional && hasMore) {
        const rest = (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(definition);
        return result.concat(getFirstNoneTerminal(rest));
    }
    else {
        return result;
    }
}
class OrCollector extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.GAstVisitor {
    constructor() {
        super(...arguments);
        this.alternations = [];
    }
    visitAlternation(node) {
        this.alternations.push(node);
    }
}
function validateEmptyOrAlternative(topLevelRule, errMsgProvider) {
    const orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    const ors = orCollector.alternations;
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(ors, (currOr) => {
        const exceptLast = (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(currOr.definition);
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(exceptLast, (currAlternative, currAltIdx) => {
            const possibleFirstInAlt = (0,_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.nextPossibleTokensAfter)([currAlternative], [], _scan_tokens_js__WEBPACK_IMPORTED_MODULE_4__.tokenStructuredMatcher, 1);
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(possibleFirstInAlt)) {
                return [
                    {
                        message: errMsgProvider.buildEmptyAlternationError({
                            topLevelRule: topLevelRule,
                            alternation: currOr,
                            emptyChoiceIdx: currAltIdx,
                        }),
                        type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.NONE_LAST_EMPTY_ALT,
                        ruleName: topLevelRule.name,
                        occurrence: currOr.idx,
                        alternative: currAltIdx + 1,
                    },
                ];
            }
            else {
                return [];
            }
        });
    });
    return errors;
}
function validateAmbiguousAlternationAlternatives(topLevelRule, globalMaxLookahead, errMsgProvider) {
    const orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    let ors = orCollector.alternations;
    // New Handling of ignoring ambiguities
    // - https://github.com/chevrotain/chevrotain/issues/869
    ors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(ors, (currOr) => currOr.ignoreAmbiguities === true);
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(ors, (currOr) => {
        const currOccurrence = currOr.idx;
        const actualMaxLookahead = currOr.maxLookahead || globalMaxLookahead;
        const alternatives = (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.getLookaheadPathsForOr)(currOccurrence, topLevelRule, actualMaxLookahead, currOr);
        const altsAmbiguityErrors = checkAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        const altsPrefixAmbiguityErrors = checkPrefixAlternativesAmbiguities(alternatives, currOr, topLevelRule, errMsgProvider);
        return altsAmbiguityErrors.concat(altsPrefixAmbiguityErrors);
    });
    return errors;
}
class RepetitionCollector extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.GAstVisitor {
    constructor() {
        super(...arguments);
        this.allProductions = [];
    }
    visitRepetitionWithSeparator(manySep) {
        this.allProductions.push(manySep);
    }
    visitRepetitionMandatory(atLeastOne) {
        this.allProductions.push(atLeastOne);
    }
    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
        this.allProductions.push(atLeastOneSep);
    }
    visitRepetition(many) {
        this.allProductions.push(many);
    }
}
function validateTooManyAlts(topLevelRule, errMsgProvider) {
    const orCollector = new OrCollector();
    topLevelRule.accept(orCollector);
    const ors = orCollector.alternations;
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(ors, (currOr) => {
        if (currOr.definition.length > 255) {
            return [
                {
                    message: errMsgProvider.buildTooManyAlternativesError({
                        topLevelRule: topLevelRule,
                        alternation: currOr,
                    }),
                    type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.TOO_MANY_ALTS,
                    ruleName: topLevelRule.name,
                    occurrence: currOr.idx,
                },
            ];
        }
        else {
            return [];
        }
    });
    return errors;
}
function validateSomeNonEmptyLookaheadPath(topLevelRules, maxLookahead, errMsgProvider) {
    const errors = [];
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(topLevelRules, (currTopRule) => {
        const collectorVisitor = new RepetitionCollector();
        currTopRule.accept(collectorVisitor);
        const allRuleProductions = collectorVisitor.allProductions;
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(allRuleProductions, (currProd) => {
            const prodType = (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.getProdType)(currProd);
            const actualMaxLookahead = currProd.maxLookahead || maxLookahead;
            const currOccurrence = currProd.idx;
            const paths = (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.getLookaheadPathsForOptionalProd)(currOccurrence, currTopRule, prodType, actualMaxLookahead);
            const pathsInsideProduction = paths[0];
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(pathsInsideProduction))) {
                const errMsg = errMsgProvider.buildEmptyRepetitionError({
                    topLevelRule: currTopRule,
                    repetition: currProd,
                });
                errors.push({
                    message: errMsg,
                    type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.NO_NON_EMPTY_LOOKAHEAD,
                    ruleName: currTopRule.name,
                });
            }
        });
    });
    return errors;
}
function checkAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    const foundAmbiguousPaths = [];
    const identicalAmbiguities = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(alternatives, (result, currAlt, currAltIdx) => {
        // ignore (skip) ambiguities with this alternative
        if (alternation.definition[currAltIdx].ignoreAmbiguities === true) {
            return result;
        }
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(currAlt, (currPath) => {
            const altsCurrPathAppearsIn = [currAltIdx];
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(alternatives, (currOtherAlt, currOtherAltIdx) => {
                if (currAltIdx !== currOtherAltIdx &&
                    (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.containsPath)(currOtherAlt, currPath) &&
                    // ignore (skip) ambiguities with this "other" alternative
                    alternation.definition[currOtherAltIdx].ignoreAmbiguities !== true) {
                    altsCurrPathAppearsIn.push(currOtherAltIdx);
                }
            });
            if (altsCurrPathAppearsIn.length > 1 &&
                !(0,_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.containsPath)(foundAmbiguousPaths, currPath)) {
                foundAmbiguousPaths.push(currPath);
                result.push({
                    alts: altsCurrPathAppearsIn,
                    path: currPath,
                });
            }
        });
        return result;
    }, []);
    const currErrors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(identicalAmbiguities, (currAmbDescriptor) => {
        const ambgIndices = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(currAmbDescriptor.alts, (currAltIdx) => currAltIdx + 1);
        const currMessage = errMsgProvider.buildAlternationAmbiguityError({
            topLevelRule: rule,
            alternation: alternation,
            ambiguityIndices: ambgIndices,
            prefixPath: currAmbDescriptor.path,
        });
        return {
            message: currMessage,
            type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.AMBIGUOUS_ALTS,
            ruleName: rule.name,
            occurrence: alternation.idx,
            alternatives: currAmbDescriptor.alts,
        };
    });
    return currErrors;
}
function checkPrefixAlternativesAmbiguities(alternatives, alternation, rule, errMsgProvider) {
    // flatten
    const pathsAndIndices = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(alternatives, (result, currAlt, idx) => {
        const currPathsAndIdx = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(currAlt, (currPath) => {
            return { idx: idx, path: currPath };
        });
        return result.concat(currPathsAndIdx);
    }, []);
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_21__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(pathsAndIndices, (currPathAndIdx) => {
        const alternativeGast = alternation.definition[currPathAndIdx.idx];
        // ignore (skip) ambiguities with this alternative
        if (alternativeGast.ignoreAmbiguities === true) {
            return [];
        }
        const targetIdx = currPathAndIdx.idx;
        const targetPath = currPathAndIdx.path;
        const prefixAmbiguitiesPathsAndIndices = (0,lodash_es__WEBPACK_IMPORTED_MODULE_22__["default"])(pathsAndIndices, (searchPathAndIdx) => {
            // prefix ambiguity can only be created from lower idx (higher priority) path
            return (
            // ignore (skip) ambiguities with this "other" alternative
            alternation.definition[searchPathAndIdx.idx].ignoreAmbiguities !==
                true &&
                searchPathAndIdx.idx < targetIdx &&
                // checking for strict prefix because identical lookaheads
                // will be be detected using a different validation.
                (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.isStrictPrefixOfPath)(searchPathAndIdx.path, targetPath));
        });
        const currPathPrefixErrors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(prefixAmbiguitiesPathsAndIndices, (currAmbPathAndIdx) => {
            const ambgIndices = [currAmbPathAndIdx.idx + 1, targetIdx + 1];
            const occurrence = alternation.idx === 0 ? "" : alternation.idx;
            const message = errMsgProvider.buildAlternationPrefixAmbiguityError({
                topLevelRule: rule,
                alternation: alternation,
                ambiguityIndices: ambgIndices,
                prefixPath: currAmbPathAndIdx.path,
            });
            return {
                message: message,
                type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.AMBIGUOUS_PREFIX_ALTS,
                ruleName: rule.name,
                occurrence: occurrence,
                alternatives: ambgIndices,
            };
        });
        return currPathPrefixErrors;
    }));
    return errors;
}
function checkTerminalAndNoneTerminalsNameSpace(topLevels, tokenTypes, errMsgProvider) {
    const errors = [];
    const tokenNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(tokenTypes, (currToken) => currToken.name);
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(topLevels, (currRule) => {
        const currRuleName = currRule.name;
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(tokenNames, currRuleName)) {
            const errMsg = errMsgProvider.buildNamespaceConflictError(currRule);
            errors.push({
                message: errMsg,
                type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.CONFLICT_TOKENS_RULES_NAMESPACE,
                ruleName: currRuleName,
            });
        }
    });
    return errors;
}
//# sourceMappingURL=checks.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/first.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/first.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   first: () => (/* binding */ first),
/* harmony export */   firstForBranching: () => (/* binding */ firstForBranching),
/* harmony export */   firstForSequence: () => (/* binding */ firstForSequence),
/* harmony export */   firstForTerminal: () => (/* binding */ firstForTerminal)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/uniq.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");


function first(prod) {
    /* istanbul ignore else */
    if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
        // this could in theory cause infinite loops if
        // (1) prod A refs prod B.
        // (2) prod B refs prod A
        // (3) AB can match the empty set
        // in other words a cycle where everything is optional so the first will keep
        // looking ahead for the next optional part and will never exit
        // currently there is no safeguard for this unique edge case because
        // (1) not sure a grammar in which this can happen is useful for anything (productive)
        return first(prod.referencedRule);
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Terminal) {
        return firstForTerminal(prod);
    }
    else if ((0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.isSequenceProd)(prod)) {
        return firstForSequence(prod);
    }
    else if ((0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.isBranchingProd)(prod)) {
        return firstForBranching(prod);
    }
    else {
        throw Error("non exhaustive match");
    }
}
function firstForSequence(prod) {
    let firstSet = [];
    const seq = prod.definition;
    let nextSubProdIdx = 0;
    let hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    let currSubProd;
    // so we enter the loop at least once (if the definition is not empty
    let isLastInnerProdOptional = true;
    // scan a sequence until it's end or until we have found a NONE optional production in it
    while (hasInnerProdsRemaining && isLastInnerProdOptional) {
        currSubProd = seq[nextSubProdIdx];
        isLastInnerProdOptional = (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.isOptionalProd)(currSubProd);
        firstSet = firstSet.concat(first(currSubProd));
        nextSubProdIdx = nextSubProdIdx + 1;
        hasInnerProdsRemaining = seq.length > nextSubProdIdx;
    }
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(firstSet);
}
function firstForBranching(prod) {
    const allAlternativesFirsts = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(prod.definition, (innerProd) => {
        return first(innerProd);
    });
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(allAlternativesFirsts));
}
function firstForTerminal(terminal) {
    return [terminal.terminalType];
}
//# sourceMappingURL=first.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/follow.js":
/*!*****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/follow.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ResyncFollowsWalker: () => (/* binding */ ResyncFollowsWalker),
/* harmony export */   buildBetweenProdsFollowPrefix: () => (/* binding */ buildBetweenProdsFollowPrefix),
/* harmony export */   buildInProdFollowPrefix: () => (/* binding */ buildInProdFollowPrefix),
/* harmony export */   computeAllProdsFollows: () => (/* binding */ computeAllProdsFollows)
/* harmony export */ });
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./rest.js */ "./node_modules/chevrotain/lib/src/parse/grammar/rest.js");
/* harmony import */ var _first_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./first.js */ "./node_modules/chevrotain/lib/src/parse/grammar/first.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/assign.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants.js */ "./node_modules/chevrotain/lib/src/parse/constants.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");





// This ResyncFollowsWalker computes all of the follows required for RESYNC
// (skipping reference production).
class ResyncFollowsWalker extends _rest_js__WEBPACK_IMPORTED_MODULE_0__.RestWalker {
    constructor(topProd) {
        super();
        this.topProd = topProd;
        this.follows = {};
    }
    startWalking() {
        this.walk(this.topProd);
        return this.follows;
    }
    walkTerminal(terminal, currRest, prevRest) {
        // do nothing! just like in the public sector after 13:00
    }
    walkProdRef(refProd, currRest, prevRest) {
        const followName = buildBetweenProdsFollowPrefix(refProd.referencedRule, refProd.idx) +
            this.topProd.name;
        const fullRest = currRest.concat(prevRest);
        const restProd = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.Alternative({ definition: fullRest });
        const t_in_topProd_follows = (0,_first_js__WEBPACK_IMPORTED_MODULE_1__.first)(restProd);
        this.follows[followName] = t_in_topProd_follows;
    }
}
function computeAllProdsFollows(topProductions) {
    const reSyncFollows = {};
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(topProductions, (topProd) => {
        const currRefsFollow = new ResyncFollowsWalker(topProd).startWalking();
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(reSyncFollows, currRefsFollow);
    });
    return reSyncFollows;
}
function buildBetweenProdsFollowPrefix(inner, occurenceInParent) {
    return inner.name + occurenceInParent + _constants_js__WEBPACK_IMPORTED_MODULE_2__.IN;
}
function buildInProdFollowPrefix(terminal) {
    const terminalName = terminal.terminalType.name;
    return terminalName + terminal.idx + _constants_js__WEBPACK_IMPORTED_MODULE_2__.IN;
}
//# sourceMappingURL=follow.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js":
/*!************************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   resolveGrammar: () => (/* binding */ resolveGrammar),
/* harmony export */   validateGrammar: () => (/* binding */ validateGrammar)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/defaults.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var _resolver_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../resolver.js */ "./node_modules/chevrotain/lib/src/parse/grammar/resolver.js");
/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../checks.js */ "./node_modules/chevrotain/lib/src/parse/grammar/checks.js");
/* harmony import */ var _errors_public_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors_public.js */ "./node_modules/chevrotain/lib/src/parse/errors_public.js");




function resolveGrammar(options) {
    const actualOptions = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, {
        errMsgProvider: _errors_public_js__WEBPACK_IMPORTED_MODULE_2__.defaultGrammarResolverErrorProvider,
    });
    const topRulesTable = {};
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(options.rules, (rule) => {
        topRulesTable[rule.name] = rule;
    });
    return (0,_resolver_js__WEBPACK_IMPORTED_MODULE_0__.resolveGrammar)(topRulesTable, actualOptions.errMsgProvider);
}
function validateGrammar(options) {
    options = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(options, {
        errMsgProvider: _errors_public_js__WEBPACK_IMPORTED_MODULE_2__.defaultGrammarValidatorErrorProvider,
    });
    return (0,_checks_js__WEBPACK_IMPORTED_MODULE_1__.validateGrammar)(options.rules, options.tokenTypes, options.errMsgProvider, options.grammarName);
}
//# sourceMappingURL=gast_resolver_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractNextPossibleTokensWalker: () => (/* binding */ AbstractNextPossibleTokensWalker),
/* harmony export */   AbstractNextTerminalAfterProductionWalker: () => (/* binding */ AbstractNextTerminalAfterProductionWalker),
/* harmony export */   NextAfterTokenWalker: () => (/* binding */ NextAfterTokenWalker),
/* harmony export */   NextTerminalAfterAtLeastOneSepWalker: () => (/* binding */ NextTerminalAfterAtLeastOneSepWalker),
/* harmony export */   NextTerminalAfterAtLeastOneWalker: () => (/* binding */ NextTerminalAfterAtLeastOneWalker),
/* harmony export */   NextTerminalAfterManySepWalker: () => (/* binding */ NextTerminalAfterManySepWalker),
/* harmony export */   NextTerminalAfterManyWalker: () => (/* binding */ NextTerminalAfterManyWalker),
/* harmony export */   nextPossibleTokensAfter: () => (/* binding */ nextPossibleTokensAfter),
/* harmony export */   possiblePathsFrom: () => (/* binding */ possiblePathsFrom)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/head.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/drop.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/last.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/dropRight.js");
/* harmony import */ var _first_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./first.js */ "./node_modules/chevrotain/lib/src/parse/grammar/first.js");
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rest.js */ "./node_modules/chevrotain/lib/src/parse/grammar/rest.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");




class AbstractNextPossibleTokensWalker extends _rest_js__WEBPACK_IMPORTED_MODULE_1__.RestWalker {
    constructor(topProd, path) {
        super();
        this.topProd = topProd;
        this.path = path;
        this.possibleTokTypes = [];
        this.nextProductionName = "";
        this.nextProductionOccurrence = 0;
        this.found = false;
        this.isAtEndOfPath = false;
    }
    startWalking() {
        this.found = false;
        if (this.path.ruleStack[0] !== this.topProd.name) {
            throw Error("The path does not start with the walker's top Rule!");
        }
        // immutable for the win
        this.ruleStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(this.path.ruleStack).reverse(); // intelij bug requires assertion
        this.occurrenceStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(this.path.occurrenceStack).reverse(); // intelij bug requires assertion
        // already verified that the first production is valid, we now seek the 2nd production
        this.ruleStack.pop();
        this.occurrenceStack.pop();
        this.updateExpectedNext();
        this.walk(this.topProd);
        return this.possibleTokTypes;
    }
    walk(prod, prevRest = []) {
        // stop scanning once we found the path
        if (!this.found) {
            super.walk(prod, prevRest);
        }
    }
    walkProdRef(refProd, currRest, prevRest) {
        // found the next production, need to keep walking in it
        if (refProd.referencedRule.name === this.nextProductionName &&
            refProd.idx === this.nextProductionOccurrence) {
            const fullRest = currRest.concat(prevRest);
            this.updateExpectedNext();
            this.walk(refProd.referencedRule, fullRest);
        }
    }
    updateExpectedNext() {
        // need to consume the Terminal
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(this.ruleStack)) {
            // must reset nextProductionXXX to avoid walking down another Top Level production while what we are
            // really seeking is the last Terminal...
            this.nextProductionName = "";
            this.nextProductionOccurrence = 0;
            this.isAtEndOfPath = true;
        }
        else {
            this.nextProductionName = this.ruleStack.pop();
            this.nextProductionOccurrence = this.occurrenceStack.pop();
        }
    }
}
class NextAfterTokenWalker extends AbstractNextPossibleTokensWalker {
    constructor(topProd, path) {
        super(topProd, path);
        this.path = path;
        this.nextTerminalName = "";
        this.nextTerminalOccurrence = 0;
        this.nextTerminalName = this.path.lastTok.name;
        this.nextTerminalOccurrence = this.path.lastTokOccurrence;
    }
    walkTerminal(terminal, currRest, prevRest) {
        if (this.isAtEndOfPath &&
            terminal.terminalType.name === this.nextTerminalName &&
            terminal.idx === this.nextTerminalOccurrence &&
            !this.found) {
            const fullRest = currRest.concat(prevRest);
            const restProd = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Alternative({ definition: fullRest });
            this.possibleTokTypes = (0,_first_js__WEBPACK_IMPORTED_MODULE_0__.first)(restProd);
            this.found = true;
        }
    }
}
/**
 * This walker only "walks" a single "TOP" level in the Grammar Ast, this means
 * it never "follows" production refs
 */
class AbstractNextTerminalAfterProductionWalker extends _rest_js__WEBPACK_IMPORTED_MODULE_1__.RestWalker {
    constructor(topRule, occurrence) {
        super();
        this.topRule = topRule;
        this.occurrence = occurrence;
        this.result = {
            token: undefined,
            occurrence: undefined,
            isEndOfRule: undefined,
        };
    }
    startWalking() {
        this.walk(this.topRule);
        return this.result;
    }
}
class NextTerminalAfterManyWalker extends AbstractNextTerminalAfterProductionWalker {
    walkMany(manyProd, currRest, prevRest) {
        if (manyProd.idx === this.occurrence) {
            const firstAfterMany = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterMany === undefined;
            if (firstAfterMany instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
                this.result.token = firstAfterMany.terminalType;
                this.result.occurrence = firstAfterMany.idx;
            }
        }
        else {
            super.walkMany(manyProd, currRest, prevRest);
        }
    }
}
class NextTerminalAfterManySepWalker extends AbstractNextTerminalAfterProductionWalker {
    walkManySep(manySepProd, currRest, prevRest) {
        if (manySepProd.idx === this.occurrence) {
            const firstAfterManySep = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterManySep === undefined;
            if (firstAfterManySep instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
                this.result.token = firstAfterManySep.terminalType;
                this.result.occurrence = firstAfterManySep.idx;
            }
        }
        else {
            super.walkManySep(manySepProd, currRest, prevRest);
        }
    }
}
class NextTerminalAfterAtLeastOneWalker extends AbstractNextTerminalAfterProductionWalker {
    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
        if (atLeastOneProd.idx === this.occurrence) {
            const firstAfterAtLeastOne = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterAtLeastOne === undefined;
            if (firstAfterAtLeastOne instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
                this.result.token = firstAfterAtLeastOne.terminalType;
                this.result.occurrence = firstAfterAtLeastOne.idx;
            }
        }
        else {
            super.walkAtLeastOne(atLeastOneProd, currRest, prevRest);
        }
    }
}
// TODO: reduce code duplication in the AfterWalkers
class NextTerminalAfterAtLeastOneSepWalker extends AbstractNextTerminalAfterProductionWalker {
    walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest) {
        if (atleastOneSepProd.idx === this.occurrence) {
            const firstAfterfirstAfterAtLeastOneSep = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(currRest.concat(prevRest));
            this.result.isEndOfRule = firstAfterfirstAfterAtLeastOneSep === undefined;
            if (firstAfterfirstAfterAtLeastOneSep instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
                this.result.token = firstAfterfirstAfterAtLeastOneSep.terminalType;
                this.result.occurrence = firstAfterfirstAfterAtLeastOneSep.idx;
            }
        }
        else {
            super.walkAtLeastOneSep(atleastOneSepProd, currRest, prevRest);
        }
    }
}
function possiblePathsFrom(targetDef, maxLength, currPath = []) {
    // avoid side effects
    currPath = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(currPath);
    let result = [];
    let i = 0;
    // TODO: avoid inner funcs
    function remainingPathWith(nextDef) {
        return nextDef.concat((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(targetDef, i + 1));
    }
    // TODO: avoid inner funcs
    function getAlternativesForProd(definition) {
        const alternatives = possiblePathsFrom(remainingPathWith(definition), maxLength, currPath);
        return result.concat(alternatives);
    }
    /**
     * Mandatory productions will halt the loop as the paths computed from their recursive calls will already contain the
     * following (rest) of the targetDef.
     *
     * For optional productions (Option/Repetition/...) the loop will continue to represent the paths that do not include the
     * the optional production.
     */
    while (currPath.length < maxLength && i < targetDef.length) {
        const prod = targetDef[i];
        /* istanbul ignore else */
        if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Alternative) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.NonTerminal) {
            return getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Option) {
            result = getAlternativesForProd(prod.definition);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatory) {
            const newDef = prod.definition.concat([
                new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                    definition: prod.definition,
                }),
            ]);
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatoryWithSeparator) {
            const newDef = [
                new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Alternative({ definition: prod.definition }),
                new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                    definition: [new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal({ terminalType: prod.separator })].concat(prod.definition),
                }),
            ];
            return getAlternativesForProd(newDef);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.RepetitionWithSeparator) {
            const newDef = prod.definition.concat([
                new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                    definition: [new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal({ terminalType: prod.separator })].concat(prod.definition),
                }),
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition) {
            const newDef = prod.definition.concat([
                new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                    definition: prod.definition,
                }),
            ]);
            result = getAlternativesForProd(newDef);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Alternation) {
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(prod.definition, (currAlt) => {
                // TODO: this is a limited check for empty alternatives
                //   It would prevent a common case of infinite loops during parser initialization.
                //   However **in-directly** empty alternatives may still cause issues.
                if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(currAlt.definition) === false) {
                    result = getAlternativesForProd(currAlt.definition);
                }
            });
            return result;
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
            currPath.push(prod.terminalType);
        }
        else {
            throw Error("non exhaustive match");
        }
        i++;
    }
    result.push({
        partialPath: currPath,
        suffixDef: (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(targetDef, i),
    });
    return result;
}
function nextPossibleTokensAfter(initialDef, tokenVector, tokMatcher, maxLookAhead) {
    const EXIT_NON_TERMINAL = "EXIT_NONE_TERMINAL";
    // to avoid creating a new Array each time.
    const EXIT_NON_TERMINAL_ARR = [EXIT_NON_TERMINAL];
    const EXIT_ALTERNATIVE = "EXIT_ALTERNATIVE";
    let foundCompletePath = false;
    const tokenVectorLength = tokenVector.length;
    const minimalAlternativesIndex = tokenVectorLength - maxLookAhead - 1;
    const result = [];
    const possiblePaths = [];
    possiblePaths.push({
        idx: -1,
        def: initialDef,
        ruleStack: [],
        occurrenceStack: [],
    });
    while (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(possiblePaths)) {
        const currPath = possiblePaths.pop();
        // skip alternatives if no more results can be found (assuming deterministic grammar with fixed lookahead)
        if (currPath === EXIT_ALTERNATIVE) {
            if (foundCompletePath &&
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(possiblePaths).idx <= minimalAlternativesIndex) {
                // remove irrelevant alternative
                possiblePaths.pop();
            }
            continue;
        }
        const currDef = currPath.def;
        const currIdx = currPath.idx;
        const currRuleStack = currPath.ruleStack;
        const currOccurrenceStack = currPath.occurrenceStack;
        // For Example: an empty path could exist in a valid grammar in the case of an EMPTY_ALT
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(currDef)) {
            continue;
        }
        const prod = currDef[0];
        /* istanbul ignore else */
        if (prod === EXIT_NON_TERMINAL) {
            const nextPath = {
                idx: currIdx,
                def: (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef),
                ruleStack: (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(currRuleStack),
                occurrenceStack: (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(currOccurrenceStack),
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal) {
            /* istanbul ignore else */
            if (currIdx < tokenVectorLength - 1) {
                const nextIdx = currIdx + 1;
                const actualToken = tokenVector[nextIdx];
                if (tokMatcher(actualToken, prod.terminalType)) {
                    const nextPath = {
                        idx: nextIdx,
                        def: (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef),
                        ruleStack: currRuleStack,
                        occurrenceStack: currOccurrenceStack,
                    };
                    possiblePaths.push(nextPath);
                }
                // end of the line
            }
            else if (currIdx === tokenVectorLength - 1) {
                // IGNORE ABOVE ELSE
                result.push({
                    nextTokenType: prod.terminalType,
                    nextTokenOccurrence: prod.idx,
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack,
                });
                foundCompletePath = true;
            }
            else {
                throw Error("non exhaustive match");
            }
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.NonTerminal) {
            const newRuleStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(currRuleStack);
            newRuleStack.push(prod.nonTerminalName);
            const newOccurrenceStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(currOccurrenceStack);
            newOccurrenceStack.push(prod.idx);
            const nextPath = {
                idx: currIdx,
                def: prod.definition.concat(EXIT_NON_TERMINAL_ARR, (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef)),
                ruleStack: newRuleStack,
                occurrenceStack: newOccurrenceStack,
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Option) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            const nextPathWithout = {
                idx: currIdx,
                def: (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            const nextPathWith = {
                idx: currIdx,
                def: prod.definition.concat((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatory) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            const secondIteration = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                definition: prod.definition,
                idx: prod.idx,
            });
            const nextDef = prod.definition.concat([secondIteration], (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef));
            const nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.RepetitionMandatoryWithSeparator) {
            // TODO:(THE NEW operators here take a while...) (convert once?)
            const separatorGast = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal({
                terminalType: prod.separator,
            });
            const secondIteration = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx,
            });
            const nextDef = prod.definition.concat([secondIteration], (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef));
            const nextPath = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPath);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.RepetitionWithSeparator) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            const nextPathWithout = {
                idx: currIdx,
                def: (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            const separatorGast = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Terminal({
                terminalType: prod.separator,
            });
            const nthRepetition = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                definition: [separatorGast].concat(prod.definition),
                idx: prod.idx,
            });
            const nextDef = prod.definition.concat([nthRepetition], (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef));
            const nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            const nextPathWithout = {
                idx: currIdx,
                def: (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPathWithout);
            // required marker to avoid backtracking paths whose higher priority alternatives already matched
            possiblePaths.push(EXIT_ALTERNATIVE);
            // TODO: an empty repetition will cause infinite loops here, will the parser detect this in selfAnalysis?
            const nthRepetition = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Repetition({
                definition: prod.definition,
                idx: prod.idx,
            });
            const nextDef = prod.definition.concat([nthRepetition], (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef));
            const nextPathWith = {
                idx: currIdx,
                def: nextDef,
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            };
            possiblePaths.push(nextPathWith);
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Alternation) {
            // the order of alternatives is meaningful, FILO (Last path will be traversed first).
            for (let i = prod.definition.length - 1; i >= 0; i--) {
                const currAlt = prod.definition[i];
                const currAltPath = {
                    idx: currIdx,
                    def: currAlt.definition.concat((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef)),
                    ruleStack: currRuleStack,
                    occurrenceStack: currOccurrenceStack,
                };
                possiblePaths.push(currAltPath);
                possiblePaths.push(EXIT_ALTERNATIVE);
            }
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Alternative) {
            possiblePaths.push({
                idx: currIdx,
                def: prod.definition.concat((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currDef)),
                ruleStack: currRuleStack,
                occurrenceStack: currOccurrenceStack,
            });
        }
        else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.Rule) {
            // last because we should only encounter at most a single one of these per invocation.
            possiblePaths.push(expandTopLevelRule(prod, currIdx, currRuleStack, currOccurrenceStack));
        }
        else {
            throw Error("non exhaustive match");
        }
    }
    return result;
}
function expandTopLevelRule(topRule, currIdx, currRuleStack, currOccurrenceStack) {
    const newRuleStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(currRuleStack);
    newRuleStack.push(topRule.name);
    const newCurrOccurrenceStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(currOccurrenceStack);
    // top rule is always assumed to have been called with occurrence index 1
    newCurrOccurrenceStack.push(1);
    return {
        idx: currIdx,
        def: topRule.definition,
        ruleStack: newRuleStack,
        occurrenceStack: newCurrOccurrenceStack,
    };
}
//# sourceMappingURL=interpreter.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/keys.js":
/*!***************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/keys.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AT_LEAST_ONE_IDX: () => (/* binding */ AT_LEAST_ONE_IDX),
/* harmony export */   AT_LEAST_ONE_SEP_IDX: () => (/* binding */ AT_LEAST_ONE_SEP_IDX),
/* harmony export */   BITS_FOR_ALT_IDX: () => (/* binding */ BITS_FOR_ALT_IDX),
/* harmony export */   BITS_FOR_METHOD_TYPE: () => (/* binding */ BITS_FOR_METHOD_TYPE),
/* harmony export */   BITS_FOR_OCCURRENCE_IDX: () => (/* binding */ BITS_FOR_OCCURRENCE_IDX),
/* harmony export */   BITS_FOR_RULE_IDX: () => (/* binding */ BITS_FOR_RULE_IDX),
/* harmony export */   MANY_IDX: () => (/* binding */ MANY_IDX),
/* harmony export */   MANY_SEP_IDX: () => (/* binding */ MANY_SEP_IDX),
/* harmony export */   OPTION_IDX: () => (/* binding */ OPTION_IDX),
/* harmony export */   OR_IDX: () => (/* binding */ OR_IDX),
/* harmony export */   getKeyForAutomaticLookahead: () => (/* binding */ getKeyForAutomaticLookahead)
/* harmony export */ });
// Lookahead keys are 32Bit integers in the form
// TTTTTTTT-ZZZZZZZZZZZZ-YYYY-XXXXXXXX
// XXXX -> Occurrence Index bitmap.
// YYYY -> DSL Method Type bitmap.
// ZZZZZZZZZZZZZZZ -> Rule short Index bitmap.
// TTTTTTTTT -> alternation alternative index bitmap
const BITS_FOR_METHOD_TYPE = 4;
const BITS_FOR_OCCURRENCE_IDX = 8;
const BITS_FOR_RULE_IDX = 12;
// TODO: validation, this means that there may at most 2^8 --> 256 alternatives for an alternation.
const BITS_FOR_ALT_IDX = 8;
// short string used as part of mapping keys.
// being short improves the performance when composing KEYS for maps out of these
// The 5 - 8 bits (16 possible values, are reserved for the DSL method indices)
const OR_IDX = 1 << BITS_FOR_OCCURRENCE_IDX;
const OPTION_IDX = 2 << BITS_FOR_OCCURRENCE_IDX;
const MANY_IDX = 3 << BITS_FOR_OCCURRENCE_IDX;
const AT_LEAST_ONE_IDX = 4 << BITS_FOR_OCCURRENCE_IDX;
const MANY_SEP_IDX = 5 << BITS_FOR_OCCURRENCE_IDX;
const AT_LEAST_ONE_SEP_IDX = 6 << BITS_FOR_OCCURRENCE_IDX;
// this actually returns a number, but it is always used as a string (object prop key)
function getKeyForAutomaticLookahead(ruleIdx, dslMethodIdx, occurrence) {
    return occurrence | dslMethodIdx | ruleIdx;
}
const BITS_START_FOR_ALT_IDX = 32 - BITS_FOR_ALT_IDX;
//# sourceMappingURL=keys.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js":
/*!************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LLkLookaheadStrategy: () => (/* binding */ LLkLookaheadStrategy)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatMap.js");
/* harmony import */ var _errors_public_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../errors_public.js */ "./node_modules/chevrotain/lib/src/parse/errors_public.js");
/* harmony import */ var _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser/parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _checks_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./checks.js */ "./node_modules/chevrotain/lib/src/parse/grammar/checks.js");
/* harmony import */ var _lookahead_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js");





class LLkLookaheadStrategy {
    constructor(options) {
        var _a;
        this.maxLookahead =
            (_a = options === null || options === void 0 ? void 0 : options.maxLookahead) !== null && _a !== void 0 ? _a : _parser_parser_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PARSER_CONFIG.maxLookahead;
    }
    validate(options) {
        const leftRecursionErrors = this.validateNoLeftRecursion(options.rules);
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(leftRecursionErrors)) {
            const emptyAltErrors = this.validateEmptyOrAlternatives(options.rules);
            const ambiguousAltsErrors = this.validateAmbiguousAlternationAlternatives(options.rules, this.maxLookahead);
            const emptyRepetitionErrors = this.validateSomeNonEmptyLookaheadPath(options.rules, this.maxLookahead);
            const allErrors = [
                ...leftRecursionErrors,
                ...emptyAltErrors,
                ...ambiguousAltsErrors,
                ...emptyRepetitionErrors,
            ];
            return allErrors;
        }
        return leftRecursionErrors;
    }
    validateNoLeftRecursion(rules) {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(rules, (currTopRule) => (0,_checks_js__WEBPACK_IMPORTED_MODULE_2__.validateNoLeftRecursion)(currTopRule, currTopRule, _errors_public_js__WEBPACK_IMPORTED_MODULE_0__.defaultGrammarValidatorErrorProvider));
    }
    validateEmptyOrAlternatives(rules) {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(rules, (currTopRule) => (0,_checks_js__WEBPACK_IMPORTED_MODULE_2__.validateEmptyOrAlternative)(currTopRule, _errors_public_js__WEBPACK_IMPORTED_MODULE_0__.defaultGrammarValidatorErrorProvider));
    }
    validateAmbiguousAlternationAlternatives(rules, maxLookahead) {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(rules, (currTopRule) => (0,_checks_js__WEBPACK_IMPORTED_MODULE_2__.validateAmbiguousAlternationAlternatives)(currTopRule, maxLookahead, _errors_public_js__WEBPACK_IMPORTED_MODULE_0__.defaultGrammarValidatorErrorProvider));
    }
    validateSomeNonEmptyLookaheadPath(rules, maxLookahead) {
        return (0,_checks_js__WEBPACK_IMPORTED_MODULE_2__.validateSomeNonEmptyLookaheadPath)(rules, maxLookahead, _errors_public_js__WEBPACK_IMPORTED_MODULE_0__.defaultGrammarValidatorErrorProvider);
    }
    buildLookaheadForAlternation(options) {
        return (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_3__.buildLookaheadFuncForOr)(options.prodOccurrence, options.rule, options.maxLookahead, options.hasPredicates, options.dynamicTokensEnabled, _lookahead_js__WEBPACK_IMPORTED_MODULE_3__.buildAlternativesLookAheadFunc);
    }
    buildLookaheadForOptional(options) {
        return (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_3__.buildLookaheadFuncForOptionalProd)(options.prodOccurrence, options.rule, options.maxLookahead, options.dynamicTokensEnabled, (0,_lookahead_js__WEBPACK_IMPORTED_MODULE_3__.getProdType)(options.prodType), _lookahead_js__WEBPACK_IMPORTED_MODULE_3__.buildSingleAlternativeLookaheadFunction);
    }
}
//# sourceMappingURL=llk_lookahead.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js":
/*!********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PROD_TYPE: () => (/* binding */ PROD_TYPE),
/* harmony export */   areTokenCategoriesNotUsed: () => (/* binding */ areTokenCategoriesNotUsed),
/* harmony export */   buildAlternativesLookAheadFunc: () => (/* binding */ buildAlternativesLookAheadFunc),
/* harmony export */   buildLookaheadFuncForOptionalProd: () => (/* binding */ buildLookaheadFuncForOptionalProd),
/* harmony export */   buildLookaheadFuncForOr: () => (/* binding */ buildLookaheadFuncForOr),
/* harmony export */   buildSingleAlternativeLookaheadFunction: () => (/* binding */ buildSingleAlternativeLookaheadFunction),
/* harmony export */   containsPath: () => (/* binding */ containsPath),
/* harmony export */   getLookaheadPaths: () => (/* binding */ getLookaheadPaths),
/* harmony export */   getLookaheadPathsForOptionalProd: () => (/* binding */ getLookaheadPathsForOptionalProd),
/* harmony export */   getLookaheadPathsForOr: () => (/* binding */ getLookaheadPathsForOr),
/* harmony export */   getProdType: () => (/* binding */ getProdType),
/* harmony export */   isStrictPrefixOfPath: () => (/* binding */ isStrictPrefixOfPath),
/* harmony export */   lookAheadSequenceFromAlternatives: () => (/* binding */ lookAheadSequenceFromAlternatives)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/every.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var _interpreter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./interpreter.js */ "./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js");
/* harmony import */ var _rest_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./rest.js */ "./node_modules/chevrotain/lib/src/parse/grammar/rest.js");
/* harmony import */ var _scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scan/tokens.js */ "./node_modules/chevrotain/lib/src/scan/tokens.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");





var PROD_TYPE;
(function (PROD_TYPE) {
    PROD_TYPE[PROD_TYPE["OPTION"] = 0] = "OPTION";
    PROD_TYPE[PROD_TYPE["REPETITION"] = 1] = "REPETITION";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY"] = 2] = "REPETITION_MANDATORY";
    PROD_TYPE[PROD_TYPE["REPETITION_MANDATORY_WITH_SEPARATOR"] = 3] = "REPETITION_MANDATORY_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["REPETITION_WITH_SEPARATOR"] = 4] = "REPETITION_WITH_SEPARATOR";
    PROD_TYPE[PROD_TYPE["ALTERNATION"] = 5] = "ALTERNATION";
})(PROD_TYPE || (PROD_TYPE = {}));
function getProdType(prod) {
    /* istanbul ignore else */
    if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.Option || prod === "Option") {
        return PROD_TYPE.OPTION;
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.Repetition || prod === "Repetition") {
        return PROD_TYPE.REPETITION;
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatory ||
        prod === "RepetitionMandatory") {
        return PROD_TYPE.REPETITION_MANDATORY;
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.RepetitionMandatoryWithSeparator ||
        prod === "RepetitionMandatoryWithSeparator") {
        return PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR;
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.RepetitionWithSeparator ||
        prod === "RepetitionWithSeparator") {
        return PROD_TYPE.REPETITION_WITH_SEPARATOR;
    }
    else if (prod instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.Alternation || prod === "Alternation") {
        return PROD_TYPE.ALTERNATION;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function getLookaheadPaths(options) {
    const { occurrence, rule, prodType, maxLookahead } = options;
    const type = getProdType(prodType);
    if (type === PROD_TYPE.ALTERNATION) {
        return getLookaheadPathsForOr(occurrence, rule, maxLookahead);
    }
    else {
        return getLookaheadPathsForOptionalProd(occurrence, rule, type, maxLookahead);
    }
}
function buildLookaheadFuncForOr(occurrence, ruleGrammar, maxLookahead, hasPredicates, dynamicTokensEnabled, laFuncBuilder) {
    const lookAheadPaths = getLookaheadPathsForOr(occurrence, ruleGrammar, maxLookahead);
    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? _scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__.tokenStructuredMatcherNoCategories
        : _scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__.tokenStructuredMatcher;
    return laFuncBuilder(lookAheadPaths, hasPredicates, tokenMatcher, dynamicTokensEnabled);
}
/**
 *  When dealing with an Optional production (OPTION/MANY/2nd iteration of AT_LEAST_ONE/...) we need to compare
 *  the lookahead "inside" the production and the lookahead immediately "after" it in the same top level rule (context free).
 *
 *  Example: given a production:
 *  ABC(DE)?DF
 *
 *  The optional '(DE)?' should only be entered if we see 'DE'. a single Token 'D' is not sufficient to distinguish between the two
 *  alternatives.
 *
 *  @returns A Lookahead function which will return true IFF the parser should parse the Optional production.
 */
function buildLookaheadFuncForOptionalProd(occurrence, ruleGrammar, k, dynamicTokensEnabled, prodType, lookaheadBuilder) {
    const lookAheadPaths = getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k);
    const tokenMatcher = areTokenCategoriesNotUsed(lookAheadPaths)
        ? _scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__.tokenStructuredMatcherNoCategories
        : _scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__.tokenStructuredMatcher;
    return lookaheadBuilder(lookAheadPaths[0], tokenMatcher, dynamicTokensEnabled);
}
function buildAlternativesLookAheadFunc(alts, hasPredicates, tokenMatcher, dynamicTokensEnabled) {
    const numOfAlts = alts.length;
    const areAllOneTokenLookahead = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(alts, (currAlt) => {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(currAlt, (currPath) => {
            return currPath.length === 1;
        });
    });
    // This version takes into account the predicates as well.
    if (hasPredicates) {
        /**
         * @returns {number} - The chosen alternative index
         */
        return function (orAlts) {
            // unfortunately the predicates must be extracted every single time
            // as they cannot be cached due to references to parameters(vars) which are no longer valid.
            // note that in the common case of no predicates, no cpu time will be wasted on this (see else block)
            const predicates = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(orAlts, (currAlt) => currAlt.GATE);
            for (let t = 0; t < numOfAlts; t++) {
                const currAlt = alts[t];
                const currNumOfPaths = currAlt.length;
                const currPredicate = predicates[t];
                if (currPredicate !== undefined && currPredicate.call(this) === false) {
                    // if the predicate does not match there is no point in checking the paths
                    continue;
                }
                nextPath: for (let j = 0; j < currNumOfPaths; j++) {
                    const currPath = currAlt[j];
                    const currPathLength = currPath.length;
                    for (let i = 0; i < currPathLength; i++) {
                        const nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
    else if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        // optimized (common) case of all the lookaheads paths requiring only
        // a single token lookahead. These Optimizations cannot work if dynamically defined Tokens are used.
        const singleTokenAlts = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(alts, (currAlt) => {
            return (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currAlt);
        });
        const choiceToAlt = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(singleTokenAlts, (result, currAlt, idx) => {
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currAlt, (currTokType) => {
                if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(result, currTokType.tokenTypeIdx)) {
                    result[currTokType.tokenTypeIdx] = idx;
                }
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currTokType.categoryMatches, (currExtendingType) => {
                    if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(result, currExtendingType)) {
                        result[currExtendingType] = idx;
                    }
                });
            });
            return result;
        }, {});
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            const nextToken = this.LA(1);
            return choiceToAlt[nextToken.tokenTypeIdx];
        };
    }
    else {
        // optimized lookahead without needing to check the predicates at all.
        // this causes code duplication which is intentional to improve performance.
        /**
         * @returns {number} - The chosen alternative index
         */
        return function () {
            for (let t = 0; t < numOfAlts; t++) {
                const currAlt = alts[t];
                const currNumOfPaths = currAlt.length;
                nextPath: for (let j = 0; j < currNumOfPaths; j++) {
                    const currPath = currAlt[j];
                    const currPathLength = currPath.length;
                    for (let i = 0; i < currPathLength; i++) {
                        const nextToken = this.LA(i + 1);
                        if (tokenMatcher(nextToken, currPath[i]) === false) {
                            // mismatch in current path
                            // try the next pth
                            continue nextPath;
                        }
                    }
                    // found a full path that matches.
                    // this will also work for an empty ALT as the loop will be skipped
                    return t;
                }
                // none of the paths for the current alternative matched
                // try the next alternative
            }
            // none of the alternatives could be matched
            return undefined;
        };
    }
}
function buildSingleAlternativeLookaheadFunction(alt, tokenMatcher, dynamicTokensEnabled) {
    const areAllOneTokenLookahead = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(alt, (currPath) => {
        return currPath.length === 1;
    });
    const numOfPaths = alt.length;
    // optimized (common) case of all the lookaheads paths requiring only
    // a single token lookahead.
    if (areAllOneTokenLookahead && !dynamicTokensEnabled) {
        const singleTokensTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(alt);
        if (singleTokensTypes.length === 1 &&
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(singleTokensTypes[0].categoryMatches)) {
            const expectedTokenType = singleTokensTypes[0];
            const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
            return function () {
                return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
            };
        }
        else {
            const choiceToAlt = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(singleTokensTypes, (result, currTokType, idx) => {
                result[currTokType.tokenTypeIdx] = true;
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currTokType.categoryMatches, (currExtendingType) => {
                    result[currExtendingType] = true;
                });
                return result;
            }, []);
            return function () {
                const nextToken = this.LA(1);
                return choiceToAlt[nextToken.tokenTypeIdx] === true;
            };
        }
    }
    else {
        return function () {
            nextPath: for (let j = 0; j < numOfPaths; j++) {
                const currPath = alt[j];
                const currPathLength = currPath.length;
                for (let i = 0; i < currPathLength; i++) {
                    const nextToken = this.LA(i + 1);
                    if (tokenMatcher(nextToken, currPath[i]) === false) {
                        // mismatch in current path
                        // try the next pth
                        continue nextPath;
                    }
                }
                // found a full path that matches.
                return true;
            }
            // none of the paths matched
            return false;
        };
    }
}
class RestDefinitionFinderWalker extends _rest_js__WEBPACK_IMPORTED_MODULE_1__.RestWalker {
    constructor(topProd, targetOccurrence, targetProdType) {
        super();
        this.topProd = topProd;
        this.targetOccurrence = targetOccurrence;
        this.targetProdType = targetProdType;
    }
    startWalking() {
        this.walk(this.topProd);
        return this.restDef;
    }
    checkIsTarget(node, expectedProdType, currRest, prevRest) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdType) {
            this.restDef = currRest.concat(prevRest);
            return true;
        }
        // performance optimization, do not iterate over the entire Grammar ast after we have found the target
        return false;
    }
    walkOption(optionProd, currRest, prevRest) {
        if (!this.checkIsTarget(optionProd, PROD_TYPE.OPTION, currRest, prevRest)) {
            super.walkOption(optionProd, currRest, prevRest);
        }
    }
    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneProd, PROD_TYPE.REPETITION_MANDATORY, currRest, prevRest)) {
            super.walkOption(atLeastOneProd, currRest, prevRest);
        }
    }
    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {
        if (!this.checkIsTarget(atLeastOneSepProd, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, currRest, prevRest)) {
            super.walkOption(atLeastOneSepProd, currRest, prevRest);
        }
    }
    walkMany(manyProd, currRest, prevRest) {
        if (!this.checkIsTarget(manyProd, PROD_TYPE.REPETITION, currRest, prevRest)) {
            super.walkOption(manyProd, currRest, prevRest);
        }
    }
    walkManySep(manySepProd, currRest, prevRest) {
        if (!this.checkIsTarget(manySepProd, PROD_TYPE.REPETITION_WITH_SEPARATOR, currRest, prevRest)) {
            super.walkOption(manySepProd, currRest, prevRest);
        }
    }
}
/**
 * Returns the definition of a target production in a top level level rule.
 */
class InsideDefinitionFinderVisitor extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.GAstVisitor {
    constructor(targetOccurrence, targetProdType, targetRef) {
        super();
        this.targetOccurrence = targetOccurrence;
        this.targetProdType = targetProdType;
        this.targetRef = targetRef;
        this.result = [];
    }
    checkIsTarget(node, expectedProdName) {
        if (node.idx === this.targetOccurrence &&
            this.targetProdType === expectedProdName &&
            (this.targetRef === undefined || node === this.targetRef)) {
            this.result = node.definition;
        }
    }
    visitOption(node) {
        this.checkIsTarget(node, PROD_TYPE.OPTION);
    }
    visitRepetition(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION);
    }
    visitRepetitionMandatory(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY);
    }
    visitRepetitionMandatoryWithSeparator(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR);
    }
    visitRepetitionWithSeparator(node) {
        this.checkIsTarget(node, PROD_TYPE.REPETITION_WITH_SEPARATOR);
    }
    visitAlternation(node) {
        this.checkIsTarget(node, PROD_TYPE.ALTERNATION);
    }
}
function initializeArrayOfArrays(size) {
    const result = new Array(size);
    for (let i = 0; i < size; i++) {
        result[i] = [];
    }
    return result;
}
/**
 * A sort of hash function between a Path in the grammar and a string.
 * Note that this returns multiple "hashes" to support the scenario of token categories.
 * -  A single path with categories may match multiple **actual** paths.
 */
function pathToHashKeys(path) {
    let keys = [""];
    for (let i = 0; i < path.length; i++) {
        const tokType = path[i];
        const longerKeys = [];
        for (let j = 0; j < keys.length; j++) {
            const currShorterKey = keys[j];
            longerKeys.push(currShorterKey + "_" + tokType.tokenTypeIdx);
            for (let t = 0; t < tokType.categoryMatches.length; t++) {
                const categoriesKeySuffix = "_" + tokType.categoryMatches[t];
                longerKeys.push(currShorterKey + categoriesKeySuffix);
            }
        }
        keys = longerKeys;
    }
    return keys;
}
/**
 * Imperative style due to being called from a hot spot
 */
function isUniquePrefixHash(altKnownPathsKeys, searchPathKeys, idx) {
    for (let currAltIdx = 0; currAltIdx < altKnownPathsKeys.length; currAltIdx++) {
        // We only want to test vs the other alternatives
        if (currAltIdx === idx) {
            continue;
        }
        const otherAltKnownPathsKeys = altKnownPathsKeys[currAltIdx];
        for (let searchIdx = 0; searchIdx < searchPathKeys.length; searchIdx++) {
            const searchKey = searchPathKeys[searchIdx];
            if (otherAltKnownPathsKeys[searchKey] === true) {
                return false;
            }
        }
    }
    // None of the SearchPathKeys were found in any of the other alternatives
    return true;
}
function lookAheadSequenceFromAlternatives(altsDefs, k) {
    const partialAlts = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(altsDefs, (currAlt) => (0,_interpreter_js__WEBPACK_IMPORTED_MODULE_0__.possiblePathsFrom)([currAlt], 1));
    const finalResult = initializeArrayOfArrays(partialAlts.length);
    const altsHashes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(partialAlts, (currAltPaths) => {
        const dict = {};
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currAltPaths, (item) => {
            const keys = pathToHashKeys(item.partialPath);
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(keys, (currKey) => {
                dict[currKey] = true;
            });
        });
        return dict;
    });
    let newData = partialAlts;
    // maxLookahead loop
    for (let pathLength = 1; pathLength <= k; pathLength++) {
        const currDataset = newData;
        newData = initializeArrayOfArrays(currDataset.length);
        // alternatives loop
        for (let altIdx = 0; altIdx < currDataset.length; altIdx++) {
            const currAltPathsAndSuffixes = currDataset[altIdx];
            // paths in current alternative loop
            for (let currPathIdx = 0; currPathIdx < currAltPathsAndSuffixes.length; currPathIdx++) {
                const currPathPrefix = currAltPathsAndSuffixes[currPathIdx].partialPath;
                const suffixDef = currAltPathsAndSuffixes[currPathIdx].suffixDef;
                const prefixKeys = pathToHashKeys(currPathPrefix);
                const isUnique = isUniquePrefixHash(altsHashes, prefixKeys, altIdx);
                // End of the line for this path.
                if (isUnique || (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(suffixDef) || currPathPrefix.length === k) {
                    const currAltResult = finalResult[altIdx];
                    // TODO: Can we implement a containsPath using Maps/Dictionaries?
                    if (containsPath(currAltResult, currPathPrefix) === false) {
                        currAltResult.push(currPathPrefix);
                        // Update all new  keys for the current path.
                        for (let j = 0; j < prefixKeys.length; j++) {
                            const currKey = prefixKeys[j];
                            altsHashes[altIdx][currKey] = true;
                        }
                    }
                }
                // Expand longer paths
                else {
                    const newPartialPathsAndSuffixes = (0,_interpreter_js__WEBPACK_IMPORTED_MODULE_0__.possiblePathsFrom)(suffixDef, pathLength + 1, currPathPrefix);
                    newData[altIdx] = newData[altIdx].concat(newPartialPathsAndSuffixes);
                    // Update keys for new known paths
                    (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(newPartialPathsAndSuffixes, (item) => {
                        const prefixKeys = pathToHashKeys(item.partialPath);
                        (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(prefixKeys, (key) => {
                            altsHashes[altIdx][key] = true;
                        });
                    });
                }
            }
        }
    }
    return finalResult;
}
function getLookaheadPathsForOr(occurrence, ruleGrammar, k, orProd) {
    const visitor = new InsideDefinitionFinderVisitor(occurrence, PROD_TYPE.ALTERNATION, orProd);
    ruleGrammar.accept(visitor);
    return lookAheadSequenceFromAlternatives(visitor.result, k);
}
function getLookaheadPathsForOptionalProd(occurrence, ruleGrammar, prodType, k) {
    const insideDefVisitor = new InsideDefinitionFinderVisitor(occurrence, prodType);
    ruleGrammar.accept(insideDefVisitor);
    const insideDef = insideDefVisitor.result;
    const afterDefWalker = new RestDefinitionFinderWalker(ruleGrammar, occurrence, prodType);
    const afterDef = afterDefWalker.startWalking();
    const insideFlat = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.Alternative({ definition: insideDef });
    const afterFlat = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_3__.Alternative({ definition: afterDef });
    return lookAheadSequenceFromAlternatives([insideFlat, afterFlat], k);
}
function containsPath(alternative, searchPath) {
    compareOtherPath: for (let i = 0; i < alternative.length; i++) {
        const otherPath = alternative[i];
        if (otherPath.length !== searchPath.length) {
            continue;
        }
        for (let j = 0; j < otherPath.length; j++) {
            const searchTok = searchPath[j];
            const otherTok = otherPath[j];
            const matchingTokens = searchTok === otherTok ||
                otherTok.categoryMatchesMap[searchTok.tokenTypeIdx] !== undefined;
            if (matchingTokens === false) {
                continue compareOtherPath;
            }
        }
        return true;
    }
    return false;
}
function isStrictPrefixOfPath(prefix, other) {
    return (prefix.length < other.length &&
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(prefix, (tokType, idx) => {
            const otherTokType = other[idx];
            return (tokType === otherTokType ||
                otherTokType.categoryMatchesMap[tokType.tokenTypeIdx]);
        }));
}
function areTokenCategoriesNotUsed(lookAheadPaths) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(lookAheadPaths, (singleAltPaths) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(singleAltPaths, (singlePath) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(singlePath, (token) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(token.categoryMatches))));
}
//# sourceMappingURL=lookahead.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/resolver.js":
/*!*******************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/resolver.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GastRefResolverVisitor: () => (/* binding */ GastRefResolverVisitor),
/* harmony export */   resolveGrammar: () => (/* binding */ resolveGrammar)
/* harmony export */ });
/* harmony import */ var _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser/parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");



function resolveGrammar(topLevels, errMsgProvider) {
    const refResolver = new GastRefResolverVisitor(topLevels, errMsgProvider);
    refResolver.resolveRefs();
    return refResolver.errors;
}
class GastRefResolverVisitor extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_1__.GAstVisitor {
    constructor(nameToTopRule, errMsgProvider) {
        super();
        this.nameToTopRule = nameToTopRule;
        this.errMsgProvider = errMsgProvider;
        this.errors = [];
    }
    resolveRefs() {
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(this.nameToTopRule), (prod) => {
            this.currTopLevel = prod;
            prod.accept(this);
        });
    }
    visitNonTerminal(node) {
        const ref = this.nameToTopRule[node.nonTerminalName];
        if (!ref) {
            const msg = this.errMsgProvider.buildRuleNotFoundError(this.currTopLevel, node);
            this.errors.push({
                message: msg,
                type: _parser_parser_js__WEBPACK_IMPORTED_MODULE_0__.ParserDefinitionErrorType.UNRESOLVED_SUBRULE_REF,
                ruleName: this.currTopLevel.name,
                unresolvedRefName: node.nonTerminalName,
            });
        }
        else {
            node.referencedRule = ref;
        }
    }
}
//# sourceMappingURL=resolver.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/grammar/rest.js":
/*!***************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/grammar/rest.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RestWalker: () => (/* binding */ RestWalker)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/drop.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");


/**
 *  A Grammar Walker that computes the "remaining" grammar "after" a productions in the grammar.
 */
class RestWalker {
    walk(prod, prevRest = []) {
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(prod.definition, (subProd, index) => {
            const currRest = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(prod.definition, index + 1);
            /* istanbul ignore else */
            if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.NonTerminal) {
                this.walkProdRef(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Terminal) {
                this.walkTerminal(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Alternative) {
                this.walkFlat(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Option) {
                this.walkOption(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory) {
                this.walkAtLeastOne(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator) {
                this.walkAtLeastOneSep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator) {
                this.walkManySep(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Repetition) {
                this.walkMany(subProd, currRest, prevRest);
            }
            else if (subProd instanceof _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Alternation) {
                this.walkOr(subProd, currRest, prevRest);
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    }
    walkTerminal(terminal, currRest, prevRest) { }
    walkProdRef(refProd, currRest, prevRest) { }
    walkFlat(flatProd, currRest, prevRest) {
        // ABCDEF => after the D the rest is EF
        const fullOrRest = currRest.concat(prevRest);
        this.walk(flatProd, fullOrRest);
    }
    walkOption(optionProd, currRest, prevRest) {
        // ABC(DE)?F => after the (DE)? the rest is F
        const fullOrRest = currRest.concat(prevRest);
        this.walk(optionProd, fullOrRest);
    }
    walkAtLeastOne(atLeastOneProd, currRest, prevRest) {
        // ABC(DE)+F => after the (DE)+ the rest is (DE)?F
        const fullAtLeastOneRest = [
            new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Option({ definition: atLeastOneProd.definition }),
        ].concat(currRest, prevRest);
        this.walk(atLeastOneProd, fullAtLeastOneRest);
    }
    walkAtLeastOneSep(atLeastOneSepProd, currRest, prevRest) {
        // ABC DE(,DE)* F => after the (,DE)+ the rest is (,DE)?F
        const fullAtLeastOneSepRest = restForRepetitionWithSeparator(atLeastOneSepProd, currRest, prevRest);
        this.walk(atLeastOneSepProd, fullAtLeastOneSepRest);
    }
    walkMany(manyProd, currRest, prevRest) {
        // ABC(DE)*F => after the (DE)* the rest is (DE)?F
        const fullManyRest = [
            new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Option({ definition: manyProd.definition }),
        ].concat(currRest, prevRest);
        this.walk(manyProd, fullManyRest);
    }
    walkManySep(manySepProd, currRest, prevRest) {
        // ABC (DE(,DE)*)? F => after the (,DE)* the rest is (,DE)?F
        const fullManySepRest = restForRepetitionWithSeparator(manySepProd, currRest, prevRest);
        this.walk(manySepProd, fullManySepRest);
    }
    walkOr(orProd, currRest, prevRest) {
        // ABC(D|E|F)G => when finding the (D|E|F) the rest is G
        const fullOrRest = currRest.concat(prevRest);
        // walk all different alternatives
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(orProd.definition, (alt) => {
            // wrapping each alternative in a single definition wrapper
            // to avoid errors in computing the rest of that alternative in the invocation to computeInProdFollows
            // (otherwise for OR([alt1,alt2]) alt2 will be considered in 'rest' of alt1
            const prodWrapper = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Alternative({ definition: [alt] });
            this.walk(prodWrapper, fullOrRest);
        });
    }
}
function restForRepetitionWithSeparator(repSepProd, currRest, prevRest) {
    const repSepRest = [
        new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Option({
            definition: [
                new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Terminal({ terminalType: repSepProd.separator }),
            ].concat(repSepProd.definition),
        }),
    ];
    const fullRepSepRest = repSepRest.concat(currRest, prevRest);
    return fullRepSepRest;
}
//# sourceMappingURL=rest.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   CstParser: () => (/* binding */ CstParser),
/* harmony export */   DEFAULT_PARSER_CONFIG: () => (/* binding */ DEFAULT_PARSER_CONFIG),
/* harmony export */   DEFAULT_RULE_CONFIG: () => (/* binding */ DEFAULT_RULE_CONFIG),
/* harmony export */   EMPTY_ALT: () => (/* binding */ EMPTY_ALT),
/* harmony export */   END_OF_FILE: () => (/* binding */ END_OF_FILE),
/* harmony export */   EmbeddedActionsParser: () => (/* binding */ EmbeddedActionsParser),
/* harmony export */   Parser: () => (/* binding */ Parser),
/* harmony export */   ParserDefinitionErrorType: () => (/* binding */ ParserDefinitionErrorType)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var _chevrotain_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/utils */ "./node_modules/@chevrotain/utils/lib/src/api.js");
/* harmony import */ var _grammar_follow_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../grammar/follow.js */ "./node_modules/chevrotain/lib/src/parse/grammar/follow.js");
/* harmony import */ var _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../scan/tokens_public.js */ "./node_modules/chevrotain/lib/src/scan/tokens_public.js");
/* harmony import */ var _errors_public_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../errors_public.js */ "./node_modules/chevrotain/lib/src/parse/errors_public.js");
/* harmony import */ var _grammar_gast_gast_resolver_public_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../grammar/gast/gast_resolver_public.js */ "./node_modules/chevrotain/lib/src/parse/grammar/gast/gast_resolver_public.js");
/* harmony import */ var _traits_recoverable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./traits/recoverable.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js");
/* harmony import */ var _traits_looksahead_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./traits/looksahead.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js");
/* harmony import */ var _traits_tree_builder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./traits/tree_builder.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js");
/* harmony import */ var _traits_lexer_adapter_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./traits/lexer_adapter.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js");
/* harmony import */ var _traits_recognizer_api_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./traits/recognizer_api.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js");
/* harmony import */ var _traits_recognizer_engine_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./traits/recognizer_engine.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js");
/* harmony import */ var _traits_error_handler_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./traits/error_handler.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js");
/* harmony import */ var _traits_context_assist_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./traits/context_assist.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js");
/* harmony import */ var _traits_gast_recorder_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./traits/gast_recorder.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js");
/* harmony import */ var _traits_perf_tracer_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./traits/perf_tracer.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js");
/* harmony import */ var _utils_apply_mixins_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/apply_mixins.js */ "./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js");
/* harmony import */ var _grammar_checks_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../grammar/checks.js */ "./node_modules/chevrotain/lib/src/parse/grammar/checks.js");


















const END_OF_FILE = (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_2__.createTokenInstance)(_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_2__.EOF, "", NaN, NaN, NaN, NaN, NaN, NaN);
Object.freeze(END_OF_FILE);
const DEFAULT_PARSER_CONFIG = Object.freeze({
    recoveryEnabled: false,
    maxLookahead: 3,
    dynamicTokensEnabled: false,
    outputCst: true,
    errorMessageProvider: _errors_public_js__WEBPACK_IMPORTED_MODULE_3__.defaultParserErrorProvider,
    nodeLocationTracking: "none",
    traceInitPerf: false,
    skipValidations: false,
});
const DEFAULT_RULE_CONFIG = Object.freeze({
    recoveryValueFunc: () => undefined,
    resyncEnabled: true,
});
var ParserDefinitionErrorType;
(function (ParserDefinitionErrorType) {
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_NAME"] = 0] = "INVALID_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_RULE_NAME"] = 1] = "DUPLICATE_RULE_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_RULE_OVERRIDE"] = 2] = "INVALID_RULE_OVERRIDE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["DUPLICATE_PRODUCTIONS"] = 3] = "DUPLICATE_PRODUCTIONS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["UNRESOLVED_SUBRULE_REF"] = 4] = "UNRESOLVED_SUBRULE_REF";
    ParserDefinitionErrorType[ParserDefinitionErrorType["LEFT_RECURSION"] = 5] = "LEFT_RECURSION";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NONE_LAST_EMPTY_ALT"] = 6] = "NONE_LAST_EMPTY_ALT";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_ALTS"] = 7] = "AMBIGUOUS_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["CONFLICT_TOKENS_RULES_NAMESPACE"] = 8] = "CONFLICT_TOKENS_RULES_NAMESPACE";
    ParserDefinitionErrorType[ParserDefinitionErrorType["INVALID_TOKEN_NAME"] = 9] = "INVALID_TOKEN_NAME";
    ParserDefinitionErrorType[ParserDefinitionErrorType["NO_NON_EMPTY_LOOKAHEAD"] = 10] = "NO_NON_EMPTY_LOOKAHEAD";
    ParserDefinitionErrorType[ParserDefinitionErrorType["AMBIGUOUS_PREFIX_ALTS"] = 11] = "AMBIGUOUS_PREFIX_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["TOO_MANY_ALTS"] = 12] = "TOO_MANY_ALTS";
    ParserDefinitionErrorType[ParserDefinitionErrorType["CUSTOM_LOOKAHEAD_VALIDATION"] = 13] = "CUSTOM_LOOKAHEAD_VALIDATION";
})(ParserDefinitionErrorType || (ParserDefinitionErrorType = {}));
function EMPTY_ALT(value = undefined) {
    return function () {
        return value;
    };
}
class Parser {
    /**
     *  @deprecated use the **instance** method with the same name instead
     */
    static performSelfAnalysis(parserInstance) {
        throw Error("The **static** `performSelfAnalysis` method has been deprecated." +
            "\t\nUse the **instance** method with the same name instead.");
    }
    performSelfAnalysis() {
        this.TRACE_INIT("performSelfAnalysis", () => {
            let defErrorsMsgs;
            this.selfAnalysisDone = true;
            const className = this.className;
            this.TRACE_INIT("toFastProps", () => {
                // Without this voodoo magic the parser would be x3-x4 slower
                // It seems it is better to invoke `toFastProperties` **before**
                // Any manipulations of the `this` object done during the recording phase.
                (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_0__.toFastProperties)(this);
            });
            this.TRACE_INIT("Grammar Recording", () => {
                try {
                    this.enableRecording();
                    // Building the GAST
                    (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(this.definedRulesNames, (currRuleName) => {
                        const wrappedRule = this[currRuleName];
                        const originalGrammarAction = wrappedRule["originalGrammarAction"];
                        let recordedRuleGast;
                        this.TRACE_INIT(`${currRuleName} Rule`, () => {
                            recordedRuleGast = this.topLevelRuleRecord(currRuleName, originalGrammarAction);
                        });
                        this.gastProductionsCache[currRuleName] = recordedRuleGast;
                    });
                }
                finally {
                    this.disableRecording();
                }
            });
            let resolverErrors = [];
            this.TRACE_INIT("Grammar Resolving", () => {
                resolverErrors = (0,_grammar_gast_gast_resolver_public_js__WEBPACK_IMPORTED_MODULE_4__.resolveGrammar)({
                    rules: (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.gastProductionsCache),
                });
                this.definitionErrors = this.definitionErrors.concat(resolverErrors);
            });
            this.TRACE_INIT("Grammar Validations", () => {
                // only perform additional grammar validations IFF no resolving errors have occurred.
                // as unresolved grammar may lead to unhandled runtime exceptions in the follow up validations.
                if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(resolverErrors) && this.skipValidations === false) {
                    const validationErrors = (0,_grammar_gast_gast_resolver_public_js__WEBPACK_IMPORTED_MODULE_4__.validateGrammar)({
                        rules: (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.gastProductionsCache),
                        tokenTypes: (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.tokensMap),
                        errMsgProvider: _errors_public_js__WEBPACK_IMPORTED_MODULE_3__.defaultGrammarValidatorErrorProvider,
                        grammarName: className,
                    });
                    const lookaheadValidationErrors = (0,_grammar_checks_js__WEBPACK_IMPORTED_MODULE_16__.validateLookahead)({
                        lookaheadStrategy: this.lookaheadStrategy,
                        rules: (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.gastProductionsCache),
                        tokenTypes: (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.tokensMap),
                        grammarName: className,
                    });
                    this.definitionErrors = this.definitionErrors.concat(validationErrors, lookaheadValidationErrors);
                }
            });
            // this analysis may fail if the grammar is not perfectly valid
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(this.definitionErrors)) {
                // The results of these computations are not needed unless error recovery is enabled.
                if (this.recoveryEnabled) {
                    this.TRACE_INIT("computeAllProdsFollows", () => {
                        const allFollows = (0,_grammar_follow_js__WEBPACK_IMPORTED_MODULE_1__.computeAllProdsFollows)((0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.gastProductionsCache));
                        this.resyncFollows = allFollows;
                    });
                }
                this.TRACE_INIT("ComputeLookaheadFunctions", () => {
                    var _a, _b;
                    (_b = (_a = this.lookaheadStrategy).initialize) === null || _b === void 0 ? void 0 : _b.call(_a, {
                        rules: (0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.gastProductionsCache),
                    });
                    this.preComputeLookaheadFunctions((0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(this.gastProductionsCache));
                });
            }
            if (!Parser.DEFER_DEFINITION_ERRORS_HANDLING &&
                !(0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(this.definitionErrors)) {
                defErrorsMsgs = (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(this.definitionErrors, (defError) => defError.message);
                throw new Error(`Parser Definition Errors detected:\n ${defErrorsMsgs.join("\n-------------------------------\n")}`);
            }
        });
    }
    constructor(tokenVocabulary, config) {
        this.definitionErrors = [];
        this.selfAnalysisDone = false;
        const that = this;
        that.initErrorHandler(config);
        that.initLexerAdapter();
        that.initLooksAhead(config);
        that.initRecognizerEngine(tokenVocabulary, config);
        that.initRecoverable(config);
        that.initTreeBuilder(config);
        that.initContentAssist();
        that.initGastRecorder(config);
        that.initPerformanceTracer(config);
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_21__["default"])(config, "ignoredIssues")) {
            throw new Error("The <ignoredIssues> IParserConfig property has been deprecated.\n\t" +
                "Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.\n\t" +
                "See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES\n\t" +
                "For further details.");
        }
        this.skipValidations = (0,lodash_es__WEBPACK_IMPORTED_MODULE_21__["default"])(config, "skipValidations")
            ? config.skipValidations // casting assumes the end user passing the correct type
            : DEFAULT_PARSER_CONFIG.skipValidations;
    }
}
// Set this flag to true if you don't want the Parser to throw error when problems in it's definition are detected.
// (normally during the parser's constructor).
// This is a design time flag, it will not affect the runtime error handling of the parser, just design time errors,
// for example: duplicate rule names, referencing an unresolved subrule, ect...
// This flag should not be enabled during normal usage, it is used in special situations, for example when
// needing to display the parser definition errors in some GUI(online playground).
Parser.DEFER_DEFINITION_ERRORS_HANDLING = false;
(0,_utils_apply_mixins_js__WEBPACK_IMPORTED_MODULE_15__.applyMixins)(Parser, [
    _traits_recoverable_js__WEBPACK_IMPORTED_MODULE_5__.Recoverable,
    _traits_looksahead_js__WEBPACK_IMPORTED_MODULE_6__.LooksAhead,
    _traits_tree_builder_js__WEBPACK_IMPORTED_MODULE_7__.TreeBuilder,
    _traits_lexer_adapter_js__WEBPACK_IMPORTED_MODULE_8__.LexerAdapter,
    _traits_recognizer_engine_js__WEBPACK_IMPORTED_MODULE_10__.RecognizerEngine,
    _traits_recognizer_api_js__WEBPACK_IMPORTED_MODULE_9__.RecognizerApi,
    _traits_error_handler_js__WEBPACK_IMPORTED_MODULE_11__.ErrorHandler,
    _traits_context_assist_js__WEBPACK_IMPORTED_MODULE_12__.ContentAssist,
    _traits_gast_recorder_js__WEBPACK_IMPORTED_MODULE_13__.GastRecorder,
    _traits_perf_tracer_js__WEBPACK_IMPORTED_MODULE_14__.PerformanceTracer,
]);
class CstParser extends Parser {
    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {
        const configClone = (0,lodash_es__WEBPACK_IMPORTED_MODULE_22__["default"])(config);
        configClone.outputCst = true;
        super(tokenVocabulary, configClone);
    }
}
class EmbeddedActionsParser extends Parser {
    constructor(tokenVocabulary, config = DEFAULT_PARSER_CONFIG) {
        const configClone = (0,lodash_es__WEBPACK_IMPORTED_MODULE_22__["default"])(config);
        configClone.outputCst = false;
        super(tokenVocabulary, configClone);
    }
}
//# sourceMappingURL=parser.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/context_assist.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContentAssist: () => (/* binding */ ContentAssist)
/* harmony export */ });
/* harmony import */ var _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../grammar/interpreter.js */ "./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/head.js");


class ContentAssist {
    initContentAssist() { }
    computeContentAssist(startRuleName, precedingInput) {
        const startRuleGast = this.gastProductionsCache[startRuleName];
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(startRuleGast)) {
            throw Error(`Rule ->${startRuleName}<- does not exist in this grammar.`);
        }
        return (0,_grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_0__.nextPossibleTokensAfter)([startRuleGast], precedingInput, this.tokenMatcher, this.maxLookahead);
    }
    // TODO: should this be a member method or a utility? it does not have any state or usage of 'this'...
    // TODO: should this be more explicitly part of the public API?
    getNextPossibleTokenTypes(grammarPath) {
        const topRuleName = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(grammarPath.ruleStack);
        const gastProductions = this.getGAstProductions();
        const topProduction = gastProductions[topRuleName];
        const nextPossibleTokenTypes = new _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_0__.NextAfterTokenWalker(topProduction, grammarPath).startWalking();
        return nextPossibleTokenTypes;
    }
}
//# sourceMappingURL=context_assist.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js":
/*!******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/error_handler.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorHandler: () => (/* binding */ ErrorHandler)
/* harmony export */ });
/* harmony import */ var _exceptions_public_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../exceptions_public.js */ "./node_modules/chevrotain/lib/src/parse/exceptions_public.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var _grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../grammar/lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");




/**
 * Trait responsible for runtime parsing errors.
 */
class ErrorHandler {
    initErrorHandler(config) {
        this._errors = [];
        this.errorMessageProvider = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(config, "errorMessageProvider")
            ? config.errorMessageProvider // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_PARSER_CONFIG.errorMessageProvider;
    }
    SAVE_ERROR(error) {
        if ((0,_exceptions_public_js__WEBPACK_IMPORTED_MODULE_0__.isRecognitionException)(error)) {
            error.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(this.RULE_OCCURRENCE_STACK),
            };
            this._errors.push(error);
            return error;
        }
        else {
            throw Error("Trying to save an Error which is not a RecognitionException");
        }
    }
    get errors() {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(this._errors);
    }
    set errors(newErrors) {
        this._errors = newErrors;
    }
    // TODO: consider caching the error message computed information
    raiseEarlyExitException(occurrence, prodType, userDefinedErrMsg) {
        const ruleName = this.getCurrRuleFullName();
        const ruleGrammar = this.getGAstProductions()[ruleName];
        const lookAheadPathsPerAlternative = (0,_grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_1__.getLookaheadPathsForOptionalProd)(occurrence, ruleGrammar, prodType, this.maxLookahead);
        const insideProdPaths = lookAheadPathsPerAlternative[0];
        const actualTokens = [];
        for (let i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        const msg = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: insideProdPaths,
            actual: actualTokens,
            previous: this.LA(0),
            customUserDescription: userDefinedErrMsg,
            ruleName: ruleName,
        });
        throw this.SAVE_ERROR(new _exceptions_public_js__WEBPACK_IMPORTED_MODULE_0__.EarlyExitException(msg, this.LA(1), this.LA(0)));
    }
    // TODO: consider caching the error message computed information
    raiseNoAltException(occurrence, errMsgTypes) {
        const ruleName = this.getCurrRuleFullName();
        const ruleGrammar = this.getGAstProductions()[ruleName];
        // TODO: getLookaheadPathsForOr can be slow for large enough maxLookahead and certain grammars, consider caching ?
        const lookAheadPathsPerAlternative = (0,_grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_1__.getLookaheadPathsForOr)(occurrence, ruleGrammar, this.maxLookahead);
        const actualTokens = [];
        for (let i = 1; i <= this.maxLookahead; i++) {
            actualTokens.push(this.LA(i));
        }
        const previousToken = this.LA(0);
        const errMsg = this.errorMessageProvider.buildNoViableAltMessage({
            expectedPathsPerAlt: lookAheadPathsPerAlternative,
            actual: actualTokens,
            previous: previousToken,
            customUserDescription: errMsgTypes,
            ruleName: this.getCurrRuleFullName(),
        });
        throw this.SAVE_ERROR(new _exceptions_public_js__WEBPACK_IMPORTED_MODULE_0__.NoViableAltException(errMsg, this.LA(1), previousToken));
    }
}
//# sourceMappingURL=error_handler.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js":
/*!******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/gast_recorder.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GastRecorder: () => (/* binding */ GastRecorder)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/last.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/some.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");
/* harmony import */ var _scan_lexer_public_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../scan/lexer_public.js */ "./node_modules/chevrotain/lib/src/scan/lexer_public.js");
/* harmony import */ var _scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../scan/tokens.js */ "./node_modules/chevrotain/lib/src/scan/tokens.js");
/* harmony import */ var _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../scan/tokens_public.js */ "./node_modules/chevrotain/lib/src/scan/tokens_public.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _grammar_keys_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../grammar/keys.js */ "./node_modules/chevrotain/lib/src/parse/grammar/keys.js");







const RECORDING_NULL_OBJECT = {
    description: "This Object indicates the Parser is during Recording Phase",
};
Object.freeze(RECORDING_NULL_OBJECT);
const HANDLE_SEPARATOR = true;
const MAX_METHOD_IDX = Math.pow(2, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_5__.BITS_FOR_OCCURRENCE_IDX) - 1;
const RFT = (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.createToken)({ name: "RECORDING_PHASE_TOKEN", pattern: _scan_lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA });
(0,_scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)([RFT]);
const RECORDING_PHASE_TOKEN = (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_3__.createTokenInstance)(RFT, "This IToken indicates the Parser is in Recording Phase\n\t" +
    "" +
    "See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details", 
// Using "-1" instead of NaN (as in EOF) because an actual number is less likely to
// cause errors if the output of LA or CONSUME would be (incorrectly) used during the recording phase.
-1, -1, -1, -1, -1, -1);
Object.freeze(RECORDING_PHASE_TOKEN);
const RECORDING_PHASE_CSTNODE = {
    name: "This CSTNode indicates the Parser is in Recording Phase\n\t" +
        "See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details",
    children: {},
};
/**
 * This trait handles the creation of the GAST structure for Chevrotain Grammars
 */
class GastRecorder {
    initGastRecorder(config) {
        this.recordingProdStack = [];
        this.RECORDING_PHASE = false;
    }
    enableRecording() {
        this.RECORDING_PHASE = true;
        this.TRACE_INIT("Enable Recording", () => {
            /**
             * Warning Dark Voodoo Magic upcoming!
             * We are "replacing" the public parsing DSL methods API
             * With **new** alternative implementations on the Parser **instance**
             *
             * So far this is the only way I've found to avoid performance regressions during parsing time.
             * - Approx 30% performance regression was measured on Chrome 75 Canary when attempting to replace the "internal"
             *   implementations directly instead.
             */
            for (let i = 0; i < 10; i++) {
                const idx = i > 0 ? i : "";
                this[`CONSUME${idx}`] = function (arg1, arg2) {
                    return this.consumeInternalRecord(arg1, i, arg2);
                };
                this[`SUBRULE${idx}`] = function (arg1, arg2) {
                    return this.subruleInternalRecord(arg1, i, arg2);
                };
                this[`OPTION${idx}`] = function (arg1) {
                    return this.optionInternalRecord(arg1, i);
                };
                this[`OR${idx}`] = function (arg1) {
                    return this.orInternalRecord(arg1, i);
                };
                this[`MANY${idx}`] = function (arg1) {
                    this.manyInternalRecord(i, arg1);
                };
                this[`MANY_SEP${idx}`] = function (arg1) {
                    this.manySepFirstInternalRecord(i, arg1);
                };
                this[`AT_LEAST_ONE${idx}`] = function (arg1) {
                    this.atLeastOneInternalRecord(i, arg1);
                };
                this[`AT_LEAST_ONE_SEP${idx}`] = function (arg1) {
                    this.atLeastOneSepFirstInternalRecord(i, arg1);
                };
            }
            // DSL methods with the idx(suffix) as an argument
            this[`consume`] = function (idx, arg1, arg2) {
                return this.consumeInternalRecord(arg1, idx, arg2);
            };
            this[`subrule`] = function (idx, arg1, arg2) {
                return this.subruleInternalRecord(arg1, idx, arg2);
            };
            this[`option`] = function (idx, arg1) {
                return this.optionInternalRecord(arg1, idx);
            };
            this[`or`] = function (idx, arg1) {
                return this.orInternalRecord(arg1, idx);
            };
            this[`many`] = function (idx, arg1) {
                this.manyInternalRecord(idx, arg1);
            };
            this[`atLeastOne`] = function (idx, arg1) {
                this.atLeastOneInternalRecord(idx, arg1);
            };
            this.ACTION = this.ACTION_RECORD;
            this.BACKTRACK = this.BACKTRACK_RECORD;
            this.LA = this.LA_RECORD;
        });
    }
    disableRecording() {
        this.RECORDING_PHASE = false;
        // By deleting these **instance** properties, any future invocation
        // will be deferred to the original methods on the **prototype** object
        // This seems to get rid of any incorrect optimizations that V8 may
        // do during the recording phase.
        this.TRACE_INIT("Deleting Recording methods", () => {
            const that = this;
            for (let i = 0; i < 10; i++) {
                const idx = i > 0 ? i : "";
                delete that[`CONSUME${idx}`];
                delete that[`SUBRULE${idx}`];
                delete that[`OPTION${idx}`];
                delete that[`OR${idx}`];
                delete that[`MANY${idx}`];
                delete that[`MANY_SEP${idx}`];
                delete that[`AT_LEAST_ONE${idx}`];
                delete that[`AT_LEAST_ONE_SEP${idx}`];
            }
            delete that[`consume`];
            delete that[`subrule`];
            delete that[`option`];
            delete that[`or`];
            delete that[`many`];
            delete that[`atLeastOne`];
            delete that.ACTION;
            delete that.BACKTRACK;
            delete that.LA;
        });
    }
    //   Parser methods are called inside an ACTION?
    //   Maybe try/catch/finally on ACTIONS while disabling the recorders state changes?
    // @ts-expect-error -- noop place holder
    ACTION_RECORD(impl) {
        // NO-OP during recording
    }
    // Executing backtracking logic will break our recording logic assumptions
    BACKTRACK_RECORD(grammarRule, args) {
        return () => true;
    }
    // LA is part of the official API and may be used for custom lookahead logic
    // by end users who may forget to wrap it in ACTION or inside a GATE
    LA_RECORD(howMuch) {
        // We cannot use the RECORD_PHASE_TOKEN here because someone may depend
        // On LA return EOF at the end of the input so an infinite loop may occur.
        return _parser_js__WEBPACK_IMPORTED_MODULE_4__.END_OF_FILE;
    }
    topLevelRuleRecord(name, def) {
        try {
            const newTopLevelRule = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Rule({ definition: [], name: name });
            newTopLevelRule.name = name;
            this.recordingProdStack.push(newTopLevelRule);
            def.call(this);
            this.recordingProdStack.pop();
            return newTopLevelRule;
        }
        catch (originalError) {
            if (originalError.KNOWN_RECORDER_ERROR !== true) {
                try {
                    originalError.message =
                        originalError.message +
                            '\n\t This error was thrown during the "grammar recording phase" For more info see:\n\t' +
                            "https://chevrotain.io/docs/guide/internals.html#grammar-recording";
                }
                catch (mutabilityError) {
                    // We may not be able to modify the original error object
                    throw originalError;
                }
            }
            throw originalError;
        }
    }
    // Implementation of parsing DSL
    optionInternalRecord(actionORMethodDef, occurrence) {
        return recordProd.call(this, _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Option, actionORMethodDef, occurrence);
    }
    atLeastOneInternalRecord(occurrence, actionORMethodDef) {
        recordProd.call(this, _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatory, actionORMethodDef, occurrence);
    }
    atLeastOneSepFirstInternalRecord(occurrence, options) {
        recordProd.call(this, _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.RepetitionMandatoryWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    }
    manyInternalRecord(occurrence, actionORMethodDef) {
        recordProd.call(this, _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Repetition, actionORMethodDef, occurrence);
    }
    manySepFirstInternalRecord(occurrence, options) {
        recordProd.call(this, _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.RepetitionWithSeparator, options, occurrence, HANDLE_SEPARATOR);
    }
    orInternalRecord(altsOrOpts, occurrence) {
        return recordOrProd.call(this, altsOrOpts, occurrence);
    }
    subruleInternalRecord(ruleToCall, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!ruleToCall || (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(ruleToCall, "ruleName") === false) {
            const error = new Error(`<SUBRULE${getIdxSuffix(occurrence)}> argument is invalid` +
                ` expecting a Parser method reference but got: <${JSON.stringify(ruleToCall)}>` +
                `\n inside top level rule: <${this.recordingProdStack[0].name}>`);
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        const prevProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(this.recordingProdStack);
        const ruleName = ruleToCall.ruleName;
        const newNoneTerminal = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.NonTerminal({
            idx: occurrence,
            nonTerminalName: ruleName,
            label: options === null || options === void 0 ? void 0 : options.LABEL,
            // The resolving of the `referencedRule` property will be done once all the Rule's GASTs have been created
            referencedRule: undefined,
        });
        prevProd.definition.push(newNoneTerminal);
        return this.outputCst
            ? RECORDING_PHASE_CSTNODE
            : RECORDING_NULL_OBJECT;
    }
    consumeInternalRecord(tokType, occurrence, options) {
        assertMethodIdxIsValid(occurrence);
        if (!(0,_scan_tokens_js__WEBPACK_IMPORTED_MODULE_2__.hasShortKeyProperty)(tokType)) {
            const error = new Error(`<CONSUME${getIdxSuffix(occurrence)}> argument is invalid` +
                ` expecting a TokenType reference but got: <${JSON.stringify(tokType)}>` +
                `\n inside top level rule: <${this.recordingProdStack[0].name}>`);
            error.KNOWN_RECORDER_ERROR = true;
            throw error;
        }
        const prevProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(this.recordingProdStack);
        const newNoneTerminal = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Terminal({
            idx: occurrence,
            terminalType: tokType,
            label: options === null || options === void 0 ? void 0 : options.LABEL,
        });
        prevProd.definition.push(newNoneTerminal);
        return RECORDING_PHASE_TOKEN;
    }
}
function recordProd(prodConstructor, mainProdArg, occurrence, handleSep = false) {
    assertMethodIdxIsValid(occurrence);
    const prevProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(this.recordingProdStack);
    const grammarAction = (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(mainProdArg) ? mainProdArg : mainProdArg.DEF;
    const newProd = new prodConstructor({ definition: [], idx: occurrence });
    if (handleSep) {
        newProd.separator = mainProdArg.SEP;
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(mainProdArg, "MAX_LOOKAHEAD")) {
        newProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    this.recordingProdStack.push(newProd);
    grammarAction.call(this);
    prevProd.definition.push(newProd);
    this.recordingProdStack.pop();
    return RECORDING_NULL_OBJECT;
}
function recordOrProd(mainProdArg, occurrence) {
    assertMethodIdxIsValid(occurrence);
    const prevProd = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(this.recordingProdStack);
    // Only an array of alternatives
    const hasOptions = (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(mainProdArg) === false;
    const alts = hasOptions === false ? mainProdArg : mainProdArg.DEF;
    const newOrProd = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Alternation({
        definition: [],
        idx: occurrence,
        ignoreAmbiguities: hasOptions && mainProdArg.IGNORE_AMBIGUITIES === true,
    });
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(mainProdArg, "MAX_LOOKAHEAD")) {
        newOrProd.maxLookahead = mainProdArg.MAX_LOOKAHEAD;
    }
    const hasPredicates = (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(alts, (currAlt) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currAlt.GATE));
    newOrProd.hasPredicates = hasPredicates;
    prevProd.definition.push(newOrProd);
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(alts, (currAlt) => {
        const currAltFlat = new _chevrotain_gast__WEBPACK_IMPORTED_MODULE_0__.Alternative({ definition: [] });
        newOrProd.definition.push(currAltFlat);
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currAlt, "IGNORE_AMBIGUITIES")) {
            currAltFlat.ignoreAmbiguities = currAlt.IGNORE_AMBIGUITIES; // assumes end user provides the correct config value/type
        }
        // **implicit** ignoreAmbiguities due to usage of gate
        else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(currAlt, "GATE")) {
            currAltFlat.ignoreAmbiguities = true;
        }
        this.recordingProdStack.push(currAltFlat);
        currAlt.ALT.call(this);
        this.recordingProdStack.pop();
    });
    return RECORDING_NULL_OBJECT;
}
function getIdxSuffix(idx) {
    return idx === 0 ? "" : `${idx}`;
}
function assertMethodIdxIsValid(idx) {
    if (idx < 0 || idx > MAX_METHOD_IDX) {
        const error = new Error(
        // The stack trace will contain all the needed details
        `Invalid DSL Method idx value: <${idx}>\n\t` +
            `Idx value must be a none negative value smaller than ${MAX_METHOD_IDX + 1}`);
        error.KNOWN_RECORDER_ERROR = true;
        throw error;
    }
}
//# sourceMappingURL=gast_recorder.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js":
/*!******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/lexer_adapter.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LexerAdapter: () => (/* binding */ LexerAdapter)
/* harmony export */ });
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");

/**
 * Trait responsible abstracting over the interaction with Lexer output (Token vector).
 *
 * This could be generalized to support other kinds of lexers, e.g.
 * - Just in Time Lexing / Lexer-Less parsing.
 * - Streaming Lexer.
 */
class LexerAdapter {
    initLexerAdapter() {
        this.tokVector = [];
        this.tokVectorLength = 0;
        this.currIdx = -1;
    }
    set input(newInput) {
        // @ts-ignore - `this parameter` not supported in setters/getters
        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters
        if (this.selfAnalysisDone !== true) {
            throw Error(`Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.`);
        }
        // @ts-ignore - `this parameter` not supported in setters/getters
        //   - https://www.typescriptlang.org/docs/handbook/functions.html#this-parameters
        this.reset();
        this.tokVector = newInput;
        this.tokVectorLength = newInput.length;
    }
    get input() {
        return this.tokVector;
    }
    // skips a token and returns the next token
    SKIP_TOKEN() {
        if (this.currIdx <= this.tokVector.length - 2) {
            this.consumeToken();
            return this.LA(1);
        }
        else {
            return _parser_js__WEBPACK_IMPORTED_MODULE_0__.END_OF_FILE;
        }
    }
    // Lexer (accessing Token vector) related methods which can be overridden to implement lazy lexers
    // or lexers dependent on parser context.
    LA(howMuch) {
        const soughtIdx = this.currIdx + howMuch;
        if (soughtIdx < 0 || this.tokVectorLength <= soughtIdx) {
            return _parser_js__WEBPACK_IMPORTED_MODULE_0__.END_OF_FILE;
        }
        else {
            return this.tokVector[soughtIdx];
        }
    }
    consumeToken() {
        this.currIdx++;
    }
    exportLexerState() {
        return this.currIdx;
    }
    importLexerState(newState) {
        this.currIdx = newState;
    }
    resetLexerState() {
        this.currIdx = -1;
    }
    moveToTerminatedState() {
        this.currIdx = this.tokVector.length - 1;
    }
    getLexerPosition() {
        return this.exportLexerState();
    }
}
//# sourceMappingURL=lexer_adapter.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js":
/*!***************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/looksahead.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   LooksAhead: () => (/* binding */ LooksAhead),
/* harmony export */   collectMethods: () => (/* binding */ collectMethods)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../grammar/keys.js */ "./node_modules/chevrotain/lib/src/parse/grammar/keys.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");
/* harmony import */ var _grammar_llk_lookahead_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/llk_lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js");





/**
 * Trait responsible for the lookahead related utilities and optimizations.
 */
class LooksAhead {
    initLooksAhead(config) {
        this.dynamicTokensEnabled = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, "dynamicTokensEnabled")
            ? config.dynamicTokensEnabled // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_PARSER_CONFIG.dynamicTokensEnabled;
        this.maxLookahead = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, "maxLookahead")
            ? config.maxLookahead // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_PARSER_CONFIG.maxLookahead;
        this.lookaheadStrategy = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, "lookaheadStrategy")
            ? config.lookaheadStrategy // assumes end user provides the correct config value/type
            : new _grammar_llk_lookahead_js__WEBPACK_IMPORTED_MODULE_3__.LLkLookaheadStrategy({ maxLookahead: this.maxLookahead });
        this.lookAheadFuncsCache = new Map();
    }
    preComputeLookaheadFunctions(rules) {
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(rules, (currRule) => {
            this.TRACE_INIT(`${currRule.name} Rule Lookahead`, () => {
                const { alternation, repetition, option, repetitionMandatory, repetitionMandatoryWithSeparator, repetitionWithSeparator, } = collectMethods(currRule);
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(alternation, (currProd) => {
                    const prodIdx = currProd.idx === 0 ? "" : currProd.idx;
                    this.TRACE_INIT(`${(0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currProd)}${prodIdx}`, () => {
                        const laFunc = this.lookaheadStrategy.buildLookaheadForAlternation({
                            prodOccurrence: currProd.idx,
                            rule: currRule,
                            maxLookahead: currProd.maxLookahead || this.maxLookahead,
                            hasPredicates: currProd.hasPredicates,
                            dynamicTokensEnabled: this.dynamicTokensEnabled,
                        });
                        const key = (0,_grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.getKeyForAutomaticLookahead)(this.fullRuleNameToShort[currRule.name], _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.OR_IDX, currProd.idx);
                        this.setLaFuncCache(key, laFunc);
                    });
                });
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(repetition, (currProd) => {
                    this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.MANY_IDX, "Repetition", currProd.maxLookahead, (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currProd));
                });
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(option, (currProd) => {
                    this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.OPTION_IDX, "Option", currProd.maxLookahead, (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currProd));
                });
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(repetitionMandatory, (currProd) => {
                    this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_IDX, "RepetitionMandatory", currProd.maxLookahead, (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currProd));
                });
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(repetitionMandatoryWithSeparator, (currProd) => {
                    this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.AT_LEAST_ONE_SEP_IDX, "RepetitionMandatoryWithSeparator", currProd.maxLookahead, (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currProd));
                });
                (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(repetitionWithSeparator, (currProd) => {
                    this.computeLookaheadFunc(currRule, currProd.idx, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.MANY_SEP_IDX, "RepetitionWithSeparator", currProd.maxLookahead, (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.getProductionDslName)(currProd));
                });
            });
        });
    }
    computeLookaheadFunc(rule, prodOccurrence, prodKey, prodType, prodMaxLookahead, dslMethodName) {
        this.TRACE_INIT(`${dslMethodName}${prodOccurrence === 0 ? "" : prodOccurrence}`, () => {
            const laFunc = this.lookaheadStrategy.buildLookaheadForOptional({
                prodOccurrence,
                rule,
                maxLookahead: prodMaxLookahead || this.maxLookahead,
                dynamicTokensEnabled: this.dynamicTokensEnabled,
                prodType,
            });
            const key = (0,_grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.getKeyForAutomaticLookahead)(this.fullRuleNameToShort[rule.name], prodKey, prodOccurrence);
            this.setLaFuncCache(key, laFunc);
        });
    }
    // this actually returns a number, but it is always used as a string (object prop key)
    getKeyForAutomaticLookahead(dslMethodIdx, occurrence) {
        const currRuleShortName = this.getLastExplicitRuleShortName();
        return (0,_grammar_keys_js__WEBPACK_IMPORTED_MODULE_1__.getKeyForAutomaticLookahead)(currRuleShortName, dslMethodIdx, occurrence);
    }
    getLaFuncFromCache(key) {
        return this.lookAheadFuncsCache.get(key);
    }
    /* istanbul ignore next */
    setLaFuncCache(key, value) {
        this.lookAheadFuncsCache.set(key, value);
    }
}
class DslMethodsCollectorVisitor extends _chevrotain_gast__WEBPACK_IMPORTED_MODULE_2__.GAstVisitor {
    constructor() {
        super(...arguments);
        this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: [],
        };
    }
    reset() {
        this.dslMethods = {
            option: [],
            alternation: [],
            repetition: [],
            repetitionWithSeparator: [],
            repetitionMandatory: [],
            repetitionMandatoryWithSeparator: [],
        };
    }
    visitOption(option) {
        this.dslMethods.option.push(option);
    }
    visitRepetitionWithSeparator(manySep) {
        this.dslMethods.repetitionWithSeparator.push(manySep);
    }
    visitRepetitionMandatory(atLeastOne) {
        this.dslMethods.repetitionMandatory.push(atLeastOne);
    }
    visitRepetitionMandatoryWithSeparator(atLeastOneSep) {
        this.dslMethods.repetitionMandatoryWithSeparator.push(atLeastOneSep);
    }
    visitRepetition(many) {
        this.dslMethods.repetition.push(many);
    }
    visitAlternation(or) {
        this.dslMethods.alternation.push(or);
    }
}
const collectorVisitor = new DslMethodsCollectorVisitor();
function collectMethods(rule) {
    collectorVisitor.reset();
    rule.accept(collectorVisitor);
    const dslMethods = collectorVisitor.dslMethods;
    // avoid uncleaned references
    collectorVisitor.reset();
    return dslMethods;
}
//# sourceMappingURL=looksahead.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/perf_tracer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   PerformanceTracer: () => (/* binding */ PerformanceTracer)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var _chevrotain_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/utils */ "./node_modules/@chevrotain/utils/lib/src/api.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");



/**
 * Trait responsible for runtime parsing errors.
 */
class PerformanceTracer {
    initPerformanceTracer(config) {
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(config, "traceInitPerf")) {
            const userTraceInitPerf = config.traceInitPerf;
            const traceIsNumber = typeof userTraceInitPerf === "number";
            this.traceInitMaxIdent = traceIsNumber
                ? userTraceInitPerf
                : Infinity;
            this.traceInitPerf = traceIsNumber
                ? userTraceInitPerf > 0
                : userTraceInitPerf; // assumes end user provides the correct config value/type
        }
        else {
            this.traceInitMaxIdent = 0;
            this.traceInitPerf = _parser_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_PARSER_CONFIG.traceInitPerf;
        }
        this.traceInitIndent = -1;
    }
    TRACE_INIT(phaseDesc, phaseImpl) {
        // No need to optimize this using NOOP pattern because
        // It is not called in a hot spot...
        if (this.traceInitPerf === true) {
            this.traceInitIndent++;
            const indent = new Array(this.traceInitIndent + 1).join("\t");
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                console.log(`${indent}--> <${phaseDesc}>`);
            }
            const { time, value } = (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_0__.timer)(phaseImpl);
            /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
            const traceMethod = time > 10 ? console.warn : console.log;
            if (this.traceInitIndent < this.traceInitMaxIdent) {
                traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);
            }
            this.traceInitIndent--;
            return value;
        }
        else {
            return phaseImpl();
        }
    }
}
//# sourceMappingURL=perf_tracer.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_api.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RecognizerApi: () => (/* binding */ RecognizerApi)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var _exceptions_public_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../exceptions_public.js */ "./node_modules/chevrotain/lib/src/parse/exceptions_public.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _errors_public_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../errors_public.js */ "./node_modules/chevrotain/lib/src/parse/errors_public.js");
/* harmony import */ var _grammar_checks_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/checks.js */ "./node_modules/chevrotain/lib/src/parse/grammar/checks.js");
/* harmony import */ var _chevrotain_gast__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @chevrotain/gast */ "./node_modules/@chevrotain/gast/lib/src/api.js");






/**
 * This trait is responsible for implementing the public API
 * for defining Chevrotain parsers, i.e:
 * - CONSUME
 * - RULE
 * - OPTION
 * - ...
 */
class RecognizerApi {
    ACTION(impl) {
        return impl.call(this);
    }
    consume(idx, tokType, options) {
        return this.consumeInternal(tokType, idx, options);
    }
    subrule(idx, ruleToCall, options) {
        return this.subruleInternal(ruleToCall, idx, options);
    }
    option(idx, actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, idx);
    }
    or(idx, altsOrOpts) {
        return this.orInternal(altsOrOpts, idx);
    }
    many(idx, actionORMethodDef) {
        return this.manyInternal(idx, actionORMethodDef);
    }
    atLeastOne(idx, actionORMethodDef) {
        return this.atLeastOneInternal(idx, actionORMethodDef);
    }
    CONSUME(tokType, options) {
        return this.consumeInternal(tokType, 0, options);
    }
    CONSUME1(tokType, options) {
        return this.consumeInternal(tokType, 1, options);
    }
    CONSUME2(tokType, options) {
        return this.consumeInternal(tokType, 2, options);
    }
    CONSUME3(tokType, options) {
        return this.consumeInternal(tokType, 3, options);
    }
    CONSUME4(tokType, options) {
        return this.consumeInternal(tokType, 4, options);
    }
    CONSUME5(tokType, options) {
        return this.consumeInternal(tokType, 5, options);
    }
    CONSUME6(tokType, options) {
        return this.consumeInternal(tokType, 6, options);
    }
    CONSUME7(tokType, options) {
        return this.consumeInternal(tokType, 7, options);
    }
    CONSUME8(tokType, options) {
        return this.consumeInternal(tokType, 8, options);
    }
    CONSUME9(tokType, options) {
        return this.consumeInternal(tokType, 9, options);
    }
    SUBRULE(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 0, options);
    }
    SUBRULE1(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 1, options);
    }
    SUBRULE2(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 2, options);
    }
    SUBRULE3(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 3, options);
    }
    SUBRULE4(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 4, options);
    }
    SUBRULE5(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 5, options);
    }
    SUBRULE6(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 6, options);
    }
    SUBRULE7(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 7, options);
    }
    SUBRULE8(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 8, options);
    }
    SUBRULE9(ruleToCall, options) {
        return this.subruleInternal(ruleToCall, 9, options);
    }
    OPTION(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 0);
    }
    OPTION1(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 1);
    }
    OPTION2(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 2);
    }
    OPTION3(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 3);
    }
    OPTION4(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 4);
    }
    OPTION5(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 5);
    }
    OPTION6(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 6);
    }
    OPTION7(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 7);
    }
    OPTION8(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 8);
    }
    OPTION9(actionORMethodDef) {
        return this.optionInternal(actionORMethodDef, 9);
    }
    OR(altsOrOpts) {
        return this.orInternal(altsOrOpts, 0);
    }
    OR1(altsOrOpts) {
        return this.orInternal(altsOrOpts, 1);
    }
    OR2(altsOrOpts) {
        return this.orInternal(altsOrOpts, 2);
    }
    OR3(altsOrOpts) {
        return this.orInternal(altsOrOpts, 3);
    }
    OR4(altsOrOpts) {
        return this.orInternal(altsOrOpts, 4);
    }
    OR5(altsOrOpts) {
        return this.orInternal(altsOrOpts, 5);
    }
    OR6(altsOrOpts) {
        return this.orInternal(altsOrOpts, 6);
    }
    OR7(altsOrOpts) {
        return this.orInternal(altsOrOpts, 7);
    }
    OR8(altsOrOpts) {
        return this.orInternal(altsOrOpts, 8);
    }
    OR9(altsOrOpts) {
        return this.orInternal(altsOrOpts, 9);
    }
    MANY(actionORMethodDef) {
        this.manyInternal(0, actionORMethodDef);
    }
    MANY1(actionORMethodDef) {
        this.manyInternal(1, actionORMethodDef);
    }
    MANY2(actionORMethodDef) {
        this.manyInternal(2, actionORMethodDef);
    }
    MANY3(actionORMethodDef) {
        this.manyInternal(3, actionORMethodDef);
    }
    MANY4(actionORMethodDef) {
        this.manyInternal(4, actionORMethodDef);
    }
    MANY5(actionORMethodDef) {
        this.manyInternal(5, actionORMethodDef);
    }
    MANY6(actionORMethodDef) {
        this.manyInternal(6, actionORMethodDef);
    }
    MANY7(actionORMethodDef) {
        this.manyInternal(7, actionORMethodDef);
    }
    MANY8(actionORMethodDef) {
        this.manyInternal(8, actionORMethodDef);
    }
    MANY9(actionORMethodDef) {
        this.manyInternal(9, actionORMethodDef);
    }
    MANY_SEP(options) {
        this.manySepFirstInternal(0, options);
    }
    MANY_SEP1(options) {
        this.manySepFirstInternal(1, options);
    }
    MANY_SEP2(options) {
        this.manySepFirstInternal(2, options);
    }
    MANY_SEP3(options) {
        this.manySepFirstInternal(3, options);
    }
    MANY_SEP4(options) {
        this.manySepFirstInternal(4, options);
    }
    MANY_SEP5(options) {
        this.manySepFirstInternal(5, options);
    }
    MANY_SEP6(options) {
        this.manySepFirstInternal(6, options);
    }
    MANY_SEP7(options) {
        this.manySepFirstInternal(7, options);
    }
    MANY_SEP8(options) {
        this.manySepFirstInternal(8, options);
    }
    MANY_SEP9(options) {
        this.manySepFirstInternal(9, options);
    }
    AT_LEAST_ONE(actionORMethodDef) {
        this.atLeastOneInternal(0, actionORMethodDef);
    }
    AT_LEAST_ONE1(actionORMethodDef) {
        return this.atLeastOneInternal(1, actionORMethodDef);
    }
    AT_LEAST_ONE2(actionORMethodDef) {
        this.atLeastOneInternal(2, actionORMethodDef);
    }
    AT_LEAST_ONE3(actionORMethodDef) {
        this.atLeastOneInternal(3, actionORMethodDef);
    }
    AT_LEAST_ONE4(actionORMethodDef) {
        this.atLeastOneInternal(4, actionORMethodDef);
    }
    AT_LEAST_ONE5(actionORMethodDef) {
        this.atLeastOneInternal(5, actionORMethodDef);
    }
    AT_LEAST_ONE6(actionORMethodDef) {
        this.atLeastOneInternal(6, actionORMethodDef);
    }
    AT_LEAST_ONE7(actionORMethodDef) {
        this.atLeastOneInternal(7, actionORMethodDef);
    }
    AT_LEAST_ONE8(actionORMethodDef) {
        this.atLeastOneInternal(8, actionORMethodDef);
    }
    AT_LEAST_ONE9(actionORMethodDef) {
        this.atLeastOneInternal(9, actionORMethodDef);
    }
    AT_LEAST_ONE_SEP(options) {
        this.atLeastOneSepFirstInternal(0, options);
    }
    AT_LEAST_ONE_SEP1(options) {
        this.atLeastOneSepFirstInternal(1, options);
    }
    AT_LEAST_ONE_SEP2(options) {
        this.atLeastOneSepFirstInternal(2, options);
    }
    AT_LEAST_ONE_SEP3(options) {
        this.atLeastOneSepFirstInternal(3, options);
    }
    AT_LEAST_ONE_SEP4(options) {
        this.atLeastOneSepFirstInternal(4, options);
    }
    AT_LEAST_ONE_SEP5(options) {
        this.atLeastOneSepFirstInternal(5, options);
    }
    AT_LEAST_ONE_SEP6(options) {
        this.atLeastOneSepFirstInternal(6, options);
    }
    AT_LEAST_ONE_SEP7(options) {
        this.atLeastOneSepFirstInternal(7, options);
    }
    AT_LEAST_ONE_SEP8(options) {
        this.atLeastOneSepFirstInternal(8, options);
    }
    AT_LEAST_ONE_SEP9(options) {
        this.atLeastOneSepFirstInternal(9, options);
    }
    RULE(name, implementation, config = _parser_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_RULE_CONFIG) {
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(this.definedRulesNames, name)) {
            const errMsg = _errors_public_js__WEBPACK_IMPORTED_MODULE_2__.defaultGrammarValidatorErrorProvider.buildDuplicateRuleNameError({
                topLevelRule: name,
                grammarName: this.className,
            });
            const error = {
                message: errMsg,
                type: _parser_js__WEBPACK_IMPORTED_MODULE_1__.ParserDefinitionErrorType.DUPLICATE_RULE_NAME,
                ruleName: name,
            };
            this.definitionErrors.push(error);
        }
        this.definedRulesNames.push(name);
        const ruleImplementation = this.defineRule(name, implementation, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    }
    OVERRIDE_RULE(name, impl, config = _parser_js__WEBPACK_IMPORTED_MODULE_1__.DEFAULT_RULE_CONFIG) {
        const ruleErrors = (0,_grammar_checks_js__WEBPACK_IMPORTED_MODULE_3__.validateRuleIsOverridden)(name, this.definedRulesNames, this.className);
        this.definitionErrors = this.definitionErrors.concat(ruleErrors);
        const ruleImplementation = this.defineRule(name, impl, config);
        this[name] = ruleImplementation;
        return ruleImplementation;
    }
    BACKTRACK(grammarRule, args) {
        return function () {
            // save org state
            this.isBackTrackingStack.push(1);
            const orgState = this.saveRecogState();
            try {
                grammarRule.apply(this, args);
                // if no exception was thrown we have succeed parsing the rule.
                return true;
            }
            catch (e) {
                if ((0,_exceptions_public_js__WEBPACK_IMPORTED_MODULE_0__.isRecognitionException)(e)) {
                    return false;
                }
                else {
                    throw e;
                }
            }
            finally {
                this.reloadRecogState(orgState);
                this.isBackTrackingStack.pop();
            }
        };
    }
    // GAST export APIs
    getGAstProductions() {
        return this.gastProductionsCache;
    }
    getSerializedGastProductions() {
        return (0,_chevrotain_gast__WEBPACK_IMPORTED_MODULE_4__.serializeGrammar)((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(this.gastProductionsCache));
    }
}
//# sourceMappingURL=recognizer_api.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/recognizer_engine.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   RecognizerEngine: () => (/* binding */ RecognizerEngine)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/every.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/uniq.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isObject.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../grammar/keys.js */ "./node_modules/chevrotain/lib/src/parse/grammar/keys.js");
/* harmony import */ var _exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../exceptions_public.js */ "./node_modules/chevrotain/lib/src/parse/exceptions_public.js");
/* harmony import */ var _grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../grammar/lookahead.js */ "./node_modules/chevrotain/lib/src/parse/grammar/lookahead.js");
/* harmony import */ var _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../grammar/interpreter.js */ "./node_modules/chevrotain/lib/src/parse/grammar/interpreter.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");
/* harmony import */ var _recoverable_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./recoverable.js */ "./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js");
/* harmony import */ var _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../../scan/tokens_public.js */ "./node_modules/chevrotain/lib/src/scan/tokens_public.js");
/* harmony import */ var _scan_tokens_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../../../scan/tokens.js */ "./node_modules/chevrotain/lib/src/scan/tokens.js");









/**
 * This trait is responsible for the runtime parsing engine
 * Used by the official API (recognizer_api.ts)
 */
class RecognizerEngine {
    initRecognizerEngine(tokenVocabulary, config) {
        this.className = this.constructor.name;
        // TODO: would using an ES6 Map or plain object be faster (CST building scenario)
        this.shortRuleNameToFull = {};
        this.fullRuleNameToShort = {};
        this.ruleShortNameIdx = 256;
        this.tokenMatcher = _scan_tokens_js__WEBPACK_IMPORTED_MODULE_7__.tokenStructuredMatcherNoCategories;
        this.subruleIdx = 0;
        this.definedRulesNames = [];
        this.tokensMap = {};
        this.isBackTrackingStack = [];
        this.RULE_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
        this.gastProductionsCache = {};
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(config, "serializedGrammar")) {
            throw Error("The Parser's configuration can no longer contain a <serializedGrammar> property.\n" +
                "\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0\n" +
                "\tFor Further details.");
        }
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokenVocabulary)) {
            // This only checks for Token vocabularies provided as arrays.
            // That is good enough because the main objective is to detect users of pre-V4.0 APIs
            // rather than all edge cases of empty Token vocabularies.
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(tokenVocabulary)) {
                throw Error("A Token Vocabulary cannot be empty.\n" +
                    "\tNote that the first argument for the parser constructor\n" +
                    "\tis no longer a Token vector (since v4.0).");
            }
            if (typeof tokenVocabulary[0].startOffset === "number") {
                throw Error("The Parser constructor no longer accepts a token vector as the first argument.\n" +
                    "\tSee: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0\n" +
                    "\tFor Further details.");
            }
        }
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokenVocabulary)) {
            this.tokensMap = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(tokenVocabulary, (acc, tokType) => {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(tokenVocabulary, "modes") &&
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(tokenVocabulary.modes)), _scan_tokens_js__WEBPACK_IMPORTED_MODULE_7__.isTokenType)) {
            const allTokenTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(tokenVocabulary.modes));
            const uniqueTokens = (0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(allTokenTypes);
            this.tokensMap = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(uniqueTokens, (acc, tokType) => {
                acc[tokType.name] = tokType;
                return acc;
            }, {});
        }
        else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(tokenVocabulary)) {
            this.tokensMap = (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(tokenVocabulary);
        }
        else {
            throw new Error("<tokensDictionary> argument must be An Array of Token constructors," +
                " A dictionary of Token constructors or an IMultiModeLexerDefinition");
        }
        // always add EOF to the tokenNames -> constructors map. it is useful to assure all the input has been
        // parsed with a clear error message ("expecting EOF but found ...")
        this.tokensMap["EOF"] = _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_6__.EOF;
        const allTokenTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(tokenVocabulary, "modes")
            ? (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(tokenVocabulary.modes))
            : (0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(tokenVocabulary);
        const noTokenCategoriesUsed = (0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(allTokenTypes, (tokenConstructor) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(tokenConstructor.categoryMatches));
        this.tokenMatcher = noTokenCategoriesUsed
            ? _scan_tokens_js__WEBPACK_IMPORTED_MODULE_7__.tokenStructuredMatcherNoCategories
            : _scan_tokens_js__WEBPACK_IMPORTED_MODULE_7__.tokenStructuredMatcher;
        // Because ES2015+ syntax should be supported for creating Token classes
        // We cannot assume that the Token classes were created using the "extendToken" utilities
        // Therefore we must augment the Token classes both on Lexer initialization and on Parser initialization
        (0,_scan_tokens_js__WEBPACK_IMPORTED_MODULE_7__.augmentTokenTypes)((0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(this.tokensMap));
    }
    defineRule(ruleName, impl, config) {
        if (this.selfAnalysisDone) {
            throw Error(`Grammar rule <${ruleName}> may not be defined after the 'performSelfAnalysis' method has been called'\n` +
                `Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
        }
        const resyncEnabled = (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(config, "resyncEnabled")
            ? config.resyncEnabled // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_RULE_CONFIG.resyncEnabled;
        const recoveryValueFunc = (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(config, "recoveryValueFunc")
            ? config.recoveryValueFunc // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_4__.DEFAULT_RULE_CONFIG.recoveryValueFunc;
        // performance optimization: Use small integers as keys for the longer human readable "full" rule names.
        // this greatly improves Map access time (as much as 8% for some performance benchmarks).
        const shortName = this.ruleShortNameIdx << (_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.BITS_FOR_METHOD_TYPE + _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.BITS_FOR_OCCURRENCE_IDX);
        this.ruleShortNameIdx++;
        this.shortRuleNameToFull[shortName] = ruleName;
        this.fullRuleNameToShort[ruleName] = shortName;
        let invokeRuleWithTry;
        // Micro optimization, only check the condition **once** on rule definition
        // instead of **every single** rule invocation.
        if (this.outputCst === true) {
            invokeRuleWithTry = function invokeRuleWithTry(...args) {
                try {
                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                    impl.apply(this, args);
                    const cst = this.CST_STACK[this.CST_STACK.length - 1];
                    this.cstPostRule(cst);
                    return cst;
                }
                catch (e) {
                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
                }
                finally {
                    this.ruleFinallyStateUpdate();
                }
            };
        }
        else {
            invokeRuleWithTry = function invokeRuleWithTryCst(...args) {
                try {
                    this.ruleInvocationStateUpdate(shortName, ruleName, this.subruleIdx);
                    return impl.apply(this, args);
                }
                catch (e) {
                    return this.invokeRuleCatch(e, resyncEnabled, recoveryValueFunc);
                }
                finally {
                    this.ruleFinallyStateUpdate();
                }
            };
        }
        const wrappedGrammarRule = Object.assign(invokeRuleWithTry, { ruleName, originalGrammarAction: impl });
        return wrappedGrammarRule;
    }
    invokeRuleCatch(e, resyncEnabledConfig, recoveryValueFunc) {
        const isFirstInvokedRule = this.RULE_STACK.length === 1;
        // note the reSync is always enabled for the first rule invocation, because we must always be able to
        // reSync with EOF and just output some INVALID ParseTree
        // during backtracking reSync recovery is disabled, otherwise we can't be certain the backtracking
        // path is really the most valid one
        const reSyncEnabled = resyncEnabledConfig && !this.isBackTracking() && this.recoveryEnabled;
        if ((0,_exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__.isRecognitionException)(e)) {
            const recogError = e;
            if (reSyncEnabled) {
                const reSyncTokType = this.findReSyncTokenType();
                if (this.isInCurrentRuleReSyncSet(reSyncTokType)) {
                    recogError.resyncedTokens = this.reSyncTo(reSyncTokType);
                    if (this.outputCst) {
                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        return partialCstResult;
                    }
                    else {
                        return recoveryValueFunc(e);
                    }
                }
                else {
                    if (this.outputCst) {
                        const partialCstResult = this.CST_STACK[this.CST_STACK.length - 1];
                        partialCstResult.recoveredNode = true;
                        recogError.partialCstResult = partialCstResult;
                    }
                    // to be handled Further up the call stack
                    throw recogError;
                }
            }
            else if (isFirstInvokedRule) {
                // otherwise a Redundant input error will be created as well and we cannot guarantee that this is indeed the case
                this.moveToTerminatedState();
                // the parser should never throw one of its own errors outside its flow.
                // even if error recovery is disabled
                return recoveryValueFunc(e);
            }
            else {
                // to be recovered Further up the call stack
                throw recogError;
            }
        }
        else {
            // some other Error type which we don't know how to handle (for example a built in JavaScript Error)
            throw e;
        }
    }
    // Implementation of parsing DSL
    optionInternal(actionORMethodDef, occurrence) {
        const key = this.getKeyForAutomaticLookahead(_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.OPTION_IDX, occurrence);
        return this.optionInternalLogic(actionORMethodDef, occurrence, key);
    }
    optionInternalLogic(actionORMethodDef, occurrence, key) {
        let lookAheadFunc = this.getLaFuncFromCache(key);
        let action;
        if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            const predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                const orgLookaheadFunction = lookAheadFunc;
                lookAheadFunc = () => {
                    return predicate.call(this) && orgLookaheadFunction.call(this);
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            return action.call(this);
        }
        return undefined;
    }
    atLeastOneInternal(prodOccurrence, actionORMethodDef) {
        const laKey = this.getKeyForAutomaticLookahead(_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.AT_LEAST_ONE_IDX, prodOccurrence);
        return this.atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    }
    atLeastOneInternalLogic(prodOccurrence, actionORMethodDef, key) {
        let lookAheadFunc = this.getLaFuncFromCache(key);
        let action;
        if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            const predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                const orgLookaheadFunction = lookAheadFunc;
                lookAheadFunc = () => {
                    return predicate.call(this) && orgLookaheadFunction.call(this);
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        if (lookAheadFunc.call(this) === true) {
            let notStuck = this.doSingleRepetition(action);
            while (lookAheadFunc.call(this) === true &&
                notStuck === true) {
                notStuck = this.doSingleRepetition(action);
            }
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.PROD_TYPE.REPETITION_MANDATORY, actionORMethodDef.ERR_MSG);
        }
        // note that while it may seem that this can cause an error because by using a recursive call to
        // AT_LEAST_ONE we change the grammar to AT_LEAST_TWO, AT_LEAST_THREE ... , the possible recursive call
        // from the tryInRepetitionRecovery(...) will only happen IFF there really are TWO/THREE/.... items.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.atLeastOneInternal, [prodOccurrence, actionORMethodDef], lookAheadFunc, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.AT_LEAST_ONE_IDX, prodOccurrence, _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.NextTerminalAfterAtLeastOneWalker);
    }
    atLeastOneSepFirstInternal(prodOccurrence, options) {
        const laKey = this.getKeyForAutomaticLookahead(_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.AT_LEAST_ONE_SEP_IDX, prodOccurrence);
        this.atLeastOneSepFirstInternalLogic(prodOccurrence, options, laKey);
    }
    atLeastOneSepFirstInternalLogic(prodOccurrence, options, key) {
        const action = options.DEF;
        const separator = options.SEP;
        const firstIterationLookaheadFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLookaheadFunc.call(this) === true) {
            action.call(this);
            //  TODO: Optimization can move this function construction into "attemptInRepetitionRecovery"
            //  because it is only needed in error recovery scenarios.
            const separatorLookAheadFunc = () => {
                return this.tokenMatcher(this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                // No need for checking infinite loop here due to consuming the separator.
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.NextTerminalAfterAtLeastOneSepWalker,
            ], separatorLookAheadFunc, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.AT_LEAST_ONE_SEP_IDX, prodOccurrence, _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.NextTerminalAfterAtLeastOneSepWalker);
        }
        else {
            throw this.raiseEarlyExitException(prodOccurrence, _grammar_lookahead_js__WEBPACK_IMPORTED_MODULE_2__.PROD_TYPE.REPETITION_MANDATORY_WITH_SEPARATOR, options.ERR_MSG);
        }
    }
    manyInternal(prodOccurrence, actionORMethodDef) {
        const laKey = this.getKeyForAutomaticLookahead(_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.MANY_IDX, prodOccurrence);
        return this.manyInternalLogic(prodOccurrence, actionORMethodDef, laKey);
    }
    manyInternalLogic(prodOccurrence, actionORMethodDef, key) {
        let lookaheadFunction = this.getLaFuncFromCache(key);
        let action;
        if (typeof actionORMethodDef !== "function") {
            action = actionORMethodDef.DEF;
            const predicate = actionORMethodDef.GATE;
            // predicate present
            if (predicate !== undefined) {
                const orgLookaheadFunction = lookaheadFunction;
                lookaheadFunction = () => {
                    return predicate.call(this) && orgLookaheadFunction.call(this);
                };
            }
        }
        else {
            action = actionORMethodDef;
        }
        let notStuck = true;
        while (lookaheadFunction.call(this) === true && notStuck === true) {
            notStuck = this.doSingleRepetition(action);
        }
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        this.attemptInRepetitionRecovery(this.manyInternal, [prodOccurrence, actionORMethodDef], lookaheadFunction, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.MANY_IDX, prodOccurrence, _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.NextTerminalAfterManyWalker, 
        // The notStuck parameter is only relevant when "attemptInRepetitionRecovery"
        // is invoked from manyInternal, in the MANY_SEP case and AT_LEAST_ONE[_SEP]
        // An infinite loop cannot occur as:
        // - Either the lookahead is guaranteed to consume something (Single Token Separator)
        // - AT_LEAST_ONE by definition is guaranteed to consume something (or error out).
        notStuck);
    }
    manySepFirstInternal(prodOccurrence, options) {
        const laKey = this.getKeyForAutomaticLookahead(_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.MANY_SEP_IDX, prodOccurrence);
        this.manySepFirstInternalLogic(prodOccurrence, options, laKey);
    }
    manySepFirstInternalLogic(prodOccurrence, options, key) {
        const action = options.DEF;
        const separator = options.SEP;
        const firstIterationLaFunc = this.getLaFuncFromCache(key);
        // 1st iteration
        if (firstIterationLaFunc.call(this) === true) {
            action.call(this);
            const separatorLookAheadFunc = () => {
                return this.tokenMatcher(this.LA(1), separator);
            };
            // 2nd..nth iterations
            while (this.tokenMatcher(this.LA(1), separator) === true) {
                // note that this CONSUME will never enter recovery because
                // the separatorLookAheadFunc checks that the separator really does exist.
                this.CONSUME(separator);
                // No need for checking infinite loop here due to consuming the separator.
                action.call(this);
            }
            // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
            this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
                prodOccurrence,
                separator,
                separatorLookAheadFunc,
                action,
                _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.NextTerminalAfterManySepWalker,
            ], separatorLookAheadFunc, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.MANY_SEP_IDX, prodOccurrence, _grammar_interpreter_js__WEBPACK_IMPORTED_MODULE_3__.NextTerminalAfterManySepWalker);
        }
    }
    repetitionSepSecondInternal(prodOccurrence, separator, separatorLookAheadFunc, action, nextTerminalAfterWalker) {
        while (separatorLookAheadFunc()) {
            // note that this CONSUME will never enter recovery because
            // the separatorLookAheadFunc checks that the separator really does exist.
            this.CONSUME(separator);
            action.call(this);
        }
        // we can only arrive to this function after an error
        // has occurred (hence the name 'second') so the following
        // IF will always be entered, its possible to remove it...
        // however it is kept to avoid confusion and be consistent.
        // Performance optimization: "attemptInRepetitionRecovery" will be defined as NOOP unless recovery is enabled
        /* istanbul ignore else */
        this.attemptInRepetitionRecovery(this.repetitionSepSecondInternal, [
            prodOccurrence,
            separator,
            separatorLookAheadFunc,
            action,
            nextTerminalAfterWalker,
        ], separatorLookAheadFunc, _grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.AT_LEAST_ONE_SEP_IDX, prodOccurrence, nextTerminalAfterWalker);
    }
    doSingleRepetition(action) {
        const beforeIteration = this.getLexerPosition();
        action.call(this);
        const afterIteration = this.getLexerPosition();
        // This boolean will indicate if this repetition progressed
        // or if we are "stuck" (potential infinite loop in the repetition).
        return afterIteration > beforeIteration;
    }
    orInternal(altsOrOpts, occurrence) {
        const laKey = this.getKeyForAutomaticLookahead(_grammar_keys_js__WEBPACK_IMPORTED_MODULE_0__.OR_IDX, occurrence);
        const alts = (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(altsOrOpts) ? altsOrOpts : altsOrOpts.DEF;
        const laFunc = this.getLaFuncFromCache(laKey);
        const altIdxToTake = laFunc.call(this, alts);
        if (altIdxToTake !== undefined) {
            const chosenAlternative = alts[altIdxToTake];
            return chosenAlternative.ALT.call(this);
        }
        this.raiseNoAltException(occurrence, altsOrOpts.ERR_MSG);
    }
    ruleFinallyStateUpdate() {
        this.RULE_STACK.pop();
        this.RULE_OCCURRENCE_STACK.pop();
        // NOOP when cst is disabled
        this.cstFinallyStateUpdate();
        if (this.RULE_STACK.length === 0 && this.isAtEndOfInput() === false) {
            const firstRedundantTok = this.LA(1);
            const errMsg = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: firstRedundantTok,
                ruleName: this.getCurrRuleFullName(),
            });
            this.SAVE_ERROR(new _exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__.NotAllInputParsedException(errMsg, firstRedundantTok));
        }
    }
    subruleInternal(ruleToCall, idx, options) {
        let ruleResult;
        try {
            const args = options !== undefined ? options.ARGS : undefined;
            this.subruleIdx = idx;
            ruleResult = ruleToCall.apply(this, args);
            this.cstPostNonTerminal(ruleResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleToCall.ruleName);
            return ruleResult;
        }
        catch (e) {
            throw this.subruleInternalError(e, options, ruleToCall.ruleName);
        }
    }
    subruleInternalError(e, options, ruleName) {
        if ((0,_exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__.isRecognitionException)(e) && e.partialCstResult !== undefined) {
            this.cstPostNonTerminal(e.partialCstResult, options !== undefined && options.LABEL !== undefined
                ? options.LABEL
                : ruleName);
            delete e.partialCstResult;
        }
        throw e;
    }
    consumeInternal(tokType, idx, options) {
        let consumedToken;
        try {
            const nextToken = this.LA(1);
            if (this.tokenMatcher(nextToken, tokType) === true) {
                this.consumeToken();
                consumedToken = nextToken;
            }
            else {
                this.consumeInternalError(tokType, nextToken, options);
            }
        }
        catch (eFromConsumption) {
            consumedToken = this.consumeInternalRecovery(tokType, idx, eFromConsumption);
        }
        this.cstPostTerminal(options !== undefined && options.LABEL !== undefined
            ? options.LABEL
            : tokType.name, consumedToken);
        return consumedToken;
    }
    consumeInternalError(tokType, nextToken, options) {
        let msg;
        const previousToken = this.LA(0);
        if (options !== undefined && options.ERR_MSG) {
            msg = options.ERR_MSG;
        }
        else {
            msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: tokType,
                actual: nextToken,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName(),
            });
        }
        throw this.SAVE_ERROR(new _exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__.MismatchedTokenException(msg, nextToken, previousToken));
    }
    consumeInternalRecovery(tokType, idx, eFromConsumption) {
        // no recovery allowed during backtracking, otherwise backtracking may recover invalid syntax and accept it
        // but the original syntax could have been parsed successfully without any backtracking + recovery
        if (this.recoveryEnabled &&
            // TODO: more robust checking of the exception type. Perhaps Typescript extending expressions?
            eFromConsumption.name === "MismatchedTokenException" &&
            !this.isBackTracking()) {
            const follows = this.getFollowsForInRuleRecovery(tokType, idx);
            try {
                return this.tryInRuleRecovery(tokType, follows);
            }
            catch (eFromInRuleRecovery) {
                if (eFromInRuleRecovery.name === _recoverable_js__WEBPACK_IMPORTED_MODULE_5__.IN_RULE_RECOVERY_EXCEPTION) {
                    // failed in RuleRecovery.
                    // throw the original error in order to trigger reSync error recovery
                    throw eFromConsumption;
                }
                else {
                    throw eFromInRuleRecovery;
                }
            }
        }
        else {
            throw eFromConsumption;
        }
    }
    saveRecogState() {
        // errors is a getter which will clone the errors array
        const savedErrors = this.errors;
        const savedRuleStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(this.RULE_STACK);
        return {
            errors: savedErrors,
            lexerState: this.exportLexerState(),
            RULE_STACK: savedRuleStack,
            CST_STACK: this.CST_STACK,
        };
    }
    reloadRecogState(newState) {
        this.errors = newState.errors;
        this.importLexerState(newState.lexerState);
        this.RULE_STACK = newState.RULE_STACK;
    }
    ruleInvocationStateUpdate(shortName, fullName, idxInCallingRule) {
        this.RULE_OCCURRENCE_STACK.push(idxInCallingRule);
        this.RULE_STACK.push(shortName);
        // NOOP when cst is disabled
        this.cstInvocationStateUpdate(fullName);
    }
    isBackTracking() {
        return this.isBackTrackingStack.length !== 0;
    }
    getCurrRuleFullName() {
        const shortName = this.getLastExplicitRuleShortName();
        return this.shortRuleNameToFull[shortName];
    }
    shortRuleNameToFullName(shortName) {
        return this.shortRuleNameToFull[shortName];
    }
    isAtEndOfInput() {
        return this.tokenMatcher(this.LA(1), _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_6__.EOF);
    }
    reset() {
        this.resetLexerState();
        this.subruleIdx = 0;
        this.isBackTrackingStack = [];
        this.errors = [];
        this.RULE_STACK = [];
        // TODO: extract a specific reset for TreeBuilder trait
        this.CST_STACK = [];
        this.RULE_OCCURRENCE_STACK = [];
    }
}
//# sourceMappingURL=recognizer_engine.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/recoverable.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EOF_FOLLOW_KEY: () => (/* binding */ EOF_FOLLOW_KEY),
/* harmony export */   IN_RULE_RECOVERY_EXCEPTION: () => (/* binding */ IN_RULE_RECOVERY_EXCEPTION),
/* harmony export */   InRuleRecoveryException: () => (/* binding */ InRuleRecoveryException),
/* harmony export */   Recoverable: () => (/* binding */ Recoverable),
/* harmony export */   attemptInRepetitionRecovery: () => (/* binding */ attemptInRepetitionRecovery)
/* harmony export */ });
/* harmony import */ var _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../scan/tokens_public.js */ "./node_modules/chevrotain/lib/src/scan/tokens_public.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/dropRight.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/find.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var _exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../exceptions_public.js */ "./node_modules/chevrotain/lib/src/parse/exceptions_public.js");
/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../constants.js */ "./node_modules/chevrotain/lib/src/parse/constants.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");





const EOF_FOLLOW_KEY = {};
const IN_RULE_RECOVERY_EXCEPTION = "InRuleRecoveryException";
class InRuleRecoveryException extends Error {
    constructor(message) {
        super(message);
        this.name = IN_RULE_RECOVERY_EXCEPTION;
    }
}
/**
 * This trait is responsible for the error recovery and fault tolerant logic
 */
class Recoverable {
    initRecoverable(config) {
        this.firstAfterRepMap = {};
        this.resyncFollows = {};
        this.recoveryEnabled = (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, "recoveryEnabled")
            ? config.recoveryEnabled // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_3__.DEFAULT_PARSER_CONFIG.recoveryEnabled;
        // performance optimization, NOOP will be inlined which
        // effectively means that this optional feature does not exist
        // when not used.
        if (this.recoveryEnabled) {
            this.attemptInRepetitionRecovery = attemptInRepetitionRecovery;
        }
    }
    getTokenToInsert(tokType) {
        const tokToInsert = (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.createTokenInstance)(tokType, "", NaN, NaN, NaN, NaN, NaN, NaN);
        tokToInsert.isInsertedInRecovery = true;
        return tokToInsert;
    }
    canTokenTypeBeInsertedInRecovery(tokType) {
        return true;
    }
    canTokenTypeBeDeletedInRecovery(tokType) {
        return true;
    }
    tryInRepetitionRecovery(grammarRule, grammarRuleArgs, lookAheadFunc, expectedTokType) {
        // TODO: can the resyncTokenType be cached?
        const reSyncTokType = this.findReSyncTokenType();
        const savedLexerState = this.exportLexerState();
        const resyncedTokens = [];
        let passedResyncPoint = false;
        const nextTokenWithoutResync = this.LA(1);
        let currToken = this.LA(1);
        const generateErrorMessage = () => {
            const previousToken = this.LA(0);
            // we are preemptively re-syncing before an error has been detected, therefor we must reproduce
            // the error that would have been thrown
            const msg = this.errorMessageProvider.buildMismatchTokenMessage({
                expected: expectedTokType,
                actual: nextTokenWithoutResync,
                previous: previousToken,
                ruleName: this.getCurrRuleFullName(),
            });
            const error = new _exceptions_public_js__WEBPACK_IMPORTED_MODULE_1__.MismatchedTokenException(msg, nextTokenWithoutResync, this.LA(0));
            // the first token here will be the original cause of the error, this is not part of the resyncedTokens property.
            error.resyncedTokens = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(resyncedTokens);
            this.SAVE_ERROR(error);
        };
        while (!passedResyncPoint) {
            // re-synced to a point where we can safely exit the repetition/
            if (this.tokenMatcher(currToken, expectedTokType)) {
                generateErrorMessage();
                return; // must return here to avoid reverting the inputIdx
            }
            else if (lookAheadFunc.call(this)) {
                // we skipped enough tokens so we can resync right back into another iteration of the repetition grammar rule
                generateErrorMessage();
                // recursive invocation in other to support multiple re-syncs in the same top level repetition grammar rule
                grammarRule.apply(this, grammarRuleArgs);
                return; // must return here to avoid reverting the inputIdx
            }
            else if (this.tokenMatcher(currToken, reSyncTokType)) {
                passedResyncPoint = true;
            }
            else {
                currToken = this.SKIP_TOKEN();
                this.addToResyncTokens(currToken, resyncedTokens);
            }
        }
        // we were unable to find a CLOSER point to resync inside the Repetition, reset the state.
        // The parsing exception we were trying to prevent will happen in the NEXT parsing step. it may be handled by
        // "between rules" resync recovery later in the flow.
        this.importLexerState(savedLexerState);
    }
    shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck) {
        // Edge case of arriving from a MANY repetition which is stuck
        // Attempting recovery in this case could cause an infinite loop
        if (notStuck === false) {
            return false;
        }
        // no need to recover, next token is what we expect...
        if (this.tokenMatcher(this.LA(1), expectTokAfterLastMatch)) {
            return false;
        }
        // error recovery is disabled during backtracking as it can make the parser ignore a valid grammar path
        // and prefer some backtracking path that includes recovered errors.
        if (this.isBackTracking()) {
            return false;
        }
        // if we can perform inRule recovery (single token insertion or deletion) we always prefer that recovery algorithm
        // because if it works, it makes the least amount of changes to the input stream (greedy algorithm)
        //noinspection RedundantIfStatementJS
        if (this.canPerformInRuleRecovery(expectTokAfterLastMatch, this.getFollowsForInRuleRecovery(expectTokAfterLastMatch, nextTokIdx))) {
            return false;
        }
        return true;
    }
    // Error Recovery functionality
    getFollowsForInRuleRecovery(tokType, tokIdxInRule) {
        const grammarPath = this.getCurrentGrammarPath(tokType, tokIdxInRule);
        const follows = this.getNextPossibleTokenTypes(grammarPath);
        return follows;
    }
    tryInRuleRecovery(expectedTokType, follows) {
        if (this.canRecoverWithSingleTokenInsertion(expectedTokType, follows)) {
            const tokToInsert = this.getTokenToInsert(expectedTokType);
            return tokToInsert;
        }
        if (this.canRecoverWithSingleTokenDeletion(expectedTokType)) {
            const nextTok = this.SKIP_TOKEN();
            this.consumeToken();
            return nextTok;
        }
        throw new InRuleRecoveryException("sad sad panda");
    }
    canPerformInRuleRecovery(expectedToken, follows) {
        return (this.canRecoverWithSingleTokenInsertion(expectedToken, follows) ||
            this.canRecoverWithSingleTokenDeletion(expectedToken));
    }
    canRecoverWithSingleTokenInsertion(expectedTokType, follows) {
        if (!this.canTokenTypeBeInsertedInRecovery(expectedTokType)) {
            return false;
        }
        // must know the possible following tokens to perform single token insertion
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(follows)) {
            return false;
        }
        const mismatchedTok = this.LA(1);
        const isMisMatchedTokInFollows = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(follows, (possibleFollowsTokType) => {
            return this.tokenMatcher(mismatchedTok, possibleFollowsTokType);
        }) !== undefined;
        return isMisMatchedTokInFollows;
    }
    canRecoverWithSingleTokenDeletion(expectedTokType) {
        if (!this.canTokenTypeBeDeletedInRecovery(expectedTokType)) {
            return false;
        }
        const isNextTokenWhatIsExpected = this.tokenMatcher(this.LA(2), expectedTokType);
        return isNextTokenWhatIsExpected;
    }
    isInCurrentRuleReSyncSet(tokenTypeIdx) {
        const followKey = this.getCurrFollowKey();
        const currentRuleReSyncSet = this.getFollowSetFromFollowKey(followKey);
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currentRuleReSyncSet, tokenTypeIdx);
    }
    findReSyncTokenType() {
        const allPossibleReSyncTokTypes = this.flattenFollowSet();
        // this loop will always terminate as EOF is always in the follow stack and also always (virtually) in the input
        let nextToken = this.LA(1);
        let k = 2;
        while (true) {
            const foundMatch = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(allPossibleReSyncTokTypes, (resyncTokType) => {
                const canMatch = (0,_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.tokenMatcher)(nextToken, resyncTokType);
                return canMatch;
            });
            if (foundMatch !== undefined) {
                return foundMatch;
            }
            nextToken = this.LA(k);
            k++;
        }
    }
    getCurrFollowKey() {
        // the length is at least one as we always add the ruleName to the stack before invoking the rule.
        if (this.RULE_STACK.length === 1) {
            return EOF_FOLLOW_KEY;
        }
        const currRuleShortName = this.getLastExplicitRuleShortName();
        const currRuleIdx = this.getLastExplicitRuleOccurrenceIndex();
        const prevRuleShortName = this.getPreviousExplicitRuleShortName();
        return {
            ruleName: this.shortRuleNameToFullName(currRuleShortName),
            idxInCallingRule: currRuleIdx,
            inRule: this.shortRuleNameToFullName(prevRuleShortName),
        };
    }
    buildFullFollowKeyStack() {
        const explicitRuleStack = this.RULE_STACK;
        const explicitOccurrenceStack = this.RULE_OCCURRENCE_STACK;
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(explicitRuleStack, (ruleName, idx) => {
            if (idx === 0) {
                return EOF_FOLLOW_KEY;
            }
            return {
                ruleName: this.shortRuleNameToFullName(ruleName),
                idxInCallingRule: explicitOccurrenceStack[idx],
                inRule: this.shortRuleNameToFullName(explicitRuleStack[idx - 1]),
            };
        });
    }
    flattenFollowSet() {
        const followStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(this.buildFullFollowKeyStack(), (currKey) => {
            return this.getFollowSetFromFollowKey(currKey);
        });
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(followStack);
    }
    getFollowSetFromFollowKey(followKey) {
        if (followKey === EOF_FOLLOW_KEY) {
            return [_scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.EOF];
        }
        const followName = followKey.ruleName + followKey.idxInCallingRule + _constants_js__WEBPACK_IMPORTED_MODULE_2__.IN + followKey.inRule;
        return this.resyncFollows[followName];
    }
    // It does not make any sense to include a virtual EOF token in the list of resynced tokens
    // as EOF does not really exist and thus does not contain any useful information (line/column numbers)
    addToResyncTokens(token, resyncTokens) {
        if (!this.tokenMatcher(token, _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.EOF)) {
            resyncTokens.push(token);
        }
        return resyncTokens;
    }
    reSyncTo(tokType) {
        const resyncedTokens = [];
        let nextTok = this.LA(1);
        while (this.tokenMatcher(nextTok, tokType) === false) {
            nextTok = this.SKIP_TOKEN();
            this.addToResyncTokens(nextTok, resyncedTokens);
        }
        // the last token is not part of the error.
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(resyncedTokens);
    }
    attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
        // by default this is a NO-OP
        // The actual implementation is with the function(not method) below
    }
    getCurrentGrammarPath(tokType, tokIdxInRule) {
        const pathRuleStack = this.getHumanReadableRuleStack();
        const pathOccurrenceStack = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(this.RULE_OCCURRENCE_STACK);
        const grammarPath = {
            ruleStack: pathRuleStack,
            occurrenceStack: pathOccurrenceStack,
            lastTok: tokType,
            lastTokOccurrence: tokIdxInRule,
        };
        return grammarPath;
    }
    getHumanReadableRuleStack() {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(this.RULE_STACK, (currShortName) => this.shortRuleNameToFullName(currShortName));
    }
}
function attemptInRepetitionRecovery(prodFunc, args, lookaheadFunc, dslMethodIdx, prodOccurrence, nextToksWalker, notStuck) {
    const key = this.getKeyForAutomaticLookahead(dslMethodIdx, prodOccurrence);
    let firstAfterRepInfo = this.firstAfterRepMap[key];
    if (firstAfterRepInfo === undefined) {
        const currRuleName = this.getCurrRuleFullName();
        const ruleGrammar = this.getGAstProductions()[currRuleName];
        const walker = new nextToksWalker(ruleGrammar, prodOccurrence);
        firstAfterRepInfo = walker.startWalking();
        this.firstAfterRepMap[key] = firstAfterRepInfo;
    }
    let expectTokAfterLastMatch = firstAfterRepInfo.token;
    let nextTokIdx = firstAfterRepInfo.occurrence;
    const isEndOfRule = firstAfterRepInfo.isEndOfRule;
    // special edge case of a TOP most repetition after which the input should END.
    // this will force an attempt for inRule recovery in that scenario.
    if (this.RULE_STACK.length === 1 &&
        isEndOfRule &&
        expectTokAfterLastMatch === undefined) {
        expectTokAfterLastMatch = _scan_tokens_public_js__WEBPACK_IMPORTED_MODULE_0__.EOF;
        nextTokIdx = 1;
    }
    // We don't have anything to re-sync to...
    // this condition was extracted from `shouldInRepetitionRecoveryBeTried` to act as a type-guard
    if (expectTokAfterLastMatch === undefined || nextTokIdx === undefined) {
        return;
    }
    if (this.shouldInRepetitionRecoveryBeTried(expectTokAfterLastMatch, nextTokIdx, notStuck)) {
        // TODO: performance optimization: instead of passing the original args here, we modify
        // the args param (or create a new one) and make sure the lookahead func is explicitly provided
        // to avoid searching the cache for it once more.
        this.tryInRepetitionRecovery(prodFunc, args, lookaheadFunc, expectTokAfterLastMatch);
    }
}
//# sourceMappingURL=recoverable.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/traits/tree_builder.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TreeBuilder: () => (/* binding */ TreeBuilder)
/* harmony export */ });
/* harmony import */ var _cst_cst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../cst/cst.js */ "./node_modules/chevrotain/lib/src/parse/cst/cst.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/noop.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/keys.js");
/* harmony import */ var _cst_cst_visitor_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../cst/cst_visitor.js */ "./node_modules/chevrotain/lib/src/parse/cst/cst_visitor.js");
/* harmony import */ var _parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../parser.js */ "./node_modules/chevrotain/lib/src/parse/parser/parser.js");




/**
 * This trait is responsible for the CST building logic.
 */
class TreeBuilder {
    initTreeBuilder(config) {
        this.CST_STACK = [];
        // outputCst is no longer exposed/defined in the pubic API
        this.outputCst = config.outputCst;
        this.nodeLocationTracking = (0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(config, "nodeLocationTracking")
            ? config.nodeLocationTracking // assumes end user provides the correct config value/type
            : _parser_js__WEBPACK_IMPORTED_MODULE_2__.DEFAULT_PARSER_CONFIG.nodeLocationTracking;
        if (!this.outputCst) {
            this.cstInvocationStateUpdate = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
            this.cstFinallyStateUpdate = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
            this.cstPostTerminal = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
            this.cstPostNonTerminal = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
            this.cstPostRule = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
        }
        else {
            if (/full/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = _cst_cst_js__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationFull;
                    this.setNodeLocationFromNode = _cst_cst_js__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationFull;
                    this.cstPostRule = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRecovery;
                }
                else {
                    this.setNodeLocationFromToken = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                    this.setNodeLocationFromNode = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                    this.cstPostRule = this.cstPostRuleFull;
                    this.setInitialNodeLocation = this.setInitialNodeLocationFullRegular;
                }
            }
            else if (/onlyOffset/i.test(this.nodeLocationTracking)) {
                if (this.recoveryEnabled) {
                    this.setNodeLocationFromToken = _cst_cst_js__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationOnlyOffset;
                    this.setNodeLocationFromNode = _cst_cst_js__WEBPACK_IMPORTED_MODULE_0__.setNodeLocationOnlyOffset;
                    this.cstPostRule = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                    this.setInitialNodeLocation =
                        this.setInitialNodeLocationOnlyOffsetRecovery;
                }
                else {
                    this.setNodeLocationFromToken = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                    this.setNodeLocationFromNode = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                    this.cstPostRule = this.cstPostRuleOnlyOffset;
                    this.setInitialNodeLocation =
                        this.setInitialNodeLocationOnlyOffsetRegular;
                }
            }
            else if (/none/i.test(this.nodeLocationTracking)) {
                this.setNodeLocationFromToken = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                this.setNodeLocationFromNode = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                this.cstPostRule = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
                this.setInitialNodeLocation = lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"];
            }
            else {
                throw Error(`Invalid <nodeLocationTracking> config option: "${config.nodeLocationTracking}"`);
            }
        }
    }
    setInitialNodeLocationOnlyOffsetRecovery(cstNode) {
        cstNode.location = {
            startOffset: NaN,
            endOffset: NaN,
        };
    }
    setInitialNodeLocationOnlyOffsetRegular(cstNode) {
        cstNode.location = {
            // without error recovery the starting Location of a new CstNode is guaranteed
            // To be the next Token's startOffset (for valid inputs).
            // For invalid inputs there won't be any CSTOutput so this potential
            // inaccuracy does not matter
            startOffset: this.LA(1).startOffset,
            endOffset: NaN,
        };
    }
    setInitialNodeLocationFullRecovery(cstNode) {
        cstNode.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN,
        };
    }
    /**
       *  @see setInitialNodeLocationOnlyOffsetRegular for explanation why this work
  
       * @param cstNode
       */
    setInitialNodeLocationFullRegular(cstNode) {
        const nextToken = this.LA(1);
        cstNode.location = {
            startOffset: nextToken.startOffset,
            startLine: nextToken.startLine,
            startColumn: nextToken.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN,
        };
    }
    cstInvocationStateUpdate(fullRuleName) {
        const cstNode = {
            name: fullRuleName,
            children: Object.create(null),
        };
        this.setInitialNodeLocation(cstNode);
        this.CST_STACK.push(cstNode);
    }
    cstFinallyStateUpdate() {
        this.CST_STACK.pop();
    }
    cstPostRuleFull(ruleCstNode) {
        // casts to `required<CstNodeLocation>` are safe because `cstPostRuleFull` should only be invoked when full location is enabled
        const prevToken = this.LA(0);
        const loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
            loc.endLine = prevToken.endLine;
            loc.endColumn = prevToken.endColumn;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
            loc.startLine = NaN;
            loc.startColumn = NaN;
        }
    }
    cstPostRuleOnlyOffset(ruleCstNode) {
        const prevToken = this.LA(0);
        // `location' is not null because `cstPostRuleOnlyOffset` will only be invoked when location tracking is enabled.
        const loc = ruleCstNode.location;
        // If this condition is true it means we consumed at least one Token
        // In this CstNode.
        if (loc.startOffset <= prevToken.startOffset === true) {
            loc.endOffset = prevToken.endOffset;
        }
        // "empty" CstNode edge case
        else {
            loc.startOffset = NaN;
        }
    }
    cstPostTerminal(key, consumedToken) {
        const rootCst = this.CST_STACK[this.CST_STACK.length - 1];
        (0,_cst_cst_js__WEBPACK_IMPORTED_MODULE_0__.addTerminalToCst)(rootCst, consumedToken, key);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromToken(rootCst.location, consumedToken);
    }
    cstPostNonTerminal(ruleCstResult, ruleName) {
        const preCstNode = this.CST_STACK[this.CST_STACK.length - 1];
        (0,_cst_cst_js__WEBPACK_IMPORTED_MODULE_0__.addNoneTerminalToCst)(preCstNode, ruleName, ruleCstResult);
        // This is only used when **both** error recovery and CST Output are enabled.
        this.setNodeLocationFromNode(preCstNode.location, ruleCstResult.location);
    }
    getBaseCstVisitorConstructor() {
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(this.baseCstVisitorConstructor)) {
            const newBaseCstVisitorConstructor = (0,_cst_cst_visitor_js__WEBPACK_IMPORTED_MODULE_1__.createBaseSemanticVisitorConstructor)(this.className, (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(this.gastProductionsCache));
            this.baseCstVisitorConstructor = newBaseCstVisitorConstructor;
            return newBaseCstVisitorConstructor;
        }
        return this.baseCstVisitorConstructor;
    }
    getBaseCstVisitorConstructorWithDefaults() {
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(this.baseCstVisitorWithDefaultsConstructor)) {
            const newConstructor = (0,_cst_cst_visitor_js__WEBPACK_IMPORTED_MODULE_1__.createBaseVisitorConstructorWithDefaults)(this.className, (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(this.gastProductionsCache), this.getBaseCstVisitorConstructor());
            this.baseCstVisitorWithDefaultsConstructor = newConstructor;
            return newConstructor;
        }
        return this.baseCstVisitorWithDefaultsConstructor;
    }
    getLastExplicitRuleShortName() {
        const ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 1];
    }
    getPreviousExplicitRuleShortName() {
        const ruleStack = this.RULE_STACK;
        return ruleStack[ruleStack.length - 2];
    }
    getLastExplicitRuleOccurrenceIndex() {
        const occurrenceStack = this.RULE_OCCURRENCE_STACK;
        return occurrenceStack[occurrenceStack.length - 1];
    }
}
//# sourceMappingURL=tree_builder.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js":
/*!****************************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/parse/parser/utils/apply_mixins.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   applyMixins: () => (/* binding */ applyMixins)
/* harmony export */ });
function applyMixins(derivedCtor, baseCtors) {
    baseCtors.forEach((baseCtor) => {
        const baseProto = baseCtor.prototype;
        Object.getOwnPropertyNames(baseProto).forEach((propName) => {
            if (propName === "constructor") {
                return;
            }
            const basePropDescriptor = Object.getOwnPropertyDescriptor(baseProto, propName);
            // Handle Accessors
            if (basePropDescriptor &&
                (basePropDescriptor.get || basePropDescriptor.set)) {
                Object.defineProperty(derivedCtor.prototype, propName, basePropDescriptor);
            }
            else {
                derivedCtor.prototype[propName] = baseCtor.prototype[propName];
            }
        });
    });
}
//# sourceMappingURL=apply_mixins.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/lexer.js":
/*!*******************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/lexer.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_MODE: () => (/* binding */ DEFAULT_MODE),
/* harmony export */   LineTerminatorOptimizedTester: () => (/* binding */ LineTerminatorOptimizedTester),
/* harmony export */   MODES: () => (/* binding */ MODES),
/* harmony export */   SUPPORT_STICKY: () => (/* binding */ SUPPORT_STICKY),
/* harmony export */   addStartOfInput: () => (/* binding */ addStartOfInput),
/* harmony export */   addStickyFlag: () => (/* binding */ addStickyFlag),
/* harmony export */   analyzeTokenTypes: () => (/* binding */ analyzeTokenTypes),
/* harmony export */   buildLineBreakIssueMessage: () => (/* binding */ buildLineBreakIssueMessage),
/* harmony export */   charCodeToOptimizedIndex: () => (/* binding */ charCodeToOptimizedIndex),
/* harmony export */   cloneEmptyGroups: () => (/* binding */ cloneEmptyGroups),
/* harmony export */   disableSticky: () => (/* binding */ disableSticky),
/* harmony export */   enableSticky: () => (/* binding */ enableSticky),
/* harmony export */   findDuplicatePatterns: () => (/* binding */ findDuplicatePatterns),
/* harmony export */   findEmptyMatchRegExps: () => (/* binding */ findEmptyMatchRegExps),
/* harmony export */   findEndOfInputAnchor: () => (/* binding */ findEndOfInputAnchor),
/* harmony export */   findInvalidGroupType: () => (/* binding */ findInvalidGroupType),
/* harmony export */   findInvalidPatterns: () => (/* binding */ findInvalidPatterns),
/* harmony export */   findMissingPatterns: () => (/* binding */ findMissingPatterns),
/* harmony export */   findModesThatDoNotExist: () => (/* binding */ findModesThatDoNotExist),
/* harmony export */   findStartOfInputAnchor: () => (/* binding */ findStartOfInputAnchor),
/* harmony export */   findUnreachablePatterns: () => (/* binding */ findUnreachablePatterns),
/* harmony export */   findUnsupportedFlags: () => (/* binding */ findUnsupportedFlags),
/* harmony export */   isCustomPattern: () => (/* binding */ isCustomPattern),
/* harmony export */   isShortPattern: () => (/* binding */ isShortPattern),
/* harmony export */   minOptimizationVal: () => (/* binding */ minOptimizationVal),
/* harmony export */   performRuntimeChecks: () => (/* binding */ performRuntimeChecks),
/* harmony export */   performWarningRuntimeChecks: () => (/* binding */ performWarningRuntimeChecks),
/* harmony export */   validatePatterns: () => (/* binding */ validatePatterns)
/* harmony export */ });
/* harmony import */ var _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/regexp-to-ast */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js");
/* harmony import */ var _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lexer_public.js */ "./node_modules/chevrotain/lib/src/scan/lexer_public.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/defaults.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reject.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isRegExp.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isFunction.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isString.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/indexOf.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/filter.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/difference.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/compact.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/head.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/find.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/keys.js");
/* harmony import */ var _chevrotain_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @chevrotain/utils */ "./node_modules/@chevrotain/utils/lib/src/api.js");
/* harmony import */ var _reg_exp_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./reg_exp.js */ "./node_modules/chevrotain/lib/src/scan/reg_exp.js");
/* harmony import */ var _reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reg_exp_parser.js */ "./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js");






const PATTERN = "PATTERN";
const DEFAULT_MODE = "defaultMode";
const MODES = "modes";
let SUPPORT_STICKY = typeof new RegExp("(?:)").sticky === "boolean";
function disableSticky() {
    SUPPORT_STICKY = false;
}
function enableSticky() {
    SUPPORT_STICKY = true;
}
function analyzeTokenTypes(tokenTypes, options) {
    options = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(options, {
        useSticky: SUPPORT_STICKY,
        debug: false,
        safeMode: false,
        positionTracking: "full",
        lineTerminatorCharacters: ["\r", "\n"],
        tracer: (msg, action) => action(),
    });
    const tracer = options.tracer;
    tracer("initCharCodeToOptimizedIndexMap", () => {
        initCharCodeToOptimizedIndexMap();
    });
    let onlyRelevantTypes;
    tracer("Reject Lexer.NA", () => {
        onlyRelevantTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(tokenTypes, (currType) => {
            return currType[PATTERN] === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA;
        });
    });
    let hasCustom = false;
    let allTransformedPatterns;
    tracer("Transform Patterns", () => {
        hasCustom = false;
        allTransformedPatterns = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (currType) => {
            const currPattern = currType[PATTERN];
            /* istanbul ignore else */
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currPattern)) {
                const regExpSource = currPattern.source;
                if (regExpSource.length === 1 &&
                    // only these regExp meta characters which can appear in a length one regExp
                    regExpSource !== "^" &&
                    regExpSource !== "$" &&
                    regExpSource !== "." &&
                    !currPattern.ignoreCase) {
                    return regExpSource;
                }
                else if (regExpSource.length === 2 &&
                    regExpSource[0] === "\\" &&
                    // not a meta character
                    !(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])([
                        "d",
                        "D",
                        "s",
                        "S",
                        "t",
                        "r",
                        "n",
                        "t",
                        "0",
                        "c",
                        "b",
                        "B",
                        "f",
                        "v",
                        "w",
                        "W",
                    ], regExpSource[1])) {
                    // escaped meta Characters: /\+/ /\[/
                    // or redundant escaping: /\a/
                    // without the escaping "\"
                    return regExpSource[1];
                }
                else {
                    return options.useSticky
                        ? addStickyFlag(currPattern)
                        : addStartOfInput(currPattern);
                }
            }
            else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(currPattern)) {
                hasCustom = true;
                // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
                return { exec: currPattern };
            }
            else if (typeof currPattern === "object") {
                hasCustom = true;
                // ICustomPattern
                return currPattern;
            }
            else if (typeof currPattern === "string") {
                if (currPattern.length === 1) {
                    return currPattern;
                }
                else {
                    const escapedRegExpString = currPattern.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&");
                    const wrappedRegExp = new RegExp(escapedRegExpString);
                    return options.useSticky
                        ? addStickyFlag(wrappedRegExp)
                        : addStartOfInput(wrappedRegExp);
                }
            }
            else {
                throw Error("non exhaustive match");
            }
        });
    });
    let patternIdxToType;
    let patternIdxToGroup;
    let patternIdxToLongerAltIdxArr;
    let patternIdxToPushMode;
    let patternIdxToPopMode;
    tracer("misc mapping", () => {
        patternIdxToType = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (currType) => currType.tokenTypeIdx);
        patternIdxToGroup = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (clazz) => {
            const groupName = clazz.GROUP;
            /* istanbul ignore next */
            if (groupName === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED) {
                return undefined;
            }
            else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(groupName)) {
                return groupName;
            }
            else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(groupName)) {
                return false;
            }
            else {
                throw Error("non exhaustive match");
            }
        });
        patternIdxToLongerAltIdxArr = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (clazz) => {
            const longerAltType = clazz.LONGER_ALT;
            if (longerAltType) {
                const longerAltIdxArr = (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(longerAltType)
                    ? (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(longerAltType, (type) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(onlyRelevantTypes, type))
                    : [(0,lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"])(onlyRelevantTypes, longerAltType)];
                return longerAltIdxArr;
            }
        });
        patternIdxToPushMode = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (clazz) => clazz.PUSH_MODE);
        patternIdxToPopMode = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (clazz) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(clazz, "POP_MODE"));
    });
    let patternIdxToCanLineTerminator;
    tracer("Line Terminator Handling", () => {
        const lineTerminatorCharCodes = getCharCodes(options.lineTerminatorCharacters);
        patternIdxToCanLineTerminator = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (tokType) => false);
        if (options.positionTracking !== "onlyOffset") {
            patternIdxToCanLineTerminator = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, (tokType) => {
                if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(tokType, "LINE_BREAKS")) {
                    return !!tokType.LINE_BREAKS;
                }
                else {
                    return (checkLineBreaksIssues(tokType, lineTerminatorCharCodes) === false &&
                        (0,_reg_exp_js__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN));
                }
            });
        }
    });
    let patternIdxToIsCustom;
    let patternIdxToShort;
    let emptyGroups;
    let patternIdxToConfig;
    tracer("Misc Mapping #2", () => {
        patternIdxToIsCustom = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(onlyRelevantTypes, isCustomPattern);
        patternIdxToShort = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(allTransformedPatterns, isShortPattern);
        emptyGroups = (0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(onlyRelevantTypes, (acc, clazz) => {
            const groupName = clazz.GROUP;
            if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(groupName) && !(groupName === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED)) {
                acc[groupName] = [];
            }
            return acc;
        }, {});
        patternIdxToConfig = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(allTransformedPatterns, (x, idx) => {
            return {
                pattern: allTransformedPatterns[idx],
                longerAlt: patternIdxToLongerAltIdxArr[idx],
                canLineTerminator: patternIdxToCanLineTerminator[idx],
                isCustom: patternIdxToIsCustom[idx],
                short: patternIdxToShort[idx],
                group: patternIdxToGroup[idx],
                push: patternIdxToPushMode[idx],
                pop: patternIdxToPopMode[idx],
                tokenTypeIdx: patternIdxToType[idx],
                tokenType: onlyRelevantTypes[idx],
            };
        });
    });
    let canBeOptimized = true;
    let charCodeToPatternIdxToConfig = [];
    if (!options.safeMode) {
        tracer("First Char Optimization", () => {
            charCodeToPatternIdxToConfig = (0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(onlyRelevantTypes, (result, currTokType, idx) => {
                if (typeof currTokType.PATTERN === "string") {
                    const charCode = currTokType.PATTERN.charCodeAt(0);
                    const optimizedIdx = charCodeToOptimizedIndex(charCode);
                    addToMapOfArrays(result, optimizedIdx, patternIdxToConfig[idx]);
                }
                else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(currTokType.START_CHARS_HINT)) {
                    let lastOptimizedIdx;
                    (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(currTokType.START_CHARS_HINT, (charOrInt) => {
                        const charCode = typeof charOrInt === "string"
                            ? charOrInt.charCodeAt(0)
                            : charOrInt;
                        const currOptimizedIdx = charCodeToOptimizedIndex(charCode);
                        // Avoid adding the config multiple times
                        /* istanbul ignore else */
                        // - Difficult to check this scenario effects as it is only a performance
                        //   optimization that does not change correctness
                        if (lastOptimizedIdx !== currOptimizedIdx) {
                            lastOptimizedIdx = currOptimizedIdx;
                            addToMapOfArrays(result, currOptimizedIdx, patternIdxToConfig[idx]);
                        }
                    });
                }
                else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currTokType.PATTERN)) {
                    if (currTokType.PATTERN.unicode) {
                        canBeOptimized = false;
                        if (options.ensureOptimizations) {
                            (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_2__.PRINT_ERROR)(`${_reg_exp_js__WEBPACK_IMPORTED_MODULE_3__.failedOptimizationPrefixMsg}` +
                                `\tUnable to analyze < ${currTokType.PATTERN.toString()} > pattern.\n` +
                                "\tThe regexp unicode flag is not currently supported by the regexp-to-ast library.\n" +
                                "\tThis will disable the lexer's first char optimizations.\n" +
                                "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE");
                        }
                    }
                    else {
                        const optimizedCodes = (0,_reg_exp_js__WEBPACK_IMPORTED_MODULE_3__.getOptimizedStartCodesIndices)(currTokType.PATTERN, options.ensureOptimizations);
                        /* istanbul ignore if */
                        // start code will only be empty given an empty regExp or failure of regexp-to-ast library
                        // the first should be a different validation and the second cannot be tested.
                        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(optimizedCodes)) {
                            // we cannot understand what codes may start possible matches
                            // The optimization correctness requires knowing start codes for ALL patterns.
                            // Not actually sure this is an error, no debug message
                            canBeOptimized = false;
                        }
                        (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(optimizedCodes, (code) => {
                            addToMapOfArrays(result, code, patternIdxToConfig[idx]);
                        });
                    }
                }
                else {
                    if (options.ensureOptimizations) {
                        (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_2__.PRINT_ERROR)(`${_reg_exp_js__WEBPACK_IMPORTED_MODULE_3__.failedOptimizationPrefixMsg}` +
                            `\tTokenType: <${currTokType.name}> is using a custom token pattern without providing <start_chars_hint> parameter.\n` +
                            "\tThis will disable the lexer's first char optimizations.\n" +
                            "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE");
                    }
                    canBeOptimized = false;
                }
                return result;
            }, []);
        });
    }
    return {
        emptyGroups: emptyGroups,
        patternIdxToConfig: patternIdxToConfig,
        charCodeToPatternIdxToConfig: charCodeToPatternIdxToConfig,
        hasCustom: hasCustom,
        canBeOptimized: canBeOptimized,
    };
}
function validatePatterns(tokenTypes, validModesNames) {
    let errors = [];
    const missingResult = findMissingPatterns(tokenTypes);
    errors = errors.concat(missingResult.errors);
    const invalidResult = findInvalidPatterns(missingResult.valid);
    const validTokenTypes = invalidResult.valid;
    errors = errors.concat(invalidResult.errors);
    errors = errors.concat(validateRegExpPattern(validTokenTypes));
    errors = errors.concat(findInvalidGroupType(validTokenTypes));
    errors = errors.concat(findModesThatDoNotExist(validTokenTypes, validModesNames));
    errors = errors.concat(findUnreachablePatterns(validTokenTypes));
    return errors;
}
function validateRegExpPattern(tokenTypes) {
    let errors = [];
    const withRegExpPatterns = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currTokType) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(currTokType[PATTERN]));
    errors = errors.concat(findEndOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findStartOfInputAnchor(withRegExpPatterns));
    errors = errors.concat(findUnsupportedFlags(withRegExpPatterns));
    errors = errors.concat(findDuplicatePatterns(withRegExpPatterns));
    errors = errors.concat(findEmptyMatchRegExps(withRegExpPatterns));
    return errors;
}
function findMissingPatterns(tokenTypes) {
    const tokenTypesWithMissingPattern = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currType) => {
        return !(0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(currType, PATTERN);
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(tokenTypesWithMissingPattern, (currType) => {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- missing static 'PATTERN' property",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MISSING_PATTERN,
            tokenTypes: [currType],
        };
    });
    const valid = (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(tokenTypes, tokenTypesWithMissingPattern);
    return { errors, valid };
}
function findInvalidPatterns(tokenTypes) {
    const tokenTypesWithInvalidPattern = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currType) => {
        const pattern = currType[PATTERN];
        return (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(pattern) &&
            !(0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(pattern) &&
            !(0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(pattern, "exec") &&
            !(0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(pattern));
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(tokenTypesWithInvalidPattern, (currType) => {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' can only be a RegExp, a" +
                " Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.INVALID_PATTERN,
            tokenTypes: [currType],
        };
    });
    const valid = (0,lodash_es__WEBPACK_IMPORTED_MODULE_20__["default"])(tokenTypes, tokenTypesWithInvalidPattern);
    return { errors, valid };
}
const end_of_input = /[^\\][$]/;
function findEndOfInputAnchor(tokenTypes) {
    class EndAnchorFinder extends _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor {
        constructor() {
            super(...arguments);
            this.found = false;
        }
        visitEndAnchor(node) {
            this.found = true;
        }
    }
    const invalidRegex = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currType) => {
        const pattern = currType.PATTERN;
        try {
            const regexpAst = (0,_reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_4__.getRegExpAst)(pattern);
            const endAnchorVisitor = new EndAnchorFinder();
            endAnchorVisitor.visit(regexpAst);
            return endAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return end_of_input.test(pattern.source);
        }
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(invalidRegex, (currType) => {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain end of input anchor '$'\n" +
                "\tSee chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.EOI_ANCHOR_FOUND,
            tokenTypes: [currType],
        };
    });
    return errors;
}
function findEmptyMatchRegExps(tokenTypes) {
    const matchesEmptyString = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currType) => {
        const pattern = currType.PATTERN;
        return pattern.test("");
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(matchesEmptyString, (currType) => {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' must not match an empty string",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.EMPTY_MATCH_PATTERN,
            tokenTypes: [currType],
        };
    });
    return errors;
}
const start_of_input = /[^\\[][\^]|^\^/;
function findStartOfInputAnchor(tokenTypes) {
    class StartAnchorFinder extends _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor {
        constructor() {
            super(...arguments);
            this.found = false;
        }
        visitStartAnchor(node) {
            this.found = true;
        }
    }
    const invalidRegex = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currType) => {
        const pattern = currType.PATTERN;
        try {
            const regexpAst = (0,_reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_4__.getRegExpAst)(pattern);
            const startAnchorVisitor = new StartAnchorFinder();
            startAnchorVisitor.visit(regexpAst);
            return startAnchorVisitor.found;
        }
        catch (e) {
            // old behavior in case of runtime exceptions with regexp-to-ast.
            /* istanbul ignore next - cannot ensure an error in regexp-to-ast*/
            return start_of_input.test(pattern.source);
        }
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(invalidRegex, (currType) => {
        return {
            message: "Unexpected RegExp Anchor Error:\n" +
                "\tToken Type: ->" +
                currType.name +
                "<- static 'PATTERN' cannot contain start of input anchor '^'\n" +
                "\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS" +
                "\tfor details.",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.SOI_ANCHOR_FOUND,
            tokenTypes: [currType],
        };
    });
    return errors;
}
function findUnsupportedFlags(tokenTypes) {
    const invalidFlags = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (currType) => {
        const pattern = currType[PATTERN];
        return pattern instanceof RegExp && (pattern.multiline || pattern.global);
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(invalidFlags, (currType) => {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.UNSUPPORTED_FLAGS_FOUND,
            tokenTypes: [currType],
        };
    });
    return errors;
}
// This can only test for identical duplicate RegExps, not semantically equivalent ones.
function findDuplicatePatterns(tokenTypes) {
    const found = [];
    let identicalPatterns = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(tokenTypes, (outerType) => {
        return (0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(tokenTypes, (result, innerType) => {
            if (outerType.PATTERN.source === innerType.PATTERN.source &&
                !(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(found, innerType) &&
                innerType.PATTERN !== _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA) {
                // this avoids duplicates in the result, each Token Type may only appear in one "set"
                // in essence we are creating Equivalence classes on equality relation.
                found.push(innerType);
                result.push(innerType);
                return result;
            }
            return result;
        }, []);
    });
    identicalPatterns = (0,lodash_es__WEBPACK_IMPORTED_MODULE_21__["default"])(identicalPatterns);
    const duplicatePatterns = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(identicalPatterns, (currIdenticalSet) => {
        return currIdenticalSet.length > 1;
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(duplicatePatterns, (setOfIdentical) => {
        const tokenTypeNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(setOfIdentical, (currType) => {
            return currType.name;
        });
        const dupPatternSrc = (0,lodash_es__WEBPACK_IMPORTED_MODULE_22__["default"])(setOfIdentical).PATTERN;
        return {
            message: `The same RegExp pattern ->${dupPatternSrc}<-` +
                `has been used in all of the following Token Types: ${tokenTypeNames.join(", ")} <-`,
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.DUPLICATE_PATTERNS_FOUND,
            tokenTypes: setOfIdentical,
        };
    });
    return errors;
}
function findInvalidGroupType(tokenTypes) {
    const invalidTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (clazz) => {
        if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(clazz, "GROUP")) {
            return false;
        }
        const group = clazz.GROUP;
        return group !== _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.SKIPPED && group !== _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA && !(0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(group);
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(invalidTypes, (currType) => {
        return {
            message: "Token Type: ->" +
                currType.name +
                "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.INVALID_GROUP_TYPE_FOUND,
            tokenTypes: [currType],
        };
    });
    return errors;
}
function findModesThatDoNotExist(tokenTypes, validModes) {
    const invalidModes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_19__["default"])(tokenTypes, (clazz) => {
        return (clazz.PUSH_MODE !== undefined && !(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(validModes, clazz.PUSH_MODE));
    });
    const errors = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(invalidModes, (tokType) => {
        const msg = `Token Type: ->${tokType.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${tokType.PUSH_MODE}<-` +
            `which does not exist`;
        return {
            message: msg,
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.PUSH_MODE_DOES_NOT_EXIST,
            tokenTypes: [tokType],
        };
    });
    return errors;
}
function findUnreachablePatterns(tokenTypes) {
    const errors = [];
    const canBeTested = (0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(tokenTypes, (result, tokType, idx) => {
        const pattern = tokType.PATTERN;
        if (pattern === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA) {
            return result;
        }
        // a more comprehensive validation for all forms of regExps would require
        // deeper regExp analysis capabilities
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(pattern)) {
            result.push({ str: pattern, idx, tokenType: tokType });
        }
        else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(pattern) && noMetaChar(pattern)) {
            result.push({ str: pattern.source, idx, tokenType: tokType });
        }
        return result;
    }, []);
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(tokenTypes, (tokType, testIdx) => {
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(canBeTested, ({ str, idx, tokenType }) => {
            if (testIdx < idx && testTokenType(str, tokType.PATTERN)) {
                const msg = `Token: ->${tokenType.name}<- can never be matched.\n` +
                    `Because it appears AFTER the Token Type ->${tokType.name}<-` +
                    `in the lexer's definition.\n` +
                    `See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
                errors.push({
                    message: msg,
                    type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.UNREACHABLE_PATTERN,
                    tokenTypes: [tokType, tokenType],
                });
            }
        });
    });
    return errors;
}
function testTokenType(str, pattern) {
    /* istanbul ignore else */
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(pattern)) {
        const regExpArray = pattern.exec(str);
        return regExpArray !== null && regExpArray.index === 0;
    }
    else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(pattern)) {
        // maintain the API of custom patterns
        return pattern(str, 0, [], {});
    }
    else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(pattern, "exec")) {
        // maintain the API of custom patterns
        return pattern.exec(str, 0, [], {});
    }
    else if (typeof pattern === "string") {
        return pattern === str;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function noMetaChar(regExp) {
    //https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp
    const metaChars = [
        ".",
        "\\",
        "[",
        "]",
        "|",
        "^",
        "$",
        "(",
        ")",
        "?",
        "*",
        "+",
        "{",
    ];
    return ((0,lodash_es__WEBPACK_IMPORTED_MODULE_23__["default"])(metaChars, (char) => regExp.source.indexOf(char) !== -1) === undefined);
}
function addStartOfInput(pattern) {
    const flags = pattern.ignoreCase ? "i" : "";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp(`^(?:${pattern.source})`, flags);
}
function addStickyFlag(pattern) {
    const flags = pattern.ignoreCase ? "iy" : "y";
    // always wrapping in a none capturing group preceded by '^' to make sure matching can only work on start of input.
    // duplicate/redundant start of input markers have no meaning (/^^^^A/ === /^A/)
    return new RegExp(`${pattern.source}`, flags);
}
function performRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    const errors = [];
    // some run time checks to help the end users.
    if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(lexerDefinition, DEFAULT_MODE)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                DEFAULT_MODE +
                "> property in its definition\n",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,
        });
    }
    if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(lexerDefinition, MODES)) {
        errors.push({
            message: "A MultiMode Lexer cannot be initialized without a <" +
                MODES +
                "> property in its definition\n",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,
        });
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(lexerDefinition, MODES) &&
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(lexerDefinition, DEFAULT_MODE) &&
        !(0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(lexerDefinition.modes, lexerDefinition.defaultMode)) {
        errors.push({
            message: `A MultiMode Lexer cannot be initialized with a ${DEFAULT_MODE}: <${lexerDefinition.defaultMode}>` +
                `which does not exist\n`,
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,
        });
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(lexerDefinition, MODES)) {
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(lexerDefinition.modes, (currModeValue, currModeName) => {
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(currModeValue, (currTokType, currIdx) => {
                if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(currTokType)) {
                    errors.push({
                        message: `A Lexer cannot be initialized using an undefined Token Type. Mode:` +
                            `<${currModeName}> at index: <${currIdx}>\n`,
                        type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,
                    });
                }
                else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(currTokType, "LONGER_ALT")) {
                    const longerAlt = (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(currTokType.LONGER_ALT)
                        ? currTokType.LONGER_ALT
                        : [currTokType.LONGER_ALT];
                    (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(longerAlt, (currLongerAlt) => {
                        if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(currLongerAlt) &&
                            !(0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(currModeValue, currLongerAlt)) {
                            errors.push({
                                message: `A MultiMode Lexer cannot be initialized with a longer_alt <${currLongerAlt.name}> on token <${currTokType.name}> outside of mode <${currModeName}>\n`,
                                type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,
                            });
                        }
                    });
                }
            });
        });
    }
    return errors;
}
function performWarningRuntimeChecks(lexerDefinition, trackLines, lineTerminatorCharacters) {
    const warnings = [];
    let hasAnyLineBreak = false;
    const allTokenTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_21__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_24__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_25__["default"])(lexerDefinition.modes)));
    const concreteTokenTypes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(allTokenTypes, (currType) => currType[PATTERN] === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.Lexer.NA);
    const terminatorCharCodes = getCharCodes(lineTerminatorCharacters);
    if (trackLines) {
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(concreteTokenTypes, (tokType) => {
            const currIssue = checkLineBreaksIssues(tokType, terminatorCharCodes);
            if (currIssue !== false) {
                const message = buildLineBreakIssueMessage(tokType, currIssue);
                const warningDescriptor = {
                    message,
                    type: currIssue.issue,
                    tokenType: tokType,
                };
                warnings.push(warningDescriptor);
            }
            else {
                // we don't want to attempt to scan if the user explicitly specified the line_breaks option.
                if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(tokType, "LINE_BREAKS")) {
                    if (tokType.LINE_BREAKS === true) {
                        hasAnyLineBreak = true;
                    }
                }
                else {
                    if ((0,_reg_exp_js__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(terminatorCharCodes, tokType.PATTERN)) {
                        hasAnyLineBreak = true;
                    }
                }
            }
        });
    }
    if (trackLines && !hasAnyLineBreak) {
        warnings.push({
            message: "Warning: No LINE_BREAKS Found.\n" +
                "\tThis Lexer has been defined to track line and column information,\n" +
                "\tBut none of the Token Types can be identified as matching a line terminator.\n" +
                "\tSee https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS \n" +
                "\tfor details.",
            type: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.NO_LINE_BREAKS_FLAGS,
        });
    }
    return warnings;
}
function cloneEmptyGroups(emptyGroups) {
    const clonedResult = {};
    const groupKeys = (0,lodash_es__WEBPACK_IMPORTED_MODULE_26__["default"])(emptyGroups);
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(groupKeys, (currKey) => {
        const currGroupValue = emptyGroups[currKey];
        /* istanbul ignore else */
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(currGroupValue)) {
            clonedResult[currKey] = [];
        }
        else {
            throw Error("non exhaustive match");
        }
    });
    return clonedResult;
}
// TODO: refactor to avoid duplication
function isCustomPattern(tokenType) {
    const pattern = tokenType.PATTERN;
    /* istanbul ignore else */
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(pattern)) {
        return false;
    }
    else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(pattern)) {
        // CustomPatternMatcherFunc - custom patterns do not require any transformations, only wrapping in a RegExp Like object
        return true;
    }
    else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(pattern, "exec")) {
        // ICustomPattern
        return true;
    }
    else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(pattern)) {
        return false;
    }
    else {
        throw Error("non exhaustive match");
    }
}
function isShortPattern(pattern) {
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(pattern) && pattern.length === 1) {
        return pattern.charCodeAt(0);
    }
    else {
        return false;
    }
}
/**
 * Faster than using a RegExp for default newline detection during lexing.
 */
const LineTerminatorOptimizedTester = {
    // implements /\n|\r\n?/g.test
    test: function (text) {
        const len = text.length;
        for (let i = this.lastIndex; i < len; i++) {
            const c = text.charCodeAt(i);
            if (c === 10) {
                this.lastIndex = i + 1;
                return true;
            }
            else if (c === 13) {
                if (text.charCodeAt(i + 1) === 10) {
                    this.lastIndex = i + 2;
                }
                else {
                    this.lastIndex = i + 1;
                }
                return true;
            }
        }
        return false;
    },
    lastIndex: 0,
};
function checkLineBreaksIssues(tokType, lineTerminatorCharCodes) {
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"])(tokType, "LINE_BREAKS")) {
        // if the user explicitly declared the line_breaks option we will respect their choice
        // and assume it is correct.
        return false;
    }
    else {
        /* istanbul ignore else */
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(tokType.PATTERN)) {
            try {
                // TODO: why is the casting suddenly needed?
                (0,_reg_exp_js__WEBPACK_IMPORTED_MODULE_3__.canMatchCharCode)(lineTerminatorCharCodes, tokType.PATTERN);
            }
            catch (e) {
                /* istanbul ignore next - to test this we would have to mock <canMatchCharCode> to throw an error */
                return {
                    issue: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.IDENTIFY_TERMINATOR,
                    errMsg: e.message,
                };
            }
            return false;
        }
        else if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(tokType.PATTERN)) {
            // string literal patterns can always be analyzed to detect line terminator usage
            return false;
        }
        else if (isCustomPattern(tokType)) {
            // custom token types
            return { issue: _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.CUSTOM_LINE_BREAK };
        }
        else {
            throw Error("non exhaustive match");
        }
    }
}
function buildLineBreakIssueMessage(tokType, details) {
    /* istanbul ignore else */
    if (details.issue === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.IDENTIFY_TERMINATOR) {
        return ("Warning: unable to identify line terminator usage in pattern.\n" +
            `\tThe problem is in the <${tokType.name}> Token Type\n` +
            `\t Root cause: ${details.errMsg}.\n` +
            "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR");
    }
    else if (details.issue === _lexer_public_js__WEBPACK_IMPORTED_MODULE_1__.LexerDefinitionErrorType.CUSTOM_LINE_BREAK) {
        return ("Warning: A Custom Token Pattern should specify the <line_breaks> option.\n" +
            `\tThe problem is in the <${tokType.name}> Token Type\n` +
            "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK");
    }
    else {
        throw Error("non exhaustive match");
    }
}
function getCharCodes(charsOrCodes) {
    const charCodes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(charsOrCodes, (numOrString) => {
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(numOrString)) {
            return numOrString.charCodeAt(0);
        }
        else {
            return numOrString;
        }
    });
    return charCodes;
}
function addToMapOfArrays(map, key, value) {
    if (map[key] === undefined) {
        map[key] = [value];
    }
    else {
        map[key].push(value);
    }
}
const minOptimizationVal = 256;
/**
 * We are mapping charCode above ASCI (256) into buckets each in the size of 256.
 * This is because ASCI are the most common start chars so each one of those will get its own
 * possible token configs vector.
 *
 * Tokens starting with charCodes "above" ASCI are uncommon, so we can "afford"
 * to place these into buckets of possible token configs, What we gain from
 * this is avoiding the case of creating an optimization 'charCodeToPatternIdxToConfig'
 * which would contain 10,000+ arrays of small size (e.g unicode Identifiers scenario).
 * Our 'charCodeToPatternIdxToConfig' max size will now be:
 * 256 + (2^16 / 2^8) - 1 === 511
 *
 * note the hack for fast division integer part extraction
 * See: https://stackoverflow.com/a/4228528
 */
let charCodeToOptimizedIdxMap = [];
function charCodeToOptimizedIndex(charCode) {
    return charCode < minOptimizationVal
        ? charCode
        : charCodeToOptimizedIdxMap[charCode];
}
/**
 * This is a compromise between cold start / hot running performance
 * Creating this array takes ~3ms on a modern machine,
 * But if we perform the computation at runtime as needed the CSS Lexer benchmark
 * performance degrades by ~10%
 *
 * TODO: Perhaps it should be lazy initialized only if a charCode > 255 is used.
 */
function initCharCodeToOptimizedIndexMap() {
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_18__["default"])(charCodeToOptimizedIdxMap)) {
        charCodeToOptimizedIdxMap = new Array(65536);
        for (let i = 0; i < 65536; i++) {
            charCodeToOptimizedIdxMap[i] = i > 255 ? 255 + ~~(i / 255) : i;
        }
    }
}
//# sourceMappingURL=lexer.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js":
/*!*********************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   defaultLexerErrorProvider: () => (/* binding */ defaultLexerErrorProvider)
/* harmony export */ });
const defaultLexerErrorProvider = {
    buildUnableToPopLexerModeMessage(token) {
        return `Unable to pop Lexer Mode after encountering Token ->${token.image}<- The Mode Stack is empty`;
    },
    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {
        return (`unexpected character: ->${fullText.charAt(startOffset)}<- at offset: ${startOffset},` + ` skipped ${length} characters.`);
    },
};
//# sourceMappingURL=lexer_errors_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/lexer_public.js":
/*!**************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/lexer_public.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Lexer: () => (/* binding */ Lexer),
/* harmony export */   LexerDefinitionErrorType: () => (/* binding */ LexerDefinitionErrorType)
/* harmony export */ });
/* harmony import */ var _lexer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer.js */ "./node_modules/chevrotain/lib/src/scan/lexer.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/assign.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reject.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/keys.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/identity.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/noop.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/reduce.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/last.js");
/* harmony import */ var _chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chevrotain/utils */ "./node_modules/@chevrotain/utils/lib/src/api.js");
/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tokens.js */ "./node_modules/chevrotain/lib/src/scan/tokens.js");
/* harmony import */ var _lexer_errors_public_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lexer_errors_public.js */ "./node_modules/chevrotain/lib/src/scan/lexer_errors_public.js");
/* harmony import */ var _reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./reg_exp_parser.js */ "./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js");






var LexerDefinitionErrorType;
(function (LexerDefinitionErrorType) {
    LexerDefinitionErrorType[LexerDefinitionErrorType["MISSING_PATTERN"] = 0] = "MISSING_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_PATTERN"] = 1] = "INVALID_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EOI_ANCHOR_FOUND"] = 2] = "EOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNSUPPORTED_FLAGS_FOUND"] = 3] = "UNSUPPORTED_FLAGS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["DUPLICATE_PATTERNS_FOUND"] = 4] = "DUPLICATE_PATTERNS_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["INVALID_GROUP_TYPE_FOUND"] = 5] = "INVALID_GROUP_TYPE_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["PUSH_MODE_DOES_NOT_EXIST"] = 6] = "PUSH_MODE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"] = 7] = "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"] = 8] = "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"] = 9] = "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST";
    LexerDefinitionErrorType[LexerDefinitionErrorType["LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"] = 10] = "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED";
    LexerDefinitionErrorType[LexerDefinitionErrorType["SOI_ANCHOR_FOUND"] = 11] = "SOI_ANCHOR_FOUND";
    LexerDefinitionErrorType[LexerDefinitionErrorType["EMPTY_MATCH_PATTERN"] = 12] = "EMPTY_MATCH_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["NO_LINE_BREAKS_FLAGS"] = 13] = "NO_LINE_BREAKS_FLAGS";
    LexerDefinitionErrorType[LexerDefinitionErrorType["UNREACHABLE_PATTERN"] = 14] = "UNREACHABLE_PATTERN";
    LexerDefinitionErrorType[LexerDefinitionErrorType["IDENTIFY_TERMINATOR"] = 15] = "IDENTIFY_TERMINATOR";
    LexerDefinitionErrorType[LexerDefinitionErrorType["CUSTOM_LINE_BREAK"] = 16] = "CUSTOM_LINE_BREAK";
    LexerDefinitionErrorType[LexerDefinitionErrorType["MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"] = 17] = "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE";
})(LexerDefinitionErrorType || (LexerDefinitionErrorType = {}));
const DEFAULT_LEXER_CONFIG = {
    deferDefinitionErrorsHandling: false,
    positionTracking: "full",
    lineTerminatorsPattern: /\n|\r\n?/g,
    lineTerminatorCharacters: ["\n", "\r"],
    ensureOptimizations: false,
    safeMode: false,
    errorMessageProvider: _lexer_errors_public_js__WEBPACK_IMPORTED_MODULE_3__.defaultLexerErrorProvider,
    traceInitPerf: false,
    skipValidations: false,
    recoveryEnabled: true,
};
Object.freeze(DEFAULT_LEXER_CONFIG);
class Lexer {
    constructor(lexerDefinition, config = DEFAULT_LEXER_CONFIG) {
        this.lexerDefinition = lexerDefinition;
        this.lexerDefinitionErrors = [];
        this.lexerDefinitionWarning = [];
        this.patternIdxToConfig = {};
        this.charCodeToPatternIdxToConfig = {};
        this.modes = [];
        this.emptyGroups = {};
        this.trackStartLines = true;
        this.trackEndLines = true;
        this.hasCustom = false;
        this.canModeBeOptimized = {};
        // Duplicated from the parser's perf trace trait to allow future extraction
        // of the lexer to a separate package.
        this.TRACE_INIT = (phaseDesc, phaseImpl) => {
            // No need to optimize this using NOOP pattern because
            // It is not called in a hot spot...
            if (this.traceInitPerf === true) {
                this.traceInitIndent++;
                const indent = new Array(this.traceInitIndent + 1).join("\t");
                if (this.traceInitIndent < this.traceInitMaxIdent) {
                    console.log(`${indent}--> <${phaseDesc}>`);
                }
                const { time, value } = (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__.timer)(phaseImpl);
                /* istanbul ignore next - Difficult to reproduce specific performance behavior (>10ms) in tests */
                const traceMethod = time > 10 ? console.warn : console.log;
                if (this.traceInitIndent < this.traceInitMaxIdent) {
                    traceMethod(`${indent}<-- <${phaseDesc}> time: ${time}ms`);
                }
                this.traceInitIndent--;
                return value;
            }
            else {
                return phaseImpl();
            }
        };
        if (typeof config === "boolean") {
            throw Error("The second argument to the Lexer constructor is now an ILexerConfig Object.\n" +
                "a boolean 2nd argument is no longer supported");
        }
        // todo: defaults func?
        this.config = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])({}, DEFAULT_LEXER_CONFIG, config);
        const traceInitVal = this.config.traceInitPerf;
        if (traceInitVal === true) {
            this.traceInitMaxIdent = Infinity;
            this.traceInitPerf = true;
        }
        else if (typeof traceInitVal === "number") {
            this.traceInitMaxIdent = traceInitVal;
            this.traceInitPerf = true;
        }
        this.traceInitIndent = -1;
        this.TRACE_INIT("Lexer Constructor", () => {
            let actualDefinition;
            let hasOnlySingleMode = true;
            this.TRACE_INIT("Lexer Config handling", () => {
                if (this.config.lineTerminatorsPattern ===
                    DEFAULT_LEXER_CONFIG.lineTerminatorsPattern) {
                    // optimized built-in implementation for the defaults definition of lineTerminators
                    this.config.lineTerminatorsPattern = _lexer_js__WEBPACK_IMPORTED_MODULE_0__.LineTerminatorOptimizedTester;
                }
                else {
                    if (this.config.lineTerminatorCharacters ===
                        DEFAULT_LEXER_CONFIG.lineTerminatorCharacters) {
                        throw Error("Error: Missing <lineTerminatorCharacters> property on the Lexer config.\n" +
                            "\tFor details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS");
                    }
                }
                if (config.safeMode && config.ensureOptimizations) {
                    throw Error('"safeMode" and "ensureOptimizations" flags are mutually exclusive.');
                }
                this.trackStartLines = /full|onlyStart/i.test(this.config.positionTracking);
                this.trackEndLines = /full/i.test(this.config.positionTracking);
                // Convert SingleModeLexerDefinition into a IMultiModeLexerDefinition.
                if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(lexerDefinition)) {
                    actualDefinition = {
                        modes: { defaultMode: (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(lexerDefinition) },
                        defaultMode: _lexer_js__WEBPACK_IMPORTED_MODULE_0__.DEFAULT_MODE,
                    };
                }
                else {
                    // no conversion needed, input should already be a IMultiModeLexerDefinition
                    hasOnlySingleMode = false;
                    actualDefinition = (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(lexerDefinition);
                }
            });
            if (this.config.skipValidations === false) {
                this.TRACE_INIT("performRuntimeChecks", () => {
                    this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat((0,_lexer_js__WEBPACK_IMPORTED_MODULE_0__.performRuntimeChecks)(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));
                });
                this.TRACE_INIT("performWarningRuntimeChecks", () => {
                    this.lexerDefinitionWarning = this.lexerDefinitionWarning.concat((0,_lexer_js__WEBPACK_IMPORTED_MODULE_0__.performWarningRuntimeChecks)(actualDefinition, this.trackStartLines, this.config.lineTerminatorCharacters));
                });
            }
            // for extra robustness to avoid throwing an none informative error message
            actualDefinition.modes = actualDefinition.modes
                ? actualDefinition.modes
                : {};
            // an error of undefined TokenTypes will be detected in "performRuntimeChecks" above.
            // this transformation is to increase robustness in the case of partially invalid lexer definition.
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(actualDefinition.modes, (currModeValue, currModeName) => {
                actualDefinition.modes[currModeName] = (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(currModeValue, (currTokType) => (0,lodash_es__WEBPACK_IMPORTED_MODULE_10__["default"])(currTokType));
            });
            const allModeNames = (0,lodash_es__WEBPACK_IMPORTED_MODULE_11__["default"])(actualDefinition.modes);
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(actualDefinition.modes, (currModDef, currModName) => {
                this.TRACE_INIT(`Mode: <${currModName}> processing`, () => {
                    this.modes.push(currModName);
                    if (this.config.skipValidations === false) {
                        this.TRACE_INIT(`validatePatterns`, () => {
                            this.lexerDefinitionErrors = this.lexerDefinitionErrors.concat((0,_lexer_js__WEBPACK_IMPORTED_MODULE_0__.validatePatterns)(currModDef, allModeNames));
                        });
                    }
                    // If definition errors were encountered, the analysis phase may fail unexpectedly/
                    // Considering a lexer with definition errors may never be used, there is no point
                    // to performing the analysis anyhow...
                    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(this.lexerDefinitionErrors)) {
                        (0,_tokens_js__WEBPACK_IMPORTED_MODULE_2__.augmentTokenTypes)(currModDef);
                        let currAnalyzeResult;
                        this.TRACE_INIT(`analyzeTokenTypes`, () => {
                            currAnalyzeResult = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_0__.analyzeTokenTypes)(currModDef, {
                                lineTerminatorCharacters: this.config.lineTerminatorCharacters,
                                positionTracking: config.positionTracking,
                                ensureOptimizations: config.ensureOptimizations,
                                safeMode: config.safeMode,
                                tracer: this.TRACE_INIT,
                            });
                        });
                        this.patternIdxToConfig[currModName] =
                            currAnalyzeResult.patternIdxToConfig;
                        this.charCodeToPatternIdxToConfig[currModName] =
                            currAnalyzeResult.charCodeToPatternIdxToConfig;
                        this.emptyGroups = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])({}, this.emptyGroups, currAnalyzeResult.emptyGroups);
                        this.hasCustom = currAnalyzeResult.hasCustom || this.hasCustom;
                        this.canModeBeOptimized[currModName] =
                            currAnalyzeResult.canBeOptimized;
                    }
                });
            });
            this.defaultMode = actualDefinition.defaultMode;
            if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(this.lexerDefinitionErrors) &&
                !this.config.deferDefinitionErrorsHandling) {
                const allErrMessages = (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(this.lexerDefinitionErrors, (error) => {
                    return error.message;
                });
                const allErrMessagesString = allErrMessages.join("-----------------------\n");
                throw new Error("Errors detected in definition of Lexer:\n" + allErrMessagesString);
            }
            // Only print warning if there are no errors, This will avoid pl
            (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(this.lexerDefinitionWarning, (warningDescriptor) => {
                (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_WARNING)(warningDescriptor.message);
            });
            this.TRACE_INIT("Choosing sub-methods implementations", () => {
                // Choose the relevant internal implementations for this specific parser.
                // These implementations should be in-lined by the JavaScript engine
                // to provide optimal performance in each scenario.
                if (_lexer_js__WEBPACK_IMPORTED_MODULE_0__.SUPPORT_STICKY) {
                    this.chopInput = lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"];
                    this.match = this.matchWithTest;
                }
                else {
                    this.updateLastIndex = lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"];
                    this.match = this.matchWithExec;
                }
                if (hasOnlySingleMode) {
                    this.handleModes = lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"];
                }
                if (this.trackStartLines === false) {
                    this.computeNewColumn = lodash_es__WEBPACK_IMPORTED_MODULE_14__["default"];
                }
                if (this.trackEndLines === false) {
                    this.updateTokenEndLineColumnLocation = lodash_es__WEBPACK_IMPORTED_MODULE_15__["default"];
                }
                if (/full/i.test(this.config.positionTracking)) {
                    this.createTokenInstance = this.createFullToken;
                }
                else if (/onlyStart/i.test(this.config.positionTracking)) {
                    this.createTokenInstance = this.createStartOnlyToken;
                }
                else if (/onlyOffset/i.test(this.config.positionTracking)) {
                    this.createTokenInstance = this.createOffsetOnlyToken;
                }
                else {
                    throw Error(`Invalid <positionTracking> config option: "${this.config.positionTracking}"`);
                }
                if (this.hasCustom) {
                    this.addToken = this.addTokenUsingPush;
                    this.handlePayload = this.handlePayloadWithCustom;
                }
                else {
                    this.addToken = this.addTokenUsingMemberAccess;
                    this.handlePayload = this.handlePayloadNoCustom;
                }
            });
            this.TRACE_INIT("Failed Optimization Warnings", () => {
                const unOptimizedModes = (0,lodash_es__WEBPACK_IMPORTED_MODULE_16__["default"])(this.canModeBeOptimized, (cannotBeOptimized, canBeOptimized, modeName) => {
                    if (canBeOptimized === false) {
                        cannotBeOptimized.push(modeName);
                    }
                    return cannotBeOptimized;
                }, []);
                if (config.ensureOptimizations && !(0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(unOptimizedModes)) {
                    throw Error(`Lexer Modes: < ${unOptimizedModes.join(", ")} > cannot be optimized.\n` +
                        '\t Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.\n' +
                        "\t Or inspect the console log for details on how to resolve these issues.");
                }
            });
            this.TRACE_INIT("clearRegExpParserCache", () => {
                (0,_reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_4__.clearRegExpParserCache)();
            });
            this.TRACE_INIT("toFastProperties", () => {
                (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__.toFastProperties)(this);
            });
        });
    }
    tokenize(text, initialMode = this.defaultMode) {
        if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_12__["default"])(this.lexerDefinitionErrors)) {
            const allErrMessages = (0,lodash_es__WEBPACK_IMPORTED_MODULE_13__["default"])(this.lexerDefinitionErrors, (error) => {
                return error.message;
            });
            const allErrMessagesString = allErrMessages.join("-----------------------\n");
            throw new Error("Unable to Tokenize because Errors detected in definition of Lexer:\n" +
                allErrMessagesString);
        }
        return this.tokenizeInternal(text, initialMode);
    }
    // There is quite a bit of duplication between this and "tokenizeInternalLazy"
    // This is intentional due to performance considerations.
    // this method also used quite a bit of `!` none null assertions because it is too optimized
    // for `tsc` to always understand it is "safe"
    tokenizeInternal(text, initialMode) {
        let i, j, k, matchAltImage, longerAlt, matchedImage, payload, altPayload, imageLength, group, tokType, newToken, errLength, droppedChar, msg, match;
        const orgText = text;
        const orgLength = orgText.length;
        let offset = 0;
        let matchedTokensIndex = 0;
        // initializing the tokensArray to the "guessed" size.
        // guessing too little will still reduce the number of array re-sizes on pushes.
        // guessing too large (Tested by guessing x4 too large) may cost a bit more of memory
        // but would still have a faster runtime by avoiding (All but one) array resizing.
        const guessedNumberOfTokens = this.hasCustom
            ? 0 // will break custom token pattern APIs the matchedTokens array will contain undefined elements.
            : Math.floor(text.length / 10);
        const matchedTokens = new Array(guessedNumberOfTokens);
        const errors = [];
        let line = this.trackStartLines ? 1 : undefined;
        let column = this.trackStartLines ? 1 : undefined;
        const groups = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_0__.cloneEmptyGroups)(this.emptyGroups);
        const trackLines = this.trackStartLines;
        const lineTerminatorPattern = this.config.lineTerminatorsPattern;
        let currModePatternsLength = 0;
        let patternIdxToConfig = [];
        let currCharCodeToPatternIdxToConfig = [];
        const modeStack = [];
        const emptyArray = [];
        Object.freeze(emptyArray);
        let getPossiblePatterns;
        function getPossiblePatternsSlow() {
            return patternIdxToConfig;
        }
        function getPossiblePatternsOptimized(charCode) {
            const optimizedCharIdx = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_0__.charCodeToOptimizedIndex)(charCode);
            const possiblePatterns = currCharCodeToPatternIdxToConfig[optimizedCharIdx];
            if (possiblePatterns === undefined) {
                return emptyArray;
            }
            else {
                return possiblePatterns;
            }
        }
        const pop_mode = (popToken) => {
            // TODO: perhaps avoid this error in the edge case there is no more input?
            if (modeStack.length === 1 &&
                // if we have both a POP_MODE and a PUSH_MODE this is in-fact a "transition"
                // So no error should occur.
                popToken.tokenType.PUSH_MODE === undefined) {
                // if we try to pop the last mode there lexer will no longer have ANY mode.
                // thus the pop is ignored, an error will be created and the lexer will continue parsing in the previous mode.
                const msg = this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(popToken);
                errors.push({
                    offset: popToken.startOffset,
                    line: popToken.startLine,
                    column: popToken.startColumn,
                    length: popToken.image.length,
                    message: msg,
                });
            }
            else {
                modeStack.pop();
                const newMode = (0,lodash_es__WEBPACK_IMPORTED_MODULE_17__["default"])(modeStack);
                patternIdxToConfig = this.patternIdxToConfig[newMode];
                currCharCodeToPatternIdxToConfig =
                    this.charCodeToPatternIdxToConfig[newMode];
                currModePatternsLength = patternIdxToConfig.length;
                const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
                if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                    getPossiblePatterns = getPossiblePatternsOptimized;
                }
                else {
                    getPossiblePatterns = getPossiblePatternsSlow;
                }
            }
        };
        function push_mode(newMode) {
            modeStack.push(newMode);
            currCharCodeToPatternIdxToConfig =
                this.charCodeToPatternIdxToConfig[newMode];
            patternIdxToConfig = this.patternIdxToConfig[newMode];
            currModePatternsLength = patternIdxToConfig.length;
            currModePatternsLength = patternIdxToConfig.length;
            const modeCanBeOptimized = this.canModeBeOptimized[newMode] && this.config.safeMode === false;
            if (currCharCodeToPatternIdxToConfig && modeCanBeOptimized) {
                getPossiblePatterns = getPossiblePatternsOptimized;
            }
            else {
                getPossiblePatterns = getPossiblePatternsSlow;
            }
        }
        // this pattern seems to avoid a V8 de-optimization, although that de-optimization does not
        // seem to matter performance wise.
        push_mode.call(this, initialMode);
        let currConfig;
        const recoveryEnabled = this.config.recoveryEnabled;
        while (offset < orgLength) {
            matchedImage = null;
            const nextCharCode = orgText.charCodeAt(offset);
            const chosenPatternIdxToConfig = getPossiblePatterns(nextCharCode);
            const chosenPatternsLength = chosenPatternIdxToConfig.length;
            for (i = 0; i < chosenPatternsLength; i++) {
                currConfig = chosenPatternIdxToConfig[i];
                const currPattern = currConfig.pattern;
                payload = null;
                // manually in-lined because > 600 chars won't be in-lined in V8
                const singleCharCode = currConfig.short;
                if (singleCharCode !== false) {
                    if (nextCharCode === singleCharCode) {
                        // single character string
                        matchedImage = currPattern;
                    }
                }
                else if (currConfig.isCustom === true) {
                    match = currPattern.exec(orgText, offset, matchedTokens, groups);
                    if (match !== null) {
                        matchedImage = match[0];
                        if (match.payload !== undefined) {
                            payload = match.payload;
                        }
                    }
                    else {
                        matchedImage = null;
                    }
                }
                else {
                    this.updateLastIndex(currPattern, offset);
                    matchedImage = this.match(currPattern, text, offset);
                }
                if (matchedImage !== null) {
                    // even though this pattern matched we must try a another longer alternative.
                    // this can be used to prioritize keywords over identifiers
                    longerAlt = currConfig.longerAlt;
                    if (longerAlt !== undefined) {
                        // TODO: micro optimize, avoid extra prop access
                        // by saving/linking longerAlt on the original config?
                        const longerAltLength = longerAlt.length;
                        for (k = 0; k < longerAltLength; k++) {
                            const longerAltConfig = patternIdxToConfig[longerAlt[k]];
                            const longerAltPattern = longerAltConfig.pattern;
                            altPayload = null;
                            // single Char can never be a longer alt so no need to test it.
                            // manually in-lined because > 600 chars won't be in-lined in V8
                            if (longerAltConfig.isCustom === true) {
                                match = longerAltPattern.exec(orgText, offset, matchedTokens, groups);
                                if (match !== null) {
                                    matchAltImage = match[0];
                                    if (match.payload !== undefined) {
                                        altPayload = match.payload;
                                    }
                                }
                                else {
                                    matchAltImage = null;
                                }
                            }
                            else {
                                this.updateLastIndex(longerAltPattern, offset);
                                matchAltImage = this.match(longerAltPattern, text, offset);
                            }
                            if (matchAltImage && matchAltImage.length > matchedImage.length) {
                                matchedImage = matchAltImage;
                                payload = altPayload;
                                currConfig = longerAltConfig;
                                // Exit the loop early after matching one of the longer alternatives
                                // The first matched alternative takes precedence
                                break;
                            }
                        }
                    }
                    break;
                }
            }
            // successful match
            if (matchedImage !== null) {
                imageLength = matchedImage.length;
                group = currConfig.group;
                if (group !== undefined) {
                    tokType = currConfig.tokenTypeIdx;
                    // TODO: "offset + imageLength" and the new column may be computed twice in case of "full" location information inside
                    // createFullToken method
                    newToken = this.createTokenInstance(matchedImage, offset, tokType, currConfig.tokenType, line, column, imageLength);
                    this.handlePayload(newToken, payload);
                    // TODO: optimize NOOP in case there are no special groups?
                    if (group === false) {
                        matchedTokensIndex = this.addToken(matchedTokens, matchedTokensIndex, newToken);
                    }
                    else {
                        groups[group].push(newToken);
                    }
                }
                text = this.chopInput(text, imageLength);
                offset = offset + imageLength;
                // TODO: with newlines the column may be assigned twice
                column = this.computeNewColumn(column, imageLength);
                if (trackLines === true && currConfig.canLineTerminator === true) {
                    let numOfLTsInMatch = 0;
                    let foundTerminator;
                    let lastLTEndOffset;
                    lineTerminatorPattern.lastIndex = 0;
                    do {
                        foundTerminator = lineTerminatorPattern.test(matchedImage);
                        if (foundTerminator === true) {
                            lastLTEndOffset = lineTerminatorPattern.lastIndex - 1;
                            numOfLTsInMatch++;
                        }
                    } while (foundTerminator === true);
                    if (numOfLTsInMatch !== 0) {
                        line = line + numOfLTsInMatch;
                        column = imageLength - lastLTEndOffset;
                        this.updateTokenEndLineColumnLocation(newToken, group, lastLTEndOffset, numOfLTsInMatch, line, column, imageLength);
                    }
                }
                // will be NOOP if no modes present
                this.handleModes(currConfig, pop_mode, push_mode, newToken);
            }
            else {
                // error recovery, drop characters until we identify a valid token's start point
                const errorStartOffset = offset;
                const errorLine = line;
                const errorColumn = column;
                let foundResyncPoint = recoveryEnabled === false;
                while (foundResyncPoint === false && offset < orgLength) {
                    // Identity Func (when sticky flag is enabled)
                    text = this.chopInput(text, 1);
                    offset++;
                    for (j = 0; j < currModePatternsLength; j++) {
                        const currConfig = patternIdxToConfig[j];
                        const currPattern = currConfig.pattern;
                        // manually in-lined because > 600 chars won't be in-lined in V8
                        const singleCharCode = currConfig.short;
                        if (singleCharCode !== false) {
                            if (orgText.charCodeAt(offset) === singleCharCode) {
                                // single character string
                                foundResyncPoint = true;
                            }
                        }
                        else if (currConfig.isCustom === true) {
                            foundResyncPoint =
                                currPattern.exec(orgText, offset, matchedTokens, groups) !== null;
                        }
                        else {
                            this.updateLastIndex(currPattern, offset);
                            foundResyncPoint = currPattern.exec(text) !== null;
                        }
                        if (foundResyncPoint === true) {
                            break;
                        }
                    }
                }
                errLength = offset - errorStartOffset;
                column = this.computeNewColumn(column, errLength);
                // at this point we either re-synced or reached the end of the input text
                msg = this.config.errorMessageProvider.buildUnexpectedCharactersMessage(orgText, errorStartOffset, errLength, errorLine, errorColumn);
                errors.push({
                    offset: errorStartOffset,
                    line: errorLine,
                    column: errorColumn,
                    length: errLength,
                    message: msg,
                });
                if (recoveryEnabled === false) {
                    break;
                }
            }
        }
        // if we do have custom patterns which push directly into the
        // TODO: custom tokens should not push directly??
        if (!this.hasCustom) {
            // if we guessed a too large size for the tokens array this will shrink it to the right size.
            matchedTokens.length = matchedTokensIndex;
        }
        return {
            tokens: matchedTokens,
            groups: groups,
            errors: errors,
        };
    }
    handleModes(config, pop_mode, push_mode, newToken) {
        if (config.pop === true) {
            // need to save the PUSH_MODE property as if the mode is popped
            // patternIdxToPopMode is updated to reflect the new mode after popping the stack
            const pushMode = config.push;
            pop_mode(newToken);
            if (pushMode !== undefined) {
                push_mode.call(this, pushMode);
            }
        }
        else if (config.push !== undefined) {
            push_mode.call(this, config.push);
        }
    }
    chopInput(text, length) {
        return text.substring(length);
    }
    updateLastIndex(regExp, newLastIndex) {
        regExp.lastIndex = newLastIndex;
    }
    // TODO: decrease this under 600 characters? inspect stripping comments option in TSC compiler
    updateTokenEndLineColumnLocation(newToken, group, lastLTIdx, numOfLTsInMatch, line, column, imageLength) {
        let lastCharIsLT, fixForEndingInLT;
        if (group !== undefined) {
            // a none skipped multi line Token, need to update endLine/endColumn
            lastCharIsLT = lastLTIdx === imageLength - 1;
            fixForEndingInLT = lastCharIsLT ? -1 : 0;
            if (!(numOfLTsInMatch === 1 && lastCharIsLT === true)) {
                // if a token ends in a LT that last LT only affects the line numbering of following Tokens
                newToken.endLine = line + fixForEndingInLT;
                // the last LT in a token does not affect the endColumn either as the [columnStart ... columnEnd)
                // inclusive to exclusive range.
                newToken.endColumn = column - 1 + -fixForEndingInLT;
            }
            // else single LT in the last character of a token, no need to modify the endLine/EndColumn
        }
    }
    computeNewColumn(oldColumn, imageLength) {
        return oldColumn + imageLength;
    }
    createOffsetOnlyToken(image, startOffset, tokenTypeIdx, tokenType) {
        return {
            image,
            startOffset,
            tokenTypeIdx,
            tokenType,
        };
    }
    createStartOnlyToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn) {
        return {
            image,
            startOffset,
            startLine,
            startColumn,
            tokenTypeIdx,
            tokenType,
        };
    }
    createFullToken(image, startOffset, tokenTypeIdx, tokenType, startLine, startColumn, imageLength) {
        return {
            image,
            startOffset,
            endOffset: startOffset + imageLength - 1,
            startLine,
            endLine: startLine,
            startColumn,
            endColumn: startColumn + imageLength - 1,
            tokenTypeIdx,
            tokenType,
        };
    }
    addTokenUsingPush(tokenVector, index, tokenToAdd) {
        tokenVector.push(tokenToAdd);
        return index;
    }
    addTokenUsingMemberAccess(tokenVector, index, tokenToAdd) {
        tokenVector[index] = tokenToAdd;
        index++;
        return index;
    }
    handlePayloadNoCustom(token, payload) { }
    handlePayloadWithCustom(token, payload) {
        if (payload !== null) {
            token.payload = payload;
        }
    }
    matchWithTest(pattern, text, offset) {
        const found = pattern.test(text);
        if (found === true) {
            return text.substring(offset, pattern.lastIndex);
        }
        return null;
    }
    matchWithExec(pattern, text) {
        const regExpArray = pattern.exec(text);
        return regExpArray !== null ? regExpArray[0] : null;
    }
}
Lexer.SKIPPED = "This marks a skipped Token pattern, this means each token identified by it will" +
    "be consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
Lexer.NA = /NOT_APPLICABLE/;
//# sourceMappingURL=lexer_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/reg_exp.js":
/*!*********************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/reg_exp.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   canMatchCharCode: () => (/* binding */ canMatchCharCode),
/* harmony export */   failedOptimizationPrefixMsg: () => (/* binding */ failedOptimizationPrefixMsg),
/* harmony export */   firstCharOptimizedIndices: () => (/* binding */ firstCharOptimizedIndices),
/* harmony export */   getOptimizedStartCodesIndices: () => (/* binding */ getOptimizedStartCodesIndices)
/* harmony export */ });
/* harmony import */ var _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/regexp-to-ast */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/values.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/find.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/every.js");
/* harmony import */ var _chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @chevrotain/utils */ "./node_modules/@chevrotain/utils/lib/src/api.js");
/* harmony import */ var _reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./reg_exp_parser.js */ "./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js");
/* harmony import */ var _lexer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lexer.js */ "./node_modules/chevrotain/lib/src/scan/lexer.js");





const complementErrorMessage = "Complement Sets are not supported for first char optimization";
const failedOptimizationPrefixMsg = 'Unable to use "first char" lexer optimizations:\n';
function getOptimizedStartCodesIndices(regExp, ensureOptimizations = false) {
    try {
        const ast = (0,_reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_2__.getRegExpAst)(regExp);
        const firstChars = firstCharOptimizedIndices(ast.value, {}, ast.flags.ignoreCase);
        return firstChars;
    }
    catch (e) {
        /* istanbul ignore next */
        // Testing this relies on the regexp-to-ast library having a bug... */
        // TODO: only the else branch needs to be ignored, try to fix with newer prettier / tsc
        if (e.message === complementErrorMessage) {
            if (ensureOptimizations) {
                (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_WARNING)(`${failedOptimizationPrefixMsg}` +
                    `\tUnable to optimize: < ${regExp.toString()} >\n` +
                    "\tComplement Sets cannot be automatically optimized.\n" +
                    "\tThis will disable the lexer's first char optimizations.\n" +
                    "\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.");
            }
        }
        else {
            let msgSuffix = "";
            if (ensureOptimizations) {
                msgSuffix =
                    "\n\tThis will disable the lexer's first char optimizations.\n" +
                        "\tSee: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.";
            }
            (0,_chevrotain_utils__WEBPACK_IMPORTED_MODULE_1__.PRINT_ERROR)(`${failedOptimizationPrefixMsg}\n` +
                `\tFailed parsing: < ${regExp.toString()} >\n` +
                `\tUsing the @chevrotain/regexp-to-ast library\n` +
                "\tPlease open an issue at: https://github.com/chevrotain/chevrotain/issues" +
                msgSuffix);
        }
    }
    return [];
}
function firstCharOptimizedIndices(ast, result, ignoreCase) {
    switch (ast.type) {
        case "Disjunction":
            for (let i = 0; i < ast.value.length; i++) {
                firstCharOptimizedIndices(ast.value[i], result, ignoreCase);
            }
            break;
        case "Alternative":
            const terms = ast.value;
            for (let i = 0; i < terms.length; i++) {
                const term = terms[i];
                // skip terms that cannot effect the first char results
                switch (term.type) {
                    case "EndAnchor":
                    // A group back reference cannot affect potential starting char.
                    // because if a back reference is the first production than automatically
                    // the group being referenced has had to come BEFORE so its codes have already been added
                    case "GroupBackReference":
                    // assertions do not affect potential starting codes
                    case "Lookahead":
                    case "NegativeLookahead":
                    case "StartAnchor":
                    case "WordBoundary":
                    case "NonWordBoundary":
                        continue;
                }
                const atom = term;
                switch (atom.type) {
                    case "Character":
                        addOptimizedIdxToResult(atom.value, result, ignoreCase);
                        break;
                    case "Set":
                        if (atom.complement === true) {
                            throw Error(complementErrorMessage);
                        }
                        (0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(atom.value, (code) => {
                            if (typeof code === "number") {
                                addOptimizedIdxToResult(code, result, ignoreCase);
                            }
                            else {
                                // range
                                const range = code;
                                // cannot optimize when ignoreCase is
                                if (ignoreCase === true) {
                                    for (let rangeCode = range.from; rangeCode <= range.to; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                }
                                // Optimization (2 orders of magnitude less work for very large ranges)
                                else {
                                    // handle unoptimized values
                                    for (let rangeCode = range.from; rangeCode <= range.to && rangeCode < _lexer_js__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal; rangeCode++) {
                                        addOptimizedIdxToResult(rangeCode, result, ignoreCase);
                                    }
                                    // Less common charCode where we optimize for faster init time, by using larger "buckets"
                                    if (range.to >= _lexer_js__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal) {
                                        const minUnOptVal = range.from >= _lexer_js__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal
                                            ? range.from
                                            : _lexer_js__WEBPACK_IMPORTED_MODULE_3__.minOptimizationVal;
                                        const maxUnOptVal = range.to;
                                        const minOptIdx = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(minUnOptVal);
                                        const maxOptIdx = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(maxUnOptVal);
                                        for (let currOptIdx = minOptIdx; currOptIdx <= maxOptIdx; currOptIdx++) {
                                            result[currOptIdx] = currOptIdx;
                                        }
                                    }
                                }
                            }
                        });
                        break;
                    case "Group":
                        firstCharOptimizedIndices(atom.value, result, ignoreCase);
                        break;
                    /* istanbul ignore next */
                    default:
                        throw Error("Non Exhaustive Match");
                }
                // reached a mandatory production, no more **start** codes can be found on this alternative
                const isOptionalQuantifier = atom.quantifier !== undefined && atom.quantifier.atLeast === 0;
                if (
                // A group may be optional due to empty contents /(?:)/
                // or if everything inside it is optional /((a)?)/
                (atom.type === "Group" && isWholeOptional(atom) === false) ||
                    // If this term is not a group it may only be optional if it has an optional quantifier
                    (atom.type !== "Group" && isOptionalQuantifier === false)) {
                    break;
                }
            }
            break;
        /* istanbul ignore next */
        default:
            throw Error("non exhaustive match!");
    }
    // console.log(Object.keys(result).length)
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(result);
}
function addOptimizedIdxToResult(code, result, ignoreCase) {
    const optimizedCharIdx = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(code);
    result[optimizedCharIdx] = optimizedCharIdx;
    if (ignoreCase === true) {
        handleIgnoreCase(code, result);
    }
}
function handleIgnoreCase(code, result) {
    const char = String.fromCharCode(code);
    const upperChar = char.toUpperCase();
    /* istanbul ignore else */
    if (upperChar !== char) {
        const optimizedCharIdx = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(upperChar.charCodeAt(0));
        result[optimizedCharIdx] = optimizedCharIdx;
    }
    else {
        const lowerChar = char.toLowerCase();
        if (lowerChar !== char) {
            const optimizedCharIdx = (0,_lexer_js__WEBPACK_IMPORTED_MODULE_3__.charCodeToOptimizedIndex)(lowerChar.charCodeAt(0));
            result[optimizedCharIdx] = optimizedCharIdx;
        }
    }
}
function findCode(setNode, targetCharCodes) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(setNode.value, (codeOrRange) => {
        if (typeof codeOrRange === "number") {
            return (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(targetCharCodes, codeOrRange);
        }
        else {
            // range
            const range = codeOrRange;
            return ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(targetCharCodes, (targetCode) => range.from <= targetCode && targetCode <= range.to) !== undefined);
        }
    });
}
function isWholeOptional(ast) {
    const quantifier = ast.quantifier;
    if (quantifier && quantifier.atLeast === 0) {
        return true;
    }
    if (!ast.value) {
        return false;
    }
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(ast.value)
        ? (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(ast.value, isWholeOptional)
        : isWholeOptional(ast.value);
}
class CharCodeFinder extends _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor {
    constructor(targetCharCodes) {
        super();
        this.targetCharCodes = targetCharCodes;
        this.found = false;
    }
    visitChildren(node) {
        // No need to keep looking...
        if (this.found === true) {
            return;
        }
        // switch lookaheads as they do not actually consume any characters thus
        // finding a charCode at lookahead context does not mean that regexp can actually contain it in a match.
        switch (node.type) {
            case "Lookahead":
                this.visitLookahead(node);
                return;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                return;
        }
        super.visitChildren(node);
    }
    visitCharacter(node) {
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(this.targetCharCodes, node.value)) {
            this.found = true;
        }
    }
    visitSet(node) {
        if (node.complement) {
            if (findCode(node, this.targetCharCodes) === undefined) {
                this.found = true;
            }
        }
        else {
            if (findCode(node, this.targetCharCodes) !== undefined) {
                this.found = true;
            }
        }
    }
}
function canMatchCharCode(charCodes, pattern) {
    if (pattern instanceof RegExp) {
        const ast = (0,_reg_exp_parser_js__WEBPACK_IMPORTED_MODULE_2__.getRegExpAst)(pattern);
        const charCodeFinder = new CharCodeFinder(charCodes);
        charCodeFinder.visit(ast);
        return charCodeFinder.found;
    }
    else {
        return ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(pattern, (char) => {
            return (0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(charCodes, char.charCodeAt(0));
        }) !== undefined);
    }
}
//# sourceMappingURL=reg_exp.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js":
/*!****************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/reg_exp_parser.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   clearRegExpParserCache: () => (/* binding */ clearRegExpParserCache),
/* harmony export */   getRegExpAst: () => (/* binding */ getRegExpAst)
/* harmony export */ });
/* harmony import */ var _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/regexp-to-ast */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js");

let regExpAstCache = {};
const regExpParser = new _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.RegExpParser();
function getRegExpAst(regExp) {
    const regExpStr = regExp.toString();
    if (regExpAstCache.hasOwnProperty(regExpStr)) {
        return regExpAstCache[regExpStr];
    }
    else {
        const regExpAst = regExpParser.pattern(regExpStr);
        regExpAstCache[regExpStr] = regExpAst;
        return regExpAst;
    }
}
function clearRegExpParserCache() {
    regExpAstCache = {};
}
//# sourceMappingURL=reg_exp_parser.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/tokens.js":
/*!********************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/tokens.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignCategoriesMapProp: () => (/* binding */ assignCategoriesMapProp),
/* harmony export */   assignCategoriesTokensProp: () => (/* binding */ assignCategoriesTokensProp),
/* harmony export */   assignTokenDefaultProps: () => (/* binding */ assignTokenDefaultProps),
/* harmony export */   augmentTokenTypes: () => (/* binding */ augmentTokenTypes),
/* harmony export */   expandCategories: () => (/* binding */ expandCategories),
/* harmony export */   hasCategoriesProperty: () => (/* binding */ hasCategoriesProperty),
/* harmony export */   hasExtendingTokensTypesMapProperty: () => (/* binding */ hasExtendingTokensTypesMapProperty),
/* harmony export */   hasExtendingTokensTypesProperty: () => (/* binding */ hasExtendingTokensTypesProperty),
/* harmony export */   hasShortKeyProperty: () => (/* binding */ hasShortKeyProperty),
/* harmony export */   isTokenType: () => (/* binding */ isTokenType),
/* harmony export */   singleAssignCategoriesToksMap: () => (/* binding */ singleAssignCategoriesToksMap),
/* harmony export */   tokenIdxToClass: () => (/* binding */ tokenIdxToClass),
/* harmony export */   tokenShortNameIdx: () => (/* binding */ tokenShortNameIdx),
/* harmony export */   tokenStructuredMatcher: () => (/* binding */ tokenStructuredMatcher),
/* harmony export */   tokenStructuredMatcherNoCategories: () => (/* binding */ tokenStructuredMatcherNoCategories)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/forEach.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/clone.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/compact.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/flatten.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/map.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/difference.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isEmpty.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/includes.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");

function tokenStructuredMatcher(tokInstance, tokConstructor) {
    const instanceType = tokInstance.tokenTypeIdx;
    if (instanceType === tokConstructor.tokenTypeIdx) {
        return true;
    }
    else {
        return (tokConstructor.isParent === true &&
            tokConstructor.categoryMatchesMap[instanceType] === true);
    }
}
// Optimized tokenMatcher in case our grammar does not use token categories
// Being so tiny it is much more likely to be in-lined and this avoid the function call overhead
function tokenStructuredMatcherNoCategories(token, tokType) {
    return token.tokenTypeIdx === tokType.tokenTypeIdx;
}
let tokenShortNameIdx = 1;
const tokenIdxToClass = {};
function augmentTokenTypes(tokenTypes) {
    // collect the parent Token Types as well.
    const tokenTypesAndParents = expandCategories(tokenTypes);
    // add required tokenType and categoryMatches properties
    assignTokenDefaultProps(tokenTypesAndParents);
    // fill up the categoryMatches
    assignCategoriesMapProp(tokenTypesAndParents);
    assignCategoriesTokensProp(tokenTypesAndParents);
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(tokenTypesAndParents, (tokType) => {
        tokType.isParent = tokType.categoryMatches.length > 0;
    });
}
function expandCategories(tokenTypes) {
    let result = (0,lodash_es__WEBPACK_IMPORTED_MODULE_1__["default"])(tokenTypes);
    let categories = tokenTypes;
    let searching = true;
    while (searching) {
        categories = (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(categories, (currTokType) => currTokType.CATEGORIES)));
        const newCategories = (0,lodash_es__WEBPACK_IMPORTED_MODULE_5__["default"])(categories, result);
        result = result.concat(newCategories);
        if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_6__["default"])(newCategories)) {
            searching = false;
        }
        else {
            categories = newCategories;
        }
    }
    return result;
}
function assignTokenDefaultProps(tokenTypes) {
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(tokenTypes, (currTokType) => {
        if (!hasShortKeyProperty(currTokType)) {
            tokenIdxToClass[tokenShortNameIdx] = currTokType;
            currTokType.tokenTypeIdx = tokenShortNameIdx++;
        }
        // CATEGORIES? : TokenType | TokenType[]
        if (hasCategoriesProperty(currTokType) &&
            !(0,lodash_es__WEBPACK_IMPORTED_MODULE_7__["default"])(currTokType.CATEGORIES)
        // &&
        // !isUndefined(currTokType.CATEGORIES.PATTERN)
        ) {
            currTokType.CATEGORIES = [currTokType.CATEGORIES];
        }
        if (!hasCategoriesProperty(currTokType)) {
            currTokType.CATEGORIES = [];
        }
        if (!hasExtendingTokensTypesProperty(currTokType)) {
            currTokType.categoryMatches = [];
        }
        if (!hasExtendingTokensTypesMapProperty(currTokType)) {
            currTokType.categoryMatchesMap = {};
        }
    });
}
function assignCategoriesTokensProp(tokenTypes) {
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(tokenTypes, (currTokType) => {
        // avoid duplications
        currTokType.categoryMatches = [];
        (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(currTokType.categoryMatchesMap, (val, key) => {
            currTokType.categoryMatches.push(tokenIdxToClass[key].tokenTypeIdx);
        });
    });
}
function assignCategoriesMapProp(tokenTypes) {
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(tokenTypes, (currTokType) => {
        singleAssignCategoriesToksMap([], currTokType);
    });
}
function singleAssignCategoriesToksMap(path, nextNode) {
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(path, (pathNode) => {
        nextNode.categoryMatchesMap[pathNode.tokenTypeIdx] = true;
    });
    (0,lodash_es__WEBPACK_IMPORTED_MODULE_0__["default"])(nextNode.CATEGORIES, (nextCategory) => {
        const newPath = path.concat(nextNode);
        // avoids infinite loops due to cyclic categories.
        if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_8__["default"])(newPath, nextCategory)) {
            singleAssignCategoriesToksMap(newPath, nextCategory);
        }
    });
}
function hasShortKeyProperty(tokType) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokType, "tokenTypeIdx");
}
function hasCategoriesProperty(tokType) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokType, "CATEGORIES");
}
function hasExtendingTokensTypesProperty(tokType) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokType, "categoryMatches");
}
function hasExtendingTokensTypesMapProperty(tokType) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokType, "categoryMatchesMap");
}
function isTokenType(tokType) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_9__["default"])(tokType, "tokenTypeIdx");
}
//# sourceMappingURL=tokens.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/scan/tokens_public.js":
/*!***************************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/scan/tokens_public.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EOF: () => (/* binding */ EOF),
/* harmony export */   createToken: () => (/* binding */ createToken),
/* harmony export */   createTokenInstance: () => (/* binding */ createTokenInstance),
/* harmony export */   hasTokenLabel: () => (/* binding */ hasTokenLabel),
/* harmony export */   tokenLabel: () => (/* binding */ tokenLabel),
/* harmony export */   tokenMatcher: () => (/* binding */ tokenMatcher),
/* harmony export */   tokenName: () => (/* binding */ tokenName)
/* harmony export */ });
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isString.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/isUndefined.js");
/* harmony import */ var lodash_es__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash-es */ "./node_modules/lodash-es/has.js");
/* harmony import */ var _lexer_public_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lexer_public.js */ "./node_modules/chevrotain/lib/src/scan/lexer_public.js");
/* harmony import */ var _tokens_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./tokens.js */ "./node_modules/chevrotain/lib/src/scan/tokens.js");



function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    }
    else {
        return tokType.name;
    }
}
function tokenName(tokType) {
    return tokType.name;
}
function hasTokenLabel(obj) {
    return (0,lodash_es__WEBPACK_IMPORTED_MODULE_2__["default"])(obj.LABEL) && obj.LABEL !== "";
}
const PARENT = "parent";
const CATEGORIES = "categories";
const LABEL = "label";
const GROUP = "group";
const PUSH_MODE = "push_mode";
const POP_MODE = "pop_mode";
const LONGER_ALT = "longer_alt";
const LINE_BREAKS = "line_breaks";
const START_CHARS_HINT = "start_chars_hint";
function createToken(config) {
    return createTokenInternal(config);
}
function createTokenInternal(config) {
    const pattern = config.pattern;
    const tokenType = {};
    tokenType.name = config.name;
    if (!(0,lodash_es__WEBPACK_IMPORTED_MODULE_3__["default"])(pattern)) {
        tokenType.PATTERN = pattern;
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, PARENT)) {
        throw ("The parent property is no longer supported.\n" +
            "See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.");
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, CATEGORIES)) {
        // casting to ANY as this will be fixed inside `augmentTokenTypes``
        tokenType.CATEGORIES = config[CATEGORIES];
    }
    (0,_tokens_js__WEBPACK_IMPORTED_MODULE_1__.augmentTokenTypes)([tokenType]);
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, LABEL)) {
        tokenType.LABEL = config[LABEL];
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, GROUP)) {
        tokenType.GROUP = config[GROUP];
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, POP_MODE)) {
        tokenType.POP_MODE = config[POP_MODE];
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, PUSH_MODE)) {
        tokenType.PUSH_MODE = config[PUSH_MODE];
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, LONGER_ALT)) {
        tokenType.LONGER_ALT = config[LONGER_ALT];
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, LINE_BREAKS)) {
        tokenType.LINE_BREAKS = config[LINE_BREAKS];
    }
    if ((0,lodash_es__WEBPACK_IMPORTED_MODULE_4__["default"])(config, START_CHARS_HINT)) {
        tokenType.START_CHARS_HINT = config[START_CHARS_HINT];
    }
    return tokenType;
}
const EOF = createToken({ name: "EOF", pattern: _lexer_public_js__WEBPACK_IMPORTED_MODULE_0__.Lexer.NA });
(0,_tokens_js__WEBPACK_IMPORTED_MODULE_1__.augmentTokenTypes)([EOF]);
function createTokenInstance(tokType, image, startOffset, endOffset, startLine, endLine, startColumn, endColumn) {
    return {
        image,
        startOffset,
        endOffset,
        startLine,
        endLine,
        startColumn,
        endColumn,
        tokenTypeIdx: tokType.tokenTypeIdx,
        tokenType: tokType,
    };
}
function tokenMatcher(token, tokType) {
    return (0,_tokens_js__WEBPACK_IMPORTED_MODULE_1__.tokenStructuredMatcher)(token, tokType);
}
//# sourceMappingURL=tokens_public.js.map

/***/ }),

/***/ "./node_modules/chevrotain/lib/src/version.js":
/*!****************************************************!*\
  !*** ./node_modules/chevrotain/lib/src/version.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   VERSION: () => (/* binding */ VERSION)
/* harmony export */ });
// needs a separate module as this is required inside chevrotain productive code
// and also in the entry point for webpack(api.ts).
// A separate file avoids cyclic dependencies and webpack errors.
const VERSION = "11.0.3";
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/langium/lib/default-module.js":
/*!****************************************************!*\
  !*** ./node_modules/langium/lib/default-module.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createDefaultCoreModule: () => (/* binding */ createDefaultCoreModule),
/* harmony export */   createDefaultSharedCoreModule: () => (/* binding */ createDefaultSharedCoreModule)
/* harmony export */ });
/* harmony import */ var _languages_grammar_config_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./languages/grammar-config.js */ "./node_modules/langium/lib/languages/grammar-config.js");
/* harmony import */ var _parser_completion_parser_builder_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parser/completion-parser-builder.js */ "./node_modules/langium/lib/parser/completion-parser-builder.js");
/* harmony import */ var _parser_langium_parser_builder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./parser/langium-parser-builder.js */ "./node_modules/langium/lib/parser/langium-parser-builder.js");
/* harmony import */ var _parser_token_builder_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./parser/token-builder.js */ "./node_modules/langium/lib/parser/token-builder.js");
/* harmony import */ var _parser_value_converter_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./parser/value-converter.js */ "./node_modules/langium/lib/parser/value-converter.js");
/* harmony import */ var _references_linker_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./references/linker.js */ "./node_modules/langium/lib/references/linker.js");
/* harmony import */ var _references_name_provider_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./references/name-provider.js */ "./node_modules/langium/lib/references/name-provider.js");
/* harmony import */ var _references_references_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./references/references.js */ "./node_modules/langium/lib/references/references.js");
/* harmony import */ var _references_scope_computation_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./references/scope-computation.js */ "./node_modules/langium/lib/references/scope-computation.js");
/* harmony import */ var _references_scope_provider_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./references/scope-provider.js */ "./node_modules/langium/lib/references/scope-provider.js");
/* harmony import */ var _serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./serializer/json-serializer.js */ "./node_modules/langium/lib/serializer/json-serializer.js");
/* harmony import */ var _service_registry_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./service-registry.js */ "./node_modules/langium/lib/service-registry.js");
/* harmony import */ var _validation_document_validator_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./validation/document-validator.js */ "./node_modules/langium/lib/validation/document-validator.js");
/* harmony import */ var _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./validation/validation-registry.js */ "./node_modules/langium/lib/validation/validation-registry.js");
/* harmony import */ var _workspace_ast_descriptions_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./workspace/ast-descriptions.js */ "./node_modules/langium/lib/workspace/ast-descriptions.js");
/* harmony import */ var _workspace_ast_node_locator_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./workspace/ast-node-locator.js */ "./node_modules/langium/lib/workspace/ast-node-locator.js");
/* harmony import */ var _workspace_configuration_js__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./workspace/configuration.js */ "./node_modules/langium/lib/workspace/configuration.js");
/* harmony import */ var _workspace_document_builder_js__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./workspace/document-builder.js */ "./node_modules/langium/lib/workspace/document-builder.js");
/* harmony import */ var _workspace_documents_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./workspace/documents.js */ "./node_modules/langium/lib/workspace/documents.js");
/* harmony import */ var _workspace_index_manager_js__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./workspace/index-manager.js */ "./node_modules/langium/lib/workspace/index-manager.js");
/* harmony import */ var _workspace_workspace_manager_js__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./workspace/workspace-manager.js */ "./node_modules/langium/lib/workspace/workspace-manager.js");
/* harmony import */ var _parser_lexer_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./parser/lexer.js */ "./node_modules/langium/lib/parser/lexer.js");
/* harmony import */ var _documentation_documentation_provider_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documentation/documentation-provider.js */ "./node_modules/langium/lib/documentation/documentation-provider.js");
/* harmony import */ var _documentation_comment_provider_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documentation/comment-provider.js */ "./node_modules/langium/lib/documentation/comment-provider.js");
/* harmony import */ var _parser_langium_parser_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./parser/langium-parser.js */ "./node_modules/langium/lib/parser/langium-parser.js");
/* harmony import */ var _parser_async_parser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./parser/async-parser.js */ "./node_modules/langium/lib/parser/async-parser.js");
/* harmony import */ var _workspace_workspace_lock_js__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./workspace/workspace-lock.js */ "./node_modules/langium/lib/workspace/workspace-lock.js");
/* harmony import */ var _serializer_hydrator_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./serializer/hydrator.js */ "./node_modules/langium/lib/serializer/hydrator.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
******************************************************************************/




























/**
 * Creates a dependency injection module configuring the default core services.
 * This is a set of services that are dedicated to a specific language.
 */
function createDefaultCoreModule(context) {
    return {
        documentation: {
            CommentProvider: (services) => new _documentation_comment_provider_js__WEBPACK_IMPORTED_MODULE_0__.DefaultCommentProvider(services),
            DocumentationProvider: (services) => new _documentation_documentation_provider_js__WEBPACK_IMPORTED_MODULE_1__.JSDocDocumentationProvider(services)
        },
        parser: {
            AsyncParser: (services) => new _parser_async_parser_js__WEBPACK_IMPORTED_MODULE_2__.DefaultAsyncParser(services),
            GrammarConfig: (services) => (0,_languages_grammar_config_js__WEBPACK_IMPORTED_MODULE_3__.createGrammarConfig)(services),
            LangiumParser: (services) => (0,_parser_langium_parser_builder_js__WEBPACK_IMPORTED_MODULE_4__.createLangiumParser)(services),
            CompletionParser: (services) => (0,_parser_completion_parser_builder_js__WEBPACK_IMPORTED_MODULE_5__.createCompletionParser)(services),
            ValueConverter: () => new _parser_value_converter_js__WEBPACK_IMPORTED_MODULE_6__.DefaultValueConverter(),
            TokenBuilder: () => new _parser_token_builder_js__WEBPACK_IMPORTED_MODULE_7__.DefaultTokenBuilder(),
            Lexer: (services) => new _parser_lexer_js__WEBPACK_IMPORTED_MODULE_8__.DefaultLexer(services),
            ParserErrorMessageProvider: () => new _parser_langium_parser_js__WEBPACK_IMPORTED_MODULE_9__.LangiumParserErrorMessageProvider(),
            LexerErrorMessageProvider: () => new _parser_lexer_js__WEBPACK_IMPORTED_MODULE_8__.DefaultLexerErrorMessageProvider()
        },
        workspace: {
            AstNodeLocator: () => new _workspace_ast_node_locator_js__WEBPACK_IMPORTED_MODULE_10__.DefaultAstNodeLocator(),
            AstNodeDescriptionProvider: (services) => new _workspace_ast_descriptions_js__WEBPACK_IMPORTED_MODULE_11__.DefaultAstNodeDescriptionProvider(services),
            ReferenceDescriptionProvider: (services) => new _workspace_ast_descriptions_js__WEBPACK_IMPORTED_MODULE_11__.DefaultReferenceDescriptionProvider(services)
        },
        references: {
            Linker: (services) => new _references_linker_js__WEBPACK_IMPORTED_MODULE_12__.DefaultLinker(services),
            NameProvider: () => new _references_name_provider_js__WEBPACK_IMPORTED_MODULE_13__.DefaultNameProvider(),
            ScopeProvider: (services) => new _references_scope_provider_js__WEBPACK_IMPORTED_MODULE_14__.DefaultScopeProvider(services),
            ScopeComputation: (services) => new _references_scope_computation_js__WEBPACK_IMPORTED_MODULE_15__.DefaultScopeComputation(services),
            References: (services) => new _references_references_js__WEBPACK_IMPORTED_MODULE_16__.DefaultReferences(services)
        },
        serializer: {
            Hydrator: (services) => new _serializer_hydrator_js__WEBPACK_IMPORTED_MODULE_17__.DefaultHydrator(services),
            JsonSerializer: (services) => new _serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_18__.DefaultJsonSerializer(services)
        },
        validation: {
            DocumentValidator: (services) => new _validation_document_validator_js__WEBPACK_IMPORTED_MODULE_19__.DefaultDocumentValidator(services),
            ValidationRegistry: (services) => new _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_20__.ValidationRegistry(services)
        },
        shared: () => context.shared
    };
}
/**
 * Creates a dependency injection module configuring the default shared core services.
 * This is the set of services that are shared between multiple languages.
 */
function createDefaultSharedCoreModule(context) {
    return {
        ServiceRegistry: (services) => new _service_registry_js__WEBPACK_IMPORTED_MODULE_21__.DefaultServiceRegistry(services),
        workspace: {
            LangiumDocuments: (services) => new _workspace_documents_js__WEBPACK_IMPORTED_MODULE_22__.DefaultLangiumDocuments(services),
            LangiumDocumentFactory: (services) => new _workspace_documents_js__WEBPACK_IMPORTED_MODULE_22__.DefaultLangiumDocumentFactory(services),
            DocumentBuilder: (services) => new _workspace_document_builder_js__WEBPACK_IMPORTED_MODULE_23__.DefaultDocumentBuilder(services),
            IndexManager: (services) => new _workspace_index_manager_js__WEBPACK_IMPORTED_MODULE_24__.DefaultIndexManager(services),
            WorkspaceManager: (services) => new _workspace_workspace_manager_js__WEBPACK_IMPORTED_MODULE_25__.DefaultWorkspaceManager(services),
            FileSystemProvider: (services) => context.fileSystemProvider(services),
            WorkspaceLock: () => new _workspace_workspace_lock_js__WEBPACK_IMPORTED_MODULE_26__.DefaultWorkspaceLock(),
            ConfigurationProvider: (services) => new _workspace_configuration_js__WEBPACK_IMPORTED_MODULE_27__.DefaultConfigurationProvider(services)
        }
    };
}
//# sourceMappingURL=default-module.js.map

/***/ }),

/***/ "./node_modules/langium/lib/dependency-injection.js":
/*!**********************************************************!*\
  !*** ./node_modules/langium/lib/dependency-injection.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Module: () => (/* binding */ Module),
/* harmony export */   eagerLoad: () => (/* binding */ eagerLoad),
/* harmony export */   inject: () => (/* binding */ inject)
/* harmony export */ });
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var Module;
(function (Module) {
    Module.merge = (m1, m2) => _merge(_merge({}, m1), m2);
})(Module || (Module = {}));
/**
 * Given a set of modules, the inject function returns a lazily evaluated injector
 * that injects dependencies into the requested service when it is requested the
 * first time. Subsequent requests will return the same service.
 *
 * In the case of cyclic dependencies, an Error will be thrown. This can be fixed
 * by injecting a provider `() => T` instead of a `T`.
 *
 * Please note that the arguments may be objects or arrays. However, the result will
 * be an object. Using it with for..of will have no effect.
 *
 * @param module1 first Module
 * @param module2 (optional) second Module
 * @param module3 (optional) third Module
 * @param module4 (optional) fourth Module
 * @param module5 (optional) fifth Module
 * @param module6 (optional) sixth Module
 * @param module7 (optional) seventh Module
 * @param module8 (optional) eighth Module
 * @param module9 (optional) ninth Module
 * @returns a new object of type I
 */
function inject(module1, module2, module3, module4, module5, module6, module7, module8, module9) {
    const module = [module1, module2, module3, module4, module5, module6, module7, module8, module9].reduce(_merge, {});
    return _inject(module);
}
const isProxy = Symbol('isProxy');
/**
 * Eagerly load all services in the given dependency injection container. This is sometimes
 * necessary because services can register event listeners in their constructors.
 */
function eagerLoad(item) {
    if (item && item[isProxy]) {
        for (const value of Object.values(item)) {
            eagerLoad(value);
        }
    }
    return item;
}
/**
 * Helper function that returns an injector by creating a proxy.
 * Invariant: injector is of type I. If injector is undefined, then T = I.
 */
function _inject(module, injector) {
    const proxy = new Proxy({}, {
        deleteProperty: () => false,
        set: () => {
            throw new Error('Cannot set property on injected service container');
        },
        get: (obj, prop) => {
            if (prop === isProxy) {
                return true;
            }
            else {
                return _resolve(obj, prop, module, injector || proxy);
            }
        },
        getOwnPropertyDescriptor: (obj, prop) => (_resolve(obj, prop, module, injector || proxy), Object.getOwnPropertyDescriptor(obj, prop)), // used by for..in
        has: (_, prop) => prop in module, // used by ..in..
        ownKeys: () => [...Object.getOwnPropertyNames(module)] // used by for..in
    });
    return proxy;
}
/**
 * Internally used to tag a requested dependency, directly before calling the factory.
 * This allows us to find cycles during instance creation.
 */
const __requested__ = Symbol();
/**
 * Returns the value `obj[prop]`. If the value does not exist, yet, it is resolved from
 * the module description. The result of service factories is cached. Groups are
 * recursively proxied.
 *
 * @param obj an object holding all group proxies and services
 * @param prop the key of a value within obj
 * @param module an object containing groups and service factories
 * @param injector the first level proxy that provides access to all values
 * @returns the requested value `obj[prop]`
 * @throws Error if a dependency cycle is detected
 */
function _resolve(obj, prop, module, injector) {
    if (prop in obj) {
        if (obj[prop] instanceof Error) {
            throw new Error('Construction failure. Please make sure that your dependencies are constructable.', { cause: obj[prop] });
        }
        if (obj[prop] === __requested__) {
            throw new Error('Cycle detected. Please make "' + String(prop) + '" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies');
        }
        return obj[prop];
    }
    else if (prop in module) {
        const value = module[prop];
        obj[prop] = __requested__;
        try {
            obj[prop] = (typeof value === 'function') ? value(injector) : _inject(value, injector);
        }
        catch (error) {
            obj[prop] = error instanceof Error ? error : undefined;
            throw error;
        }
        return obj[prop];
    }
    else {
        return undefined;
    }
}
/**
 * Performs a deep-merge of two modules by writing source entries into the target module.
 *
 * @param target the module which is written
 * @param source the module which is read
 * @returns the target module
 */
function _merge(target, source) {
    if (source) {
        for (const [key, value2] of Object.entries(source)) {
            if (value2 !== undefined) {
                const value1 = target[key];
                if (value1 !== null && value2 !== null && typeof value1 === 'object' && typeof value2 === 'object') {
                    target[key] = _merge(value1, value2);
                }
                else {
                    target[key] = value2;
                }
            }
        }
    }
    return target;
}
//# sourceMappingURL=dependency-injection.js.map

/***/ }),

/***/ "./node_modules/langium/lib/documentation/comment-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/langium/lib/documentation/comment-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultCommentProvider: () => (/* binding */ DefaultCommentProvider)
/* harmony export */ });
/* harmony import */ var _serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../serializer/json-serializer.js */ "./node_modules/langium/lib/serializer/json-serializer.js");
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


class DefaultCommentProvider {
    constructor(services) {
        this.grammarConfig = () => services.parser.GrammarConfig;
    }
    getComment(node) {
        var _a;
        if ((0,_serializer_json_serializer_js__WEBPACK_IMPORTED_MODULE_0__.isAstNodeWithComment)(node)) {
            return node.$comment;
        }
        return (_a = (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.findCommentNode)(node.$cstNode, this.grammarConfig().multilineCommentRules)) === null || _a === void 0 ? void 0 : _a.text;
    }
}
//# sourceMappingURL=comment-provider.js.map

/***/ }),

/***/ "./node_modules/langium/lib/documentation/documentation-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/langium/lib/documentation/documentation-provider.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   JSDocDocumentationProvider: () => (/* binding */ JSDocDocumentationProvider)
/* harmony export */ });
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _jsdoc_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./jsdoc.js */ "./node_modules/langium/lib/documentation/jsdoc.js");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


class JSDocDocumentationProvider {
    constructor(services) {
        this.indexManager = services.shared.workspace.IndexManager;
        this.commentProvider = services.documentation.CommentProvider;
    }
    getDocumentation(node) {
        const comment = this.commentProvider.getComment(node);
        if (comment && (0,_jsdoc_js__WEBPACK_IMPORTED_MODULE_0__.isJSDoc)(comment)) {
            const parsedJSDoc = (0,_jsdoc_js__WEBPACK_IMPORTED_MODULE_0__.parseJSDoc)(comment);
            return parsedJSDoc.toMarkdown({
                renderLink: (link, display) => {
                    return this.documentationLinkRenderer(node, link, display);
                },
                renderTag: (tag) => {
                    return this.documentationTagRenderer(node, tag);
                }
            });
        }
        return undefined;
    }
    documentationLinkRenderer(node, name, display) {
        var _a;
        const description = (_a = this.findNameInPrecomputedScopes(node, name)) !== null && _a !== void 0 ? _a : this.findNameInGlobalScope(node, name);
        if (description && description.nameSegment) {
            const line = description.nameSegment.range.start.line + 1;
            const character = description.nameSegment.range.start.character + 1;
            const uri = description.documentUri.with({ fragment: `L${line},${character}` });
            return `[${display}](${uri.toString()})`;
        }
        else {
            return undefined;
        }
    }
    documentationTagRenderer(_node, _tag) {
        // Fall back to the default tag rendering
        return undefined;
    }
    findNameInPrecomputedScopes(node, name) {
        const document = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)(node);
        const precomputed = document.precomputedScopes;
        if (!precomputed) {
            return undefined;
        }
        let currentNode = node;
        do {
            const allDescriptions = precomputed.get(currentNode);
            const description = allDescriptions.find(e => e.name === name);
            if (description) {
                return description;
            }
            currentNode = currentNode.$container;
        } while (currentNode);
        return undefined;
    }
    findNameInGlobalScope(node, name) {
        const description = this.indexManager.allElements().find(e => e.name === name);
        return description;
    }
}
//# sourceMappingURL=documentation-provider.js.map

/***/ }),

/***/ "./node_modules/langium/lib/documentation/jsdoc.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/documentation/jsdoc.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   isJSDoc: () => (/* binding */ isJSDoc),
/* harmony export */   parseJSDoc: () => (/* binding */ parseJSDoc)
/* harmony export */ });
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js");
/* harmony import */ var _utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/regexp-utils.js */ "./node_modules/langium/lib/utils/regexp-utils.js");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/vscode-uri/lib/esm/index.mjs");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/



function parseJSDoc(node, start, options) {
    let opts;
    let position;
    if (typeof node === 'string') {
        position = start;
        opts = options;
    }
    else {
        position = node.range.start;
        opts = start;
    }
    if (!position) {
        position = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(0, 0);
    }
    const lines = getLines(node);
    const normalizedOptions = normalizeOptions(opts);
    const tokens = tokenize({
        lines,
        position,
        options: normalizedOptions
    });
    return parseJSDocComment({
        index: 0,
        tokens,
        position
    });
}
function isJSDoc(node, options) {
    const normalizedOptions = normalizeOptions(options);
    const lines = getLines(node);
    if (lines.length === 0) {
        return false;
    }
    const first = lines[0];
    const last = lines[lines.length - 1];
    const firstRegex = normalizedOptions.start;
    const lastRegex = normalizedOptions.end;
    return Boolean(firstRegex === null || firstRegex === void 0 ? void 0 : firstRegex.exec(first)) && Boolean(lastRegex === null || lastRegex === void 0 ? void 0 : lastRegex.exec(last));
}
function getLines(node) {
    let content = '';
    if (typeof node === 'string') {
        content = node;
    }
    else {
        content = node.text;
    }
    const lines = content.split(_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_1__.NEWLINE_REGEXP);
    return lines;
}
const tagRegex = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy;
const inlineTagRegex = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu;
function tokenize(context) {
    var _a, _b, _c;
    const tokens = [];
    let currentLine = context.position.line;
    let currentCharacter = context.position.character;
    for (let i = 0; i < context.lines.length; i++) {
        const first = i === 0;
        const last = i === context.lines.length - 1;
        let line = context.lines[i];
        let index = 0;
        if (first && context.options.start) {
            const match = (_a = context.options.start) === null || _a === void 0 ? void 0 : _a.exec(line);
            if (match) {
                index = match.index + match[0].length;
            }
        }
        else {
            const match = (_b = context.options.line) === null || _b === void 0 ? void 0 : _b.exec(line);
            if (match) {
                index = match.index + match[0].length;
            }
        }
        if (last) {
            const match = (_c = context.options.end) === null || _c === void 0 ? void 0 : _c.exec(line);
            if (match) {
                line = line.substring(0, match.index);
            }
        }
        line = line.substring(0, lastCharacter(line));
        const whitespaceEnd = skipWhitespace(line, index);
        if (whitespaceEnd >= line.length) {
            // Only create a break token when we already have previous tokens
            if (tokens.length > 0) {
                const position = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(currentLine, currentCharacter);
                tokens.push({
                    type: 'break',
                    content: '',
                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(position, position)
                });
            }
        }
        else {
            tagRegex.lastIndex = index;
            const tagMatch = tagRegex.exec(line);
            if (tagMatch) {
                const fullMatch = tagMatch[0];
                const value = tagMatch[1];
                const start = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(currentLine, currentCharacter + index);
                const end = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(currentLine, currentCharacter + index + fullMatch.length);
                tokens.push({
                    type: 'tag',
                    content: value,
                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(start, end)
                });
                index += fullMatch.length;
                index = skipWhitespace(line, index);
            }
            if (index < line.length) {
                const rest = line.substring(index);
                const inlineTagMatches = Array.from(rest.matchAll(inlineTagRegex));
                tokens.push(...buildInlineTokens(inlineTagMatches, rest, currentLine, currentCharacter + index));
            }
        }
        currentLine++;
        currentCharacter = 0;
    }
    // Remove last break token if there is one
    if (tokens.length > 0 && tokens[tokens.length - 1].type === 'break') {
        return tokens.slice(0, -1);
    }
    return tokens;
}
function buildInlineTokens(tags, line, lineIndex, characterIndex) {
    const tokens = [];
    if (tags.length === 0) {
        const start = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, characterIndex);
        const end = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, characterIndex + line.length);
        tokens.push({
            type: 'text',
            content: line,
            range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(start, end)
        });
    }
    else {
        let lastIndex = 0;
        for (const match of tags) {
            const matchIndex = match.index;
            const startContent = line.substring(lastIndex, matchIndex);
            if (startContent.length > 0) {
                tokens.push({
                    type: 'text',
                    content: line.substring(lastIndex, matchIndex),
                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, matchIndex + characterIndex))
                });
            }
            let offset = startContent.length + 1;
            const tagName = match[1];
            tokens.push({
                type: 'inline-tag',
                content: tagName,
                range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + tagName.length + characterIndex))
            });
            offset += tagName.length;
            if (match.length === 4) {
                offset += match[2].length;
                const value = match[3];
                tokens.push({
                    type: 'text',
                    content: value,
                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + value.length + characterIndex))
                });
            }
            else {
                tokens.push({
                    type: 'text',
                    content: '',
                    range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + offset + characterIndex))
                });
            }
            lastIndex = matchIndex + match[0].length;
        }
        const endContent = line.substring(lastIndex);
        if (endContent.length > 0) {
            tokens.push({
                type: 'text',
                content: endContent,
                range: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + characterIndex), vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(lineIndex, lastIndex + characterIndex + endContent.length))
            });
        }
    }
    return tokens;
}
const nonWhitespaceRegex = /\S/;
const whitespaceEndRegex = /\s*$/;
function skipWhitespace(line, index) {
    const match = line.substring(index).match(nonWhitespaceRegex);
    if (match) {
        return index + match.index;
    }
    else {
        return line.length;
    }
}
function lastCharacter(line) {
    const match = line.match(whitespaceEndRegex);
    if (match && typeof match.index === 'number') {
        return match.index;
    }
    return undefined;
}
// Parsing
function parseJSDocComment(context) {
    var _a, _b, _c, _d;
    const startPosition = vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(context.position.line, context.position.character);
    if (context.tokens.length === 0) {
        return new JSDocCommentImpl([], vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(startPosition, startPosition));
    }
    const elements = [];
    while (context.index < context.tokens.length) {
        const element = parseJSDocElement(context, elements[elements.length - 1]);
        if (element) {
            elements.push(element);
        }
    }
    const start = (_b = (_a = elements[0]) === null || _a === void 0 ? void 0 : _a.range.start) !== null && _b !== void 0 ? _b : startPosition;
    const end = (_d = (_c = elements[elements.length - 1]) === null || _c === void 0 ? void 0 : _c.range.end) !== null && _d !== void 0 ? _d : startPosition;
    return new JSDocCommentImpl(elements, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(start, end));
}
function parseJSDocElement(context, last) {
    const next = context.tokens[context.index];
    if (next.type === 'tag') {
        return parseJSDocTag(context, false);
    }
    else if (next.type === 'text' || next.type === 'inline-tag') {
        return parseJSDocText(context);
    }
    else {
        appendEmptyLine(next, last);
        context.index++;
        return undefined;
    }
}
function appendEmptyLine(token, element) {
    if (element) {
        const line = new JSDocLineImpl('', token.range);
        if ('inlines' in element) {
            element.inlines.push(line);
        }
        else {
            element.content.inlines.push(line);
        }
    }
}
function parseJSDocText(context) {
    let token = context.tokens[context.index];
    const firstToken = token;
    let lastToken = token;
    const lines = [];
    while (token && token.type !== 'break' && token.type !== 'tag') {
        lines.push(parseJSDocInline(context));
        lastToken = token;
        token = context.tokens[context.index];
    }
    return new JSDocTextImpl(lines, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(firstToken.range.start, lastToken.range.end));
}
function parseJSDocInline(context) {
    const token = context.tokens[context.index];
    if (token.type === 'inline-tag') {
        return parseJSDocTag(context, true);
    }
    else {
        return parseJSDocLine(context);
    }
}
function parseJSDocTag(context, inline) {
    const tagToken = context.tokens[context.index++];
    const name = tagToken.content.substring(1);
    const nextToken = context.tokens[context.index];
    if ((nextToken === null || nextToken === void 0 ? void 0 : nextToken.type) === 'text') {
        if (inline) {
            const docLine = parseJSDocLine(context);
            return new JSDocTagImpl(name, new JSDocTextImpl([docLine], docLine.range), inline, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(tagToken.range.start, docLine.range.end));
        }
        else {
            const textDoc = parseJSDocText(context);
            return new JSDocTagImpl(name, textDoc, inline, vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Range.create(tagToken.range.start, textDoc.range.end));
        }
    }
    else {
        const range = tagToken.range;
        return new JSDocTagImpl(name, new JSDocTextImpl([], range), inline, range);
    }
}
function parseJSDocLine(context) {
    const token = context.tokens[context.index++];
    return new JSDocLineImpl(token.content, token.range);
}
function normalizeOptions(options) {
    if (!options) {
        return normalizeOptions({
            start: '/**',
            end: '*/',
            line: '*'
        });
    }
    const { start, end, line } = options;
    return {
        start: normalizeOption(start, true),
        end: normalizeOption(end, false),
        line: normalizeOption(line, true)
    };
}
function normalizeOption(option, start) {
    if (typeof option === 'string' || typeof option === 'object') {
        const escaped = typeof option === 'string' ? (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_1__.escapeRegExp)(option) : option.source;
        if (start) {
            return new RegExp(`^\\s*${escaped}`);
        }
        else {
            return new RegExp(`\\s*${escaped}\\s*$`);
        }
    }
    else {
        return option;
    }
}
class JSDocCommentImpl {
    constructor(elements, range) {
        this.elements = elements;
        this.range = range;
    }
    getTag(name) {
        return this.getAllTags().find(e => e.name === name);
    }
    getTags(name) {
        return this.getAllTags().filter(e => e.name === name);
    }
    getAllTags() {
        return this.elements.filter((e) => 'name' in e);
    }
    toString() {
        let value = '';
        for (const element of this.elements) {
            if (value.length === 0) {
                value = element.toString();
            }
            else {
                const text = element.toString();
                value += fillNewlines(value) + text;
            }
        }
        return value.trim();
    }
    toMarkdown(options) {
        let value = '';
        for (const element of this.elements) {
            if (value.length === 0) {
                value = element.toMarkdown(options);
            }
            else {
                const text = element.toMarkdown(options);
                value += fillNewlines(value) + text;
            }
        }
        return value.trim();
    }
}
class JSDocTagImpl {
    constructor(name, content, inline, range) {
        this.name = name;
        this.content = content;
        this.inline = inline;
        this.range = range;
    }
    toString() {
        let text = `@${this.name}`;
        const content = this.content.toString();
        if (this.content.inlines.length === 1) {
            text = `${text} ${content}`;
        }
        else if (this.content.inlines.length > 1) {
            text = `${text}\n${content}`;
        }
        if (this.inline) {
            // Inline tags are surrounded by curly braces
            return `{${text}}`;
        }
        else {
            return text;
        }
    }
    toMarkdown(options) {
        var _a, _b;
        return (_b = (_a = options === null || options === void 0 ? void 0 : options.renderTag) === null || _a === void 0 ? void 0 : _a.call(options, this)) !== null && _b !== void 0 ? _b : this.toMarkdownDefault(options);
    }
    toMarkdownDefault(options) {
        const content = this.content.toMarkdown(options);
        if (this.inline) {
            const rendered = renderInlineTag(this.name, content, options !== null && options !== void 0 ? options : {});
            if (typeof rendered === 'string') {
                return rendered;
            }
        }
        let marker = '';
        if ((options === null || options === void 0 ? void 0 : options.tag) === 'italic' || (options === null || options === void 0 ? void 0 : options.tag) === undefined) {
            marker = '*';
        }
        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold') {
            marker = '**';
        }
        else if ((options === null || options === void 0 ? void 0 : options.tag) === 'bold-italic') {
            marker = '***';
        }
        let text = `${marker}@${this.name}${marker}`;
        if (this.content.inlines.length === 1) {
            text = `${text}  ${content}`;
        }
        else if (this.content.inlines.length > 1) {
            text = `${text}\n${content}`;
        }
        if (this.inline) {
            // Inline tags are surrounded by curly braces
            return `{${text}}`;
        }
        else {
            return text;
        }
    }
}
function renderInlineTag(tag, content, options) {
    var _a, _b;
    if (tag === 'linkplain' || tag === 'linkcode' || tag === 'link') {
        const index = content.indexOf(' ');
        let display = content;
        if (index > 0) {
            const displayStart = skipWhitespace(content, index);
            display = content.substring(displayStart);
            content = content.substring(0, index);
        }
        if (tag === 'linkcode' || (tag === 'link' && options.link === 'code')) {
            // Surround the display value in a markdown inline code block
            display = `\`${display}\``;
        }
        const renderedLink = (_b = (_a = options.renderLink) === null || _a === void 0 ? void 0 : _a.call(options, content, display)) !== null && _b !== void 0 ? _b : renderLinkDefault(content, display);
        return renderedLink;
    }
    return undefined;
}
function renderLinkDefault(content, display) {
    try {
        _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(content, true);
        return `[${display}](${content})`;
    }
    catch (_a) {
        return content;
    }
}
class JSDocTextImpl {
    constructor(lines, range) {
        this.inlines = lines;
        this.range = range;
    }
    toString() {
        let text = '';
        for (let i = 0; i < this.inlines.length; i++) {
            const inline = this.inlines[i];
            const next = this.inlines[i + 1];
            text += inline.toString();
            if (next && next.range.start.line > inline.range.start.line) {
                text += '\n';
            }
        }
        return text;
    }
    toMarkdown(options) {
        let text = '';
        for (let i = 0; i < this.inlines.length; i++) {
            const inline = this.inlines[i];
            const next = this.inlines[i + 1];
            text += inline.toMarkdown(options);
            if (next && next.range.start.line > inline.range.start.line) {
                text += '\n';
            }
        }
        return text;
    }
}
class JSDocLineImpl {
    constructor(text, range) {
        this.text = text;
        this.range = range;
    }
    toString() {
        return this.text;
    }
    toMarkdown() {
        return this.text;
    }
}
function fillNewlines(text) {
    if (text.endsWith('\n')) {
        return '\n';
    }
    else {
        return '\n\n';
    }
}
//# sourceMappingURL=jsdoc.js.map

/***/ }),

/***/ "./node_modules/langium/lib/languages/generated/ast.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/languages/generated/ast.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractElement: () => (/* binding */ AbstractElement),
/* harmony export */   AbstractRule: () => (/* binding */ AbstractRule),
/* harmony export */   AbstractType: () => (/* binding */ AbstractType),
/* harmony export */   Action: () => (/* binding */ Action),
/* harmony export */   Alternatives: () => (/* binding */ Alternatives),
/* harmony export */   ArrayLiteral: () => (/* binding */ ArrayLiteral),
/* harmony export */   ArrayType: () => (/* binding */ ArrayType),
/* harmony export */   Assignment: () => (/* binding */ Assignment),
/* harmony export */   BooleanLiteral: () => (/* binding */ BooleanLiteral),
/* harmony export */   CharacterRange: () => (/* binding */ CharacterRange),
/* harmony export */   Condition: () => (/* binding */ Condition),
/* harmony export */   Conjunction: () => (/* binding */ Conjunction),
/* harmony export */   CrossReference: () => (/* binding */ CrossReference),
/* harmony export */   Disjunction: () => (/* binding */ Disjunction),
/* harmony export */   EndOfFile: () => (/* binding */ EndOfFile),
/* harmony export */   Grammar: () => (/* binding */ Grammar),
/* harmony export */   GrammarImport: () => (/* binding */ GrammarImport),
/* harmony export */   Group: () => (/* binding */ Group),
/* harmony export */   InferredType: () => (/* binding */ InferredType),
/* harmony export */   Interface: () => (/* binding */ Interface),
/* harmony export */   Keyword: () => (/* binding */ Keyword),
/* harmony export */   LangiumGrammarAstReflection: () => (/* binding */ LangiumGrammarAstReflection),
/* harmony export */   LangiumGrammarTerminals: () => (/* binding */ LangiumGrammarTerminals),
/* harmony export */   NamedArgument: () => (/* binding */ NamedArgument),
/* harmony export */   NegatedToken: () => (/* binding */ NegatedToken),
/* harmony export */   Negation: () => (/* binding */ Negation),
/* harmony export */   NumberLiteral: () => (/* binding */ NumberLiteral),
/* harmony export */   Parameter: () => (/* binding */ Parameter),
/* harmony export */   ParameterReference: () => (/* binding */ ParameterReference),
/* harmony export */   ParserRule: () => (/* binding */ ParserRule),
/* harmony export */   ReferenceType: () => (/* binding */ ReferenceType),
/* harmony export */   RegexToken: () => (/* binding */ RegexToken),
/* harmony export */   ReturnType: () => (/* binding */ ReturnType),
/* harmony export */   RuleCall: () => (/* binding */ RuleCall),
/* harmony export */   SimpleType: () => (/* binding */ SimpleType),
/* harmony export */   StringLiteral: () => (/* binding */ StringLiteral),
/* harmony export */   TerminalAlternatives: () => (/* binding */ TerminalAlternatives),
/* harmony export */   TerminalGroup: () => (/* binding */ TerminalGroup),
/* harmony export */   TerminalRule: () => (/* binding */ TerminalRule),
/* harmony export */   TerminalRuleCall: () => (/* binding */ TerminalRuleCall),
/* harmony export */   Type: () => (/* binding */ Type),
/* harmony export */   TypeAttribute: () => (/* binding */ TypeAttribute),
/* harmony export */   TypeDefinition: () => (/* binding */ TypeDefinition),
/* harmony export */   UnionType: () => (/* binding */ UnionType),
/* harmony export */   UnorderedGroup: () => (/* binding */ UnorderedGroup),
/* harmony export */   UntilToken: () => (/* binding */ UntilToken),
/* harmony export */   ValueLiteral: () => (/* binding */ ValueLiteral),
/* harmony export */   Wildcard: () => (/* binding */ Wildcard),
/* harmony export */   isAbstractElement: () => (/* binding */ isAbstractElement),
/* harmony export */   isAbstractRule: () => (/* binding */ isAbstractRule),
/* harmony export */   isAbstractType: () => (/* binding */ isAbstractType),
/* harmony export */   isAction: () => (/* binding */ isAction),
/* harmony export */   isAlternatives: () => (/* binding */ isAlternatives),
/* harmony export */   isArrayLiteral: () => (/* binding */ isArrayLiteral),
/* harmony export */   isArrayType: () => (/* binding */ isArrayType),
/* harmony export */   isAssignment: () => (/* binding */ isAssignment),
/* harmony export */   isBooleanLiteral: () => (/* binding */ isBooleanLiteral),
/* harmony export */   isCharacterRange: () => (/* binding */ isCharacterRange),
/* harmony export */   isCondition: () => (/* binding */ isCondition),
/* harmony export */   isConjunction: () => (/* binding */ isConjunction),
/* harmony export */   isCrossReference: () => (/* binding */ isCrossReference),
/* harmony export */   isDisjunction: () => (/* binding */ isDisjunction),
/* harmony export */   isEndOfFile: () => (/* binding */ isEndOfFile),
/* harmony export */   isFeatureName: () => (/* binding */ isFeatureName),
/* harmony export */   isGrammar: () => (/* binding */ isGrammar),
/* harmony export */   isGrammarImport: () => (/* binding */ isGrammarImport),
/* harmony export */   isGroup: () => (/* binding */ isGroup),
/* harmony export */   isInferredType: () => (/* binding */ isInferredType),
/* harmony export */   isInterface: () => (/* binding */ isInterface),
/* harmony export */   isKeyword: () => (/* binding */ isKeyword),
/* harmony export */   isNamedArgument: () => (/* binding */ isNamedArgument),
/* harmony export */   isNegatedToken: () => (/* binding */ isNegatedToken),
/* harmony export */   isNegation: () => (/* binding */ isNegation),
/* harmony export */   isNumberLiteral: () => (/* binding */ isNumberLiteral),
/* harmony export */   isParameter: () => (/* binding */ isParameter),
/* harmony export */   isParameterReference: () => (/* binding */ isParameterReference),
/* harmony export */   isParserRule: () => (/* binding */ isParserRule),
/* harmony export */   isPrimitiveType: () => (/* binding */ isPrimitiveType),
/* harmony export */   isReferenceType: () => (/* binding */ isReferenceType),
/* harmony export */   isRegexToken: () => (/* binding */ isRegexToken),
/* harmony export */   isReturnType: () => (/* binding */ isReturnType),
/* harmony export */   isRuleCall: () => (/* binding */ isRuleCall),
/* harmony export */   isSimpleType: () => (/* binding */ isSimpleType),
/* harmony export */   isStringLiteral: () => (/* binding */ isStringLiteral),
/* harmony export */   isTerminalAlternatives: () => (/* binding */ isTerminalAlternatives),
/* harmony export */   isTerminalGroup: () => (/* binding */ isTerminalGroup),
/* harmony export */   isTerminalRule: () => (/* binding */ isTerminalRule),
/* harmony export */   isTerminalRuleCall: () => (/* binding */ isTerminalRuleCall),
/* harmony export */   isType: () => (/* binding */ isType),
/* harmony export */   isTypeAttribute: () => (/* binding */ isTypeAttribute),
/* harmony export */   isTypeDefinition: () => (/* binding */ isTypeDefinition),
/* harmony export */   isUnionType: () => (/* binding */ isUnionType),
/* harmony export */   isUnorderedGroup: () => (/* binding */ isUnorderedGroup),
/* harmony export */   isUntilToken: () => (/* binding */ isUntilToken),
/* harmony export */   isValueLiteral: () => (/* binding */ isValueLiteral),
/* harmony export */   isWildcard: () => (/* binding */ isWildcard),
/* harmony export */   reflection: () => (/* binding */ reflection)
/* harmony export */ });
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/******************************************************************************
 * This file was generated by langium-cli 3.3.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

const LangiumGrammarTerminals = {
    ID: /\^?[_a-zA-Z][\w_]*/,
    STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
    NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
    RegexLiteral: /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
    WS: /\s+/,
    ML_COMMENT: /\/\*[\s\S]*?\*\//,
    SL_COMMENT: /\/\/[^\n\r]*/,
};
const AbstractRule = 'AbstractRule';
function isAbstractRule(item) {
    return reflection.isInstance(item, AbstractRule);
}
const AbstractType = 'AbstractType';
function isAbstractType(item) {
    return reflection.isInstance(item, AbstractType);
}
const Condition = 'Condition';
function isCondition(item) {
    return reflection.isInstance(item, Condition);
}
function isFeatureName(item) {
    return isPrimitiveType(item) || item === 'current' || item === 'entry' || item === 'extends' || item === 'false' || item === 'fragment' || item === 'grammar' || item === 'hidden' || item === 'import' || item === 'interface' || item === 'returns' || item === 'terminal' || item === 'true' || item === 'type' || item === 'infer' || item === 'infers' || item === 'with' || (typeof item === 'string' && (/\^?[_a-zA-Z][\w_]*/.test(item)));
}
function isPrimitiveType(item) {
    return item === 'string' || item === 'number' || item === 'boolean' || item === 'Date' || item === 'bigint';
}
const TypeDefinition = 'TypeDefinition';
function isTypeDefinition(item) {
    return reflection.isInstance(item, TypeDefinition);
}
const ValueLiteral = 'ValueLiteral';
function isValueLiteral(item) {
    return reflection.isInstance(item, ValueLiteral);
}
const AbstractElement = 'AbstractElement';
function isAbstractElement(item) {
    return reflection.isInstance(item, AbstractElement);
}
const ArrayLiteral = 'ArrayLiteral';
function isArrayLiteral(item) {
    return reflection.isInstance(item, ArrayLiteral);
}
const ArrayType = 'ArrayType';
function isArrayType(item) {
    return reflection.isInstance(item, ArrayType);
}
const BooleanLiteral = 'BooleanLiteral';
function isBooleanLiteral(item) {
    return reflection.isInstance(item, BooleanLiteral);
}
const Conjunction = 'Conjunction';
function isConjunction(item) {
    return reflection.isInstance(item, Conjunction);
}
const Disjunction = 'Disjunction';
function isDisjunction(item) {
    return reflection.isInstance(item, Disjunction);
}
const Grammar = 'Grammar';
function isGrammar(item) {
    return reflection.isInstance(item, Grammar);
}
const GrammarImport = 'GrammarImport';
function isGrammarImport(item) {
    return reflection.isInstance(item, GrammarImport);
}
const InferredType = 'InferredType';
function isInferredType(item) {
    return reflection.isInstance(item, InferredType);
}
const Interface = 'Interface';
function isInterface(item) {
    return reflection.isInstance(item, Interface);
}
const NamedArgument = 'NamedArgument';
function isNamedArgument(item) {
    return reflection.isInstance(item, NamedArgument);
}
const Negation = 'Negation';
function isNegation(item) {
    return reflection.isInstance(item, Negation);
}
const NumberLiteral = 'NumberLiteral';
function isNumberLiteral(item) {
    return reflection.isInstance(item, NumberLiteral);
}
const Parameter = 'Parameter';
function isParameter(item) {
    return reflection.isInstance(item, Parameter);
}
const ParameterReference = 'ParameterReference';
function isParameterReference(item) {
    return reflection.isInstance(item, ParameterReference);
}
const ParserRule = 'ParserRule';
function isParserRule(item) {
    return reflection.isInstance(item, ParserRule);
}
const ReferenceType = 'ReferenceType';
function isReferenceType(item) {
    return reflection.isInstance(item, ReferenceType);
}
const ReturnType = 'ReturnType';
function isReturnType(item) {
    return reflection.isInstance(item, ReturnType);
}
const SimpleType = 'SimpleType';
function isSimpleType(item) {
    return reflection.isInstance(item, SimpleType);
}
const StringLiteral = 'StringLiteral';
function isStringLiteral(item) {
    return reflection.isInstance(item, StringLiteral);
}
const TerminalRule = 'TerminalRule';
function isTerminalRule(item) {
    return reflection.isInstance(item, TerminalRule);
}
const Type = 'Type';
function isType(item) {
    return reflection.isInstance(item, Type);
}
const TypeAttribute = 'TypeAttribute';
function isTypeAttribute(item) {
    return reflection.isInstance(item, TypeAttribute);
}
const UnionType = 'UnionType';
function isUnionType(item) {
    return reflection.isInstance(item, UnionType);
}
const Action = 'Action';
function isAction(item) {
    return reflection.isInstance(item, Action);
}
const Alternatives = 'Alternatives';
function isAlternatives(item) {
    return reflection.isInstance(item, Alternatives);
}
const Assignment = 'Assignment';
function isAssignment(item) {
    return reflection.isInstance(item, Assignment);
}
const CharacterRange = 'CharacterRange';
function isCharacterRange(item) {
    return reflection.isInstance(item, CharacterRange);
}
const CrossReference = 'CrossReference';
function isCrossReference(item) {
    return reflection.isInstance(item, CrossReference);
}
const EndOfFile = 'EndOfFile';
function isEndOfFile(item) {
    return reflection.isInstance(item, EndOfFile);
}
const Group = 'Group';
function isGroup(item) {
    return reflection.isInstance(item, Group);
}
const Keyword = 'Keyword';
function isKeyword(item) {
    return reflection.isInstance(item, Keyword);
}
const NegatedToken = 'NegatedToken';
function isNegatedToken(item) {
    return reflection.isInstance(item, NegatedToken);
}
const RegexToken = 'RegexToken';
function isRegexToken(item) {
    return reflection.isInstance(item, RegexToken);
}
const RuleCall = 'RuleCall';
function isRuleCall(item) {
    return reflection.isInstance(item, RuleCall);
}
const TerminalAlternatives = 'TerminalAlternatives';
function isTerminalAlternatives(item) {
    return reflection.isInstance(item, TerminalAlternatives);
}
const TerminalGroup = 'TerminalGroup';
function isTerminalGroup(item) {
    return reflection.isInstance(item, TerminalGroup);
}
const TerminalRuleCall = 'TerminalRuleCall';
function isTerminalRuleCall(item) {
    return reflection.isInstance(item, TerminalRuleCall);
}
const UnorderedGroup = 'UnorderedGroup';
function isUnorderedGroup(item) {
    return reflection.isInstance(item, UnorderedGroup);
}
const UntilToken = 'UntilToken';
function isUntilToken(item) {
    return reflection.isInstance(item, UntilToken);
}
const Wildcard = 'Wildcard';
function isWildcard(item) {
    return reflection.isInstance(item, Wildcard);
}
class LangiumGrammarAstReflection extends _syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.AbstractAstReflection {
    getAllTypes() {
        return [AbstractElement, AbstractRule, AbstractType, Action, Alternatives, ArrayLiteral, ArrayType, Assignment, BooleanLiteral, CharacterRange, Condition, Conjunction, CrossReference, Disjunction, EndOfFile, Grammar, GrammarImport, Group, InferredType, Interface, Keyword, NamedArgument, NegatedToken, Negation, NumberLiteral, Parameter, ParameterReference, ParserRule, ReferenceType, RegexToken, ReturnType, RuleCall, SimpleType, StringLiteral, TerminalAlternatives, TerminalGroup, TerminalRule, TerminalRuleCall, Type, TypeAttribute, TypeDefinition, UnionType, UnorderedGroup, UntilToken, ValueLiteral, Wildcard];
    }
    computeIsSubtype(subtype, supertype) {
        switch (subtype) {
            case Action:
            case Alternatives:
            case Assignment:
            case CharacterRange:
            case CrossReference:
            case EndOfFile:
            case Group:
            case Keyword:
            case NegatedToken:
            case RegexToken:
            case RuleCall:
            case TerminalAlternatives:
            case TerminalGroup:
            case TerminalRuleCall:
            case UnorderedGroup:
            case UntilToken:
            case Wildcard: {
                return this.isSubtype(AbstractElement, supertype);
            }
            case ArrayLiteral:
            case NumberLiteral:
            case StringLiteral: {
                return this.isSubtype(ValueLiteral, supertype);
            }
            case ArrayType:
            case ReferenceType:
            case SimpleType:
            case UnionType: {
                return this.isSubtype(TypeDefinition, supertype);
            }
            case BooleanLiteral: {
                return this.isSubtype(Condition, supertype) || this.isSubtype(ValueLiteral, supertype);
            }
            case Conjunction:
            case Disjunction:
            case Negation:
            case ParameterReference: {
                return this.isSubtype(Condition, supertype);
            }
            case InferredType:
            case Interface:
            case Type: {
                return this.isSubtype(AbstractType, supertype);
            }
            case ParserRule: {
                return this.isSubtype(AbstractRule, supertype) || this.isSubtype(AbstractType, supertype);
            }
            case TerminalRule: {
                return this.isSubtype(AbstractRule, supertype);
            }
            default: {
                return false;
            }
        }
    }
    getReferenceType(refInfo) {
        const referenceId = `${refInfo.container.$type}:${refInfo.property}`;
        switch (referenceId) {
            case 'Action:type':
            case 'CrossReference:type':
            case 'Interface:superTypes':
            case 'ParserRule:returnType':
            case 'SimpleType:typeRef': {
                return AbstractType;
            }
            case 'Grammar:hiddenTokens':
            case 'ParserRule:hiddenTokens':
            case 'RuleCall:rule': {
                return AbstractRule;
            }
            case 'Grammar:usedGrammars': {
                return Grammar;
            }
            case 'NamedArgument:parameter':
            case 'ParameterReference:parameter': {
                return Parameter;
            }
            case 'TerminalRuleCall:rule': {
                return TerminalRule;
            }
            default: {
                throw new Error(`${referenceId} is not a valid reference id.`);
            }
        }
    }
    getTypeMetaData(type) {
        switch (type) {
            case AbstractElement: {
                return {
                    name: AbstractElement,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' }
                    ]
                };
            }
            case ArrayLiteral: {
                return {
                    name: ArrayLiteral,
                    properties: [
                        { name: 'elements', defaultValue: [] }
                    ]
                };
            }
            case ArrayType: {
                return {
                    name: ArrayType,
                    properties: [
                        { name: 'elementType' }
                    ]
                };
            }
            case BooleanLiteral: {
                return {
                    name: BooleanLiteral,
                    properties: [
                        { name: 'true', defaultValue: false }
                    ]
                };
            }
            case Conjunction: {
                return {
                    name: Conjunction,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case Disjunction: {
                return {
                    name: Disjunction,
                    properties: [
                        { name: 'left' },
                        { name: 'right' }
                    ]
                };
            }
            case Grammar: {
                return {
                    name: Grammar,
                    properties: [
                        { name: 'definesHiddenTokens', defaultValue: false },
                        { name: 'hiddenTokens', defaultValue: [] },
                        { name: 'imports', defaultValue: [] },
                        { name: 'interfaces', defaultValue: [] },
                        { name: 'isDeclared', defaultValue: false },
                        { name: 'name' },
                        { name: 'rules', defaultValue: [] },
                        { name: 'types', defaultValue: [] },
                        { name: 'usedGrammars', defaultValue: [] }
                    ]
                };
            }
            case GrammarImport: {
                return {
                    name: GrammarImport,
                    properties: [
                        { name: 'path' }
                    ]
                };
            }
            case InferredType: {
                return {
                    name: InferredType,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case Interface: {
                return {
                    name: Interface,
                    properties: [
                        { name: 'attributes', defaultValue: [] },
                        { name: 'name' },
                        { name: 'superTypes', defaultValue: [] }
                    ]
                };
            }
            case NamedArgument: {
                return {
                    name: NamedArgument,
                    properties: [
                        { name: 'calledByName', defaultValue: false },
                        { name: 'parameter' },
                        { name: 'value' }
                    ]
                };
            }
            case Negation: {
                return {
                    name: Negation,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case NumberLiteral: {
                return {
                    name: NumberLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case Parameter: {
                return {
                    name: Parameter,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case ParameterReference: {
                return {
                    name: ParameterReference,
                    properties: [
                        { name: 'parameter' }
                    ]
                };
            }
            case ParserRule: {
                return {
                    name: ParserRule,
                    properties: [
                        { name: 'dataType' },
                        { name: 'definesHiddenTokens', defaultValue: false },
                        { name: 'definition' },
                        { name: 'entry', defaultValue: false },
                        { name: 'fragment', defaultValue: false },
                        { name: 'hiddenTokens', defaultValue: [] },
                        { name: 'inferredType' },
                        { name: 'name' },
                        { name: 'parameters', defaultValue: [] },
                        { name: 'returnType' },
                        { name: 'wildcard', defaultValue: false }
                    ]
                };
            }
            case ReferenceType: {
                return {
                    name: ReferenceType,
                    properties: [
                        { name: 'referenceType' }
                    ]
                };
            }
            case ReturnType: {
                return {
                    name: ReturnType,
                    properties: [
                        { name: 'name' }
                    ]
                };
            }
            case SimpleType: {
                return {
                    name: SimpleType,
                    properties: [
                        { name: 'primitiveType' },
                        { name: 'stringType' },
                        { name: 'typeRef' }
                    ]
                };
            }
            case StringLiteral: {
                return {
                    name: StringLiteral,
                    properties: [
                        { name: 'value' }
                    ]
                };
            }
            case TerminalRule: {
                return {
                    name: TerminalRule,
                    properties: [
                        { name: 'definition' },
                        { name: 'fragment', defaultValue: false },
                        { name: 'hidden', defaultValue: false },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case Type: {
                return {
                    name: Type,
                    properties: [
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case TypeAttribute: {
                return {
                    name: TypeAttribute,
                    properties: [
                        { name: 'defaultValue' },
                        { name: 'isOptional', defaultValue: false },
                        { name: 'name' },
                        { name: 'type' }
                    ]
                };
            }
            case UnionType: {
                return {
                    name: UnionType,
                    properties: [
                        { name: 'types', defaultValue: [] }
                    ]
                };
            }
            case Action: {
                return {
                    name: Action,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'feature' },
                        { name: 'inferredType' },
                        { name: 'lookahead' },
                        { name: 'operator' },
                        { name: 'type' }
                    ]
                };
            }
            case Alternatives: {
                return {
                    name: Alternatives,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'lookahead' }
                    ]
                };
            }
            case Assignment: {
                return {
                    name: Assignment,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'feature' },
                        { name: 'lookahead' },
                        { name: 'operator' },
                        { name: 'terminal' }
                    ]
                };
            }
            case CharacterRange: {
                return {
                    name: CharacterRange,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'left' },
                        { name: 'lookahead' },
                        { name: 'right' }
                    ]
                };
            }
            case CrossReference: {
                return {
                    name: CrossReference,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'deprecatedSyntax', defaultValue: false },
                        { name: 'lookahead' },
                        { name: 'terminal' },
                        { name: 'type' }
                    ]
                };
            }
            case EndOfFile: {
                return {
                    name: EndOfFile,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' }
                    ]
                };
            }
            case Group: {
                return {
                    name: Group,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'guardCondition' },
                        { name: 'lookahead' }
                    ]
                };
            }
            case Keyword: {
                return {
                    name: Keyword,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' },
                        { name: 'value' }
                    ]
                };
            }
            case NegatedToken: {
                return {
                    name: NegatedToken,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' },
                        { name: 'terminal' }
                    ]
                };
            }
            case RegexToken: {
                return {
                    name: RegexToken,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' },
                        { name: 'regex' }
                    ]
                };
            }
            case RuleCall: {
                return {
                    name: RuleCall,
                    properties: [
                        { name: 'arguments', defaultValue: [] },
                        { name: 'cardinality' },
                        { name: 'lookahead' },
                        { name: 'rule' }
                    ]
                };
            }
            case TerminalAlternatives: {
                return {
                    name: TerminalAlternatives,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'lookahead' }
                    ]
                };
            }
            case TerminalGroup: {
                return {
                    name: TerminalGroup,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'lookahead' }
                    ]
                };
            }
            case TerminalRuleCall: {
                return {
                    name: TerminalRuleCall,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' },
                        { name: 'rule' }
                    ]
                };
            }
            case UnorderedGroup: {
                return {
                    name: UnorderedGroup,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'elements', defaultValue: [] },
                        { name: 'lookahead' }
                    ]
                };
            }
            case UntilToken: {
                return {
                    name: UntilToken,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' },
                        { name: 'terminal' }
                    ]
                };
            }
            case Wildcard: {
                return {
                    name: Wildcard,
                    properties: [
                        { name: 'cardinality' },
                        { name: 'lookahead' }
                    ]
                };
            }
            default: {
                return {
                    name: type,
                    properties: []
                };
            }
        }
    }
}
const reflection = new LangiumGrammarAstReflection();
//# sourceMappingURL=ast.js.map

/***/ }),

/***/ "./node_modules/langium/lib/languages/grammar-config.js":
/*!**************************************************************!*\
  !*** ./node_modules/langium/lib/languages/grammar-config.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createGrammarConfig: () => (/* binding */ createGrammarConfig)
/* harmony export */ });
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/* harmony import */ var _utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/regexp-utils.js */ "./node_modules/langium/lib/utils/regexp-utils.js");
/* harmony import */ var _generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/




/**
 * Create the default grammar configuration (used by `createDefaultModule`). This can be overridden in a
 * language-specific module.
 */
function createGrammarConfig(services) {
    const rules = [];
    const grammar = services.Grammar;
    for (const rule of grammar.rules) {
        if ((0,_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule)(rule) && (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.isCommentTerminal)(rule) && (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__.isMultilineComment)((0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.terminalRegex)(rule))) {
            rules.push(rule.name);
        }
    }
    return {
        multilineCommentRules: rules,
        nameRegexp: _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_3__.DefaultNameRegexp
    };
}
//# sourceMappingURL=grammar-config.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/async-parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/parser/async-parser.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractThreadedAsyncParser: () => (/* binding */ AbstractThreadedAsyncParser),
/* harmony export */   DefaultAsyncParser: () => (/* binding */ DefaultAsyncParser),
/* harmony export */   ParserWorker: () => (/* binding */ ParserWorker)
/* harmony export */ });
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/event.js */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


/**
 * Default implementation of the async parser which simply wraps the sync parser in a promise.
 *
 * @remarks
 * A real implementation would create worker threads or web workers to offload the parsing work.
 */
class DefaultAsyncParser {
    constructor(services) {
        this.syncParser = services.parser.LangiumParser;
    }
    parse(text, _cancelToken) {
        return Promise.resolve(this.syncParser.parse(text));
    }
}
class AbstractThreadedAsyncParser {
    constructor(services) {
        /**
         * The thread count determines how many threads are used to parse files in parallel.
         * The default value is 8. Decreasing this value increases startup performance, but decreases parallel parsing performance.
         */
        this.threadCount = 8;
        /**
         * The termination delay determines how long the parser waits for a thread to finish after a cancellation request.
         * The default value is 200(ms).
         */
        this.terminationDelay = 200;
        this.workerPool = [];
        this.queue = [];
        this.hydrator = services.serializer.Hydrator;
    }
    initializeWorkers() {
        while (this.workerPool.length < this.threadCount) {
            const worker = this.createWorker();
            worker.onReady(() => {
                if (this.queue.length > 0) {
                    const deferred = this.queue.shift();
                    if (deferred) {
                        worker.lock();
                        deferred.resolve(worker);
                    }
                }
            });
            this.workerPool.push(worker);
        }
    }
    async parse(text, cancelToken) {
        const worker = await this.acquireParserWorker(cancelToken);
        const deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        let timeout;
        // If the cancellation token is requested, we wait for a certain time before terminating the worker.
        // Since the cancellation token lives longer than the parsing process, we need to dispose the event listener.
        // Otherwise, we might accidentally terminate the worker after the parsing process has finished.
        const cancellation = cancelToken.onCancellationRequested(() => {
            timeout = setTimeout(() => {
                this.terminateWorker(worker);
            }, this.terminationDelay);
        });
        worker.parse(text).then(result => {
            const hydrated = this.hydrator.hydrate(result);
            deferred.resolve(hydrated);
        }).catch(err => {
            deferred.reject(err);
        }).finally(() => {
            cancellation.dispose();
            clearTimeout(timeout);
        });
        return deferred.promise;
    }
    terminateWorker(worker) {
        worker.terminate();
        const index = this.workerPool.indexOf(worker);
        if (index >= 0) {
            this.workerPool.splice(index, 1);
        }
    }
    async acquireParserWorker(cancelToken) {
        this.initializeWorkers();
        for (const worker of this.workerPool) {
            if (worker.ready) {
                worker.lock();
                return worker;
            }
        }
        const deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        cancelToken.onCancellationRequested(() => {
            const index = this.queue.indexOf(deferred);
            if (index >= 0) {
                this.queue.splice(index, 1);
            }
            deferred.reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.OperationCancelled);
        });
        this.queue.push(deferred);
        return deferred.promise;
    }
}
class ParserWorker {
    get ready() {
        return this._ready;
    }
    get onReady() {
        return this.onReadyEmitter.event;
    }
    constructor(sendMessage, onMessage, onError, terminate) {
        this.onReadyEmitter = new _utils_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter();
        this.deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this._ready = true;
        this._parsing = false;
        this.sendMessage = sendMessage;
        this._terminate = terminate;
        onMessage(result => {
            const parseResult = result;
            this.deferred.resolve(parseResult);
            this.unlock();
        });
        onError(error => {
            this.deferred.reject(error);
            this.unlock();
        });
    }
    terminate() {
        this.deferred.reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.OperationCancelled);
        this._terminate();
    }
    lock() {
        this._ready = false;
    }
    unlock() {
        this._parsing = false;
        this._ready = true;
        this.onReadyEmitter.fire();
    }
    parse(text) {
        if (this._parsing) {
            throw new Error('Parser worker is busy');
        }
        this._parsing = true;
        this.deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.sendMessage(text);
        return this.deferred.promise;
    }
}
//# sourceMappingURL=async-parser.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/completion-parser-builder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/langium/lib/parser/completion-parser-builder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createCompletionParser: () => (/* binding */ createCompletionParser)
/* harmony export */ });
/* harmony import */ var _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langium-parser.js */ "./node_modules/langium/lib/parser/langium-parser.js");
/* harmony import */ var _parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser-builder-base.js */ "./node_modules/langium/lib/parser/parser-builder-base.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


function createCompletionParser(services) {
    const grammar = services.Grammar;
    const lexer = services.parser.Lexer;
    const parser = new _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__.LangiumCompletionParser(services);
    (0,_parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__.createParser)(grammar, parser, lexer.definition);
    parser.finalize();
    return parser;
}
//# sourceMappingURL=completion-parser-builder.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/cst-node-builder.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/parser/cst-node-builder.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractCstNode: () => (/* binding */ AbstractCstNode),
/* harmony export */   CompositeCstNodeImpl: () => (/* binding */ CompositeCstNodeImpl),
/* harmony export */   CstNodeBuilder: () => (/* binding */ CstNodeBuilder),
/* harmony export */   LeafCstNodeImpl: () => (/* binding */ LeafCstNodeImpl),
/* harmony export */   RootCstNodeImpl: () => (/* binding */ RootCstNodeImpl)
/* harmony export */ });
/* harmony import */ var vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/esm/main.js");
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


class CstNodeBuilder {
    constructor() {
        this.nodeStack = [];
    }
    get current() {
        var _a;
        return (_a = this.nodeStack[this.nodeStack.length - 1]) !== null && _a !== void 0 ? _a : this.rootNode;
    }
    buildRootNode(input) {
        this.rootNode = new RootCstNodeImpl(input);
        this.rootNode.root = this.rootNode;
        this.nodeStack = [this.rootNode];
        return this.rootNode;
    }
    buildCompositeNode(feature) {
        const compositeNode = new CompositeCstNodeImpl();
        compositeNode.grammarSource = feature;
        compositeNode.root = this.rootNode;
        this.current.content.push(compositeNode);
        this.nodeStack.push(compositeNode);
        return compositeNode;
    }
    buildLeafNode(token, feature) {
        const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.tokenToRange)(token), token.tokenType, !feature);
        leafNode.grammarSource = feature;
        leafNode.root = this.rootNode;
        this.current.content.push(leafNode);
        return leafNode;
    }
    removeNode(node) {
        const parent = node.container;
        if (parent) {
            const index = parent.content.indexOf(node);
            if (index >= 0) {
                parent.content.splice(index, 1);
            }
        }
    }
    addHiddenNodes(tokens) {
        const nodes = [];
        for (const token of tokens) {
            const leafNode = new LeafCstNodeImpl(token.startOffset, token.image.length, (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.tokenToRange)(token), token.tokenType, true);
            leafNode.root = this.rootNode;
            nodes.push(leafNode);
        }
        let current = this.current;
        let added = false;
        // If we are within a composite node, we add the hidden nodes to the content
        if (current.content.length > 0) {
            current.content.push(...nodes);
            return;
        }
        // Otherwise we are at a newly created node
        // Instead of adding the hidden nodes here, we search for the first parent node with content
        while (current.container) {
            const index = current.container.content.indexOf(current);
            if (index > 0) {
                // Add the hidden nodes before the current node
                current.container.content.splice(index, 0, ...nodes);
                added = true;
                break;
            }
            current = current.container;
        }
        // If we arrive at the root node, we add the hidden nodes at the beginning
        // This is the case if the hidden nodes are the first nodes in the tree
        if (!added) {
            this.rootNode.content.unshift(...nodes);
        }
    }
    construct(item) {
        const current = this.current;
        // The specified item could be a datatype ($type is symbol) or a fragment ($type is undefined)
        // Only if the $type is a string, we actually assign the element
        if (typeof item.$type === 'string') {
            this.current.astNode = item;
        }
        item.$cstNode = current;
        const node = this.nodeStack.pop();
        // Empty composite nodes are not valid
        // Simply remove the node from the tree
        if ((node === null || node === void 0 ? void 0 : node.content.length) === 0) {
            this.removeNode(node);
        }
    }
}
class AbstractCstNode {
    /** @deprecated use `container` instead. */
    get parent() {
        return this.container;
    }
    /** @deprecated use `grammarSource` instead. */
    get feature() {
        return this.grammarSource;
    }
    get hidden() {
        return false;
    }
    get astNode() {
        var _a, _b;
        const node = typeof ((_a = this._astNode) === null || _a === void 0 ? void 0 : _a.$type) === 'string' ? this._astNode : (_b = this.container) === null || _b === void 0 ? void 0 : _b.astNode;
        if (!node) {
            throw new Error('This node has no associated AST element');
        }
        return node;
    }
    set astNode(value) {
        this._astNode = value;
    }
    /** @deprecated use `astNode` instead. */
    get element() {
        return this.astNode;
    }
    get text() {
        return this.root.fullText.substring(this.offset, this.end);
    }
}
class LeafCstNodeImpl extends AbstractCstNode {
    get offset() {
        return this._offset;
    }
    get length() {
        return this._length;
    }
    get end() {
        return this._offset + this._length;
    }
    get hidden() {
        return this._hidden;
    }
    get tokenType() {
        return this._tokenType;
    }
    get range() {
        return this._range;
    }
    constructor(offset, length, range, tokenType, hidden = false) {
        super();
        this._hidden = hidden;
        this._offset = offset;
        this._tokenType = tokenType;
        this._length = length;
        this._range = range;
    }
}
class CompositeCstNodeImpl extends AbstractCstNode {
    constructor() {
        super(...arguments);
        this.content = new CstNodeContainer(this);
    }
    /** @deprecated use `content` instead. */
    get children() {
        return this.content;
    }
    get offset() {
        var _a, _b;
        return (_b = (_a = this.firstNonHiddenNode) === null || _a === void 0 ? void 0 : _a.offset) !== null && _b !== void 0 ? _b : 0;
    }
    get length() {
        return this.end - this.offset;
    }
    get end() {
        var _a, _b;
        return (_b = (_a = this.lastNonHiddenNode) === null || _a === void 0 ? void 0 : _a.end) !== null && _b !== void 0 ? _b : 0;
    }
    get range() {
        const firstNode = this.firstNonHiddenNode;
        const lastNode = this.lastNonHiddenNode;
        if (firstNode && lastNode) {
            if (this._rangeCache === undefined) {
                const { range: firstRange } = firstNode;
                const { range: lastRange } = lastNode;
                this._rangeCache = { start: firstRange.start, end: lastRange.end.line < firstRange.start.line ? firstRange.start : lastRange.end };
            }
            return this._rangeCache;
        }
        else {
            return { start: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(0, 0), end: vscode_languageserver_types__WEBPACK_IMPORTED_MODULE_0__.Position.create(0, 0) };
        }
    }
    get firstNonHiddenNode() {
        for (const child of this.content) {
            if (!child.hidden) {
                return child;
            }
        }
        return this.content[0];
    }
    get lastNonHiddenNode() {
        for (let i = this.content.length - 1; i >= 0; i--) {
            const child = this.content[i];
            if (!child.hidden) {
                return child;
            }
        }
        return this.content[this.content.length - 1];
    }
}
class CstNodeContainer extends Array {
    constructor(parent) {
        super();
        this.parent = parent;
        Object.setPrototypeOf(this, CstNodeContainer.prototype);
    }
    push(...items) {
        this.addParents(items);
        return super.push(...items);
    }
    unshift(...items) {
        this.addParents(items);
        return super.unshift(...items);
    }
    splice(start, count, ...items) {
        this.addParents(items);
        return super.splice(start, count, ...items);
    }
    addParents(items) {
        for (const item of items) {
            item.container = this.parent;
        }
    }
}
class RootCstNodeImpl extends CompositeCstNodeImpl {
    get text() {
        return this._text.substring(this.offset, this.end);
    }
    get fullText() {
        return this._text;
    }
    constructor(input) {
        super();
        this._text = '';
        this._text = input !== null && input !== void 0 ? input : '';
    }
}
//# sourceMappingURL=cst-node-builder.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/langium-parser-builder.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langium/lib/parser/langium-parser-builder.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createLangiumParser: () => (/* binding */ createLangiumParser),
/* harmony export */   prepareLangiumParser: () => (/* binding */ prepareLangiumParser)
/* harmony export */ });
/* harmony import */ var _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./langium-parser.js */ "./node_modules/langium/lib/parser/langium-parser.js");
/* harmony import */ var _parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./parser-builder-base.js */ "./node_modules/langium/lib/parser/parser-builder-base.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


/**
 * Create and finalize a Langium parser. The parser rules are derived from the grammar, which is
 * available at `services.Grammar`.
 */
function createLangiumParser(services) {
    const parser = prepareLangiumParser(services);
    parser.finalize();
    return parser;
}
/**
 * Create a Langium parser without finalizing it. This is used to extract more detailed error
 * information when the parser is initially validated.
 */
function prepareLangiumParser(services) {
    const grammar = services.Grammar;
    const lexer = services.parser.Lexer;
    const parser = new _langium_parser_js__WEBPACK_IMPORTED_MODULE_0__.LangiumParser(services);
    return (0,_parser_builder_base_js__WEBPACK_IMPORTED_MODULE_1__.createParser)(grammar, parser, lexer.definition);
}
//# sourceMappingURL=langium-parser-builder.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/langium-parser.js":
/*!***********************************************************!*\
  !*** ./node_modules/langium/lib/parser/langium-parser.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractLangiumParser: () => (/* binding */ AbstractLangiumParser),
/* harmony export */   AbstractParserErrorMessageProvider: () => (/* binding */ AbstractParserErrorMessageProvider),
/* harmony export */   DatatypeSymbol: () => (/* binding */ DatatypeSymbol),
/* harmony export */   LangiumCompletionParser: () => (/* binding */ LangiumCompletionParser),
/* harmony export */   LangiumParser: () => (/* binding */ LangiumParser),
/* harmony export */   LangiumParserErrorMessageProvider: () => (/* binding */ LangiumParserErrorMessageProvider)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ "./node_modules/chevrotain/lib/src/api.js");
/* harmony import */ var chevrotain_allstar__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! chevrotain-allstar */ "./node_modules/chevrotain-allstar/lib/index.js");
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _cst_node_builder_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cst-node-builder.js */ "./node_modules/langium/lib/parser/cst-node-builder.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






const DatatypeSymbol = Symbol('Datatype');
function isDataTypeNode(node) {
    return node.$type === DatatypeSymbol;
}
const ruleSuffix = '\u200B';
const withRuleSuffix = (name) => name.endsWith(ruleSuffix) ? name : name + ruleSuffix;
class AbstractLangiumParser {
    constructor(services) {
        this._unorderedGroups = new Map();
        this.allRules = new Map();
        this.lexer = services.parser.Lexer;
        const tokens = this.lexer.definition;
        const production = services.LanguageMetaData.mode === 'production';
        this.wrapper = new ChevrotainWrapper(tokens, Object.assign(Object.assign({}, services.parser.ParserConfig), { skipValidations: production, errorMessageProvider: services.parser.ParserErrorMessageProvider }));
    }
    alternatives(idx, choices) {
        this.wrapper.wrapOr(idx, choices);
    }
    optional(idx, callback) {
        this.wrapper.wrapOption(idx, callback);
    }
    many(idx, callback) {
        this.wrapper.wrapMany(idx, callback);
    }
    atLeastOne(idx, callback) {
        this.wrapper.wrapAtLeastOne(idx, callback);
    }
    getRule(name) {
        return this.allRules.get(name);
    }
    isRecording() {
        return this.wrapper.IS_RECORDING;
    }
    get unorderedGroups() {
        return this._unorderedGroups;
    }
    getRuleStack() {
        return this.wrapper.RULE_STACK;
    }
    finalize() {
        this.wrapper.wrapSelfAnalysis();
    }
}
class LangiumParser extends AbstractLangiumParser {
    get current() {
        return this.stack[this.stack.length - 1];
    }
    constructor(services) {
        super(services);
        this.nodeBuilder = new _cst_node_builder_js__WEBPACK_IMPORTED_MODULE_2__.CstNodeBuilder();
        this.stack = [];
        this.assignmentMap = new Map();
        this.linker = services.references.Linker;
        this.converter = services.parser.ValueConverter;
        this.astReflection = services.shared.AstReflection;
    }
    rule(rule, impl) {
        const type = this.computeRuleType(rule);
        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(type, impl).bind(this));
        this.allRules.set(rule.name, ruleMethod);
        if (rule.entry) {
            this.mainRule = ruleMethod;
        }
        return ruleMethod;
    }
    computeRuleType(rule) {
        if (rule.fragment) {
            return undefined;
        }
        else if ((0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_3__.isDataTypeRule)(rule)) {
            return DatatypeSymbol;
        }
        else {
            const explicit = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_3__.getExplicitRuleType)(rule);
            return explicit !== null && explicit !== void 0 ? explicit : rule.name;
        }
    }
    parse(input, options = {}) {
        this.nodeBuilder.buildRootNode(input);
        const lexerResult = this.lexerResult = this.lexer.tokenize(input);
        this.wrapper.input = lexerResult.tokens;
        const ruleMethod = options.rule ? this.allRules.get(options.rule) : this.mainRule;
        if (!ruleMethod) {
            throw new Error(options.rule ? `No rule found with name '${options.rule}'` : 'No main rule available.');
        }
        const result = ruleMethod.call(this.wrapper, {});
        this.nodeBuilder.addHiddenNodes(lexerResult.hidden);
        this.unorderedGroups.clear();
        this.lexerResult = undefined;
        return {
            value: result,
            lexerErrors: lexerResult.errors,
            lexerReport: lexerResult.report,
            parserErrors: this.wrapper.errors
        };
    }
    startImplementation($type, implementation) {
        return (args) => {
            // Only create a new AST node in case the calling rule is not a fragment rule
            const createNode = !this.isRecording() && $type !== undefined;
            if (createNode) {
                const node = { $type };
                this.stack.push(node);
                if ($type === DatatypeSymbol) {
                    node.value = '';
                }
            }
            let result;
            try {
                result = implementation(args);
            }
            catch (err) {
                result = undefined;
            }
            if (result === undefined && createNode) {
                result = this.construct();
            }
            return result;
        };
    }
    extractHiddenTokens(token) {
        const hiddenTokens = this.lexerResult.hidden;
        if (!hiddenTokens.length) {
            return [];
        }
        const offset = token.startOffset;
        for (let i = 0; i < hiddenTokens.length; i++) {
            const token = hiddenTokens[i];
            if (token.startOffset > offset) {
                return hiddenTokens.splice(0, i);
            }
        }
        return hiddenTokens.splice(0, hiddenTokens.length);
    }
    consume(idx, tokenType, feature) {
        const token = this.wrapper.wrapConsume(idx, tokenType);
        if (!this.isRecording() && this.isValidToken(token)) {
            const hiddenTokens = this.extractHiddenTokens(token);
            this.nodeBuilder.addHiddenNodes(hiddenTokens);
            const leafNode = this.nodeBuilder.buildLeafNode(token, feature);
            const { assignment, isCrossRef } = this.getAssignment(feature);
            const current = this.current;
            if (assignment) {
                const convertedValue = (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isKeyword)(feature) ? token.image : this.converter.convert(token.image, leafNode);
                this.assign(assignment.operator, assignment.feature, convertedValue, leafNode, isCrossRef);
            }
            else if (isDataTypeNode(current)) {
                let text = token.image;
                if (!(0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isKeyword)(feature)) {
                    text = this.converter.convert(text, leafNode).toString();
                }
                current.value += text;
            }
        }
    }
    /**
     * Most consumed parser tokens are valid. However there are two cases in which they are not valid:
     *
     * 1. They were inserted during error recovery by the parser. These tokens don't really exist and should not be further processed
     * 2. They contain invalid token ranges. This might include the special EOF token, or other tokens produced by invalid token builders.
     */
    isValidToken(token) {
        return !token.isInsertedInRecovery && !isNaN(token.startOffset) && typeof token.endOffset === 'number' && !isNaN(token.endOffset);
    }
    subrule(idx, rule, fragment, feature, args) {
        let cstNode;
        if (!this.isRecording() && !fragment) {
            // We only want to create a new CST node if the subrule actually creates a new AST node.
            // In other cases like calls of fragment rules the current CST/AST is populated further.
            // Note that skipping this initialization and leaving cstNode unassigned also skips the subrule assignment later on.
            // This is intended, as fragment rules only enrich the current AST node
            cstNode = this.nodeBuilder.buildCompositeNode(feature);
        }
        const subruleResult = this.wrapper.wrapSubrule(idx, rule, args);
        if (!this.isRecording() && cstNode && cstNode.length > 0) {
            this.performSubruleAssignment(subruleResult, feature, cstNode);
        }
    }
    performSubruleAssignment(result, feature, cstNode) {
        const { assignment, isCrossRef } = this.getAssignment(feature);
        if (assignment) {
            this.assign(assignment.operator, assignment.feature, result, cstNode, isCrossRef);
        }
        else if (!assignment) {
            // If we call a subrule without an assignment we either:
            // 1. append the result of the subrule (data type rule)
            // 2. override the current object with the newly parsed object
            // If the current element is an AST node and the result of the subrule
            // is a data type rule, we can safely discard the results.
            const current = this.current;
            if (isDataTypeNode(current)) {
                current.value += result.toString();
            }
            else if (typeof result === 'object' && result) {
                const object = this.assignWithoutOverride(result, current);
                const newItem = object;
                this.stack.pop();
                this.stack.push(newItem);
            }
        }
    }
    action($type, action) {
        if (!this.isRecording()) {
            let last = this.current;
            if (action.feature && action.operator) {
                last = this.construct();
                this.nodeBuilder.removeNode(last.$cstNode);
                const node = this.nodeBuilder.buildCompositeNode(action);
                node.content.push(last.$cstNode);
                const newItem = { $type };
                this.stack.push(newItem);
                this.assign(action.operator, action.feature, last, last.$cstNode, false);
            }
            else {
                last.$type = $type;
            }
        }
    }
    construct() {
        if (this.isRecording()) {
            return undefined;
        }
        const obj = this.current;
        (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.linkContentToContainer)(obj);
        this.nodeBuilder.construct(obj);
        this.stack.pop();
        if (isDataTypeNode(obj)) {
            return this.converter.convert(obj.value, obj.$cstNode);
        }
        else {
            (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.assignMandatoryProperties)(this.astReflection, obj);
        }
        return obj;
    }
    getAssignment(feature) {
        if (!this.assignmentMap.has(feature)) {
            const assignment = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.getContainerOfType)(feature, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isAssignment);
            this.assignmentMap.set(feature, {
                assignment: assignment,
                isCrossRef: assignment ? (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isCrossReference)(assignment.terminal) : false
            });
        }
        return this.assignmentMap.get(feature);
    }
    assign(operator, feature, value, cstNode, isCrossRef) {
        const obj = this.current;
        let item;
        if (isCrossRef && typeof value === 'string') {
            item = this.linker.buildReference(obj, feature, cstNode, value);
        }
        else {
            item = value;
        }
        switch (operator) {
            case '=': {
                obj[feature] = item;
                break;
            }
            case '?=': {
                obj[feature] = true;
                break;
            }
            case '+=': {
                if (!Array.isArray(obj[feature])) {
                    obj[feature] = [];
                }
                obj[feature].push(item);
            }
        }
    }
    assignWithoutOverride(target, source) {
        for (const [name, existingValue] of Object.entries(source)) {
            const newValue = target[name];
            if (newValue === undefined) {
                target[name] = existingValue;
            }
            else if (Array.isArray(newValue) && Array.isArray(existingValue)) {
                existingValue.push(...newValue);
                target[name] = existingValue;
            }
        }
        // The target was parsed from a unassigned subrule
        // After the subrule construction, it received a cst node
        // This CST node will later be overriden by the cst node builder
        // To prevent references to stale AST nodes in the CST,
        // we need to remove the reference here
        const targetCstNode = target.$cstNode;
        if (targetCstNode) {
            targetCstNode.astNode = undefined;
            target.$cstNode = undefined;
        }
        return target;
    }
    get definitionErrors() {
        return this.wrapper.definitionErrors;
    }
}
class AbstractParserErrorMessageProvider {
    buildMismatchTokenMessage(options) {
        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildMismatchTokenMessage(options);
    }
    buildNotAllInputParsedMessage(options) {
        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildNotAllInputParsedMessage(options);
    }
    buildNoViableAltMessage(options) {
        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildNoViableAltMessage(options);
    }
    buildEarlyExitMessage(options) {
        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultParserErrorProvider.buildEarlyExitMessage(options);
    }
}
class LangiumParserErrorMessageProvider extends AbstractParserErrorMessageProvider {
    buildMismatchTokenMessage({ expected, actual }) {
        const expectedMsg = expected.LABEL
            ? '`' + expected.LABEL + '`'
            : expected.name.endsWith(':KW')
                ? `keyword '${expected.name.substring(0, expected.name.length - 3)}'`
                : `token of type '${expected.name}'`;
        return `Expecting ${expectedMsg} but found \`${actual.image}\`.`;
    }
    buildNotAllInputParsedMessage({ firstRedundant }) {
        return `Expecting end of file but found \`${firstRedundant.image}\`.`;
    }
}
class LangiumCompletionParser extends AbstractLangiumParser {
    constructor() {
        super(...arguments);
        this.tokens = [];
        this.elementStack = [];
        this.lastElementStack = [];
        this.nextTokenIndex = 0;
        this.stackSize = 0;
    }
    action() {
        // NOOP
    }
    construct() {
        // NOOP
        return undefined;
    }
    parse(input) {
        this.resetState();
        const tokens = this.lexer.tokenize(input, { mode: 'partial' });
        this.tokens = tokens.tokens;
        this.wrapper.input = [...this.tokens];
        this.mainRule.call(this.wrapper, {});
        this.unorderedGroups.clear();
        return {
            tokens: this.tokens,
            elementStack: [...this.lastElementStack],
            tokenIndex: this.nextTokenIndex
        };
    }
    rule(rule, impl) {
        const ruleMethod = this.wrapper.DEFINE_RULE(withRuleSuffix(rule.name), this.startImplementation(impl).bind(this));
        this.allRules.set(rule.name, ruleMethod);
        if (rule.entry) {
            this.mainRule = ruleMethod;
        }
        return ruleMethod;
    }
    resetState() {
        this.elementStack = [];
        this.lastElementStack = [];
        this.nextTokenIndex = 0;
        this.stackSize = 0;
    }
    startImplementation(implementation) {
        return (args) => {
            const size = this.keepStackSize();
            try {
                implementation(args);
            }
            finally {
                this.resetStackSize(size);
            }
        };
    }
    removeUnexpectedElements() {
        this.elementStack.splice(this.stackSize);
    }
    keepStackSize() {
        const size = this.elementStack.length;
        this.stackSize = size;
        return size;
    }
    resetStackSize(size) {
        this.removeUnexpectedElements();
        this.stackSize = size;
    }
    consume(idx, tokenType, feature) {
        this.wrapper.wrapConsume(idx, tokenType);
        if (!this.isRecording()) {
            this.lastElementStack = [...this.elementStack, feature];
            this.nextTokenIndex = this.currIdx + 1;
        }
    }
    subrule(idx, rule, fragment, feature, args) {
        this.before(feature);
        this.wrapper.wrapSubrule(idx, rule, args);
        this.after(feature);
    }
    before(element) {
        if (!this.isRecording()) {
            this.elementStack.push(element);
        }
    }
    after(element) {
        if (!this.isRecording()) {
            const index = this.elementStack.lastIndexOf(element);
            if (index >= 0) {
                this.elementStack.splice(index);
            }
        }
    }
    get currIdx() {
        return this.wrapper.currIdx;
    }
}
const defaultConfig = {
    recoveryEnabled: true,
    nodeLocationTracking: 'full',
    skipValidations: true,
    errorMessageProvider: new LangiumParserErrorMessageProvider()
};
/**
 * This class wraps the embedded actions parser of chevrotain and exposes protected methods.
 * This way, we can build the `LangiumParser` as a composition.
 */
class ChevrotainWrapper extends chevrotain__WEBPACK_IMPORTED_MODULE_0__.EmbeddedActionsParser {
    constructor(tokens, config) {
        const useDefaultLookahead = config && 'maxLookahead' in config;
        super(tokens, Object.assign(Object.assign(Object.assign({}, defaultConfig), { lookaheadStrategy: useDefaultLookahead
                ? new chevrotain__WEBPACK_IMPORTED_MODULE_0__.LLkLookaheadStrategy({ maxLookahead: config.maxLookahead })
                : new chevrotain_allstar__WEBPACK_IMPORTED_MODULE_1__.LLStarLookaheadStrategy({
                    // If validations are skipped, don't log the lookahead warnings
                    logging: config.skipValidations ? () => { } : undefined
                }) }), config));
    }
    get IS_RECORDING() {
        return this.RECORDING_PHASE;
    }
    DEFINE_RULE(name, impl) {
        return this.RULE(name, impl);
    }
    wrapSelfAnalysis() {
        this.performSelfAnalysis();
    }
    wrapConsume(idx, tokenType) {
        return this.consume(idx, tokenType);
    }
    wrapSubrule(idx, rule, args) {
        return this.subrule(idx, rule, {
            ARGS: [args]
        });
    }
    wrapOr(idx, choices) {
        this.or(idx, choices);
    }
    wrapOption(idx, callback) {
        this.option(idx, callback);
    }
    wrapMany(idx, callback) {
        this.many(idx, callback);
    }
    wrapAtLeastOne(idx, callback) {
        this.atLeastOne(idx, callback);
    }
}
//# sourceMappingURL=langium-parser.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/lexer.js":
/*!**************************************************!*\
  !*** ./node_modules/langium/lib/parser/lexer.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DEFAULT_TOKENIZE_OPTIONS: () => (/* binding */ DEFAULT_TOKENIZE_OPTIONS),
/* harmony export */   DefaultLexer: () => (/* binding */ DefaultLexer),
/* harmony export */   DefaultLexerErrorMessageProvider: () => (/* binding */ DefaultLexerErrorMessageProvider),
/* harmony export */   isIMultiModeLexerDefinition: () => (/* binding */ isIMultiModeLexerDefinition),
/* harmony export */   isTokenTypeArray: () => (/* binding */ isTokenTypeArray),
/* harmony export */   isTokenTypeDictionary: () => (/* binding */ isTokenTypeDictionary)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ "./node_modules/chevrotain/lib/src/api.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

class DefaultLexerErrorMessageProvider {
    buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column) {
        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultLexerErrorProvider.buildUnexpectedCharactersMessage(fullText, startOffset, length, line, column);
    }
    buildUnableToPopLexerModeMessage(token) {
        return chevrotain__WEBPACK_IMPORTED_MODULE_0__.defaultLexerErrorProvider.buildUnableToPopLexerModeMessage(token);
    }
}
const DEFAULT_TOKENIZE_OPTIONS = { mode: 'full' };
class DefaultLexer {
    constructor(services) {
        this.errorMessageProvider = services.parser.LexerErrorMessageProvider;
        this.tokenBuilder = services.parser.TokenBuilder;
        const tokens = this.tokenBuilder.buildTokens(services.Grammar, {
            caseInsensitive: services.LanguageMetaData.caseInsensitive
        });
        this.tokenTypes = this.toTokenTypeDictionary(tokens);
        const lexerTokens = isTokenTypeDictionary(tokens) ? Object.values(tokens) : tokens;
        const production = services.LanguageMetaData.mode === 'production';
        this.chevrotainLexer = new chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer(lexerTokens, {
            positionTracking: 'full',
            skipValidations: production,
            errorMessageProvider: this.errorMessageProvider
        });
    }
    get definition() {
        return this.tokenTypes;
    }
    tokenize(text, _options = DEFAULT_TOKENIZE_OPTIONS) {
        var _a, _b, _c;
        const chevrotainResult = this.chevrotainLexer.tokenize(text);
        return {
            tokens: chevrotainResult.tokens,
            errors: chevrotainResult.errors,
            hidden: (_a = chevrotainResult.groups.hidden) !== null && _a !== void 0 ? _a : [],
            report: (_c = (_b = this.tokenBuilder).flushLexingReport) === null || _c === void 0 ? void 0 : _c.call(_b, text)
        };
    }
    toTokenTypeDictionary(buildTokens) {
        if (isTokenTypeDictionary(buildTokens))
            return buildTokens;
        const tokens = isIMultiModeLexerDefinition(buildTokens) ? Object.values(buildTokens.modes).flat() : buildTokens;
        const res = {};
        tokens.forEach(token => res[token.name] = token);
        return res;
    }
}
/**
 * Returns a check whether the given TokenVocabulary is TokenType array
 */
function isTokenTypeArray(tokenVocabulary) {
    return Array.isArray(tokenVocabulary) && (tokenVocabulary.length === 0 || 'name' in tokenVocabulary[0]);
}
/**
 * Returns a check whether the given TokenVocabulary is IMultiModeLexerDefinition
 */
function isIMultiModeLexerDefinition(tokenVocabulary) {
    return tokenVocabulary && 'modes' in tokenVocabulary && 'defaultMode' in tokenVocabulary;
}
/**
 * Returns a check whether the given TokenVocabulary is TokenTypeDictionary
 */
function isTokenTypeDictionary(tokenVocabulary) {
    return !isTokenTypeArray(tokenVocabulary) && !isIMultiModeLexerDefinition(tokenVocabulary);
}
//# sourceMappingURL=lexer.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/parser-builder-base.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/parser/parser-builder-base.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createParser: () => (/* binding */ createParser)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ "./node_modules/chevrotain/lib/src/api.js");
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _utils_errors_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/errors.js */ "./node_modules/langium/lib/utils/errors.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/





function createParser(grammar, parser, tokens) {
    const parserContext = {
        parser,
        tokens,
        ruleNames: new Map()
    };
    buildRules(parserContext, grammar);
    return parser;
}
function buildRules(parserContext, grammar) {
    const reachable = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getAllReachableRules)(grammar, false);
    const parserRules = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(grammar.rules).filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule).filter(rule => reachable.has(rule));
    for (const rule of parserRules) {
        const ctx = Object.assign(Object.assign({}, parserContext), { consume: 1, optional: 1, subrule: 1, many: 1, or: 1 });
        parserContext.parser.rule(rule, buildElement(ctx, rule.definition));
    }
}
function buildElement(ctx, element, ignoreGuard = false) {
    let method;
    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isKeyword)(element)) {
        method = buildKeyword(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAction)(element)) {
        method = buildAction(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAssignment)(element)) {
        method = buildElement(ctx, element.terminal);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isCrossReference)(element)) {
        method = buildCrossReference(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isRuleCall)(element)) {
        method = buildRuleCall(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAlternatives)(element)) {
        method = buildAlternatives(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isUnorderedGroup)(element)) {
        method = buildUnorderedGroup(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isGroup)(element)) {
        method = buildGroup(ctx, element);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isEndOfFile)(element)) {
        const idx = ctx.consume++;
        method = () => ctx.parser.consume(idx, chevrotain__WEBPACK_IMPORTED_MODULE_0__.EOF, element);
    }
    else {
        throw new _utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.ErrorWithLocation(element.$cstNode, `Unexpected element type: ${element.$type}`);
    }
    return wrap(ctx, ignoreGuard ? undefined : getGuardCondition(element), method, element.cardinality);
}
function buildAction(ctx, action) {
    const actionType = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTypeName)(action);
    return () => ctx.parser.action(actionType, action);
}
function buildRuleCall(ctx, ruleCall) {
    const rule = ruleCall.rule.ref;
    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(rule)) {
        const idx = ctx.subrule++;
        const fragment = rule.fragment;
        const predicate = ruleCall.arguments.length > 0 ? buildRuleCallPredicate(rule, ruleCall.arguments) : () => ({});
        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), fragment, ruleCall, predicate(args));
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isTerminalRule)(rule)) {
        const idx = ctx.consume++;
        const method = getToken(ctx, rule.name);
        return () => ctx.parser.consume(idx, method, ruleCall);
    }
    else if (!rule) {
        throw new _utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.ErrorWithLocation(ruleCall.$cstNode, `Undefined rule: ${ruleCall.rule.$refText}`);
    }
    else {
        (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.assertUnreachable)(rule);
    }
}
function buildRuleCallPredicate(rule, namedArgs) {
    const predicates = namedArgs.map(e => buildPredicate(e.value));
    return (args) => {
        const ruleArgs = {};
        for (let i = 0; i < predicates.length; i++) {
            const ruleTarget = rule.parameters[i];
            const predicate = predicates[i];
            ruleArgs[ruleTarget.name] = predicate(args);
        }
        return ruleArgs;
    };
}
function buildPredicate(condition) {
    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isDisjunction)(condition)) {
        const left = buildPredicate(condition.left);
        const right = buildPredicate(condition.right);
        return (args) => (left(args) || right(args));
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isConjunction)(condition)) {
        const left = buildPredicate(condition.left);
        const right = buildPredicate(condition.right);
        return (args) => (left(args) && right(args));
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isNegation)(condition)) {
        const value = buildPredicate(condition.value);
        return (args) => !value(args);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParameterReference)(condition)) {
        const name = condition.parameter.ref.name;
        return (args) => args !== undefined && args[name] === true;
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isBooleanLiteral)(condition)) {
        const value = Boolean(condition.true);
        return () => value;
    }
    (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.assertUnreachable)(condition);
}
function buildAlternatives(ctx, alternatives) {
    if (alternatives.elements.length === 1) {
        return buildElement(ctx, alternatives.elements[0]);
    }
    else {
        const methods = [];
        for (const element of alternatives.elements) {
            const predicatedMethod = {
                // Since we handle the guard condition in the alternative already
                // We can ignore the group guard condition inside
                ALT: buildElement(ctx, element, true)
            };
            const guard = getGuardCondition(element);
            if (guard) {
                predicatedMethod.GATE = buildPredicate(guard);
            }
            methods.push(predicatedMethod);
        }
        const idx = ctx.or++;
        return (args) => ctx.parser.alternatives(idx, methods.map(method => {
            const alt = {
                ALT: () => method.ALT(args)
            };
            const gate = method.GATE;
            if (gate) {
                alt.GATE = () => gate(args);
            }
            return alt;
        }));
    }
}
function buildUnorderedGroup(ctx, group) {
    if (group.elements.length === 1) {
        return buildElement(ctx, group.elements[0]);
    }
    const methods = [];
    for (const element of group.elements) {
        const predicatedMethod = {
            // Since we handle the guard condition in the alternative already
            // We can ignore the group guard condition inside
            ALT: buildElement(ctx, element, true)
        };
        const guard = getGuardCondition(element);
        if (guard) {
            predicatedMethod.GATE = buildPredicate(guard);
        }
        methods.push(predicatedMethod);
    }
    const orIdx = ctx.or++;
    const idFunc = (groupIdx, lParser) => {
        const stackId = lParser.getRuleStack().join('-');
        return `uGroup_${groupIdx}_${stackId}`;
    };
    const alternatives = (args) => ctx.parser.alternatives(orIdx, methods.map((method, idx) => {
        const alt = { ALT: () => true };
        const parser = ctx.parser;
        alt.ALT = () => {
            method.ALT(args);
            if (!parser.isRecording()) {
                const key = idFunc(orIdx, parser);
                if (!parser.unorderedGroups.get(key)) {
                    // init after clear state
                    parser.unorderedGroups.set(key, []);
                }
                const groupState = parser.unorderedGroups.get(key);
                if (typeof (groupState === null || groupState === void 0 ? void 0 : groupState[idx]) === 'undefined') {
                    // Not accessed yet
                    groupState[idx] = true;
                }
            }
        };
        const gate = method.GATE;
        if (gate) {
            alt.GATE = () => gate(args);
        }
        else {
            alt.GATE = () => {
                const trackedAlternatives = parser.unorderedGroups.get(idFunc(orIdx, parser));
                const allow = !(trackedAlternatives === null || trackedAlternatives === void 0 ? void 0 : trackedAlternatives[idx]);
                return allow;
            };
        }
        return alt;
    }));
    const wrapped = wrap(ctx, getGuardCondition(group), alternatives, '*');
    return (args) => {
        wrapped(args);
        if (!ctx.parser.isRecording()) {
            ctx.parser.unorderedGroups.delete(idFunc(orIdx, ctx.parser));
        }
    };
}
function buildGroup(ctx, group) {
    const methods = group.elements.map(e => buildElement(ctx, e));
    return (args) => methods.forEach(method => method(args));
}
function getGuardCondition(element) {
    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isGroup)(element)) {
        return element.guardCondition;
    }
    return undefined;
}
function buildCrossReference(ctx, crossRef, terminal = crossRef.terminal) {
    if (!terminal) {
        if (!crossRef.type.ref) {
            throw new Error('Could not resolve reference to type: ' + crossRef.type.$refText);
        }
        const assignment = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.findNameAssignment)(crossRef.type.ref);
        const assignTerminal = assignment === null || assignment === void 0 ? void 0 : assignment.terminal;
        if (!assignTerminal) {
            throw new Error('Could not find name assignment for type: ' + (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getTypeName)(crossRef.type.ref));
        }
        return buildCrossReference(ctx, crossRef, assignTerminal);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isRuleCall)(terminal) && (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(terminal.rule.ref)) {
        // The terminal is a data type rule here. Everything else will result in a validation error.
        const rule = terminal.rule.ref;
        const idx = ctx.subrule++;
        return (args) => ctx.parser.subrule(idx, getRule(ctx, rule), false, crossRef, args);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isRuleCall)(terminal) && (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isTerminalRule)(terminal.rule.ref)) {
        const idx = ctx.consume++;
        const terminalRule = getToken(ctx, terminal.rule.ref.name);
        return () => ctx.parser.consume(idx, terminalRule, crossRef);
    }
    else if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isKeyword)(terminal)) {
        const idx = ctx.consume++;
        const keyword = getToken(ctx, terminal.value);
        return () => ctx.parser.consume(idx, keyword, crossRef);
    }
    else {
        throw new Error('Could not build cross reference parser');
    }
}
function buildKeyword(ctx, keyword) {
    const idx = ctx.consume++;
    const token = ctx.tokens[keyword.value];
    if (!token) {
        throw new Error('Could not find token for keyword: ' + keyword.value);
    }
    return () => ctx.parser.consume(idx, token, keyword);
}
function wrap(ctx, guard, method, cardinality) {
    const gate = guard && buildPredicate(guard);
    if (!cardinality) {
        if (gate) {
            const idx = ctx.or++;
            return (args) => ctx.parser.alternatives(idx, [
                {
                    ALT: () => method(args),
                    GATE: () => gate(args)
                },
                {
                    ALT: (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ALT)(),
                    GATE: () => !gate(args)
                }
            ]);
        }
        else {
            return method;
        }
    }
    if (cardinality === '*') {
        const idx = ctx.many++;
        return (args) => ctx.parser.many(idx, {
            DEF: () => method(args),
            GATE: gate ? () => gate(args) : undefined
        });
    }
    else if (cardinality === '+') {
        const idx = ctx.many++;
        if (gate) {
            const orIdx = ctx.or++;
            // In the case of a guard condition for the `+` group
            // We combine it with an empty alternative
            // If the condition returns true, it needs to parse at least a single iteration
            // If its false, it is not allowed to parse anything
            return (args) => ctx.parser.alternatives(orIdx, [
                {
                    ALT: () => ctx.parser.atLeastOne(idx, {
                        DEF: () => method(args)
                    }),
                    GATE: () => gate(args)
                },
                {
                    ALT: (0,chevrotain__WEBPACK_IMPORTED_MODULE_0__.EMPTY_ALT)(),
                    GATE: () => !gate(args)
                }
            ]);
        }
        else {
            return (args) => ctx.parser.atLeastOne(idx, {
                DEF: () => method(args),
            });
        }
    }
    else if (cardinality === '?') {
        const idx = ctx.optional++;
        return (args) => ctx.parser.optional(idx, {
            DEF: () => method(args),
            GATE: gate ? () => gate(args) : undefined
        });
    }
    else {
        (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_4__.assertUnreachable)(cardinality);
    }
}
function getRule(ctx, element) {
    const name = getRuleName(ctx, element);
    const rule = ctx.parser.getRule(name);
    if (!rule)
        throw new Error(`Rule "${name}" not found."`);
    return rule;
}
function getRuleName(ctx, element) {
    if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(element)) {
        return element.name;
    }
    else if (ctx.ruleNames.has(element)) {
        return ctx.ruleNames.get(element);
    }
    else {
        let item = element;
        let parent = item.$container;
        let ruleName = element.$type;
        while (!(0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isParserRule)(parent)) {
            if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isGroup)(parent) || (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isAlternatives)(parent) || (0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_3__.isUnorderedGroup)(parent)) {
                const index = parent.elements.indexOf(item);
                ruleName = index.toString() + ':' + ruleName;
            }
            item = parent;
            parent = parent.$container;
        }
        const rule = parent;
        ruleName = rule.name + ':' + ruleName;
        ctx.ruleNames.set(element, ruleName);
        return ruleName;
    }
}
function getToken(ctx, name) {
    const token = ctx.tokens[name];
    if (!token)
        throw new Error(`Token "${name}" not found."`);
    return token;
}
//# sourceMappingURL=parser-builder-base.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/token-builder.js":
/*!**********************************************************!*\
  !*** ./node_modules/langium/lib/parser/token-builder.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultTokenBuilder: () => (/* binding */ DefaultTokenBuilder)
/* harmony export */ });
/* harmony import */ var chevrotain__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! chevrotain */ "./node_modules/chevrotain/lib/src/api.js");
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/* harmony import */ var _utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/regexp-utils.js */ "./node_modules/langium/lib/utils/regexp-utils.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






class DefaultTokenBuilder {
    constructor() {
        /**
         * The list of diagnostics stored during the lexing process of a single text.
         */
        this.diagnostics = [];
    }
    buildTokens(grammar, options) {
        const reachableRules = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_1__.stream)((0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__.getAllReachableRules)(grammar, false));
        const terminalTokens = this.buildTerminalTokens(reachableRules);
        const tokens = this.buildKeywordTokens(reachableRules, terminalTokens, options);
        terminalTokens.forEach(terminalToken => {
            const pattern = terminalToken.PATTERN;
            if (typeof pattern === 'object' && pattern && 'test' in pattern && (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.isWhitespace)(pattern)) {
                tokens.unshift(terminalToken);
            }
            else {
                tokens.push(terminalToken);
            }
        });
        // We don't need to add the EOF token explicitly.
        // It is automatically available at the end of the token stream.
        return tokens;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    flushLexingReport(text) {
        return { diagnostics: this.popDiagnostics() };
    }
    popDiagnostics() {
        const diagnostics = [...this.diagnostics];
        this.diagnostics = [];
        return diagnostics;
    }
    buildTerminalTokens(rules) {
        return rules.filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isTerminalRule).filter(e => !e.fragment)
            .map(terminal => this.buildTerminalToken(terminal)).toArray();
    }
    buildTerminalToken(terminal) {
        const regex = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__.terminalRegex)(terminal);
        const pattern = this.requiresCustomPattern(regex) ? this.regexPatternFunction(regex) : regex;
        const tokenType = {
            name: terminal.name,
            PATTERN: pattern,
        };
        if (typeof pattern === 'function') {
            tokenType.LINE_BREAKS = true;
        }
        if (terminal.hidden) {
            // Only skip tokens that are able to accept whitespace
            tokenType.GROUP = (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.isWhitespace)(regex) ? chevrotain__WEBPACK_IMPORTED_MODULE_0__.Lexer.SKIPPED : 'hidden';
        }
        return tokenType;
    }
    requiresCustomPattern(regex) {
        if (regex.flags.includes('u') || regex.flags.includes('s')) {
            // Unicode and dotall regexes are not supported by Chevrotain.
            return true;
        }
        else if (regex.source.includes('?<=') || regex.source.includes('?<!')) {
            // Negative and positive lookbehind are not supported by Chevrotain yet.
            return true;
        }
        else {
            return false;
        }
    }
    regexPatternFunction(regex) {
        const stickyRegex = new RegExp(regex, regex.flags + 'y');
        return (text, offset) => {
            stickyRegex.lastIndex = offset;
            const execResult = stickyRegex.exec(text);
            return execResult;
        };
    }
    buildKeywordTokens(rules, terminalTokens, options) {
        return rules
            // We filter by parser rules, since keywords in terminal rules get transformed into regex and are not actual tokens
            .filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isParserRule)
            .flatMap(rule => (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.streamAllContents)(rule).filter(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_4__.isKeyword))
            .distinct(e => e.value).toArray()
            // Sort keywords by descending length
            .sort((a, b) => b.value.length - a.value.length)
            .map(keyword => this.buildKeywordToken(keyword, terminalTokens, Boolean(options === null || options === void 0 ? void 0 : options.caseInsensitive)));
    }
    buildKeywordToken(keyword, terminalTokens, caseInsensitive) {
        const keywordPattern = this.buildKeywordPattern(keyword, caseInsensitive);
        const tokenType = {
            name: keyword.value,
            PATTERN: keywordPattern,
            LONGER_ALT: this.findLongerAlt(keyword, terminalTokens)
        };
        if (typeof keywordPattern === 'function') {
            tokenType.LINE_BREAKS = true;
        }
        return tokenType;
    }
    buildKeywordPattern(keyword, caseInsensitive) {
        return caseInsensitive ?
            new RegExp((0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.getCaseInsensitivePattern)(keyword.value)) :
            keyword.value;
    }
    findLongerAlt(keyword, terminalTokens) {
        return terminalTokens.reduce((longerAlts, token) => {
            const pattern = token === null || token === void 0 ? void 0 : token.PATTERN;
            if ((pattern === null || pattern === void 0 ? void 0 : pattern.source) && (0,_utils_regexp_utils_js__WEBPACK_IMPORTED_MODULE_3__.partialMatches)('^' + pattern.source + '$', keyword.value)) {
                longerAlts.push(token);
            }
            return longerAlts;
        }, []);
    }
}
//# sourceMappingURL=token-builder.js.map

/***/ }),

/***/ "./node_modules/langium/lib/parser/value-converter.js":
/*!************************************************************!*\
  !*** ./node_modules/langium/lib/parser/value-converter.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultValueConverter: () => (/* binding */ DefaultValueConverter),
/* harmony export */   ValueConverter: () => (/* binding */ ValueConverter)
/* harmony export */ });
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


class DefaultValueConverter {
    convert(input, cstNode) {
        let feature = cstNode.grammarSource;
        if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isCrossReference)(feature)) {
            feature = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getCrossReferenceTerminal)(feature);
        }
        if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall)(feature)) {
            const rule = feature.rule.ref;
            if (!rule) {
                throw new Error('This cst node was not parsed by a rule.');
            }
            return this.runConverter(rule, input, cstNode);
        }
        return input;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    runConverter(rule, input, cstNode) {
        var _a;
        switch (rule.name.toUpperCase()) {
            case 'INT': return ValueConverter.convertInt(input);
            case 'STRING': return ValueConverter.convertString(input);
            case 'ID': return ValueConverter.convertID(input);
        }
        switch ((_a = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_1__.getRuleType)(rule)) === null || _a === void 0 ? void 0 : _a.toLowerCase()) {
            case 'number': return ValueConverter.convertNumber(input);
            case 'boolean': return ValueConverter.convertBoolean(input);
            case 'bigint': return ValueConverter.convertBigint(input);
            case 'date': return ValueConverter.convertDate(input);
            default: return input;
        }
    }
}
var ValueConverter;
(function (ValueConverter) {
    function convertString(input) {
        let result = '';
        for (let i = 1; i < input.length - 1; i++) {
            const c = input.charAt(i);
            if (c === '\\') {
                const c1 = input.charAt(++i);
                result += convertEscapeCharacter(c1);
            }
            else {
                result += c;
            }
        }
        return result;
    }
    ValueConverter.convertString = convertString;
    function convertEscapeCharacter(char) {
        switch (char) {
            case 'b': return '\b';
            case 'f': return '\f';
            case 'n': return '\n';
            case 'r': return '\r';
            case 't': return '\t';
            case 'v': return '\v';
            case '0': return '\0';
            default: return char;
        }
    }
    function convertID(input) {
        if (input.charAt(0) === '^') {
            return input.substring(1);
        }
        else {
            return input;
        }
    }
    ValueConverter.convertID = convertID;
    function convertInt(input) {
        return parseInt(input);
    }
    ValueConverter.convertInt = convertInt;
    function convertBigint(input) {
        return BigInt(input);
    }
    ValueConverter.convertBigint = convertBigint;
    function convertDate(input) {
        return new Date(input);
    }
    ValueConverter.convertDate = convertDate;
    function convertNumber(input) {
        return Number(input);
    }
    ValueConverter.convertNumber = convertNumber;
    function convertBoolean(input) {
        return input.toLowerCase() === 'true';
    }
    ValueConverter.convertBoolean = convertBoolean;
})(ValueConverter || (ValueConverter = {}));
//# sourceMappingURL=value-converter.js.map

/***/ }),

/***/ "./node_modules/langium/lib/references/linker.js":
/*!*******************************************************!*\
  !*** ./node_modules/langium/lib/references/linker.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultLinker: () => (/* binding */ DefaultLinker)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _workspace_documents_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../workspace/documents.js */ "./node_modules/langium/lib/workspace/documents.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/





const ref_resolving = Symbol('ref_resolving');
class DefaultLinker {
    constructor(services) {
        this.reflection = services.shared.AstReflection;
        this.langiumDocuments = () => services.shared.workspace.LangiumDocuments;
        this.scopeProvider = services.references.ScopeProvider;
        this.astNodeLocator = services.workspace.AstNodeLocator;
    }
    async link(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        for (const node of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(document.parseResult.value)) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.interruptAndCheck)(cancelToken);
            (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamReferences)(node).forEach(ref => this.doLink(ref, document));
        }
    }
    doLink(refInfo, document) {
        var _a;
        const ref = refInfo.reference;
        // The reference may already have been resolved lazily by accessing its `ref` property.
        if (ref._ref === undefined) {
            ref._ref = ref_resolving;
            try {
                const description = this.getCandidate(refInfo);
                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLinkingError)(description)) {
                    ref._ref = description;
                }
                else {
                    ref._nodeDescription = description;
                    if (this.langiumDocuments().hasDocument(description.documentUri)) {
                        // The target document is already loaded
                        const linkedNode = this.loadAstNode(description);
                        ref._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : this.createLinkingError(refInfo, description);
                    }
                    else {
                        // Try to load the target AST node later using the already provided description
                        ref._ref = undefined;
                    }
                }
            }
            catch (err) {
                console.error(`An error occurred while resolving reference to '${ref.$refText}':`, err);
                const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);
                ref._ref = Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${ref.$refText}': ${errorMessage}` });
            }
            // Add the reference to the document's array of references
            // Only add if the reference has been not been resolved earlier
            // Otherwise we end up with duplicates
            // See also implementation of `buildReference`
            document.references.push(ref);
        }
    }
    unlink(document) {
        for (const ref of document.references) {
            delete ref._ref;
            delete ref._nodeDescription;
        }
        document.references = [];
    }
    getCandidate(refInfo) {
        const scope = this.scopeProvider.getScope(refInfo);
        const description = scope.getElement(refInfo.reference.$refText);
        return description !== null && description !== void 0 ? description : this.createLinkingError(refInfo);
    }
    buildReference(node, property, refNode, refText) {
        // See behavior description in doc of Linker, update that on changes in here.
        // eslint-disable-next-line @typescript-eslint/no-this-alias
        const linker = this;
        const reference = {
            $refNode: refNode,
            $refText: refText,
            get ref() {
                var _a;
                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(this._ref)) {
                    // Most frequent case: the target is already resolved.
                    return this._ref;
                }
                else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNodeDescription)(this._nodeDescription)) {
                    // A candidate has been found before, but it is not loaded yet.
                    const linkedNode = linker.loadAstNode(this._nodeDescription);
                    this._ref = linkedNode !== null && linkedNode !== void 0 ? linkedNode : linker.createLinkingError({ reference, container: node, property }, this._nodeDescription);
                }
                else if (this._ref === undefined) {
                    // The reference has not been linked yet, so do that now.
                    this._ref = ref_resolving;
                    const document = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.findRootNode)(node).$document;
                    const refData = linker.getLinkedNode({ reference, container: node, property });
                    if (refData.error && document && document.state < _workspace_documents_js__WEBPACK_IMPORTED_MODULE_4__.DocumentState.ComputedScopes) {
                        // Document scope is not ready, don't set `this._ref` so linker can retry later.
                        return this._ref = undefined;
                    }
                    this._ref = (_a = refData.node) !== null && _a !== void 0 ? _a : refData.error;
                    this._nodeDescription = refData.descr;
                    document === null || document === void 0 ? void 0 : document.references.push(this);
                }
                else if (this._ref === ref_resolving) {
                    throw new Error(`Cyclic reference resolution detected: ${linker.astNodeLocator.getAstNodePath(node)}/${property} (symbol '${refText}')`);
                }
                return (0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(this._ref) ? this._ref : undefined;
            },
            get $nodeDescription() {
                return this._nodeDescription;
            },
            get error() {
                return (0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLinkingError)(this._ref) ? this._ref : undefined;
            }
        };
        return reference;
    }
    getLinkedNode(refInfo) {
        var _a;
        try {
            const description = this.getCandidate(refInfo);
            if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLinkingError)(description)) {
                return { error: description };
            }
            const linkedNode = this.loadAstNode(description);
            if (linkedNode) {
                return { node: linkedNode, descr: description };
            }
            else {
                return {
                    descr: description,
                    error: this.createLinkingError(refInfo, description)
                };
            }
        }
        catch (err) {
            console.error(`An error occurred while resolving reference to '${refInfo.reference.$refText}':`, err);
            const errorMessage = (_a = err.message) !== null && _a !== void 0 ? _a : String(err);
            return {
                error: Object.assign(Object.assign({}, refInfo), { message: `An error occurred while resolving reference to '${refInfo.reference.$refText}': ${errorMessage}` })
            };
        }
    }
    loadAstNode(nodeDescription) {
        if (nodeDescription.node) {
            return nodeDescription.node;
        }
        const doc = this.langiumDocuments().getDocument(nodeDescription.documentUri);
        if (!doc) {
            return undefined;
        }
        return this.astNodeLocator.getAstNode(doc.parseResult.value, nodeDescription.path);
    }
    createLinkingError(refInfo, targetDescription) {
        // Check whether the document is sufficiently processed by the DocumentBuilder. If not, this is a hint for a bug
        // in the language implementation.
        const document = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.findRootNode)(refInfo.container).$document;
        if (document && document.state < _workspace_documents_js__WEBPACK_IMPORTED_MODULE_4__.DocumentState.ComputedScopes) {
            console.warn(`Attempted reference resolution before document reached ComputedScopes state (${document.uri}).`);
        }
        const referenceType = this.reflection.getReferenceType(refInfo);
        return Object.assign(Object.assign({}, refInfo), { message: `Could not resolve reference to ${referenceType} named '${refInfo.reference.$refText}'.`, targetDescription });
    }
}
//# sourceMappingURL=linker.js.map

/***/ }),

/***/ "./node_modules/langium/lib/references/name-provider.js":
/*!**************************************************************!*\
  !*** ./node_modules/langium/lib/references/name-provider.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultNameProvider: () => (/* binding */ DefaultNameProvider),
/* harmony export */   isNamed: () => (/* binding */ isNamed)
/* harmony export */ });
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

function isNamed(node) {
    return typeof node.name === 'string';
}
class DefaultNameProvider {
    getName(node) {
        if (isNamed(node)) {
            return node.name;
        }
        return undefined;
    }
    getNameNode(node) {
        return (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__.findNodeForProperty)(node.$cstNode, 'name');
    }
}
//# sourceMappingURL=name-provider.js.map

/***/ }),

/***/ "./node_modules/langium/lib/references/references.js":
/*!***********************************************************!*\
  !*** ./node_modules/langium/lib/references/references.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultReferences: () => (/* binding */ DefaultReferences)
/* harmony export */ });
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/langium/lib/utils/uri-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






class DefaultReferences {
    constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.index = services.shared.workspace.IndexManager;
        this.nodeLocator = services.workspace.AstNodeLocator;
    }
    findDeclaration(sourceCstNode) {
        if (sourceCstNode) {
            const assignment = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_0__.findAssignment)(sourceCstNode);
            const nodeElem = sourceCstNode.astNode;
            if (assignment && nodeElem) {
                const reference = nodeElem[assignment.feature];
                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(reference)) {
                    return reference.ref;
                }
                else if (Array.isArray(reference)) {
                    for (const ref of reference) {
                        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(ref) && ref.$refNode
                            && ref.$refNode.offset <= sourceCstNode.offset
                            && ref.$refNode.end >= sourceCstNode.end) {
                            return ref.ref;
                        }
                    }
                }
            }
            if (nodeElem) {
                const nameNode = this.nameProvider.getNameNode(nodeElem);
                // Only return the targeted node in case the targeted cst node is the name node or part of it
                if (nameNode && (nameNode === sourceCstNode || (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.isChildNode)(sourceCstNode, nameNode))) {
                    return nodeElem;
                }
            }
        }
        return undefined;
    }
    findDeclarationNode(sourceCstNode) {
        const astNode = this.findDeclaration(sourceCstNode);
        if (astNode === null || astNode === void 0 ? void 0 : astNode.$cstNode) {
            const targetNode = this.nameProvider.getNameNode(astNode);
            return targetNode !== null && targetNode !== void 0 ? targetNode : astNode.$cstNode;
        }
        return undefined;
    }
    findReferences(targetNode, options) {
        const refs = [];
        if (options.includeDeclaration) {
            const ref = this.getReferenceToSelf(targetNode);
            if (ref) {
                refs.push(ref);
            }
        }
        let indexReferences = this.index.findAllReferences(targetNode, this.nodeLocator.getAstNodePath(targetNode));
        if (options.documentUri) {
            indexReferences = indexReferences.filter(ref => _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__.UriUtils.equals(ref.sourceUri, options.documentUri));
        }
        refs.push(...indexReferences);
        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.stream)(refs);
    }
    getReferenceToSelf(targetNode) {
        const nameNode = this.nameProvider.getNameNode(targetNode);
        if (nameNode) {
            const doc = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_5__.getDocument)(targetNode);
            const path = this.nodeLocator.getAstNodePath(targetNode);
            return {
                sourceUri: doc.uri,
                sourcePath: path,
                targetUri: doc.uri,
                targetPath: path,
                segment: (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.toDocumentSegment)(nameNode),
                local: true
            };
        }
        return undefined;
    }
}
//# sourceMappingURL=references.js.map

/***/ }),

/***/ "./node_modules/langium/lib/references/scope-computation.js":
/*!******************************************************************!*\
  !*** ./node_modules/langium/lib/references/scope-computation.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultScopeComputation: () => (/* binding */ DefaultScopeComputation)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/collections.js */ "./node_modules/langium/lib/utils/collections.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/




/**
 * The default scope computation creates and collectes descriptions of the AST nodes to be exported into the
 * _global_ scope from the given document. By default those are the document's root AST node and its directly
 * contained child nodes.
 *
 * Besides, it gathers all AST nodes that have a name (according to the `NameProvider` service) and includes them
 * in the local scope of their particular container nodes. As a result, for every cross-reference in the AST,
 * target elements from the same level (siblings) and further up towards the root (parents and siblings of parents)
 * are visible. Elements being nested inside lower levels (children, children of siblings and parents' siblings)
 * are _invisible_ by default, but that can be changed by customizing this service.
 */
class DefaultScopeComputation {
    constructor(services) {
        this.nameProvider = services.references.NameProvider;
        this.descriptions = services.workspace.AstNodeDescriptionProvider;
    }
    async computeExports(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        return this.computeExportsForNode(document.parseResult.value, document, undefined, cancelToken);
    }
    /**
     * Creates {@link AstNodeDescription AstNodeDescriptions} for the given {@link AstNode parentNode} and its children.
     * The list of children to be considered is determined by the function parameter {@link children}.
     * By default only the direct children of {@link parentNode} are visited, nested nodes are not exported.
     *
     * @param parentNode AST node to be exported, i.e., of which an {@link AstNodeDescription} shall be added to the returned list.
     * @param document The document containing the AST node to be exported.
     * @param children A function called with {@link parentNode} as single argument and returning an {@link Iterable} supplying the children to be visited, which must be directly or transitively contained in {@link parentNode}.
     * @param cancelToken Indicates when to cancel the current operation.
     * @throws `OperationCancelled` if a user action occurs during execution.
     * @returns A list of {@link AstNodeDescription AstNodeDescriptions} to be published to index.
     */
    async computeExportsForNode(parentNode, document, children = _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamContents, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        const exports = [];
        this.exportNode(parentNode, exports, document);
        for (const node of children(parentNode)) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.interruptAndCheck)(cancelToken);
            this.exportNode(node, exports, document);
        }
        return exports;
    }
    /**
     * Add a single node to the list of exports if it has a name. Override this method to change how
     * symbols are exported, e.g. by modifying their exported name.
     */
    exportNode(node, exports, document) {
        const name = this.nameProvider.getName(node);
        if (name) {
            exports.push(this.descriptions.createDescription(node, name, document));
        }
    }
    async computeLocalScopes(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        const rootNode = document.parseResult.value;
        const scopes = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_3__.MultiMap();
        // Here we navigate the full AST - local scopes shall be available in the whole document
        for (const node of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(rootNode)) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.interruptAndCheck)(cancelToken);
            this.processNode(node, document, scopes);
        }
        return scopes;
    }
    /**
     * Process a single node during scopes computation. The default implementation makes the node visible
     * in the subtree of its container (if the node has a name). Override this method to change this,
     * e.g. by increasing the visibility to a higher level in the AST.
     */
    processNode(node, document, scopes) {
        const container = node.$container;
        if (container) {
            const name = this.nameProvider.getName(node);
            if (name) {
                scopes.add(container, this.descriptions.createDescription(node, name, document));
            }
        }
    }
}
//# sourceMappingURL=scope-computation.js.map

/***/ }),

/***/ "./node_modules/langium/lib/references/scope-provider.js":
/*!***************************************************************!*\
  !*** ./node_modules/langium/lib/references/scope-provider.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultScopeProvider: () => (/* binding */ DefaultScopeProvider)
/* harmony export */ });
/* harmony import */ var _scope_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./scope.js */ "./node_modules/langium/lib/references/scope.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/caching.js */ "./node_modules/langium/lib/utils/caching.js");
/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/




class DefaultScopeProvider {
    constructor(services) {
        this.reflection = services.shared.AstReflection;
        this.nameProvider = services.references.NameProvider;
        this.descriptions = services.workspace.AstNodeDescriptionProvider;
        this.indexManager = services.shared.workspace.IndexManager;
        this.globalScopeCache = new _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__.WorkspaceCache(services.shared);
    }
    getScope(context) {
        const scopes = [];
        const referenceType = this.reflection.getReferenceType(context);
        const precomputed = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)(context.container).precomputedScopes;
        if (precomputed) {
            let currentNode = context.container;
            do {
                const allDescriptions = precomputed.get(currentNode);
                if (allDescriptions.length > 0) {
                    scopes.push((0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(allDescriptions).filter(desc => this.reflection.isSubtype(desc.type, referenceType)));
                }
                currentNode = currentNode.$container;
            } while (currentNode);
        }
        let result = this.getGlobalScope(referenceType, context);
        for (let i = scopes.length - 1; i >= 0; i--) {
            result = this.createScope(scopes[i], result);
        }
        return result;
    }
    /**
     * Create a scope for the given collection of AST node descriptions.
     */
    createScope(elements, outerScope, options) {
        return new _scope_js__WEBPACK_IMPORTED_MODULE_3__.StreamScope((0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(elements), outerScope, options);
    }
    /**
     * Create a scope for the given collection of AST nodes, which need to be transformed into respective
     * descriptions first. This is done using the `NameProvider` and `AstNodeDescriptionProvider` services.
     */
    createScopeForNodes(elements, outerScope, options) {
        const s = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_2__.stream)(elements).map(e => {
            const name = this.nameProvider.getName(e);
            if (name) {
                return this.descriptions.createDescription(e, name);
            }
            return undefined;
        }).nonNullable();
        return new _scope_js__WEBPACK_IMPORTED_MODULE_3__.StreamScope(s, outerScope, options);
    }
    /**
     * Create a global scope filtered for the given reference type.
     */
    getGlobalScope(referenceType, _context) {
        return this.globalScopeCache.get(referenceType, () => new _scope_js__WEBPACK_IMPORTED_MODULE_3__.MapScope(this.indexManager.allElements(referenceType)));
    }
}
//# sourceMappingURL=scope-provider.js.map

/***/ }),

/***/ "./node_modules/langium/lib/references/scope.js":
/*!******************************************************!*\
  !*** ./node_modules/langium/lib/references/scope.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EMPTY_SCOPE: () => (/* binding */ EMPTY_SCOPE),
/* harmony export */   MapScope: () => (/* binding */ MapScope),
/* harmony export */   StreamScope: () => (/* binding */ StreamScope)
/* harmony export */ });
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * The default scope implementation is based on a `Stream`. It has an optional _outer scope_ describing
 * the next level of elements, which are queried when a target element is not found in the stream provided
 * to this scope.
 */
class StreamScope {
    constructor(elements, outerScope, options) {
        var _a;
        this.elements = elements;
        this.outerScope = outerScope;
        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;
    }
    getAllElements() {
        if (this.outerScope) {
            return this.elements.concat(this.outerScope.getAllElements());
        }
        else {
            return this.elements;
        }
    }
    getElement(name) {
        const local = this.caseInsensitive
            ? this.elements.find(e => e.name.toLowerCase() === name.toLowerCase())
            : this.elements.find(e => e.name === name);
        if (local) {
            return local;
        }
        if (this.outerScope) {
            return this.outerScope.getElement(name);
        }
        return undefined;
    }
}
class MapScope {
    constructor(elements, outerScope, options) {
        var _a;
        this.elements = new Map();
        this.caseInsensitive = (_a = options === null || options === void 0 ? void 0 : options.caseInsensitive) !== null && _a !== void 0 ? _a : false;
        for (const element of elements) {
            const name = this.caseInsensitive
                ? element.name.toLowerCase()
                : element.name;
            this.elements.set(name, element);
        }
        this.outerScope = outerScope;
    }
    getElement(name) {
        const localName = this.caseInsensitive ? name.toLowerCase() : name;
        const local = this.elements.get(localName);
        if (local) {
            return local;
        }
        if (this.outerScope) {
            return this.outerScope.getElement(name);
        }
        return undefined;
    }
    getAllElements() {
        let elementStream = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.elements.values());
        if (this.outerScope) {
            elementStream = elementStream.concat(this.outerScope.getAllElements());
        }
        return elementStream;
    }
}
const EMPTY_SCOPE = {
    getElement() {
        return undefined;
    },
    getAllElements() {
        return _utils_stream_js__WEBPACK_IMPORTED_MODULE_0__.EMPTY_STREAM;
    }
};
//# sourceMappingURL=scope.js.map

/***/ }),

/***/ "./node_modules/langium/lib/serializer/hydrator.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/serializer/hydrator.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultHydrator: () => (/* binding */ DefaultHydrator)
/* harmony export */ });
/* harmony import */ var _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parser/cst-node-builder.js */ "./node_modules/langium/lib/parser/cst-node-builder.js");
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/collections.js */ "./node_modules/langium/lib/utils/collections.js");
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/******************************************************************************
 * Copyright 2024 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






class DefaultHydrator {
    constructor(services) {
        this.grammarElementIdMap = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.BiMap();
        this.tokenTypeIdMap = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.BiMap();
        this.grammar = services.Grammar;
        this.lexer = services.parser.Lexer;
        this.linker = services.references.Linker;
    }
    dehydrate(result) {
        return {
            lexerErrors: result.lexerErrors,
            lexerReport: result.lexerReport ? this.dehydrateLexerReport(result.lexerReport) : undefined,
            // We need to create shallow copies of the errors
            // The original errors inherit from the `Error` class, which is not transferable across worker threads
            parserErrors: result.parserErrors.map(e => (Object.assign(Object.assign({}, e), { message: e.message }))),
            value: this.dehydrateAstNode(result.value, this.createDehyrationContext(result.value))
        };
    }
    dehydrateLexerReport(lexerReport) {
        // By default, lexer reports are serializable
        return lexerReport;
    }
    createDehyrationContext(node) {
        const astNodes = new Map();
        const cstNodes = new Map();
        for (const astNode of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(node)) {
            astNodes.set(astNode, {});
        }
        if (node.$cstNode) {
            for (const cstNode of (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.streamCst)(node.$cstNode)) {
                cstNodes.set(cstNode, {});
            }
        }
        return {
            astNodes,
            cstNodes
        };
    }
    dehydrateAstNode(node, context) {
        const obj = context.astNodes.get(node);
        obj.$type = node.$type;
        obj.$containerIndex = node.$containerIndex;
        obj.$containerProperty = node.$containerProperty;
        if (node.$cstNode !== undefined) {
            obj.$cstNode = this.dehydrateCstNode(node.$cstNode, context);
        }
        for (const [name, value] of Object.entries(node)) {
            if (name.startsWith('$')) {
                continue;
            }
            if (Array.isArray(value)) {
                const arr = [];
                obj[name] = arr;
                for (const item of value) {
                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(item)) {
                        arr.push(this.dehydrateAstNode(item, context));
                    }
                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(item)) {
                        arr.push(this.dehydrateReference(item, context));
                    }
                    else {
                        arr.push(item);
                    }
                }
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(value)) {
                obj[name] = this.dehydrateAstNode(value, context);
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(value)) {
                obj[name] = this.dehydrateReference(value, context);
            }
            else if (value !== undefined) {
                obj[name] = value;
            }
        }
        return obj;
    }
    dehydrateReference(reference, context) {
        const obj = {};
        obj.$refText = reference.$refText;
        if (reference.$refNode) {
            obj.$refNode = context.cstNodes.get(reference.$refNode);
        }
        return obj;
    }
    dehydrateCstNode(node, context) {
        const cstNode = context.cstNodes.get(node);
        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isRootCstNode)(node)) {
            cstNode.fullText = node.fullText;
        }
        else {
            // Note: This returns undefined for hidden nodes (i.e. comments)
            cstNode.grammarSource = this.getGrammarElementId(node.grammarSource);
        }
        cstNode.hidden = node.hidden;
        cstNode.astNode = context.astNodes.get(node.astNode);
        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isCompositeCstNode)(node)) {
            cstNode.content = node.content.map(child => this.dehydrateCstNode(child, context));
        }
        else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isLeafCstNode)(node)) {
            cstNode.tokenType = node.tokenType.name;
            cstNode.offset = node.offset;
            cstNode.length = node.length;
            cstNode.startLine = node.range.start.line;
            cstNode.startColumn = node.range.start.character;
            cstNode.endLine = node.range.end.line;
            cstNode.endColumn = node.range.end.character;
        }
        return cstNode;
    }
    hydrate(result) {
        const node = result.value;
        const context = this.createHydrationContext(node);
        if ('$cstNode' in node) {
            this.hydrateCstNode(node.$cstNode, context);
        }
        return {
            lexerErrors: result.lexerErrors,
            lexerReport: result.lexerReport,
            parserErrors: result.parserErrors,
            value: this.hydrateAstNode(node, context)
        };
    }
    createHydrationContext(node) {
        const astNodes = new Map();
        const cstNodes = new Map();
        for (const astNode of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(node)) {
            astNodes.set(astNode, {});
        }
        let root;
        if (node.$cstNode) {
            for (const cstNode of (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.streamCst)(node.$cstNode)) {
                let cst;
                if ('fullText' in cstNode) {
                    cst = new _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__.RootCstNodeImpl(cstNode.fullText);
                    root = cst;
                }
                else if ('content' in cstNode) {
                    cst = new _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__.CompositeCstNodeImpl();
                }
                else if ('tokenType' in cstNode) {
                    cst = this.hydrateCstLeafNode(cstNode);
                }
                if (cst) {
                    cstNodes.set(cstNode, cst);
                    cst.root = root;
                }
            }
        }
        return {
            astNodes,
            cstNodes
        };
    }
    hydrateAstNode(node, context) {
        const astNode = context.astNodes.get(node);
        astNode.$type = node.$type;
        astNode.$containerIndex = node.$containerIndex;
        astNode.$containerProperty = node.$containerProperty;
        if (node.$cstNode) {
            astNode.$cstNode = context.cstNodes.get(node.$cstNode);
        }
        for (const [name, value] of Object.entries(node)) {
            if (name.startsWith('$')) {
                continue;
            }
            if (Array.isArray(value)) {
                const arr = [];
                astNode[name] = arr;
                for (const item of value) {
                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(item)) {
                        arr.push(this.setParent(this.hydrateAstNode(item, context), astNode));
                    }
                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(item)) {
                        arr.push(this.hydrateReference(item, astNode, name, context));
                    }
                    else {
                        arr.push(item);
                    }
                }
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isAstNode)(value)) {
                astNode[name] = this.setParent(this.hydrateAstNode(value, context), astNode);
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isReference)(value)) {
                astNode[name] = this.hydrateReference(value, astNode, name, context);
            }
            else if (value !== undefined) {
                astNode[name] = value;
            }
        }
        return astNode;
    }
    setParent(node, parent) {
        node.$container = parent;
        return node;
    }
    hydrateReference(reference, node, name, context) {
        return this.linker.buildReference(node, name, context.cstNodes.get(reference.$refNode), reference.$refText);
    }
    hydrateCstNode(cstNode, context, num = 0) {
        const cstNodeObj = context.cstNodes.get(cstNode);
        if (typeof cstNode.grammarSource === 'number') {
            cstNodeObj.grammarSource = this.getGrammarElement(cstNode.grammarSource);
        }
        cstNodeObj.astNode = context.astNodes.get(cstNode.astNode);
        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isCompositeCstNode)(cstNodeObj)) {
            for (const child of cstNode.content) {
                const hydrated = this.hydrateCstNode(child, context, num++);
                cstNodeObj.content.push(hydrated);
            }
        }
        return cstNodeObj;
    }
    hydrateCstLeafNode(cstNode) {
        const tokenType = this.getTokenType(cstNode.tokenType);
        const offset = cstNode.offset;
        const length = cstNode.length;
        const startLine = cstNode.startLine;
        const startColumn = cstNode.startColumn;
        const endLine = cstNode.endLine;
        const endColumn = cstNode.endColumn;
        const hidden = cstNode.hidden;
        const node = new _parser_cst_node_builder_js__WEBPACK_IMPORTED_MODULE_4__.LeafCstNodeImpl(offset, length, {
            start: {
                line: startLine,
                character: startColumn
            },
            end: {
                line: endLine,
                character: endColumn
            }
        }, tokenType, hidden);
        return node;
    }
    getTokenType(name) {
        return this.lexer.definition[name];
    }
    getGrammarElementId(node) {
        if (!node) {
            return undefined;
        }
        if (this.grammarElementIdMap.size === 0) {
            this.createGrammarElementIdMap();
        }
        return this.grammarElementIdMap.get(node);
    }
    getGrammarElement(id) {
        if (this.grammarElementIdMap.size === 0) {
            this.createGrammarElementIdMap();
        }
        const element = this.grammarElementIdMap.getKey(id);
        return element;
    }
    createGrammarElementIdMap() {
        let id = 0;
        for (const element of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAst)(this.grammar)) {
            if ((0,_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_5__.isAbstractElement)(element)) {
                this.grammarElementIdMap.set(element, id++);
            }
        }
    }
}
//# sourceMappingURL=hydrator.js.map

/***/ }),

/***/ "./node_modules/langium/lib/serializer/json-serializer.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/serializer/json-serializer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultJsonSerializer: () => (/* binding */ DefaultJsonSerializer),
/* harmony export */   isAstNodeWithComment: () => (/* binding */ isAstNodeWithComment)
/* harmony export */ });
/* harmony import */ var vscode_uri__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/esm/index.mjs");
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/




function isAstNodeWithComment(node) {
    return typeof node.$comment === 'string';
}
function isIntermediateReference(obj) {
    return typeof obj === 'object' && !!obj && ('$ref' in obj || '$error' in obj);
}
class DefaultJsonSerializer {
    constructor(services) {
        /** The set of AstNode properties to be ignored by the serializer. */
        this.ignoreProperties = new Set(['$container', '$containerProperty', '$containerIndex', '$document', '$cstNode']);
        this.langiumDocuments = services.shared.workspace.LangiumDocuments;
        this.astNodeLocator = services.workspace.AstNodeLocator;
        this.nameProvider = services.references.NameProvider;
        this.commentProvider = services.documentation.CommentProvider;
    }
    serialize(node, options) {
        const serializeOptions = options !== null && options !== void 0 ? options : {};
        const specificReplacer = options === null || options === void 0 ? void 0 : options.replacer;
        const defaultReplacer = (key, value) => this.replacer(key, value, serializeOptions);
        const replacer = specificReplacer ? (key, value) => specificReplacer(key, value, defaultReplacer) : defaultReplacer;
        try {
            this.currentDocument = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node);
            return JSON.stringify(node, replacer, options === null || options === void 0 ? void 0 : options.space);
        }
        finally {
            this.currentDocument = undefined;
        }
    }
    deserialize(content, options) {
        const deserializeOptions = options !== null && options !== void 0 ? options : {};
        const root = JSON.parse(content);
        this.linkNode(root, root, deserializeOptions);
        return root;
    }
    replacer(key, value, { refText, sourceText, textRegions, comments, uriConverter }) {
        var _a, _b, _c, _d;
        if (this.ignoreProperties.has(key)) {
            return undefined;
        }
        else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isReference)(value)) {
            const refValue = value.ref;
            const $refText = refText ? value.$refText : undefined;
            if (refValue) {
                const targetDocument = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(refValue);
                let targetUri = '';
                if (this.currentDocument && this.currentDocument !== targetDocument) {
                    if (uriConverter) {
                        targetUri = uriConverter(targetDocument.uri, value);
                    }
                    else {
                        targetUri = targetDocument.uri.toString();
                    }
                }
                const targetPath = this.astNodeLocator.getAstNodePath(refValue);
                return {
                    $ref: `${targetUri}#${targetPath}`,
                    $refText
                };
            }
            else {
                return {
                    $error: (_b = (_a = value.error) === null || _a === void 0 ? void 0 : _a.message) !== null && _b !== void 0 ? _b : 'Could not resolve reference',
                    $refText
                };
            }
        }
        else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(value)) {
            let astNode = undefined;
            if (textRegions) {
                astNode = this.addAstNodeRegionWithAssignmentsTo(Object.assign({}, value));
                if ((!key || value.$document) && (astNode === null || astNode === void 0 ? void 0 : astNode.$textRegion)) {
                    // The document URI is added to the root node of the resulting JSON tree
                    astNode.$textRegion.documentURI = (_c = this.currentDocument) === null || _c === void 0 ? void 0 : _c.uri.toString();
                }
            }
            if (sourceText && !key) {
                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));
                astNode.$sourceText = (_d = value.$cstNode) === null || _d === void 0 ? void 0 : _d.text;
            }
            if (comments) {
                astNode !== null && astNode !== void 0 ? astNode : (astNode = Object.assign({}, value));
                const comment = this.commentProvider.getComment(value);
                if (comment) {
                    astNode.$comment = comment.replace(/\r/g, '');
                }
            }
            return astNode !== null && astNode !== void 0 ? astNode : value;
        }
        else {
            return value;
        }
    }
    addAstNodeRegionWithAssignmentsTo(node) {
        const createDocumentSegment = cstNode => ({
            offset: cstNode.offset,
            end: cstNode.end,
            length: cstNode.length,
            range: cstNode.range,
        });
        if (node.$cstNode) {
            const textRegion = node.$textRegion = createDocumentSegment(node.$cstNode);
            const assignments = textRegion.assignments = {};
            Object.keys(node).filter(key => !key.startsWith('$')).forEach(key => {
                const propertyAssignments = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_2__.findNodesForProperty)(node.$cstNode, key).map(createDocumentSegment);
                if (propertyAssignments.length !== 0) {
                    assignments[key] = propertyAssignments;
                }
            });
            return node;
        }
        return undefined;
    }
    linkNode(node, root, options, container, containerProperty, containerIndex) {
        for (const [propertyName, item] of Object.entries(node)) {
            if (Array.isArray(item)) {
                for (let index = 0; index < item.length; index++) {
                    const element = item[index];
                    if (isIntermediateReference(element)) {
                        item[index] = this.reviveReference(node, propertyName, root, element, options);
                    }
                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(element)) {
                        this.linkNode(element, root, options, node, propertyName, index);
                    }
                }
            }
            else if (isIntermediateReference(item)) {
                node[propertyName] = this.reviveReference(node, propertyName, root, item, options);
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(item)) {
                this.linkNode(item, root, options, node, propertyName);
            }
        }
        const mutable = node;
        mutable.$container = container;
        mutable.$containerProperty = containerProperty;
        mutable.$containerIndex = containerIndex;
    }
    reviveReference(container, property, root, reference, options) {
        let refText = reference.$refText;
        let error = reference.$error;
        if (reference.$ref) {
            const ref = this.getRefNode(root, reference.$ref, options.uriConverter);
            if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isAstNode)(ref)) {
                if (!refText) {
                    refText = this.nameProvider.getName(ref);
                }
                return {
                    $refText: refText !== null && refText !== void 0 ? refText : '',
                    ref
                };
            }
            else {
                error = ref;
            }
        }
        if (error) {
            const ref = {
                $refText: refText !== null && refText !== void 0 ? refText : ''
            };
            ref.error = {
                container,
                property,
                message: error,
                reference: ref
            };
            return ref;
        }
        else {
            return undefined;
        }
    }
    getRefNode(root, uri, uriConverter) {
        try {
            const fragmentIndex = uri.indexOf('#');
            if (fragmentIndex === 0) {
                const node = this.astNodeLocator.getAstNode(root, uri.substring(1));
                if (!node) {
                    return 'Could not resolve path: ' + uri;
                }
                return node;
            }
            if (fragmentIndex < 0) {
                const documentUri = uriConverter ? uriConverter(uri) : vscode_uri__WEBPACK_IMPORTED_MODULE_3__.URI.parse(uri);
                const document = this.langiumDocuments.getDocument(documentUri);
                if (!document) {
                    return 'Could not find document for URI: ' + uri;
                }
                return document.parseResult.value;
            }
            const documentUri = uriConverter ? uriConverter(uri.substring(0, fragmentIndex)) : vscode_uri__WEBPACK_IMPORTED_MODULE_3__.URI.parse(uri.substring(0, fragmentIndex));
            const document = this.langiumDocuments.getDocument(documentUri);
            if (!document) {
                return 'Could not find document for URI: ' + uri;
            }
            if (fragmentIndex === uri.length - 1) {
                return document.parseResult.value;
            }
            const node = this.astNodeLocator.getAstNode(document.parseResult.value, uri.substring(fragmentIndex + 1));
            if (!node) {
                return 'Could not resolve URI: ' + uri;
            }
            return node;
        }
        catch (err) {
            return String(err);
        }
    }
}
//# sourceMappingURL=json-serializer.js.map

/***/ }),

/***/ "./node_modules/langium/lib/service-registry.js":
/*!******************************************************!*\
  !*** ./node_modules/langium/lib/service-registry.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultServiceRegistry: () => (/* binding */ DefaultServiceRegistry)
/* harmony export */ });
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/uri-utils.js */ "./node_modules/langium/lib/utils/uri-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Generic registry for Langium services, but capable of being used with extending service sets as well (such as the lsp-complete LangiumCoreServices set)
 */
class DefaultServiceRegistry {
    /**
     * @deprecated Use the new `fileExtensionMap` (or `languageIdMap`) property instead.
     */
    get map() {
        return this.fileExtensionMap;
    }
    constructor(services) {
        this.languageIdMap = new Map();
        this.fileExtensionMap = new Map();
        this.textDocuments = services === null || services === void 0 ? void 0 : services.workspace.TextDocuments;
    }
    register(language) {
        const data = language.LanguageMetaData;
        for (const ext of data.fileExtensions) {
            if (this.fileExtensionMap.has(ext)) {
                console.warn(`The file extension ${ext} is used by multiple languages. It is now assigned to '${data.languageId}'.`);
            }
            this.fileExtensionMap.set(ext, language);
        }
        this.languageIdMap.set(data.languageId, language);
        if (this.languageIdMap.size === 1) {
            this.singleton = language;
        }
        else {
            this.singleton = undefined;
        }
    }
    getServices(uri) {
        var _a, _b;
        if (this.singleton !== undefined) {
            return this.singleton;
        }
        if (this.languageIdMap.size === 0) {
            throw new Error('The service registry is empty. Use `register` to register the services of a language.');
        }
        const languageId = (_b = (_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(uri)) === null || _b === void 0 ? void 0 : _b.languageId;
        if (languageId !== undefined) {
            const services = this.languageIdMap.get(languageId);
            if (services) {
                return services;
            }
        }
        const ext = _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_0__.UriUtils.extname(uri);
        const services = this.fileExtensionMap.get(ext);
        if (!services) {
            if (languageId) {
                throw new Error(`The service registry contains no services for the extension '${ext}' for language '${languageId}'.`);
            }
            else {
                throw new Error(`The service registry contains no services for the extension '${ext}'.`);
            }
        }
        return services;
    }
    hasServices(uri) {
        try {
            this.getServices(uri);
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    get all() {
        return Array.from(this.languageIdMap.values());
    }
}
//# sourceMappingURL=service-registry.js.map

/***/ }),

/***/ "./node_modules/langium/lib/syntax-tree.js":
/*!*************************************************!*\
  !*** ./node_modules/langium/lib/syntax-tree.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AbstractAstReflection: () => (/* binding */ AbstractAstReflection),
/* harmony export */   isAstNode: () => (/* binding */ isAstNode),
/* harmony export */   isAstNodeDescription: () => (/* binding */ isAstNodeDescription),
/* harmony export */   isCompositeCstNode: () => (/* binding */ isCompositeCstNode),
/* harmony export */   isLeafCstNode: () => (/* binding */ isLeafCstNode),
/* harmony export */   isLinkingError: () => (/* binding */ isLinkingError),
/* harmony export */   isReference: () => (/* binding */ isReference),
/* harmony export */   isRootCstNode: () => (/* binding */ isRootCstNode)
/* harmony export */ });
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
function isAstNode(obj) {
    return typeof obj === 'object' && obj !== null && typeof obj.$type === 'string';
}
function isReference(obj) {
    return typeof obj === 'object' && obj !== null && typeof obj.$refText === 'string';
}
function isAstNodeDescription(obj) {
    return typeof obj === 'object' && obj !== null
        && typeof obj.name === 'string'
        && typeof obj.type === 'string'
        && typeof obj.path === 'string';
}
function isLinkingError(obj) {
    return typeof obj === 'object' && obj !== null
        && isAstNode(obj.container)
        && isReference(obj.reference)
        && typeof obj.message === 'string';
}
/**
 * An abstract implementation of the {@link AstReflection} interface.
 * Serves to cache subtype computation results to improve performance throughout different parts of Langium.
 */
class AbstractAstReflection {
    constructor() {
        this.subtypes = {};
        this.allSubtypes = {};
    }
    isInstance(node, type) {
        return isAstNode(node) && this.isSubtype(node.$type, type);
    }
    isSubtype(subtype, supertype) {
        if (subtype === supertype) {
            return true;
        }
        let nested = this.subtypes[subtype];
        if (!nested) {
            nested = this.subtypes[subtype] = {};
        }
        const existing = nested[supertype];
        if (existing !== undefined) {
            return existing;
        }
        else {
            const result = this.computeIsSubtype(subtype, supertype);
            nested[supertype] = result;
            return result;
        }
    }
    getAllSubTypes(type) {
        const existing = this.allSubtypes[type];
        if (existing) {
            return existing;
        }
        else {
            const allTypes = this.getAllTypes();
            const types = [];
            for (const possibleSubType of allTypes) {
                if (this.isSubtype(possibleSubType, type)) {
                    types.push(possibleSubType);
                }
            }
            this.allSubtypes[type] = types;
            return types;
        }
    }
}
function isCompositeCstNode(node) {
    return typeof node === 'object' && node !== null && Array.isArray(node.content);
}
function isLeafCstNode(node) {
    return typeof node === 'object' && node !== null && typeof node.tokenType === 'object';
}
function isRootCstNode(node) {
    return isCompositeCstNode(node) && typeof node.fullText === 'string';
}
//# sourceMappingURL=syntax-tree.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/ast-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/langium/lib/utils/ast-utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   assignMandatoryProperties: () => (/* binding */ assignMandatoryProperties),
/* harmony export */   copyAstNode: () => (/* binding */ copyAstNode),
/* harmony export */   findLocalReferences: () => (/* binding */ findLocalReferences),
/* harmony export */   findRootNode: () => (/* binding */ findRootNode),
/* harmony export */   getContainerOfType: () => (/* binding */ getContainerOfType),
/* harmony export */   getDocument: () => (/* binding */ getDocument),
/* harmony export */   hasContainerOfType: () => (/* binding */ hasContainerOfType),
/* harmony export */   linkContentToContainer: () => (/* binding */ linkContentToContainer),
/* harmony export */   streamAllContents: () => (/* binding */ streamAllContents),
/* harmony export */   streamAst: () => (/* binding */ streamAst),
/* harmony export */   streamContents: () => (/* binding */ streamContents),
/* harmony export */   streamReferences: () => (/* binding */ streamReferences)
/* harmony export */ });
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/



/**
 * Link the `$container` and other related properties of every AST node that is directly contained
 * in the given `node`.
 */
function linkContentToContainer(node) {
    for (const [name, value] of Object.entries(node)) {
        if (!name.startsWith('$')) {
            if (Array.isArray(value)) {
                value.forEach((item, index) => {
                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(item)) {
                        item.$container = node;
                        item.$containerProperty = name;
                        item.$containerIndex = index;
                    }
                });
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(value)) {
                value.$container = node;
                value.$containerProperty = name;
            }
        }
    }
}
/**
 * Walk along the hierarchy of containers from the given AST node to the root and return the first
 * node that matches the type predicate. If the start node itself matches, it is returned.
 * If no container matches, `undefined` is returned.
 */
function getContainerOfType(node, typePredicate) {
    let item = node;
    while (item) {
        if (typePredicate(item)) {
            return item;
        }
        item = item.$container;
    }
    return undefined;
}
/**
 * Walk along the hierarchy of containers from the given AST node to the root and check for existence
 * of a container that matches the given predicate. The start node is included in the checks.
 */
function hasContainerOfType(node, predicate) {
    let item = node;
    while (item) {
        if (predicate(item)) {
            return true;
        }
        item = item.$container;
    }
    return false;
}
/**
 * Retrieve the document in which the given AST node is contained. A reference to the document is
 * usually held by the root node of the AST.
 *
 * @throws an error if the node is not contained in a document.
 */
function getDocument(node) {
    const rootNode = findRootNode(node);
    const result = rootNode.$document;
    if (!result) {
        throw new Error('AST node has no document.');
    }
    return result;
}
/**
 * Returns the root node of the given AST node by following the `$container` references.
 */
function findRootNode(node) {
    while (node.$container) {
        node = node.$container;
    }
    return node;
}
/**
 * Create a stream of all AST nodes that are directly contained in the given node. This includes
 * single-valued as well as multi-valued (array) properties.
 */
function streamContents(node, options) {
    if (!node) {
        throw new Error('Node must be an AstNode.');
    }
    const range = options === null || options === void 0 ? void 0 : options.range;
    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.StreamImpl(() => ({
        keys: Object.keys(node),
        keyIndex: 0,
        arrayIndex: 0
    }), state => {
        while (state.keyIndex < state.keys.length) {
            const property = state.keys[state.keyIndex];
            if (!property.startsWith('$')) {
                const value = node[property];
                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(value)) {
                    state.keyIndex++;
                    if (isAstNodeInRange(value, range)) {
                        return { done: false, value };
                    }
                }
                else if (Array.isArray(value)) {
                    while (state.arrayIndex < value.length) {
                        const index = state.arrayIndex++;
                        const element = value[index];
                        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(element) && isAstNodeInRange(element, range)) {
                            return { done: false, value: element };
                        }
                    }
                    state.arrayIndex = 0;
                }
            }
            state.keyIndex++;
        }
        return _stream_js__WEBPACK_IMPORTED_MODULE_1__.DONE_RESULT;
    });
}
/**
 * Create a stream of all AST nodes that are directly and indirectly contained in the given root node.
 * This does not include the root node itself.
 */
function streamAllContents(root, options) {
    if (!root) {
        throw new Error('Root node must be an AstNode.');
    }
    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.TreeStreamImpl(root, node => streamContents(node, options));
}
/**
 * Create a stream of all AST nodes that are directly and indirectly contained in the given root node,
 * including the root node itself.
 */
function streamAst(root, options) {
    if (!root) {
        throw new Error('Root node must be an AstNode.');
    }
    else if ((options === null || options === void 0 ? void 0 : options.range) && !isAstNodeInRange(root, options.range)) {
        // Return an empty stream if the root node isn't in range
        return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.TreeStreamImpl(root, () => []);
    }
    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.TreeStreamImpl(root, node => streamContents(node, options), { includeRoot: true });
}
function isAstNodeInRange(astNode, range) {
    var _a;
    if (!range) {
        return true;
    }
    const nodeRange = (_a = astNode.$cstNode) === null || _a === void 0 ? void 0 : _a.range;
    if (!nodeRange) {
        return false;
    }
    return (0,_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.inRange)(nodeRange, range);
}
/**
 * Create a stream of all cross-references that are held by the given AST node. This includes
 * single-valued as well as multi-valued (array) properties.
 */
function streamReferences(node) {
    return new _stream_js__WEBPACK_IMPORTED_MODULE_1__.StreamImpl(() => ({
        keys: Object.keys(node),
        keyIndex: 0,
        arrayIndex: 0
    }), state => {
        while (state.keyIndex < state.keys.length) {
            const property = state.keys[state.keyIndex];
            if (!property.startsWith('$')) {
                const value = node[property];
                if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(value)) {
                    state.keyIndex++;
                    return { done: false, value: { reference: value, container: node, property } };
                }
                else if (Array.isArray(value)) {
                    while (state.arrayIndex < value.length) {
                        const index = state.arrayIndex++;
                        const element = value[index];
                        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(element)) {
                            return { done: false, value: { reference: element, container: node, property, index } };
                        }
                    }
                    state.arrayIndex = 0;
                }
            }
            state.keyIndex++;
        }
        return _stream_js__WEBPACK_IMPORTED_MODULE_1__.DONE_RESULT;
    });
}
/**
 * Returns a Stream of references to the target node from the AstNode tree
 *
 * @param targetNode AstNode we are looking for
 * @param lookup AstNode where we search for references. If not provided, the root node of the document is used as the default value
 */
function findLocalReferences(targetNode, lookup = getDocument(targetNode).parseResult.value) {
    const refs = [];
    streamAst(lookup).forEach(node => {
        streamReferences(node).forEach(refInfo => {
            if (refInfo.reference.ref === targetNode) {
                refs.push(refInfo.reference);
            }
        });
    });
    return (0,_stream_js__WEBPACK_IMPORTED_MODULE_1__.stream)(refs);
}
/**
 * Assigns all mandatory AST properties to the specified node.
 *
 * @param reflection Reflection object used to gather mandatory properties for the node.
 * @param node Specified node is modified in place and properties are directly assigned.
 */
function assignMandatoryProperties(reflection, node) {
    const typeMetaData = reflection.getTypeMetaData(node.$type);
    const genericNode = node;
    for (const property of typeMetaData.properties) {
        // Only set the value if the property is not already set and if it has a default value
        if (property.defaultValue !== undefined && genericNode[property.name] === undefined) {
            genericNode[property.name] = copyDefaultValue(property.defaultValue);
        }
    }
}
function copyDefaultValue(propertyType) {
    if (Array.isArray(propertyType)) {
        return [...propertyType.map(copyDefaultValue)];
    }
    else {
        return propertyType;
    }
}
/**
 * Creates a deep copy of the specified AST node.
 * The resulting copy will only contain semantically relevant information, such as the `$type` property and AST properties.
 *
 * References are copied without resolved cross reference. The specified function is used to rebuild them.
 */
function copyAstNode(node, buildReference) {
    const copy = { $type: node.$type };
    for (const [name, value] of Object.entries(node)) {
        if (!name.startsWith('$')) {
            if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(value)) {
                copy[name] = copyAstNode(value, buildReference);
            }
            else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(value)) {
                copy[name] = buildReference(copy, name, value.$refNode, value.$refText);
            }
            else if (Array.isArray(value)) {
                const copiedArray = [];
                for (const element of value) {
                    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isAstNode)(element)) {
                        copiedArray.push(copyAstNode(element, buildReference));
                    }
                    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_0__.isReference)(element)) {
                        copiedArray.push(buildReference(copy, name, element.$refNode, element.$refText));
                    }
                    else {
                        copiedArray.push(element);
                    }
                }
                copy[name] = copiedArray;
            }
            else {
                copy[name] = value;
            }
        }
    }
    linkContentToContainer(copy);
    return copy;
}
//# sourceMappingURL=ast-utils.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/caching.js":
/*!***************************************************!*\
  !*** ./node_modules/langium/lib/utils/caching.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ContextCache: () => (/* binding */ ContextCache),
/* harmony export */   DisposableCache: () => (/* binding */ DisposableCache),
/* harmony export */   DocumentCache: () => (/* binding */ DocumentCache),
/* harmony export */   SimpleCache: () => (/* binding */ SimpleCache),
/* harmony export */   WorkspaceCache: () => (/* binding */ WorkspaceCache)
/* harmony export */ });
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
class DisposableCache {
    constructor() {
        this.toDispose = [];
        this.isDisposed = false;
    }
    onDispose(disposable) {
        this.toDispose.push(disposable);
    }
    dispose() {
        this.throwIfDisposed();
        this.clear();
        this.isDisposed = true;
        this.toDispose.forEach(disposable => disposable.dispose());
    }
    throwIfDisposed() {
        if (this.isDisposed) {
            throw new Error('This cache has already been disposed');
        }
    }
}
class SimpleCache extends DisposableCache {
    constructor() {
        super(...arguments);
        this.cache = new Map();
    }
    has(key) {
        this.throwIfDisposed();
        return this.cache.has(key);
    }
    set(key, value) {
        this.throwIfDisposed();
        this.cache.set(key, value);
    }
    get(key, provider) {
        this.throwIfDisposed();
        if (this.cache.has(key)) {
            return this.cache.get(key);
        }
        else if (provider) {
            const value = provider();
            this.cache.set(key, value);
            return value;
        }
        else {
            return undefined;
        }
    }
    delete(key) {
        this.throwIfDisposed();
        return this.cache.delete(key);
    }
    clear() {
        this.throwIfDisposed();
        this.cache.clear();
    }
}
class ContextCache extends DisposableCache {
    constructor(converter) {
        super();
        this.cache = new Map();
        this.converter = converter !== null && converter !== void 0 ? converter : (value => value);
    }
    has(contextKey, key) {
        this.throwIfDisposed();
        return this.cacheForContext(contextKey).has(key);
    }
    set(contextKey, key, value) {
        this.throwIfDisposed();
        this.cacheForContext(contextKey).set(key, value);
    }
    get(contextKey, key, provider) {
        this.throwIfDisposed();
        const contextCache = this.cacheForContext(contextKey);
        if (contextCache.has(key)) {
            return contextCache.get(key);
        }
        else if (provider) {
            const value = provider();
            contextCache.set(key, value);
            return value;
        }
        else {
            return undefined;
        }
    }
    delete(contextKey, key) {
        this.throwIfDisposed();
        return this.cacheForContext(contextKey).delete(key);
    }
    clear(contextKey) {
        this.throwIfDisposed();
        if (contextKey) {
            const mapKey = this.converter(contextKey);
            this.cache.delete(mapKey);
        }
        else {
            this.cache.clear();
        }
    }
    cacheForContext(contextKey) {
        const mapKey = this.converter(contextKey);
        let documentCache = this.cache.get(mapKey);
        if (!documentCache) {
            documentCache = new Map();
            this.cache.set(mapKey, documentCache);
        }
        return documentCache;
    }
}
/**
 * Every key/value pair in this cache is scoped to a document.
 * If this document is changed or deleted, all associated key/value pairs are deleted.
 */
class DocumentCache extends ContextCache {
    /**
     * Creates a new document cache.
     *
     * @param sharedServices Service container instance to hook into document lifecycle events.
     * @param state Optional document state on which the cache should evict.
     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
     * *Deleted* documents are considered in both cases.
     *
     * Providing a state here will use `DocumentBuilder#onDocumentPhase` instead,
     * which triggers on all documents that have been affected by this change, assuming that the
     * state is `DocumentState.Linked` or a later state.
     */
    constructor(sharedServices, state) {
        super(uri => uri.toString());
        if (state) {
            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onDocumentPhase(state, document => {
                this.clear(document.uri.toString());
            }));
            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {
                for (const uri of deleted) { // react only on deleted documents
                    this.clear(uri);
                }
            }));
        }
        else {
            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((changed, deleted) => {
                const allUris = changed.concat(deleted); // react on both changed and deleted documents
                for (const uri of allUris) {
                    this.clear(uri);
                }
            }));
        }
    }
}
/**
 * Every key/value pair in this cache is scoped to the whole workspace.
 * If any document in the workspace is added, changed or deleted, the whole cache is evicted.
 */
class WorkspaceCache extends SimpleCache {
    /**
     * Creates a new workspace cache.
     *
     * @param sharedServices Service container instance to hook into document lifecycle events.
     * @param state Optional document state on which the cache should evict.
     * If not provided, the cache will evict on `DocumentBuilder#onUpdate`.
     * *Deleted* documents are considered in both cases.
     */
    constructor(sharedServices, state) {
        super();
        if (state) {
            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onBuildPhase(state, () => {
                this.clear();
            }));
            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate((_changed, deleted) => {
                if (deleted.length > 0) { // react only on deleted documents
                    this.clear();
                }
            }));
        }
        else {
            this.toDispose.push(sharedServices.workspace.DocumentBuilder.onUpdate(() => {
                this.clear();
            }));
        }
    }
}
//# sourceMappingURL=caching.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/collections.js":
/*!*******************************************************!*\
  !*** ./node_modules/langium/lib/utils/collections.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   BiMap: () => (/* binding */ BiMap),
/* harmony export */   MultiMap: () => (/* binding */ MultiMap)
/* harmony export */ });
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stream.js */ "./node_modules/langium/lib/utils/stream.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * A multimap is a variation of a Map that has potentially multiple values for every key.
 */
class MultiMap {
    constructor(elements) {
        this.map = new Map();
        if (elements) {
            for (const [key, value] of elements) {
                this.add(key, value);
            }
        }
    }
    /**
     * The total number of values in the multimap.
     */
    get size() {
        return _stream_js__WEBPACK_IMPORTED_MODULE_0__.Reduction.sum((0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.values()).map(a => a.length));
    }
    /**
     * Clear all entries in the multimap.
     */
    clear() {
        this.map.clear();
    }
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method deletes the specific key / value pair from the multimap.
     *  * Without a value, all values associated with the given key are deleted.
     *
     * @returns `true` if a value existed and has been removed, or `false` if the specified
     *     key / value does not exist.
     */
    delete(key, value) {
        if (value === undefined) {
            return this.map.delete(key);
        }
        else {
            const values = this.map.get(key);
            if (values) {
                const index = values.indexOf(value);
                if (index >= 0) {
                    if (values.length === 1) {
                        this.map.delete(key);
                    }
                    else {
                        values.splice(index, 1);
                    }
                    return true;
                }
            }
            return false;
        }
    }
    /**
     * Returns an array of all values associated with the given key. If no value exists,
     * an empty array is returned.
     *
     * _Note:_ The returned array is assumed not to be modified. Use the `set` method to add a
     * value and `delete` to remove a value from the multimap.
     */
    get(key) {
        var _a;
        return (_a = this.map.get(key)) !== null && _a !== void 0 ? _a : [];
    }
    /**
     * Operates differently depending on whether a `value` is given:
     *  * With a value, this method returns `true` if the specific key / value pair is present in the multimap.
     *  * Without a value, this method returns `true` if the given key is present in the multimap.
     */
    has(key, value) {
        if (value === undefined) {
            return this.map.has(key);
        }
        else {
            const values = this.map.get(key);
            if (values) {
                return values.indexOf(value) >= 0;
            }
            return false;
        }
    }
    /**
     * Add the given key / value pair to the multimap.
     */
    add(key, value) {
        if (this.map.has(key)) {
            this.map.get(key).push(value);
        }
        else {
            this.map.set(key, [value]);
        }
        return this;
    }
    /**
     * Add the given set of key / value pairs to the multimap.
     */
    addAll(key, values) {
        if (this.map.has(key)) {
            this.map.get(key).push(...values);
        }
        else {
            this.map.set(key, Array.from(values));
        }
        return this;
    }
    /**
     * Invokes the given callback function for every key / value pair in the multimap.
     */
    forEach(callbackfn) {
        this.map.forEach((array, key) => array.forEach(value => callbackfn(value, key, this)));
    }
    /**
     * Returns an iterator of key, value pairs for every entry in the map.
     */
    [Symbol.iterator]() {
        return this.entries().iterator();
    }
    /**
     * Returns a stream of key, value pairs for every entry in the map.
     */
    entries() {
        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.entries())
            .flatMap(([key, array]) => array.map(value => [key, value]));
    }
    /**
     * Returns a stream of keys in the map.
     */
    keys() {
        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.keys());
    }
    /**
     * Returns a stream of values in the map.
     */
    values() {
        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.values()).flat();
    }
    /**
     * Returns a stream of key, value set pairs for every key in the map.
     */
    entriesGroupedByKey() {
        return (0,_stream_js__WEBPACK_IMPORTED_MODULE_0__.stream)(this.map.entries());
    }
}
class BiMap {
    get size() {
        return this.map.size;
    }
    constructor(elements) {
        this.map = new Map();
        this.inverse = new Map();
        if (elements) {
            for (const [key, value] of elements) {
                this.set(key, value);
            }
        }
    }
    clear() {
        this.map.clear();
        this.inverse.clear();
    }
    set(key, value) {
        this.map.set(key, value);
        this.inverse.set(value, key);
        return this;
    }
    get(key) {
        return this.map.get(key);
    }
    getKey(value) {
        return this.inverse.get(value);
    }
    delete(key) {
        const value = this.map.get(key);
        if (value !== undefined) {
            this.map.delete(key);
            this.inverse.delete(value);
            return true;
        }
        return false;
    }
}
//# sourceMappingURL=collections.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/cst-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/langium/lib/utils/cst-utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultNameRegexp: () => (/* binding */ DefaultNameRegexp),
/* harmony export */   RangeComparison: () => (/* binding */ RangeComparison),
/* harmony export */   compareRange: () => (/* binding */ compareRange),
/* harmony export */   findCommentNode: () => (/* binding */ findCommentNode),
/* harmony export */   findDeclarationNodeAtOffset: () => (/* binding */ findDeclarationNodeAtOffset),
/* harmony export */   findLeafNodeAtOffset: () => (/* binding */ findLeafNodeAtOffset),
/* harmony export */   findLeafNodeBeforeOffset: () => (/* binding */ findLeafNodeBeforeOffset),
/* harmony export */   flattenCst: () => (/* binding */ flattenCst),
/* harmony export */   getInteriorNodes: () => (/* binding */ getInteriorNodes),
/* harmony export */   getNextNode: () => (/* binding */ getNextNode),
/* harmony export */   getPreviousNode: () => (/* binding */ getPreviousNode),
/* harmony export */   getStartlineNode: () => (/* binding */ getStartlineNode),
/* harmony export */   inRange: () => (/* binding */ inRange),
/* harmony export */   isChildNode: () => (/* binding */ isChildNode),
/* harmony export */   isCommentNode: () => (/* binding */ isCommentNode),
/* harmony export */   streamCst: () => (/* binding */ streamCst),
/* harmony export */   toDocumentSegment: () => (/* binding */ toDocumentSegment),
/* harmony export */   tokenToRange: () => (/* binding */ tokenToRange)
/* harmony export */ });
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./stream.js */ "./node_modules/langium/lib/utils/stream.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


/**
 * Create a stream of all CST nodes that are directly and indirectly contained in the given root node,
 * including the root node itself.
 */
function streamCst(node) {
    return new _stream_js__WEBPACK_IMPORTED_MODULE_0__.TreeStreamImpl(node, element => {
        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeCstNode)(element)) {
            return element.content;
        }
        else {
            return [];
        }
    }, { includeRoot: true });
}
/**
 * Create a stream of all leaf nodes that are directly and indirectly contained in the given root node.
 */
function flattenCst(node) {
    return streamCst(node).filter(_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode);
}
/**
 * Determines whether the specified cst node is a child of the specified parent node.
 */
function isChildNode(child, parent) {
    while (child.container) {
        child = child.container;
        if (child === parent) {
            return true;
        }
    }
    return false;
}
function tokenToRange(token) {
    // Chevrotain uses 1-based indices everywhere
    // So we subtract 1 from every value to align with the LSP
    return {
        start: {
            character: token.startColumn - 1,
            line: token.startLine - 1
        },
        end: {
            character: token.endColumn, // endColumn uses the correct index
            line: token.endLine - 1
        }
    };
}
function toDocumentSegment(node) {
    if (!node) {
        return undefined;
    }
    const { offset, end, range } = node;
    return {
        range,
        offset,
        end,
        length: end - offset
    };
}
var RangeComparison;
(function (RangeComparison) {
    RangeComparison[RangeComparison["Before"] = 0] = "Before";
    RangeComparison[RangeComparison["After"] = 1] = "After";
    RangeComparison[RangeComparison["OverlapFront"] = 2] = "OverlapFront";
    RangeComparison[RangeComparison["OverlapBack"] = 3] = "OverlapBack";
    RangeComparison[RangeComparison["Inside"] = 4] = "Inside";
    RangeComparison[RangeComparison["Outside"] = 5] = "Outside";
})(RangeComparison || (RangeComparison = {}));
function compareRange(range, to) {
    if (range.end.line < to.start.line || (range.end.line === to.start.line && range.end.character <= to.start.character)) {
        return RangeComparison.Before;
    }
    else if (range.start.line > to.end.line || (range.start.line === to.end.line && range.start.character >= to.end.character)) {
        return RangeComparison.After;
    }
    const startInside = range.start.line > to.start.line || (range.start.line === to.start.line && range.start.character >= to.start.character);
    const endInside = range.end.line < to.end.line || (range.end.line === to.end.line && range.end.character <= to.end.character);
    if (startInside && endInside) {
        return RangeComparison.Inside;
    }
    else if (startInside) {
        return RangeComparison.OverlapBack;
    }
    else if (endInside) {
        return RangeComparison.OverlapFront;
    }
    else {
        return RangeComparison.Outside;
    }
}
function inRange(range, to) {
    const comparison = compareRange(range, to);
    return comparison > RangeComparison.After;
}
// The \p{L} regex matches any unicode letter character, i.e. characters from non-english alphabets
// Together with \w it matches any kind of character which can commonly appear in IDs
const DefaultNameRegexp = /^[\w\p{L}]$/u;
/**
 * Performs `findLeafNodeAtOffset` with a minor difference: When encountering a character that matches the `nameRegexp` argument,
 * it will instead return the leaf node at the `offset - 1` position.
 *
 * For LSP services, users expect that the declaration of an element is available if the cursor is directly after the element.
 */
function findDeclarationNodeAtOffset(cstNode, offset, nameRegexp = DefaultNameRegexp) {
    if (cstNode) {
        if (offset > 0) {
            const localOffset = offset - cstNode.offset;
            const textAtOffset = cstNode.text.charAt(localOffset);
            if (!nameRegexp.test(textAtOffset)) {
                offset--;
            }
        }
        return findLeafNodeAtOffset(cstNode, offset);
    }
    return undefined;
}
function findCommentNode(cstNode, commentNames) {
    if (cstNode) {
        const previous = getPreviousNode(cstNode, true);
        if (previous && isCommentNode(previous, commentNames)) {
            return previous;
        }
        if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isRootCstNode)(cstNode)) {
            // Go from the first non-hidden node through all nodes in reverse order
            // We do this to find the comment node which directly precedes the root node
            const endIndex = cstNode.content.findIndex(e => !e.hidden);
            for (let i = endIndex - 1; i >= 0; i--) {
                const child = cstNode.content[i];
                if (isCommentNode(child, commentNames)) {
                    return child;
                }
            }
        }
    }
    return undefined;
}
function isCommentNode(cstNode, commentNames) {
    return (0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode)(cstNode) && commentNames.includes(cstNode.tokenType.name);
}
/**
 * Finds the leaf CST node at the specified 0-based string offset.
 * Note that the given offset will be within the range of the returned leaf node.
 *
 * If the offset does not point to a CST node (but just white space), this method will return `undefined`.
 *
 * @param node The CST node to search through.
 * @param offset The specified offset.
 * @returns The CST node at the specified offset.
 */
function findLeafNodeAtOffset(node, offset) {
    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode)(node)) {
        return node;
    }
    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeCstNode)(node)) {
        const searchResult = binarySearch(node, offset, false);
        if (searchResult) {
            return findLeafNodeAtOffset(searchResult, offset);
        }
    }
    return undefined;
}
/**
 * Finds the leaf CST node at the specified 0-based string offset.
 * If no CST node exists at the specified position, it will return the leaf node before it.
 *
 * If there is no leaf node before the specified offset, this method will return `undefined`.
 *
 * @param node The CST node to search through.
 * @param offset The specified offset.
 * @returns The CST node closest to the specified offset.
 */
function findLeafNodeBeforeOffset(node, offset) {
    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isLeafCstNode)(node)) {
        return node;
    }
    else if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_1__.isCompositeCstNode)(node)) {
        const searchResult = binarySearch(node, offset, true);
        if (searchResult) {
            return findLeafNodeBeforeOffset(searchResult, offset);
        }
    }
    return undefined;
}
function binarySearch(node, offset, closest) {
    let left = 0;
    let right = node.content.length - 1;
    let closestNode = undefined;
    while (left <= right) {
        const middle = Math.floor((left + right) / 2);
        const middleNode = node.content[middle];
        if (middleNode.offset <= offset && middleNode.end > offset) {
            // Found an exact match
            return middleNode;
        }
        if (middleNode.end <= offset) {
            // Update the closest node (less than offset) and move to the right half
            closestNode = closest ? middleNode : undefined;
            left = middle + 1;
        }
        else {
            // Move to the left half
            right = middle - 1;
        }
    }
    return closestNode;
}
function getPreviousNode(node, hidden = true) {
    while (node.container) {
        const parent = node.container;
        let index = parent.content.indexOf(node);
        while (index > 0) {
            index--;
            const previous = parent.content[index];
            if (hidden || !previous.hidden) {
                return previous;
            }
        }
        node = parent;
    }
    return undefined;
}
function getNextNode(node, hidden = true) {
    while (node.container) {
        const parent = node.container;
        let index = parent.content.indexOf(node);
        const last = parent.content.length - 1;
        while (index < last) {
            index++;
            const next = parent.content[index];
            if (hidden || !next.hidden) {
                return next;
            }
        }
        node = parent;
    }
    return undefined;
}
function getStartlineNode(node) {
    if (node.range.start.character === 0) {
        return node;
    }
    const line = node.range.start.line;
    let last = node;
    let index;
    while (node.container) {
        const parent = node.container;
        const selfIndex = index !== null && index !== void 0 ? index : parent.content.indexOf(node);
        if (selfIndex === 0) {
            node = parent;
            index = undefined;
        }
        else {
            index = selfIndex - 1;
            node = parent.content[index];
        }
        if (node.range.start.line !== line) {
            break;
        }
        last = node;
    }
    return last;
}
function getInteriorNodes(start, end) {
    const commonParent = getCommonParent(start, end);
    if (!commonParent) {
        return [];
    }
    return commonParent.parent.content.slice(commonParent.a + 1, commonParent.b);
}
function getCommonParent(a, b) {
    const aParents = getParentChain(a);
    const bParents = getParentChain(b);
    let current;
    for (let i = 0; i < aParents.length && i < bParents.length; i++) {
        const aParent = aParents[i];
        const bParent = bParents[i];
        if (aParent.parent === bParent.parent) {
            current = {
                parent: aParent.parent,
                a: aParent.index,
                b: bParent.index
            };
        }
        else {
            break;
        }
    }
    return current;
}
function getParentChain(node) {
    const chain = [];
    while (node.container) {
        const parent = node.container;
        const index = parent.content.indexOf(node);
        chain.push({
            parent,
            index
        });
        node = parent;
    }
    return chain.reverse();
}
//# sourceMappingURL=cst-utils.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/disposable.js":
/*!******************************************************!*\
  !*** ./node_modules/langium/lib/utils/disposable.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Disposable: () => (/* binding */ Disposable)
/* harmony export */ });
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
var Disposable;
(function (Disposable) {
    function create(callback) {
        return {
            dispose: async () => await callback()
        };
    }
    Disposable.create = create;
})(Disposable || (Disposable = {}));
//# sourceMappingURL=disposable.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/langium/lib/utils/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ErrorWithLocation: () => (/* binding */ ErrorWithLocation),
/* harmony export */   assertUnreachable: () => (/* binding */ assertUnreachable)
/* harmony export */ });
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
class ErrorWithLocation extends Error {
    constructor(node, message) {
        super(node ? `${message} at ${node.range.start.line}:${node.range.start.character}` : message);
    }
}
function assertUnreachable(_) {
    throw new Error('Error! The input value was not handled.');
}
//# sourceMappingURL=errors.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/grammar-loader.js":
/*!**********************************************************!*\
  !*** ./node_modules/langium/lib/utils/grammar-loader.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   loadGrammarFromJson: () => (/* binding */ loadGrammarFromJson)
/* harmony export */ });
/* harmony import */ var _default_module_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../default-module.js */ "./node_modules/langium/lib/default-module.js");
/* harmony import */ var _dependency_injection_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../dependency-injection.js */ "./node_modules/langium/lib/dependency-injection.js");
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _workspace_file_system_provider_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../workspace/file-system-provider.js */ "./node_modules/langium/lib/workspace/file-system-provider.js");
/* harmony import */ var _uri_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./uri-utils.js */ "./node_modules/vscode-uri/lib/esm/index.mjs");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/





const minimalGrammarModule = {
    Grammar: () => undefined,
    LanguageMetaData: () => ({
        caseInsensitive: false,
        fileExtensions: ['.langium'],
        languageId: 'langium'
    })
};
const minimalSharedGrammarModule = {
    AstReflection: () => new _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.LangiumGrammarAstReflection()
};
function createMinimalGrammarServices() {
    const shared = (0,_dependency_injection_js__WEBPACK_IMPORTED_MODULE_1__.inject)((0,_default_module_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultSharedCoreModule)(_workspace_file_system_provider_js__WEBPACK_IMPORTED_MODULE_3__.EmptyFileSystem), minimalSharedGrammarModule);
    const grammar = (0,_dependency_injection_js__WEBPACK_IMPORTED_MODULE_1__.inject)((0,_default_module_js__WEBPACK_IMPORTED_MODULE_2__.createDefaultCoreModule)({ shared }), minimalGrammarModule);
    shared.ServiceRegistry.register(grammar);
    return grammar;
}
/**
 * Load a Langium grammar for your language from a JSON string. This is used by several services,
 * most notably the parser builder which interprets the grammar to create a parser.
 */
function loadGrammarFromJson(json) {
    var _a;
    const services = createMinimalGrammarServices();
    const astNode = services.serializer.JsonSerializer.deserialize(json);
    services.shared.workspace.LangiumDocumentFactory.fromModel(astNode, _uri_utils_js__WEBPACK_IMPORTED_MODULE_4__.URI.parse(`memory://${(_a = astNode.name) !== null && _a !== void 0 ? _a : 'grammar'}.langium`));
    return astNode;
}
//# sourceMappingURL=grammar-loader.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/grammar-utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/utils/grammar-utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   findAssignment: () => (/* binding */ findAssignment),
/* harmony export */   findNameAssignment: () => (/* binding */ findNameAssignment),
/* harmony export */   findNodeForKeyword: () => (/* binding */ findNodeForKeyword),
/* harmony export */   findNodeForProperty: () => (/* binding */ findNodeForProperty),
/* harmony export */   findNodesForKeyword: () => (/* binding */ findNodesForKeyword),
/* harmony export */   findNodesForKeywordInternal: () => (/* binding */ findNodesForKeywordInternal),
/* harmony export */   findNodesForProperty: () => (/* binding */ findNodesForProperty),
/* harmony export */   getActionAtElement: () => (/* binding */ getActionAtElement),
/* harmony export */   getActionType: () => (/* binding */ getActionType),
/* harmony export */   getAllReachableRules: () => (/* binding */ getAllReachableRules),
/* harmony export */   getCrossReferenceTerminal: () => (/* binding */ getCrossReferenceTerminal),
/* harmony export */   getEntryRule: () => (/* binding */ getEntryRule),
/* harmony export */   getExplicitRuleType: () => (/* binding */ getExplicitRuleType),
/* harmony export */   getHiddenRules: () => (/* binding */ getHiddenRules),
/* harmony export */   getRuleType: () => (/* binding */ getRuleType),
/* harmony export */   getRuleTypeName: () => (/* binding */ getRuleTypeName),
/* harmony export */   getTypeName: () => (/* binding */ getTypeName),
/* harmony export */   isArrayCardinality: () => (/* binding */ isArrayCardinality),
/* harmony export */   isArrayOperator: () => (/* binding */ isArrayOperator),
/* harmony export */   isCommentTerminal: () => (/* binding */ isCommentTerminal),
/* harmony export */   isDataType: () => (/* binding */ isDataType),
/* harmony export */   isDataTypeRule: () => (/* binding */ isDataTypeRule),
/* harmony export */   isOptionalCardinality: () => (/* binding */ isOptionalCardinality),
/* harmony export */   terminalRegex: () => (/* binding */ terminalRegex)
/* harmony export */ });
/* harmony import */ var _utils_errors_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/errors.js */ "./node_modules/langium/lib/utils/errors.js");
/* harmony import */ var _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../languages/generated/ast.js */ "./node_modules/langium/lib/languages/generated/ast.js");
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _cst_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/* harmony import */ var _regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./regexp-utils.js */ "./node_modules/langium/lib/utils/regexp-utils.js");
/******************************************************************************
 * Copyright 2021-2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






/**
 * Returns the entry rule of the given grammar, if any. If the grammar file does not contain an entry rule,
 * the result is `undefined`.
 */
function getEntryRule(grammar) {
    return grammar.rules.find(e => _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(e) && e.entry);
}
/**
 * Returns all hidden terminal rules of the given grammar, if any.
 */
function getHiddenRules(grammar) {
    return grammar.rules.filter((e) => _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(e) && e.hidden);
}
/**
 * Returns all rules that can be reached from the topmost rules of the specified grammar (entry and hidden terminal rules).
 *
 * @param grammar The grammar that contains all rules
 * @param allTerminals Whether or not to include terminals that are referenced only by other terminals
 * @returns A list of referenced parser and terminal rules. If the grammar contains no entry rule,
 *      this function returns all rules of the specified grammar.
 */
function getAllReachableRules(grammar, allTerminals) {
    const ruleNames = new Set();
    const entryRule = getEntryRule(grammar);
    if (!entryRule) {
        return new Set(grammar.rules);
    }
    const topMostRules = [entryRule].concat(getHiddenRules(grammar));
    for (const rule of topMostRules) {
        ruleDfs(rule, ruleNames, allTerminals);
    }
    const rules = new Set();
    for (const rule of grammar.rules) {
        if (ruleNames.has(rule.name) || (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(rule) && rule.hidden)) {
            rules.add(rule);
        }
    }
    return rules;
}
function ruleDfs(rule, visitedSet, allTerminals) {
    visitedSet.add(rule.name);
    (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(rule).forEach(node => {
        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall(node) || (allTerminals && _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRuleCall(node))) {
            const refRule = node.rule.ref;
            if (refRule && !visitedSet.has(refRule.name)) {
                ruleDfs(refRule, visitedSet, allTerminals);
            }
        }
    });
}
/**
 * Determines the grammar expression used to parse a cross-reference (usually a reference to a terminal rule).
 * A cross-reference can declare this expression explicitly in the form `[Type : Terminal]`, but if `Terminal`
 * is omitted, this function attempts to infer it from the name of the referenced `Type` (using `findNameAssignment`).
 *
 * Returns the grammar expression used to parse the given cross-reference, or `undefined` if it is not declared
 * and cannot be inferred.
 */
function getCrossReferenceTerminal(crossRef) {
    if (crossRef.terminal) {
        return crossRef.terminal;
    }
    else if (crossRef.type.ref) {
        const nameAssigment = findNameAssignment(crossRef.type.ref);
        return nameAssigment === null || nameAssigment === void 0 ? void 0 : nameAssigment.terminal;
    }
    return undefined;
}
/**
 * Determines whether the given terminal rule represents a comment. This is true if the rule is marked
 * as `hidden` and it does not match white space. This means every hidden token (i.e. excluded from the AST)
 * that contains visible characters is considered a comment.
 */
function isCommentTerminal(terminalRule) {
    return terminalRule.hidden && !(0,_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__.isWhitespace)(terminalRegex(terminalRule));
}
/**
 * Find all CST nodes within the given node that contribute to the specified property.
 *
 * @param node A CST node in which to look for property assignments. If this is undefined, the result is an empty array.
 * @param property A property name of the constructed AST node. If this is undefined, the result is an empty array.
 */
function findNodesForProperty(node, property) {
    if (!node || !property) {
        return [];
    }
    return findNodesForPropertyInternal(node, property, node.astNode, true);
}
/**
 * Find a single CST node within the given node that contributes to the specified property.
 *
 * @param node A CST node in which to look for property assignments. If this is undefined, the result is `undefined`.
 * @param property A property name of the constructed AST node. If this is undefined, the result is `undefined`.
 * @param index If no index is specified or the index is less than zero, the first found node is returned. If the
 *        specified index exceeds the number of assignments to the property, the last found node is returned. Otherwise,
 *        the node with the specified index is returned.
 */
function findNodeForProperty(node, property, index) {
    if (!node || !property) {
        return undefined;
    }
    const nodes = findNodesForPropertyInternal(node, property, node.astNode, true);
    if (nodes.length === 0) {
        return undefined;
    }
    if (index !== undefined) {
        index = Math.max(0, Math.min(index, nodes.length - 1));
    }
    else {
        index = 0;
    }
    return nodes[index];
}
function findNodesForPropertyInternal(node, property, element, first) {
    if (!first) {
        const nodeFeature = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getContainerOfType)(node.grammarSource, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment);
        if (nodeFeature && nodeFeature.feature === property) {
            return [node];
        }
    }
    if ((0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_3__.isCompositeCstNode)(node) && node.astNode === element) {
        return node.content.flatMap(e => findNodesForPropertyInternal(e, property, element, false));
    }
    return [];
}
/**
 * Find all CST nodes within the given node that correspond to the specified keyword.
 *
 * @param node A CST node in which to look for keywords. If this is undefined, the result is an empty array.
 * @param keyword A keyword as specified in the grammar.
 */
function findNodesForKeyword(node, keyword) {
    if (!node) {
        return [];
    }
    return findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);
}
/**
 * Find a single CST node within the given node that corresponds to the specified keyword.
 *
 * @param node A CST node in which to look for keywords. If this is undefined, the result is `undefined`.
 * @param keyword A keyword as specified in the grammar.
 * @param index If no index is specified or the index is less than zero, the first found node is returned. If the
 *        specified index exceeds the number of keyword occurrences, the last found node is returned. Otherwise,
 *        the node with the specified index is returned.
 */
function findNodeForKeyword(node, keyword, index) {
    if (!node) {
        return undefined;
    }
    const nodes = findNodesForKeywordInternal(node, keyword, node === null || node === void 0 ? void 0 : node.astNode);
    if (nodes.length === 0) {
        return undefined;
    }
    if (index !== undefined) {
        index = Math.max(0, Math.min(index, nodes.length - 1));
    }
    else {
        index = 0;
    }
    return nodes[index];
}
function findNodesForKeywordInternal(node, keyword, element) {
    if (node.astNode !== element) {
        return [];
    }
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isKeyword(node.grammarSource) && node.grammarSource.value === keyword) {
        return [node];
    }
    const treeIterator = (0,_cst_utils_js__WEBPACK_IMPORTED_MODULE_4__.streamCst)(node).iterator();
    let result;
    const keywordNodes = [];
    do {
        result = treeIterator.next();
        if (!result.done) {
            const childNode = result.value;
            if (childNode.astNode === element) {
                if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isKeyword(childNode.grammarSource) && childNode.grammarSource.value === keyword) {
                    keywordNodes.push(childNode);
                }
            }
            else {
                treeIterator.prune();
            }
        }
    } while (!result.done);
    return keywordNodes;
}
/**
 * If the given CST node was parsed in the context of a property assignment, the respective `Assignment` grammar
 * node is returned. If no assignment is found, the result is `undefined`.
 *
 * @param cstNode A CST node for which to find a property assignment.
 */
function findAssignment(cstNode) {
    var _a;
    const astNode = cstNode.astNode;
    // Only search until the ast node of the parent cst node is no longer the original ast node
    // This would make us jump to a preceding rule call, which contains only unrelated assignments
    while (astNode === ((_a = cstNode.container) === null || _a === void 0 ? void 0 : _a.astNode)) {
        const assignment = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getContainerOfType)(cstNode.grammarSource, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment);
        if (assignment) {
            return assignment;
        }
        cstNode = cstNode.container;
    }
    return undefined;
}
/**
 * Find an assignment to the `name` property for the given grammar type. This requires the `type` to be inferred
 * from a parser rule, and that rule must contain an assignment to the `name` property. In all other cases,
 * this function returns `undefined`.
 */
function findNameAssignment(type) {
    let startNode = type;
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInferredType(startNode)) {
        // for inferred types, the location to start searching for the name-assignment is different
        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(startNode.$container)) {
            // a type which is explicitly inferred by an action: investigate the sibbling of the Action node, i.e. start searching at the Action's parent
            startNode = startNode.$container.$container;
        }
        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(startNode.$container)) {
            // investigate the parser rule with the explicitly inferred type
            startNode = startNode.$container;
        }
        else {
            (0,_utils_errors_js__WEBPACK_IMPORTED_MODULE_5__.assertUnreachable)(startNode.$container);
        }
    }
    return findNameAssignmentInternal(type, startNode, new Map());
}
function findNameAssignmentInternal(type, startNode, cache) {
    var _a;
    // the cache is only required to prevent infinite loops
    function go(node, refType) {
        let childAssignment = undefined;
        const parentAssignment = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getContainerOfType)(node, _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment);
        // No parent assignment implies unassigned rule call
        if (!parentAssignment) {
            childAssignment = findNameAssignmentInternal(refType, refType, cache);
        }
        cache.set(type, childAssignment);
        return childAssignment;
    }
    if (cache.has(type)) {
        return cache.get(type);
    }
    cache.set(type, undefined);
    for (const node of (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(startNode)) {
        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment(node) && node.feature.toLowerCase() === 'name') {
            cache.set(type, node);
            return node;
        }
        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall(node) && _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(node.rule.ref)) {
            return go(node, node.rule.ref);
        }
        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isSimpleType(node) && ((_a = node.typeRef) === null || _a === void 0 ? void 0 : _a.ref)) {
            return go(node, node.typeRef.ref);
        }
    }
    return undefined;
}
function getActionAtElement(element) {
    const parent = element.$container;
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isGroup(parent)) {
        const elements = parent.elements;
        const index = elements.indexOf(element);
        for (let i = index - 1; i >= 0; i--) {
            const item = elements[i];
            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(item)) {
                return item;
            }
            else {
                const action = (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(elements[i]).find(_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction);
                if (action) {
                    return action;
                }
            }
        }
    }
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAbstractElement(parent)) {
        return getActionAtElement(parent);
    }
    else {
        return undefined;
    }
}
function isOptionalCardinality(cardinality, element) {
    return cardinality === '?' || cardinality === '*' || (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isGroup(element) && Boolean(element.guardCondition));
}
function isArrayCardinality(cardinality) {
    return cardinality === '*' || cardinality === '+';
}
function isArrayOperator(operator) {
    return operator === '+=';
}
/**
 * Determines whether the given parser rule is a _data type rule_, meaning that it has a
 * primitive return type like `number`, `boolean`, etc.
 */
function isDataTypeRule(rule) {
    return isDataTypeRuleInternal(rule, new Set());
}
function isDataTypeRuleInternal(rule, visited) {
    if (visited.has(rule)) {
        return true;
    }
    else {
        visited.add(rule);
    }
    for (const node of (0,_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.streamAllContents)(rule)) {
        if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRuleCall(node)) {
            if (!node.rule.ref) {
                // RuleCall to unresolved rule. Don't assume `rule` is a DataType rule.
                return false;
            }
            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(node.rule.ref) && !isDataTypeRuleInternal(node.rule.ref, visited)) {
                return false;
            }
        }
        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAssignment(node)) {
            return false;
        }
        else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(node)) {
            return false;
        }
    }
    return Boolean(rule.definition);
}
function isDataType(type) {
    return isDataTypeInternal(type.type, new Set());
}
function isDataTypeInternal(type, visited) {
    if (visited.has(type)) {
        return true;
    }
    else {
        visited.add(type);
    }
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isArrayType(type)) {
        return false;
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isReferenceType(type)) {
        return false;
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isUnionType(type)) {
        return type.types.every(e => isDataTypeInternal(e, visited));
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isSimpleType(type)) {
        if (type.primitiveType !== undefined) {
            return true;
        }
        else if (type.stringType !== undefined) {
            return true;
        }
        else if (type.typeRef !== undefined) {
            const ref = type.typeRef.ref;
            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isType(ref)) {
                return isDataTypeInternal(ref.type, visited);
            }
            else {
                return false;
            }
        }
        else {
            return false;
        }
    }
    else {
        return false;
    }
}
function getExplicitRuleType(rule) {
    if (rule.inferredType) {
        return rule.inferredType.name;
    }
    else if (rule.dataType) {
        return rule.dataType;
    }
    else if (rule.returnType) {
        const refType = rule.returnType.ref;
        if (refType) {
            // check if we need to check Action as return type
            if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(refType)) {
                return refType.name;
            }
            else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInterface(refType) || _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isType(refType)) {
                return refType.name;
            }
        }
    }
    return undefined;
}
function getTypeName(type) {
    var _a;
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isParserRule(type)) {
        return isDataTypeRule(type) ? type.name : (_a = getExplicitRuleType(type)) !== null && _a !== void 0 ? _a : type.name;
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInterface(type) || _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isType(type) || _languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isReturnType(type)) {
        return type.name;
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isAction(type)) {
        const actionType = getActionType(type);
        if (actionType) {
            return actionType;
        }
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isInferredType(type)) {
        return type.name;
    }
    throw new Error('Cannot get name of Unknown Type');
}
function getActionType(action) {
    var _a;
    if (action.inferredType) {
        return action.inferredType.name;
    }
    else if ((_a = action.type) === null || _a === void 0 ? void 0 : _a.ref) {
        return getTypeName(action.type.ref);
    }
    return undefined; // not inferring and not referencing a valid type
}
/**
 * This function is used at development time (for code generation and the internal type system) to get the type of the AST node produced by the given rule.
 * For data type rules, the name of the rule is returned,
 * e.g. "INT_value returns number: MY_INT;" returns "INT_value".
 * @param rule the given rule
 * @returns the name of the AST node type of the rule
 */
function getRuleTypeName(rule) {
    var _a, _b, _c;
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(rule)) {
        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';
    }
    else {
        return isDataTypeRule(rule) ? rule.name : (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;
    }
}
/**
 * This function is used at runtime to get the actual type of the values produced by the given rule at runtime.
 * For data type rules, the name of the declared return type of the rule is returned (if any),
 * e.g. "INT_value returns number: MY_INT;" returns "number".
 * @param rule the given rule
 * @returns the name of the type of the produced values of the rule at runtime
 */
function getRuleType(rule) {
    var _a, _b, _c;
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRule(rule)) {
        return (_b = (_a = rule.type) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : 'string';
    }
    else {
        return (_c = getExplicitRuleType(rule)) !== null && _c !== void 0 ? _c : rule.name;
    }
}
function terminalRegex(terminalRule) {
    const flags = {
        s: false,
        i: false,
        u: false
    };
    const source = abstractElementToRegex(terminalRule.definition, flags);
    const flagText = Object.entries(flags).filter(([, value]) => value).map(([name]) => name).join('');
    return new RegExp(source, flagText);
}
// Using [\s\S]* allows to match everything, compared to . which doesn't match line terminators
const WILDCARD = /[\s\S]/.source;
function abstractElementToRegex(element, flags) {
    if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalAlternatives(element)) {
        return terminalAlternativesToRegex(element);
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalGroup(element)) {
        return terminalGroupToRegex(element);
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isCharacterRange(element)) {
        return characterRangeToRegex(element);
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isTerminalRuleCall(element)) {
        const rule = element.rule.ref;
        if (!rule) {
            throw new Error('Missing rule reference.');
        }
        return withCardinality(abstractElementToRegex(rule.definition), {
            cardinality: element.cardinality,
            lookahead: element.lookahead
        });
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isNegatedToken(element)) {
        return negateTokenToRegex(element);
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isUntilToken(element)) {
        return untilTokenToRegex(element);
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isRegexToken(element)) {
        const lastSlash = element.regex.lastIndexOf('/');
        const source = element.regex.substring(1, lastSlash);
        const regexFlags = element.regex.substring(lastSlash + 1);
        if (flags) {
            flags.i = regexFlags.includes('i');
            flags.s = regexFlags.includes('s');
            flags.u = regexFlags.includes('u');
        }
        return withCardinality(source, {
            cardinality: element.cardinality,
            lookahead: element.lookahead,
            wrap: false
        });
    }
    else if (_languages_generated_ast_js__WEBPACK_IMPORTED_MODULE_0__.isWildcard(element)) {
        return withCardinality(WILDCARD, {
            cardinality: element.cardinality,
            lookahead: element.lookahead
        });
    }
    else {
        throw new Error(`Invalid terminal element: ${element === null || element === void 0 ? void 0 : element.$type}`);
    }
}
function terminalAlternativesToRegex(alternatives) {
    return withCardinality(alternatives.elements.map(e => abstractElementToRegex(e)).join('|'), {
        cardinality: alternatives.cardinality,
        lookahead: alternatives.lookahead
    });
}
function terminalGroupToRegex(group) {
    return withCardinality(group.elements.map(e => abstractElementToRegex(e)).join(''), {
        cardinality: group.cardinality,
        lookahead: group.lookahead
    });
}
function untilTokenToRegex(until) {
    return withCardinality(`${WILDCARD}*?${abstractElementToRegex(until.terminal)}`, {
        cardinality: until.cardinality,
        lookahead: until.lookahead
    });
}
function negateTokenToRegex(negate) {
    return withCardinality(`(?!${abstractElementToRegex(negate.terminal)})${WILDCARD}*?`, {
        cardinality: negate.cardinality,
        lookahead: negate.lookahead
    });
}
function characterRangeToRegex(range) {
    if (range.right) {
        return withCardinality(`[${keywordToRegex(range.left)}-${keywordToRegex(range.right)}]`, {
            cardinality: range.cardinality,
            lookahead: range.lookahead,
            wrap: false
        });
    }
    return withCardinality(keywordToRegex(range.left), {
        cardinality: range.cardinality,
        lookahead: range.lookahead,
        wrap: false
    });
}
function keywordToRegex(keyword) {
    return (0,_regexp_utils_js__WEBPACK_IMPORTED_MODULE_2__.escapeRegExp)(keyword.value);
}
function withCardinality(regex, options) {
    var _a;
    if (options.wrap !== false || options.lookahead) {
        regex = `(${(_a = options.lookahead) !== null && _a !== void 0 ? _a : ''}${regex})`;
    }
    if (options.cardinality) {
        return `${regex}${options.cardinality}`;
    }
    return regex;
}
//# sourceMappingURL=grammar-utils.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/promise-utils.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/utils/promise-utils.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Deferred: () => (/* binding */ Deferred),
/* harmony export */   OperationCancelled: () => (/* binding */ OperationCancelled),
/* harmony export */   delayNextTick: () => (/* binding */ delayNextTick),
/* harmony export */   interruptAndCheck: () => (/* binding */ interruptAndCheck),
/* harmony export */   isOperationCancelled: () => (/* binding */ isOperationCancelled),
/* harmony export */   setInterruptionPeriod: () => (/* binding */ setInterruptionPeriod),
/* harmony export */   startCancelableOperation: () => (/* binding */ startCancelableOperation)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

/**
 * Delays the execution of the current code to the next tick of the event loop.
 * Don't call this method directly in a tight loop to prevent too many promises from being created.
 */
function delayNextTick() {
    return new Promise(resolve => {
        // In case we are running in a non-node environment, `setImmediate` isn't available.
        // Using `setTimeout` of the browser API accomplishes the same result.
        if (typeof setImmediate === 'undefined') {
            setTimeout(resolve, 0);
        }
        else {
            setImmediate(resolve);
        }
    });
}
let lastTick = 0;
let globalInterruptionPeriod = 10;
/**
 * Reset the global interruption period and create a cancellation token source.
 */
function startCancelableOperation() {
    lastTick = performance.now();
    return new _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
}
/**
 * Change the period duration for `interruptAndCheck` to the given number of milliseconds.
 * The default value is 10ms.
 */
function setInterruptionPeriod(period) {
    globalInterruptionPeriod = period;
}
/**
 * This symbol may be thrown in an asynchronous context by any Langium service that receives
 * a `CancellationToken`. This means that the promise returned by such a service is rejected with
 * this symbol as rejection reason.
 */
const OperationCancelled = Symbol('OperationCancelled');
/**
 * Use this in a `catch` block to check whether the thrown object indicates that the operation
 * has been cancelled.
 */
function isOperationCancelled(err) {
    return err === OperationCancelled;
}
/**
 * This function does two things:
 *  1. Check the elapsed time since the last call to this function or to `startCancelableOperation`. If the predefined
 *     period (configured with `setInterruptionPeriod`) is exceeded, execution is delayed with `delayNextTick`.
 *  2. If the predefined period is not met yet or execution is resumed after an interruption, the given cancellation
 *     token is checked, and if cancellation is requested, `OperationCanceled` is thrown.
 *
 * All services in Langium that receive a `CancellationToken` may potentially call this function, so the
 * `CancellationToken` must be caught (with an `async` try-catch block or a `catch` callback attached to
 * the promise) to avoid that event being exposed as an error.
 */
async function interruptAndCheck(token) {
    if (token === _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        // Early exit in case cancellation was disabled by the caller
        return;
    }
    const current = performance.now();
    if (current - lastTick >= globalInterruptionPeriod) {
        lastTick = current;
        await delayNextTick();
        // prevent calling delayNextTick every iteration of loop
        // where delayNextTick takes up the majority or all of the
        // globalInterruptionPeriod itself
        lastTick = performance.now();
    }
    if (token.isCancellationRequested) {
        throw OperationCancelled;
    }
}
/**
 * Simple implementation of the deferred pattern.
 * An object that exposes a promise and functions to resolve and reject it.
 */
class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = (arg) => {
                resolve(arg);
                return this;
            };
            this.reject = (err) => {
                reject(err);
                return this;
            };
        });
    }
}
//# sourceMappingURL=promise-utils.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/regexp-utils.js":
/*!********************************************************!*\
  !*** ./node_modules/langium/lib/utils/regexp-utils.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   NEWLINE_REGEXP: () => (/* binding */ NEWLINE_REGEXP),
/* harmony export */   escapeRegExp: () => (/* binding */ escapeRegExp),
/* harmony export */   getCaseInsensitivePattern: () => (/* binding */ getCaseInsensitivePattern),
/* harmony export */   getTerminalParts: () => (/* binding */ getTerminalParts),
/* harmony export */   isMultilineComment: () => (/* binding */ isMultilineComment),
/* harmony export */   isWhitespace: () => (/* binding */ isWhitespace),
/* harmony export */   partialMatches: () => (/* binding */ partialMatches),
/* harmony export */   partialRegExp: () => (/* binding */ partialRegExp),
/* harmony export */   whitespaceCharacters: () => (/* binding */ whitespaceCharacters)
/* harmony export */ });
/* harmony import */ var _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @chevrotain/regexp-to-ast */ "./node_modules/@chevrotain/regexp-to-ast/lib/src/api.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/

const NEWLINE_REGEXP = /\r?\n/gm;
const regexpParser = new _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.RegExpParser();
/**
 * This class is in charge of heuristically identifying start/end tokens of terminals.
 *
 * The way this works is by doing the following:
 * 1. Traverse the regular expression in the "start state"
 * 2. Add any encountered sets/single characters to the "start regexp"
 * 3. Once we encounter any variable-length content (i.e. with quantifiers such as +/?/*), we enter the "end state"
 * 4. In the end state, any sets/single characters are added to an "end stack".
 * 5. If we re-encounter any variable-length content we reset the end stack
 * 6. We continue visiting the regex until the end, reseting the end stack and rebuilding it as necessary
 *
 * After traversing a regular expression the `startRegexp/endRegexp` properties allow access to the stored start/end of the terminal
 */
class TerminalRegExpVisitor extends _chevrotain_regexp_to_ast__WEBPACK_IMPORTED_MODULE_0__.BaseRegExpVisitor {
    constructor() {
        super(...arguments);
        this.isStarting = true;
        this.endRegexpStack = [];
        this.multiline = false;
    }
    get endRegex() {
        return this.endRegexpStack.join('');
    }
    reset(regex) {
        this.multiline = false;
        this.regex = regex;
        this.startRegexp = '';
        this.isStarting = true;
        this.endRegexpStack = [];
    }
    visitGroup(node) {
        if (node.quantifier) {
            this.isStarting = false;
            this.endRegexpStack = [];
        }
    }
    visitCharacter(node) {
        const char = String.fromCharCode(node.value);
        if (!this.multiline && char === '\n') {
            this.multiline = true;
        }
        if (node.quantifier) {
            this.isStarting = false;
            this.endRegexpStack = [];
        }
        else {
            const escapedChar = escapeRegExp(char);
            this.endRegexpStack.push(escapedChar);
            if (this.isStarting) {
                this.startRegexp += escapedChar;
            }
        }
    }
    visitSet(node) {
        if (!this.multiline) {
            const set = this.regex.substring(node.loc.begin, node.loc.end);
            const regex = new RegExp(set);
            this.multiline = Boolean('\n'.match(regex));
        }
        if (node.quantifier) {
            this.isStarting = false;
            this.endRegexpStack = [];
        }
        else {
            const set = this.regex.substring(node.loc.begin, node.loc.end);
            this.endRegexpStack.push(set);
            if (this.isStarting) {
                this.startRegexp += set;
            }
        }
    }
    visitChildren(node) {
        if (node.type === 'Group') {
            // Ignore children of groups with quantifier (+/*/?)
            // These groups are unrelated to start/end tokens of terminals
            const group = node;
            if (group.quantifier) {
                return;
            }
        }
        super.visitChildren(node);
    }
}
const visitor = new TerminalRegExpVisitor();
function getTerminalParts(regexp) {
    try {
        if (typeof regexp !== 'string') {
            regexp = regexp.source;
        }
        regexp = `/${regexp}/`;
        const pattern = regexpParser.pattern(regexp);
        const parts = [];
        for (const alternative of pattern.value.value) {
            visitor.reset(regexp);
            visitor.visit(alternative);
            parts.push({
                start: visitor.startRegexp,
                end: visitor.endRegex
            });
        }
        return parts;
    }
    catch (_a) {
        return [];
    }
}
function isMultilineComment(regexp) {
    try {
        if (typeof regexp === 'string') {
            regexp = new RegExp(regexp);
        }
        regexp = regexp.toString();
        visitor.reset(regexp);
        // Parsing the pattern might fail (since it's user code)
        visitor.visit(regexpParser.pattern(regexp));
        return visitor.multiline;
    }
    catch (_a) {
        return false;
    }
}
/**
 * A set of all characters that are considered whitespace by the '\s' RegExp character class.
 * Taken from [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_expressions/Character_classes).
 */
const whitespaceCharacters = ('\f\n\r\t\v\u0020\u00a0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007' +
    '\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000\ufeff').split('');
function isWhitespace(value) {
    const regexp = typeof value === 'string' ? new RegExp(value) : value;
    return whitespaceCharacters.some((ws) => regexp.test(ws));
}
function escapeRegExp(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
function getCaseInsensitivePattern(keyword) {
    return Array.prototype.map.call(keyword, letter => /\w/.test(letter) ? `[${letter.toLowerCase()}${letter.toUpperCase()}]` : escapeRegExp(letter)).join('');
}
/**
 * Determines whether the given input has a partial match with the specified regex.
 * @param regex The regex to partially match against
 * @param input The input string
 * @returns Whether any match exists.
 */
function partialMatches(regex, input) {
    const partial = partialRegExp(regex);
    const match = input.match(partial);
    return !!match && match[0].length > 0;
}
/**
 * Builds a partial regex from the input regex. A partial regex is able to match incomplete input strings. E.g.
 * a partial regex constructed from `/ab/` is able to match the string `a` without needing a following `b` character. However it won't match `b` alone.
 * @param regex The input regex to be converted.
 * @returns A partial regex constructed from the input regex.
 */
function partialRegExp(regex) {
    if (typeof regex === 'string') {
        regex = new RegExp(regex);
    }
    const re = regex, source = regex.source;
    let i = 0;
    function process() {
        let result = '', tmp;
        function appendRaw(nbChars) {
            result += source.substr(i, nbChars);
            i += nbChars;
        }
        function appendOptional(nbChars) {
            result += '(?:' + source.substr(i, nbChars) + '|$)';
            i += nbChars;
        }
        while (i < source.length) {
            switch (source[i]) {
                case '\\':
                    switch (source[i + 1]) {
                        case 'c':
                            appendOptional(3);
                            break;
                        case 'x':
                            appendOptional(4);
                            break;
                        case 'u':
                            if (re.unicode) {
                                if (source[i + 2] === '{') {
                                    appendOptional(source.indexOf('}', i) - i + 1);
                                }
                                else {
                                    appendOptional(6);
                                }
                            }
                            else {
                                appendOptional(2);
                            }
                            break;
                        case 'p':
                        case 'P':
                            if (re.unicode) {
                                appendOptional(source.indexOf('}', i) - i + 1);
                            }
                            else {
                                appendOptional(2);
                            }
                            break;
                        case 'k':
                            appendOptional(source.indexOf('>', i) - i + 1);
                            break;
                        default:
                            appendOptional(2);
                            break;
                    }
                    break;
                case '[':
                    tmp = /\[(?:\\.|.)*?\]/g;
                    tmp.lastIndex = i;
                    tmp = tmp.exec(source) || [];
                    appendOptional(tmp[0].length);
                    break;
                case '|':
                case '^':
                case '$':
                case '*':
                case '+':
                case '?':
                    appendRaw(1);
                    break;
                case '{':
                    tmp = /\{\d+,?\d*\}/g;
                    tmp.lastIndex = i;
                    tmp = tmp.exec(source);
                    if (tmp) {
                        appendRaw(tmp[0].length);
                    }
                    else {
                        appendOptional(1);
                    }
                    break;
                case '(':
                    if (source[i + 1] === '?') {
                        switch (source[i + 2]) {
                            case ':':
                                result += '(?:';
                                i += 3;
                                result += process() + '|$)';
                                break;
                            case '=':
                                result += '(?=';
                                i += 3;
                                result += process() + ')';
                                break;
                            case '!':
                                tmp = i;
                                i += 3;
                                process();
                                result += source.substr(tmp, i - tmp);
                                break;
                            case '<':
                                switch (source[i + 3]) {
                                    case '=':
                                    case '!':
                                        tmp = i;
                                        i += 4;
                                        process();
                                        result += source.substr(tmp, i - tmp);
                                        break;
                                    default:
                                        appendRaw(source.indexOf('>', i) - i + 1);
                                        result += process() + '|$)';
                                        break;
                                }
                                break;
                        }
                    }
                    else {
                        appendRaw(1);
                        result += process() + '|$)';
                    }
                    break;
                case ')':
                    ++i;
                    return result;
                default:
                    appendOptional(1);
                    break;
            }
        }
        return result;
    }
    return new RegExp(process(), regex.flags);
}
//# sourceMappingURL=regexp-utils.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/stream.js":
/*!**************************************************!*\
  !*** ./node_modules/langium/lib/utils/stream.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DONE_RESULT: () => (/* binding */ DONE_RESULT),
/* harmony export */   EMPTY_STREAM: () => (/* binding */ EMPTY_STREAM),
/* harmony export */   Reduction: () => (/* binding */ Reduction),
/* harmony export */   StreamImpl: () => (/* binding */ StreamImpl),
/* harmony export */   TreeStreamImpl: () => (/* binding */ TreeStreamImpl),
/* harmony export */   stream: () => (/* binding */ stream)
/* harmony export */ });
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * The default implementation of `Stream` works with two input functions:
 *  - The first function creates the initial state of an iteration.
 *  - The second function gets the current state as argument and returns an `IteratorResult`.
 */
class StreamImpl {
    constructor(startFn, nextFn) {
        this.startFn = startFn;
        this.nextFn = nextFn;
    }
    iterator() {
        const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            [Symbol.iterator]: () => iterator
        };
        return iterator;
    }
    [Symbol.iterator]() {
        return this.iterator();
    }
    isEmpty() {
        const iterator = this.iterator();
        return Boolean(iterator.next().done);
    }
    count() {
        const iterator = this.iterator();
        let count = 0;
        let next = iterator.next();
        while (!next.done) {
            count++;
            next = iterator.next();
        }
        return count;
    }
    toArray() {
        const result = [];
        const iterator = this.iterator();
        let next;
        do {
            next = iterator.next();
            if (next.value !== undefined) {
                result.push(next.value);
            }
        } while (!next.done);
        return result;
    }
    toSet() {
        return new Set(this);
    }
    toMap(keyFn, valueFn) {
        const entryStream = this.map(element => [
            keyFn ? keyFn(element) : element,
            valueFn ? valueFn(element) : element
        ]);
        return new Map(entryStream);
    }
    toString() {
        return this.join();
    }
    concat(other) {
        return new StreamImpl(() => ({ first: this.startFn(), firstDone: false, iterator: other[Symbol.iterator]() }), state => {
            let result;
            if (!state.firstDone) {
                do {
                    result = this.nextFn(state.first);
                    if (!result.done) {
                        return result;
                    }
                } while (!result.done);
                state.firstDone = true;
            }
            do {
                result = state.iterator.next();
                if (!result.done) {
                    return result;
                }
            } while (!result.done);
            return DONE_RESULT;
        });
    }
    join(separator = ',') {
        const iterator = this.iterator();
        let value = '';
        let result;
        let addSeparator = false;
        do {
            result = iterator.next();
            if (!result.done) {
                if (addSeparator) {
                    value += separator;
                }
                value += toString(result.value);
            }
            addSeparator = true;
        } while (!result.done);
        return value;
    }
    indexOf(searchElement, fromIndex = 0) {
        const iterator = this.iterator();
        let index = 0;
        let next = iterator.next();
        while (!next.done) {
            if (index >= fromIndex && next.value === searchElement) {
                return index;
            }
            next = iterator.next();
            index++;
        }
        return -1;
    }
    every(predicate) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
            if (!predicate(next.value)) {
                return false;
            }
            next = iterator.next();
        }
        return true;
    }
    some(predicate) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
            if (predicate(next.value)) {
                return true;
            }
            next = iterator.next();
        }
        return false;
    }
    forEach(callbackfn) {
        const iterator = this.iterator();
        let index = 0;
        let next = iterator.next();
        while (!next.done) {
            callbackfn(next.value, index);
            next = iterator.next();
            index++;
        }
    }
    map(callbackfn) {
        return new StreamImpl(this.startFn, (state) => {
            const { done, value } = this.nextFn(state);
            if (done) {
                return DONE_RESULT;
            }
            else {
                return { done: false, value: callbackfn(value) };
            }
        });
    }
    filter(predicate) {
        return new StreamImpl(this.startFn, state => {
            let result;
            do {
                result = this.nextFn(state);
                if (!result.done && predicate(result.value)) {
                    return result;
                }
            } while (!result.done);
            return DONE_RESULT;
        });
    }
    nonNullable() {
        return this.filter(e => e !== undefined && e !== null);
    }
    reduce(callbackfn, initialValue) {
        const iterator = this.iterator();
        let previousValue = initialValue;
        let next = iterator.next();
        while (!next.done) {
            if (previousValue === undefined) {
                previousValue = next.value;
            }
            else {
                previousValue = callbackfn(previousValue, next.value);
            }
            next = iterator.next();
        }
        return previousValue;
    }
    reduceRight(callbackfn, initialValue) {
        return this.recursiveReduce(this.iterator(), callbackfn, initialValue);
    }
    recursiveReduce(iterator, callbackfn, initialValue) {
        const next = iterator.next();
        if (next.done) {
            return initialValue;
        }
        const previousValue = this.recursiveReduce(iterator, callbackfn, initialValue);
        if (previousValue === undefined) {
            return next.value;
        }
        return callbackfn(previousValue, next.value);
    }
    find(predicate) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
            if (predicate(next.value)) {
                return next.value;
            }
            next = iterator.next();
        }
        return undefined;
    }
    findIndex(predicate) {
        const iterator = this.iterator();
        let index = 0;
        let next = iterator.next();
        while (!next.done) {
            if (predicate(next.value)) {
                return index;
            }
            next = iterator.next();
            index++;
        }
        return -1;
    }
    includes(searchElement) {
        const iterator = this.iterator();
        let next = iterator.next();
        while (!next.done) {
            if (next.value === searchElement) {
                return true;
            }
            next = iterator.next();
        }
        return false;
    }
    flatMap(callbackfn) {
        return new StreamImpl(() => ({ this: this.startFn() }), (state) => {
            do {
                if (state.iterator) {
                    const next = state.iterator.next();
                    if (next.done) {
                        state.iterator = undefined;
                    }
                    else {
                        return next;
                    }
                }
                const { done, value } = this.nextFn(state.this);
                if (!done) {
                    const mapped = callbackfn(value);
                    if (isIterable(mapped)) {
                        state.iterator = mapped[Symbol.iterator]();
                    }
                    else {
                        return { done: false, value: mapped };
                    }
                }
            } while (state.iterator);
            return DONE_RESULT;
        });
    }
    flat(depth) {
        if (depth === undefined) {
            depth = 1;
        }
        if (depth <= 0) {
            return this;
        }
        const stream = depth > 1 ? this.flat(depth - 1) : this;
        return new StreamImpl(() => ({ this: stream.startFn() }), (state) => {
            do {
                if (state.iterator) {
                    const next = state.iterator.next();
                    if (next.done) {
                        state.iterator = undefined;
                    }
                    else {
                        return next;
                    }
                }
                const { done, value } = stream.nextFn(state.this);
                if (!done) {
                    if (isIterable(value)) {
                        state.iterator = value[Symbol.iterator]();
                    }
                    else {
                        return { done: false, value: value };
                    }
                }
            } while (state.iterator);
            return DONE_RESULT;
        });
    }
    head() {
        const iterator = this.iterator();
        const result = iterator.next();
        if (result.done) {
            return undefined;
        }
        return result.value;
    }
    tail(skipCount = 1) {
        return new StreamImpl(() => {
            const state = this.startFn();
            for (let i = 0; i < skipCount; i++) {
                const next = this.nextFn(state);
                if (next.done) {
                    return state;
                }
            }
            return state;
        }, this.nextFn);
    }
    limit(maxSize) {
        return new StreamImpl(() => ({ size: 0, state: this.startFn() }), state => {
            state.size++;
            if (state.size > maxSize) {
                return DONE_RESULT;
            }
            return this.nextFn(state.state);
        });
    }
    distinct(by) {
        return new StreamImpl(() => ({ set: new Set(), internalState: this.startFn() }), state => {
            let result;
            do {
                result = this.nextFn(state.internalState);
                if (!result.done) {
                    const value = by ? by(result.value) : result.value;
                    if (!state.set.has(value)) {
                        state.set.add(value);
                        return result;
                    }
                }
            } while (!result.done);
            return DONE_RESULT;
        });
    }
    exclude(other, key) {
        const otherKeySet = new Set();
        for (const item of other) {
            const value = key ? key(item) : item;
            otherKeySet.add(value);
        }
        return this.filter(e => {
            const ownKey = key ? key(e) : e;
            return !otherKeySet.has(ownKey);
        });
    }
}
function toString(item) {
    if (typeof item === 'string') {
        return item;
    }
    if (typeof item === 'undefined') {
        return 'undefined';
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    if (typeof item.toString === 'function') {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        return item.toString();
    }
    return Object.prototype.toString.call(item);
}
function isIterable(obj) {
    return !!obj && typeof obj[Symbol.iterator] === 'function';
}
/**
 * An empty stream of any type.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const EMPTY_STREAM = new StreamImpl(() => undefined, () => DONE_RESULT);
/**
 * Use this `IteratorResult` when implementing a `StreamImpl` to indicate that there are no more elements in the stream.
 */
const DONE_RESULT = Object.freeze({ done: true, value: undefined });
/**
 * Create a stream from one or more iterables or array-likes.
 */
function stream(...collections) {
    if (collections.length === 1) {
        const collection = collections[0];
        if (collection instanceof StreamImpl) {
            return collection;
        }
        if (isIterable(collection)) {
            return new StreamImpl(() => collection[Symbol.iterator](), (iterator) => iterator.next());
        }
        if (typeof collection.length === 'number') {
            return new StreamImpl(() => ({ index: 0 }), (state) => {
                if (state.index < collection.length) {
                    return { done: false, value: collection[state.index++] };
                }
                else {
                    return DONE_RESULT;
                }
            });
        }
    }
    if (collections.length > 1) {
        return new StreamImpl(() => ({ collIndex: 0, arrIndex: 0 }), (state) => {
            do {
                if (state.iterator) {
                    const next = state.iterator.next();
                    if (!next.done) {
                        return next;
                    }
                    state.iterator = undefined;
                }
                if (state.array) {
                    if (state.arrIndex < state.array.length) {
                        return { done: false, value: state.array[state.arrIndex++] };
                    }
                    state.array = undefined;
                    state.arrIndex = 0;
                }
                if (state.collIndex < collections.length) {
                    const collection = collections[state.collIndex++];
                    if (isIterable(collection)) {
                        state.iterator = collection[Symbol.iterator]();
                    }
                    else if (collection && typeof collection.length === 'number') {
                        state.array = collection;
                    }
                }
            } while (state.iterator || state.array || state.collIndex < collections.length);
            return DONE_RESULT;
        });
    }
    return EMPTY_STREAM;
}
/**
 * The default implementation of `TreeStream` takes a root element and a function that computes the
 * children of its argument. Whether the root node included in the stream is controlled with the
 * `includeRoot` option, which defaults to `false`.
 */
class TreeStreamImpl extends StreamImpl {
    constructor(root, children, options) {
        super(() => ({
            iterators: (options === null || options === void 0 ? void 0 : options.includeRoot) ? [[root][Symbol.iterator]()] : [children(root)[Symbol.iterator]()],
            pruned: false
        }), state => {
            if (state.pruned) {
                state.iterators.pop();
                state.pruned = false;
            }
            while (state.iterators.length > 0) {
                const iterator = state.iterators[state.iterators.length - 1];
                const next = iterator.next();
                if (next.done) {
                    state.iterators.pop();
                }
                else {
                    state.iterators.push(children(next.value)[Symbol.iterator]());
                    return next;
                }
            }
            return DONE_RESULT;
        });
    }
    iterator() {
        const iterator = {
            state: this.startFn(),
            next: () => this.nextFn(iterator.state),
            prune: () => {
                iterator.state.pruned = true;
            },
            [Symbol.iterator]: () => iterator
        };
        return iterator;
    }
}
/**
 * A set of utility functions that reduce a stream to a single value.
 */
var Reduction;
(function (Reduction) {
    /**
     * Compute the sum of a number stream.
     */
    function sum(stream) {
        return stream.reduce((a, b) => a + b, 0);
    }
    Reduction.sum = sum;
    /**
     * Compute the product of a number stream.
     */
    function product(stream) {
        return stream.reduce((a, b) => a * b, 0);
    }
    Reduction.product = product;
    /**
     * Compute the minimum of a number stream. Returns `undefined` if the stream is empty.
     */
    function min(stream) {
        return stream.reduce((a, b) => Math.min(a, b));
    }
    Reduction.min = min;
    /**
     * Compute the maximum of a number stream. Returns `undefined` if the stream is empty.
     */
    function max(stream) {
        return stream.reduce((a, b) => Math.max(a, b));
    }
    Reduction.max = max;
})(Reduction || (Reduction = {}));
//# sourceMappingURL=stream.js.map

/***/ }),

/***/ "./node_modules/langium/lib/utils/uri-utils.js":
/*!*****************************************************!*\
  !*** ./node_modules/langium/lib/utils/uri-utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   URI: () => (/* reexport safe */ vscode_uri__WEBPACK_IMPORTED_MODULE_0__.URI),
/* harmony export */   UriUtils: () => (/* binding */ UriUtils)
/* harmony export */ });
/* harmony import */ var vscode_uri__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vscode-uri */ "./node_modules/vscode-uri/lib/esm/index.mjs");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


var UriUtils;
(function (UriUtils) {
    UriUtils.basename = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.basename;
    UriUtils.dirname = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.dirname;
    UriUtils.extname = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.extname;
    UriUtils.joinPath = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.joinPath;
    UriUtils.resolvePath = vscode_uri__WEBPACK_IMPORTED_MODULE_0__.Utils.resolvePath;
    function equals(a, b) {
        return (a === null || a === void 0 ? void 0 : a.toString()) === (b === null || b === void 0 ? void 0 : b.toString());
    }
    UriUtils.equals = equals;
    function relative(from, to) {
        const fromPath = typeof from === 'string' ? from : from.path;
        const toPath = typeof to === 'string' ? to : to.path;
        const fromParts = fromPath.split('/').filter(e => e.length > 0);
        const toParts = toPath.split('/').filter(e => e.length > 0);
        let i = 0;
        for (; i < fromParts.length; i++) {
            if (fromParts[i] !== toParts[i]) {
                break;
            }
        }
        const backPart = '../'.repeat(fromParts.length - i);
        const toPart = toParts.slice(i).join('/');
        return backPart + toPart;
    }
    UriUtils.relative = relative;
    function normalize(uri) {
        return vscode_uri__WEBPACK_IMPORTED_MODULE_0__.URI.parse(uri.toString()).toString();
    }
    UriUtils.normalize = normalize;
})(UriUtils || (UriUtils = {}));
//# sourceMappingURL=uri-utils.js.map

/***/ }),

/***/ "./node_modules/langium/lib/validation/document-validator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/langium/lib/validation/document-validator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultDocumentValidator: () => (/* binding */ DefaultDocumentValidator),
/* harmony export */   DocumentValidator: () => (/* binding */ DocumentValidator),
/* harmony export */   getDiagnosticRange: () => (/* binding */ getDiagnosticRange),
/* harmony export */   toDiagnosticData: () => (/* binding */ toDiagnosticData),
/* harmony export */   toDiagnosticSeverity: () => (/* binding */ toDiagnosticSeverity)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/grammar-utils.js */ "./node_modules/langium/lib/utils/grammar-utils.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _validation_registry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./validation-registry.js */ "./node_modules/langium/lib/validation/validation-registry.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






class DefaultDocumentValidator {
    constructor(services) {
        this.validationRegistry = services.validation.ValidationRegistry;
        this.metadata = services.LanguageMetaData;
    }
    async validateDocument(document, options = {}, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        const parseResult = document.parseResult;
        const diagnostics = [];
        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);
        if (!options.categories || options.categories.includes('built-in')) {
            this.processLexingErrors(parseResult, diagnostics, options);
            if (options.stopAfterLexingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LexingError; })) {
                return diagnostics;
            }
            this.processParsingErrors(parseResult, diagnostics, options);
            if (options.stopAfterParsingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.ParsingError; })) {
                return diagnostics;
            }
            this.processLinkingErrors(document, diagnostics, options);
            if (options.stopAfterLinkingErrors && diagnostics.some(d => { var _a; return ((_a = d.data) === null || _a === void 0 ? void 0 : _a.code) === DocumentValidator.LinkingError; })) {
                return diagnostics;
            }
        }
        // Process custom validations
        try {
            diagnostics.push(...await this.validateAst(parseResult.value, options, cancelToken));
        }
        catch (err) {
            if ((0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.isOperationCancelled)(err)) {
                throw err;
            }
            console.error('An error occurred during validation:', err);
        }
        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);
        return diagnostics;
    }
    processLexingErrors(parseResult, diagnostics, _options) {
        var _a, _b, _c;
        const lexerDiagnostics = [...parseResult.lexerErrors, ...(_b = (_a = parseResult.lexerReport) === null || _a === void 0 ? void 0 : _a.diagnostics) !== null && _b !== void 0 ? _b : []];
        for (const lexerDiagnostic of lexerDiagnostics) {
            const severity = (_c = lexerDiagnostic.severity) !== null && _c !== void 0 ? _c : 'error';
            const diagnostic = {
                severity: toDiagnosticSeverity(severity),
                range: {
                    start: {
                        line: lexerDiagnostic.line - 1,
                        character: lexerDiagnostic.column - 1
                    },
                    end: {
                        line: lexerDiagnostic.line - 1,
                        character: lexerDiagnostic.column + lexerDiagnostic.length - 1
                    }
                },
                message: lexerDiagnostic.message,
                data: toDiagnosticData(severity),
                source: this.getSource()
            };
            diagnostics.push(diagnostic);
        }
    }
    processParsingErrors(parseResult, diagnostics, _options) {
        for (const parserError of parseResult.parserErrors) {
            let range = undefined;
            // We can run into the chevrotain error recovery here
            // The token contained in the parser error might be automatically inserted
            // In this case every position value will be `NaN`
            if (isNaN(parserError.token.startOffset)) {
                // Some special parser error types contain a `previousToken`
                // We can simply append our diagnostic to that token
                if ('previousToken' in parserError) {
                    const token = parserError.previousToken;
                    if (!isNaN(token.startOffset)) {
                        const position = { line: token.endLine - 1, character: token.endColumn };
                        range = { start: position, end: position };
                    }
                    else {
                        // No valid prev token. Might be empty document or containing only hidden tokens.
                        // Point to document start
                        const position = { line: 0, character: 0 };
                        range = { start: position, end: position };
                    }
                }
            }
            else {
                range = (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_2__.tokenToRange)(parserError.token);
            }
            if (range) {
                const diagnostic = {
                    severity: toDiagnosticSeverity('error'),
                    range,
                    message: parserError.message,
                    data: (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.ParsingError),
                    source: this.getSource()
                };
                diagnostics.push(diagnostic);
            }
        }
    }
    processLinkingErrors(document, diagnostics, _options) {
        for (const reference of document.references) {
            const linkingError = reference.error;
            if (linkingError) {
                const info = {
                    node: linkingError.container,
                    property: linkingError.property,
                    index: linkingError.index,
                    data: {
                        code: DocumentValidator.LinkingError,
                        containerType: linkingError.container.$type,
                        property: linkingError.property,
                        refText: linkingError.reference.$refText
                    }
                };
                diagnostics.push(this.toDiagnostic('error', linkingError.message, info));
            }
        }
    }
    async validateAst(rootNode, options, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        const validationItems = [];
        const acceptor = (severity, message, info) => {
            validationItems.push(this.toDiagnostic(severity, message, info));
        };
        await this.validateAstBefore(rootNode, options, acceptor, cancelToken);
        await this.validateAstNodes(rootNode, options, acceptor, cancelToken);
        await this.validateAstAfter(rootNode, options, acceptor, cancelToken);
        return validationItems;
    }
    async validateAstBefore(rootNode, options, acceptor, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        var _a;
        const checksBefore = this.validationRegistry.checksBefore;
        for (const checkBefore of checksBefore) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);
            await checkBefore(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);
        }
    }
    async validateAstNodes(rootNode, options, acceptor, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        await Promise.all((0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_4__.streamAst)(rootNode).map(async (node) => {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);
            const checks = this.validationRegistry.getChecks(node.$type, options.categories);
            for (const check of checks) {
                await check(node, acceptor, cancelToken);
            }
        }));
    }
    async validateAstAfter(rootNode, options, acceptor, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        var _a;
        const checksAfter = this.validationRegistry.checksAfter;
        for (const checkAfter of checksAfter) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.interruptAndCheck)(cancelToken);
            await checkAfter(rootNode, acceptor, (_a = options.categories) !== null && _a !== void 0 ? _a : [], cancelToken);
        }
    }
    toDiagnostic(severity, message, info) {
        return {
            message,
            range: getDiagnosticRange(info),
            severity: toDiagnosticSeverity(severity),
            code: info.code,
            codeDescription: info.codeDescription,
            tags: info.tags,
            relatedInformation: info.relatedInformation,
            data: info.data,
            source: this.getSource()
        };
    }
    getSource() {
        return this.metadata.languageId;
    }
}
function getDiagnosticRange(info) {
    if (info.range) {
        return info.range;
    }
    let cstNode;
    if (typeof info.property === 'string') {
        cstNode = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_5__.findNodeForProperty)(info.node.$cstNode, info.property, info.index);
    }
    else if (typeof info.keyword === 'string') {
        cstNode = (0,_utils_grammar_utils_js__WEBPACK_IMPORTED_MODULE_5__.findNodeForKeyword)(info.node.$cstNode, info.keyword, info.index);
    }
    cstNode !== null && cstNode !== void 0 ? cstNode : (cstNode = info.node.$cstNode);
    if (!cstNode) {
        return {
            start: { line: 0, character: 0 },
            end: { line: 0, character: 0 }
        };
    }
    return cstNode.range;
}
/**
 * Transforms the diagnostic severity from the {@link LexingDiagnosticSeverity} format to LSP's `DiagnosticSeverity` format.
 *
 * @param severity The lexing diagnostic severity
 * @returns Diagnostic severity according to `vscode-languageserver-types/lib/esm/main.js#DiagnosticSeverity`
 */
function toDiagnosticSeverity(severity) {
    switch (severity) {
        case 'error':
            return 1;
        case 'warning':
            return 2;
        case 'info':
            return 3;
        case 'hint':
            return 4;
        default:
            throw new Error('Invalid diagnostic severity: ' + severity);
    }
}
function toDiagnosticData(severity) {
    switch (severity) {
        case 'error':
            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingError);
        case 'warning':
            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingWarning);
        case 'info':
            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingInfo);
        case 'hint':
            return (0,_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.diagnosticData)(DocumentValidator.LexingHint);
        default:
            throw new Error('Invalid diagnostic severity: ' + severity);
    }
}
var DocumentValidator;
(function (DocumentValidator) {
    DocumentValidator.LexingError = 'lexing-error';
    DocumentValidator.LexingWarning = 'lexing-warning';
    DocumentValidator.LexingInfo = 'lexing-info';
    DocumentValidator.LexingHint = 'lexing-hint';
    DocumentValidator.ParsingError = 'parsing-error';
    DocumentValidator.LinkingError = 'linking-error';
})(DocumentValidator || (DocumentValidator = {}));
//# sourceMappingURL=document-validator.js.map

/***/ }),

/***/ "./node_modules/langium/lib/validation/validation-registry.js":
/*!********************************************************************!*\
  !*** ./node_modules/langium/lib/validation/validation-registry.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   ValidationCategory: () => (/* binding */ ValidationCategory),
/* harmony export */   ValidationRegistry: () => (/* binding */ ValidationRegistry),
/* harmony export */   diagnosticData: () => (/* binding */ diagnosticData)
/* harmony export */ });
/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.js */ "./node_modules/langium/lib/utils/errors.js");
/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/collections.js */ "./node_modules/langium/lib/utils/collections.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/




/**
 * Create DiagnosticData for a given diagnostic code. The result can be put into the `data` field of a DiagnosticInfo.
 */
function diagnosticData(code) {
    return { code };
}
var ValidationCategory;
(function (ValidationCategory) {
    ValidationCategory.all = ['fast', 'slow', 'built-in'];
})(ValidationCategory || (ValidationCategory = {}));
/**
 * Manages a set of `ValidationCheck`s to be applied when documents are validated.
 */
class ValidationRegistry {
    constructor(services) {
        this.entries = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.MultiMap();
        this.entriesBefore = [];
        this.entriesAfter = [];
        this.reflection = services.shared.AstReflection;
    }
    /**
     * Register a set of validation checks. Each value in the record can be either a single validation check (i.e. a function)
     * or an array of validation checks.
     *
     * @param checksRecord Set of validation checks to register.
     * @param category Optional category for the validation checks (defaults to `'fast'`).
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    register(checksRecord, thisObj = this, category = 'fast') {
        if (category === 'built-in') {
            throw new Error("The 'built-in' category is reserved for lexer, parser, and linker errors.");
        }
        for (const [type, ch] of Object.entries(checksRecord)) {
            const callbacks = ch;
            if (Array.isArray(callbacks)) {
                for (const check of callbacks) {
                    const entry = {
                        check: this.wrapValidationException(check, thisObj),
                        category
                    };
                    this.addEntry(type, entry);
                }
            }
            else if (typeof callbacks === 'function') {
                const entry = {
                    check: this.wrapValidationException(callbacks, thisObj),
                    category
                };
                this.addEntry(type, entry);
            }
            else {
                (0,_index_js__WEBPACK_IMPORTED_MODULE_1__.assertUnreachable)(callbacks);
            }
        }
    }
    wrapValidationException(check, thisObj) {
        return async (node, accept, cancelToken) => {
            await this.handleException(() => check.call(thisObj, node, accept, cancelToken), 'An error occurred during validation', accept, node);
        };
    }
    async handleException(functionality, messageContext, accept, node) {
        try {
            await functionality();
        }
        catch (err) {
            if ((0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_2__.isOperationCancelled)(err)) {
                throw err;
            }
            console.error(`${messageContext}:`, err);
            if (err instanceof Error && err.stack) {
                console.error(err.stack);
            }
            const messageDetails = err instanceof Error ? err.message : String(err);
            accept('error', `${messageContext}: ${messageDetails}`, { node });
        }
    }
    addEntry(type, entry) {
        if (type === 'AstNode') {
            this.entries.add('AstNode', entry);
            return;
        }
        for (const subtype of this.reflection.getAllSubTypes(type)) {
            this.entries.add(subtype, entry);
        }
    }
    getChecks(type, categories) {
        let checks = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(this.entries.get(type))
            .concat(this.entries.get('AstNode'));
        if (categories) {
            checks = checks.filter(entry => categories.includes(entry.category));
        }
        return checks.map(entry => entry.check);
    }
    /**
     * Register logic which will be executed once before validating all the nodes of an AST/Langium document.
     * This helps to prepare or initialize some information which are required or reusable for the following checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map for mapping names to nodes could be established.
     * During the usual checks on the nodes, they are put into this map with their name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerBeforeDocument(checkBefore, thisObj = this) {
        this.entriesBefore.push(this.wrapPreparationException(checkBefore, 'An error occurred during set-up of the validation', thisObj));
    }
    /**
     * Register logic which will be executed once after validating all the nodes of an AST/Langium document.
     * This helps to finally evaluate information which are collected during the checks on the AstNodes.
     *
     * As an example, for validating unique fully-qualified names of nodes in the AST,
     * here the map with all the collected nodes and their names is checked
     * and validation hints are created for all nodes with the same name.
     *
     * Note that this approach makes validations stateful, which is relevant e.g. when cancelling the validation.
     * Therefore it is recommended to clear stored information
     * _before_ validating an AST to validate each AST unaffected from other ASTs
     * AND _after_ validating the AST to free memory by information which are no longer used.
     *
     * @param checkBefore a set-up function which will be called once before actually validating an AST
     * @param thisObj Optional object to be used as `this` when calling the validation check functions.
     */
    registerAfterDocument(checkAfter, thisObj = this) {
        this.entriesAfter.push(this.wrapPreparationException(checkAfter, 'An error occurred during tear-down of the validation', thisObj));
    }
    wrapPreparationException(check, messageContext, thisObj) {
        return async (rootNode, accept, categories, cancelToken) => {
            await this.handleException(() => check.call(thisObj, rootNode, accept, categories, cancelToken), messageContext, accept, rootNode);
        };
    }
    get checksBefore() {
        return this.entriesBefore;
    }
    get checksAfter() {
        return this.entriesAfter;
    }
}
//# sourceMappingURL=validation-registry.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/ast-descriptions.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/ast-descriptions.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultAstNodeDescriptionProvider: () => (/* binding */ DefaultAstNodeDescriptionProvider),
/* harmony export */   DefaultReferenceDescriptionProvider: () => (/* binding */ DefaultReferenceDescriptionProvider)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _syntax_tree_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../syntax-tree.js */ "./node_modules/langium/lib/syntax-tree.js");
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cst-utils.js */ "./node_modules/langium/lib/utils/cst-utils.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/langium/lib/utils/uri-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/






class DefaultAstNodeDescriptionProvider {
    constructor(services) {
        this.astNodeLocator = services.workspace.AstNodeLocator;
        this.nameProvider = services.references.NameProvider;
    }
    createDescription(node, name, document) {
        const doc = document !== null && document !== void 0 ? document : (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(node);
        name !== null && name !== void 0 ? name : (name = this.nameProvider.getName(node));
        const path = this.astNodeLocator.getAstNodePath(node);
        if (!name) {
            throw new Error(`Node at path ${path} has no name.`);
        }
        let nameNodeSegment;
        const nameSegmentGetter = () => { var _a; return nameNodeSegment !== null && nameNodeSegment !== void 0 ? nameNodeSegment : (nameNodeSegment = (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.toDocumentSegment)((_a = this.nameProvider.getNameNode(node)) !== null && _a !== void 0 ? _a : node.$cstNode)); };
        return {
            node,
            name,
            get nameSegment() {
                return nameSegmentGetter();
            },
            selectionSegment: (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.toDocumentSegment)(node.$cstNode),
            type: node.$type,
            documentUri: doc.uri,
            path
        };
    }
}
class DefaultReferenceDescriptionProvider {
    constructor(services) {
        this.nodeLocator = services.workspace.AstNodeLocator;
    }
    async createDescriptions(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None) {
        const descr = [];
        const rootNode = document.parseResult.value;
        for (const astNode of (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.streamAst)(rootNode)) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_3__.interruptAndCheck)(cancelToken);
            (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.streamReferences)(astNode).filter(refInfo => !(0,_syntax_tree_js__WEBPACK_IMPORTED_MODULE_4__.isLinkingError)(refInfo)).forEach(refInfo => {
                // TODO: Consider logging a warning or throw an exception when DocumentState is < than Linked
                const description = this.createDescription(refInfo);
                if (description) {
                    descr.push(description);
                }
            });
        }
        return descr;
    }
    createDescription(refInfo) {
        const targetNodeDescr = refInfo.reference.$nodeDescription;
        const refCstNode = refInfo.reference.$refNode;
        if (!targetNodeDescr || !refCstNode) {
            return undefined;
        }
        const docUri = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_0__.getDocument)(refInfo.container).uri;
        return {
            sourceUri: docUri,
            sourcePath: this.nodeLocator.getAstNodePath(refInfo.container),
            targetUri: targetNodeDescr.documentUri,
            targetPath: targetNodeDescr.path,
            segment: (0,_utils_cst_utils_js__WEBPACK_IMPORTED_MODULE_1__.toDocumentSegment)(refCstNode),
            local: _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_5__.UriUtils.equals(targetNodeDescr.documentUri, docUri)
        };
    }
}
//# sourceMappingURL=ast-descriptions.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/ast-node-locator.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/ast-node-locator.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultAstNodeLocator: () => (/* binding */ DefaultAstNodeLocator)
/* harmony export */ });
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
class DefaultAstNodeLocator {
    constructor() {
        this.segmentSeparator = '/';
        this.indexSeparator = '@';
    }
    getAstNodePath(node) {
        if (node.$container) {
            const containerPath = this.getAstNodePath(node.$container);
            const newSegment = this.getPathSegment(node);
            const nodePath = containerPath + this.segmentSeparator + newSegment;
            return nodePath;
        }
        return '';
    }
    getPathSegment({ $containerProperty, $containerIndex }) {
        if (!$containerProperty) {
            throw new Error("Missing '$containerProperty' in AST node.");
        }
        if ($containerIndex !== undefined) {
            return $containerProperty + this.indexSeparator + $containerIndex;
        }
        return $containerProperty;
    }
    getAstNode(node, path) {
        const segments = path.split(this.segmentSeparator);
        return segments.reduce((previousValue, currentValue) => {
            if (!previousValue || currentValue.length === 0) {
                return previousValue;
            }
            const propertyIndex = currentValue.indexOf(this.indexSeparator);
            if (propertyIndex > 0) {
                const property = currentValue.substring(0, propertyIndex);
                const arrayIndex = parseInt(currentValue.substring(propertyIndex + 1));
                const array = previousValue[property];
                return array === null || array === void 0 ? void 0 : array[arrayIndex];
            }
            return previousValue[currentValue];
        }, node);
    }
}
//# sourceMappingURL=ast-node-locator.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/configuration.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/configuration.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultConfigurationProvider: () => (/* binding */ DefaultConfigurationProvider)
/* harmony export */ });
/* harmony import */ var _utils_event_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/event.js */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


/**
 * Base configuration provider for building up other configuration providers
 */
class DefaultConfigurationProvider {
    constructor(services) {
        this._ready = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.settings = {};
        this.workspaceConfig = false;
        this.onConfigurationSectionUpdateEmitter = new _utils_event_js__WEBPACK_IMPORTED_MODULE_1__.Emitter();
        this.serviceRegistry = services.ServiceRegistry;
    }
    get ready() {
        return this._ready.promise;
    }
    initialize(params) {
        var _a, _b;
        this.workspaceConfig = (_b = (_a = params.capabilities.workspace) === null || _a === void 0 ? void 0 : _a.configuration) !== null && _b !== void 0 ? _b : false;
    }
    async initialized(params) {
        if (this.workspaceConfig) {
            if (params.register) {
                // params.register(...) is a function to be provided by the calling language server for the sake of
                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection
                const languages = this.serviceRegistry.all;
                params.register({
                    // Listen to configuration changes for all languages
                    section: languages.map(lang => this.toSectionName(lang.LanguageMetaData.languageId))
                });
            }
            if (params.fetchConfiguration) {
                // params.fetchConfiguration(...) is a function to be provided by the calling language server for the sake of
                //  decoupling this implementation from the concrete LSP implementations, specifically the LSP Connection
                const configToUpdate = this.serviceRegistry.all.map(lang => ({
                    // Fetch the configuration changes for all languages
                    section: this.toSectionName(lang.LanguageMetaData.languageId)
                }));
                // get workspace configurations (default scope URI)
                const configs = await params.fetchConfiguration(configToUpdate);
                configToUpdate.forEach((conf, idx) => {
                    this.updateSectionConfiguration(conf.section, configs[idx]);
                });
            }
        }
        this._ready.resolve();
    }
    /**
     *  Updates the cached configurations using the `change` notification parameters.
     *
     * @param change The parameters of a change configuration notification.
     * `settings` property of the change object could be expressed as `Record<string, Record<string, any>>`
     */
    updateConfiguration(change) {
        if (!change.settings) {
            return;
        }
        Object.keys(change.settings).forEach(section => {
            const configuration = change.settings[section];
            this.updateSectionConfiguration(section, configuration);
            this.onConfigurationSectionUpdateEmitter.fire({ section, configuration });
        });
    }
    updateSectionConfiguration(section, configuration) {
        this.settings[section] = configuration;
    }
    /**
    * Returns a configuration value stored for the given language.
    *
    * @param language The language id
    * @param configuration Configuration name
    */
    async getConfiguration(language, configuration) {
        await this.ready;
        const sectionName = this.toSectionName(language);
        if (this.settings[sectionName]) {
            return this.settings[sectionName][configuration];
        }
    }
    toSectionName(languageId) {
        return `${languageId}`;
    }
    get onConfigurationSectionUpdate() {
        return this.onConfigurationSectionUpdateEmitter.event;
    }
}
//# sourceMappingURL=configuration.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/document-builder.js":
/*!****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/document-builder.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultDocumentBuilder: () => (/* binding */ DefaultDocumentBuilder)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/disposable.js */ "./node_modules/langium/lib/utils/disposable.js");
/* harmony import */ var _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/collections.js */ "./node_modules/langium/lib/utils/collections.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../validation/validation-registry.js */ "./node_modules/langium/lib/validation/validation-registry.js");
/* harmony import */ var _documents_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./documents.js */ "./node_modules/langium/lib/workspace/documents.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/







class DefaultDocumentBuilder {
    constructor(services) {
        this.updateBuildOptions = {
            // Default: run only the built-in validation checks and those in the _fast_ category (includes those without category)
            validation: {
                categories: ['built-in', 'fast']
            }
        };
        this.updateListeners = [];
        this.buildPhaseListeners = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.MultiMap();
        this.documentPhaseListeners = new _utils_collections_js__WEBPACK_IMPORTED_MODULE_0__.MultiMap();
        this.buildState = new Map();
        this.documentBuildWaiters = new Map();
        this.currentState = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;
        this.langiumDocuments = services.workspace.LangiumDocuments;
        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
        this.textDocuments = services.workspace.TextDocuments;
        this.indexManager = services.workspace.IndexManager;
        this.serviceRegistry = services.ServiceRegistry;
    }
    async build(documents, options = {}, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None) {
        var _a, _b;
        for (const document of documents) {
            const key = document.uri.toString();
            if (document.state === _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Validated) {
                if (typeof options.validation === 'boolean' && options.validation) {
                    // Force re-running all validation checks
                    document.state = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedReferences;
                    document.diagnostics = undefined;
                    this.buildState.delete(key);
                }
                else if (typeof options.validation === 'object') {
                    const buildState = this.buildState.get(key);
                    const previousCategories = (_a = buildState === null || buildState === void 0 ? void 0 : buildState.result) === null || _a === void 0 ? void 0 : _a.validationChecks;
                    if (previousCategories) {
                        // Validation with explicit options was requested for a document that has already been partly validated.
                        // In this case, we need to merge the previous validation categories with the new ones.
                        const newCategories = (_b = options.validation.categories) !== null && _b !== void 0 ? _b : _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.ValidationCategory.all;
                        const categories = newCategories.filter(c => !previousCategories.includes(c));
                        if (categories.length > 0) {
                            this.buildState.set(key, {
                                completed: false,
                                options: {
                                    validation: Object.assign(Object.assign({}, options.validation), { categories })
                                },
                                result: buildState.result
                            });
                            document.state = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedReferences;
                        }
                    }
                }
            }
            else {
                // Default: forget any previous build options
                this.buildState.delete(key);
            }
        }
        this.currentState = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;
        await this.emitUpdate(documents.map(e => e.uri), []);
        await this.buildDocuments(documents, options, cancelToken);
    }
    async update(changed, deleted, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None) {
        this.currentState = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;
        // Remove all metadata of documents that are reported as deleted
        for (const deletedUri of deleted) {
            this.langiumDocuments.deleteDocument(deletedUri);
            this.buildState.delete(deletedUri.toString());
            this.indexManager.remove(deletedUri);
        }
        // Set the state of all changed documents to `Changed` so they are completely rebuilt
        for (const changedUri of changed) {
            const invalidated = this.langiumDocuments.invalidateDocument(changedUri);
            if (!invalidated) {
                // We create an unparsed, invalid document.
                // This will be parsed as soon as we reach the first document builder phase.
                // This allows to cancel the parsing process later in case we need it.
                const newDocument = this.langiumDocumentFactory.fromModel({ $type: 'INVALID' }, changedUri);
                newDocument.state = _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Changed;
                this.langiumDocuments.addDocument(newDocument);
            }
            this.buildState.delete(changedUri.toString());
        }
        // Set the state of all documents that should be relinked to `ComputedScopes` (if not already lower)
        const allChangedUris = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_4__.stream)(changed).concat(deleted).map(uri => uri.toString()).toSet();
        this.langiumDocuments.all
            .filter(doc => !allChangedUris.has(doc.uri.toString()) && this.shouldRelink(doc, allChangedUris))
            .forEach(doc => {
            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;
            linker.unlink(doc);
            doc.state = Math.min(doc.state, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.ComputedScopes);
            doc.diagnostics = undefined;
        });
        // Notify listeners of the update
        await this.emitUpdate(changed, deleted);
        // Only allow interrupting the execution after all state changes are done
        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.interruptAndCheck)(cancelToken);
        // Collect and sort all documents that we should rebuild
        const rebuildDocuments = this.sortDocuments(this.langiumDocuments.all
            .filter(doc => {
            var _a;
            // This includes those that were reported as changed and those that we selected for relinking
            return doc.state < _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Linked
                // This includes those for which a previous build has been cancelled
                || !((_a = this.buildState.get(doc.uri.toString())) === null || _a === void 0 ? void 0 : _a.completed);
        })
            .toArray());
        await this.buildDocuments(rebuildDocuments, this.updateBuildOptions, cancelToken);
    }
    async emitUpdate(changed, deleted) {
        await Promise.all(this.updateListeners.map(listener => listener(changed, deleted)));
    }
    /**
     * Sort the given documents by priority. By default, documents with an open text document are prioritized.
     * This is useful to ensure that visible documents show their diagnostics before all other documents.
     *
     * This improves the responsiveness in large workspaces as users usually don't care about diagnostics
     * in files that are currently not opened in the editor.
     */
    sortDocuments(documents) {
        let left = 0;
        let right = documents.length - 1;
        while (left < right) {
            while (left < documents.length && this.hasTextDocument(documents[left])) {
                left++;
            }
            while (right >= 0 && !this.hasTextDocument(documents[right])) {
                right--;
            }
            if (left < right) {
                [documents[left], documents[right]] = [documents[right], documents[left]];
            }
        }
        return documents;
    }
    hasTextDocument(doc) {
        var _a;
        return Boolean((_a = this.textDocuments) === null || _a === void 0 ? void 0 : _a.get(doc.uri));
    }
    /**
     * Check whether the given document should be relinked after changes were found in the given URIs.
     */
    shouldRelink(document, changedUris) {
        // Relink documents with linking errors -- maybe those references can be resolved now
        if (document.references.some(ref => ref.error !== undefined)) {
            return true;
        }
        // Check whether the document is affected by any of the changed URIs
        return this.indexManager.isAffected(document, changedUris);
    }
    onUpdate(callback) {
        this.updateListeners.push(callback);
        return _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__.Disposable.create(() => {
            const index = this.updateListeners.indexOf(callback);
            if (index >= 0) {
                this.updateListeners.splice(index, 1);
            }
        });
    }
    /**
     * Build the given documents by stepping through all build phases. If a document's state indicates
     * that a certain build phase is already done, the phase is skipped for that document.
     *
     * @param documents The documents to build.
     * @param options the {@link BuildOptions} to use.
     * @param cancelToken A cancellation token that can be used to cancel the build.
     * @returns A promise that resolves when the build is done.
     */
    async buildDocuments(documents, options, cancelToken) {
        this.prepareBuild(documents, options);
        // 0. Parse content
        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Parsed, cancelToken, doc => this.langiumDocumentFactory.update(doc, cancelToken));
        // 1. Index content
        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedContent, cancelToken, doc => this.indexManager.updateContent(doc, cancelToken));
        // 2. Compute scopes
        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.ComputedScopes, cancelToken, async (doc) => {
            const scopeComputation = this.serviceRegistry.getServices(doc.uri).references.ScopeComputation;
            doc.precomputedScopes = await scopeComputation.computeLocalScopes(doc, cancelToken);
        });
        // 3. Linking
        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Linked, cancelToken, doc => {
            const linker = this.serviceRegistry.getServices(doc.uri).references.Linker;
            return linker.link(doc, cancelToken);
        });
        // 4. Index references
        await this.runCancelable(documents, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.IndexedReferences, cancelToken, doc => this.indexManager.updateReferences(doc, cancelToken));
        // 5. Validation
        const toBeValidated = documents.filter(doc => this.shouldValidate(doc));
        await this.runCancelable(toBeValidated, _documents_js__WEBPACK_IMPORTED_MODULE_1__.DocumentState.Validated, cancelToken, doc => this.validate(doc, cancelToken));
        // If we've made it to this point without being cancelled, we can mark the build state as completed.
        for (const doc of documents) {
            const state = this.buildState.get(doc.uri.toString());
            if (state) {
                state.completed = true;
            }
        }
    }
    /**
     * Runs prior to beginning the build process to update the {@link DocumentBuildState} for each document
     *
     * @param documents collection of documents to be built
     * @param options the {@link BuildOptions} to use
     */
    prepareBuild(documents, options) {
        for (const doc of documents) {
            const key = doc.uri.toString();
            const state = this.buildState.get(key);
            // If the document has no previous build state, we set it. If it has one, but it's already marked
            // as completed, we overwrite it. If the previous build was not completed, we keep its state
            // and continue where it was cancelled.
            if (!state || state.completed) {
                this.buildState.set(key, {
                    completed: false,
                    options,
                    result: state === null || state === void 0 ? void 0 : state.result
                });
            }
        }
    }
    /**
     * Runs a cancelable operation on a set of documents to bring them to a specified {@link DocumentState}.
     *
     * @param documents The array of documents to process.
     * @param targetState The target {@link DocumentState} to bring the documents to.
     * @param cancelToken A token that can be used to cancel the operation.
     * @param callback A function to be called for each document.
     * @returns A promise that resolves when all documents have been processed or the operation is canceled.
     * @throws Will throw `OperationCancelled` if the operation is canceled via a `CancellationToken`.
     */
    async runCancelable(documents, targetState, cancelToken, callback) {
        const filtered = documents.filter(doc => doc.state < targetState);
        for (const document of filtered) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.interruptAndCheck)(cancelToken);
            await callback(document);
            document.state = targetState;
            await this.notifyDocumentPhase(document, targetState, cancelToken);
        }
        // Do not use `filtered` here, as that will miss documents that have previously reached the current target state
        // For example, this happens in case the cancellation triggers between the processing of two documents
        // Or files that were picked up during the workspace initialization
        const targetStateDocs = documents.filter(doc => doc.state === targetState);
        await this.notifyBuildPhase(targetStateDocs, targetState, cancelToken);
        this.currentState = targetState;
    }
    onBuildPhase(targetState, callback) {
        this.buildPhaseListeners.add(targetState, callback);
        return _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__.Disposable.create(() => {
            this.buildPhaseListeners.delete(targetState, callback);
        });
    }
    onDocumentPhase(targetState, callback) {
        this.documentPhaseListeners.add(targetState, callback);
        return _utils_disposable_js__WEBPACK_IMPORTED_MODULE_6__.Disposable.create(() => {
            this.documentPhaseListeners.delete(targetState, callback);
        });
    }
    waitUntil(state, uriOrToken, cancelToken) {
        let uri = undefined;
        if (uriOrToken && 'path' in uriOrToken) {
            uri = uriOrToken;
        }
        else {
            cancelToken = uriOrToken;
        }
        cancelToken !== null && cancelToken !== void 0 ? cancelToken : (cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_2__.CancellationToken.None);
        if (uri) {
            const document = this.langiumDocuments.getDocument(uri);
            if (document && document.state > state) {
                return Promise.resolve(uri);
            }
        }
        if (this.currentState >= state) {
            return Promise.resolve(undefined);
        }
        else if (cancelToken.isCancellationRequested) {
            return Promise.reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.OperationCancelled);
        }
        return new Promise((resolve, reject) => {
            const buildDisposable = this.onBuildPhase(state, () => {
                buildDisposable.dispose();
                cancelDisposable.dispose();
                if (uri) {
                    const document = this.langiumDocuments.getDocument(uri);
                    resolve(document === null || document === void 0 ? void 0 : document.uri);
                }
                else {
                    resolve(undefined);
                }
            });
            const cancelDisposable = cancelToken.onCancellationRequested(() => {
                buildDisposable.dispose();
                cancelDisposable.dispose();
                reject(_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.OperationCancelled);
            });
        });
    }
    async notifyDocumentPhase(document, state, cancelToken) {
        const listeners = this.documentPhaseListeners.get(state);
        const listenersCopy = listeners.slice();
        for (const listener of listenersCopy) {
            try {
                await listener(document, cancelToken);
            }
            catch (err) {
                // Ignore cancellation errors
                // We want to finish the listeners before throwing
                if (!(0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.isOperationCancelled)(err)) {
                    throw err;
                }
            }
        }
    }
    async notifyBuildPhase(documents, state, cancelToken) {
        if (documents.length === 0) {
            // Don't notify when no document has been processed
            return;
        }
        const listeners = this.buildPhaseListeners.get(state);
        const listenersCopy = listeners.slice();
        for (const listener of listenersCopy) {
            await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_5__.interruptAndCheck)(cancelToken);
            await listener(documents, cancelToken);
        }
    }
    /**
     * Determine whether the given document should be validated during a build. The default
     * implementation checks the `validation` property of the build options. If it's set to `true`
     * or a `ValidationOptions` object, the document is included in the validation phase.
     */
    shouldValidate(document) {
        return Boolean(this.getBuildOptions(document).validation);
    }
    /**
     * Run validation checks on the given document and store the resulting diagnostics in the document.
     * If the document already contains diagnostics, the new ones are added to the list.
     */
    async validate(document, cancelToken) {
        var _a, _b;
        const validator = this.serviceRegistry.getServices(document.uri).validation.DocumentValidator;
        const validationSetting = this.getBuildOptions(document).validation;
        const options = typeof validationSetting === 'object' ? validationSetting : undefined;
        const diagnostics = await validator.validateDocument(document, options, cancelToken);
        if (document.diagnostics) {
            document.diagnostics.push(...diagnostics);
        }
        else {
            document.diagnostics = diagnostics;
        }
        // Store information about the executed validation in the build state
        const state = this.buildState.get(document.uri.toString());
        if (state) {
            (_a = state.result) !== null && _a !== void 0 ? _a : (state.result = {});
            const newCategories = (_b = options === null || options === void 0 ? void 0 : options.categories) !== null && _b !== void 0 ? _b : _validation_validation_registry_js__WEBPACK_IMPORTED_MODULE_3__.ValidationCategory.all;
            if (state.result.validationChecks) {
                state.result.validationChecks.push(...newCategories);
            }
            else {
                state.result.validationChecks = [...newCategories];
            }
        }
    }
    getBuildOptions(document) {
        var _a, _b;
        return (_b = (_a = this.buildState.get(document.uri.toString())) === null || _a === void 0 ? void 0 : _a.options) !== null && _b !== void 0 ? _b : {};
    }
}
//# sourceMappingURL=document-builder.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/documents.js":
/*!*********************************************************!*\
  !*** ./node_modules/langium/lib/workspace/documents.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultLangiumDocumentFactory: () => (/* binding */ DefaultLangiumDocumentFactory),
/* harmony export */   DefaultLangiumDocuments: () => (/* binding */ DefaultLangiumDocuments),
/* harmony export */   DocumentState: () => (/* binding */ DocumentState),
/* harmony export */   TextDocument: () => (/* reexport safe */ vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__.TextDocument)
/* harmony export */ });
/* harmony import */ var vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./documents.js */ "./node_modules/vscode-languageserver-textdocument/lib/esm/main.js");
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/vscode-uri/lib/esm/index.mjs");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
/**
 * Re-export 'TextDocument' from 'vscode-languageserver-textdocument' for convenience,
 *  including both type _and_ symbol (namespace), as we here and there also refer to the symbol,
 *  the overhead is very small, just a few kilobytes.
 * Everything else of that package (at the time contributing) is also defined
 *  in 'vscode-languageserver-protocol' or 'vscode-languageserver-types'.
 */





/**
 * A document is subject to several phases that are run in predefined order. Any state value implies that
 * smaller state values are finished as well.
 */
var DocumentState;
(function (DocumentState) {
    /**
     * The text content has changed and needs to be parsed again. The AST held by this outdated
     * document instance is no longer valid.
     */
    DocumentState[DocumentState["Changed"] = 0] = "Changed";
    /**
     * An AST has been created from the text content. The document structure can be traversed,
     * but cross-references cannot be resolved yet. If necessary, the structure can be manipulated
     * at this stage as a preprocessing step.
     */
    DocumentState[DocumentState["Parsed"] = 1] = "Parsed";
    /**
     * The `IndexManager` service has processed AST nodes of this document. This means the
     * exported symbols are available in the global scope and can be resolved from other documents.
     */
    DocumentState[DocumentState["IndexedContent"] = 2] = "IndexedContent";
    /**
     * The `ScopeComputation` service has processed this document. This means the local symbols
     * are stored in a MultiMap so they can be looked up by the `ScopeProvider` service.
     * Once a document has reached this state, you may follow every reference - it will lazily
     * resolve its `ref` property and yield either the target AST node or `undefined` in case
     * the target is not in scope.
     */
    DocumentState[DocumentState["ComputedScopes"] = 3] = "ComputedScopes";
    /**
     * The `Linker` service has processed this document. All outgoing references have been
     * resolved or marked as erroneous.
     */
    DocumentState[DocumentState["Linked"] = 4] = "Linked";
    /**
     * The `IndexManager` service has processed AST node references of this document. This is
     * necessary to determine which documents are affected by a change in one of the workspace
     * documents.
     */
    DocumentState[DocumentState["IndexedReferences"] = 5] = "IndexedReferences";
    /**
     * The `DocumentValidator` service has processed this document. The language server listens
     * to the results of this phase and sends diagnostics to the client.
     */
    DocumentState[DocumentState["Validated"] = 6] = "Validated";
})(DocumentState || (DocumentState = {}));
class DefaultLangiumDocumentFactory {
    constructor(services) {
        this.serviceRegistry = services.ServiceRegistry;
        this.textDocuments = services.workspace.TextDocuments;
        this.fileSystemProvider = services.workspace.FileSystemProvider;
    }
    async fromUri(uri, cancellationToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.None) {
        const content = await this.fileSystemProvider.readFile(uri);
        return this.createAsync(uri, content, cancellationToken);
    }
    fromTextDocument(textDocument, uri, token) {
        uri = uri !== null && uri !== void 0 ? uri : _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(textDocument.uri);
        if (_utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.is(token)) {
            return this.createAsync(uri, textDocument, token);
        }
        else {
            return this.create(uri, textDocument, token);
        }
    }
    fromString(text, uri, token) {
        if (_utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.is(token)) {
            return this.createAsync(uri, text, token);
        }
        else {
            return this.create(uri, text, token);
        }
    }
    fromModel(model, uri) {
        return this.create(uri, { $model: model });
    }
    create(uri, content, options) {
        if (typeof content === 'string') {
            const parseResult = this.parse(uri, content, options);
            return this.createLangiumDocument(parseResult, uri, undefined, content);
        }
        else if ('$model' in content) {
            const parseResult = { value: content.$model, parserErrors: [], lexerErrors: [] };
            return this.createLangiumDocument(parseResult, uri);
        }
        else {
            const parseResult = this.parse(uri, content.getText(), options);
            return this.createLangiumDocument(parseResult, uri, content);
        }
    }
    async createAsync(uri, content, cancelToken) {
        if (typeof content === 'string') {
            const parseResult = await this.parseAsync(uri, content, cancelToken);
            return this.createLangiumDocument(parseResult, uri, undefined, content);
        }
        else {
            const parseResult = await this.parseAsync(uri, content.getText(), cancelToken);
            return this.createLangiumDocument(parseResult, uri, content);
        }
    }
    /**
     * Create a LangiumDocument from a given parse result.
     *
     * A TextDocument is created on demand if it is not provided as argument here. Usually this
     * should not be necessary because the main purpose of the TextDocument is to convert between
     * text ranges and offsets, which is done solely in LSP request handling.
     *
     * With the introduction of {@link update} below this method is supposed to be mainly called
     * during workspace initialization and on addition/recognition of new files, while changes in
     * existing documents are processed via {@link update}.
     */
    createLangiumDocument(parseResult, uri, textDocument, text) {
        let document;
        if (textDocument) {
            document = {
                parseResult,
                uri,
                state: DocumentState.Parsed,
                references: [],
                textDocument
            };
        }
        else {
            const textDocumentGetter = this.createTextDocumentGetter(uri, text);
            document = {
                parseResult,
                uri,
                state: DocumentState.Parsed,
                references: [],
                get textDocument() {
                    return textDocumentGetter();
                }
            };
        }
        parseResult.value.$document = document;
        return document;
    }
    async update(document, cancellationToken) {
        var _a, _b;
        // The CST full text property contains the original text that was used to create the AST.
        const oldText = (_a = document.parseResult.value.$cstNode) === null || _a === void 0 ? void 0 : _a.root.fullText;
        const textDocument = (_b = this.textDocuments) === null || _b === void 0 ? void 0 : _b.get(document.uri.toString());
        const text = textDocument ? textDocument.getText() : await this.fileSystemProvider.readFile(document.uri);
        if (textDocument) {
            Object.defineProperty(document, 'textDocument', {
                value: textDocument
            });
        }
        else {
            const textDocumentGetter = this.createTextDocumentGetter(document.uri, text);
            Object.defineProperty(document, 'textDocument', {
                get: textDocumentGetter
            });
        }
        // Some of these documents can be pretty large, so parsing them again can be quite expensive.
        // Therefore, we only parse if the text has actually changed.
        if (oldText !== text) {
            document.parseResult = await this.parseAsync(document.uri, text, cancellationToken);
            document.parseResult.value.$document = document;
        }
        document.state = DocumentState.Parsed;
        return document;
    }
    parse(uri, text, options) {
        const services = this.serviceRegistry.getServices(uri);
        return services.parser.LangiumParser.parse(text, options);
    }
    parseAsync(uri, text, cancellationToken) {
        const services = this.serviceRegistry.getServices(uri);
        return services.parser.AsyncParser.parse(text, cancellationToken);
    }
    createTextDocumentGetter(uri, text) {
        const serviceRegistry = this.serviceRegistry;
        let textDoc = undefined;
        return () => {
            return textDoc !== null && textDoc !== void 0 ? textDoc : (textDoc = vscode_languageserver_textdocument__WEBPACK_IMPORTED_MODULE_0__.TextDocument.create(uri.toString(), serviceRegistry.getServices(uri).LanguageMetaData.languageId, 0, text !== null && text !== void 0 ? text : ''));
        };
    }
}
class DefaultLangiumDocuments {
    constructor(services) {
        this.documentMap = new Map();
        this.langiumDocumentFactory = services.workspace.LangiumDocumentFactory;
        this.serviceRegistry = services.ServiceRegistry;
    }
    get all() {
        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(this.documentMap.values());
    }
    addDocument(document) {
        const uriString = document.uri.toString();
        if (this.documentMap.has(uriString)) {
            throw new Error(`A document with the URI '${uriString}' is already present.`);
        }
        this.documentMap.set(uriString, document);
    }
    getDocument(uri) {
        const uriString = uri.toString();
        return this.documentMap.get(uriString);
    }
    async getOrCreateDocument(uri, cancellationToken) {
        let document = this.getDocument(uri);
        if (document) {
            return document;
        }
        document = await this.langiumDocumentFactory.fromUri(uri, cancellationToken);
        this.addDocument(document);
        return document;
    }
    createDocument(uri, text, cancellationToken) {
        if (cancellationToken) {
            return this.langiumDocumentFactory.fromString(text, uri, cancellationToken).then(document => {
                this.addDocument(document);
                return document;
            });
        }
        else {
            const document = this.langiumDocumentFactory.fromString(text, uri);
            this.addDocument(document);
            return document;
        }
    }
    hasDocument(uri) {
        return this.documentMap.has(uri.toString());
    }
    invalidateDocument(uri) {
        const uriString = uri.toString();
        const langiumDoc = this.documentMap.get(uriString);
        if (langiumDoc) {
            const linker = this.serviceRegistry.getServices(uri).references.Linker;
            linker.unlink(langiumDoc);
            langiumDoc.state = DocumentState.Changed;
            langiumDoc.precomputedScopes = undefined;
            langiumDoc.diagnostics = undefined;
        }
        return langiumDoc;
    }
    deleteDocument(uri) {
        const uriString = uri.toString();
        const langiumDoc = this.documentMap.get(uriString);
        if (langiumDoc) {
            langiumDoc.state = DocumentState.Changed;
            this.documentMap.delete(uriString);
        }
        return langiumDoc;
    }
}
//# sourceMappingURL=documents.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/file-system-provider.js":
/*!********************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/file-system-provider.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   EmptyFileSystem: () => (/* binding */ EmptyFileSystem),
/* harmony export */   EmptyFileSystemProvider: () => (/* binding */ EmptyFileSystemProvider)
/* harmony export */ });
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/
class EmptyFileSystemProvider {
    readFile() {
        throw new Error('No file system is available.');
    }
    async readDirectory() {
        return [];
    }
}
const EmptyFileSystem = {
    fileSystemProvider: () => new EmptyFileSystemProvider()
};
//# sourceMappingURL=file-system-provider.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/index-manager.js":
/*!*************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/index-manager.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultIndexManager: () => (/* binding */ DefaultIndexManager)
/* harmony export */ });
/* harmony import */ var _utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/ast-utils.js */ "./node_modules/langium/lib/utils/ast-utils.js");
/* harmony import */ var _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/caching.js */ "./node_modules/langium/lib/utils/caching.js");
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_stream_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/stream.js */ "./node_modules/langium/lib/utils/stream.js");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/langium/lib/utils/uri-utils.js");
/******************************************************************************
 * Copyright 2021 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/





class DefaultIndexManager {
    constructor(services) {
        /**
         * The symbol index stores all `AstNodeDescription` items exported by a document.
         * The key used in this map is the string representation of the specific document URI.
         */
        this.symbolIndex = new Map();
        /**
         * This is a cache for the `allElements()` method.
         * It caches the descriptions from `symbolIndex` grouped by types.
         */
        this.symbolByTypeIndex = new _utils_caching_js__WEBPACK_IMPORTED_MODULE_0__.ContextCache();
        /**
         * This index keeps track of all `ReferenceDescription` items exported by a document.
         * This is used to compute which elements are affected by a document change
         * and for finding references to an AST node.
         */
        this.referenceIndex = new Map();
        this.documents = services.workspace.LangiumDocuments;
        this.serviceRegistry = services.ServiceRegistry;
        this.astReflection = services.AstReflection;
    }
    findAllReferences(targetNode, astNodePath) {
        const targetDocUri = (0,_utils_ast_utils_js__WEBPACK_IMPORTED_MODULE_1__.getDocument)(targetNode).uri;
        const result = [];
        this.referenceIndex.forEach(docRefs => {
            docRefs.forEach(refDescr => {
                if (_utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.UriUtils.equals(refDescr.targetUri, targetDocUri) && refDescr.targetPath === astNodePath) {
                    result.push(refDescr);
                }
            });
        });
        return (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(result);
    }
    allElements(nodeType, uris) {
        let documentUris = (0,_utils_stream_js__WEBPACK_IMPORTED_MODULE_3__.stream)(this.symbolIndex.keys());
        if (uris) {
            documentUris = documentUris.filter(uri => !uris || uris.has(uri));
        }
        return documentUris
            .map(uri => this.getFileDescriptions(uri, nodeType))
            .flat();
    }
    getFileDescriptions(uri, nodeType) {
        var _a;
        if (!nodeType) {
            return (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];
        }
        const descriptions = this.symbolByTypeIndex.get(uri, nodeType, () => {
            var _a;
            const allFileDescriptions = (_a = this.symbolIndex.get(uri)) !== null && _a !== void 0 ? _a : [];
            return allFileDescriptions.filter(e => this.astReflection.isSubtype(e.type, nodeType));
        });
        return descriptions;
    }
    remove(uri) {
        const uriString = uri.toString();
        this.symbolIndex.delete(uriString);
        this.symbolByTypeIndex.clear(uriString);
        this.referenceIndex.delete(uriString);
    }
    async updateContent(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_4__.CancellationToken.None) {
        const services = this.serviceRegistry.getServices(document.uri);
        const exports = await services.references.ScopeComputation.computeExports(document, cancelToken);
        const uri = document.uri.toString();
        this.symbolIndex.set(uri, exports);
        this.symbolByTypeIndex.clear(uri);
    }
    async updateReferences(document, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_4__.CancellationToken.None) {
        const services = this.serviceRegistry.getServices(document.uri);
        const indexData = await services.workspace.ReferenceDescriptionProvider.createDescriptions(document, cancelToken);
        this.referenceIndex.set(document.uri.toString(), indexData);
    }
    isAffected(document, changedUris) {
        const references = this.referenceIndex.get(document.uri.toString());
        if (!references) {
            return false;
        }
        return references.some(ref => !ref.local && changedUris.has(ref.targetUri.toString()));
    }
}
//# sourceMappingURL=index-manager.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/workspace-lock.js":
/*!**************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/workspace-lock.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultWorkspaceLock: () => (/* binding */ DefaultWorkspaceLock)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/******************************************************************************
 * Copyright 2023 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/


class DefaultWorkspaceLock {
    constructor() {
        this.previousTokenSource = new _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationTokenSource();
        this.writeQueue = [];
        this.readQueue = [];
        this.done = true;
    }
    write(action) {
        this.cancelWrite();
        const tokenSource = (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.startCancelableOperation)();
        this.previousTokenSource = tokenSource;
        return this.enqueue(this.writeQueue, action, tokenSource.token);
    }
    read(action) {
        return this.enqueue(this.readQueue, action);
    }
    enqueue(queue, action, cancellationToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_0__.CancellationToken.None) {
        const deferred = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.Deferred();
        const entry = {
            action,
            deferred,
            cancellationToken
        };
        queue.push(entry);
        this.performNextOperation();
        return deferred.promise;
    }
    async performNextOperation() {
        if (!this.done) {
            return;
        }
        const entries = [];
        if (this.writeQueue.length > 0) {
            // Just perform the next write action
            entries.push(this.writeQueue.shift());
        }
        else if (this.readQueue.length > 0) {
            // Empty the read queue and perform all actions in parallel
            entries.push(...this.readQueue.splice(0, this.readQueue.length));
        }
        else {
            return;
        }
        this.done = false;
        await Promise.all(entries.map(async ({ action, deferred, cancellationToken }) => {
            try {
                // Move the execution of the action to the next event loop tick via `Promise.resolve()`
                const result = await Promise.resolve().then(() => action(cancellationToken));
                deferred.resolve(result);
            }
            catch (err) {
                if ((0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_1__.isOperationCancelled)(err)) {
                    // If the operation was cancelled, we don't want to reject the promise
                    deferred.resolve(undefined);
                }
                else {
                    deferred.reject(err);
                }
            }
        }));
        this.done = true;
        this.performNextOperation();
    }
    cancelWrite() {
        this.previousTokenSource.cancel();
    }
}
//# sourceMappingURL=workspace-lock.js.map

/***/ }),

/***/ "./node_modules/langium/lib/workspace/workspace-manager.js":
/*!*****************************************************************!*\
  !*** ./node_modules/langium/lib/workspace/workspace-manager.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   DefaultWorkspaceManager: () => (/* binding */ DefaultWorkspaceManager)
/* harmony export */ });
/* harmony import */ var _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/cancellation.js */ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js");
/* harmony import */ var _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/promise-utils.js */ "./node_modules/langium/lib/utils/promise-utils.js");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/vscode-uri/lib/esm/index.mjs");
/* harmony import */ var _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/uri-utils.js */ "./node_modules/langium/lib/utils/uri-utils.js");
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/



class DefaultWorkspaceManager {
    constructor(services) {
        this.initialBuildOptions = {};
        this._ready = new _utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.Deferred();
        this.serviceRegistry = services.ServiceRegistry;
        this.langiumDocuments = services.workspace.LangiumDocuments;
        this.documentBuilder = services.workspace.DocumentBuilder;
        this.fileSystemProvider = services.workspace.FileSystemProvider;
        this.mutex = services.workspace.WorkspaceLock;
    }
    get ready() {
        return this._ready.promise;
    }
    get workspaceFolders() {
        return this.folders;
    }
    initialize(params) {
        var _a;
        this.folders = (_a = params.workspaceFolders) !== null && _a !== void 0 ? _a : undefined;
    }
    initialized(_params) {
        // Initialize the workspace even if there are no workspace folders
        // We still want to load additional documents (language library or similar) during initialization
        return this.mutex.write(token => { var _a; return this.initializeWorkspace((_a = this.folders) !== null && _a !== void 0 ? _a : [], token); });
    }
    async initializeWorkspace(folders, cancelToken = _utils_cancellation_js__WEBPACK_IMPORTED_MODULE_1__.CancellationToken.None) {
        const documents = await this.performStartup(folders);
        // Only after creating all documents do we check whether we need to cancel the initialization
        // The document builder will later pick up on all unprocessed documents
        await (0,_utils_promise_utils_js__WEBPACK_IMPORTED_MODULE_0__.interruptAndCheck)(cancelToken);
        await this.documentBuilder.build(documents, this.initialBuildOptions, cancelToken);
    }
    /**
     * Performs the uninterruptable startup sequence of the workspace manager.
     * This methods loads all documents in the workspace and other documents and returns them.
     */
    async performStartup(folders) {
        const fileExtensions = this.serviceRegistry.all.flatMap(e => e.LanguageMetaData.fileExtensions);
        const documents = [];
        const collector = (document) => {
            documents.push(document);
            if (!this.langiumDocuments.hasDocument(document.uri)) {
                this.langiumDocuments.addDocument(document);
            }
        };
        // Even though we don't await the initialization of the workspace manager,
        // we can still assume that all library documents and file documents are loaded by the time we start building documents.
        // The mutex prevents anything from performing a workspace build until we check the cancellation token
        await this.loadAdditionalDocuments(folders, collector);
        await Promise.all(folders.map(wf => [wf, this.getRootFolder(wf)])
            .map(async (entry) => this.traverseFolder(...entry, fileExtensions, collector)));
        this._ready.resolve();
        return documents;
    }
    /**
     * Load all additional documents that shall be visible in the context of the given workspace
     * folders and add them to the collector. This can be used to include built-in libraries of
     * your language, which can be either loaded from provided files or constructed in memory.
     */
    loadAdditionalDocuments(_folders, _collector) {
        return Promise.resolve();
    }
    /**
     * Determine the root folder of the source documents in the given workspace folder.
     * The default implementation returns the URI of the workspace folder, but you can override
     * this to return a subfolder like `src` instead.
     */
    getRootFolder(workspaceFolder) {
        return _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_2__.URI.parse(workspaceFolder.uri);
    }
    /**
     * Traverse the file system folder identified by the given URI and its subfolders. All
     * contained files that match the file extensions are added to the collector.
     */
    async traverseFolder(workspaceFolder, folderPath, fileExtensions, collector) {
        const content = await this.fileSystemProvider.readDirectory(folderPath);
        await Promise.all(content.map(async (entry) => {
            if (this.includeEntry(workspaceFolder, entry, fileExtensions)) {
                if (entry.isDirectory) {
                    await this.traverseFolder(workspaceFolder, entry.uri, fileExtensions, collector);
                }
                else if (entry.isFile) {
                    const document = await this.langiumDocuments.getOrCreateDocument(entry.uri);
                    collector(document);
                }
            }
        }));
    }
    /**
     * Determine whether the given folder entry shall be included while indexing the workspace.
     */
    includeEntry(_workspaceFolder, entry, fileExtensions) {
        const name = _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__.UriUtils.basename(entry.uri);
        if (name.startsWith('.')) {
            return false;
        }
        if (entry.isDirectory) {
            return name !== 'node_modules' && name !== 'out';
        }
        else if (entry.isFile) {
            const extname = _utils_uri_utils_js__WEBPACK_IMPORTED_MODULE_3__.UriUtils.extname(entry.uri);
            return fileExtensions.includes(extname);
        }
        return false;
    }
}
//# sourceMappingURL=workspace-manager.js.map

/***/ }),

/***/ "./node_modules/lodash-es/_arrayAggregator.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_arrayAggregator.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `baseAggregator` for arrays.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function arrayAggregator(array, setter, iteratee, accumulator) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    var value = array[index];
    setter(accumulator, value, iteratee(value), array);
  }
  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayAggregator);


/***/ }),

/***/ "./node_modules/lodash-es/_arrayEvery.js":
/*!***********************************************!*\
  !*** ./node_modules/lodash-es/_arrayEvery.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * A specialized version of `_.every` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 */
function arrayEvery(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (!predicate(array[index], index, array)) {
      return false;
    }
  }
  return true;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (arrayEvery);


/***/ }),

/***/ "./node_modules/lodash-es/_asciiToArray.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_asciiToArray.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (asciiToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_baseAggregator.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseAggregator.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");


/**
 * Aggregates elements of `collection` on `accumulator` with keys transformed
 * by `iteratee` and values set by `setter`.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} setter The function to set `accumulator` values.
 * @param {Function} iteratee The iteratee to transform keys.
 * @param {Object} accumulator The initial aggregated object.
 * @returns {Function} Returns `accumulator`.
 */
function baseAggregator(collection, setter, iteratee, accumulator) {
  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function(value, key, collection) {
    setter(accumulator, value, iteratee(value), collection);
  });
  return accumulator;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseAggregator);


/***/ }),

/***/ "./node_modules/lodash-es/_baseDifference.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_baseDifference.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _SetCache_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_SetCache.js */ "./node_modules/lodash-es/_SetCache.js");
/* harmony import */ var _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayIncludes.js */ "./node_modules/lodash-es/_arrayIncludes.js");
/* harmony import */ var _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_arrayIncludesWith.js */ "./node_modules/lodash-es/_arrayIncludesWith.js");
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_cacheHas.js */ "./node_modules/lodash-es/_cacheHas.js");







/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = _arrayIncludes_js__WEBPACK_IMPORTED_MODULE_0__["default"],
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_1__["default"])(values, (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_2__["default"])(iteratee));
  }
  if (comparator) {
    includes = _arrayIncludesWith_js__WEBPACK_IMPORTED_MODULE_3__["default"];
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = _cacheHas_js__WEBPACK_IMPORTED_MODULE_4__["default"];
    isCommon = false;
    values = new _SetCache_js__WEBPACK_IMPORTED_MODULE_5__["default"](values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee == null ? value : iteratee(value);

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseDifference);


/***/ }),

/***/ "./node_modules/lodash-es/_baseEvery.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseEvery.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");


/**
 * The base implementation of `_.every` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`
 */
function baseEvery(collection, predicate) {
  var result = true;
  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function(value, index, collection) {
    result = !!predicate(value, index, collection);
    return result;
  });
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseEvery);


/***/ }),

/***/ "./node_modules/lodash-es/_baseIsRegExp.js":
/*!*************************************************!*\
  !*** ./node_modules/lodash-es/_baseIsRegExp.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseGetTag.js */ "./node_modules/lodash-es/_baseGetTag.js");
/* harmony import */ var _isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isObjectLike.js */ "./node_modules/lodash-es/isObjectLike.js");



/** `Object#toString` result references. */
var regexpTag = '[object RegExp]';

/**
 * The base implementation of `_.isRegExp` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 */
function baseIsRegExp(value) {
  return (0,_isObjectLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value) && (0,_baseGetTag_js__WEBPACK_IMPORTED_MODULE_1__["default"])(value) == regexpTag;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseIsRegExp);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSlice.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_baseSlice.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSlice);


/***/ }),

/***/ "./node_modules/lodash-es/_baseSome.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/_baseSome.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseEach_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseEach.js */ "./node_modules/lodash-es/_baseEach.js");


/**
 * The base implementation of `_.some` without support for iteratee shorthands.
 *
 * @private
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function baseSome(collection, predicate) {
  var result;

  (0,_baseEach_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection, function(value, index, collection) {
    result = predicate(value, index, collection);
    return !result;
  });
  return !!result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (baseSome);


/***/ }),

/***/ "./node_modules/lodash-es/_castSlice.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/_castSlice.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSlice_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseSlice.js */ "./node_modules/lodash-es/_baseSlice.js");


/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : (0,_baseSlice_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, start, end);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (castSlice);


/***/ }),

/***/ "./node_modules/lodash-es/_createAggregator.js":
/*!*****************************************************!*\
  !*** ./node_modules/lodash-es/_createAggregator.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayAggregator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayAggregator.js */ "./node_modules/lodash-es/_arrayAggregator.js");
/* harmony import */ var _baseAggregator_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseAggregator.js */ "./node_modules/lodash-es/_baseAggregator.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");





/**
 * Creates a function like `_.groupBy`.
 *
 * @private
 * @param {Function} setter The function to set accumulator values.
 * @param {Function} [initializer] The accumulator object initializer.
 * @returns {Function} Returns the new aggregator function.
 */
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? _arrayAggregator_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _baseAggregator_js__WEBPACK_IMPORTED_MODULE_2__["default"],
        accumulator = initializer ? initializer() : {};

    return func(collection, setter, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_3__["default"])(iteratee, 2), accumulator);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createAggregator);


/***/ }),

/***/ "./node_modules/lodash-es/_createCaseFirst.js":
/*!****************************************************!*\
  !*** ./node_modules/lodash-es/_createCaseFirst.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _castSlice_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_castSlice.js */ "./node_modules/lodash-es/_castSlice.js");
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_hasUnicode.js */ "./node_modules/lodash-es/_hasUnicode.js");
/* harmony import */ var _stringToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_stringToArray.js */ "./node_modules/lodash-es/_stringToArray.js");
/* harmony import */ var _toString_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toString.js */ "./node_modules/lodash-es/toString.js");





/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = (0,_toString_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string);

    var strSymbols = (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string)
      ? (0,_stringToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? (0,_castSlice_js__WEBPACK_IMPORTED_MODULE_3__["default"])(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (createCaseFirst);


/***/ }),

/***/ "./node_modules/lodash-es/_stringToArray.js":
/*!**************************************************!*\
  !*** ./node_modules/lodash-es/_stringToArray.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _asciiToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_asciiToArray.js */ "./node_modules/lodash-es/_asciiToArray.js");
/* harmony import */ var _hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_hasUnicode.js */ "./node_modules/lodash-es/_hasUnicode.js");
/* harmony import */ var _unicodeToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_unicodeToArray.js */ "./node_modules/lodash-es/_unicodeToArray.js");




/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return (0,_hasUnicode_js__WEBPACK_IMPORTED_MODULE_0__["default"])(string)
    ? (0,_unicodeToArray_js__WEBPACK_IMPORTED_MODULE_1__["default"])(string)
    : (0,_asciiToArray_js__WEBPACK_IMPORTED_MODULE_2__["default"])(string);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (stringToArray);


/***/ }),

/***/ "./node_modules/lodash-es/_unicodeToArray.js":
/*!***************************************************!*\
  !*** ./node_modules/lodash-es/_unicodeToArray.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (unicodeToArray);


/***/ }),

/***/ "./node_modules/lodash-es/assign.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/assign.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _assignValue_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_assignValue.js */ "./node_modules/lodash-es/_assignValue.js");
/* harmony import */ var _copyObject_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_copyObject.js */ "./node_modules/lodash-es/_copyObject.js");
/* harmony import */ var _createAssigner_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAssigner.js */ "./node_modules/lodash-es/_createAssigner.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
/* harmony import */ var _isPrototype_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_isPrototype.js */ "./node_modules/lodash-es/_isPrototype.js");
/* harmony import */ var _keys_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./keys.js */ "./node_modules/lodash-es/keys.js");







/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Assigns own enumerable string keyed properties of source objects to the
 * destination object. Source objects are applied from left to right.
 * Subsequent sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object` and is loosely based on
 * [`Object.assign`](https://mdn.io/Object/assign).
 *
 * @static
 * @memberOf _
 * @since 0.10.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assignIn
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assign({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'c': 3 }
 */
var assign = (0,_createAssigner_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(object, source) {
  if ((0,_isPrototype_js__WEBPACK_IMPORTED_MODULE_1__["default"])(source) || (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_2__["default"])(source)) {
    (0,_copyObject_js__WEBPACK_IMPORTED_MODULE_3__["default"])(source, (0,_keys_js__WEBPACK_IMPORTED_MODULE_4__["default"])(source), object);
    return;
  }
  for (var key in source) {
    if (hasOwnProperty.call(source, key)) {
      (0,_assignValue_js__WEBPACK_IMPORTED_MODULE_5__["default"])(object, key, source[key]);
    }
  }
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (assign);


/***/ }),

/***/ "./node_modules/lodash-es/clone.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/clone.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseClone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseClone.js */ "./node_modules/lodash-es/_baseClone.js");


/** Used to compose bitmasks for cloning. */
var CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone(value) {
  return (0,_baseClone_js__WEBPACK_IMPORTED_MODULE_0__["default"])(value, CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (clone);


/***/ }),

/***/ "./node_modules/lodash-es/compact.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/compact.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Creates an array with all falsey values removed. The values `false`, `null`,
 * `0`, `""`, `undefined`, and `NaN` are falsey.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to compact.
 * @returns {Array} Returns the new array of filtered values.
 * @example
 *
 * _.compact([0, 1, false, 2, '', 3]);
 * // => [1, 2, 3]
 */
function compact(array) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (compact);


/***/ }),

/***/ "./node_modules/lodash-es/difference.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/difference.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseDifference_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseDifference.js */ "./node_modules/lodash-es/_baseDifference.js");
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_baseFlatten.js */ "./node_modules/lodash-es/_baseFlatten.js");
/* harmony import */ var _baseRest_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseRest.js */ "./node_modules/lodash-es/_baseRest.js");
/* harmony import */ var _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isArrayLikeObject.js */ "./node_modules/lodash-es/isArrayLikeObject.js");





/**
 * Creates an array of `array` values not included in the other given arrays
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. The order and references of result values are
 * determined by the first array.
 *
 * **Note:** Unlike `_.pullAll`, this method returns a new array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {...Array} [values] The values to exclude.
 * @returns {Array} Returns the new array of filtered values.
 * @see _.without, _.xor
 * @example
 *
 * _.difference([2, 1], [2, 3]);
 * // => [1]
 */
var difference = (0,_baseRest_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(array, values) {
  return (0,_isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array)
    ? (0,_baseDifference_js__WEBPACK_IMPORTED_MODULE_2__["default"])(array, (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_3__["default"])(values, 1, _isArrayLikeObject_js__WEBPACK_IMPORTED_MODULE_1__["default"], true))
    : [];
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (difference);


/***/ }),

/***/ "./node_modules/lodash-es/drop.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/drop.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSlice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSlice.js */ "./node_modules/lodash-es/_baseSlice.js");
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toInteger.js */ "./node_modules/lodash-es/toInteger.js");



/**
 * Creates a slice of `array` with `n` elements dropped from the beginning.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.drop([1, 2, 3]);
 * // => [2, 3]
 *
 * _.drop([1, 2, 3], 2);
 * // => [3]
 *
 * _.drop([1, 2, 3], 5);
 * // => []
 *
 * _.drop([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function drop(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n);
  return (0,_baseSlice_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, n < 0 ? 0 : n, length);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (drop);


/***/ }),

/***/ "./node_modules/lodash-es/dropRight.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash-es/dropRight.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseSlice_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseSlice.js */ "./node_modules/lodash-es/_baseSlice.js");
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toInteger.js */ "./node_modules/lodash-es/toInteger.js");



/**
 * Creates a slice of `array` with `n` elements dropped from the end.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Array
 * @param {Array} array The array to query.
 * @param {number} [n=1] The number of elements to drop.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the slice of `array`.
 * @example
 *
 * _.dropRight([1, 2, 3]);
 * // => [1, 2]
 *
 * _.dropRight([1, 2, 3], 2);
 * // => [1]
 *
 * _.dropRight([1, 2, 3], 5);
 * // => []
 *
 * _.dropRight([1, 2, 3], 0);
 * // => [1, 2, 3]
 */
function dropRight(array, n, guard) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return [];
  }
  n = (guard || n === undefined) ? 1 : (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_0__["default"])(n);
  n = length - n;
  return (0,_baseSlice_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, 0, n < 0 ? 0 : n);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (dropRight);


/***/ }),

/***/ "./node_modules/lodash-es/every.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash-es/every.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayEvery_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayEvery.js */ "./node_modules/lodash-es/_arrayEvery.js");
/* harmony import */ var _baseEvery_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseEvery.js */ "./node_modules/lodash-es/_baseEvery.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js");






/**
 * Checks if `predicate` returns truthy for **all** elements of `collection`.
 * Iteration is stopped once `predicate` returns falsey. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * **Note:** This method returns `true` for
 * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
 * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
 * elements of empty collections.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if all elements pass the predicate check,
 *  else `false`.
 * @example
 *
 * _.every([true, 1, null, 'yes'], Boolean);
 * // => false
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.every(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.every(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.every(users, 'active');
 * // => false
 */
function every(collection, predicate, guard) {
  var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? _arrayEvery_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _baseEvery_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_3__["default"])(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_4__["default"])(predicate, 3));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (every);


/***/ }),

/***/ "./node_modules/lodash-es/flatMap.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/flatMap.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseFlatten.js */ "./node_modules/lodash-es/_baseFlatten.js");
/* harmony import */ var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./map.js */ "./node_modules/lodash-es/map.js");



/**
 * Creates a flattened array of values by running each element in `collection`
 * thru `iteratee` and flattening the mapped results. The iteratee is invoked
 * with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new flattened array.
 * @example
 *
 * function duplicate(n) {
 *   return [n, n];
 * }
 *
 * _.flatMap([1, 2], duplicate);
 * // => [1, 1, 2, 2]
 */
function flatMap(collection, iteratee) {
  return (0,_baseFlatten_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_map_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection, iteratee), 1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (flatMap);


/***/ }),

/***/ "./node_modules/lodash-es/groupBy.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/groupBy.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseAssignValue.js */ "./node_modules/lodash-es/_baseAssignValue.js");
/* harmony import */ var _createAggregator_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createAggregator.js */ "./node_modules/lodash-es/_createAggregator.js");



/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an object composed of keys generated from the results of running
 * each element of `collection` thru `iteratee`. The order of grouped values
 * is determined by the order they occur in `collection`. The corresponding
 * value of each key is an array of elements responsible for generating the
 * key. The iteratee is invoked with one argument: (value).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
 * @returns {Object} Returns the composed aggregate object.
 * @example
 *
 * _.groupBy([6.1, 4.2, 6.3], Math.floor);
 * // => { '4': [4.2], '6': [6.1, 6.3] }
 *
 * // The `_.property` iteratee shorthand.
 * _.groupBy(['one', 'two', 'three'], 'length');
 * // => { '3': ['one', 'two'], '5': ['three'] }
 */
var groupBy = (0,_createAggregator_js__WEBPACK_IMPORTED_MODULE_0__["default"])(function(result, value, key) {
  if (hasOwnProperty.call(result, key)) {
    result[key].push(value);
  } else {
    (0,_baseAssignValue_js__WEBPACK_IMPORTED_MODULE_1__["default"])(result, key, [value]);
  }
});

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (groupBy);


/***/ }),

/***/ "./node_modules/lodash-es/head.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/head.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head(array) {
  return (array && array.length) ? array[0] : undefined;
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (head);


/***/ }),

/***/ "./node_modules/lodash-es/includes.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/includes.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIndexOf_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseIndexOf.js */ "./node_modules/lodash-es/_baseIndexOf.js");
/* harmony import */ var _isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArrayLike.js */ "./node_modules/lodash-es/isArrayLike.js");
/* harmony import */ var _isString_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./isString.js */ "./node_modules/lodash-es/isString.js");
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./toInteger.js */ "./node_modules/lodash-es/toInteger.js");
/* harmony import */ var _values_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./values.js */ "./node_modules/lodash-es/values.js");






/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */
function includes(collection, value, fromIndex, guard) {
  collection = (0,_isArrayLike_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? collection : (0,_values_js__WEBPACK_IMPORTED_MODULE_1__["default"])(collection);
  fromIndex = (fromIndex && !guard) ? (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_2__["default"])(fromIndex) : 0;

  var length = collection.length;
  if (fromIndex < 0) {
    fromIndex = nativeMax(length + fromIndex, 0);
  }
  return (0,_isString_js__WEBPACK_IMPORTED_MODULE_3__["default"])(collection)
    ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
    : (!!length && (0,_baseIndexOf_js__WEBPACK_IMPORTED_MODULE_4__["default"])(collection, value, fromIndex) > -1);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (includes);


/***/ }),

/***/ "./node_modules/lodash-es/indexOf.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash-es/indexOf.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIndexOf_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIndexOf.js */ "./node_modules/lodash-es/_baseIndexOf.js");
/* harmony import */ var _toInteger_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./toInteger.js */ "./node_modules/lodash-es/toInteger.js");



/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Gets the index at which the first occurrence of `value` is found in `array`
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons. If `fromIndex` is negative, it's used as the
 * offset from the end of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 * @example
 *
 * _.indexOf([1, 2, 1, 2], 2);
 * // => 1
 *
 * // Search from the `fromIndex`.
 * _.indexOf([1, 2, 1, 2], 2, 2);
 * // => 3
 */
function indexOf(array, value, fromIndex) {
  var length = array == null ? 0 : array.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : (0,_toInteger_js__WEBPACK_IMPORTED_MODULE_0__["default"])(fromIndex);
  if (index < 0) {
    index = nativeMax(length + index, 0);
  }
  return (0,_baseIndexOf_js__WEBPACK_IMPORTED_MODULE_1__["default"])(array, value, index);
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (indexOf);


/***/ }),

/***/ "./node_modules/lodash-es/isRegExp.js":
/*!********************************************!*\
  !*** ./node_modules/lodash-es/isRegExp.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIsRegExp_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIsRegExp.js */ "./node_modules/lodash-es/_baseIsRegExp.js");
/* harmony import */ var _baseUnary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseUnary.js */ "./node_modules/lodash-es/_baseUnary.js");
/* harmony import */ var _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_nodeUtil.js */ "./node_modules/lodash-es/_nodeUtil.js");




/* Node.js helper references. */
var nodeIsRegExp = _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"] && _nodeUtil_js__WEBPACK_IMPORTED_MODULE_0__["default"].isRegExp;

/**
 * Checks if `value` is classified as a `RegExp` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
 * @example
 *
 * _.isRegExp(/abc/);
 * // => true
 *
 * _.isRegExp('/abc/');
 * // => false
 */
var isRegExp = nodeIsRegExp ? (0,_baseUnary_js__WEBPACK_IMPORTED_MODULE_1__["default"])(nodeIsRegExp) : _baseIsRegExp_js__WEBPACK_IMPORTED_MODULE_2__["default"];

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isRegExp);


/***/ }),

/***/ "./node_modules/lodash-es/negate.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/negate.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that negates the result of the predicate `func`. The
 * `func` predicate is invoked with the `this` binding and arguments of the
 * created function.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {Function} predicate The predicate to negate.
 * @returns {Function} Returns the new negated function.
 * @example
 *
 * function isEven(n) {
 *   return n % 2 == 0;
 * }
 *
 * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
 * // => [1, 3, 5]
 */
function negate(predicate) {
  if (typeof predicate != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  return function() {
    var args = arguments;
    switch (args.length) {
      case 0: return !predicate.call(this);
      case 1: return !predicate.call(this, args[0]);
      case 2: return !predicate.call(this, args[0], args[1]);
      case 3: return !predicate.call(this, args[0], args[1], args[2]);
    }
    return !predicate.apply(this, args);
  };
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (negate);


/***/ }),

/***/ "./node_modules/lodash-es/pickBy.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/pickBy.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayMap_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_arrayMap.js */ "./node_modules/lodash-es/_arrayMap.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _basePickBy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_basePickBy.js */ "./node_modules/lodash-es/_basePickBy.js");
/* harmony import */ var _getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_getAllKeysIn.js */ "./node_modules/lodash-es/_getAllKeysIn.js");





/**
 * Creates an object composed of the `object` properties `predicate` returns
 * truthy for. The predicate is invoked with two arguments: (value, key).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The source object.
 * @param {Function} [predicate=_.identity] The function invoked per property.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.pickBy(object, _.isNumber);
 * // => { 'a': 1, 'c': 3 }
 */
function pickBy(object, predicate) {
  if (object == null) {
    return {};
  }
  var props = (0,_arrayMap_js__WEBPACK_IMPORTED_MODULE_0__["default"])((0,_getAllKeysIn_js__WEBPACK_IMPORTED_MODULE_1__["default"])(object), function(prop) {
    return [prop];
  });
  predicate = (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_2__["default"])(predicate);
  return (0,_basePickBy_js__WEBPACK_IMPORTED_MODULE_3__["default"])(object, props, function(value, path) {
    return predicate(value, path[0]);
  });
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (pickBy);


/***/ }),

/***/ "./node_modules/lodash-es/reject.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/reject.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arrayFilter_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arrayFilter.js */ "./node_modules/lodash-es/_arrayFilter.js");
/* harmony import */ var _baseFilter_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseFilter.js */ "./node_modules/lodash-es/_baseFilter.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _negate_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./negate.js */ "./node_modules/lodash-es/negate.js");






/**
 * The opposite of `_.filter`; this method returns the elements of `collection`
 * that `predicate` does **not** return truthy for.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 * @see _.filter
 * @example
 *
 * var users = [
 *   { 'user': 'barney', 'age': 36, 'active': false },
 *   { 'user': 'fred',   'age': 40, 'active': true }
 * ];
 *
 * _.reject(users, function(o) { return !o.active; });
 * // => objects for ['fred']
 *
 * // The `_.matches` iteratee shorthand.
 * _.reject(users, { 'age': 40, 'active': true });
 * // => objects for ['barney']
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.reject(users, ['active', false]);
 * // => objects for ['fred']
 *
 * // The `_.property` iteratee shorthand.
 * _.reject(users, 'active');
 * // => objects for ['barney']
 */
function reject(collection, predicate) {
  var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? _arrayFilter_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _baseFilter_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  return func(collection, (0,_negate_js__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_4__["default"])(predicate, 3)));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (reject);


/***/ }),

/***/ "./node_modules/lodash-es/some.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/some.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _arraySome_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_arraySome.js */ "./node_modules/lodash-es/_arraySome.js");
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _baseSome_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_baseSome.js */ "./node_modules/lodash-es/_baseSome.js");
/* harmony import */ var _isArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./isArray.js */ "./node_modules/lodash-es/isArray.js");
/* harmony import */ var _isIterateeCall_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_isIterateeCall.js */ "./node_modules/lodash-es/_isIterateeCall.js");






/**
 * Checks if `predicate` returns truthy for **any** element of `collection`.
 * Iteration is stopped once `predicate` returns truthy. The predicate is
 * invoked with three arguments: (value, index|key, collection).
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object} collection The collection to iterate over.
 * @param {Function} [predicate=_.identity] The function invoked per iteration.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 * @example
 *
 * _.some([null, 0, 'yes', false], Boolean);
 * // => true
 *
 * var users = [
 *   { 'user': 'barney', 'active': true },
 *   { 'user': 'fred',   'active': false }
 * ];
 *
 * // The `_.matches` iteratee shorthand.
 * _.some(users, { 'user': 'barney', 'active': false });
 * // => false
 *
 * // The `_.matchesProperty` iteratee shorthand.
 * _.some(users, ['active', false]);
 * // => true
 *
 * // The `_.property` iteratee shorthand.
 * _.some(users, 'active');
 * // => true
 */
function some(collection, predicate, guard) {
  var func = (0,_isArray_js__WEBPACK_IMPORTED_MODULE_0__["default"])(collection) ? _arraySome_js__WEBPACK_IMPORTED_MODULE_1__["default"] : _baseSome_js__WEBPACK_IMPORTED_MODULE_2__["default"];
  if (guard && (0,_isIterateeCall_js__WEBPACK_IMPORTED_MODULE_3__["default"])(collection, predicate, guard)) {
    predicate = undefined;
  }
  return func(collection, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_4__["default"])(predicate, 3));
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (some);


/***/ }),

/***/ "./node_modules/lodash-es/uniq.js":
/*!****************************************!*\
  !*** ./node_modules/lodash-es/uniq.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseUniq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseUniq.js */ "./node_modules/lodash-es/_baseUniq.js");


/**
 * Creates a duplicate-free version of an array, using
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons, in which only the first occurrence of each element
 * is kept. The order of result values is determined by the order they occur
 * in the array.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniq([2, 1, 2]);
 * // => [2, 1]
 */
function uniq(array) {
  return (array && array.length) ? (0,_baseUniq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array) : [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniq);


/***/ }),

/***/ "./node_modules/lodash-es/uniqBy.js":
/*!******************************************!*\
  !*** ./node_modules/lodash-es/uniqBy.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_baseIteratee.js */ "./node_modules/lodash-es/_baseIteratee.js");
/* harmony import */ var _baseUniq_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_baseUniq.js */ "./node_modules/lodash-es/_baseUniq.js");



/**
 * This method is like `_.uniq` except that it accepts `iteratee` which is
 * invoked for each element in `array` to generate the criterion by which
 * uniqueness is computed. The order of result values is determined by the
 * order they occur in the array. The iteratee is invoked with one argument:
 * (value).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Array
 * @param {Array} array The array to inspect.
 * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
 * @returns {Array} Returns the new duplicate free array.
 * @example
 *
 * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
 * // => [2.1, 1.2]
 *
 * // The `_.property` iteratee shorthand.
 * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
 * // => [{ 'x': 1 }, { 'x': 2 }]
 */
function uniqBy(array, iteratee) {
  return (array && array.length) ? (0,_baseUniq_js__WEBPACK_IMPORTED_MODULE_0__["default"])(array, (0,_baseIteratee_js__WEBPACK_IMPORTED_MODULE_1__["default"])(iteratee, 2)) : [];
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (uniqBy);


/***/ }),

/***/ "./node_modules/lodash-es/upperFirst.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash-es/upperFirst.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_createCaseFirst.js */ "./node_modules/lodash-es/_createCaseFirst.js");


/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = (0,_createCaseFirst_js__WEBPACK_IMPORTED_MODULE_0__["default"])('toUpperCase');

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (upperFirst);


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/cancellation.js":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/cancellation.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
const Is = __webpack_require__(/*! ./is */ "./node_modules/vscode-jsonrpc/lib/common/is.js");
const events_1 = __webpack_require__(/*! ./events */ "./node_modules/vscode-jsonrpc/lib/common/events.js");
var CancellationToken;
(function (CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None
            || candidate === CancellationToken.Cancelled
            || (Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested));
    }
    CancellationToken.is = is;
})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
const shortcutEvent = Object.freeze(function (callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return { dispose() { handle.dispose(); } };
});
class MutableToken {
    constructor() {
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        }
        else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        }
        else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/events.js":
/*!**********************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/events.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Emitter = exports.Event = void 0;
const ral_1 = __webpack_require__(/*! ./ral */ "./node_modules/vscode-jsonrpc/lib/common/ral.js");
var Event;
(function (Event) {
    const _disposable = { dispose() { } };
    Event.None = function () { return _disposable; };
})(Event || (exports.Event = Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({ dispose: () => this.remove(callback, context) });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for (let i = 0, len = this._callbacks.length; i < len; i++) {
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                }
                else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for (let i = 0, len = callbacks.length; i < len; i++) {
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            }
            catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables) => {
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: () => {
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function () { };


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/is.js":
/*!******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/is.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every(elem => string(elem));
}
exports.stringArray = stringArray;


/***/ }),

/***/ "./node_modules/vscode-jsonrpc/lib/common/ral.js":
/*!*******************************************************!*\
  !*** ./node_modules/vscode-jsonrpc/lib/common/ral.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
Object.defineProperty(exports, "__esModule", ({ value: true }));
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function (RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports["default"] = RAL;


/***/ }),

/***/ "./node_modules/vscode-languageserver-textdocument/lib/esm/main.js":
/*!*************************************************************************!*\
  !*** ./node_modules/vscode-languageserver-textdocument/lib/esm/main.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   TextDocument: () => (/* binding */ TextDocument)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(changes, version) {
        for (const change of changes) {
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                const range = getWellformedRange(change.range);
                // update content
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (let i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            const mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return { line, character: offset - lineOffsets[line] };
    }
    offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
            return lineOffset;
        }
        const nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
    }
    ensureBeforeEOL(offset, lineOffset) {
        while (offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))) {
            offset--;
        }
        return offset;
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
    static isIncremental(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    static isFull(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
}
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b) => {
            const diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits) {
            const startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            }
            else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = (data.length / 2) | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        const ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [textOffset] : [];
    for (let i = 0; i < text.length; i++) {
        const ch = text.charCodeAt(i);
        if (isEOL(ch)) {
            if (ch === 13 /* CharCode.CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function isEOL(char) {
    return char === 13 /* CharCode.CarriageReturn */ || char === 10 /* CharCode.LineFeed */;
}
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range };
    }
    return textEdit;
}


/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/esm/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/esm/main.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   AnnotatedTextEdit: () => (/* binding */ AnnotatedTextEdit),
/* harmony export */   ChangeAnnotation: () => (/* binding */ ChangeAnnotation),
/* harmony export */   ChangeAnnotationIdentifier: () => (/* binding */ ChangeAnnotationIdentifier),
/* harmony export */   CodeAction: () => (/* binding */ CodeAction),
/* harmony export */   CodeActionContext: () => (/* binding */ CodeActionContext),
/* harmony export */   CodeActionKind: () => (/* binding */ CodeActionKind),
/* harmony export */   CodeActionTriggerKind: () => (/* binding */ CodeActionTriggerKind),
/* harmony export */   CodeDescription: () => (/* binding */ CodeDescription),
/* harmony export */   CodeLens: () => (/* binding */ CodeLens),
/* harmony export */   Color: () => (/* binding */ Color),
/* harmony export */   ColorInformation: () => (/* binding */ ColorInformation),
/* harmony export */   ColorPresentation: () => (/* binding */ ColorPresentation),
/* harmony export */   Command: () => (/* binding */ Command),
/* harmony export */   CompletionItem: () => (/* binding */ CompletionItem),
/* harmony export */   CompletionItemKind: () => (/* binding */ CompletionItemKind),
/* harmony export */   CompletionItemLabelDetails: () => (/* binding */ CompletionItemLabelDetails),
/* harmony export */   CompletionItemTag: () => (/* binding */ CompletionItemTag),
/* harmony export */   CompletionList: () => (/* binding */ CompletionList),
/* harmony export */   CreateFile: () => (/* binding */ CreateFile),
/* harmony export */   DeleteFile: () => (/* binding */ DeleteFile),
/* harmony export */   Diagnostic: () => (/* binding */ Diagnostic),
/* harmony export */   DiagnosticRelatedInformation: () => (/* binding */ DiagnosticRelatedInformation),
/* harmony export */   DiagnosticSeverity: () => (/* binding */ DiagnosticSeverity),
/* harmony export */   DiagnosticTag: () => (/* binding */ DiagnosticTag),
/* harmony export */   DocumentHighlight: () => (/* binding */ DocumentHighlight),
/* harmony export */   DocumentHighlightKind: () => (/* binding */ DocumentHighlightKind),
/* harmony export */   DocumentLink: () => (/* binding */ DocumentLink),
/* harmony export */   DocumentSymbol: () => (/* binding */ DocumentSymbol),
/* harmony export */   DocumentUri: () => (/* binding */ DocumentUri),
/* harmony export */   EOL: () => (/* binding */ EOL),
/* harmony export */   FoldingRange: () => (/* binding */ FoldingRange),
/* harmony export */   FoldingRangeKind: () => (/* binding */ FoldingRangeKind),
/* harmony export */   FormattingOptions: () => (/* binding */ FormattingOptions),
/* harmony export */   Hover: () => (/* binding */ Hover),
/* harmony export */   InlayHint: () => (/* binding */ InlayHint),
/* harmony export */   InlayHintKind: () => (/* binding */ InlayHintKind),
/* harmony export */   InlayHintLabelPart: () => (/* binding */ InlayHintLabelPart),
/* harmony export */   InlineCompletionContext: () => (/* binding */ InlineCompletionContext),
/* harmony export */   InlineCompletionItem: () => (/* binding */ InlineCompletionItem),
/* harmony export */   InlineCompletionList: () => (/* binding */ InlineCompletionList),
/* harmony export */   InlineCompletionTriggerKind: () => (/* binding */ InlineCompletionTriggerKind),
/* harmony export */   InlineValueContext: () => (/* binding */ InlineValueContext),
/* harmony export */   InlineValueEvaluatableExpression: () => (/* binding */ InlineValueEvaluatableExpression),
/* harmony export */   InlineValueText: () => (/* binding */ InlineValueText),
/* harmony export */   InlineValueVariableLookup: () => (/* binding */ InlineValueVariableLookup),
/* harmony export */   InsertReplaceEdit: () => (/* binding */ InsertReplaceEdit),
/* harmony export */   InsertTextFormat: () => (/* binding */ InsertTextFormat),
/* harmony export */   InsertTextMode: () => (/* binding */ InsertTextMode),
/* harmony export */   Location: () => (/* binding */ Location),
/* harmony export */   LocationLink: () => (/* binding */ LocationLink),
/* harmony export */   MarkedString: () => (/* binding */ MarkedString),
/* harmony export */   MarkupContent: () => (/* binding */ MarkupContent),
/* harmony export */   MarkupKind: () => (/* binding */ MarkupKind),
/* harmony export */   OptionalVersionedTextDocumentIdentifier: () => (/* binding */ OptionalVersionedTextDocumentIdentifier),
/* harmony export */   ParameterInformation: () => (/* binding */ ParameterInformation),
/* harmony export */   Position: () => (/* binding */ Position),
/* harmony export */   Range: () => (/* binding */ Range),
/* harmony export */   RenameFile: () => (/* binding */ RenameFile),
/* harmony export */   SelectedCompletionInfo: () => (/* binding */ SelectedCompletionInfo),
/* harmony export */   SelectionRange: () => (/* binding */ SelectionRange),
/* harmony export */   SemanticTokenModifiers: () => (/* binding */ SemanticTokenModifiers),
/* harmony export */   SemanticTokenTypes: () => (/* binding */ SemanticTokenTypes),
/* harmony export */   SemanticTokens: () => (/* binding */ SemanticTokens),
/* harmony export */   SignatureInformation: () => (/* binding */ SignatureInformation),
/* harmony export */   StringValue: () => (/* binding */ StringValue),
/* harmony export */   SymbolInformation: () => (/* binding */ SymbolInformation),
/* harmony export */   SymbolKind: () => (/* binding */ SymbolKind),
/* harmony export */   SymbolTag: () => (/* binding */ SymbolTag),
/* harmony export */   TextDocument: () => (/* binding */ TextDocument),
/* harmony export */   TextDocumentEdit: () => (/* binding */ TextDocumentEdit),
/* harmony export */   TextDocumentIdentifier: () => (/* binding */ TextDocumentIdentifier),
/* harmony export */   TextDocumentItem: () => (/* binding */ TextDocumentItem),
/* harmony export */   TextEdit: () => (/* binding */ TextEdit),
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   VersionedTextDocumentIdentifier: () => (/* binding */ VersionedTextDocumentIdentifier),
/* harmony export */   WorkspaceChange: () => (/* binding */ WorkspaceChange),
/* harmony export */   WorkspaceEdit: () => (/* binding */ WorkspaceEdit),
/* harmony export */   WorkspaceFolder: () => (/* binding */ WorkspaceFolder),
/* harmony export */   WorkspaceSymbol: () => (/* binding */ WorkspaceSymbol),
/* harmony export */   integer: () => (/* binding */ integer),
/* harmony export */   uinteger: () => (/* binding */ uinteger)
/* harmony export */ });
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var DocumentUri;
(function (DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function (URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function (integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function (uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
/**
 * The Position namespace provides helper functions to work with
 * {@link Position} literals.
 */
var Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return { line, character };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * {@link Range} literals.
 */
var Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return { start: Position.create(one, two), end: Position.create(three, four) };
        }
        else if (Position.is(one) && Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * {@link Location} literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri, range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * {@link LocationLink} literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
            && Range.is(candidate.targetSelectionRange)
            && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link Color} literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red,
            green,
            blue,
            alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
            && Is.numberRange(candidate.green, 0, 1)
            && Is.numberRange(candidate.blue, 0, 1)
            && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * {@link ColorInformation} literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range,
            color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * {@link ColorPresentation} literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label,
            textEdit,
            additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * A set of predefined range kinds.
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */
    FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * {@link FoldingRange} literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        const result = {
            startLine,
            endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * {@link DiagnosticRelatedInformation} literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location,
            message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
 *
 * @since 3.16.0
 */
var CodeDescription;
(function (CodeDescription) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * {@link Diagnostic} literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        let result = { range, message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */
    function is(value) {
        var _a;
        let candidate = value;
        return Is.defined(candidate)
            && Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * {@link Command} literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command, ...args) {
        let result = { title, command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range, newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function (ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        const result = { label };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
            (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function (ChangeAnnotationIdentifier) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function (AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */
    function replace(range, newText, annotation) {
        return { range, newText, annotationId: annotation };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */
    function insert(position, newText, annotation) {
        return { range: { start: position, end: position }, newText, annotationId: annotation };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */
    function del(range, annotation) {
        return { range, newText: '', annotationId: annotation };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        const candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument, edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        let candidate = value;
        return Is.defined(candidate)
            && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options, annotation) {
        let result = {
            kind: 'create',
            uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        let result = {
            kind: 'rename',
            oldUri,
            newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
            ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options, annotation) {
        let result = {
            kind: 'delete',
            uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
            ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        let candidate = value;
        return candidate &&
            (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
            (candidate.documentChanges === undefined || candidate.documentChanges.every((change) => {
                if (Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
class TextEditChangeImpl {
    constructor(edits, changeAnnotations) {
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    insert(position, newText, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    replace(range, newText, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    delete(range, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        }
        else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        }
        else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    add(edit) {
        this.edits.push(edit);
    }
    all() {
        return this.edits;
    }
    clear() {
        this.edits.splice(0, this.edits.length);
    }
    assertChangeAnnotations(value) {
        if (value === undefined) {
            throw new Error(`Text edit change is not configured to manage change annotations.`);
        }
    }
}
/**
 * A helper class
 */
class ChangeAnnotations {
    constructor(annotations) {
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    all() {
        return this._annotations;
    }
    get size() {
        return this._size;
    }
    manage(idOrAnnotation, annotation) {
        let id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        }
        else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error(`Id ${id} is already in use.`);
        }
        if (annotation === undefined) {
            throw new Error(`No annotation provided for id ${id}`);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    }
    nextId() {
        this._counter++;
        return this._counter.toString();
    }
}
/**
 * A workspace change helps constructing changes to a workspace.
 */
class WorkspaceChange {
    constructor(workspaceEdit) {
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach((change) => {
                    if (TextDocumentEdit.is(change)) {
                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                        this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach((key) => {
                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    this._textEditChanges[key] = textEditChange;
                });
            }
        }
        else {
            this._workspaceEdit = {};
        }
    }
    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */
    get edit() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== undefined) {
            if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = undefined;
            }
            else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
        }
        return this._workspaceEdit;
    }
    getTextEditChange(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            const textDocument = { uri: key.uri, version: key.version };
            let result = this._textEditChanges[textDocument.uri];
            if (!result) {
                const edits = [];
                const textDocumentEdit = {
                    textDocument,
                    edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            let result = this._textEditChanges[key];
            if (!result) {
                let edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    }
    initDocumentChanges() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    }
    initChanges() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    }
    createFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
    deleteFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        }
        else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        }
        else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
}
/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * {@link TextDocumentIdentifier} literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link VersionedTextDocumentIdentifier} literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri, version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
 * {@link OptionalVersionedTextDocumentIdentifier} literals.
 */
var OptionalVersionedTextDocumentIdentifier;
(function (OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */
    function create(uri, version) {
        return { uri, version };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * {@link TextDocumentItem} literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri, languageId, version, text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */
    function is(value) {
        const candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
 *
 * @since 3.16.0
 */
var InsertReplaceEdit;
(function (InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */
    function create(newText, insert, replace) {
        return { newText, insert, replace };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */
    function is(value) {
        const candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
/**
 * How whitespace and indentation is handled during completion
 * item insertion.
 *
 * @since 3.16.0
 */
var InsertTextMode;
(function (InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */
    InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */
    InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function (CompletionItemLabelDetails) {
    function is(value) {
        const candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
            (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */
    function is(value) {
        const candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */
    function is(value) {
        let candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * {@link ParameterInformation} literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label, documentation } : { label };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * {@link SignatureInformation} literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation, ...parameters) {
        let result = { label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * {@link DocumentHighlight} literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */
    function create(range, kind) {
        let result = { range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 *
 * @since 3.16
 */
var SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        let result = {
            name,
            kind,
            location: { uri, range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function (WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */
    function create(name, kind, uri, range) {
        return range !== undefined
            ? { name, kind, location: { uri, range } }
            : { name, kind, location: { uri } };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        let result = {
            name,
            detail,
            kind,
            range,
            selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */
    function is(value) {
        let candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
            (candidate.detail === undefined || Is.string(candidate.detail)) &&
            (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
            (candidate.children === undefined || Array.isArray(candidate.children)) &&
            (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The reason why code actions were requested.
 *
 * @since 3.17.0
 */
var CodeActionTriggerKind;
(function (CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */
    CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */
    CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * {@link CodeActionContext} literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only, triggerKind) {
        let result = { diagnostics };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
            && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
            && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        let result = { title };
        let checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        }
        else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        }
        else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === undefined || Is.string(candidate.kind)) &&
            (candidate.edit !== undefined || candidate.command !== undefined) &&
            (candidate.command === undefined || Command.is(candidate.command)) &&
            (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * {@link CodeLens} literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        let result = { range };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * {@link FormattingOptions} literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize, insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * {@link DocumentLink} literals.
 */
var DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range, target, data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range, parent };
    }
    SelectionRange.create = create;
    function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
/**
 * A set of predefined token types. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenTypes;
(function (SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */
    SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */
    SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
/**
 * A set of predefined token modifiers. This set is not fixed
 * an clients can specify additional token types via the
 * corresponding client capabilities.
 *
 * @since 3.16.0
 */
var SemanticTokenModifiers;
(function (SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
/**
 * @since 3.16.0
 */
var SemanticTokens;
(function (SemanticTokens) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
            Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
/**
 * The InlineValueText namespace provides functions to deal with InlineValueTexts.
 *
 * @since 3.17.0
 */
var InlineValueText;
(function (InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, text) {
        return { range, text };
    }
    InlineValueText.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
/**
 * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
 *
 * @since 3.17.0
 */
var InlineValueVariableLookup;
(function (InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */
    function create(range, variableName, caseSensitiveLookup) {
        return { range, variableName, caseSensitiveLookup };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
            && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
/**
 * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
 *
 * @since 3.17.0
 */
var InlineValueEvaluatableExpression;
(function (InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */
    function create(range, expression) {
        return { range, expression };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range)
            && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
/**
 * The InlineValueContext namespace provides helper functions to work with
 * {@link InlineValueContext} literals.
 *
 * @since 3.17.0
 */
var InlineValueContext;
(function (InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */
    function create(frameId, stoppedLocation) {
        return { frameId, stoppedLocation };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */
    function is(value) {
        const candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
/**
 * Inlay hint kinds.
 *
 * @since 3.17.0
 */
var InlayHintKind;
(function (InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */
    InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */
    InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function (InlayHintLabelPart) {
    function create(value) {
        return { value };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.location === undefined || Location.is(candidate.location))
            && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function (InlayHint) {
    function create(position, label, kind) {
        const result = { position, label };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position)
            && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
            && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
            && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
            && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
            && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
            && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var StringValue;
(function (StringValue) {
    function createSnippet(value) {
        return { kind: 'snippet', value };
    }
    StringValue.createSnippet = createSnippet;
})(StringValue || (StringValue = {}));
var InlineCompletionItem;
(function (InlineCompletionItem) {
    function create(insertText, filterText, range, command) {
        return { insertText, filterText, range, command };
    }
    InlineCompletionItem.create = create;
})(InlineCompletionItem || (InlineCompletionItem = {}));
var InlineCompletionList;
(function (InlineCompletionList) {
    function create(items) {
        return { items };
    }
    InlineCompletionList.create = create;
})(InlineCompletionList || (InlineCompletionList = {}));
/**
 * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
 *
 * @since 3.18.0
 * @proposed
 */
var InlineCompletionTriggerKind;
(function (InlineCompletionTriggerKind) {
    /**
     * Completion was triggered explicitly by a user gesture.
     */
    InlineCompletionTriggerKind.Invoked = 0;
    /**
     * Completion was triggered automatically while editing.
     */
    InlineCompletionTriggerKind.Automatic = 1;
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SelectedCompletionInfo;
(function (SelectedCompletionInfo) {
    function create(range, text) {
        return { range, text };
    }
    SelectedCompletionInfo.create = create;
})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
var InlineCompletionContext;
(function (InlineCompletionContext) {
    function create(triggerKind, selectedCompletionInfo) {
        return { triggerKind, selectedCompletionInfo };
    }
    InlineCompletionContext.create = create;
})(InlineCompletionContext || (InlineCompletionContext = {}));
var WorkspaceFolder;
(function (WorkspaceFolder) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
const EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        let text = document.getText();
        let sortedEdits = mergeSort(edits, (a, b) => {
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = text.length;
        for (let i = sortedEdits.length - 1; i >= 0; i--) {
            let e = sortedEdits[i];
            let startOffset = document.offsetAt(e.range.start);
            let endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        const p = (data.length / 2) | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
class FullTextDocument {
    constructor(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            let start = this.offsetAt(range.start);
            let end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            let lineOffsets = [];
            let text = this._content;
            let isLineStart = true;
            for (let i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                let ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while (low < high) {
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        let line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    }
    offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
}
var Is;
(function (Is) {
    const toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));


/***/ }),

/***/ "./node_modules/vscode-uri/lib/esm/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/vscode-uri/lib/esm/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   URI: () => (/* binding */ URI),
/* harmony export */   Utils: () => (/* binding */ Utils)
/* harmony export */ });
/* provided dependency */ var process = __webpack_require__(/*! process/browser */ "./node_modules/process/browser.js");
var LIB;(()=>{"use strict";var t={470:t=>{function e(t){if("string"!=typeof t)throw new TypeError("Path must be a string. Received "+JSON.stringify(t))}function r(t,e){for(var r,n="",i=0,o=-1,s=0,h=0;h<=t.length;++h){if(h<t.length)r=t.charCodeAt(h);else{if(47===r)break;r=47}if(47===r){if(o===h-1||1===s);else if(o!==h-1&&2===s){if(n.length<2||2!==i||46!==n.charCodeAt(n.length-1)||46!==n.charCodeAt(n.length-2))if(n.length>2){var a=n.lastIndexOf("/");if(a!==n.length-1){-1===a?(n="",i=0):i=(n=n.slice(0,a)).length-1-n.lastIndexOf("/"),o=h,s=0;continue}}else if(2===n.length||1===n.length){n="",i=0,o=h,s=0;continue}e&&(n.length>0?n+="/..":n="..",i=2)}else n.length>0?n+="/"+t.slice(o+1,h):n=t.slice(o+1,h),i=h-o-1;o=h,s=0}else 46===r&&-1!==s?++s:s=-1}return n}var n={resolve:function(){for(var t,n="",i=!1,o=arguments.length-1;o>=-1&&!i;o--){var s;o>=0?s=arguments[o]:(void 0===t&&(t=process.cwd()),s=t),e(s),0!==s.length&&(n=s+"/"+n,i=47===s.charCodeAt(0))}return n=r(n,!i),i?n.length>0?"/"+n:"/":n.length>0?n:"."},normalize:function(t){if(e(t),0===t.length)return".";var n=47===t.charCodeAt(0),i=47===t.charCodeAt(t.length-1);return 0!==(t=r(t,!n)).length||n||(t="."),t.length>0&&i&&(t+="/"),n?"/"+t:t},isAbsolute:function(t){return e(t),t.length>0&&47===t.charCodeAt(0)},join:function(){if(0===arguments.length)return".";for(var t,r=0;r<arguments.length;++r){var i=arguments[r];e(i),i.length>0&&(void 0===t?t=i:t+="/"+i)}return void 0===t?".":n.normalize(t)},relative:function(t,r){if(e(t),e(r),t===r)return"";if((t=n.resolve(t))===(r=n.resolve(r)))return"";for(var i=1;i<t.length&&47===t.charCodeAt(i);++i);for(var o=t.length,s=o-i,h=1;h<r.length&&47===r.charCodeAt(h);++h);for(var a=r.length-h,c=s<a?s:a,f=-1,u=0;u<=c;++u){if(u===c){if(a>c){if(47===r.charCodeAt(h+u))return r.slice(h+u+1);if(0===u)return r.slice(h+u)}else s>c&&(47===t.charCodeAt(i+u)?f=u:0===u&&(f=0));break}var l=t.charCodeAt(i+u);if(l!==r.charCodeAt(h+u))break;47===l&&(f=u)}var g="";for(u=i+f+1;u<=o;++u)u!==o&&47!==t.charCodeAt(u)||(0===g.length?g+="..":g+="/..");return g.length>0?g+r.slice(h+f):(h+=f,47===r.charCodeAt(h)&&++h,r.slice(h))},_makeLong:function(t){return t},dirname:function(t){if(e(t),0===t.length)return".";for(var r=t.charCodeAt(0),n=47===r,i=-1,o=!0,s=t.length-1;s>=1;--s)if(47===(r=t.charCodeAt(s))){if(!o){i=s;break}}else o=!1;return-1===i?n?"/":".":n&&1===i?"//":t.slice(0,i)},basename:function(t,r){if(void 0!==r&&"string"!=typeof r)throw new TypeError('"ext" argument must be a string');e(t);var n,i=0,o=-1,s=!0;if(void 0!==r&&r.length>0&&r.length<=t.length){if(r.length===t.length&&r===t)return"";var h=r.length-1,a=-1;for(n=t.length-1;n>=0;--n){var c=t.charCodeAt(n);if(47===c){if(!s){i=n+1;break}}else-1===a&&(s=!1,a=n+1),h>=0&&(c===r.charCodeAt(h)?-1==--h&&(o=n):(h=-1,o=a))}return i===o?o=a:-1===o&&(o=t.length),t.slice(i,o)}for(n=t.length-1;n>=0;--n)if(47===t.charCodeAt(n)){if(!s){i=n+1;break}}else-1===o&&(s=!1,o=n+1);return-1===o?"":t.slice(i,o)},extname:function(t){e(t);for(var r=-1,n=0,i=-1,o=!0,s=0,h=t.length-1;h>=0;--h){var a=t.charCodeAt(h);if(47!==a)-1===i&&(o=!1,i=h+1),46===a?-1===r?r=h:1!==s&&(s=1):-1!==r&&(s=-1);else if(!o){n=h+1;break}}return-1===r||-1===i||0===s||1===s&&r===i-1&&r===n+1?"":t.slice(r,i)},format:function(t){if(null===t||"object"!=typeof t)throw new TypeError('The "pathObject" argument must be of type Object. Received type '+typeof t);return function(t,e){var r=e.dir||e.root,n=e.base||(e.name||"")+(e.ext||"");return r?r===e.root?r+n:r+"/"+n:n}(0,t)},parse:function(t){e(t);var r={root:"",dir:"",base:"",ext:"",name:""};if(0===t.length)return r;var n,i=t.charCodeAt(0),o=47===i;o?(r.root="/",n=1):n=0;for(var s=-1,h=0,a=-1,c=!0,f=t.length-1,u=0;f>=n;--f)if(47!==(i=t.charCodeAt(f)))-1===a&&(c=!1,a=f+1),46===i?-1===s?s=f:1!==u&&(u=1):-1!==s&&(u=-1);else if(!c){h=f+1;break}return-1===s||-1===a||0===u||1===u&&s===a-1&&s===h+1?-1!==a&&(r.base=r.name=0===h&&o?t.slice(1,a):t.slice(h,a)):(0===h&&o?(r.name=t.slice(1,s),r.base=t.slice(1,a)):(r.name=t.slice(h,s),r.base=t.slice(h,a)),r.ext=t.slice(s,a)),h>0?r.dir=t.slice(0,h-1):o&&(r.dir="/"),r},sep:"/",delimiter:":",win32:null,posix:null};n.posix=n,t.exports=n}},e={};function r(n){var i=e[n];if(void 0!==i)return i.exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}r.d=(t,e)=>{for(var n in e)r.o(e,n)&&!r.o(t,n)&&Object.defineProperty(t,n,{enumerable:!0,get:e[n]})},r.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r.r=t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})};var n={};(()=>{let t;if(r.r(n),r.d(n,{URI:()=>f,Utils:()=>P}),"object"==typeof process)t="win32"===process.platform;else if("object"==typeof navigator){let e=navigator.userAgent;t=e.indexOf("Windows")>=0}const e=/^\w[\w\d+.-]*$/,i=/^\//,o=/^\/\//;function s(t,r){if(!t.scheme&&r)throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);if(t.scheme&&!e.test(t.scheme))throw new Error("[UriError]: Scheme contains illegal characters.");if(t.path)if(t.authority){if(!i.test(t.path))throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character')}else if(o.test(t.path))throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")')}const h="",a="/",c=/^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;class f{static isUri(t){return t instanceof f||!!t&&"string"==typeof t.authority&&"string"==typeof t.fragment&&"string"==typeof t.path&&"string"==typeof t.query&&"string"==typeof t.scheme&&"string"==typeof t.fsPath&&"function"==typeof t.with&&"function"==typeof t.toString}scheme;authority;path;query;fragment;constructor(t,e,r,n,i,o=!1){"object"==typeof t?(this.scheme=t.scheme||h,this.authority=t.authority||h,this.path=t.path||h,this.query=t.query||h,this.fragment=t.fragment||h):(this.scheme=function(t,e){return t||e?t:"file"}(t,o),this.authority=e||h,this.path=function(t,e){switch(t){case"https":case"http":case"file":e?e[0]!==a&&(e=a+e):e=a}return e}(this.scheme,r||h),this.query=n||h,this.fragment=i||h,s(this,o))}get fsPath(){return m(this,!1)}with(t){if(!t)return this;let{scheme:e,authority:r,path:n,query:i,fragment:o}=t;return void 0===e?e=this.scheme:null===e&&(e=h),void 0===r?r=this.authority:null===r&&(r=h),void 0===n?n=this.path:null===n&&(n=h),void 0===i?i=this.query:null===i&&(i=h),void 0===o?o=this.fragment:null===o&&(o=h),e===this.scheme&&r===this.authority&&n===this.path&&i===this.query&&o===this.fragment?this:new l(e,r,n,i,o)}static parse(t,e=!1){const r=c.exec(t);return r?new l(r[2]||h,C(r[4]||h),C(r[5]||h),C(r[7]||h),C(r[9]||h),e):new l(h,h,h,h,h)}static file(e){let r=h;if(t&&(e=e.replace(/\\/g,a)),e[0]===a&&e[1]===a){const t=e.indexOf(a,2);-1===t?(r=e.substring(2),e=a):(r=e.substring(2,t),e=e.substring(t)||a)}return new l("file",r,e,h,h)}static from(t){const e=new l(t.scheme,t.authority,t.path,t.query,t.fragment);return s(e,!0),e}toString(t=!1){return y(this,t)}toJSON(){return this}static revive(t){if(t){if(t instanceof f)return t;{const e=new l(t);return e._formatted=t.external,e._fsPath=t._sep===u?t.fsPath:null,e}}return t}}const u=t?1:void 0;class l extends f{_formatted=null;_fsPath=null;get fsPath(){return this._fsPath||(this._fsPath=m(this,!1)),this._fsPath}toString(t=!1){return t?y(this,!0):(this._formatted||(this._formatted=y(this,!1)),this._formatted)}toJSON(){const t={$mid:1};return this._fsPath&&(t.fsPath=this._fsPath,t._sep=u),this._formatted&&(t.external=this._formatted),this.path&&(t.path=this.path),this.scheme&&(t.scheme=this.scheme),this.authority&&(t.authority=this.authority),this.query&&(t.query=this.query),this.fragment&&(t.fragment=this.fragment),t}}const g={58:"%3A",47:"%2F",63:"%3F",35:"%23",91:"%5B",93:"%5D",64:"%40",33:"%21",36:"%24",38:"%26",39:"%27",40:"%28",41:"%29",42:"%2A",43:"%2B",44:"%2C",59:"%3B",61:"%3D",32:"%20"};function d(t,e,r){let n,i=-1;for(let o=0;o<t.length;o++){const s=t.charCodeAt(o);if(s>=97&&s<=122||s>=65&&s<=90||s>=48&&s<=57||45===s||46===s||95===s||126===s||e&&47===s||r&&91===s||r&&93===s||r&&58===s)-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),void 0!==n&&(n+=t.charAt(o));else{void 0===n&&(n=t.substr(0,o));const e=g[s];void 0!==e?(-1!==i&&(n+=encodeURIComponent(t.substring(i,o)),i=-1),n+=e):-1===i&&(i=o)}}return-1!==i&&(n+=encodeURIComponent(t.substring(i))),void 0!==n?n:t}function p(t){let e;for(let r=0;r<t.length;r++){const n=t.charCodeAt(r);35===n||63===n?(void 0===e&&(e=t.substr(0,r)),e+=g[n]):void 0!==e&&(e+=t[r])}return void 0!==e?e:t}function m(e,r){let n;return n=e.authority&&e.path.length>1&&"file"===e.scheme?`//${e.authority}${e.path}`:47===e.path.charCodeAt(0)&&(e.path.charCodeAt(1)>=65&&e.path.charCodeAt(1)<=90||e.path.charCodeAt(1)>=97&&e.path.charCodeAt(1)<=122)&&58===e.path.charCodeAt(2)?r?e.path.substr(1):e.path[1].toLowerCase()+e.path.substr(2):e.path,t&&(n=n.replace(/\//g,"\\")),n}function y(t,e){const r=e?p:d;let n="",{scheme:i,authority:o,path:s,query:h,fragment:c}=t;if(i&&(n+=i,n+=":"),(o||"file"===i)&&(n+=a,n+=a),o){let t=o.indexOf("@");if(-1!==t){const e=o.substr(0,t);o=o.substr(t+1),t=e.lastIndexOf(":"),-1===t?n+=r(e,!1,!1):(n+=r(e.substr(0,t),!1,!1),n+=":",n+=r(e.substr(t+1),!1,!0)),n+="@"}o=o.toLowerCase(),t=o.lastIndexOf(":"),-1===t?n+=r(o,!1,!0):(n+=r(o.substr(0,t),!1,!0),n+=o.substr(t))}if(s){if(s.length>=3&&47===s.charCodeAt(0)&&58===s.charCodeAt(2)){const t=s.charCodeAt(1);t>=65&&t<=90&&(s=`/${String.fromCharCode(t+32)}:${s.substr(3)}`)}else if(s.length>=2&&58===s.charCodeAt(1)){const t=s.charCodeAt(0);t>=65&&t<=90&&(s=`${String.fromCharCode(t+32)}:${s.substr(2)}`)}n+=r(s,!0,!1)}return h&&(n+="?",n+=r(h,!1,!1)),c&&(n+="#",n+=e?c:d(c,!1,!1)),n}function v(t){try{return decodeURIComponent(t)}catch{return t.length>3?t.substr(0,3)+v(t.substr(3)):t}}const b=/(%[0-9A-Za-z][0-9A-Za-z])+/g;function C(t){return t.match(b)?t.replace(b,(t=>v(t))):t}var A=r(470);const w=A.posix||A,x="/";var P;!function(t){t.joinPath=function(t,...e){return t.with({path:w.join(t.path,...e)})},t.resolvePath=function(t,...e){let r=t.path,n=!1;r[0]!==x&&(r=x+r,n=!0);let i=w.resolve(r,...e);return n&&i[0]===x&&!t.authority&&(i=i.substring(1)),t.with({path:i})},t.dirname=function(t){if(0===t.path.length||t.path===x)return t;let e=w.dirname(t.path);return 1===e.length&&46===e.charCodeAt(0)&&(e=""),t.with({path:e})},t.basename=function(t){return w.basename(t.path)},t.extname=function(t){return w.extname(t.path)}}(P||(P={}))})(),LIB=n})();const{URI,Utils}=LIB;
//# sourceMappingURL=index.mjs.map

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbWVybWFpZC1qc19wYXJzZXJfZGlzdF9tZXJtYWlkLXBhcnNlcl9jb3JlX21qcy5mZDZkYzc4NDg4ODQzNGNjODBkNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBd0M7QUFDRDtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsMkRBQTJEO0FBQzNELGtCQUFrQixxREFBVTtBQUM1QixXQUFXLG9EQUFNO0FBQ2pCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1g0RTtBQUNyRTtBQUNQO0FBQ0Esc0RBQXNELCtCQUErQixrQkFBa0I7QUFDdkcsdUNBQXVDLHFEQUFPLENBQUMscURBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsbUJBQW1CO0FBQ2xELFdBQVcsVUFBVTtBQUNyQixjQUFjO0FBQ2QsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDLElBQUkscURBQUc7QUFDUCxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsY0FBYyxVQUFVLEVBQUUseUJBQXlCLElBQUksU0FBUyxHQUFHO0FBQ25FO0FBQ0E7QUFDQSwrQkFBK0IsS0FBSztBQUNwQyxJQUFJLHFEQUFHO0FBQ1AsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLGNBQWMsVUFBVSxhQUFhLGlCQUFpQixtQkFBbUI7QUFDekU7QUFDQTtBQUNBLFFBQVEscURBQU87QUFDZiwwQkFBMEIscURBQUksQ0FBQyxxREFBRztBQUNsQywyQkFBMkIscURBQU07QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHFEQUFVO0FBQ3JCO0FBQ0E7QUFDQSxXQUFXLHFEQUFVO0FBQ3JCO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNoRTREO0FBQ1k7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UztBQUNUO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU0sT0FBTyxxREFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU0sT0FBTyxxREFBTTtBQUMzQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFNLE9BQU8scURBQU07QUFDM0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBTSxPQUFPLHFEQUFNO0FBQzNCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU0sT0FBTyxxREFBTTtBQUMzQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRLHFEQUFNLE9BQU8scURBQU07QUFDM0I7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBTSxPQUFPLHFEQUFNO0FBQzNCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFFBQVEscURBQU0sT0FBTyxxREFBTTtBQUMzQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxxREFBTSxPQUFPLHFEQUFNO0FBQzNCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSxRQUFRLHFEQUFNLE9BQU8scURBQU07QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsV0FBVyxxREFBRztBQUNkO0FBQ087QUFDUDtBQUNBLGVBQWUscURBQUc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQVE7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMEJBQTBCLDZDQUFFO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGFBQWE7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFtQjtBQUMzRCxZQUFZLHFEQUFRO0FBQ3BCLDJCQUEyQixtRkFBb0M7QUFDL0Q7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLGlFQUF5QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsMkRBQW1CO0FBQzFELDJCQUEyQiw0RUFBd0I7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkVBQXNCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFnQixDQUFDLHFEQUFNO0FBQ3RDO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN1UwRztBQUNpRTtBQUNoRDtBQUNwRTtBQUM4SDtBQUNsSTtBQUNXO0FBQ1Q7QUFDaUY7QUFDdEk7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwrRUFBa0M7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFHO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLHFEQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixzREFBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkscURBQU87QUFDbkIsNkJBQTZCLHNEQUFNO0FBQ25DO0FBQ0E7QUFDQSxhQUFhLElBQUk7QUFDakI7QUFDQSxpQkFBaUIscURBQUc7QUFDcEIsWUFBWSxzREFBSyxDQUFDLHNEQUFPLENBQUMsc0RBQU0sMEJBQTBCLHdEQUFXO0FBQ3JFLGtDQUFrQyxzREFBTyxDQUFDLHNEQUFNO0FBQ2hELGlDQUFpQyxzREFBSTtBQUNyQyw2QkFBNkIsc0RBQU07QUFDbkM7QUFDQTtBQUNBLGFBQWEsSUFBSTtBQUNqQjtBQUNBLGlCQUFpQixzREFBUTtBQUN6Qiw2QkFBNkIsc0RBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsdURBQUc7QUFDbkMsOEJBQThCLHFEQUFHO0FBQ2pDLGNBQWMsc0RBQU8sQ0FBQyxzREFBTTtBQUM1QixjQUFjLHNEQUFNO0FBQ3BCLHNDQUFzQyxzREFBSyxzQ0FBc0Msc0RBQU87QUFDeEY7QUFDQSxjQUFjLCtFQUFrQztBQUNoRCxjQUFjLG1FQUFzQjtBQUNwQztBQUNBO0FBQ0E7QUFDQSxRQUFRLGtFQUFpQixDQUFDLHNEQUFNO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQSw4QkFBOEIscURBQUc7QUFDakM7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQyxrQ0FBa0MscURBQUc7QUFDckM7QUFDQSxjQUFjLDJEQUFtQjtBQUNqQztBQUNBO0FBQ0Esb0RBQW9ELGtFQUFvQixHQUFHLHFFQUF1QjtBQUNsRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSx1Q0FBdUM7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSw2RUFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsd0RBQVU7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsOERBQWdCO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0REFBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0hBQXNILDhEQUFnQixrQkFBa0Isc0ZBQWlDO0FBQ3pMO0FBQ0E7QUFDQSx1REFBdUQsa0VBQW9CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHlGQUFvQztBQUNwRCx1Q0FBdUMsa0VBQW9CLGtCQUFrQix5RkFBb0M7QUFDakg7QUFDQTtBQUNBLCtEQUErRCw0REFBUztBQUN4RTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsc0RBQVE7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9ILHNEQUFRLGtCQUFrQixnRkFBMkI7QUFDeks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCwwREFBWTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1GQUE4QjtBQUM5Qyx1Q0FBdUMsMERBQVksa0JBQWtCLG1GQUE4QjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0VBQW9CO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG9EQUFNO0FBQzdELHFCQUFxQixxREFBTztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0NBQWdDLDZFQUEwQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLDZFQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxrQ0FBa0MsMkVBQXdCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHVFQUEwQjtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzREFBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLHVEQUFHO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDN2hCeUY7QUFDQztBQUNwQjtBQUM5QjtBQUNhO0FBQzlDO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxREFBRztBQUNs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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ087QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNBO0FBQ1A7QUFDQTtBQUNPO0FBQ0E7QUFDUDtBQUNBO0FBQ08sMENBQTBDLGtFQUFxQjtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMERBQVM7QUFDakM7QUFDQTtBQUNBLDZCQUE2Qiw0REFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaFJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFD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QUFpRCx1QkFBdUIsdUVBQXVFLDZCQUE2QixlQUFlLDhEQUE4RCxpQkFBaUIsZUFBZSxpQkFBaUIsU0FBUyxZQUFZLGlCQUFpQixNQUFNLDRCQUE0QixpQkFBaUIscUVBQXFFLFVBQVUsbUJBQW1CLGtCQUFrQixnQkFBZ0IsYUFBYSxhQUFhLDREQUE0RCxlQUFlLG9GQUFvRixTQUFTLFNBQVMsUUFBUSxpU0FBaVMsU0FBUyw0S0FBNEssa0JBQWtCLFdBQVcsWUFBWSxXQUFXLEtBQUssd0JBQXdCLDhNQUE4TSxLQUFLLDhCQUE4QixhQUFhLHdGQUF3RixxRUFBcUUsY0FBYyxNQUFNLFlBQVksV0FBVyxLQUFLLHdCQUF3Qiw2RUFBNkUsc0JBQXNCLGdCQUFnQixNQUFNLDhEQUE4RCxZQUFZLEVBQUUsT0FBTyxvUUFBb1EsZ0JBQWdCLGNBQWMsVUFBVSwrQ0FBK0MsR0FBRyxvREFBb0QscUJBQXFCLFdBQVcsc0JBQXNCLDhIQUE4SCx1R0FBdUcsTUFBTSw0REFBNEQsd0JBQXdCLHFCQUFxQiwwQkFBMEIsR0FBRyxZQUFZLEdBQUcsMkNBQTJDLHdCQUF3QixvQkFBb0IsMEJBQTBCLEdBQUcsWUFBWSxHQUFHLGNBQWMsaUVBQWlFLGNBQWMsSUFBSSw2QkFBNkIsTUFBTSxrREFBa0Qsc0NBQXNDLGNBQWMsMkNBQTJDLGFBQWEseUJBQXlCLE1BQU0sYUFBYSw0QkFBNEIsZUFBZSx5QkFBeUIsRUFBRSxnQ0FBZ0Msa0JBQWtCLHVCQUF1Qix3QkFBd0IsNkRBQTZELE9BQU8sRUFBRSx1QkFBdUIsMENBQTBDLHdCQUF3QiwwREFBMEQsT0FBTyxFQUFFLHdCQUF3QiwwQkFBMEIsdUJBQXVCLDBCQUEwQixTQUFTLEdBQUcsVUFBVSxJQUFXLE1BQU0sVUFBVTtBQUM5OFUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vY3N0LWR0cy1nZW4vbGliL3NyYy9hcGkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2NzdC1kdHMtZ2VuL2xpYi9zcmMvZ2VuZXJhdGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2NzdC1kdHMtZ2VuL2xpYi9zcmMvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2dhc3QvbGliL3NyYy9hcGkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2dhc3QvbGliL3NyYy9oZWxwZXJzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9nYXN0L2xpYi9zcmMvbW9kZWwuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BjaGV2cm90YWluL2dhc3QvbGliL3NyYy92aXNpdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0L2xpYi9zcmMvYXBpLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0L2xpYi9zcmMvYmFzZS1yZWdleHAtdmlzaXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vcmVnZXhwLXRvLWFzdC9saWIvc3JjL2NoYXJhY3Rlci1jbGFzc2VzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0L2xpYi9zcmMvcmVnZXhwLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vcmVnZXhwLXRvLWFzdC9saWIvc3JjL3V0aWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AY2hldnJvdGFpbi91dGlscy9saWIvc3JjL2FwaS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vdXRpbHMvbGliL3NyYy9wcmludC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vdXRpbHMvbGliL3NyYy90aW1lci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQGNoZXZyb3RhaW4vdXRpbHMvbGliL3NyYy90by1mYXN0LXByb3BlcnRpZXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLTJOWUZUSUwyLm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1lcm1haWQtanMvcGFyc2VyL2Rpc3QvY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvY2h1bmstMk81Wks3UlIubWpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWVybWFpZC1qcy9wYXJzZXIvZGlzdC9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay03UEtJNkUyRS5tanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLUM0T0VJUzdOLm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1lcm1haWQtanMvcGFyc2VyL2Rpc3QvY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvY2h1bmstRVhaWk5FNkYubWpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9AbWVybWFpZC1qcy9wYXJzZXIvZGlzdC9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay1ST1hHN1M0RS5tanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL0BtZXJtYWlkLWpzL3BhcnNlci9kaXN0L2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLVY0UTMyRzZTLm1qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvQG1lcm1haWQtanMvcGFyc2VyL2Rpc3QvbWVybWFpZC1wYXJzZXIuY29yZS5tanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4tYWxsc3Rhci9saWIvYWxsLXN0YXItbG9va2FoZWFkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluLWFsbHN0YXIvbGliL2F0bi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi1hbGxzdGFyL2xpYi9kZmEuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4tYWxsc3Rhci9saWIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9hcGkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9kaWFncmFtcy9yZW5kZXJfcHVibGljLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvbGFuZy9sYW5nX2V4dGVuc2lvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9jb25zdGFudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9jc3QvY3N0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvY3N0L2NzdF92aXNpdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZXJyb3JzX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL2V4Y2VwdGlvbnNfcHVibGljLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9jaGVja3MuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2ZpcnN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9mb2xsb3cuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2dhc3QvZ2FzdF9yZXNvbHZlcl9wdWJsaWMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL2ludGVycHJldGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9rZXlzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9sbGtfbG9va2FoZWFkLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9sb29rYWhlYWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9ncmFtbWFyL3Jlc29sdmVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvZ3JhbW1hci9yZXN0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3BhcnNlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvY29udGV4dF9hc3Npc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2Vycm9yX2hhbmRsZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2dhc3RfcmVjb3JkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xleGVyX2FkYXB0ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL2xvb2tzYWhlYWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3BlcmZfdHJhY2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy9yZWNvZ25pemVyX2FwaS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3BhcnNlL3BhcnNlci90cmFpdHMvcmVjb2duaXplcl9lbmdpbmUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdHJhaXRzL3JlY292ZXJhYmxlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvcGFyc2UvcGFyc2VyL3RyYWl0cy90cmVlX2J1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2NoZXZyb3RhaW4vbGliL3NyYy9wYXJzZS9wYXJzZXIvdXRpbHMvYXBwbHlfbWl4aW5zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi9sZXhlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfZXJyb3JzX3B1YmxpYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vbGV4ZXJfcHVibGljLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi9yZWdfZXhwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi9yZWdfZXhwX3BhcnNlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvY2hldnJvdGFpbi9saWIvc3JjL3NjYW4vdG9rZW5zLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvc2Nhbi90b2tlbnNfcHVibGljLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9jaGV2cm90YWluL2xpYi9zcmMvdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZGVmYXVsdC1tb2R1bGUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL2RlcGVuZGVuY3ktaW5qZWN0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9kb2N1bWVudGF0aW9uL2NvbW1lbnQtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL2RvY3VtZW50YXRpb24vZG9jdW1lbnRhdGlvbi1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvZG9jdW1lbnRhdGlvbi9qc2RvYy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL2xhbmd1YWdlcy9ncmFtbWFyLWNvbmZpZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2FzeW5jLXBhcnNlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2NvbXBsZXRpb24tcGFyc2VyLWJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3BhcnNlci9jc3Qtbm9kZS1idWlsZGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvbGFuZ2l1bS1wYXJzZXItYnVpbGRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL2xhbmdpdW0tcGFyc2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvbGV4ZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3BhcnNlci9wYXJzZXItYnVpbGRlci1iYXNlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9wYXJzZXIvdG9rZW4tYnVpbGRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcGFyc2VyL3ZhbHVlLWNvbnZlcnRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9saW5rZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3JlZmVyZW5jZXMvbmFtZS1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvcmVmZXJlbmNlcy9yZWZlcmVuY2VzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3Njb3BlLWNvbXB1dGF0aW9uLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3Njb3BlLXByb3ZpZGVyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9yZWZlcmVuY2VzL3Njb3BlLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9zZXJpYWxpemVyL2h5ZHJhdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi9zZXJpYWxpemVyL2pzb24tc2VyaWFsaXplci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc2VydmljZS1yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvc3ludGF4LXRyZWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2FzdC11dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvY2FjaGluZy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvY29sbGVjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL2NzdC11dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZGlzcG9zYWJsZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZXJyb3JzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi91dGlscy9ncmFtbWFyLWxvYWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvZ3JhbW1hci11dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvcHJvbWlzZS11dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdXRpbHMvcmVnZXhwLXV0aWxzLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi91dGlscy9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3V0aWxzL3VyaS11dGlscy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvdmFsaWRhdGlvbi9kb2N1bWVudC12YWxpZGF0b3IuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1yZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2FzdC1kZXNjcmlwdGlvbnMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS9hc3Qtbm9kZS1sb2NhdG9yLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sYW5naXVtL2xpYi93b3Jrc3BhY2UvY29uZmlndXJhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2RvY3VtZW50LWJ1aWxkZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS9kb2N1bWVudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS9maWxlLXN5c3RlbS1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL2luZGV4LW1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xhbmdpdW0vbGliL3dvcmtzcGFjZS93b3Jrc3BhY2UtbG9jay5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbGFuZ2l1bS9saWIvd29ya3NwYWNlL3dvcmtzcGFjZS1tYW5hZ2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FycmF5QWdncmVnYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19hcnJheUV2ZXJ5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2FzY2lpVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlQWdncmVnYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRGlmZmVyZW5jZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlRXZlcnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fYmFzZUlzUmVnRXhwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvX2Jhc2VTbGljZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19iYXNlU29tZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jYXN0U2xpY2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fY3JlYXRlQWdncmVnYXRvci5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL19jcmVhdGVDYXNlRmlyc3QuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9fc3RyaW5nVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL191bmljb2RlVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Fzc2lnbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2Nsb25lLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvY29tcGFjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2RpZmZlcmVuY2UuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9kcm9wLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZHJvcFJpZ2h0LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZXZlcnkuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9mbGF0TWFwLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvZ3JvdXBCeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2hlYWQuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pbmNsdWRlcy5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL2luZGV4T2YuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy9pc1JlZ0V4cC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL25lZ2F0ZS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3BpY2tCeS5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3JlamVjdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvbG9kYXNoLWVzL3NvbWUuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL2xvZGFzaC1lcy91bmlxLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdW5pcUJ5LmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy9sb2Rhc2gtZXMvdXBwZXJGaXJzdC5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92c2NvZGUtanNvbnJwYy9saWIvY29tbW9uL2NhbmNlbGxhdGlvbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWpzb25ycGMvbGliL2NvbW1vbi9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9jb21tb24vaXMuanMiLCJ3ZWJwYWNrOi8vQGp1cHl0ZXJsYWIvYXBwbGljYXRpb24tdG9wLy4vbm9kZV9tb2R1bGVzL3ZzY29kZS1qc29ucnBjL2xpYi9jb21tb24vcmFsLmpzIiwid2VicGFjazovL0BqdXB5dGVybGFiL2FwcGxpY2F0aW9uLXRvcC8uL25vZGVfbW9kdWxlcy92c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50L2xpYi9lc20vbWFpbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyIsIndlYnBhY2s6Ly9AanVweXRlcmxhYi9hcHBsaWNhdGlvbi10b3AvLi9ub2RlX21vZHVsZXMvdnNjb2RlLXVyaS9saWIvZXNtL2luZGV4Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBidWlsZE1vZGVsIH0gZnJvbSBcIi4vbW9kZWwuanNcIjtcbmltcG9ydCB7IGdlbkR0cyB9IGZyb20gXCIuL2dlbmVyYXRlLmpzXCI7XG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBpbmNsdWRlVmlzaXRvckludGVyZmFjZTogdHJ1ZSxcbiAgICB2aXNpdG9ySW50ZXJmYWNlTmFtZTogXCJJQ3N0Tm9kZVZpc2l0b3JcIixcbn07XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVDc3REdHMocHJvZHVjdGlvbnMsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBlZmZlY3RpdmVPcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBkZWZhdWx0T3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIGNvbnN0IG1vZGVsID0gYnVpbGRNb2RlbChwcm9kdWN0aW9ucyk7XG4gICAgcmV0dXJuIGdlbkR0cyhtb2RlbCwgZWZmZWN0aXZlT3B0aW9ucyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcGkuanMubWFwIiwiaW1wb3J0IHsgZmxhdHRlbiwgaXNBcnJheSwgbWFwLCByZWR1Y2UsIHVuaXEsIHVwcGVyRmlyc3QgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5leHBvcnQgZnVuY3Rpb24gZ2VuRHRzKG1vZGVsLCBvcHRpb25zKSB7XG4gICAgbGV0IGNvbnRlbnRQYXJ0cyA9IFtdO1xuICAgIGNvbnRlbnRQYXJ0cyA9IGNvbnRlbnRQYXJ0cy5jb25jYXQoYGltcG9ydCB0eXBlIHsgQ3N0Tm9kZSwgSUNzdFZpc2l0b3IsIElUb2tlbiB9IGZyb20gXCJjaGV2cm90YWluXCI7YCk7XG4gICAgY29udGVudFBhcnRzID0gY29udGVudFBhcnRzLmNvbmNhdChmbGF0dGVuKG1hcChtb2RlbCwgKG5vZGUpID0+IGdlbkNzdE5vZGVUeXBlcyhub2RlKSkpKTtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlVmlzaXRvckludGVyZmFjZSkge1xuICAgICAgICBjb250ZW50UGFydHMgPSBjb250ZW50UGFydHMuY29uY2F0KGdlblZpc2l0b3Iob3B0aW9ucy52aXNpdG9ySW50ZXJmYWNlTmFtZSwgbW9kZWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRlbnRQYXJ0cy5qb2luKFwiXFxuXFxuXCIpICsgXCJcXG5cIjtcbn1cbmZ1bmN0aW9uIGdlbkNzdE5vZGVUeXBlcyhub2RlKSB7XG4gICAgY29uc3Qgbm9kZUNzdEludGVyZmFjZSA9IGdlbk5vZGVJbnRlcmZhY2Uobm9kZSk7XG4gICAgY29uc3Qgbm9kZUNoaWxkcmVuSW50ZXJmYWNlID0gZ2VuTm9kZUNoaWxkcmVuVHlwZShub2RlKTtcbiAgICByZXR1cm4gW25vZGVDc3RJbnRlcmZhY2UsIG5vZGVDaGlsZHJlbkludGVyZmFjZV07XG59XG5mdW5jdGlvbiBnZW5Ob2RlSW50ZXJmYWNlKG5vZGUpIHtcbiAgICBjb25zdCBub2RlSW50ZXJmYWNlTmFtZSA9IGdldE5vZGVJbnRlcmZhY2VOYW1lKG5vZGUubmFtZSk7XG4gICAgY29uc3QgY2hpbGRyZW5UeXBlTmFtZSA9IGdldE5vZGVDaGlsZHJlblR5cGVOYW1lKG5vZGUubmFtZSk7XG4gICAgcmV0dXJuIGBleHBvcnQgaW50ZXJmYWNlICR7bm9kZUludGVyZmFjZU5hbWV9IGV4dGVuZHMgQ3N0Tm9kZSB7XG4gIG5hbWU6IFwiJHtub2RlLm5hbWV9XCI7XG4gIGNoaWxkcmVuOiAke2NoaWxkcmVuVHlwZU5hbWV9O1xufWA7XG59XG5mdW5jdGlvbiBnZW5Ob2RlQ2hpbGRyZW5UeXBlKG5vZGUpIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGdldE5vZGVDaGlsZHJlblR5cGVOYW1lKG5vZGUubmFtZSk7XG4gICAgcmV0dXJuIGBleHBvcnQgdHlwZSAke3R5cGVOYW1lfSA9IHtcbiAgJHttYXAobm9kZS5wcm9wZXJ0aWVzLCAocHJvcGVydHkpID0+IGdlbkNoaWxkUHJvcGVydHkocHJvcGVydHkpKS5qb2luKFwiXFxuICBcIil9XG59O2A7XG59XG5mdW5jdGlvbiBnZW5DaGlsZFByb3BlcnR5KHByb3ApIHtcbiAgICBjb25zdCB0eXBlTmFtZSA9IGJ1aWxkVHlwZVN0cmluZyhwcm9wLnR5cGUpO1xuICAgIHJldHVybiBgJHtwcm9wLm5hbWV9JHtwcm9wLm9wdGlvbmFsID8gXCI/XCIgOiBcIlwifTogJHt0eXBlTmFtZX1bXTtgO1xufVxuZnVuY3Rpb24gZ2VuVmlzaXRvcihuYW1lLCBub2Rlcykge1xuICAgIHJldHVybiBgZXhwb3J0IGludGVyZmFjZSAke25hbWV9PElOLCBPVVQ+IGV4dGVuZHMgSUNzdFZpc2l0b3I8SU4sIE9VVD4ge1xuICAke21hcChub2RlcywgKG5vZGUpID0+IGdlblZpc2l0b3JGdW5jdGlvbihub2RlKSkuam9pbihcIlxcbiAgXCIpfVxufWA7XG59XG5mdW5jdGlvbiBnZW5WaXNpdG9yRnVuY3Rpb24obm9kZSkge1xuICAgIGNvbnN0IGNoaWxkcmVuVHlwZU5hbWUgPSBnZXROb2RlQ2hpbGRyZW5UeXBlTmFtZShub2RlLm5hbWUpO1xuICAgIHJldHVybiBgJHtub2RlLm5hbWV9KGNoaWxkcmVuOiAke2NoaWxkcmVuVHlwZU5hbWV9LCBwYXJhbT86IElOKTogT1VUO2A7XG59XG5mdW5jdGlvbiBidWlsZFR5cGVTdHJpbmcodHlwZSkge1xuICAgIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IHR5cGVOYW1lcyA9IHVuaXEobWFwKHR5cGUsICh0KSA9PiBnZXRUeXBlU3RyaW5nKHQpKSk7XG4gICAgICAgIGNvbnN0IHR5cGVTdHJpbmcgPSByZWR1Y2UodHlwZU5hbWVzLCAoc3VtLCB0KSA9PiBzdW0gKyBcIiB8IFwiICsgdCk7XG4gICAgICAgIHJldHVybiBcIihcIiArIHR5cGVTdHJpbmcgKyBcIilcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBnZXRUeXBlU3RyaW5nKHR5cGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFR5cGVTdHJpbmcodHlwZSkge1xuICAgIGlmICh0eXBlLmtpbmQgPT09IFwidG9rZW5cIikge1xuICAgICAgICByZXR1cm4gXCJJVG9rZW5cIjtcbiAgICB9XG4gICAgcmV0dXJuIGdldE5vZGVJbnRlcmZhY2VOYW1lKHR5cGUubmFtZSk7XG59XG5mdW5jdGlvbiBnZXROb2RlSW50ZXJmYWNlTmFtZShydWxlTmFtZSkge1xuICAgIHJldHVybiB1cHBlckZpcnN0KHJ1bGVOYW1lKSArIFwiQ3N0Tm9kZVwiO1xufVxuZnVuY3Rpb24gZ2V0Tm9kZUNoaWxkcmVuVHlwZU5hbWUocnVsZU5hbWUpIHtcbiAgICByZXR1cm4gdXBwZXJGaXJzdChydWxlTmFtZSkgKyBcIkNzdENoaWxkcmVuXCI7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZW5lcmF0ZS5qcy5tYXAiLCJpbXBvcnQgeyBHQXN0VmlzaXRvciwgTm9uVGVybWluYWwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuaW1wb3J0IHsgYXNzaWduLCBmbGF0dGVuLCBncm91cEJ5LCBtYXAsIHNvbWUsIHZhbHVlcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBidWlsZE1vZGVsKHByb2R1Y3Rpb25zKSB7XG4gICAgY29uc3QgZ2VuZXJhdG9yID0gbmV3IENzdE5vZGVEZWZpbml0aW9uR2VuZXJhdG9yKCk7XG4gICAgY29uc3QgYWxsUnVsZXMgPSB2YWx1ZXMocHJvZHVjdGlvbnMpO1xuICAgIHJldHVybiBtYXAoYWxsUnVsZXMsIChydWxlKSA9PiBnZW5lcmF0b3IudmlzaXRSdWxlKHJ1bGUpKTtcbn1cbmNsYXNzIENzdE5vZGVEZWZpbml0aW9uR2VuZXJhdG9yIGV4dGVuZHMgR0FzdFZpc2l0b3Ige1xuICAgIHZpc2l0UnVsZShub2RlKSB7XG4gICAgICAgIGNvbnN0IHJhd0VsZW1lbnRzID0gdGhpcy52aXNpdEVhY2gobm9kZS5kZWZpbml0aW9uKTtcbiAgICAgICAgY29uc3QgZ3JvdXBlZCA9IGdyb3VwQnkocmF3RWxlbWVudHMsIChlbCkgPT4gZWwucHJvcGVydHlOYW1lKTtcbiAgICAgICAgY29uc3QgcHJvcGVydGllcyA9IG1hcChncm91cGVkLCAoZ3JvdXAsIHByb3BlcnR5TmFtZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYWxsTnVsbGFibGUgPSAhc29tZShncm91cCwgKGVsKSA9PiAhZWwuY2FuQmVOdWxsKTtcbiAgICAgICAgICAgIC8vIEluIGFuIGFsdGVybmF0aW9uIHdpdGggYSBsYWJlbCBhIHByb3BlcnR5IG5hbWUgY2FuIGhhdmVcbiAgICAgICAgICAgIC8vIG11bHRpcGxlIHR5cGVzLlxuICAgICAgICAgICAgbGV0IHByb3BlcnR5VHlwZSA9IGdyb3VwWzBdLnR5cGU7XG4gICAgICAgICAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHByb3BlcnR5VHlwZSA9IG1hcChncm91cCwgKGcpID0+IGcudHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHByb3BlcnR5TmFtZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBwcm9wZXJ0eVR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uYWw6IGFsbE51bGxhYmxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdEFsdGVybmF0aXZlKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFYWNoQW5kT3ZlcnJpZGVXaXRoKG5vZGUuZGVmaW5pdGlvbiwgeyBjYW5CZU51bGw6IHRydWUgfSk7XG4gICAgfVxuICAgIHZpc2l0T3B0aW9uKG5vZGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRFYWNoQW5kT3ZlcnJpZGVXaXRoKG5vZGUuZGVmaW5pdGlvbiwgeyBjYW5CZU51bGw6IHRydWUgfSk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RWFjaEFuZE92ZXJyaWRlV2l0aChub2RlLmRlZmluaXRpb24sIHsgY2FuQmVOdWxsOiB0cnVlIH0pO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnkobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEVhY2gobm9kZS5kZWZpbml0aW9uKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihub2RlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2l0RWFjaChub2RlLmRlZmluaXRpb24pLmNvbmNhdCh7XG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IG5vZGUuc2VwYXJhdG9yLm5hbWUsXG4gICAgICAgICAgICBjYW5CZU51bGw6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBnZXRUeXBlKG5vZGUuc2VwYXJhdG9yKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3Iobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEVhY2hBbmRPdmVycmlkZVdpdGgobm9kZS5kZWZpbml0aW9uLCB7XG4gICAgICAgICAgICBjYW5CZU51bGw6IHRydWUsXG4gICAgICAgIH0pLmNvbmNhdCh7XG4gICAgICAgICAgICBwcm9wZXJ0eU5hbWU6IG5vZGUuc2VwYXJhdG9yLm5hbWUsXG4gICAgICAgICAgICBjYW5CZU51bGw6IHRydWUsXG4gICAgICAgICAgICB0eXBlOiBnZXRUeXBlKG5vZGUuc2VwYXJhdG9yKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHZpc2l0QWx0ZXJuYXRpb24obm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpdEVhY2hBbmRPdmVycmlkZVdpdGgobm9kZS5kZWZpbml0aW9uLCB7IGNhbkJlTnVsbDogdHJ1ZSB9KTtcbiAgICB9XG4gICAgdmlzaXRUZXJtaW5hbChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBub2RlLmxhYmVsIHx8IG5vZGUudGVybWluYWxUeXBlLm5hbWUsXG4gICAgICAgICAgICAgICAgY2FuQmVOdWxsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBnZXRUeXBlKG5vZGUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgdmlzaXROb25UZXJtaW5hbChub2RlKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBub2RlLmxhYmVsIHx8IG5vZGUubm9uVGVybWluYWxOYW1lLFxuICAgICAgICAgICAgICAgIGNhbkJlTnVsbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgdHlwZTogZ2V0VHlwZShub2RlKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF07XG4gICAgfVxuICAgIHZpc2l0RWFjaEFuZE92ZXJyaWRlV2l0aChkZWZpbml0aW9uLCBvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gbWFwKHRoaXMudmlzaXRFYWNoKGRlZmluaXRpb24pLCAoZGVmaW5pdGlvbikgPT4gYXNzaWduKHt9LCBkZWZpbml0aW9uLCBvdmVycmlkZSkpO1xuICAgIH1cbiAgICB2aXNpdEVhY2goZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gZmxhdHRlbihtYXAoZGVmaW5pdGlvbiwgKGRlZmluaXRpb24pID0+IHRoaXMudmlzaXQoZGVmaW5pdGlvbikpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRUeXBlKHByb2R1Y3Rpb24pIHtcbiAgICBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBraW5kOiBcInJ1bGVcIixcbiAgICAgICAgICAgIG5hbWU6IHByb2R1Y3Rpb24ucmVmZXJlbmNlZFJ1bGUubmFtZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHsga2luZDogXCJ0b2tlblwiIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1tb2RlbC5qcy5tYXAiLCJleHBvcnQgeyBSdWxlLCBUZXJtaW5hbCwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIHNlcmlhbGl6ZUdyYW1tYXIsIHNlcmlhbGl6ZVByb2R1Y3Rpb24sIH0gZnJvbSBcIi4vbW9kZWwuanNcIjtcbmV4cG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIi4vdmlzaXRvci5qc1wiO1xuZXhwb3J0IHsgZ2V0UHJvZHVjdGlvbkRzbE5hbWUsIGlzT3B0aW9uYWxQcm9kLCBpc0JyYW5jaGluZ1Byb2QsIGlzU2VxdWVuY2VQcm9kLCB9IGZyb20gXCIuL2hlbHBlcnMuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCJpbXBvcnQgeyBldmVyeSwgaW5jbHVkZXMsIHNvbWUgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBBYnN0cmFjdFByb2R1Y3Rpb24sIEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCwgfSBmcm9tIFwiLi9tb2RlbC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzU2VxdWVuY2VQcm9kKHByb2QpIHtcbiAgICByZXR1cm4gKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZSB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgT3B0aW9uIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgcHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsIHx8XG4gICAgICAgIHByb2QgaW5zdGFuY2VvZiBSdWxlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc09wdGlvbmFsUHJvZChwcm9kLCBhbHJlYWR5VmlzaXRlZCA9IFtdKSB7XG4gICAgY29uc3QgaXNEaXJlY3RseU9wdGlvbmFsID0gcHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fFxuICAgICAgICBwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3I7XG4gICAgaWYgKGlzRGlyZWN0bHlPcHRpb25hbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLy8gbm90ZSB0aGF0IHRoaXMgY2FuIGNhdXNlIGluZmluaXRlIGxvb3AgaWYgb25lIG9wdGlvbmFsIGVtcHR5IFRPUCBwcm9kdWN0aW9uIGhhcyBhIGN5Y2xpYyBkZXBlbmRlbmN5IHdpdGggYW5vdGhlclxuICAgIC8vIGVtcHR5IG9wdGlvbmFsIHRvcCBydWxlXG4gICAgLy8gbWF5IGJlIGluZGlyZWN0bHkgb3B0aW9uYWwgKChBP0I/Qz8pIHwgKEQ/RT9GPykpXG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAvLyBmb3IgT1IgaXRzIGVub3VnaCBmb3IganVzdCBvbmUgb2YgdGhlIGFsdGVybmF0aXZlcyB0byBiZSBvcHRpb25hbFxuICAgICAgICByZXR1cm4gc29tZShwcm9kLmRlZmluaXRpb24sIChzdWJQcm9kKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNPcHRpb25hbFByb2Qoc3ViUHJvZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsICYmIGluY2x1ZGVzKGFscmVhZHlWaXNpdGVkLCBwcm9kKSkge1xuICAgICAgICAvLyBhdm9pZGluZyBzdGFjayBvdmVyZmxvdyBkdWUgdG8gaW5maW5pdGUgcmVjdXJzaW9uXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIEFic3RyYWN0UHJvZHVjdGlvbikge1xuICAgICAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICBhbHJlYWR5VmlzaXRlZC5wdXNoKHByb2QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBldmVyeShwcm9kLmRlZmluaXRpb24sIChzdWJQcm9kKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gaXNPcHRpb25hbFByb2Qoc3ViUHJvZCwgYWxyZWFkeVZpc2l0ZWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNCcmFuY2hpbmdQcm9kKHByb2QpIHtcbiAgICByZXR1cm4gcHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb2R1Y3Rpb25Ec2xOYW1lKHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgcmV0dXJuIFwiU1VCUlVMRVwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk9QVElPTlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiT1JcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIFwiQVRfTEVBU1RfT05FXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJBVF9MRUFTVF9PTkVfU0VQXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZX1NFUFwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gXCJNQU5ZXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gXCJDT05TVU1FXCI7XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGVscGVycy5qcy5tYXAiLCJpbXBvcnQgeyBhc3NpZ24sIGZvckVhY2gsIGlzUmVnRXhwLCBpc1N0cmluZywgbWFwLCBwaWNrQnkgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG4vLyBUT0RPOiBkdXBsaWNhdGVkIGNvZGUgdG8gYXZvaWQgZXh0cmFjdGluZyBhbm90aGVyIHN1Yi1wYWNrYWdlIC0tIGhvdyB0byBhdm9pZD9cbmZ1bmN0aW9uIHRva2VuTGFiZWwodG9rVHlwZSkge1xuICAgIGlmIChoYXNUb2tlbkxhYmVsKHRva1R5cGUpKSB7XG4gICAgICAgIHJldHVybiB0b2tUeXBlLkxBQkVMO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRva1R5cGUubmFtZTtcbiAgICB9XG59XG4vLyBUT0RPOiBkdXBsaWNhdGVkIGNvZGUgdG8gYXZvaWQgZXh0cmFjdGluZyBhbm90aGVyIHN1Yi1wYWNrYWdlIC0tIGhvdyB0byBhdm9pZD9cbmZ1bmN0aW9uIGhhc1Rva2VuTGFiZWwob2JqKSB7XG4gICAgcmV0dXJuIGlzU3RyaW5nKG9iai5MQUJFTCkgJiYgb2JqLkxBQkVMICE9PSBcIlwiO1xufVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0UHJvZHVjdGlvbiB7XG4gICAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuICAgIH1cbiAgICBzZXQgZGVmaW5pdGlvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9kZWZpbml0aW9uID0gdmFsdWU7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKF9kZWZpbml0aW9uKSB7XG4gICAgICAgIHRoaXMuX2RlZmluaXRpb24gPSBfZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgYWNjZXB0KHZpc2l0b3IpIHtcbiAgICAgICAgdmlzaXRvci52aXNpdCh0aGlzKTtcbiAgICAgICAgZm9yRWFjaCh0aGlzLmRlZmluaXRpb24sIChwcm9kKSA9PiB7XG4gICAgICAgICAgICBwcm9kLmFjY2VwdCh2aXNpdG9yKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5vblRlcm1pbmFsIGV4dGVuZHMgQWJzdHJhY3RQcm9kdWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKFtdKTtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG4gICAgc2V0IGRlZmluaXRpb24oZGVmaW5pdGlvbikge1xuICAgICAgICAvLyBpbW11dGFibGVcbiAgICB9XG4gICAgZ2V0IGRlZmluaXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZmVyZW5jZWRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZmVyZW5jZWRSdWxlLmRlZmluaXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICBhY2NlcHQodmlzaXRvcikge1xuICAgICAgICB2aXNpdG9yLnZpc2l0KHRoaXMpO1xuICAgICAgICAvLyBkb24ndCB2aXNpdCBjaGlsZHJlbiBvZiBhIHJlZmVyZW5jZSwgd2Ugd2lsbCBnZXQgY3ljbGljIGluZmluaXRlIGxvb3BzIGlmIHdlIGRvIHNvXG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJ1bGUgZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5vcmdUZXh0ID0gXCJcIjtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFsdGVybmF0aXZlIGV4dGVuZHMgQWJzdHJhY3RQcm9kdWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuaWdub3JlQW1iaWd1aXRpZXMgPSBmYWxzZTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE9wdGlvbiBleHRlbmRzIEFic3RyYWN0UHJvZHVjdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zLmRlZmluaXRpb24pO1xuICAgICAgICB0aGlzLmlkeCA9IDE7XG4gICAgICAgIGFzc2lnbih0aGlzLCBwaWNrQnkob3B0aW9ucywgKHYpID0+IHYgIT09IHVuZGVmaW5lZCkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBSZXBldGl0aW9uTWFuZGF0b3J5IGV4dGVuZHMgQWJzdHJhY3RQcm9kdWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yIGV4dGVuZHMgQWJzdHJhY3RQcm9kdWN0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJlcGV0aXRpb24gZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucy5kZWZpbml0aW9uKTtcbiAgICAgICAgdGhpcy5pZHggPSAxO1xuICAgICAgICBhc3NpZ24odGhpcywgcGlja0J5KG9wdGlvbnMsICh2KSA9PiB2ICE9PSB1bmRlZmluZWQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWx0ZXJuYXRpb24gZXh0ZW5kcyBBYnN0cmFjdFByb2R1Y3Rpb24ge1xuICAgIGdldCBkZWZpbml0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcbiAgICB9XG4gICAgc2V0IGRlZmluaXRpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5fZGVmaW5pdGlvbiA9IHZhbHVlO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGVmaW5pdGlvbik7XG4gICAgICAgIHRoaXMuaWR4ID0gMTtcbiAgICAgICAgdGhpcy5pZ25vcmVBbWJpZ3VpdGllcyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc1ByZWRpY2F0ZXMgPSBmYWxzZTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRlcm1pbmFsIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuaWR4ID0gMTtcbiAgICAgICAgYXNzaWduKHRoaXMsIHBpY2tCeShvcHRpb25zLCAodikgPT4gdiAhPT0gdW5kZWZpbmVkKSk7XG4gICAgfVxuICAgIGFjY2VwdCh2aXNpdG9yKSB7XG4gICAgICAgIHZpc2l0b3IudmlzaXQodGhpcyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUdyYW1tYXIodG9wUnVsZXMpIHtcbiAgICByZXR1cm4gbWFwKHRvcFJ1bGVzLCBzZXJpYWxpemVQcm9kdWN0aW9uKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVQcm9kdWN0aW9uKG5vZGUpIHtcbiAgICBmdW5jdGlvbiBjb252ZXJ0RGVmaW5pdGlvbihkZWZpbml0aW9uKSB7XG4gICAgICAgIHJldHVybiBtYXAoZGVmaW5pdGlvbiwgc2VyaWFsaXplUHJvZHVjdGlvbik7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICBjb25zdCBzZXJpYWxpemVkTm9uVGVybWluYWwgPSB7XG4gICAgICAgICAgICB0eXBlOiBcIk5vblRlcm1pbmFsXCIsXG4gICAgICAgICAgICBuYW1lOiBub2RlLm5vblRlcm1pbmFsTmFtZSxcbiAgICAgICAgICAgIGlkeDogbm9kZS5pZHgsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc1N0cmluZyhub2RlLmxhYmVsKSkge1xuICAgICAgICAgICAgc2VyaWFsaXplZE5vblRlcm1pbmFsLmxhYmVsID0gbm9kZS5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2VyaWFsaXplZE5vblRlcm1pbmFsO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiQWx0ZXJuYXRpdmVcIixcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiT3B0aW9uXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbiksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvclwiLFxuICAgICAgICAgICAgaWR4OiBub2RlLmlkeCxcbiAgICAgICAgICAgIHNlcGFyYXRvcjogKHNlcmlhbGl6ZVByb2R1Y3Rpb24obmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiBub2RlLnNlcGFyYXRvciB9KSkpLFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgc2VwYXJhdG9yOiAoc2VyaWFsaXplUHJvZHVjdGlvbihuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IG5vZGUuc2VwYXJhdG9yIH0pKSksXG4gICAgICAgICAgICBkZWZpbml0aW9uOiBjb252ZXJ0RGVmaW5pdGlvbihub2RlLmRlZmluaXRpb24pLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogXCJSZXBldGl0aW9uXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIkFsdGVybmF0aW9uXCIsXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICAgICAgZGVmaW5pdGlvbjogY29udmVydERlZmluaXRpb24obm9kZS5kZWZpbml0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZSBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWRUZXJtaW5hbCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiVGVybWluYWxcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUudGVybWluYWxUeXBlLm5hbWUsXG4gICAgICAgICAgICBsYWJlbDogdG9rZW5MYWJlbChub2RlLnRlcm1pbmFsVHlwZSksXG4gICAgICAgICAgICBpZHg6IG5vZGUuaWR4LFxuICAgICAgICB9O1xuICAgICAgICBpZiAoaXNTdHJpbmcobm9kZS5sYWJlbCkpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRUZXJtaW5hbC50ZXJtaW5hbExhYmVsID0gbm9kZS5sYWJlbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXR0ZXJuID0gbm9kZS50ZXJtaW5hbFR5cGUuUEFUVEVSTjtcbiAgICAgICAgaWYgKG5vZGUudGVybWluYWxUeXBlLlBBVFRFUk4pIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZWRUZXJtaW5hbC5wYXR0ZXJuID0gaXNSZWdFeHAocGF0dGVybilcbiAgICAgICAgICAgICAgICA/IHBhdHRlcm4uc291cmNlXG4gICAgICAgICAgICAgICAgOiBwYXR0ZXJuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkVGVybWluYWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5vZGUgaW5zdGFuY2VvZiBSdWxlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIlJ1bGVcIixcbiAgICAgICAgICAgIG5hbWU6IG5vZGUubmFtZSxcbiAgICAgICAgICAgIG9yZ1RleHQ6IG5vZGUub3JnVGV4dCxcbiAgICAgICAgICAgIGRlZmluaXRpb246IGNvbnZlcnREZWZpbml0aW9uKG5vZGUuZGVmaW5pdGlvbiksXG4gICAgICAgIH07XG4gICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bW9kZWwuanMubWFwIiwiaW1wb3J0IHsgQWx0ZXJuYXRpb24sIEFsdGVybmF0aXZlLCBOb25UZXJtaW5hbCwgT3B0aW9uLCBSZXBldGl0aW9uLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IsIFJ1bGUsIFRlcm1pbmFsLCB9IGZyb20gXCIuL21vZGVsLmpzXCI7XG5leHBvcnQgY2xhc3MgR0FzdFZpc2l0b3Ige1xuICAgIHZpc2l0KG5vZGUpIHtcbiAgICAgICAgY29uc3Qgbm9kZUFueSA9IG5vZGU7XG4gICAgICAgIHN3aXRjaCAobm9kZUFueS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY2FzZSBOb25UZXJtaW5hbDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdE5vblRlcm1pbmFsKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBBbHRlcm5hdGl2ZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdEFsdGVybmF0aXZlKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBPcHRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRPcHRpb24obm9kZUFueSk7XG4gICAgICAgICAgICBjYXNlIFJlcGV0aXRpb25NYW5kYXRvcnk6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG5vZGVBbnkpO1xuICAgICAgICAgICAgY2FzZSBSZXBldGl0aW9uOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnZpc2l0UmVwZXRpdGlvbihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgQWx0ZXJuYXRpb246XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRBbHRlcm5hdGlvbihub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgVGVybWluYWw6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudmlzaXRUZXJtaW5hbChub2RlQW55KTtcbiAgICAgICAgICAgIGNhc2UgUnVsZTpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy52aXNpdFJ1bGUobm9kZUFueSk7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgbmV4dCAyICovXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdE5vblRlcm1pbmFsKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRBbHRlcm5hdGl2ZShub2RlKSB7IH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIHZpc2l0T3B0aW9uKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRSZXBldGl0aW9uKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0IDMgKi9cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihub2RlKSB7IH1cbiAgICAvKiBjOCBpZ25vcmUgbmV4dCAqL1xuICAgIHZpc2l0QWx0ZXJuYXRpb24obm9kZSkgeyB9XG4gICAgLyogYzggaWdub3JlIG5leHQgKi9cbiAgICB2aXNpdFRlcm1pbmFsKG5vZGUpIHsgfVxuICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgdmlzaXRSdWxlKG5vZGUpIHsgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dmlzaXRvci5qcy5tYXAiLCJleHBvcnQgeyBSZWdFeHBQYXJzZXIgfSBmcm9tIFwiLi9yZWdleHAtcGFyc2VyLmpzXCI7XG5leHBvcnQgeyBCYXNlUmVnRXhwVmlzaXRvciB9IGZyb20gXCIuL2Jhc2UtcmVnZXhwLXZpc2l0b3IuanNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCJleHBvcnQgY2xhc3MgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgIHZpc2l0Q2hpbGRyZW4obm9kZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBub2RlKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IG5vZGVba2V5XTtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAobm9kZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnZpc2l0KGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjaGlsZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuZm9yRWFjaCgoc3ViQ2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudmlzaXQoc3ViQ2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXQobm9kZSkge1xuICAgICAgICBzd2l0Y2ggKG5vZGUudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIlBhdHRlcm5cIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UGF0dGVybihub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJGbGFnc1wiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRGbGFncyhub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJEaXNqdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXREaXNqdW5jdGlvbihub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJBbHRlcm5hdGl2ZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRBbHRlcm5hdGl2ZShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTdGFydEFuY2hvclwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRTdGFydEFuY2hvcihub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJFbmRBbmNob3JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0RW5kQW5jaG9yKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldvcmRCb3VuZGFyeVwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRXb3JkQm91bmRhcnkobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiTm9uV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdE5vbldvcmRCb3VuZGFyeShub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TG9va2FoZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdE5lZ2F0aXZlTG9va2FoZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkNoYXJhY3RlclwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRDaGFyYWN0ZXIobm9kZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiU2V0XCI6XG4gICAgICAgICAgICAgICAgdGhpcy52aXNpdFNldChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJHcm91cFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXRHcm91cChub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJHcm91cEJhY2tSZWZlcmVuY2VcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0R3JvdXBCYWNrUmVmZXJlbmNlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIlF1YW50aWZpZXJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0UXVhbnRpZmllcihub2RlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZpc2l0Q2hpbGRyZW4obm9kZSk7XG4gICAgfVxuICAgIHZpc2l0UGF0dGVybihub2RlKSB7IH1cbiAgICB2aXNpdEZsYWdzKG5vZGUpIHsgfVxuICAgIHZpc2l0RGlzanVuY3Rpb24obm9kZSkgeyB9XG4gICAgdmlzaXRBbHRlcm5hdGl2ZShub2RlKSB7IH1cbiAgICAvLyBBc3NlcnRpb25cbiAgICB2aXNpdFN0YXJ0QW5jaG9yKG5vZGUpIHsgfVxuICAgIHZpc2l0RW5kQW5jaG9yKG5vZGUpIHsgfVxuICAgIHZpc2l0V29yZEJvdW5kYXJ5KG5vZGUpIHsgfVxuICAgIHZpc2l0Tm9uV29yZEJvdW5kYXJ5KG5vZGUpIHsgfVxuICAgIHZpc2l0TG9va2FoZWFkKG5vZGUpIHsgfVxuICAgIHZpc2l0TmVnYXRpdmVMb29rYWhlYWQobm9kZSkgeyB9XG4gICAgLy8gYXRvbXNcbiAgICB2aXNpdENoYXJhY3Rlcihub2RlKSB7IH1cbiAgICB2aXNpdFNldChub2RlKSB7IH1cbiAgICB2aXNpdEdyb3VwKG5vZGUpIHsgfVxuICAgIHZpc2l0R3JvdXBCYWNrUmVmZXJlbmNlKG5vZGUpIHsgfVxuICAgIHZpc2l0UXVhbnRpZmllcihub2RlKSB7IH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJhc2UtcmVnZXhwLXZpc2l0b3IuanMubWFwIiwiaW1wb3J0IHsgY2MgfSBmcm9tIFwiLi91dGlscy5qc1wiO1xuZXhwb3J0IGNvbnN0IGRpZ2l0c0NoYXJDb2RlcyA9IFtdO1xuZm9yIChsZXQgaSA9IGNjKFwiMFwiKTsgaSA8PSBjYyhcIjlcIik7IGkrKykge1xuICAgIGRpZ2l0c0NoYXJDb2Rlcy5wdXNoKGkpO1xufVxuZXhwb3J0IGNvbnN0IHdvcmRDaGFyQ29kZXMgPSBbY2MoXCJfXCIpXS5jb25jYXQoZGlnaXRzQ2hhckNvZGVzKTtcbmZvciAobGV0IGkgPSBjYyhcImFcIik7IGkgPD0gY2MoXCJ6XCIpOyBpKyspIHtcbiAgICB3b3JkQ2hhckNvZGVzLnB1c2goaSk7XG59XG5mb3IgKGxldCBpID0gY2MoXCJBXCIpOyBpIDw9IGNjKFwiWlwiKTsgaSsrKSB7XG4gICAgd29yZENoYXJDb2Rlcy5wdXNoKGkpO1xufVxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUmVnRXhwI2NoYXJhY3Rlci1jbGFzc2VzXG5leHBvcnQgY29uc3Qgd2hpdGVzcGFjZUNvZGVzID0gW1xuICAgIGNjKFwiIFwiKSxcbiAgICBjYyhcIlxcZlwiKSxcbiAgICBjYyhcIlxcblwiKSxcbiAgICBjYyhcIlxcclwiKSxcbiAgICBjYyhcIlxcdFwiKSxcbiAgICBjYyhcIlxcdlwiKSxcbiAgICBjYyhcIlxcdFwiKSxcbiAgICBjYyhcIlxcdTAwYTBcIiksXG4gICAgY2MoXCJcXHUxNjgwXCIpLFxuICAgIGNjKFwiXFx1MjAwMFwiKSxcbiAgICBjYyhcIlxcdTIwMDFcIiksXG4gICAgY2MoXCJcXHUyMDAyXCIpLFxuICAgIGNjKFwiXFx1MjAwM1wiKSxcbiAgICBjYyhcIlxcdTIwMDRcIiksXG4gICAgY2MoXCJcXHUyMDA1XCIpLFxuICAgIGNjKFwiXFx1MjAwNlwiKSxcbiAgICBjYyhcIlxcdTIwMDdcIiksXG4gICAgY2MoXCJcXHUyMDA4XCIpLFxuICAgIGNjKFwiXFx1MjAwOVwiKSxcbiAgICBjYyhcIlxcdTIwMGFcIiksXG4gICAgY2MoXCJcXHUyMDI4XCIpLFxuICAgIGNjKFwiXFx1MjAyOVwiKSxcbiAgICBjYyhcIlxcdTIwMmZcIiksXG4gICAgY2MoXCJcXHUyMDVmXCIpLFxuICAgIGNjKFwiXFx1MzAwMFwiKSxcbiAgICBjYyhcIlxcdWZlZmZcIiksXG5dO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2hhcmFjdGVyLWNsYXNzZXMuanMubWFwIiwiaW1wb3J0IHsgYWRkRmxhZywgQVNTRVJUX0VYSVNUUywgQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUsIGNjLCBpbnNlcnRUb1NldCwgaXNDaGFyYWN0ZXIsIH0gZnJvbSBcIi4vdXRpbHMuanNcIjtcbmltcG9ydCB7IGRpZ2l0c0NoYXJDb2Rlcywgd2hpdGVzcGFjZUNvZGVzLCB3b3JkQ2hhckNvZGVzLCB9IGZyb20gXCIuL2NoYXJhY3Rlci1jbGFzc2VzLmpzXCI7XG4vLyBjb25zdHMgYW5kIHV0aWxpdGllc1xuY29uc3QgaGV4RGlnaXRQYXR0ZXJuID0gL1swLTlhLWZBLUZdLztcbmNvbnN0IGRlY2ltYWxQYXR0ZXJuID0gL1swLTldLztcbmNvbnN0IGRlY2ltYWxQYXR0ZXJuTm9aZXJvID0gL1sxLTldLztcbi8vIGh0dHBzOi8vaGFja2Vybm9vbi5jb20vdGhlLW1hZG5lc3Mtb2YtcGFyc2luZy1yZWFsLXdvcmxkLWphdmFzY3JpcHQtcmVnZXhwcy1kOWVlMzM2ZGY5ODNcbi8vIGh0dHBzOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvOC4wL2luZGV4Lmh0bWwjcHJvZC1QYXR0ZXJuXG5leHBvcnQgY2xhc3MgUmVnRXhwUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5pZHggPSAwO1xuICAgICAgICB0aGlzLmlucHV0ID0gXCJcIjtcbiAgICAgICAgdGhpcy5ncm91cElkeCA9IDA7XG4gICAgfVxuICAgIHNhdmVTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkeDogdGhpcy5pZHgsXG4gICAgICAgICAgICBpbnB1dDogdGhpcy5pbnB1dCxcbiAgICAgICAgICAgIGdyb3VwSWR4OiB0aGlzLmdyb3VwSWR4LFxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXN0b3JlU3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5pZHggPSBuZXdTdGF0ZS5pZHg7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBuZXdTdGF0ZS5pbnB1dDtcbiAgICAgICAgdGhpcy5ncm91cElkeCA9IG5ld1N0YXRlLmdyb3VwSWR4O1xuICAgIH1cbiAgICBwYXR0ZXJuKGlucHV0KSB7XG4gICAgICAgIC8vIHBhcnNlciBzdGF0ZVxuICAgICAgICB0aGlzLmlkeCA9IDA7XG4gICAgICAgIHRoaXMuaW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5ncm91cElkeCA9IDA7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIvXCIpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGlzanVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIi9cIik7XG4gICAgICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICAgICAgdHlwZTogXCJGbGFnc1wiLFxuICAgICAgICAgICAgbG9jOiB7IGJlZ2luOiB0aGlzLmlkeCwgZW5kOiBpbnB1dC5sZW5ndGggfSxcbiAgICAgICAgICAgIGdsb2JhbDogZmFsc2UsXG4gICAgICAgICAgICBpZ25vcmVDYXNlOiBmYWxzZSxcbiAgICAgICAgICAgIG11bHRpTGluZTogZmFsc2UsXG4gICAgICAgICAgICB1bmljb2RlOiBmYWxzZSxcbiAgICAgICAgICAgIHN0aWNreTogZmFsc2UsXG4gICAgICAgIH07XG4gICAgICAgIHdoaWxlICh0aGlzLmlzUmVnRXhwRmxhZygpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJnbG9iYWxcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwiaWdub3JlQ2FzZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm1cIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJtdWx0aUxpbmVcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICAgICAgICAgIGFkZEZsYWcoZmxhZ3MsIFwidW5pY29kZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInlcIjpcbiAgICAgICAgICAgICAgICAgICAgYWRkRmxhZyhmbGFncywgXCJzdGlja3lcIik7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlkeCAhPT0gdGhpcy5pbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmVkdW5kYW50IGlucHV0OiBcIiArIHRoaXMuaW5wdXQuc3Vic3RyaW5nKHRoaXMuaWR4KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiUGF0dGVyblwiLFxuICAgICAgICAgICAgZmxhZ3M6IGZsYWdzLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgbG9jOiB0aGlzLmxvYygwKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGlzanVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IGFsdHMgPSBbXTtcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmlkeDtcbiAgICAgICAgYWx0cy5wdXNoKHRoaXMuYWx0ZXJuYXRpdmUoKSk7XG4gICAgICAgIHdoaWxlICh0aGlzLnBlZWtDaGFyKCkgPT09IFwifFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwifFwiKTtcbiAgICAgICAgICAgIGFsdHMucHVzaCh0aGlzLmFsdGVybmF0aXZlKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiRGlzanVuY3Rpb25cIiwgdmFsdWU6IGFsdHMsIGxvYzogdGhpcy5sb2MoYmVnaW4pIH07XG4gICAgfVxuICAgIGFsdGVybmF0aXZlKCkge1xuICAgICAgICBjb25zdCB0ZXJtcyA9IFtdO1xuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuaWR4O1xuICAgICAgICB3aGlsZSAodGhpcy5pc1Rlcm0oKSkge1xuICAgICAgICAgICAgdGVybXMucHVzaCh0aGlzLnRlcm0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgdHlwZTogXCJBbHRlcm5hdGl2ZVwiLCB2YWx1ZTogdGVybXMsIGxvYzogdGhpcy5sb2MoYmVnaW4pIH07XG4gICAgfVxuICAgIHRlcm0oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQXNzZXJ0aW9uKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmFzc2VydGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYXRvbSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzc2VydGlvbigpIHtcbiAgICAgICAgY29uc3QgYmVnaW4gPSB0aGlzLmlkeDtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBvcENoYXIoKSkge1xuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIlN0YXJ0QW5jaG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGxvYzogdGhpcy5sb2MoYmVnaW4pLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiRW5kQW5jaG9yXCIsIGxvYzogdGhpcy5sb2MoYmVnaW4pIH07XG4gICAgICAgICAgICAvLyAnXFxiJyBvciAnXFxCJ1xuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJiXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiV29yZEJvdW5kYXJ5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9jOiB0aGlzLmxvYyhiZWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQlwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIk5vbldvcmRCb3VuZGFyeVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvYzogdGhpcy5sb2MoYmVnaW4pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgQXNzZXJ0aW9uIEVzY2FwZVwiKTtcbiAgICAgICAgICAgIC8vICcoPz0nIG9yICcoPyEnXG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpO1xuICAgICAgICAgICAgICAgIGxldCB0eXBlO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIj1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBcIkxvb2thaGVhZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCIhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlID0gXCJOZWdhdGl2ZUxvb2thaGVhZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFTU0VSVF9FWElTVFModHlwZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlzanVuY3Rpb24gPSB0aGlzLmRpc2p1bmN0aW9uKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGRpc2p1bmN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHRoaXMubG9jKGJlZ2luKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHJldHVybiBBU1NFUlRfTkVWRVJfUkVBQ0hfSEVSRSgpO1xuICAgIH1cbiAgICBxdWFudGlmaWVyKGlzQmFja3RyYWNraW5nID0gZmFsc2UpIHtcbiAgICAgICAgbGV0IHJhbmdlID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuaWR4O1xuICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBhdExlYXN0OiAwLFxuICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBhdExlYXN0OiAxLFxuICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IEluZmluaXR5LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgICAgIHJhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICBhdExlYXN0OiAwLFxuICAgICAgICAgICAgICAgICAgICBhdE1vc3Q6IDEsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ7XCI6XG4gICAgICAgICAgICAgICAgY29uc3QgYXRMZWFzdCA9IHRoaXMuaW50ZWdlckluY2x1ZGluZ1plcm8oKTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ9XCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdExlYXN0OiBhdExlYXN0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBhdE1vc3Q7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0RpZ2l0KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdE1vc3QgPSB0aGlzLmludGVnZXJJbmNsdWRpbmdaZXJvKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TGVhc3Q6IGF0TGVhc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0TW9zdDogYXRNb3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRMZWFzdDogYXRMZWFzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXRNb3N0OiBJbmZpbml0eSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIn1cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gdGhyb3dpbmcgZXhjZXB0aW9ucyBmcm9tIFwiQVNTRVJUX0VYSVNUU1wiIGR1cmluZyBiYWNrdHJhY2tpbmdcbiAgICAgICAgICAgICAgICAvLyBjYXVzZXMgc2V2ZXJlIHBlcmZvcm1hbmNlIGRlZ3JhZGF0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChpc0JhY2t0cmFja2luZyA9PT0gdHJ1ZSAmJiByYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIEFTU0VSVF9FWElTVFMocmFuZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRocm93aW5nIGV4Y2VwdGlvbnMgZnJvbSBcIkFTU0VSVF9FWElTVFNcIiBkdXJpbmcgYmFja3RyYWNraW5nXG4gICAgICAgIC8vIGNhdXNlcyBzZXZlcmUgcGVyZm9ybWFuY2UgZGVncmFkYXRpb25zXG4gICAgICAgIGlmIChpc0JhY2t0cmFja2luZyA9PT0gdHJ1ZSAmJiByYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgICAgIGlmIChBU1NFUlRfRVhJU1RTKHJhbmdlKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVla0NoYXIoMCkgPT09IFwiP1wiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIj9cIik7XG4gICAgICAgICAgICAgICAgcmFuZ2UuZ3JlZWR5ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZS5ncmVlZHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFuZ2UudHlwZSA9IFwiUXVhbnRpZmllclwiO1xuICAgICAgICAgICAgcmFuZ2UubG9jID0gdGhpcy5sb2MoYmVnaW4pO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGF0b20oKSB7XG4gICAgICAgIGxldCBhdG9tO1xuICAgICAgICBjb25zdCBiZWdpbiA9IHRoaXMuaWR4O1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgICAgICBhdG9tID0gdGhpcy5kb3RBbGwoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAgICAgYXRvbSA9IHRoaXMuYXRvbUVzY2FwZSgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgICAgICBhdG9tID0gdGhpcy5jaGFyYWN0ZXJDbGFzcygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICBhdG9tID0gdGhpcy5ncm91cCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdG9tID09PSB1bmRlZmluZWQgJiYgdGhpcy5pc1BhdHRlcm5DaGFyYWN0ZXIoKSkge1xuICAgICAgICAgICAgYXRvbSA9IHRoaXMucGF0dGVybkNoYXJhY3RlcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgICAgIGlmIChBU1NFUlRfRVhJU1RTKGF0b20pKSB7XG4gICAgICAgICAgICBhdG9tLmxvYyA9IHRoaXMubG9jKGJlZ2luKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzUXVhbnRpZmllcigpKSB7XG4gICAgICAgICAgICAgICAgYXRvbS5xdWFudGlmaWVyID0gdGhpcy5xdWFudGlmaWVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXRvbTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICByZXR1cm4gQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKTtcbiAgICB9XG4gICAgZG90QWxsKCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiLlwiKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwiU2V0XCIsXG4gICAgICAgICAgICBjb21wbGVtZW50OiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IFtjYyhcIlxcblwiKSwgY2MoXCJcXHJcIiksIGNjKFwiXFx1MjAyOFwiKSwgY2MoXCJcXHUyMDI5XCIpXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXRvbUVzY2FwZSgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcIlxcXFxcIik7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICBjYXNlIFwiMVwiOlxuICAgICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgICBjYXNlIFwiNFwiOlxuICAgICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgICBjYXNlIFwiN1wiOlxuICAgICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICAgIGNhc2UgXCI5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVjaW1hbEVzY2FwZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICBjYXNlIFwiRFwiOlxuICAgICAgICAgICAgY2FzZSBcInNcIjpcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICBjYXNlIFwid1wiOlxuICAgICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jaGFyYWN0ZXJDbGFzc0VzY2FwZSgpO1xuICAgICAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICBjYXNlIFwiclwiOlxuICAgICAgICAgICAgY2FzZSBcInRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbEVzY2FwZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCJjXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udHJvbExldHRlckVzY2FwZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubnVsQ2hhcmFjdGVyQXRvbSgpO1xuICAgICAgICAgICAgY2FzZSBcInhcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oZXhFc2NhcGVTZXF1ZW5jZUF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCJ1XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVnRXhwVW5pY29kZUVzY2FwZVNlcXVlbmNlQXRvbSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pZGVudGl0eUVzY2FwZUF0b20oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWNpbWFsRXNjYXBlQXRvbSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnBvc2l0aXZlSW50ZWdlcigpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkdyb3VwQmFja1JlZmVyZW5jZVwiLCB2YWx1ZTogdmFsdWUgfTtcbiAgICB9XG4gICAgY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKSB7XG4gICAgICAgIGxldCBzZXQ7XG4gICAgICAgIGxldCBjb21wbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wb3BDaGFyKCkpIHtcbiAgICAgICAgICAgIGNhc2UgXCJkXCI6XG4gICAgICAgICAgICAgICAgc2V0ID0gZGlnaXRzQ2hhckNvZGVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgICAgICBzZXQgPSBkaWdpdHNDaGFyQ29kZXM7XG4gICAgICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic1wiOlxuICAgICAgICAgICAgICAgIHNldCA9IHdoaXRlc3BhY2VDb2RlcztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJTXCI6XG4gICAgICAgICAgICAgICAgc2V0ID0gd2hpdGVzcGFjZUNvZGVzO1xuICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgICAgICBzZXQgPSB3b3JkQ2hhckNvZGVzO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIldcIjpcbiAgICAgICAgICAgICAgICBzZXQgPSB3b3JkQ2hhckNvZGVzO1xuICAgICAgICAgICAgICAgIGNvbXBsZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgICAgIGlmIChBU1NFUlRfRVhJU1RTKHNldCkpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiU2V0XCIsIHZhbHVlOiBzZXQsIGNvbXBsZW1lbnQ6IGNvbXBsZW1lbnQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICByZXR1cm4gQVNTRVJUX05FVkVSX1JFQUNIX0hFUkUoKTtcbiAgICB9XG4gICAgY29udHJvbEVzY2FwZUF0b20oKSB7XG4gICAgICAgIGxldCBlc2NhcGVDb2RlO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucG9wQ2hhcigpKSB7XG4gICAgICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICAgICAgICAgIGVzY2FwZUNvZGUgPSBjYyhcIlxcZlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJuXCI6XG4gICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFxuXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgICAgICBlc2NhcGVDb2RlID0gY2MoXCJcXHJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICAgICAgICAgIGVzY2FwZUNvZGUgPSBjYyhcIlxcdFwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ2XCI6XG4gICAgICAgICAgICAgICAgZXNjYXBlQ29kZSA9IGNjKFwiXFx2XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBlbHNlXG4gICAgICAgIGlmIChBU1NFUlRfRVhJU1RTKGVzY2FwZUNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogZXNjYXBlQ29kZSB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHJldHVybiBBU1NFUlRfTkVWRVJfUkVBQ0hfSEVSRSgpO1xuICAgIH1cbiAgICBjb250cm9sTGV0dGVyRXNjYXBlQXRvbSgpIHtcbiAgICAgICAgdGhpcy5jb25zdW1lQ2hhcihcImNcIik7XG4gICAgICAgIGNvbnN0IGxldHRlciA9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICBpZiAoL1thLXpBLVpdLy50ZXN0KGxldHRlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkludmFsaWQgXCIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxldHRlckNvZGUgPSBsZXR0ZXIudG9VcHBlckNhc2UoKS5jaGFyQ29kZUF0KDApIC0gNjQ7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBsZXR0ZXJDb2RlIH07XG4gICAgfVxuICAgIG51bENoYXJhY3RlckF0b20oKSB7XG4gICAgICAgIC8vIFRPRE8gaW1wbGVtZW50ICdbbG9va2FoZWFkIOKIiSBEZWNpbWFsRGlnaXRdJ1xuICAgICAgICAvLyBUT0RPOiBmb3IgdGhlIGRlcHJlY2F0ZWQgb2N0YWwgZXNjYXBlIHNlcXVlbmNlXG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIwXCIpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2MoXCJcXDBcIikgfTtcbiAgICB9XG4gICAgaGV4RXNjYXBlU2VxdWVuY2VBdG9tKCkge1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwieFwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VIZXhEaWdpdHMoMik7XG4gICAgfVxuICAgIHJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJ1XCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUhleERpZ2l0cyg0KTtcbiAgICB9XG4gICAgaWRlbnRpdHlFc2NhcGVBdG9tKCkge1xuICAgICAgICAvLyBUT0RPOiBpbXBsZW1lbnQgXCJTb3VyY2VDaGFyYWN0ZXIgYnV0IG5vdCBVbmljb2RlSURDb250aW51ZVwiXG4gICAgICAgIC8vIC8vIGh0dHA6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyMzEvI1NwZWNpZmljX0NoYXJhY3Rlcl9BZGp1c3RtZW50c1xuICAgICAgICBjb25zdCBlc2NhcGVkQ2hhciA9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2MoZXNjYXBlZENoYXIpIH07XG4gICAgfVxuICAgIGNsYXNzUGF0dGVybkNoYXJhY3RlckF0b20oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigpKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVEJEXCIpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhuZXh0Q2hhcikgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjaGFyYWN0ZXJDbGFzcygpIHtcbiAgICAgICAgY29uc3Qgc2V0ID0gW107XG4gICAgICAgIGxldCBjb21wbGVtZW50ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJbXCIpO1xuICAgICAgICBpZiAodGhpcy5wZWVrQ2hhcigwKSA9PT0gXCJeXCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJeXCIpO1xuICAgICAgICAgICAgY29tcGxlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHRoaXMuaXNDbGFzc0F0b20oKSkge1xuICAgICAgICAgICAgY29uc3QgZnJvbSA9IHRoaXMuY2xhc3NBdG9tKCk7XG4gICAgICAgICAgICBjb25zdCBpc0Zyb21TaW5nbGVDaGFyID0gZnJvbS50eXBlID09PSBcIkNoYXJhY3RlclwiO1xuICAgICAgICAgICAgaWYgKGlzQ2hhcmFjdGVyKGZyb20pICYmIHRoaXMuaXNSYW5nZURhc2goKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCItXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvID0gdGhpcy5jbGFzc0F0b20oKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1RvU2luZ2xlQ2hhciA9IHRvLnR5cGUgPT09IFwiQ2hhcmFjdGVyXCI7XG4gICAgICAgICAgICAgICAgLy8gYSByYW5nZSBjYW4gb25seSBiZSB1c2VkIHdoZW4gYm90aCBzaWRlcyBhcmUgc2luZ2xlIGNoYXJhY3RlcnNcbiAgICAgICAgICAgICAgICBpZiAoaXNDaGFyYWN0ZXIodG8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0by52YWx1ZSA8IGZyb20udmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiUmFuZ2Ugb3V0IG9mIG9yZGVyIGluIGNoYXJhY3RlciBjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaCh7IGZyb206IGZyb20udmFsdWUsIHRvOiB0by52YWx1ZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGxpdGVyYWwgZGFzaFxuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUb1NldChmcm9tLnZhbHVlLCBzZXQpO1xuICAgICAgICAgICAgICAgICAgICBzZXQucHVzaChjYyhcIi1cIikpO1xuICAgICAgICAgICAgICAgICAgICBpbnNlcnRUb1NldCh0by52YWx1ZSwgc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpbnNlcnRUb1NldChmcm9tLnZhbHVlLCBzZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJdXCIpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIlNldFwiLCBjb21wbGVtZW50OiBjb21wbGVtZW50LCB2YWx1ZTogc2V0IH07XG4gICAgfVxuICAgIGNsYXNzQXRvbSgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKCkpIHtcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFxyXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiVEJEXCIpO1xuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc0VzY2FwZSgpO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jbGFzc1BhdHRlcm5DaGFyYWN0ZXJBdG9tKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3NFc2NhcGUoKSB7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCJcXFxcXCIpO1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgLy8gTWF0Y2hlcyBhIGJhY2tzcGFjZS5cbiAgICAgICAgICAgIC8vIChOb3QgdG8gYmUgY29uZnVzZWQgd2l0aCBcXGIgd29yZCBib3VuZGFyeSBvdXRzaWRlIGNoYXJhY3RlckNsYXNzKVxuICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiYlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2MoXCJcXHUwMDA4XCIpIH07XG4gICAgICAgICAgICBjYXNlIFwiZFwiOlxuICAgICAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJzXCI6XG4gICAgICAgICAgICBjYXNlIFwiU1wiOlxuICAgICAgICAgICAgY2FzZSBcIndcIjpcbiAgICAgICAgICAgIGNhc2UgXCJXXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcmFjdGVyQ2xhc3NFc2NhcGUoKTtcbiAgICAgICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgICAgICBjYXNlIFwiblwiOlxuICAgICAgICAgICAgY2FzZSBcInJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgICAgICBjYXNlIFwidlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xFc2NhcGVBdG9tKCk7XG4gICAgICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRyb2xMZXR0ZXJFc2NhcGVBdG9tKCk7XG4gICAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm51bENoYXJhY3RlckF0b20oKTtcbiAgICAgICAgICAgIGNhc2UgXCJ4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGV4RXNjYXBlU2VxdWVuY2VBdG9tKCk7XG4gICAgICAgICAgICBjYXNlIFwidVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJlZ0V4cFVuaWNvZGVFc2NhcGVTZXF1ZW5jZUF0b20oKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaWRlbnRpdHlFc2NhcGVBdG9tKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ3JvdXAoKSB7XG4gICAgICAgIGxldCBjYXB0dXJpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKFwiKFwiKTtcbiAgICAgICAgc3dpdGNoICh0aGlzLnBlZWtDaGFyKDApKSB7XG4gICAgICAgICAgICBjYXNlIFwiP1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI/XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCI6XCIpO1xuICAgICAgICAgICAgICAgIGNhcHR1cmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aGlzLmdyb3VwSWR4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRpc2p1bmN0aW9uKCk7XG4gICAgICAgIHRoaXMuY29uc3VtZUNoYXIoXCIpXCIpO1xuICAgICAgICBjb25zdCBncm91cEFzdCA9IHtcbiAgICAgICAgICAgIHR5cGU6IFwiR3JvdXBcIixcbiAgICAgICAgICAgIGNhcHR1cmluZzogY2FwdHVyaW5nLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoY2FwdHVyaW5nKSB7XG4gICAgICAgICAgICBncm91cEFzdFtcImlkeFwiXSA9IHRoaXMuZ3JvdXBJZHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwQXN0O1xuICAgIH1cbiAgICBwb3NpdGl2ZUludGVnZXIoKSB7XG4gICAgICAgIGxldCBudW1iZXIgPSB0aGlzLnBvcENoYXIoKTtcbiAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHQgLSBjYW4ndCBldmVyIGdldCBoZXJlIGR1ZSB0byBwcmV2aW91cyBsb29rYWhlYWQgY2hlY2tzXG4gICAgICAgIC8vIHN0aWxsIGltcGxlbWVudGluZyB0aGlzIGVycm9yIGNoZWNraW5nIGluIGNhc2UgdGhpcyBldmVyIGNoYW5nZXMuXG4gICAgICAgIGlmIChkZWNpbWFsUGF0dGVybk5vWmVyby50ZXN0KG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhIHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGRlY2ltYWxQYXR0ZXJuLnRlc3QodGhpcy5wZWVrQ2hhcigwKSkpIHtcbiAgICAgICAgICAgIG51bWJlciArPSB0aGlzLnBvcENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VJbnQobnVtYmVyLCAxMCk7XG4gICAgfVxuICAgIGludGVnZXJJbmNsdWRpbmdaZXJvKCkge1xuICAgICAgICBsZXQgbnVtYmVyID0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgIGlmIChkZWNpbWFsUGF0dGVybi50ZXN0KG51bWJlcikgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGluZyBhbiBpbnRlZ2VyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChkZWNpbWFsUGF0dGVybi50ZXN0KHRoaXMucGVla0NoYXIoMCkpKSB7XG4gICAgICAgICAgICBudW1iZXIgKz0gdGhpcy5wb3BDaGFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KG51bWJlciwgMTApO1xuICAgIH1cbiAgICBwYXR0ZXJuQ2hhcmFjdGVyKCkge1xuICAgICAgICBjb25zdCBuZXh0Q2hhciA9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICBzd2l0Y2ggKG5leHRDaGFyKSB7XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiJFwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiKlwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCIrXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgIGNhc2UgXCIpXCI6XG4gICAgICAgICAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICBjYXNlIFwifFwiOlxuICAgICAgICAgICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUQkRcIik7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IFwiQ2hhcmFjdGVyXCIsIHZhbHVlOiBjYyhuZXh0Q2hhcikgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1JlZ0V4cEZsYWcoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigwKSkge1xuICAgICAgICAgICAgY2FzZSBcImdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJpXCI6XG4gICAgICAgICAgICBjYXNlIFwibVwiOlxuICAgICAgICAgICAgY2FzZSBcInVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1JhbmdlRGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGVla0NoYXIoKSA9PT0gXCItXCIgJiYgdGhpcy5pc0NsYXNzQXRvbSgxKTtcbiAgICB9XG4gICAgaXNEaWdpdCgpIHtcbiAgICAgICAgcmV0dXJuIGRlY2ltYWxQYXR0ZXJuLnRlc3QodGhpcy5wZWVrQ2hhcigwKSk7XG4gICAgfVxuICAgIGlzQ2xhc3NBdG9tKGhvd011Y2ggPSAwKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcihob3dNdWNoKSkge1xuICAgICAgICAgICAgY2FzZSBcIl1cIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXG5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI4XCI6XG4gICAgICAgICAgICBjYXNlIFwiXFx1MjAyOVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNUZXJtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0F0b20oKSB8fCB0aGlzLmlzQXNzZXJ0aW9uKCk7XG4gICAgfVxuICAgIGlzQXRvbSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNQYXR0ZXJuQ2hhcmFjdGVyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigwKSkge1xuICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IC8vIGF0b21Fc2NhcGVcbiAgICAgICAgICAgIGNhc2UgXCJbXCI6IC8vIGNoYXJhY3RlckNsYXNzXG4gICAgICAgICAgICAvLyBUT0RPOiBpc0F0b20gbXVzdCBiZSBjYWxsZWQgYmVmb3JlIGlzQXNzZXJ0aW9uIC0gZGlzYW1iaWd1YXRlXG4gICAgICAgICAgICBjYXNlIFwiKFwiOiAvLyBncm91cFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNBc3NlcnRpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5wZWVrQ2hhcigwKSkge1xuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAvLyAnXFxiJyBvciAnXFxCJ1xuICAgICAgICAgICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkJcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vICcoPz0nIG9yICcoPyEnXG4gICAgICAgICAgICBjYXNlIFwiKFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5wZWVrQ2hhcigxKSA9PT0gXCI/XCIgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRoaXMucGVla0NoYXIoMikgPT09IFwiPVwiIHx8IHRoaXMucGVla0NoYXIoMikgPT09IFwiIVwiKSk7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1F1YW50aWZpZXIoKSB7XG4gICAgICAgIGNvbnN0IHByZXZTdGF0ZSA9IHRoaXMuc2F2ZVN0YXRlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5xdWFudGlmaWVyKHRydWUpICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucmVzdG9yZVN0YXRlKHByZXZTdGF0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaXNQYXR0ZXJuQ2hhcmFjdGVyKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMucGVla0NoYXIoKSkge1xuICAgICAgICAgICAgY2FzZSBcIl5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIkXCI6XG4gICAgICAgICAgICBjYXNlIFwiXFxcXFwiOlxuICAgICAgICAgICAgY2FzZSBcIi5cIjpcbiAgICAgICAgICAgIGNhc2UgXCIqXCI6XG4gICAgICAgICAgICBjYXNlIFwiK1wiOlxuICAgICAgICAgICAgY2FzZSBcIj9cIjpcbiAgICAgICAgICAgIGNhc2UgXCIoXCI6XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgY2FzZSBcIltcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ8XCI6XG4gICAgICAgICAgICBjYXNlIFwiL1wiOlxuICAgICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcclwiOlxuICAgICAgICAgICAgY2FzZSBcIlxcdTIwMjhcIjpcbiAgICAgICAgICAgIGNhc2UgXCJcXHUyMDI5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUhleERpZ2l0cyhob3dNYW55KSB7XG4gICAgICAgIGxldCBoZXhTdHJpbmcgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhvd01hbnk7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaGV4Q2hhciA9IHRoaXMucG9wQ2hhcigpO1xuICAgICAgICAgICAgaWYgKGhleERpZ2l0UGF0dGVybi50ZXN0KGhleENoYXIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiRXhwZWN0aW5nIGEgSGV4RGVjaW1hbCBkaWdpdHNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZXhTdHJpbmcgKz0gaGV4Q2hhcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFyQ29kZSA9IHBhcnNlSW50KGhleFN0cmluZywgMTYpO1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkNoYXJhY3RlclwiLCB2YWx1ZTogY2hhckNvZGUgfTtcbiAgICB9XG4gICAgcGVla0NoYXIoaG93TXVjaCA9IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5wdXRbdGhpcy5pZHggKyBob3dNdWNoXTtcbiAgICB9XG4gICAgcG9wQ2hhcigpIHtcbiAgICAgICAgY29uc3QgbmV4dENoYXIgPSB0aGlzLnBlZWtDaGFyKDApO1xuICAgICAgICB0aGlzLmNvbnN1bWVDaGFyKHVuZGVmaW5lZCk7XG4gICAgICAgIHJldHVybiBuZXh0Q2hhcjtcbiAgICB9XG4gICAgY29uc3VtZUNoYXIoY2hhcikge1xuICAgICAgICBpZiAoY2hhciAhPT0gdW5kZWZpbmVkICYmIHRoaXMuaW5wdXRbdGhpcy5pZHhdICE9PSBjaGFyKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkOiAnXCIgK1xuICAgICAgICAgICAgICAgIGNoYXIgK1xuICAgICAgICAgICAgICAgIFwiJyBidXQgZm91bmQ6ICdcIiArXG4gICAgICAgICAgICAgICAgdGhpcy5pbnB1dFt0aGlzLmlkeF0gK1xuICAgICAgICAgICAgICAgIFwiJyBhdCBvZmZzZXQ6IFwiICtcbiAgICAgICAgICAgICAgICB0aGlzLmlkeCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaWR4ID49IHRoaXMuaW5wdXQubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgZW5kIG9mIGlucHV0XCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaWR4Kys7XG4gICAgfVxuICAgIGxvYyhiZWdpbikge1xuICAgICAgICByZXR1cm4geyBiZWdpbjogYmVnaW4sIGVuZDogdGhpcy5pZHggfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdleHAtcGFyc2VyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBjYyhjaGFyKSB7XG4gICAgcmV0dXJuIGNoYXIuY2hhckNvZGVBdCgwKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpbnNlcnRUb1NldChpdGVtLCBzZXQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICBpdGVtLmZvckVhY2goZnVuY3Rpb24gKHN1Ykl0ZW0pIHtcbiAgICAgICAgICAgIHNldC5wdXNoKHN1Ykl0ZW0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldC5wdXNoKGl0ZW0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBhZGRGbGFnKGZsYWdPYmosIGZsYWdLZXkpIHtcbiAgICBpZiAoZmxhZ09ialtmbGFnS2V5XSA9PT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBcImR1cGxpY2F0ZSBmbGFnIFwiICsgZmxhZ0tleTtcbiAgICB9XG4gICAgY29uc3QgeCA9IGZsYWdPYmpbZmxhZ0tleV07XG4gICAgZmxhZ09ialtmbGFnS2V5XSA9IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gQVNTRVJUX0VYSVNUUyhvYmopIHtcbiAgICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuICAgIGlmIChvYmogPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBFcnJvcihcIkludGVybmFsIEVycm9yIC0gU2hvdWxkIG5ldmVyIGdldCBoZXJlIVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dFxuZXhwb3J0IGZ1bmN0aW9uIEFTU0VSVF9ORVZFUl9SRUFDSF9IRVJFKCkge1xuICAgIHRocm93IEVycm9yKFwiSW50ZXJuYWwgRXJyb3IgLSBTaG91bGQgbmV2ZXIgZ2V0IGhlcmUhXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hhcmFjdGVyKG9iaikge1xuICAgIHJldHVybiBvYmpbXCJ0eXBlXCJdID09PSBcIkNoYXJhY3RlclwiO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwiZXhwb3J0IHsgUFJJTlRfV0FSTklORywgUFJJTlRfRVJST1IgfSBmcm9tIFwiLi9wcmludC5qc1wiO1xuZXhwb3J0IHsgdGltZXIgfSBmcm9tIFwiLi90aW1lci5qc1wiO1xuZXhwb3J0IHsgdG9GYXN0UHJvcGVydGllcyB9IGZyb20gXCIuL3RvLWZhc3QtcHJvcGVydGllcy5qc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBQUklOVF9FUlJPUihtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGNhbid0IG92ZXJyaWRlIGdsb2JhbC5jb25zb2xlIGluIG5vZGUuanMgKi9cbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yOiAke21zZ31gKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gUFJJTlRfV0FSTklORyhtc2cpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIGNhbid0IG92ZXJyaWRlIGdsb2JhbC5jb25zb2xlIGluIG5vZGUuanMqL1xuICAgIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAvLyBUT0RPOiBtb2RpZnkgZG9jcyBhY2NvcmRpbmdseVxuICAgICAgICBjb25zb2xlLndhcm4oYFdhcm5pbmc6ICR7bXNnfWApO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByaW50LmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiB0aW1lcihmdW5jKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgICBjb25zdCB2YWwgPSBmdW5jKCk7XG4gICAgY29uc3QgZW5kID0gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgY29uc3QgdG90YWwgPSBlbmQgLSBzdGFydDtcbiAgICByZXR1cm4geyB0aW1lOiB0b3RhbCwgdmFsdWU6IHZhbCB9O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGltZXIuanMubWFwIiwiLy8gYmFzZWQgb246IGh0dHBzOi8vZ2l0aHViLmNvbS9wZXRrYWFudG9ub3YvYmx1ZWJpcmQvYmxvYi9iOTdjMGQyZDQ4N2U4YzUwNzZlOGJkODk3ZTBkY2Q0NjIyZDMxODQ2L3NyYy91dGlsLmpzI0wyMDEtTDIxNlxuZXhwb3J0IGZ1bmN0aW9uIHRvRmFzdFByb3BlcnRpZXModG9CZWNvbWVGYXN0KSB7XG4gICAgZnVuY3Rpb24gRmFrZUNvbnN0cnVjdG9yKCkgeyB9XG4gICAgLy8gSWYgb3VyIG9iamVjdCBpcyB1c2VkIGFzIGEgY29uc3RydWN0b3IsIGl0IHdvdWxkIHJlY2VpdmVcbiAgICBGYWtlQ29uc3RydWN0b3IucHJvdG90eXBlID0gdG9CZWNvbWVGYXN0O1xuICAgIGNvbnN0IGZha2VJbnN0YW5jZSA9IG5ldyBGYWtlQ29uc3RydWN0b3IoKTtcbiAgICBmdW5jdGlvbiBmYWtlQWNjZXNzKCkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIGZha2VJbnN0YW5jZS5iYXI7XG4gICAgfVxuICAgIC8vIGhlbHAgVjggdW5kZXJzdGFuZCB0aGlzIGlzIGEgXCJyZWFsXCIgcHJvdG90eXBlIGJ5IGFjdHVhbGx5IHVzaW5nXG4gICAgLy8gdGhlIGZha2UgaW5zdGFuY2UuXG4gICAgZmFrZUFjY2VzcygpO1xuICAgIGZha2VBY2Nlc3MoKTtcbiAgICAvLyBBbHdheXMgdHJ1ZSBjb25kaXRpb24gdG8gc3VwcHJlc3MgdGhlIEZpcmVmb3ggd2FybmluZyBvZiB1bnJlYWNoYWJsZVxuICAgIC8vIGNvZGUgYWZ0ZXIgYSByZXR1cm4gc3RhdGVtZW50LlxuICAgIGlmICgxKVxuICAgICAgICByZXR1cm4gdG9CZWNvbWVGYXN0O1xuICAgIC8vIEV2YWwgcHJldmVudHMgb3B0aW1pemF0aW9uIG9mIHRoaXMgbWV0aG9kIChldmVuIHRob3VnaCB0aGlzIGlzIGRlYWQgY29kZSlcbiAgICAvLyAtIGh0dHBzOi8vZXNidWlsZC5naXRodWIuaW8vY29udGVudC10eXBlcy8jZGlyZWN0LWV2YWxcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZVxuICAgICgwLCBldmFsKSh0b0JlY29tZUZhc3QpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG8tZmFzdC1wcm9wZXJ0aWVzLmpzLm1hcCIsImltcG9ydCB7XG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQ29tbW9uVmFsdWVDb252ZXJ0ZXIsXG4gIEdpdEdyYXBoR2VuZXJhdGVkTW9kdWxlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBfX25hbWVcbn0gZnJvbSBcIi4vY2h1bmstN1BLSTZFMkUubWpzXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9naXRHcmFwaC9tb2R1bGUudHNcbmltcG9ydCB7XG4gIGluamVjdCxcbiAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUsXG4gIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlLFxuICBFbXB0eUZpbGVTeXN0ZW1cbn0gZnJvbSBcImxhbmdpdW1cIjtcblxuLy8gc3JjL2xhbmd1YWdlL2dpdEdyYXBoL3Rva2VuQnVpbGRlci50c1xudmFyIEdpdEdyYXBoVG9rZW5CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkdpdEdyYXBoVG9rZW5CdWlsZGVyXCIpO1xuICB9XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKFtcImdpdEdyYXBoXCJdKTtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2dpdEdyYXBoL21vZHVsZS50c1xudmFyIEdpdEdyYXBoTW9kdWxlID0ge1xuICBwYXJzZXI6IHtcbiAgICBUb2tlbkJ1aWxkZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IEdpdEdyYXBoVG9rZW5CdWlsZGVyKCksIFwiVG9rZW5CdWlsZGVyXCIpLFxuICAgIFZhbHVlQ29udmVydGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBDb21tb25WYWx1ZUNvbnZlcnRlcigpLCBcIlZhbHVlQ29udmVydGVyXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzKGNvbnRleHQgPSBFbXB0eUZpbGVTeXN0ZW0pIHtcbiAgY29uc3Qgc2hhcmVkID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlKGNvbnRleHQpLFxuICAgIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGVcbiAgKTtcbiAgY29uc3QgR2l0R3JhcGggPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoeyBzaGFyZWQgfSksXG4gICAgR2l0R3JhcGhHZW5lcmF0ZWRNb2R1bGUsXG4gICAgR2l0R3JhcGhNb2R1bGVcbiAgKTtcbiAgc2hhcmVkLlNlcnZpY2VSZWdpc3RyeS5yZWdpc3RlcihHaXRHcmFwaCk7XG4gIHJldHVybiB7IHNoYXJlZCwgR2l0R3JhcGggfTtcbn1cbl9fbmFtZShjcmVhdGVHaXRHcmFwaFNlcnZpY2VzLCBcImNyZWF0ZUdpdEdyYXBoU2VydmljZXNcIik7XG5cbmV4cG9ydCB7XG4gIEdpdEdyYXBoTW9kdWxlLFxuICBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzXG59O1xuIiwiaW1wb3J0IHtcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBDb21tb25WYWx1ZUNvbnZlcnRlcixcbiAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZSxcbiAgUmFkYXJHZW5lcmF0ZWRNb2R1bGUsXG4gIF9fbmFtZVxufSBmcm9tIFwiLi9jaHVuay03UEtJNkUyRS5tanNcIjtcblxuLy8gc3JjL2xhbmd1YWdlL3JhZGFyL21vZHVsZS50c1xuaW1wb3J0IHtcbiAgRW1wdHlGaWxlU3lzdGVtLFxuICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSxcbiAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUsXG4gIGluamVjdFxufSBmcm9tIFwibGFuZ2l1bVwiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcmFkYXIvdG9rZW5CdWlsZGVyLnRzXG52YXIgUmFkYXJUb2tlbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiUmFkYXJUb2tlbkJ1aWxkZXJcIik7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW1wicmFkYXItYmV0YVwiXSk7XG4gIH1cbn07XG5cbi8vIHNyYy9sYW5ndWFnZS9yYWRhci9tb2R1bGUudHNcbnZhciBSYWRhck1vZHVsZSA9IHtcbiAgcGFyc2VyOiB7XG4gICAgVG9rZW5CdWlsZGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBSYWRhclRva2VuQnVpbGRlcigpLCBcIlRva2VuQnVpbGRlclwiKSxcbiAgICBWYWx1ZUNvbnZlcnRlcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBuZXcgQ29tbW9uVmFsdWVDb252ZXJ0ZXIoKSwgXCJWYWx1ZUNvbnZlcnRlclwiKVxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUmFkYXJTZXJ2aWNlcyhjb250ZXh0ID0gRW1wdHlGaWxlU3lzdGVtKSB7XG4gIGNvbnN0IHNoYXJlZCA9IGluamVjdChcbiAgICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShjb250ZXh0KSxcbiAgICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlXG4gICk7XG4gIGNvbnN0IFJhZGFyID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlKHsgc2hhcmVkIH0pLFxuICAgIFJhZGFyR2VuZXJhdGVkTW9kdWxlLFxuICAgIFJhZGFyTW9kdWxlXG4gICk7XG4gIHNoYXJlZC5TZXJ2aWNlUmVnaXN0cnkucmVnaXN0ZXIoUmFkYXIpO1xuICByZXR1cm4geyBzaGFyZWQsIFJhZGFyIH07XG59XG5fX25hbWUoY3JlYXRlUmFkYXJTZXJ2aWNlcywgXCJjcmVhdGVSYWRhclNlcnZpY2VzXCIpO1xuXG5leHBvcnQge1xuICBSYWRhck1vZHVsZSxcbiAgY3JlYXRlUmFkYXJTZXJ2aWNlc1xufTtcbiIsInZhciBfX2RlZlByb3AgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG52YXIgX19uYW1lID0gKHRhcmdldCwgdmFsdWUpID0+IF9fZGVmUHJvcCh0YXJnZXQsIFwibmFtZVwiLCB7IHZhbHVlLCBjb25maWd1cmFibGU6IHRydWUgfSk7XG5cbi8vIHNyYy9sYW5ndWFnZS9nZW5lcmF0ZWQvYXN0LnRzXG5pbXBvcnQgeyBBYnN0cmFjdEFzdFJlZmxlY3Rpb24gfSBmcm9tIFwibGFuZ2l1bVwiO1xudmFyIFN0YXRlbWVudCA9IFwiU3RhdGVtZW50XCI7XG52YXIgQXJjaGl0ZWN0dXJlID0gXCJBcmNoaXRlY3R1cmVcIjtcbmZ1bmN0aW9uIGlzQXJjaGl0ZWN0dXJlKGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBcmNoaXRlY3R1cmUpO1xufVxuX19uYW1lKGlzQXJjaGl0ZWN0dXJlLCBcImlzQXJjaGl0ZWN0dXJlXCIpO1xudmFyIEF4aXMgPSBcIkF4aXNcIjtcbnZhciBCcmFuY2ggPSBcIkJyYW5jaFwiO1xuZnVuY3Rpb24gaXNCcmFuY2goaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEJyYW5jaCk7XG59XG5fX25hbWUoaXNCcmFuY2gsIFwiaXNCcmFuY2hcIik7XG52YXIgQ2hlY2tvdXQgPSBcIkNoZWNrb3V0XCI7XG52YXIgQ2hlcnJ5UGlja2luZyA9IFwiQ2hlcnJ5UGlja2luZ1wiO1xudmFyIENvbW1pdCA9IFwiQ29tbWl0XCI7XG5mdW5jdGlvbiBpc0NvbW1pdChpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ29tbWl0KTtcbn1cbl9fbmFtZShpc0NvbW1pdCwgXCJpc0NvbW1pdFwiKTtcbnZhciBDb21tb24gPSBcIkNvbW1vblwiO1xuZnVuY3Rpb24gaXNDb21tb24oaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIENvbW1vbik7XG59XG5fX25hbWUoaXNDb21tb24sIFwiaXNDb21tb25cIik7XG52YXIgQ3VydmUgPSBcIkN1cnZlXCI7XG52YXIgRWRnZSA9IFwiRWRnZVwiO1xudmFyIEVudHJ5ID0gXCJFbnRyeVwiO1xudmFyIEdpdEdyYXBoID0gXCJHaXRHcmFwaFwiO1xuZnVuY3Rpb24gaXNHaXRHcmFwaChpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgR2l0R3JhcGgpO1xufVxuX19uYW1lKGlzR2l0R3JhcGgsIFwiaXNHaXRHcmFwaFwiKTtcbnZhciBHcm91cCA9IFwiR3JvdXBcIjtcbnZhciBJbmZvID0gXCJJbmZvXCI7XG5mdW5jdGlvbiBpc0luZm8oaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEluZm8pO1xufVxuX19uYW1lKGlzSW5mbywgXCJpc0luZm9cIik7XG52YXIgSnVuY3Rpb24gPSBcIkp1bmN0aW9uXCI7XG52YXIgTWVyZ2UgPSBcIk1lcmdlXCI7XG5mdW5jdGlvbiBpc01lcmdlKGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBNZXJnZSk7XG59XG5fX25hbWUoaXNNZXJnZSwgXCJpc01lcmdlXCIpO1xudmFyIE9wdGlvbiA9IFwiT3B0aW9uXCI7XG52YXIgUGFja2V0ID0gXCJQYWNrZXRcIjtcbmZ1bmN0aW9uIGlzUGFja2V0KGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBQYWNrZXQpO1xufVxuX19uYW1lKGlzUGFja2V0LCBcImlzUGFja2V0XCIpO1xudmFyIFBhY2tldEJsb2NrID0gXCJQYWNrZXRCbG9ja1wiO1xuZnVuY3Rpb24gaXNQYWNrZXRCbG9jayhpdGVtKSB7XG4gIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUGFja2V0QmxvY2spO1xufVxuX19uYW1lKGlzUGFja2V0QmxvY2ssIFwiaXNQYWNrZXRCbG9ja1wiKTtcbnZhciBQaWUgPSBcIlBpZVwiO1xuZnVuY3Rpb24gaXNQaWUoaXRlbSkge1xuICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFBpZSk7XG59XG5fX25hbWUoaXNQaWUsIFwiaXNQaWVcIik7XG52YXIgUGllU2VjdGlvbiA9IFwiUGllU2VjdGlvblwiO1xuZnVuY3Rpb24gaXNQaWVTZWN0aW9uKGl0ZW0pIHtcbiAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBQaWVTZWN0aW9uKTtcbn1cbl9fbmFtZShpc1BpZVNlY3Rpb24sIFwiaXNQaWVTZWN0aW9uXCIpO1xudmFyIFJhZGFyID0gXCJSYWRhclwiO1xudmFyIFNlcnZpY2UgPSBcIlNlcnZpY2VcIjtcbnZhciBEaXJlY3Rpb24gPSBcIkRpcmVjdGlvblwiO1xudmFyIE1lcm1haWRBc3RSZWZsZWN0aW9uID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdEFzdFJlZmxlY3Rpb24ge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIk1lcm1haWRBc3RSZWZsZWN0aW9uXCIpO1xuICB9XG4gIGdldEFsbFR5cGVzKCkge1xuICAgIHJldHVybiBbQXJjaGl0ZWN0dXJlLCBBeGlzLCBCcmFuY2gsIENoZWNrb3V0LCBDaGVycnlQaWNraW5nLCBDb21taXQsIENvbW1vbiwgQ3VydmUsIERpcmVjdGlvbiwgRWRnZSwgRW50cnksIEdpdEdyYXBoLCBHcm91cCwgSW5mbywgSnVuY3Rpb24sIE1lcmdlLCBPcHRpb24sIFBhY2tldCwgUGFja2V0QmxvY2ssIFBpZSwgUGllU2VjdGlvbiwgUmFkYXIsIFNlcnZpY2UsIFN0YXRlbWVudF07XG4gIH1cbiAgY29tcHV0ZUlzU3VidHlwZShzdWJ0eXBlLCBzdXBlcnR5cGUpIHtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgQnJhbmNoOlxuICAgICAgY2FzZSBDaGVja291dDpcbiAgICAgIGNhc2UgQ2hlcnJ5UGlja2luZzpcbiAgICAgIGNhc2UgQ29tbWl0OlxuICAgICAgY2FzZSBNZXJnZToge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoU3RhdGVtZW50LCBzdXBlcnR5cGUpO1xuICAgICAgfVxuICAgICAgY2FzZSBEaXJlY3Rpb246IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKEdpdEdyYXBoLCBzdXBlcnR5cGUpO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldFJlZmVyZW5jZVR5cGUocmVmSW5mbykge1xuICAgIGNvbnN0IHJlZmVyZW5jZUlkID0gYCR7cmVmSW5mby5jb250YWluZXIuJHR5cGV9OiR7cmVmSW5mby5wcm9wZXJ0eX1gO1xuICAgIHN3aXRjaCAocmVmZXJlbmNlSWQpIHtcbiAgICAgIGNhc2UgXCJFbnRyeTpheGlzXCI6IHtcbiAgICAgICAgcmV0dXJuIEF4aXM7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgJHtyZWZlcmVuY2VJZH0gaXMgbm90IGEgdmFsaWQgcmVmZXJlbmNlIGlkLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRUeXBlTWV0YURhdGEodHlwZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBBcmNoaXRlY3R1cmU6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBBcmNoaXRlY3R1cmUsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImFjY0Rlc2NyXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NUaXRsZVwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiZWRnZXNcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImdyb3Vwc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwianVuY3Rpb25zXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJzZXJ2aWNlc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwidGl0bGVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBBeGlzOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogQXhpcyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwibGFiZWxcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIm5hbWVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBCcmFuY2g6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBCcmFuY2gsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcIm5hbWVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIm9yZGVyXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQ2hlY2tvdXQ6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBDaGVja291dCxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYnJhbmNoXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQ2hlcnJ5UGlja2luZzoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IENoZXJyeVBpY2tpbmcsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJwYXJlbnRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRhZ3NcIiwgZGVmYXVsdFZhbHVlOiBbXSB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBDb21taXQ6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBDb21taXQsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJtZXNzYWdlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0YWdzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0eXBlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQ29tbW9uOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogQ29tbW9uLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NEZXNjclwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjVGl0bGVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgQ3VydmU6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBDdXJ2ZSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiZW50cmllc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwibGFiZWxcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcIm5hbWVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBFZGdlOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogRWRnZSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwibGhzRGlyXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJsaHNHcm91cFwiLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwibGhzSWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImxoc0ludG9cIiwgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInJoc0RpclwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwicmhzR3JvdXBcIiwgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInJoc0lkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJyaHNJbnRvXCIsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIEVudHJ5OiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogRW50cnksXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImF4aXNcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInZhbHVlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgR2l0R3JhcGg6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBHaXRHcmFwaCxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJzdGF0ZW1lbnRzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIEdyb3VwOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogR3JvdXAsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImljb25cIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJpblwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwidGl0bGVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBJbmZvOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogSW5mbyxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIEp1bmN0aW9uOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogSnVuY3Rpb24sXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImlkXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJpblwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIE1lcmdlOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogTWVyZ2UsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImJyYW5jaFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiaWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRhZ3NcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInR5cGVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBPcHRpb246IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBPcHRpb24sXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcIm5hbWVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInZhbHVlXCIsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgUGFja2V0OiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogUGFja2V0LFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NEZXNjclwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjVGl0bGVcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImJsb2Nrc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwidGl0bGVcIiB9XG4gICAgICAgICAgXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY2FzZSBQYWNrZXRCbG9jazoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFBhY2tldEJsb2NrLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJlbmRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImxhYmVsXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJzdGFydFwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFBpZToge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFBpZSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJzZWN0aW9uc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwic2hvd0RhdGFcIiwgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNhc2UgUGllU2VjdGlvbjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IFBpZVNlY3Rpb24sXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImxhYmVsXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ2YWx1ZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFJhZGFyOiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZTogUmFkYXIsXG4gICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgeyBuYW1lOiBcImFjY0Rlc2NyXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJhY2NUaXRsZVwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiYXhlc1wiLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiY3VydmVzXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJvcHRpb25zXCIsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIFNlcnZpY2U6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiBTZXJ2aWNlLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgIHsgbmFtZTogXCJpY29uXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJpY29uVGV4dFwiIH0sXG4gICAgICAgICAgICB7IG5hbWU6IFwiaWRcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImluXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJ0aXRsZVwiIH1cbiAgICAgICAgICBdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjYXNlIERpcmVjdGlvbjoge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6IERpcmVjdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICB7IG5hbWU6IFwiYWNjRGVzY3JcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcImFjY1RpdGxlXCIgfSxcbiAgICAgICAgICAgIHsgbmFtZTogXCJkaXJcIiB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInN0YXRlbWVudHNcIiwgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgeyBuYW1lOiBcInRpdGxlXCIgfVxuICAgICAgICAgIF1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgIHByb3BlcnRpZXM6IFtdXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xudmFyIHJlZmxlY3Rpb24gPSBuZXcgTWVybWFpZEFzdFJlZmxlY3Rpb24oKTtcblxuLy8gc3JjL2xhbmd1YWdlL2dlbmVyYXRlZC9ncmFtbWFyLnRzXG5pbXBvcnQgeyBsb2FkR3JhbW1hckZyb21Kc29uIH0gZnJvbSBcImxhbmdpdW1cIjtcbnZhciBsb2FkZWRJbmZvR3JhbW1hcjtcbnZhciBJbmZvR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkSW5mb0dyYW1tYXIgPz8gKGxvYWRlZEluZm9HcmFtbWFyID0gbG9hZEdyYW1tYXJGcm9tSnNvbigne1wiJHR5cGVcIjpcIkdyYW1tYXJcIixcImlzRGVjbGFyZWRcIjp0cnVlLFwibmFtZVwiOlwiSW5mb1wiLFwiaW1wb3J0c1wiOltdLFwicnVsZXNcIjpbe1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImVudHJ5XCI6dHJ1ZSxcIm5hbWVcIjpcIkluZm9cIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJpbmZvXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInNob3dJbmZvXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dLFwiY2FyZGluYWxpdHlcIjpcIj9cIn0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiP1wifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIlRpdGxlQW5kQWNjZXNzaWJpbGl0aWVzXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjRGVzY3JcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImFjY1RpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0aXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdfV0sXCJjYXJkaW5hbGl0eVwiOlwiK1wifSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJmcmFnbWVudFwiOnRydWUsXCJuYW1lXCI6XCJFT0xcIixcImRhdGFUeXBlXCI6XCJzdHJpbmdcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDNcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LHtcIiR0eXBlXCI6XCJFbmRPZkZpbGVcIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIk5FV0xJTkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9cXFxcXFxcXHI/XFxcXFxcXFxuL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQUNDX0RFU0NSXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKmFjY0Rlc2NyKD86W1xcXFxcXFxcdCBdKjooW15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKil8XFxcXFxcXFxzKnsoW159XSopfSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjVGl0bGVbXFxcXFxcXFx0IF0qOig/OlteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFteXFxcXFxcXFxuXFxcXFxcXFxyXSopL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qdGl0bGUoPzpbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qfCkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiV0hJVEVTUEFDRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSsvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIllBTUxcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8tLS1bXFxcXFxcXFx0IF0qXFxcXFxcXFxyP1xcXFxcXFxcbig/OltcXFxcXFxcXFNcXFxcXFxcXHNdKj9cXFxcXFxcXHI/XFxcXFxcXFxuKT8tLS0oPzpcXFxcXFxcXHI/XFxcXFxcXFxufCg/IVxcXFxcXFxcUykpL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJESVJFQ1RJVkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSV7W1xcXFxcXFxcU1xcXFxcXFxcc10qP30lJSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIlNJTkdMRV9MSU5FX0NPTU1FTlRcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSVbXlxcXFxcXFxcblxcXFxcXFxccl0qL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJ0eXBlc1wiOltdLFwidXNlZEdyYW1tYXJzXCI6W119JykpLCBcIkluZm9HcmFtbWFyXCIpO1xudmFyIGxvYWRlZFBhY2tldEdyYW1tYXI7XG52YXIgUGFja2V0R3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkUGFja2V0R3JhbW1hciA/PyAobG9hZGVkUGFja2V0R3JhbW1hciA9IGxvYWRHcmFtbWFyRnJvbUpzb24oYHtcIiR0eXBlXCI6XCJHcmFtbWFyXCIsXCJpc0RlY2xhcmVkXCI6dHJ1ZSxcIm5hbWVcIjpcIlBhY2tldFwiLFwiaW1wb3J0c1wiOltdLFwicnVsZXNcIjpbe1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImVudHJ5XCI6dHJ1ZSxcIm5hbWVcIjpcIlBhY2tldFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInBhY2tldC1iZXRhXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDRcIn0sXCJhcmd1bWVudHNcIjpbXX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImJsb2Nrc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDZcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJibG9ja3NcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiK1wifV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlBhY2tldEJsb2NrXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic3RhcnRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIi1cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImVuZFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxhYmVsXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDNcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIklOVFwiLFwidHlwZVwiOntcIiR0eXBlXCI6XCJSZXR1cm5UeXBlXCIsXCJuYW1lXCI6XCJudW1iZXJcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvMHxbMS05XVswLTldKi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlNUUklOR1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcIlteXFxcXFwiXSpcXFxcXCJ8J1teJ10qJy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJmcmFnbWVudFwiOnRydWUsXCJuYW1lXCI6XCJUaXRsZUFuZEFjY2Vzc2liaWxpdGllc1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImFjY0Rlc2NyXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDdcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NUaXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A4XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAOVwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX1dLFwiY2FyZGluYWxpdHlcIjpcIitcIn0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwiZnJhZ21lbnRcIjp0cnVlLFwibmFtZVwiOlwiRU9MXCIsXCJkYXRhVHlwZVwiOlwic3RyaW5nXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiK1wifSx7XCIkdHlwZVwiOlwiRW5kT2ZGaWxlXCJ9XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJORVdMSU5FXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvXFxcXFxcXFxyP1xcXFxcXFxcbi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19ERVNDUlwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NEZXNjcig/OltcXFxcXFxcXHQgXSo6KFteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFteXFxcXFxcXFxuXFxcXFxcXFxyXSopfFxcXFxcXFxccyp7KFtefV0qKX0pL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQUNDX1RJVExFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKmFjY1RpdGxlW1xcXFxcXFxcdCBdKjooPzpbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlRJVExFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKnRpdGxlKD86W1xcXFxcXFxcdCBdW15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W1xcXFxcXFxcdCBdW15cXFxcXFxcXG5cXFxcXFxcXHJdKnwpL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIldISVRFU1BBQ0VcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0rL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJZQU1MXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvLS0tW1xcXFxcXFxcdCBdKlxcXFxcXFxccj9cXFxcXFxcXG4oPzpbXFxcXFxcXFxTXFxcXFxcXFxzXSo/XFxcXFxcXFxyP1xcXFxcXFxcbik/LS0tKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiRElSRUNUSVZFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKiUle1tcXFxcXFxcXFNcXFxcXFxcXHNdKj99JSUoPzpcXFxcXFxcXHI/XFxcXFxcXFxufCg/IVxcXFxcXFxcUykpL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJTSU5HTEVfTElORV9DT01NRU5UXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKiUlW15cXFxcXFxcXG5cXFxcXFxcXHJdKi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfV0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcImludGVyZmFjZXNcIjpbe1wiJHR5cGVcIjpcIkludGVyZmFjZVwiLFwibmFtZVwiOlwiQ29tbW9uXCIsXCJhdHRyaWJ1dGVzXCI6W3tcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJhY2NEZXNjclwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX0se1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY1RpdGxlXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwidGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19XSxcInN1cGVyVHlwZXNcIjpbXX1dLFwidHlwZXNcIjpbXSxcInVzZWRHcmFtbWFyc1wiOltdfWApKSwgXCJQYWNrZXRHcmFtbWFyXCIpO1xudmFyIGxvYWRlZFBpZUdyYW1tYXI7XG52YXIgUGllR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkUGllR3JhbW1hciA/PyAobG9hZGVkUGllR3JhbW1hciA9IGxvYWRHcmFtbWFyRnJvbUpzb24oJ3tcIiR0eXBlXCI6XCJHcmFtbWFyXCIsXCJpc0RlY2xhcmVkXCI6dHJ1ZSxcIm5hbWVcIjpcIlBpZVwiLFwiaW1wb3J0c1wiOltdLFwicnVsZXNcIjpbe1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImVudHJ5XCI6dHJ1ZSxcIm5hbWVcIjpcIlBpZVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInBpZVwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic2hvd0RhdGFcIixcIm9wZXJhdG9yXCI6XCI/PVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInNob3dEYXRhXCJ9LFwiY2FyZGluYWxpdHlcIjpcIj9cIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDZcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic2VjdGlvbnNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiKlwifV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A2XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiK1wifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwic2VjdGlvbnNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiK1wifV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlBpZVNlY3Rpb25cIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJsYWJlbFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInZhbHVlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDNcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlBJRV9TRUNUSU9OX0xBQkVMXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvXFxcXFwiW15cXFxcXCJdK1xcXFxcIi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlBJRV9TRUNUSU9OX1ZBTFVFXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJldHVyblR5cGVcIixcIm5hbWVcIjpcIm51bWJlclwifSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8oMHxbMS05XVswLTldKikoXFxcXFxcXFwuWzAtOV0rKT8vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwiZnJhZ21lbnRcIjp0cnVlLFwibmFtZVwiOlwiVGl0bGVBbmRBY2Nlc3NpYmlsaXRpZXNcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NEZXNjclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A3XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAOFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDlcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A1XCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIkVPTFwiLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIitcIn0se1wiJHR5cGVcIjpcIkVuZE9mRmlsZVwifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiTkVXTElORVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxccj9cXFxcXFxcXG4vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfREVTQ1JcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjRGVzY3IoPzpbXFxcXFxcXFx0IF0qOihbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKXxcXFxcXFxcXHMqeyhbXn1dKil9KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NUaXRsZVtcXFxcXFxcXHQgXSo6KD86W15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKikvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJUSVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSp0aXRsZSg/OltcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFtcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSp8KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJXSElURVNQQUNFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiWUFNTFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLy0tLVtcXFxcXFxcXHQgXSpcXFxcXFxcXHI/XFxcXFxcXFxuKD86W1xcXFxcXFxcU1xcXFxcXFxcc10qP1xcXFxcXFxccj9cXFxcXFxcXG4pPy0tLSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIkRJUkVDVElWRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJXtbXFxcXFxcXFxTXFxcXFxcXFxzXSo/fSUlKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiU0lOR0xFX0xJTkVfQ09NTUVOVFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJVteXFxcXFxcXFxuXFxcXFxcXFxyXSovXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX1dLFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJpbnRlcmZhY2VzXCI6W3tcIiR0eXBlXCI6XCJJbnRlcmZhY2VcIixcIm5hbWVcIjpcIkNvbW1vblwiLFwiYXR0cmlidXRlc1wiOlt7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjRGVzY3JcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJhY2NUaXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX0se1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcInRpdGxlXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fV0sXCJzdXBlclR5cGVzXCI6W119XSxcInR5cGVzXCI6W10sXCJ1c2VkR3JhbW1hcnNcIjpbXX0nKSksIFwiUGllR3JhbW1hclwiKTtcbnZhciBsb2FkZWRBcmNoaXRlY3R1cmVHcmFtbWFyO1xudmFyIEFyY2hpdGVjdHVyZUdyYW1tYXIgPSAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IGxvYWRlZEFyY2hpdGVjdHVyZUdyYW1tYXIgPz8gKGxvYWRlZEFyY2hpdGVjdHVyZUdyYW1tYXIgPSBsb2FkR3JhbW1hckZyb21Kc29uKCd7XCIkdHlwZVwiOlwiR3JhbW1hclwiLFwiaXNEZWNsYXJlZFwiOnRydWUsXCJuYW1lXCI6XCJBcmNoaXRlY3R1cmVcIixcImltcG9ydHNcIjpbXSxcInJ1bGVzXCI6W3tcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJlbnRyeVwiOnRydWUsXCJuYW1lXCI6XCJBcmNoaXRlY3R1cmVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiYXJjaGl0ZWN0dXJlLWJldGFcIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE4XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE2XCJ9LFwiYXJndW1lbnRzXCI6W119XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE4XCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDFcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxOFwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIlN0YXRlbWVudFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJncm91cHNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJzZXJ2aWNlc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANlwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImp1bmN0aW9uc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAN1wifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImVkZ2VzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A4XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIkxlZnRQb3J0XCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxoc0RpclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A5XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIlJpZ2h0UG9ydFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInJoc0RpclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0A5XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIjpcIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJmcmFnbWVudFwiOnRydWUsXCJuYW1lXCI6XCJBcnJvd1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJsaHNJbnRvXCIsXCJvcGVyYXRvclwiOlwiPz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiLS1cIn0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIi1cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEzXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIi1cIn1dfV19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJyaHNJbnRvXCIsXCJvcGVyYXRvclwiOlwiPz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAM1wifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkdyb3VwXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImdyb3VwXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJpZFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImljb25cIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTJcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTNcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiaW5cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImluXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEwXCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIlNlcnZpY2VcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwic2VydmljZVwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTBcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJpY29uVGV4dFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMVwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImljb25cIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTJcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0aXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxM1wifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJpblwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaW5cIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTBcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTdcIn0sXCJhcmd1bWVudHNcIjpbXX1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiSnVuY3Rpb25cIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwianVuY3Rpb25cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImlkXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEwXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiaW5cIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImluXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEwXCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkVkZ2VcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJsaHNJZFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxoc0dyb3VwXCIsXCJvcGVyYXRvclwiOlwiPz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNFwifSxcImFyZ3VtZW50c1wiOltdfSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwicmhzSWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTBcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJyaHNHcm91cFwiLFwib3BlcmF0b3JcIjpcIj89XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTRcIn0sXCJhcmd1bWVudHNcIjpbXX0sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJST1dfRElSRUNUSU9OXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlRlcm1pbmFsQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiVGVybWluYWxBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJUZXJtaW5hbEFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkNoYXJhY3RlclJhbmdlXCIsXCJsZWZ0XCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJMXCJ9fSx7XCIkdHlwZVwiOlwiQ2hhcmFjdGVyUmFuZ2VcIixcImxlZnRcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIlJcIn19XX0se1wiJHR5cGVcIjpcIkNoYXJhY3RlclJhbmdlXCIsXCJsZWZ0XCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJUXCJ9fV19LHtcIiR0eXBlXCI6XCJDaGFyYWN0ZXJSYW5nZVwiLFwibGVmdFwiOntcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiQlwifX1dfSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJDSF9JRFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHddKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFSQ0hfVEVYVF9JQ09OXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvXFxcXFxcXFwoXFxcXFwiW15cXFxcXCJdK1xcXFxcIlxcXFxcXFxcKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFSQ0hfSUNPTlwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxcKFtcXFxcXFxcXHctOl0rXFxcXFxcXFwpL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJDSF9USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxcW1tcXFxcXFxcXHcgXStcXFxcXFxcXF0vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBUlJPV19HUk9VUFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxce2dyb3VwXFxcXFxcXFx9L1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQVJST1dfSU5UT1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLzx8Pi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJmcmFnbWVudFwiOnRydWUsXCJuYW1lXCI6XCJUaXRsZUFuZEFjY2Vzc2liaWxpdGllc1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImFjY0Rlc2NyXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE5XCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0aXRsZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMVwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIkVPTFwiLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LHtcIiR0eXBlXCI6XCJFbmRPZkZpbGVcIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIk5FV0xJTkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9cXFxcXFxcXHI/XFxcXFxcXFxuL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiQUNDX0RFU0NSXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKmFjY0Rlc2NyKD86W1xcXFxcXFxcdCBdKjooW15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKil8XFxcXFxcXFxzKnsoW159XSopfSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjVGl0bGVbXFxcXFxcXFx0IF0qOig/OlteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFteXFxcXFxcXFxuXFxcXFxcXFxyXSopL1wifSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5cIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiVElUTEVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qdGl0bGUoPzpbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXFxcXFxcXFx0IF1bXlxcXFxcXFxcblxcXFxcXFxccl0qfCkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiV0hJVEVTUEFDRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSsvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIllBTUxcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8tLS1bXFxcXFxcXFx0IF0qXFxcXFxcXFxyP1xcXFxcXFxcbig/OltcXFxcXFxcXFNcXFxcXFxcXHNdKj9cXFxcXFxcXHI/XFxcXFxcXFxuKT8tLS0oPzpcXFxcXFxcXHI/XFxcXFxcXFxufCg/IVxcXFxcXFxcUykpL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJESVJFQ1RJVkVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSV7W1xcXFxcXFxcU1xcXFxcXFxcc10qP30lJSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIlNJTkdMRV9MSU5FX0NPTU1FTlRcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qJSVbXlxcXFxcXFxcblxcXFxcXFxccl0qL1wifSxcImZyYWdtZW50XCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJ0eXBlc1wiOltdLFwidXNlZEdyYW1tYXJzXCI6W119JykpLCBcIkFyY2hpdGVjdHVyZUdyYW1tYXJcIik7XG52YXIgbG9hZGVkR2l0R3JhcGhHcmFtbWFyO1xudmFyIEdpdEdyYXBoR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkR2l0R3JhcGhHcmFtbWFyID8/IChsb2FkZWRHaXRHcmFwaEdyYW1tYXIgPSBsb2FkR3JhbW1hckZyb21Kc29uKGB7XCIkdHlwZVwiOlwiR3JhbW1hclwiLFwiaXNEZWNsYXJlZFwiOnRydWUsXCJuYW1lXCI6XCJHaXRHcmFwaFwiLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJydWxlc1wiOlt7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwiZnJhZ21lbnRcIjp0cnVlLFwibmFtZVwiOlwiVGl0bGVBbmRBY2Nlc3NpYmlsaXRpZXNcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NEZXNjclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AzXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIkVPTFwiLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIitcIn0se1wiJHR5cGVcIjpcIkVuZE9mRmlsZVwifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiTkVXTElORVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxccj9cXFxcXFxcXG4vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfREVTQ1JcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjRGVzY3IoPzpbXFxcXFxcXFx0IF0qOihbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKXxcXFxcXFxcXHMqeyhbXn1dKil9KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NUaXRsZVtcXFxcXFxcXHQgXSo6KD86W15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKikvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJUSVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSp0aXRsZSg/OltcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFtcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSp8KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJXSElURVNQQUNFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiWUFNTFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLy0tLVtcXFxcXFxcXHQgXSpcXFxcXFxcXHI/XFxcXFxcXFxuKD86W1xcXFxcXFxcU1xcXFxcXFxcc10qP1xcXFxcXFxccj9cXFxcXFxcXG4pPy0tLSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIkRJUkVDVElWRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJXtbXFxcXFxcXFxTXFxcXFxcXFxzXSo/fSUlKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiU0lOR0xFX0xJTkVfQ09NTUVOVFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJVteXFxcXFxcXFxuXFxcXFxcXFxyXSovXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImVudHJ5XCI6dHJ1ZSxcIm5hbWVcIjpcIkdpdEdyYXBoXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDJcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiZ2l0R3JhcGhcIn0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImdpdEdyYXBoXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiOlwifV19LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiZ2l0R3JhcGg6XCJ9LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJnaXRHcmFwaFwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEyXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiOlwifV19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AwXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJzdGF0ZW1lbnRzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMVwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJTdGF0ZW1lbnRcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEzXCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTRcIn0sXCJhcmd1bWVudHNcIjpbXX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE2XCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTdcIn0sXCJhcmd1bWVudHNcIjpbXX1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiRGlyZWN0aW9uXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImRpclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJMUlwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIlRCXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiQlRcIn1dfX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkNvbW1pdFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJjb21taXRcIn0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImlkOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIm1zZzpcIixcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJtZXNzYWdlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0YWc6XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0YWdzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMFwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwidHlwZTpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInR5cGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiTk9STUFMXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiUkVWRVJTRVwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIkhJR0hMSUdIVFwifV19fV19XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJCcmFuY2hcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiYnJhbmNoXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJuYW1lXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE5XCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX1dfX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIm9yZGVyOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwib3JkZXJcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCI/XCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJNZXJnZVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJtZXJnZVwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYnJhbmNoXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE5XCJ9LFwiYXJndW1lbnRzXCI6W119LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX1dfX0se1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImlkOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiaWRcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMjBcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInRhZzpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRhZ3NcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0eXBlOlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidHlwZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJOT1JNQUxcIn0se1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJSRVZFUlNFXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiSElHSExJR0hUXCJ9XX19XX1dLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W119XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkNoZWNrb3V0XCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImNoZWNrb3V0XCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwic3dpdGNoXCJ9XX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImJyYW5jaFwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxOVwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119XX19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJDaGVycnlQaWNraW5nXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImNoZXJyeS1waWNrXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJpZDpcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImlkXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0YWc6XCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ0YWdzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMFwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwicGFyZW50OlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwicGFyZW50XCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMVwifSxcImFyZ3VtZW50c1wiOltdfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImZyYWdtZW50XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIklOVFwiLFwidHlwZVwiOntcIiR0eXBlXCI6XCJSZXR1cm5UeXBlXCIsXCJuYW1lXCI6XCJudW1iZXJcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvWzAtOV0rKD89XFxcXFxcXFxzKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIklEXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJldHVyblR5cGVcIixcIm5hbWVcIjpcInN0cmluZ1wifSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9cXFxcXFxcXHcoWy1cXFxcXFxcXC4vXFxcXFxcXFx3XSpbLVxcXFxcXFxcd10pPy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlNUUklOR1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcIlteXFxcXFwiXSpcXFxcXCJ8J1teJ10qJy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW1wb3J0c1wiOltdLFwidHlwZXNcIjpbXSxcInVzZWRHcmFtbWFyc1wiOltdfWApKSwgXCJHaXRHcmFwaEdyYW1tYXJcIik7XG52YXIgbG9hZGVkUmFkYXJHcmFtbWFyO1xudmFyIFJhZGFyR3JhbW1hciA9IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbG9hZGVkUmFkYXJHcmFtbWFyID8/IChsb2FkZWRSYWRhckdyYW1tYXIgPSBsb2FkR3JhbW1hckZyb21Kc29uKGB7XCIkdHlwZVwiOlwiR3JhbW1hclwiLFwiaXNEZWNsYXJlZFwiOnRydWUsXCJuYW1lXCI6XCJSYWRhclwiLFwiaW50ZXJmYWNlc1wiOlt7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJDb21tb25cIixcImF0dHJpYnV0ZXNcIjpbe1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcImFjY0Rlc2NyXCIsXCJpc09wdGlvbmFsXCI6dHJ1ZSxcInR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwicHJpbWl0aXZlVHlwZVwiOlwic3RyaW5nXCJ9fSx7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYWNjVGl0bGVcIixcImlzT3B0aW9uYWxcIjp0cnVlLFwidHlwZVwiOntcIiR0eXBlXCI6XCJTaW1wbGVUeXBlXCIsXCJwcmltaXRpdmVUeXBlXCI6XCJzdHJpbmdcIn19LHtcIiR0eXBlXCI6XCJUeXBlQXR0cmlidXRlXCIsXCJuYW1lXCI6XCJ0aXRsZVwiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcInN0cmluZ1wifX1dLFwic3VwZXJUeXBlc1wiOltdfSx7XCIkdHlwZVwiOlwiSW50ZXJmYWNlXCIsXCJuYW1lXCI6XCJFbnRyeVwiLFwiYXR0cmlidXRlc1wiOlt7XCIkdHlwZVwiOlwiVHlwZUF0dHJpYnV0ZVwiLFwibmFtZVwiOlwiYXhpc1wiLFwiaXNPcHRpb25hbFwiOnRydWUsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJlZmVyZW5jZVR5cGVcIixcInJlZmVyZW5jZVR5cGVcIjp7XCIkdHlwZVwiOlwiU2ltcGxlVHlwZVwiLFwidHlwZVJlZlwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTJcIn19fX0se1wiJHR5cGVcIjpcIlR5cGVBdHRyaWJ1dGVcIixcIm5hbWVcIjpcInZhbHVlXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlNpbXBsZVR5cGVcIixcInByaW1pdGl2ZVR5cGVcIjpcIm51bWJlclwifSxcImlzT3B0aW9uYWxcIjpmYWxzZX1dLFwic3VwZXJUeXBlc1wiOltdfV0sXCJydWxlc1wiOlt7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwiZnJhZ21lbnRcIjp0cnVlLFwibmFtZVwiOlwiVGl0bGVBbmRBY2Nlc3NpYmlsaXRpZXNcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJhY2NEZXNjclwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AzXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYWNjVGl0bGVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNANFwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInRpdGxlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDVcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxXCJ9LFwiYXJndW1lbnRzXCI6W119XSxcImNhcmRpbmFsaXR5XCI6XCIrXCJ9LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIkVPTFwiLFwiZGF0YVR5cGVcIjpcInN0cmluZ1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIitcIn0se1wiJHR5cGVcIjpcIkVuZE9mRmlsZVwifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiTkVXTElORVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcXFxccj9cXFxcXFxcXG4vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJBQ0NfREVTQ1JcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi9bXFxcXFxcXFx0IF0qYWNjRGVzY3IoPzpbXFxcXFxcXFx0IF0qOihbXlxcXFxcXFxcblxcXFxcXFxccl0qPyg/PSUlKXxbXlxcXFxcXFxcblxcXFxcXFxccl0qKXxcXFxcXFxcXHMqeyhbXn1dKil9KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkFDQ19USVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSphY2NUaXRsZVtcXFxcXFxcXHQgXSo6KD86W15cXFxcXFxcXG5cXFxcXFxcXHJdKj8oPz0lJSl8W15cXFxcXFxcXG5cXFxcXFxcXHJdKikvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJUSVRMRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSp0aXRsZSg/OltcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSo/KD89JSUpfFtcXFxcXFxcXHQgXVteXFxcXFxcXFxuXFxcXFxcXFxyXSp8KS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcImhpZGRlblwiOnRydWUsXCJuYW1lXCI6XCJXSElURVNQQUNFXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW1xcXFxcXFxcdCBdKy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiWUFNTFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiLy0tLVtcXFxcXFxcXHQgXSpcXFxcXFxcXHI/XFxcXFxcXFxuKD86W1xcXFxcXFxcU1xcXFxcXFxcc10qP1xcXFxcXFxccj9cXFxcXFxcXG4pPy0tLSg/OlxcXFxcXFxccj9cXFxcXFxcXG58KD8hXFxcXFxcXFxTKSkvXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwiaGlkZGVuXCI6dHJ1ZSxcIm5hbWVcIjpcIkRJUkVDVElWRVwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJXtbXFxcXFxcXFxTXFxcXFxcXFxzXSo/fSUlKD86XFxcXFxcXFxyP1xcXFxcXFxcbnwoPyFcXFxcXFxcXFMpKS9cIn0sXCJmcmFnbWVudFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJoaWRkZW5cIjp0cnVlLFwibmFtZVwiOlwiU0lOR0xFX0xJTkVfQ09NTUVOVFwiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1tcXFxcXFxcXHQgXSolJVteXFxcXFxcXFxuXFxcXFxcXFxyXSovXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImVudHJ5XCI6dHJ1ZSxcIm5hbWVcIjpcIlJhZGFyXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDJcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwicmFkYXItYmV0YVwifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInJhZGFyLWJldGE6XCJ9LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJyYWRhci1iZXRhXCJ9LHtcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiOlwifV19XX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDBcIn0sXCJhcmd1bWVudHNcIjpbXX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImF4aXNcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImF4ZXNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEyXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiLFwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiYXhlc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTJcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImN1cnZlXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJjdXJ2ZXNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEzXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiLFwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiY3VydmVzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxM1wifSxcImFyZ3VtZW50c1wiOltdfX1dLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJvcHRpb25zXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxN1wifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIixcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcIm9wdGlvbnNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE3XCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiKlwifV19LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdfV0sXCJjYXJkaW5hbGl0eVwiOlwiKlwifV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcImZyYWdtZW50XCI6dHJ1ZSxcIm5hbWVcIjpcIkxhYmVsXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIltcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImxhYmVsXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIyXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIl1cIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJoaWRkZW5Ub2tlbnNcIjpbXSxcInBhcmFtZXRlcnNcIjpbXSxcIndpbGRjYXJkXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJQYXJzZXJSdWxlXCIsXCJuYW1lXCI6XCJBeGlzXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwibmFtZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyMVwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxMVwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIj9cIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiQ3VydmVcIixcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJuYW1lXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIxXCJ9LFwiYXJndW1lbnRzXCI6W119fSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDExXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIntcIn0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNFwifSxcImFyZ3VtZW50c1wiOltdfSx7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIn1cIn1dfSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwiZnJhZ21lbnRcIjp0cnVlLFwibmFtZVwiOlwiRW50cmllc1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJBbHRlcm5hdGl2ZXNcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiZW50cmllc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTZcIn0sXCJhcmd1bWVudHNcIjpbXX19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCIsXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcImVudHJpZXNcIixcIm9wZXJhdG9yXCI6XCIrPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE2XCJ9LFwiYXJndW1lbnRzXCI6W119fV0sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDJcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDJcIn0sXCJhcmd1bWVudHNcIjpbXSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJlbnRyaWVzXCIsXCJvcGVyYXRvclwiOlwiKz1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxNVwifSxcImFyZ3VtZW50c1wiOltdfX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcIixcIn0se1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AyXCJ9LFwiYXJndW1lbnRzXCI6W10sXCJjYXJkaW5hbGl0eVwiOlwiKlwifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwiZW50cmllc1wiLFwib3BlcmF0b3JcIjpcIis9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTVcIn0sXCJhcmd1bWVudHNcIjpbXX19XSxcImNhcmRpbmFsaXR5XCI6XCIqXCJ9LHtcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMlwifSxcImFyZ3VtZW50c1wiOltdLFwiY2FyZGluYWxpdHlcIjpcIipcIn1dfV19LFwiZGVmaW5lc0hpZGRlblRva2Vuc1wiOmZhbHNlLFwiZW50cnlcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIkRldGFpbGVkRW50cnlcIixcInJldHVyblR5cGVcIjp7XCIkcmVmXCI6XCIjL2ludGVyZmFjZXNAMVwifSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJheGlzXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiQ3Jvc3NSZWZlcmVuY2VcIixcInR5cGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDEyXCJ9LFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIxXCJ9LFwiYXJndW1lbnRzXCI6W119LFwiZGVwcmVjYXRlZFN5bnRheFwiOmZhbHNlfX0se1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCI6XCIsXCJjYXJkaW5hbGl0eVwiOlwiP1wifSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidmFsdWVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlBhcnNlclJ1bGVcIixcIm5hbWVcIjpcIk51bWJlckVudHJ5XCIsXCJyZXR1cm5UeXBlXCI6e1wiJHJlZlwiOlwiIy9pbnRlcmZhY2VzQDFcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInZhbHVlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE4XCJ9LFwiYXJndW1lbnRzXCI6W119fSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImVudHJ5XCI6ZmFsc2UsXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuVG9rZW5zXCI6W10sXCJwYXJhbWV0ZXJzXCI6W10sXCJ3aWxkY2FyZFwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiUGFyc2VyUnVsZVwiLFwibmFtZVwiOlwiT3B0aW9uXCIsXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIkFsdGVybmF0aXZlc1wiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwibmFtZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJzaG93TGVnZW5kXCJ9fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidmFsdWVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMTlcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwibmFtZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJ0aWNrc1wifX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInZhbHVlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDE4XCJ9LFwiYXJndW1lbnRzXCI6W119fV19LHtcIiR0eXBlXCI6XCJHcm91cFwiLFwiZWxlbWVudHNcIjpbe1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcIm5hbWVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwibWF4XCJ9fSx7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwidmFsdWVcIixcIm9wZXJhdG9yXCI6XCI9XCIsXCJ0ZXJtaW5hbFwiOntcIiR0eXBlXCI6XCJSdWxlQ2FsbFwiLFwicnVsZVwiOntcIiRyZWZcIjpcIiMvcnVsZXNAMThcIn0sXCJhcmd1bWVudHNcIjpbXX19XX0se1wiJHR5cGVcIjpcIkdyb3VwXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQXNzaWdubWVudFwiLFwiZmVhdHVyZVwiOlwibmFtZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJtaW5cIn19LHtcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJ2YWx1ZVwiLFwib3BlcmF0b3JcIjpcIj1cIixcInRlcm1pbmFsXCI6e1wiJHR5cGVcIjpcIlJ1bGVDYWxsXCIsXCJydWxlXCI6e1wiJHJlZlwiOlwiIy9ydWxlc0AxOFwifSxcImFyZ3VtZW50c1wiOltdfX1dfSx7XCIkdHlwZVwiOlwiR3JvdXBcIixcImVsZW1lbnRzXCI6W3tcIiR0eXBlXCI6XCJBc3NpZ25tZW50XCIsXCJmZWF0dXJlXCI6XCJuYW1lXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImdyYXRpY3VsZVwifX0se1wiJHR5cGVcIjpcIkFzc2lnbm1lbnRcIixcImZlYXR1cmVcIjpcInZhbHVlXCIsXCJvcGVyYXRvclwiOlwiPVwiLFwidGVybWluYWxcIjp7XCIkdHlwZVwiOlwiUnVsZUNhbGxcIixcInJ1bGVcIjp7XCIkcmVmXCI6XCIjL3J1bGVzQDIwXCJ9LFwiYXJndW1lbnRzXCI6W119fV19XX0sXCJkZWZpbmVzSGlkZGVuVG9rZW5zXCI6ZmFsc2UsXCJlbnRyeVwiOmZhbHNlLFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwicGFyYW1ldGVyc1wiOltdLFwid2lsZGNhcmRcIjpmYWxzZX0se1wiJHR5cGVcIjpcIlRlcm1pbmFsUnVsZVwiLFwibmFtZVwiOlwiTlVNQkVSXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJldHVyblR5cGVcIixcIm5hbWVcIjpcIm51bWJlclwifSxcImRlZmluaXRpb25cIjp7XCIkdHlwZVwiOlwiUmVnZXhUb2tlblwiLFwicmVnZXhcIjpcIi8oMHxbMS05XVswLTldKikoXFxcXFxcXFwuWzAtOV0rKT8vXCJ9LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJCT09MRUFOXCIsXCJ0eXBlXCI6e1wiJHR5cGVcIjpcIlJldHVyblR5cGVcIixcIm5hbWVcIjpcImJvb2xlYW5cIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlRlcm1pbmFsQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQ2hhcmFjdGVyUmFuZ2VcIixcImxlZnRcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcInRydWVcIn19LHtcIiR0eXBlXCI6XCJDaGFyYWN0ZXJSYW5nZVwiLFwibGVmdFwiOntcIiR0eXBlXCI6XCJLZXl3b3JkXCIsXCJ2YWx1ZVwiOlwiZmFsc2VcIn19XX0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIkdSQVRJQ1VMRVwiLFwidHlwZVwiOntcIiR0eXBlXCI6XCJSZXR1cm5UeXBlXCIsXCJuYW1lXCI6XCJzdHJpbmdcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlRlcm1pbmFsQWx0ZXJuYXRpdmVzXCIsXCJlbGVtZW50c1wiOlt7XCIkdHlwZVwiOlwiQ2hhcmFjdGVyUmFuZ2VcIixcImxlZnRcIjp7XCIkdHlwZVwiOlwiS2V5d29yZFwiLFwidmFsdWVcIjpcImNpcmNsZVwifX0se1wiJHR5cGVcIjpcIkNoYXJhY3RlclJhbmdlXCIsXCJsZWZ0XCI6e1wiJHR5cGVcIjpcIktleXdvcmRcIixcInZhbHVlXCI6XCJwb2x5Z29uXCJ9fV19LFwiZnJhZ21lbnRcIjpmYWxzZSxcImhpZGRlblwiOmZhbHNlfSx7XCIkdHlwZVwiOlwiVGVybWluYWxSdWxlXCIsXCJuYW1lXCI6XCJJRFwiLFwidHlwZVwiOntcIiR0eXBlXCI6XCJSZXR1cm5UeXBlXCIsXCJuYW1lXCI6XCJzdHJpbmdcIn0sXCJkZWZpbml0aW9uXCI6e1wiJHR5cGVcIjpcIlJlZ2V4VG9rZW5cIixcInJlZ2V4XCI6XCIvW2EtekEtWl9dW2EtekEtWjAtOVxcXFxcXFxcLV9dKi9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9LHtcIiR0eXBlXCI6XCJUZXJtaW5hbFJ1bGVcIixcIm5hbWVcIjpcIlNUUklOR1wiLFwiZGVmaW5pdGlvblwiOntcIiR0eXBlXCI6XCJSZWdleFRva2VuXCIsXCJyZWdleFwiOlwiL1xcXFxcIlteXFxcXFwiXSpcXFxcXCJ8J1teJ10qJy9cIn0sXCJmcmFnbWVudFwiOmZhbHNlLFwiaGlkZGVuXCI6ZmFsc2V9XSxcImRlZmluZXNIaWRkZW5Ub2tlbnNcIjpmYWxzZSxcImhpZGRlblRva2Vuc1wiOltdLFwiaW1wb3J0c1wiOltdLFwidHlwZXNcIjpbXSxcInVzZWRHcmFtbWFyc1wiOltdfWApKSwgXCJSYWRhckdyYW1tYXJcIik7XG5cbi8vIHNyYy9sYW5ndWFnZS9nZW5lcmF0ZWQvbW9kdWxlLnRzXG52YXIgSW5mb0xhbmd1YWdlTWV0YURhdGEgPSB7XG4gIGxhbmd1YWdlSWQ6IFwiaW5mb1wiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICBtb2RlOiBcInByb2R1Y3Rpb25cIlxufTtcbnZhciBQYWNrZXRMYW5ndWFnZU1ldGFEYXRhID0ge1xuICBsYW5ndWFnZUlkOiBcInBhY2tldFwiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICBtb2RlOiBcInByb2R1Y3Rpb25cIlxufTtcbnZhciBQaWVMYW5ndWFnZU1ldGFEYXRhID0ge1xuICBsYW5ndWFnZUlkOiBcInBpZVwiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICBtb2RlOiBcInByb2R1Y3Rpb25cIlxufTtcbnZhciBBcmNoaXRlY3R1cmVMYW5ndWFnZU1ldGFEYXRhID0ge1xuICBsYW5ndWFnZUlkOiBcImFyY2hpdGVjdHVyZVwiLFxuICBmaWxlRXh0ZW5zaW9uczogW1wiLm1tZFwiLCBcIi5tZXJtYWlkXCJdLFxuICBjYXNlSW5zZW5zaXRpdmU6IGZhbHNlLFxuICBtb2RlOiBcInByb2R1Y3Rpb25cIlxufTtcbnZhciBHaXRHcmFwaExhbmd1YWdlTWV0YURhdGEgPSB7XG4gIGxhbmd1YWdlSWQ6IFwiZ2l0R3JhcGhcIixcbiAgZmlsZUV4dGVuc2lvbnM6IFtcIi5tbWRcIiwgXCIubWVybWFpZFwiXSxcbiAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgbW9kZTogXCJwcm9kdWN0aW9uXCJcbn07XG52YXIgUmFkYXJMYW5ndWFnZU1ldGFEYXRhID0ge1xuICBsYW5ndWFnZUlkOiBcInJhZGFyXCIsXG4gIGZpbGVFeHRlbnNpb25zOiBbXCIubW1kXCIsIFwiLm1lcm1haWRcIl0sXG4gIGNhc2VJbnNlbnNpdGl2ZTogZmFsc2UsXG4gIG1vZGU6IFwicHJvZHVjdGlvblwiXG59O1xudmFyIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGUgPSB7XG4gIEFzdFJlZmxlY3Rpb246IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IE1lcm1haWRBc3RSZWZsZWN0aW9uKCksIFwiQXN0UmVmbGVjdGlvblwiKVxufTtcbnZhciBJbmZvR2VuZXJhdGVkTW9kdWxlID0ge1xuICBHcmFtbWFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IEluZm9HcmFtbWFyKCksIFwiR3JhbW1hclwiKSxcbiAgTGFuZ3VhZ2VNZXRhRGF0YTogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBJbmZvTGFuZ3VhZ2VNZXRhRGF0YSwgXCJMYW5ndWFnZU1ldGFEYXRhXCIpLFxuICBwYXJzZXI6IHt9XG59O1xudmFyIFBhY2tldEdlbmVyYXRlZE1vZHVsZSA9IHtcbiAgR3JhbW1hcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBQYWNrZXRHcmFtbWFyKCksIFwiR3JhbW1hclwiKSxcbiAgTGFuZ3VhZ2VNZXRhRGF0YTogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBQYWNrZXRMYW5ndWFnZU1ldGFEYXRhLCBcIkxhbmd1YWdlTWV0YURhdGFcIiksXG4gIHBhcnNlcjoge31cbn07XG52YXIgUGllR2VuZXJhdGVkTW9kdWxlID0ge1xuICBHcmFtbWFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IFBpZUdyYW1tYXIoKSwgXCJHcmFtbWFyXCIpLFxuICBMYW5ndWFnZU1ldGFEYXRhOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IFBpZUxhbmd1YWdlTWV0YURhdGEsIFwiTGFuZ3VhZ2VNZXRhRGF0YVwiKSxcbiAgcGFyc2VyOiB7fVxufTtcbnZhciBBcmNoaXRlY3R1cmVHZW5lcmF0ZWRNb2R1bGUgPSB7XG4gIEdyYW1tYXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gQXJjaGl0ZWN0dXJlR3JhbW1hcigpLCBcIkdyYW1tYXJcIiksXG4gIExhbmd1YWdlTWV0YURhdGE6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gQXJjaGl0ZWN0dXJlTGFuZ3VhZ2VNZXRhRGF0YSwgXCJMYW5ndWFnZU1ldGFEYXRhXCIpLFxuICBwYXJzZXI6IHt9XG59O1xudmFyIEdpdEdyYXBoR2VuZXJhdGVkTW9kdWxlID0ge1xuICBHcmFtbWFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IEdpdEdyYXBoR3JhbW1hcigpLCBcIkdyYW1tYXJcIiksXG4gIExhbmd1YWdlTWV0YURhdGE6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gR2l0R3JhcGhMYW5ndWFnZU1ldGFEYXRhLCBcIkxhbmd1YWdlTWV0YURhdGFcIiksXG4gIHBhcnNlcjoge31cbn07XG52YXIgUmFkYXJHZW5lcmF0ZWRNb2R1bGUgPSB7XG4gIEdyYW1tYXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gUmFkYXJHcmFtbWFyKCksIFwiR3JhbW1hclwiKSxcbiAgTGFuZ3VhZ2VNZXRhRGF0YTogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBSYWRhckxhbmd1YWdlTWV0YURhdGEsIFwiTGFuZ3VhZ2VNZXRhRGF0YVwiKSxcbiAgcGFyc2VyOiB7fVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2NvbW1vbi92YWx1ZUNvbnZlcnRlci50c1xuaW1wb3J0IHsgRGVmYXVsdFZhbHVlQ29udmVydGVyIH0gZnJvbSBcImxhbmdpdW1cIjtcblxuLy8gc3JjL2xhbmd1YWdlL2NvbW1vbi9tYXRjaGVyLnRzXG52YXIgYWNjZXNzaWJpbGl0eURlc2NyUmVnZXggPSAvYWNjRGVzY3IoPzpbXFx0IF0qOihbXlxcblxccl0qKXxcXHMqeyhbXn1dKil9KS87XG52YXIgYWNjZXNzaWJpbGl0eVRpdGxlUmVnZXggPSAvYWNjVGl0bGVbXFx0IF0qOihbXlxcblxccl0qKS87XG52YXIgdGl0bGVSZWdleCA9IC90aXRsZShbXFx0IF1bXlxcblxccl0qfCkvO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvY29tbW9uL3ZhbHVlQ29udmVydGVyLnRzXG52YXIgcnVsZXNSZWdleGVzID0ge1xuICBBQ0NfREVTQ1I6IGFjY2Vzc2liaWxpdHlEZXNjclJlZ2V4LFxuICBBQ0NfVElUTEU6IGFjY2Vzc2liaWxpdHlUaXRsZVJlZ2V4LFxuICBUSVRMRTogdGl0bGVSZWdleFxufTtcbnZhciBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlciA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdFZhbHVlQ29udmVydGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlclwiKTtcbiAgfVxuICBydW5Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIGNzdE5vZGUpIHtcbiAgICBsZXQgdmFsdWUgPSB0aGlzLnJ1bkNvbW1vbkNvbnZlcnRlcihydWxlLCBpbnB1dCwgY3N0Tm9kZSk7XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gdGhpcy5ydW5DdXN0b21Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIGNzdE5vZGUpO1xuICAgIH1cbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHN1cGVyLnJ1bkNvbnZlcnRlcihydWxlLCBpbnB1dCwgY3N0Tm9kZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBydW5Db21tb25Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIF9jc3ROb2RlKSB7XG4gICAgY29uc3QgcmVnZXggPSBydWxlc1JlZ2V4ZXNbcnVsZS5uYW1lXTtcbiAgICBpZiAocmVnZXggPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSByZWdleC5leGVjKGlucHV0KTtcbiAgICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICAgIHJldHVybiB2b2lkIDA7XG4gICAgfVxuICAgIGlmIChtYXRjaFsxXSAhPT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbWF0Y2hbMV0udHJpbSgpLnJlcGxhY2UoL1tcXHQgXXsyLH0vZ20sIFwiIFwiKTtcbiAgICB9XG4gICAgaWYgKG1hdGNoWzJdICE9PSB2b2lkIDApIHtcbiAgICAgIHJldHVybiBtYXRjaFsyXS5yZXBsYWNlKC9eXFxzKi9nbSwgXCJcIikucmVwbGFjZSgvXFxzKyQvZ20sIFwiXCIpLnJlcGxhY2UoL1tcXHQgXXsyLH0vZ20sIFwiIFwiKS5yZXBsYWNlKC9bXFxuXFxyXXsyLH0vZ20sIFwiXFxuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59O1xudmFyIENvbW1vblZhbHVlQ29udmVydGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQ29tbW9uVmFsdWVDb252ZXJ0ZXJcIik7XG4gIH1cbiAgcnVuQ3VzdG9tQ29udmVydGVyKF9ydWxlLCBfaW5wdXQsIF9jc3ROb2RlKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2NvbW1vbi90b2tlbkJ1aWxkZXIudHNcbmltcG9ydCB7IERlZmF1bHRUb2tlbkJ1aWxkZXIgfSBmcm9tIFwibGFuZ2l1bVwiO1xudmFyIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgRGVmYXVsdFRva2VuQnVpbGRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyXCIpO1xuICB9XG4gIGNvbnN0cnVjdG9yKGtleXdvcmRzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmtleXdvcmRzID0gbmV3IFNldChrZXl3b3Jkcyk7XG4gIH1cbiAgYnVpbGRLZXl3b3JkVG9rZW5zKHJ1bGVzLCB0ZXJtaW5hbFRva2Vucywgb3B0aW9ucykge1xuICAgIGNvbnN0IHRva2VuVHlwZXMgPSBzdXBlci5idWlsZEtleXdvcmRUb2tlbnMocnVsZXMsIHRlcm1pbmFsVG9rZW5zLCBvcHRpb25zKTtcbiAgICB0b2tlblR5cGVzLmZvckVhY2goKHRva2VuVHlwZSkgPT4ge1xuICAgICAgaWYgKHRoaXMua2V5d29yZHMuaGFzKHRva2VuVHlwZS5uYW1lKSAmJiB0b2tlblR5cGUuUEFUVEVSTiAhPT0gdm9pZCAwKSB7XG4gICAgICAgIHRva2VuVHlwZS5QQVRURVJOID0gbmV3IFJlZ0V4cCh0b2tlblR5cGUuUEFUVEVSTi50b1N0cmluZygpICsgXCIoPzooPz0lJSl8KD8hXFxcXFMpKVwiKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdG9rZW5UeXBlcztcbiAgfVxufTtcbnZhciBDb21tb25Ub2tlbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiQ29tbW9uVG9rZW5CdWlsZGVyXCIpO1xuICB9XG59O1xuXG5leHBvcnQge1xuICBfX25hbWUsXG4gIFN0YXRlbWVudCxcbiAgQXJjaGl0ZWN0dXJlLFxuICBpc0FyY2hpdGVjdHVyZSxcbiAgQnJhbmNoLFxuICBpc0JyYW5jaCxcbiAgQ29tbWl0LFxuICBpc0NvbW1pdCxcbiAgaXNDb21tb24sXG4gIEdpdEdyYXBoLFxuICBpc0dpdEdyYXBoLFxuICBJbmZvLFxuICBpc0luZm8sXG4gIE1lcmdlLFxuICBpc01lcmdlLFxuICBQYWNrZXQsXG4gIGlzUGFja2V0LFxuICBQYWNrZXRCbG9jayxcbiAgaXNQYWNrZXRCbG9jayxcbiAgUGllLFxuICBpc1BpZSxcbiAgUGllU2VjdGlvbixcbiAgaXNQaWVTZWN0aW9uLFxuICBSYWRhcixcbiAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZSxcbiAgSW5mb0dlbmVyYXRlZE1vZHVsZSxcbiAgUGFja2V0R2VuZXJhdGVkTW9kdWxlLFxuICBQaWVHZW5lcmF0ZWRNb2R1bGUsXG4gIEFyY2hpdGVjdHVyZUdlbmVyYXRlZE1vZHVsZSxcbiAgR2l0R3JhcGhHZW5lcmF0ZWRNb2R1bGUsXG4gIFJhZGFyR2VuZXJhdGVkTW9kdWxlLFxuICBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlcixcbiAgQ29tbW9uVmFsdWVDb252ZXJ0ZXIsXG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQ29tbW9uVG9rZW5CdWlsZGVyXG59O1xuIiwiaW1wb3J0IHtcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlcixcbiAgQXJjaGl0ZWN0dXJlR2VuZXJhdGVkTW9kdWxlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBfX25hbWVcbn0gZnJvbSBcIi4vY2h1bmstN1BLSTZFMkUubWpzXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9hcmNoaXRlY3R1cmUvbW9kdWxlLnRzXG5pbXBvcnQge1xuICBFbXB0eUZpbGVTeXN0ZW0sXG4gIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlLFxuICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZSxcbiAgaW5qZWN0XG59IGZyb20gXCJsYW5naXVtXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9hcmNoaXRlY3R1cmUvdG9rZW5CdWlsZGVyLnRzXG52YXIgQXJjaGl0ZWN0dXJlVG9rZW5CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIkFyY2hpdGVjdHVyZVRva2VuQnVpbGRlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbXCJhcmNoaXRlY3R1cmVcIl0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGFuZ3VhZ2UvYXJjaGl0ZWN0dXJlL3ZhbHVlQ29udmVydGVyLnRzXG52YXIgQXJjaGl0ZWN0dXJlVmFsdWVDb252ZXJ0ZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWVybWFpZFZhbHVlQ29udmVydGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJBcmNoaXRlY3R1cmVWYWx1ZUNvbnZlcnRlclwiKTtcbiAgfVxuICBydW5DdXN0b21Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIF9jc3ROb2RlKSB7XG4gICAgaWYgKHJ1bGUubmFtZSA9PT0gXCJBUkNIX0lDT05cIikge1xuICAgICAgcmV0dXJuIGlucHV0LnJlcGxhY2UoL1soKV0vZywgXCJcIikudHJpbSgpO1xuICAgIH0gZWxzZSBpZiAocnVsZS5uYW1lID09PSBcIkFSQ0hfVEVYVF9JQ09OXCIpIHtcbiAgICAgIHJldHVybiBpbnB1dC5yZXBsYWNlKC9bXCIoKV0vZywgXCJcIik7XG4gICAgfSBlbHNlIGlmIChydWxlLm5hbWUgPT09IFwiQVJDSF9USVRMRVwiKSB7XG4gICAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvW1tcXF1dL2csIFwiXCIpLnRyaW0oKTtcbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxufTtcblxuLy8gc3JjL2xhbmd1YWdlL2FyY2hpdGVjdHVyZS9tb2R1bGUudHNcbnZhciBBcmNoaXRlY3R1cmVNb2R1bGUgPSB7XG4gIHBhcnNlcjoge1xuICAgIFRva2VuQnVpbGRlcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBuZXcgQXJjaGl0ZWN0dXJlVG9rZW5CdWlsZGVyKCksIFwiVG9rZW5CdWlsZGVyXCIpLFxuICAgIFZhbHVlQ29udmVydGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBBcmNoaXRlY3R1cmVWYWx1ZUNvbnZlcnRlcigpLCBcIlZhbHVlQ29udmVydGVyXCIpXG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlcyhjb250ZXh0ID0gRW1wdHlGaWxlU3lzdGVtKSB7XG4gIGNvbnN0IHNoYXJlZCA9IGluamVjdChcbiAgICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShjb250ZXh0KSxcbiAgICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlXG4gICk7XG4gIGNvbnN0IEFyY2hpdGVjdHVyZSA9IGluamVjdChcbiAgICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSh7IHNoYXJlZCB9KSxcbiAgICBBcmNoaXRlY3R1cmVHZW5lcmF0ZWRNb2R1bGUsXG4gICAgQXJjaGl0ZWN0dXJlTW9kdWxlXG4gICk7XG4gIHNoYXJlZC5TZXJ2aWNlUmVnaXN0cnkucmVnaXN0ZXIoQXJjaGl0ZWN0dXJlKTtcbiAgcmV0dXJuIHsgc2hhcmVkLCBBcmNoaXRlY3R1cmUgfTtcbn1cbl9fbmFtZShjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlcywgXCJjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlc1wiKTtcblxuZXhwb3J0IHtcbiAgQXJjaGl0ZWN0dXJlTW9kdWxlLFxuICBjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlc1xufTtcbiIsImltcG9ydCB7XG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQ29tbW9uVmFsdWVDb252ZXJ0ZXIsXG4gIEluZm9HZW5lcmF0ZWRNb2R1bGUsXG4gIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGUsXG4gIF9fbmFtZVxufSBmcm9tIFwiLi9jaHVuay03UEtJNkUyRS5tanNcIjtcblxuLy8gc3JjL2xhbmd1YWdlL2luZm8vbW9kdWxlLnRzXG5pbXBvcnQge1xuICBFbXB0eUZpbGVTeXN0ZW0sXG4gIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlLFxuICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZSxcbiAgaW5qZWN0XG59IGZyb20gXCJsYW5naXVtXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9pbmZvL3Rva2VuQnVpbGRlci50c1xudmFyIEluZm9Ub2tlbkJ1aWxkZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlciB7XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiSW5mb1Rva2VuQnVpbGRlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbXCJpbmZvXCIsIFwic2hvd0luZm9cIl0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGFuZ3VhZ2UvaW5mby9tb2R1bGUudHNcbnZhciBJbmZvTW9kdWxlID0ge1xuICBwYXJzZXI6IHtcbiAgICBUb2tlbkJ1aWxkZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IEluZm9Ub2tlbkJ1aWxkZXIoKSwgXCJUb2tlbkJ1aWxkZXJcIiksXG4gICAgVmFsdWVDb252ZXJ0ZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IENvbW1vblZhbHVlQ29udmVydGVyKCksIFwiVmFsdWVDb252ZXJ0ZXJcIilcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZUluZm9TZXJ2aWNlcyhjb250ZXh0ID0gRW1wdHlGaWxlU3lzdGVtKSB7XG4gIGNvbnN0IHNoYXJlZCA9IGluamVjdChcbiAgICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShjb250ZXh0KSxcbiAgICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlXG4gICk7XG4gIGNvbnN0IEluZm8gPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoeyBzaGFyZWQgfSksXG4gICAgSW5mb0dlbmVyYXRlZE1vZHVsZSxcbiAgICBJbmZvTW9kdWxlXG4gICk7XG4gIHNoYXJlZC5TZXJ2aWNlUmVnaXN0cnkucmVnaXN0ZXIoSW5mbyk7XG4gIHJldHVybiB7IHNoYXJlZCwgSW5mbyB9O1xufVxuX19uYW1lKGNyZWF0ZUluZm9TZXJ2aWNlcywgXCJjcmVhdGVJbmZvU2VydmljZXNcIik7XG5cbmV4cG9ydCB7XG4gIEluZm9Nb2R1bGUsXG4gIGNyZWF0ZUluZm9TZXJ2aWNlc1xufTtcbiIsImltcG9ydCB7XG4gIEFic3RyYWN0TWVybWFpZFRva2VuQnVpbGRlcixcbiAgQWJzdHJhY3RNZXJtYWlkVmFsdWVDb252ZXJ0ZXIsXG4gIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGUsXG4gIFBpZUdlbmVyYXRlZE1vZHVsZSxcbiAgX19uYW1lXG59IGZyb20gXCIuL2NodW5rLTdQS0k2RTJFLm1qc1wiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGllL21vZHVsZS50c1xuaW1wb3J0IHtcbiAgRW1wdHlGaWxlU3lzdGVtLFxuICBjcmVhdGVEZWZhdWx0Q29yZU1vZHVsZSxcbiAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUsXG4gIGluamVjdFxufSBmcm9tIFwibGFuZ2l1bVwiO1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGllL3Rva2VuQnVpbGRlci50c1xudmFyIFBpZVRva2VuQnVpbGRlciA9IGNsYXNzIGV4dGVuZHMgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJQaWVUb2tlbkJ1aWxkZXJcIik7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoW1wicGllXCIsIFwic2hvd0RhdGFcIl0pO1xuICB9XG59O1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGllL3ZhbHVlQ29udmVydGVyLnRzXG52YXIgUGllVmFsdWVDb252ZXJ0ZXIgPSBjbGFzcyBleHRlbmRzIEFic3RyYWN0TWVybWFpZFZhbHVlQ29udmVydGVyIHtcbiAgc3RhdGljIHtcbiAgICBfX25hbWUodGhpcywgXCJQaWVWYWx1ZUNvbnZlcnRlclwiKTtcbiAgfVxuICBydW5DdXN0b21Db252ZXJ0ZXIocnVsZSwgaW5wdXQsIF9jc3ROb2RlKSB7XG4gICAgaWYgKHJ1bGUubmFtZSAhPT0gXCJQSUVfU0VDVElPTl9MQUJFTFwiKSB7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQucmVwbGFjZSgvXCIvZywgXCJcIikudHJpbSgpO1xuICB9XG59O1xuXG4vLyBzcmMvbGFuZ3VhZ2UvcGllL21vZHVsZS50c1xudmFyIFBpZU1vZHVsZSA9IHtcbiAgcGFyc2VyOiB7XG4gICAgVG9rZW5CdWlsZGVyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKCgpID0+IG5ldyBQaWVUb2tlbkJ1aWxkZXIoKSwgXCJUb2tlbkJ1aWxkZXJcIiksXG4gICAgVmFsdWVDb252ZXJ0ZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IFBpZVZhbHVlQ29udmVydGVyKCksIFwiVmFsdWVDb252ZXJ0ZXJcIilcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVBpZVNlcnZpY2VzKGNvbnRleHQgPSBFbXB0eUZpbGVTeXN0ZW0pIHtcbiAgY29uc3Qgc2hhcmVkID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlKGNvbnRleHQpLFxuICAgIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGVcbiAgKTtcbiAgY29uc3QgUGllID0gaW5qZWN0KFxuICAgIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlKHsgc2hhcmVkIH0pLFxuICAgIFBpZUdlbmVyYXRlZE1vZHVsZSxcbiAgICBQaWVNb2R1bGVcbiAgKTtcbiAgc2hhcmVkLlNlcnZpY2VSZWdpc3RyeS5yZWdpc3RlcihQaWUpO1xuICByZXR1cm4geyBzaGFyZWQsIFBpZSB9O1xufVxuX19uYW1lKGNyZWF0ZVBpZVNlcnZpY2VzLCBcImNyZWF0ZVBpZVNlcnZpY2VzXCIpO1xuXG5leHBvcnQge1xuICBQaWVNb2R1bGUsXG4gIGNyZWF0ZVBpZVNlcnZpY2VzXG59O1xuIiwiaW1wb3J0IHtcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBDb21tb25WYWx1ZUNvbnZlcnRlcixcbiAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZSxcbiAgUGFja2V0R2VuZXJhdGVkTW9kdWxlLFxuICBfX25hbWVcbn0gZnJvbSBcIi4vY2h1bmstN1BLSTZFMkUubWpzXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9wYWNrZXQvbW9kdWxlLnRzXG5pbXBvcnQge1xuICBFbXB0eUZpbGVTeXN0ZW0sXG4gIGNyZWF0ZURlZmF1bHRDb3JlTW9kdWxlLFxuICBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZSxcbiAgaW5qZWN0XG59IGZyb20gXCJsYW5naXVtXCI7XG5cbi8vIHNyYy9sYW5ndWFnZS9wYWNrZXQvdG9rZW5CdWlsZGVyLnRzXG52YXIgUGFja2V0VG9rZW5CdWlsZGVyID0gY2xhc3MgZXh0ZW5kcyBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIge1xuICBzdGF0aWMge1xuICAgIF9fbmFtZSh0aGlzLCBcIlBhY2tldFRva2VuQnVpbGRlclwiKTtcbiAgfVxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcihbXCJwYWNrZXQtYmV0YVwiXSk7XG4gIH1cbn07XG5cbi8vIHNyYy9sYW5ndWFnZS9wYWNrZXQvbW9kdWxlLnRzXG52YXIgUGFja2V0TW9kdWxlID0ge1xuICBwYXJzZXI6IHtcbiAgICBUb2tlbkJ1aWxkZXI6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoKCkgPT4gbmV3IFBhY2tldFRva2VuQnVpbGRlcigpLCBcIlRva2VuQnVpbGRlclwiKSxcbiAgICBWYWx1ZUNvbnZlcnRlcjogLyogQF9fUFVSRV9fICovIF9fbmFtZSgoKSA9PiBuZXcgQ29tbW9uVmFsdWVDb252ZXJ0ZXIoKSwgXCJWYWx1ZUNvbnZlcnRlclwiKVxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlUGFja2V0U2VydmljZXMoY29udGV4dCA9IEVtcHR5RmlsZVN5c3RlbSkge1xuICBjb25zdCBzaGFyZWQgPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUoY29udGV4dCksXG4gICAgTWVybWFpZEdlbmVyYXRlZFNoYXJlZE1vZHVsZVxuICApO1xuICBjb25zdCBQYWNrZXQgPSBpbmplY3QoXG4gICAgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoeyBzaGFyZWQgfSksXG4gICAgUGFja2V0R2VuZXJhdGVkTW9kdWxlLFxuICAgIFBhY2tldE1vZHVsZVxuICApO1xuICBzaGFyZWQuU2VydmljZVJlZ2lzdHJ5LnJlZ2lzdGVyKFBhY2tldCk7XG4gIHJldHVybiB7IHNoYXJlZCwgUGFja2V0IH07XG59XG5fX25hbWUoY3JlYXRlUGFja2V0U2VydmljZXMsIFwiY3JlYXRlUGFja2V0U2VydmljZXNcIik7XG5cbmV4cG9ydCB7XG4gIFBhY2tldE1vZHVsZSxcbiAgY3JlYXRlUGFja2V0U2VydmljZXNcbn07XG4iLCJpbXBvcnQge1xuICBHaXRHcmFwaE1vZHVsZSxcbiAgY3JlYXRlR2l0R3JhcGhTZXJ2aWNlc1xufSBmcm9tIFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay0yTllGVElMMi5tanNcIjtcbmltcG9ydCB7XG4gIEluZm9Nb2R1bGUsXG4gIGNyZWF0ZUluZm9TZXJ2aWNlc1xufSBmcm9tIFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay1FWFpaTkU2Ri5tanNcIjtcbmltcG9ydCB7XG4gIFBhY2tldE1vZHVsZSxcbiAgY3JlYXRlUGFja2V0U2VydmljZXNcbn0gZnJvbSBcIi4vY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvY2h1bmstVjRRMzJHNlMubWpzXCI7XG5pbXBvcnQge1xuICBQaWVNb2R1bGUsXG4gIGNyZWF0ZVBpZVNlcnZpY2VzXG59IGZyb20gXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLVJPWEc3UzRFLm1qc1wiO1xuaW1wb3J0IHtcbiAgQXJjaGl0ZWN0dXJlTW9kdWxlLFxuICBjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlc1xufSBmcm9tIFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay1DNE9FSVM3Ti5tanNcIjtcbmltcG9ydCB7XG4gIFJhZGFyTW9kdWxlLFxuICBjcmVhdGVSYWRhclNlcnZpY2VzXG59IGZyb20gXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2NodW5rLTJPNVpLN1JSLm1qc1wiO1xuaW1wb3J0IHtcbiAgQWJzdHJhY3RNZXJtYWlkVG9rZW5CdWlsZGVyLFxuICBBYnN0cmFjdE1lcm1haWRWYWx1ZUNvbnZlcnRlcixcbiAgQXJjaGl0ZWN0dXJlLFxuICBBcmNoaXRlY3R1cmVHZW5lcmF0ZWRNb2R1bGUsXG4gIEJyYW5jaCxcbiAgQ29tbWl0LFxuICBDb21tb25Ub2tlbkJ1aWxkZXIsXG4gIENvbW1vblZhbHVlQ29udmVydGVyLFxuICBHaXRHcmFwaCxcbiAgR2l0R3JhcGhHZW5lcmF0ZWRNb2R1bGUsXG4gIEluZm8sXG4gIEluZm9HZW5lcmF0ZWRNb2R1bGUsXG4gIE1lcmdlLFxuICBNZXJtYWlkR2VuZXJhdGVkU2hhcmVkTW9kdWxlLFxuICBQYWNrZXQsXG4gIFBhY2tldEJsb2NrLFxuICBQYWNrZXRHZW5lcmF0ZWRNb2R1bGUsXG4gIFBpZSxcbiAgUGllR2VuZXJhdGVkTW9kdWxlLFxuICBQaWVTZWN0aW9uLFxuICBSYWRhcixcbiAgUmFkYXJHZW5lcmF0ZWRNb2R1bGUsXG4gIFN0YXRlbWVudCxcbiAgX19uYW1lLFxuICBpc0FyY2hpdGVjdHVyZSxcbiAgaXNCcmFuY2gsXG4gIGlzQ29tbWl0LFxuICBpc0NvbW1vbixcbiAgaXNHaXRHcmFwaCxcbiAgaXNJbmZvLFxuICBpc01lcmdlLFxuICBpc1BhY2tldCxcbiAgaXNQYWNrZXRCbG9jayxcbiAgaXNQaWUsXG4gIGlzUGllU2VjdGlvblxufSBmcm9tIFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9jaHVuay03UEtJNkUyRS5tanNcIjtcblxuLy8gc3JjL3BhcnNlLnRzXG52YXIgcGFyc2VycyA9IHt9O1xudmFyIGluaXRpYWxpemVycyA9IHtcbiAgaW5mbzogLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjcmVhdGVJbmZvU2VydmljZXM6IGNyZWF0ZUluZm9TZXJ2aWNlczIgfSA9IGF3YWl0IGltcG9ydChcIi4vY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvaW5mby00TjQ3UVRPWi5tanNcIik7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlSW5mb1NlcnZpY2VzMigpLkluZm8ucGFyc2VyLkxhbmdpdW1QYXJzZXI7XG4gICAgcGFyc2Vycy5pbmZvID0gcGFyc2VyO1xuICB9LCBcImluZm9cIiksXG4gIHBhY2tldDogLyogQF9fUFVSRV9fICovIF9fbmFtZShhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgeyBjcmVhdGVQYWNrZXRTZXJ2aWNlczogY3JlYXRlUGFja2V0U2VydmljZXMyIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL3BhY2tldC1LVllPTjM2Ny5tanNcIik7XG4gICAgY29uc3QgcGFyc2VyID0gY3JlYXRlUGFja2V0U2VydmljZXMyKCkuUGFja2V0LnBhcnNlci5MYW5naXVtUGFyc2VyO1xuICAgIHBhcnNlcnMucGFja2V0ID0gcGFyc2VyO1xuICB9LCBcInBhY2tldFwiKSxcbiAgcGllOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZVBpZVNlcnZpY2VzOiBjcmVhdGVQaWVTZXJ2aWNlczIgfSA9IGF3YWl0IGltcG9ydChcIi4vY2h1bmtzL21lcm1haWQtcGFyc2VyLmNvcmUvcGllLVI2Uk5SUllGLm1qc1wiKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVQaWVTZXJ2aWNlczIoKS5QaWUucGFyc2VyLkxhbmdpdW1QYXJzZXI7XG4gICAgcGFyc2Vycy5waWUgPSBwYXJzZXI7XG4gIH0sIFwicGllXCIpLFxuICBhcmNoaXRlY3R1cmU6IC8qIEBfX1BVUkVfXyAqLyBfX25hbWUoYXN5bmMgKCkgPT4ge1xuICAgIGNvbnN0IHsgY3JlYXRlQXJjaGl0ZWN0dXJlU2VydmljZXM6IGNyZWF0ZUFyY2hpdGVjdHVyZVNlcnZpY2VzMiB9ID0gYXdhaXQgaW1wb3J0KFwiLi9jaHVua3MvbWVybWFpZC1wYXJzZXIuY29yZS9hcmNoaXRlY3R1cmUtNEFCMkUzUFAubWpzXCIpO1xuICAgIGNvbnN0IHBhcnNlciA9IGNyZWF0ZUFyY2hpdGVjdHVyZVNlcnZpY2VzMigpLkFyY2hpdGVjdHVyZS5wYXJzZXIuTGFuZ2l1bVBhcnNlcjtcbiAgICBwYXJzZXJzLmFyY2hpdGVjdHVyZSA9IHBhcnNlcjtcbiAgfSwgXCJhcmNoaXRlY3R1cmVcIiksXG4gIGdpdEdyYXBoOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZUdpdEdyYXBoU2VydmljZXM6IGNyZWF0ZUdpdEdyYXBoU2VydmljZXMyIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL2dpdEdyYXBoLU8yUTJDWExYLm1qc1wiKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVHaXRHcmFwaFNlcnZpY2VzMigpLkdpdEdyYXBoLnBhcnNlci5MYW5naXVtUGFyc2VyO1xuICAgIHBhcnNlcnMuZ2l0R3JhcGggPSBwYXJzZXI7XG4gIH0sIFwiZ2l0R3JhcGhcIiksXG4gIHJhZGFyOiAvKiBAX19QVVJFX18gKi8gX19uYW1lKGFzeW5jICgpID0+IHtcbiAgICBjb25zdCB7IGNyZWF0ZVJhZGFyU2VydmljZXM6IGNyZWF0ZVJhZGFyU2VydmljZXMyIH0gPSBhd2FpdCBpbXBvcnQoXCIuL2NodW5rcy9tZXJtYWlkLXBhcnNlci5jb3JlL3JhZGFyLU1LM0lDS1dLLm1qc1wiKTtcbiAgICBjb25zdCBwYXJzZXIgPSBjcmVhdGVSYWRhclNlcnZpY2VzMigpLlJhZGFyLnBhcnNlci5MYW5naXVtUGFyc2VyO1xuICAgIHBhcnNlcnMucmFkYXIgPSBwYXJzZXI7XG4gIH0sIFwicmFkYXJcIilcbn07XG5hc3luYyBmdW5jdGlvbiBwYXJzZShkaWFncmFtVHlwZSwgdGV4dCkge1xuICBjb25zdCBpbml0aWFsaXplciA9IGluaXRpYWxpemVyc1tkaWFncmFtVHlwZV07XG4gIGlmICghaW5pdGlhbGl6ZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZGlhZ3JhbSB0eXBlOiAke2RpYWdyYW1UeXBlfWApO1xuICB9XG4gIGlmICghcGFyc2Vyc1tkaWFncmFtVHlwZV0pIHtcbiAgICBhd2FpdCBpbml0aWFsaXplcigpO1xuICB9XG4gIGNvbnN0IHBhcnNlciA9IHBhcnNlcnNbZGlhZ3JhbVR5cGVdO1xuICBjb25zdCByZXN1bHQgPSBwYXJzZXIucGFyc2UodGV4dCk7XG4gIGlmIChyZXN1bHQubGV4ZXJFcnJvcnMubGVuZ3RoID4gMCB8fCByZXN1bHQucGFyc2VyRXJyb3JzLmxlbmd0aCA+IDApIHtcbiAgICB0aHJvdyBuZXcgTWVybWFpZFBhcnNlRXJyb3IocmVzdWx0KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuX19uYW1lKHBhcnNlLCBcInBhcnNlXCIpO1xudmFyIE1lcm1haWRQYXJzZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlc3VsdCkge1xuICAgIGNvbnN0IGxleGVyRXJyb3JzID0gcmVzdWx0LmxleGVyRXJyb3JzLm1hcCgoZXJyKSA9PiBlcnIubWVzc2FnZSkuam9pbihcIlxcblwiKTtcbiAgICBjb25zdCBwYXJzZXJFcnJvcnMgPSByZXN1bHQucGFyc2VyRXJyb3JzLm1hcCgoZXJyKSA9PiBlcnIubWVzc2FnZSkuam9pbihcIlxcblwiKTtcbiAgICBzdXBlcihgUGFyc2luZyBmYWlsZWQ6ICR7bGV4ZXJFcnJvcnN9ICR7cGFyc2VyRXJyb3JzfWApO1xuICAgIHRoaXMucmVzdWx0ID0gcmVzdWx0O1xuICB9XG4gIHN0YXRpYyB7XG4gICAgX19uYW1lKHRoaXMsIFwiTWVybWFpZFBhcnNlRXJyb3JcIik7XG4gIH1cbn07XG5leHBvcnQge1xuICBBYnN0cmFjdE1lcm1haWRUb2tlbkJ1aWxkZXIsXG4gIEFic3RyYWN0TWVybWFpZFZhbHVlQ29udmVydGVyLFxuICBBcmNoaXRlY3R1cmUsXG4gIEFyY2hpdGVjdHVyZUdlbmVyYXRlZE1vZHVsZSxcbiAgQXJjaGl0ZWN0dXJlTW9kdWxlLFxuICBCcmFuY2gsXG4gIENvbW1pdCxcbiAgQ29tbW9uVG9rZW5CdWlsZGVyLFxuICBDb21tb25WYWx1ZUNvbnZlcnRlcixcbiAgR2l0R3JhcGgsXG4gIEdpdEdyYXBoR2VuZXJhdGVkTW9kdWxlLFxuICBHaXRHcmFwaE1vZHVsZSxcbiAgSW5mbyxcbiAgSW5mb0dlbmVyYXRlZE1vZHVsZSxcbiAgSW5mb01vZHVsZSxcbiAgTWVyZ2UsXG4gIE1lcm1haWRHZW5lcmF0ZWRTaGFyZWRNb2R1bGUsXG4gIE1lcm1haWRQYXJzZUVycm9yLFxuICBQYWNrZXQsXG4gIFBhY2tldEJsb2NrLFxuICBQYWNrZXRHZW5lcmF0ZWRNb2R1bGUsXG4gIFBhY2tldE1vZHVsZSxcbiAgUGllLFxuICBQaWVHZW5lcmF0ZWRNb2R1bGUsXG4gIFBpZU1vZHVsZSxcbiAgUGllU2VjdGlvbixcbiAgUmFkYXIsXG4gIFJhZGFyR2VuZXJhdGVkTW9kdWxlLFxuICBSYWRhck1vZHVsZSxcbiAgU3RhdGVtZW50LFxuICBjcmVhdGVBcmNoaXRlY3R1cmVTZXJ2aWNlcyxcbiAgY3JlYXRlR2l0R3JhcGhTZXJ2aWNlcyxcbiAgY3JlYXRlSW5mb1NlcnZpY2VzLFxuICBjcmVhdGVQYWNrZXRTZXJ2aWNlcyxcbiAgY3JlYXRlUGllU2VydmljZXMsXG4gIGNyZWF0ZVJhZGFyU2VydmljZXMsXG4gIGlzQXJjaGl0ZWN0dXJlLFxuICBpc0JyYW5jaCxcbiAgaXNDb21taXQsXG4gIGlzQ29tbW9uLFxuICBpc0dpdEdyYXBoLFxuICBpc0luZm8sXG4gIGlzTWVyZ2UsXG4gIGlzUGFja2V0LFxuICBpc1BhY2tldEJsb2NrLFxuICBpc1BpZSxcbiAgaXNQaWVTZWN0aW9uLFxuICBwYXJzZVxufTtcbiIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IHRva2VuTWF0Y2hlciwgdG9rZW5MYWJlbCwgTm9uVGVybWluYWwsIEFsdGVybmF0aW9uLCBPcHRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbiwgVGVybWluYWwsIExMa0xvb2thaGVhZFN0cmF0ZWd5LCBnZXRMb29rYWhlYWRQYXRocyB9IGZyb20gXCJjaGV2cm90YWluXCI7XG5pbXBvcnQgeyBBVE5fUlVMRV9TVE9QLCBBdG9tVHJhbnNpdGlvbiwgYnVpbGRBVE5LZXksIGNyZWF0ZUFUTiwgRXBzaWxvblRyYW5zaXRpb24sIFJ1bGVUcmFuc2l0aW9uIH0gZnJvbSBcIi4vYXRuLmpzXCI7XG5pbXBvcnQgeyBBVE5Db25maWdTZXQsIERGQV9FUlJPUiwgZ2V0QVROQ29uZmlnS2V5IH0gZnJvbSBcIi4vZGZhLmpzXCI7XG5pbXBvcnQgbWluIGZyb20gXCJsb2Rhc2gtZXMvbWluLmpzXCI7XG5pbXBvcnQgZmxhdE1hcCBmcm9tIFwibG9kYXNoLWVzL2ZsYXRNYXAuanNcIjtcbmltcG9ydCB1bmlxQnkgZnJvbSBcImxvZGFzaC1lcy91bmlxQnkuanNcIjtcbmltcG9ydCBtYXAgZnJvbSBcImxvZGFzaC1lcy9tYXAuanNcIjtcbmltcG9ydCBmbGF0dGVuIGZyb20gXCJsb2Rhc2gtZXMvZmxhdHRlbi5qc1wiO1xuaW1wb3J0IGZvckVhY2ggZnJvbSBcImxvZGFzaC1lcy9mb3JFYWNoLmpzXCI7XG5pbXBvcnQgaXNFbXB0eSBmcm9tIFwibG9kYXNoLWVzL2lzRW1wdHkuanNcIjtcbmltcG9ydCByZWR1Y2UgZnJvbSBcImxvZGFzaC1lcy9yZWR1Y2UuanNcIjtcbmZ1bmN0aW9uIGNyZWF0ZURGQUNhY2hlKHN0YXJ0U3RhdGUsIGRlY2lzaW9uKSB7XG4gICAgY29uc3QgbWFwID0ge307XG4gICAgcmV0dXJuIChwcmVkaWNhdGVTZXQpID0+IHtcbiAgICAgICAgY29uc3Qga2V5ID0gcHJlZGljYXRlU2V0LnRvU3RyaW5nKCk7XG4gICAgICAgIGxldCBleGlzdGluZyA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZXhpc3RpbmcgPSB7XG4gICAgICAgICAgICAgICAgYXRuU3RhcnRTdGF0ZTogc3RhcnRTdGF0ZSxcbiAgICAgICAgICAgICAgICBkZWNpc2lvbixcbiAgICAgICAgICAgICAgICBzdGF0ZXM6IHt9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbWFwW2tleV0gPSBleGlzdGluZztcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgIH07XG59XG5jbGFzcyBQcmVkaWNhdGVTZXQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZXMgPSBbXTtcbiAgICB9XG4gICAgaXMoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4ID49IHRoaXMucHJlZGljYXRlcy5sZW5ndGggfHwgdGhpcy5wcmVkaWNhdGVzW2luZGV4XTtcbiAgICB9XG4gICAgc2V0KGluZGV4LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnByZWRpY2F0ZXNbaW5kZXhdID0gdmFsdWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy5wcmVkaWNhdGVzLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIHZhbHVlICs9IHRoaXMucHJlZGljYXRlc1tpXSA9PT0gdHJ1ZSA/IFwiMVwiIDogXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbn1cbmNvbnN0IEVNUFRZX1BSRURJQ0FURVMgPSBuZXcgUHJlZGljYXRlU2V0KCk7XG5leHBvcnQgY2xhc3MgTExTdGFyTG9va2FoZWFkU3RyYXRlZ3kgZXh0ZW5kcyBMTGtMb29rYWhlYWRTdHJhdGVneSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubG9nZ2luZyA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5sb2dnaW5nKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAoKG1lc3NhZ2UpID0+IGNvbnNvbGUubG9nKG1lc3NhZ2UpKTtcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRuID0gY3JlYXRlQVROKG9wdGlvbnMucnVsZXMpO1xuICAgICAgICB0aGlzLmRmYXMgPSBpbml0QVROU2ltdWxhdG9yKHRoaXMuYXRuKTtcbiAgICB9XG4gICAgdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcygpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICB2YWxpZGF0ZUVtcHR5T3JBbHRlcm5hdGl2ZXMoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgYnVpbGRMb29rYWhlYWRGb3JBbHRlcm5hdGlvbihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHsgcHJvZE9jY3VycmVuY2UsIHJ1bGUsIGhhc1ByZWRpY2F0ZXMsIGR5bmFtaWNUb2tlbnNFbmFibGVkIH0gPSBvcHRpb25zO1xuICAgICAgICBjb25zdCBkZmFzID0gdGhpcy5kZmFzO1xuICAgICAgICBjb25zdCBsb2dnaW5nID0gdGhpcy5sb2dnaW5nO1xuICAgICAgICBjb25zdCBrZXkgPSBidWlsZEFUTktleShydWxlLCAnQWx0ZXJuYXRpb24nLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIGNvbnN0IGRlY2lzaW9uU3RhdGUgPSB0aGlzLmF0bi5kZWNpc2lvbk1hcFtrZXldO1xuICAgICAgICBjb25zdCBkZWNpc2lvbkluZGV4ID0gZGVjaXNpb25TdGF0ZS5kZWNpc2lvbjtcbiAgICAgICAgY29uc3QgcGFydGlhbEFsdHMgPSBtYXAoZ2V0TG9va2FoZWFkUGF0aHMoe1xuICAgICAgICAgICAgbWF4TG9va2FoZWFkOiAxLFxuICAgICAgICAgICAgb2NjdXJyZW5jZTogcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICBwcm9kVHlwZTogXCJBbHRlcm5hdGlvblwiLFxuICAgICAgICAgICAgcnVsZTogcnVsZVxuICAgICAgICB9KSwgKGN1cnJBbHQpID0+IG1hcChjdXJyQWx0LCAocGF0aCkgPT4gcGF0aFswXSkpO1xuICAgICAgICBpZiAoaXNMTDFTZXF1ZW5jZShwYXJ0aWFsQWx0cywgZmFsc2UpICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICAgICAgY29uc3QgY2hvaWNlVG9BbHQgPSByZWR1Y2UocGFydGlhbEFsdHMsIChyZXN1bHQsIGN1cnJBbHQsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvckVhY2goY3VyckFsdCwgKGN1cnJUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVG9rVHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJUb2tUeXBlLnRva2VuVHlwZUlkeF0gPSBpZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcywgKGN1cnJFeHRlbmRpbmdUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIHt9KTtcbiAgICAgICAgICAgIGlmIChoYXNQcmVkaWNhdGVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvckFsdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcmVkaWN0aW9uID0gY2hvaWNlVG9BbHRbbmV4dFRva2VuLnRva2VuVHlwZUlkeF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvckFsdHMgIT09IHVuZGVmaW5lZCAmJiBwcmVkaWN0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGdhdGUgPSAoX2EgPSBvckFsdHNbcHJlZGljdGlvbl0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5HQVRFO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGdhdGUgIT09IHVuZGVmaW5lZCAmJiBnYXRlLmNhbGwodGhpcykgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljdGlvbjtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNob2ljZVRvQWx0W25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzUHJlZGljYXRlcykge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChvckFsdHMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVkaWNhdGVzID0gbmV3IFByZWRpY2F0ZVNldCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IG9yQWx0cyA9PT0gdW5kZWZpbmVkID8gMCA6IG9yQWx0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBnYXRlID0gb3JBbHRzID09PSBudWxsIHx8IG9yQWx0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3JBbHRzW2ldLkdBVEU7XG4gICAgICAgICAgICAgICAgICAgIHByZWRpY2F0ZXMuc2V0KGksIGdhdGUgPT09IHVuZGVmaW5lZCB8fCBnYXRlLmNhbGwodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhZGFwdGl2ZVByZWRpY3QuY2FsbCh0aGlzLCBkZmFzLCBkZWNpc2lvbkluZGV4LCBwcmVkaWNhdGVzLCBsb2dnaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhZGFwdGl2ZVByZWRpY3QuY2FsbCh0aGlzLCBkZmFzLCBkZWNpc2lvbkluZGV4LCBFTVBUWV9QUkVESUNBVEVTLCBsb2dnaW5nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHJlc3VsdCA9PT0gJ251bWJlcicgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGJ1aWxkTG9va2FoZWFkRm9yT3B0aW9uYWwob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IHByb2RPY2N1cnJlbmNlLCBydWxlLCBwcm9kVHlwZSwgZHluYW1pY1Rva2Vuc0VuYWJsZWQgfSA9IG9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGRmYXMgPSB0aGlzLmRmYXM7XG4gICAgICAgIGNvbnN0IGxvZ2dpbmcgPSB0aGlzLmxvZ2dpbmc7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ1aWxkQVROS2V5KHJ1bGUsIHByb2RUeXBlLCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgIGNvbnN0IGRlY2lzaW9uU3RhdGUgPSB0aGlzLmF0bi5kZWNpc2lvbk1hcFtrZXldO1xuICAgICAgICBjb25zdCBkZWNpc2lvbkluZGV4ID0gZGVjaXNpb25TdGF0ZS5kZWNpc2lvbjtcbiAgICAgICAgY29uc3QgYWx0cyA9IG1hcChnZXRMb29rYWhlYWRQYXRocyh7XG4gICAgICAgICAgICBtYXhMb29rYWhlYWQ6IDEsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgIHByb2RUeXBlLFxuICAgICAgICAgICAgcnVsZVxuICAgICAgICB9KSwgKGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBtYXAoZSwgKGcpID0+IGdbMF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGlzTEwxU2VxdWVuY2UoYWx0cykgJiYgYWx0c1swXVswXSAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGFsdCA9IGFsdHNbMF07XG4gICAgICAgICAgICBjb25zdCBzaW5nbGVUb2tlbnNUeXBlcyA9IGZsYXR0ZW4oYWx0KTtcbiAgICAgICAgICAgIGlmIChzaW5nbGVUb2tlbnNUeXBlcy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICBpc0VtcHR5KHNpbmdsZVRva2Vuc1R5cGVzWzBdLmNhdGVnb3J5TWF0Y2hlcykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZFRva2VuVHlwZSA9IHNpbmdsZVRva2Vuc1R5cGVzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkVG9rZW5VbmlxdWVLZXkgPSBleHBlY3RlZFRva2VuVHlwZS50b2tlblR5cGVJZHg7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSkudG9rZW5UeXBlSWR4ID09PSBleHBlY3RlZFRva2VuVW5pcXVlS2V5O1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaG9pY2VUb0FsdCA9IHJlZHVjZShzaW5nbGVUb2tlbnNUeXBlcywgKHJlc3VsdCwgY3VyclRva1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJUb2tUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFtjdXJyVG9rVHlwZS50b2tlblR5cGVJZHhdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2goY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLCAoY3VyckV4dGVuZGluZ1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyckV4dGVuZGluZ1R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgfSwge30pO1xuICAgICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjaG9pY2VUb0FsdFtuZXh0VG9rZW4udG9rZW5UeXBlSWR4XSA9PT0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhZGFwdGl2ZVByZWRpY3QuY2FsbCh0aGlzLCBkZmFzLCBkZWNpc2lvbkluZGV4LCBFTVBUWV9QUkVESUNBVEVTLCBsb2dnaW5nKTtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcmVzdWx0ID09PSBcIm9iamVjdFwiID8gZmFsc2UgOiByZXN1bHQgPT09IDA7XG4gICAgICAgIH07XG4gICAgfVxufVxuZnVuY3Rpb24gaXNMTDFTZXF1ZW5jZShzZXF1ZW5jZXMsIGFsbG93RW1wdHkgPSB0cnVlKSB7XG4gICAgY29uc3QgZnVsbFNldCA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGFsdCBvZiBzZXF1ZW5jZXMpIHtcbiAgICAgICAgY29uc3QgYWx0U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IHRva1R5cGUgb2YgYWx0KSB7XG4gICAgICAgICAgICBpZiAodG9rVHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93RW1wdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXBzaWxvbiBwcm9kdWN0aW9uIGVuY291bnRlcmVkXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBbdG9rVHlwZS50b2tlblR5cGVJZHhdLmNvbmNhdCh0b2tUeXBlLmNhdGVnb3J5TWF0Y2hlcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIGluZGljZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZnVsbFNldC5oYXMoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWx0U2V0LmhhcyhpbmRleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFNldC5hZGQoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBhbHRTZXQuYWRkKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpbml0QVROU2ltdWxhdG9yKGF0bikge1xuICAgIGNvbnN0IGRlY2lzaW9uTGVuZ3RoID0gYXRuLmRlY2lzaW9uU3RhdGVzLmxlbmd0aDtcbiAgICBjb25zdCBkZWNpc2lvblRvREZBID0gQXJyYXkoZGVjaXNpb25MZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGVjaXNpb25MZW5ndGg7IGkrKykge1xuICAgICAgICBkZWNpc2lvblRvREZBW2ldID0gY3JlYXRlREZBQ2FjaGUoYXRuLmRlY2lzaW9uU3RhdGVzW2ldLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlY2lzaW9uVG9ERkE7XG59XG5mdW5jdGlvbiBhZGFwdGl2ZVByZWRpY3QoZGZhQ2FjaGVzLCBkZWNpc2lvbiwgcHJlZGljYXRlU2V0LCBsb2dnaW5nKSB7XG4gICAgY29uc3QgZGZhID0gZGZhQ2FjaGVzW2RlY2lzaW9uXShwcmVkaWNhdGVTZXQpO1xuICAgIGxldCBzdGFydCA9IGRmYS5zdGFydDtcbiAgICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBjbG9zdXJlID0gY29tcHV0ZVN0YXJ0U3RhdGUoZGZhLmF0blN0YXJ0U3RhdGUpO1xuICAgICAgICBzdGFydCA9IGFkZERGQVN0YXRlKGRmYSwgbmV3REZBU3RhdGUoY2xvc3VyZSkpO1xuICAgICAgICBkZmEuc3RhcnQgPSBzdGFydDtcbiAgICB9XG4gICAgY29uc3QgYWx0ID0gcGVyZm9ybUxvb2thaGVhZC5hcHBseSh0aGlzLCBbZGZhLCBzdGFydCwgcHJlZGljYXRlU2V0LCBsb2dnaW5nXSk7XG4gICAgcmV0dXJuIGFsdDtcbn1cbmZ1bmN0aW9uIHBlcmZvcm1Mb29rYWhlYWQoZGZhLCBzMCwgcHJlZGljYXRlU2V0LCBsb2dnaW5nKSB7XG4gICAgbGV0IHByZXZpb3VzRCA9IHMwO1xuICAgIGxldCBpID0gMTtcbiAgICBjb25zdCBwYXRoID0gW107XG4gICAgbGV0IHQgPSB0aGlzLkxBKGkrKyk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgbGV0IGQgPSBnZXRFeGlzdGluZ1RhcmdldFN0YXRlKHByZXZpb3VzRCwgdCk7XG4gICAgICAgIGlmIChkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGQgPSBjb21wdXRlTG9va2FoZWFkVGFyZ2V0LmFwcGx5KHRoaXMsIFtkZmEsIHByZXZpb3VzRCwgdCwgaSwgcHJlZGljYXRlU2V0LCBsb2dnaW5nXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGQgPT09IERGQV9FUlJPUikge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkQWRhcHRpdmVQcmVkaWN0RXJyb3IocGF0aCwgcHJldmlvdXNELCB0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZC5pc0FjY2VwdFN0YXRlID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gZC5wcmVkaWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzRCA9IGQ7XG4gICAgICAgIHBhdGgucHVzaCh0KTtcbiAgICAgICAgdCA9IHRoaXMuTEEoaSsrKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjb21wdXRlTG9va2FoZWFkVGFyZ2V0KGRmYSwgcHJldmlvdXNELCB0b2tlbiwgbG9va2FoZWFkLCBwcmVkaWNhdGVTZXQsIGxvZ2dpbmcpIHtcbiAgICBjb25zdCByZWFjaCA9IGNvbXB1dGVSZWFjaFNldChwcmV2aW91c0QuY29uZmlncywgdG9rZW4sIHByZWRpY2F0ZVNldCk7XG4gICAgaWYgKHJlYWNoLnNpemUgPT09IDApIHtcbiAgICAgICAgYWRkREZBRWRnZShkZmEsIHByZXZpb3VzRCwgdG9rZW4sIERGQV9FUlJPUik7XG4gICAgICAgIHJldHVybiBERkFfRVJST1I7XG4gICAgfVxuICAgIGxldCBuZXdTdGF0ZSA9IG5ld0RGQVN0YXRlKHJlYWNoKTtcbiAgICBjb25zdCBwcmVkaWN0ZWRBbHQgPSBnZXRVbmlxdWVBbHQocmVhY2gsIHByZWRpY2F0ZVNldCk7XG4gICAgaWYgKHByZWRpY3RlZEFsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1N0YXRlLmlzQWNjZXB0U3RhdGUgPSB0cnVlO1xuICAgICAgICBuZXdTdGF0ZS5wcmVkaWN0aW9uID0gcHJlZGljdGVkQWx0O1xuICAgICAgICBuZXdTdGF0ZS5jb25maWdzLnVuaXF1ZUFsdCA9IHByZWRpY3RlZEFsdDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFzQ29uZmxpY3RUZXJtaW5hdGluZ1ByZWRpY3Rpb24ocmVhY2gpKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY3Rpb24gPSBtaW4ocmVhY2guYWx0cyk7XG4gICAgICAgIG5ld1N0YXRlLmlzQWNjZXB0U3RhdGUgPSB0cnVlO1xuICAgICAgICBuZXdTdGF0ZS5wcmVkaWN0aW9uID0gcHJlZGljdGlvbjtcbiAgICAgICAgbmV3U3RhdGUuY29uZmlncy51bmlxdWVBbHQgPSBwcmVkaWN0aW9uO1xuICAgICAgICByZXBvcnRMb29rYWhlYWRBbWJpZ3VpdHkuYXBwbHkodGhpcywgW2RmYSwgbG9va2FoZWFkLCByZWFjaC5hbHRzLCBsb2dnaW5nXSk7XG4gICAgfVxuICAgIG5ld1N0YXRlID0gYWRkREZBRWRnZShkZmEsIHByZXZpb3VzRCwgdG9rZW4sIG5ld1N0YXRlKTtcbiAgICByZXR1cm4gbmV3U3RhdGU7XG59XG5mdW5jdGlvbiByZXBvcnRMb29rYWhlYWRBbWJpZ3VpdHkoZGZhLCBsb29rYWhlYWQsIGFtYmlndWl0eUluZGljZXMsIGxvZ2dpbmcpIHtcbiAgICBjb25zdCBwcmVmaXhQYXRoID0gW107XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPD0gbG9va2FoZWFkOyBpKyspIHtcbiAgICAgICAgcHJlZml4UGF0aC5wdXNoKHRoaXMuTEEoaSkudG9rZW5UeXBlKTtcbiAgICB9XG4gICAgY29uc3QgYXRuU3RhdGUgPSBkZmEuYXRuU3RhcnRTdGF0ZTtcbiAgICBjb25zdCB0b3BMZXZlbFJ1bGUgPSBhdG5TdGF0ZS5ydWxlO1xuICAgIGNvbnN0IHByb2R1Y3Rpb24gPSBhdG5TdGF0ZS5wcm9kdWN0aW9uO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBidWlsZEFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgdG9wTGV2ZWxSdWxlLFxuICAgICAgICBhbWJpZ3VpdHlJbmRpY2VzLFxuICAgICAgICBwcm9kdWN0aW9uLFxuICAgICAgICBwcmVmaXhQYXRoXG4gICAgfSk7XG4gICAgbG9nZ2luZyhtZXNzYWdlKTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQW1iaWd1aXR5RXJyb3Iob3B0aW9ucykge1xuICAgIGNvbnN0IHBhdGhNc2cgPSBtYXAob3B0aW9ucy5wcmVmaXhQYXRoLCAoY3VycnRvaykgPT4gdG9rZW5MYWJlbChjdXJydG9rKSkuam9pbihcIiwgXCIpO1xuICAgIGNvbnN0IG9jY3VycmVuY2UgPSBvcHRpb25zLnByb2R1Y3Rpb24uaWR4ID09PSAwID8gXCJcIiA6IG9wdGlvbnMucHJvZHVjdGlvbi5pZHg7XG4gICAgbGV0IGN1cnJNZXNzYWdlID0gYEFtYmlndW91cyBBbHRlcm5hdGl2ZXMgRGV0ZWN0ZWQ6IDwke29wdGlvbnMuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiLCBcIil9PiBpbiA8JHtnZXRQcm9kdWN0aW9uRHNsTmFtZShvcHRpb25zLnByb2R1Y3Rpb24pfSR7b2NjdXJyZW5jZX0+YCArXG4gICAgICAgIGAgaW5zaWRlIDwke29wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWV9PiBSdWxlLFxcbmAgK1xuICAgICAgICBgPCR7cGF0aE1zZ30+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5gO1xuICAgIGN1cnJNZXNzYWdlID1cbiAgICAgICAgY3Vyck1lc3NhZ2UgK1xuICAgICAgICAgICAgYFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQU1CSUdVT1VTX0FMVEVSTkFUSVZFU1xcbmAgK1xuICAgICAgICAgICAgYEZvciBGdXJ0aGVyIGRldGFpbHMuYDtcbiAgICByZXR1cm4gY3Vyck1lc3NhZ2U7XG59XG5mdW5jdGlvbiBnZXRQcm9kdWN0aW9uRHNsTmFtZShwcm9kKSB7XG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gXCJTVUJSVUxFXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFwiT1BUSU9OXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4gXCJPUlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICByZXR1cm4gXCJBVF9MRUFTVF9PTkVcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBcIkFUX0xFQVNUX09ORV9TRVBcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiBcIk1BTllfU0VQXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJldHVybiBcIk1BTllcIjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBcIkNPTlNVTUVcIjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRBZGFwdGl2ZVByZWRpY3RFcnJvcihwYXRoLCBwcmV2aW91cywgY3VycmVudCkge1xuICAgIGNvbnN0IG5leHRUcmFuc2l0aW9ucyA9IGZsYXRNYXAocHJldmlvdXMuY29uZmlncy5lbGVtZW50cywgKGUpID0+IGUuc3RhdGUudHJhbnNpdGlvbnMpO1xuICAgIGNvbnN0IG5leHRUb2tlblR5cGVzID0gdW5pcUJ5KG5leHRUcmFuc2l0aW9uc1xuICAgICAgICAuZmlsdGVyKChlKSA9PiBlIGluc3RhbmNlb2YgQXRvbVRyYW5zaXRpb24pXG4gICAgICAgIC5tYXAoKGUpID0+IGUudG9rZW5UeXBlKSwgKGUpID0+IGUudG9rZW5UeXBlSWR4KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY3R1YWxUb2tlbjogY3VycmVudCxcbiAgICAgICAgcG9zc2libGVUb2tlblR5cGVzOiBuZXh0VG9rZW5UeXBlcyxcbiAgICAgICAgdG9rZW5QYXRoOiBwYXRoXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldEV4aXN0aW5nVGFyZ2V0U3RhdGUoc3RhdGUsIHRva2VuKSB7XG4gICAgcmV0dXJuIHN0YXRlLmVkZ2VzW3Rva2VuLnRva2VuVHlwZUlkeF07XG59XG5mdW5jdGlvbiBjb21wdXRlUmVhY2hTZXQoY29uZmlncywgdG9rZW4sIHByZWRpY2F0ZVNldCkge1xuICAgIGNvbnN0IGludGVybWVkaWF0ZSA9IG5ldyBBVE5Db25maWdTZXQoKTtcbiAgICBjb25zdCBza2lwcGVkU3RvcFN0YXRlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgYyBvZiBjb25maWdzLmVsZW1lbnRzKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGVTZXQuaXMoYy5hbHQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGMuc3RhdGUudHlwZSA9PT0gQVROX1JVTEVfU1RPUCkge1xuICAgICAgICAgICAgc2tpcHBlZFN0b3BTdGF0ZXMucHVzaChjKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zaXRpb25MZW5ndGggPSBjLnN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2l0aW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zaXRpb24gPSBjLnN0YXRlLnRyYW5zaXRpb25zW2ldO1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zaXRpb24sIHRva2VuKTtcbiAgICAgICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGludGVybWVkaWF0ZS5hZGQoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZTogdGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICBhbHQ6IGMuYWx0LFxuICAgICAgICAgICAgICAgICAgICBzdGFjazogYy5zdGFja1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxldCByZWFjaDtcbiAgICBpZiAoc2tpcHBlZFN0b3BTdGF0ZXMubGVuZ3RoID09PSAwICYmIGludGVybWVkaWF0ZS5zaXplID09PSAxKSB7XG4gICAgICAgIHJlYWNoID0gaW50ZXJtZWRpYXRlO1xuICAgIH1cbiAgICBpZiAocmVhY2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWFjaCA9IG5ldyBBVE5Db25maWdTZXQoKTtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIGludGVybWVkaWF0ZS5lbGVtZW50cykge1xuICAgICAgICAgICAgY2xvc3VyZShjLCByZWFjaCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNraXBwZWRTdG9wU3RhdGVzLmxlbmd0aCA+IDAgJiYgIWhhc0NvbmZpZ0luUnVsZVN0b3BTdGF0ZShyZWFjaCkpIHtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHNraXBwZWRTdG9wU3RhdGVzKSB7XG4gICAgICAgICAgICByZWFjaC5hZGQoYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlYWNoO1xufVxuZnVuY3Rpb24gZ2V0UmVhY2hhYmxlVGFyZ2V0KHRyYW5zaXRpb24sIHRva2VuKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gaW5zdGFuY2VvZiBBdG9tVHJhbnNpdGlvbiAmJlxuICAgICAgICB0b2tlbk1hdGNoZXIodG9rZW4sIHRyYW5zaXRpb24udG9rZW5UeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJhbnNpdGlvbi50YXJnZXQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBnZXRVbmlxdWVBbHQoY29uZmlncywgcHJlZGljYXRlU2V0KSB7XG4gICAgbGV0IGFsdDtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY29uZmlncy5lbGVtZW50cykge1xuICAgICAgICBpZiAocHJlZGljYXRlU2V0LmlzKGMuYWx0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgaWYgKGFsdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYWx0ID0gYy5hbHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhbHQgIT09IGMuYWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWx0O1xufVxuZnVuY3Rpb24gbmV3REZBU3RhdGUoY2xvc3VyZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbmZpZ3M6IGNsb3N1cmUsXG4gICAgICAgIGVkZ2VzOiB7fSxcbiAgICAgICAgaXNBY2NlcHRTdGF0ZTogZmFsc2UsXG4gICAgICAgIHByZWRpY3Rpb246IC0xXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZERGQUVkZ2UoZGZhLCBmcm9tLCB0b2tlbiwgdG8pIHtcbiAgICB0byA9IGFkZERGQVN0YXRlKGRmYSwgdG8pO1xuICAgIGZyb20uZWRnZXNbdG9rZW4udG9rZW5UeXBlSWR4XSA9IHRvO1xuICAgIHJldHVybiB0bztcbn1cbmZ1bmN0aW9uIGFkZERGQVN0YXRlKGRmYSwgc3RhdGUpIHtcbiAgICBpZiAoc3RhdGUgPT09IERGQV9FUlJPUikge1xuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfVxuICAgIC8vIFJlcGV0aXRpb25zIGhhdmUgdGhlIHNhbWUgY29uZmlnIHNldFxuICAgIC8vIFRoZXJlZm9yZSwgc3RvcmluZyB0aGUga2V5IG9mIHRoZSBjb25maWcgaW4gYSBtYXAgYWxsb3dzIHVzIHRvIGNyZWF0ZSBhIGxvb3AgaW4gb3VyIERGQVxuICAgIGNvbnN0IG1hcEtleSA9IHN0YXRlLmNvbmZpZ3Mua2V5O1xuICAgIGNvbnN0IGV4aXN0aW5nID0gZGZhLnN0YXRlc1ttYXBLZXldO1xuICAgIGlmIChleGlzdGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gICAgc3RhdGUuY29uZmlncy5maW5hbGl6ZSgpO1xuICAgIGRmYS5zdGF0ZXNbbWFwS2V5XSA9IHN0YXRlO1xuICAgIHJldHVybiBzdGF0ZTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVTdGFydFN0YXRlKGF0blN0YXRlKSB7XG4gICAgY29uc3QgY29uZmlncyA9IG5ldyBBVE5Db25maWdTZXQoKTtcbiAgICBjb25zdCBudW1iZXJPZlRyYW5zaXRpb25zID0gYXRuU3RhdGUudHJhbnNpdGlvbnMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtYmVyT2ZUcmFuc2l0aW9uczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IGF0blN0YXRlLnRyYW5zaXRpb25zW2ldLnRhcmdldDtcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRhcmdldCxcbiAgICAgICAgICAgIGFsdDogaSxcbiAgICAgICAgICAgIHN0YWNrOiBbXVxuICAgICAgICB9O1xuICAgICAgICBjbG9zdXJlKGNvbmZpZywgY29uZmlncyk7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdzO1xufVxuZnVuY3Rpb24gY2xvc3VyZShjb25maWcsIGNvbmZpZ3MpIHtcbiAgICBjb25zdCBwID0gY29uZmlnLnN0YXRlO1xuICAgIGlmIChwLnR5cGUgPT09IEFUTl9SVUxFX1NUT1ApIHtcbiAgICAgICAgaWYgKGNvbmZpZy5zdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBhdG5TdGFjayA9IFsuLi5jb25maWcuc3RhY2tdO1xuICAgICAgICAgICAgY29uc3QgZm9sbG93U3RhdGUgPSBhdG5TdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGNvbnN0IGZvbGxvd0NvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogZm9sbG93U3RhdGUsXG4gICAgICAgICAgICAgICAgYWx0OiBjb25maWcuYWx0LFxuICAgICAgICAgICAgICAgIHN0YWNrOiBhdG5TdGFja1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNsb3N1cmUoZm9sbG93Q29uZmlnLCBjb25maWdzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpcHBpbmcgaW50byBvdXRlciBjb250ZXh0LCBzaW1wbHkgYWRkIHRoZSBjb25maWdcbiAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBzdG9wIGNvbXB1dGF0aW9uIG9uY2UgZXZlcnkgY29uZmlnIGlzIGF0IHRoZSBydWxlIHN0b3Agc3RhdGVcbiAgICAgICAgICAgIGNvbmZpZ3MuYWRkKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXAuZXBzaWxvbk9ubHlUcmFuc2l0aW9ucykge1xuICAgICAgICBjb25maWdzLmFkZChjb25maWcpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2l0aW9uTGVuZ3RoID0gcC50cmFuc2l0aW9ucy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0cmFuc2l0aW9uTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgdHJhbnNpdGlvbiA9IHAudHJhbnNpdGlvbnNbaV07XG4gICAgICAgIGNvbnN0IGMgPSBnZXRFcHNpbG9uVGFyZ2V0KGNvbmZpZywgdHJhbnNpdGlvbik7XG4gICAgICAgIGlmIChjICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNsb3N1cmUoYywgY29uZmlncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBnZXRFcHNpbG9uVGFyZ2V0KGNvbmZpZywgdHJhbnNpdGlvbikge1xuICAgIGlmICh0cmFuc2l0aW9uIGluc3RhbmNlb2YgRXBzaWxvblRyYW5zaXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0YXRlOiB0cmFuc2l0aW9uLnRhcmdldCxcbiAgICAgICAgICAgIGFsdDogY29uZmlnLmFsdCxcbiAgICAgICAgICAgIHN0YWNrOiBjb25maWcuc3RhY2tcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHJhbnNpdGlvbiBpbnN0YW5jZW9mIFJ1bGVUcmFuc2l0aW9uKSB7XG4gICAgICAgIGNvbnN0IHN0YWNrID0gWy4uLmNvbmZpZy5zdGFjaywgdHJhbnNpdGlvbi5mb2xsb3dTdGF0ZV07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdGF0ZTogdHJhbnNpdGlvbi50YXJnZXQsXG4gICAgICAgICAgICBhbHQ6IGNvbmZpZy5hbHQsXG4gICAgICAgICAgICBzdGFja1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaGFzQ29uZmlnSW5SdWxlU3RvcFN0YXRlKGNvbmZpZ3MpIHtcbiAgICBmb3IgKGNvbnN0IGMgb2YgY29uZmlncy5lbGVtZW50cykge1xuICAgICAgICBpZiAoYy5zdGF0ZS50eXBlID09PSBBVE5fUlVMRV9TVE9QKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBhbGxDb25maWdzSW5SdWxlU3RvcFN0YXRlcyhjb25maWdzKSB7XG4gICAgZm9yIChjb25zdCBjIG9mIGNvbmZpZ3MuZWxlbWVudHMpIHtcbiAgICAgICAgaWYgKGMuc3RhdGUudHlwZSAhPT0gQVROX1JVTEVfU1RPUCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaGFzQ29uZmxpY3RUZXJtaW5hdGluZ1ByZWRpY3Rpb24oY29uZmlncykge1xuICAgIGlmIChhbGxDb25maWdzSW5SdWxlU3RvcFN0YXRlcyhjb25maWdzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3QgYWx0U2V0cyA9IGdldENvbmZsaWN0aW5nQWx0U2V0cyhjb25maWdzLmVsZW1lbnRzKTtcbiAgICBjb25zdCBoZXVyaXN0aWMgPSBoYXNDb25mbGljdGluZ0FsdFNldChhbHRTZXRzKSAmJiAhaGFzU3RhdGVBc3NvY2lhdGVkV2l0aE9uZUFsdChhbHRTZXRzKTtcbiAgICByZXR1cm4gaGV1cmlzdGljO1xufVxuZnVuY3Rpb24gZ2V0Q29uZmxpY3RpbmdBbHRTZXRzKGNvbmZpZ3MpIHtcbiAgICBjb25zdCBjb25maWdUb0FsdHMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBjIG9mIGNvbmZpZ3MpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0QVROQ29uZmlnS2V5KGMsIGZhbHNlKTtcbiAgICAgICAgbGV0IGFsdHMgPSBjb25maWdUb0FsdHMuZ2V0KGtleSk7XG4gICAgICAgIGlmIChhbHRzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGFsdHMgPSB7fTtcbiAgICAgICAgICAgIGNvbmZpZ1RvQWx0cy5zZXQoa2V5LCBhbHRzKTtcbiAgICAgICAgfVxuICAgICAgICBhbHRzW2MuYWx0XSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBjb25maWdUb0FsdHM7XG59XG5mdW5jdGlvbiBoYXNDb25mbGljdGluZ0FsdFNldChhbHRTZXRzKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBBcnJheS5mcm9tKGFsdFNldHMudmFsdWVzKCkpKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gaGFzU3RhdGVBc3NvY2lhdGVkV2l0aE9uZUFsdChhbHRTZXRzKSB7XG4gICAgZm9yIChjb25zdCB2YWx1ZSBvZiBBcnJheS5mcm9tKGFsdFNldHMudmFsdWVzKCkpKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyh2YWx1ZSkubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGwtc3Rhci1sb29rYWhlYWQuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IG1hcCBmcm9tIFwibG9kYXNoLWVzL21hcC5qc1wiO1xuaW1wb3J0IGZpbHRlciBmcm9tIFwibG9kYXNoLWVzL2ZpbHRlci5qc1wiO1xuaW1wb3J0IHsgQWx0ZXJuYXRpb24sIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb24sIFRlcm1pbmFsLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfSBmcm9tIFwiY2hldnJvdGFpblwiO1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkQVROS2V5KHJ1bGUsIHR5cGUsIG9jY3VycmVuY2UpIHtcbiAgICByZXR1cm4gYCR7cnVsZS5uYW1lfV8ke3R5cGV9XyR7b2NjdXJyZW5jZX1gO1xufVxuZXhwb3J0IGNvbnN0IEFUTl9JTlZBTElEX1RZUEUgPSAwO1xuZXhwb3J0IGNvbnN0IEFUTl9CQVNJQyA9IDE7XG5leHBvcnQgY29uc3QgQVROX1JVTEVfU1RBUlQgPSAyO1xuZXhwb3J0IGNvbnN0IEFUTl9QTFVTX0JMT0NLX1NUQVJUID0gNDtcbmV4cG9ydCBjb25zdCBBVE5fU1RBUl9CTE9DS19TVEFSVCA9IDU7XG4vLyBDdXJyZW50bHkgdW51c2VkIGFzIHRoZSBBVE4gaXMgbm90IHVzZWQgZm9yIGxleGluZ1xuZXhwb3J0IGNvbnN0IEFUTl9UT0tFTl9TVEFSVCA9IDY7XG5leHBvcnQgY29uc3QgQVROX1JVTEVfU1RPUCA9IDc7XG5leHBvcnQgY29uc3QgQVROX0JMT0NLX0VORCA9IDg7XG5leHBvcnQgY29uc3QgQVROX1NUQVJfTE9PUF9CQUNLID0gOTtcbmV4cG9ydCBjb25zdCBBVE5fU1RBUl9MT09QX0VOVFJZID0gMTA7XG5leHBvcnQgY29uc3QgQVROX1BMVVNfTE9PUF9CQUNLID0gMTE7XG5leHBvcnQgY29uc3QgQVROX0xPT1BfRU5EID0gMTI7XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgfVxuICAgIGlzRXBzaWxvbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBdG9tVHJhbnNpdGlvbiBleHRlbmRzIEFic3RyYWN0VHJhbnNpdGlvbiB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0LCB0b2tlblR5cGUpIHtcbiAgICAgICAgc3VwZXIodGFyZ2V0KTtcbiAgICAgICAgdGhpcy50b2tlblR5cGUgPSB0b2tlblR5cGU7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEVwc2lsb25UcmFuc2l0aW9uIGV4dGVuZHMgQWJzdHJhY3RUcmFuc2l0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXQpIHtcbiAgICAgICAgc3VwZXIodGFyZ2V0KTtcbiAgICB9XG4gICAgaXNFcHNpbG9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUnVsZVRyYW5zaXRpb24gZXh0ZW5kcyBBYnN0cmFjdFRyYW5zaXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHJ1bGVTdGFydCwgcnVsZSwgZm9sbG93U3RhdGUpIHtcbiAgICAgICAgc3VwZXIocnVsZVN0YXJ0KTtcbiAgICAgICAgdGhpcy5ydWxlID0gcnVsZTtcbiAgICAgICAgdGhpcy5mb2xsb3dTdGF0ZSA9IGZvbGxvd1N0YXRlO1xuICAgIH1cbiAgICBpc0Vwc2lsb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVBVE4ocnVsZXMpIHtcbiAgICBjb25zdCBhdG4gPSB7XG4gICAgICAgIGRlY2lzaW9uTWFwOiB7fSxcbiAgICAgICAgZGVjaXNpb25TdGF0ZXM6IFtdLFxuICAgICAgICBydWxlVG9TdGFydFN0YXRlOiBuZXcgTWFwKCksXG4gICAgICAgIHJ1bGVUb1N0b3BTdGF0ZTogbmV3IE1hcCgpLFxuICAgICAgICBzdGF0ZXM6IFtdXG4gICAgfTtcbiAgICBjcmVhdGVSdWxlU3RhcnRBbmRTdG9wQVROU3RhdGVzKGF0biwgcnVsZXMpO1xuICAgIGNvbnN0IHJ1bGVMZW5ndGggPSBydWxlcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydWxlTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgcnVsZSA9IHJ1bGVzW2ldO1xuICAgICAgICBjb25zdCBydWxlQmxvY2sgPSBibG9jayhhdG4sIHJ1bGUsIHJ1bGUpO1xuICAgICAgICBpZiAocnVsZUJsb2NrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGJ1aWxkUnVsZUhhbmRsZShhdG4sIHJ1bGUsIHJ1bGVCbG9jayk7XG4gICAgfVxuICAgIHJldHVybiBhdG47XG59XG5mdW5jdGlvbiBjcmVhdGVSdWxlU3RhcnRBbmRTdG9wQVROU3RhdGVzKGF0biwgcnVsZXMpIHtcbiAgICBjb25zdCBydWxlTGVuZ3RoID0gcnVsZXMubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnVsZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHJ1bGUgPSBydWxlc1tpXTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgdHlwZTogQVROX1JVTEVfU1RBUlRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHN0b3AgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHVuZGVmaW5lZCwge1xuICAgICAgICAgICAgdHlwZTogQVROX1JVTEVfU1RPUFxuICAgICAgICB9KTtcbiAgICAgICAgc3RhcnQuc3RvcCA9IHN0b3A7XG4gICAgICAgIGF0bi5ydWxlVG9TdGFydFN0YXRlLnNldChydWxlLCBzdGFydCk7XG4gICAgICAgIGF0bi5ydWxlVG9TdG9wU3RhdGUuc2V0KHJ1bGUsIHN0b3ApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGF0b20oYXRuLCBydWxlLCBwcm9kdWN0aW9uKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gdG9rZW5SZWYoYXRuLCBydWxlLCBwcm9kdWN0aW9uLnRlcm1pbmFsVHlwZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gcnVsZVJlZihhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgQWx0ZXJuYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGFsdGVybmF0aW9uKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbihhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXR1cm4gcmVwZXRpdGlvbihhdG4sIHJ1bGUsIHByb2R1Y3Rpb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kdWN0aW9uIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgcmV0dXJuIHJlcGV0aXRpb25TZXAoYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuIHJlcGV0aXRpb25NYW5kYXRvcnkoYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiByZXBldGl0aW9uTWFuZGF0b3J5U2VwKGF0biwgcnVsZSwgcHJvZHVjdGlvbik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYmxvY2soYXRuLCBydWxlLCBwcm9kdWN0aW9uKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXBldGl0aW9uKGF0biwgcnVsZSwgcmVwZXRpdGlvbikge1xuICAgIGNvbnN0IHN0YXJTdGF0ZSA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fU1RBUl9CTE9DS19TVEFSVFxuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBzdGFyU3RhdGUpO1xuICAgIGNvbnN0IGhhbmRsZSA9IG1ha2VBbHRzKGF0biwgcnVsZSwgc3RhclN0YXRlLCByZXBldGl0aW9uLCBibG9jayhhdG4sIHJ1bGUsIHJlcGV0aXRpb24pKTtcbiAgICByZXR1cm4gc3RhcihhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIGhhbmRsZSk7XG59XG5mdW5jdGlvbiByZXBldGl0aW9uU2VwKGF0biwgcnVsZSwgcmVwZXRpdGlvbikge1xuICAgIGNvbnN0IHN0YXJTdGF0ZSA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fU1RBUl9CTE9DS19TVEFSVFxuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBzdGFyU3RhdGUpO1xuICAgIGNvbnN0IGhhbmRsZSA9IG1ha2VBbHRzKGF0biwgcnVsZSwgc3RhclN0YXRlLCByZXBldGl0aW9uLCBibG9jayhhdG4sIHJ1bGUsIHJlcGV0aXRpb24pKTtcbiAgICBjb25zdCBzZXAgPSB0b2tlblJlZihhdG4sIHJ1bGUsIHJlcGV0aXRpb24uc2VwYXJhdG9yLCByZXBldGl0aW9uKTtcbiAgICByZXR1cm4gc3RhcihhdG4sIHJ1bGUsIHJlcGV0aXRpb24sIGhhbmRsZSwgc2VwKTtcbn1cbmZ1bmN0aW9uIHJlcGV0aXRpb25NYW5kYXRvcnkoYXRuLCBydWxlLCByZXBldGl0aW9uKSB7XG4gICAgY29uc3QgcGx1c1N0YXRlID0gbmV3U3RhdGUoYXRuLCBydWxlLCByZXBldGl0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9QTFVTX0JMT0NLX1NUQVJUXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHBsdXNTdGF0ZSk7XG4gICAgY29uc3QgaGFuZGxlID0gbWFrZUFsdHMoYXRuLCBydWxlLCBwbHVzU3RhdGUsIHJlcGV0aXRpb24sIGJsb2NrKGF0biwgcnVsZSwgcmVwZXRpdGlvbikpO1xuICAgIHJldHVybiBwbHVzKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwgaGFuZGxlKTtcbn1cbmZ1bmN0aW9uIHJlcGV0aXRpb25NYW5kYXRvcnlTZXAoYXRuLCBydWxlLCByZXBldGl0aW9uKSB7XG4gICAgY29uc3QgcGx1c1N0YXRlID0gbmV3U3RhdGUoYXRuLCBydWxlLCByZXBldGl0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9QTFVTX0JMT0NLX1NUQVJUXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIHBsdXNTdGF0ZSk7XG4gICAgY29uc3QgaGFuZGxlID0gbWFrZUFsdHMoYXRuLCBydWxlLCBwbHVzU3RhdGUsIHJlcGV0aXRpb24sIGJsb2NrKGF0biwgcnVsZSwgcmVwZXRpdGlvbikpO1xuICAgIGNvbnN0IHNlcCA9IHRva2VuUmVmKGF0biwgcnVsZSwgcmVwZXRpdGlvbi5zZXBhcmF0b3IsIHJlcGV0aXRpb24pO1xuICAgIHJldHVybiBwbHVzKGF0biwgcnVsZSwgcmVwZXRpdGlvbiwgaGFuZGxlLCBzZXApO1xufVxuZnVuY3Rpb24gYWx0ZXJuYXRpb24oYXRuLCBydWxlLCBhbHRlcm5hdGlvbikge1xuICAgIGNvbnN0IHN0YXJ0ID0gbmV3U3RhdGUoYXRuLCBydWxlLCBhbHRlcm5hdGlvbiwge1xuICAgICAgICB0eXBlOiBBVE5fQkFTSUNcbiAgICB9KTtcbiAgICBkZWZpbmVEZWNpc2lvblN0YXRlKGF0biwgc3RhcnQpO1xuICAgIGNvbnN0IGFsdHMgPSBtYXAoYWx0ZXJuYXRpb24uZGVmaW5pdGlvbiwgKGUpID0+IGF0b20oYXRuLCBydWxlLCBlKSk7XG4gICAgY29uc3QgaGFuZGxlID0gbWFrZUFsdHMoYXRuLCBydWxlLCBzdGFydCwgYWx0ZXJuYXRpb24sIC4uLmFsdHMpO1xuICAgIHJldHVybiBoYW5kbGU7XG59XG5mdW5jdGlvbiBvcHRpb24oYXRuLCBydWxlLCBvcHRpb24pIHtcbiAgICBjb25zdCBzdGFydCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgb3B0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CQVNJQ1xuICAgIH0pO1xuICAgIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBzdGFydCk7XG4gICAgY29uc3QgaGFuZGxlID0gbWFrZUFsdHMoYXRuLCBydWxlLCBzdGFydCwgb3B0aW9uLCBibG9jayhhdG4sIHJ1bGUsIG9wdGlvbikpO1xuICAgIHJldHVybiBvcHRpb25hbChhdG4sIHJ1bGUsIG9wdGlvbiwgaGFuZGxlKTtcbn1cbmZ1bmN0aW9uIGJsb2NrKGF0biwgcnVsZSwgYmxvY2spIHtcbiAgICBjb25zdCBoYW5kbGVzID0gZmlsdGVyKG1hcChibG9jay5kZWZpbml0aW9uLCAoZSkgPT4gYXRvbShhdG4sIHJ1bGUsIGUpKSwgKGUpID0+IGUgIT09IHVuZGVmaW5lZCk7XG4gICAgaWYgKGhhbmRsZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBoYW5kbGVzWzBdO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYW5kbGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG1ha2VCbG9jayhhdG4sIGhhbmRsZXMpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBsdXMoYXRuLCBydWxlLCBwbHVzLCBoYW5kbGUsIHNlcCkge1xuICAgIGNvbnN0IGJsa1N0YXJ0ID0gaGFuZGxlLmxlZnQ7XG4gICAgY29uc3QgYmxrRW5kID0gaGFuZGxlLnJpZ2h0O1xuICAgIGNvbnN0IGxvb3AgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHBsdXMsIHtcbiAgICAgICAgdHlwZTogQVROX1BMVVNfTE9PUF9CQUNLXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIGxvb3ApO1xuICAgIGNvbnN0IGVuZCA9IG5ld1N0YXRlKGF0biwgcnVsZSwgcGx1cywge1xuICAgICAgICB0eXBlOiBBVE5fTE9PUF9FTkRcbiAgICB9KTtcbiAgICBibGtTdGFydC5sb29wYmFjayA9IGxvb3A7XG4gICAgZW5kLmxvb3BiYWNrID0gbG9vcDtcbiAgICBhdG4uZGVjaXNpb25NYXBbYnVpbGRBVE5LZXkocnVsZSwgc2VwID8gJ1JlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yJyA6ICdSZXBldGl0aW9uTWFuZGF0b3J5JywgcGx1cy5pZHgpXSA9IGxvb3A7XG4gICAgZXBzaWxvbihibGtFbmQsIGxvb3ApOyAvLyBibG9jayBjYW4gc2VlIGxvb3AgYmFja1xuICAgIC8vIERlcGVuZGluZyBvbiB3aGV0aGVyIHdlIGhhdmUgYSBzZXBhcmF0b3Igd2UgcHV0IHRoZSBleGl0IHRyYW5zaXRpb24gYXQgaW5kZXggMSBvciAwXG4gICAgLy8gVGhpcyBpbmZsdWVuY2VzIHRoZSBjaG9zZW4gb3B0aW9uIGluIHRoZSBsb29rYWhlYWQgREZBXG4gICAgaWYgKHNlcCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVwc2lsb24obG9vcCwgYmxrU3RhcnQpOyAvLyBsb29wIGJhY2sgdG8gc3RhcnRcbiAgICAgICAgZXBzaWxvbihsb29wLCBlbmQpOyAvLyBleGl0XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlcHNpbG9uKGxvb3AsIGVuZCk7IC8vIGV4aXRcbiAgICAgICAgLy8gbG9vcCBiYWNrIHRvIHN0YXJ0IHdpdGggc2VwYXJhdG9yXG4gICAgICAgIGVwc2lsb24obG9vcCwgc2VwLmxlZnQpO1xuICAgICAgICBlcHNpbG9uKHNlcC5yaWdodCwgYmxrU3RhcnQpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBibGtTdGFydCxcbiAgICAgICAgcmlnaHQ6IGVuZFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFyKGF0biwgcnVsZSwgc3RhciwgaGFuZGxlLCBzZXApIHtcbiAgICBjb25zdCBzdGFydCA9IGhhbmRsZS5sZWZ0O1xuICAgIGNvbnN0IGVuZCA9IGhhbmRsZS5yaWdodDtcbiAgICBjb25zdCBlbnRyeSA9IG5ld1N0YXRlKGF0biwgcnVsZSwgc3Rhciwge1xuICAgICAgICB0eXBlOiBBVE5fU1RBUl9MT09QX0VOVFJZXG4gICAgfSk7XG4gICAgZGVmaW5lRGVjaXNpb25TdGF0ZShhdG4sIGVudHJ5KTtcbiAgICBjb25zdCBsb29wRW5kID0gbmV3U3RhdGUoYXRuLCBydWxlLCBzdGFyLCB7XG4gICAgICAgIHR5cGU6IEFUTl9MT09QX0VORFxuICAgIH0pO1xuICAgIGNvbnN0IGxvb3AgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHN0YXIsIHtcbiAgICAgICAgdHlwZTogQVROX1NUQVJfTE9PUF9CQUNLXG4gICAgfSk7XG4gICAgZW50cnkubG9vcGJhY2sgPSBsb29wO1xuICAgIGxvb3BFbmQubG9vcGJhY2sgPSBsb29wO1xuICAgIGVwc2lsb24oZW50cnksIHN0YXJ0KTsgLy8gbG9vcCBlbnRlciBlZGdlIChhbHQgMilcbiAgICBlcHNpbG9uKGVudHJ5LCBsb29wRW5kKTsgLy8gYnlwYXNzIGxvb3AgZWRnZSAoYWx0IDEpXG4gICAgZXBzaWxvbihlbmQsIGxvb3ApOyAvLyBibG9jayBlbmQgaGl0cyBsb29wIGJhY2tcbiAgICBpZiAoc2VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXBzaWxvbihsb29wLCBsb29wRW5kKTsgLy8gZW5kIGxvb3BcbiAgICAgICAgLy8gbG9vcCBiYWNrIHRvIHN0YXJ0IG9mIGhhbmRsZSB1c2luZyBzZXBhcmF0b3JcbiAgICAgICAgZXBzaWxvbihsb29wLCBzZXAubGVmdCk7XG4gICAgICAgIGVwc2lsb24oc2VwLnJpZ2h0LCBzdGFydCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlcHNpbG9uKGxvb3AsIGVudHJ5KTsgLy8gbG9vcCBiYWNrIHRvIGVudHJ5L2V4aXQgZGVjaXNpb25cbiAgICB9XG4gICAgYXRuLmRlY2lzaW9uTWFwW2J1aWxkQVROS2V5KHJ1bGUsIHNlcCA/ICdSZXBldGl0aW9uV2l0aFNlcGFyYXRvcicgOiAnUmVwZXRpdGlvbicsIHN0YXIuaWR4KV0gPSBlbnRyeTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0OiBlbnRyeSxcbiAgICAgICAgcmlnaHQ6IGxvb3BFbmRcbiAgICB9O1xufVxuZnVuY3Rpb24gb3B0aW9uYWwoYXRuLCBydWxlLCBvcHRpb25hbCwgaGFuZGxlKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBoYW5kbGUubGVmdDtcbiAgICBjb25zdCBlbmQgPSBoYW5kbGUucmlnaHQ7XG4gICAgZXBzaWxvbihzdGFydCwgZW5kKTtcbiAgICBhdG4uZGVjaXNpb25NYXBbYnVpbGRBVE5LZXkocnVsZSwgJ09wdGlvbicsIG9wdGlvbmFsLmlkeCldID0gc3RhcnQ7XG4gICAgcmV0dXJuIGhhbmRsZTtcbn1cbmZ1bmN0aW9uIGRlZmluZURlY2lzaW9uU3RhdGUoYXRuLCBzdGF0ZSkge1xuICAgIGF0bi5kZWNpc2lvblN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICBzdGF0ZS5kZWNpc2lvbiA9IGF0bi5kZWNpc2lvblN0YXRlcy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBzdGF0ZS5kZWNpc2lvbjtcbn1cbmZ1bmN0aW9uIG1ha2VBbHRzKGF0biwgcnVsZSwgc3RhcnQsIHByb2R1Y3Rpb24sIC4uLmFsdHMpIHtcbiAgICBjb25zdCBlbmQgPSBuZXdTdGF0ZShhdG4sIHJ1bGUsIHByb2R1Y3Rpb24sIHtcbiAgICAgICAgdHlwZTogQVROX0JMT0NLX0VORCxcbiAgICAgICAgc3RhcnRcbiAgICB9KTtcbiAgICBzdGFydC5lbmQgPSBlbmQ7XG4gICAgZm9yIChjb25zdCBhbHQgb2YgYWx0cykge1xuICAgICAgICBpZiAoYWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGhvb2sgYWx0cyB1cCB0byBkZWNpc2lvbiBibG9ja1xuICAgICAgICAgICAgZXBzaWxvbihzdGFydCwgYWx0LmxlZnQpO1xuICAgICAgICAgICAgZXBzaWxvbihhbHQucmlnaHQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBlcHNpbG9uKHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhhbmRsZSA9IHtcbiAgICAgICAgbGVmdDogc3RhcnQsXG4gICAgICAgIHJpZ2h0OiBlbmRcbiAgICB9O1xuICAgIGF0bi5kZWNpc2lvbk1hcFtidWlsZEFUTktleShydWxlLCBnZXRQcm9kVHlwZShwcm9kdWN0aW9uKSwgcHJvZHVjdGlvbi5pZHgpXSA9IHN0YXJ0O1xuICAgIHJldHVybiBoYW5kbGU7XG59XG5mdW5jdGlvbiBnZXRQcm9kVHlwZShwcm9kdWN0aW9uKSB7XG4gICAgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICByZXR1cm4gJ0FsdGVybmF0aW9uJztcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIE9wdGlvbikge1xuICAgICAgICByZXR1cm4gJ09wdGlvbic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgIHJldHVybiAnUmVwZXRpdGlvbic7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2R1Y3Rpb24gaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICByZXR1cm4gJ1JlcGV0aXRpb25XaXRoU2VwYXJhdG9yJztcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkpIHtcbiAgICAgICAgcmV0dXJuICdSZXBldGl0aW9uTWFuZGF0b3J5JztcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZHVjdGlvbiBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgIHJldHVybiAnUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3InO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHByb2R1Y3Rpb24gdHlwZSBlbmNvdW50ZXJlZCcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG1ha2VCbG9jayhhdG4sIGFsdHMpIHtcbiAgICBjb25zdCBhbHRzTGVuZ3RoID0gYWx0cy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHRzTGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IGFsdHNbaV07XG4gICAgICAgIGxldCB0cmFuc2l0aW9uO1xuICAgICAgICBpZiAoaGFuZGxlLmxlZnQudHJhbnNpdGlvbnMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICB0cmFuc2l0aW9uID0gaGFuZGxlLmxlZnQudHJhbnNpdGlvbnNbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNSdWxlVHJhbnNpdGlvbiA9IHRyYW5zaXRpb24gaW5zdGFuY2VvZiBSdWxlVHJhbnNpdGlvbjtcbiAgICAgICAgY29uc3QgcnVsZVRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICBjb25zdCBuZXh0ID0gYWx0c1tpICsgMV0ubGVmdDtcbiAgICAgICAgaWYgKGhhbmRsZS5sZWZ0LnR5cGUgPT09IEFUTl9CQVNJQyAmJlxuICAgICAgICAgICAgaGFuZGxlLnJpZ2h0LnR5cGUgPT09IEFUTl9CQVNJQyAmJlxuICAgICAgICAgICAgdHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAoKGlzUnVsZVRyYW5zaXRpb24gJiYgcnVsZVRyYW5zaXRpb24uZm9sbG93U3RhdGUgPT09IGhhbmRsZS5yaWdodCkgfHxcbiAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLnRhcmdldCA9PT0gaGFuZGxlLnJpZ2h0KSkge1xuICAgICAgICAgICAgLy8gd2UgY2FuIGF2b2lkIGVwc2lsb24gZWRnZSB0byBuZXh0IGVsZW1lbnRcbiAgICAgICAgICAgIGlmIChpc1J1bGVUcmFuc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgcnVsZVRyYW5zaXRpb24uZm9sbG93U3RhdGUgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbi50YXJnZXQgPSBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVtb3ZlU3RhdGUoYXRuLCBoYW5kbGUucmlnaHQpOyAvLyB3ZSBza2lwcGVkIG92ZXIgdGhpcyBzdGF0ZVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gbmVlZCBlcHNpbG9uIGlmIHByZXZpb3VzIGJsb2NrJ3MgcmlnaHQgZW5kIG5vZGUgaXMgY29tcGxleFxuICAgICAgICAgICAgZXBzaWxvbihoYW5kbGUucmlnaHQsIG5leHQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpcnN0ID0gYWx0c1swXTtcbiAgICBjb25zdCBsYXN0ID0gYWx0c1thbHRzTGVuZ3RoIC0gMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbGVmdDogZmlyc3QubGVmdCxcbiAgICAgICAgcmlnaHQ6IGxhc3QucmlnaHRcbiAgICB9O1xufVxuZnVuY3Rpb24gdG9rZW5SZWYoYXRuLCBydWxlLCB0b2tlblR5cGUsIHByb2R1Y3Rpb24pIHtcbiAgICBjb25zdCBsZWZ0ID0gbmV3U3RhdGUoYXRuLCBydWxlLCBwcm9kdWN0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CQVNJQ1xuICAgIH0pO1xuICAgIGNvbnN0IHJpZ2h0ID0gbmV3U3RhdGUoYXRuLCBydWxlLCBwcm9kdWN0aW9uLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CQVNJQ1xuICAgIH0pO1xuICAgIGFkZFRyYW5zaXRpb24obGVmdCwgbmV3IEF0b21UcmFuc2l0aW9uKHJpZ2h0LCB0b2tlblR5cGUpKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBsZWZ0LFxuICAgICAgICByaWdodFxuICAgIH07XG59XG5mdW5jdGlvbiBydWxlUmVmKGF0biwgY3VycmVudFJ1bGUsIG5vblRlcm1pbmFsKSB7XG4gICAgY29uc3QgcnVsZSA9IG5vblRlcm1pbmFsLnJlZmVyZW5jZWRSdWxlO1xuICAgIGNvbnN0IHN0YXJ0ID0gYXRuLnJ1bGVUb1N0YXJ0U3RhdGUuZ2V0KHJ1bGUpO1xuICAgIGNvbnN0IGxlZnQgPSBuZXdTdGF0ZShhdG4sIGN1cnJlbnRSdWxlLCBub25UZXJtaW5hbCwge1xuICAgICAgICB0eXBlOiBBVE5fQkFTSUNcbiAgICB9KTtcbiAgICBjb25zdCByaWdodCA9IG5ld1N0YXRlKGF0biwgY3VycmVudFJ1bGUsIG5vblRlcm1pbmFsLCB7XG4gICAgICAgIHR5cGU6IEFUTl9CQVNJQ1xuICAgIH0pO1xuICAgIGNvbnN0IGNhbGwgPSBuZXcgUnVsZVRyYW5zaXRpb24oc3RhcnQsIHJ1bGUsIHJpZ2h0KTtcbiAgICBhZGRUcmFuc2l0aW9uKGxlZnQsIGNhbGwpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGxlZnQsXG4gICAgICAgIHJpZ2h0XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUnVsZUhhbmRsZShhdG4sIHJ1bGUsIGJsb2NrKSB7XG4gICAgY29uc3Qgc3RhcnQgPSBhdG4ucnVsZVRvU3RhcnRTdGF0ZS5nZXQocnVsZSk7XG4gICAgZXBzaWxvbihzdGFydCwgYmxvY2subGVmdCk7XG4gICAgY29uc3Qgc3RvcCA9IGF0bi5ydWxlVG9TdG9wU3RhdGUuZ2V0KHJ1bGUpO1xuICAgIGVwc2lsb24oYmxvY2sucmlnaHQsIHN0b3ApO1xuICAgIGNvbnN0IGhhbmRsZSA9IHtcbiAgICAgICAgbGVmdDogc3RhcnQsXG4gICAgICAgIHJpZ2h0OiBzdG9wXG4gICAgfTtcbiAgICByZXR1cm4gaGFuZGxlO1xufVxuZnVuY3Rpb24gZXBzaWxvbihhLCBiKSB7XG4gICAgY29uc3QgdHJhbnNpdGlvbiA9IG5ldyBFcHNpbG9uVHJhbnNpdGlvbihiKTtcbiAgICBhZGRUcmFuc2l0aW9uKGEsIHRyYW5zaXRpb24pO1xufVxuZnVuY3Rpb24gbmV3U3RhdGUoYXRuLCBydWxlLCBwcm9kdWN0aW9uLCBwYXJ0aWFsKSB7XG4gICAgY29uc3QgdCA9IE9iamVjdC5hc3NpZ24oeyBhdG4sXG4gICAgICAgIHByb2R1Y3Rpb24sIGVwc2lsb25Pbmx5VHJhbnNpdGlvbnM6IGZhbHNlLCBydWxlLCB0cmFuc2l0aW9uczogW10sIG5leHRUb2tlbldpdGhpblJ1bGU6IFtdLCBzdGF0ZU51bWJlcjogYXRuLnN0YXRlcy5sZW5ndGggfSwgcGFydGlhbCk7XG4gICAgYXRuLnN0YXRlcy5wdXNoKHQpO1xuICAgIHJldHVybiB0O1xufVxuZnVuY3Rpb24gYWRkVHJhbnNpdGlvbihzdGF0ZSwgdHJhbnNpdGlvbikge1xuICAgIC8vIEEgc2luZ2xlIEFUTiBzdGF0ZSBjYW4gb25seSBjb250YWluIGVwc2lsb24gdHJhbnNpdGlvbnMgb3Igbm9uLWVwc2lsb24gdHJhbnNpdGlvbnNcbiAgICAvLyBCZWNhdXNlIHRoZXkgYXJlIG5ldmVyIG1peGVkLCBvbmx5IHNldHRpbmcgdGhlIHByb3BlcnR5IGZvciB0aGUgZmlyc3QgdHJhbnNpdGlvbiBpcyBmaW5lXG4gICAgaWYgKHN0YXRlLnRyYW5zaXRpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5lcHNpbG9uT25seVRyYW5zaXRpb25zID0gdHJhbnNpdGlvbi5pc0Vwc2lsb24oKTtcbiAgICB9XG4gICAgc3RhdGUudHJhbnNpdGlvbnMucHVzaCh0cmFuc2l0aW9uKTtcbn1cbmZ1bmN0aW9uIHJlbW92ZVN0YXRlKGF0biwgc3RhdGUpIHtcbiAgICBhdG4uc3RhdGVzLnNwbGljZShhdG4uc3RhdGVzLmluZGV4T2Yoc3RhdGUpLCAxKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWF0bi5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgbWFwIGZyb20gXCJsb2Rhc2gtZXMvbWFwLmpzXCI7XG5leHBvcnQgY29uc3QgREZBX0VSUk9SID0ge307XG5leHBvcnQgY2xhc3MgQVROQ29uZmlnU2V0IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICAgICAgdGhpcy5jb25maWdzID0gW107XG4gICAgfVxuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25maWdzLmxlbmd0aDtcbiAgICB9XG4gICAgZmluYWxpemUoKSB7XG4gICAgICAgIC8vIEVtcHRpZXMgdGhlIG1hcCB0byBmcmVlIHVwIG1lbW9yeVxuICAgICAgICB0aGlzLm1hcCA9IHt9O1xuICAgIH1cbiAgICBhZGQoY29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldEFUTkNvbmZpZ0tleShjb25maWcpO1xuICAgICAgICAvLyBPbmx5IGFkZCBjb25maWdzIHdoaWNoIGRvbid0IGV4aXN0IGluIG91ciBtYXAgYWxyZWFkeVxuICAgICAgICAvLyBXaGlsZSB0aGlzIGRvZXMgbm90IGluZmx1ZW5jZSB0aGUgYWN0dWFsIGFsZ29yaXRobSwgYWRkaW5nIHRoZW0gYW55d2F5IHdvdWxkIG1hc3NpdmVseSBpbmNyZWFzZSBtZW1vcnkgY29uc3VtcHRpb25cbiAgICAgICAgaWYgKCEoa2V5IGluIHRoaXMubWFwKSkge1xuICAgICAgICAgICAgdGhpcy5tYXBba2V5XSA9IHRoaXMuY29uZmlncy5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLmNvbmZpZ3MucHVzaChjb25maWcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBlbGVtZW50cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlncztcbiAgICB9XG4gICAgZ2V0IGFsdHMoKSB7XG4gICAgICAgIHJldHVybiBtYXAodGhpcy5jb25maWdzLCAoZSkgPT4gZS5hbHQpO1xuICAgIH1cbiAgICBnZXQga2V5KCkge1xuICAgICAgICBsZXQgdmFsdWUgPSBcIlwiO1xuICAgICAgICBmb3IgKGNvbnN0IGsgaW4gdGhpcy5tYXApIHtcbiAgICAgICAgICAgIHZhbHVlICs9IGsgKyBcIjpcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFUTkNvbmZpZ0tleShjb25maWcsIGFsdCA9IHRydWUpIHtcbiAgICByZXR1cm4gYCR7YWx0ID8gYGEke2NvbmZpZy5hbHR9YCA6IFwiXCJ9cyR7Y29uZmlnLnN0YXRlLnN0YXRlTnVtYmVyfToke2NvbmZpZy5zdGFjay5tYXAoKGUpID0+IGUuc3RhdGVOdW1iZXIudG9TdHJpbmcoKSkuam9pbihcIl9cIil9YDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRmYS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgeyBMTFN0YXJMb29rYWhlYWRTdHJhdGVneSB9IGZyb20gJy4vYWxsLXN0YXItbG9va2FoZWFkLmpzJztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlIC0gdHJpY2t5IHRvIGltcG9ydCBzb21lIHRoaW5ncyBmcm9tIHRoaXMgbW9kdWxlIGR1cmluZyB0ZXN0aW5nICovXG4vLyBzZW1hbnRpYyB2ZXJzaW9uXG5leHBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4vdmVyc2lvbi5qc1wiO1xuZXhwb3J0IHsgQ3N0UGFyc2VyLCBFbWJlZGRlZEFjdGlvbnNQYXJzZXIsIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsIEVNUFRZX0FMVCwgfSBmcm9tIFwiLi9wYXJzZS9wYXJzZXIvcGFyc2VyLmpzXCI7XG5leHBvcnQgeyBMZXhlciwgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4vc2Nhbi9sZXhlcl9wdWJsaWMuanNcIjtcbi8vIFRva2VucyB1dGlsaXRpZXNcbmV4cG9ydCB7IGNyZWF0ZVRva2VuLCBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YsIHRva2VuTGFiZWwsIHRva2VuTWF0Y2hlciwgdG9rZW5OYW1lLCB9IGZyb20gXCIuL3NjYW4vdG9rZW5zX3B1YmxpYy5qc1wiO1xuLy8gTG9va2FoZWFkXG5leHBvcnQgeyBnZXRMb29rYWhlYWRQYXRocyB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvbG9va2FoZWFkLmpzXCI7XG5leHBvcnQgeyBMTGtMb29rYWhlYWRTdHJhdGVneSB9IGZyb20gXCIuL3BhcnNlL2dyYW1tYXIvbGxrX2xvb2thaGVhZC5qc1wiO1xuLy8gT3RoZXIgVXRpbGl0aWVzXG5leHBvcnQgeyBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciB9IGZyb20gXCIuL3BhcnNlL2Vycm9yc19wdWJsaWMuanNcIjtcbmV4cG9ydCB7IEVhcmx5RXhpdEV4Y2VwdGlvbiwgaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbiwgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uLCBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbiwgTm9WaWFibGVBbHRFeGNlcHRpb24sIH0gZnJvbSBcIi4vcGFyc2UvZXhjZXB0aW9uc19wdWJsaWMuanNcIjtcbmV4cG9ydCB7IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgfSBmcm9tIFwiLi9zY2FuL2xleGVyX2Vycm9yc19wdWJsaWMuanNcIjtcbi8vIGdyYW1tYXIgcmVmbGVjdGlvbiBBUElcbmV4cG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuLy8gR0FTVCBVdGlsaXRpZXNcbmV4cG9ydCB7IHNlcmlhbGl6ZUdyYW1tYXIsIHNlcmlhbGl6ZVByb2R1Y3Rpb24sIEdBc3RWaXNpdG9yLCB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG5leHBvcnQgeyBnZW5lcmF0ZUNzdER0cyB9IGZyb20gXCJAY2hldnJvdGFpbi9jc3QtZHRzLWdlblwiO1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmV4cG9ydCBmdW5jdGlvbiBjbGVhckNhY2hlKCkge1xuICAgIGNvbnNvbGUud2FybihcIlRoZSBjbGVhckNhY2hlIGZ1bmN0aW9uIHdhcyAnc29mdCcgcmVtb3ZlZCBmcm9tIHRoZSBDaGV2cm90YWluIEFQSS5cIiArXG4gICAgICAgIFwiXFxuXFx0IEl0IHBlcmZvcm1zIG5vIGFjdGlvbiBvdGhlciB0aGFuIHByaW50aW5nIHRoaXMgbWVzc2FnZS5cIiArXG4gICAgICAgIFwiXFxuXFx0IFBsZWFzZSBhdm9pZCB1c2luZyBpdCBhcyBpdCB3aWxsIGJlIGNvbXBsZXRlbHkgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlXCIpO1xufVxuZXhwb3J0IHsgY3JlYXRlU3ludGF4RGlhZ3JhbXNDb2RlIH0gZnJvbSBcIi4vZGlhZ3JhbXMvcmVuZGVyX3B1YmxpYy5qc1wiO1xuZXhwb3J0IGNsYXNzIFBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSBQYXJzZXIgY2xhc3MgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIENzdFBhcnNlciBvciBFbWJlZGRlZEFjdGlvbnNQYXJzZXIgaW5zdGVhZC5cXHRcXG5cIiArXG4gICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvY2hhbmdlcy9CUkVBS0lOR19DSEFOR0VTLmh0bWwjXzctMC0wXCIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFwaS5qcy5tYXAiLCJpbXBvcnQgeyBWRVJTSU9OIH0gZnJvbSBcIi4uL3ZlcnNpb24uanNcIjtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTeW50YXhEaWFncmFtc0NvZGUoZ3JhbW1hciwgeyByZXNvdXJjZUJhc2UgPSBgaHR0cHM6Ly91bnBrZy5jb20vY2hldnJvdGFpbkAke1ZFUlNJT059L2RpYWdyYW1zL2AsIGNzcyA9IGBodHRwczovL3VucGtnLmNvbS9jaGV2cm90YWluQCR7VkVSU0lPTn0vZGlhZ3JhbXMvZGlhZ3JhbXMuY3NzYCwgfSA9IHt9KSB7XG4gICAgY29uc3QgaGVhZGVyID0gYFxuPCEtLSBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUgLS0+XG48IURPQ1RZUEUgaHRtbD5cbjxtZXRhIGNoYXJzZXQ9XCJ1dGYtOFwiPlxuPHN0eWxlPlxuICBib2R5IHtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBoc2woMzAsIDIwJSwgOTUlKVxuICB9XG48L3N0eWxlPlxuXG5gO1xuICAgIGNvbnN0IGNzc0h0bWwgPSBgXG48bGluayByZWw9J3N0eWxlc2hlZXQnIGhyZWY9JyR7Y3NzfSc+XG5gO1xuICAgIGNvbnN0IHNjcmlwdHMgPSBgXG48c2NyaXB0IHNyYz0nJHtyZXNvdXJjZUJhc2V9dmVuZG9yL3JhaWxyb2FkLWRpYWdyYW1zLmpzJz48L3NjcmlwdD5cbjxzY3JpcHQgc3JjPScke3Jlc291cmNlQmFzZX1zcmMvZGlhZ3JhbXNfYnVpbGRlci5qcyc+PC9zY3JpcHQ+XG48c2NyaXB0IHNyYz0nJHtyZXNvdXJjZUJhc2V9c3JjL2RpYWdyYW1zX2JlaGF2aW9yLmpzJz48L3NjcmlwdD5cbjxzY3JpcHQgc3JjPScke3Jlc291cmNlQmFzZX1zcmMvbWFpbi5qcyc+PC9zY3JpcHQ+XG5gO1xuICAgIGNvbnN0IGRpYWdyYW1zRGl2ID0gYFxuPGRpdiBpZD1cImRpYWdyYW1zXCIgYWxpZ249XCJjZW50ZXJcIj48L2Rpdj4gICAgXG5gO1xuICAgIGNvbnN0IHNlcmlhbGl6ZWRHcmFtbWFyID0gYFxuPHNjcmlwdD5cbiAgICB3aW5kb3cuc2VyaWFsaXplZEdyYW1tYXIgPSAke0pTT04uc3RyaW5naWZ5KGdyYW1tYXIsIG51bGwsIFwiICBcIil9O1xuPC9zY3JpcHQ+XG5gO1xuICAgIGNvbnN0IGluaXRMb2dpYyA9IGBcbjxzY3JpcHQ+XG4gICAgdmFyIGRpYWdyYW1zRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJkaWFncmFtc1wiKTtcbiAgICBtYWluLmRyYXdEaWFncmFtc0Zyb21TZXJpYWxpemVkR3JhbW1hcihzZXJpYWxpemVkR3JhbW1hciwgZGlhZ3JhbXNEaXYpO1xuPC9zY3JpcHQ+XG5gO1xuICAgIHJldHVybiAoaGVhZGVyICsgY3NzSHRtbCArIHNjcmlwdHMgKyBkaWFncmFtc0RpdiArIHNlcmlhbGl6ZWRHcmFtbWFyICsgaW5pdExvZ2ljKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlbmRlcl9wdWJsaWMuanMubWFwIiwiY29uc3QgTkFNRSA9IFwibmFtZVwiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmluZU5hbWVQcm9wKG9iaiwgbmFtZVZhbHVlKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgTkFNRSwge1xuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBuYW1lVmFsdWUsXG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sYW5nX2V4dGVuc2lvbnMuanMubWFwIiwiLy8gVE9ETzogY2FuIHRoaXMgYmUgcmVtb3ZlZD8gd2hlcmUgaXMgaXQgdXNlZD9cbmV4cG9ydCBjb25zdCBJTiA9IFwiX35JTn5fXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25zdGFudHMuanMubWFwIiwiLyoqXG4gKiBUaGlzIG5vZGVMb2NhdGlvbiB0cmFja2luZyBpcyBub3QgZWZmaWNpZW50IGFuZCBzaG91bGQgb25seSBiZSB1c2VkXG4gKiB3aGVuIGVycm9yIHJlY292ZXJ5IGlzIGVuYWJsZWQgb3IgdGhlIFRva2VuIFZlY3RvciBjb250YWlucyB2aXJ0dWFsIFRva2Vuc1xuICogKGUuZywgUHl0aG9uIEluZGVudC9PdXRkZW50KVxuICogQXMgaXQgZXhlY3V0ZXMgdGhlIGNhbGN1bGF0aW9uIGZvciBldmVyeSBzaW5nbGUgdGVybWluYWwvbm9uVGVybWluYWxcbiAqIGFuZCBkb2VzIG5vdCByZWx5IG9uIHRoZSBmYWN0IHRoZSB0b2tlbiB2ZWN0b3IgaXMgKipzb3J0ZWQqKlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldChjdXJyTm9kZUxvY2F0aW9uLCBuZXdMb2NhdGlvbkluZm8pIHtcbiAgICAvLyBGaXJzdCAodmFsaWQpIHVwZGF0ZSBmb3IgdGhpcyBjc3Qgbm9kZVxuICAgIGlmIChpc05hTihjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0KSA9PT0gdHJ1ZSkge1xuICAgICAgICAvLyBhc3N1bXB0aW9uMTogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZWl0aGVyIE5hTiBvciBhIHZhbGlkIG51bWJlclxuICAgICAgICAvLyBhc3N1bXB0aW9uMjogVG9rZW4gbG9jYXRpb24gaW5mb3JtYXRpb24gaXMgZnVsbHkgdmFsaWQgaWYgaXQgZXhpc3RcbiAgICAgICAgLy8gKGJvdGggc3RhcnQvZW5kIG9mZnNldHMgZXhpc3QgYW5kIGFyZSBudW1iZXJzKS5cbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5zdGFydE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5zdGFydE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPSBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0O1xuICAgIH1cbiAgICAvLyBPbmNlIHRoZSBzdGFydE9mZnNldCBoYXMgYmVlbiB1cGRhdGVkIHdpdGggYSB2YWxpZCBudW1iZXIgaXQgc2hvdWxkIG5ldmVyIHJlY2VpdmVcbiAgICAvLyBhbnkgZmFydGhlciB1cGRhdGVzIGFzIHRoZSBUb2tlbiB2ZWN0b3IgaXMgc29ydGVkLlxuICAgIC8vIFdlIHN0aWxsIGhhdmUgdG8gY2hlY2sgdGhpcyB0aGlzIGNvbmRpdGlvbiBmb3IgZXZlcnkgbmV3IHBvc3NpYmxlIGxvY2F0aW9uIGluZm9cbiAgICAvLyBiZWNhdXNlIHdpdGggZXJyb3IgcmVjb3ZlcnkgZW5hYmxlZCB3ZSBtYXkgZW5jb3VudGVyIGludmFsaWQgdG9rZW5zIChOYU4gbG9jYXRpb24gcHJvcHMpXG4gICAgZWxzZSBpZiAoY3Vyck5vZGVMb2NhdGlvbi5lbmRPZmZzZXQgPCBuZXdMb2NhdGlvbkluZm8uZW5kT2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICB9XG59XG4vKipcbiAqIFRoaXMgbm9kZUxvY2F0aW9uIHRyYWNraW5nIGlzIG5vdCBlZmZpY2llbnQgYW5kIHNob3VsZCBvbmx5IGJlIHVzZWRcbiAqIHdoZW4gZXJyb3IgcmVjb3ZlcnkgaXMgZW5hYmxlZCBvciB0aGUgVG9rZW4gVmVjdG9yIGNvbnRhaW5zIHZpcnR1YWwgVG9rZW5zXG4gKiAoZS5nLCBQeXRob24gSW5kZW50L091dGRlbnQpXG4gKiBBcyBpdCBleGVjdXRlcyB0aGUgY2FsY3VsYXRpb24gZm9yIGV2ZXJ5IHNpbmdsZSB0ZXJtaW5hbC9ub25UZXJtaW5hbFxuICogYW5kIGRvZXMgbm90IHJlbHkgb24gdGhlIGZhY3QgdGhlIHRva2VuIHZlY3RvciBpcyAqKnNvcnRlZCoqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXROb2RlTG9jYXRpb25GdWxsKGN1cnJOb2RlTG9jYXRpb24sIG5ld0xvY2F0aW9uSW5mbykge1xuICAgIC8vIEZpcnN0ICh2YWxpZCkgdXBkYXRlIGZvciB0aGlzIGNzdCBub2RlXG4gICAgaWYgKGlzTmFOKGN1cnJOb2RlTG9jYXRpb24uc3RhcnRPZmZzZXQpID09PSB0cnVlKSB7XG4gICAgICAgIC8vIGFzc3VtcHRpb24xOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBlaXRoZXIgTmFOIG9yIGEgdmFsaWQgbnVtYmVyXG4gICAgICAgIC8vIGFzc3VtcHRpb24yOiBUb2tlbiBsb2NhdGlvbiBpbmZvcm1hdGlvbiBpcyBmdWxseSB2YWxpZCBpZiBpdCBleGlzdFxuICAgICAgICAvLyAoYWxsIHN0YXJ0L2VuZCBwcm9wcyBleGlzdCBhbmQgYXJlIG51bWJlcnMpLlxuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0T2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0T2Zmc2V0O1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0Q29sdW1uID0gbmV3TG9jYXRpb25JbmZvLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLnN0YXJ0TGluZSA9IG5ld0xvY2F0aW9uSW5mby5zdGFydExpbmU7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0ID0gbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldDtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRDb2x1bW4gPSBuZXdMb2NhdGlvbkluZm8uZW5kQ29sdW1uO1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZExpbmUgPSBuZXdMb2NhdGlvbkluZm8uZW5kTGluZTtcbiAgICB9XG4gICAgLy8gT25jZSB0aGUgc3RhcnQgcHJvcHMgaGFzIGJlZW4gdXBkYXRlZCB3aXRoIGEgdmFsaWQgbnVtYmVyIGl0IHNob3VsZCBuZXZlciByZWNlaXZlXG4gICAgLy8gYW55IGZhcnRoZXIgdXBkYXRlcyBhcyB0aGUgVG9rZW4gdmVjdG9yIGlzIHNvcnRlZC5cbiAgICAvLyBXZSBzdGlsbCBoYXZlIHRvIGNoZWNrIHRoaXMgdGhpcyBjb25kaXRpb24gZm9yIGV2ZXJ5IG5ldyBwb3NzaWJsZSBsb2NhdGlvbiBpbmZvXG4gICAgLy8gYmVjYXVzZSB3aXRoIGVycm9yIHJlY292ZXJ5IGVuYWJsZWQgd2UgbWF5IGVuY291bnRlciBpbnZhbGlkIHRva2VucyAoTmFOIGxvY2F0aW9uIHByb3BzKVxuICAgIGVsc2UgaWYgKGN1cnJOb2RlTG9jYXRpb24uZW5kT2Zmc2V0IDwgbmV3TG9jYXRpb25JbmZvLmVuZE9mZnNldCA9PT0gdHJ1ZSkge1xuICAgICAgICBjdXJyTm9kZUxvY2F0aW9uLmVuZE9mZnNldCA9IG5ld0xvY2F0aW9uSW5mby5lbmRPZmZzZXQ7XG4gICAgICAgIGN1cnJOb2RlTG9jYXRpb24uZW5kQ29sdW1uID0gbmV3TG9jYXRpb25JbmZvLmVuZENvbHVtbjtcbiAgICAgICAgY3Vyck5vZGVMb2NhdGlvbi5lbmRMaW5lID0gbmV3TG9jYXRpb25JbmZvLmVuZExpbmU7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFRlcm1pbmFsVG9Dc3Qobm9kZSwgdG9rZW4sIHRva2VuVHlwZU5hbWUpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bdG9rZW5UeXBlTmFtZV0gPSBbdG9rZW5dO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbm9kZS5jaGlsZHJlblt0b2tlblR5cGVOYW1lXS5wdXNoKHRva2VuKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkTm9uZVRlcm1pbmFsVG9Dc3Qobm9kZSwgcnVsZU5hbWUsIHJ1bGVSZXN1bHQpIHtcbiAgICBpZiAobm9kZS5jaGlsZHJlbltydWxlTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBub2RlLmNoaWxkcmVuW3J1bGVOYW1lXSA9IFtydWxlUmVzdWx0XTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGRyZW5bcnVsZU5hbWVdLnB1c2gocnVsZVJlc3VsdCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0LmpzLm1hcCIsImltcG9ydCB7IGNvbXBhY3QsIGZpbHRlciwgZm9yRWFjaCwgaXNBcnJheSwgaXNFbXB0eSwgaXNGdW5jdGlvbiwgaXNVbmRlZmluZWQsIGtleXMsIG1hcCwgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBkZWZpbmVOYW1lUHJvcCB9IGZyb20gXCIuLi8uLi9sYW5nL2xhbmdfZXh0ZW5zaW9ucy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlZmF1bHRWaXNpdChjdHgsIHBhcmFtKSB7XG4gICAgY29uc3QgY2hpbGRyZW5OYW1lcyA9IGtleXMoY3R4KTtcbiAgICBjb25zdCBjaGlsZHJlbk5hbWVzTGVuZ3RoID0gY2hpbGRyZW5OYW1lcy5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjaGlsZHJlbk5hbWVzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY3VyckNoaWxkTmFtZSA9IGNoaWxkcmVuTmFtZXNbaV07XG4gICAgICAgIGNvbnN0IGN1cnJDaGlsZEFycmF5ID0gY3R4W2N1cnJDaGlsZE5hbWVdO1xuICAgICAgICBjb25zdCBjdXJyQ2hpbGRBcnJheUxlbmd0aCA9IGN1cnJDaGlsZEFycmF5Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyQ2hpbGRBcnJheUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjdXJyQ2hpbGQgPSBjdXJyQ2hpbGRBcnJheVtqXTtcbiAgICAgICAgICAgIC8vIGRpc3RpbmN0aW9uIGJldHdlZW4gVG9rZW5zIENoaWxkcmVuIGFuZCBDc3ROb2RlIGNoaWxkcmVuXG4gICAgICAgICAgICBpZiAoY3VyckNoaWxkLnRva2VuVHlwZUlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tjdXJyQ2hpbGQubmFtZV0oY3VyckNoaWxkLmNoaWxkcmVuLCBwYXJhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZGVmYXVsdFZpc2l0IGRvZXMgbm90IHN1cHBvcnQgZ2VuZXJpYyBvdXQgcGFyYW1cbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IoZ3JhbW1hck5hbWUsIHJ1bGVOYW1lcykge1xuICAgIGNvbnN0IGRlcml2ZWRDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICAvLyBjYW4gYmUgb3ZlcndyaXR0ZW4gYWNjb3JkaW5nIHRvOlxuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0Z1bmN0aW9uL1xuICAgIC8vIG5hbWU/cmVkaXJlY3Rsb2NhbGU9ZW4tVVMmcmVkaXJlY3RzbHVnPUphdmFTY3JpcHQlMkZSZWZlcmVuY2UlMkZHbG9iYWxfT2JqZWN0cyUyRkZ1bmN0aW9uJTJGbmFtZVxuICAgIGRlZmluZU5hbWVQcm9wKGRlcml2ZWRDb25zdHJ1Y3RvciwgZ3JhbW1hck5hbWUgKyBcIkJhc2VTZW1hbnRpY3NcIik7XG4gICAgY29uc3Qgc2VtYW50aWNQcm90byA9IHtcbiAgICAgICAgdmlzaXQ6IGZ1bmN0aW9uIChjc3ROb2RlLCBwYXJhbSkge1xuICAgICAgICAgICAgLy8gZW5hYmxlcyB3cml0aW5nIG1vcmUgY29uY2lzZSB2aXNpdG9yIG1ldGhvZHMgd2hlbiBDc3ROb2RlIGhhcyBvbmx5IGEgc2luZ2xlIGNoaWxkXG4gICAgICAgICAgICBpZiAoaXNBcnJheShjc3ROb2RlKSkge1xuICAgICAgICAgICAgICAgIC8vIEEgQ1NUIE5vZGUncyBjaGlsZHJlbiBkaWN0aW9uYXJ5IGNhbiBuZXZlciBoYXZlIGVtcHR5IGFycmF5cyBhcyB2YWx1ZXNcbiAgICAgICAgICAgICAgICAvLyBJZiBhIGtleSBpcyBkZWZpbmVkIHRoZXJlIHdpbGwgYmUgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgYXJyYXkuXG4gICAgICAgICAgICAgICAgY3N0Tm9kZSA9IGNzdE5vZGVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbmFibGVzIHBhc3Npbmcgb3B0aW9uYWwgQ3N0Tm9kZXMgY29uY2lzZWx5LlxuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzW2NzdE5vZGUubmFtZV0oY3N0Tm9kZS5jaGlsZHJlbiwgcGFyYW0pO1xuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0ZVZpc2l0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbWFudGljRGVmaW5pdGlvbkVycm9ycyA9IHZhbGlkYXRlVmlzaXRvcih0aGlzLCBydWxlTmFtZXMpO1xuICAgICAgICAgICAgaWYgKCFpc0VtcHR5KHNlbWFudGljRGVmaW5pdGlvbkVycm9ycykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2VzID0gbWFwKHNlbWFudGljRGVmaW5pdGlvbkVycm9ycywgKGN1cnJEZWZFcnJvcikgPT4gY3VyckRlZkVycm9yLm1zZyk7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYEVycm9ycyBEZXRlY3RlZCBpbiBDU1QgVmlzaXRvciA8JHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9PjpcXG5cXHRgICtcbiAgICAgICAgICAgICAgICAgICAgYCR7ZXJyb3JNZXNzYWdlcy5qb2luKFwiXFxuXFxuXCIpLnJlcGxhY2UoL1xcbi9nLCBcIlxcblxcdFwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBzZW1hbnRpY1Byb3RvO1xuICAgIGRlcml2ZWRDb25zdHJ1Y3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBkZXJpdmVkQ29uc3RydWN0b3I7XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLl9SVUxFX05BTUVTID0gcnVsZU5hbWVzO1xuICAgIHJldHVybiBkZXJpdmVkQ29uc3RydWN0b3I7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQmFzZVZpc2l0b3JDb25zdHJ1Y3RvcldpdGhEZWZhdWx0cyhncmFtbWFyTmFtZSwgcnVsZU5hbWVzLCBiYXNlQ29uc3RydWN0b3IpIHtcbiAgICBjb25zdCBkZXJpdmVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgLy8gY2FuIGJlIG92ZXJ3cml0dGVuIGFjY29yZGluZyB0bzpcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9GdW5jdGlvbi9cbiAgICAvLyBuYW1lP3JlZGlyZWN0bG9jYWxlPWVuLVVTJnJlZGlyZWN0c2x1Zz1KYXZhU2NyaXB0JTJGUmVmZXJlbmNlJTJGR2xvYmFsX09iamVjdHMlMkZGdW5jdGlvbiUyRm5hbWVcbiAgICBkZWZpbmVOYW1lUHJvcChkZXJpdmVkQ29uc3RydWN0b3IsIGdyYW1tYXJOYW1lICsgXCJCYXNlU2VtYW50aWNzV2l0aERlZmF1bHRzXCIpO1xuICAgIGNvbnN0IHdpdGhEZWZhdWx0c1Byb3RvID0gT2JqZWN0LmNyZWF0ZShiYXNlQ29uc3RydWN0b3IucHJvdG90eXBlKTtcbiAgICBmb3JFYWNoKHJ1bGVOYW1lcywgKHJ1bGVOYW1lKSA9PiB7XG4gICAgICAgIHdpdGhEZWZhdWx0c1Byb3RvW3J1bGVOYW1lXSA9IGRlZmF1bHRWaXNpdDtcbiAgICB9KTtcbiAgICBkZXJpdmVkQ29uc3RydWN0b3IucHJvdG90eXBlID0gd2l0aERlZmF1bHRzUHJvdG87XG4gICAgZGVyaXZlZENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGRlcml2ZWRDb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gZGVyaXZlZENvbnN0cnVjdG9yO1xufVxuZXhwb3J0IHZhciBDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yO1xuKGZ1bmN0aW9uIChDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yKSB7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiUkVEVU5EQU5UX01FVEhPRFwiXSA9IDBdID0gXCJSRURVTkRBTlRfTUVUSE9EXCI7XG4gICAgQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvcltDc3RWaXNpdG9yRGVmaW5pdGlvbkVycm9yW1wiTUlTU0lOR19NRVRIT0RcIl0gPSAxXSA9IFwiTUlTU0lOR19NRVRIT0RcIjtcbn0pKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgfHwgKENzdFZpc2l0b3JEZWZpbml0aW9uRXJyb3IgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVmlzaXRvcih2aXNpdG9ySW5zdGFuY2UsIHJ1bGVOYW1lcykge1xuICAgIGNvbnN0IG1pc3NpbmdFcnJvcnMgPSB2YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzKHZpc2l0b3JJbnN0YW5jZSwgcnVsZU5hbWVzKTtcbiAgICByZXR1cm4gbWlzc2luZ0Vycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU1pc3NpbmdDc3RNZXRob2RzKHZpc2l0b3JJbnN0YW5jZSwgcnVsZU5hbWVzKSB7XG4gICAgY29uc3QgbWlzc2luZ1J1bGVOYW1lcyA9IGZpbHRlcihydWxlTmFtZXMsIChjdXJyUnVsZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIGlzRnVuY3Rpb24odmlzaXRvckluc3RhbmNlW2N1cnJSdWxlTmFtZV0pID09PSBmYWxzZTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAobWlzc2luZ1J1bGVOYW1lcywgKGN1cnJSdWxlTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbXNnOiBgTWlzc2luZyB2aXNpdG9yIG1ldGhvZDogPCR7Y3VyclJ1bGVOYW1lfT4gb24gJHsodmlzaXRvckluc3RhbmNlLmNvbnN0cnVjdG9yLm5hbWUpfSBDU1QgVmlzaXRvci5gLFxuICAgICAgICAgICAgdHlwZTogQ3N0VmlzaXRvckRlZmluaXRpb25FcnJvci5NSVNTSU5HX01FVEhPRCxcbiAgICAgICAgICAgIG1ldGhvZE5hbWU6IGN1cnJSdWxlTmFtZSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29tcGFjdChlcnJvcnMpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y3N0X3Zpc2l0b3IuanMubWFwIiwiaW1wb3J0IHsgaGFzVG9rZW5MYWJlbCwgdG9rZW5MYWJlbCB9IGZyb20gXCIuLi9zY2FuL3Rva2Vuc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IGZpcnN0LCBtYXAsIHJlZHVjZSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IGdldFByb2R1Y3Rpb25Ec2xOYW1lLCBOb25UZXJtaW5hbCwgUnVsZSwgVGVybWluYWwsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmV4cG9ydCBjb25zdCBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciA9IHtcbiAgICBidWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHsgZXhwZWN0ZWQsIGFjdHVhbCwgcHJldmlvdXMsIHJ1bGVOYW1lIH0pIHtcbiAgICAgICAgY29uc3QgaGFzTGFiZWwgPSBoYXNUb2tlbkxhYmVsKGV4cGVjdGVkKTtcbiAgICAgICAgY29uc3QgZXhwZWN0ZWRNc2cgPSBoYXNMYWJlbFxuICAgICAgICAgICAgPyBgLS0+ICR7dG9rZW5MYWJlbChleHBlY3RlZCl9IDwtLWBcbiAgICAgICAgICAgIDogYHRva2VuIG9mIHR5cGUgLS0+ICR7ZXhwZWN0ZWQubmFtZX0gPC0tYDtcbiAgICAgICAgY29uc3QgbXNnID0gYEV4cGVjdGluZyAke2V4cGVjdGVkTXNnfSBidXQgZm91bmQgLS0+ICcke2FjdHVhbC5pbWFnZX0nIDwtLWA7XG4gICAgICAgIHJldHVybiBtc2c7XG4gICAgfSxcbiAgICBidWlsZE5vdEFsbElucHV0UGFyc2VkTWVzc2FnZSh7IGZpcnN0UmVkdW5kYW50LCBydWxlTmFtZSB9KSB7XG4gICAgICAgIHJldHVybiBcIlJlZHVuZGFudCBpbnB1dCwgZXhwZWN0aW5nIEVPRiBidXQgZm91bmQ6IFwiICsgZmlyc3RSZWR1bmRhbnQuaW1hZ2U7XG4gICAgfSxcbiAgICBidWlsZE5vVmlhYmxlQWx0TWVzc2FnZSh7IGV4cGVjdGVkUGF0aHNQZXJBbHQsIGFjdHVhbCwgcHJldmlvdXMsIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiwgcnVsZU5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgZXJyUHJlZml4ID0gXCJFeHBlY3Rpbmc6IFwiO1xuICAgICAgICAvLyBUT0RPOiBpc3N1ZTogTm8gVmlhYmxlIEFsdGVybmF0aXZlIEVycm9yIG1heSBoYXZlIGluY29tcGxldGUgZGV0YWlscy4gIzUwMlxuICAgICAgICBjb25zdCBhY3R1YWxUZXh0ID0gZmlyc3QoYWN0dWFsKS5pbWFnZTtcbiAgICAgICAgY29uc3QgZXJyU3VmZml4ID0gXCJcXG5idXQgZm91bmQ6ICdcIiArIGFjdHVhbFRleHQgKyBcIidcIjtcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbExvb2tBaGVhZFBhdGhzID0gcmVkdWNlKGV4cGVjdGVkUGF0aHNQZXJBbHQsIChyZXN1bHQsIGN1cnJBbHRQYXRocykgPT4gcmVzdWx0LmNvbmNhdChjdXJyQWx0UGF0aHMpLCBbXSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0VmFsaWRUb2tlblNlcXVlbmNlcyA9IG1hcChhbGxMb29rQWhlYWRQYXRocywgKGN1cnJQYXRoKSA9PiBgWyR7bWFwKGN1cnJQYXRoLCAoY3VyclRva2VuVHlwZSkgPT4gdG9rZW5MYWJlbChjdXJyVG9rZW5UeXBlKSkuam9pbihcIiwgXCIpfV1gKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRWYWxpZFNlcXVlbmNlSXRlbXMgPSBtYXAobmV4dFZhbGlkVG9rZW5TZXF1ZW5jZXMsIChpdGVtTXNnLCBpZHgpID0+IGAgICR7aWR4ICsgMX0uICR7aXRlbU1zZ31gKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWREZXNjcmlwdGlvbiA9IGBvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOlxcbiR7bmV4dFZhbGlkU2VxdWVuY2VJdGVtcy5qb2luKFwiXFxuXCIpfWA7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY2FsY3VsYXRlZERlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgfSxcbiAgICBidWlsZEVhcmx5RXhpdE1lc3NhZ2UoeyBleHBlY3RlZEl0ZXJhdGlvblBhdGhzLCBhY3R1YWwsIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiwgcnVsZU5hbWUsIH0pIHtcbiAgICAgICAgY29uc3QgZXJyUHJlZml4ID0gXCJFeHBlY3Rpbmc6IFwiO1xuICAgICAgICAvLyBUT0RPOiBpc3N1ZTogTm8gVmlhYmxlIEFsdGVybmF0aXZlIEVycm9yIG1heSBoYXZlIGluY29tcGxldGUgZGV0YWlscy4gIzUwMlxuICAgICAgICBjb25zdCBhY3R1YWxUZXh0ID0gZmlyc3QoYWN0dWFsKS5pbWFnZTtcbiAgICAgICAgY29uc3QgZXJyU3VmZml4ID0gXCJcXG5idXQgZm91bmQ6ICdcIiArIGFjdHVhbFRleHQgKyBcIidcIjtcbiAgICAgICAgaWYgKGN1c3RvbVVzZXJEZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIGVyclByZWZpeCArIGN1c3RvbVVzZXJEZXNjcmlwdGlvbiArIGVyclN1ZmZpeDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRWYWxpZFRva2VuU2VxdWVuY2VzID0gbWFwKGV4cGVjdGVkSXRlcmF0aW9uUGF0aHMsIChjdXJyUGF0aCkgPT4gYFske21hcChjdXJyUGF0aCwgKGN1cnJUb2tlblR5cGUpID0+IHRva2VuTGFiZWwoY3VyclRva2VuVHlwZSkpLmpvaW4oXCIsXCIpfV1gKTtcbiAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWREZXNjcmlwdGlvbiA9IGBleHBlY3RpbmcgYXQgbGVhc3Qgb25lIGl0ZXJhdGlvbiB3aGljaCBzdGFydHMgd2l0aCBvbmUgb2YgdGhlc2UgcG9zc2libGUgVG9rZW4gc2VxdWVuY2VzOjpcXG4gIGAgK1xuICAgICAgICAgICAgICAgIGA8JHtuZXh0VmFsaWRUb2tlblNlcXVlbmNlcy5qb2luKFwiICxcIil9PmA7XG4gICAgICAgICAgICByZXR1cm4gZXJyUHJlZml4ICsgY2FsY3VsYXRlZERlc2NyaXB0aW9uICsgZXJyU3VmZml4O1xuICAgICAgICB9XG4gICAgfSxcbn07XG5PYmplY3QuZnJlZXplKGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyKTtcbmV4cG9ydCBjb25zdCBkZWZhdWx0R3JhbW1hclJlc29sdmVyRXJyb3JQcm92aWRlciA9IHtcbiAgICBidWlsZFJ1bGVOb3RGb3VuZEVycm9yKHRvcExldmVsUnVsZSwgdW5kZWZpbmVkUnVsZSkge1xuICAgICAgICBjb25zdCBtc2cgPSBcIkludmFsaWQgZ3JhbW1hciwgcmVmZXJlbmNlIHRvIGEgcnVsZSB3aGljaCBpcyBub3QgZGVmaW5lZDogLT5cIiArXG4gICAgICAgICAgICB1bmRlZmluZWRSdWxlLm5vblRlcm1pbmFsTmFtZSArXG4gICAgICAgICAgICBcIjwtXFxuXCIgK1xuICAgICAgICAgICAgXCJpbnNpZGUgdG9wIGxldmVsIHJ1bGU6IC0+XCIgK1xuICAgICAgICAgICAgdG9wTGV2ZWxSdWxlLm5hbWUgK1xuICAgICAgICAgICAgXCI8LVwiO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH0sXG59O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciA9IHtcbiAgICBidWlsZER1cGxpY2F0ZUZvdW5kRXJyb3IodG9wTGV2ZWxSdWxlLCBkdXBsaWNhdGVQcm9kcykge1xuICAgICAgICBmdW5jdGlvbiBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChwcm9kKSB7XG4gICAgICAgICAgICBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb2QudGVybWluYWxUeXBlLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvZC5ub25UZXJtaW5hbE5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BMZXZlbE5hbWUgPSB0b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgY29uc3QgZHVwbGljYXRlUHJvZCA9IGZpcnN0KGR1cGxpY2F0ZVByb2RzKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBkdXBsaWNhdGVQcm9kLmlkeDtcbiAgICAgICAgY29uc3QgZHNsTmFtZSA9IGdldFByb2R1Y3Rpb25Ec2xOYW1lKGR1cGxpY2F0ZVByb2QpO1xuICAgICAgICBjb25zdCBleHRyYUFyZ3VtZW50ID0gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQoZHVwbGljYXRlUHJvZCk7XG4gICAgICAgIGNvbnN0IGhhc0V4cGxpY2l0SW5kZXggPSBpbmRleCA+IDA7XG4gICAgICAgIGxldCBtc2cgPSBgLT4ke2RzbE5hbWV9JHtoYXNFeHBsaWNpdEluZGV4ID8gaW5kZXggOiBcIlwifTwtICR7ZXh0cmFBcmd1bWVudCA/IGB3aXRoIGFyZ3VtZW50OiAtPiR7ZXh0cmFBcmd1bWVudH08LWAgOiBcIlwifVxuICAgICAgICAgICAgICAgICAgYXBwZWFycyBtb3JlIHRoYW4gb25jZSAoJHtkdXBsaWNhdGVQcm9kcy5sZW5ndGh9IHRpbWVzKSBpbiB0aGUgdG9wIGxldmVsIHJ1bGU6IC0+JHt0b3BMZXZlbE5hbWV9PC0uICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICBGb3IgZnVydGhlciBkZXRhaWxzIHNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvRkFRLmh0bWwjTlVNRVJJQ0FMX1NVRkZJWEVTIFxuICAgICAgICAgICAgICAgICAgYDtcbiAgICAgICAgLy8gd2hpdGUgc3BhY2UgdHJpbW1pbmcgdGltZSEgYmV0dGVyIHRvIHRyaW0gYWZ0ZXJ3YXJkcyBhcyBpdCBhbGxvd3MgdG8gdXNlIFdFTEwgZm9ybWF0dGVkIG11bHRpIGxpbmUgdGVtcGxhdGUgc3RyaW5ncy4uLlxuICAgICAgICBtc2cgPSBtc2cucmVwbGFjZSgvWyBcXHRdKy9nLCBcIiBcIik7XG4gICAgICAgIG1zZyA9IG1zZy5yZXBsYWNlKC9cXHNcXHMrL2csIFwiXFxuXCIpO1xuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH0sXG4gICAgYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yKHJ1bGUpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gYE5hbWVzcGFjZSBjb25mbGljdCBmb3VuZCBpbiBncmFtbWFyLlxcbmAgK1xuICAgICAgICAgICAgYFRoZSBncmFtbWFyIGhhcyBib3RoIGEgVGVybWluYWwoVG9rZW4pIGFuZCBhIE5vbi1UZXJtaW5hbChSdWxlKSBuYW1lZDogPCR7cnVsZS5uYW1lfT4uXFxuYCArXG4gICAgICAgICAgICBgVG8gcmVzb2x2ZSB0aGlzIG1ha2Ugc3VyZSBlYWNoIFRlcm1pbmFsIGFuZCBOb24tVGVybWluYWwgbmFtZXMgYXJlIHVuaXF1ZVxcbmAgK1xuICAgICAgICAgICAgYFRoaXMgaXMgZWFzeSB0byBhY2NvbXBsaXNoIGJ5IHVzaW5nIHRoZSBjb252ZW50aW9uIHRoYXQgVGVybWluYWwgbmFtZXMgc3RhcnQgd2l0aCBhbiB1cHBlcmNhc2UgbGV0dGVyXFxuYCArXG4gICAgICAgICAgICBgYW5kIE5vbi1UZXJtaW5hbCBuYW1lcyBzdGFydCB3aXRoIGEgbG93ZXIgY2FzZSBsZXR0ZXIuYDtcbiAgICAgICAgcmV0dXJuIGVyck1zZztcbiAgICB9LFxuICAgIGJ1aWxkQWx0ZXJuYXRpb25QcmVmaXhBbWJpZ3VpdHlFcnJvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHBhdGhNc2cgPSBtYXAob3B0aW9ucy5wcmVmaXhQYXRoLCAoY3VyclRvaykgPT4gdG9rZW5MYWJlbChjdXJyVG9rKSkuam9pbihcIiwgXCIpO1xuICAgICAgICBjb25zdCBvY2N1cnJlbmNlID0gb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHggPT09IDAgPyBcIlwiIDogb3B0aW9ucy5hbHRlcm5hdGlvbi5pZHg7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBBbWJpZ3VvdXMgYWx0ZXJuYXRpdmVzOiA8JHtvcHRpb25zLmFtYmlndWl0eUluZGljZXMuam9pbihcIiAsXCIpfT4gZHVlIHRvIGNvbW1vbiBsb29rYWhlYWQgcHJlZml4XFxuYCArXG4gICAgICAgICAgICBgaW4gPE9SJHtvY2N1cnJlbmNlfT4gaW5zaWRlIDwke29wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWV9PiBSdWxlLFxcbmAgK1xuICAgICAgICAgICAgYDwke3BhdGhNc2d9PiBtYXkgYXBwZWFycyBhcyBhIHByZWZpeCBwYXRoIGluIGFsbCB0aGVzZSBhbHRlcm5hdGl2ZXMuXFxuYCArXG4gICAgICAgICAgICBgU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfZ3JhbW1hcl9lcnJvcnMuaHRtbCNDT01NT05fUFJFRklYXFxuYCArXG4gICAgICAgICAgICBgRm9yIEZ1cnRoZXIgZGV0YWlscy5gO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgYnVpbGRBbHRlcm5hdGlvbkFtYmlndWl0eUVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcGF0aE1zZyA9IG1hcChvcHRpb25zLnByZWZpeFBhdGgsIChjdXJydG9rKSA9PiB0b2tlbkxhYmVsKGN1cnJ0b2spKS5qb2luKFwiLCBcIik7XG4gICAgICAgIGNvbnN0IG9jY3VycmVuY2UgPSBvcHRpb25zLmFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBvcHRpb25zLmFsdGVybmF0aW9uLmlkeDtcbiAgICAgICAgbGV0IGN1cnJNZXNzYWdlID0gYEFtYmlndW91cyBBbHRlcm5hdGl2ZXMgRGV0ZWN0ZWQ6IDwke29wdGlvbnMuYW1iaWd1aXR5SW5kaWNlcy5qb2luKFwiICxcIil9PiBpbiA8T1Ike29jY3VycmVuY2V9PmAgK1xuICAgICAgICAgICAgYCBpbnNpZGUgPCR7b3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZX0+IFJ1bGUsXFxuYCArXG4gICAgICAgICAgICBgPCR7cGF0aE1zZ30+IG1heSBhcHBlYXJzIGFzIGEgcHJlZml4IHBhdGggaW4gYWxsIHRoZXNlIGFsdGVybmF0aXZlcy5cXG5gO1xuICAgICAgICBjdXJyTWVzc2FnZSA9XG4gICAgICAgICAgICBjdXJyTWVzc2FnZSArXG4gICAgICAgICAgICAgICAgYFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjQU1CSUdVT1VTX0FMVEVSTkFUSVZFU1xcbmAgK1xuICAgICAgICAgICAgICAgIGBGb3IgRnVydGhlciBkZXRhaWxzLmA7XG4gICAgICAgIHJldHVybiBjdXJyTWVzc2FnZTtcbiAgICB9LFxuICAgIGJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3Iob3B0aW9ucykge1xuICAgICAgICBsZXQgZHNsTmFtZSA9IGdldFByb2R1Y3Rpb25Ec2xOYW1lKG9wdGlvbnMucmVwZXRpdGlvbik7XG4gICAgICAgIGlmIChvcHRpb25zLnJlcGV0aXRpb24uaWR4ICE9PSAwKSB7XG4gICAgICAgICAgICBkc2xOYW1lICs9IG9wdGlvbnMucmVwZXRpdGlvbi5pZHg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyTXNnID0gYFRoZSByZXBldGl0aW9uIDwke2RzbE5hbWV9PiB3aXRoaW4gUnVsZSA8JHtvcHRpb25zLnRvcExldmVsUnVsZS5uYW1lfT4gY2FuIG5ldmVyIGNvbnN1bWUgYW55IHRva2Vucy5cXG5gICtcbiAgICAgICAgICAgIGBUaGlzIGNvdWxkIGxlYWQgdG8gYW4gaW5maW5pdGUgbG9vcC5gO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG4gICAgLy8gVE9ETzogcmVtb3ZlIC0gYGVycm9yc19wdWJsaWNgIGZyb20gbnljLmNvbmZpZy5qcyBleGNsdWRlXG4gICAgLy8gICAgICAgb25jZSB0aGlzIG1ldGhvZCBpcyBmdWxseSByZW1vdmVkIGZyb20gdGhpcyBmaWxlXG4gICAgYnVpbGRUb2tlbk5hbWVFcnJvcihvcHRpb25zKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBcImRlcHJlY2F0ZWRcIjtcbiAgICB9LFxuICAgIGJ1aWxkRW1wdHlBbHRlcm5hdGlvbkVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZXJyTXNnID0gYEFtYmlndW91cyBlbXB0eSBhbHRlcm5hdGl2ZTogPCR7b3B0aW9ucy5lbXB0eUNob2ljZUlkeCArIDF9PmAgK1xuICAgICAgICAgICAgYCBpbiA8T1Ike29wdGlvbnMuYWx0ZXJuYXRpb24uaWR4fT4gaW5zaWRlIDwke29wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWV9PiBSdWxlLlxcbmAgK1xuICAgICAgICAgICAgYE9ubHkgdGhlIGxhc3QgYWx0ZXJuYXRpdmUgbWF5IGJlIGFuIGVtcHR5IGFsdGVybmF0aXZlLmA7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZFRvb01hbnlBbHRlcm5hdGl2ZXNFcnJvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBBbiBBbHRlcm5hdGlvbiBjYW5ub3QgaGF2ZSBtb3JlIHRoYW4gMjU2IGFsdGVybmF0aXZlczpcXG5gICtcbiAgICAgICAgICAgIGA8T1Ike29wdGlvbnMuYWx0ZXJuYXRpb24uaWR4fT4gaW5zaWRlIDwke29wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWV9PiBSdWxlLlxcbiBoYXMgJHtvcHRpb25zLmFsdGVybmF0aW9uLmRlZmluaXRpb24ubGVuZ3RoICsgMX0gYWx0ZXJuYXRpdmVzLmA7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICBidWlsZExlZnRSZWN1cnNpb25FcnJvcihvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVOYW1lID0gb3B0aW9ucy50b3BMZXZlbFJ1bGUubmFtZTtcbiAgICAgICAgY29uc3QgcGF0aE5hbWVzID0gbWFwKG9wdGlvbnMubGVmdFJlY3Vyc2lvblBhdGgsIChjdXJyUnVsZSkgPT4gY3VyclJ1bGUubmFtZSk7XG4gICAgICAgIGNvbnN0IGxlZnRSZWN1cnNpdmVQYXRoID0gYCR7cnVsZU5hbWV9IC0tPiAke3BhdGhOYW1lc1xuICAgICAgICAgICAgLmNvbmNhdChbcnVsZU5hbWVdKVxuICAgICAgICAgICAgLmpvaW4oXCIgLS0+IFwiKX1gO1xuICAgICAgICBjb25zdCBlcnJNc2cgPSBgTGVmdCBSZWN1cnNpb24gZm91bmQgaW4gZ3JhbW1hci5cXG5gICtcbiAgICAgICAgICAgIGBydWxlOiA8JHtydWxlTmFtZX0+IGNhbiBiZSBpbnZva2VkIGZyb20gaXRzZWxmIChkaXJlY3RseSBvciBpbmRpcmVjdGx5KVxcbmAgK1xuICAgICAgICAgICAgYHdpdGhvdXQgY29uc3VtaW5nIGFueSBUb2tlbnMuIFRoZSBncmFtbWFyIHBhdGggdGhhdCBjYXVzZXMgdGhpcyBpczogXFxuICR7bGVmdFJlY3Vyc2l2ZVBhdGh9XFxuYCArXG4gICAgICAgICAgICBgIFRvIGZpeCB0aGlzIHJlZmFjdG9yIHlvdXIgZ3JhbW1hciB0byByZW1vdmUgdGhlIGxlZnQgcmVjdXJzaW9uLlxcbmAgK1xuICAgICAgICAgICAgYHNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTExfcGFyc2VyI0xlZnRfZmFjdG9yaW5nLmA7XG4gICAgICAgIHJldHVybiBlcnJNc2c7XG4gICAgfSxcbiAgICAvLyBUT0RPOiByZW1vdmUgLSBgZXJyb3JzX3B1YmxpY2AgZnJvbSBueWMuY29uZmlnLmpzIGV4Y2x1ZGVcbiAgICAvLyAgICAgICBvbmNlIHRoaXMgbWV0aG9kIGlzIGZ1bGx5IHJlbW92ZWQgZnJvbSB0aGlzIGZpbGVcbiAgICBidWlsZEludmFsaWRSdWxlTmFtZUVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgcmV0dXJuIFwiZGVwcmVjYXRlZFwiO1xuICAgIH0sXG4gICAgYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHJ1bGVOYW1lO1xuICAgICAgICBpZiAob3B0aW9ucy50b3BMZXZlbFJ1bGUgaW5zdGFuY2VvZiBSdWxlKSB7XG4gICAgICAgICAgICBydWxlTmFtZSA9IG9wdGlvbnMudG9wTGV2ZWxSdWxlLm5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBydWxlTmFtZSA9IG9wdGlvbnMudG9wTGV2ZWxSdWxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGBEdXBsaWNhdGUgZGVmaW5pdGlvbiwgcnVsZTogLT4ke3J1bGVOYW1lfTwtIGlzIGFscmVhZHkgZGVmaW5lZCBpbiB0aGUgZ3JhbW1hcjogLT4ke29wdGlvbnMuZ3JhbW1hck5hbWV9PC1gO1xuICAgICAgICByZXR1cm4gZXJyTXNnO1xuICAgIH0sXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JzX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBpbmNsdWRlcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmNvbnN0IE1JU01BVENIRURfVE9LRU5fRVhDRVBUSU9OID0gXCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIjtcbmNvbnN0IE5PX1ZJQUJMRV9BTFRfRVhDRVBUSU9OID0gXCJOb1ZpYWJsZUFsdEV4Y2VwdGlvblwiO1xuY29uc3QgRUFSTFlfRVhJVF9FWENFUFRJT04gPSBcIkVhcmx5RXhpdEV4Y2VwdGlvblwiO1xuY29uc3QgTk9UX0FMTF9JTlBVVF9QQVJTRURfRVhDRVBUSU9OID0gXCJOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvblwiO1xuY29uc3QgUkVDT0dOSVRJT05fRVhDRVBUSU9OX05BTUVTID0gW1xuICAgIE1JU01BVENIRURfVE9LRU5fRVhDRVBUSU9OLFxuICAgIE5PX1ZJQUJMRV9BTFRfRVhDRVBUSU9OLFxuICAgIEVBUkxZX0VYSVRfRVhDRVBUSU9OLFxuICAgIE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTixcbl07XG5PYmplY3QuZnJlZXplKFJFQ09HTklUSU9OX0VYQ0VQVElPTl9OQU1FUyk7XG4vLyBoYWNrcyB0byBieXBhc3Mgbm8gc3VwcG9ydCBmb3IgY3VzdG9tIEVycm9ycyBpbiBqYXZhc2NyaXB0L3R5cGVzY3JpcHRcbmV4cG9ydCBmdW5jdGlvbiBpc1JlY29nbml0aW9uRXhjZXB0aW9uKGVycm9yKSB7XG4gICAgLy8gY2FuJ3QgZG8gaW5zdGFuY2VvZiBvbiBoYWNrZWQgY3VzdG9tIGpzIGV4Y2VwdGlvbnNcbiAgICByZXR1cm4gaW5jbHVkZXMoUkVDT0dOSVRJT05fRVhDRVBUSU9OX05BTUVTLCBlcnJvci5uYW1lKTtcbn1cbmNsYXNzIFJlY29nbml0aW9uRXhjZXB0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHRva2VuKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMucmVzeW5jZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgLy8gZml4IHByb3RvdHlwZSBjaGFpbiB3aGVuIHR5cGVzY3JpcHQgdGFyZ2V0IGlzIEVTNVxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgbmV3LnRhcmdldC5wcm90b3R5cGUpO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIFY4IHdvcmthcm91bmQgdG8gcmVtb3ZlIGNvbnN0cnVjdG9yIGZyb20gc3RhY2t0cmFjZSB3aGVuIHR5cGVzY3JpcHQgdGFyZ2V0IGlzIEVTNSAqL1xuICAgICAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIHRoaXMuY29uc3RydWN0b3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0b2tlbiwgcHJldmlvdXNUb2tlbikge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB0b2tlbik7XG4gICAgICAgIHRoaXMucHJldmlvdXNUb2tlbiA9IHByZXZpb3VzVG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9IE1JU01BVENIRURfVE9LRU5fRVhDRVBUSU9OO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0b2tlbiwgcHJldmlvdXNUb2tlbikge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB0b2tlbik7XG4gICAgICAgIHRoaXMucHJldmlvdXNUb2tlbiA9IHByZXZpb3VzVG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9IE5PX1ZJQUJMRV9BTFRfRVhDRVBUSU9OO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOb3RBbGxJbnB1dFBhcnNlZEV4Y2VwdGlvbiBleHRlbmRzIFJlY29nbml0aW9uRXhjZXB0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB0b2tlbikge1xuICAgICAgICBzdXBlcihtZXNzYWdlLCB0b2tlbik7XG4gICAgICAgIHRoaXMubmFtZSA9IE5PVF9BTExfSU5QVVRfUEFSU0VEX0VYQ0VQVElPTjtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRWFybHlFeGl0RXhjZXB0aW9uIGV4dGVuZHMgUmVjb2duaXRpb25FeGNlcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHRva2VuLCBwcmV2aW91c1Rva2VuKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UsIHRva2VuKTtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Rva2VuID0gcHJldmlvdXNUb2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gRUFSTFlfRVhJVF9FWENFUFRJT047XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXhjZXB0aW9uc19wdWJsaWMuanMubWFwIiwiaW1wb3J0IHsgY2xvbmUsIGNvbXBhY3QsIGRpZmZlcmVuY2UsIGRyb3AsIGRyb3BSaWdodCwgZmlsdGVyLCBmaXJzdCwgZmxhdE1hcCwgZmxhdHRlbiwgZm9yRWFjaCwgZ3JvdXBCeSwgaW5jbHVkZXMsIGlzRW1wdHksIG1hcCwgcGlja0J5LCByZWR1Y2UsIHJlamVjdCwgdmFsdWVzLCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsIH0gZnJvbSBcIi4uL3BhcnNlci9wYXJzZXIuanNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSBhcyBBbHRlcm5hdGl2ZUdBU1QsIEdBc3RWaXNpdG9yLCBnZXRQcm9kdWN0aW9uRHNsTmFtZSwgaXNPcHRpb25hbFByb2QsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgVGVybWluYWwsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmltcG9ydCB7IGNvbnRhaW5zUGF0aCwgZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QsIGdldExvb2thaGVhZFBhdGhzRm9yT3IsIGdldFByb2RUeXBlLCBpc1N0cmljdFByZWZpeE9mUGF0aCwgfSBmcm9tIFwiLi9sb29rYWhlYWQuanNcIjtcbmltcG9ydCB7IG5leHRQb3NzaWJsZVRva2Vuc0FmdGVyIH0gZnJvbSBcIi4vaW50ZXJwcmV0ZXIuanNcIjtcbmltcG9ydCB7IHRva2VuU3RydWN0dXJlZE1hdGNoZXIgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZUxvb2thaGVhZChvcHRpb25zKSB7XG4gICAgY29uc3QgbG9va2FoZWFkVmFsaWRhdGlvbkVycm9yTWVzc2FnZXMgPSBvcHRpb25zLmxvb2thaGVhZFN0cmF0ZWd5LnZhbGlkYXRlKHtcbiAgICAgICAgcnVsZXM6IG9wdGlvbnMucnVsZXMsXG4gICAgICAgIHRva2VuVHlwZXM6IG9wdGlvbnMudG9rZW5UeXBlcyxcbiAgICAgICAgZ3JhbW1hck5hbWU6IG9wdGlvbnMuZ3JhbW1hck5hbWUsXG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcChsb29rYWhlYWRWYWxpZGF0aW9uRXJyb3JNZXNzYWdlcywgKGVycm9yTWVzc2FnZSkgPT4gKE9iamVjdC5hc3NpZ24oeyB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkNVU1RPTV9MT09LQUhFQURfVkFMSURBVElPTiB9LCBlcnJvck1lc3NhZ2UpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVHcmFtbWFyKHRvcExldmVscywgdG9rZW5UeXBlcywgZXJyTXNnUHJvdmlkZXIsIGdyYW1tYXJOYW1lKSB7XG4gICAgY29uc3QgZHVwbGljYXRlRXJyb3JzID0gZmxhdE1hcCh0b3BMZXZlbHMsIChjdXJyVG9wTGV2ZWwpID0+IHZhbGlkYXRlRHVwbGljYXRlUHJvZHVjdGlvbnMoY3VyclRvcExldmVsLCBlcnJNc2dQcm92aWRlcikpO1xuICAgIGNvbnN0IHRlcm1zTmFtZXNwYWNlQ29uZmxpY3RFcnJvcnMgPSBjaGVja1Rlcm1pbmFsQW5kTm9uZVRlcm1pbmFsc05hbWVTcGFjZSh0b3BMZXZlbHMsIHRva2VuVHlwZXMsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICBjb25zdCB0b29NYW55QWx0c0Vycm9ycyA9IGZsYXRNYXAodG9wTGV2ZWxzLCAoY3VyUnVsZSkgPT4gdmFsaWRhdGVUb29NYW55QWx0cyhjdXJSdWxlLCBlcnJNc2dQcm92aWRlcikpO1xuICAgIGNvbnN0IGR1cGxpY2F0ZVJ1bGVzRXJyb3IgPSBmbGF0TWFwKHRvcExldmVscywgKGN1clJ1bGUpID0+IHZhbGlkYXRlUnVsZURvZXNOb3RBbHJlYWR5RXhpc3QoY3VyUnVsZSwgdG9wTGV2ZWxzLCBncmFtbWFyTmFtZSwgZXJyTXNnUHJvdmlkZXIpKTtcbiAgICByZXR1cm4gZHVwbGljYXRlRXJyb3JzLmNvbmNhdCh0ZXJtc05hbWVzcGFjZUNvbmZsaWN0RXJyb3JzLCB0b29NYW55QWx0c0Vycm9ycywgZHVwbGljYXRlUnVsZXNFcnJvcik7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZUR1cGxpY2F0ZVByb2R1Y3Rpb25zKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICBjb25zdCBjb2xsZWN0b3JWaXNpdG9yID0gbmV3IE9jY3VycmVuY2VWYWxpZGF0aW9uQ29sbGVjdG9yKCk7XG4gICAgdG9wTGV2ZWxSdWxlLmFjY2VwdChjb2xsZWN0b3JWaXNpdG9yKTtcbiAgICBjb25zdCBhbGxSdWxlUHJvZHVjdGlvbnMgPSBjb2xsZWN0b3JWaXNpdG9yLmFsbFByb2R1Y3Rpb25zO1xuICAgIGNvbnN0IHByb2R1Y3Rpb25Hcm91cHMgPSBncm91cEJ5KGFsbFJ1bGVQcm9kdWN0aW9ucywgaWRlbnRpZnlQcm9kdWN0aW9uRm9yRHVwbGljYXRlcyk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IHBpY2tCeShwcm9kdWN0aW9uR3JvdXBzLCAoY3Vyckdyb3VwKSA9PiB7XG4gICAgICAgIHJldHVybiBjdXJyR3JvdXAubGVuZ3RoID4gMTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAodmFsdWVzKGR1cGxpY2F0ZXMpLCAoY3VyckR1cGxpY2F0ZXMpID0+IHtcbiAgICAgICAgY29uc3QgZmlyc3RQcm9kID0gZmlyc3QoY3VyckR1cGxpY2F0ZXMpO1xuICAgICAgICBjb25zdCBtc2cgPSBlcnJNc2dQcm92aWRlci5idWlsZER1cGxpY2F0ZUZvdW5kRXJyb3IodG9wTGV2ZWxSdWxlLCBjdXJyRHVwbGljYXRlcyk7XG4gICAgICAgIGNvbnN0IGRzbE5hbWUgPSBnZXRQcm9kdWN0aW9uRHNsTmFtZShmaXJzdFByb2QpO1xuICAgICAgICBjb25zdCBkZWZFcnJvciA9IHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1BST0RVQ1RJT05TLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHRvcExldmVsUnVsZS5uYW1lLFxuICAgICAgICAgICAgZHNsTmFtZTogZHNsTmFtZSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IGZpcnN0UHJvZC5pZHgsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHBhcmFtID0gZ2V0RXh0cmFQcm9kdWN0aW9uQXJndW1lbnQoZmlyc3RQcm9kKTtcbiAgICAgICAgaWYgKHBhcmFtKSB7XG4gICAgICAgICAgICBkZWZFcnJvci5wYXJhbWV0ZXIgPSBwYXJhbTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmRXJyb3I7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpZGVudGlmeVByb2R1Y3Rpb25Gb3JEdXBsaWNhdGVzKHByb2QpIHtcbiAgICByZXR1cm4gYCR7Z2V0UHJvZHVjdGlvbkRzbE5hbWUocHJvZCl9XyNfJHtwcm9kLmlkeH1fI18ke2dldEV4dHJhUHJvZHVjdGlvbkFyZ3VtZW50KHByb2QpfWA7XG59XG5mdW5jdGlvbiBnZXRFeHRyYVByb2R1Y3Rpb25Bcmd1bWVudChwcm9kKSB7XG4gICAgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gcHJvZC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBwcm9kLm5vblRlcm1pbmFsTmFtZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBPY2N1cnJlbmNlVmFsaWRhdGlvbkNvbGxlY3RvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucyA9IFtdO1xuICAgIH1cbiAgICB2aXNpdE5vblRlcm1pbmFsKHN1YnJ1bGUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHN1YnJ1bGUpO1xuICAgIH1cbiAgICB2aXNpdE9wdGlvbihvcHRpb24pIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG9wdGlvbik7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcCkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueVNlcCk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeShhdExlYXN0T25lKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihhdExlYXN0T25lU2VwKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChhdExlYXN0T25lU2VwKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uKG1hbnkpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKG1hbnkpO1xuICAgIH1cbiAgICB2aXNpdEFsdGVybmF0aW9uKG9yKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChvcik7XG4gICAgfVxuICAgIHZpc2l0VGVybWluYWwodGVybWluYWwpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKHRlcm1pbmFsKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSdWxlRG9lc05vdEFscmVhZHlFeGlzdChydWxlLCBhbGxSdWxlcywgY2xhc3NOYW1lLCBlcnJNc2dQcm92aWRlcikge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IG9jY3VycmVuY2VzID0gcmVkdWNlKGFsbFJ1bGVzLCAocmVzdWx0LCBjdXJSdWxlKSA9PiB7XG4gICAgICAgIGlmIChjdXJSdWxlLm5hbWUgPT09IHJ1bGUubmFtZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdCArIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCAwKTtcbiAgICBpZiAob2NjdXJyZW5jZXMgPiAxKSB7XG4gICAgICAgIGNvbnN0IGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRHVwbGljYXRlUnVsZU5hbWVFcnJvcih7XG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICBncmFtbWFyTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICB9KTtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogZXJyTXNnLFxuICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG4vLyBUT0RPOiBpcyB0aGVyZSBhbnl3YXkgdG8gZ2V0IG9ubHkgdGhlIHJ1bGUgbmFtZXMgb2YgcnVsZXMgaW5oZXJpdGVkIGZyb20gdGhlIHN1cGVyIGdyYW1tYXJzP1xuLy8gVGhpcyBpcyBub3QgcGFydCBvZiB0aGUgSUdyYW1tYXJFcnJvclByb3ZpZGVyIGJlY2F1c2UgdGhlIHZhbGlkYXRpb24gY2Fubm90IGJlIHBlcmZvcm1lZCBvblxuLy8gVGhlIGdyYW1tYXIgc3RydWN0dXJlLCBvbmx5IGF0IHJ1bnRpbWUuXG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVSdWxlSXNPdmVycmlkZGVuKHJ1bGVOYW1lLCBkZWZpbmVkUnVsZXNOYW1lcywgY2xhc3NOYW1lKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgbGV0IGVyck1zZztcbiAgICBpZiAoIWluY2x1ZGVzKGRlZmluZWRSdWxlc05hbWVzLCBydWxlTmFtZSkpIHtcbiAgICAgICAgZXJyTXNnID1cbiAgICAgICAgICAgIGBJbnZhbGlkIHJ1bGUgb3ZlcnJpZGUsIHJ1bGU6IC0+JHtydWxlTmFtZX08LSBjYW5ub3QgYmUgb3ZlcnJpZGRlbiBpbiB0aGUgZ3JhbW1hcjogLT4ke2NsYXNzTmFtZX08LWAgK1xuICAgICAgICAgICAgICAgIGBhcyBpdCBpcyBub3QgZGVmaW5lZCBpbiBhbnkgb2YgdGhlIHN1cGVyIGdyYW1tYXJzIGA7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgIHR5cGU6IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9SVUxFX09WRVJSSURFLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGVOYW1lLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZU5vTGVmdFJlY3Vyc2lvbih0b3BSdWxlLCBjdXJyUnVsZSwgZXJyTXNnUHJvdmlkZXIsIHBhdGggPSBbXSkge1xuICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IG5leHROb25UZXJtaW5hbHMgPSBnZXRGaXJzdE5vbmVUZXJtaW5hbChjdXJyUnVsZS5kZWZpbml0aW9uKTtcbiAgICBpZiAoaXNFbXB0eShuZXh0Tm9uVGVybWluYWxzKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBydWxlTmFtZSA9IHRvcFJ1bGUubmFtZTtcbiAgICAgICAgY29uc3QgZm91bmRMZWZ0UmVjdXJzaW9uID0gaW5jbHVkZXMobmV4dE5vblRlcm1pbmFscywgdG9wUnVsZSk7XG4gICAgICAgIGlmIChmb3VuZExlZnRSZWN1cnNpb24pIHtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZExlZnRSZWN1cnNpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgIHRvcExldmVsUnVsZTogdG9wUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgbGVmdFJlY3Vyc2lvblBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5MRUZUX1JFQ1VSU0lPTixcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogcnVsZU5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSBhcmUgb25seSBsb29raW5nIGZvciBjeWNsaWMgcGF0aHMgbGVhZGluZyBiYWNrIHRvIHRoZSBzcGVjaWZpYyB0b3BSdWxlXG4gICAgICAgIC8vIG90aGVyIGN5Y2xpYyBwYXRocyBhcmUgaWdub3JlZCwgd2Ugc3RpbGwgbmVlZCB0aGlzIGRpZmZlcmVuY2UgdG8gYXZvaWQgaW5maW5pdGUgbG9vcHMuLi5cbiAgICAgICAgY29uc3QgdmFsaWROZXh0U3RlcHMgPSBkaWZmZXJlbmNlKG5leHROb25UZXJtaW5hbHMsIHBhdGguY29uY2F0KFt0b3BSdWxlXSkpO1xuICAgICAgICBjb25zdCBlcnJvcnNGcm9tTmV4dFN0ZXBzID0gZmxhdE1hcCh2YWxpZE5leHRTdGVwcywgKGN1cnJSZWZSdWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuZXdQYXRoID0gY2xvbmUocGF0aCk7XG4gICAgICAgICAgICBuZXdQYXRoLnB1c2goY3VyclJlZlJ1bGUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKHRvcFJ1bGUsIGN1cnJSZWZSdWxlLCBlcnJNc2dQcm92aWRlciwgbmV3UGF0aCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZXJyb3JzLmNvbmNhdChlcnJvcnNGcm9tTmV4dFN0ZXBzKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0Rmlyc3ROb25lVGVybWluYWwoZGVmaW5pdGlvbikge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBpZiAoaXNFbXB0eShkZWZpbml0aW9uKSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjb25zdCBmaXJzdFByb2QgPSBmaXJzdChkZWZpbml0aW9uKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICByZXN1bHQucHVzaChmaXJzdFByb2QucmVmZXJlbmNlZFJ1bGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZUdBU1QgfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgT3B0aW9uIHx8XG4gICAgICAgIGZpcnN0UHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnkgfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IgfHxcbiAgICAgICAgZmlyc3RQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbikge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KGdldEZpcnN0Tm9uZVRlcm1pbmFsKGZpcnN0UHJvZC5kZWZpbml0aW9uKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGZpcnN0UHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgIC8vIGVhY2ggc3ViIGRlZmluaXRpb24gaW4gYWx0ZXJuYXRpb24gaXMgYSBGTEFUXG4gICAgICAgIHJlc3VsdCA9IGZsYXR0ZW4obWFwKGZpcnN0UHJvZC5kZWZpbml0aW9uLCAoY3VyclN1YkRlZikgPT4gZ2V0Rmlyc3ROb25lVGVybWluYWwoY3VyclN1YkRlZi5kZWZpbml0aW9uKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmaXJzdFByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAvLyBub3RoaW5nIHRvIHNlZSwgbW92ZSBhbG9uZ1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICB9XG4gICAgY29uc3QgaXNGaXJzdE9wdGlvbmFsID0gaXNPcHRpb25hbFByb2QoZmlyc3RQcm9kKTtcbiAgICBjb25zdCBoYXNNb3JlID0gZGVmaW5pdGlvbi5sZW5ndGggPiAxO1xuICAgIGlmIChpc0ZpcnN0T3B0aW9uYWwgJiYgaGFzTW9yZSkge1xuICAgICAgICBjb25zdCByZXN0ID0gZHJvcChkZWZpbml0aW9uKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5jb25jYXQoZ2V0Rmlyc3ROb25lVGVybWluYWwocmVzdCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG5jbGFzcyBPckNvbGxlY3RvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5hbHRlcm5hdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgdmlzaXRBbHRlcm5hdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMuYWx0ZXJuYXRpb25zLnB1c2gobm9kZSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlKHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICBjb25zdCBvckNvbGxlY3RvciA9IG5ldyBPckNvbGxlY3RvcigpO1xuICAgIHRvcExldmVsUnVsZS5hY2NlcHQob3JDb2xsZWN0b3IpO1xuICAgIGNvbnN0IG9ycyA9IG9yQ29sbGVjdG9yLmFsdGVybmF0aW9ucztcbiAgICBjb25zdCBlcnJvcnMgPSBmbGF0TWFwKG9ycywgKGN1cnJPcikgPT4ge1xuICAgICAgICBjb25zdCBleGNlcHRMYXN0ID0gZHJvcFJpZ2h0KGN1cnJPci5kZWZpbml0aW9uKTtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAoZXhjZXB0TGFzdCwgKGN1cnJBbHRlcm5hdGl2ZSwgY3VyckFsdElkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9zc2libGVGaXJzdEluQWx0ID0gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW2N1cnJBbHRlcm5hdGl2ZV0sIFtdLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyLCAxKTtcbiAgICAgICAgICAgIGlmIChpc0VtcHR5KHBvc3NpYmxlRmlyc3RJbkFsdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZEVtcHR5QWx0ZXJuYXRpb25FcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9wTGV2ZWxSdWxlOiB0b3BMZXZlbFJ1bGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpb246IGN1cnJPcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbXB0eUNob2ljZUlkeDogY3VyckFsdElkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT05FX0xBU1RfRU1QVFlfQUxULFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRvcExldmVsUnVsZS5uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogY3Vyck9yLmlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aXZlOiBjdXJyQWx0SWR4ICsgMSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXModG9wTGV2ZWxSdWxlLCBnbG9iYWxNYXhMb29rYWhlYWQsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3Qgb3JDb2xsZWN0b3IgPSBuZXcgT3JDb2xsZWN0b3IoKTtcbiAgICB0b3BMZXZlbFJ1bGUuYWNjZXB0KG9yQ29sbGVjdG9yKTtcbiAgICBsZXQgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIC8vIE5ldyBIYW5kbGluZyBvZiBpZ25vcmluZyBhbWJpZ3VpdGllc1xuICAgIC8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2NoZXZyb3RhaW4vY2hldnJvdGFpbi9pc3N1ZXMvODY5XG4gICAgb3JzID0gcmVqZWN0KG9ycywgKGN1cnJPcikgPT4gY3Vyck9yLmlnbm9yZUFtYmlndWl0aWVzID09PSB0cnVlKTtcbiAgICBjb25zdCBlcnJvcnMgPSBmbGF0TWFwKG9ycywgKGN1cnJPcikgPT4ge1xuICAgICAgICBjb25zdCBjdXJyT2NjdXJyZW5jZSA9IGN1cnJPci5pZHg7XG4gICAgICAgIGNvbnN0IGFjdHVhbE1heExvb2thaGVhZCA9IGN1cnJPci5tYXhMb29rYWhlYWQgfHwgZ2xvYmFsTWF4TG9va2FoZWFkO1xuICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZXMgPSBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKGN1cnJPY2N1cnJlbmNlLCB0b3BMZXZlbFJ1bGUsIGFjdHVhbE1heExvb2thaGVhZCwgY3Vyck9yKTtcbiAgICAgICAgY29uc3QgYWx0c0FtYmlndWl0eUVycm9ycyA9IGNoZWNrQWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBjdXJyT3IsIHRvcExldmVsUnVsZSwgZXJyTXNnUHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBhbHRzUHJlZml4QW1iaWd1aXR5RXJyb3JzID0gY2hlY2tQcmVmaXhBbHRlcm5hdGl2ZXNBbWJpZ3VpdGllcyhhbHRlcm5hdGl2ZXMsIGN1cnJPciwgdG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcik7XG4gICAgICAgIHJldHVybiBhbHRzQW1iaWd1aXR5RXJyb3JzLmNvbmNhdChhbHRzUHJlZml4QW1iaWd1aXR5RXJyb3JzKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGNsYXNzIFJlcGV0aXRpb25Db2xsZWN0b3IgZXh0ZW5kcyBHQXN0VmlzaXRvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihtYW55U2VwKSB7XG4gICAgICAgIHRoaXMuYWxsUHJvZHVjdGlvbnMucHVzaChtYW55U2VwKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmUpO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKGF0TGVhc3RPbmVTZXApIHtcbiAgICAgICAgdGhpcy5hbGxQcm9kdWN0aW9ucy5wdXNoKGF0TGVhc3RPbmVTZXApO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb24obWFueSkge1xuICAgICAgICB0aGlzLmFsbFByb2R1Y3Rpb25zLnB1c2gobWFueSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlVG9vTWFueUFsdHModG9wTGV2ZWxSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgIGNvbnN0IG9yQ29sbGVjdG9yID0gbmV3IE9yQ29sbGVjdG9yKCk7XG4gICAgdG9wTGV2ZWxSdWxlLmFjY2VwdChvckNvbGxlY3Rvcik7XG4gICAgY29uc3Qgb3JzID0gb3JDb2xsZWN0b3IuYWx0ZXJuYXRpb25zO1xuICAgIGNvbnN0IGVycm9ycyA9IGZsYXRNYXAob3JzLCAoY3Vyck9yKSA9PiB7XG4gICAgICAgIGlmIChjdXJyT3IuZGVmaW5pdGlvbi5sZW5ndGggPiAyNTUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2dQcm92aWRlci5idWlsZFRvb01hbnlBbHRlcm5hdGl2ZXNFcnJvcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHRvcExldmVsUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uOiBjdXJyT3IsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLlRPT19NQU5ZX0FMVFMsXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0b3BMZXZlbFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgb2NjdXJyZW5jZTogY3Vyck9yLmlkeCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsaWRhdGVTb21lTm9uRW1wdHlMb29rYWhlYWRQYXRoKHRvcExldmVsUnVsZXMsIG1heExvb2thaGVhZCwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBmb3JFYWNoKHRvcExldmVsUnVsZXMsIChjdXJyVG9wUnVsZSkgPT4ge1xuICAgICAgICBjb25zdCBjb2xsZWN0b3JWaXNpdG9yID0gbmV3IFJlcGV0aXRpb25Db2xsZWN0b3IoKTtcbiAgICAgICAgY3VyclRvcFJ1bGUuYWNjZXB0KGNvbGxlY3RvclZpc2l0b3IpO1xuICAgICAgICBjb25zdCBhbGxSdWxlUHJvZHVjdGlvbnMgPSBjb2xsZWN0b3JWaXNpdG9yLmFsbFByb2R1Y3Rpb25zO1xuICAgICAgICBmb3JFYWNoKGFsbFJ1bGVQcm9kdWN0aW9ucywgKGN1cnJQcm9kKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwcm9kVHlwZSA9IGdldFByb2RUeXBlKGN1cnJQcm9kKTtcbiAgICAgICAgICAgIGNvbnN0IGFjdHVhbE1heExvb2thaGVhZCA9IGN1cnJQcm9kLm1heExvb2thaGVhZCB8fCBtYXhMb29rYWhlYWQ7XG4gICAgICAgICAgICBjb25zdCBjdXJyT2NjdXJyZW5jZSA9IGN1cnJQcm9kLmlkeDtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhzID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2QoY3Vyck9jY3VycmVuY2UsIGN1cnJUb3BSdWxlLCBwcm9kVHlwZSwgYWN0dWFsTWF4TG9va2FoZWFkKTtcbiAgICAgICAgICAgIGNvbnN0IHBhdGhzSW5zaWRlUHJvZHVjdGlvbiA9IHBhdGhzWzBdO1xuICAgICAgICAgICAgaWYgKGlzRW1wdHkoZmxhdHRlbihwYXRoc0luc2lkZVByb2R1Y3Rpb24pKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyck1zZyA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkRW1wdHlSZXBldGl0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IGN1cnJUb3BSdWxlLFxuICAgICAgICAgICAgICAgICAgICByZXBldGl0aW9uOiBjdXJyUHJvZCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBlcnJvcnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGVyck1zZyxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19OT05fRU1QVFlfTE9PS0FIRUFELFxuICAgICAgICAgICAgICAgICAgICBydWxlTmFtZTogY3VyclRvcFJ1bGUubmFtZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIGNoZWNrQWx0ZXJuYXRpdmVzQW1iaWd1aXRpZXMoYWx0ZXJuYXRpdmVzLCBhbHRlcm5hdGlvbiwgcnVsZSwgZXJyTXNnUHJvdmlkZXIpIHtcbiAgICBjb25zdCBmb3VuZEFtYmlndW91c1BhdGhzID0gW107XG4gICAgY29uc3QgaWRlbnRpY2FsQW1iaWd1aXRpZXMgPSByZWR1Y2UoYWx0ZXJuYXRpdmVzLCAocmVzdWx0LCBjdXJyQWx0LCBjdXJyQWx0SWR4KSA9PiB7XG4gICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIGFsdGVybmF0aXZlXG4gICAgICAgIGlmIChhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJBbHRJZHhdLmlnbm9yZUFtYmlndWl0aWVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGZvckVhY2goY3VyckFsdCwgKGN1cnJQYXRoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHRzQ3VyclBhdGhBcHBlYXJzSW4gPSBbY3VyckFsdElkeF07XG4gICAgICAgICAgICBmb3JFYWNoKGFsdGVybmF0aXZlcywgKGN1cnJPdGhlckFsdCwgY3Vyck90aGVyQWx0SWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJBbHRJZHggIT09IGN1cnJPdGhlckFsdElkeCAmJlxuICAgICAgICAgICAgICAgICAgICBjb250YWluc1BhdGgoY3Vyck90aGVyQWx0LCBjdXJyUGF0aCkgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIChza2lwKSBhbWJpZ3VpdGllcyB3aXRoIHRoaXMgXCJvdGhlclwiIGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgICAgIGFsdGVybmF0aW9uLmRlZmluaXRpb25bY3Vyck90aGVyQWx0SWR4XS5pZ25vcmVBbWJpZ3VpdGllcyAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBhbHRzQ3VyclBhdGhBcHBlYXJzSW4ucHVzaChjdXJyT3RoZXJBbHRJZHgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGFsdHNDdXJyUGF0aEFwcGVhcnNJbi5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAgICAgIWNvbnRhaW5zUGF0aChmb3VuZEFtYmlndW91c1BhdGhzLCBjdXJyUGF0aCkpIHtcbiAgICAgICAgICAgICAgICBmb3VuZEFtYmlndW91c1BhdGhzLnB1c2goY3VyclBhdGgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgYWx0czogYWx0c0N1cnJQYXRoQXBwZWFyc0luLFxuICAgICAgICAgICAgICAgICAgICBwYXRoOiBjdXJyUGF0aCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGN1cnJFcnJvcnMgPSBtYXAoaWRlbnRpY2FsQW1iaWd1aXRpZXMsIChjdXJyQW1iRGVzY3JpcHRvcikgPT4ge1xuICAgICAgICBjb25zdCBhbWJnSW5kaWNlcyA9IG1hcChjdXJyQW1iRGVzY3JpcHRvci5hbHRzLCAoY3VyckFsdElkeCkgPT4gY3VyckFsdElkeCArIDEpO1xuICAgICAgICBjb25zdCBjdXJyTWVzc2FnZSA9IGVyck1zZ1Byb3ZpZGVyLmJ1aWxkQWx0ZXJuYXRpb25BbWJpZ3VpdHlFcnJvcih7XG4gICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogYWx0ZXJuYXRpb24sXG4gICAgICAgICAgICBhbWJpZ3VpdHlJbmRpY2VzOiBhbWJnSW5kaWNlcyxcbiAgICAgICAgICAgIHByZWZpeFBhdGg6IGN1cnJBbWJEZXNjcmlwdG9yLnBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogY3Vyck1lc3NhZ2UsXG4gICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19BTFRTLFxuICAgICAgICAgICAgcnVsZU5hbWU6IHJ1bGUubmFtZSxcbiAgICAgICAgICAgIG9jY3VycmVuY2U6IGFsdGVybmF0aW9uLmlkeCxcbiAgICAgICAgICAgIGFsdGVybmF0aXZlczogY3VyckFtYkRlc2NyaXB0b3IuYWx0cyxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gY3VyckVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1ByZWZpeEFsdGVybmF0aXZlc0FtYmlndWl0aWVzKGFsdGVybmF0aXZlcywgYWx0ZXJuYXRpb24sIHJ1bGUsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgLy8gZmxhdHRlblxuICAgIGNvbnN0IHBhdGhzQW5kSW5kaWNlcyA9IHJlZHVjZShhbHRlcm5hdGl2ZXMsIChyZXN1bHQsIGN1cnJBbHQsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyUGF0aHNBbmRJZHggPSBtYXAoY3VyckFsdCwgKGN1cnJQYXRoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4geyBpZHg6IGlkeCwgcGF0aDogY3VyclBhdGggfTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGN1cnJQYXRoc0FuZElkeCk7XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVycm9ycyA9IGNvbXBhY3QoZmxhdE1hcChwYXRoc0FuZEluZGljZXMsIChjdXJyUGF0aEFuZElkeCkgPT4ge1xuICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZUdhc3QgPSBhbHRlcm5hdGlvbi5kZWZpbml0aW9uW2N1cnJQYXRoQW5kSWR4LmlkeF07XG4gICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIGFsdGVybmF0aXZlXG4gICAgICAgIGlmIChhbHRlcm5hdGl2ZUdhc3QuaWdub3JlQW1iaWd1aXRpZXMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZHggPSBjdXJyUGF0aEFuZElkeC5pZHg7XG4gICAgICAgIGNvbnN0IHRhcmdldFBhdGggPSBjdXJyUGF0aEFuZElkeC5wYXRoO1xuICAgICAgICBjb25zdCBwcmVmaXhBbWJpZ3VpdGllc1BhdGhzQW5kSW5kaWNlcyA9IGZpbHRlcihwYXRoc0FuZEluZGljZXMsIChzZWFyY2hQYXRoQW5kSWR4KSA9PiB7XG4gICAgICAgICAgICAvLyBwcmVmaXggYW1iaWd1aXR5IGNhbiBvbmx5IGJlIGNyZWF0ZWQgZnJvbSBsb3dlciBpZHggKGhpZ2hlciBwcmlvcml0eSkgcGF0aFxuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIC8vIGlnbm9yZSAoc2tpcCkgYW1iaWd1aXRpZXMgd2l0aCB0aGlzIFwib3RoZXJcIiBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgYWx0ZXJuYXRpb24uZGVmaW5pdGlvbltzZWFyY2hQYXRoQW5kSWR4LmlkeF0uaWdub3JlQW1iaWd1aXRpZXMgIT09XG4gICAgICAgICAgICAgICAgdHJ1ZSAmJlxuICAgICAgICAgICAgICAgIHNlYXJjaFBhdGhBbmRJZHguaWR4IDwgdGFyZ2V0SWR4ICYmXG4gICAgICAgICAgICAgICAgLy8gY2hlY2tpbmcgZm9yIHN0cmljdCBwcmVmaXggYmVjYXVzZSBpZGVudGljYWwgbG9va2FoZWFkc1xuICAgICAgICAgICAgICAgIC8vIHdpbGwgYmUgYmUgZGV0ZWN0ZWQgdXNpbmcgYSBkaWZmZXJlbnQgdmFsaWRhdGlvbi5cbiAgICAgICAgICAgICAgICBpc1N0cmljdFByZWZpeE9mUGF0aChzZWFyY2hQYXRoQW5kSWR4LnBhdGgsIHRhcmdldFBhdGgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJQYXRoUHJlZml4RXJyb3JzID0gbWFwKHByZWZpeEFtYmlndWl0aWVzUGF0aHNBbmRJbmRpY2VzLCAoY3VyckFtYlBhdGhBbmRJZHgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFtYmdJbmRpY2VzID0gW2N1cnJBbWJQYXRoQW5kSWR4LmlkeCArIDEsIHRhcmdldElkeCArIDFdO1xuICAgICAgICAgICAgY29uc3Qgb2NjdXJyZW5jZSA9IGFsdGVybmF0aW9uLmlkeCA9PT0gMCA/IFwiXCIgOiBhbHRlcm5hdGlvbi5pZHg7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyTXNnUHJvdmlkZXIuYnVpbGRBbHRlcm5hdGlvblByZWZpeEFtYmlndWl0eUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IHJ1bGUsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpb246IGFsdGVybmF0aW9uLFxuICAgICAgICAgICAgICAgIGFtYmlndWl0eUluZGljZXM6IGFtYmdJbmRpY2VzLFxuICAgICAgICAgICAgICAgIHByZWZpeFBhdGg6IGN1cnJBbWJQYXRoQW5kSWR4LnBhdGgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICAgICAgICB0eXBlOiBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlLkFNQklHVU9VU19QUkVGSVhfQUxUUyxcbiAgICAgICAgICAgICAgICBydWxlTmFtZTogcnVsZS5uYW1lLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2U6IG9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVzOiBhbWJnSW5kaWNlcyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gY3VyclBhdGhQcmVmaXhFcnJvcnM7XG4gICAgfSkpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiBjaGVja1Rlcm1pbmFsQW5kTm9uZVRlcm1pbmFsc05hbWVTcGFjZSh0b3BMZXZlbHMsIHRva2VuVHlwZXMsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgdG9rZW5OYW1lcyA9IG1hcCh0b2tlblR5cGVzLCAoY3VyclRva2VuKSA9PiBjdXJyVG9rZW4ubmFtZSk7XG4gICAgZm9yRWFjaCh0b3BMZXZlbHMsIChjdXJyUnVsZSkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyUnVsZU5hbWUgPSBjdXJyUnVsZS5uYW1lO1xuICAgICAgICBpZiAoaW5jbHVkZXModG9rZW5OYW1lcywgY3VyclJ1bGVOYW1lKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyTXNnID0gZXJyTXNnUHJvdmlkZXIuYnVpbGROYW1lc3BhY2VDb25mbGljdEVycm9yKGN1cnJSdWxlKTtcbiAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5DT05GTElDVF9UT0tFTlNfUlVMRVNfTkFNRVNQQUNFLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBjdXJyUnVsZU5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jaGVja3MuanMubWFwIiwiaW1wb3J0IHsgZmxhdHRlbiwgbWFwLCB1bmlxIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgaXNCcmFuY2hpbmdQcm9kLCBpc09wdGlvbmFsUHJvZCwgaXNTZXF1ZW5jZVByb2QsIE5vblRlcm1pbmFsLCBUZXJtaW5hbCwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0KHByb2QpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgLy8gdGhpcyBjb3VsZCBpbiB0aGVvcnkgY2F1c2UgaW5maW5pdGUgbG9vcHMgaWZcbiAgICAgICAgLy8gKDEpIHByb2QgQSByZWZzIHByb2QgQi5cbiAgICAgICAgLy8gKDIpIHByb2QgQiByZWZzIHByb2QgQVxuICAgICAgICAvLyAoMykgQUIgY2FuIG1hdGNoIHRoZSBlbXB0eSBzZXRcbiAgICAgICAgLy8gaW4gb3RoZXIgd29yZHMgYSBjeWNsZSB3aGVyZSBldmVyeXRoaW5nIGlzIG9wdGlvbmFsIHNvIHRoZSBmaXJzdCB3aWxsIGtlZXBcbiAgICAgICAgLy8gbG9va2luZyBhaGVhZCBmb3IgdGhlIG5leHQgb3B0aW9uYWwgcGFydCBhbmQgd2lsbCBuZXZlciBleGl0XG4gICAgICAgIC8vIGN1cnJlbnRseSB0aGVyZSBpcyBubyBzYWZlZ3VhcmQgZm9yIHRoaXMgdW5pcXVlIGVkZ2UgY2FzZSBiZWNhdXNlXG4gICAgICAgIC8vICgxKSBub3Qgc3VyZSBhIGdyYW1tYXIgaW4gd2hpY2ggdGhpcyBjYW4gaGFwcGVuIGlzIHVzZWZ1bCBmb3IgYW55dGhpbmcgKHByb2R1Y3RpdmUpXG4gICAgICAgIHJldHVybiBmaXJzdChwcm9kLnJlZmVyZW5jZWRSdWxlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEZvclRlcm1pbmFsKHByb2QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1NlcXVlbmNlUHJvZChwcm9kKSkge1xuICAgICAgICByZXR1cm4gZmlyc3RGb3JTZXF1ZW5jZShwcm9kKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNCcmFuY2hpbmdQcm9kKHByb2QpKSB7XG4gICAgICAgIHJldHVybiBmaXJzdEZvckJyYW5jaGluZyhwcm9kKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yU2VxdWVuY2UocHJvZCkge1xuICAgIGxldCBmaXJzdFNldCA9IFtdO1xuICAgIGNvbnN0IHNlcSA9IHByb2QuZGVmaW5pdGlvbjtcbiAgICBsZXQgbmV4dFN1YlByb2RJZHggPSAwO1xuICAgIGxldCBoYXNJbm5lclByb2RzUmVtYWluaW5nID0gc2VxLmxlbmd0aCA+IG5leHRTdWJQcm9kSWR4O1xuICAgIGxldCBjdXJyU3ViUHJvZDtcbiAgICAvLyBzbyB3ZSBlbnRlciB0aGUgbG9vcCBhdCBsZWFzdCBvbmNlIChpZiB0aGUgZGVmaW5pdGlvbiBpcyBub3QgZW1wdHlcbiAgICBsZXQgaXNMYXN0SW5uZXJQcm9kT3B0aW9uYWwgPSB0cnVlO1xuICAgIC8vIHNjYW4gYSBzZXF1ZW5jZSB1bnRpbCBpdCdzIGVuZCBvciB1bnRpbCB3ZSBoYXZlIGZvdW5kIGEgTk9ORSBvcHRpb25hbCBwcm9kdWN0aW9uIGluIGl0XG4gICAgd2hpbGUgKGhhc0lubmVyUHJvZHNSZW1haW5pbmcgJiYgaXNMYXN0SW5uZXJQcm9kT3B0aW9uYWwpIHtcbiAgICAgICAgY3VyclN1YlByb2QgPSBzZXFbbmV4dFN1YlByb2RJZHhdO1xuICAgICAgICBpc0xhc3RJbm5lclByb2RPcHRpb25hbCA9IGlzT3B0aW9uYWxQcm9kKGN1cnJTdWJQcm9kKTtcbiAgICAgICAgZmlyc3RTZXQgPSBmaXJzdFNldC5jb25jYXQoZmlyc3QoY3VyclN1YlByb2QpKTtcbiAgICAgICAgbmV4dFN1YlByb2RJZHggPSBuZXh0U3ViUHJvZElkeCArIDE7XG4gICAgICAgIGhhc0lubmVyUHJvZHNSZW1haW5pbmcgPSBzZXEubGVuZ3RoID4gbmV4dFN1YlByb2RJZHg7XG4gICAgfVxuICAgIHJldHVybiB1bmlxKGZpcnN0U2V0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaXJzdEZvckJyYW5jaGluZyhwcm9kKSB7XG4gICAgY29uc3QgYWxsQWx0ZXJuYXRpdmVzRmlyc3RzID0gbWFwKHByb2QuZGVmaW5pdGlvbiwgKGlubmVyUHJvZCkgPT4ge1xuICAgICAgICByZXR1cm4gZmlyc3QoaW5uZXJQcm9kKTtcbiAgICB9KTtcbiAgICByZXR1cm4gdW5pcShmbGF0dGVuKGFsbEFsdGVybmF0aXZlc0ZpcnN0cykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Rm9yVGVybWluYWwodGVybWluYWwpIHtcbiAgICByZXR1cm4gW3Rlcm1pbmFsLnRlcm1pbmFsVHlwZV07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1maXJzdC5qcy5tYXAiLCJpbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdC5qc1wiO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi9maXJzdC5qc1wiO1xuaW1wb3J0IHsgYXNzaWduLCBmb3JFYWNoIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgSU4gfSBmcm9tIFwiLi4vY29uc3RhbnRzLmpzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGl2ZSB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG4vLyBUaGlzIFJlc3luY0ZvbGxvd3NXYWxrZXIgY29tcHV0ZXMgYWxsIG9mIHRoZSBmb2xsb3dzIHJlcXVpcmVkIGZvciBSRVNZTkNcbi8vIChza2lwcGluZyByZWZlcmVuY2UgcHJvZHVjdGlvbikuXG5leHBvcnQgY2xhc3MgUmVzeW5jRm9sbG93c1dhbGtlciBleHRlbmRzIFJlc3RXYWxrZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcFByb2QpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50b3BQcm9kID0gdG9wUHJvZDtcbiAgICAgICAgdGhpcy5mb2xsb3dzID0ge307XG4gICAgfVxuICAgIHN0YXJ0V2Fsa2luZygpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLmZvbGxvd3M7XG4gICAgfVxuICAgIHdhbGtUZXJtaW5hbCh0ZXJtaW5hbCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIGRvIG5vdGhpbmchIGp1c3QgbGlrZSBpbiB0aGUgcHVibGljIHNlY3RvciBhZnRlciAxMzowMFxuICAgIH1cbiAgICB3YWxrUHJvZFJlZihyZWZQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgY29uc3QgZm9sbG93TmFtZSA9IGJ1aWxkQmV0d2VlblByb2RzRm9sbG93UHJlZml4KHJlZlByb2QucmVmZXJlbmNlZFJ1bGUsIHJlZlByb2QuaWR4KSArXG4gICAgICAgICAgICB0aGlzLnRvcFByb2QubmFtZTtcbiAgICAgICAgY29uc3QgZnVsbFJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICBjb25zdCByZXN0UHJvZCA9IG5ldyBBbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IGZ1bGxSZXN0IH0pO1xuICAgICAgICBjb25zdCB0X2luX3RvcFByb2RfZm9sbG93cyA9IGZpcnN0KHJlc3RQcm9kKTtcbiAgICAgICAgdGhpcy5mb2xsb3dzW2ZvbGxvd05hbWVdID0gdF9pbl90b3BQcm9kX2ZvbGxvd3M7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVBbGxQcm9kc0ZvbGxvd3ModG9wUHJvZHVjdGlvbnMpIHtcbiAgICBjb25zdCByZVN5bmNGb2xsb3dzID0ge307XG4gICAgZm9yRWFjaCh0b3BQcm9kdWN0aW9ucywgKHRvcFByb2QpID0+IHtcbiAgICAgICAgY29uc3QgY3VyclJlZnNGb2xsb3cgPSBuZXcgUmVzeW5jRm9sbG93c1dhbGtlcih0b3BQcm9kKS5zdGFydFdhbGtpbmcoKTtcbiAgICAgICAgYXNzaWduKHJlU3luY0ZvbGxvd3MsIGN1cnJSZWZzRm9sbG93KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVTeW5jRm9sbG93cztcbn1cbmV4cG9ydCBmdW5jdGlvbiBidWlsZEJldHdlZW5Qcm9kc0ZvbGxvd1ByZWZpeChpbm5lciwgb2NjdXJlbmNlSW5QYXJlbnQpIHtcbiAgICByZXR1cm4gaW5uZXIubmFtZSArIG9jY3VyZW5jZUluUGFyZW50ICsgSU47XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRJblByb2RGb2xsb3dQcmVmaXgodGVybWluYWwpIHtcbiAgICBjb25zdCB0ZXJtaW5hbE5hbWUgPSB0ZXJtaW5hbC50ZXJtaW5hbFR5cGUubmFtZTtcbiAgICByZXR1cm4gdGVybWluYWxOYW1lICsgdGVybWluYWwuaWR4ICsgSU47XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb2xsb3cuanMubWFwIiwiaW1wb3J0IHsgZGVmYXVsdHMsIGZvckVhY2ggfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyByZXNvbHZlR3JhbW1hciBhcyBvcmdSZXNvbHZlR3JhbW1hciB9IGZyb20gXCIuLi9yZXNvbHZlci5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVHcmFtbWFyIGFzIG9yZ1ZhbGlkYXRlR3JhbW1hciB9IGZyb20gXCIuLi9jaGVja3MuanNcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsIH0gZnJvbSBcIi4uLy4uL2Vycm9yc19wdWJsaWMuanNcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlR3JhbW1hcihvcHRpb25zKSB7XG4gICAgY29uc3QgYWN0dWFsT3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZXJyTXNnUHJvdmlkZXI6IGRlZmF1bHRHcmFtbWFyUmVzb2x2ZXJFcnJvclByb3ZpZGVyLFxuICAgIH0pO1xuICAgIGNvbnN0IHRvcFJ1bGVzVGFibGUgPSB7fTtcbiAgICBmb3JFYWNoKG9wdGlvbnMucnVsZXMsIChydWxlKSA9PiB7XG4gICAgICAgIHRvcFJ1bGVzVGFibGVbcnVsZS5uYW1lXSA9IHJ1bGU7XG4gICAgfSk7XG4gICAgcmV0dXJuIG9yZ1Jlc29sdmVHcmFtbWFyKHRvcFJ1bGVzVGFibGUsIGFjdHVhbE9wdGlvbnMuZXJyTXNnUHJvdmlkZXIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlR3JhbW1hcihvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IGRlZmF1bHRzKG9wdGlvbnMsIHtcbiAgICAgICAgZXJyTXNnUHJvdmlkZXI6IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlcixcbiAgICB9KTtcbiAgICByZXR1cm4gb3JnVmFsaWRhdGVHcmFtbWFyKG9wdGlvbnMucnVsZXMsIG9wdGlvbnMudG9rZW5UeXBlcywgb3B0aW9ucy5lcnJNc2dQcm92aWRlciwgb3B0aW9ucy5ncmFtbWFyTmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1nYXN0X3Jlc29sdmVyX3B1YmxpYy5qcy5tYXAiLCJpbXBvcnQgeyBjbG9uZSwgZHJvcCwgZHJvcFJpZ2h0LCBmaXJzdCBhcyBfZmlyc3QsIGZvckVhY2gsIGlzRW1wdHksIGxhc3QsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgZmlyc3QgfSBmcm9tIFwiLi9maXJzdC5qc1wiO1xuaW1wb3J0IHsgUmVzdFdhbGtlciB9IGZyb20gXCIuL3Jlc3QuanNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSwgTm9uVGVybWluYWwsIE9wdGlvbiwgUmVwZXRpdGlvbiwgUmVwZXRpdGlvbk1hbmRhdG9yeSwgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBSdWxlLCBUZXJtaW5hbCwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0TmV4dFBvc3NpYmxlVG9rZW5zV2Fsa2VyIGV4dGVuZHMgUmVzdFdhbGtlciB7XG4gICAgY29uc3RydWN0b3IodG9wUHJvZCwgcGF0aCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcFByb2QgPSB0b3BQcm9kO1xuICAgICAgICB0aGlzLnBhdGggPSBwYXRoO1xuICAgICAgICB0aGlzLnBvc3NpYmxlVG9rVHlwZXMgPSBbXTtcbiAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgPSBcIlwiO1xuICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgIHRoaXMuZm91bmQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0F0RW5kT2ZQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIHN0YXJ0V2Fsa2luZygpIHtcbiAgICAgICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5wYXRoLnJ1bGVTdGFja1swXSAhPT0gdGhpcy50b3BQcm9kLm5hbWUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVGhlIHBhdGggZG9lcyBub3Qgc3RhcnQgd2l0aCB0aGUgd2Fsa2VyJ3MgdG9wIFJ1bGUhXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGltbXV0YWJsZSBmb3IgdGhlIHdpblxuICAgICAgICB0aGlzLnJ1bGVTdGFjayA9IGNsb25lKHRoaXMucGF0aC5ydWxlU3RhY2spLnJldmVyc2UoKTsgLy8gaW50ZWxpaiBidWcgcmVxdWlyZXMgYXNzZXJ0aW9uXG4gICAgICAgIHRoaXMub2NjdXJyZW5jZVN0YWNrID0gY2xvbmUodGhpcy5wYXRoLm9jY3VycmVuY2VTdGFjaykucmV2ZXJzZSgpOyAvLyBpbnRlbGlqIGJ1ZyByZXF1aXJlcyBhc3NlcnRpb25cbiAgICAgICAgLy8gYWxyZWFkeSB2ZXJpZmllZCB0aGF0IHRoZSBmaXJzdCBwcm9kdWN0aW9uIGlzIHZhbGlkLCB3ZSBub3cgc2VlayB0aGUgMm5kIHByb2R1Y3Rpb25cbiAgICAgICAgdGhpcy5ydWxlU3RhY2sucG9wKCk7XG4gICAgICAgIHRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUV4cGVjdGVkTmV4dCgpO1xuICAgICAgICB0aGlzLndhbGsodGhpcy50b3BQcm9kKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9zc2libGVUb2tUeXBlcztcbiAgICB9XG4gICAgd2Fsayhwcm9kLCBwcmV2UmVzdCA9IFtdKSB7XG4gICAgICAgIC8vIHN0b3Agc2Nhbm5pbmcgb25jZSB3ZSBmb3VuZCB0aGUgcGF0aFxuICAgICAgICBpZiAoIXRoaXMuZm91bmQpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGsocHJvZCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhbGtQcm9kUmVmKHJlZlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBmb3VuZCB0aGUgbmV4dCBwcm9kdWN0aW9uLCBuZWVkIHRvIGtlZXAgd2Fsa2luZyBpbiBpdFxuICAgICAgICBpZiAocmVmUHJvZC5yZWZlcmVuY2VkUnVsZS5uYW1lID09PSB0aGlzLm5leHRQcm9kdWN0aW9uTmFtZSAmJlxuICAgICAgICAgICAgcmVmUHJvZC5pZHggPT09IHRoaXMubmV4dFByb2R1Y3Rpb25PY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUV4cGVjdGVkTmV4dCgpO1xuICAgICAgICAgICAgdGhpcy53YWxrKHJlZlByb2QucmVmZXJlbmNlZFJ1bGUsIGZ1bGxSZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVFeHBlY3RlZE5leHQoKSB7XG4gICAgICAgIC8vIG5lZWQgdG8gY29uc3VtZSB0aGUgVGVybWluYWxcbiAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5ydWxlU3RhY2spKSB7XG4gICAgICAgICAgICAvLyBtdXN0IHJlc2V0IG5leHRQcm9kdWN0aW9uWFhYIHRvIGF2b2lkIHdhbGtpbmcgZG93biBhbm90aGVyIFRvcCBMZXZlbCBwcm9kdWN0aW9uIHdoaWxlIHdoYXQgd2UgYXJlXG4gICAgICAgICAgICAvLyByZWFsbHkgc2Vla2luZyBpcyB0aGUgbGFzdCBUZXJtaW5hbC4uLlxuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgdGhpcy5uZXh0UHJvZHVjdGlvbk9jY3VycmVuY2UgPSAwO1xuICAgICAgICAgICAgdGhpcy5pc0F0RW5kT2ZQYXRoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubmV4dFByb2R1Y3Rpb25OYW1lID0gdGhpcy5ydWxlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB0aGlzLm5leHRQcm9kdWN0aW9uT2NjdXJyZW5jZSA9IHRoaXMub2NjdXJyZW5jZVN0YWNrLnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5leHRBZnRlclRva2VuV2Fsa2VyIGV4dGVuZHMgQWJzdHJhY3ROZXh0UG9zc2libGVUb2tlbnNXYWxrZXIge1xuICAgIGNvbnN0cnVjdG9yKHRvcFByb2QsIHBhdGgpIHtcbiAgICAgICAgc3VwZXIodG9wUHJvZCwgcGF0aCk7XG4gICAgICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgICAgIHRoaXMubmV4dFRlcm1pbmFsTmFtZSA9IFwiXCI7XG4gICAgICAgIHRoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSA9IDA7XG4gICAgICAgIHRoaXMubmV4dFRlcm1pbmFsTmFtZSA9IHRoaXMucGF0aC5sYXN0VG9rLm5hbWU7XG4gICAgICAgIHRoaXMubmV4dFRlcm1pbmFsT2NjdXJyZW5jZSA9IHRoaXMucGF0aC5sYXN0VG9rT2NjdXJyZW5jZTtcbiAgICB9XG4gICAgd2Fsa1Rlcm1pbmFsKHRlcm1pbmFsLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBdEVuZE9mUGF0aCAmJlxuICAgICAgICAgICAgdGVybWluYWwudGVybWluYWxUeXBlLm5hbWUgPT09IHRoaXMubmV4dFRlcm1pbmFsTmFtZSAmJlxuICAgICAgICAgICAgdGVybWluYWwuaWR4ID09PSB0aGlzLm5leHRUZXJtaW5hbE9jY3VycmVuY2UgJiZcbiAgICAgICAgICAgICF0aGlzLmZvdW5kKSB7XG4gICAgICAgICAgICBjb25zdCBmdWxsUmVzdCA9IGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCk7XG4gICAgICAgICAgICBjb25zdCByZXN0UHJvZCA9IG5ldyBBbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IGZ1bGxSZXN0IH0pO1xuICAgICAgICAgICAgdGhpcy5wb3NzaWJsZVRva1R5cGVzID0gZmlyc3QocmVzdFByb2QpO1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFRoaXMgd2Fsa2VyIG9ubHkgXCJ3YWxrc1wiIGEgc2luZ2xlIFwiVE9QXCIgbGV2ZWwgaW4gdGhlIEdyYW1tYXIgQXN0LCB0aGlzIG1lYW5zXG4gKiBpdCBuZXZlciBcImZvbGxvd3NcIiBwcm9kdWN0aW9uIHJlZnNcbiAqL1xuZXhwb3J0IGNsYXNzIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyIGV4dGVuZHMgUmVzdFdhbGtlciB7XG4gICAgY29uc3RydWN0b3IodG9wUnVsZSwgb2NjdXJyZW5jZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcFJ1bGUgPSB0b3BSdWxlO1xuICAgICAgICB0aGlzLm9jY3VycmVuY2UgPSBvY2N1cnJlbmNlO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHtcbiAgICAgICAgICAgIHRva2VuOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBvY2N1cnJlbmNlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBpc0VuZE9mUnVsZTogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzdGFydFdhbGtpbmcoKSB7XG4gICAgICAgIHRoaXMud2Fsayh0aGlzLnRvcFJ1bGUpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZXN1bHQ7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciBleHRlbmRzIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyIHtcbiAgICB3YWxrTWFueShtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChtYW55UHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RBZnRlck1hbnkgPSBfZmlyc3QoY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KSk7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5pc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJNYW55ID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoZmlyc3RBZnRlck1hbnkgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlck1hbnkudGVybWluYWxUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0Lm9jY3VycmVuY2UgPSBmaXJzdEFmdGVyTWFueS5pZHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci53YWxrTWFueShtYW55UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIgZXh0ZW5kcyBBYnN0cmFjdE5leHRUZXJtaW5hbEFmdGVyUHJvZHVjdGlvbldhbGtlciB7XG4gICAgd2Fsa01hbnlTZXAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAobWFueVNlcFByb2QuaWR4ID09PSB0aGlzLm9jY3VycmVuY2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0QWZ0ZXJNYW55U2VwID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyTWFueVNlcCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKGZpcnN0QWZ0ZXJNYW55U2VwIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC50b2tlbiA9IGZpcnN0QWZ0ZXJNYW55U2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlck1hbnlTZXAuaWR4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3VwZXIud2Fsa01hbnlTZXAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyIGV4dGVuZHMgQWJzdHJhY3ROZXh0VGVybWluYWxBZnRlclByb2R1Y3Rpb25XYWxrZXIge1xuICAgIHdhbGtBdExlYXN0T25lKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKGF0TGVhc3RPbmVQcm9kLmlkeCA9PT0gdGhpcy5vY2N1cnJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdEFmdGVyQXRMZWFzdE9uZSA9IF9maXJzdChjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpKTtcbiAgICAgICAgICAgIHRoaXMucmVzdWx0LmlzRW5kT2ZSdWxlID0gZmlyc3RBZnRlckF0TGVhc3RPbmUgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyQXRMZWFzdE9uZSBpbnN0YW5jZW9mIFRlcm1pbmFsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQudG9rZW4gPSBmaXJzdEFmdGVyQXRMZWFzdE9uZS50ZXJtaW5hbFR5cGU7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQub2NjdXJyZW5jZSA9IGZpcnN0QWZ0ZXJBdExlYXN0T25lLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtBdExlYXN0T25lKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8gVE9ETzogcmVkdWNlIGNvZGUgZHVwbGljYXRpb24gaW4gdGhlIEFmdGVyV2Fsa2Vyc1xuZXhwb3J0IGNsYXNzIE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciBleHRlbmRzIEFic3RyYWN0TmV4dFRlcm1pbmFsQWZ0ZXJQcm9kdWN0aW9uV2Fsa2VyIHtcbiAgICB3YWxrQXRMZWFzdE9uZVNlcChhdGxlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChhdGxlYXN0T25lU2VwUHJvZC5pZHggPT09IHRoaXMub2NjdXJyZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwID0gX2ZpcnN0KGN1cnJSZXN0LmNvbmNhdChwcmV2UmVzdCkpO1xuICAgICAgICAgICAgdGhpcy5yZXN1bHQuaXNFbmRPZlJ1bGUgPSBmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChmaXJzdEFmdGVyZmlyc3RBZnRlckF0TGVhc3RPbmVTZXAgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdWx0LnRva2VuID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLnRlcm1pbmFsVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdC5vY2N1cnJlbmNlID0gZmlyc3RBZnRlcmZpcnN0QWZ0ZXJBdExlYXN0T25lU2VwLmlkeDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtBdExlYXN0T25lU2VwKGF0bGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3NpYmxlUGF0aHNGcm9tKHRhcmdldERlZiwgbWF4TGVuZ3RoLCBjdXJyUGF0aCA9IFtdKSB7XG4gICAgLy8gYXZvaWQgc2lkZSBlZmZlY3RzXG4gICAgY3VyclBhdGggPSBjbG9uZShjdXJyUGF0aCk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBpID0gMDtcbiAgICAvLyBUT0RPOiBhdm9pZCBpbm5lciBmdW5jc1xuICAgIGZ1bmN0aW9uIHJlbWFpbmluZ1BhdGhXaXRoKG5leHREZWYpIHtcbiAgICAgICAgcmV0dXJuIG5leHREZWYuY29uY2F0KGRyb3AodGFyZ2V0RGVmLCBpICsgMSkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBhdm9pZCBpbm5lciBmdW5jc1xuICAgIGZ1bmN0aW9uIGdldEFsdGVybmF0aXZlc0ZvclByb2QoZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBhbHRlcm5hdGl2ZXMgPSBwb3NzaWJsZVBhdGhzRnJvbShyZW1haW5pbmdQYXRoV2l0aChkZWZpbml0aW9uKSwgbWF4TGVuZ3RoLCBjdXJyUGF0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQuY29uY2F0KGFsdGVybmF0aXZlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hbmRhdG9yeSBwcm9kdWN0aW9ucyB3aWxsIGhhbHQgdGhlIGxvb3AgYXMgdGhlIHBhdGhzIGNvbXB1dGVkIGZyb20gdGhlaXIgcmVjdXJzaXZlIGNhbGxzIHdpbGwgYWxyZWFkeSBjb250YWluIHRoZVxuICAgICAqIGZvbGxvd2luZyAocmVzdCkgb2YgdGhlIHRhcmdldERlZi5cbiAgICAgKlxuICAgICAqIEZvciBvcHRpb25hbCBwcm9kdWN0aW9ucyAoT3B0aW9uL1JlcGV0aXRpb24vLi4uKSB0aGUgbG9vcCB3aWxsIGNvbnRpbnVlIHRvIHJlcHJlc2VudCB0aGUgcGF0aHMgdGhhdCBkbyBub3QgaW5jbHVkZSB0aGVcbiAgICAgKiB0aGUgb3B0aW9uYWwgcHJvZHVjdGlvbi5cbiAgICAgKi9cbiAgICB3aGlsZSAoY3VyclBhdGgubGVuZ3RoIDwgbWF4TGVuZ3RoICYmIGkgPCB0YXJnZXREZWYubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHByb2QgPSB0YXJnZXREZWZbaV07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChwcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKHByb2QuZGVmaW5pdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIE5vblRlcm1pbmFsKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChwcm9kLmRlZmluaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBPcHRpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGdldEFsdGVybmF0aXZlc0ZvclByb2QocHJvZC5kZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgY29uc3QgbmV3RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbXG4gICAgICAgICAgICAgICAgbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBwcm9kLmRlZmluaXRpb24sXG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZWYgPSBbXG4gICAgICAgICAgICAgICAgbmV3IEFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uIH0pLFxuICAgICAgICAgICAgICAgIG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogW25ldyBUZXJtaW5hbCh7IHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3IgfSldLmNvbmNhdChwcm9kLmRlZmluaXRpb24pLFxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHJldHVybiBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKG5ld0RlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IFtuZXcgVGVybWluYWwoeyB0ZXJtaW5hbFR5cGU6IHByb2Quc2VwYXJhdG9yIH0pXS5jb25jYXQocHJvZC5kZWZpbml0aW9uKSxcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdEZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtcbiAgICAgICAgICAgICAgICBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmVzdWx0ID0gZ2V0QWx0ZXJuYXRpdmVzRm9yUHJvZChuZXdEZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgZm9yRWFjaChwcm9kLmRlZmluaXRpb24sIChjdXJyQWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogdGhpcyBpcyBhIGxpbWl0ZWQgY2hlY2sgZm9yIGVtcHR5IGFsdGVybmF0aXZlc1xuICAgICAgICAgICAgICAgIC8vICAgSXQgd291bGQgcHJldmVudCBhIGNvbW1vbiBjYXNlIG9mIGluZmluaXRlIGxvb3BzIGR1cmluZyBwYXJzZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgICAgICAgICAgICAgLy8gICBIb3dldmVyICoqaW4tZGlyZWN0bHkqKiBlbXB0eSBhbHRlcm5hdGl2ZXMgbWF5IHN0aWxsIGNhdXNlIGlzc3Vlcy5cbiAgICAgICAgICAgICAgICBpZiAoaXNFbXB0eShjdXJyQWx0LmRlZmluaXRpb24pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSBnZXRBbHRlcm5hdGl2ZXNGb3JQcm9kKGN1cnJBbHQuZGVmaW5pdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgY3VyclBhdGgucHVzaChwcm9kLnRlcm1pbmFsVHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goe1xuICAgICAgICBwYXJ0aWFsUGF0aDogY3VyclBhdGgsXG4gICAgICAgIHN1ZmZpeERlZjogZHJvcCh0YXJnZXREZWYsIGkpLFxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoaW5pdGlhbERlZiwgdG9rZW5WZWN0b3IsIHRva01hdGNoZXIsIG1heExvb2tBaGVhZCkge1xuICAgIGNvbnN0IEVYSVRfTk9OX1RFUk1JTkFMID0gXCJFWElUX05PTkVfVEVSTUlOQUxcIjtcbiAgICAvLyB0byBhdm9pZCBjcmVhdGluZyBhIG5ldyBBcnJheSBlYWNoIHRpbWUuXG4gICAgY29uc3QgRVhJVF9OT05fVEVSTUlOQUxfQVJSID0gW0VYSVRfTk9OX1RFUk1JTkFMXTtcbiAgICBjb25zdCBFWElUX0FMVEVSTkFUSVZFID0gXCJFWElUX0FMVEVSTkFUSVZFXCI7XG4gICAgbGV0IGZvdW5kQ29tcGxldGVQYXRoID0gZmFsc2U7XG4gICAgY29uc3QgdG9rZW5WZWN0b3JMZW5ndGggPSB0b2tlblZlY3Rvci5sZW5ndGg7XG4gICAgY29uc3QgbWluaW1hbEFsdGVybmF0aXZlc0luZGV4ID0gdG9rZW5WZWN0b3JMZW5ndGggLSBtYXhMb29rQWhlYWQgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IHBvc3NpYmxlUGF0aHMgPSBbXTtcbiAgICBwb3NzaWJsZVBhdGhzLnB1c2goe1xuICAgICAgICBpZHg6IC0xLFxuICAgICAgICBkZWY6IGluaXRpYWxEZWYsXG4gICAgICAgIHJ1bGVTdGFjazogW10sXG4gICAgICAgIG9jY3VycmVuY2VTdGFjazogW10sXG4gICAgfSk7XG4gICAgd2hpbGUgKCFpc0VtcHR5KHBvc3NpYmxlUGF0aHMpKSB7XG4gICAgICAgIGNvbnN0IGN1cnJQYXRoID0gcG9zc2libGVQYXRocy5wb3AoKTtcbiAgICAgICAgLy8gc2tpcCBhbHRlcm5hdGl2ZXMgaWYgbm8gbW9yZSByZXN1bHRzIGNhbiBiZSBmb3VuZCAoYXNzdW1pbmcgZGV0ZXJtaW5pc3RpYyBncmFtbWFyIHdpdGggZml4ZWQgbG9va2FoZWFkKVxuICAgICAgICBpZiAoY3VyclBhdGggPT09IEVYSVRfQUxURVJOQVRJVkUpIHtcbiAgICAgICAgICAgIGlmIChmb3VuZENvbXBsZXRlUGF0aCAmJlxuICAgICAgICAgICAgICAgIGxhc3QocG9zc2libGVQYXRocykuaWR4IDw9IG1pbmltYWxBbHRlcm5hdGl2ZXNJbmRleCkge1xuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBpcnJlbGV2YW50IGFsdGVybmF0aXZlXG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1cnJEZWYgPSBjdXJyUGF0aC5kZWY7XG4gICAgICAgIGNvbnN0IGN1cnJJZHggPSBjdXJyUGF0aC5pZHg7XG4gICAgICAgIGNvbnN0IGN1cnJSdWxlU3RhY2sgPSBjdXJyUGF0aC5ydWxlU3RhY2s7XG4gICAgICAgIGNvbnN0IGN1cnJPY2N1cnJlbmNlU3RhY2sgPSBjdXJyUGF0aC5vY2N1cnJlbmNlU3RhY2s7XG4gICAgICAgIC8vIEZvciBFeGFtcGxlOiBhbiBlbXB0eSBwYXRoIGNvdWxkIGV4aXN0IGluIGEgdmFsaWQgZ3JhbW1hciBpbiB0aGUgY2FzZSBvZiBhbiBFTVBUWV9BTFRcbiAgICAgICAgaWYgKGlzRW1wdHkoY3VyckRlZikpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb2QgPSBjdXJyRGVmWzBdO1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAocHJvZCA9PT0gRVhJVF9OT05fVEVSTUlOQUwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBkcm9wUmlnaHQoY3VyclJ1bGVTdGFjayksXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBkcm9wUmlnaHQoY3Vyck9jY3VycmVuY2VTdGFjayksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgVGVybWluYWwpIHtcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoY3VycklkeCA8IHRva2VuVmVjdG9yTGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHRJZHggPSBjdXJySWR4ICsgMTtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3R1YWxUb2tlbiA9IHRva2VuVmVjdG9yW25leHRJZHhdO1xuICAgICAgICAgICAgICAgIGlmICh0b2tNYXRjaGVyKGFjdHVhbFRva2VuLCBwcm9kLnRlcm1pbmFsVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHg6IG5leHRJZHgsXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWY6IGRyb3AoY3VyckRlZiksXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGVuZCBvZiB0aGUgbGluZVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY3VycklkeCA9PT0gdG9rZW5WZWN0b3JMZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgLy8gSUdOT1JFIEFCT1ZFIEVMU0VcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5leHRUb2tlblR5cGU6IHByb2QudGVybWluYWxUeXBlLFxuICAgICAgICAgICAgICAgICAgICBuZXh0VG9rZW5PY2N1cnJlbmNlOiBwcm9kLmlkeCxcbiAgICAgICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm91bmRDb21wbGV0ZVBhdGggPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgTm9uVGVybWluYWwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1J1bGVTdGFjayA9IGNsb25lKGN1cnJSdWxlU3RhY2spO1xuICAgICAgICAgICAgbmV3UnVsZVN0YWNrLnB1c2gocHJvZC5ub25UZXJtaW5hbE5hbWUpO1xuICAgICAgICAgICAgY29uc3QgbmV3T2NjdXJyZW5jZVN0YWNrID0gY2xvbmUoY3Vyck9jY3VycmVuY2VTdGFjayk7XG4gICAgICAgICAgICBuZXdPY2N1cnJlbmNlU3RhY2sucHVzaChwcm9kLmlkeCk7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBwcm9kLmRlZmluaXRpb24uY29uY2F0KEVYSVRfTk9OX1RFUk1JTkFMX0FSUiwgZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBuZXdSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBuZXdPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aFdpdGhvdXQgPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFBhdGhXaXRoID0ge1xuICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICBkZWY6IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoZHJvcChjdXJyRGVmKSksXG4gICAgICAgICAgICAgICAgcnVsZVN0YWNrOiBjdXJyUnVsZVN0YWNrLFxuICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2gobmV4dFBhdGhXaXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgLy8gVE9ETzooVEhFIE5FVyBvcGVyYXRvcnMgaGVyZSB0YWtlIGEgd2hpbGUuLi4pIChjb252ZXJ0IG9uY2U/KVxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kSXRlcmF0aW9uID0gbmV3IFJlcGV0aXRpb24oe1xuICAgICAgICAgICAgICAgIGRlZmluaXRpb246IHByb2QuZGVmaW5pdGlvbixcbiAgICAgICAgICAgICAgICBpZHg6IHByb2QuaWR4LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0RGVmID0gcHJvZC5kZWZpbml0aW9uLmNvbmNhdChbc2Vjb25kSXRlcmF0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3IpIHtcbiAgICAgICAgICAgIC8vIFRPRE86KFRIRSBORVcgb3BlcmF0b3JzIGhlcmUgdGFrZSBhIHdoaWxlLi4uKSAoY29udmVydCBvbmNlPylcbiAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckdhc3QgPSBuZXcgVGVybWluYWwoe1xuICAgICAgICAgICAgICAgIHRlcm1pbmFsVHlwZTogcHJvZC5zZXBhcmF0b3IsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZEl0ZXJhdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbc2VwYXJhdG9yR2FzdF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW3NlY29uZEl0ZXJhdGlvbl0sIGRyb3AoY3VyckRlZikpO1xuICAgICAgICAgICAgY29uc3QgbmV4dFBhdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAvLyB0aGUgb3JkZXIgb2YgYWx0ZXJuYXRpdmVzIGlzIG1lYW5pbmdmdWwsIEZJTE8gKExhc3QgcGF0aCB3aWxsIGJlIHRyYXZlcnNlZCBmaXJzdCkuXG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aFdpdGhvdXQgPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogZHJvcChjdXJyRGVmKSxcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGhvdXQpO1xuICAgICAgICAgICAgLy8gcmVxdWlyZWQgbWFya2VyIHRvIGF2b2lkIGJhY2t0cmFja2luZyBwYXRocyB3aG9zZSBoaWdoZXIgcHJpb3JpdHkgYWx0ZXJuYXRpdmVzIGFscmVhZHkgbWF0Y2hlZFxuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgY29uc3Qgc2VwYXJhdG9yR2FzdCA9IG5ldyBUZXJtaW5hbCh7XG4gICAgICAgICAgICAgICAgdGVybWluYWxUeXBlOiBwcm9kLnNlcGFyYXRvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbnRoUmVwZXRpdGlvbiA9IG5ldyBSZXBldGl0aW9uKHtcbiAgICAgICAgICAgICAgICBkZWZpbml0aW9uOiBbc2VwYXJhdG9yR2FzdF0uY29uY2F0KHByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgICAgICAgICAgaWR4OiBwcm9kLmlkeCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dERlZiA9IHByb2QuZGVmaW5pdGlvbi5jb25jYXQoW250aFJlcGV0aXRpb25dLCBkcm9wKGN1cnJEZWYpKTtcbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoV2l0aCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBuZXh0RGVmLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb24pIHtcbiAgICAgICAgICAgIC8vIHRoZSBvcmRlciBvZiBhbHRlcm5hdGl2ZXMgaXMgbWVhbmluZ2Z1bCwgRklMTyAoTGFzdCBwYXRoIHdpbGwgYmUgdHJhdmVyc2VkIGZpcnN0KS5cbiAgICAgICAgICAgIGNvbnN0IG5leHRQYXRoV2l0aG91dCA9IHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBkcm9wKGN1cnJEZWYpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKG5leHRQYXRoV2l0aG91dCk7XG4gICAgICAgICAgICAvLyByZXF1aXJlZCBtYXJrZXIgdG8gYXZvaWQgYmFja3RyYWNraW5nIHBhdGhzIHdob3NlIGhpZ2hlciBwcmlvcml0eSBhbHRlcm5hdGl2ZXMgYWxyZWFkeSBtYXRjaGVkXG4gICAgICAgICAgICBwb3NzaWJsZVBhdGhzLnB1c2goRVhJVF9BTFRFUk5BVElWRSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBhbiBlbXB0eSByZXBldGl0aW9uIHdpbGwgY2F1c2UgaW5maW5pdGUgbG9vcHMgaGVyZSwgd2lsbCB0aGUgcGFyc2VyIGRldGVjdCB0aGlzIGluIHNlbGZBbmFseXNpcz9cbiAgICAgICAgICAgIGNvbnN0IG50aFJlcGV0aXRpb24gPSBuZXcgUmVwZXRpdGlvbih7XG4gICAgICAgICAgICAgICAgZGVmaW5pdGlvbjogcHJvZC5kZWZpbml0aW9uLFxuICAgICAgICAgICAgICAgIGlkeDogcHJvZC5pZHgsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IG5leHREZWYgPSBwcm9kLmRlZmluaXRpb24uY29uY2F0KFtudGhSZXBldGl0aW9uXSwgZHJvcChjdXJyRGVmKSk7XG4gICAgICAgICAgICBjb25zdCBuZXh0UGF0aFdpdGggPSB7XG4gICAgICAgICAgICAgICAgaWR4OiBjdXJySWR4LFxuICAgICAgICAgICAgICAgIGRlZjogbmV4dERlZixcbiAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgb2NjdXJyZW5jZVN0YWNrOiBjdXJyT2NjdXJyZW5jZVN0YWNrLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChuZXh0UGF0aFdpdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbikge1xuICAgICAgICAgICAgLy8gdGhlIG9yZGVyIG9mIGFsdGVybmF0aXZlcyBpcyBtZWFuaW5nZnVsLCBGSUxPIChMYXN0IHBhdGggd2lsbCBiZSB0cmF2ZXJzZWQgZmlyc3QpLlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHByb2QuZGVmaW5pdGlvbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJBbHQgPSBwcm9kLmRlZmluaXRpb25baV07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdFBhdGggPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgICAgICAgICAgICAgZGVmOiBjdXJyQWx0LmRlZmluaXRpb24uY29uY2F0KGRyb3AoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgICAgICBydWxlU3RhY2s6IGN1cnJSdWxlU3RhY2ssXG4gICAgICAgICAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogY3Vyck9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChjdXJyQWx0UGF0aCk7XG4gICAgICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKEVYSVRfQUxURVJOQVRJVkUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGl2ZSkge1xuICAgICAgICAgICAgcG9zc2libGVQYXRocy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZHg6IGN1cnJJZHgsXG4gICAgICAgICAgICAgICAgZGVmOiBwcm9kLmRlZmluaXRpb24uY29uY2F0KGRyb3AoY3VyckRlZikpLFxuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogY3VyclJ1bGVTdGFjayxcbiAgICAgICAgICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IGN1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUnVsZSkge1xuICAgICAgICAgICAgLy8gbGFzdCBiZWNhdXNlIHdlIHNob3VsZCBvbmx5IGVuY291bnRlciBhdCBtb3N0IGEgc2luZ2xlIG9uZSBvZiB0aGVzZSBwZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICAgIHBvc3NpYmxlUGF0aHMucHVzaChleHBhbmRUb3BMZXZlbFJ1bGUocHJvZCwgY3VycklkeCwgY3VyclJ1bGVTdGFjaywgY3Vyck9jY3VycmVuY2VTdGFjaykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZXhwYW5kVG9wTGV2ZWxSdWxlKHRvcFJ1bGUsIGN1cnJJZHgsIGN1cnJSdWxlU3RhY2ssIGN1cnJPY2N1cnJlbmNlU3RhY2spIHtcbiAgICBjb25zdCBuZXdSdWxlU3RhY2sgPSBjbG9uZShjdXJyUnVsZVN0YWNrKTtcbiAgICBuZXdSdWxlU3RhY2sucHVzaCh0b3BSdWxlLm5hbWUpO1xuICAgIGNvbnN0IG5ld0N1cnJPY2N1cnJlbmNlU3RhY2sgPSBjbG9uZShjdXJyT2NjdXJyZW5jZVN0YWNrKTtcbiAgICAvLyB0b3AgcnVsZSBpcyBhbHdheXMgYXNzdW1lZCB0byBoYXZlIGJlZW4gY2FsbGVkIHdpdGggb2NjdXJyZW5jZSBpbmRleCAxXG4gICAgbmV3Q3Vyck9jY3VycmVuY2VTdGFjay5wdXNoKDEpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkeDogY3VycklkeCxcbiAgICAgICAgZGVmOiB0b3BSdWxlLmRlZmluaXRpb24sXG4gICAgICAgIHJ1bGVTdGFjazogbmV3UnVsZVN0YWNrLFxuICAgICAgICBvY2N1cnJlbmNlU3RhY2s6IG5ld0N1cnJPY2N1cnJlbmNlU3RhY2ssXG4gICAgfTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVycHJldGVyLmpzLm1hcCIsIi8vIExvb2thaGVhZCBrZXlzIGFyZSAzMkJpdCBpbnRlZ2VycyBpbiB0aGUgZm9ybVxuLy8gVFRUVFRUVFQtWlpaWlpaWlpaWlpaLVlZWVktWFhYWFhYWFhcbi8vIFhYWFggLT4gT2NjdXJyZW5jZSBJbmRleCBiaXRtYXAuXG4vLyBZWVlZIC0+IERTTCBNZXRob2QgVHlwZSBiaXRtYXAuXG4vLyBaWlpaWlpaWlpaWlpaWlogLT4gUnVsZSBzaG9ydCBJbmRleCBiaXRtYXAuXG4vLyBUVFRUVFRUVFQgLT4gYWx0ZXJuYXRpb24gYWx0ZXJuYXRpdmUgaW5kZXggYml0bWFwXG5leHBvcnQgY29uc3QgQklUU19GT1JfTUVUSE9EX1RZUEUgPSA0O1xuZXhwb3J0IGNvbnN0IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYID0gODtcbmV4cG9ydCBjb25zdCBCSVRTX0ZPUl9SVUxFX0lEWCA9IDEyO1xuLy8gVE9ETzogdmFsaWRhdGlvbiwgdGhpcyBtZWFucyB0aGF0IHRoZXJlIG1heSBhdCBtb3N0IDJeOCAtLT4gMjU2IGFsdGVybmF0aXZlcyBmb3IgYW4gYWx0ZXJuYXRpb24uXG5leHBvcnQgY29uc3QgQklUU19GT1JfQUxUX0lEWCA9IDg7XG4vLyBzaG9ydCBzdHJpbmcgdXNlZCBhcyBwYXJ0IG9mIG1hcHBpbmcga2V5cy5cbi8vIGJlaW5nIHNob3J0IGltcHJvdmVzIHRoZSBwZXJmb3JtYW5jZSB3aGVuIGNvbXBvc2luZyBLRVlTIGZvciBtYXBzIG91dCBvZiB0aGVzZVxuLy8gVGhlIDUgLSA4IGJpdHMgKDE2IHBvc3NpYmxlIHZhbHVlcywgYXJlIHJlc2VydmVkIGZvciB0aGUgRFNMIG1ldGhvZCBpbmRpY2VzKVxuZXhwb3J0IGNvbnN0IE9SX0lEWCA9IDEgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgY29uc3QgT1BUSU9OX0lEWCA9IDIgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgY29uc3QgTUFOWV9JRFggPSAzIDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0IGNvbnN0IEFUX0xFQVNUX09ORV9JRFggPSA0IDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuZXhwb3J0IGNvbnN0IE1BTllfU0VQX0lEWCA9IDUgPDwgQklUU19GT1JfT0NDVVJSRU5DRV9JRFg7XG5leHBvcnQgY29uc3QgQVRfTEVBU1RfT05FX1NFUF9JRFggPSA2IDw8IEJJVFNfRk9SX09DQ1VSUkVOQ0VfSURYO1xuLy8gdGhpcyBhY3R1YWxseSByZXR1cm5zIGEgbnVtYmVyLCBidXQgaXQgaXMgYWx3YXlzIHVzZWQgYXMgYSBzdHJpbmcgKG9iamVjdCBwcm9wIGtleSlcbmV4cG9ydCBmdW5jdGlvbiBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQocnVsZUlkeCwgZHNsTWV0aG9kSWR4LCBvY2N1cnJlbmNlKSB7XG4gICAgcmV0dXJuIG9jY3VycmVuY2UgfCBkc2xNZXRob2RJZHggfCBydWxlSWR4O1xufVxuY29uc3QgQklUU19TVEFSVF9GT1JfQUxUX0lEWCA9IDMyIC0gQklUU19GT1JfQUxUX0lEWDtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXMuanMubWFwIiwiaW1wb3J0IHsgZmxhdE1hcCwgaXNFbXB0eSB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IGRlZmF1bHRHcmFtbWFyVmFsaWRhdG9yRXJyb3JQcm92aWRlciB9IGZyb20gXCIuLi9lcnJvcnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1BBUlNFUl9DT05GSUcgfSBmcm9tIFwiLi4vcGFyc2VyL3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcywgdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmUsIHZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uLCB2YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgsIH0gZnJvbSBcIi4vY2hlY2tzLmpzXCI7XG5pbXBvcnQgeyBidWlsZEFsdGVybmF0aXZlc0xvb2tBaGVhZEZ1bmMsIGJ1aWxkTG9va2FoZWFkRnVuY0Zvck9wdGlvbmFsUHJvZCwgYnVpbGRMb29rYWhlYWRGdW5jRm9yT3IsIGJ1aWxkU2luZ2xlQWx0ZXJuYXRpdmVMb29rYWhlYWRGdW5jdGlvbiwgZ2V0UHJvZFR5cGUsIH0gZnJvbSBcIi4vbG9va2FoZWFkLmpzXCI7XG5leHBvcnQgY2xhc3MgTExrTG9va2FoZWFkU3RyYXRlZ3kge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm1heExvb2thaGVhZCA9XG4gICAgICAgICAgICAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWF4TG9va2FoZWFkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcubWF4TG9va2FoZWFkO1xuICAgIH1cbiAgICB2YWxpZGF0ZShvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGxlZnRSZWN1cnNpb25FcnJvcnMgPSB0aGlzLnZhbGlkYXRlTm9MZWZ0UmVjdXJzaW9uKG9wdGlvbnMucnVsZXMpO1xuICAgICAgICBpZiAoaXNFbXB0eShsZWZ0UmVjdXJzaW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgY29uc3QgZW1wdHlBbHRFcnJvcnMgPSB0aGlzLnZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlcyhvcHRpb25zLnJ1bGVzKTtcbiAgICAgICAgICAgIGNvbnN0IGFtYmlndW91c0FsdHNFcnJvcnMgPSB0aGlzLnZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMob3B0aW9ucy5ydWxlcywgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICAgICAgY29uc3QgZW1wdHlSZXBldGl0aW9uRXJyb3JzID0gdGhpcy52YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgob3B0aW9ucy5ydWxlcywgdGhpcy5tYXhMb29rYWhlYWQpO1xuICAgICAgICAgICAgY29uc3QgYWxsRXJyb3JzID0gW1xuICAgICAgICAgICAgICAgIC4uLmxlZnRSZWN1cnNpb25FcnJvcnMsXG4gICAgICAgICAgICAgICAgLi4uZW1wdHlBbHRFcnJvcnMsXG4gICAgICAgICAgICAgICAgLi4uYW1iaWd1b3VzQWx0c0Vycm9ycyxcbiAgICAgICAgICAgICAgICAuLi5lbXB0eVJlcGV0aXRpb25FcnJvcnMsXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcmV0dXJuIGFsbEVycm9ycztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGVmdFJlY3Vyc2lvbkVycm9ycztcbiAgICB9XG4gICAgdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24ocnVsZXMpIHtcbiAgICAgICAgcmV0dXJuIGZsYXRNYXAocnVsZXMsIChjdXJyVG9wUnVsZSkgPT4gdmFsaWRhdGVOb0xlZnRSZWN1cnNpb24oY3VyclRvcFJ1bGUsIGN1cnJUb3BSdWxlLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIpKTtcbiAgICB9XG4gICAgdmFsaWRhdGVFbXB0eU9yQWx0ZXJuYXRpdmVzKHJ1bGVzKSB7XG4gICAgICAgIHJldHVybiBmbGF0TWFwKHJ1bGVzLCAoY3VyclRvcFJ1bGUpID0+IHZhbGlkYXRlRW1wdHlPckFsdGVybmF0aXZlKGN1cnJUb3BSdWxlLCBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIpKTtcbiAgICB9XG4gICAgdmFsaWRhdGVBbWJpZ3VvdXNBbHRlcm5hdGlvbkFsdGVybmF0aXZlcyhydWxlcywgbWF4TG9va2FoZWFkKSB7XG4gICAgICAgIHJldHVybiBmbGF0TWFwKHJ1bGVzLCAoY3VyclRvcFJ1bGUpID0+IHZhbGlkYXRlQW1iaWd1b3VzQWx0ZXJuYXRpb25BbHRlcm5hdGl2ZXMoY3VyclRvcFJ1bGUsIG1heExvb2thaGVhZCwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyKSk7XG4gICAgfVxuICAgIHZhbGlkYXRlU29tZU5vbkVtcHR5TG9va2FoZWFkUGF0aChydWxlcywgbWF4TG9va2FoZWFkKSB7XG4gICAgICAgIHJldHVybiB2YWxpZGF0ZVNvbWVOb25FbXB0eUxvb2thaGVhZFBhdGgocnVsZXMsIG1heExvb2thaGVhZCwgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyKTtcbiAgICB9XG4gICAgYnVpbGRMb29rYWhlYWRGb3JBbHRlcm5hdGlvbihvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBidWlsZExvb2thaGVhZEZ1bmNGb3JPcihvcHRpb25zLnByb2RPY2N1cnJlbmNlLCBvcHRpb25zLnJ1bGUsIG9wdGlvbnMubWF4TG9va2FoZWFkLCBvcHRpb25zLmhhc1ByZWRpY2F0ZXMsIG9wdGlvbnMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGJ1aWxkQWx0ZXJuYXRpdmVzTG9va0FoZWFkRnVuYyk7XG4gICAgfVxuICAgIGJ1aWxkTG9va2FoZWFkRm9yT3B0aW9uYWwob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9wdGlvbnMucHJvZE9jY3VycmVuY2UsIG9wdGlvbnMucnVsZSwgb3B0aW9ucy5tYXhMb29rYWhlYWQsIG9wdGlvbnMuZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGdldFByb2RUeXBlKG9wdGlvbnMucHJvZFR5cGUpLCBidWlsZFNpbmdsZUFsdGVybmF0aXZlTG9va2FoZWFkRnVuY3Rpb24pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxsa19sb29rYWhlYWQuanMubWFwIiwiaW1wb3J0IHsgZXZlcnksIGZsYXR0ZW4sIGZvckVhY2gsIGhhcywgaXNFbXB0eSwgbWFwLCByZWR1Y2UgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBwb3NzaWJsZVBhdGhzRnJvbSB9IGZyb20gXCIuL2ludGVycHJldGVyLmpzXCI7XG5pbXBvcnQgeyBSZXN0V2Fsa2VyIH0gZnJvbSBcIi4vcmVzdC5qc1wiO1xuaW1wb3J0IHsgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciwgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcywgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnMuanNcIjtcbmltcG9ydCB7IEFsdGVybmF0aW9uLCBBbHRlcm5hdGl2ZSBhcyBBbHRlcm5hdGl2ZUdBU1QsIEdBc3RWaXNpdG9yLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgfSBmcm9tIFwiQGNoZXZyb3RhaW4vZ2FzdFwiO1xuZXhwb3J0IHZhciBQUk9EX1RZUEU7XG4oZnVuY3Rpb24gKFBST0RfVFlQRSkge1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJPUFRJT05cIl0gPSAwXSA9IFwiT1BUSU9OXCI7XG4gICAgUFJPRF9UWVBFW1BST0RfVFlQRVtcIlJFUEVUSVRJT05cIl0gPSAxXSA9IFwiUkVQRVRJVElPTlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OX01BTkRBVE9SWVwiXSA9IDJdID0gXCJSRVBFVElUSU9OX01BTkRBVE9SWVwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUlwiXSA9IDNdID0gXCJSRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUlwiO1xuICAgIFBST0RfVFlQRVtQUk9EX1RZUEVbXCJSRVBFVElUSU9OX1dJVEhfU0VQQVJBVE9SXCJdID0gNF0gPSBcIlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1JcIjtcbiAgICBQUk9EX1RZUEVbUFJPRF9UWVBFW1wiQUxURVJOQVRJT05cIl0gPSA1XSA9IFwiQUxURVJOQVRJT05cIjtcbn0pKFBST0RfVFlQRSB8fCAoUFJPRF9UWVBFID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBnZXRQcm9kVHlwZShwcm9kKSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAocHJvZCBpbnN0YW5jZW9mIE9wdGlvbiB8fCBwcm9kID09PSBcIk9wdGlvblwiKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuT1BUSU9OO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbiB8fCBwcm9kID09PSBcIlJlcGV0aXRpb25cIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT047XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5IHx8XG4gICAgICAgIHByb2QgPT09IFwiUmVwZXRpdGlvbk1hbmRhdG9yeVwiKSB7XG4gICAgICAgIHJldHVybiBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUlk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvciB8fFxuICAgICAgICBwcm9kID09PSBcIlJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yXCIpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWV9XSVRIX1NFUEFSQVRPUjtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJvZCBpbnN0YW5jZW9mIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yIHx8XG4gICAgICAgIHByb2QgPT09IFwiUmVwZXRpdGlvbldpdGhTZXBhcmF0b3JcIikge1xuICAgICAgICByZXR1cm4gUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1I7XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb2QgaW5zdGFuY2VvZiBBbHRlcm5hdGlvbiB8fCBwcm9kID09PSBcIkFsdGVybmF0aW9uXCIpIHtcbiAgICAgICAgcmV0dXJuIFBST0RfVFlQRS5BTFRFUk5BVElPTjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzKG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IG9jY3VycmVuY2UsIHJ1bGUsIHByb2RUeXBlLCBtYXhMb29rYWhlYWQgfSA9IG9wdGlvbnM7XG4gICAgY29uc3QgdHlwZSA9IGdldFByb2RUeXBlKHByb2RUeXBlKTtcbiAgICBpZiAodHlwZSA9PT0gUFJPRF9UWVBFLkFMVEVSTkFUSU9OKSB7XG4gICAgICAgIHJldHVybiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yKG9jY3VycmVuY2UsIHJ1bGUsIG1heExvb2thaGVhZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZSwgdHlwZSwgbWF4TG9va2FoZWFkKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIG1heExvb2thaGVhZCwgaGFzUHJlZGljYXRlcywgZHluYW1pY1Rva2Vuc0VuYWJsZWQsIGxhRnVuY0J1aWxkZXIpIHtcbiAgICBjb25zdCBsb29rQWhlYWRQYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIG1heExvb2thaGVhZCk7XG4gICAgY29uc3QgdG9rZW5NYXRjaGVyID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocylcbiAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICByZXR1cm4gbGFGdW5jQnVpbGRlcihsb29rQWhlYWRQYXRocywgaGFzUHJlZGljYXRlcywgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG59XG4vKipcbiAqICBXaGVuIGRlYWxpbmcgd2l0aCBhbiBPcHRpb25hbCBwcm9kdWN0aW9uIChPUFRJT04vTUFOWS8ybmQgaXRlcmF0aW9uIG9mIEFUX0xFQVNUX09ORS8uLi4pIHdlIG5lZWQgdG8gY29tcGFyZVxuICogIHRoZSBsb29rYWhlYWQgXCJpbnNpZGVcIiB0aGUgcHJvZHVjdGlvbiBhbmQgdGhlIGxvb2thaGVhZCBpbW1lZGlhdGVseSBcImFmdGVyXCIgaXQgaW4gdGhlIHNhbWUgdG9wIGxldmVsIHJ1bGUgKGNvbnRleHQgZnJlZSkuXG4gKlxuICogIEV4YW1wbGU6IGdpdmVuIGEgcHJvZHVjdGlvbjpcbiAqICBBQkMoREUpP0RGXG4gKlxuICogIFRoZSBvcHRpb25hbCAnKERFKT8nIHNob3VsZCBvbmx5IGJlIGVudGVyZWQgaWYgd2Ugc2VlICdERScuIGEgc2luZ2xlIFRva2VuICdEJyBpcyBub3Qgc3VmZmljaWVudCB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d29cbiAqICBhbHRlcm5hdGl2ZXMuXG4gKlxuICogIEByZXR1cm5zIEEgTG9va2FoZWFkIGZ1bmN0aW9uIHdoaWNoIHdpbGwgcmV0dXJuIHRydWUgSUZGIHRoZSBwYXJzZXIgc2hvdWxkIHBhcnNlIHRoZSBPcHRpb25hbCBwcm9kdWN0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMb29rYWhlYWRGdW5jRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBrLCBkeW5hbWljVG9rZW5zRW5hYmxlZCwgcHJvZFR5cGUsIGxvb2thaGVhZEJ1aWxkZXIpIHtcbiAgICBjb25zdCBsb29rQWhlYWRQYXRocyA9IGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBwcm9kVHlwZSwgayk7XG4gICAgY29uc3QgdG9rZW5NYXRjaGVyID0gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocylcbiAgICAgICAgPyB0b2tlblN0cnVjdHVyZWRNYXRjaGVyTm9DYXRlZ29yaWVzXG4gICAgICAgIDogdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcjtcbiAgICByZXR1cm4gbG9va2FoZWFkQnVpbGRlcihsb29rQWhlYWRQYXRoc1swXSwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCk7XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRBbHRlcm5hdGl2ZXNMb29rQWhlYWRGdW5jKGFsdHMsIGhhc1ByZWRpY2F0ZXMsIHRva2VuTWF0Y2hlciwgZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICBjb25zdCBudW1PZkFsdHMgPSBhbHRzLmxlbmd0aDtcbiAgICBjb25zdCBhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCA9IGV2ZXJ5KGFsdHMsIChjdXJyQWx0KSA9PiB7XG4gICAgICAgIHJldHVybiBldmVyeShjdXJyQWx0LCAoY3VyclBhdGgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyUGF0aC5sZW5ndGggPT09IDE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIC8vIFRoaXMgdmVyc2lvbiB0YWtlcyBpbnRvIGFjY291bnQgdGhlIHByZWRpY2F0ZXMgYXMgd2VsbC5cbiAgICBpZiAoaGFzUHJlZGljYXRlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn0gLSBUaGUgY2hvc2VuIGFsdGVybmF0aXZlIGluZGV4XG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9yQWx0cykge1xuICAgICAgICAgICAgLy8gdW5mb3J0dW5hdGVseSB0aGUgcHJlZGljYXRlcyBtdXN0IGJlIGV4dHJhY3RlZCBldmVyeSBzaW5nbGUgdGltZVxuICAgICAgICAgICAgLy8gYXMgdGhleSBjYW5ub3QgYmUgY2FjaGVkIGR1ZSB0byByZWZlcmVuY2VzIHRvIHBhcmFtZXRlcnModmFycykgd2hpY2ggYXJlIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgICAgICAgIC8vIG5vdGUgdGhhdCBpbiB0aGUgY29tbW9uIGNhc2Ugb2Ygbm8gcHJlZGljYXRlcywgbm8gY3B1IHRpbWUgd2lsbCBiZSB3YXN0ZWQgb24gdGhpcyAoc2VlIGVsc2UgYmxvY2spXG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGVzID0gbWFwKG9yQWx0cywgKGN1cnJBbHQpID0+IGN1cnJBbHQuR0FURSk7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyck51bU9mUGF0aHMgPSBjdXJyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyUHJlZGljYXRlID0gcHJlZGljYXRlc1t0XTtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkICYmIGN1cnJQcmVkaWNhdGUuY2FsbCh0aGlzKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHByZWRpY2F0ZSBkb2VzIG5vdCBtYXRjaCB0aGVyZSBpcyBubyBwb2ludCBpbiBjaGVja2luZyB0aGUgcGF0aHNcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHRQYXRoOiBmb3IgKGxldCBqID0gMDsgaiA8IGN1cnJOdW1PZlBhdGhzOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGggPSBjdXJyQWx0W2pdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyUGF0aExlbmd0aCA9IGN1cnJQYXRoLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbk1hdGNoZXIobmV4dFRva2VuLCBjdXJyUGF0aFtpXSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IHB0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIG5leHRQYXRoO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIGZvdW5kIGEgZnVsbCBwYXRoIHRoYXQgbWF0Y2hlcy5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB3aWxsIGFsc28gd29yayBmb3IgYW4gZW1wdHkgQUxUIGFzIHRoZSBsb29wIHdpbGwgYmUgc2tpcHBlZFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gbm9uZSBvZiB0aGUgcGF0aHMgZm9yIHRoZSBjdXJyZW50IGFsdGVybmF0aXZlIG1hdGNoZWRcbiAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIGFsdGVybmF0aXZlcyBjb3VsZCBiZSBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmVBbGxPbmVUb2tlbkxvb2thaGVhZCAmJiAhZHluYW1pY1Rva2Vuc0VuYWJsZWQpIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIChjb21tb24pIGNhc2Ugb2YgYWxsIHRoZSBsb29rYWhlYWRzIHBhdGhzIHJlcXVpcmluZyBvbmx5XG4gICAgICAgIC8vIGEgc2luZ2xlIHRva2VuIGxvb2thaGVhZC4gVGhlc2UgT3B0aW1pemF0aW9ucyBjYW5ub3Qgd29yayBpZiBkeW5hbWljYWxseSBkZWZpbmVkIFRva2VucyBhcmUgdXNlZC5cbiAgICAgICAgY29uc3Qgc2luZ2xlVG9rZW5BbHRzID0gbWFwKGFsdHMsIChjdXJyQWx0KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gZmxhdHRlbihjdXJyQWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGNob2ljZVRvQWx0ID0gcmVkdWNlKHNpbmdsZVRva2VuQWx0cywgKHJlc3VsdCwgY3VyckFsdCwgaWR4KSA9PiB7XG4gICAgICAgICAgICBmb3JFYWNoKGN1cnJBbHQsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaGFzKHJlc3VsdCwgY3VyclRva1R5cGUudG9rZW5UeXBlSWR4KSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbY3VyclRva1R5cGUudG9rZW5UeXBlSWR4XSA9IGlkeDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMsIChjdXJyRXh0ZW5kaW5nVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWhhcyhyZXN1bHQsIGN1cnJFeHRlbmRpbmdUeXBlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IGlkeDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LCB7fSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgcmV0dXJuIGNob2ljZVRvQWx0W25leHRUb2tlbi50b2tlblR5cGVJZHhdO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gb3B0aW1pemVkIGxvb2thaGVhZCB3aXRob3V0IG5lZWRpbmcgdG8gY2hlY2sgdGhlIHByZWRpY2F0ZXMgYXQgYWxsLlxuICAgICAgICAvLyB0aGlzIGNhdXNlcyBjb2RlIGR1cGxpY2F0aW9uIHdoaWNoIGlzIGludGVudGlvbmFsIHRvIGltcHJvdmUgcGVyZm9ybWFuY2UuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIFRoZSBjaG9zZW4gYWx0ZXJuYXRpdmUgaW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IG51bU9mQWx0czsgdCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdCA9IGFsdHNbdF07XG4gICAgICAgICAgICAgICAgY29uc3QgY3Vyck51bU9mUGF0aHMgPSBjdXJyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBuZXh0UGF0aDogZm9yIChsZXQgaiA9IDA7IGogPCBjdXJyTnVtT2ZQYXRoczsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJQYXRoID0gY3VyckFsdFtqXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY3VyclBhdGhMZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQShpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgY3VyclBhdGhbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1pc21hdGNoIGluIGN1cnJlbnQgcGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0aGUgbmV4dCBwdGhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGZ1bGwgcGF0aCB0aGF0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBhbHNvIHdvcmsgZm9yIGFuIGVtcHR5IEFMVCBhcyB0aGUgbG9vcCB3aWxsIGJlIHNraXBwZWRcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG5vbmUgb2YgdGhlIHBhdGhzIGZvciB0aGUgY3VycmVudCBhbHRlcm5hdGl2ZSBtYXRjaGVkXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRoZSBuZXh0IGFsdGVybmF0aXZlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZSBhbHRlcm5hdGl2ZXMgY291bGQgYmUgbWF0Y2hlZFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRTaW5nbGVBbHRlcm5hdGl2ZUxvb2thaGVhZEZ1bmN0aW9uKGFsdCwgdG9rZW5NYXRjaGVyLCBkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgIGNvbnN0IGFyZUFsbE9uZVRva2VuTG9va2FoZWFkID0gZXZlcnkoYWx0LCAoY3VyclBhdGgpID0+IHtcbiAgICAgICAgcmV0dXJuIGN1cnJQYXRoLmxlbmd0aCA9PT0gMTtcbiAgICB9KTtcbiAgICBjb25zdCBudW1PZlBhdGhzID0gYWx0Lmxlbmd0aDtcbiAgICAvLyBvcHRpbWl6ZWQgKGNvbW1vbikgY2FzZSBvZiBhbGwgdGhlIGxvb2thaGVhZHMgcGF0aHMgcmVxdWlyaW5nIG9ubHlcbiAgICAvLyBhIHNpbmdsZSB0b2tlbiBsb29rYWhlYWQuXG4gICAgaWYgKGFyZUFsbE9uZVRva2VuTG9va2FoZWFkICYmICFkeW5hbWljVG9rZW5zRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBzaW5nbGVUb2tlbnNUeXBlcyA9IGZsYXR0ZW4oYWx0KTtcbiAgICAgICAgaWYgKHNpbmdsZVRva2Vuc1R5cGVzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgaXNFbXB0eShzaW5nbGVUb2tlbnNUeXBlc1swXS5jYXRlZ29yeU1hdGNoZXMpKSB7XG4gICAgICAgICAgICBjb25zdCBleHBlY3RlZFRva2VuVHlwZSA9IHNpbmdsZVRva2Vuc1R5cGVzWzBdO1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0ZWRUb2tlblVuaXF1ZUtleSA9IGV4cGVjdGVkVG9rZW5UeXBlLnRva2VuVHlwZUlkeDtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSkudG9rZW5UeXBlSWR4ID09PSBleHBlY3RlZFRva2VuVW5pcXVlS2V5O1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGNob2ljZVRvQWx0ID0gcmVkdWNlKHNpbmdsZVRva2Vuc1R5cGVzLCAocmVzdWx0LCBjdXJyVG9rVHlwZSwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJUb2tUeXBlLnRva2VuVHlwZUlkeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZvckVhY2goY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLCAoY3VyckV4dGVuZGluZ1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJFeHRlbmRpbmdUeXBlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hvaWNlVG9BbHRbbmV4dFRva2VuLnRva2VuVHlwZUlkeF0gPT09IHRydWU7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgbmV4dFBhdGg6IGZvciAobGV0IGogPSAwOyBqIDwgbnVtT2ZQYXRoczsgaisrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGggPSBhbHRbal07XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGhMZW5ndGggPSBjdXJyUGF0aC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjdXJyUGF0aExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHRUb2tlbiA9IHRoaXMuTEEoaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgY3VyclBhdGhbaV0pID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWlzbWF0Y2ggaW4gY3VycmVudCBwYXRoXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnkgdGhlIG5leHQgcHRoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBuZXh0UGF0aDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBmb3VuZCBhIGZ1bGwgcGF0aCB0aGF0IG1hdGNoZXMuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBub25lIG9mIHRoZSBwYXRocyBtYXRjaGVkXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfVxufVxuY2xhc3MgUmVzdERlZmluaXRpb25GaW5kZXJXYWxrZXIgZXh0ZW5kcyBSZXN0V2Fsa2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b3BQcm9kLCB0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRvcFByb2QgPSB0b3BQcm9kO1xuICAgICAgICB0aGlzLnRhcmdldE9jY3VycmVuY2UgPSB0YXJnZXRPY2N1cnJlbmNlO1xuICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID0gdGFyZ2V0UHJvZFR5cGU7XG4gICAgfVxuICAgIHN0YXJ0V2Fsa2luZygpIHtcbiAgICAgICAgdGhpcy53YWxrKHRoaXMudG9wUHJvZCk7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc3REZWY7XG4gICAgfVxuICAgIGNoZWNrSXNUYXJnZXQobm9kZSwgZXhwZWN0ZWRQcm9kVHlwZSwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmIChub2RlLmlkeCA9PT0gdGhpcy50YXJnZXRPY2N1cnJlbmNlICYmXG4gICAgICAgICAgICB0aGlzLnRhcmdldFByb2RUeXBlID09PSBleHBlY3RlZFByb2RUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3REZWYgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLCBkbyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgR3JhbW1hciBhc3QgYWZ0ZXIgd2UgaGF2ZSBmb3VuZCB0aGUgdGFyZ2V0XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgd2Fsa09wdGlvbihvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQob3B0aW9uUHJvZCwgUFJPRF9UWVBFLk9QVElPTiwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgc3VwZXIud2Fsa09wdGlvbihvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhbGtBdExlYXN0T25lKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoZWNrSXNUYXJnZXQoYXRMZWFzdE9uZVByb2QsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgY3VyclJlc3QsIHByZXZSZXN0KSkge1xuICAgICAgICAgICAgc3VwZXIud2Fsa09wdGlvbihhdExlYXN0T25lUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3YWxrQXRMZWFzdE9uZVNlcChhdExlYXN0T25lU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0lzVGFyZ2V0KGF0TGVhc3RPbmVTZXBQcm9kLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9NQU5EQVRPUllfV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtPcHRpb24oYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2Fsa01hbnkobWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55UHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT04sIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtPcHRpb24obWFueVByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2Fsa01hbnlTZXAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tJc1RhcmdldChtYW55U2VwUHJvZCwgUFJPRF9UWVBFLlJFUEVUSVRJT05fV0lUSF9TRVBBUkFUT1IsIGN1cnJSZXN0LCBwcmV2UmVzdCkpIHtcbiAgICAgICAgICAgIHN1cGVyLndhbGtPcHRpb24obWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgdGhlIGRlZmluaXRpb24gb2YgYSB0YXJnZXQgcHJvZHVjdGlvbiBpbiBhIHRvcCBsZXZlbCBsZXZlbCBydWxlLlxuICovXG5jbGFzcyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0YXJnZXRPY2N1cnJlbmNlLCB0YXJnZXRQcm9kVHlwZSwgdGFyZ2V0UmVmKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGFyZ2V0T2NjdXJyZW5jZSA9IHRhcmdldE9jY3VycmVuY2U7XG4gICAgICAgIHRoaXMudGFyZ2V0UHJvZFR5cGUgPSB0YXJnZXRQcm9kVHlwZTtcbiAgICAgICAgdGhpcy50YXJnZXRSZWYgPSB0YXJnZXRSZWY7XG4gICAgICAgIHRoaXMucmVzdWx0ID0gW107XG4gICAgfVxuICAgIGNoZWNrSXNUYXJnZXQobm9kZSwgZXhwZWN0ZWRQcm9kTmFtZSkge1xuICAgICAgICBpZiAobm9kZS5pZHggPT09IHRoaXMudGFyZ2V0T2NjdXJyZW5jZSAmJlxuICAgICAgICAgICAgdGhpcy50YXJnZXRQcm9kVHlwZSA9PT0gZXhwZWN0ZWRQcm9kTmFtZSAmJlxuICAgICAgICAgICAgKHRoaXMudGFyZ2V0UmVmID09PSB1bmRlZmluZWQgfHwgbm9kZSA9PT0gdGhpcy50YXJnZXRSZWYpKSB7XG4gICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG5vZGUuZGVmaW5pdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdE9wdGlvbihub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuT1BUSU9OKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uKG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KG5vZGUpIHtcbiAgICAgICAgdGhpcy5jaGVja0lzVGFyZ2V0KG5vZGUsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSk7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3Iobm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uV2l0aFNlcGFyYXRvcihub2RlKSB7XG4gICAgICAgIHRoaXMuY2hlY2tJc1RhcmdldChub2RlLCBQUk9EX1RZUEUuUkVQRVRJVElPTl9XSVRIX1NFUEFSQVRPUik7XG4gICAgfVxuICAgIHZpc2l0QWx0ZXJuYXRpb24obm9kZSkge1xuICAgICAgICB0aGlzLmNoZWNrSXNUYXJnZXQobm9kZSwgUFJPRF9UWVBFLkFMVEVSTkFUSU9OKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbml0aWFsaXplQXJyYXlPZkFycmF5cyhzaXplKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IEFycmF5KHNpemUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IFtdO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLyoqXG4gKiBBIHNvcnQgb2YgaGFzaCBmdW5jdGlvbiBiZXR3ZWVuIGEgUGF0aCBpbiB0aGUgZ3JhbW1hciBhbmQgYSBzdHJpbmcuXG4gKiBOb3RlIHRoYXQgdGhpcyByZXR1cm5zIG11bHRpcGxlIFwiaGFzaGVzXCIgdG8gc3VwcG9ydCB0aGUgc2NlbmFyaW8gb2YgdG9rZW4gY2F0ZWdvcmllcy5cbiAqIC0gIEEgc2luZ2xlIHBhdGggd2l0aCBjYXRlZ29yaWVzIG1heSBtYXRjaCBtdWx0aXBsZSAqKmFjdHVhbCoqIHBhdGhzLlxuICovXG5mdW5jdGlvbiBwYXRoVG9IYXNoS2V5cyhwYXRoKSB7XG4gICAgbGV0IGtleXMgPSBbXCJcIl07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRva1R5cGUgPSBwYXRoW2ldO1xuICAgICAgICBjb25zdCBsb25nZXJLZXlzID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwga2V5cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3QgY3VyclNob3J0ZXJLZXkgPSBrZXlzW2pdO1xuICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgXCJfXCIgKyB0b2tUeXBlLnRva2VuVHlwZUlkeCk7XG4gICAgICAgICAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzLmxlbmd0aDsgdCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2F0ZWdvcmllc0tleVN1ZmZpeCA9IFwiX1wiICsgdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNbdF07XG4gICAgICAgICAgICAgICAgbG9uZ2VyS2V5cy5wdXNoKGN1cnJTaG9ydGVyS2V5ICsgY2F0ZWdvcmllc0tleVN1ZmZpeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5cyA9IGxvbmdlcktleXM7XG4gICAgfVxuICAgIHJldHVybiBrZXlzO1xufVxuLyoqXG4gKiBJbXBlcmF0aXZlIHN0eWxlIGR1ZSB0byBiZWluZyBjYWxsZWQgZnJvbSBhIGhvdCBzcG90XG4gKi9cbmZ1bmN0aW9uIGlzVW5pcXVlUHJlZml4SGFzaChhbHRLbm93blBhdGhzS2V5cywgc2VhcmNoUGF0aEtleXMsIGlkeCkge1xuICAgIGZvciAobGV0IGN1cnJBbHRJZHggPSAwOyBjdXJyQWx0SWR4IDwgYWx0S25vd25QYXRoc0tleXMubGVuZ3RoOyBjdXJyQWx0SWR4KyspIHtcbiAgICAgICAgLy8gV2Ugb25seSB3YW50IHRvIHRlc3QgdnMgdGhlIG90aGVyIGFsdGVybmF0aXZlc1xuICAgICAgICBpZiAoY3VyckFsdElkeCA9PT0gaWR4KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvdGhlckFsdEtub3duUGF0aHNLZXlzID0gYWx0S25vd25QYXRoc0tleXNbY3VyckFsdElkeF07XG4gICAgICAgIGZvciAobGV0IHNlYXJjaElkeCA9IDA7IHNlYXJjaElkeCA8IHNlYXJjaFBhdGhLZXlzLmxlbmd0aDsgc2VhcmNoSWR4KyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaEtleSA9IHNlYXJjaFBhdGhLZXlzW3NlYXJjaElkeF07XG4gICAgICAgICAgICBpZiAob3RoZXJBbHRLbm93blBhdGhzS2V5c1tzZWFyY2hLZXldID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE5vbmUgb2YgdGhlIFNlYXJjaFBhdGhLZXlzIHdlcmUgZm91bmQgaW4gYW55IG9mIHRoZSBvdGhlciBhbHRlcm5hdGl2ZXNcbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXMoYWx0c0RlZnMsIGspIHtcbiAgICBjb25zdCBwYXJ0aWFsQWx0cyA9IG1hcChhbHRzRGVmcywgKGN1cnJBbHQpID0+IHBvc3NpYmxlUGF0aHNGcm9tKFtjdXJyQWx0XSwgMSkpO1xuICAgIGNvbnN0IGZpbmFsUmVzdWx0ID0gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMocGFydGlhbEFsdHMubGVuZ3RoKTtcbiAgICBjb25zdCBhbHRzSGFzaGVzID0gbWFwKHBhcnRpYWxBbHRzLCAoY3VyckFsdFBhdGhzKSA9PiB7XG4gICAgICAgIGNvbnN0IGRpY3QgPSB7fTtcbiAgICAgICAgZm9yRWFjaChjdXJyQWx0UGF0aHMsIChpdGVtKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gcGF0aFRvSGFzaEtleXMoaXRlbS5wYXJ0aWFsUGF0aCk7XG4gICAgICAgICAgICBmb3JFYWNoKGtleXMsIChjdXJyS2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGljdFtjdXJyS2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBkaWN0O1xuICAgIH0pO1xuICAgIGxldCBuZXdEYXRhID0gcGFydGlhbEFsdHM7XG4gICAgLy8gbWF4TG9va2FoZWFkIGxvb3BcbiAgICBmb3IgKGxldCBwYXRoTGVuZ3RoID0gMTsgcGF0aExlbmd0aCA8PSBrOyBwYXRoTGVuZ3RoKyspIHtcbiAgICAgICAgY29uc3QgY3VyckRhdGFzZXQgPSBuZXdEYXRhO1xuICAgICAgICBuZXdEYXRhID0gaW5pdGlhbGl6ZUFycmF5T2ZBcnJheXMoY3VyckRhdGFzZXQubGVuZ3RoKTtcbiAgICAgICAgLy8gYWx0ZXJuYXRpdmVzIGxvb3BcbiAgICAgICAgZm9yIChsZXQgYWx0SWR4ID0gMDsgYWx0SWR4IDwgY3VyckRhdGFzZXQubGVuZ3RoOyBhbHRJZHgrKykge1xuICAgICAgICAgICAgY29uc3QgY3VyckFsdFBhdGhzQW5kU3VmZml4ZXMgPSBjdXJyRGF0YXNldFthbHRJZHhdO1xuICAgICAgICAgICAgLy8gcGF0aHMgaW4gY3VycmVudCBhbHRlcm5hdGl2ZSBsb29wXG4gICAgICAgICAgICBmb3IgKGxldCBjdXJyUGF0aElkeCA9IDA7IGN1cnJQYXRoSWR4IDwgY3VyckFsdFBhdGhzQW5kU3VmZml4ZXMubGVuZ3RoOyBjdXJyUGF0aElkeCsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VyclBhdGhQcmVmaXggPSBjdXJyQWx0UGF0aHNBbmRTdWZmaXhlc1tjdXJyUGF0aElkeF0ucGFydGlhbFBhdGg7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3VmZml4RGVmID0gY3VyckFsdFBhdGhzQW5kU3VmZml4ZXNbY3VyclBhdGhJZHhdLnN1ZmZpeERlZjtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVmaXhLZXlzID0gcGF0aFRvSGFzaEtleXMoY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzVW5pcXVlID0gaXNVbmlxdWVQcmVmaXhIYXNoKGFsdHNIYXNoZXMsIHByZWZpeEtleXMsIGFsdElkeCk7XG4gICAgICAgICAgICAgICAgLy8gRW5kIG9mIHRoZSBsaW5lIGZvciB0aGlzIHBhdGguXG4gICAgICAgICAgICAgICAgaWYgKGlzVW5pcXVlIHx8IGlzRW1wdHkoc3VmZml4RGVmKSB8fCBjdXJyUGF0aFByZWZpeC5sZW5ndGggPT09IGspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyckFsdFJlc3VsdCA9IGZpbmFsUmVzdWx0W2FsdElkeF07XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IENhbiB3ZSBpbXBsZW1lbnQgYSBjb250YWluc1BhdGggdXNpbmcgTWFwcy9EaWN0aW9uYXJpZXM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb250YWluc1BhdGgoY3VyckFsdFJlc3VsdCwgY3VyclBhdGhQcmVmaXgpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFsdFJlc3VsdC5wdXNoKGN1cnJQYXRoUHJlZml4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBhbGwgbmV3ICBrZXlzIGZvciB0aGUgY3VycmVudCBwYXRoLlxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBwcmVmaXhLZXlzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VycktleSA9IHByZWZpeEtleXNbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0c0hhc2hlc1thbHRJZHhdW2N1cnJLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFeHBhbmQgbG9uZ2VyIHBhdGhzXG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzID0gcG9zc2libGVQYXRoc0Zyb20oc3VmZml4RGVmLCBwYXRoTGVuZ3RoICsgMSwgY3VyclBhdGhQcmVmaXgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdEYXRhW2FsdElkeF0gPSBuZXdEYXRhW2FsdElkeF0uY29uY2F0KG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIGtleXMgZm9yIG5ldyBrbm93biBwYXRoc1xuICAgICAgICAgICAgICAgICAgICBmb3JFYWNoKG5ld1BhcnRpYWxQYXRoc0FuZFN1ZmZpeGVzLCAoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJlZml4S2V5cyA9IHBhdGhUb0hhc2hLZXlzKGl0ZW0ucGFydGlhbFBhdGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChwcmVmaXhLZXlzLCAoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWx0c0hhc2hlc1thbHRJZHhdW2tleV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmluYWxSZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcihvY2N1cnJlbmNlLCBydWxlR3JhbW1hciwgaywgb3JQcm9kKSB7XG4gICAgY29uc3QgdmlzaXRvciA9IG5ldyBJbnNpZGVEZWZpbml0aW9uRmluZGVyVmlzaXRvcihvY2N1cnJlbmNlLCBQUk9EX1RZUEUuQUxURVJOQVRJT04sIG9yUHJvZCk7XG4gICAgcnVsZUdyYW1tYXIuYWNjZXB0KHZpc2l0b3IpO1xuICAgIHJldHVybiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXModmlzaXRvci5yZXN1bHQsIGspO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldExvb2thaGVhZFBhdGhzRm9yT3B0aW9uYWxQcm9kKG9jY3VycmVuY2UsIHJ1bGVHcmFtbWFyLCBwcm9kVHlwZSwgaykge1xuICAgIGNvbnN0IGluc2lkZURlZlZpc2l0b3IgPSBuZXcgSW5zaWRlRGVmaW5pdGlvbkZpbmRlclZpc2l0b3Iob2NjdXJyZW5jZSwgcHJvZFR5cGUpO1xuICAgIHJ1bGVHcmFtbWFyLmFjY2VwdChpbnNpZGVEZWZWaXNpdG9yKTtcbiAgICBjb25zdCBpbnNpZGVEZWYgPSBpbnNpZGVEZWZWaXNpdG9yLnJlc3VsdDtcbiAgICBjb25zdCBhZnRlckRlZldhbGtlciA9IG5ldyBSZXN0RGVmaW5pdGlvbkZpbmRlcldhbGtlcihydWxlR3JhbW1hciwgb2NjdXJyZW5jZSwgcHJvZFR5cGUpO1xuICAgIGNvbnN0IGFmdGVyRGVmID0gYWZ0ZXJEZWZXYWxrZXIuc3RhcnRXYWxraW5nKCk7XG4gICAgY29uc3QgaW5zaWRlRmxhdCA9IG5ldyBBbHRlcm5hdGl2ZUdBU1QoeyBkZWZpbml0aW9uOiBpbnNpZGVEZWYgfSk7XG4gICAgY29uc3QgYWZ0ZXJGbGF0ID0gbmV3IEFsdGVybmF0aXZlR0FTVCh7IGRlZmluaXRpb246IGFmdGVyRGVmIH0pO1xuICAgIHJldHVybiBsb29rQWhlYWRTZXF1ZW5jZUZyb21BbHRlcm5hdGl2ZXMoW2luc2lkZUZsYXQsIGFmdGVyRmxhdF0sIGspO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbnRhaW5zUGF0aChhbHRlcm5hdGl2ZSwgc2VhcmNoUGF0aCkge1xuICAgIGNvbXBhcmVPdGhlclBhdGg6IGZvciAobGV0IGkgPSAwOyBpIDwgYWx0ZXJuYXRpdmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb3RoZXJQYXRoID0gYWx0ZXJuYXRpdmVbaV07XG4gICAgICAgIGlmIChvdGhlclBhdGgubGVuZ3RoICE9PSBzZWFyY2hQYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvdGhlclBhdGgubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHNlYXJjaFRvayA9IHNlYXJjaFBhdGhbal07XG4gICAgICAgICAgICBjb25zdCBvdGhlclRvayA9IG90aGVyUGF0aFtqXTtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoaW5nVG9rZW5zID0gc2VhcmNoVG9rID09PSBvdGhlclRvayB8fFxuICAgICAgICAgICAgICAgIG90aGVyVG9rLmNhdGVnb3J5TWF0Y2hlc01hcFtzZWFyY2hUb2sudG9rZW5UeXBlSWR4XSAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nVG9rZW5zID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlIGNvbXBhcmVPdGhlclBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmljdFByZWZpeE9mUGF0aChwcmVmaXgsIG90aGVyKSB7XG4gICAgcmV0dXJuIChwcmVmaXgubGVuZ3RoIDwgb3RoZXIubGVuZ3RoICYmXG4gICAgICAgIGV2ZXJ5KHByZWZpeCwgKHRva1R5cGUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3RoZXJUb2tUeXBlID0gb3RoZXJbaWR4XTtcbiAgICAgICAgICAgIHJldHVybiAodG9rVHlwZSA9PT0gb3RoZXJUb2tUeXBlIHx8XG4gICAgICAgICAgICAgICAgb3RoZXJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlc01hcFt0b2tUeXBlLnRva2VuVHlwZUlkeF0pO1xuICAgICAgICB9KSk7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJlVG9rZW5DYXRlZ29yaWVzTm90VXNlZChsb29rQWhlYWRQYXRocykge1xuICAgIHJldHVybiBldmVyeShsb29rQWhlYWRQYXRocywgKHNpbmdsZUFsdFBhdGhzKSA9PiBldmVyeShzaW5nbGVBbHRQYXRocywgKHNpbmdsZVBhdGgpID0+IGV2ZXJ5KHNpbmdsZVBhdGgsICh0b2tlbikgPT4gaXNFbXB0eSh0b2tlbi5jYXRlZ29yeU1hdGNoZXMpKSkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9va2FoZWFkLmpzLm1hcCIsImltcG9ydCB7IFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUsIH0gZnJvbSBcIi4uL3BhcnNlci9wYXJzZXIuanNcIjtcbmltcG9ydCB7IGZvckVhY2gsIHZhbHVlcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IEdBc3RWaXNpdG9yIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlR3JhbW1hcih0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKSB7XG4gICAgY29uc3QgcmVmUmVzb2x2ZXIgPSBuZXcgR2FzdFJlZlJlc29sdmVyVmlzaXRvcih0b3BMZXZlbHMsIGVyck1zZ1Byb3ZpZGVyKTtcbiAgICByZWZSZXNvbHZlci5yZXNvbHZlUmVmcygpO1xuICAgIHJldHVybiByZWZSZXNvbHZlci5lcnJvcnM7XG59XG5leHBvcnQgY2xhc3MgR2FzdFJlZlJlc29sdmVyVmlzaXRvciBleHRlbmRzIEdBc3RWaXNpdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihuYW1lVG9Ub3BSdWxlLCBlcnJNc2dQcm92aWRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWVUb1RvcFJ1bGUgPSBuYW1lVG9Ub3BSdWxlO1xuICAgICAgICB0aGlzLmVyck1zZ1Byb3ZpZGVyID0gZXJyTXNnUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgfVxuICAgIHJlc29sdmVSZWZzKCkge1xuICAgICAgICBmb3JFYWNoKHZhbHVlcyh0aGlzLm5hbWVUb1RvcFJ1bGUpLCAocHJvZCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5jdXJyVG9wTGV2ZWwgPSBwcm9kO1xuICAgICAgICAgICAgcHJvZC5hY2NlcHQodGhpcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2aXNpdE5vblRlcm1pbmFsKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcmVmID0gdGhpcy5uYW1lVG9Ub3BSdWxlW25vZGUubm9uVGVybWluYWxOYW1lXTtcbiAgICAgICAgaWYgKCFyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZXJyTXNnUHJvdmlkZXIuYnVpbGRSdWxlTm90Rm91bmRFcnJvcih0aGlzLmN1cnJUb3BMZXZlbCwgbm9kZSk7XG4gICAgICAgICAgICB0aGlzLmVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlJFU09MVkVEX1NVQlJVTEVfUkVGLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmN1cnJUb3BMZXZlbC5uYW1lLFxuICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRSZWZOYW1lOiBub2RlLm5vblRlcm1pbmFsTmFtZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5yZWZlcmVuY2VkUnVsZSA9IHJlZjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVyLmpzLm1hcCIsImltcG9ydCB7IGRyb3AsIGZvckVhY2ggfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgVGVybWluYWwsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbi8qKlxuICogIEEgR3JhbW1hciBXYWxrZXIgdGhhdCBjb21wdXRlcyB0aGUgXCJyZW1haW5pbmdcIiBncmFtbWFyIFwiYWZ0ZXJcIiBhIHByb2R1Y3Rpb25zIGluIHRoZSBncmFtbWFyLlxuICovXG5leHBvcnQgY2xhc3MgUmVzdFdhbGtlciB7XG4gICAgd2Fsayhwcm9kLCBwcmV2UmVzdCA9IFtdKSB7XG4gICAgICAgIGZvckVhY2gocHJvZC5kZWZpbml0aW9uLCAoc3ViUHJvZCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJSZXN0ID0gZHJvcChwcm9kLmRlZmluaXRpb24sIGluZGV4ICsgMSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBOb25UZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Byb2RSZWYoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBUZXJtaW5hbCkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa1Rlcm1pbmFsKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgQWx0ZXJuYXRpdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLndhbGtGbGF0KHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgT3B0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrT3B0aW9uKHN1YlByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdWJQcm9kIGluc3RhbmNlb2YgUmVwZXRpdGlvbk1hbmRhdG9yeSkge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0F0TGVhc3RPbmUoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa0F0TGVhc3RPbmVTZXAoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uV2l0aFNlcGFyYXRvcikge1xuICAgICAgICAgICAgICAgIHRoaXMud2Fsa01hbnlTZXAoc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN1YlByb2QgaW5zdGFuY2VvZiBSZXBldGl0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrTWFueShzdWJQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3ViUHJvZCBpbnN0YW5jZW9mIEFsdGVybmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy53YWxrT3Ioc3ViUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB3YWxrVGVybWluYWwodGVybWluYWwsIGN1cnJSZXN0LCBwcmV2UmVzdCkgeyB9XG4gICAgd2Fsa1Byb2RSZWYocmVmUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7IH1cbiAgICB3YWxrRmxhdChmbGF0UHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgICAgIC8vIEFCQ0RFRiA9PiBhZnRlciB0aGUgRCB0aGUgcmVzdCBpcyBFRlxuICAgICAgICBjb25zdCBmdWxsT3JSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgdGhpcy53YWxrKGZsYXRQcm9kLCBmdWxsT3JSZXN0KTtcbiAgICB9XG4gICAgd2Fsa09wdGlvbihvcHRpb25Qcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKT9GID0+IGFmdGVyIHRoZSAoREUpPyB0aGUgcmVzdCBpcyBGXG4gICAgICAgIGNvbnN0IGZ1bGxPclJlc3QgPSBjdXJyUmVzdC5jb25jYXQocHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsob3B0aW9uUHJvZCwgZnVsbE9yUmVzdCk7XG4gICAgfVxuICAgIHdhbGtBdExlYXN0T25lKGF0TGVhc3RPbmVQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKStGID0+IGFmdGVyIHRoZSAoREUpKyB0aGUgcmVzdCBpcyAoREUpP0ZcbiAgICAgICAgY29uc3QgZnVsbEF0TGVhc3RPbmVSZXN0ID0gW1xuICAgICAgICAgICAgbmV3IE9wdGlvbih7IGRlZmluaXRpb246IGF0TGVhc3RPbmVQcm9kLmRlZmluaXRpb24gfSksXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhhdExlYXN0T25lUHJvZCwgZnVsbEF0TGVhc3RPbmVSZXN0KTtcbiAgICB9XG4gICAgd2Fsa0F0TGVhc3RPbmVTZXAoYXRMZWFzdE9uZVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMgREUoLERFKSogRiA9PiBhZnRlciB0aGUgKCxERSkrIHRoZSByZXN0IGlzICgsREUpP0ZcbiAgICAgICAgY29uc3QgZnVsbEF0TGVhc3RPbmVTZXBSZXN0ID0gcmVzdEZvclJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKGF0TGVhc3RPbmVTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsoYXRMZWFzdE9uZVNlcFByb2QsIGZ1bGxBdExlYXN0T25lU2VwUmVzdCk7XG4gICAgfVxuICAgIHdhbGtNYW55KG1hbnlQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpIHtcbiAgICAgICAgLy8gQUJDKERFKSpGID0+IGFmdGVyIHRoZSAoREUpKiB0aGUgcmVzdCBpcyAoREUpP0ZcbiAgICAgICAgY29uc3QgZnVsbE1hbnlSZXN0ID0gW1xuICAgICAgICAgICAgbmV3IE9wdGlvbih7IGRlZmluaXRpb246IG1hbnlQcm9kLmRlZmluaXRpb24gfSksXG4gICAgICAgIF0uY29uY2F0KGN1cnJSZXN0LCBwcmV2UmVzdCk7XG4gICAgICAgIHRoaXMud2FsayhtYW55UHJvZCwgZnVsbE1hbnlSZXN0KTtcbiAgICB9XG4gICAgd2Fsa01hbnlTZXAobWFueVNlcFByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMgKERFKCxERSkqKT8gRiA9PiBhZnRlciB0aGUgKCxERSkqIHRoZSByZXN0IGlzICgsREUpP0ZcbiAgICAgICAgY29uc3QgZnVsbE1hbnlTZXBSZXN0ID0gcmVzdEZvclJlcGV0aXRpb25XaXRoU2VwYXJhdG9yKG1hbnlTZXBQcm9kLCBjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgICAgICB0aGlzLndhbGsobWFueVNlcFByb2QsIGZ1bGxNYW55U2VwUmVzdCk7XG4gICAgfVxuICAgIHdhbGtPcihvclByb2QsIGN1cnJSZXN0LCBwcmV2UmVzdCkge1xuICAgICAgICAvLyBBQkMoRHxFfEYpRyA9PiB3aGVuIGZpbmRpbmcgdGhlIChEfEV8RikgdGhlIHJlc3QgaXMgR1xuICAgICAgICBjb25zdCBmdWxsT3JSZXN0ID0gY3VyclJlc3QuY29uY2F0KHByZXZSZXN0KTtcbiAgICAgICAgLy8gd2FsayBhbGwgZGlmZmVyZW50IGFsdGVybmF0aXZlc1xuICAgICAgICBmb3JFYWNoKG9yUHJvZC5kZWZpbml0aW9uLCAoYWx0KSA9PiB7XG4gICAgICAgICAgICAvLyB3cmFwcGluZyBlYWNoIGFsdGVybmF0aXZlIGluIGEgc2luZ2xlIGRlZmluaXRpb24gd3JhcHBlclxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgZXJyb3JzIGluIGNvbXB1dGluZyB0aGUgcmVzdCBvZiB0aGF0IGFsdGVybmF0aXZlIGluIHRoZSBpbnZvY2F0aW9uIHRvIGNvbXB1dGVJblByb2RGb2xsb3dzXG4gICAgICAgICAgICAvLyAob3RoZXJ3aXNlIGZvciBPUihbYWx0MSxhbHQyXSkgYWx0MiB3aWxsIGJlIGNvbnNpZGVyZWQgaW4gJ3Jlc3QnIG9mIGFsdDFcbiAgICAgICAgICAgIGNvbnN0IHByb2RXcmFwcGVyID0gbmV3IEFsdGVybmF0aXZlKHsgZGVmaW5pdGlvbjogW2FsdF0gfSk7XG4gICAgICAgICAgICB0aGlzLndhbGsocHJvZFdyYXBwZXIsIGZ1bGxPclJlc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiByZXN0Rm9yUmVwZXRpdGlvbldpdGhTZXBhcmF0b3IocmVwU2VwUHJvZCwgY3VyclJlc3QsIHByZXZSZXN0KSB7XG4gICAgY29uc3QgcmVwU2VwUmVzdCA9IFtcbiAgICAgICAgbmV3IE9wdGlvbih7XG4gICAgICAgICAgICBkZWZpbml0aW9uOiBbXG4gICAgICAgICAgICAgICAgbmV3IFRlcm1pbmFsKHsgdGVybWluYWxUeXBlOiByZXBTZXBQcm9kLnNlcGFyYXRvciB9KSxcbiAgICAgICAgICAgIF0uY29uY2F0KHJlcFNlcFByb2QuZGVmaW5pdGlvbiksXG4gICAgICAgIH0pLFxuICAgIF07XG4gICAgY29uc3QgZnVsbFJlcFNlcFJlc3QgPSByZXBTZXBSZXN0LmNvbmNhdChjdXJyUmVzdCwgcHJldlJlc3QpO1xuICAgIHJldHVybiBmdWxsUmVwU2VwUmVzdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc3QuanMubWFwIiwiaW1wb3J0IHsgY2xvbmUsIGZvckVhY2gsIGhhcywgaXNFbXB0eSwgbWFwLCB2YWx1ZXMgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyB0b0Zhc3RQcm9wZXJ0aWVzIH0gZnJvbSBcIkBjaGV2cm90YWluL3V0aWxzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWxsUHJvZHNGb2xsb3dzIH0gZnJvbSBcIi4uL2dyYW1tYXIvZm9sbG93LmpzXCI7XG5pbXBvcnQgeyBjcmVhdGVUb2tlbkluc3RhbmNlLCBFT0YgfSBmcm9tIFwiLi4vLi4vc2Nhbi90b2tlbnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsIGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLCB9IGZyb20gXCIuLi9lcnJvcnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyByZXNvbHZlR3JhbW1hciwgdmFsaWRhdGVHcmFtbWFyLCB9IGZyb20gXCIuLi9ncmFtbWFyL2dhc3QvZ2FzdF9yZXNvbHZlcl9wdWJsaWMuanNcIjtcbmltcG9ydCB7IFJlY292ZXJhYmxlIH0gZnJvbSBcIi4vdHJhaXRzL3JlY292ZXJhYmxlLmpzXCI7XG5pbXBvcnQgeyBMb29rc0FoZWFkIH0gZnJvbSBcIi4vdHJhaXRzL2xvb2tzYWhlYWQuanNcIjtcbmltcG9ydCB7IFRyZWVCdWlsZGVyIH0gZnJvbSBcIi4vdHJhaXRzL3RyZWVfYnVpbGRlci5qc1wiO1xuaW1wb3J0IHsgTGV4ZXJBZGFwdGVyIH0gZnJvbSBcIi4vdHJhaXRzL2xleGVyX2FkYXB0ZXIuanNcIjtcbmltcG9ydCB7IFJlY29nbml6ZXJBcGkgfSBmcm9tIFwiLi90cmFpdHMvcmVjb2duaXplcl9hcGkuanNcIjtcbmltcG9ydCB7IFJlY29nbml6ZXJFbmdpbmUgfSBmcm9tIFwiLi90cmFpdHMvcmVjb2duaXplcl9lbmdpbmUuanNcIjtcbmltcG9ydCB7IEVycm9ySGFuZGxlciB9IGZyb20gXCIuL3RyYWl0cy9lcnJvcl9oYW5kbGVyLmpzXCI7XG5pbXBvcnQgeyBDb250ZW50QXNzaXN0IH0gZnJvbSBcIi4vdHJhaXRzL2NvbnRleHRfYXNzaXN0LmpzXCI7XG5pbXBvcnQgeyBHYXN0UmVjb3JkZXIgfSBmcm9tIFwiLi90cmFpdHMvZ2FzdF9yZWNvcmRlci5qc1wiO1xuaW1wb3J0IHsgUGVyZm9ybWFuY2VUcmFjZXIgfSBmcm9tIFwiLi90cmFpdHMvcGVyZl90cmFjZXIuanNcIjtcbmltcG9ydCB7IGFwcGx5TWl4aW5zIH0gZnJvbSBcIi4vdXRpbHMvYXBwbHlfbWl4aW5zLmpzXCI7XG5pbXBvcnQgeyB2YWxpZGF0ZUxvb2thaGVhZCB9IGZyb20gXCIuLi9ncmFtbWFyL2NoZWNrcy5qc1wiO1xuZXhwb3J0IGNvbnN0IEVORF9PRl9GSUxFID0gY3JlYXRlVG9rZW5JbnN0YW5jZShFT0YsIFwiXCIsIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuT2JqZWN0LmZyZWV6ZShFTkRfT0ZfRklMRSk7XG5leHBvcnQgY29uc3QgREVGQVVMVF9QQVJTRVJfQ09ORklHID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgcmVjb3ZlcnlFbmFibGVkOiBmYWxzZSxcbiAgICBtYXhMb29rYWhlYWQ6IDMsXG4gICAgZHluYW1pY1Rva2Vuc0VuYWJsZWQ6IGZhbHNlLFxuICAgIG91dHB1dENzdDogdHJ1ZSxcbiAgICBlcnJvck1lc3NhZ2VQcm92aWRlcjogZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIsXG4gICAgbm9kZUxvY2F0aW9uVHJhY2tpbmc6IFwibm9uZVwiLFxuICAgIHRyYWNlSW5pdFBlcmY6IGZhbHNlLFxuICAgIHNraXBWYWxpZGF0aW9uczogZmFsc2UsXG59KTtcbmV4cG9ydCBjb25zdCBERUZBVUxUX1JVTEVfQ09ORklHID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgcmVjb3ZlcnlWYWx1ZUZ1bmM6ICgpID0+IHVuZGVmaW5lZCxcbiAgICByZXN5bmNFbmFibGVkOiB0cnVlLFxufSk7XG5leHBvcnQgdmFyIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGU7XG4oZnVuY3Rpb24gKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUpIHtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX1JVTEVfTkFNRVwiXSA9IDBdID0gXCJJTlZBTElEX1JVTEVfTkFNRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkRVUExJQ0FURV9SVUxFX05BTUVcIl0gPSAxXSA9IFwiRFVQTElDQVRFX1JVTEVfTkFNRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfUlVMRV9PVkVSUklERVwiXSA9IDJdID0gXCJJTlZBTElEX1JVTEVfT1ZFUlJJREVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJEVVBMSUNBVEVfUFJPRFVDVElPTlNcIl0gPSAzXSA9IFwiRFVQTElDQVRFX1BST0RVQ1RJT05TXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVU5SRVNPTFZFRF9TVUJSVUxFX1JFRlwiXSA9IDRdID0gXCJVTlJFU09MVkVEX1NVQlJVTEVfUkVGXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTEVGVF9SRUNVUlNJT05cIl0gPSA1XSA9IFwiTEVGVF9SRUNVUlNJT05cIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJOT05FX0xBU1RfRU1QVFlfQUxUXCJdID0gNl0gPSBcIk5PTkVfTEFTVF9FTVBUWV9BTFRcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJBTUJJR1VPVVNfQUxUU1wiXSA9IDddID0gXCJBTUJJR1VPVVNfQUxUU1wiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkNPTkZMSUNUX1RPS0VOU19SVUxFU19OQU1FU1BBQ0VcIl0gPSA4XSA9IFwiQ09ORkxJQ1RfVE9LRU5TX1JVTEVTX05BTUVTUEFDRVwiO1xuICAgIFBhcnNlckRlZmluaXRpb25FcnJvclR5cGVbUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtcIklOVkFMSURfVE9LRU5fTkFNRVwiXSA9IDldID0gXCJJTlZBTElEX1RPS0VOX05BTUVcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJOT19OT05fRU1QVFlfTE9PS0FIRUFEXCJdID0gMTBdID0gXCJOT19OT05fRU1QVFlfTE9PS0FIRUFEXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQU1CSUdVT1VTX1BSRUZJWF9BTFRTXCJdID0gMTFdID0gXCJBTUJJR1VPVVNfUFJFRklYX0FMVFNcIjtcbiAgICBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1BhcnNlckRlZmluaXRpb25FcnJvclR5cGVbXCJUT09fTUFOWV9BTFRTXCJdID0gMTJdID0gXCJUT09fTUFOWV9BTFRTXCI7XG4gICAgUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZVtQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiQ1VTVE9NX0xPT0tBSEVBRF9WQUxJREFUSU9OXCJdID0gMTNdID0gXCJDVVNUT01fTE9PS0FIRUFEX1ZBTElEQVRJT05cIjtcbn0pKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgfHwgKFBhcnNlckRlZmluaXRpb25FcnJvclR5cGUgPSB7fSkpO1xuZXhwb3J0IGZ1bmN0aW9uIEVNUFRZX0FMVCh2YWx1ZSA9IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xufVxuZXhwb3J0IGNsYXNzIFBhcnNlciB7XG4gICAgLyoqXG4gICAgICogIEBkZXByZWNhdGVkIHVzZSB0aGUgKippbnN0YW5jZSoqIG1ldGhvZCB3aXRoIHRoZSBzYW1lIG5hbWUgaW5zdGVhZFxuICAgICAqL1xuICAgIHN0YXRpYyBwZXJmb3JtU2VsZkFuYWx5c2lzKHBhcnNlckluc3RhbmNlKSB7XG4gICAgICAgIHRocm93IEVycm9yKFwiVGhlICoqc3RhdGljKiogYHBlcmZvcm1TZWxmQW5hbHlzaXNgIG1ldGhvZCBoYXMgYmVlbiBkZXByZWNhdGVkLlwiICtcbiAgICAgICAgICAgIFwiXFx0XFxuVXNlIHRoZSAqKmluc3RhbmNlKiogbWV0aG9kIHdpdGggdGhlIHNhbWUgbmFtZSBpbnN0ZWFkLlwiKTtcbiAgICB9XG4gICAgcGVyZm9ybVNlbGZBbmFseXNpcygpIHtcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwicGVyZm9ybVNlbGZBbmFseXNpc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgZGVmRXJyb3JzTXNncztcbiAgICAgICAgICAgIHRoaXMuc2VsZkFuYWx5c2lzRG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjb25zdCBjbGFzc05hbWUgPSB0aGlzLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BzXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXaXRob3V0IHRoaXMgdm9vZG9vIG1hZ2ljIHRoZSBwYXJzZXIgd291bGQgYmUgeDMteDQgc2xvd2VyXG4gICAgICAgICAgICAgICAgLy8gSXQgc2VlbXMgaXQgaXMgYmV0dGVyIHRvIGludm9rZSBgdG9GYXN0UHJvcGVydGllc2AgKipiZWZvcmUqKlxuICAgICAgICAgICAgICAgIC8vIEFueSBtYW5pcHVsYXRpb25zIG9mIHRoZSBgdGhpc2Agb2JqZWN0IGRvbmUgZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgICAgICAgICAgdG9GYXN0UHJvcGVydGllcyh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiR3JhbW1hciBSZWNvcmRpbmdcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW5hYmxlUmVjb3JkaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ1aWxkaW5nIHRoZSBHQVNUXG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2godGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgKGN1cnJSdWxlTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgd3JhcHBlZFJ1bGUgPSB0aGlzW2N1cnJSdWxlTmFtZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEdyYW1tYXJBY3Rpb24gPSB3cmFwcGVkUnVsZVtcIm9yaWdpbmFsR3JhbW1hckFjdGlvblwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCByZWNvcmRlZFJ1bGVHYXN0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKGAke2N1cnJSdWxlTmFtZX0gUnVsZWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvcmRlZFJ1bGVHYXN0ID0gdGhpcy50b3BMZXZlbFJ1bGVSZWNvcmQoY3VyclJ1bGVOYW1lLCBvcmlnaW5hbEdyYW1tYXJBY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlW2N1cnJSdWxlTmFtZV0gPSByZWNvcmRlZFJ1bGVHYXN0O1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzYWJsZVJlY29yZGluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbGV0IHJlc29sdmVyRXJyb3JzID0gW107XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJHcmFtbWFyIFJlc29sdmluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXJFcnJvcnMgPSByZXNvbHZlR3JhbW1hcih7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzOiB2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzID0gdGhpcy5kZWZpbml0aW9uRXJyb3JzLmNvbmNhdChyZXNvbHZlckVycm9ycyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkdyYW1tYXIgVmFsaWRhdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgcGVyZm9ybSBhZGRpdGlvbmFsIGdyYW1tYXIgdmFsaWRhdGlvbnMgSUZGIG5vIHJlc29sdmluZyBlcnJvcnMgaGF2ZSBvY2N1cnJlZC5cbiAgICAgICAgICAgICAgICAvLyBhcyB1bnJlc29sdmVkIGdyYW1tYXIgbWF5IGxlYWQgdG8gdW5oYW5kbGVkIHJ1bnRpbWUgZXhjZXB0aW9ucyBpbiB0aGUgZm9sbG93IHVwIHZhbGlkYXRpb25zLlxuICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KHJlc29sdmVyRXJyb3JzKSAmJiB0aGlzLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlR3JhbW1hcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlczogdmFsdWVzKHRoaXMuZ2FzdFByb2R1Y3Rpb25zQ2FjaGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogdmFsdWVzKHRoaXMudG9rZW5zTWFwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyck1zZ1Byb3ZpZGVyOiBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFtbWFyTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9va2FoZWFkVmFsaWRhdGlvbkVycm9ycyA9IHZhbGlkYXRlTG9va2FoZWFkKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvb2thaGVhZFN0cmF0ZWd5OiB0aGlzLmxvb2thaGVhZFN0cmF0ZWd5LFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHZhbHVlcyh0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuVHlwZXM6IHZhbHVlcyh0aGlzLnRva2Vuc01hcCksXG4gICAgICAgICAgICAgICAgICAgICAgICBncmFtbWFyTmFtZTogY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZWZpbml0aW9uRXJyb3JzID0gdGhpcy5kZWZpbml0aW9uRXJyb3JzLmNvbmNhdCh2YWxpZGF0aW9uRXJyb3JzLCBsb29rYWhlYWRWYWxpZGF0aW9uRXJyb3JzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIHRoaXMgYW5hbHlzaXMgbWF5IGZhaWwgaWYgdGhlIGdyYW1tYXIgaXMgbm90IHBlcmZlY3RseSB2YWxpZFxuICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5kZWZpbml0aW9uRXJyb3JzKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSByZXN1bHRzIG9mIHRoZXNlIGNvbXB1dGF0aW9ucyBhcmUgbm90IG5lZWRlZCB1bmxlc3MgZXJyb3IgcmVjb3ZlcnkgaXMgZW5hYmxlZC5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiY29tcHV0ZUFsbFByb2RzRm9sbG93c1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbGxGb2xsb3dzID0gY29tcHV0ZUFsbFByb2RzRm9sbG93cyh2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN5bmNGb2xsb3dzID0gYWxsRm9sbG93cztcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkNvbXB1dGVMb29rYWhlYWRGdW5jdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLmxvb2thaGVhZFN0cmF0ZWd5KS5pbml0aWFsaXplKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgcnVsZXM6IHZhbHVlcyh0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlKSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyh2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFQYXJzZXIuREVGRVJfREVGSU5JVElPTl9FUlJPUlNfSEFORExJTkcgJiZcbiAgICAgICAgICAgICAgICAhaXNFbXB0eSh0aGlzLmRlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgZGVmRXJyb3JzTXNncyA9IG1hcCh0aGlzLmRlZmluaXRpb25FcnJvcnMsIChkZWZFcnJvcikgPT4gZGVmRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJzZXIgRGVmaW5pdGlvbiBFcnJvcnMgZGV0ZWN0ZWQ6XFxuICR7ZGVmRXJyb3JzTXNncy5qb2luKFwiXFxuLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKSB7XG4gICAgICAgIHRoaXMuZGVmaW5pdGlvbkVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLnNlbGZBbmFseXNpc0RvbmUgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgICAgIHRoYXQuaW5pdEVycm9ySGFuZGxlcihjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRMZXhlckFkYXB0ZXIoKTtcbiAgICAgICAgdGhhdC5pbml0TG9va3NBaGVhZChjb25maWcpO1xuICAgICAgICB0aGF0LmluaXRSZWNvZ25pemVyRW5naW5lKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UmVjb3ZlcmFibGUoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0VHJlZUJ1aWxkZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0Q29udGVudEFzc2lzdCgpO1xuICAgICAgICB0aGF0LmluaXRHYXN0UmVjb3JkZXIoY29uZmlnKTtcbiAgICAgICAgdGhhdC5pbml0UGVyZm9ybWFuY2VUcmFjZXIoY29uZmlnKTtcbiAgICAgICAgaWYgKGhhcyhjb25maWcsIFwiaWdub3JlZElzc3Vlc1wiKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxpZ25vcmVkSXNzdWVzPiBJUGFyc2VyQ29uZmlnIHByb3BlcnR5IGhhcyBiZWVuIGRlcHJlY2F0ZWQuXFxuXFx0XCIgK1xuICAgICAgICAgICAgICAgIFwiUGxlYXNlIHVzZSB0aGUgPElHTk9SRV9BTUJJR1VJVElFUz4gZmxhZyBvbiB0aGUgcmVsZXZhbnQgRFNMIG1ldGhvZCBpbnN0ZWFkLlxcblxcdFwiICtcbiAgICAgICAgICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2dyYW1tYXJfZXJyb3JzLmh0bWwjSUdOT1JJTkdfQU1CSUdVSVRJRVNcXG5cXHRcIiArXG4gICAgICAgICAgICAgICAgXCJGb3IgZnVydGhlciBkZXRhaWxzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNraXBWYWxpZGF0aW9ucyA9IGhhcyhjb25maWcsIFwic2tpcFZhbGlkYXRpb25zXCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5za2lwVmFsaWRhdGlvbnMgLy8gY2FzdGluZyBhc3N1bWVzIHRoZSBlbmQgdXNlciBwYXNzaW5nIHRoZSBjb3JyZWN0IHR5cGVcbiAgICAgICAgICAgIDogREVGQVVMVF9QQVJTRVJfQ09ORklHLnNraXBWYWxpZGF0aW9ucztcbiAgICB9XG59XG4vLyBTZXQgdGhpcyBmbGFnIHRvIHRydWUgaWYgeW91IGRvbid0IHdhbnQgdGhlIFBhcnNlciB0byB0aHJvdyBlcnJvciB3aGVuIHByb2JsZW1zIGluIGl0J3MgZGVmaW5pdGlvbiBhcmUgZGV0ZWN0ZWQuXG4vLyAobm9ybWFsbHkgZHVyaW5nIHRoZSBwYXJzZXIncyBjb25zdHJ1Y3RvcikuXG4vLyBUaGlzIGlzIGEgZGVzaWduIHRpbWUgZmxhZywgaXQgd2lsbCBub3QgYWZmZWN0IHRoZSBydW50aW1lIGVycm9yIGhhbmRsaW5nIG9mIHRoZSBwYXJzZXIsIGp1c3QgZGVzaWduIHRpbWUgZXJyb3JzLFxuLy8gZm9yIGV4YW1wbGU6IGR1cGxpY2F0ZSBydWxlIG5hbWVzLCByZWZlcmVuY2luZyBhbiB1bnJlc29sdmVkIHN1YnJ1bGUsIGVjdC4uLlxuLy8gVGhpcyBmbGFnIHNob3VsZCBub3QgYmUgZW5hYmxlZCBkdXJpbmcgbm9ybWFsIHVzYWdlLCBpdCBpcyB1c2VkIGluIHNwZWNpYWwgc2l0dWF0aW9ucywgZm9yIGV4YW1wbGUgd2hlblxuLy8gbmVlZGluZyB0byBkaXNwbGF5IHRoZSBwYXJzZXIgZGVmaW5pdGlvbiBlcnJvcnMgaW4gc29tZSBHVUkob25saW5lIHBsYXlncm91bmQpLlxuUGFyc2VyLkRFRkVSX0RFRklOSVRJT05fRVJST1JTX0hBTkRMSU5HID0gZmFsc2U7XG5hcHBseU1peGlucyhQYXJzZXIsIFtcbiAgICBSZWNvdmVyYWJsZSxcbiAgICBMb29rc0FoZWFkLFxuICAgIFRyZWVCdWlsZGVyLFxuICAgIExleGVyQWRhcHRlcixcbiAgICBSZWNvZ25pemVyRW5naW5lLFxuICAgIFJlY29nbml6ZXJBcGksXG4gICAgRXJyb3JIYW5kbGVyLFxuICAgIENvbnRlbnRBc3Npc3QsXG4gICAgR2FzdFJlY29yZGVyLFxuICAgIFBlcmZvcm1hbmNlVHJhY2VyLFxuXSk7XG5leHBvcnQgY2xhc3MgQ3N0UGFyc2VyIGV4dGVuZHMgUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3Rvcih0b2tlblZvY2FidWxhcnksIGNvbmZpZyA9IERFRkFVTFRfUEFSU0VSX0NPTkZJRykge1xuICAgICAgICBjb25zdCBjb25maWdDbG9uZSA9IGNsb25lKGNvbmZpZyk7XG4gICAgICAgIGNvbmZpZ0Nsb25lLm91dHB1dENzdCA9IHRydWU7XG4gICAgICAgIHN1cGVyKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnQ2xvbmUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBFbWJlZGRlZEFjdGlvbnNQYXJzZXIgZXh0ZW5kcyBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnID0gREVGQVVMVF9QQVJTRVJfQ09ORklHKSB7XG4gICAgICAgIGNvbnN0IGNvbmZpZ0Nsb25lID0gY2xvbmUoY29uZmlnKTtcbiAgICAgICAgY29uZmlnQ2xvbmUub3V0cHV0Q3N0ID0gZmFsc2U7XG4gICAgICAgIHN1cGVyKHRva2VuVm9jYWJ1bGFyeSwgY29uZmlnQ2xvbmUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhcnNlci5qcy5tYXAiLCJpbXBvcnQgeyBOZXh0QWZ0ZXJUb2tlbldhbGtlciwgbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIsIH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvaW50ZXJwcmV0ZXIuanNcIjtcbmltcG9ydCB7IGZpcnN0LCBpc1VuZGVmaW5lZCB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmV4cG9ydCBjbGFzcyBDb250ZW50QXNzaXN0IHtcbiAgICBpbml0Q29udGVudEFzc2lzdCgpIHsgfVxuICAgIGNvbXB1dGVDb250ZW50QXNzaXN0KHN0YXJ0UnVsZU5hbWUsIHByZWNlZGluZ0lucHV0KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0UnVsZUdhc3QgPSB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlW3N0YXJ0UnVsZU5hbWVdO1xuICAgICAgICBpZiAoaXNVbmRlZmluZWQoc3RhcnRSdWxlR2FzdCkpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBSdWxlIC0+JHtzdGFydFJ1bGVOYW1lfTwtIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgZ3JhbW1hci5gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV4dFBvc3NpYmxlVG9rZW5zQWZ0ZXIoW3N0YXJ0UnVsZUdhc3RdLCBwcmVjZWRpbmdJbnB1dCwgdGhpcy50b2tlbk1hdGNoZXIsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICB9XG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgYSBtZW1iZXIgbWV0aG9kIG9yIGEgdXRpbGl0eT8gaXQgZG9lcyBub3QgaGF2ZSBhbnkgc3RhdGUgb3IgdXNhZ2Ugb2YgJ3RoaXMnLi4uXG4gICAgLy8gVE9ETzogc2hvdWxkIHRoaXMgYmUgbW9yZSBleHBsaWNpdGx5IHBhcnQgb2YgdGhlIHB1YmxpYyBBUEk/XG4gICAgZ2V0TmV4dFBvc3NpYmxlVG9rZW5UeXBlcyhncmFtbWFyUGF0aCkge1xuICAgICAgICBjb25zdCB0b3BSdWxlTmFtZSA9IGZpcnN0KGdyYW1tYXJQYXRoLnJ1bGVTdGFjayk7XG4gICAgICAgIGNvbnN0IGdhc3RQcm9kdWN0aW9ucyA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKCk7XG4gICAgICAgIGNvbnN0IHRvcFByb2R1Y3Rpb24gPSBnYXN0UHJvZHVjdGlvbnNbdG9wUnVsZU5hbWVdO1xuICAgICAgICBjb25zdCBuZXh0UG9zc2libGVUb2tlblR5cGVzID0gbmV3IE5leHRBZnRlclRva2VuV2Fsa2VyKHRvcFByb2R1Y3Rpb24sIGdyYW1tYXJQYXRoKS5zdGFydFdhbGtpbmcoKTtcbiAgICAgICAgcmV0dXJuIG5leHRQb3NzaWJsZVRva2VuVHlwZXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29udGV4dF9hc3Npc3QuanMubWFwIiwiaW1wb3J0IHsgRWFybHlFeGl0RXhjZXB0aW9uLCBpc1JlY29nbml0aW9uRXhjZXB0aW9uLCBOb1ZpYWJsZUFsdEV4Y2VwdGlvbiwgfSBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IGNsb25lLCBoYXMgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBnZXRMb29rYWhlYWRQYXRoc0Zvck9wdGlvbmFsUHJvZCwgZ2V0TG9va2FoZWFkUGF0aHNGb3JPciwgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9sb29rYWhlYWQuanNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbi8qKlxuICogVHJhaXQgcmVzcG9uc2libGUgZm9yIHJ1bnRpbWUgcGFyc2luZyBlcnJvcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBFcnJvckhhbmRsZXIge1xuICAgIGluaXRFcnJvckhhbmRsZXIoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyID0gaGFzKGNvbmZpZywgXCJlcnJvck1lc3NhZ2VQcm92aWRlclwiKVxuICAgICAgICAgICAgPyBjb25maWcuZXJyb3JNZXNzYWdlUHJvdmlkZXIgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcuZXJyb3JNZXNzYWdlUHJvdmlkZXI7XG4gICAgfVxuICAgIFNBVkVfRVJST1IoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzUmVjb2duaXRpb25FeGNlcHRpb24oZXJyb3IpKSB7XG4gICAgICAgICAgICBlcnJvci5jb250ZXh0ID0ge1xuICAgICAgICAgICAgICAgIHJ1bGVTdGFjazogdGhpcy5nZXRIdW1hblJlYWRhYmxlUnVsZVN0YWNrKCksXG4gICAgICAgICAgICAgICAgcnVsZU9jY3VycmVuY2VTdGFjazogY2xvbmUodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2Vycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiVHJ5aW5nIHRvIHNhdmUgYW4gRXJyb3Igd2hpY2ggaXMgbm90IGEgUmVjb2duaXRpb25FeGNlcHRpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIGNsb25lKHRoaXMuX2Vycm9ycyk7XG4gICAgfVxuICAgIHNldCBlcnJvcnMobmV3RXJyb3JzKSB7XG4gICAgICAgIHRoaXMuX2Vycm9ycyA9IG5ld0Vycm9ycztcbiAgICB9XG4gICAgLy8gVE9ETzogY29uc2lkZXIgY2FjaGluZyB0aGUgZXJyb3IgbWVzc2FnZSBjb21wdXRlZCBpbmZvcm1hdGlvblxuICAgIHJhaXNlRWFybHlFeGl0RXhjZXB0aW9uKG9jY3VycmVuY2UsIHByb2RUeXBlLCB1c2VyRGVmaW5lZEVyck1zZykge1xuICAgICAgICBjb25zdCBydWxlTmFtZSA9IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO1xuICAgICAgICBjb25zdCBydWxlR3JhbW1hciA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKClbcnVsZU5hbWVdO1xuICAgICAgICBjb25zdCBsb29rQWhlYWRQYXRoc1BlckFsdGVybmF0aXZlID0gZ2V0TG9va2FoZWFkUGF0aHNGb3JPcHRpb25hbFByb2Qob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIHByb2RUeXBlLCB0aGlzLm1heExvb2thaGVhZCk7XG4gICAgICAgIGNvbnN0IGluc2lkZVByb2RQYXRocyA9IGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmVbMF07XG4gICAgICAgIGNvbnN0IGFjdHVhbFRva2VucyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMTsgaSA8PSB0aGlzLm1heExvb2thaGVhZDsgaSsrKSB7XG4gICAgICAgICAgICBhY3R1YWxUb2tlbnMucHVzaCh0aGlzLkxBKGkpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtc2cgPSB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkRWFybHlFeGl0TWVzc2FnZSh7XG4gICAgICAgICAgICBleHBlY3RlZEl0ZXJhdGlvblBhdGhzOiBpbnNpZGVQcm9kUGF0aHMsXG4gICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFRva2VucyxcbiAgICAgICAgICAgIHByZXZpb3VzOiB0aGlzLkxBKDApLFxuICAgICAgICAgICAgY3VzdG9tVXNlckRlc2NyaXB0aW9uOiB1c2VyRGVmaW5lZEVyck1zZyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiBydWxlTmFtZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgRWFybHlFeGl0RXhjZXB0aW9uKG1zZywgdGhpcy5MQSgxKSwgdGhpcy5MQSgwKSkpO1xuICAgIH1cbiAgICAvLyBUT0RPOiBjb25zaWRlciBjYWNoaW5nIHRoZSBlcnJvciBtZXNzYWdlIGNvbXB1dGVkIGluZm9ybWF0aW9uXG4gICAgcmFpc2VOb0FsdEV4Y2VwdGlvbihvY2N1cnJlbmNlLCBlcnJNc2dUeXBlcykge1xuICAgICAgICBjb25zdCBydWxlTmFtZSA9IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpO1xuICAgICAgICBjb25zdCBydWxlR3JhbW1hciA9IHRoaXMuZ2V0R0FzdFByb2R1Y3Rpb25zKClbcnVsZU5hbWVdO1xuICAgICAgICAvLyBUT0RPOiBnZXRMb29rYWhlYWRQYXRoc0Zvck9yIGNhbiBiZSBzbG93IGZvciBsYXJnZSBlbm91Z2ggbWF4TG9va2FoZWFkIGFuZCBjZXJ0YWluIGdyYW1tYXJzLCBjb25zaWRlciBjYWNoaW5nID9cbiAgICAgICAgY29uc3QgbG9va0FoZWFkUGF0aHNQZXJBbHRlcm5hdGl2ZSA9IGdldExvb2thaGVhZFBhdGhzRm9yT3Iob2NjdXJyZW5jZSwgcnVsZUdyYW1tYXIsIHRoaXMubWF4TG9va2FoZWFkKTtcbiAgICAgICAgY29uc3QgYWN0dWFsVG9rZW5zID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHRoaXMubWF4TG9va2FoZWFkOyBpKyspIHtcbiAgICAgICAgICAgIGFjdHVhbFRva2Vucy5wdXNoKHRoaXMuTEEoaSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICBjb25zdCBlcnJNc2cgPSB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKHtcbiAgICAgICAgICAgIGV4cGVjdGVkUGF0aHNQZXJBbHQ6IGxvb2tBaGVhZFBhdGhzUGVyQWx0ZXJuYXRpdmUsXG4gICAgICAgICAgICBhY3R1YWw6IGFjdHVhbFRva2VucyxcbiAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91c1Rva2VuLFxuICAgICAgICAgICAgY3VzdG9tVXNlckRlc2NyaXB0aW9uOiBlcnJNc2dUeXBlcyxcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgTm9WaWFibGVBbHRFeGNlcHRpb24oZXJyTXNnLCB0aGlzLkxBKDEpLCBwcmV2aW91c1Rva2VuKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXJyb3JfaGFuZGxlci5qcy5tYXAiLCJpbXBvcnQgeyBmb3JFYWNoLCBoYXMsIGlzQXJyYXksIGlzRnVuY3Rpb24sIGxhc3QgYXMgcGVlaywgc29tZSwgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBBbHRlcm5hdGlvbiwgQWx0ZXJuYXRpdmUsIE5vblRlcm1pbmFsLCBPcHRpb24sIFJlcGV0aXRpb24sIFJlcGV0aXRpb25NYW5kYXRvcnksIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBSZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgUnVsZSwgVGVybWluYWwsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmltcG9ydCB7IExleGVyIH0gZnJvbSBcIi4uLy4uLy4uL3NjYW4vbGV4ZXJfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBhdWdtZW50VG9rZW5UeXBlcywgaGFzU2hvcnRLZXlQcm9wZXJ0eSwgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnMuanNcIjtcbmltcG9ydCB7IGNyZWF0ZVRva2VuLCBjcmVhdGVUb2tlbkluc3RhbmNlLCB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IEVORF9PRl9GSUxFIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgQklUU19GT1JfT0NDVVJSRU5DRV9JRFggfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzLmpzXCI7XG5jb25zdCBSRUNPUkRJTkdfTlVMTF9PQkpFQ1QgPSB7XG4gICAgZGVzY3JpcHRpb246IFwiVGhpcyBPYmplY3QgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgZHVyaW5nIFJlY29yZGluZyBQaGFzZVwiLFxufTtcbk9iamVjdC5mcmVlemUoUkVDT1JESU5HX05VTExfT0JKRUNUKTtcbmNvbnN0IEhBTkRMRV9TRVBBUkFUT1IgPSB0cnVlO1xuY29uc3QgTUFYX01FVEhPRF9JRFggPSBNYXRoLnBvdygyLCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCkgLSAxO1xuY29uc3QgUkZUID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIlJFQ09SRElOR19QSEFTRV9UT0tFTlwiLCBwYXR0ZXJuOiBMZXhlci5OQSB9KTtcbmF1Z21lbnRUb2tlblR5cGVzKFtSRlRdKTtcbmNvbnN0IFJFQ09SRElOR19QSEFTRV9UT0tFTiA9IGNyZWF0ZVRva2VuSW5zdGFuY2UoUkZULCBcIlRoaXMgSVRva2VuIGluZGljYXRlcyB0aGUgUGFyc2VyIGlzIGluIFJlY29yZGluZyBQaGFzZVxcblxcdFwiICtcbiAgICBcIlwiICtcbiAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIiwgXG4vLyBVc2luZyBcIi0xXCIgaW5zdGVhZCBvZiBOYU4gKGFzIGluIEVPRikgYmVjYXVzZSBhbiBhY3R1YWwgbnVtYmVyIGlzIGxlc3MgbGlrZWx5IHRvXG4vLyBjYXVzZSBlcnJvcnMgaWYgdGhlIG91dHB1dCBvZiBMQSBvciBDT05TVU1FIHdvdWxkIGJlIChpbmNvcnJlY3RseSkgdXNlZCBkdXJpbmcgdGhlIHJlY29yZGluZyBwaGFzZS5cbi0xLCAtMSwgLTEsIC0xLCAtMSwgLTEpO1xuT2JqZWN0LmZyZWV6ZShSRUNPUkRJTkdfUEhBU0VfVE9LRU4pO1xuY29uc3QgUkVDT1JESU5HX1BIQVNFX0NTVE5PREUgPSB7XG4gICAgbmFtZTogXCJUaGlzIENTVE5vZGUgaW5kaWNhdGVzIHRoZSBQYXJzZXIgaXMgaW4gUmVjb3JkaW5nIFBoYXNlXFxuXFx0XCIgK1xuICAgICAgICBcIlNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmcgZm9yIGRldGFpbHNcIixcbiAgICBjaGlsZHJlbjoge30sXG59O1xuLyoqXG4gKiBUaGlzIHRyYWl0IGhhbmRsZXMgdGhlIGNyZWF0aW9uIG9mIHRoZSBHQVNUIHN0cnVjdHVyZSBmb3IgQ2hldnJvdGFpbiBHcmFtbWFyc1xuICovXG5leHBvcnQgY2xhc3MgR2FzdFJlY29yZGVyIHtcbiAgICBpbml0R2FzdFJlY29yZGVyKGNvbmZpZykge1xuICAgICAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgIH1cbiAgICBlbmFibGVSZWNvcmRpbmcoKSB7XG4gICAgICAgIHRoaXMuUkVDT1JESU5HX1BIQVNFID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5UUkFDRV9JTklUKFwiRW5hYmxlIFJlY29yZGluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdhcm5pbmcgRGFyayBWb29kb28gTWFnaWMgdXBjb21pbmchXG4gICAgICAgICAgICAgKiBXZSBhcmUgXCJyZXBsYWNpbmdcIiB0aGUgcHVibGljIHBhcnNpbmcgRFNMIG1ldGhvZHMgQVBJXG4gICAgICAgICAgICAgKiBXaXRoICoqbmV3KiogYWx0ZXJuYXRpdmUgaW1wbGVtZW50YXRpb25zIG9uIHRoZSBQYXJzZXIgKippbnN0YW5jZSoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogU28gZmFyIHRoaXMgaXMgdGhlIG9ubHkgd2F5IEkndmUgZm91bmQgdG8gYXZvaWQgcGVyZm9ybWFuY2UgcmVncmVzc2lvbnMgZHVyaW5nIHBhcnNpbmcgdGltZS5cbiAgICAgICAgICAgICAqIC0gQXBwcm94IDMwJSBwZXJmb3JtYW5jZSByZWdyZXNzaW9uIHdhcyBtZWFzdXJlZCBvbiBDaHJvbWUgNzUgQ2FuYXJ5IHdoZW4gYXR0ZW1wdGluZyB0byByZXBsYWNlIHRoZSBcImludGVybmFsXCJcbiAgICAgICAgICAgICAqICAgaW1wbGVtZW50YXRpb25zIGRpcmVjdGx5IGluc3RlYWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTA7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkeCA9IGkgPiAwID8gaSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgdGhpc1tgQ09OU1VNRSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsUmVjb3JkKGFyZzEsIGksIGFyZzIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tgU1VCUlVMRSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsUmVjb3JkKGFyZzEsIGksIGFyZzIpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tgT1BUSU9OJHtpZHh9YF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNbYE9SJHtpZHh9YF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsUmVjb3JkKGFyZzEsIGkpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpc1tgTUFOWSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW55SW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzW2BNQU5ZX1NFUCR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbFJlY29yZChpLCBhcmcxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXNbYEFUX0xFQVNUX09ORSR7aWR4fWBdID0gZnVuY3Rpb24gKGFyZzEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWxSZWNvcmQoaSwgYXJnMSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzW2BBVF9MRUFTVF9PTkVfU0VQJHtpZHh9YF0gPSBmdW5jdGlvbiAoYXJnMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkKGksIGFyZzEpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEU0wgbWV0aG9kcyB3aXRoIHRoZSBpZHgoc3VmZml4KSBhcyBhbiBhcmd1bWVudFxuICAgICAgICAgICAgdGhpc1tgY29uc3VtZWBdID0gZnVuY3Rpb24gKGlkeCwgYXJnMSwgYXJnMikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgsIGFyZzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYHN1YnJ1bGVgXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEsIGFyZzIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWxSZWNvcmQoYXJnMSwgaWR4LCBhcmcyKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzW2BvcHRpb25gXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYG9yYF0gPSBmdW5jdGlvbiAoaWR4LCBhcmcxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMub3JJbnRlcm5hbFJlY29yZChhcmcxLCBpZHgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYG1hbnlgXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXNbYGF0TGVhc3RPbmVgXSA9IGZ1bmN0aW9uIChpZHgsIGFyZzEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbFJlY29yZChpZHgsIGFyZzEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuQUNUSU9OID0gdGhpcy5BQ1RJT05fUkVDT1JEO1xuICAgICAgICAgICAgdGhpcy5CQUNLVFJBQ0sgPSB0aGlzLkJBQ0tUUkFDS19SRUNPUkQ7XG4gICAgICAgICAgICB0aGlzLkxBID0gdGhpcy5MQV9SRUNPUkQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNhYmxlUmVjb3JkaW5nKCkge1xuICAgICAgICB0aGlzLlJFQ09SRElOR19QSEFTRSA9IGZhbHNlO1xuICAgICAgICAvLyBCeSBkZWxldGluZyB0aGVzZSAqKmluc3RhbmNlKiogcHJvcGVydGllcywgYW55IGZ1dHVyZSBpbnZvY2F0aW9uXG4gICAgICAgIC8vIHdpbGwgYmUgZGVmZXJyZWQgdG8gdGhlIG9yaWdpbmFsIG1ldGhvZHMgb24gdGhlICoqcHJvdG90eXBlKiogb2JqZWN0XG4gICAgICAgIC8vIFRoaXMgc2VlbXMgdG8gZ2V0IHJpZCBvZiBhbnkgaW5jb3JyZWN0IG9wdGltaXphdGlvbnMgdGhhdCBWOCBtYXlcbiAgICAgICAgLy8gZG8gZHVyaW5nIHRoZSByZWNvcmRpbmcgcGhhc2UuXG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkRlbGV0aW5nIFJlY29yZGluZyBtZXRob2RzXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWR4ID0gaSA+IDAgPyBpIDogXCJcIjtcbiAgICAgICAgICAgICAgICBkZWxldGUgdGhhdFtgQ09OU1VNRSR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BTVUJSVUxFJHtpZHh9YF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbYE9QVElPTiR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BPUiR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BNQU5ZJHtpZHh9YF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbYE1BTllfU0VQJHtpZHh9YF07XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRoYXRbYEFUX0xFQVNUX09ORSR7aWR4fWBdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BBVF9MRUFTVF9PTkVfU0VQJHtpZHh9YF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhhdFtgY29uc3VtZWBdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbYHN1YnJ1bGVgXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BvcHRpb25gXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BvcmBdO1xuICAgICAgICAgICAgZGVsZXRlIHRoYXRbYG1hbnlgXTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGF0W2BhdExlYXN0T25lYF07XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5BQ1RJT047XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5CQUNLVFJBQ0s7XG4gICAgICAgICAgICBkZWxldGUgdGhhdC5MQTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vICAgUGFyc2VyIG1ldGhvZHMgYXJlIGNhbGxlZCBpbnNpZGUgYW4gQUNUSU9OP1xuICAgIC8vICAgTWF5YmUgdHJ5L2NhdGNoL2ZpbmFsbHkgb24gQUNUSU9OUyB3aGlsZSBkaXNhYmxpbmcgdGhlIHJlY29yZGVycyBzdGF0ZSBjaGFuZ2VzP1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLS0gbm9vcCBwbGFjZSBob2xkZXJcbiAgICBBQ1RJT05fUkVDT1JEKGltcGwpIHtcbiAgICAgICAgLy8gTk8tT1AgZHVyaW5nIHJlY29yZGluZ1xuICAgIH1cbiAgICAvLyBFeGVjdXRpbmcgYmFja3RyYWNraW5nIGxvZ2ljIHdpbGwgYnJlYWsgb3VyIHJlY29yZGluZyBsb2dpYyBhc3N1bXB0aW9uc1xuICAgIEJBQ0tUUkFDS19SRUNPUkQoZ3JhbW1hclJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IHRydWU7XG4gICAgfVxuICAgIC8vIExBIGlzIHBhcnQgb2YgdGhlIG9mZmljaWFsIEFQSSBhbmQgbWF5IGJlIHVzZWQgZm9yIGN1c3RvbSBsb29rYWhlYWQgbG9naWNcbiAgICAvLyBieSBlbmQgdXNlcnMgd2hvIG1heSBmb3JnZXQgdG8gd3JhcCBpdCBpbiBBQ1RJT04gb3IgaW5zaWRlIGEgR0FURVxuICAgIExBX1JFQ09SRChob3dNdWNoKSB7XG4gICAgICAgIC8vIFdlIGNhbm5vdCB1c2UgdGhlIFJFQ09SRF9QSEFTRV9UT0tFTiBoZXJlIGJlY2F1c2Ugc29tZW9uZSBtYXkgZGVwZW5kXG4gICAgICAgIC8vIE9uIExBIHJldHVybiBFT0YgYXQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgc28gYW4gaW5maW5pdGUgbG9vcCBtYXkgb2NjdXIuXG4gICAgICAgIHJldHVybiBFTkRfT0ZfRklMRTtcbiAgICB9XG4gICAgdG9wTGV2ZWxSdWxlUmVjb3JkKG5hbWUsIGRlZikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbmV3VG9wTGV2ZWxSdWxlID0gbmV3IFJ1bGUoeyBkZWZpbml0aW9uOiBbXSwgbmFtZTogbmFtZSB9KTtcbiAgICAgICAgICAgIG5ld1RvcExldmVsUnVsZS5uYW1lID0gbmFtZTtcbiAgICAgICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3VG9wTGV2ZWxSdWxlKTtcbiAgICAgICAgICAgIGRlZi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3VG9wTGV2ZWxSdWxlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChvcmlnaW5hbEVycm9yKSB7XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxFcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG9yaWdpbmFsRXJyb3IubWVzc2FnZSA9XG4gICAgICAgICAgICAgICAgICAgICAgICBvcmlnaW5hbEVycm9yLm1lc3NhZ2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdcXG5cXHQgVGhpcyBlcnJvciB3YXMgdGhyb3duIGR1cmluZyB0aGUgXCJncmFtbWFyIHJlY29yZGluZyBwaGFzZVwiIEZvciBtb3JlIGluZm8gc2VlOlxcblxcdCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvaW50ZXJuYWxzLmh0bWwjZ3JhbW1hci1yZWNvcmRpbmdcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKG11dGFiaWxpdHlFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBtYXkgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSBvcmlnaW5hbCBlcnJvciBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgb3JpZ2luYWxFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBvcmlnaW5hbEVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIHBhcnNpbmcgRFNMXG4gICAgb3B0aW9uSW50ZXJuYWxSZWNvcmQoYWN0aW9uT1JNZXRob2REZWYsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgcmV0dXJuIHJlY29yZFByb2QuY2FsbCh0aGlzLCBPcHRpb24sIGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKTtcbiAgICB9XG4gICAgYXRMZWFzdE9uZUludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uTWFuZGF0b3J5LCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgbWFueUludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJlY29yZFByb2QuY2FsbCh0aGlzLCBSZXBldGl0aW9uLCBhY3Rpb25PUk1ldGhvZERlZiwgb2NjdXJyZW5jZSk7XG4gICAgfVxuICAgIG1hbnlTZXBGaXJzdEludGVybmFsUmVjb3JkKG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgcmVjb3JkUHJvZC5jYWxsKHRoaXMsIFJlcGV0aXRpb25XaXRoU2VwYXJhdG9yLCBvcHRpb25zLCBvY2N1cnJlbmNlLCBIQU5ETEVfU0VQQVJBVE9SKTtcbiAgICB9XG4gICAgb3JJbnRlcm5hbFJlY29yZChhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIHJldHVybiByZWNvcmRPclByb2QuY2FsbCh0aGlzLCBhbHRzT3JPcHRzLCBvY2N1cnJlbmNlKTtcbiAgICB9XG4gICAgc3VicnVsZUludGVybmFsUmVjb3JkKHJ1bGVUb0NhbGwsIG9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICAgICAgaWYgKCFydWxlVG9DYWxsIHx8IGhhcyhydWxlVG9DYWxsLCBcInJ1bGVOYW1lXCIpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYDxTVUJSVUxFJHtnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSl9PiBhcmd1bWVudCBpcyBpbnZhbGlkYCArXG4gICAgICAgICAgICAgICAgYCBleHBlY3RpbmcgYSBQYXJzZXIgbWV0aG9kIHJlZmVyZW5jZSBidXQgZ290OiA8JHtKU09OLnN0cmluZ2lmeShydWxlVG9DYWxsKX0+YCArXG4gICAgICAgICAgICAgICAgYFxcbiBpbnNpZGUgdG9wIGxldmVsIHJ1bGU6IDwke3RoaXMucmVjb3JkaW5nUHJvZFN0YWNrWzBdLm5hbWV9PmApO1xuICAgICAgICAgICAgZXJyb3IuS05PV05fUkVDT1JERVJfRVJST1IgPSB0cnVlO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJldlByb2QgPSBwZWVrKHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrKTtcbiAgICAgICAgY29uc3QgcnVsZU5hbWUgPSBydWxlVG9DYWxsLnJ1bGVOYW1lO1xuICAgICAgICBjb25zdCBuZXdOb25lVGVybWluYWwgPSBuZXcgTm9uVGVybWluYWwoe1xuICAgICAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgbm9uVGVybWluYWxOYW1lOiBydWxlTmFtZSxcbiAgICAgICAgICAgIGxhYmVsOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuTEFCRUwsXG4gICAgICAgICAgICAvLyBUaGUgcmVzb2x2aW5nIG9mIHRoZSBgcmVmZXJlbmNlZFJ1bGVgIHByb3BlcnR5IHdpbGwgYmUgZG9uZSBvbmNlIGFsbCB0aGUgUnVsZSdzIEdBU1RzIGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgICAgICAgICByZWZlcmVuY2VkUnVsZTogdW5kZWZpbmVkLFxuICAgICAgICB9KTtcbiAgICAgICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld05vbmVUZXJtaW5hbCk7XG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dENzdFxuICAgICAgICAgICAgPyBSRUNPUkRJTkdfUEhBU0VfQ1NUTk9ERVxuICAgICAgICAgICAgOiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG4gICAgfVxuICAgIGNvbnN1bWVJbnRlcm5hbFJlY29yZCh0b2tUeXBlLCBvY2N1cnJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGFzc2VydE1ldGhvZElkeElzVmFsaWQob2NjdXJyZW5jZSk7XG4gICAgICAgIGlmICghaGFzU2hvcnRLZXlQcm9wZXJ0eSh0b2tUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoYDxDT05TVU1FJHtnZXRJZHhTdWZmaXgob2NjdXJyZW5jZSl9PiBhcmd1bWVudCBpcyBpbnZhbGlkYCArXG4gICAgICAgICAgICAgICAgYCBleHBlY3RpbmcgYSBUb2tlblR5cGUgcmVmZXJlbmNlIGJ1dCBnb3Q6IDwke0pTT04uc3RyaW5naWZ5KHRva1R5cGUpfT5gICtcbiAgICAgICAgICAgICAgICBgXFxuIGluc2lkZSB0b3AgbGV2ZWwgcnVsZTogPCR7dGhpcy5yZWNvcmRpbmdQcm9kU3RhY2tbMF0ubmFtZX0+YCk7XG4gICAgICAgICAgICBlcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiA9IHRydWU7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgICAgICBjb25zdCBuZXdOb25lVGVybWluYWwgPSBuZXcgVGVybWluYWwoe1xuICAgICAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICAgICAgdGVybWluYWxUeXBlOiB0b2tUeXBlLFxuICAgICAgICAgICAgbGFiZWw6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5MQUJFTCxcbiAgICAgICAgfSk7XG4gICAgICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdOb25lVGVybWluYWwpO1xuICAgICAgICByZXR1cm4gUkVDT1JESU5HX1BIQVNFX1RPS0VOO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHJlY29yZFByb2QocHJvZENvbnN0cnVjdG9yLCBtYWluUHJvZEFyZywgb2NjdXJyZW5jZSwgaGFuZGxlU2VwID0gZmFsc2UpIHtcbiAgICBhc3NlcnRNZXRob2RJZHhJc1ZhbGlkKG9jY3VycmVuY2UpO1xuICAgIGNvbnN0IHByZXZQcm9kID0gcGVlayh0aGlzLnJlY29yZGluZ1Byb2RTdGFjayk7XG4gICAgY29uc3QgZ3JhbW1hckFjdGlvbiA9IGlzRnVuY3Rpb24obWFpblByb2RBcmcpID8gbWFpblByb2RBcmcgOiBtYWluUHJvZEFyZy5ERUY7XG4gICAgY29uc3QgbmV3UHJvZCA9IG5ldyBwcm9kQ29uc3RydWN0b3IoeyBkZWZpbml0aW9uOiBbXSwgaWR4OiBvY2N1cnJlbmNlIH0pO1xuICAgIGlmIChoYW5kbGVTZXApIHtcbiAgICAgICAgbmV3UHJvZC5zZXBhcmF0b3IgPSBtYWluUHJvZEFyZy5TRVA7XG4gICAgfVxuICAgIGlmIChoYXMobWFpblByb2RBcmcsIFwiTUFYX0xPT0tBSEVBRFwiKSkge1xuICAgICAgICBuZXdQcm9kLm1heExvb2thaGVhZCA9IG1haW5Qcm9kQXJnLk1BWF9MT09LQUhFQUQ7XG4gICAgfVxuICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnB1c2gobmV3UHJvZCk7XG4gICAgZ3JhbW1hckFjdGlvbi5jYWxsKHRoaXMpO1xuICAgIHByZXZQcm9kLmRlZmluaXRpb24ucHVzaChuZXdQcm9kKTtcbiAgICB0aGlzLnJlY29yZGluZ1Byb2RTdGFjay5wb3AoKTtcbiAgICByZXR1cm4gUkVDT1JESU5HX05VTExfT0JKRUNUO1xufVxuZnVuY3Rpb24gcmVjb3JkT3JQcm9kKG1haW5Qcm9kQXJnLCBvY2N1cnJlbmNlKSB7XG4gICAgYXNzZXJ0TWV0aG9kSWR4SXNWYWxpZChvY2N1cnJlbmNlKTtcbiAgICBjb25zdCBwcmV2UHJvZCA9IHBlZWsodGhpcy5yZWNvcmRpbmdQcm9kU3RhY2spO1xuICAgIC8vIE9ubHkgYW4gYXJyYXkgb2YgYWx0ZXJuYXRpdmVzXG4gICAgY29uc3QgaGFzT3B0aW9ucyA9IGlzQXJyYXkobWFpblByb2RBcmcpID09PSBmYWxzZTtcbiAgICBjb25zdCBhbHRzID0gaGFzT3B0aW9ucyA9PT0gZmFsc2UgPyBtYWluUHJvZEFyZyA6IG1haW5Qcm9kQXJnLkRFRjtcbiAgICBjb25zdCBuZXdPclByb2QgPSBuZXcgQWx0ZXJuYXRpb24oe1xuICAgICAgICBkZWZpbml0aW9uOiBbXSxcbiAgICAgICAgaWR4OiBvY2N1cnJlbmNlLFxuICAgICAgICBpZ25vcmVBbWJpZ3VpdGllczogaGFzT3B0aW9ucyAmJiBtYWluUHJvZEFyZy5JR05PUkVfQU1CSUdVSVRJRVMgPT09IHRydWUsXG4gICAgfSk7XG4gICAgaWYgKGhhcyhtYWluUHJvZEFyZywgXCJNQVhfTE9PS0FIRUFEXCIpKSB7XG4gICAgICAgIG5ld09yUHJvZC5tYXhMb29rYWhlYWQgPSBtYWluUHJvZEFyZy5NQVhfTE9PS0FIRUFEO1xuICAgIH1cbiAgICBjb25zdCBoYXNQcmVkaWNhdGVzID0gc29tZShhbHRzLCAoY3VyckFsdCkgPT4gaXNGdW5jdGlvbihjdXJyQWx0LkdBVEUpKTtcbiAgICBuZXdPclByb2QuaGFzUHJlZGljYXRlcyA9IGhhc1ByZWRpY2F0ZXM7XG4gICAgcHJldlByb2QuZGVmaW5pdGlvbi5wdXNoKG5ld09yUHJvZCk7XG4gICAgZm9yRWFjaChhbHRzLCAoY3VyckFsdCkgPT4ge1xuICAgICAgICBjb25zdCBjdXJyQWx0RmxhdCA9IG5ldyBBbHRlcm5hdGl2ZSh7IGRlZmluaXRpb246IFtdIH0pO1xuICAgICAgICBuZXdPclByb2QuZGVmaW5pdGlvbi5wdXNoKGN1cnJBbHRGbGF0KTtcbiAgICAgICAgaWYgKGhhcyhjdXJyQWx0LCBcIklHTk9SRV9BTUJJR1VJVElFU1wiKSkge1xuICAgICAgICAgICAgY3VyckFsdEZsYXQuaWdub3JlQW1iaWd1aXRpZXMgPSBjdXJyQWx0LklHTk9SRV9BTUJJR1VJVElFUzsgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICB9XG4gICAgICAgIC8vICoqaW1wbGljaXQqKiBpZ25vcmVBbWJpZ3VpdGllcyBkdWUgdG8gdXNhZ2Ugb2YgZ2F0ZVxuICAgICAgICBlbHNlIGlmIChoYXMoY3VyckFsdCwgXCJHQVRFXCIpKSB7XG4gICAgICAgICAgICBjdXJyQWx0RmxhdC5pZ25vcmVBbWJpZ3VpdGllcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNvcmRpbmdQcm9kU3RhY2sucHVzaChjdXJyQWx0RmxhdCk7XG4gICAgICAgIGN1cnJBbHQuQUxULmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucmVjb3JkaW5nUHJvZFN0YWNrLnBvcCgpO1xuICAgIH0pO1xuICAgIHJldHVybiBSRUNPUkRJTkdfTlVMTF9PQkpFQ1Q7XG59XG5mdW5jdGlvbiBnZXRJZHhTdWZmaXgoaWR4KSB7XG4gICAgcmV0dXJuIGlkeCA9PT0gMCA/IFwiXCIgOiBgJHtpZHh9YDtcbn1cbmZ1bmN0aW9uIGFzc2VydE1ldGhvZElkeElzVmFsaWQoaWR4KSB7XG4gICAgaWYgKGlkeCA8IDAgfHwgaWR4ID4gTUFYX01FVEhPRF9JRFgpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoXG4gICAgICAgIC8vIFRoZSBzdGFjayB0cmFjZSB3aWxsIGNvbnRhaW4gYWxsIHRoZSBuZWVkZWQgZGV0YWlsc1xuICAgICAgICBgSW52YWxpZCBEU0wgTWV0aG9kIGlkeCB2YWx1ZTogPCR7aWR4fT5cXG5cXHRgICtcbiAgICAgICAgICAgIGBJZHggdmFsdWUgbXVzdCBiZSBhIG5vbmUgbmVnYXRpdmUgdmFsdWUgc21hbGxlciB0aGFuICR7TUFYX01FVEhPRF9JRFggKyAxfWApO1xuICAgICAgICBlcnJvci5LTk9XTl9SRUNPUkRFUl9FUlJPUiA9IHRydWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdhc3RfcmVjb3JkZXIuanMubWFwIiwiaW1wb3J0IHsgRU5EX09GX0ZJTEUgfSBmcm9tIFwiLi4vcGFyc2VyLmpzXCI7XG4vKipcbiAqIFRyYWl0IHJlc3BvbnNpYmxlIGFic3RyYWN0aW5nIG92ZXIgdGhlIGludGVyYWN0aW9uIHdpdGggTGV4ZXIgb3V0cHV0IChUb2tlbiB2ZWN0b3IpLlxuICpcbiAqIFRoaXMgY291bGQgYmUgZ2VuZXJhbGl6ZWQgdG8gc3VwcG9ydCBvdGhlciBraW5kcyBvZiBsZXhlcnMsIGUuZy5cbiAqIC0gSnVzdCBpbiBUaW1lIExleGluZyAvIExleGVyLUxlc3MgcGFyc2luZy5cbiAqIC0gU3RyZWFtaW5nIExleGVyLlxuICovXG5leHBvcnQgY2xhc3MgTGV4ZXJBZGFwdGVyIHtcbiAgICBpbml0TGV4ZXJBZGFwdGVyKCkge1xuICAgICAgICB0aGlzLnRva1ZlY3RvciA9IFtdO1xuICAgICAgICB0aGlzLnRva1ZlY3Rvckxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IC0xO1xuICAgIH1cbiAgICBzZXQgaW5wdXQobmV3SW5wdXQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSAtIGB0aGlzIHBhcmFtZXRlcmAgbm90IHN1cHBvcnRlZCBpbiBzZXR0ZXJzL2dldHRlcnNcbiAgICAgICAgLy8gICAtIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL2Z1bmN0aW9ucy5odG1sI3RoaXMtcGFyYW1ldGVyc1xuICAgICAgICBpZiAodGhpcy5zZWxmQW5hbHlzaXNEb25lICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihgTWlzc2luZyA8cGVyZm9ybVNlbGZBbmFseXNpcz4gaW52b2NhdGlvbiBhdCB0aGUgZW5kIG9mIHRoZSBQYXJzZXIncyBjb25zdHJ1Y3Rvci5gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlIC0gYHRoaXMgcGFyYW1ldGVyYCBub3Qgc3VwcG9ydGVkIGluIHNldHRlcnMvZ2V0dGVyc1xuICAgICAgICAvLyAgIC0gaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svZnVuY3Rpb25zLmh0bWwjdGhpcy1wYXJhbWV0ZXJzXG4gICAgICAgIHRoaXMucmVzZXQoKTtcbiAgICAgICAgdGhpcy50b2tWZWN0b3IgPSBuZXdJbnB1dDtcbiAgICAgICAgdGhpcy50b2tWZWN0b3JMZW5ndGggPSBuZXdJbnB1dC5sZW5ndGg7XG4gICAgfVxuICAgIGdldCBpbnB1dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rVmVjdG9yO1xuICAgIH1cbiAgICAvLyBza2lwcyBhIHRva2VuIGFuZCByZXR1cm5zIHRoZSBuZXh0IHRva2VuXG4gICAgU0tJUF9UT0tFTigpIHtcbiAgICAgICAgaWYgKHRoaXMuY3VycklkeCA8PSB0aGlzLnRva1ZlY3Rvci5sZW5ndGggLSAyKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuTEEoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gRU5EX09GX0ZJTEU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTGV4ZXIgKGFjY2Vzc2luZyBUb2tlbiB2ZWN0b3IpIHJlbGF0ZWQgbWV0aG9kcyB3aGljaCBjYW4gYmUgb3ZlcnJpZGRlbiB0byBpbXBsZW1lbnQgbGF6eSBsZXhlcnNcbiAgICAvLyBvciBsZXhlcnMgZGVwZW5kZW50IG9uIHBhcnNlciBjb250ZXh0LlxuICAgIExBKGhvd011Y2gpIHtcbiAgICAgICAgY29uc3Qgc291Z2h0SWR4ID0gdGhpcy5jdXJySWR4ICsgaG93TXVjaDtcbiAgICAgICAgaWYgKHNvdWdodElkeCA8IDAgfHwgdGhpcy50b2tWZWN0b3JMZW5ndGggPD0gc291Z2h0SWR4KSB7XG4gICAgICAgICAgICByZXR1cm4gRU5EX09GX0ZJTEU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tWZWN0b3Jbc291Z2h0SWR4XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdW1lVG9rZW4oKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCsrO1xuICAgIH1cbiAgICBleHBvcnRMZXhlclN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jdXJySWR4O1xuICAgIH1cbiAgICBpbXBvcnRMZXhlclN0YXRlKG5ld1N0YXRlKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IG5ld1N0YXRlO1xuICAgIH1cbiAgICByZXNldExleGVyU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IC0xO1xuICAgIH1cbiAgICBtb3ZlVG9UZXJtaW5hdGVkU3RhdGUoKSB7XG4gICAgICAgIHRoaXMuY3VycklkeCA9IHRoaXMudG9rVmVjdG9yLmxlbmd0aCAtIDE7XG4gICAgfVxuICAgIGdldExleGVyUG9zaXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmV4cG9ydExleGVyU3RhdGUoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9hZGFwdGVyLmpzLm1hcCIsImltcG9ydCB7IGZvckVhY2gsIGhhcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbmltcG9ydCB7IEFUX0xFQVNUX09ORV9JRFgsIEFUX0xFQVNUX09ORV9TRVBfSURYLCBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQsIE1BTllfSURYLCBNQU5ZX1NFUF9JRFgsIE9QVElPTl9JRFgsIE9SX0lEWCwgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9rZXlzLmpzXCI7XG5pbXBvcnQgeyBHQXN0VmlzaXRvciwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUsIH0gZnJvbSBcIkBjaGV2cm90YWluL2dhc3RcIjtcbmltcG9ydCB7IExMa0xvb2thaGVhZFN0cmF0ZWd5IH0gZnJvbSBcIi4uLy4uL2dyYW1tYXIvbGxrX2xvb2thaGVhZC5qc1wiO1xuLyoqXG4gKiBUcmFpdCByZXNwb25zaWJsZSBmb3IgdGhlIGxvb2thaGVhZCByZWxhdGVkIHV0aWxpdGllcyBhbmQgb3B0aW1pemF0aW9ucy5cbiAqL1xuZXhwb3J0IGNsYXNzIExvb2tzQWhlYWQge1xuICAgIGluaXRMb29rc0FoZWFkKGNvbmZpZykge1xuICAgICAgICB0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkID0gaGFzKGNvbmZpZywgXCJkeW5hbWljVG9rZW5zRW5hYmxlZFwiKVxuICAgICAgICAgICAgPyBjb25maWcuZHluYW1pY1Rva2Vuc0VuYWJsZWQgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcuZHluYW1pY1Rva2Vuc0VuYWJsZWQ7XG4gICAgICAgIHRoaXMubWF4TG9va2FoZWFkID0gaGFzKGNvbmZpZywgXCJtYXhMb29rYWhlYWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLm1heExvb2thaGVhZCAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5tYXhMb29rYWhlYWQ7XG4gICAgICAgIHRoaXMubG9va2FoZWFkU3RyYXRlZ3kgPSBoYXMoY29uZmlnLCBcImxvb2thaGVhZFN0cmF0ZWd5XCIpXG4gICAgICAgICAgICA/IGNvbmZpZy5sb29rYWhlYWRTdHJhdGVneSAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IG5ldyBMTGtMb29rYWhlYWRTdHJhdGVneSh7IG1heExvb2thaGVhZDogdGhpcy5tYXhMb29rYWhlYWQgfSk7XG4gICAgICAgIHRoaXMubG9va0FoZWFkRnVuY3NDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICB9XG4gICAgcHJlQ29tcHV0ZUxvb2thaGVhZEZ1bmN0aW9ucyhydWxlcykge1xuICAgICAgICBmb3JFYWNoKHJ1bGVzLCAoY3VyclJ1bGUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChgJHtjdXJyUnVsZS5uYW1lfSBSdWxlIExvb2thaGVhZGAsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGFsdGVybmF0aW9uLCByZXBldGl0aW9uLCBvcHRpb24sIHJlcGV0aXRpb25NYW5kYXRvcnksIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCByZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgfSA9IGNvbGxlY3RNZXRob2RzKGN1cnJSdWxlKTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKGFsdGVybmF0aW9uLCAoY3VyclByb2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvZElkeCA9IGN1cnJQcm9kLmlkeCA9PT0gMCA/IFwiXCIgOiBjdXJyUHJvZC5pZHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChgJHtnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCl9JHtwcm9kSWR4fWAsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxhRnVuYyA9IHRoaXMubG9va2FoZWFkU3RyYXRlZ3kuYnVpbGRMb29rYWhlYWRGb3JBbHRlcm5hdGlvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvZE9jY3VycmVuY2U6IGN1cnJQcm9kLmlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydWxlOiBjdXJyUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXhMb29rYWhlYWQ6IGN1cnJQcm9kLm1heExvb2thaGVhZCB8fCB0aGlzLm1heExvb2thaGVhZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNQcmVkaWNhdGVzOiBjdXJyUHJvZC5oYXNQcmVkaWNhdGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR5bmFtaWNUb2tlbnNFbmFibGVkOiB0aGlzLmR5bmFtaWNUb2tlbnNFbmFibGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQodGhpcy5mdWxsUnVsZU5hbWVUb1Nob3J0W2N1cnJSdWxlLm5hbWVdLCBPUl9JRFgsIGN1cnJQcm9kLmlkeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldExhRnVuY0NhY2hlKGtleSwgbGFGdW5jKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChyZXBldGl0aW9uLCAoY3VyclByb2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBNQU5ZX0lEWCwgXCJSZXBldGl0aW9uXCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKG9wdGlvbiwgKGN1cnJQcm9kKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgT1BUSU9OX0lEWCwgXCJPcHRpb25cIiwgY3VyclByb2QubWF4TG9va2FoZWFkLCBnZXRQcm9kdWN0aW9uRHNsTmFtZShjdXJyUHJvZCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGZvckVhY2gocmVwZXRpdGlvbk1hbmRhdG9yeSwgKGN1cnJQcm9kKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgQVRfTEVBU1RfT05FX0lEWCwgXCJSZXBldGl0aW9uTWFuZGF0b3J5XCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBmb3JFYWNoKHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yLCAoY3VyclByb2QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTG9va2FoZWFkRnVuYyhjdXJyUnVsZSwgY3VyclByb2QuaWR4LCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgXCJSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvclwiLCBjdXJyUHJvZC5tYXhMb29rYWhlYWQsIGdldFByb2R1Y3Rpb25Ec2xOYW1lKGN1cnJQcm9kKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZm9yRWFjaChyZXBldGl0aW9uV2l0aFNlcGFyYXRvciwgKGN1cnJQcm9kKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcHV0ZUxvb2thaGVhZEZ1bmMoY3VyclJ1bGUsIGN1cnJQcm9kLmlkeCwgTUFOWV9TRVBfSURYLCBcIlJlcGV0aXRpb25XaXRoU2VwYXJhdG9yXCIsIGN1cnJQcm9kLm1heExvb2thaGVhZCwgZ2V0UHJvZHVjdGlvbkRzbE5hbWUoY3VyclByb2QpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29tcHV0ZUxvb2thaGVhZEZ1bmMocnVsZSwgcHJvZE9jY3VycmVuY2UsIHByb2RLZXksIHByb2RUeXBlLCBwcm9kTWF4TG9va2FoZWFkLCBkc2xNZXRob2ROYW1lKSB7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChgJHtkc2xNZXRob2ROYW1lfSR7cHJvZE9jY3VycmVuY2UgPT09IDAgPyBcIlwiIDogcHJvZE9jY3VycmVuY2V9YCwgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFGdW5jID0gdGhpcy5sb29rYWhlYWRTdHJhdGVneS5idWlsZExvb2thaGVhZEZvck9wdGlvbmFsKHtcbiAgICAgICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBydWxlLFxuICAgICAgICAgICAgICAgIG1heExvb2thaGVhZDogcHJvZE1heExvb2thaGVhZCB8fCB0aGlzLm1heExvb2thaGVhZCxcbiAgICAgICAgICAgICAgICBkeW5hbWljVG9rZW5zRW5hYmxlZDogdGhpcy5keW5hbWljVG9rZW5zRW5hYmxlZCxcbiAgICAgICAgICAgICAgICBwcm9kVHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKHRoaXMuZnVsbFJ1bGVOYW1lVG9TaG9ydFtydWxlLm5hbWVdLCBwcm9kS2V5LCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgICAgICAgICB0aGlzLnNldExhRnVuY0NhY2hlKGtleSwgbGFGdW5jKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIHRoaXMgYWN0dWFsbHkgcmV0dXJucyBhIG51bWJlciwgYnV0IGl0IGlzIGFsd2F5cyB1c2VkIGFzIGEgc3RyaW5nIChvYmplY3QgcHJvcCBrZXkpXG4gICAgZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGRzbE1ldGhvZElkeCwgb2NjdXJyZW5jZSkge1xuICAgICAgICBjb25zdCBjdXJyUnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICByZXR1cm4gZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKGN1cnJSdWxlU2hvcnROYW1lLCBkc2xNZXRob2RJZHgsIG9jY3VycmVuY2UpO1xuICAgIH1cbiAgICBnZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuZ2V0KGtleSk7XG4gICAgfVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgc2V0TGFGdW5jQ2FjaGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxvb2tBaGVhZEZ1bmNzQ2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbn1cbmNsYXNzIERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yIGV4dGVuZHMgR0FzdFZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMgPSB7XG4gICAgICAgICAgICBvcHRpb246IFtdLFxuICAgICAgICAgICAgYWx0ZXJuYXRpb246IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uV2l0aFNlcGFyYXRvcjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uTWFuZGF0b3J5OiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnlXaXRoU2VwYXJhdG9yOiBbXSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcyA9IHtcbiAgICAgICAgICAgIG9wdGlvbjogW10sXG4gICAgICAgICAgICBhbHRlcm5hdGlvbjogW10sXG4gICAgICAgICAgICByZXBldGl0aW9uOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25XaXRoU2VwYXJhdG9yOiBbXSxcbiAgICAgICAgICAgIHJlcGV0aXRpb25NYW5kYXRvcnk6IFtdLFxuICAgICAgICAgICAgcmVwZXRpdGlvbk1hbmRhdG9yeVdpdGhTZXBhcmF0b3I6IFtdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB2aXNpdE9wdGlvbihvcHRpb24pIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLm9wdGlvbi5wdXNoKG9wdGlvbik7XG4gICAgfVxuICAgIHZpc2l0UmVwZXRpdGlvbldpdGhTZXBhcmF0b3IobWFueVNlcCkge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbldpdGhTZXBhcmF0b3IucHVzaChtYW55U2VwKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5KGF0TGVhc3RPbmUpIHtcbiAgICAgICAgdGhpcy5kc2xNZXRob2RzLnJlcGV0aXRpb25NYW5kYXRvcnkucHVzaChhdExlYXN0T25lKTtcbiAgICB9XG4gICAgdmlzaXRSZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvcihhdExlYXN0T25lU2VwKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5yZXBldGl0aW9uTWFuZGF0b3J5V2l0aFNlcGFyYXRvci5wdXNoKGF0TGVhc3RPbmVTZXApO1xuICAgIH1cbiAgICB2aXNpdFJlcGV0aXRpb24obWFueSkge1xuICAgICAgICB0aGlzLmRzbE1ldGhvZHMucmVwZXRpdGlvbi5wdXNoKG1hbnkpO1xuICAgIH1cbiAgICB2aXNpdEFsdGVybmF0aW9uKG9yKSB7XG4gICAgICAgIHRoaXMuZHNsTWV0aG9kcy5hbHRlcm5hdGlvbi5wdXNoKG9yKTtcbiAgICB9XG59XG5jb25zdCBjb2xsZWN0b3JWaXNpdG9yID0gbmV3IERzbE1ldGhvZHNDb2xsZWN0b3JWaXNpdG9yKCk7XG5leHBvcnQgZnVuY3Rpb24gY29sbGVjdE1ldGhvZHMocnVsZSkge1xuICAgIGNvbGxlY3RvclZpc2l0b3IucmVzZXQoKTtcbiAgICBydWxlLmFjY2VwdChjb2xsZWN0b3JWaXNpdG9yKTtcbiAgICBjb25zdCBkc2xNZXRob2RzID0gY29sbGVjdG9yVmlzaXRvci5kc2xNZXRob2RzO1xuICAgIC8vIGF2b2lkIHVuY2xlYW5lZCByZWZlcmVuY2VzXG4gICAgY29sbGVjdG9yVmlzaXRvci5yZXNldCgpO1xuICAgIHJldHVybiBkc2xNZXRob2RzO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bG9va3NhaGVhZC5qcy5tYXAiLCJpbXBvcnQgeyBoYXMgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyB0aW1lciB9IGZyb20gXCJAY2hldnJvdGFpbi91dGlsc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuLyoqXG4gKiBUcmFpdCByZXNwb25zaWJsZSBmb3IgcnVudGltZSBwYXJzaW5nIGVycm9ycy5cbiAqL1xuZXhwb3J0IGNsYXNzIFBlcmZvcm1hbmNlVHJhY2VyIHtcbiAgICBpbml0UGVyZm9ybWFuY2VUcmFjZXIoY29uZmlnKSB7XG4gICAgICAgIGlmIChoYXMoY29uZmlnLCBcInRyYWNlSW5pdFBlcmZcIikpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZXJUcmFjZUluaXRQZXJmID0gY29uZmlnLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgICAgICBjb25zdCB0cmFjZUlzTnVtYmVyID0gdHlwZW9mIHVzZXJUcmFjZUluaXRQZXJmID09PSBcIm51bWJlclwiO1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRNYXhJZGVudCA9IHRyYWNlSXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IHVzZXJUcmFjZUluaXRQZXJmXG4gICAgICAgICAgICAgICAgOiBJbmZpbml0eTtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0UGVyZiA9IHRyYWNlSXNOdW1iZXJcbiAgICAgICAgICAgICAgICA/IHVzZXJUcmFjZUluaXRQZXJmID4gMFxuICAgICAgICAgICAgICAgIDogdXNlclRyYWNlSW5pdFBlcmY7IC8vIGFzc3VtZXMgZW5kIHVzZXIgcHJvdmlkZXMgdGhlIGNvcnJlY3QgY29uZmlnIHZhbHVlL3R5cGVcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSAwO1xuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRQZXJmID0gREVGQVVMVF9QQVJTRVJfQ09ORklHLnRyYWNlSW5pdFBlcmY7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQgPSAtMTtcbiAgICB9XG4gICAgVFJBQ0VfSU5JVChwaGFzZURlc2MsIHBoYXNlSW1wbCkge1xuICAgICAgICAvLyBObyBuZWVkIHRvIG9wdGltaXplIHRoaXMgdXNpbmcgTk9PUCBwYXR0ZXJuIGJlY2F1c2VcbiAgICAgICAgLy8gSXQgaXMgbm90IGNhbGxlZCBpbiBhIGhvdCBzcG90Li4uXG4gICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdFBlcmYgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50Kys7XG4gICAgICAgICAgICBjb25zdCBpbmRlbnQgPSBuZXcgQXJyYXkodGhpcy50cmFjZUluaXRJbmRlbnQgKyAxKS5qb2luKFwiXFx0XCIpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0SW5kZW50IDwgdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGAke2luZGVudH0tLT4gPCR7cGhhc2VEZXNjfT5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgdGltZSwgdmFsdWUgfSA9IHRpbWVyKHBoYXNlSW1wbCk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIERpZmZpY3VsdCB0byByZXByb2R1Y2Ugc3BlY2lmaWMgcGVyZm9ybWFuY2UgYmVoYXZpb3IgKD4xMG1zKSBpbiB0ZXN0cyAqL1xuICAgICAgICAgICAgY29uc3QgdHJhY2VNZXRob2QgPSB0aW1lID4gMTAgPyBjb25zb2xlLndhcm4gOiBjb25zb2xlLmxvZztcbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICB0cmFjZU1ldGhvZChgJHtpbmRlbnR9PC0tIDwke3BoYXNlRGVzY30+IHRpbWU6ICR7dGltZX1tc2ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQtLTtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBwaGFzZUltcGwoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBlcmZfdHJhY2VyLmpzLm1hcCIsImltcG9ydCB7IGluY2x1ZGVzLCB2YWx1ZXMgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBpc1JlY29nbml0aW9uRXhjZXB0aW9uIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBERUZBVUxUX1JVTEVfQ09ORklHLCBQYXJzZXJEZWZpbml0aW9uRXJyb3JUeXBlIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgZGVmYXVsdEdyYW1tYXJWYWxpZGF0b3JFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4uLy4uL2Vycm9yc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IHZhbGlkYXRlUnVsZUlzT3ZlcnJpZGRlbiB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2NoZWNrcy5qc1wiO1xuaW1wb3J0IHsgc2VyaWFsaXplR3JhbW1hciB9IGZyb20gXCJAY2hldnJvdGFpbi9nYXN0XCI7XG4vKipcbiAqIFRoaXMgdHJhaXQgaXMgcmVzcG9uc2libGUgZm9yIGltcGxlbWVudGluZyB0aGUgcHVibGljIEFQSVxuICogZm9yIGRlZmluaW5nIENoZXZyb3RhaW4gcGFyc2VycywgaS5lOlxuICogLSBDT05TVU1FXG4gKiAtIFJVTEVcbiAqIC0gT1BUSU9OXG4gKiAtIC4uLlxuICovXG5leHBvcnQgY2xhc3MgUmVjb2duaXplckFwaSB7XG4gICAgQUNUSU9OKGltcGwpIHtcbiAgICAgICAgcmV0dXJuIGltcGwuY2FsbCh0aGlzKTtcbiAgICB9XG4gICAgY29uc3VtZShpZHgsIHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIGlkeCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHN1YnJ1bGUoaWR4LCBydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCBpZHgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBvcHRpb24oaWR4LCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgaWR4KTtcbiAgICB9XG4gICAgb3IoaWR4LCBhbHRzT3JPcHRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9ySW50ZXJuYWwoYWx0c09yT3B0cywgaWR4KTtcbiAgICB9XG4gICAgbWFueShpZHgsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hbnlJbnRlcm5hbChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgYXRMZWFzdE9uZShpZHgsIGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbChpZHgsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQ09OU1VNRSh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ09OU1VNRTEodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgMSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIENPTlNVTUUyKHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDT05TVU1FMyh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCAzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ09OU1VNRTQodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIENPTlNVTUU1KHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDT05TVU1FNih0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA2LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQ09OU1VNRTcodG9rVHlwZSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lSW50ZXJuYWwodG9rVHlwZSwgNywgb3B0aW9ucyk7XG4gICAgfVxuICAgIENPTlNVTUU4KHRva1R5cGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uc3VtZUludGVybmFsKHRva1R5cGUsIDgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBDT05TVU1FOSh0b2tUeXBlLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCA5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRShydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAwLCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRTEocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgMSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEUyKHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBTVUJSVUxFMyhydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCAzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRTQocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEU1KHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBTVUJSVUxFNihydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA2LCBvcHRpb25zKTtcbiAgICB9XG4gICAgU1VCUlVMRTcocnVsZVRvQ2FsbCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5zdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgNywgb3B0aW9ucyk7XG4gICAgfVxuICAgIFNVQlJVTEU4KHJ1bGVUb0NhbGwsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZUludGVybmFsKHJ1bGVUb0NhbGwsIDgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBTVUJSVUxFOShydWxlVG9DYWxsLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnJ1bGVJbnRlcm5hbChydWxlVG9DYWxsLCA5LCBvcHRpb25zKTtcbiAgICB9XG4gICAgT1BUSU9OKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAwKTtcbiAgICB9XG4gICAgT1BUSU9OMShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgMSk7XG4gICAgfVxuICAgIE9QVElPTjIoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDIpO1xuICAgIH1cbiAgICBPUFRJT04zKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCAzKTtcbiAgICB9XG4gICAgT1BUSU9ONChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNCk7XG4gICAgfVxuICAgIE9QVElPTjUoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDUpO1xuICAgIH1cbiAgICBPUFRJT042KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA2KTtcbiAgICB9XG4gICAgT1BUSU9ONyhhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbChhY3Rpb25PUk1ldGhvZERlZiwgNyk7XG4gICAgfVxuICAgIE9QVElPTjgoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9uSW50ZXJuYWwoYWN0aW9uT1JNZXRob2REZWYsIDgpO1xuICAgIH1cbiAgICBPUFRJT045KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCA5KTtcbiAgICB9XG4gICAgT1IoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDApO1xuICAgIH1cbiAgICBPUjEoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDEpO1xuICAgIH1cbiAgICBPUjIoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDIpO1xuICAgIH1cbiAgICBPUjMoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDMpO1xuICAgIH1cbiAgICBPUjQoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDQpO1xuICAgIH1cbiAgICBPUjUoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDUpO1xuICAgIH1cbiAgICBPUjYoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDYpO1xuICAgIH1cbiAgICBPUjcoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDcpO1xuICAgIH1cbiAgICBPUjgoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDgpO1xuICAgIH1cbiAgICBPUjkoYWx0c09yT3B0cykge1xuICAgICAgICByZXR1cm4gdGhpcy5vckludGVybmFsKGFsdHNPck9wdHMsIDkpO1xuICAgIH1cbiAgICBNQU5ZKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDAsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWTEoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoMSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBNQU5ZMihhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCgyLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTlkzKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDMsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWTQoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBNQU5ZNShhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg1LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTlk2KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDYsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWTcoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5tYW55SW50ZXJuYWwoNywgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBNQU5ZOChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLm1hbnlJbnRlcm5hbCg4LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIE1BTlk5KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMubWFueUludGVybmFsKDksIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgTUFOWV9TRVAob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDAsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDEob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDEsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDIob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDMob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDQob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDQsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDUob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDYob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDYsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDcob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDcsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDgob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBNQU5ZX1NFUDkob3B0aW9ucykge1xuICAgICAgICB0aGlzLm1hbnlTZXBGaXJzdEludGVybmFsKDksIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkUoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkUxKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCgxLCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORTIoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoMiwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkUzKGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDMsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FNChhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg0LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORTUoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoNSwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkU2KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDYsIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FNyhhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVJbnRlcm5hbCg3LCBhY3Rpb25PUk1ldGhvZERlZik7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORTgoYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lSW50ZXJuYWwoOCwgYWN0aW9uT1JNZXRob2REZWYpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkU5KGFjdGlvbk9STWV0aG9kRGVmKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZUludGVybmFsKDksIGFjdGlvbk9STWV0aG9kRGVmKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUChvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVAxKG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCgxLCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUDIob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkVfU0VQMyhvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoMywgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVA0KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUDUob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDUsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkVfU0VQNihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoNiwgb3B0aW9ucyk7XG4gICAgfVxuICAgIEFUX0xFQVNUX09ORV9TRVA3KG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lU2VwRmlyc3RJbnRlcm5hbCg3LCBvcHRpb25zKTtcbiAgICB9XG4gICAgQVRfTEVBU1RfT05FX1NFUDgob3B0aW9ucykge1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsKDgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICBBVF9MRUFTVF9PTkVfU0VQOShvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwoOSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFJVTEUobmFtZSwgaW1wbGVtZW50YXRpb24sIGNvbmZpZyA9IERFRkFVTFRfUlVMRV9DT05GSUcpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzKHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMsIG5hbWUpKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSBkZWZhdWx0R3JhbW1hclZhbGlkYXRvckVycm9yUHJvdmlkZXIuYnVpbGREdXBsaWNhdGVSdWxlTmFtZUVycm9yKHtcbiAgICAgICAgICAgICAgICB0b3BMZXZlbFJ1bGU6IG5hbWUsXG4gICAgICAgICAgICAgICAgZ3JhbW1hck5hbWU6IHRoaXMuY2xhc3NOYW1lLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnJNc2csXG4gICAgICAgICAgICAgICAgdHlwZTogUGFyc2VyRGVmaW5pdGlvbkVycm9yVHlwZS5EVVBMSUNBVEVfUlVMRV9OQU1FLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiBuYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZGVmaW5pdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRlZmluZWRSdWxlc05hbWVzLnB1c2gobmFtZSk7XG4gICAgICAgIGNvbnN0IHJ1bGVJbXBsZW1lbnRhdGlvbiA9IHRoaXMuZGVmaW5lUnVsZShuYW1lLCBpbXBsZW1lbnRhdGlvbiwgY29uZmlnKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICB9XG4gICAgT1ZFUlJJREVfUlVMRShuYW1lLCBpbXBsLCBjb25maWcgPSBERUZBVUxUX1JVTEVfQ09ORklHKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVFcnJvcnMgPSB2YWxpZGF0ZVJ1bGVJc092ZXJyaWRkZW4obmFtZSwgdGhpcy5kZWZpbmVkUnVsZXNOYW1lcywgdGhpcy5jbGFzc05hbWUpO1xuICAgICAgICB0aGlzLmRlZmluaXRpb25FcnJvcnMgPSB0aGlzLmRlZmluaXRpb25FcnJvcnMuY29uY2F0KHJ1bGVFcnJvcnMpO1xuICAgICAgICBjb25zdCBydWxlSW1wbGVtZW50YXRpb24gPSB0aGlzLmRlZmluZVJ1bGUobmFtZSwgaW1wbCwgY29uZmlnKTtcbiAgICAgICAgdGhpc1tuYW1lXSA9IHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICAgICAgcmV0dXJuIHJ1bGVJbXBsZW1lbnRhdGlvbjtcbiAgICB9XG4gICAgQkFDS1RSQUNLKGdyYW1tYXJSdWxlLCBhcmdzKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIG9yZyBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrLnB1c2goMSk7XG4gICAgICAgICAgICBjb25zdCBvcmdTdGF0ZSA9IHRoaXMuc2F2ZVJlY29nU3RhdGUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZ3JhbW1hclJ1bGUuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gZXhjZXB0aW9uIHdhcyB0aHJvd24gd2UgaGF2ZSBzdWNjZWVkIHBhcnNpbmcgdGhlIHJ1bGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChpc1JlY29nbml0aW9uRXhjZXB0aW9uKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxvYWRSZWNvZ1N0YXRlKG9yZ1N0YXRlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzQmFja1RyYWNraW5nU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIEdBU1QgZXhwb3J0IEFQSXNcbiAgICBnZXRHQXN0UHJvZHVjdGlvbnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlO1xuICAgIH1cbiAgICBnZXRTZXJpYWxpemVkR2FzdFByb2R1Y3Rpb25zKCkge1xuICAgICAgICByZXR1cm4gc2VyaWFsaXplR3JhbW1hcih2YWx1ZXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29nbml6ZXJfYXBpLmpzLm1hcCIsImltcG9ydCB7IGNsb25lLCBldmVyeSwgZmxhdHRlbiwgaGFzLCBpc0FycmF5LCBpc0VtcHR5LCBpc09iamVjdCwgcmVkdWNlLCB1bmlxLCB2YWx1ZXMsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgQVRfTEVBU1RfT05FX0lEWCwgQVRfTEVBU1RfT05FX1NFUF9JRFgsIEJJVFNfRk9SX01FVEhPRF9UWVBFLCBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCwgTUFOWV9JRFgsIE1BTllfU0VQX0lEWCwgT1BUSU9OX0lEWCwgT1JfSURYLCB9IGZyb20gXCIuLi8uLi9ncmFtbWFyL2tleXMuanNcIjtcbmltcG9ydCB7IGlzUmVjb2duaXRpb25FeGNlcHRpb24sIE1pc21hdGNoZWRUb2tlbkV4Y2VwdGlvbiwgTm90QWxsSW5wdXRQYXJzZWRFeGNlcHRpb24sIH0gZnJvbSBcIi4uLy4uL2V4Y2VwdGlvbnNfcHVibGljLmpzXCI7XG5pbXBvcnQgeyBQUk9EX1RZUEUgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9sb29rYWhlYWQuanNcIjtcbmltcG9ydCB7IE5leHRUZXJtaW5hbEFmdGVyQXRMZWFzdE9uZVNlcFdhbGtlciwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyLCBOZXh0VGVybWluYWxBZnRlck1hbnlTZXBXYWxrZXIsIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciwgfSBmcm9tIFwiLi4vLi4vZ3JhbW1hci9pbnRlcnByZXRlci5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9SVUxFX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbmltcG9ydCB7IElOX1JVTEVfUkVDT1ZFUllfRVhDRVBUSU9OIH0gZnJvbSBcIi4vcmVjb3ZlcmFibGUuanNcIjtcbmltcG9ydCB7IEVPRiB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzLCBpc1Rva2VuVHlwZSwgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlciwgdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllcywgfSBmcm9tIFwiLi4vLi4vLi4vc2Nhbi90b2tlbnMuanNcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIHJ1bnRpbWUgcGFyc2luZyBlbmdpbmVcbiAqIFVzZWQgYnkgdGhlIG9mZmljaWFsIEFQSSAocmVjb2duaXplcl9hcGkudHMpXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvZ25pemVyRW5naW5lIHtcbiAgICBpbml0UmVjb2duaXplckVuZ2luZSh0b2tlblZvY2FidWxhcnksIGNvbmZpZykge1xuICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IHRoaXMuY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgLy8gVE9ETzogd291bGQgdXNpbmcgYW4gRVM2IE1hcCBvciBwbGFpbiBvYmplY3QgYmUgZmFzdGVyIChDU1QgYnVpbGRpbmcgc2NlbmFyaW8pXG4gICAgICAgIHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbCA9IHt9O1xuICAgICAgICB0aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnQgPSB7fTtcbiAgICAgICAgdGhpcy5ydWxlU2hvcnROYW1lSWR4ID0gMjU2O1xuICAgICAgICB0aGlzLnRva2VuTWF0Y2hlciA9IHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXM7XG4gICAgICAgIHRoaXMuc3VicnVsZUlkeCA9IDA7XG4gICAgICAgIHRoaXMuZGVmaW5lZFJ1bGVzTmFtZXMgPSBbXTtcbiAgICAgICAgdGhpcy50b2tlbnNNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5pc0JhY2tUcmFja2luZ1N0YWNrID0gW107XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLmdhc3RQcm9kdWN0aW9uc0NhY2hlID0ge307XG4gICAgICAgIGlmIChoYXMoY29uZmlnLCBcInNlcmlhbGl6ZWRHcmFtbWFyXCIpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlRoZSBQYXJzZXIncyBjb25maWd1cmF0aW9uIGNhbiBubyBsb25nZXIgY29udGFpbiBhIDxzZXJpYWxpemVkR3JhbW1hcj4gcHJvcGVydHkuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNi0wLTBcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRGb3IgRnVydGhlciBkZXRhaWxzLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSh0b2tlblZvY2FidWxhcnkpKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG9ubHkgY2hlY2tzIGZvciBUb2tlbiB2b2NhYnVsYXJpZXMgcHJvdmlkZWQgYXMgYXJyYXlzLlxuICAgICAgICAgICAgLy8gVGhhdCBpcyBnb29kIGVub3VnaCBiZWNhdXNlIHRoZSBtYWluIG9iamVjdGl2ZSBpcyB0byBkZXRlY3QgdXNlcnMgb2YgcHJlLVY0LjAgQVBJc1xuICAgICAgICAgICAgLy8gcmF0aGVyIHRoYW4gYWxsIGVkZ2UgY2FzZXMgb2YgZW1wdHkgVG9rZW4gdm9jYWJ1bGFyaWVzLlxuICAgICAgICAgICAgaWYgKGlzRW1wdHkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKFwiQSBUb2tlbiBWb2NhYnVsYXJ5IGNhbm5vdCBiZSBlbXB0eS5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0Tm90ZSB0aGF0IHRoZSBmaXJzdCBhcmd1bWVudCBmb3IgdGhlIHBhcnNlciBjb25zdHJ1Y3RvclxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRpcyBubyBsb25nZXIgYSBUb2tlbiB2ZWN0b3IgKHNpbmNlIHY0LjApLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5Wb2NhYnVsYXJ5WzBdLnN0YXJ0T2Zmc2V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgUGFyc2VyIGNvbnN0cnVjdG9yIG5vIGxvbmdlciBhY2NlcHRzIGEgdG9rZW4gdmVjdG9yIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9jaGFuZ2VzL0JSRUFLSU5HX0NIQU5HRVMuaHRtbCNfNC0wLTBcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIEZ1cnRoZXIgZGV0YWlscy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJyYXkodG9rZW5Wb2NhYnVsYXJ5KSkge1xuICAgICAgICAgICAgdGhpcy50b2tlbnNNYXAgPSByZWR1Y2UodG9rZW5Wb2NhYnVsYXJ5LCAoYWNjLCB0b2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgYWNjW3Rva1R5cGUubmFtZV0gPSB0b2tUeXBlO1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaGFzKHRva2VuVm9jYWJ1bGFyeSwgXCJtb2Rlc1wiKSAmJlxuICAgICAgICAgICAgZXZlcnkoZmxhdHRlbih2YWx1ZXModG9rZW5Wb2NhYnVsYXJ5Lm1vZGVzKSksIGlzVG9rZW5UeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgYWxsVG9rZW5UeXBlcyA9IGZsYXR0ZW4odmFsdWVzKHRva2VuVm9jYWJ1bGFyeS5tb2RlcykpO1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlVG9rZW5zID0gdW5pcShhbGxUb2tlblR5cGVzKTtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zTWFwID0gcmVkdWNlKHVuaXF1ZVRva2VucywgKGFjYywgdG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY1t0b2tUeXBlLm5hbWVdID0gdG9rVHlwZTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KHRva2VuVm9jYWJ1bGFyeSkpIHtcbiAgICAgICAgICAgIHRoaXMudG9rZW5zTWFwID0gY2xvbmUodG9rZW5Wb2NhYnVsYXJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIjx0b2tlbnNEaWN0aW9uYXJ5PiBhcmd1bWVudCBtdXN0IGJlIEFuIEFycmF5IG9mIFRva2VuIGNvbnN0cnVjdG9ycyxcIiArXG4gICAgICAgICAgICAgICAgXCIgQSBkaWN0aW9uYXJ5IG9mIFRva2VuIGNvbnN0cnVjdG9ycyBvciBhbiBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGFsd2F5cyBhZGQgRU9GIHRvIHRoZSB0b2tlbk5hbWVzIC0+IGNvbnN0cnVjdG9ycyBtYXAuIGl0IGlzIHVzZWZ1bCB0byBhc3N1cmUgYWxsIHRoZSBpbnB1dCBoYXMgYmVlblxuICAgICAgICAvLyBwYXJzZWQgd2l0aCBhIGNsZWFyIGVycm9yIG1lc3NhZ2UgKFwiZXhwZWN0aW5nIEVPRiBidXQgZm91bmQgLi4uXCIpXG4gICAgICAgIHRoaXMudG9rZW5zTWFwW1wiRU9GXCJdID0gRU9GO1xuICAgICAgICBjb25zdCBhbGxUb2tlblR5cGVzID0gaGFzKHRva2VuVm9jYWJ1bGFyeSwgXCJtb2Rlc1wiKVxuICAgICAgICAgICAgPyBmbGF0dGVuKHZhbHVlcyh0b2tlblZvY2FidWxhcnkubW9kZXMpKVxuICAgICAgICAgICAgOiB2YWx1ZXModG9rZW5Wb2NhYnVsYXJ5KTtcbiAgICAgICAgY29uc3Qgbm9Ub2tlbkNhdGVnb3JpZXNVc2VkID0gZXZlcnkoYWxsVG9rZW5UeXBlcywgKHRva2VuQ29uc3RydWN0b3IpID0+IGlzRW1wdHkodG9rZW5Db25zdHJ1Y3Rvci5jYXRlZ29yeU1hdGNoZXMpKTtcbiAgICAgICAgdGhpcy50b2tlbk1hdGNoZXIgPSBub1Rva2VuQ2F0ZWdvcmllc1VzZWRcbiAgICAgICAgICAgID8gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlck5vQ2F0ZWdvcmllc1xuICAgICAgICAgICAgOiB0b2tlblN0cnVjdHVyZWRNYXRjaGVyO1xuICAgICAgICAvLyBCZWNhdXNlIEVTMjAxNSsgc3ludGF4IHNob3VsZCBiZSBzdXBwb3J0ZWQgZm9yIGNyZWF0aW5nIFRva2VuIGNsYXNzZXNcbiAgICAgICAgLy8gV2UgY2Fubm90IGFzc3VtZSB0aGF0IHRoZSBUb2tlbiBjbGFzc2VzIHdlcmUgY3JlYXRlZCB1c2luZyB0aGUgXCJleHRlbmRUb2tlblwiIHV0aWxpdGllc1xuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbXVzdCBhdWdtZW50IHRoZSBUb2tlbiBjbGFzc2VzIGJvdGggb24gTGV4ZXIgaW5pdGlhbGl6YXRpb24gYW5kIG9uIFBhcnNlciBpbml0aWFsaXphdGlvblxuICAgICAgICBhdWdtZW50VG9rZW5UeXBlcyh2YWx1ZXModGhpcy50b2tlbnNNYXApKTtcbiAgICB9XG4gICAgZGVmaW5lUnVsZShydWxlTmFtZSwgaW1wbCwgY29uZmlnKSB7XG4gICAgICAgIGlmICh0aGlzLnNlbGZBbmFseXNpc0RvbmUpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKGBHcmFtbWFyIHJ1bGUgPCR7cnVsZU5hbWV9PiBtYXkgbm90IGJlIGRlZmluZWQgYWZ0ZXIgdGhlICdwZXJmb3JtU2VsZkFuYWx5c2lzJyBtZXRob2QgaGFzIGJlZW4gY2FsbGVkJ1xcbmAgK1xuICAgICAgICAgICAgICAgIGBNYWtlIHN1cmUgdGhhdCBhbGwgZ3JhbW1hciBydWxlIGRlZmluaXRpb25zIGFyZSBkb25lIGJlZm9yZSAncGVyZm9ybVNlbGZBbmFseXNpcycgaXMgY2FsbGVkLmApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3luY0VuYWJsZWQgPSBoYXMoY29uZmlnLCBcInJlc3luY0VuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlc3luY0VuYWJsZWQgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBERUZBVUxUX1JVTEVfQ09ORklHLnJlc3luY0VuYWJsZWQ7XG4gICAgICAgIGNvbnN0IHJlY292ZXJ5VmFsdWVGdW5jID0gaGFzKGNvbmZpZywgXCJyZWNvdmVyeVZhbHVlRnVuY1wiKVxuICAgICAgICAgICAgPyBjb25maWcucmVjb3ZlcnlWYWx1ZUZ1bmMgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBERUZBVUxUX1JVTEVfQ09ORklHLnJlY292ZXJ5VmFsdWVGdW5jO1xuICAgICAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFVzZSBzbWFsbCBpbnRlZ2VycyBhcyBrZXlzIGZvciB0aGUgbG9uZ2VyIGh1bWFuIHJlYWRhYmxlIFwiZnVsbFwiIHJ1bGUgbmFtZXMuXG4gICAgICAgIC8vIHRoaXMgZ3JlYXRseSBpbXByb3ZlcyBNYXAgYWNjZXNzIHRpbWUgKGFzIG11Y2ggYXMgOCUgZm9yIHNvbWUgcGVyZm9ybWFuY2UgYmVuY2htYXJrcykuXG4gICAgICAgIGNvbnN0IHNob3J0TmFtZSA9IHRoaXMucnVsZVNob3J0TmFtZUlkeCA8PCAoQklUU19GT1JfTUVUSE9EX1RZUEUgKyBCSVRTX0ZPUl9PQ0NVUlJFTkNFX0lEWCk7XG4gICAgICAgIHRoaXMucnVsZVNob3J0TmFtZUlkeCsrO1xuICAgICAgICB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxbc2hvcnROYW1lXSA9IHJ1bGVOYW1lO1xuICAgICAgICB0aGlzLmZ1bGxSdWxlTmFtZVRvU2hvcnRbcnVsZU5hbWVdID0gc2hvcnROYW1lO1xuICAgICAgICBsZXQgaW52b2tlUnVsZVdpdGhUcnk7XG4gICAgICAgIC8vIE1pY3JvIG9wdGltaXphdGlvbiwgb25seSBjaGVjayB0aGUgY29uZGl0aW9uICoqb25jZSoqIG9uIHJ1bGUgZGVmaW5pdGlvblxuICAgICAgICAvLyBpbnN0ZWFkIG9mICoqZXZlcnkgc2luZ2xlKiogcnVsZSBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGludm9rZVJ1bGVXaXRoVHJ5ID0gZnVuY3Rpb24gaW52b2tlUnVsZVdpdGhUcnkoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShzaG9ydE5hbWUsIHJ1bGVOYW1lLCB0aGlzLnN1YnJ1bGVJZHgpO1xuICAgICAgICAgICAgICAgICAgICBpbXBsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjc3QgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZShjc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pbnZva2VSdWxlQ2F0Y2goZSwgcmVzeW5jRW5hYmxlZCwgcmVjb3ZlcnlWYWx1ZUZ1bmMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ydWxlRmluYWxseVN0YXRlVXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGludm9rZVJ1bGVXaXRoVHJ5ID0gZnVuY3Rpb24gaW52b2tlUnVsZVdpdGhUcnlDc3QoLi4uYXJncykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShzaG9ydE5hbWUsIHJ1bGVOYW1lLCB0aGlzLnN1YnJ1bGVJZHgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaW1wbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW52b2tlUnVsZUNhdGNoKGUsIHJlc3luY0VuYWJsZWQsIHJlY292ZXJ5VmFsdWVGdW5jKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd3JhcHBlZEdyYW1tYXJSdWxlID0gT2JqZWN0LmFzc2lnbihpbnZva2VSdWxlV2l0aFRyeSwgeyBydWxlTmFtZSwgb3JpZ2luYWxHcmFtbWFyQWN0aW9uOiBpbXBsIH0pO1xuICAgICAgICByZXR1cm4gd3JhcHBlZEdyYW1tYXJSdWxlO1xuICAgIH1cbiAgICBpbnZva2VSdWxlQ2F0Y2goZSwgcmVzeW5jRW5hYmxlZENvbmZpZywgcmVjb3ZlcnlWYWx1ZUZ1bmMpIHtcbiAgICAgICAgY29uc3QgaXNGaXJzdEludm9rZWRSdWxlID0gdGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMTtcbiAgICAgICAgLy8gbm90ZSB0aGUgcmVTeW5jIGlzIGFsd2F5cyBlbmFibGVkIGZvciB0aGUgZmlyc3QgcnVsZSBpbnZvY2F0aW9uLCBiZWNhdXNlIHdlIG11c3QgYWx3YXlzIGJlIGFibGUgdG9cbiAgICAgICAgLy8gcmVTeW5jIHdpdGggRU9GIGFuZCBqdXN0IG91dHB1dCBzb21lIElOVkFMSUQgUGFyc2VUcmVlXG4gICAgICAgIC8vIGR1cmluZyBiYWNrdHJhY2tpbmcgcmVTeW5jIHJlY292ZXJ5IGlzIGRpc2FibGVkLCBvdGhlcndpc2Ugd2UgY2FuJ3QgYmUgY2VydGFpbiB0aGUgYmFja3RyYWNraW5nXG4gICAgICAgIC8vIHBhdGggaXMgcmVhbGx5IHRoZSBtb3N0IHZhbGlkIG9uZVxuICAgICAgICBjb25zdCByZVN5bmNFbmFibGVkID0gcmVzeW5jRW5hYmxlZENvbmZpZyAmJiAhdGhpcy5pc0JhY2tUcmFja2luZygpICYmIHRoaXMucmVjb3ZlcnlFbmFibGVkO1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSkge1xuICAgICAgICAgICAgY29uc3QgcmVjb2dFcnJvciA9IGU7XG4gICAgICAgICAgICBpZiAocmVTeW5jRW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlU3luY1Rva1R5cGUgPSB0aGlzLmZpbmRSZVN5bmNUb2tlblR5cGUoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pc0luQ3VycmVudFJ1bGVSZVN5bmNTZXQocmVTeW5jVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb2dFcnJvci5yZXN5bmNlZFRva2VucyA9IHRoaXMucmVTeW5jVG8ocmVTeW5jVG9rVHlwZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dENzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbENzdFJlc3VsdCA9IHRoaXMuQ1NUX1NUQUNLW3RoaXMuQ1NUX1NUQUNLLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbENzdFJlc3VsdC5yZWNvdmVyZWROb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxDc3RSZXN1bHQgPSB0aGlzLkNTVF9TVEFDS1t0aGlzLkNTVF9TVEFDSy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWxDc3RSZXN1bHQucmVjb3ZlcmVkTm9kZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWNvZ0Vycm9yLnBhcnRpYWxDc3RSZXN1bHQgPSBwYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGJlIGhhbmRsZWQgRnVydGhlciB1cCB0aGUgY2FsbCBzdGFja1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyByZWNvZ0Vycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRmlyc3RJbnZva2VkUnVsZSkge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBhIFJlZHVuZGFudCBpbnB1dCBlcnJvciB3aWxsIGJlIGNyZWF0ZWQgYXMgd2VsbCBhbmQgd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoaXMgaXMgaW5kZWVkIHRoZSBjYXNlXG4gICAgICAgICAgICAgICAgdGhpcy5tb3ZlVG9UZXJtaW5hdGVkU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAvLyB0aGUgcGFyc2VyIHNob3VsZCBuZXZlciB0aHJvdyBvbmUgb2YgaXRzIG93biBlcnJvcnMgb3V0c2lkZSBpdHMgZmxvdy5cbiAgICAgICAgICAgICAgICAvLyBldmVuIGlmIGVycm9yIHJlY292ZXJ5IGlzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY292ZXJ5VmFsdWVGdW5jKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdG8gYmUgcmVjb3ZlcmVkIEZ1cnRoZXIgdXAgdGhlIGNhbGwgc3RhY2tcbiAgICAgICAgICAgICAgICB0aHJvdyByZWNvZ0Vycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gc29tZSBvdGhlciBFcnJvciB0eXBlIHdoaWNoIHdlIGRvbid0IGtub3cgaG93IHRvIGhhbmRsZSAoZm9yIGV4YW1wbGUgYSBidWlsdCBpbiBKYXZhU2NyaXB0IEVycm9yKVxuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiBwYXJzaW5nIERTTFxuICAgIG9wdGlvbkludGVybmFsKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKE9QVElPTl9JRFgsIG9jY3VycmVuY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25JbnRlcm5hbExvZ2ljKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpO1xuICAgIH1cbiAgICBvcHRpb25JbnRlcm5hbExvZ2ljKGFjdGlvbk9STWV0aG9kRGVmLCBvY2N1cnJlbmNlLCBrZXkpIHtcbiAgICAgICAgbGV0IGxvb2tBaGVhZEZ1bmMgPSB0aGlzLmdldExhRnVuY0Zyb21DYWNoZShrZXkpO1xuICAgICAgICBsZXQgYWN0aW9uO1xuICAgICAgICBpZiAodHlwZW9mIGFjdGlvbk9STWV0aG9kRGVmICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbk9STWV0aG9kRGVmLkRFRjtcbiAgICAgICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IGFjdGlvbk9STWV0aG9kRGVmLkdBVEU7XG4gICAgICAgICAgICAvLyBwcmVkaWNhdGUgcHJlc2VudFxuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JnTG9va2FoZWFkRnVuY3Rpb24gPSBsb29rQWhlYWRGdW5jO1xuICAgICAgICAgICAgICAgIGxvb2tBaGVhZEZ1bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuY2FsbCh0aGlzKSAmJiBvcmdMb29rYWhlYWRGdW5jdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZjtcbiAgICAgICAgfVxuICAgICAgICBpZiAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgYXRMZWFzdE9uZUludGVybmFsKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZikge1xuICAgICAgICBjb25zdCBsYUtleSA9IHRoaXMuZ2V0S2V5Rm9yQXV0b21hdGljTG9va2FoZWFkKEFUX0xFQVNUX09ORV9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXRMZWFzdE9uZUludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBsYUtleSk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmVJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZiwga2V5KSB7XG4gICAgICAgIGxldCBsb29rQWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgbGV0IGFjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25PUk1ldGhvZERlZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvb2thaGVhZEZ1bmN0aW9uID0gbG9va0FoZWFkRnVuYztcbiAgICAgICAgICAgICAgICBsb29rQWhlYWRGdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcHJlZGljYXRlLmNhbGwodGhpcykgJiYgb3JnTG9va2FoZWFkRnVuY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWN0aW9uID0gYWN0aW9uT1JNZXRob2REZWY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvb2tBaGVhZEZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbGV0IG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIHdoaWxlIChsb29rQWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUgJiZcbiAgICAgICAgICAgICAgICBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIG5vdFN0dWNrID0gdGhpcy5kb1NpbmdsZVJlcGV0aXRpb24oYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IHRoaXMucmFpc2VFYXJseUV4aXRFeGNlcHRpb24ocHJvZE9jY3VycmVuY2UsIFBST0RfVFlQRS5SRVBFVElUSU9OX01BTkRBVE9SWSwgYWN0aW9uT1JNZXRob2REZWYuRVJSX01TRyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm90ZSB0aGF0IHdoaWxlIGl0IG1heSBzZWVtIHRoYXQgdGhpcyBjYW4gY2F1c2UgYW4gZXJyb3IgYmVjYXVzZSBieSB1c2luZyBhIHJlY3Vyc2l2ZSBjYWxsIHRvXG4gICAgICAgIC8vIEFUX0xFQVNUX09ORSB3ZSBjaGFuZ2UgdGhlIGdyYW1tYXIgdG8gQVRfTEVBU1RfVFdPLCBBVF9MRUFTVF9USFJFRSAuLi4gLCB0aGUgcG9zc2libGUgcmVjdXJzaXZlIGNhbGxcbiAgICAgICAgLy8gZnJvbSB0aGUgdHJ5SW5SZXBldGl0aW9uUmVjb3ZlcnkoLi4uKSB3aWxsIG9ubHkgaGFwcGVuIElGRiB0aGVyZSByZWFsbHkgYXJlIFRXTy9USFJFRS8uLi4uIGl0ZW1zLlxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5hdExlYXN0T25lSW50ZXJuYWwsIFtwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWZdLCBsb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfSURYLCBwcm9kT2NjdXJyZW5jZSwgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lV2Fsa2VyKTtcbiAgICB9XG4gICAgYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWwocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChBVF9MRUFTVF9PTkVfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICB0aGlzLmF0TGVhc3RPbmVTZXBGaXJzdEludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMsIGxhS2V5KTtcbiAgICB9XG4gICAgYXRMZWFzdE9uZVNlcEZpcnN0SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgb3B0aW9ucywga2V5KSB7XG4gICAgICAgIGNvbnN0IGFjdGlvbiA9IG9wdGlvbnMuREVGO1xuICAgICAgICBjb25zdCBzZXBhcmF0b3IgPSBvcHRpb25zLlNFUDtcbiAgICAgICAgY29uc3QgZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgLy8gMXN0IGl0ZXJhdGlvblxuICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb25Mb29rYWhlYWRGdW5jLmNhbGwodGhpcykgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgLy8gIFRPRE86IE9wdGltaXphdGlvbiBjYW4gbW92ZSB0aGlzIGZ1bmN0aW9uIGNvbnN0cnVjdGlvbiBpbnRvIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgICAgIC8vICBiZWNhdXNlIGl0IGlzIG9ubHkgbmVlZGVkIGluIGVycm9yIHJlY292ZXJ5IHNjZW5hcmlvcy5cbiAgICAgICAgICAgIGNvbnN0IHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHNlcGFyYXRvcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgLy8gMm5kLi5udGggaXRlcmF0aW9uc1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMudG9rZW5NYXRjaGVyKHRoaXMuTEEoMSksIHNlcGFyYXRvcikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyBub3RlIHRoYXQgdGhpcyBDT05TVU1FIHdpbGwgbmV2ZXIgZW50ZXIgcmVjb3ZlcnkgYmVjYXVzZVxuICAgICAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0b3JMb29rQWhlYWRGdW5jIGNoZWNrcyB0aGF0IHRoZSBzZXBhcmF0b3IgcmVhbGx5IGRvZXMgZXhpc3QuXG4gICAgICAgICAgICAgICAgdGhpcy5DT05TVU1FKHNlcGFyYXRvcik7XG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCBmb3IgY2hlY2tpbmcgaW5maW5pdGUgbG9vcCBoZXJlIGR1ZSB0byBjb25zdW1pbmcgdGhlIHNlcGFyYXRvci5cbiAgICAgICAgICAgICAgICBhY3Rpb24uY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIiB3aWxsIGJlIGRlZmluZWQgYXMgTk9PUCB1bmxlc3MgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsIFtcbiAgICAgICAgICAgICAgICBwcm9kT2NjdXJyZW5jZSxcbiAgICAgICAgICAgICAgICBzZXBhcmF0b3IsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyxcbiAgICAgICAgICAgICAgICBhY3Rpb24sXG4gICAgICAgICAgICAgICAgTmV4dFRlcm1pbmFsQWZ0ZXJBdExlYXN0T25lU2VwV2Fsa2VyLFxuICAgICAgICAgICAgXSwgc2VwYXJhdG9yTG9va0FoZWFkRnVuYywgQVRfTEVBU1RfT05FX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlLCBOZXh0VGVybWluYWxBZnRlckF0TGVhc3RPbmVTZXBXYWxrZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5yYWlzZUVhcmx5RXhpdEV4Y2VwdGlvbihwcm9kT2NjdXJyZW5jZSwgUFJPRF9UWVBFLlJFUEVUSVRJT05fTUFOREFUT1JZX1dJVEhfU0VQQVJBVE9SLCBvcHRpb25zLkVSUl9NU0cpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hbnlJbnRlcm5hbChwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYpIHtcbiAgICAgICAgY29uc3QgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChNQU5ZX0lEWCwgcHJvZE9jY3VycmVuY2UpO1xuICAgICAgICByZXR1cm4gdGhpcy5tYW55SW50ZXJuYWxMb2dpYyhwcm9kT2NjdXJyZW5jZSwgYWN0aW9uT1JNZXRob2REZWYsIGxhS2V5KTtcbiAgICB9XG4gICAgbWFueUludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIGFjdGlvbk9STWV0aG9kRGVmLCBrZXkpIHtcbiAgICAgICAgbGV0IGxvb2thaGVhZEZ1bmN0aW9uID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgbGV0IGFjdGlvbjtcbiAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb25PUk1ldGhvZERlZiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZi5ERUY7XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBhY3Rpb25PUk1ldGhvZERlZi5HQVRFO1xuICAgICAgICAgICAgLy8gcHJlZGljYXRlIHByZXNlbnRcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZ0xvb2thaGVhZEZ1bmN0aW9uID0gbG9va2FoZWFkRnVuY3Rpb247XG4gICAgICAgICAgICAgICAgbG9va2FoZWFkRnVuY3Rpb24gPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuY2FsbCh0aGlzKSAmJiBvcmdMb29rYWhlYWRGdW5jdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY3Rpb24gPSBhY3Rpb25PUk1ldGhvZERlZjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbm90U3R1Y2sgPSB0cnVlO1xuICAgICAgICB3aGlsZSAobG9va2FoZWFkRnVuY3Rpb24uY2FsbCh0aGlzKSA9PT0gdHJ1ZSAmJiBub3RTdHVjayA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgbm90U3R1Y2sgPSB0aGlzLmRvU2luZ2xlUmVwZXRpdGlvbihhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBlcmZvcm1hbmNlIG9wdGltaXphdGlvbjogXCJhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnlcIiB3aWxsIGJlIGRlZmluZWQgYXMgTk9PUCB1bmxlc3MgcmVjb3ZlcnkgaXMgZW5hYmxlZFxuICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSh0aGlzLm1hbnlJbnRlcm5hbCwgW3Byb2RPY2N1cnJlbmNlLCBhY3Rpb25PUk1ldGhvZERlZl0sIGxvb2thaGVhZEZ1bmN0aW9uLCBNQU5ZX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVdhbGtlciwgXG4gICAgICAgIC8vIFRoZSBub3RTdHVjayBwYXJhbWV0ZXIgaXMgb25seSByZWxldmFudCB3aGVuIFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCJcbiAgICAgICAgLy8gaXMgaW52b2tlZCBmcm9tIG1hbnlJbnRlcm5hbCwgaW4gdGhlIE1BTllfU0VQIGNhc2UgYW5kIEFUX0xFQVNUX09ORVtfU0VQXVxuICAgICAgICAvLyBBbiBpbmZpbml0ZSBsb29wIGNhbm5vdCBvY2N1ciBhczpcbiAgICAgICAgLy8gLSBFaXRoZXIgdGhlIGxvb2thaGVhZCBpcyBndWFyYW50ZWVkIHRvIGNvbnN1bWUgc29tZXRoaW5nIChTaW5nbGUgVG9rZW4gU2VwYXJhdG9yKVxuICAgICAgICAvLyAtIEFUX0xFQVNUX09ORSBieSBkZWZpbml0aW9uIGlzIGd1YXJhbnRlZWQgdG8gY29uc3VtZSBzb21ldGhpbmcgKG9yIGVycm9yIG91dCkuXG4gICAgICAgIG5vdFN0dWNrKTtcbiAgICB9XG4gICAgbWFueVNlcEZpcnN0SW50ZXJuYWwocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChNQU5ZX1NFUF9JRFgsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgdGhpcy5tYW55U2VwRmlyc3RJbnRlcm5hbExvZ2ljKHByb2RPY2N1cnJlbmNlLCBvcHRpb25zLCBsYUtleSk7XG4gICAgfVxuICAgIG1hbnlTZXBGaXJzdEludGVybmFsTG9naWMocHJvZE9jY3VycmVuY2UsIG9wdGlvbnMsIGtleSkge1xuICAgICAgICBjb25zdCBhY3Rpb24gPSBvcHRpb25zLkRFRjtcbiAgICAgICAgY29uc3Qgc2VwYXJhdG9yID0gb3B0aW9ucy5TRVA7XG4gICAgICAgIGNvbnN0IGZpcnN0SXRlcmF0aW9uTGFGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUoa2V5KTtcbiAgICAgICAgLy8gMXN0IGl0ZXJhdGlvblxuICAgICAgICBpZiAoZmlyc3RJdGVyYXRpb25MYUZ1bmMuY2FsbCh0aGlzKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLCBzZXBhcmF0b3IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIC8vIDJuZC4ubnRoIGl0ZXJhdGlvbnNcbiAgICAgICAgICAgIHdoaWxlICh0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDEpLCBzZXBhcmF0b3IpID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoaXMgQ09OU1VNRSB3aWxsIG5ldmVyIGVudGVyIHJlY292ZXJ5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAvLyB0aGUgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyBjaGVja3MgdGhhdCB0aGUgc2VwYXJhdG9yIHJlYWxseSBkb2VzIGV4aXN0LlxuICAgICAgICAgICAgICAgIHRoaXMuQ09OU1VNRShzZXBhcmF0b3IpO1xuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgZm9yIGNoZWNraW5nIGluZmluaXRlIGxvb3AgaGVyZSBkdWUgdG8gY29uc3VtaW5nIHRoZSBzZXBhcmF0b3IuXG4gICAgICAgICAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgICAgIHRoaXMuYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5KHRoaXMucmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsLCBbXG4gICAgICAgICAgICAgICAgcHJvZE9jY3VycmVuY2UsXG4gICAgICAgICAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICAgICAgICAgIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsXG4gICAgICAgICAgICAgICAgYWN0aW9uLFxuICAgICAgICAgICAgICAgIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcixcbiAgICAgICAgICAgIF0sIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIE1BTllfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIE5leHRUZXJtaW5hbEFmdGVyTWFueVNlcFdhbGtlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwZXRpdGlvblNlcFNlY29uZEludGVybmFsKHByb2RPY2N1cnJlbmNlLCBzZXBhcmF0b3IsIHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMsIGFjdGlvbiwgbmV4dFRlcm1pbmFsQWZ0ZXJXYWxrZXIpIHtcbiAgICAgICAgd2hpbGUgKHNlcGFyYXRvckxvb2tBaGVhZEZ1bmMoKSkge1xuICAgICAgICAgICAgLy8gbm90ZSB0aGF0IHRoaXMgQ09OU1VNRSB3aWxsIG5ldmVyIGVudGVyIHJlY292ZXJ5IGJlY2F1c2VcbiAgICAgICAgICAgIC8vIHRoZSBzZXBhcmF0b3JMb29rQWhlYWRGdW5jIGNoZWNrcyB0aGF0IHRoZSBzZXBhcmF0b3IgcmVhbGx5IGRvZXMgZXhpc3QuXG4gICAgICAgICAgICB0aGlzLkNPTlNVTUUoc2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGFjdGlvbi5jYWxsKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdlIGNhbiBvbmx5IGFycml2ZSB0byB0aGlzIGZ1bmN0aW9uIGFmdGVyIGFuIGVycm9yXG4gICAgICAgIC8vIGhhcyBvY2N1cnJlZCAoaGVuY2UgdGhlIG5hbWUgJ3NlY29uZCcpIHNvIHRoZSBmb2xsb3dpbmdcbiAgICAgICAgLy8gSUYgd2lsbCBhbHdheXMgYmUgZW50ZXJlZCwgaXRzIHBvc3NpYmxlIHRvIHJlbW92ZSBpdC4uLlxuICAgICAgICAvLyBob3dldmVyIGl0IGlzIGtlcHQgdG8gYXZvaWQgY29uZnVzaW9uIGFuZCBiZSBjb25zaXN0ZW50LlxuICAgICAgICAvLyBQZXJmb3JtYW5jZSBvcHRpbWl6YXRpb246IFwiYXR0ZW1wdEluUmVwZXRpdGlvblJlY292ZXJ5XCIgd2lsbCBiZSBkZWZpbmVkIGFzIE5PT1AgdW5sZXNzIHJlY292ZXJ5IGlzIGVuYWJsZWRcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgdGhpcy5hdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkodGhpcy5yZXBldGl0aW9uU2VwU2Vjb25kSW50ZXJuYWwsIFtcbiAgICAgICAgICAgIHByb2RPY2N1cnJlbmNlLFxuICAgICAgICAgICAgc2VwYXJhdG9yLFxuICAgICAgICAgICAgc2VwYXJhdG9yTG9va0FoZWFkRnVuYyxcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyLFxuICAgICAgICBdLCBzZXBhcmF0b3JMb29rQWhlYWRGdW5jLCBBVF9MRUFTVF9PTkVfU0VQX0lEWCwgcHJvZE9jY3VycmVuY2UsIG5leHRUZXJtaW5hbEFmdGVyV2Fsa2VyKTtcbiAgICB9XG4gICAgZG9TaW5nbGVSZXBldGl0aW9uKGFjdGlvbikge1xuICAgICAgICBjb25zdCBiZWZvcmVJdGVyYXRpb24gPSB0aGlzLmdldExleGVyUG9zaXRpb24oKTtcbiAgICAgICAgYWN0aW9uLmNhbGwodGhpcyk7XG4gICAgICAgIGNvbnN0IGFmdGVySXRlcmF0aW9uID0gdGhpcy5nZXRMZXhlclBvc2l0aW9uKCk7XG4gICAgICAgIC8vIFRoaXMgYm9vbGVhbiB3aWxsIGluZGljYXRlIGlmIHRoaXMgcmVwZXRpdGlvbiBwcm9ncmVzc2VkXG4gICAgICAgIC8vIG9yIGlmIHdlIGFyZSBcInN0dWNrXCIgKHBvdGVudGlhbCBpbmZpbml0ZSBsb29wIGluIHRoZSByZXBldGl0aW9uKS5cbiAgICAgICAgcmV0dXJuIGFmdGVySXRlcmF0aW9uID4gYmVmb3JlSXRlcmF0aW9uO1xuICAgIH1cbiAgICBvckludGVybmFsKGFsdHNPck9wdHMsIG9jY3VycmVuY2UpIHtcbiAgICAgICAgY29uc3QgbGFLZXkgPSB0aGlzLmdldEtleUZvckF1dG9tYXRpY0xvb2thaGVhZChPUl9JRFgsIG9jY3VycmVuY2UpO1xuICAgICAgICBjb25zdCBhbHRzID0gaXNBcnJheShhbHRzT3JPcHRzKSA/IGFsdHNPck9wdHMgOiBhbHRzT3JPcHRzLkRFRjtcbiAgICAgICAgY29uc3QgbGFGdW5jID0gdGhpcy5nZXRMYUZ1bmNGcm9tQ2FjaGUobGFLZXkpO1xuICAgICAgICBjb25zdCBhbHRJZHhUb1Rha2UgPSBsYUZ1bmMuY2FsbCh0aGlzLCBhbHRzKTtcbiAgICAgICAgaWYgKGFsdElkeFRvVGFrZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBjaG9zZW5BbHRlcm5hdGl2ZSA9IGFsdHNbYWx0SWR4VG9UYWtlXTtcbiAgICAgICAgICAgIHJldHVybiBjaG9zZW5BbHRlcm5hdGl2ZS5BTFQuY2FsbCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJhaXNlTm9BbHRFeGNlcHRpb24ob2NjdXJyZW5jZSwgYWx0c09yT3B0cy5FUlJfTVNHKTtcbiAgICB9XG4gICAgcnVsZUZpbmFsbHlTdGF0ZVVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLLnBvcCgpO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSy5wb3AoKTtcbiAgICAgICAgLy8gTk9PUCB3aGVuIGNzdCBpcyBkaXNhYmxlZFxuICAgICAgICB0aGlzLmNzdEZpbmFsbHlTdGF0ZVVwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5SVUxFX1NUQUNLLmxlbmd0aCA9PT0gMCAmJiB0aGlzLmlzQXRFbmRPZklucHV0KCkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaXJzdFJlZHVuZGFudFRvayA9IHRoaXMuTEEoMSk7XG4gICAgICAgICAgICBjb25zdCBlcnJNc2cgPSB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTm90QWxsSW5wdXRQYXJzZWRNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBmaXJzdFJlZHVuZGFudDogZmlyc3RSZWR1bmRhbnRUb2ssXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlNBVkVfRVJST1IobmV3IE5vdEFsbElucHV0UGFyc2VkRXhjZXB0aW9uKGVyck1zZywgZmlyc3RSZWR1bmRhbnRUb2spKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJydWxlSW50ZXJuYWwocnVsZVRvQ2FsbCwgaWR4LCBvcHRpb25zKSB7XG4gICAgICAgIGxldCBydWxlUmVzdWx0O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IG9wdGlvbnMgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuQVJHUyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuc3VicnVsZUlkeCA9IGlkeDtcbiAgICAgICAgICAgIHJ1bGVSZXN1bHQgPSBydWxlVG9DYWxsLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwocnVsZVJlc3VsdCwgb3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5MQUJFTFxuICAgICAgICAgICAgICAgIDogcnVsZVRvQ2FsbC5ydWxlTmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gcnVsZVJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgdGhpcy5zdWJydWxlSW50ZXJuYWxFcnJvcihlLCBvcHRpb25zLCBydWxlVG9DYWxsLnJ1bGVOYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJydWxlSW50ZXJuYWxFcnJvcihlLCBvcHRpb25zLCBydWxlTmFtZSkge1xuICAgICAgICBpZiAoaXNSZWNvZ25pdGlvbkV4Y2VwdGlvbihlKSAmJiBlLnBhcnRpYWxDc3RSZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5jc3RQb3N0Tm9uVGVybWluYWwoZS5wYXJ0aWFsQ3N0UmVzdWx0LCBvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5MQUJFTCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLkxBQkVMXG4gICAgICAgICAgICAgICAgOiBydWxlTmFtZSk7XG4gICAgICAgICAgICBkZWxldGUgZS5wYXJ0aWFsQ3N0UmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgfVxuICAgIGNvbnN1bWVJbnRlcm5hbCh0b2tUeXBlLCBpZHgsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGNvbnN1bWVkVG9rZW47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBuZXh0VG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICAgICAgaWYgKHRoaXMudG9rZW5NYXRjaGVyKG5leHRUb2tlbiwgdG9rVHlwZSkgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVUb2tlbigpO1xuICAgICAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSBuZXh0VG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN1bWVJbnRlcm5hbEVycm9yKHRva1R5cGUsIG5leHRUb2tlbiwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVGcm9tQ29uc3VtcHRpb24pIHtcbiAgICAgICAgICAgIGNvbnN1bWVkVG9rZW4gPSB0aGlzLmNvbnN1bWVJbnRlcm5hbFJlY292ZXJ5KHRva1R5cGUsIGlkeCwgZUZyb21Db25zdW1wdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jc3RQb3N0VGVybWluYWwob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIG9wdGlvbnMuTEFCRUwgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBvcHRpb25zLkxBQkVMXG4gICAgICAgICAgICA6IHRva1R5cGUubmFtZSwgY29uc3VtZWRUb2tlbik7XG4gICAgICAgIHJldHVybiBjb25zdW1lZFRva2VuO1xuICAgIH1cbiAgICBjb25zdW1lSW50ZXJuYWxFcnJvcih0b2tUeXBlLCBuZXh0VG9rZW4sIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IG1zZztcbiAgICAgICAgY29uc3QgcHJldmlvdXNUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIGlmIChvcHRpb25zICE9PSB1bmRlZmluZWQgJiYgb3B0aW9ucy5FUlJfTVNHKSB7XG4gICAgICAgICAgICBtc2cgPSBvcHRpb25zLkVSUl9NU0c7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtc2cgPSB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkOiB0b2tUeXBlLFxuICAgICAgICAgICAgICAgIGFjdHVhbDogbmV4dFRva2VuLFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBwcmV2aW91c1Rva2VuLFxuICAgICAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLmdldEN1cnJSdWxlRnVsbE5hbWUoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IHRoaXMuU0FWRV9FUlJPUihuZXcgTWlzbWF0Y2hlZFRva2VuRXhjZXB0aW9uKG1zZywgbmV4dFRva2VuLCBwcmV2aW91c1Rva2VuKSk7XG4gICAgfVxuICAgIGNvbnN1bWVJbnRlcm5hbFJlY292ZXJ5KHRva1R5cGUsIGlkeCwgZUZyb21Db25zdW1wdGlvbikge1xuICAgICAgICAvLyBubyByZWNvdmVyeSBhbGxvd2VkIGR1cmluZyBiYWNrdHJhY2tpbmcsIG90aGVyd2lzZSBiYWNrdHJhY2tpbmcgbWF5IHJlY292ZXIgaW52YWxpZCBzeW50YXggYW5kIGFjY2VwdCBpdFxuICAgICAgICAvLyBidXQgdGhlIG9yaWdpbmFsIHN5bnRheCBjb3VsZCBoYXZlIGJlZW4gcGFyc2VkIHN1Y2Nlc3NmdWxseSB3aXRob3V0IGFueSBiYWNrdHJhY2tpbmcgKyByZWNvdmVyeVxuICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQgJiZcbiAgICAgICAgICAgIC8vIFRPRE86IG1vcmUgcm9idXN0IGNoZWNraW5nIG9mIHRoZSBleGNlcHRpb24gdHlwZS4gUGVyaGFwcyBUeXBlc2NyaXB0IGV4dGVuZGluZyBleHByZXNzaW9ucz9cbiAgICAgICAgICAgIGVGcm9tQ29uc3VtcHRpb24ubmFtZSA9PT0gXCJNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb25cIiAmJlxuICAgICAgICAgICAgIXRoaXMuaXNCYWNrVHJhY2tpbmcoKSkge1xuICAgICAgICAgICAgY29uc3QgZm9sbG93cyA9IHRoaXMuZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHRva1R5cGUsIGlkeCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyeUluUnVsZVJlY292ZXJ5KHRva1R5cGUsIGZvbGxvd3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVGcm9tSW5SdWxlUmVjb3ZlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoZUZyb21JblJ1bGVSZWNvdmVyeS5uYW1lID09PSBJTl9SVUxFX1JFQ09WRVJZX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICAvLyBmYWlsZWQgaW4gUnVsZVJlY292ZXJ5LlxuICAgICAgICAgICAgICAgICAgICAvLyB0aHJvdyB0aGUgb3JpZ2luYWwgZXJyb3IgaW4gb3JkZXIgdG8gdHJpZ2dlciByZVN5bmMgZXJyb3IgcmVjb3ZlcnlcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZUZyb21Db25zdW1wdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVGcm9tSW5SdWxlUmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgZUZyb21Db25zdW1wdGlvbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzYXZlUmVjb2dTdGF0ZSgpIHtcbiAgICAgICAgLy8gZXJyb3JzIGlzIGEgZ2V0dGVyIHdoaWNoIHdpbGwgY2xvbmUgdGhlIGVycm9ycyBhcnJheVxuICAgICAgICBjb25zdCBzYXZlZEVycm9ycyA9IHRoaXMuZXJyb3JzO1xuICAgICAgICBjb25zdCBzYXZlZFJ1bGVTdGFjayA9IGNsb25lKHRoaXMuUlVMRV9TVEFDSyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcnM6IHNhdmVkRXJyb3JzLFxuICAgICAgICAgICAgbGV4ZXJTdGF0ZTogdGhpcy5leHBvcnRMZXhlclN0YXRlKCksXG4gICAgICAgICAgICBSVUxFX1NUQUNLOiBzYXZlZFJ1bGVTdGFjayxcbiAgICAgICAgICAgIENTVF9TVEFDSzogdGhpcy5DU1RfU1RBQ0ssXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbG9hZFJlY29nU3RhdGUobmV3U3RhdGUpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMgPSBuZXdTdGF0ZS5lcnJvcnM7XG4gICAgICAgIHRoaXMuaW1wb3J0TGV4ZXJTdGF0ZShuZXdTdGF0ZS5sZXhlclN0YXRlKTtcbiAgICAgICAgdGhpcy5SVUxFX1NUQUNLID0gbmV3U3RhdGUuUlVMRV9TVEFDSztcbiAgICB9XG4gICAgcnVsZUludm9jYXRpb25TdGF0ZVVwZGF0ZShzaG9ydE5hbWUsIGZ1bGxOYW1lLCBpZHhJbkNhbGxpbmdSdWxlKSB7XG4gICAgICAgIHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLLnB1c2goaWR4SW5DYWxsaW5nUnVsZSk7XG4gICAgICAgIHRoaXMuUlVMRV9TVEFDSy5wdXNoKHNob3J0TmFtZSk7XG4gICAgICAgIC8vIE5PT1Agd2hlbiBjc3QgaXMgZGlzYWJsZWRcbiAgICAgICAgdGhpcy5jc3RJbnZvY2F0aW9uU3RhdGVVcGRhdGUoZnVsbE5hbWUpO1xuICAgIH1cbiAgICBpc0JhY2tUcmFja2luZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjay5sZW5ndGggIT09IDA7XG4gICAgfVxuICAgIGdldEN1cnJSdWxlRnVsbE5hbWUoKSB7XG4gICAgICAgIGNvbnN0IHNob3J0TmFtZSA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3Nob3J0TmFtZV07XG4gICAgfVxuICAgIHNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHNob3J0TmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsW3Nob3J0TmFtZV07XG4gICAgfVxuICAgIGlzQXRFbmRPZklucHV0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgRU9GKTtcbiAgICB9XG4gICAgcmVzZXQoKSB7XG4gICAgICAgIHRoaXMucmVzZXRMZXhlclN0YXRlKCk7XG4gICAgICAgIHRoaXMuc3VicnVsZUlkeCA9IDA7XG4gICAgICAgIHRoaXMuaXNCYWNrVHJhY2tpbmdTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfU1RBQ0sgPSBbXTtcbiAgICAgICAgLy8gVE9ETzogZXh0cmFjdCBhIHNwZWNpZmljIHJlc2V0IGZvciBUcmVlQnVpbGRlciB0cmFpdFxuICAgICAgICB0aGlzLkNTVF9TVEFDSyA9IFtdO1xuICAgICAgICB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSyA9IFtdO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY29nbml6ZXJfZW5naW5lLmpzLm1hcCIsImltcG9ydCB7IGNyZWF0ZVRva2VuSW5zdGFuY2UsIEVPRiwgdG9rZW5NYXRjaGVyLCB9IGZyb20gXCIuLi8uLi8uLi9zY2FuL3Rva2Vuc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IGNsb25lLCBkcm9wUmlnaHQsIGZpbmQsIGZsYXR0ZW4sIGhhcywgaW5jbHVkZXMsIGlzRW1wdHksIG1hcCwgfSBmcm9tIFwibG9kYXNoLWVzXCI7XG5pbXBvcnQgeyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24gfSBmcm9tIFwiLi4vLi4vZXhjZXB0aW9uc19wdWJsaWMuanNcIjtcbmltcG9ydCB7IElOIH0gZnJvbSBcIi4uLy4uL2NvbnN0YW50cy5qc1wiO1xuaW1wb3J0IHsgREVGQVVMVF9QQVJTRVJfQ09ORklHIH0gZnJvbSBcIi4uL3BhcnNlci5qc1wiO1xuZXhwb3J0IGNvbnN0IEVPRl9GT0xMT1dfS0VZID0ge307XG5leHBvcnQgY29uc3QgSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT04gPSBcIkluUnVsZVJlY292ZXJ5RXhjZXB0aW9uXCI7XG5leHBvcnQgY2xhc3MgSW5SdWxlUmVjb3ZlcnlFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gSU5fUlVMRV9SRUNPVkVSWV9FWENFUFRJT047XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIHRyYWl0IGlzIHJlc3BvbnNpYmxlIGZvciB0aGUgZXJyb3IgcmVjb3ZlcnkgYW5kIGZhdWx0IHRvbGVyYW50IGxvZ2ljXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWNvdmVyYWJsZSB7XG4gICAgaW5pdFJlY292ZXJhYmxlKGNvbmZpZykge1xuICAgICAgICB0aGlzLmZpcnN0QWZ0ZXJSZXBNYXAgPSB7fTtcbiAgICAgICAgdGhpcy5yZXN5bmNGb2xsb3dzID0ge307XG4gICAgICAgIHRoaXMucmVjb3ZlcnlFbmFibGVkID0gaGFzKGNvbmZpZywgXCJyZWNvdmVyeUVuYWJsZWRcIilcbiAgICAgICAgICAgID8gY29uZmlnLnJlY292ZXJ5RW5hYmxlZCAvLyBhc3N1bWVzIGVuZCB1c2VyIHByb3ZpZGVzIHRoZSBjb3JyZWN0IGNvbmZpZyB2YWx1ZS90eXBlXG4gICAgICAgICAgICA6IERFRkFVTFRfUEFSU0VSX0NPTkZJRy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIC8vIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgTk9PUCB3aWxsIGJlIGlubGluZWQgd2hpY2hcbiAgICAgICAgLy8gZWZmZWN0aXZlbHkgbWVhbnMgdGhhdCB0aGlzIG9wdGlvbmFsIGZlYXR1cmUgZG9lcyBub3QgZXhpc3RcbiAgICAgICAgLy8gd2hlbiBub3QgdXNlZC5cbiAgICAgICAgaWYgKHRoaXMucmVjb3ZlcnlFbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeSA9IGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRUb2tlblRvSW5zZXJ0KHRva1R5cGUpIHtcbiAgICAgICAgY29uc3QgdG9rVG9JbnNlcnQgPSBjcmVhdGVUb2tlbkluc3RhbmNlKHRva1R5cGUsIFwiXCIsIE5hTiwgTmFOLCBOYU4sIE5hTiwgTmFOLCBOYU4pO1xuICAgICAgICB0b2tUb0luc2VydC5pc0luc2VydGVkSW5SZWNvdmVyeSA9IHRydWU7XG4gICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICB9XG4gICAgY2FuVG9rZW5UeXBlQmVJbnNlcnRlZEluUmVjb3ZlcnkodG9rVHlwZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2FuVG9rZW5UeXBlQmVEZWxldGVkSW5SZWNvdmVyeSh0b2tUeXBlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0cnlJblJlcGV0aXRpb25SZWNvdmVyeShncmFtbWFyUnVsZSwgZ3JhbW1hclJ1bGVBcmdzLCBsb29rQWhlYWRGdW5jLCBleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgLy8gVE9ETzogY2FuIHRoZSByZXN5bmNUb2tlblR5cGUgYmUgY2FjaGVkP1xuICAgICAgICBjb25zdCByZVN5bmNUb2tUeXBlID0gdGhpcy5maW5kUmVTeW5jVG9rZW5UeXBlKCk7XG4gICAgICAgIGNvbnN0IHNhdmVkTGV4ZXJTdGF0ZSA9IHRoaXMuZXhwb3J0TGV4ZXJTdGF0ZSgpO1xuICAgICAgICBjb25zdCByZXN5bmNlZFRva2VucyA9IFtdO1xuICAgICAgICBsZXQgcGFzc2VkUmVzeW5jUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuV2l0aG91dFJlc3luYyA9IHRoaXMuTEEoMSk7XG4gICAgICAgIGxldCBjdXJyVG9rZW4gPSB0aGlzLkxBKDEpO1xuICAgICAgICBjb25zdCBnZW5lcmF0ZUVycm9yTWVzc2FnZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVG9rZW4gPSB0aGlzLkxBKDApO1xuICAgICAgICAgICAgLy8gd2UgYXJlIHByZWVtcHRpdmVseSByZS1zeW5jaW5nIGJlZm9yZSBhbiBlcnJvciBoYXMgYmVlbiBkZXRlY3RlZCwgdGhlcmVmb3Igd2UgbXVzdCByZXByb2R1Y2VcbiAgICAgICAgICAgIC8vIHRoZSBlcnJvciB0aGF0IHdvdWxkIGhhdmUgYmVlbiB0aHJvd25cbiAgICAgICAgICAgIGNvbnN0IG1zZyA9IHRoaXMuZXJyb3JNZXNzYWdlUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZSh7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQ6IGV4cGVjdGVkVG9rVHlwZSxcbiAgICAgICAgICAgICAgICBhY3R1YWw6IG5leHRUb2tlbldpdGhvdXRSZXN5bmMsXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IHByZXZpb3VzVG9rZW4sXG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuZ2V0Q3VyclJ1bGVGdWxsTmFtZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBNaXNtYXRjaGVkVG9rZW5FeGNlcHRpb24obXNnLCBuZXh0VG9rZW5XaXRob3V0UmVzeW5jLCB0aGlzLkxBKDApKTtcbiAgICAgICAgICAgIC8vIHRoZSBmaXJzdCB0b2tlbiBoZXJlIHdpbGwgYmUgdGhlIG9yaWdpbmFsIGNhdXNlIG9mIHRoZSBlcnJvciwgdGhpcyBpcyBub3QgcGFydCBvZiB0aGUgcmVzeW5jZWRUb2tlbnMgcHJvcGVydHkuXG4gICAgICAgICAgICBlcnJvci5yZXN5bmNlZFRva2VucyA9IGRyb3BSaWdodChyZXN5bmNlZFRva2Vucyk7XG4gICAgICAgICAgICB0aGlzLlNBVkVfRVJST1IoZXJyb3IpO1xuICAgICAgICB9O1xuICAgICAgICB3aGlsZSAoIXBhc3NlZFJlc3luY1BvaW50KSB7XG4gICAgICAgICAgICAvLyByZS1zeW5jZWQgdG8gYSBwb2ludCB3aGVyZSB3ZSBjYW4gc2FmZWx5IGV4aXQgdGhlIHJlcGV0aXRpb24vXG4gICAgICAgICAgICBpZiAodGhpcy50b2tlbk1hdGNoZXIoY3VyclRva2VuLCBleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgZ2VuZXJhdGVFcnJvck1lc3NhZ2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIG11c3QgcmV0dXJuIGhlcmUgdG8gYXZvaWQgcmV2ZXJ0aW5nIHRoZSBpbnB1dElkeFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobG9va0FoZWFkRnVuYy5jYWxsKHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgLy8gd2Ugc2tpcHBlZCBlbm91Z2ggdG9rZW5zIHNvIHdlIGNhbiByZXN5bmMgcmlnaHQgYmFjayBpbnRvIGFub3RoZXIgaXRlcmF0aW9uIG9mIHRoZSByZXBldGl0aW9uIGdyYW1tYXIgcnVsZVxuICAgICAgICAgICAgICAgIGdlbmVyYXRlRXJyb3JNZXNzYWdlKCk7XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlIGludm9jYXRpb24gaW4gb3RoZXIgdG8gc3VwcG9ydCBtdWx0aXBsZSByZS1zeW5jcyBpbiB0aGUgc2FtZSB0b3AgbGV2ZWwgcmVwZXRpdGlvbiBncmFtbWFyIHJ1bGVcbiAgICAgICAgICAgICAgICBncmFtbWFyUnVsZS5hcHBseSh0aGlzLCBncmFtbWFyUnVsZUFyZ3MpO1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gbXVzdCByZXR1cm4gaGVyZSB0byBhdm9pZCByZXZlcnRpbmcgdGhlIGlucHV0SWR4XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLnRva2VuTWF0Y2hlcihjdXJyVG9rZW4sIHJlU3luY1Rva1R5cGUpKSB7XG4gICAgICAgICAgICAgICAgcGFzc2VkUmVzeW5jUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY3VyclRva2VuID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGRUb1Jlc3luY1Rva2VucyhjdXJyVG9rZW4sIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB3ZSB3ZXJlIHVuYWJsZSB0byBmaW5kIGEgQ0xPU0VSIHBvaW50IHRvIHJlc3luYyBpbnNpZGUgdGhlIFJlcGV0aXRpb24sIHJlc2V0IHRoZSBzdGF0ZS5cbiAgICAgICAgLy8gVGhlIHBhcnNpbmcgZXhjZXB0aW9uIHdlIHdlcmUgdHJ5aW5nIHRvIHByZXZlbnQgd2lsbCBoYXBwZW4gaW4gdGhlIE5FWFQgcGFyc2luZyBzdGVwLiBpdCBtYXkgYmUgaGFuZGxlZCBieVxuICAgICAgICAvLyBcImJldHdlZW4gcnVsZXNcIiByZXN5bmMgcmVjb3ZlcnkgbGF0ZXIgaW4gdGhlIGZsb3cuXG4gICAgICAgIHRoaXMuaW1wb3J0TGV4ZXJTdGF0ZShzYXZlZExleGVyU3RhdGUpO1xuICAgIH1cbiAgICBzaG91bGRJblJlcGV0aXRpb25SZWNvdmVyeUJlVHJpZWQoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgsIG5vdFN0dWNrKSB7XG4gICAgICAgIC8vIEVkZ2UgY2FzZSBvZiBhcnJpdmluZyBmcm9tIGEgTUFOWSByZXBldGl0aW9uIHdoaWNoIGlzIHN0dWNrXG4gICAgICAgIC8vIEF0dGVtcHRpbmcgcmVjb3ZlcnkgaW4gdGhpcyBjYXNlIGNvdWxkIGNhdXNlIGFuIGluZmluaXRlIGxvb3BcbiAgICAgICAgaWYgKG5vdFN0dWNrID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gcmVjb3ZlciwgbmV4dCB0b2tlbiBpcyB3aGF0IHdlIGV4cGVjdC4uLlxuICAgICAgICBpZiAodGhpcy50b2tlbk1hdGNoZXIodGhpcy5MQSgxKSwgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXJyb3IgcmVjb3ZlcnkgaXMgZGlzYWJsZWQgZHVyaW5nIGJhY2t0cmFja2luZyBhcyBpdCBjYW4gbWFrZSB0aGUgcGFyc2VyIGlnbm9yZSBhIHZhbGlkIGdyYW1tYXIgcGF0aFxuICAgICAgICAvLyBhbmQgcHJlZmVyIHNvbWUgYmFja3RyYWNraW5nIHBhdGggdGhhdCBpbmNsdWRlcyByZWNvdmVyZWQgZXJyb3JzLlxuICAgICAgICBpZiAodGhpcy5pc0JhY2tUcmFja2luZygpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgY2FuIHBlcmZvcm0gaW5SdWxlIHJlY292ZXJ5IChzaW5nbGUgdG9rZW4gaW5zZXJ0aW9uIG9yIGRlbGV0aW9uKSB3ZSBhbHdheXMgcHJlZmVyIHRoYXQgcmVjb3ZlcnkgYWxnb3JpdGhtXG4gICAgICAgIC8vIGJlY2F1c2UgaWYgaXQgd29ya3MsIGl0IG1ha2VzIHRoZSBsZWFzdCBhbW91bnQgb2YgY2hhbmdlcyB0byB0aGUgaW5wdXQgc3RyZWFtIChncmVlZHkgYWxnb3JpdGhtKVxuICAgICAgICAvL25vaW5zcGVjdGlvbiBSZWR1bmRhbnRJZlN0YXRlbWVudEpTXG4gICAgICAgIGlmICh0aGlzLmNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeShleHBlY3RUb2tBZnRlckxhc3RNYXRjaCwgdGhpcy5nZXRGb2xsb3dzRm9ySW5SdWxlUmVjb3ZlcnkoZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gsIG5leHRUb2tJZHgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBFcnJvciBSZWNvdmVyeSBmdW5jdGlvbmFsaXR5XG4gICAgZ2V0Rm9sbG93c0ZvckluUnVsZVJlY292ZXJ5KHRva1R5cGUsIHRva0lkeEluUnVsZSkge1xuICAgICAgICBjb25zdCBncmFtbWFyUGF0aCA9IHRoaXMuZ2V0Q3VycmVudEdyYW1tYXJQYXRoKHRva1R5cGUsIHRva0lkeEluUnVsZSk7XG4gICAgICAgIGNvbnN0IGZvbGxvd3MgPSB0aGlzLmdldE5leHRQb3NzaWJsZVRva2VuVHlwZXMoZ3JhbW1hclBhdGgpO1xuICAgICAgICByZXR1cm4gZm9sbG93cztcbiAgICB9XG4gICAgdHJ5SW5SdWxlUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSB7XG4gICAgICAgIGlmICh0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSkge1xuICAgICAgICAgICAgY29uc3QgdG9rVG9JbnNlcnQgPSB0aGlzLmdldFRva2VuVG9JbnNlcnQoZXhwZWN0ZWRUb2tUeXBlKTtcbiAgICAgICAgICAgIHJldHVybiB0b2tUb0luc2VydDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuRGVsZXRpb24oZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRvayA9IHRoaXMuU0tJUF9UT0tFTigpO1xuICAgICAgICAgICAgdGhpcy5jb25zdW1lVG9rZW4oKTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0VG9rO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBJblJ1bGVSZWNvdmVyeUV4Y2VwdGlvbihcInNhZCBzYWQgcGFuZGFcIik7XG4gICAgfVxuICAgIGNhblBlcmZvcm1JblJ1bGVSZWNvdmVyeShleHBlY3RlZFRva2VuLCBmb2xsb3dzKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jYW5SZWNvdmVyV2l0aFNpbmdsZVRva2VuSW5zZXJ0aW9uKGV4cGVjdGVkVG9rZW4sIGZvbGxvd3MpIHx8XG4gICAgICAgICAgICB0aGlzLmNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva2VuKSk7XG4gICAgfVxuICAgIGNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5JbnNlcnRpb24oZXhwZWN0ZWRUb2tUeXBlLCBmb2xsb3dzKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5Ub2tlblR5cGVCZUluc2VydGVkSW5SZWNvdmVyeShleHBlY3RlZFRva1R5cGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbXVzdCBrbm93IHRoZSBwb3NzaWJsZSBmb2xsb3dpbmcgdG9rZW5zIHRvIHBlcmZvcm0gc2luZ2xlIHRva2VuIGluc2VydGlvblxuICAgICAgICBpZiAoaXNFbXB0eShmb2xsb3dzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1pc21hdGNoZWRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICBjb25zdCBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3MgPSBmaW5kKGZvbGxvd3MsIChwb3NzaWJsZUZvbGxvd3NUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbk1hdGNoZXIobWlzbWF0Y2hlZFRvaywgcG9zc2libGVGb2xsb3dzVG9rVHlwZSk7XG4gICAgICAgIH0pICE9PSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiBpc01pc01hdGNoZWRUb2tJbkZvbGxvd3M7XG4gICAgfVxuICAgIGNhblJlY292ZXJXaXRoU2luZ2xlVG9rZW5EZWxldGlvbihleHBlY3RlZFRva1R5cGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblRva2VuVHlwZUJlRGVsZXRlZEluUmVjb3ZlcnkoZXhwZWN0ZWRUb2tUeXBlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTmV4dFRva2VuV2hhdElzRXhwZWN0ZWQgPSB0aGlzLnRva2VuTWF0Y2hlcih0aGlzLkxBKDIpLCBleHBlY3RlZFRva1R5cGUpO1xuICAgICAgICByZXR1cm4gaXNOZXh0VG9rZW5XaGF0SXNFeHBlY3RlZDtcbiAgICB9XG4gICAgaXNJbkN1cnJlbnRSdWxlUmVTeW5jU2V0KHRva2VuVHlwZUlkeCkge1xuICAgICAgICBjb25zdCBmb2xsb3dLZXkgPSB0aGlzLmdldEN1cnJGb2xsb3dLZXkoKTtcbiAgICAgICAgY29uc3QgY3VycmVudFJ1bGVSZVN5bmNTZXQgPSB0aGlzLmdldEZvbGxvd1NldEZyb21Gb2xsb3dLZXkoZm9sbG93S2V5KTtcbiAgICAgICAgcmV0dXJuIGluY2x1ZGVzKGN1cnJlbnRSdWxlUmVTeW5jU2V0LCB0b2tlblR5cGVJZHgpO1xuICAgIH1cbiAgICBmaW5kUmVTeW5jVG9rZW5UeXBlKCkge1xuICAgICAgICBjb25zdCBhbGxQb3NzaWJsZVJlU3luY1Rva1R5cGVzID0gdGhpcy5mbGF0dGVuRm9sbG93U2V0KCk7XG4gICAgICAgIC8vIHRoaXMgbG9vcCB3aWxsIGFsd2F5cyB0ZXJtaW5hdGUgYXMgRU9GIGlzIGFsd2F5cyBpbiB0aGUgZm9sbG93IHN0YWNrIGFuZCBhbHNvIGFsd2F5cyAodmlydHVhbGx5KSBpbiB0aGUgaW5wdXRcbiAgICAgICAgbGV0IG5leHRUb2tlbiA9IHRoaXMuTEEoMSk7XG4gICAgICAgIGxldCBrID0gMjtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvdW5kTWF0Y2ggPSBmaW5kKGFsbFBvc3NpYmxlUmVTeW5jVG9rVHlwZXMsIChyZXN5bmNUb2tUeXBlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuTWF0Y2ggPSB0b2tlbk1hdGNoZXIobmV4dFRva2VuLCByZXN5bmNUb2tUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FuTWF0Y2g7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChmb3VuZE1hdGNoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm91bmRNYXRjaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHRUb2tlbiA9IHRoaXMuTEEoayk7XG4gICAgICAgICAgICBrKys7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0Q3VyckZvbGxvd0tleSgpIHtcbiAgICAgICAgLy8gdGhlIGxlbmd0aCBpcyBhdCBsZWFzdCBvbmUgYXMgd2UgYWx3YXlzIGFkZCB0aGUgcnVsZU5hbWUgdG8gdGhlIHN0YWNrIGJlZm9yZSBpbnZva2luZyB0aGUgcnVsZS5cbiAgICAgICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBFT0ZfRk9MTE9XX0tFWTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyUnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZVNob3J0TmFtZSgpO1xuICAgICAgICBjb25zdCBjdXJyUnVsZUlkeCA9IHRoaXMuZ2V0TGFzdEV4cGxpY2l0UnVsZU9jY3VycmVuY2VJbmRleCgpO1xuICAgICAgICBjb25zdCBwcmV2UnVsZVNob3J0TmFtZSA9IHRoaXMuZ2V0UHJldmlvdXNFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJ1bGVOYW1lOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGN1cnJSdWxlU2hvcnROYW1lKSxcbiAgICAgICAgICAgIGlkeEluQ2FsbGluZ1J1bGU6IGN1cnJSdWxlSWR4LFxuICAgICAgICAgICAgaW5SdWxlOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKHByZXZSdWxlU2hvcnROYW1lKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYnVpbGRGdWxsRm9sbG93S2V5U3RhY2soKSB7XG4gICAgICAgIGNvbnN0IGV4cGxpY2l0UnVsZVN0YWNrID0gdGhpcy5SVUxFX1NUQUNLO1xuICAgICAgICBjb25zdCBleHBsaWNpdE9jY3VycmVuY2VTdGFjayA9IHRoaXMuUlVMRV9PQ0NVUlJFTkNFX1NUQUNLO1xuICAgICAgICByZXR1cm4gbWFwKGV4cGxpY2l0UnVsZVN0YWNrLCAocnVsZU5hbWUsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBFT0ZfRk9MTE9XX0tFWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcnVsZU5hbWU6IHRoaXMuc2hvcnRSdWxlTmFtZVRvRnVsbE5hbWUocnVsZU5hbWUpLFxuICAgICAgICAgICAgICAgIGlkeEluQ2FsbGluZ1J1bGU6IGV4cGxpY2l0T2NjdXJyZW5jZVN0YWNrW2lkeF0sXG4gICAgICAgICAgICAgICAgaW5SdWxlOiB0aGlzLnNob3J0UnVsZU5hbWVUb0Z1bGxOYW1lKGV4cGxpY2l0UnVsZVN0YWNrW2lkeCAtIDFdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmbGF0dGVuRm9sbG93U2V0KCkge1xuICAgICAgICBjb25zdCBmb2xsb3dTdGFjayA9IG1hcCh0aGlzLmJ1aWxkRnVsbEZvbGxvd0tleVN0YWNrKCksIChjdXJyS2V5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGN1cnJLZXkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW4oZm9sbG93U3RhY2spO1xuICAgIH1cbiAgICBnZXRGb2xsb3dTZXRGcm9tRm9sbG93S2V5KGZvbGxvd0tleSkge1xuICAgICAgICBpZiAoZm9sbG93S2V5ID09PSBFT0ZfRk9MTE9XX0tFWSkge1xuICAgICAgICAgICAgcmV0dXJuIFtFT0ZdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvbGxvd05hbWUgPSBmb2xsb3dLZXkucnVsZU5hbWUgKyBmb2xsb3dLZXkuaWR4SW5DYWxsaW5nUnVsZSArIElOICsgZm9sbG93S2V5LmluUnVsZTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzeW5jRm9sbG93c1tmb2xsb3dOYW1lXTtcbiAgICB9XG4gICAgLy8gSXQgZG9lcyBub3QgbWFrZSBhbnkgc2Vuc2UgdG8gaW5jbHVkZSBhIHZpcnR1YWwgRU9GIHRva2VuIGluIHRoZSBsaXN0IG9mIHJlc3luY2VkIHRva2Vuc1xuICAgIC8vIGFzIEVPRiBkb2VzIG5vdCByZWFsbHkgZXhpc3QgYW5kIHRodXMgZG9lcyBub3QgY29udGFpbiBhbnkgdXNlZnVsIGluZm9ybWF0aW9uIChsaW5lL2NvbHVtbiBudW1iZXJzKVxuICAgIGFkZFRvUmVzeW5jVG9rZW5zKHRva2VuLCByZXN5bmNUb2tlbnMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRva2VuTWF0Y2hlcih0b2tlbiwgRU9GKSkge1xuICAgICAgICAgICAgcmVzeW5jVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN5bmNUb2tlbnM7XG4gICAgfVxuICAgIHJlU3luY1RvKHRva1R5cGUpIHtcbiAgICAgICAgY29uc3QgcmVzeW5jZWRUb2tlbnMgPSBbXTtcbiAgICAgICAgbGV0IG5leHRUb2sgPSB0aGlzLkxBKDEpO1xuICAgICAgICB3aGlsZSAodGhpcy50b2tlbk1hdGNoZXIobmV4dFRvaywgdG9rVHlwZSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICBuZXh0VG9rID0gdGhpcy5TS0lQX1RPS0VOKCk7XG4gICAgICAgICAgICB0aGlzLmFkZFRvUmVzeW5jVG9rZW5zKG5leHRUb2ssIHJlc3luY2VkVG9rZW5zKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0aGUgbGFzdCB0b2tlbiBpcyBub3QgcGFydCBvZiB0aGUgZXJyb3IuXG4gICAgICAgIHJldHVybiBkcm9wUmlnaHQocmVzeW5jZWRUb2tlbnMpO1xuICAgIH1cbiAgICBhdHRlbXB0SW5SZXBldGl0aW9uUmVjb3ZlcnkocHJvZEZ1bmMsIGFyZ3MsIGxvb2thaGVhZEZ1bmMsIGRzbE1ldGhvZElkeCwgcHJvZE9jY3VycmVuY2UsIG5leHRUb2tzV2Fsa2VyLCBub3RTdHVjaykge1xuICAgICAgICAvLyBieSBkZWZhdWx0IHRoaXMgaXMgYSBOTy1PUFxuICAgICAgICAvLyBUaGUgYWN0dWFsIGltcGxlbWVudGF0aW9uIGlzIHdpdGggdGhlIGZ1bmN0aW9uKG5vdCBtZXRob2QpIGJlbG93XG4gICAgfVxuICAgIGdldEN1cnJlbnRHcmFtbWFyUGF0aCh0b2tUeXBlLCB0b2tJZHhJblJ1bGUpIHtcbiAgICAgICAgY29uc3QgcGF0aFJ1bGVTdGFjayA9IHRoaXMuZ2V0SHVtYW5SZWFkYWJsZVJ1bGVTdGFjaygpO1xuICAgICAgICBjb25zdCBwYXRoT2NjdXJyZW5jZVN0YWNrID0gY2xvbmUodGhpcy5SVUxFX09DQ1VSUkVOQ0VfU1RBQ0spO1xuICAgICAgICBjb25zdCBncmFtbWFyUGF0aCA9IHtcbiAgICAgICAgICAgIHJ1bGVTdGFjazogcGF0aFJ1bGVTdGFjayxcbiAgICAgICAgICAgIG9jY3VycmVuY2VTdGFjazogcGF0aE9jY3VycmVuY2VTdGFjayxcbiAgICAgICAgICAgIGxhc3RUb2s6IHRva1R5cGUsXG4gICAgICAgICAgICBsYXN0VG9rT2NjdXJyZW5jZTogdG9rSWR4SW5SdWxlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gZ3JhbW1hclBhdGg7XG4gICAgfVxuICAgIGdldEh1bWFuUmVhZGFibGVSdWxlU3RhY2soKSB7XG4gICAgICAgIHJldHVybiBtYXAodGhpcy5SVUxFX1NUQUNLLCAoY3VyclNob3J0TmFtZSkgPT4gdGhpcy5zaG9ydFJ1bGVOYW1lVG9GdWxsTmFtZShjdXJyU2hvcnROYW1lKSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGF0dGVtcHRJblJlcGV0aXRpb25SZWNvdmVyeShwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSwgbmV4dFRva3NXYWxrZXIsIG5vdFN0dWNrKSB7XG4gICAgY29uc3Qga2V5ID0gdGhpcy5nZXRLZXlGb3JBdXRvbWF0aWNMb29rYWhlYWQoZHNsTWV0aG9kSWR4LCBwcm9kT2NjdXJyZW5jZSk7XG4gICAgbGV0IGZpcnN0QWZ0ZXJSZXBJbmZvID0gdGhpcy5maXJzdEFmdGVyUmVwTWFwW2tleV07XG4gICAgaWYgKGZpcnN0QWZ0ZXJSZXBJbmZvID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgY3VyclJ1bGVOYW1lID0gdGhpcy5nZXRDdXJyUnVsZUZ1bGxOYW1lKCk7XG4gICAgICAgIGNvbnN0IHJ1bGVHcmFtbWFyID0gdGhpcy5nZXRHQXN0UHJvZHVjdGlvbnMoKVtjdXJyUnVsZU5hbWVdO1xuICAgICAgICBjb25zdCB3YWxrZXIgPSBuZXcgbmV4dFRva3NXYWxrZXIocnVsZUdyYW1tYXIsIHByb2RPY2N1cnJlbmNlKTtcbiAgICAgICAgZmlyc3RBZnRlclJlcEluZm8gPSB3YWxrZXIuc3RhcnRXYWxraW5nKCk7XG4gICAgICAgIHRoaXMuZmlyc3RBZnRlclJlcE1hcFtrZXldID0gZmlyc3RBZnRlclJlcEluZm87XG4gICAgfVxuICAgIGxldCBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IGZpcnN0QWZ0ZXJSZXBJbmZvLnRva2VuO1xuICAgIGxldCBuZXh0VG9rSWR4ID0gZmlyc3RBZnRlclJlcEluZm8ub2NjdXJyZW5jZTtcbiAgICBjb25zdCBpc0VuZE9mUnVsZSA9IGZpcnN0QWZ0ZXJSZXBJbmZvLmlzRW5kT2ZSdWxlO1xuICAgIC8vIHNwZWNpYWwgZWRnZSBjYXNlIG9mIGEgVE9QIG1vc3QgcmVwZXRpdGlvbiBhZnRlciB3aGljaCB0aGUgaW5wdXQgc2hvdWxkIEVORC5cbiAgICAvLyB0aGlzIHdpbGwgZm9yY2UgYW4gYXR0ZW1wdCBmb3IgaW5SdWxlIHJlY292ZXJ5IGluIHRoYXQgc2NlbmFyaW8uXG4gICAgaWYgKHRoaXMuUlVMRV9TVEFDSy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgaXNFbmRPZlJ1bGUgJiZcbiAgICAgICAgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2ggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBleHBlY3RUb2tBZnRlckxhc3RNYXRjaCA9IEVPRjtcbiAgICAgICAgbmV4dFRva0lkeCA9IDE7XG4gICAgfVxuICAgIC8vIFdlIGRvbid0IGhhdmUgYW55dGhpbmcgdG8gcmUtc3luYyB0by4uLlxuICAgIC8vIHRoaXMgY29uZGl0aW9uIHdhcyBleHRyYWN0ZWQgZnJvbSBgc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkYCB0byBhY3QgYXMgYSB0eXBlLWd1YXJkXG4gICAgaWYgKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoID09PSB1bmRlZmluZWQgfHwgbmV4dFRva0lkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuc2hvdWxkSW5SZXBldGl0aW9uUmVjb3ZlcnlCZVRyaWVkKGV4cGVjdFRva0FmdGVyTGFzdE1hdGNoLCBuZXh0VG9rSWR4LCBub3RTdHVjaykpIHtcbiAgICAgICAgLy8gVE9ETzogcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uOiBpbnN0ZWFkIG9mIHBhc3NpbmcgdGhlIG9yaWdpbmFsIGFyZ3MgaGVyZSwgd2UgbW9kaWZ5XG4gICAgICAgIC8vIHRoZSBhcmdzIHBhcmFtIChvciBjcmVhdGUgYSBuZXcgb25lKSBhbmQgbWFrZSBzdXJlIHRoZSBsb29rYWhlYWQgZnVuYyBpcyBleHBsaWNpdGx5IHByb3ZpZGVkXG4gICAgICAgIC8vIHRvIGF2b2lkIHNlYXJjaGluZyB0aGUgY2FjaGUgZm9yIGl0IG9uY2UgbW9yZS5cbiAgICAgICAgdGhpcy50cnlJblJlcGV0aXRpb25SZWNvdmVyeShwcm9kRnVuYywgYXJncywgbG9va2FoZWFkRnVuYywgZXhwZWN0VG9rQWZ0ZXJMYXN0TWF0Y2gpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlY292ZXJhYmxlLmpzLm1hcCIsImltcG9ydCB7IGFkZE5vbmVUZXJtaW5hbFRvQ3N0LCBhZGRUZXJtaW5hbFRvQ3N0LCBzZXROb2RlTG9jYXRpb25GdWxsLCBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0LCB9IGZyb20gXCIuLi8uLi9jc3QvY3N0LmpzXCI7XG5pbXBvcnQgeyBoYXMsIGlzVW5kZWZpbmVkLCBrZXlzLCBub29wIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgY3JlYXRlQmFzZVNlbWFudGljVmlzaXRvckNvbnN0cnVjdG9yLCBjcmVhdGVCYXNlVmlzaXRvckNvbnN0cnVjdG9yV2l0aERlZmF1bHRzLCB9IGZyb20gXCIuLi8uLi9jc3QvY3N0X3Zpc2l0b3IuanNcIjtcbmltcG9ydCB7IERFRkFVTFRfUEFSU0VSX0NPTkZJRyB9IGZyb20gXCIuLi9wYXJzZXIuanNcIjtcbi8qKlxuICogVGhpcyB0cmFpdCBpcyByZXNwb25zaWJsZSBmb3IgdGhlIENTVCBidWlsZGluZyBsb2dpYy5cbiAqL1xuZXhwb3J0IGNsYXNzIFRyZWVCdWlsZGVyIHtcbiAgICBpbml0VHJlZUJ1aWxkZXIoY29uZmlnKSB7XG4gICAgICAgIHRoaXMuQ1NUX1NUQUNLID0gW107XG4gICAgICAgIC8vIG91dHB1dENzdCBpcyBubyBsb25nZXIgZXhwb3NlZC9kZWZpbmVkIGluIHRoZSBwdWJpYyBBUElcbiAgICAgICAgdGhpcy5vdXRwdXRDc3QgPSBjb25maWcub3V0cHV0Q3N0O1xuICAgICAgICB0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nID0gaGFzKGNvbmZpZywgXCJub2RlTG9jYXRpb25UcmFja2luZ1wiKVxuICAgICAgICAgICAgPyBjb25maWcubm9kZUxvY2F0aW9uVHJhY2tpbmcgLy8gYXNzdW1lcyBlbmQgdXNlciBwcm92aWRlcyB0aGUgY29ycmVjdCBjb25maWcgdmFsdWUvdHlwZVxuICAgICAgICAgICAgOiBERUZBVUxUX1BBUlNFUl9DT05GSUcubm9kZUxvY2F0aW9uVHJhY2tpbmc7XG4gICAgICAgIGlmICghdGhpcy5vdXRwdXRDc3QpIHtcbiAgICAgICAgICAgIHRoaXMuY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0RmluYWxseVN0YXRlVXBkYXRlID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdFRlcm1pbmFsID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdE5vblRlcm1pbmFsID0gbm9vcDtcbiAgICAgICAgICAgIHRoaXMuY3N0UG9zdFJ1bGUgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKC9mdWxsL2kudGVzdCh0aGlzLm5vZGVMb2NhdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlY292ZXJ5RW5hYmxlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IHNldE5vZGVMb2NhdGlvbkZ1bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBzZXROb2RlTG9jYXRpb25GdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uRnVsbFJlY292ZXJ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBub29wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IHRoaXMuY3N0UG9zdFJ1bGVGdWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb24gPSB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25GdWxsUmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvb25seU9mZnNldC9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWNvdmVyeUVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4gPSBzZXROb2RlTG9jYXRpb25Pbmx5T2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ob2RlID0gc2V0Tm9kZUxvY2F0aW9uT25seU9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3Zlcnk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IG5vb3A7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0Tm9kZUxvY2F0aW9uRnJvbU5vZGUgPSBub29wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNzdFBvc3RSdWxlID0gdGhpcy5jc3RQb3N0UnVsZU9ubHlPZmZzZXQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbiA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVndWxhcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgvbm9uZS9pLnRlc3QodGhpcy5ub2RlTG9jYXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldE5vZGVMb2NhdGlvbkZyb21Ub2tlbiA9IG5vb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5jc3RQb3N0UnVsZSA9IG5vb3A7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRJbml0aWFsTm9kZUxvY2F0aW9uID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IEVycm9yKGBJbnZhbGlkIDxub2RlTG9jYXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXCIke2NvbmZpZy5ub2RlTG9jYXRpb25UcmFja2luZ31cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEluaXRpYWxOb2RlTG9jYXRpb25Pbmx5T2Zmc2V0UmVjb3ZlcnkoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IE5hTixcbiAgICAgICAgICAgIGVuZE9mZnNldDogTmFOLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIoY3N0Tm9kZSkge1xuICAgICAgICBjc3ROb2RlLmxvY2F0aW9uID0ge1xuICAgICAgICAgICAgLy8gd2l0aG91dCBlcnJvciByZWNvdmVyeSB0aGUgc3RhcnRpbmcgTG9jYXRpb24gb2YgYSBuZXcgQ3N0Tm9kZSBpcyBndWFyYW50ZWVkXG4gICAgICAgICAgICAvLyBUbyBiZSB0aGUgbmV4dCBUb2tlbidzIHN0YXJ0T2Zmc2V0IChmb3IgdmFsaWQgaW5wdXRzKS5cbiAgICAgICAgICAgIC8vIEZvciBpbnZhbGlkIGlucHV0cyB0aGVyZSB3b24ndCBiZSBhbnkgQ1NUT3V0cHV0IHNvIHRoaXMgcG90ZW50aWFsXG4gICAgICAgICAgICAvLyBpbmFjY3VyYWN5IGRvZXMgbm90IG1hdHRlclxuICAgICAgICAgICAgc3RhcnRPZmZzZXQ6IHRoaXMuTEEoMSkuc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBlbmRPZmZzZXQ6IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWNvdmVyeShjc3ROb2RlKSB7XG4gICAgICAgIGNzdE5vZGUubG9jYXRpb24gPSB7XG4gICAgICAgICAgICBzdGFydE9mZnNldDogTmFOLFxuICAgICAgICAgICAgc3RhcnRMaW5lOiBOYU4sXG4gICAgICAgICAgICBzdGFydENvbHVtbjogTmFOLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBlbmRMaW5lOiBOYU4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICAgKiAgQHNlZSBzZXRJbml0aWFsTm9kZUxvY2F0aW9uT25seU9mZnNldFJlZ3VsYXIgZm9yIGV4cGxhbmF0aW9uIHdoeSB0aGlzIHdvcmtcbiAgXG4gICAgICAgKiBAcGFyYW0gY3N0Tm9kZVxuICAgICAgICovXG4gICAgc2V0SW5pdGlhbE5vZGVMb2NhdGlvbkZ1bGxSZWd1bGFyKGNzdE5vZGUpIHtcbiAgICAgICAgY29uc3QgbmV4dFRva2VuID0gdGhpcy5MQSgxKTtcbiAgICAgICAgY3N0Tm9kZS5sb2NhdGlvbiA9IHtcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0OiBuZXh0VG9rZW4uc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBzdGFydExpbmU6IG5leHRUb2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICBzdGFydENvbHVtbjogbmV4dFRva2VuLnN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBOYU4sXG4gICAgICAgICAgICBlbmRMaW5lOiBOYU4sXG4gICAgICAgICAgICBlbmRDb2x1bW46IE5hTixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3N0SW52b2NhdGlvblN0YXRlVXBkYXRlKGZ1bGxSdWxlTmFtZSkge1xuICAgICAgICBjb25zdCBjc3ROb2RlID0ge1xuICAgICAgICAgICAgbmFtZTogZnVsbFJ1bGVOYW1lLFxuICAgICAgICAgICAgY2hpbGRyZW46IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuc2V0SW5pdGlhbE5vZGVMb2NhdGlvbihjc3ROb2RlKTtcbiAgICAgICAgdGhpcy5DU1RfU1RBQ0sucHVzaChjc3ROb2RlKTtcbiAgICB9XG4gICAgY3N0RmluYWxseVN0YXRlVXBkYXRlKCkge1xuICAgICAgICB0aGlzLkNTVF9TVEFDSy5wb3AoKTtcbiAgICB9XG4gICAgY3N0UG9zdFJ1bGVGdWxsKHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIC8vIGNhc3RzIHRvIGByZXF1aXJlZDxDc3ROb2RlTG9jYXRpb24+YCBhcmUgc2FmZSBiZWNhdXNlIGBjc3RQb3N0UnVsZUZ1bGxgIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBmdWxsIGxvY2F0aW9uIGlzIGVuYWJsZWRcbiAgICAgICAgY29uc3QgcHJldlRva2VuID0gdGhpcy5MQSgwKTtcbiAgICAgICAgY29uc3QgbG9jID0gcnVsZUNzdE5vZGUubG9jYXRpb247XG4gICAgICAgIC8vIElmIHRoaXMgY29uZGl0aW9uIGlzIHRydWUgaXQgbWVhbnMgd2UgY29uc3VtZWQgYXQgbGVhc3Qgb25lIFRva2VuXG4gICAgICAgIC8vIEluIHRoaXMgQ3N0Tm9kZS5cbiAgICAgICAgaWYgKGxvYy5zdGFydE9mZnNldCA8PSBwcmV2VG9rZW4uc3RhcnRPZmZzZXQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGxvYy5lbmRPZmZzZXQgPSBwcmV2VG9rZW4uZW5kT2Zmc2V0O1xuICAgICAgICAgICAgbG9jLmVuZExpbmUgPSBwcmV2VG9rZW4uZW5kTGluZTtcbiAgICAgICAgICAgIGxvYy5lbmRDb2x1bW4gPSBwcmV2VG9rZW4uZW5kQ29sdW1uO1xuICAgICAgICB9XG4gICAgICAgIC8vIFwiZW1wdHlcIiBDc3ROb2RlIGVkZ2UgY2FzZVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvYy5zdGFydE9mZnNldCA9IE5hTjtcbiAgICAgICAgICAgIGxvYy5zdGFydExpbmUgPSBOYU47XG4gICAgICAgICAgICBsb2Muc3RhcnRDb2x1bW4gPSBOYU47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0KHJ1bGVDc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZUb2tlbiA9IHRoaXMuTEEoMCk7XG4gICAgICAgIC8vIGBsb2NhdGlvbicgaXMgbm90IG51bGwgYmVjYXVzZSBgY3N0UG9zdFJ1bGVPbmx5T2Zmc2V0YCB3aWxsIG9ubHkgYmUgaW52b2tlZCB3aGVuIGxvY2F0aW9uIHRyYWNraW5nIGlzIGVuYWJsZWQuXG4gICAgICAgIGNvbnN0IGxvYyA9IHJ1bGVDc3ROb2RlLmxvY2F0aW9uO1xuICAgICAgICAvLyBJZiB0aGlzIGNvbmRpdGlvbiBpcyB0cnVlIGl0IG1lYW5zIHdlIGNvbnN1bWVkIGF0IGxlYXN0IG9uZSBUb2tlblxuICAgICAgICAvLyBJbiB0aGlzIENzdE5vZGUuXG4gICAgICAgIGlmIChsb2Muc3RhcnRPZmZzZXQgPD0gcHJldlRva2VuLnN0YXJ0T2Zmc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICBsb2MuZW5kT2Zmc2V0ID0gcHJldlRva2VuLmVuZE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBcImVtcHR5XCIgQ3N0Tm9kZSBlZGdlIGNhc2VcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2Muc3RhcnRPZmZzZXQgPSBOYU47XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3N0UG9zdFRlcm1pbmFsKGtleSwgY29uc3VtZWRUb2tlbikge1xuICAgICAgICBjb25zdCByb290Q3N0ID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIGFkZFRlcm1pbmFsVG9Dc3Qocm9vdENzdCwgY29uc3VtZWRUb2tlbiwga2V5KTtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tVG9rZW4ocm9vdENzdC5sb2NhdGlvbiwgY29uc3VtZWRUb2tlbik7XG4gICAgfVxuICAgIGNzdFBvc3ROb25UZXJtaW5hbChydWxlQ3N0UmVzdWx0LCBydWxlTmFtZSkge1xuICAgICAgICBjb25zdCBwcmVDc3ROb2RlID0gdGhpcy5DU1RfU1RBQ0tbdGhpcy5DU1RfU1RBQ0subGVuZ3RoIC0gMV07XG4gICAgICAgIGFkZE5vbmVUZXJtaW5hbFRvQ3N0KHByZUNzdE5vZGUsIHJ1bGVOYW1lLCBydWxlQ3N0UmVzdWx0KTtcbiAgICAgICAgLy8gVGhpcyBpcyBvbmx5IHVzZWQgd2hlbiAqKmJvdGgqKiBlcnJvciByZWNvdmVyeSBhbmQgQ1NUIE91dHB1dCBhcmUgZW5hYmxlZC5cbiAgICAgICAgdGhpcy5zZXROb2RlTG9jYXRpb25Gcm9tTm9kZShwcmVDc3ROb2RlLmxvY2F0aW9uLCBydWxlQ3N0UmVzdWx0LmxvY2F0aW9uKTtcbiAgICB9XG4gICAgZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKGlzVW5kZWZpbmVkKHRoaXMuYmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0Jhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3IgPSBjcmVhdGVCYXNlU2VtYW50aWNWaXNpdG9yQ29uc3RydWN0b3IodGhpcy5jbGFzc05hbWUsIGtleXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSkpO1xuICAgICAgICAgICAgdGhpcy5iYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yID0gbmV3QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcjtcbiAgICAgICAgICAgIHJldHVybiBuZXdCYXNlQ3N0VmlzaXRvckNvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGdldEJhc2VDc3RWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHMoKSB7XG4gICAgICAgIGlmIChpc1VuZGVmaW5lZCh0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdDb25zdHJ1Y3RvciA9IGNyZWF0ZUJhc2VWaXNpdG9yQ29uc3RydWN0b3JXaXRoRGVmYXVsdHModGhpcy5jbGFzc05hbWUsIGtleXModGhpcy5nYXN0UHJvZHVjdGlvbnNDYWNoZSksIHRoaXMuZ2V0QmFzZUNzdFZpc2l0b3JDb25zdHJ1Y3RvcigpKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZUNzdFZpc2l0b3JXaXRoRGVmYXVsdHNDb25zdHJ1Y3RvciA9IG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICAgICAgcmV0dXJuIG5ld0NvbnN0cnVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJhc2VDc3RWaXNpdG9yV2l0aERlZmF1bHRzQ29uc3RydWN0b3I7XG4gICAgfVxuICAgIGdldExhc3RFeHBsaWNpdFJ1bGVTaG9ydE5hbWUoKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVTdGFjayA9IHRoaXMuUlVMRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIHJ1bGVTdGFja1tydWxlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxuICAgIGdldFByZXZpb3VzRXhwbGljaXRSdWxlU2hvcnROYW1lKCkge1xuICAgICAgICBjb25zdCBydWxlU3RhY2sgPSB0aGlzLlJVTEVfU1RBQ0s7XG4gICAgICAgIHJldHVybiBydWxlU3RhY2tbcnVsZVN0YWNrLmxlbmd0aCAtIDJdO1xuICAgIH1cbiAgICBnZXRMYXN0RXhwbGljaXRSdWxlT2NjdXJyZW5jZUluZGV4KCkge1xuICAgICAgICBjb25zdCBvY2N1cnJlbmNlU3RhY2sgPSB0aGlzLlJVTEVfT0NDVVJSRU5DRV9TVEFDSztcbiAgICAgICAgcmV0dXJuIG9jY3VycmVuY2VTdGFja1tvY2N1cnJlbmNlU3RhY2subGVuZ3RoIC0gMV07XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dHJlZV9idWlsZGVyLmpzLm1hcCIsImV4cG9ydCBmdW5jdGlvbiBhcHBseU1peGlucyhkZXJpdmVkQ3RvciwgYmFzZUN0b3JzKSB7XG4gICAgYmFzZUN0b3JzLmZvckVhY2goKGJhc2VDdG9yKSA9PiB7XG4gICAgICAgIGNvbnN0IGJhc2VQcm90byA9IGJhc2VDdG9yLnByb3RvdHlwZTtcbiAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoYmFzZVByb3RvKS5mb3JFYWNoKChwcm9wTmFtZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHByb3BOYW1lID09PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBiYXNlUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGJhc2VQcm90bywgcHJvcE5hbWUpO1xuICAgICAgICAgICAgLy8gSGFuZGxlIEFjY2Vzc29yc1xuICAgICAgICAgICAgaWYgKGJhc2VQcm9wRGVzY3JpcHRvciAmJlxuICAgICAgICAgICAgICAgIChiYXNlUHJvcERlc2NyaXB0b3IuZ2V0IHx8IGJhc2VQcm9wRGVzY3JpcHRvci5zZXQpKSB7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDdG9yLnByb3RvdHlwZSwgcHJvcE5hbWUsIGJhc2VQcm9wRGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZXJpdmVkQ3Rvci5wcm90b3R5cGVbcHJvcE5hbWVdID0gYmFzZUN0b3IucHJvdG90eXBlW3Byb3BOYW1lXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcHBseV9taXhpbnMuanMubWFwIiwiaW1wb3J0IHsgQmFzZVJlZ0V4cFZpc2l0b3IgfSBmcm9tIFwiQGNoZXZyb3RhaW4vcmVnZXhwLXRvLWFzdFwiO1xuaW1wb3J0IHsgTGV4ZXIsIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSwgfSBmcm9tIFwiLi9sZXhlcl9wdWJsaWMuanNcIjtcbmltcG9ydCB7IGNvbXBhY3QsIGRlZmF1bHRzLCBkaWZmZXJlbmNlLCBmaWx0ZXIsIGZpbmQsIGZpcnN0LCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGluY2x1ZGVzLCBpbmRleE9mLCBpc0FycmF5LCBpc0VtcHR5LCBpc0Z1bmN0aW9uLCBpc1JlZ0V4cCwgaXNTdHJpbmcsIGlzVW5kZWZpbmVkLCBrZXlzLCBtYXAsIHJlZHVjZSwgcmVqZWN0LCB2YWx1ZXMsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgUFJJTlRfRVJST1IgfSBmcm9tIFwiQGNoZXZyb3RhaW4vdXRpbHNcIjtcbmltcG9ydCB7IGNhbk1hdGNoQ2hhckNvZGUsIGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZywgZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXMsIH0gZnJvbSBcIi4vcmVnX2V4cC5qc1wiO1xuaW1wb3J0IHsgZ2V0UmVnRXhwQXN0IH0gZnJvbSBcIi4vcmVnX2V4cF9wYXJzZXIuanNcIjtcbmNvbnN0IFBBVFRFUk4gPSBcIlBBVFRFUk5cIjtcbmV4cG9ydCBjb25zdCBERUZBVUxUX01PREUgPSBcImRlZmF1bHRNb2RlXCI7XG5leHBvcnQgY29uc3QgTU9ERVMgPSBcIm1vZGVzXCI7XG5leHBvcnQgbGV0IFNVUFBPUlRfU1RJQ0tZID0gdHlwZW9mIG5ldyBSZWdFeHAoXCIoPzopXCIpLnN0aWNreSA9PT0gXCJib29sZWFuXCI7XG5leHBvcnQgZnVuY3Rpb24gZGlzYWJsZVN0aWNreSgpIHtcbiAgICBTVVBQT1JUX1NUSUNLWSA9IGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuYWJsZVN0aWNreSgpIHtcbiAgICBTVVBQT1JUX1NUSUNLWSA9IHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYW5hbHl6ZVRva2VuVHlwZXModG9rZW5UeXBlcywgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBkZWZhdWx0cyhvcHRpb25zLCB7XG4gICAgICAgIHVzZVN0aWNreTogU1VQUE9SVF9TVElDS1ksXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICAgICAgc2FmZU1vZGU6IGZhbHNlLFxuICAgICAgICBwb3NpdGlvblRyYWNraW5nOiBcImZ1bGxcIixcbiAgICAgICAgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzOiBbXCJcXHJcIiwgXCJcXG5cIl0sXG4gICAgICAgIHRyYWNlcjogKG1zZywgYWN0aW9uKSA9PiBhY3Rpb24oKSxcbiAgICB9KTtcbiAgICBjb25zdCB0cmFjZXIgPSBvcHRpb25zLnRyYWNlcjtcbiAgICB0cmFjZXIoXCJpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwXCIsICgpID0+IHtcbiAgICAgICAgaW5pdENoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleE1hcCgpO1xuICAgIH0pO1xuICAgIGxldCBvbmx5UmVsZXZhbnRUeXBlcztcbiAgICB0cmFjZXIoXCJSZWplY3QgTGV4ZXIuTkFcIiwgKCkgPT4ge1xuICAgICAgICBvbmx5UmVsZXZhbnRUeXBlcyA9IHJlamVjdCh0b2tlblR5cGVzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyVHlwZVtQQVRURVJOXSA9PT0gTGV4ZXIuTkE7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGxldCBoYXNDdXN0b20gPSBmYWxzZTtcbiAgICBsZXQgYWxsVHJhbnNmb3JtZWRQYXR0ZXJucztcbiAgICB0cmFjZXIoXCJUcmFuc2Zvcm0gUGF0dGVybnNcIiwgKCkgPT4ge1xuICAgICAgICBoYXNDdXN0b20gPSBmYWxzZTtcbiAgICAgICAgYWxsVHJhbnNmb3JtZWRQYXR0ZXJucyA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjdXJyUGF0dGVybiA9IGN1cnJUeXBlW1BBVFRFUk5dO1xuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChpc1JlZ0V4cChjdXJyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZWdFeHBTb3VyY2UgPSBjdXJyUGF0dGVybi5zb3VyY2U7XG4gICAgICAgICAgICAgICAgaWYgKHJlZ0V4cFNvdXJjZS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gb25seSB0aGVzZSByZWdFeHAgbWV0YSBjaGFyYWN0ZXJzIHdoaWNoIGNhbiBhcHBlYXIgaW4gYSBsZW5ndGggb25lIHJlZ0V4cFxuICAgICAgICAgICAgICAgICAgICByZWdFeHBTb3VyY2UgIT09IFwiXlwiICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZSAhPT0gXCIkXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVnRXhwU291cmNlICE9PSBcIi5cIiAmJlxuICAgICAgICAgICAgICAgICAgICAhY3VyclBhdHRlcm4uaWdub3JlQ2FzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnRXhwU291cmNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZWdFeHBTb3VyY2UubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIHJlZ0V4cFNvdXJjZVswXSA9PT0gXCJcXFxcXCIgJiZcbiAgICAgICAgICAgICAgICAgICAgLy8gbm90IGEgbWV0YSBjaGFyYWN0ZXJcbiAgICAgICAgICAgICAgICAgICAgIWluY2x1ZGVzKFtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiU1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcInJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiZlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJ2XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiV1wiLFxuICAgICAgICAgICAgICAgICAgICBdLCByZWdFeHBTb3VyY2VbMV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzY2FwZWQgbWV0YSBDaGFyYWN0ZXJzOiAvXFwrLyAvXFxbL1xuICAgICAgICAgICAgICAgICAgICAvLyBvciByZWR1bmRhbnQgZXNjYXBpbmc6IC9cXGEvXG4gICAgICAgICAgICAgICAgICAgIC8vIHdpdGhvdXQgdGhlIGVzY2FwaW5nIFwiXFxcIlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVnRXhwU291cmNlWzFdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMudXNlU3RpY2t5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGFkZFN0aWNreUZsYWcoY3VyclBhdHRlcm4pXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGFkZFN0YXJ0T2ZJbnB1dChjdXJyUGF0dGVybik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNGdW5jdGlvbihjdXJyUGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICBoYXNDdXN0b20gPSB0cnVlO1xuICAgICAgICAgICAgICAgIC8vIEN1c3RvbVBhdHRlcm5NYXRjaGVyRnVuYyAtIGN1c3RvbSBwYXR0ZXJucyBkbyBub3QgcmVxdWlyZSBhbnkgdHJhbnNmb3JtYXRpb25zLCBvbmx5IHdyYXBwaW5nIGluIGEgUmVnRXhwIExpa2Ugb2JqZWN0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXhlYzogY3VyclBhdHRlcm4gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjdXJyUGF0dGVybiA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGhhc0N1c3RvbSA9IHRydWU7XG4gICAgICAgICAgICAgICAgLy8gSUN1c3RvbVBhdHRlcm5cbiAgICAgICAgICAgICAgICByZXR1cm4gY3VyclBhdHRlcm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY3VyclBhdHRlcm4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VyclBhdHRlcm4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVzY2FwZWRSZWdFeHBTdHJpbmcgPSBjdXJyUGF0dGVybi5yZXBsYWNlKC9bXFxcXF4kLiorPygpW1xcXXt9fF0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHdyYXBwZWRSZWdFeHAgPSBuZXcgUmVnRXhwKGVzY2FwZWRSZWdFeHBTdHJpbmcpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy51c2VTdGlja3lcbiAgICAgICAgICAgICAgICAgICAgICAgID8gYWRkU3RpY2t5RmxhZyh3cmFwcGVkUmVnRXhwKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBhZGRTdGFydE9mSW5wdXQod3JhcHBlZFJlZ0V4cCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJub24gZXhoYXVzdGl2ZSBtYXRjaFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgbGV0IHBhdHRlcm5JZHhUb1R5cGU7XG4gICAgbGV0IHBhdHRlcm5JZHhUb0dyb3VwO1xuICAgIGxldCBwYXR0ZXJuSWR4VG9Mb25nZXJBbHRJZHhBcnI7XG4gICAgbGV0IHBhdHRlcm5JZHhUb1B1c2hNb2RlO1xuICAgIGxldCBwYXR0ZXJuSWR4VG9Qb3BNb2RlO1xuICAgIHRyYWNlcihcIm1pc2MgbWFwcGluZ1wiLCAoKSA9PiB7XG4gICAgICAgIHBhdHRlcm5JZHhUb1R5cGUgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIChjdXJyVHlwZSkgPT4gY3VyclR5cGUudG9rZW5UeXBlSWR4KTtcbiAgICAgICAgcGF0dGVybklkeFRvR3JvdXAgPSBtYXAob25seVJlbGV2YW50VHlwZXMsIChjbGF6eikgPT4ge1xuICAgICAgICAgICAgY29uc3QgZ3JvdXBOYW1lID0gY2xhenouR1JPVVA7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgaWYgKGdyb3VwTmFtZSA9PT0gTGV4ZXIuU0tJUFBFRCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhncm91cE5hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdyb3VwTmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzVW5kZWZpbmVkKGdyb3VwTmFtZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcGF0dGVybklkeFRvTG9uZ2VyQWx0SWR4QXJyID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCAoY2xhenopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxvbmdlckFsdFR5cGUgPSBjbGF6ei5MT05HRVJfQUxUO1xuICAgICAgICAgICAgaWYgKGxvbmdlckFsdFR5cGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb25nZXJBbHRJZHhBcnIgPSBpc0FycmF5KGxvbmdlckFsdFR5cGUpXG4gICAgICAgICAgICAgICAgICAgID8gbWFwKGxvbmdlckFsdFR5cGUsICh0eXBlKSA9PiBpbmRleE9mKG9ubHlSZWxldmFudFR5cGVzLCB0eXBlKSlcbiAgICAgICAgICAgICAgICAgICAgOiBbaW5kZXhPZihvbmx5UmVsZXZhbnRUeXBlcywgbG9uZ2VyQWx0VHlwZSldO1xuICAgICAgICAgICAgICAgIHJldHVybiBsb25nZXJBbHRJZHhBcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBwYXR0ZXJuSWR4VG9QdXNoTW9kZSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgKGNsYXp6KSA9PiBjbGF6ei5QVVNIX01PREUpO1xuICAgICAgICBwYXR0ZXJuSWR4VG9Qb3BNb2RlID0gbWFwKG9ubHlSZWxldmFudFR5cGVzLCAoY2xhenopID0+IGhhcyhjbGF6eiwgXCJQT1BfTU9ERVwiKSk7XG4gICAgfSk7XG4gICAgbGV0IHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yO1xuICAgIHRyYWNlcihcIkxpbmUgVGVybWluYXRvciBIYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzID0gZ2V0Q2hhckNvZGVzKG9wdGlvbnMubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKTtcbiAgICAgICAgcGF0dGVybklkeFRvQ2FuTGluZVRlcm1pbmF0b3IgPSBtYXAob25seVJlbGV2YW50VHlwZXMsICh0b2tUeXBlKSA9PiBmYWxzZSk7XG4gICAgICAgIGlmIChvcHRpb25zLnBvc2l0aW9uVHJhY2tpbmcgIT09IFwib25seU9mZnNldFwiKSB7XG4gICAgICAgICAgICBwYXR0ZXJuSWR4VG9DYW5MaW5lVGVybWluYXRvciA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgKHRva1R5cGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoaGFzKHRva1R5cGUsIFwiTElORV9CUkVBS1NcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhdG9rVHlwZS5MSU5FX0JSRUFLUztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAoY2hlY2tMaW5lQnJlYWtzSXNzdWVzKHRva1R5cGUsIGxpbmVUZXJtaW5hdG9yQ2hhckNvZGVzKSA9PT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbk1hdGNoQ2hhckNvZGUobGluZVRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHBhdHRlcm5JZHhUb0lzQ3VzdG9tO1xuICAgIGxldCBwYXR0ZXJuSWR4VG9TaG9ydDtcbiAgICBsZXQgZW1wdHlHcm91cHM7XG4gICAgbGV0IHBhdHRlcm5JZHhUb0NvbmZpZztcbiAgICB0cmFjZXIoXCJNaXNjIE1hcHBpbmcgIzJcIiwgKCkgPT4ge1xuICAgICAgICBwYXR0ZXJuSWR4VG9Jc0N1c3RvbSA9IG1hcChvbmx5UmVsZXZhbnRUeXBlcywgaXNDdXN0b21QYXR0ZXJuKTtcbiAgICAgICAgcGF0dGVybklkeFRvU2hvcnQgPSBtYXAoYWxsVHJhbnNmb3JtZWRQYXR0ZXJucywgaXNTaG9ydFBhdHRlcm4pO1xuICAgICAgICBlbXB0eUdyb3VwcyA9IHJlZHVjZShvbmx5UmVsZXZhbnRUeXBlcywgKGFjYywgY2xhenopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwTmFtZSA9IGNsYXp6LkdST1VQO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKGdyb3VwTmFtZSkgJiYgIShncm91cE5hbWUgPT09IExleGVyLlNLSVBQRUQpKSB7XG4gICAgICAgICAgICAgICAgYWNjW2dyb3VwTmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2M7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnID0gbWFwKGFsbFRyYW5zZm9ybWVkUGF0dGVybnMsICh4LCBpZHgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcGF0dGVybjogYWxsVHJhbnNmb3JtZWRQYXR0ZXJuc1tpZHhdLFxuICAgICAgICAgICAgICAgIGxvbmdlckFsdDogcGF0dGVybklkeFRvTG9uZ2VyQWx0SWR4QXJyW2lkeF0sXG4gICAgICAgICAgICAgICAgY2FuTGluZVRlcm1pbmF0b3I6IHBhdHRlcm5JZHhUb0NhbkxpbmVUZXJtaW5hdG9yW2lkeF0sXG4gICAgICAgICAgICAgICAgaXNDdXN0b206IHBhdHRlcm5JZHhUb0lzQ3VzdG9tW2lkeF0sXG4gICAgICAgICAgICAgICAgc2hvcnQ6IHBhdHRlcm5JZHhUb1Nob3J0W2lkeF0sXG4gICAgICAgICAgICAgICAgZ3JvdXA6IHBhdHRlcm5JZHhUb0dyb3VwW2lkeF0sXG4gICAgICAgICAgICAgICAgcHVzaDogcGF0dGVybklkeFRvUHVzaE1vZGVbaWR4XSxcbiAgICAgICAgICAgICAgICBwb3A6IHBhdHRlcm5JZHhUb1BvcE1vZGVbaWR4XSxcbiAgICAgICAgICAgICAgICB0b2tlblR5cGVJZHg6IHBhdHRlcm5JZHhUb1R5cGVbaWR4XSxcbiAgICAgICAgICAgICAgICB0b2tlblR5cGU6IG9ubHlSZWxldmFudFR5cGVzW2lkeF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICBsZXQgY2FuQmVPcHRpbWl6ZWQgPSB0cnVlO1xuICAgIGxldCBjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID0gW107XG4gICAgaWYgKCFvcHRpb25zLnNhZmVNb2RlKSB7XG4gICAgICAgIHRyYWNlcihcIkZpcnN0IENoYXIgT3B0aW1pemF0aW9uXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSByZWR1Y2Uob25seVJlbGV2YW50VHlwZXMsIChyZXN1bHQsIGN1cnJUb2tUeXBlLCBpZHgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGN1cnJUb2tUeXBlLlBBVFRFUk4gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2hhckNvZGUgPSBjdXJyVG9rVHlwZS5QQVRURVJOLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGltaXplZElkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjaGFyQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFRvTWFwT2ZBcnJheXMocmVzdWx0LCBvcHRpbWl6ZWRJZHgsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNBcnJheShjdXJyVG9rVHlwZS5TVEFSVF9DSEFSU19ISU5UKSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdE9wdGltaXplZElkeDtcbiAgICAgICAgICAgICAgICAgICAgZm9yRWFjaChjdXJyVG9rVHlwZS5TVEFSVF9DSEFSU19ISU5ULCAoY2hhck9ySW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFyQ29kZSA9IHR5cGVvZiBjaGFyT3JJbnQgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IGNoYXJPckludC5jaGFyQ29kZUF0KDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjaGFyT3JJbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjdXJyT3B0aW1pemVkSWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEF2b2lkIGFkZGluZyB0aGUgY29uZmlnIG11bHRpcGxlIHRpbWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSBEaWZmaWN1bHQgdG8gY2hlY2sgdGhpcyBzY2VuYXJpbyBlZmZlY3RzIGFzIGl0IGlzIG9ubHkgYSBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gICBvcHRpbWl6YXRpb24gdGhhdCBkb2VzIG5vdCBjaGFuZ2UgY29ycmVjdG5lc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYXN0T3B0aW1pemVkSWR4ICE9PSBjdXJyT3B0aW1pemVkSWR4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE9wdGltaXplZElkeCA9IGN1cnJPcHRpbWl6ZWRJZHg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9NYXBPZkFycmF5cyhyZXN1bHQsIGN1cnJPcHRpbWl6ZWRJZHgsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKGN1cnJUb2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjdXJyVG9rVHlwZS5QQVRURVJOLnVuaWNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbkJlT3B0aW1pemVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgUFJJTlRfRVJST1IoYCR7ZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnfWAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBgXFx0VW5hYmxlIHRvIGFuYWx5emUgPCAke2N1cnJUb2tUeXBlLlBBVFRFUk4udG9TdHJpbmcoKX0gPiBwYXR0ZXJuLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoZSByZWdleHAgdW5pY29kZSBmbGFnIGlzIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0Rm9yIGRldGFpbHMgU2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjVU5JQ09ERV9PUFRJTUlaRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9wdGltaXplZENvZGVzID0gZ2V0T3B0aW1pemVkU3RhcnRDb2Rlc0luZGljZXMoY3VyclRva1R5cGUuUEFUVEVSTiwgb3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgY29kZSB3aWxsIG9ubHkgYmUgZW1wdHkgZ2l2ZW4gYW4gZW1wdHkgcmVnRXhwIG9yIGZhaWx1cmUgb2YgcmVnZXhwLXRvLWFzdCBsaWJyYXJ5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgZmlyc3Qgc2hvdWxkIGJlIGEgZGlmZmVyZW50IHZhbGlkYXRpb24gYW5kIHRoZSBzZWNvbmQgY2Fubm90IGJlIHRlc3RlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0VtcHR5KG9wdGltaXplZENvZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIGNhbm5vdCB1bmRlcnN0YW5kIHdoYXQgY29kZXMgbWF5IHN0YXJ0IHBvc3NpYmxlIG1hdGNoZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3B0aW1pemF0aW9uIGNvcnJlY3RuZXNzIHJlcXVpcmVzIGtub3dpbmcgc3RhcnQgY29kZXMgZm9yIEFMTCBwYXR0ZXJucy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBOb3QgYWN0dWFsbHkgc3VyZSB0aGlzIGlzIGFuIGVycm9yLCBubyBkZWJ1ZyBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2gob3B0aW1pemVkQ29kZXMsIChjb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkVG9NYXBPZkFycmF5cyhyZXN1bHQsIGNvZGUsIHBhdHRlcm5JZHhUb0NvbmZpZ1tpZHhdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5lbnN1cmVPcHRpbWl6YXRpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBQUklOVF9FUlJPUihgJHtmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2d9YCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYFxcdFRva2VuVHlwZTogPCR7Y3VyclRva1R5cGUubmFtZX0+IGlzIHVzaW5nIGEgY3VzdG9tIHRva2VuIHBhdHRlcm4gd2l0aG91dCBwcm92aWRpbmcgPHN0YXJ0X2NoYXJzX2hpbnQ+IHBhcmFtZXRlci5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdFRoaXMgd2lsbCBkaXNhYmxlIHRoZSBsZXhlcidzIGZpcnN0IGNoYXIgb3B0aW1pemF0aW9ucy5cXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fT1BUSU1JWkVcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2FuQmVPcHRpbWl6ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH0sIFtdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGVtcHR5R3JvdXBzOiBlbXB0eUdyb3VwcyxcbiAgICAgICAgcGF0dGVybklkeFRvQ29uZmlnOiBwYXR0ZXJuSWR4VG9Db25maWcsXG4gICAgICAgIGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc6IGNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcsXG4gICAgICAgIGhhc0N1c3RvbTogaGFzQ3VzdG9tLFxuICAgICAgICBjYW5CZU9wdGltaXplZDogY2FuQmVPcHRpbWl6ZWQsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB2YWxpZGF0ZVBhdHRlcm5zKHRva2VuVHlwZXMsIHZhbGlkTW9kZXNOYW1lcykge1xuICAgIGxldCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBtaXNzaW5nUmVzdWx0ID0gZmluZE1pc3NpbmdQYXR0ZXJucyh0b2tlblR5cGVzKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KG1pc3NpbmdSZXN1bHQuZXJyb3JzKTtcbiAgICBjb25zdCBpbnZhbGlkUmVzdWx0ID0gZmluZEludmFsaWRQYXR0ZXJucyhtaXNzaW5nUmVzdWx0LnZhbGlkKTtcbiAgICBjb25zdCB2YWxpZFRva2VuVHlwZXMgPSBpbnZhbGlkUmVzdWx0LnZhbGlkO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoaW52YWxpZFJlc3VsdC5lcnJvcnMpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQodmFsaWRhdGVSZWdFeHBQYXR0ZXJuKHZhbGlkVG9rZW5UeXBlcykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZEludmFsaWRHcm91cFR5cGUodmFsaWRUb2tlblR5cGVzKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kTW9kZXNUaGF0RG9Ob3RFeGlzdCh2YWxpZFRva2VuVHlwZXMsIHZhbGlkTW9kZXNOYW1lcykpO1xuICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoZmluZFVucmVhY2hhYmxlUGF0dGVybnModmFsaWRUb2tlblR5cGVzKSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVnRXhwUGF0dGVybih0b2tlblR5cGVzKSB7XG4gICAgbGV0IGVycm9ycyA9IFtdO1xuICAgIGNvbnN0IHdpdGhSZWdFeHBQYXR0ZXJucyA9IGZpbHRlcih0b2tlblR5cGVzLCAoY3VyclRva1R5cGUpID0+IGlzUmVnRXhwKGN1cnJUb2tUeXBlW1BBVFRFUk5dKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kRW5kT2ZJbnB1dEFuY2hvcih3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRTdGFydE9mSW5wdXRBbmNob3Iod2l0aFJlZ0V4cFBhdHRlcm5zKSk7XG4gICAgZXJyb3JzID0gZXJyb3JzLmNvbmNhdChmaW5kVW5zdXBwb3J0ZWRGbGFncyh3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmREdXBsaWNhdGVQYXR0ZXJucyh3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICBlcnJvcnMgPSBlcnJvcnMuY29uY2F0KGZpbmRFbXB0eU1hdGNoUmVnRXhwcyh3aXRoUmVnRXhwUGF0dGVybnMpKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNaXNzaW5nUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIGNvbnN0IHRva2VuVHlwZXNXaXRoTWlzc2luZ1BhdHRlcm4gPSBmaWx0ZXIodG9rZW5UeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIHJldHVybiAhaGFzKGN1cnJUeXBlLCBQQVRURVJOKTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAodG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybiwgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gbWlzc2luZyBzdGF0aWMgJ1BBVFRFUk4nIHByb3BlcnR5XCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTUlTU0lOR19QQVRURVJOLFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICBjb25zdCB2YWxpZCA9IGRpZmZlcmVuY2UodG9rZW5UeXBlcywgdG9rZW5UeXBlc1dpdGhNaXNzaW5nUGF0dGVybik7XG4gICAgcmV0dXJuIHsgZXJyb3JzLCB2YWxpZCB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRJbnZhbGlkUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIGNvbnN0IHRva2VuVHlwZXNXaXRoSW52YWxpZFBhdHRlcm4gPSBmaWx0ZXIodG9rZW5UeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyVHlwZVtQQVRURVJOXTtcbiAgICAgICAgcmV0dXJuICghaXNSZWdFeHAocGF0dGVybikgJiZcbiAgICAgICAgICAgICFpc0Z1bmN0aW9uKHBhdHRlcm4pICYmXG4gICAgICAgICAgICAhaGFzKHBhdHRlcm4sIFwiZXhlY1wiKSAmJlxuICAgICAgICAgICAgIWlzU3RyaW5nKHBhdHRlcm4pKTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAodG9rZW5UeXBlc1dpdGhJbnZhbGlkUGF0dGVybiwgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW4gb25seSBiZSBhIFJlZ0V4cCwgYVwiICtcbiAgICAgICAgICAgICAgICBcIiBGdW5jdGlvbiBtYXRjaGluZyB0aGUge0N1c3RvbVBhdHRlcm5NYXRjaGVyRnVuY30gdHlwZSBvciBhbiBPYmplY3QgbWF0Y2hpbmcgdGhlIHtJQ3VzdG9tUGF0dGVybn0gaW50ZXJmYWNlLlwiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklOVkFMSURfUEFUVEVSTixcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgY29uc3QgdmFsaWQgPSBkaWZmZXJlbmNlKHRva2VuVHlwZXMsIHRva2VuVHlwZXNXaXRoSW52YWxpZFBhdHRlcm4pO1xuICAgIHJldHVybiB7IGVycm9ycywgdmFsaWQgfTtcbn1cbmNvbnN0IGVuZF9vZl9pbnB1dCA9IC9bXlxcXFxdWyRdLztcbmV4cG9ydCBmdW5jdGlvbiBmaW5kRW5kT2ZJbnB1dEFuY2hvcih0b2tlblR5cGVzKSB7XG4gICAgY2xhc3MgRW5kQW5jaG9yRmluZGVyIGV4dGVuZHMgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRFbmRBbmNob3Iobm9kZSkge1xuICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW52YWxpZFJlZ2V4ID0gZmlsdGVyKHRva2VuVHlwZXMsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gY3VyclR5cGUuUEFUVEVSTjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlZ2V4cEFzdCA9IGdldFJlZ0V4cEFzdChwYXR0ZXJuKTtcbiAgICAgICAgICAgIGNvbnN0IGVuZEFuY2hvclZpc2l0b3IgPSBuZXcgRW5kQW5jaG9yRmluZGVyKCk7XG4gICAgICAgICAgICBlbmRBbmNob3JWaXNpdG9yLnZpc2l0KHJlZ2V4cEFzdCk7XG4gICAgICAgICAgICByZXR1cm4gZW5kQW5jaG9yVmlzaXRvci5mb3VuZDtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgLy8gb2xkIGJlaGF2aW9yIGluIGNhc2Ugb2YgcnVudGltZSBleGNlcHRpb25zIHdpdGggcmVnZXhwLXRvLWFzdC5cbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gY2Fubm90IGVuc3VyZSBhbiBlcnJvciBpbiByZWdleHAtdG8tYXN0Ki9cbiAgICAgICAgICAgIHJldHVybiBlbmRfb2ZfaW5wdXQudGVzdChwYXR0ZXJuLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAoaW52YWxpZFJlZ2V4LCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBlbmQgb2YgaW5wdXQgYW5jaG9yICckJ1xcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFNlZSBjaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0FOQ0hPUlNcIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5FT0lfQU5DSE9SX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRFbXB0eU1hdGNoUmVnRXhwcyh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgbWF0Y2hlc0VtcHR5U3RyaW5nID0gZmlsdGVyKHRva2VuVHlwZXMsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gY3VyclR5cGUuUEFUVEVSTjtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4udGVzdChcIlwiKTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAobWF0Y2hlc0VtcHR5U3RyaW5nLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ1BBVFRFUk4nIG11c3Qgbm90IG1hdGNoIGFuIGVtcHR5IHN0cmluZ1wiLFxuICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLkVNUFRZX01BVENIX1BBVFRFUk4sXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbY3VyclR5cGVdLFxuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5jb25zdCBzdGFydF9vZl9pbnB1dCA9IC9bXlxcXFxbXVtcXF5dfF5cXF4vO1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRTdGFydE9mSW5wdXRBbmNob3IodG9rZW5UeXBlcykge1xuICAgIGNsYXNzIFN0YXJ0QW5jaG9yRmluZGVyIGV4dGVuZHMgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdmlzaXRTdGFydEFuY2hvcihub2RlKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBpbnZhbGlkUmVnZXggPSBmaWx0ZXIodG9rZW5UeXBlcywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSBjdXJyVHlwZS5QQVRURVJOO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVnZXhwQXN0ID0gZ2V0UmVnRXhwQXN0KHBhdHRlcm4pO1xuICAgICAgICAgICAgY29uc3Qgc3RhcnRBbmNob3JWaXNpdG9yID0gbmV3IFN0YXJ0QW5jaG9yRmluZGVyKCk7XG4gICAgICAgICAgICBzdGFydEFuY2hvclZpc2l0b3IudmlzaXQocmVnZXhwQXN0KTtcbiAgICAgICAgICAgIHJldHVybiBzdGFydEFuY2hvclZpc2l0b3IuZm91bmQ7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIG9sZCBiZWhhdmlvciBpbiBjYXNlIG9mIHJ1bnRpbWUgZXhjZXB0aW9ucyB3aXRoIHJlZ2V4cC10by1hc3QuXG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIGNhbm5vdCBlbnN1cmUgYW4gZXJyb3IgaW4gcmVnZXhwLXRvLWFzdCovXG4gICAgICAgICAgICByZXR1cm4gc3RhcnRfb2ZfaW5wdXQudGVzdChwYXR0ZXJuLnNvdXJjZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAoaW52YWxpZFJlZ2V4LCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVW5leHBlY3RlZCBSZWdFeHAgQW5jaG9yIEVycm9yOlxcblwiICtcbiAgICAgICAgICAgICAgICBcIlxcdFRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBjYW5ub3QgY29udGFpbiBzdGFydCBvZiBpbnB1dCBhbmNob3IgJ14nXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNBTkNIT1JTXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0Zm9yIGRldGFpbHMuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuU09JX0FOQ0hPUl9GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVW5zdXBwb3J0ZWRGbGFncyh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgaW52YWxpZEZsYWdzID0gZmlsdGVyKHRva2VuVHlwZXMsIChjdXJyVHlwZSkgPT4ge1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gY3VyclR5cGVbUEFUVEVSTl07XG4gICAgICAgIHJldHVybiBwYXR0ZXJuIGluc3RhbmNlb2YgUmVnRXhwICYmIChwYXR0ZXJuLm11bHRpbGluZSB8fCBwYXR0ZXJuLmdsb2JhbCk7XG4gICAgfSk7XG4gICAgY29uc3QgZXJyb3JzID0gbWFwKGludmFsaWRGbGFncywgKGN1cnJUeXBlKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBcIlRva2VuIFR5cGU6IC0+XCIgK1xuICAgICAgICAgICAgICAgIGN1cnJUeXBlLm5hbWUgK1xuICAgICAgICAgICAgICAgIFwiPC0gc3RhdGljICdQQVRURVJOJyBtYXkgTk9UIGNvbnRhaW4gZ2xvYmFsKCdnJykgb3IgbXVsdGlsaW5lKCdtJylcIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5VTlNVUFBPUlRFRF9GTEFHU19GT1VORCxcbiAgICAgICAgICAgIHRva2VuVHlwZXM6IFtjdXJyVHlwZV0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbi8vIFRoaXMgY2FuIG9ubHkgdGVzdCBmb3IgaWRlbnRpY2FsIGR1cGxpY2F0ZSBSZWdFeHBzLCBub3Qgc2VtYW50aWNhbGx5IGVxdWl2YWxlbnQgb25lcy5cbmV4cG9ydCBmdW5jdGlvbiBmaW5kRHVwbGljYXRlUGF0dGVybnModG9rZW5UeXBlcykge1xuICAgIGNvbnN0IGZvdW5kID0gW107XG4gICAgbGV0IGlkZW50aWNhbFBhdHRlcm5zID0gbWFwKHRva2VuVHlwZXMsIChvdXRlclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHJlZHVjZSh0b2tlblR5cGVzLCAocmVzdWx0LCBpbm5lclR5cGUpID0+IHtcbiAgICAgICAgICAgIGlmIChvdXRlclR5cGUuUEFUVEVSTi5zb3VyY2UgPT09IGlubmVyVHlwZS5QQVRURVJOLnNvdXJjZSAmJlxuICAgICAgICAgICAgICAgICFpbmNsdWRlcyhmb3VuZCwgaW5uZXJUeXBlKSAmJlxuICAgICAgICAgICAgICAgIGlubmVyVHlwZS5QQVRURVJOICE9PSBMZXhlci5OQSkge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgYXZvaWRzIGR1cGxpY2F0ZXMgaW4gdGhlIHJlc3VsdCwgZWFjaCBUb2tlbiBUeXBlIG1heSBvbmx5IGFwcGVhciBpbiBvbmUgXCJzZXRcIlxuICAgICAgICAgICAgICAgIC8vIGluIGVzc2VuY2Ugd2UgYXJlIGNyZWF0aW5nIEVxdWl2YWxlbmNlIGNsYXNzZXMgb24gZXF1YWxpdHkgcmVsYXRpb24uXG4gICAgICAgICAgICAgICAgZm91bmQucHVzaChpbm5lclR5cGUpO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGlubmVyVHlwZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0sIFtdKTtcbiAgICB9KTtcbiAgICBpZGVudGljYWxQYXR0ZXJucyA9IGNvbXBhY3QoaWRlbnRpY2FsUGF0dGVybnMpO1xuICAgIGNvbnN0IGR1cGxpY2F0ZVBhdHRlcm5zID0gZmlsdGVyKGlkZW50aWNhbFBhdHRlcm5zLCAoY3VycklkZW50aWNhbFNldCkgPT4ge1xuICAgICAgICByZXR1cm4gY3VycklkZW50aWNhbFNldC5sZW5ndGggPiAxO1xuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcChkdXBsaWNhdGVQYXR0ZXJucywgKHNldE9mSWRlbnRpY2FsKSA9PiB7XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZU5hbWVzID0gbWFwKHNldE9mSWRlbnRpY2FsLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBjdXJyVHlwZS5uYW1lO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZHVwUGF0dGVyblNyYyA9IGZpcnN0KHNldE9mSWRlbnRpY2FsKS5QQVRURVJOO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWVzc2FnZTogYFRoZSBzYW1lIFJlZ0V4cCBwYXR0ZXJuIC0+JHtkdXBQYXR0ZXJuU3JjfTwtYCArXG4gICAgICAgICAgICAgICAgYGhhcyBiZWVuIHVzZWQgaW4gYWxsIG9mIHRoZSBmb2xsb3dpbmcgVG9rZW4gVHlwZXM6ICR7dG9rZW5UeXBlTmFtZXMuam9pbihcIiwgXCIpfSA8LWAsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogc2V0T2ZJZGVudGljYWwsXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kSW52YWxpZEdyb3VwVHlwZSh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgaW52YWxpZFR5cGVzID0gZmlsdGVyKHRva2VuVHlwZXMsIChjbGF6eikgPT4ge1xuICAgICAgICBpZiAoIWhhcyhjbGF6eiwgXCJHUk9VUFwiKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGdyb3VwID0gY2xhenouR1JPVVA7XG4gICAgICAgIHJldHVybiBncm91cCAhPT0gTGV4ZXIuU0tJUFBFRCAmJiBncm91cCAhPT0gTGV4ZXIuTkEgJiYgIWlzU3RyaW5nKGdyb3VwKTtcbiAgICB9KTtcbiAgICBjb25zdCBlcnJvcnMgPSBtYXAoaW52YWxpZFR5cGVzLCAoY3VyclR5cGUpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiVG9rZW4gVHlwZTogLT5cIiArXG4gICAgICAgICAgICAgICAgY3VyclR5cGUubmFtZSArXG4gICAgICAgICAgICAgICAgXCI8LSBzdGF0aWMgJ0dST1VQJyBjYW4gb25seSBiZSBMZXhlci5TS0lQUEVEL0xleGVyLk5BL0EgU3RyaW5nXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5ELFxuICAgICAgICAgICAgdG9rZW5UeXBlczogW2N1cnJUeXBlXSxcbiAgICAgICAgfTtcbiAgICB9KTtcbiAgICByZXR1cm4gZXJyb3JzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpbmRNb2Rlc1RoYXREb05vdEV4aXN0KHRva2VuVHlwZXMsIHZhbGlkTW9kZXMpIHtcbiAgICBjb25zdCBpbnZhbGlkTW9kZXMgPSBmaWx0ZXIodG9rZW5UeXBlcywgKGNsYXp6KSA9PiB7XG4gICAgICAgIHJldHVybiAoY2xhenouUFVTSF9NT0RFICE9PSB1bmRlZmluZWQgJiYgIWluY2x1ZGVzKHZhbGlkTW9kZXMsIGNsYXp6LlBVU0hfTU9ERSkpO1xuICAgIH0pO1xuICAgIGNvbnN0IGVycm9ycyA9IG1hcChpbnZhbGlkTW9kZXMsICh0b2tUeXBlKSA9PiB7XG4gICAgICAgIGNvbnN0IG1zZyA9IGBUb2tlbiBUeXBlOiAtPiR7dG9rVHlwZS5uYW1lfTwtIHN0YXRpYyAnUFVTSF9NT0RFJyB2YWx1ZSBjYW5ub3QgcmVmZXIgdG8gYSBMZXhlciBNb2RlIC0+JHt0b2tUeXBlLlBVU0hfTU9ERX08LWAgK1xuICAgICAgICAgICAgYHdoaWNoIGRvZXMgbm90IGV4aXN0YDtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5QVVNIX01PREVfRE9FU19OT1RfRVhJU1QsXG4gICAgICAgICAgICB0b2tlblR5cGVzOiBbdG9rVHlwZV0sXG4gICAgICAgIH07XG4gICAgfSk7XG4gICAgcmV0dXJuIGVycm9ycztcbn1cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVW5yZWFjaGFibGVQYXR0ZXJucyh0b2tlblR5cGVzKSB7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2FuQmVUZXN0ZWQgPSByZWR1Y2UodG9rZW5UeXBlcywgKHJlc3VsdCwgdG9rVHlwZSwgaWR4KSA9PiB7XG4gICAgICAgIGNvbnN0IHBhdHRlcm4gPSB0b2tUeXBlLlBBVFRFUk47XG4gICAgICAgIGlmIChwYXR0ZXJuID09PSBMZXhlci5OQSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICAvLyBhIG1vcmUgY29tcHJlaGVuc2l2ZSB2YWxpZGF0aW9uIGZvciBhbGwgZm9ybXMgb2YgcmVnRXhwcyB3b3VsZCByZXF1aXJlXG4gICAgICAgIC8vIGRlZXBlciByZWdFeHAgYW5hbHlzaXMgY2FwYWJpbGl0aWVzXG4gICAgICAgIGlmIChpc1N0cmluZyhwYXR0ZXJuKSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goeyBzdHI6IHBhdHRlcm4sIGlkeCwgdG9rZW5UeXBlOiB0b2tUeXBlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pICYmIG5vTWV0YUNoYXIocGF0dGVybikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHsgc3RyOiBwYXR0ZXJuLnNvdXJjZSwgaWR4LCB0b2tlblR5cGU6IHRva1R5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCBbXSk7XG4gICAgZm9yRWFjaCh0b2tlblR5cGVzLCAodG9rVHlwZSwgdGVzdElkeCkgPT4ge1xuICAgICAgICBmb3JFYWNoKGNhbkJlVGVzdGVkLCAoeyBzdHIsIGlkeCwgdG9rZW5UeXBlIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0ZXN0SWR4IDwgaWR4ICYmIHRlc3RUb2tlblR5cGUoc3RyLCB0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gYFRva2VuOiAtPiR7dG9rZW5UeXBlLm5hbWV9PC0gY2FuIG5ldmVyIGJlIG1hdGNoZWQuXFxuYCArXG4gICAgICAgICAgICAgICAgICAgIGBCZWNhdXNlIGl0IGFwcGVhcnMgQUZURVIgdGhlIFRva2VuIFR5cGUgLT4ke3Rva1R5cGUubmFtZX08LWAgK1xuICAgICAgICAgICAgICAgICAgICBgaW4gdGhlIGxleGVyJ3MgZGVmaW5pdGlvbi5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgYFNlZSBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjVU5SRUFDSEFCTEVgO1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogbXNnLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuVU5SRUFDSEFCTEVfUEFUVEVSTixcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5UeXBlczogW3Rva1R5cGUsIHRva2VuVHlwZV0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5mdW5jdGlvbiB0ZXN0VG9rZW5UeXBlKHN0ciwgcGF0dGVybikge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cEFycmF5ID0gcGF0dGVybi5leGVjKHN0cik7XG4gICAgICAgIHJldHVybiByZWdFeHBBcnJheSAhPT0gbnVsbCAmJiByZWdFeHBBcnJheS5pbmRleCA9PT0gMDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNGdW5jdGlvbihwYXR0ZXJuKSkge1xuICAgICAgICAvLyBtYWludGFpbiB0aGUgQVBJIG9mIGN1c3RvbSBwYXR0ZXJuc1xuICAgICAgICByZXR1cm4gcGF0dGVybihzdHIsIDAsIFtdLCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhcyhwYXR0ZXJuLCBcImV4ZWNcIikpIHtcbiAgICAgICAgLy8gbWFpbnRhaW4gdGhlIEFQSSBvZiBjdXN0b20gcGF0dGVybnNcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uZXhlYyhzdHIsIDAsIFtdLCB7fSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBwYXR0ZXJuID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBwYXR0ZXJuID09PSBzdHI7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vTWV0YUNoYXIocmVnRXhwKSB7XG4gICAgLy9odHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHBcbiAgICBjb25zdCBtZXRhQ2hhcnMgPSBbXG4gICAgICAgIFwiLlwiLFxuICAgICAgICBcIlxcXFxcIixcbiAgICAgICAgXCJbXCIsXG4gICAgICAgIFwiXVwiLFxuICAgICAgICBcInxcIixcbiAgICAgICAgXCJeXCIsXG4gICAgICAgIFwiJFwiLFxuICAgICAgICBcIihcIixcbiAgICAgICAgXCIpXCIsXG4gICAgICAgIFwiP1wiLFxuICAgICAgICBcIipcIixcbiAgICAgICAgXCIrXCIsXG4gICAgICAgIFwie1wiLFxuICAgIF07XG4gICAgcmV0dXJuIChmaW5kKG1ldGFDaGFycywgKGNoYXIpID0+IHJlZ0V4cC5zb3VyY2UuaW5kZXhPZihjaGFyKSAhPT0gLTEpID09PSB1bmRlZmluZWQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFkZFN0YXJ0T2ZJbnB1dChwYXR0ZXJuKSB7XG4gICAgY29uc3QgZmxhZ3MgPSBwYXR0ZXJuLmlnbm9yZUNhc2UgPyBcImlcIiA6IFwiXCI7XG4gICAgLy8gYWx3YXlzIHdyYXBwaW5nIGluIGEgbm9uZSBjYXB0dXJpbmcgZ3JvdXAgcHJlY2VkZWQgYnkgJ14nIHRvIG1ha2Ugc3VyZSBtYXRjaGluZyBjYW4gb25seSB3b3JrIG9uIHN0YXJ0IG9mIGlucHV0LlxuICAgIC8vIGR1cGxpY2F0ZS9yZWR1bmRhbnQgc3RhcnQgb2YgaW5wdXQgbWFya2VycyBoYXZlIG5vIG1lYW5pbmcgKC9eXl5eQS8gPT09IC9eQS8pXG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoYF4oPzoke3BhdHRlcm4uc291cmNlfSlgLCBmbGFncyk7XG59XG5leHBvcnQgZnVuY3Rpb24gYWRkU3RpY2t5RmxhZyhwYXR0ZXJuKSB7XG4gICAgY29uc3QgZmxhZ3MgPSBwYXR0ZXJuLmlnbm9yZUNhc2UgPyBcIml5XCIgOiBcInlcIjtcbiAgICAvLyBhbHdheXMgd3JhcHBpbmcgaW4gYSBub25lIGNhcHR1cmluZyBncm91cCBwcmVjZWRlZCBieSAnXicgdG8gbWFrZSBzdXJlIG1hdGNoaW5nIGNhbiBvbmx5IHdvcmsgb24gc3RhcnQgb2YgaW5wdXQuXG4gICAgLy8gZHVwbGljYXRlL3JlZHVuZGFudCBzdGFydCBvZiBpbnB1dCBtYXJrZXJzIGhhdmUgbm8gbWVhbmluZyAoL15eXl5BLyA9PT0gL15BLylcbiAgICByZXR1cm4gbmV3IFJlZ0V4cChgJHtwYXR0ZXJuLnNvdXJjZX1gLCBmbGFncyk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybVJ1bnRpbWVDaGVja3MobGV4ZXJEZWZpbml0aW9uLCB0cmFja0xpbmVzLCBsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpIHtcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICAvLyBzb21lIHJ1biB0aW1lIGNoZWNrcyB0byBoZWxwIHRoZSBlbmQgdXNlcnMuXG4gICAgaWYgKCFoYXMobGV4ZXJEZWZpbml0aW9uLCBERUZBVUxUX01PREUpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIgK1xuICAgICAgICAgICAgICAgIERFRkFVTFRfTU9ERSArXG4gICAgICAgICAgICAgICAgXCI+IHByb3BlcnR5IGluIGl0cyBkZWZpbml0aW9uXFxuXCIsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmICghaGFzKGxleGVyRGVmaW5pdGlvbiwgTU9ERVMpKSB7XG4gICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiQSBNdWx0aU1vZGUgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHdpdGhvdXQgYSA8XCIgK1xuICAgICAgICAgICAgICAgIE1PREVTICtcbiAgICAgICAgICAgICAgICBcIj4gcHJvcGVydHkgaW4gaXRzIGRlZmluaXRpb25cXG5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5NVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzKGxleGVyRGVmaW5pdGlvbiwgTU9ERVMpICYmXG4gICAgICAgIGhhcyhsZXhlckRlZmluaXRpb24sIERFRkFVTFRfTU9ERSkgJiZcbiAgICAgICAgIWhhcyhsZXhlckRlZmluaXRpb24ubW9kZXMsIGxleGVyRGVmaW5pdGlvbi5kZWZhdWx0TW9kZSkpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgbWVzc2FnZTogYEEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgJHtERUZBVUxUX01PREV9OiA8JHtsZXhlckRlZmluaXRpb24uZGVmYXVsdE1vZGV9PmAgK1xuICAgICAgICAgICAgICAgIGB3aGljaCBkb2VzIG5vdCBleGlzdFxcbmAsXG4gICAgICAgICAgICB0eXBlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1QsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaGFzKGxleGVyRGVmaW5pdGlvbiwgTU9ERVMpKSB7XG4gICAgICAgIGZvckVhY2gobGV4ZXJEZWZpbml0aW9uLm1vZGVzLCAoY3Vyck1vZGVWYWx1ZSwgY3Vyck1vZGVOYW1lKSA9PiB7XG4gICAgICAgICAgICBmb3JFYWNoKGN1cnJNb2RlVmFsdWUsIChjdXJyVG9rVHlwZSwgY3VycklkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChjdXJyVG9rVHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEEgTGV4ZXIgY2Fubm90IGJlIGluaXRpYWxpemVkIHVzaW5nIGFuIHVuZGVmaW5lZCBUb2tlbiBUeXBlLiBNb2RlOmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA8JHtjdXJyTW9kZU5hbWV9PiBhdCBpbmRleDogPCR7Y3VycklkeH0+XFxuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5MRVhFUl9ERUZJTklUSU9OX0NBTk5PVF9DT05UQUlOX1VOREVGSU5FRCxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhcyhjdXJyVG9rVHlwZSwgXCJMT05HRVJfQUxUXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdlckFsdCA9IGlzQXJyYXkoY3VyclRva1R5cGUuTE9OR0VSX0FMVClcbiAgICAgICAgICAgICAgICAgICAgICAgID8gY3VyclRva1R5cGUuTE9OR0VSX0FMVFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbY3VyclRva1R5cGUuTE9OR0VSX0FMVF07XG4gICAgICAgICAgICAgICAgICAgIGZvckVhY2gobG9uZ2VyQWx0LCAoY3VyckxvbmdlckFsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc1VuZGVmaW5lZChjdXJyTG9uZ2VyQWx0KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICFpbmNsdWRlcyhjdXJyTW9kZVZhbHVlLCBjdXJyTG9uZ2VyQWx0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogYEEgTXVsdGlNb2RlIExleGVyIGNhbm5vdCBiZSBpbml0aWFsaXplZCB3aXRoIGEgbG9uZ2VyX2FsdCA8JHtjdXJyTG9uZ2VyQWx0Lm5hbWV9PiBvbiB0b2tlbiA8JHtjdXJyVG9rVHlwZS5uYW1lfT4gb3V0c2lkZSBvZiBtb2RlIDwke2N1cnJNb2RlTmFtZX0+XFxuYCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLk1VTFRJX01PREVfTEVYRVJfTE9OR0VSX0FMVF9OT1RfSU5fQ1VSUkVOVF9NT0RFLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybVdhcm5pbmdSdW50aW1lQ2hlY2tzKGxleGVyRGVmaW5pdGlvbiwgdHJhY2tMaW5lcywgbGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSB7XG4gICAgY29uc3Qgd2FybmluZ3MgPSBbXTtcbiAgICBsZXQgaGFzQW55TGluZUJyZWFrID0gZmFsc2U7XG4gICAgY29uc3QgYWxsVG9rZW5UeXBlcyA9IGNvbXBhY3QoZmxhdHRlbih2YWx1ZXMobGV4ZXJEZWZpbml0aW9uLm1vZGVzKSkpO1xuICAgIGNvbnN0IGNvbmNyZXRlVG9rZW5UeXBlcyA9IHJlamVjdChhbGxUb2tlblR5cGVzLCAoY3VyclR5cGUpID0+IGN1cnJUeXBlW1BBVFRFUk5dID09PSBMZXhlci5OQSk7XG4gICAgY29uc3QgdGVybWluYXRvckNoYXJDb2RlcyA9IGdldENoYXJDb2RlcyhsaW5lVGVybWluYXRvckNoYXJhY3RlcnMpO1xuICAgIGlmICh0cmFja0xpbmVzKSB7XG4gICAgICAgIGZvckVhY2goY29uY3JldGVUb2tlblR5cGVzLCAodG9rVHlwZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3Vycklzc3VlID0gY2hlY2tMaW5lQnJlYWtzSXNzdWVzKHRva1R5cGUsIHRlcm1pbmF0b3JDaGFyQ29kZXMpO1xuICAgICAgICAgICAgaWYgKGN1cnJJc3N1ZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2UodG9rVHlwZSwgY3Vycklzc3VlKTtcbiAgICAgICAgICAgICAgICBjb25zdCB3YXJuaW5nRGVzY3JpcHRvciA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogY3Vycklzc3VlLmlzc3VlLFxuICAgICAgICAgICAgICAgICAgICB0b2tlblR5cGU6IHRva1R5cGUsXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3YXJuaW5ncy5wdXNoKHdhcm5pbmdEZXNjcmlwdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHdlIGRvbid0IHdhbnQgdG8gYXR0ZW1wdCB0byBzY2FuIGlmIHRoZSB1c2VyIGV4cGxpY2l0bHkgc3BlY2lmaWVkIHRoZSBsaW5lX2JyZWFrcyBvcHRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGhhcyh0b2tUeXBlLCBcIkxJTkVfQlJFQUtTXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tUeXBlLkxJTkVfQlJFQUtTID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBbnlMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuTWF0Y2hDaGFyQ29kZSh0ZXJtaW5hdG9yQ2hhckNvZGVzLCB0b2tUeXBlLlBBVFRFUk4pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNBbnlMaW5lQnJlYWsgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRyYWNrTGluZXMgJiYgIWhhc0FueUxpbmVCcmVhaykge1xuICAgICAgICB3YXJuaW5ncy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IFwiV2FybmluZzogTm8gTElORV9CUkVBS1MgRm91bmQuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0VGhpcyBMZXhlciBoYXMgYmVlbiBkZWZpbmVkIHRvIHRyYWNrIGxpbmUgYW5kIGNvbHVtbiBpbmZvcm1hdGlvbixcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRCdXQgbm9uZSBvZiB0aGUgVG9rZW4gVHlwZXMgY2FuIGJlIGlkZW50aWZpZWQgYXMgbWF0Y2hpbmcgYSBsaW5lIHRlcm1pbmF0b3IuXFxuXCIgK1xuICAgICAgICAgICAgICAgIFwiXFx0U2VlIGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNMSU5FX0JSRUFLUyBcXG5cIiArXG4gICAgICAgICAgICAgICAgXCJcXHRmb3IgZGV0YWlscy5cIixcbiAgICAgICAgICAgIHR5cGU6IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5OT19MSU5FX0JSRUFLU19GTEFHUyxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB3YXJuaW5ncztcbn1cbmV4cG9ydCBmdW5jdGlvbiBjbG9uZUVtcHR5R3JvdXBzKGVtcHR5R3JvdXBzKSB7XG4gICAgY29uc3QgY2xvbmVkUmVzdWx0ID0ge307XG4gICAgY29uc3QgZ3JvdXBLZXlzID0ga2V5cyhlbXB0eUdyb3Vwcyk7XG4gICAgZm9yRWFjaChncm91cEtleXMsIChjdXJyS2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGN1cnJHcm91cFZhbHVlID0gZW1wdHlHcm91cHNbY3VycktleV07XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgIGlmIChpc0FycmF5KGN1cnJHcm91cFZhbHVlKSkge1xuICAgICAgICAgICAgY2xvbmVkUmVzdWx0W2N1cnJLZXldID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb25lZFJlc3VsdDtcbn1cbi8vIFRPRE86IHJlZmFjdG9yIHRvIGF2b2lkIGR1cGxpY2F0aW9uXG5leHBvcnQgZnVuY3Rpb24gaXNDdXN0b21QYXR0ZXJuKHRva2VuVHlwZSkge1xuICAgIGNvbnN0IHBhdHRlcm4gPSB0b2tlblR5cGUuUEFUVEVSTjtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChpc1JlZ0V4cChwYXR0ZXJuKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRnVuY3Rpb24ocGF0dGVybikpIHtcbiAgICAgICAgLy8gQ3VzdG9tUGF0dGVybk1hdGNoZXJGdW5jIC0gY3VzdG9tIHBhdHRlcm5zIGRvIG5vdCByZXF1aXJlIGFueSB0cmFuc2Zvcm1hdGlvbnMsIG9ubHkgd3JhcHBpbmcgaW4gYSBSZWdFeHAgTGlrZSBvYmplY3RcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhcyhwYXR0ZXJuLCBcImV4ZWNcIikpIHtcbiAgICAgICAgLy8gSUN1c3RvbVBhdHRlcm5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzU3RyaW5nKHBhdHRlcm4pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGlzU2hvcnRQYXR0ZXJuKHBhdHRlcm4pIHtcbiAgICBpZiAoaXNTdHJpbmcocGF0dGVybikgJiYgcGF0dGVybi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHBhdHRlcm4uY2hhckNvZGVBdCgwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEZhc3RlciB0aGFuIHVzaW5nIGEgUmVnRXhwIGZvciBkZWZhdWx0IG5ld2xpbmUgZGV0ZWN0aW9uIGR1cmluZyBsZXhpbmcuXG4gKi9cbmV4cG9ydCBjb25zdCBMaW5lVGVybWluYXRvck9wdGltaXplZFRlc3RlciA9IHtcbiAgICAvLyBpbXBsZW1lbnRzIC9cXG58XFxyXFxuPy9nLnRlc3RcbiAgICB0ZXN0OiBmdW5jdGlvbiAodGV4dCkge1xuICAgICAgICBjb25zdCBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMubGFzdEluZGV4OyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBpZiAoYyA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxhc3RJbmRleCA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYyA9PT0gMTMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGV4dC5jaGFyQ29kZUF0KGkgKyAxKSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sYXN0SW5kZXggPSBpICsgMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGFzdEluZGV4ID0gaSArIDE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGxhc3RJbmRleDogMCxcbn07XG5mdW5jdGlvbiBjaGVja0xpbmVCcmVha3NJc3N1ZXModG9rVHlwZSwgbGluZVRlcm1pbmF0b3JDaGFyQ29kZXMpIHtcbiAgICBpZiAoaGFzKHRva1R5cGUsIFwiTElORV9CUkVBS1NcIikpIHtcbiAgICAgICAgLy8gaWYgdGhlIHVzZXIgZXhwbGljaXRseSBkZWNsYXJlZCB0aGUgbGluZV9icmVha3Mgb3B0aW9uIHdlIHdpbGwgcmVzcGVjdCB0aGVpciBjaG9pY2VcbiAgICAgICAgLy8gYW5kIGFzc3VtZSBpdCBpcyBjb3JyZWN0LlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICBpZiAoaXNSZWdFeHAodG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiB3aHkgaXMgdGhlIGNhc3Rpbmcgc3VkZGVubHkgbmVlZGVkP1xuICAgICAgICAgICAgICAgIGNhbk1hdGNoQ2hhckNvZGUobGluZVRlcm1pbmF0b3JDaGFyQ29kZXMsIHRva1R5cGUuUEFUVEVSTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gdG8gdGVzdCB0aGlzIHdlIHdvdWxkIGhhdmUgdG8gbW9jayA8Y2FuTWF0Y2hDaGFyQ29kZT4gdG8gdGhyb3cgYW4gZXJyb3IgKi9cbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpc3N1ZTogTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlLklERU5USUZZX1RFUk1JTkFUT1IsXG4gICAgICAgICAgICAgICAgICAgIGVyck1zZzogZS5tZXNzYWdlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcodG9rVHlwZS5QQVRURVJOKSkge1xuICAgICAgICAgICAgLy8gc3RyaW5nIGxpdGVyYWwgcGF0dGVybnMgY2FuIGFsd2F5cyBiZSBhbmFseXplZCB0byBkZXRlY3QgbGluZSB0ZXJtaW5hdG9yIHVzYWdlXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDdXN0b21QYXR0ZXJuKHRva1R5cGUpKSB7XG4gICAgICAgICAgICAvLyBjdXN0b20gdG9rZW4gdHlwZXNcbiAgICAgICAgICAgIHJldHVybiB7IGlzc3VlOiBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuQ1VTVE9NX0xJTkVfQlJFQUsgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYnVpbGRMaW5lQnJlYWtJc3N1ZU1lc3NhZ2UodG9rVHlwZSwgZGV0YWlscykge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGRldGFpbHMuaXNzdWUgPT09IExleGVyRGVmaW5pdGlvbkVycm9yVHlwZS5JREVOVElGWV9URVJNSU5BVE9SKSB7XG4gICAgICAgIHJldHVybiAoXCJXYXJuaW5nOiB1bmFibGUgdG8gaWRlbnRpZnkgbGluZSB0ZXJtaW5hdG9yIHVzYWdlIGluIHBhdHRlcm4uXFxuXCIgK1xuICAgICAgICAgICAgYFxcdFRoZSBwcm9ibGVtIGlzIGluIHRoZSA8JHt0b2tUeXBlLm5hbWV9PiBUb2tlbiBUeXBlXFxuYCArXG4gICAgICAgICAgICBgXFx0IFJvb3QgY2F1c2U6ICR7ZGV0YWlscy5lcnJNc2d9LlxcbmAgK1xuICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNJREVOVElGWV9URVJNSU5BVE9SXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkZXRhaWxzLmlzc3VlID09PSBMZXhlckRlZmluaXRpb25FcnJvclR5cGUuQ1VTVE9NX0xJTkVfQlJFQUspIHtcbiAgICAgICAgcmV0dXJuIChcIldhcm5pbmc6IEEgQ3VzdG9tIFRva2VuIFBhdHRlcm4gc2hvdWxkIHNwZWNpZnkgdGhlIDxsaW5lX2JyZWFrcz4gb3B0aW9uLlxcblwiICtcbiAgICAgICAgICAgIGBcXHRUaGUgcHJvYmxlbSBpcyBpbiB0aGUgPCR7dG9rVHlwZS5uYW1lfT4gVG9rZW4gVHlwZVxcbmAgK1xuICAgICAgICAgICAgXCJcXHRGb3IgZGV0YWlscyBTZWU6IGh0dHBzOi8vY2hldnJvdGFpbi5pby9kb2NzL2d1aWRlL3Jlc29sdmluZ19sZXhlcl9lcnJvcnMuaHRtbCNDVVNUT01fTElORV9CUkVBS1wiKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IEVycm9yKFwibm9uIGV4aGF1c3RpdmUgbWF0Y2hcIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q2hhckNvZGVzKGNoYXJzT3JDb2Rlcykge1xuICAgIGNvbnN0IGNoYXJDb2RlcyA9IG1hcChjaGFyc09yQ29kZXMsIChudW1PclN0cmluZykgPT4ge1xuICAgICAgICBpZiAoaXNTdHJpbmcobnVtT3JTdHJpbmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtT3JTdHJpbmcuY2hhckNvZGVBdCgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBudW1PclN0cmluZztcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBjaGFyQ29kZXM7XG59XG5mdW5jdGlvbiBhZGRUb01hcE9mQXJyYXlzKG1hcCwga2V5LCB2YWx1ZSkge1xuICAgIGlmIChtYXBba2V5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1hcFtrZXldID0gW3ZhbHVlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1hcFtrZXldLnB1c2godmFsdWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjb25zdCBtaW5PcHRpbWl6YXRpb25WYWwgPSAyNTY7XG4vKipcbiAqIFdlIGFyZSBtYXBwaW5nIGNoYXJDb2RlIGFib3ZlIEFTQ0kgKDI1NikgaW50byBidWNrZXRzIGVhY2ggaW4gdGhlIHNpemUgb2YgMjU2LlxuICogVGhpcyBpcyBiZWNhdXNlIEFTQ0kgYXJlIHRoZSBtb3N0IGNvbW1vbiBzdGFydCBjaGFycyBzbyBlYWNoIG9uZSBvZiB0aG9zZSB3aWxsIGdldCBpdHMgb3duXG4gKiBwb3NzaWJsZSB0b2tlbiBjb25maWdzIHZlY3Rvci5cbiAqXG4gKiBUb2tlbnMgc3RhcnRpbmcgd2l0aCBjaGFyQ29kZXMgXCJhYm92ZVwiIEFTQ0kgYXJlIHVuY29tbW9uLCBzbyB3ZSBjYW4gXCJhZmZvcmRcIlxuICogdG8gcGxhY2UgdGhlc2UgaW50byBidWNrZXRzIG9mIHBvc3NpYmxlIHRva2VuIGNvbmZpZ3MsIFdoYXQgd2UgZ2FpbiBmcm9tXG4gKiB0aGlzIGlzIGF2b2lkaW5nIHRoZSBjYXNlIG9mIGNyZWF0aW5nIGFuIG9wdGltaXphdGlvbiAnY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZydcbiAqIHdoaWNoIHdvdWxkIGNvbnRhaW4gMTAsMDAwKyBhcnJheXMgb2Ygc21hbGwgc2l6ZSAoZS5nIHVuaWNvZGUgSWRlbnRpZmllcnMgc2NlbmFyaW8pLlxuICogT3VyICdjaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnJyBtYXggc2l6ZSB3aWxsIG5vdyBiZTpcbiAqIDI1NiArICgyXjE2IC8gMl44KSAtIDEgPT09IDUxMVxuICpcbiAqIG5vdGUgdGhlIGhhY2sgZm9yIGZhc3QgZGl2aXNpb24gaW50ZWdlciBwYXJ0IGV4dHJhY3Rpb25cbiAqIFNlZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQyMjg1MjhcbiAqL1xubGV0IGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXAgPSBbXTtcbmV4cG9ydCBmdW5jdGlvbiBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgoY2hhckNvZGUpIHtcbiAgICByZXR1cm4gY2hhckNvZGUgPCBtaW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgPyBjaGFyQ29kZVxuICAgICAgICA6IGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXBbY2hhckNvZGVdO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgY29tcHJvbWlzZSBiZXR3ZWVuIGNvbGQgc3RhcnQgLyBob3QgcnVubmluZyBwZXJmb3JtYW5jZVxuICogQ3JlYXRpbmcgdGhpcyBhcnJheSB0YWtlcyB+M21zIG9uIGEgbW9kZXJuIG1hY2hpbmUsXG4gKiBCdXQgaWYgd2UgcGVyZm9ybSB0aGUgY29tcHV0YXRpb24gYXQgcnVudGltZSBhcyBuZWVkZWQgdGhlIENTUyBMZXhlciBiZW5jaG1hcmtcbiAqIHBlcmZvcm1hbmNlIGRlZ3JhZGVzIGJ5IH4xMCVcbiAqXG4gKiBUT0RPOiBQZXJoYXBzIGl0IHNob3VsZCBiZSBsYXp5IGluaXRpYWxpemVkIG9ubHkgaWYgYSBjaGFyQ29kZSA+IDI1NSBpcyB1c2VkLlxuICovXG5mdW5jdGlvbiBpbml0Q2hhckNvZGVUb09wdGltaXplZEluZGV4TWFwKCkge1xuICAgIGlmIChpc0VtcHR5KGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXApKSB7XG4gICAgICAgIGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXAgPSBuZXcgQXJyYXkoNjU1MzYpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY1NTM2OyBpKyspIHtcbiAgICAgICAgICAgIGNoYXJDb2RlVG9PcHRpbWl6ZWRJZHhNYXBbaV0gPSBpID4gMjU1ID8gMjU1ICsgfn4oaSAvIDI1NSkgOiBpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXIuanMubWFwIiwiZXhwb3J0IGNvbnN0IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIgPSB7XG4gICAgYnVpbGRVbmFibGVUb1BvcExleGVyTW9kZU1lc3NhZ2UodG9rZW4pIHtcbiAgICAgICAgcmV0dXJuIGBVbmFibGUgdG8gcG9wIExleGVyIE1vZGUgYWZ0ZXIgZW5jb3VudGVyaW5nIFRva2VuIC0+JHt0b2tlbi5pbWFnZX08LSBUaGUgTW9kZSBTdGFjayBpcyBlbXB0eWA7XG4gICAgfSxcbiAgICBidWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZShmdWxsVGV4dCwgc3RhcnRPZmZzZXQsIGxlbmd0aCwgbGluZSwgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiAoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyOiAtPiR7ZnVsbFRleHQuY2hhckF0KHN0YXJ0T2Zmc2V0KX08LSBhdCBvZmZzZXQ6ICR7c3RhcnRPZmZzZXR9LGAgKyBgIHNraXBwZWQgJHtsZW5ndGh9IGNoYXJhY3RlcnMuYCk7XG4gICAgfSxcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1sZXhlcl9lcnJvcnNfcHVibGljLmpzLm1hcCIsImltcG9ydCB7IGFuYWx5emVUb2tlblR5cGVzLCBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgsIGNsb25lRW1wdHlHcm91cHMsIERFRkFVTFRfTU9ERSwgTGluZVRlcm1pbmF0b3JPcHRpbWl6ZWRUZXN0ZXIsIHBlcmZvcm1SdW50aW1lQ2hlY2tzLCBwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3MsIFNVUFBPUlRfU1RJQ0tZLCB2YWxpZGF0ZVBhdHRlcm5zLCB9IGZyb20gXCIuL2xleGVyLmpzXCI7XG5pbXBvcnQgeyBhc3NpZ24sIGNsb25lLCBmb3JFYWNoLCBpZGVudGl0eSwgaXNBcnJheSwgaXNFbXB0eSwgaXNVbmRlZmluZWQsIGtleXMsIGxhc3QsIG1hcCwgbm9vcCwgcmVkdWNlLCByZWplY3QsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgUFJJTlRfV0FSTklORywgdGltZXIsIHRvRmFzdFByb3BlcnRpZXMgfSBmcm9tIFwiQGNoZXZyb3RhaW4vdXRpbHNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzIH0gZnJvbSBcIi4vdG9rZW5zLmpzXCI7XG5pbXBvcnQgeyBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyIH0gZnJvbSBcIi4vbGV4ZXJfZXJyb3JzX3B1YmxpYy5qc1wiO1xuaW1wb3J0IHsgY2xlYXJSZWdFeHBQYXJzZXJDYWNoZSB9IGZyb20gXCIuL3JlZ19leHBfcGFyc2VyLmpzXCI7XG5leHBvcnQgdmFyIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZTtcbihmdW5jdGlvbiAoTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlKSB7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1JU1NJTkdfUEFUVEVSTlwiXSA9IDBdID0gXCJNSVNTSU5HX1BBVFRFUk5cIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiSU5WQUxJRF9QQVRURVJOXCJdID0gMV0gPSBcIklOVkFMSURfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJFT0lfQU5DSE9SX0ZPVU5EXCJdID0gMl0gPSBcIkVPSV9BTkNIT1JfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVU5TVVBQT1JURURfRkxBR1NfRk9VTkRcIl0gPSAzXSA9IFwiVU5TVVBQT1JURURfRkxBR1NfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRFVQTElDQVRFX1BBVFRFUk5TX0ZPVU5EXCJdID0gNF0gPSBcIkRVUExJQ0FURV9QQVRURVJOU19GT1VORFwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJJTlZBTElEX0dST1VQX1RZUEVfRk9VTkRcIl0gPSA1XSA9IFwiSU5WQUxJRF9HUk9VUF9UWVBFX0ZPVU5EXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlBVU0hfTU9ERV9ET0VTX05PVF9FWElTVFwiXSA9IDZdID0gXCJQVVNIX01PREVfRE9FU19OT1RfRVhJU1RcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9XSVRIT1VUX0RFRkFVTFRfTU9ERVwiXSA9IDddID0gXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfREVGQVVMVF9NT0RFXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIk1VTFRJX01PREVfTEVYRVJfV0lUSE9VVF9NT0RFU19QUk9QRVJUWVwiXSA9IDhdID0gXCJNVUxUSV9NT0RFX0xFWEVSX1dJVEhPVVRfTU9ERVNfUFJPUEVSVFlcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcIl0gPSA5XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9ERUZBVUxUX01PREVfVkFMVUVfRE9FU19OT1RfRVhJU1RcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiTEVYRVJfREVGSU5JVElPTl9DQU5OT1RfQ09OVEFJTl9VTkRFRklORURcIl0gPSAxMF0gPSBcIkxFWEVSX0RFRklOSVRJT05fQ0FOTk9UX0NPTlRBSU5fVU5ERUZJTkVEXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIlNPSV9BTkNIT1JfRk9VTkRcIl0gPSAxMV0gPSBcIlNPSV9BTkNIT1JfRk9VTkRcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiRU1QVFlfTUFUQ0hfUEFUVEVSTlwiXSA9IDEyXSA9IFwiRU1QVFlfTUFUQ0hfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJOT19MSU5FX0JSRUFLU19GTEFHU1wiXSA9IDEzXSA9IFwiTk9fTElORV9CUkVBS1NfRkxBR1NcIjtcbiAgICBMZXhlckRlZmluaXRpb25FcnJvclR5cGVbTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW1wiVU5SRUFDSEFCTEVfUEFUVEVSTlwiXSA9IDE0XSA9IFwiVU5SRUFDSEFCTEVfUEFUVEVSTlwiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJJREVOVElGWV9URVJNSU5BVE9SXCJdID0gMTVdID0gXCJJREVOVElGWV9URVJNSU5BVE9SXCI7XG4gICAgTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlW0xleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtcIkNVU1RPTV9MSU5FX0JSRUFLXCJdID0gMTZdID0gXCJDVVNUT01fTElORV9CUkVBS1wiO1xuICAgIExleGVyRGVmaW5pdGlvbkVycm9yVHlwZVtMZXhlckRlZmluaXRpb25FcnJvclR5cGVbXCJNVUxUSV9NT0RFX0xFWEVSX0xPTkdFUl9BTFRfTk9UX0lOX0NVUlJFTlRfTU9ERVwiXSA9IDE3XSA9IFwiTVVMVElfTU9ERV9MRVhFUl9MT05HRVJfQUxUX05PVF9JTl9DVVJSRU5UX01PREVcIjtcbn0pKExleGVyRGVmaW5pdGlvbkVycm9yVHlwZSB8fCAoTGV4ZXJEZWZpbml0aW9uRXJyb3JUeXBlID0ge30pKTtcbmNvbnN0IERFRkFVTFRfTEVYRVJfQ09ORklHID0ge1xuICAgIGRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nOiBmYWxzZSxcbiAgICBwb3NpdGlvblRyYWNraW5nOiBcImZ1bGxcIixcbiAgICBsaW5lVGVybWluYXRvcnNQYXR0ZXJuOiAvXFxufFxcclxcbj8vZyxcbiAgICBsaW5lVGVybWluYXRvckNoYXJhY3RlcnM6IFtcIlxcblwiLCBcIlxcclwiXSxcbiAgICBlbnN1cmVPcHRpbWl6YXRpb25zOiBmYWxzZSxcbiAgICBzYWZlTW9kZTogZmFsc2UsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IGRlZmF1bHRMZXhlckVycm9yUHJvdmlkZXIsXG4gICAgdHJhY2VJbml0UGVyZjogZmFsc2UsXG4gICAgc2tpcFZhbGlkYXRpb25zOiBmYWxzZSxcbiAgICByZWNvdmVyeUVuYWJsZWQ6IHRydWUsXG59O1xuT2JqZWN0LmZyZWV6ZShERUZBVUxUX0xFWEVSX0NPTkZJRyk7XG5leHBvcnQgY2xhc3MgTGV4ZXIge1xuICAgIGNvbnN0cnVjdG9yKGxleGVyRGVmaW5pdGlvbiwgY29uZmlnID0gREVGQVVMVF9MRVhFUl9DT05GSUcpIHtcbiAgICAgICAgdGhpcy5sZXhlckRlZmluaXRpb24gPSBsZXhlckRlZmluaXRpb247XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzID0gW107XG4gICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uV2FybmluZyA9IFtdO1xuICAgICAgICB0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZyA9IHt9O1xuICAgICAgICB0aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSB7fTtcbiAgICAgICAgdGhpcy5tb2RlcyA9IFtdO1xuICAgICAgICB0aGlzLmVtcHR5R3JvdXBzID0ge307XG4gICAgICAgIHRoaXMudHJhY2tTdGFydExpbmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50cmFja0VuZExpbmVzID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5oYXNDdXN0b20gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jYW5Nb2RlQmVPcHRpbWl6ZWQgPSB7fTtcbiAgICAgICAgLy8gRHVwbGljYXRlZCBmcm9tIHRoZSBwYXJzZXIncyBwZXJmIHRyYWNlIHRyYWl0IHRvIGFsbG93IGZ1dHVyZSBleHRyYWN0aW9uXG4gICAgICAgIC8vIG9mIHRoZSBsZXhlciB0byBhIHNlcGFyYXRlIHBhY2thZ2UuXG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVCA9IChwaGFzZURlc2MsIHBoYXNlSW1wbCkgPT4ge1xuICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBvcHRpbWl6ZSB0aGlzIHVzaW5nIE5PT1AgcGF0dGVybiBiZWNhdXNlXG4gICAgICAgICAgICAvLyBJdCBpcyBub3QgY2FsbGVkIGluIGEgaG90IHNwb3QuLi5cbiAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdFBlcmYgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYWNlSW5pdEluZGVudCsrO1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGVudCA9IG5ldyBBcnJheSh0aGlzLnRyYWNlSW5pdEluZGVudCArIDEpLmpvaW4oXCJcXHRcIik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhY2VJbml0SW5kZW50IDwgdGhpcy50cmFjZUluaXRNYXhJZGVudCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgJHtpbmRlbnR9LS0+IDwke3BoYXNlRGVzY30+YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgdGltZSwgdmFsdWUgfSA9IHRpbWVyKHBoYXNlSW1wbCk7XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgLSBEaWZmaWN1bHQgdG8gcmVwcm9kdWNlIHNwZWNpZmljIHBlcmZvcm1hbmNlIGJlaGF2aW9yICg+MTBtcykgaW4gdGVzdHMgKi9cbiAgICAgICAgICAgICAgICBjb25zdCB0cmFjZU1ldGhvZCA9IHRpbWUgPiAxMCA/IGNvbnNvbGUud2FybiA6IGNvbnNvbGUubG9nO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNlSW5pdEluZGVudCA8IHRoaXMudHJhY2VJbml0TWF4SWRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2VNZXRob2QoYCR7aW5kZW50fTwtLSA8JHtwaGFzZURlc2N9PiB0aW1lOiAke3RpbWV9bXNgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFjZUluaXRJbmRlbnQtLTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGhhc2VJbXBsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJUaGUgc2Vjb25kIGFyZ3VtZW50IHRvIHRoZSBMZXhlciBjb25zdHJ1Y3RvciBpcyBub3cgYW4gSUxleGVyQ29uZmlnIE9iamVjdC5cXG5cIiArXG4gICAgICAgICAgICAgICAgXCJhIGJvb2xlYW4gMm5kIGFyZ3VtZW50IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdG9kbzogZGVmYXVsdHMgZnVuYz9cbiAgICAgICAgdGhpcy5jb25maWcgPSBhc3NpZ24oe30sIERFRkFVTFRfTEVYRVJfQ09ORklHLCBjb25maWcpO1xuICAgICAgICBjb25zdCB0cmFjZUluaXRWYWwgPSB0aGlzLmNvbmZpZy50cmFjZUluaXRQZXJmO1xuICAgICAgICBpZiAodHJhY2VJbml0VmFsID09PSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdE1heElkZW50ID0gSW5maW5pdHk7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiB0cmFjZUluaXRWYWwgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMudHJhY2VJbml0TWF4SWRlbnQgPSB0cmFjZUluaXRWYWw7XG4gICAgICAgICAgICB0aGlzLnRyYWNlSW5pdFBlcmYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhY2VJbml0SW5kZW50ID0gLTE7XG4gICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkxleGVyIENvbnN0cnVjdG9yXCIsICgpID0+IHtcbiAgICAgICAgICAgIGxldCBhY3R1YWxEZWZpbml0aW9uO1xuICAgICAgICAgICAgbGV0IGhhc09ubHlTaW5nbGVNb2RlID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcIkxleGVyIENvbmZpZyBoYW5kbGluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4gPT09XG4gICAgICAgICAgICAgICAgICAgIERFRkFVTFRfTEVYRVJfQ09ORklHLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm4pIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3B0aW1pemVkIGJ1aWx0LWluIGltcGxlbWVudGF0aW9uIGZvciB0aGUgZGVmYXVsdHMgZGVmaW5pdGlvbiBvZiBsaW5lVGVybWluYXRvcnNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JzUGF0dGVybiA9IExpbmVUZXJtaW5hdG9yT3B0aW1pemVkVGVzdGVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycyA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgIERFRkFVTFRfTEVYRVJfQ09ORklHLmxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFcnJvcjogTWlzc2luZyA8bGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzPiBwcm9wZXJ0eSBvbiB0aGUgTGV4ZXIgY29uZmlnLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcdEZvciBkZXRhaWxzIFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI01JU1NJTkdfTElORV9URVJNX0NIQVJTXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjb25maWcuc2FmZU1vZGUgJiYgY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1wic2FmZU1vZGVcIiBhbmQgXCJlbnN1cmVPcHRpbWl6YXRpb25zXCIgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZS4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy50cmFja1N0YXJ0TGluZXMgPSAvZnVsbHxvbmx5U3RhcnQvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhY2tFbmRMaW5lcyA9IC9mdWxsL2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKTtcbiAgICAgICAgICAgICAgICAvLyBDb252ZXJ0IFNpbmdsZU1vZGVMZXhlckRlZmluaXRpb24gaW50byBhIElNdWx0aU1vZGVMZXhlckRlZmluaXRpb24uXG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkobGV4ZXJEZWZpbml0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZXM6IHsgZGVmYXVsdE1vZGU6IGNsb25lKGxleGVyRGVmaW5pdGlvbikgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHRNb2RlOiBERUZBVUxUX01PREUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBubyBjb252ZXJzaW9uIG5lZWRlZCwgaW5wdXQgc2hvdWxkIGFscmVhZHkgYmUgYSBJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uXG4gICAgICAgICAgICAgICAgICAgIGhhc09ubHlTaW5nbGVNb2RlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24gPSBjbG9uZShsZXhlckRlZmluaXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJwZXJmb3JtUnVudGltZUNoZWNrc1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzID0gdGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMuY29uY2F0KHBlcmZvcm1SdW50aW1lQ2hlY2tzKGFjdHVhbERlZmluaXRpb24sIHRoaXMudHJhY2tTdGFydExpbmVzLCB0aGlzLmNvbmZpZy5saW5lVGVybWluYXRvckNoYXJhY3RlcnMpKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJwZXJmb3JtV2FybmluZ1J1bnRpbWVDaGVja3NcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcgPSB0aGlzLmxleGVyRGVmaW5pdGlvbldhcm5pbmcuY29uY2F0KHBlcmZvcm1XYXJuaW5nUnVudGltZUNoZWNrcyhhY3R1YWxEZWZpbml0aW9uLCB0aGlzLnRyYWNrU3RhcnRMaW5lcywgdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBmb3IgZXh0cmEgcm9idXN0bmVzcyB0byBhdm9pZCB0aHJvd2luZyBhbiBub25lIGluZm9ybWF0aXZlIGVycm9yIG1lc3NhZ2VcbiAgICAgICAgICAgIGFjdHVhbERlZmluaXRpb24ubW9kZXMgPSBhY3R1YWxEZWZpbml0aW9uLm1vZGVzXG4gICAgICAgICAgICAgICAgPyBhY3R1YWxEZWZpbml0aW9uLm1vZGVzXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIC8vIGFuIGVycm9yIG9mIHVuZGVmaW5lZCBUb2tlblR5cGVzIHdpbGwgYmUgZGV0ZWN0ZWQgaW4gXCJwZXJmb3JtUnVudGltZUNoZWNrc1wiIGFib3ZlLlxuICAgICAgICAgICAgLy8gdGhpcyB0cmFuc2Zvcm1hdGlvbiBpcyB0byBpbmNyZWFzZSByb2J1c3RuZXNzIGluIHRoZSBjYXNlIG9mIHBhcnRpYWxseSBpbnZhbGlkIGxleGVyIGRlZmluaXRpb24uXG4gICAgICAgICAgICBmb3JFYWNoKGFjdHVhbERlZmluaXRpb24ubW9kZXMsIChjdXJyTW9kZVZhbHVlLCBjdXJyTW9kZU5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBhY3R1YWxEZWZpbml0aW9uLm1vZGVzW2N1cnJNb2RlTmFtZV0gPSByZWplY3QoY3Vyck1vZGVWYWx1ZSwgKGN1cnJUb2tUeXBlKSA9PiBpc1VuZGVmaW5lZChjdXJyVG9rVHlwZSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBhbGxNb2RlTmFtZXMgPSBrZXlzKGFjdHVhbERlZmluaXRpb24ubW9kZXMpO1xuICAgICAgICAgICAgZm9yRWFjaChhY3R1YWxEZWZpbml0aW9uLm1vZGVzLCAoY3Vyck1vZERlZiwgY3Vyck1vZE5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoYE1vZGU6IDwke2N1cnJNb2ROYW1lfT4gcHJvY2Vzc2luZ2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tb2Rlcy5wdXNoKGN1cnJNb2ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnNraXBWYWxpZGF0aW9ucyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChgdmFsaWRhdGVQYXR0ZXJuc2AsICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycyA9IHRoaXMubGV4ZXJEZWZpbml0aW9uRXJyb3JzLmNvbmNhdCh2YWxpZGF0ZVBhdHRlcm5zKGN1cnJNb2REZWYsIGFsbE1vZGVOYW1lcykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgZGVmaW5pdGlvbiBlcnJvcnMgd2VyZSBlbmNvdW50ZXJlZCwgdGhlIGFuYWx5c2lzIHBoYXNlIG1heSBmYWlsIHVuZXhwZWN0ZWRseS9cbiAgICAgICAgICAgICAgICAgICAgLy8gQ29uc2lkZXJpbmcgYSBsZXhlciB3aXRoIGRlZmluaXRpb24gZXJyb3JzIG1heSBuZXZlciBiZSB1c2VkLCB0aGVyZSBpcyBubyBwb2ludFxuICAgICAgICAgICAgICAgICAgICAvLyB0byBwZXJmb3JtaW5nIHRoZSBhbmFseXNpcyBhbnlob3cuLi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRW1wdHkodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhdWdtZW50VG9rZW5UeXBlcyhjdXJyTW9kRGVmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBjdXJyQW5hbHl6ZVJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChgYW5hbHl6ZVRva2VuVHlwZXNgLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHQgPSBhbmFseXplVG9rZW5UeXBlcyhjdXJyTW9kRGVmLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVUZXJtaW5hdG9yQ2hhcmFjdGVyczogdGhpcy5jb25maWcubGluZVRlcm1pbmF0b3JDaGFyYWN0ZXJzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvblRyYWNraW5nOiBjb25maWcucG9zaXRpb25UcmFja2luZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5zdXJlT3B0aW1pemF0aW9uczogY29uZmlnLmVuc3VyZU9wdGltaXphdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNhZmVNb2RlOiBjb25maWcuc2FmZU1vZGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNlcjogdGhpcy5UUkFDRV9JTklULFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tjdXJyTW9kTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0LnBhdHRlcm5JZHhUb0NvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tjdXJyTW9kTmFtZV0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJBbmFseXplUmVzdWx0LmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtcHR5R3JvdXBzID0gYXNzaWduKHt9LCB0aGlzLmVtcHR5R3JvdXBzLCBjdXJyQW5hbHl6ZVJlc3VsdC5lbXB0eUdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc0N1c3RvbSA9IGN1cnJBbmFseXplUmVzdWx0Lmhhc0N1c3RvbSB8fCB0aGlzLmhhc0N1c3RvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkW2N1cnJNb2ROYW1lXSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckFuYWx5emVSZXN1bHQuY2FuQmVPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kZWZhdWx0TW9kZSA9IGFjdHVhbERlZmluaXRpb24uZGVmYXVsdE1vZGU7XG4gICAgICAgICAgICBpZiAoIWlzRW1wdHkodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuY29uZmlnLmRlZmVyRGVmaW5pdGlvbkVycm9yc0hhbmRsaW5nKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsRXJyTWVzc2FnZXMgPSBtYXAodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMsIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhbGxFcnJNZXNzYWdlc1N0cmluZyA9IGFsbEVyck1lc3NhZ2VzLmpvaW4oXCItLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcblwiKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvcnMgZGV0ZWN0ZWQgaW4gZGVmaW5pdGlvbiBvZiBMZXhlcjpcXG5cIiArIGFsbEVyck1lc3NhZ2VzU3RyaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE9ubHkgcHJpbnQgd2FybmluZyBpZiB0aGVyZSBhcmUgbm8gZXJyb3JzLCBUaGlzIHdpbGwgYXZvaWQgcGxcbiAgICAgICAgICAgIGZvckVhY2godGhpcy5sZXhlckRlZmluaXRpb25XYXJuaW5nLCAod2FybmluZ0Rlc2NyaXB0b3IpID0+IHtcbiAgICAgICAgICAgICAgICBQUklOVF9XQVJOSU5HKHdhcm5pbmdEZXNjcmlwdG9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJDaG9vc2luZyBzdWItbWV0aG9kcyBpbXBsZW1lbnRhdGlvbnNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIENob29zZSB0aGUgcmVsZXZhbnQgaW50ZXJuYWwgaW1wbGVtZW50YXRpb25zIGZvciB0aGlzIHNwZWNpZmljIHBhcnNlci5cbiAgICAgICAgICAgICAgICAvLyBUaGVzZSBpbXBsZW1lbnRhdGlvbnMgc2hvdWxkIGJlIGluLWxpbmVkIGJ5IHRoZSBKYXZhU2NyaXB0IGVuZ2luZVxuICAgICAgICAgICAgICAgIC8vIHRvIHByb3ZpZGUgb3B0aW1hbCBwZXJmb3JtYW5jZSBpbiBlYWNoIHNjZW5hcmlvLlxuICAgICAgICAgICAgICAgIGlmIChTVVBQT1JUX1NUSUNLWSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNob3BJbnB1dCA9IGlkZW50aXR5O1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaFdpdGhUZXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGVMYXN0SW5kZXggPSBub29wO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaFdpdGhFeGVjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaGFzT25seVNpbmdsZU1vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVNb2RlcyA9IG5vb3A7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrU3RhcnRMaW5lcyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wdXRlTmV3Q29sdW1uID0gaWRlbnRpdHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYWNrRW5kTGluZXMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24gPSBub29wO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoL2Z1bGwvaS50ZXN0KHRoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlVG9rZW5JbnN0YW5jZSA9IHRoaXMuY3JlYXRlRnVsbFRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvb25seVN0YXJ0L2kudGVzdCh0aGlzLmNvbmZpZy5wb3NpdGlvblRyYWNraW5nKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZVRva2VuSW5zdGFuY2UgPSB0aGlzLmNyZWF0ZVN0YXJ0T25seVRva2VuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgvb25seU9mZnNldC9pLnRlc3QodGhpcy5jb25maWcucG9zaXRpb25UcmFja2luZykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlID0gdGhpcy5jcmVhdGVPZmZzZXRPbmx5VG9rZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgSW52YWxpZCA8cG9zaXRpb25UcmFja2luZz4gY29uZmlnIG9wdGlvbjogXCIke3RoaXMuY29uZmlnLnBvc2l0aW9uVHJhY2tpbmd9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaGFzQ3VzdG9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkVG9rZW4gPSB0aGlzLmFkZFRva2VuVXNpbmdQdXNoO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVBheWxvYWQgPSB0aGlzLmhhbmRsZVBheWxvYWRXaXRoQ3VzdG9tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRUb2tlbiA9IHRoaXMuYWRkVG9rZW5Vc2luZ01lbWJlckFjY2VzcztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVQYXlsb2FkID0gdGhpcy5oYW5kbGVQYXlsb2FkTm9DdXN0b207XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJGYWlsZWQgT3B0aW1pemF0aW9uIFdhcm5pbmdzXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB1bk9wdGltaXplZE1vZGVzID0gcmVkdWNlKHRoaXMuY2FuTW9kZUJlT3B0aW1pemVkLCAoY2Fubm90QmVPcHRpbWl6ZWQsIGNhbkJlT3B0aW1pemVkLCBtb2RlTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuQmVPcHRpbWl6ZWQgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5ub3RCZU9wdGltaXplZC5wdXNoKG1vZGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2Fubm90QmVPcHRpbWl6ZWQ7XG4gICAgICAgICAgICAgICAgfSwgW10pO1xuICAgICAgICAgICAgICAgIGlmIChjb25maWcuZW5zdXJlT3B0aW1pemF0aW9ucyAmJiAhaXNFbXB0eSh1bk9wdGltaXplZE1vZGVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihgTGV4ZXIgTW9kZXM6IDwgJHt1bk9wdGltaXplZE1vZGVzLmpvaW4oXCIsIFwiKX0gPiBjYW5ub3QgYmUgb3B0aW1pemVkLlxcbmAgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1xcdCBEaXNhYmxlIHRoZSBcImVuc3VyZU9wdGltaXphdGlvbnNcIiBsZXhlciBjb25maWcgZmxhZyB0byBzaWxlbnRseSBpZ25vcmUgdGhpcyBhbmQgcnVuIHRoZSBsZXhlciBpbiBhbiB1bi1vcHRpbWl6ZWQgbW9kZS5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0IE9yIGluc3BlY3QgdGhlIGNvbnNvbGUgbG9nIGZvciBkZXRhaWxzIG9uIGhvdyB0byByZXNvbHZlIHRoZXNlIGlzc3Vlcy5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLlRSQUNFX0lOSVQoXCJjbGVhclJlZ0V4cFBhcnNlckNhY2hlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclJlZ0V4cFBhcnNlckNhY2hlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuVFJBQ0VfSU5JVChcInRvRmFzdFByb3BlcnRpZXNcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRvRmFzdFByb3BlcnRpZXModGhpcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRva2VuaXplKHRleHQsIGluaXRpYWxNb2RlID0gdGhpcy5kZWZhdWx0TW9kZSkge1xuICAgICAgICBpZiAoIWlzRW1wdHkodGhpcy5sZXhlckRlZmluaXRpb25FcnJvcnMpKSB7XG4gICAgICAgICAgICBjb25zdCBhbGxFcnJNZXNzYWdlcyA9IG1hcCh0aGlzLmxleGVyRGVmaW5pdGlvbkVycm9ycywgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFsbEVyck1lc3NhZ2VzU3RyaW5nID0gYWxsRXJyTWVzc2FnZXMuam9pbihcIi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXCIpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5hYmxlIHRvIFRva2VuaXplIGJlY2F1c2UgRXJyb3JzIGRldGVjdGVkIGluIGRlZmluaXRpb24gb2YgTGV4ZXI6XFxuXCIgK1xuICAgICAgICAgICAgICAgIGFsbEVyck1lc3NhZ2VzU3RyaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50b2tlbml6ZUludGVybmFsKHRleHQsIGluaXRpYWxNb2RlKTtcbiAgICB9XG4gICAgLy8gVGhlcmUgaXMgcXVpdGUgYSBiaXQgb2YgZHVwbGljYXRpb24gYmV0d2VlbiB0aGlzIGFuZCBcInRva2VuaXplSW50ZXJuYWxMYXp5XCJcbiAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsIGR1ZSB0byBwZXJmb3JtYW5jZSBjb25zaWRlcmF0aW9ucy5cbiAgICAvLyB0aGlzIG1ldGhvZCBhbHNvIHVzZWQgcXVpdGUgYSBiaXQgb2YgYCFgIG5vbmUgbnVsbCBhc3NlcnRpb25zIGJlY2F1c2UgaXQgaXMgdG9vIG9wdGltaXplZFxuICAgIC8vIGZvciBgdHNjYCB0byBhbHdheXMgdW5kZXJzdGFuZCBpdCBpcyBcInNhZmVcIlxuICAgIHRva2VuaXplSW50ZXJuYWwodGV4dCwgaW5pdGlhbE1vZGUpIHtcbiAgICAgICAgbGV0IGksIGosIGssIG1hdGNoQWx0SW1hZ2UsIGxvbmdlckFsdCwgbWF0Y2hlZEltYWdlLCBwYXlsb2FkLCBhbHRQYXlsb2FkLCBpbWFnZUxlbmd0aCwgZ3JvdXAsIHRva1R5cGUsIG5ld1Rva2VuLCBlcnJMZW5ndGgsIGRyb3BwZWRDaGFyLCBtc2csIG1hdGNoO1xuICAgICAgICBjb25zdCBvcmdUZXh0ID0gdGV4dDtcbiAgICAgICAgY29uc3Qgb3JnTGVuZ3RoID0gb3JnVGV4dC5sZW5ndGg7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBsZXQgbWF0Y2hlZFRva2Vuc0luZGV4ID0gMDtcbiAgICAgICAgLy8gaW5pdGlhbGl6aW5nIHRoZSB0b2tlbnNBcnJheSB0byB0aGUgXCJndWVzc2VkXCIgc2l6ZS5cbiAgICAgICAgLy8gZ3Vlc3NpbmcgdG9vIGxpdHRsZSB3aWxsIHN0aWxsIHJlZHVjZSB0aGUgbnVtYmVyIG9mIGFycmF5IHJlLXNpemVzIG9uIHB1c2hlcy5cbiAgICAgICAgLy8gZ3Vlc3NpbmcgdG9vIGxhcmdlIChUZXN0ZWQgYnkgZ3Vlc3NpbmcgeDQgdG9vIGxhcmdlKSBtYXkgY29zdCBhIGJpdCBtb3JlIG9mIG1lbW9yeVxuICAgICAgICAvLyBidXQgd291bGQgc3RpbGwgaGF2ZSBhIGZhc3RlciBydW50aW1lIGJ5IGF2b2lkaW5nIChBbGwgYnV0IG9uZSkgYXJyYXkgcmVzaXppbmcuXG4gICAgICAgIGNvbnN0IGd1ZXNzZWROdW1iZXJPZlRva2VucyA9IHRoaXMuaGFzQ3VzdG9tXG4gICAgICAgICAgICA/IDAgLy8gd2lsbCBicmVhayBjdXN0b20gdG9rZW4gcGF0dGVybiBBUElzIHRoZSBtYXRjaGVkVG9rZW5zIGFycmF5IHdpbGwgY29udGFpbiB1bmRlZmluZWQgZWxlbWVudHMuXG4gICAgICAgICAgICA6IE1hdGguZmxvb3IodGV4dC5sZW5ndGggLyAxMCk7XG4gICAgICAgIGNvbnN0IG1hdGNoZWRUb2tlbnMgPSBuZXcgQXJyYXkoZ3Vlc3NlZE51bWJlck9mVG9rZW5zKTtcbiAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgIGxldCBsaW5lID0gdGhpcy50cmFja1N0YXJ0TGluZXMgPyAxIDogdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29sdW1uID0gdGhpcy50cmFja1N0YXJ0TGluZXMgPyAxIDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBncm91cHMgPSBjbG9uZUVtcHR5R3JvdXBzKHRoaXMuZW1wdHlHcm91cHMpO1xuICAgICAgICBjb25zdCB0cmFja0xpbmVzID0gdGhpcy50cmFja1N0YXJ0TGluZXM7XG4gICAgICAgIGNvbnN0IGxpbmVUZXJtaW5hdG9yUGF0dGVybiA9IHRoaXMuY29uZmlnLmxpbmVUZXJtaW5hdG9yc1BhdHRlcm47XG4gICAgICAgIGxldCBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gMDtcbiAgICAgICAgbGV0IHBhdHRlcm5JZHhUb0NvbmZpZyA9IFtdO1xuICAgICAgICBsZXQgY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgPSBbXTtcbiAgICAgICAgY29uc3QgbW9kZVN0YWNrID0gW107XG4gICAgICAgIGNvbnN0IGVtcHR5QXJyYXkgPSBbXTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZShlbXB0eUFycmF5KTtcbiAgICAgICAgbGV0IGdldFBvc3NpYmxlUGF0dGVybnM7XG4gICAgICAgIGZ1bmN0aW9uIGdldFBvc3NpYmxlUGF0dGVybnNTbG93KCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdHRlcm5JZHhUb0NvbmZpZztcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBnZXRQb3NzaWJsZVBhdHRlcm5zT3B0aW1pemVkKGNoYXJDb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBvcHRpbWl6ZWRDaGFySWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KGNoYXJDb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc3NpYmxlUGF0dGVybnMgPSBjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tvcHRpbWl6ZWRDaGFySWR4XTtcbiAgICAgICAgICAgIGlmIChwb3NzaWJsZVBhdHRlcm5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlBcnJheTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBwb3NzaWJsZVBhdHRlcm5zO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBvcF9tb2RlID0gKHBvcFRva2VuKSA9PiB7XG4gICAgICAgICAgICAvLyBUT0RPOiBwZXJoYXBzIGF2b2lkIHRoaXMgZXJyb3IgaW4gdGhlIGVkZ2UgY2FzZSB0aGVyZSBpcyBubyBtb3JlIGlucHV0P1xuICAgICAgICAgICAgaWYgKG1vZGVTdGFjay5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBoYXZlIGJvdGggYSBQT1BfTU9ERSBhbmQgYSBQVVNIX01PREUgdGhpcyBpcyBpbi1mYWN0IGEgXCJ0cmFuc2l0aW9uXCJcbiAgICAgICAgICAgICAgICAvLyBTbyBubyBlcnJvciBzaG91bGQgb2NjdXIuXG4gICAgICAgICAgICAgICAgcG9wVG9rZW4udG9rZW5UeXBlLlBVU0hfTU9ERSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UgdHJ5IHRvIHBvcCB0aGUgbGFzdCBtb2RlIHRoZXJlIGxleGVyIHdpbGwgbm8gbG9uZ2VyIGhhdmUgQU5ZIG1vZGUuXG4gICAgICAgICAgICAgICAgLy8gdGh1cyB0aGUgcG9wIGlzIGlnbm9yZWQsIGFuIGVycm9yIHdpbGwgYmUgY3JlYXRlZCBhbmQgdGhlIGxleGVyIHdpbGwgY29udGludWUgcGFyc2luZyBpbiB0aGUgcHJldmlvdXMgbW9kZS5cbiAgICAgICAgICAgICAgICBjb25zdCBtc2cgPSB0aGlzLmNvbmZpZy5lcnJvck1lc3NhZ2VQcm92aWRlci5idWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZShwb3BUb2tlbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHBvcFRva2VuLnN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgICAgICAgICBsaW5lOiBwb3BUb2tlbi5zdGFydExpbmUsXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbjogcG9wVG9rZW4uc3RhcnRDb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcG9wVG9rZW4uaW1hZ2UubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBtc2csXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3TW9kZSA9IGxhc3QobW9kZVN0YWNrKTtcbiAgICAgICAgICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSB0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgICAgICBjdXJyQ2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZyA9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hhckNvZGVUb1BhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgICAgICBjdXJyTW9kZVBhdHRlcm5zTGVuZ3RoID0gcGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBtb2RlQ2FuQmVPcHRpbWl6ZWQgPSB0aGlzLmNhbk1vZGVCZU9wdGltaXplZFtuZXdNb2RlXSAmJiB0aGlzLmNvbmZpZy5zYWZlTW9kZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnICYmIG1vZGVDYW5CZU9wdGltaXplZCkge1xuICAgICAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc09wdGltaXplZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGdldFBvc3NpYmxlUGF0dGVybnMgPSBnZXRQb3NzaWJsZVBhdHRlcm5zU2xvdztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIHB1c2hfbW9kZShuZXdNb2RlKSB7XG4gICAgICAgICAgICBtb2RlU3RhY2sucHVzaChuZXdNb2RlKTtcbiAgICAgICAgICAgIGN1cnJDaGFyQ29kZVRvUGF0dGVybklkeFRvQ29uZmlnID1cbiAgICAgICAgICAgICAgICB0aGlzLmNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWdbbmV3TW9kZV07XG4gICAgICAgICAgICBwYXR0ZXJuSWR4VG9Db25maWcgPSB0aGlzLnBhdHRlcm5JZHhUb0NvbmZpZ1tuZXdNb2RlXTtcbiAgICAgICAgICAgIGN1cnJNb2RlUGF0dGVybnNMZW5ndGggPSBwYXR0ZXJuSWR4VG9Db25maWcubGVuZ3RoO1xuICAgICAgICAgICAgY3Vyck1vZGVQYXR0ZXJuc0xlbmd0aCA9IHBhdHRlcm5JZHhUb0NvbmZpZy5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBtb2RlQ2FuQmVPcHRpbWl6ZWQgPSB0aGlzLmNhbk1vZGVCZU9wdGltaXplZFtuZXdNb2RlXSAmJiB0aGlzLmNvbmZpZy5zYWZlTW9kZSA9PT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoY3VyckNoYXJDb2RlVG9QYXR0ZXJuSWR4VG9Db25maWcgJiYgbW9kZUNhbkJlT3B0aW1pemVkKSB7XG4gICAgICAgICAgICAgICAgZ2V0UG9zc2libGVQYXR0ZXJucyA9IGdldFBvc3NpYmxlUGF0dGVybnNPcHRpbWl6ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnZXRQb3NzaWJsZVBhdHRlcm5zID0gZ2V0UG9zc2libGVQYXR0ZXJuc1Nsb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdGhpcyBwYXR0ZXJuIHNlZW1zIHRvIGF2b2lkIGEgVjggZGUtb3B0aW1pemF0aW9uLCBhbHRob3VnaCB0aGF0IGRlLW9wdGltaXphdGlvbiBkb2VzIG5vdFxuICAgICAgICAvLyBzZWVtIHRvIG1hdHRlciBwZXJmb3JtYW5jZSB3aXNlLlxuICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBpbml0aWFsTW9kZSk7XG4gICAgICAgIGxldCBjdXJyQ29uZmlnO1xuICAgICAgICBjb25zdCByZWNvdmVyeUVuYWJsZWQgPSB0aGlzLmNvbmZpZy5yZWNvdmVyeUVuYWJsZWQ7XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCBvcmdMZW5ndGgpIHtcbiAgICAgICAgICAgIG1hdGNoZWRJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICBjb25zdCBuZXh0Q2hhckNvZGUgPSBvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KTtcbiAgICAgICAgICAgIGNvbnN0IGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZyA9IGdldFBvc3NpYmxlUGF0dGVybnMobmV4dENoYXJDb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGNob3NlblBhdHRlcm5zTGVuZ3RoID0gY2hvc2VuUGF0dGVybklkeFRvQ29uZmlnLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBjaG9zZW5QYXR0ZXJuc0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VyckNvbmZpZyA9IGNob3NlblBhdHRlcm5JZHhUb0NvbmZpZ1tpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyUGF0dGVybiA9IGN1cnJDb25maWcucGF0dGVybjtcbiAgICAgICAgICAgICAgICBwYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlQ2hhckNvZGUgPSBjdXJyQ29uZmlnLnNob3J0O1xuICAgICAgICAgICAgICAgIGlmIChzaW5nbGVDaGFyQ29kZSAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5leHRDaGFyQ29kZSA9PT0gc2luZ2xlQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmdsZSBjaGFyYWN0ZXIgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBjdXJyUGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjdXJyQ29uZmlnLmlzQ3VzdG9tID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gY3VyclBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gbWF0Y2hbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2gucGF5bG9hZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCA9IG1hdGNoLnBheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZUxhc3RJbmRleChjdXJyUGF0dGVybiwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2hlZEltYWdlID0gdGhpcy5tYXRjaChjdXJyUGF0dGVybiwgdGV4dCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoZWRJbWFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBldmVuIHRob3VnaCB0aGlzIHBhdHRlcm4gbWF0Y2hlZCB3ZSBtdXN0IHRyeSBhIGFub3RoZXIgbG9uZ2VyIGFsdGVybmF0aXZlLlxuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGNhbiBiZSB1c2VkIHRvIHByaW9yaXRpemUga2V5d29yZHMgb3ZlciBpZGVudGlmaWVyc1xuICAgICAgICAgICAgICAgICAgICBsb25nZXJBbHQgPSBjdXJyQ29uZmlnLmxvbmdlckFsdDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdlckFsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBtaWNybyBvcHRpbWl6ZSwgYXZvaWQgZXh0cmEgcHJvcCBhY2Nlc3NcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJ5IHNhdmluZy9saW5raW5nIGxvbmdlckFsdCBvbiB0aGUgb3JpZ2luYWwgY29uZmlnP1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9uZ2VyQWx0TGVuZ3RoID0gbG9uZ2VyQWx0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBsb25nZXJBbHRMZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdlckFsdENvbmZpZyA9IHBhdHRlcm5JZHhUb0NvbmZpZ1tsb25nZXJBbHRba11dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvbmdlckFsdFBhdHRlcm4gPSBsb25nZXJBbHRDb25maWcucGF0dGVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHRQYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW5nbGUgQ2hhciBjYW4gbmV2ZXIgYmUgYSBsb25nZXIgYWx0IHNvIG5vIG5lZWQgdG8gdGVzdCBpdC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtYW51YWxseSBpbi1saW5lZCBiZWNhdXNlID4gNjAwIGNoYXJzIHdvbid0IGJlIGluLWxpbmVkIGluIFY4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxvbmdlckFsdENvbmZpZy5pc0N1c3RvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGxvbmdlckFsdFBhdHRlcm4uZXhlYyhvcmdUZXh0LCBvZmZzZXQsIG1hdGNoZWRUb2tlbnMsIGdyb3Vwcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IG1hdGNoWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoLnBheWxvYWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFsdFBheWxvYWQgPSBtYXRjaC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hBbHRJbWFnZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdEluZGV4KGxvbmdlckFsdFBhdHRlcm4sIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoQWx0SW1hZ2UgPSB0aGlzLm1hdGNoKGxvbmdlckFsdFBhdHRlcm4sIHRleHQsIG9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaEFsdEltYWdlICYmIG1hdGNoQWx0SW1hZ2UubGVuZ3RoID4gbWF0Y2hlZEltYWdlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaGVkSW1hZ2UgPSBtYXRjaEFsdEltYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkID0gYWx0UGF5bG9hZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY3VyckNvbmZpZyA9IGxvbmdlckFsdENvbmZpZztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRXhpdCB0aGUgbG9vcCBlYXJseSBhZnRlciBtYXRjaGluZyBvbmUgb2YgdGhlIGxvbmdlciBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZpcnN0IG1hdGNoZWQgYWx0ZXJuYXRpdmUgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gc3VjY2Vzc2Z1bCBtYXRjaFxuICAgICAgICAgICAgaWYgKG1hdGNoZWRJbWFnZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGltYWdlTGVuZ3RoID0gbWF0Y2hlZEltYWdlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBncm91cCA9IGN1cnJDb25maWcuZ3JvdXA7XG4gICAgICAgICAgICAgICAgaWYgKGdyb3VwICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rVHlwZSA9IGN1cnJDb25maWcudG9rZW5UeXBlSWR4O1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBcIm9mZnNldCArIGltYWdlTGVuZ3RoXCIgYW5kIHRoZSBuZXcgY29sdW1uIG1heSBiZSBjb21wdXRlZCB0d2ljZSBpbiBjYXNlIG9mIFwiZnVsbFwiIGxvY2F0aW9uIGluZm9ybWF0aW9uIGluc2lkZVxuICAgICAgICAgICAgICAgICAgICAvLyBjcmVhdGVGdWxsVG9rZW4gbWV0aG9kXG4gICAgICAgICAgICAgICAgICAgIG5ld1Rva2VuID0gdGhpcy5jcmVhdGVUb2tlbkluc3RhbmNlKG1hdGNoZWRJbWFnZSwgb2Zmc2V0LCB0b2tUeXBlLCBjdXJyQ29uZmlnLnRva2VuVHlwZSwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUGF5bG9hZChuZXdUb2tlbiwgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IG9wdGltaXplIE5PT1AgaW4gY2FzZSB0aGVyZSBhcmUgbm8gc3BlY2lhbCBncm91cHM/XG4gICAgICAgICAgICAgICAgICAgIGlmIChncm91cCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWRUb2tlbnNJbmRleCA9IHRoaXMuYWRkVG9rZW4obWF0Y2hlZFRva2VucywgbWF0Y2hlZFRva2Vuc0luZGV4LCBuZXdUb2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cHNbZ3JvdXBdLnB1c2gobmV3VG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRleHQgPSB0aGlzLmNob3BJbnB1dCh0ZXh0LCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gb2Zmc2V0ICsgaW1hZ2VMZW5ndGg7XG4gICAgICAgICAgICAgICAgLy8gVE9ETzogd2l0aCBuZXdsaW5lcyB0aGUgY29sdW1uIG1heSBiZSBhc3NpZ25lZCB0d2ljZVxuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuY29tcHV0ZU5ld0NvbHVtbihjb2x1bW4sIGltYWdlTGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBpZiAodHJhY2tMaW5lcyA9PT0gdHJ1ZSAmJiBjdXJyQ29uZmlnLmNhbkxpbmVUZXJtaW5hdG9yID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBudW1PZkxUc0luTWF0Y2ggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgZm91bmRUZXJtaW5hdG9yO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdExURW5kT2Zmc2V0O1xuICAgICAgICAgICAgICAgICAgICBsaW5lVGVybWluYXRvclBhdHRlcm4ubGFzdEluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRUZXJtaW5hdG9yID0gbGluZVRlcm1pbmF0b3JQYXR0ZXJuLnRlc3QobWF0Y2hlZEltYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmb3VuZFRlcm1pbmF0b3IgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0TFRFbmRPZmZzZXQgPSBsaW5lVGVybWluYXRvclBhdHRlcm4ubGFzdEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBudW1PZkxUc0luTWF0Y2grKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoZm91bmRUZXJtaW5hdG9yID09PSB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG51bU9mTFRzSW5NYXRjaCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUgKyBudW1PZkxUc0luTWF0Y2g7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2x1bW4gPSBpbWFnZUxlbmd0aCAtIGxhc3RMVEVuZE9mZnNldDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24obmV3VG9rZW4sIGdyb3VwLCBsYXN0TFRFbmRPZmZzZXQsIG51bU9mTFRzSW5NYXRjaCwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gd2lsbCBiZSBOT09QIGlmIG5vIG1vZGVzIHByZXNlbnRcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZU1vZGVzKGN1cnJDb25maWcsIHBvcF9tb2RlLCBwdXNoX21vZGUsIG5ld1Rva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGVycm9yIHJlY292ZXJ5LCBkcm9wIGNoYXJhY3RlcnMgdW50aWwgd2UgaWRlbnRpZnkgYSB2YWxpZCB0b2tlbidzIHN0YXJ0IHBvaW50XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JTdGFydE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvckxpbmUgPSBsaW5lO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yQ29sdW1uID0gY29sdW1uO1xuICAgICAgICAgICAgICAgIGxldCBmb3VuZFJlc3luY1BvaW50ID0gcmVjb3ZlcnlFbmFibGVkID09PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZm91bmRSZXN5bmNQb2ludCA9PT0gZmFsc2UgJiYgb2Zmc2V0IDwgb3JnTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElkZW50aXR5IEZ1bmMgKHdoZW4gc3RpY2t5IGZsYWcgaXMgZW5hYmxlZClcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRoaXMuY2hvcElucHV0KHRleHQsIDEpO1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGN1cnJNb2RlUGF0dGVybnNMZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY3VyckNvbmZpZyA9IHBhdHRlcm5JZHhUb0NvbmZpZ1tqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJQYXR0ZXJuID0gY3VyckNvbmZpZy5wYXR0ZXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbWFudWFsbHkgaW4tbGluZWQgYmVjYXVzZSA+IDYwMCBjaGFycyB3b24ndCBiZSBpbi1saW5lZCBpbiBWOFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2luZ2xlQ2hhckNvZGUgPSBjdXJyQ29uZmlnLnNob3J0O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNpbmdsZUNoYXJDb2RlICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmdUZXh0LmNoYXJDb2RlQXQob2Zmc2V0KSA9PT0gc2luZ2xlQ2hhckNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRSZXN5bmNQb2ludCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY3VyckNvbmZpZy5pc0N1c3RvbSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kUmVzeW5jUG9pbnQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXJyUGF0dGVybi5leGVjKG9yZ1RleHQsIG9mZnNldCwgbWF0Y2hlZFRva2VucywgZ3JvdXBzKSAhPT0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGFzdEluZGV4KGN1cnJQYXR0ZXJuLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvdW5kUmVzeW5jUG9pbnQgPSBjdXJyUGF0dGVybi5leGVjKHRleHQpICE9PSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvdW5kUmVzeW5jUG9pbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlcnJMZW5ndGggPSBvZmZzZXQgLSBlcnJvclN0YXJ0T2Zmc2V0O1xuICAgICAgICAgICAgICAgIGNvbHVtbiA9IHRoaXMuY29tcHV0ZU5ld0NvbHVtbihjb2x1bW4sIGVyckxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gYXQgdGhpcyBwb2ludCB3ZSBlaXRoZXIgcmUtc3luY2VkIG9yIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgaW5wdXQgdGV4dFxuICAgICAgICAgICAgICAgIG1zZyA9IHRoaXMuY29uZmlnLmVycm9yTWVzc2FnZVByb3ZpZGVyLmJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlKG9yZ1RleHQsIGVycm9yU3RhcnRPZmZzZXQsIGVyckxlbmd0aCwgZXJyb3JMaW5lLCBlcnJvckNvbHVtbik7XG4gICAgICAgICAgICAgICAgZXJyb3JzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IGVycm9yU3RhcnRPZmZzZXQsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGVycm9yTGluZSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uOiBlcnJvckNvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoOiBlcnJMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IG1zZyxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcnlFbmFibGVkID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgZG8gaGF2ZSBjdXN0b20gcGF0dGVybnMgd2hpY2ggcHVzaCBkaXJlY3RseSBpbnRvIHRoZVxuICAgICAgICAvLyBUT0RPOiBjdXN0b20gdG9rZW5zIHNob3VsZCBub3QgcHVzaCBkaXJlY3RseT8/XG4gICAgICAgIGlmICghdGhpcy5oYXNDdXN0b20pIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGd1ZXNzZWQgYSB0b28gbGFyZ2Ugc2l6ZSBmb3IgdGhlIHRva2VucyBhcnJheSB0aGlzIHdpbGwgc2hyaW5rIGl0IHRvIHRoZSByaWdodCBzaXplLlxuICAgICAgICAgICAgbWF0Y2hlZFRva2Vucy5sZW5ndGggPSBtYXRjaGVkVG9rZW5zSW5kZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuczogbWF0Y2hlZFRva2VucyxcbiAgICAgICAgICAgIGdyb3VwczogZ3JvdXBzLFxuICAgICAgICAgICAgZXJyb3JzOiBlcnJvcnMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGhhbmRsZU1vZGVzKGNvbmZpZywgcG9wX21vZGUsIHB1c2hfbW9kZSwgbmV3VG9rZW4pIHtcbiAgICAgICAgaWYgKGNvbmZpZy5wb3AgPT09IHRydWUpIHtcbiAgICAgICAgICAgIC8vIG5lZWQgdG8gc2F2ZSB0aGUgUFVTSF9NT0RFIHByb3BlcnR5IGFzIGlmIHRoZSBtb2RlIGlzIHBvcHBlZFxuICAgICAgICAgICAgLy8gcGF0dGVybklkeFRvUG9wTW9kZSBpcyB1cGRhdGVkIHRvIHJlZmxlY3QgdGhlIG5ldyBtb2RlIGFmdGVyIHBvcHBpbmcgdGhlIHN0YWNrXG4gICAgICAgICAgICBjb25zdCBwdXNoTW9kZSA9IGNvbmZpZy5wdXNoO1xuICAgICAgICAgICAgcG9wX21vZGUobmV3VG9rZW4pO1xuICAgICAgICAgICAgaWYgKHB1c2hNb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBwdXNoX21vZGUuY2FsbCh0aGlzLCBwdXNoTW9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29uZmlnLnB1c2ggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHVzaF9tb2RlLmNhbGwodGhpcywgY29uZmlnLnB1c2gpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNob3BJbnB1dCh0ZXh0LCBsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRleHQuc3Vic3RyaW5nKGxlbmd0aCk7XG4gICAgfVxuICAgIHVwZGF0ZUxhc3RJbmRleChyZWdFeHAsIG5ld0xhc3RJbmRleCkge1xuICAgICAgICByZWdFeHAubGFzdEluZGV4ID0gbmV3TGFzdEluZGV4O1xuICAgIH1cbiAgICAvLyBUT0RPOiBkZWNyZWFzZSB0aGlzIHVuZGVyIDYwMCBjaGFyYWN0ZXJzPyBpbnNwZWN0IHN0cmlwcGluZyBjb21tZW50cyBvcHRpb24gaW4gVFNDIGNvbXBpbGVyXG4gICAgdXBkYXRlVG9rZW5FbmRMaW5lQ29sdW1uTG9jYXRpb24obmV3VG9rZW4sIGdyb3VwLCBsYXN0TFRJZHgsIG51bU9mTFRzSW5NYXRjaCwgbGluZSwgY29sdW1uLCBpbWFnZUxlbmd0aCkge1xuICAgICAgICBsZXQgbGFzdENoYXJJc0xULCBmaXhGb3JFbmRpbmdJbkxUO1xuICAgICAgICBpZiAoZ3JvdXAgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYSBub25lIHNraXBwZWQgbXVsdGkgbGluZSBUb2tlbiwgbmVlZCB0byB1cGRhdGUgZW5kTGluZS9lbmRDb2x1bW5cbiAgICAgICAgICAgIGxhc3RDaGFySXNMVCA9IGxhc3RMVElkeCA9PT0gaW1hZ2VMZW5ndGggLSAxO1xuICAgICAgICAgICAgZml4Rm9yRW5kaW5nSW5MVCA9IGxhc3RDaGFySXNMVCA/IC0xIDogMDtcbiAgICAgICAgICAgIGlmICghKG51bU9mTFRzSW5NYXRjaCA9PT0gMSAmJiBsYXN0Q2hhcklzTFQgPT09IHRydWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgYSB0b2tlbiBlbmRzIGluIGEgTFQgdGhhdCBsYXN0IExUIG9ubHkgYWZmZWN0cyB0aGUgbGluZSBudW1iZXJpbmcgb2YgZm9sbG93aW5nIFRva2Vuc1xuICAgICAgICAgICAgICAgIG5ld1Rva2VuLmVuZExpbmUgPSBsaW5lICsgZml4Rm9yRW5kaW5nSW5MVDtcbiAgICAgICAgICAgICAgICAvLyB0aGUgbGFzdCBMVCBpbiBhIHRva2VuIGRvZXMgbm90IGFmZmVjdCB0aGUgZW5kQ29sdW1uIGVpdGhlciBhcyB0aGUgW2NvbHVtblN0YXJ0IC4uLiBjb2x1bW5FbmQpXG4gICAgICAgICAgICAgICAgLy8gaW5jbHVzaXZlIHRvIGV4Y2x1c2l2ZSByYW5nZS5cbiAgICAgICAgICAgICAgICBuZXdUb2tlbi5lbmRDb2x1bW4gPSBjb2x1bW4gLSAxICsgLWZpeEZvckVuZGluZ0luTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlIHNpbmdsZSBMVCBpbiB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSB0b2tlbiwgbm8gbmVlZCB0byBtb2RpZnkgdGhlIGVuZExpbmUvRW5kQ29sdW1uXG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZU5ld0NvbHVtbihvbGRDb2x1bW4sIGltYWdlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBvbGRDb2x1bW4gKyBpbWFnZUxlbmd0aDtcbiAgICB9XG4gICAgY3JlYXRlT2Zmc2V0T25seVRva2VuKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICB0b2tlblR5cGVJZHgsXG4gICAgICAgICAgICB0b2tlblR5cGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNyZWF0ZVN0YXJ0T25seVRva2VuKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGltYWdlLFxuICAgICAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgICAgICBzdGFydExpbmUsXG4gICAgICAgICAgICBzdGFydENvbHVtbixcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeCxcbiAgICAgICAgICAgIHRva2VuVHlwZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlRnVsbFRva2VuKGltYWdlLCBzdGFydE9mZnNldCwgdG9rZW5UeXBlSWR4LCB0b2tlblR5cGUsIHN0YXJ0TGluZSwgc3RhcnRDb2x1bW4sIGltYWdlTGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpbWFnZSxcbiAgICAgICAgICAgIHN0YXJ0T2Zmc2V0LFxuICAgICAgICAgICAgZW5kT2Zmc2V0OiBzdGFydE9mZnNldCArIGltYWdlTGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHN0YXJ0TGluZSxcbiAgICAgICAgICAgIGVuZExpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgIHN0YXJ0Q29sdW1uLFxuICAgICAgICAgICAgZW5kQ29sdW1uOiBzdGFydENvbHVtbiArIGltYWdlTGVuZ3RoIC0gMSxcbiAgICAgICAgICAgIHRva2VuVHlwZUlkeCxcbiAgICAgICAgICAgIHRva2VuVHlwZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYWRkVG9rZW5Vc2luZ1B1c2godG9rZW5WZWN0b3IsIGluZGV4LCB0b2tlblRvQWRkKSB7XG4gICAgICAgIHRva2VuVmVjdG9yLnB1c2godG9rZW5Ub0FkZCk7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG4gICAgYWRkVG9rZW5Vc2luZ01lbWJlckFjY2Vzcyh0b2tlblZlY3RvciwgaW5kZXgsIHRva2VuVG9BZGQpIHtcbiAgICAgICAgdG9rZW5WZWN0b3JbaW5kZXhdID0gdG9rZW5Ub0FkZDtcbiAgICAgICAgaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgIH1cbiAgICBoYW5kbGVQYXlsb2FkTm9DdXN0b20odG9rZW4sIHBheWxvYWQpIHsgfVxuICAgIGhhbmRsZVBheWxvYWRXaXRoQ3VzdG9tKHRva2VuLCBwYXlsb2FkKSB7XG4gICAgICAgIGlmIChwYXlsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0b2tlbi5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtYXRjaFdpdGhUZXN0KHBhdHRlcm4sIHRleHQsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBmb3VuZCA9IHBhdHRlcm4udGVzdCh0ZXh0KTtcbiAgICAgICAgaWYgKGZvdW5kID09PSB0cnVlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dC5zdWJzdHJpbmcob2Zmc2V0LCBwYXR0ZXJuLmxhc3RJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIG1hdGNoV2l0aEV4ZWMocGF0dGVybiwgdGV4dCkge1xuICAgICAgICBjb25zdCByZWdFeHBBcnJheSA9IHBhdHRlcm4uZXhlYyh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHJlZ0V4cEFycmF5ICE9PSBudWxsID8gcmVnRXhwQXJyYXlbMF0gOiBudWxsO1xuICAgIH1cbn1cbkxleGVyLlNLSVBQRUQgPSBcIlRoaXMgbWFya3MgYSBza2lwcGVkIFRva2VuIHBhdHRlcm4sIHRoaXMgbWVhbnMgZWFjaCB0b2tlbiBpZGVudGlmaWVkIGJ5IGl0IHdpbGxcIiArXG4gICAgXCJiZSBjb25zdW1lZCBhbmQgdGhlbiB0aHJvd24gaW50byBvYmxpdmlvbiwgdGhpcyBjYW4gYmUgdXNlZCB0byBmb3IgZXhhbXBsZSB0byBjb21wbGV0ZWx5IGlnbm9yZSB3aGl0ZXNwYWNlLlwiO1xuTGV4ZXIuTkEgPSAvTk9UX0FQUExJQ0FCTEUvO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGV4ZXJfcHVibGljLmpzLm1hcCIsImltcG9ydCB7IEJhc2VSZWdFeHBWaXNpdG9yLCB9IGZyb20gXCJAY2hldnJvdGFpbi9yZWdleHAtdG8tYXN0XCI7XG5pbXBvcnQgeyBldmVyeSwgZmluZCwgZm9yRWFjaCwgaW5jbHVkZXMsIGlzQXJyYXksIHZhbHVlcyB9IGZyb20gXCJsb2Rhc2gtZXNcIjtcbmltcG9ydCB7IFBSSU5UX0VSUk9SLCBQUklOVF9XQVJOSU5HIH0gZnJvbSBcIkBjaGV2cm90YWluL3V0aWxzXCI7XG5pbXBvcnQgeyBnZXRSZWdFeHBBc3QgfSBmcm9tIFwiLi9yZWdfZXhwX3BhcnNlci5qc1wiO1xuaW1wb3J0IHsgY2hhckNvZGVUb09wdGltaXplZEluZGV4LCBtaW5PcHRpbWl6YXRpb25WYWwgfSBmcm9tIFwiLi9sZXhlci5qc1wiO1xuY29uc3QgY29tcGxlbWVudEVycm9yTWVzc2FnZSA9IFwiQ29tcGxlbWVudCBTZXRzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBmaXJzdCBjaGFyIG9wdGltaXphdGlvblwiO1xuZXhwb3J0IGNvbnN0IGZhaWxlZE9wdGltaXphdGlvblByZWZpeE1zZyA9ICdVbmFibGUgdG8gdXNlIFwiZmlyc3QgY2hhclwiIGxleGVyIG9wdGltaXphdGlvbnM6XFxuJztcbmV4cG9ydCBmdW5jdGlvbiBnZXRPcHRpbWl6ZWRTdGFydENvZGVzSW5kaWNlcyhyZWdFeHAsIGVuc3VyZU9wdGltaXphdGlvbnMgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGFzdCA9IGdldFJlZ0V4cEFzdChyZWdFeHApO1xuICAgICAgICBjb25zdCBmaXJzdENoYXJzID0gZmlyc3RDaGFyT3B0aW1pemVkSW5kaWNlcyhhc3QudmFsdWUsIHt9LCBhc3QuZmxhZ3MuaWdub3JlQ2FzZSk7XG4gICAgICAgIHJldHVybiBmaXJzdENoYXJzO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAvLyBUZXN0aW5nIHRoaXMgcmVsaWVzIG9uIHRoZSByZWdleHAtdG8tYXN0IGxpYnJhcnkgaGF2aW5nIGEgYnVnLi4uICovXG4gICAgICAgIC8vIFRPRE86IG9ubHkgdGhlIGVsc2UgYnJhbmNoIG5lZWRzIHRvIGJlIGlnbm9yZWQsIHRyeSB0byBmaXggd2l0aCBuZXdlciBwcmV0dGllciAvIHRzY1xuICAgICAgICBpZiAoZS5tZXNzYWdlID09PSBjb21wbGVtZW50RXJyb3JNZXNzYWdlKSB7XG4gICAgICAgICAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgIFBSSU5UX1dBUk5JTkcoYCR7ZmFpbGVkT3B0aW1pemF0aW9uUHJlZml4TXNnfWAgK1xuICAgICAgICAgICAgICAgICAgICBgXFx0VW5hYmxlIHRvIG9wdGltaXplOiA8ICR7cmVnRXhwLnRvU3RyaW5nKCl9ID5cXG5gICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRDb21wbGVtZW50IFNldHMgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgb3B0aW1pemVkLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgXCJcXHRUaGlzIHdpbGwgZGlzYWJsZSB0aGUgbGV4ZXIncyBmaXJzdCBjaGFyIG9wdGltaXphdGlvbnMuXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICBcIlxcdFNlZTogaHR0cHM6Ly9jaGV2cm90YWluLmlvL2RvY3MvZ3VpZGUvcmVzb2x2aW5nX2xleGVyX2Vycm9ycy5odG1sI0NPTVBMRU1FTlQgZm9yIGRldGFpbHMuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGV0IG1zZ1N1ZmZpeCA9IFwiXCI7XG4gICAgICAgICAgICBpZiAoZW5zdXJlT3B0aW1pemF0aW9ucykge1xuICAgICAgICAgICAgICAgIG1zZ1N1ZmZpeCA9XG4gICAgICAgICAgICAgICAgICAgIFwiXFxuXFx0VGhpcyB3aWxsIGRpc2FibGUgdGhlIGxleGVyJ3MgZmlyc3QgY2hhciBvcHRpbWl6YXRpb25zLlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFx0U2VlOiBodHRwczovL2NoZXZyb3RhaW4uaW8vZG9jcy9ndWlkZS9yZXNvbHZpbmdfbGV4ZXJfZXJyb3JzLmh0bWwjUkVHRVhQX1BBUlNJTkcgZm9yIGRldGFpbHMuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBQUklOVF9FUlJPUihgJHtmYWlsZWRPcHRpbWl6YXRpb25QcmVmaXhNc2d9XFxuYCArXG4gICAgICAgICAgICAgICAgYFxcdEZhaWxlZCBwYXJzaW5nOiA8ICR7cmVnRXhwLnRvU3RyaW5nKCl9ID5cXG5gICtcbiAgICAgICAgICAgICAgICBgXFx0VXNpbmcgdGhlIEBjaGV2cm90YWluL3JlZ2V4cC10by1hc3QgbGlicmFyeVxcbmAgK1xuICAgICAgICAgICAgICAgIFwiXFx0UGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGV2cm90YWluL2NoZXZyb3RhaW4vaXNzdWVzXCIgK1xuICAgICAgICAgICAgICAgIG1zZ1N1ZmZpeCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXN0LCByZXN1bHQsIGlnbm9yZUNhc2UpIHtcbiAgICBzd2l0Y2ggKGFzdC50eXBlKSB7XG4gICAgICAgIGNhc2UgXCJEaXNqdW5jdGlvblwiOlxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhc3QudmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmaXJzdENoYXJPcHRpbWl6ZWRJbmRpY2VzKGFzdC52YWx1ZVtpXSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQWx0ZXJuYXRpdmVcIjpcbiAgICAgICAgICAgIGNvbnN0IHRlcm1zID0gYXN0LnZhbHVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXJtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRlcm0gPSB0ZXJtc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBza2lwIHRlcm1zIHRoYXQgY2Fubm90IGVmZmVjdCB0aGUgZmlyc3QgY2hhciByZXN1bHRzXG4gICAgICAgICAgICAgICAgc3dpdGNoICh0ZXJtLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkVuZEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBBIGdyb3VwIGJhY2sgcmVmZXJlbmNlIGNhbm5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNoYXIuXG4gICAgICAgICAgICAgICAgICAgIC8vIGJlY2F1c2UgaWYgYSBiYWNrIHJlZmVyZW5jZSBpcyB0aGUgZmlyc3QgcHJvZHVjdGlvbiB0aGFuIGF1dG9tYXRpY2FsbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGdyb3VwIGJlaW5nIHJlZmVyZW5jZWQgaGFzIGhhZCB0byBjb21lIEJFRk9SRSBzbyBpdHMgY29kZXMgaGF2ZSBhbHJlYWR5IGJlZW4gYWRkZWRcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkdyb3VwQmFja1JlZmVyZW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIGRvIG5vdCBhZmZlY3QgcG90ZW50aWFsIHN0YXJ0aW5nIGNvZGVzXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIk5lZ2F0aXZlTG9va2FoZWFkXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTdGFydEFuY2hvclwiOlxuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiV29yZEJvdW5kYXJ5XCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJOb25Xb3JkQm91bmRhcnlcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhdG9tID0gdGVybTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF0b20udHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiQ2hhcmFjdGVyXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBhZGRPcHRpbWl6ZWRJZHhUb1Jlc3VsdChhdG9tLnZhbHVlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJTZXRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdG9tLmNvbXBsZW1lbnQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcihjb21wbGVtZW50RXJyb3JNZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvckVhY2goYXRvbS52YWx1ZSwgKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoY29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJhbmdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gY29kZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2Fubm90IG9wdGltaXplIHdoZW4gaWdub3JlQ2FzZSBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaWdub3JlQ2FzZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcmFuZ2VDb2RlID0gcmFuZ2UuZnJvbTsgcmFuZ2VDb2RlIDw9IHJhbmdlLnRvOyByYW5nZUNvZGUrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZE9wdGltaXplZElkeFRvUmVzdWx0KHJhbmdlQ29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBPcHRpbWl6YXRpb24gKDIgb3JkZXJzIG9mIG1hZ25pdHVkZSBsZXNzIHdvcmsgZm9yIHZlcnkgbGFyZ2UgcmFuZ2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSB1bm9wdGltaXplZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IHJhbmdlQ29kZSA9IHJhbmdlLmZyb207IHJhbmdlQ29kZSA8PSByYW5nZS50byAmJiByYW5nZUNvZGUgPCBtaW5PcHRpbWl6YXRpb25WYWw7IHJhbmdlQ29kZSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQocmFuZ2VDb2RlLCByZXN1bHQsIGlnbm9yZUNhc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTGVzcyBjb21tb24gY2hhckNvZGUgd2hlcmUgd2Ugb3B0aW1pemUgZm9yIGZhc3RlciBpbml0IHRpbWUsIGJ5IHVzaW5nIGxhcmdlciBcImJ1Y2tldHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJhbmdlLnRvID49IG1pbk9wdGltaXphdGlvblZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pblVuT3B0VmFsID0gcmFuZ2UuZnJvbSA+PSBtaW5PcHRpbWl6YXRpb25WYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyByYW5nZS5mcm9tXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogbWluT3B0aW1pemF0aW9uVmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1heFVuT3B0VmFsID0gcmFuZ2UudG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluT3B0SWR4ID0gY2hhckNvZGVUb09wdGltaXplZEluZGV4KG1pblVuT3B0VmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhPcHRJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobWF4VW5PcHRWYWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGN1cnJPcHRJZHggPSBtaW5PcHRJZHg7IGN1cnJPcHRJZHggPD0gbWF4T3B0SWR4OyBjdXJyT3B0SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2N1cnJPcHRJZHhdID0gY3Vyck9wdElkeDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwiR3JvdXBcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0Q2hhck9wdGltaXplZEluZGljZXMoYXRvbS52YWx1ZSwgcmVzdWx0LCBpZ25vcmVDYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJOb24gRXhoYXVzdGl2ZSBNYXRjaFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVhY2hlZCBhIG1hbmRhdG9yeSBwcm9kdWN0aW9uLCBubyBtb3JlICoqc3RhcnQqKiBjb2RlcyBjYW4gYmUgZm91bmQgb24gdGhpcyBhbHRlcm5hdGl2ZVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzT3B0aW9uYWxRdWFudGlmaWVyID0gYXRvbS5xdWFudGlmaWVyICE9PSB1bmRlZmluZWQgJiYgYXRvbS5xdWFudGlmaWVyLmF0TGVhc3QgPT09IDA7XG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIC8vIEEgZ3JvdXAgbWF5IGJlIG9wdGlvbmFsIGR1ZSB0byBlbXB0eSBjb250ZW50cyAvKD86KS9cbiAgICAgICAgICAgICAgICAvLyBvciBpZiBldmVyeXRoaW5nIGluc2lkZSBpdCBpcyBvcHRpb25hbCAvKChhKT8pL1xuICAgICAgICAgICAgICAgIChhdG9tLnR5cGUgPT09IFwiR3JvdXBcIiAmJiBpc1dob2xlT3B0aW9uYWwoYXRvbSkgPT09IGZhbHNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGlzIHRlcm0gaXMgbm90IGEgZ3JvdXAgaXQgbWF5IG9ubHkgYmUgb3B0aW9uYWwgaWYgaXQgaGFzIGFuIG9wdGlvbmFsIHF1YW50aWZpZXJcbiAgICAgICAgICAgICAgICAgICAgKGF0b20udHlwZSAhPT0gXCJHcm91cFwiICYmIGlzT3B0aW9uYWxRdWFudGlmaWVyID09PSBmYWxzZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIm5vbiBleGhhdXN0aXZlIG1hdGNoIVwiKTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coT2JqZWN0LmtleXMocmVzdWx0KS5sZW5ndGgpXG4gICAgcmV0dXJuIHZhbHVlcyhyZXN1bHQpO1xufVxuZnVuY3Rpb24gYWRkT3B0aW1pemVkSWR4VG9SZXN1bHQoY29kZSwgcmVzdWx0LCBpZ25vcmVDYXNlKSB7XG4gICAgY29uc3Qgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleChjb2RlKTtcbiAgICByZXN1bHRbb3B0aW1pemVkQ2hhcklkeF0gPSBvcHRpbWl6ZWRDaGFySWR4O1xuICAgIGlmIChpZ25vcmVDYXNlID09PSB0cnVlKSB7XG4gICAgICAgIGhhbmRsZUlnbm9yZUNhc2UoY29kZSwgcmVzdWx0KTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYW5kbGVJZ25vcmVDYXNlKGNvZGUsIHJlc3VsdCkge1xuICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpO1xuICAgIGNvbnN0IHVwcGVyQ2hhciA9IGNoYXIudG9VcHBlckNhc2UoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh1cHBlckNoYXIgIT09IGNoYXIpIHtcbiAgICAgICAgY29uc3Qgb3B0aW1pemVkQ2hhcklkeCA9IGNoYXJDb2RlVG9PcHRpbWl6ZWRJbmRleCh1cHBlckNoYXIuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJlc3VsdFtvcHRpbWl6ZWRDaGFySWR4XSA9IG9wdGltaXplZENoYXJJZHg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsb3dlckNoYXIgPSBjaGFyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChsb3dlckNoYXIgIT09IGNoYXIpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGltaXplZENoYXJJZHggPSBjaGFyQ29kZVRvT3B0aW1pemVkSW5kZXgobG93ZXJDaGFyLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICAgICAgcmVzdWx0W29wdGltaXplZENoYXJJZHhdID0gb3B0aW1pemVkQ2hhcklkeDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbmRDb2RlKHNldE5vZGUsIHRhcmdldENoYXJDb2Rlcykge1xuICAgIHJldHVybiBmaW5kKHNldE5vZGUudmFsdWUsIChjb2RlT3JSYW5nZSkgPT4ge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVPclJhbmdlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gaW5jbHVkZXModGFyZ2V0Q2hhckNvZGVzLCBjb2RlT3JSYW5nZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyByYW5nZVxuICAgICAgICAgICAgY29uc3QgcmFuZ2UgPSBjb2RlT3JSYW5nZTtcbiAgICAgICAgICAgIHJldHVybiAoZmluZCh0YXJnZXRDaGFyQ29kZXMsICh0YXJnZXRDb2RlKSA9PiByYW5nZS5mcm9tIDw9IHRhcmdldENvZGUgJiYgdGFyZ2V0Q29kZSA8PSByYW5nZS50bykgIT09IHVuZGVmaW5lZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGlzV2hvbGVPcHRpb25hbChhc3QpIHtcbiAgICBjb25zdCBxdWFudGlmaWVyID0gYXN0LnF1YW50aWZpZXI7XG4gICAgaWYgKHF1YW50aWZpZXIgJiYgcXVhbnRpZmllci5hdExlYXN0ID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWFzdC52YWx1ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBpc0FycmF5KGFzdC52YWx1ZSlcbiAgICAgICAgPyBldmVyeShhc3QudmFsdWUsIGlzV2hvbGVPcHRpb25hbClcbiAgICAgICAgOiBpc1dob2xlT3B0aW9uYWwoYXN0LnZhbHVlKTtcbn1cbmNsYXNzIENoYXJDb2RlRmluZGVyIGV4dGVuZHMgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldENoYXJDb2Rlcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRhcmdldENoYXJDb2RlcyA9IHRhcmdldENoYXJDb2RlcztcbiAgICAgICAgdGhpcy5mb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgICB2aXNpdENoaWxkcmVuKG5vZGUpIHtcbiAgICAgICAgLy8gTm8gbmVlZCB0byBrZWVwIGxvb2tpbmcuLi5cbiAgICAgICAgaWYgKHRoaXMuZm91bmQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBzd2l0Y2ggbG9va2FoZWFkcyBhcyB0aGV5IGRvIG5vdCBhY3R1YWxseSBjb25zdW1lIGFueSBjaGFyYWN0ZXJzIHRodXNcbiAgICAgICAgLy8gZmluZGluZyBhIGNoYXJDb2RlIGF0IGxvb2thaGVhZCBjb250ZXh0IGRvZXMgbm90IG1lYW4gdGhhdCByZWdleHAgY2FuIGFjdHVhbGx5IGNvbnRhaW4gaXQgaW4gYSBtYXRjaC5cbiAgICAgICAgc3dpdGNoIChub2RlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJMb29rYWhlYWRcIjpcbiAgICAgICAgICAgICAgICB0aGlzLnZpc2l0TG9va2FoZWFkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNhc2UgXCJOZWdhdGl2ZUxvb2thaGVhZFwiOlxuICAgICAgICAgICAgICAgIHRoaXMudmlzaXROZWdhdGl2ZUxvb2thaGVhZChub2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIudmlzaXRDaGlsZHJlbihub2RlKTtcbiAgICB9XG4gICAgdmlzaXRDaGFyYWN0ZXIobm9kZSkge1xuICAgICAgICBpZiAoaW5jbHVkZXModGhpcy50YXJnZXRDaGFyQ29kZXMsIG5vZGUudmFsdWUpKSB7XG4gICAgICAgICAgICB0aGlzLmZvdW5kID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFNldChub2RlKSB7XG4gICAgICAgIGlmIChub2RlLmNvbXBsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChmaW5kQ29kZShub2RlLCB0aGlzLnRhcmdldENoYXJDb2RlcykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGZpbmRDb2RlKG5vZGUsIHRoaXMudGFyZ2V0Q2hhckNvZGVzKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3VuZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gY2FuTWF0Y2hDaGFyQ29kZShjaGFyQ29kZXMsIHBhdHRlcm4pIHtcbiAgICBpZiAocGF0dGVybiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICBjb25zdCBhc3QgPSBnZXRSZWdFeHBBc3QocGF0dGVybik7XG4gICAgICAgIGNvbnN0IGNoYXJDb2RlRmluZGVyID0gbmV3IENoYXJDb2RlRmluZGVyKGNoYXJDb2Rlcyk7XG4gICAgICAgIGNoYXJDb2RlRmluZGVyLnZpc2l0KGFzdCk7XG4gICAgICAgIHJldHVybiBjaGFyQ29kZUZpbmRlci5mb3VuZDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoZmluZChwYXR0ZXJuLCAoY2hhcikgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGluY2x1ZGVzKGNoYXJDb2RlcywgY2hhci5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgfSkgIT09IHVuZGVmaW5lZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVnX2V4cC5qcy5tYXAiLCJpbXBvcnQgeyBSZWdFeHBQYXJzZXIsIH0gZnJvbSBcIkBjaGV2cm90YWluL3JlZ2V4cC10by1hc3RcIjtcbmxldCByZWdFeHBBc3RDYWNoZSA9IHt9O1xuY29uc3QgcmVnRXhwUGFyc2VyID0gbmV3IFJlZ0V4cFBhcnNlcigpO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJlZ0V4cEFzdChyZWdFeHApIHtcbiAgICBjb25zdCByZWdFeHBTdHIgPSByZWdFeHAudG9TdHJpbmcoKTtcbiAgICBpZiAocmVnRXhwQXN0Q2FjaGUuaGFzT3duUHJvcGVydHkocmVnRXhwU3RyKSkge1xuICAgICAgICByZXR1cm4gcmVnRXhwQXN0Q2FjaGVbcmVnRXhwU3RyXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlZ0V4cEFzdCA9IHJlZ0V4cFBhcnNlci5wYXR0ZXJuKHJlZ0V4cFN0cik7XG4gICAgICAgIHJlZ0V4cEFzdENhY2hlW3JlZ0V4cFN0cl0gPSByZWdFeHBBc3Q7XG4gICAgICAgIHJldHVybiByZWdFeHBBc3Q7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyUmVnRXhwUGFyc2VyQ2FjaGUoKSB7XG4gICAgcmVnRXhwQXN0Q2FjaGUgPSB7fTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlZ19leHBfcGFyc2VyLmpzLm1hcCIsImltcG9ydCB7IGNsb25lLCBjb21wYWN0LCBkaWZmZXJlbmNlLCBmbGF0dGVuLCBmb3JFYWNoLCBoYXMsIGluY2x1ZGVzLCBpc0FycmF5LCBpc0VtcHR5LCBtYXAsIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXIodG9rSW5zdGFuY2UsIHRva0NvbnN0cnVjdG9yKSB7XG4gICAgY29uc3QgaW5zdGFuY2VUeXBlID0gdG9rSW5zdGFuY2UudG9rZW5UeXBlSWR4O1xuICAgIGlmIChpbnN0YW5jZVR5cGUgPT09IHRva0NvbnN0cnVjdG9yLnRva2VuVHlwZUlkeCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAodG9rQ29uc3RydWN0b3IuaXNQYXJlbnQgPT09IHRydWUgJiZcbiAgICAgICAgICAgIHRva0NvbnN0cnVjdG9yLmNhdGVnb3J5TWF0Y2hlc01hcFtpbnN0YW5jZVR5cGVdID09PSB0cnVlKTtcbiAgICB9XG59XG4vLyBPcHRpbWl6ZWQgdG9rZW5NYXRjaGVyIGluIGNhc2Ugb3VyIGdyYW1tYXIgZG9lcyBub3QgdXNlIHRva2VuIGNhdGVnb3JpZXNcbi8vIEJlaW5nIHNvIHRpbnkgaXQgaXMgbXVjaCBtb3JlIGxpa2VseSB0byBiZSBpbi1saW5lZCBhbmQgdGhpcyBhdm9pZCB0aGUgZnVuY3Rpb24gY2FsbCBvdmVyaGVhZFxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuU3RydWN0dXJlZE1hdGNoZXJOb0NhdGVnb3JpZXModG9rZW4sIHRva1R5cGUpIHtcbiAgICByZXR1cm4gdG9rZW4udG9rZW5UeXBlSWR4ID09PSB0b2tUeXBlLnRva2VuVHlwZUlkeDtcbn1cbmV4cG9ydCBsZXQgdG9rZW5TaG9ydE5hbWVJZHggPSAxO1xuZXhwb3J0IGNvbnN0IHRva2VuSWR4VG9DbGFzcyA9IHt9O1xuZXhwb3J0IGZ1bmN0aW9uIGF1Z21lbnRUb2tlblR5cGVzKHRva2VuVHlwZXMpIHtcbiAgICAvLyBjb2xsZWN0IHRoZSBwYXJlbnQgVG9rZW4gVHlwZXMgYXMgd2VsbC5cbiAgICBjb25zdCB0b2tlblR5cGVzQW5kUGFyZW50cyA9IGV4cGFuZENhdGVnb3JpZXModG9rZW5UeXBlcyk7XG4gICAgLy8gYWRkIHJlcXVpcmVkIHRva2VuVHlwZSBhbmQgY2F0ZWdvcnlNYXRjaGVzIHByb3BlcnRpZXNcbiAgICBhc3NpZ25Ub2tlbkRlZmF1bHRQcm9wcyh0b2tlblR5cGVzQW5kUGFyZW50cyk7XG4gICAgLy8gZmlsbCB1cCB0aGUgY2F0ZWdvcnlNYXRjaGVzXG4gICAgYXNzaWduQ2F0ZWdvcmllc01hcFByb3AodG9rZW5UeXBlc0FuZFBhcmVudHMpO1xuICAgIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXNBbmRQYXJlbnRzKTtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXNBbmRQYXJlbnRzLCAodG9rVHlwZSkgPT4ge1xuICAgICAgICB0b2tUeXBlLmlzUGFyZW50ID0gdG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMubGVuZ3RoID4gMDtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBleHBhbmRDYXRlZ29yaWVzKHRva2VuVHlwZXMpIHtcbiAgICBsZXQgcmVzdWx0ID0gY2xvbmUodG9rZW5UeXBlcyk7XG4gICAgbGV0IGNhdGVnb3JpZXMgPSB0b2tlblR5cGVzO1xuICAgIGxldCBzZWFyY2hpbmcgPSB0cnVlO1xuICAgIHdoaWxlIChzZWFyY2hpbmcpIHtcbiAgICAgICAgY2F0ZWdvcmllcyA9IGNvbXBhY3QoZmxhdHRlbihtYXAoY2F0ZWdvcmllcywgKGN1cnJUb2tUeXBlKSA9PiBjdXJyVG9rVHlwZS5DQVRFR09SSUVTKSkpO1xuICAgICAgICBjb25zdCBuZXdDYXRlZ29yaWVzID0gZGlmZmVyZW5jZShjYXRlZ29yaWVzLCByZXN1bHQpO1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuY29uY2F0KG5ld0NhdGVnb3JpZXMpO1xuICAgICAgICBpZiAoaXNFbXB0eShuZXdDYXRlZ29yaWVzKSkge1xuICAgICAgICAgICAgc2VhcmNoaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYXRlZ29yaWVzID0gbmV3Q2F0ZWdvcmllcztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnblRva2VuRGVmYXVsdFByb3BzKHRva2VuVHlwZXMpIHtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICBpZiAoIWhhc1Nob3J0S2V5UHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICB0b2tlbklkeFRvQ2xhc3NbdG9rZW5TaG9ydE5hbWVJZHhdID0gY3VyclRva1R5cGU7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS50b2tlblR5cGVJZHggPSB0b2tlblNob3J0TmFtZUlkeCsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIENBVEVHT1JJRVM/IDogVG9rZW5UeXBlIHwgVG9rZW5UeXBlW11cbiAgICAgICAgaWYgKGhhc0NhdGVnb3JpZXNQcm9wZXJ0eShjdXJyVG9rVHlwZSkgJiZcbiAgICAgICAgICAgICFpc0FycmF5KGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMpXG4gICAgICAgIC8vICYmXG4gICAgICAgIC8vICFpc1VuZGVmaW5lZChjdXJyVG9rVHlwZS5DQVRFR09SSUVTLlBBVFRFUk4pXG4gICAgICAgICkge1xuICAgICAgICAgICAgY3VyclRva1R5cGUuQ0FURUdPUklFUyA9IFtjdXJyVG9rVHlwZS5DQVRFR09SSUVTXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0NhdGVnb3JpZXNQcm9wZXJ0eShjdXJyVG9rVHlwZSkpIHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLkNBVEVHT1JJRVMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWhhc0V4dGVuZGluZ1Rva2Vuc1R5cGVzTWFwUHJvcGVydHkoY3VyclRva1R5cGUpKSB7XG4gICAgICAgICAgICBjdXJyVG9rVHlwZS5jYXRlZ29yeU1hdGNoZXNNYXAgPSB7fTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNhdGVnb3JpZXNUb2tlbnNQcm9wKHRva2VuVHlwZXMpIHtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICAvLyBhdm9pZCBkdXBsaWNhdGlvbnNcbiAgICAgICAgY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzID0gW107XG4gICAgICAgIGZvckVhY2goY3VyclRva1R5cGUuY2F0ZWdvcnlNYXRjaGVzTWFwLCAodmFsLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGN1cnJUb2tUeXBlLmNhdGVnb3J5TWF0Y2hlcy5wdXNoKHRva2VuSWR4VG9DbGFzc1trZXldLnRva2VuVHlwZUlkeCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2lnbkNhdGVnb3JpZXNNYXBQcm9wKHRva2VuVHlwZXMpIHtcbiAgICBmb3JFYWNoKHRva2VuVHlwZXMsIChjdXJyVG9rVHlwZSkgPT4ge1xuICAgICAgICBzaW5nbGVBc3NpZ25DYXRlZ29yaWVzVG9rc01hcChbXSwgY3VyclRva1R5cGUpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwKHBhdGgsIG5leHROb2RlKSB7XG4gICAgZm9yRWFjaChwYXRoLCAocGF0aE5vZGUpID0+IHtcbiAgICAgICAgbmV4dE5vZGUuY2F0ZWdvcnlNYXRjaGVzTWFwW3BhdGhOb2RlLnRva2VuVHlwZUlkeF0gPSB0cnVlO1xuICAgIH0pO1xuICAgIGZvckVhY2gobmV4dE5vZGUuQ0FURUdPUklFUywgKG5leHRDYXRlZ29yeSkgPT4ge1xuICAgICAgICBjb25zdCBuZXdQYXRoID0gcGF0aC5jb25jYXQobmV4dE5vZGUpO1xuICAgICAgICAvLyBhdm9pZHMgaW5maW5pdGUgbG9vcHMgZHVlIHRvIGN5Y2xpYyBjYXRlZ29yaWVzLlxuICAgICAgICBpZiAoIWluY2x1ZGVzKG5ld1BhdGgsIG5leHRDYXRlZ29yeSkpIHtcbiAgICAgICAgICAgIHNpbmdsZUFzc2lnbkNhdGVnb3JpZXNUb2tzTWFwKG5ld1BhdGgsIG5leHRDYXRlZ29yeSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNTaG9ydEtleVByb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwidG9rZW5UeXBlSWR4XCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhhc0NhdGVnb3JpZXNQcm9wZXJ0eSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuIGhhcyh0b2tUeXBlLCBcIkNBVEVHT1JJRVNcIik7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzRXh0ZW5kaW5nVG9rZW5zVHlwZXNQcm9wZXJ0eSh0b2tUeXBlKSB7XG4gICAgcmV0dXJuIGhhcyh0b2tUeXBlLCBcImNhdGVnb3J5TWF0Y2hlc1wiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoYXNFeHRlbmRpbmdUb2tlbnNUeXBlc01hcFByb3BlcnR5KHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwiY2F0ZWdvcnlNYXRjaGVzTWFwXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVG9rZW5UeXBlKHRva1R5cGUpIHtcbiAgICByZXR1cm4gaGFzKHRva1R5cGUsIFwidG9rZW5UeXBlSWR4XCIpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dG9rZW5zLmpzLm1hcCIsImltcG9ydCB7IGhhcywgaXNTdHJpbmcsIGlzVW5kZWZpbmVkIH0gZnJvbSBcImxvZGFzaC1lc1wiO1xuaW1wb3J0IHsgTGV4ZXIgfSBmcm9tIFwiLi9sZXhlcl9wdWJsaWMuanNcIjtcbmltcG9ydCB7IGF1Z21lbnRUb2tlblR5cGVzLCB0b2tlblN0cnVjdHVyZWRNYXRjaGVyIH0gZnJvbSBcIi4vdG9rZW5zLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gdG9rZW5MYWJlbCh0b2tUeXBlKSB7XG4gICAgaWYgKGhhc1Rva2VuTGFiZWwodG9rVHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRva1R5cGUuTEFCRUw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gdG9rVHlwZS5uYW1lO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbk5hbWUodG9rVHlwZSkge1xuICAgIHJldHVybiB0b2tUeXBlLm5hbWU7XG59XG5leHBvcnQgZnVuY3Rpb24gaGFzVG9rZW5MYWJlbChvYmopIHtcbiAgICByZXR1cm4gaXNTdHJpbmcob2JqLkxBQkVMKSAmJiBvYmouTEFCRUwgIT09IFwiXCI7XG59XG5jb25zdCBQQVJFTlQgPSBcInBhcmVudFwiO1xuY29uc3QgQ0FURUdPUklFUyA9IFwiY2F0ZWdvcmllc1wiO1xuY29uc3QgTEFCRUwgPSBcImxhYmVsXCI7XG5jb25zdCBHUk9VUCA9IFwiZ3JvdXBcIjtcbmNvbnN0IFBVU0hfTU9ERSA9IFwicHVzaF9tb2RlXCI7XG5jb25zdCBQT1BfTU9ERSA9IFwicG9wX21vZGVcIjtcbmNvbnN0IExPTkdFUl9BTFQgPSBcImxvbmdlcl9hbHRcIjtcbmNvbnN0IExJTkVfQlJFQUtTID0gXCJsaW5lX2JyZWFrc1wiO1xuY29uc3QgU1RBUlRfQ0hBUlNfSElOVCA9IFwic3RhcnRfY2hhcnNfaGludFwiO1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZVRva2VuKGNvbmZpZykge1xuICAgIHJldHVybiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZyk7XG59XG5mdW5jdGlvbiBjcmVhdGVUb2tlbkludGVybmFsKGNvbmZpZykge1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjb25maWcucGF0dGVybjtcbiAgICBjb25zdCB0b2tlblR5cGUgPSB7fTtcbiAgICB0b2tlblR5cGUubmFtZSA9IGNvbmZpZy5uYW1lO1xuICAgIGlmICghaXNVbmRlZmluZWQocGF0dGVybikpIHtcbiAgICAgICAgdG9rZW5UeXBlLlBBVFRFUk4gPSBwYXR0ZXJuO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgUEFSRU5UKSkge1xuICAgICAgICB0aHJvdyAoXCJUaGUgcGFyZW50IHByb3BlcnR5IGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuXFxuXCIgK1xuICAgICAgICAgICAgXCJTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9jaGV2cm90YWluL2NoZXZyb3RhaW4vaXNzdWVzLzU2NCNpc3N1ZWNvbW1lbnQtMzQ5MDYyMzQ2IGZvciBkZXRhaWxzLlwiKTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIENBVEVHT1JJRVMpKSB7XG4gICAgICAgIC8vIGNhc3RpbmcgdG8gQU5ZIGFzIHRoaXMgd2lsbCBiZSBmaXhlZCBpbnNpZGUgYGF1Z21lbnRUb2tlblR5cGVzYGBcbiAgICAgICAgdG9rZW5UeXBlLkNBVEVHT1JJRVMgPSBjb25maWdbQ0FURUdPUklFU107XG4gICAgfVxuICAgIGF1Z21lbnRUb2tlblR5cGVzKFt0b2tlblR5cGVdKTtcbiAgICBpZiAoaGFzKGNvbmZpZywgTEFCRUwpKSB7XG4gICAgICAgIHRva2VuVHlwZS5MQUJFTCA9IGNvbmZpZ1tMQUJFTF07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBHUk9VUCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLkdST1VQID0gY29uZmlnW0dST1VQXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIFBPUF9NT0RFKSkge1xuICAgICAgICB0b2tlblR5cGUuUE9QX01PREUgPSBjb25maWdbUE9QX01PREVdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgUFVTSF9NT0RFKSkge1xuICAgICAgICB0b2tlblR5cGUuUFVTSF9NT0RFID0gY29uZmlnW1BVU0hfTU9ERV07XG4gICAgfVxuICAgIGlmIChoYXMoY29uZmlnLCBMT05HRVJfQUxUKSkge1xuICAgICAgICB0b2tlblR5cGUuTE9OR0VSX0FMVCA9IGNvbmZpZ1tMT05HRVJfQUxUXTtcbiAgICB9XG4gICAgaWYgKGhhcyhjb25maWcsIExJTkVfQlJFQUtTKSkge1xuICAgICAgICB0b2tlblR5cGUuTElORV9CUkVBS1MgPSBjb25maWdbTElORV9CUkVBS1NdO1xuICAgIH1cbiAgICBpZiAoaGFzKGNvbmZpZywgU1RBUlRfQ0hBUlNfSElOVCkpIHtcbiAgICAgICAgdG9rZW5UeXBlLlNUQVJUX0NIQVJTX0hJTlQgPSBjb25maWdbU1RBUlRfQ0hBUlNfSElOVF07XG4gICAgfVxuICAgIHJldHVybiB0b2tlblR5cGU7XG59XG5leHBvcnQgY29uc3QgRU9GID0gY3JlYXRlVG9rZW4oeyBuYW1lOiBcIkVPRlwiLCBwYXR0ZXJuOiBMZXhlci5OQSB9KTtcbmF1Z21lbnRUb2tlblR5cGVzKFtFT0ZdKTtcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUb2tlbkluc3RhbmNlKHRva1R5cGUsIGltYWdlLCBzdGFydE9mZnNldCwgZW5kT2Zmc2V0LCBzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q29sdW1uLCBlbmRDb2x1bW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpbWFnZSxcbiAgICAgICAgc3RhcnRPZmZzZXQsXG4gICAgICAgIGVuZE9mZnNldCxcbiAgICAgICAgc3RhcnRMaW5lLFxuICAgICAgICBlbmRMaW5lLFxuICAgICAgICBzdGFydENvbHVtbixcbiAgICAgICAgZW5kQ29sdW1uLFxuICAgICAgICB0b2tlblR5cGVJZHg6IHRva1R5cGUudG9rZW5UeXBlSWR4LFxuICAgICAgICB0b2tlblR5cGU6IHRva1R5cGUsXG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b2tlbk1hdGNoZXIodG9rZW4sIHRva1R5cGUpIHtcbiAgICByZXR1cm4gdG9rZW5TdHJ1Y3R1cmVkTWF0Y2hlcih0b2tlbiwgdG9rVHlwZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10b2tlbnNfcHVibGljLmpzLm1hcCIsIi8vIG5lZWRzIGEgc2VwYXJhdGUgbW9kdWxlIGFzIHRoaXMgaXMgcmVxdWlyZWQgaW5zaWRlIGNoZXZyb3RhaW4gcHJvZHVjdGl2ZSBjb2RlXG4vLyBhbmQgYWxzbyBpbiB0aGUgZW50cnkgcG9pbnQgZm9yIHdlYnBhY2soYXBpLnRzKS5cbi8vIEEgc2VwYXJhdGUgZmlsZSBhdm9pZHMgY3ljbGljIGRlcGVuZGVuY2llcyBhbmQgd2VicGFjayBlcnJvcnMuXG5leHBvcnQgY29uc3QgVkVSU0lPTiA9IFwiMTEuMC4zXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD12ZXJzaW9uLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgY3JlYXRlR3JhbW1hckNvbmZpZyB9IGZyb20gJy4vbGFuZ3VhZ2VzL2dyYW1tYXItY29uZmlnLmpzJztcbmltcG9ydCB7IGNyZWF0ZUNvbXBsZXRpb25QYXJzZXIgfSBmcm9tICcuL3BhcnNlci9jb21wbGV0aW9uLXBhcnNlci1idWlsZGVyLmpzJztcbmltcG9ydCB7IGNyZWF0ZUxhbmdpdW1QYXJzZXIgfSBmcm9tICcuL3BhcnNlci9sYW5naXVtLXBhcnNlci1idWlsZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRUb2tlbkJ1aWxkZXIgfSBmcm9tICcuL3BhcnNlci90b2tlbi1idWlsZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRWYWx1ZUNvbnZlcnRlciB9IGZyb20gJy4vcGFyc2VyL3ZhbHVlLWNvbnZlcnRlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0TGlua2VyIH0gZnJvbSAnLi9yZWZlcmVuY2VzL2xpbmtlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0TmFtZVByb3ZpZGVyIH0gZnJvbSAnLi9yZWZlcmVuY2VzL25hbWUtcHJvdmlkZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFJlZmVyZW5jZXMgfSBmcm9tICcuL3JlZmVyZW5jZXMvcmVmZXJlbmNlcy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0U2NvcGVDb21wdXRhdGlvbiB9IGZyb20gJy4vcmVmZXJlbmNlcy9zY29wZS1jb21wdXRhdGlvbi5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0U2NvcGVQcm92aWRlciB9IGZyb20gJy4vcmVmZXJlbmNlcy9zY29wZS1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0SnNvblNlcmlhbGl6ZXIgfSBmcm9tICcuL3NlcmlhbGl6ZXIvanNvbi1zZXJpYWxpemVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRTZXJ2aWNlUmVnaXN0cnkgfSBmcm9tICcuL3NlcnZpY2UtcmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgRGVmYXVsdERvY3VtZW50VmFsaWRhdG9yIH0gZnJvbSAnLi92YWxpZGF0aW9uL2RvY3VtZW50LXZhbGlkYXRvci5qcyc7XG5pbXBvcnQgeyBWYWxpZGF0aW9uUmVnaXN0cnkgfSBmcm9tICcuL3ZhbGlkYXRpb24vdmFsaWRhdGlvbi1yZWdpc3RyeS5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0QXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXIsIERlZmF1bHRSZWZlcmVuY2VEZXNjcmlwdGlvblByb3ZpZGVyIH0gZnJvbSAnLi93b3Jrc3BhY2UvYXN0LWRlc2NyaXB0aW9ucy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0QXN0Tm9kZUxvY2F0b3IgfSBmcm9tICcuL3dvcmtzcGFjZS9hc3Qtbm9kZS1sb2NhdG9yLmpzJztcbmltcG9ydCB7IERlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIgfSBmcm9tICcuL3dvcmtzcGFjZS9jb25maWd1cmF0aW9uLmpzJztcbmltcG9ydCB7IERlZmF1bHREb2N1bWVudEJ1aWxkZXIgfSBmcm9tICcuL3dvcmtzcGFjZS9kb2N1bWVudC1idWlsZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRMYW5naXVtRG9jdW1lbnRGYWN0b3J5LCBEZWZhdWx0TGFuZ2l1bURvY3VtZW50cyB9IGZyb20gJy4vd29ya3NwYWNlL2RvY3VtZW50cy5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0SW5kZXhNYW5hZ2VyIH0gZnJvbSAnLi93b3Jrc3BhY2UvaW5kZXgtbWFuYWdlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0V29ya3NwYWNlTWFuYWdlciB9IGZyb20gJy4vd29ya3NwYWNlL3dvcmtzcGFjZS1tYW5hZ2VyLmpzJztcbmltcG9ydCB7IERlZmF1bHRMZXhlciwgRGVmYXVsdExleGVyRXJyb3JNZXNzYWdlUHJvdmlkZXIgfSBmcm9tICcuL3BhcnNlci9sZXhlci5qcyc7XG5pbXBvcnQgeyBKU0RvY0RvY3VtZW50YXRpb25Qcm92aWRlciB9IGZyb20gJy4vZG9jdW1lbnRhdGlvbi9kb2N1bWVudGF0aW9uLXByb3ZpZGVyLmpzJztcbmltcG9ydCB7IERlZmF1bHRDb21tZW50UHJvdmlkZXIgfSBmcm9tICcuL2RvY3VtZW50YXRpb24vY29tbWVudC1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIgfSBmcm9tICcuL3BhcnNlci9sYW5naXVtLXBhcnNlci5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0QXN5bmNQYXJzZXIgfSBmcm9tICcuL3BhcnNlci9hc3luYy1wYXJzZXIuanMnO1xuaW1wb3J0IHsgRGVmYXVsdFdvcmtzcGFjZUxvY2sgfSBmcm9tICcuL3dvcmtzcGFjZS93b3Jrc3BhY2UtbG9jay5qcyc7XG5pbXBvcnQgeyBEZWZhdWx0SHlkcmF0b3IgfSBmcm9tICcuL3NlcmlhbGl6ZXIvaHlkcmF0b3IuanMnO1xuLyoqXG4gKiBDcmVhdGVzIGEgZGVwZW5kZW5jeSBpbmplY3Rpb24gbW9kdWxlIGNvbmZpZ3VyaW5nIHRoZSBkZWZhdWx0IGNvcmUgc2VydmljZXMuXG4gKiBUaGlzIGlzIGEgc2V0IG9mIHNlcnZpY2VzIHRoYXQgYXJlIGRlZGljYXRlZCB0byBhIHNwZWNpZmljIGxhbmd1YWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoY29udGV4dCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGRvY3VtZW50YXRpb246IHtcbiAgICAgICAgICAgIENvbW1lbnRQcm92aWRlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdENvbW1lbnRQcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBEb2N1bWVudGF0aW9uUHJvdmlkZXI6IChzZXJ2aWNlcykgPT4gbmV3IEpTRG9jRG9jdW1lbnRhdGlvblByb3ZpZGVyKHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICBwYXJzZXI6IHtcbiAgICAgICAgICAgIEFzeW5jUGFyc2VyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0QXN5bmNQYXJzZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgR3JhbW1hckNvbmZpZzogKHNlcnZpY2VzKSA9PiBjcmVhdGVHcmFtbWFyQ29uZmlnKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIExhbmdpdW1QYXJzZXI6IChzZXJ2aWNlcykgPT4gY3JlYXRlTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBDb21wbGV0aW9uUGFyc2VyOiAoc2VydmljZXMpID0+IGNyZWF0ZUNvbXBsZXRpb25QYXJzZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgVmFsdWVDb252ZXJ0ZXI6ICgpID0+IG5ldyBEZWZhdWx0VmFsdWVDb252ZXJ0ZXIoKSxcbiAgICAgICAgICAgIFRva2VuQnVpbGRlcjogKCkgPT4gbmV3IERlZmF1bHRUb2tlbkJ1aWxkZXIoKSxcbiAgICAgICAgICAgIExleGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGV4ZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXI6ICgpID0+IG5ldyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIoKSxcbiAgICAgICAgICAgIExleGVyRXJyb3JNZXNzYWdlUHJvdmlkZXI6ICgpID0+IG5ldyBEZWZhdWx0TGV4ZXJFcnJvck1lc3NhZ2VQcm92aWRlcigpXG4gICAgICAgIH0sXG4gICAgICAgIHdvcmtzcGFjZToge1xuICAgICAgICAgICAgQXN0Tm9kZUxvY2F0b3I6ICgpID0+IG5ldyBEZWZhdWx0QXN0Tm9kZUxvY2F0b3IoKSxcbiAgICAgICAgICAgIEFzdE5vZGVEZXNjcmlwdGlvblByb3ZpZGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0QXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgUmVmZXJlbmNlRGVzY3JpcHRpb25Qcm92aWRlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdFJlZmVyZW5jZURlc2NyaXB0aW9uUHJvdmlkZXIoc2VydmljZXMpXG4gICAgICAgIH0sXG4gICAgICAgIHJlZmVyZW5jZXM6IHtcbiAgICAgICAgICAgIExpbmtlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdExpbmtlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBOYW1lUHJvdmlkZXI6ICgpID0+IG5ldyBEZWZhdWx0TmFtZVByb3ZpZGVyKCksXG4gICAgICAgICAgICBTY29wZVByb3ZpZGVyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0U2NvcGVQcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBTY29wZUNvbXB1dGF0aW9uOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0U2NvcGVDb21wdXRhdGlvbihzZXJ2aWNlcyksXG4gICAgICAgICAgICBSZWZlcmVuY2VzOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0UmVmZXJlbmNlcyhzZXJ2aWNlcylcbiAgICAgICAgfSxcbiAgICAgICAgc2VyaWFsaXplcjoge1xuICAgICAgICAgICAgSHlkcmF0b3I6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRIeWRyYXRvcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBKc29uU2VyaWFsaXplcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdEpzb25TZXJpYWxpemVyKHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICB2YWxpZGF0aW9uOiB7XG4gICAgICAgICAgICBEb2N1bWVudFZhbGlkYXRvcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdERvY3VtZW50VmFsaWRhdG9yKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFZhbGlkYXRpb25SZWdpc3RyeTogKHNlcnZpY2VzKSA9PiBuZXcgVmFsaWRhdGlvblJlZ2lzdHJ5KHNlcnZpY2VzKVxuICAgICAgICB9LFxuICAgICAgICBzaGFyZWQ6ICgpID0+IGNvbnRleHQuc2hhcmVkXG4gICAgfTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGRlcGVuZGVuY3kgaW5qZWN0aW9uIG1vZHVsZSBjb25maWd1cmluZyB0aGUgZGVmYXVsdCBzaGFyZWQgY29yZSBzZXJ2aWNlcy5cbiAqIFRoaXMgaXMgdGhlIHNldCBvZiBzZXJ2aWNlcyB0aGF0IGFyZSBzaGFyZWQgYmV0d2VlbiBtdWx0aXBsZSBsYW5ndWFnZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVEZWZhdWx0U2hhcmVkQ29yZU1vZHVsZShjb250ZXh0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgU2VydmljZVJlZ2lzdHJ5OiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0U2VydmljZVJlZ2lzdHJ5KHNlcnZpY2VzKSxcbiAgICAgICAgd29ya3NwYWNlOiB7XG4gICAgICAgICAgICBMYW5naXVtRG9jdW1lbnRzOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGFuZ2l1bURvY3VtZW50cyhzZXJ2aWNlcyksXG4gICAgICAgICAgICBMYW5naXVtRG9jdW1lbnRGYWN0b3J5OiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0TGFuZ2l1bURvY3VtZW50RmFjdG9yeShzZXJ2aWNlcyksXG4gICAgICAgICAgICBEb2N1bWVudEJ1aWxkZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHREb2N1bWVudEJ1aWxkZXIoc2VydmljZXMpLFxuICAgICAgICAgICAgSW5kZXhNYW5hZ2VyOiAoc2VydmljZXMpID0+IG5ldyBEZWZhdWx0SW5kZXhNYW5hZ2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIFdvcmtzcGFjZU1hbmFnZXI6IChzZXJ2aWNlcykgPT4gbmV3IERlZmF1bHRXb3Jrc3BhY2VNYW5hZ2VyKHNlcnZpY2VzKSxcbiAgICAgICAgICAgIEZpbGVTeXN0ZW1Qcm92aWRlcjogKHNlcnZpY2VzKSA9PiBjb250ZXh0LmZpbGVTeXN0ZW1Qcm92aWRlcihzZXJ2aWNlcyksXG4gICAgICAgICAgICBXb3Jrc3BhY2VMb2NrOiAoKSA9PiBuZXcgRGVmYXVsdFdvcmtzcGFjZUxvY2soKSxcbiAgICAgICAgICAgIENvbmZpZ3VyYXRpb25Qcm92aWRlcjogKHNlcnZpY2VzKSA9PiBuZXcgRGVmYXVsdENvbmZpZ3VyYXRpb25Qcm92aWRlcihzZXJ2aWNlcylcbiAgICAgICAgfVxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LW1vZHVsZS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgdmFyIE1vZHVsZTtcbihmdW5jdGlvbiAoTW9kdWxlKSB7XG4gICAgTW9kdWxlLm1lcmdlID0gKG0xLCBtMikgPT4gX21lcmdlKF9tZXJnZSh7fSwgbTEpLCBtMik7XG59KShNb2R1bGUgfHwgKE1vZHVsZSA9IHt9KSk7XG4vKipcbiAqIEdpdmVuIGEgc2V0IG9mIG1vZHVsZXMsIHRoZSBpbmplY3QgZnVuY3Rpb24gcmV0dXJucyBhIGxhemlseSBldmFsdWF0ZWQgaW5qZWN0b3JcbiAqIHRoYXQgaW5qZWN0cyBkZXBlbmRlbmNpZXMgaW50byB0aGUgcmVxdWVzdGVkIHNlcnZpY2Ugd2hlbiBpdCBpcyByZXF1ZXN0ZWQgdGhlXG4gKiBmaXJzdCB0aW1lLiBTdWJzZXF1ZW50IHJlcXVlc3RzIHdpbGwgcmV0dXJuIHRoZSBzYW1lIHNlcnZpY2UuXG4gKlxuICogSW4gdGhlIGNhc2Ugb2YgY3ljbGljIGRlcGVuZGVuY2llcywgYW4gRXJyb3Igd2lsbCBiZSB0aHJvd24uIFRoaXMgY2FuIGJlIGZpeGVkXG4gKiBieSBpbmplY3RpbmcgYSBwcm92aWRlciBgKCkgPT4gVGAgaW5zdGVhZCBvZiBhIGBUYC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IHRoZSBhcmd1bWVudHMgbWF5IGJlIG9iamVjdHMgb3IgYXJyYXlzLiBIb3dldmVyLCB0aGUgcmVzdWx0IHdpbGxcbiAqIGJlIGFuIG9iamVjdC4gVXNpbmcgaXQgd2l0aCBmb3IuLm9mIHdpbGwgaGF2ZSBubyBlZmZlY3QuXG4gKlxuICogQHBhcmFtIG1vZHVsZTEgZmlyc3QgTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlMiAob3B0aW9uYWwpIHNlY29uZCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGUzIChvcHRpb25hbCkgdGhpcmQgTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlNCAob3B0aW9uYWwpIGZvdXJ0aCBNb2R1bGVcbiAqIEBwYXJhbSBtb2R1bGU1IChvcHRpb25hbCkgZmlmdGggTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlNiAob3B0aW9uYWwpIHNpeHRoIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTcgKG9wdGlvbmFsKSBzZXZlbnRoIE1vZHVsZVxuICogQHBhcmFtIG1vZHVsZTggKG9wdGlvbmFsKSBlaWdodGggTW9kdWxlXG4gKiBAcGFyYW0gbW9kdWxlOSAob3B0aW9uYWwpIG5pbnRoIE1vZHVsZVxuICogQHJldHVybnMgYSBuZXcgb2JqZWN0IG9mIHR5cGUgSVxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5qZWN0KG1vZHVsZTEsIG1vZHVsZTIsIG1vZHVsZTMsIG1vZHVsZTQsIG1vZHVsZTUsIG1vZHVsZTYsIG1vZHVsZTcsIG1vZHVsZTgsIG1vZHVsZTkpIHtcbiAgICBjb25zdCBtb2R1bGUgPSBbbW9kdWxlMSwgbW9kdWxlMiwgbW9kdWxlMywgbW9kdWxlNCwgbW9kdWxlNSwgbW9kdWxlNiwgbW9kdWxlNywgbW9kdWxlOCwgbW9kdWxlOV0ucmVkdWNlKF9tZXJnZSwge30pO1xuICAgIHJldHVybiBfaW5qZWN0KG1vZHVsZSk7XG59XG5jb25zdCBpc1Byb3h5ID0gU3ltYm9sKCdpc1Byb3h5Jyk7XG4vKipcbiAqIEVhZ2VybHkgbG9hZCBhbGwgc2VydmljZXMgaW4gdGhlIGdpdmVuIGRlcGVuZGVuY3kgaW5qZWN0aW9uIGNvbnRhaW5lci4gVGhpcyBpcyBzb21ldGltZXNcbiAqIG5lY2Vzc2FyeSBiZWNhdXNlIHNlcnZpY2VzIGNhbiByZWdpc3RlciBldmVudCBsaXN0ZW5lcnMgaW4gdGhlaXIgY29uc3RydWN0b3JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZWFnZXJMb2FkKGl0ZW0pIHtcbiAgICBpZiAoaXRlbSAmJiBpdGVtW2lzUHJveHldKSB7XG4gICAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgT2JqZWN0LnZhbHVlcyhpdGVtKSkge1xuICAgICAgICAgICAgZWFnZXJMb2FkKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaXRlbTtcbn1cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBpbmplY3RvciBieSBjcmVhdGluZyBhIHByb3h5LlxuICogSW52YXJpYW50OiBpbmplY3RvciBpcyBvZiB0eXBlIEkuIElmIGluamVjdG9yIGlzIHVuZGVmaW5lZCwgdGhlbiBUID0gSS5cbiAqL1xuZnVuY3Rpb24gX2luamVjdChtb2R1bGUsIGluamVjdG9yKSB7XG4gICAgY29uc3QgcHJveHkgPSBuZXcgUHJveHkoe30sIHtcbiAgICAgICAgZGVsZXRlUHJvcGVydHk6ICgpID0+IGZhbHNlLFxuICAgICAgICBzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBwcm9wZXJ0eSBvbiBpbmplY3RlZCBzZXJ2aWNlIGNvbnRhaW5lcicpO1xuICAgICAgICB9LFxuICAgICAgICBnZXQ6IChvYmosIHByb3ApID0+IHtcbiAgICAgICAgICAgIGlmIChwcm9wID09PSBpc1Byb3h5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3Jlc29sdmUob2JqLCBwcm9wLCBtb2R1bGUsIGluamVjdG9yIHx8IHByb3h5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yOiAob2JqLCBwcm9wKSA9PiAoX3Jlc29sdmUob2JqLCBwcm9wLCBtb2R1bGUsIGluamVjdG9yIHx8IHByb3h5KSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHByb3ApKSwgLy8gdXNlZCBieSBmb3IuLmluXG4gICAgICAgIGhhczogKF8sIHByb3ApID0+IHByb3AgaW4gbW9kdWxlLCAvLyB1c2VkIGJ5IC4uaW4uLlxuICAgICAgICBvd25LZXlzOiAoKSA9PiBbLi4uT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobW9kdWxlKV0gLy8gdXNlZCBieSBmb3IuLmluXG4gICAgfSk7XG4gICAgcmV0dXJuIHByb3h5O1xufVxuLyoqXG4gKiBJbnRlcm5hbGx5IHVzZWQgdG8gdGFnIGEgcmVxdWVzdGVkIGRlcGVuZGVuY3ksIGRpcmVjdGx5IGJlZm9yZSBjYWxsaW5nIHRoZSBmYWN0b3J5LlxuICogVGhpcyBhbGxvd3MgdXMgdG8gZmluZCBjeWNsZXMgZHVyaW5nIGluc3RhbmNlIGNyZWF0aW9uLlxuICovXG5jb25zdCBfX3JlcXVlc3RlZF9fID0gU3ltYm9sKCk7XG4vKipcbiAqIFJldHVybnMgdGhlIHZhbHVlIGBvYmpbcHJvcF1gLiBJZiB0aGUgdmFsdWUgZG9lcyBub3QgZXhpc3QsIHlldCwgaXQgaXMgcmVzb2x2ZWQgZnJvbVxuICogdGhlIG1vZHVsZSBkZXNjcmlwdGlvbi4gVGhlIHJlc3VsdCBvZiBzZXJ2aWNlIGZhY3RvcmllcyBpcyBjYWNoZWQuIEdyb3VwcyBhcmVcbiAqIHJlY3Vyc2l2ZWx5IHByb3hpZWQuXG4gKlxuICogQHBhcmFtIG9iaiBhbiBvYmplY3QgaG9sZGluZyBhbGwgZ3JvdXAgcHJveGllcyBhbmQgc2VydmljZXNcbiAqIEBwYXJhbSBwcm9wIHRoZSBrZXkgb2YgYSB2YWx1ZSB3aXRoaW4gb2JqXG4gKiBAcGFyYW0gbW9kdWxlIGFuIG9iamVjdCBjb250YWluaW5nIGdyb3VwcyBhbmQgc2VydmljZSBmYWN0b3JpZXNcbiAqIEBwYXJhbSBpbmplY3RvciB0aGUgZmlyc3QgbGV2ZWwgcHJveHkgdGhhdCBwcm92aWRlcyBhY2Nlc3MgdG8gYWxsIHZhbHVlc1xuICogQHJldHVybnMgdGhlIHJlcXVlc3RlZCB2YWx1ZSBgb2JqW3Byb3BdYFxuICogQHRocm93cyBFcnJvciBpZiBhIGRlcGVuZGVuY3kgY3ljbGUgaXMgZGV0ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gX3Jlc29sdmUob2JqLCBwcm9wLCBtb2R1bGUsIGluamVjdG9yKSB7XG4gICAgaWYgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmpbcHJvcF0gaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb25zdHJ1Y3Rpb24gZmFpbHVyZS4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdXIgZGVwZW5kZW5jaWVzIGFyZSBjb25zdHJ1Y3RhYmxlLicsIHsgY2F1c2U6IG9ialtwcm9wXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqW3Byb3BdID09PSBfX3JlcXVlc3RlZF9fKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N5Y2xlIGRldGVjdGVkLiBQbGVhc2UgbWFrZSBcIicgKyBTdHJpbmcocHJvcCkgKyAnXCIgbGF6eS4gVmlzaXQgaHR0cHM6Ly9sYW5naXVtLm9yZy9kb2NzL3JlZmVyZW5jZS9jb25maWd1cmF0aW9uLXNlcnZpY2VzLyNyZXNvbHZpbmctY3ljbGljLWRlcGVuZGVuY2llcycpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmpbcHJvcF07XG4gICAgfVxuICAgIGVsc2UgaWYgKHByb3AgaW4gbW9kdWxlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbW9kdWxlW3Byb3BdO1xuICAgICAgICBvYmpbcHJvcF0gPSBfX3JlcXVlc3RlZF9fO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgb2JqW3Byb3BdID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykgPyB2YWx1ZShpbmplY3RvcikgOiBfaW5qZWN0KHZhbHVlLCBpbmplY3Rvcik7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBvYmpbcHJvcF0gPSBlcnJvciBpbnN0YW5jZW9mIEVycm9yID8gZXJyb3IgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqW3Byb3BdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG4vKipcbiAqIFBlcmZvcm1zIGEgZGVlcC1tZXJnZSBvZiB0d28gbW9kdWxlcyBieSB3cml0aW5nIHNvdXJjZSBlbnRyaWVzIGludG8gdGhlIHRhcmdldCBtb2R1bGUuXG4gKlxuICogQHBhcmFtIHRhcmdldCB0aGUgbW9kdWxlIHdoaWNoIGlzIHdyaXR0ZW5cbiAqIEBwYXJhbSBzb3VyY2UgdGhlIG1vZHVsZSB3aGljaCBpcyByZWFkXG4gKiBAcmV0dXJucyB0aGUgdGFyZ2V0IG1vZHVsZVxuICovXG5mdW5jdGlvbiBfbWVyZ2UodGFyZ2V0LCBzb3VyY2UpIHtcbiAgICBpZiAoc291cmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWUyXSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZTEgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUxICE9PSBudWxsICYmIHZhbHVlMiAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUxID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdmFsdWUyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IF9tZXJnZSh2YWx1ZTEsIHZhbHVlMik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlMjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRlcGVuZGVuY3ktaW5qZWN0aW9uLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IGlzQXN0Tm9kZVdpdGhDb21tZW50IH0gZnJvbSAnLi4vc2VyaWFsaXplci9qc29uLXNlcmlhbGl6ZXIuanMnO1xuaW1wb3J0IHsgZmluZENvbW1lbnROb2RlIH0gZnJvbSAnLi4vdXRpbHMvY3N0LXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0Q29tbWVudFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmdyYW1tYXJDb25maWcgPSAoKSA9PiBzZXJ2aWNlcy5wYXJzZXIuR3JhbW1hckNvbmZpZztcbiAgICB9XG4gICAgZ2V0Q29tbWVudChub2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGlzQXN0Tm9kZVdpdGhDb21tZW50KG5vZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZS4kY29tbWVudDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKF9hID0gZmluZENvbW1lbnROb2RlKG5vZGUuJGNzdE5vZGUsIHRoaXMuZ3JhbW1hckNvbmZpZygpLm11bHRpbGluZUNvbW1lbnRSdWxlcykpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS50ZXh0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1lbnQtcHJvdmlkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNKU0RvYywgcGFyc2VKU0RvYyB9IGZyb20gJy4vanNkb2MuanMnO1xuZXhwb3J0IGNsYXNzIEpTRG9jRG9jdW1lbnRhdGlvblByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmluZGV4TWFuYWdlciA9IHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuSW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLmNvbW1lbnRQcm92aWRlciA9IHNlcnZpY2VzLmRvY3VtZW50YXRpb24uQ29tbWVudFByb3ZpZGVyO1xuICAgIH1cbiAgICBnZXREb2N1bWVudGF0aW9uKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY29tbWVudCA9IHRoaXMuY29tbWVudFByb3ZpZGVyLmdldENvbW1lbnQobm9kZSk7XG4gICAgICAgIGlmIChjb21tZW50ICYmIGlzSlNEb2MoY29tbWVudCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZEpTRG9jID0gcGFyc2VKU0RvYyhjb21tZW50KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZWRKU0RvYy50b01hcmtkb3duKHtcbiAgICAgICAgICAgICAgICByZW5kZXJMaW5rOiAobGluaywgZGlzcGxheSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudGF0aW9uTGlua1JlbmRlcmVyKG5vZGUsIGxpbmssIGRpc3BsYXkpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgcmVuZGVyVGFnOiAodGFnKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRvY3VtZW50YXRpb25UYWdSZW5kZXJlcihub2RlLCB0YWcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRvY3VtZW50YXRpb25MaW5rUmVuZGVyZXIobm9kZSwgbmFtZSwgZGlzcGxheSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gKF9hID0gdGhpcy5maW5kTmFtZUluUHJlY29tcHV0ZWRTY29wZXMobm9kZSwgbmFtZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMuZmluZE5hbWVJbkdsb2JhbFNjb3BlKG5vZGUsIG5hbWUpO1xuICAgICAgICBpZiAoZGVzY3JpcHRpb24gJiYgZGVzY3JpcHRpb24ubmFtZVNlZ21lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmUgPSBkZXNjcmlwdGlvbi5uYW1lU2VnbWVudC5yYW5nZS5zdGFydC5saW5lICsgMTtcbiAgICAgICAgICAgIGNvbnN0IGNoYXJhY3RlciA9IGRlc2NyaXB0aW9uLm5hbWVTZWdtZW50LnJhbmdlLnN0YXJ0LmNoYXJhY3RlciArIDE7XG4gICAgICAgICAgICBjb25zdCB1cmkgPSBkZXNjcmlwdGlvbi5kb2N1bWVudFVyaS53aXRoKHsgZnJhZ21lbnQ6IGBMJHtsaW5lfSwke2NoYXJhY3Rlcn1gIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGBbJHtkaXNwbGF5fV0oJHt1cmkudG9TdHJpbmcoKX0pYDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9jdW1lbnRhdGlvblRhZ1JlbmRlcmVyKF9ub2RlLCBfdGFnKSB7XG4gICAgICAgIC8vIEZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCB0YWcgcmVuZGVyaW5nXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmROYW1lSW5QcmVjb21wdXRlZFNjb3Blcyhub2RlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZ2V0RG9jdW1lbnQobm9kZSk7XG4gICAgICAgIGNvbnN0IHByZWNvbXB1dGVkID0gZG9jdW1lbnQucHJlY29tcHV0ZWRTY29wZXM7XG4gICAgICAgIGlmICghcHJlY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnROb2RlID0gbm9kZTtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYWxsRGVzY3JpcHRpb25zID0gcHJlY29tcHV0ZWQuZ2V0KGN1cnJlbnROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gYWxsRGVzY3JpcHRpb25zLmZpbmQoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xuICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudE5vZGUgPSBjdXJyZW50Tm9kZS4kY29udGFpbmVyO1xuICAgICAgICB9IHdoaWxlIChjdXJyZW50Tm9kZSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmROYW1lSW5HbG9iYWxTY29wZShub2RlLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5pbmRleE1hbmFnZXIuYWxsRWxlbWVudHMoKS5maW5kKGUgPT4gZS5uYW1lID09PSBuYW1lKTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50YXRpb24tcHJvdmlkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgUG9zaXRpb24sIFJhbmdlIH0gZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzJztcbmltcG9ydCB7IE5FV0xJTkVfUkVHRVhQLCBlc2NhcGVSZWdFeHAgfSBmcm9tICcuLi91dGlscy9yZWdleHAtdXRpbHMuanMnO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUpTRG9jKG5vZGUsIHN0YXJ0LCBvcHRpb25zKSB7XG4gICAgbGV0IG9wdHM7XG4gICAgbGV0IHBvc2l0aW9uO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcG9zaXRpb24gPSBzdGFydDtcbiAgICAgICAgb3B0cyA9IG9wdGlvbnM7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBwb3NpdGlvbiA9IG5vZGUucmFuZ2Uuc3RhcnQ7XG4gICAgICAgIG9wdHMgPSBzdGFydDtcbiAgICB9XG4gICAgaWYgKCFwb3NpdGlvbikge1xuICAgICAgICBwb3NpdGlvbiA9IFBvc2l0aW9uLmNyZWF0ZSgwLCAwKTtcbiAgICB9XG4gICAgY29uc3QgbGluZXMgPSBnZXRMaW5lcyhub2RlKTtcbiAgICBjb25zdCBub3JtYWxpemVkT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0cyk7XG4gICAgY29uc3QgdG9rZW5zID0gdG9rZW5pemUoe1xuICAgICAgICBsaW5lcyxcbiAgICAgICAgcG9zaXRpb24sXG4gICAgICAgIG9wdGlvbnM6IG5vcm1hbGl6ZWRPcHRpb25zXG4gICAgfSk7XG4gICAgcmV0dXJuIHBhcnNlSlNEb2NDb21tZW50KHtcbiAgICAgICAgaW5kZXg6IDAsXG4gICAgICAgIHRva2VucyxcbiAgICAgICAgcG9zaXRpb25cbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0pTRG9jKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBub3JtYWxpemVkT3B0aW9ucyA9IG5vcm1hbGl6ZU9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgbGluZXMgPSBnZXRMaW5lcyhub2RlKTtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3QgPSBsaW5lc1swXTtcbiAgICBjb25zdCBsYXN0ID0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV07XG4gICAgY29uc3QgZmlyc3RSZWdleCA9IG5vcm1hbGl6ZWRPcHRpb25zLnN0YXJ0O1xuICAgIGNvbnN0IGxhc3RSZWdleCA9IG5vcm1hbGl6ZWRPcHRpb25zLmVuZDtcbiAgICByZXR1cm4gQm9vbGVhbihmaXJzdFJlZ2V4ID09PSBudWxsIHx8IGZpcnN0UmVnZXggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpcnN0UmVnZXguZXhlYyhmaXJzdCkpICYmIEJvb2xlYW4obGFzdFJlZ2V4ID09PSBudWxsIHx8IGxhc3RSZWdleCA9PT0gdm9pZCAwID8gdm9pZCAwIDogbGFzdFJlZ2V4LmV4ZWMobGFzdCkpO1xufVxuZnVuY3Rpb24gZ2V0TGluZXMobm9kZSkge1xuICAgIGxldCBjb250ZW50ID0gJyc7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBjb250ZW50ID0gbm9kZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnRlbnQgPSBub2RlLnRleHQ7XG4gICAgfVxuICAgIGNvbnN0IGxpbmVzID0gY29udGVudC5zcGxpdChORVdMSU5FX1JFR0VYUCk7XG4gICAgcmV0dXJuIGxpbmVzO1xufVxuY29uc3QgdGFnUmVnZXggPSAvXFxzKihAKFtcXHB7TH1dW1xccHtMfVxccHtOfV0qKT8pL3V5O1xuY29uc3QgaW5saW5lVGFnUmVnZXggPSAvXFx7KEBbXFxwe0x9XVtcXHB7TH1cXHB7Tn1dKikoXFxzKikoW15cXHJcXG59XSspP1xcfS9ndTtcbmZ1bmN0aW9uIHRva2VuaXplKGNvbnRleHQpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBsZXQgY3VycmVudExpbmUgPSBjb250ZXh0LnBvc2l0aW9uLmxpbmU7XG4gICAgbGV0IGN1cnJlbnRDaGFyYWN0ZXIgPSBjb250ZXh0LnBvc2l0aW9uLmNoYXJhY3RlcjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbnRleHQubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZmlyc3QgPSBpID09PSAwO1xuICAgICAgICBjb25zdCBsYXN0ID0gaSA9PT0gY29udGV4dC5saW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBsZXQgbGluZSA9IGNvbnRleHQubGluZXNbaV07XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGlmIChmaXJzdCAmJiBjb250ZXh0Lm9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gKF9hID0gY29udGV4dC5vcHRpb25zLnN0YXJ0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhlYyhsaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaCA9IChfYiA9IGNvbnRleHQub3B0aW9ucy5saW5lKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZXhlYyhsaW5lKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3QpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gKF9jID0gY29udGV4dC5vcHRpb25zLmVuZCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmV4ZWMobGluZSk7XG4gICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxpbmUgPSBsaW5lLnN1YnN0cmluZygwLCBsYXN0Q2hhcmFjdGVyKGxpbmUpKTtcbiAgICAgICAgY29uc3Qgd2hpdGVzcGFjZUVuZCA9IHNraXBXaGl0ZXNwYWNlKGxpbmUsIGluZGV4KTtcbiAgICAgICAgaWYgKHdoaXRlc3BhY2VFbmQgPj0gbGluZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIE9ubHkgY3JlYXRlIGEgYnJlYWsgdG9rZW4gd2hlbiB3ZSBhbHJlYWR5IGhhdmUgcHJldmlvdXMgdG9rZW5zXG4gICAgICAgICAgICBpZiAodG9rZW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IFBvc2l0aW9uLmNyZWF0ZShjdXJyZW50TGluZSwgY3VycmVudENoYXJhY3Rlcik7XG4gICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnYnJlYWsnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShwb3NpdGlvbiwgcG9zaXRpb24pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YWdSZWdleC5sYXN0SW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgIGNvbnN0IHRhZ01hdGNoID0gdGFnUmVnZXguZXhlYyhsaW5lKTtcbiAgICAgICAgICAgIGlmICh0YWdNYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZ1bGxNYXRjaCA9IHRhZ01hdGNoWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGFnTWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBQb3NpdGlvbi5jcmVhdGUoY3VycmVudExpbmUsIGN1cnJlbnRDaGFyYWN0ZXIgKyBpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kID0gUG9zaXRpb24uY3JlYXRlKGN1cnJlbnRMaW5lLCBjdXJyZW50Q2hhcmFjdGVyICsgaW5kZXggKyBmdWxsTWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0YWcnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShzdGFydCwgZW5kKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGluZGV4ICs9IGZ1bGxNYXRjaC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBza2lwV2hpdGVzcGFjZShsaW5lLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPCBsaW5lLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3QgPSBsaW5lLnN1YnN0cmluZyhpbmRleCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5saW5lVGFnTWF0Y2hlcyA9IEFycmF5LmZyb20ocmVzdC5tYXRjaEFsbChpbmxpbmVUYWdSZWdleCkpO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKC4uLmJ1aWxkSW5saW5lVG9rZW5zKGlubGluZVRhZ01hdGNoZXMsIHJlc3QsIGN1cnJlbnRMaW5lLCBjdXJyZW50Q2hhcmFjdGVyICsgaW5kZXgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50TGluZSsrO1xuICAgICAgICBjdXJyZW50Q2hhcmFjdGVyID0gMDtcbiAgICB9XG4gICAgLy8gUmVtb3ZlIGxhc3QgYnJlYWsgdG9rZW4gaWYgdGhlcmUgaXMgb25lXG4gICAgaWYgKHRva2Vucy5sZW5ndGggPiAwICYmIHRva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV0udHlwZSA9PT0gJ2JyZWFrJykge1xuICAgICAgICByZXR1cm4gdG9rZW5zLnNsaWNlKDAsIC0xKTtcbiAgICB9XG4gICAgcmV0dXJuIHRva2Vucztcbn1cbmZ1bmN0aW9uIGJ1aWxkSW5saW5lVG9rZW5zKHRhZ3MsIGxpbmUsIGxpbmVJbmRleCwgY2hhcmFjdGVySW5kZXgpIHtcbiAgICBjb25zdCB0b2tlbnMgPSBbXTtcbiAgICBpZiAodGFncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBjaGFyYWN0ZXJJbmRleCk7XG4gICAgICAgIGNvbnN0IGVuZCA9IFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGNoYXJhY3RlckluZGV4ICsgbGluZS5sZW5ndGgpO1xuICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICBjb250ZW50OiBsaW5lLFxuICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShzdGFydCwgZW5kKVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBsYXN0SW5kZXggPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IG1hdGNoIG9mIHRhZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoSW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0Q29udGVudCA9IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCwgbWF0Y2hJbmRleCk7XG4gICAgICAgICAgICBpZiAoc3RhcnRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogbGluZS5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaEluZGV4KSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBjaGFyYWN0ZXJJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIG1hdGNoSW5kZXggKyBjaGFyYWN0ZXJJbmRleCkpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgb2Zmc2V0ID0gc3RhcnRDb250ZW50Lmxlbmd0aCArIDE7XG4gICAgICAgICAgICBjb25zdCB0YWdOYW1lID0gbWF0Y2hbMV07XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogJ2lubGluZS10YWcnLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRhZ05hbWUsXG4gICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyBjaGFyYWN0ZXJJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGxhc3RJbmRleCArIG9mZnNldCArIHRhZ05hbWUubGVuZ3RoICsgY2hhcmFjdGVySW5kZXgpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gdGFnTmFtZS5sZW5ndGg7XG4gICAgICAgICAgICBpZiAobWF0Y2gubGVuZ3RoID09PSA0KSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0ICs9IG1hdGNoWzJdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG1hdGNoWzNdO1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyBjaGFyYWN0ZXJJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGxhc3RJbmRleCArIG9mZnNldCArIHZhbHVlLmxlbmd0aCArIGNoYXJhY3RlckluZGV4KSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2U6IFJhbmdlLmNyZWF0ZShQb3NpdGlvbi5jcmVhdGUobGluZUluZGV4LCBsYXN0SW5kZXggKyBvZmZzZXQgKyBjaGFyYWN0ZXJJbmRleCksIFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGxhc3RJbmRleCArIG9mZnNldCArIGNoYXJhY3RlckluZGV4KSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IG1hdGNoSW5kZXggKyBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5kQ29udGVudCA9IGxpbmUuc3Vic3RyaW5nKGxhc3RJbmRleCk7XG4gICAgICAgIGlmIChlbmRDb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXG4gICAgICAgICAgICAgICAgY29udGVudDogZW5kQ29udGVudCxcbiAgICAgICAgICAgICAgICByYW5nZTogUmFuZ2UuY3JlYXRlKFBvc2l0aW9uLmNyZWF0ZShsaW5lSW5kZXgsIGxhc3RJbmRleCArIGNoYXJhY3RlckluZGV4KSwgUG9zaXRpb24uY3JlYXRlKGxpbmVJbmRleCwgbGFzdEluZGV4ICsgY2hhcmFjdGVySW5kZXggKyBlbmRDb250ZW50Lmxlbmd0aCkpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdG9rZW5zO1xufVxuY29uc3Qgbm9uV2hpdGVzcGFjZVJlZ2V4ID0gL1xcUy87XG5jb25zdCB3aGl0ZXNwYWNlRW5kUmVnZXggPSAvXFxzKiQvO1xuZnVuY3Rpb24gc2tpcFdoaXRlc3BhY2UobGluZSwgaW5kZXgpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUuc3Vic3RyaW5nKGluZGV4KS5tYXRjaChub25XaGl0ZXNwYWNlUmVnZXgpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICByZXR1cm4gaW5kZXggKyBtYXRjaC5pbmRleDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBsaW5lLmxlbmd0aDtcbiAgICB9XG59XG5mdW5jdGlvbiBsYXN0Q2hhcmFjdGVyKGxpbmUpIHtcbiAgICBjb25zdCBtYXRjaCA9IGxpbmUubWF0Y2god2hpdGVzcGFjZUVuZFJlZ2V4KTtcbiAgICBpZiAobWF0Y2ggJiYgdHlwZW9mIG1hdGNoLmluZGV4ID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gbWF0Y2guaW5kZXg7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG4vLyBQYXJzaW5nXG5mdW5jdGlvbiBwYXJzZUpTRG9jQ29tbWVudChjb250ZXh0KSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgIGNvbnN0IHN0YXJ0UG9zaXRpb24gPSBQb3NpdGlvbi5jcmVhdGUoY29udGV4dC5wb3NpdGlvbi5saW5lLCBjb250ZXh0LnBvc2l0aW9uLmNoYXJhY3Rlcik7XG4gICAgaWYgKGNvbnRleHQudG9rZW5zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbmV3IEpTRG9jQ29tbWVudEltcGwoW10sIFJhbmdlLmNyZWF0ZShzdGFydFBvc2l0aW9uLCBzdGFydFBvc2l0aW9uKSk7XG4gICAgfVxuICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgd2hpbGUgKGNvbnRleHQuaW5kZXggPCBjb250ZXh0LnRva2Vucy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHBhcnNlSlNEb2NFbGVtZW50KGNvbnRleHQsIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGVsZW1lbnRzLnB1c2goZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgc3RhcnQgPSAoX2IgPSAoX2EgPSBlbGVtZW50c1swXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhbmdlLnN0YXJ0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBzdGFydFBvc2l0aW9uO1xuICAgIGNvbnN0IGVuZCA9IChfZCA9IChfYyA9IGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmFuZ2UuZW5kKSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBzdGFydFBvc2l0aW9uO1xuICAgIHJldHVybiBuZXcgSlNEb2NDb21tZW50SW1wbChlbGVtZW50cywgUmFuZ2UuY3JlYXRlKHN0YXJ0LCBlbmQpKTtcbn1cbmZ1bmN0aW9uIHBhcnNlSlNEb2NFbGVtZW50KGNvbnRleHQsIGxhc3QpIHtcbiAgICBjb25zdCBuZXh0ID0gY29udGV4dC50b2tlbnNbY29udGV4dC5pbmRleF07XG4gICAgaWYgKG5leHQudHlwZSA9PT0gJ3RhZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNEb2NUYWcoY29udGV4dCwgZmFsc2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0LnR5cGUgPT09ICd0ZXh0JyB8fCBuZXh0LnR5cGUgPT09ICdpbmxpbmUtdGFnJykge1xuICAgICAgICByZXR1cm4gcGFyc2VKU0RvY1RleHQoY29udGV4dCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhcHBlbmRFbXB0eUxpbmUobmV4dCwgbGFzdCk7XG4gICAgICAgIGNvbnRleHQuaW5kZXgrKztcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5mdW5jdGlvbiBhcHBlbmRFbXB0eUxpbmUodG9rZW4sIGVsZW1lbnQpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBjb25zdCBsaW5lID0gbmV3IEpTRG9jTGluZUltcGwoJycsIHRva2VuLnJhbmdlKTtcbiAgICAgICAgaWYgKCdpbmxpbmVzJyBpbiBlbGVtZW50KSB7XG4gICAgICAgICAgICBlbGVtZW50LmlubGluZXMucHVzaChsaW5lKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVsZW1lbnQuY29udGVudC5pbmxpbmVzLnB1c2gobGluZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUpTRG9jVGV4dChjb250ZXh0KSB7XG4gICAgbGV0IHRva2VuID0gY29udGV4dC50b2tlbnNbY29udGV4dC5pbmRleF07XG4gICAgY29uc3QgZmlyc3RUb2tlbiA9IHRva2VuO1xuICAgIGxldCBsYXN0VG9rZW4gPSB0b2tlbjtcbiAgICBjb25zdCBsaW5lcyA9IFtdO1xuICAgIHdoaWxlICh0b2tlbiAmJiB0b2tlbi50eXBlICE9PSAnYnJlYWsnICYmIHRva2VuLnR5cGUgIT09ICd0YWcnKSB7XG4gICAgICAgIGxpbmVzLnB1c2gocGFyc2VKU0RvY0lubGluZShjb250ZXh0KSk7XG4gICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICB0b2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEpTRG9jVGV4dEltcGwobGluZXMsIFJhbmdlLmNyZWF0ZShmaXJzdFRva2VuLnJhbmdlLnN0YXJ0LCBsYXN0VG9rZW4ucmFuZ2UuZW5kKSk7XG59XG5mdW5jdGlvbiBwYXJzZUpTRG9jSW5saW5lKGNvbnRleHQpIHtcbiAgICBjb25zdCB0b2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIGlmICh0b2tlbi50eXBlID09PSAnaW5saW5lLXRhZycpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSlNEb2NUYWcoY29udGV4dCwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGFyc2VKU0RvY0xpbmUoY29udGV4dCk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VKU0RvY1RhZyhjb250ZXh0LCBpbmxpbmUpIHtcbiAgICBjb25zdCB0YWdUb2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXgrK107XG4gICAgY29uc3QgbmFtZSA9IHRhZ1Rva2VuLmNvbnRlbnQuc3Vic3RyaW5nKDEpO1xuICAgIGNvbnN0IG5leHRUb2tlbiA9IGNvbnRleHQudG9rZW5zW2NvbnRleHQuaW5kZXhdO1xuICAgIGlmICgobmV4dFRva2VuID09PSBudWxsIHx8IG5leHRUb2tlbiA9PT0gdm9pZCAwID8gdm9pZCAwIDogbmV4dFRva2VuLnR5cGUpID09PSAndGV4dCcpIHtcbiAgICAgICAgaWYgKGlubGluZSkge1xuICAgICAgICAgICAgY29uc3QgZG9jTGluZSA9IHBhcnNlSlNEb2NMaW5lKGNvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBKU0RvY1RhZ0ltcGwobmFtZSwgbmV3IEpTRG9jVGV4dEltcGwoW2RvY0xpbmVdLCBkb2NMaW5lLnJhbmdlKSwgaW5saW5lLCBSYW5nZS5jcmVhdGUodGFnVG9rZW4ucmFuZ2Uuc3RhcnQsIGRvY0xpbmUucmFuZ2UuZW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jID0gcGFyc2VKU0RvY1RleHQoY29udGV4dCk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEpTRG9jVGFnSW1wbChuYW1lLCB0ZXh0RG9jLCBpbmxpbmUsIFJhbmdlLmNyZWF0ZSh0YWdUb2tlbi5yYW5nZS5zdGFydCwgdGV4dERvYy5yYW5nZS5lbmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmFuZ2UgPSB0YWdUb2tlbi5yYW5nZTtcbiAgICAgICAgcmV0dXJuIG5ldyBKU0RvY1RhZ0ltcGwobmFtZSwgbmV3IEpTRG9jVGV4dEltcGwoW10sIHJhbmdlKSwgaW5saW5lLCByYW5nZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFyc2VKU0RvY0xpbmUoY29udGV4dCkge1xuICAgIGNvbnN0IHRva2VuID0gY29udGV4dC50b2tlbnNbY29udGV4dC5pbmRleCsrXTtcbiAgICByZXR1cm4gbmV3IEpTRG9jTGluZUltcGwodG9rZW4uY29udGVudCwgdG9rZW4ucmFuZ2UpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBub3JtYWxpemVPcHRpb25zKHtcbiAgICAgICAgICAgIHN0YXJ0OiAnLyoqJyxcbiAgICAgICAgICAgIGVuZDogJyovJyxcbiAgICAgICAgICAgIGxpbmU6ICcqJ1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgeyBzdGFydCwgZW5kLCBsaW5lIH0gPSBvcHRpb25zO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiBub3JtYWxpemVPcHRpb24oc3RhcnQsIHRydWUpLFxuICAgICAgICBlbmQ6IG5vcm1hbGl6ZU9wdGlvbihlbmQsIGZhbHNlKSxcbiAgICAgICAgbGluZTogbm9ybWFsaXplT3B0aW9uKGxpbmUsIHRydWUpXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbihvcHRpb24sIHN0YXJ0KSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb24gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBvcHRpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnN0IGVzY2FwZWQgPSB0eXBlb2Ygb3B0aW9uID09PSAnc3RyaW5nJyA/IGVzY2FwZVJlZ0V4cChvcHRpb24pIDogb3B0aW9uLnNvdXJjZTtcbiAgICAgICAgaWYgKHN0YXJ0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChgXlxcXFxzKiR7ZXNjYXBlZH1gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKGBcXFxccyoke2VzY2FwZWR9XFxcXHMqJGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb3B0aW9uO1xuICAgIH1cbn1cbmNsYXNzIEpTRG9jQ29tbWVudEltcGwge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCByYW5nZSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICB9XG4gICAgZ2V0VGFnKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsVGFncygpLmZpbmQoZSA9PiBlLm5hbWUgPT09IG5hbWUpO1xuICAgIH1cbiAgICBnZXRUYWdzKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QWxsVGFncygpLmZpbHRlcihlID0+IGUubmFtZSA9PT0gbmFtZSk7XG4gICAgfVxuICAgIGdldEFsbFRhZ3MoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzLmZpbHRlcigoZSkgPT4gJ25hbWUnIGluIGUpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gJyc7XG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlbGVtZW50LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gZWxlbWVudC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIHZhbHVlICs9IGZpbGxOZXdsaW5lcyh2YWx1ZSkgKyB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZS50cmltKCk7XG4gICAgfVxuICAgIHRvTWFya2Rvd24ob3B0aW9ucykge1xuICAgICAgICBsZXQgdmFsdWUgPSAnJztcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVsZW1lbnQudG9NYXJrZG93bihvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBlbGVtZW50LnRvTWFya2Rvd24ob3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gZmlsbE5ld2xpbmVzKHZhbHVlKSArIHRleHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlLnRyaW0oKTtcbiAgICB9XG59XG5jbGFzcyBKU0RvY1RhZ0ltcGwge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIGNvbnRlbnQsIGlubGluZSwgcmFuZ2UpIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gY29udGVudDtcbiAgICAgICAgdGhpcy5pbmxpbmUgPSBpbmxpbmU7XG4gICAgICAgIHRoaXMucmFuZ2UgPSByYW5nZTtcbiAgICB9XG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gYEAke3RoaXMubmFtZX1gO1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmNvbnRlbnQuaW5saW5lcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIHRleHQgPSBgJHt0ZXh0fSAke2NvbnRlbnR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnQuaW5saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYCR7dGV4dH1cXG4ke2NvbnRlbnR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIC8vIElubGluZSB0YWdzIGFyZSBzdXJyb3VuZGVkIGJ5IGN1cmx5IGJyYWNlc1xuICAgICAgICAgICAgcmV0dXJuIGB7JHt0ZXh0fX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9NYXJrZG93bihvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmVuZGVyVGFnKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChvcHRpb25zLCB0aGlzKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy50b01hcmtkb3duRGVmYXVsdChvcHRpb25zKTtcbiAgICB9XG4gICAgdG9NYXJrZG93bkRlZmF1bHQob3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gdGhpcy5jb250ZW50LnRvTWFya2Rvd24ob3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLmlubGluZSkge1xuICAgICAgICAgICAgY29uc3QgcmVuZGVyZWQgPSByZW5kZXJJbmxpbmVUYWcodGhpcy5uYW1lLCBjb250ZW50LCBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlbmRlcmVkID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByZW5kZXJlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgbWFya2VyID0gJyc7XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRhZykgPT09ICdpdGFsaWMnIHx8IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGFnKSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSAnKic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50YWcpID09PSAnYm9sZCcpIHtcbiAgICAgICAgICAgIG1hcmtlciA9ICcqKic7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50YWcpID09PSAnYm9sZC1pdGFsaWMnKSB7XG4gICAgICAgICAgICBtYXJrZXIgPSAnKioqJztcbiAgICAgICAgfVxuICAgICAgICBsZXQgdGV4dCA9IGAke21hcmtlcn1AJHt0aGlzLm5hbWV9JHttYXJrZXJ9YDtcbiAgICAgICAgaWYgKHRoaXMuY29udGVudC5pbmxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdGV4dCA9IGAke3RleHR9IOKAlCAke2NvbnRlbnR9YDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnRlbnQuaW5saW5lcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0ZXh0ID0gYCR7dGV4dH1cXG4ke2NvbnRlbnR9YDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbmxpbmUpIHtcbiAgICAgICAgICAgIC8vIElubGluZSB0YWdzIGFyZSBzdXJyb3VuZGVkIGJ5IGN1cmx5IGJyYWNlc1xuICAgICAgICAgICAgcmV0dXJuIGB7JHt0ZXh0fX1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiByZW5kZXJJbmxpbmVUYWcodGFnLCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAodGFnID09PSAnbGlua3BsYWluJyB8fCB0YWcgPT09ICdsaW5rY29kZScgfHwgdGFnID09PSAnbGluaycpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBjb250ZW50LmluZGV4T2YoJyAnKTtcbiAgICAgICAgbGV0IGRpc3BsYXkgPSBjb250ZW50O1xuICAgICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNwbGF5U3RhcnQgPSBza2lwV2hpdGVzcGFjZShjb250ZW50LCBpbmRleCk7XG4gICAgICAgICAgICBkaXNwbGF5ID0gY29udGVudC5zdWJzdHJpbmcoZGlzcGxheVN0YXJ0KTtcbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PT0gJ2xpbmtjb2RlJyB8fCAodGFnID09PSAnbGluaycgJiYgb3B0aW9ucy5saW5rID09PSAnY29kZScpKSB7XG4gICAgICAgICAgICAvLyBTdXJyb3VuZCB0aGUgZGlzcGxheSB2YWx1ZSBpbiBhIG1hcmtkb3duIGlubGluZSBjb2RlIGJsb2NrXG4gICAgICAgICAgICBkaXNwbGF5ID0gYFxcYCR7ZGlzcGxheX1cXGBgO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkTGluayA9IChfYiA9IChfYSA9IG9wdGlvbnMucmVuZGVyTGluaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwob3B0aW9ucywgY29udGVudCwgZGlzcGxheSkpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHJlbmRlckxpbmtEZWZhdWx0KGNvbnRlbnQsIGRpc3BsYXkpO1xuICAgICAgICByZXR1cm4gcmVuZGVyZWRMaW5rO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gcmVuZGVyTGlua0RlZmF1bHQoY29udGVudCwgZGlzcGxheSkge1xuICAgIHRyeSB7XG4gICAgICAgIFVSSS5wYXJzZShjb250ZW50LCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGBbJHtkaXNwbGF5fV0oJHtjb250ZW50fSlgO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgfVxufVxuY2xhc3MgSlNEb2NUZXh0SW1wbCB7XG4gICAgY29uc3RydWN0b3IobGluZXMsIHJhbmdlKSB7XG4gICAgICAgIHRoaXMuaW5saW5lcyA9IGxpbmVzO1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICBsZXQgdGV4dCA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuaW5saW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgaW5saW5lID0gdGhpcy5pbmxpbmVzW2ldO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMuaW5saW5lc1tpICsgMV07XG4gICAgICAgICAgICB0ZXh0ICs9IGlubGluZS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKG5leHQgJiYgbmV4dC5yYW5nZS5zdGFydC5saW5lID4gaW5saW5lLnJhbmdlLnN0YXJ0LmxpbmUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9ICdcXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0O1xuICAgIH1cbiAgICB0b01hcmtkb3duKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IHRleHQgPSAnJztcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlubGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGlubGluZSA9IHRoaXMuaW5saW5lc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSB0aGlzLmlubGluZXNbaSArIDFdO1xuICAgICAgICAgICAgdGV4dCArPSBpbmxpbmUudG9NYXJrZG93bihvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChuZXh0ICYmIG5leHQucmFuZ2Uuc3RhcnQubGluZSA+IGlubGluZS5yYW5nZS5zdGFydC5saW5lKSB7XG4gICAgICAgICAgICAgICAgdGV4dCArPSAnXFxuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG59XG5jbGFzcyBKU0RvY0xpbmVJbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZXh0LCByYW5nZSkge1xuICAgICAgICB0aGlzLnRleHQgPSB0ZXh0O1xuICAgICAgICB0aGlzLnJhbmdlID0gcmFuZ2U7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbiAgICB0b01hcmtkb3duKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZpbGxOZXdsaW5lcyh0ZXh0KSB7XG4gICAgaWYgKHRleHQuZW5kc1dpdGgoJ1xcbicpKSB7XG4gICAgICAgIHJldHVybiAnXFxuJztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAnXFxuXFxuJztcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc2RvYy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBUaGlzIGZpbGUgd2FzIGdlbmVyYXRlZCBieSBsYW5naXVtLWNsaSAzLjMuMC5cbiAqIERPIE5PVCBFRElUIE1BTlVBTExZIVxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IEFic3RyYWN0QXN0UmVmbGVjdGlvbiB9IGZyb20gJy4uLy4uL3N5bnRheC10cmVlLmpzJztcbmV4cG9ydCBjb25zdCBMYW5naXVtR3JhbW1hclRlcm1pbmFscyA9IHtcbiAgICBJRDogL1xcXj9bX2EtekEtWl1bXFx3X10qLyxcbiAgICBTVFJJTkc6IC9cIihcXFxcLnxbXlwiXFxcXF0pKlwifCcoXFxcXC58W14nXFxcXF0pKicvLFxuICAgIE5VTUJFUjogL05hTnwtPygoXFxkKlxcLlxcZCt8XFxkKykoW0VlXVsrLV0/XFxkKyk/fEluZmluaXR5KS8sXG4gICAgUmVnZXhMaXRlcmFsOiAvXFwvKD8hWyorP10pKD86W15cXHJcXG5cXFsvXFxcXF18XFxcXC58XFxbKD86W15cXHJcXG5cXF1cXFxcXXxcXFxcLikqXFxdKStcXC9bYS16XSovLFxuICAgIFdTOiAvXFxzKy8sXG4gICAgTUxfQ09NTUVOVDogL1xcL1xcKltcXHNcXFNdKj9cXCpcXC8vLFxuICAgIFNMX0NPTU1FTlQ6IC9cXC9cXC9bXlxcblxccl0qLyxcbn07XG5leHBvcnQgY29uc3QgQWJzdHJhY3RSdWxlID0gJ0Fic3RyYWN0UnVsZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNBYnN0cmFjdFJ1bGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQWJzdHJhY3RSdWxlKTtcbn1cbmV4cG9ydCBjb25zdCBBYnN0cmFjdFR5cGUgPSAnQWJzdHJhY3RUeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0Fic3RyYWN0VHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBYnN0cmFjdFR5cGUpO1xufVxuZXhwb3J0IGNvbnN0IENvbmRpdGlvbiA9ICdDb25kaXRpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ29uZGl0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIENvbmRpdGlvbik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNGZWF0dXJlTmFtZShpdGVtKSB7XG4gICAgcmV0dXJuIGlzUHJpbWl0aXZlVHlwZShpdGVtKSB8fCBpdGVtID09PSAnY3VycmVudCcgfHwgaXRlbSA9PT0gJ2VudHJ5JyB8fCBpdGVtID09PSAnZXh0ZW5kcycgfHwgaXRlbSA9PT0gJ2ZhbHNlJyB8fCBpdGVtID09PSAnZnJhZ21lbnQnIHx8IGl0ZW0gPT09ICdncmFtbWFyJyB8fCBpdGVtID09PSAnaGlkZGVuJyB8fCBpdGVtID09PSAnaW1wb3J0JyB8fCBpdGVtID09PSAnaW50ZXJmYWNlJyB8fCBpdGVtID09PSAncmV0dXJucycgfHwgaXRlbSA9PT0gJ3Rlcm1pbmFsJyB8fCBpdGVtID09PSAndHJ1ZScgfHwgaXRlbSA9PT0gJ3R5cGUnIHx8IGl0ZW0gPT09ICdpbmZlcicgfHwgaXRlbSA9PT0gJ2luZmVycycgfHwgaXRlbSA9PT0gJ3dpdGgnIHx8ICh0eXBlb2YgaXRlbSA9PT0gJ3N0cmluZycgJiYgKC9cXF4/W19hLXpBLVpdW1xcd19dKi8udGVzdChpdGVtKSkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzUHJpbWl0aXZlVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0gPT09ICdzdHJpbmcnIHx8IGl0ZW0gPT09ICdudW1iZXInIHx8IGl0ZW0gPT09ICdib29sZWFuJyB8fCBpdGVtID09PSAnRGF0ZScgfHwgaXRlbSA9PT0gJ2JpZ2ludCc7XG59XG5leHBvcnQgY29uc3QgVHlwZURlZmluaXRpb24gPSAnVHlwZURlZmluaXRpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZURlZmluaXRpb24oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVHlwZURlZmluaXRpb24pO1xufVxuZXhwb3J0IGNvbnN0IFZhbHVlTGl0ZXJhbCA9ICdWYWx1ZUxpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVmFsdWVMaXRlcmFsKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFZhbHVlTGl0ZXJhbCk7XG59XG5leHBvcnQgY29uc3QgQWJzdHJhY3RFbGVtZW50ID0gJ0Fic3RyYWN0RWxlbWVudCc7XG5leHBvcnQgZnVuY3Rpb24gaXNBYnN0cmFjdEVsZW1lbnQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQWJzdHJhY3RFbGVtZW50KTtcbn1cbmV4cG9ydCBjb25zdCBBcnJheUxpdGVyYWwgPSAnQXJyYXlMaXRlcmFsJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5TGl0ZXJhbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBcnJheUxpdGVyYWwpO1xufVxuZXhwb3J0IGNvbnN0IEFycmF5VHlwZSA9ICdBcnJheVR5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlUeXBlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFycmF5VHlwZSk7XG59XG5leHBvcnQgY29uc3QgQm9vbGVhbkxpdGVyYWwgPSAnQm9vbGVhbkxpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQm9vbGVhbkxpdGVyYWwoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQm9vbGVhbkxpdGVyYWwpO1xufVxuZXhwb3J0IGNvbnN0IENvbmp1bmN0aW9uID0gJ0Nvbmp1bmN0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc0Nvbmp1bmN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIENvbmp1bmN0aW9uKTtcbn1cbmV4cG9ydCBjb25zdCBEaXNqdW5jdGlvbiA9ICdEaXNqdW5jdGlvbic7XG5leHBvcnQgZnVuY3Rpb24gaXNEaXNqdW5jdGlvbihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBEaXNqdW5jdGlvbik7XG59XG5leHBvcnQgY29uc3QgR3JhbW1hciA9ICdHcmFtbWFyJztcbmV4cG9ydCBmdW5jdGlvbiBpc0dyYW1tYXIoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgR3JhbW1hcik7XG59XG5leHBvcnQgY29uc3QgR3JhbW1hckltcG9ydCA9ICdHcmFtbWFySW1wb3J0JztcbmV4cG9ydCBmdW5jdGlvbiBpc0dyYW1tYXJJbXBvcnQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgR3JhbW1hckltcG9ydCk7XG59XG5leHBvcnQgY29uc3QgSW5mZXJyZWRUeXBlID0gJ0luZmVycmVkVHlwZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNJbmZlcnJlZFR5cGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgSW5mZXJyZWRUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBJbnRlcmZhY2UgPSAnSW50ZXJmYWNlJztcbmV4cG9ydCBmdW5jdGlvbiBpc0ludGVyZmFjZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBJbnRlcmZhY2UpO1xufVxuZXhwb3J0IGNvbnN0IE5hbWVkQXJndW1lbnQgPSAnTmFtZWRBcmd1bWVudCc7XG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lZEFyZ3VtZW50KGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIE5hbWVkQXJndW1lbnQpO1xufVxuZXhwb3J0IGNvbnN0IE5lZ2F0aW9uID0gJ05lZ2F0aW9uJztcbmV4cG9ydCBmdW5jdGlvbiBpc05lZ2F0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIE5lZ2F0aW9uKTtcbn1cbmV4cG9ydCBjb25zdCBOdW1iZXJMaXRlcmFsID0gJ051bWJlckxpdGVyYWwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTnVtYmVyTGl0ZXJhbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBOdW1iZXJMaXRlcmFsKTtcbn1cbmV4cG9ydCBjb25zdCBQYXJhbWV0ZXIgPSAnUGFyYW1ldGVyJztcbmV4cG9ydCBmdW5jdGlvbiBpc1BhcmFtZXRlcihpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBQYXJhbWV0ZXIpO1xufVxuZXhwb3J0IGNvbnN0IFBhcmFtZXRlclJlZmVyZW5jZSA9ICdQYXJhbWV0ZXJSZWZlcmVuY2UnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUGFyYW1ldGVyUmVmZXJlbmNlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFBhcmFtZXRlclJlZmVyZW5jZSk7XG59XG5leHBvcnQgY29uc3QgUGFyc2VyUnVsZSA9ICdQYXJzZXJSdWxlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1BhcnNlclJ1bGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUGFyc2VyUnVsZSk7XG59XG5leHBvcnQgY29uc3QgUmVmZXJlbmNlVHlwZSA9ICdSZWZlcmVuY2VUeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1JlZmVyZW5jZVR5cGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUmVmZXJlbmNlVHlwZSk7XG59XG5leHBvcnQgY29uc3QgUmV0dXJuVHlwZSA9ICdSZXR1cm5UeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1JldHVyblR5cGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUmV0dXJuVHlwZSk7XG59XG5leHBvcnQgY29uc3QgU2ltcGxlVHlwZSA9ICdTaW1wbGVUeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1NpbXBsZVR5cGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgU2ltcGxlVHlwZSk7XG59XG5leHBvcnQgY29uc3QgU3RyaW5nTGl0ZXJhbCA9ICdTdHJpbmdMaXRlcmFsJztcbmV4cG9ydCBmdW5jdGlvbiBpc1N0cmluZ0xpdGVyYWwoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgU3RyaW5nTGl0ZXJhbCk7XG59XG5leHBvcnQgY29uc3QgVGVybWluYWxSdWxlID0gJ1Rlcm1pbmFsUnVsZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNUZXJtaW5hbFJ1bGUoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVGVybWluYWxSdWxlKTtcbn1cbmV4cG9ydCBjb25zdCBUeXBlID0gJ1R5cGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUeXBlKTtcbn1cbmV4cG9ydCBjb25zdCBUeXBlQXR0cmlidXRlID0gJ1R5cGVBdHRyaWJ1dGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHlwZUF0dHJpYnV0ZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUeXBlQXR0cmlidXRlKTtcbn1cbmV4cG9ydCBjb25zdCBVbmlvblR5cGUgPSAnVW5pb25UeXBlJztcbmV4cG9ydCBmdW5jdGlvbiBpc1VuaW9uVHlwZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBVbmlvblR5cGUpO1xufVxuZXhwb3J0IGNvbnN0IEFjdGlvbiA9ICdBY3Rpb24nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQWN0aW9uKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEFjdGlvbik7XG59XG5leHBvcnQgY29uc3QgQWx0ZXJuYXRpdmVzID0gJ0FsdGVybmF0aXZlcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNBbHRlcm5hdGl2ZXMoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQWx0ZXJuYXRpdmVzKTtcbn1cbmV4cG9ydCBjb25zdCBBc3NpZ25tZW50ID0gJ0Fzc2lnbm1lbnQnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXNzaWdubWVudChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBBc3NpZ25tZW50KTtcbn1cbmV4cG9ydCBjb25zdCBDaGFyYWN0ZXJSYW5nZSA9ICdDaGFyYWN0ZXJSYW5nZSc7XG5leHBvcnQgZnVuY3Rpb24gaXNDaGFyYWN0ZXJSYW5nZShpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBDaGFyYWN0ZXJSYW5nZSk7XG59XG5leHBvcnQgY29uc3QgQ3Jvc3NSZWZlcmVuY2UgPSAnQ3Jvc3NSZWZlcmVuY2UnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ3Jvc3NSZWZlcmVuY2UoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgQ3Jvc3NSZWZlcmVuY2UpO1xufVxuZXhwb3J0IGNvbnN0IEVuZE9mRmlsZSA9ICdFbmRPZkZpbGUnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW5kT2ZGaWxlKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEVuZE9mRmlsZSk7XG59XG5leHBvcnQgY29uc3QgR3JvdXAgPSAnR3JvdXAnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzR3JvdXAoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgR3JvdXApO1xufVxuZXhwb3J0IGNvbnN0IEtleXdvcmQgPSAnS2V5d29yZCc7XG5leHBvcnQgZnVuY3Rpb24gaXNLZXl3b3JkKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIEtleXdvcmQpO1xufVxuZXhwb3J0IGNvbnN0IE5lZ2F0ZWRUb2tlbiA9ICdOZWdhdGVkVG9rZW4nO1xuZXhwb3J0IGZ1bmN0aW9uIGlzTmVnYXRlZFRva2VuKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIE5lZ2F0ZWRUb2tlbik7XG59XG5leHBvcnQgY29uc3QgUmVnZXhUb2tlbiA9ICdSZWdleFRva2VuJztcbmV4cG9ydCBmdW5jdGlvbiBpc1JlZ2V4VG9rZW4oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUmVnZXhUb2tlbik7XG59XG5leHBvcnQgY29uc3QgUnVsZUNhbGwgPSAnUnVsZUNhbGwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzUnVsZUNhbGwoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgUnVsZUNhbGwpO1xufVxuZXhwb3J0IGNvbnN0IFRlcm1pbmFsQWx0ZXJuYXRpdmVzID0gJ1Rlcm1pbmFsQWx0ZXJuYXRpdmVzJztcbmV4cG9ydCBmdW5jdGlvbiBpc1Rlcm1pbmFsQWx0ZXJuYXRpdmVzKGl0ZW0pIHtcbiAgICByZXR1cm4gcmVmbGVjdGlvbi5pc0luc3RhbmNlKGl0ZW0sIFRlcm1pbmFsQWx0ZXJuYXRpdmVzKTtcbn1cbmV4cG9ydCBjb25zdCBUZXJtaW5hbEdyb3VwID0gJ1Rlcm1pbmFsR3JvdXAnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGVybWluYWxHcm91cChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUZXJtaW5hbEdyb3VwKTtcbn1cbmV4cG9ydCBjb25zdCBUZXJtaW5hbFJ1bGVDYWxsID0gJ1Rlcm1pbmFsUnVsZUNhbGwnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzVGVybWluYWxSdWxlQ2FsbChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBUZXJtaW5hbFJ1bGVDYWxsKTtcbn1cbmV4cG9ydCBjb25zdCBVbm9yZGVyZWRHcm91cCA9ICdVbm9yZGVyZWRHcm91cCc7XG5leHBvcnQgZnVuY3Rpb24gaXNVbm9yZGVyZWRHcm91cChpdGVtKSB7XG4gICAgcmV0dXJuIHJlZmxlY3Rpb24uaXNJbnN0YW5jZShpdGVtLCBVbm9yZGVyZWRHcm91cCk7XG59XG5leHBvcnQgY29uc3QgVW50aWxUb2tlbiA9ICdVbnRpbFRva2VuJztcbmV4cG9ydCBmdW5jdGlvbiBpc1VudGlsVG9rZW4oaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgVW50aWxUb2tlbik7XG59XG5leHBvcnQgY29uc3QgV2lsZGNhcmQgPSAnV2lsZGNhcmQnO1xuZXhwb3J0IGZ1bmN0aW9uIGlzV2lsZGNhcmQoaXRlbSkge1xuICAgIHJldHVybiByZWZsZWN0aW9uLmlzSW5zdGFuY2UoaXRlbSwgV2lsZGNhcmQpO1xufVxuZXhwb3J0IGNsYXNzIExhbmdpdW1HcmFtbWFyQXN0UmVmbGVjdGlvbiBleHRlbmRzIEFic3RyYWN0QXN0UmVmbGVjdGlvbiB7XG4gICAgZ2V0QWxsVHlwZXMoKSB7XG4gICAgICAgIHJldHVybiBbQWJzdHJhY3RFbGVtZW50LCBBYnN0cmFjdFJ1bGUsIEFic3RyYWN0VHlwZSwgQWN0aW9uLCBBbHRlcm5hdGl2ZXMsIEFycmF5TGl0ZXJhbCwgQXJyYXlUeXBlLCBBc3NpZ25tZW50LCBCb29sZWFuTGl0ZXJhbCwgQ2hhcmFjdGVyUmFuZ2UsIENvbmRpdGlvbiwgQ29uanVuY3Rpb24sIENyb3NzUmVmZXJlbmNlLCBEaXNqdW5jdGlvbiwgRW5kT2ZGaWxlLCBHcmFtbWFyLCBHcmFtbWFySW1wb3J0LCBHcm91cCwgSW5mZXJyZWRUeXBlLCBJbnRlcmZhY2UsIEtleXdvcmQsIE5hbWVkQXJndW1lbnQsIE5lZ2F0ZWRUb2tlbiwgTmVnYXRpb24sIE51bWJlckxpdGVyYWwsIFBhcmFtZXRlciwgUGFyYW1ldGVyUmVmZXJlbmNlLCBQYXJzZXJSdWxlLCBSZWZlcmVuY2VUeXBlLCBSZWdleFRva2VuLCBSZXR1cm5UeXBlLCBSdWxlQ2FsbCwgU2ltcGxlVHlwZSwgU3RyaW5nTGl0ZXJhbCwgVGVybWluYWxBbHRlcm5hdGl2ZXMsIFRlcm1pbmFsR3JvdXAsIFRlcm1pbmFsUnVsZSwgVGVybWluYWxSdWxlQ2FsbCwgVHlwZSwgVHlwZUF0dHJpYnV0ZSwgVHlwZURlZmluaXRpb24sIFVuaW9uVHlwZSwgVW5vcmRlcmVkR3JvdXAsIFVudGlsVG9rZW4sIFZhbHVlTGl0ZXJhbCwgV2lsZGNhcmRdO1xuICAgIH1cbiAgICBjb21wdXRlSXNTdWJ0eXBlKHN1YnR5cGUsIHN1cGVydHlwZSkge1xuICAgICAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQWN0aW9uOlxuICAgICAgICAgICAgY2FzZSBBbHRlcm5hdGl2ZXM6XG4gICAgICAgICAgICBjYXNlIEFzc2lnbm1lbnQ6XG4gICAgICAgICAgICBjYXNlIENoYXJhY3RlclJhbmdlOlxuICAgICAgICAgICAgY2FzZSBDcm9zc1JlZmVyZW5jZTpcbiAgICAgICAgICAgIGNhc2UgRW5kT2ZGaWxlOlxuICAgICAgICAgICAgY2FzZSBHcm91cDpcbiAgICAgICAgICAgIGNhc2UgS2V5d29yZDpcbiAgICAgICAgICAgIGNhc2UgTmVnYXRlZFRva2VuOlxuICAgICAgICAgICAgY2FzZSBSZWdleFRva2VuOlxuICAgICAgICAgICAgY2FzZSBSdWxlQ2FsbDpcbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxBbHRlcm5hdGl2ZXM6XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsR3JvdXA6XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsUnVsZUNhbGw6XG4gICAgICAgICAgICBjYXNlIFVub3JkZXJlZEdyb3VwOlxuICAgICAgICAgICAgY2FzZSBVbnRpbFRva2VuOlxuICAgICAgICAgICAgY2FzZSBXaWxkY2FyZDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShBYnN0cmFjdEVsZW1lbnQsIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFycmF5TGl0ZXJhbDpcbiAgICAgICAgICAgIGNhc2UgTnVtYmVyTGl0ZXJhbDpcbiAgICAgICAgICAgIGNhc2UgU3RyaW5nTGl0ZXJhbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShWYWx1ZUxpdGVyYWwsIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFycmF5VHlwZTpcbiAgICAgICAgICAgIGNhc2UgUmVmZXJlbmNlVHlwZTpcbiAgICAgICAgICAgIGNhc2UgU2ltcGxlVHlwZTpcbiAgICAgICAgICAgIGNhc2UgVW5pb25UeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKFR5cGVEZWZpbml0aW9uLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBCb29sZWFuTGl0ZXJhbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShDb25kaXRpb24sIHN1cGVydHlwZSkgfHwgdGhpcy5pc1N1YnR5cGUoVmFsdWVMaXRlcmFsLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDb25qdW5jdGlvbjpcbiAgICAgICAgICAgIGNhc2UgRGlzanVuY3Rpb246XG4gICAgICAgICAgICBjYXNlIE5lZ2F0aW9uOlxuICAgICAgICAgICAgY2FzZSBQYXJhbWV0ZXJSZWZlcmVuY2U6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoQ29uZGl0aW9uLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJbmZlcnJlZFR5cGU6XG4gICAgICAgICAgICBjYXNlIEludGVyZmFjZTpcbiAgICAgICAgICAgIGNhc2UgVHlwZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmlzU3VidHlwZShBYnN0cmFjdFR5cGUsIHN1cGVydHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBhcnNlclJ1bGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5pc1N1YnR5cGUoQWJzdHJhY3RSdWxlLCBzdXBlcnR5cGUpIHx8IHRoaXMuaXNTdWJ0eXBlKEFic3RyYWN0VHlwZSwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxSdWxlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaXNTdWJ0eXBlKEFic3RyYWN0UnVsZSwgc3VwZXJ0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0UmVmZXJlbmNlVHlwZShyZWZJbmZvKSB7XG4gICAgICAgIGNvbnN0IHJlZmVyZW5jZUlkID0gYCR7cmVmSW5mby5jb250YWluZXIuJHR5cGV9OiR7cmVmSW5mby5wcm9wZXJ0eX1gO1xuICAgICAgICBzd2l0Y2ggKHJlZmVyZW5jZUlkKSB7XG4gICAgICAgICAgICBjYXNlICdBY3Rpb246dHlwZSc6XG4gICAgICAgICAgICBjYXNlICdDcm9zc1JlZmVyZW5jZTp0eXBlJzpcbiAgICAgICAgICAgIGNhc2UgJ0ludGVyZmFjZTpzdXBlclR5cGVzJzpcbiAgICAgICAgICAgIGNhc2UgJ1BhcnNlclJ1bGU6cmV0dXJuVHlwZSc6XG4gICAgICAgICAgICBjYXNlICdTaW1wbGVUeXBlOnR5cGVSZWYnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0VHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0dyYW1tYXI6aGlkZGVuVG9rZW5zJzpcbiAgICAgICAgICAgIGNhc2UgJ1BhcnNlclJ1bGU6aGlkZGVuVG9rZW5zJzpcbiAgICAgICAgICAgIGNhc2UgJ1J1bGVDYWxsOnJ1bGUnOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFic3RyYWN0UnVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0dyYW1tYXI6dXNlZEdyYW1tYXJzJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBHcmFtbWFyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTmFtZWRBcmd1bWVudDpwYXJhbWV0ZXInOlxuICAgICAgICAgICAgY2FzZSAnUGFyYW1ldGVyUmVmZXJlbmNlOnBhcmFtZXRlcic6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUGFyYW1ldGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnVGVybWluYWxSdWxlQ2FsbDpydWxlJzoge1xuICAgICAgICAgICAgICAgIHJldHVybiBUZXJtaW5hbFJ1bGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3JlZmVyZW5jZUlkfSBpcyBub3QgYSB2YWxpZCByZWZlcmVuY2UgaWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VHlwZU1ldGFEYXRhKHR5cGUpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIEFic3RyYWN0RWxlbWVudDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEFic3RyYWN0RWxlbWVudCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFycmF5TGl0ZXJhbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEFycmF5TGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudHMnLCBkZWZhdWx0VmFsdWU6IFtdIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFycmF5VHlwZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEFycmF5VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudFR5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEJvb2xlYW5MaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQm9vbGVhbkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3RydWUnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENvbmp1bmN0aW9uOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQ29uanVuY3Rpb24sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xlZnQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdyaWdodCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgRGlzanVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBEaXNqdW5jdGlvbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbGVmdCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0JyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmFtbWFyOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogR3JhbW1hcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZGVmaW5lc0hpZGRlblRva2VucycsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2hpZGRlblRva2VucycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2ltcG9ydHMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdpbnRlcmZhY2VzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaXNEZWNsYXJlZCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdydWxlcycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGVzJywgZGVmYXVsdFZhbHVlOiBbXSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndXNlZEdyYW1tYXJzJywgZGVmYXVsdFZhbHVlOiBbXSB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBHcmFtbWFySW1wb3J0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogR3JhbW1hckltcG9ydCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncGF0aCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgSW5mZXJyZWRUeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogSW5mZXJyZWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBJbnRlcmZhY2U6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBJbnRlcmZhY2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2F0dHJpYnV0ZXMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnc3VwZXJUeXBlcycsIGRlZmF1bHRWYWx1ZTogW10gfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTmFtZWRBcmd1bWVudDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IE5hbWVkQXJndW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhbGxlZEJ5TmFtZScsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3BhcmFtZXRlcicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ZhbHVlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBOZWdhdGlvbjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IE5lZ2F0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd2YWx1ZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgTnVtYmVyTGl0ZXJhbDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IE51bWJlckxpdGVyYWwsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3ZhbHVlJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQYXJhbWV0ZXI6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBQYXJhbWV0ZXIsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ25hbWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFBhcmFtZXRlclJlZmVyZW5jZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFBhcmFtZXRlclJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncGFyYW1ldGVyJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBQYXJzZXJSdWxlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogUGFyc2VyUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZGF0YVR5cGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdkZWZpbmVzSGlkZGVuVG9rZW5zJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZGVmaW5pdGlvbicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2VudHJ5JywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZnJhZ21lbnQnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdoaWRkZW5Ub2tlbnMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdpbmZlcnJlZFR5cGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncGFyYW1ldGVycycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JldHVyblR5cGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd3aWxkY2FyZCcsIGRlZmF1bHRWYWx1ZTogZmFsc2UgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUmVmZXJlbmNlVHlwZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFJlZmVyZW5jZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JlZmVyZW5jZVR5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFJldHVyblR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBSZXR1cm5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTaW1wbGVUeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogU2ltcGxlVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncHJpbWl0aXZlVHlwZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3N0cmluZ1R5cGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlUmVmJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTdHJpbmdMaXRlcmFsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogU3RyaW5nTGl0ZXJhbCxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsUnVsZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFRlcm1pbmFsUnVsZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZGVmaW5pdGlvbicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2ZyYWdtZW50JywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnaGlkZGVuJywgZGVmYXVsdFZhbHVlOiBmYWxzZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbmFtZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFR5cGU6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBUeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVHlwZUF0dHJpYnV0ZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFR5cGVBdHRyaWJ1dGUsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlZmF1bHRWYWx1ZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2lzT3B0aW9uYWwnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICduYW1lJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndHlwZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVW5pb25UeXBlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogVW5pb25UeXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0eXBlcycsIGRlZmF1bHRWYWx1ZTogW10gfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQWN0aW9uOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQWN0aW9uLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2ZlYXR1cmUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdpbmZlcnJlZFR5cGUnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdvcGVyYXRvcicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEFsdGVybmF0aXZlczoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEFsdGVybmF0aXZlcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgQXNzaWdubWVudDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZmVhdHVyZScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ29wZXJhdG9yJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndGVybWluYWwnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIENoYXJhY3RlclJhbmdlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogQ2hhcmFjdGVyUmFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbGVmdCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3JpZ2h0JyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBDcm9zc1JlZmVyZW5jZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IENyb3NzUmVmZXJlbmNlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2RlcHJlY2F0ZWRTeW50YXgnLCBkZWZhdWx0VmFsdWU6IGZhbHNlIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0ZXJtaW5hbCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3R5cGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEVuZE9mRmlsZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEVuZE9mRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIEdyb3VwOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudHMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdndWFyZENvbmRpdGlvbicgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgS2V5d29yZDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IEtleXdvcmQsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAndmFsdWUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE5lZ2F0ZWRUb2tlbjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IE5lZ2F0ZWRUb2tlbixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICd0ZXJtaW5hbCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgUmVnZXhUb2tlbjoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFJlZ2V4VG9rZW4sXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncmVnZXgnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFJ1bGVDYWxsOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogUnVsZUNhbGwsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2FyZ3VtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnbG9va2FoZWFkJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAncnVsZScgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxBbHRlcm5hdGl2ZXM6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBUZXJtaW5hbEFsdGVybmF0aXZlcyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnY2FyZGluYWxpdHknIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdlbGVtZW50cycsIGRlZmF1bHRWYWx1ZTogW10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgVGVybWluYWxHcm91cDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFRlcm1pbmFsR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudHMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFRlcm1pbmFsUnVsZUNhbGw6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBUZXJtaW5hbFJ1bGVDYWxsLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3J1bGUnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFVub3JkZXJlZEdyb3VwOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogVW5vcmRlcmVkR3JvdXAsXG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2NhcmRpbmFsaXR5JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBuYW1lOiAnZWxlbWVudHMnLCBkZWZhdWx0VmFsdWU6IFtdIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdsb29rYWhlYWQnIH1cbiAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFVudGlsVG9rZW46IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBVbnRpbFRva2VuLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ3Rlcm1pbmFsJyB9XG4gICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBXaWxkY2FyZDoge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFdpbGRjYXJkLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IG5hbWU6ICdjYXJkaW5hbGl0eScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgbmFtZTogJ2xvb2thaGVhZCcgfVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBbXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY29uc3QgcmVmbGVjdGlvbiA9IG5ldyBMYW5naXVtR3JhbW1hckFzdFJlZmxlY3Rpb24oKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBEZWZhdWx0TmFtZVJlZ2V4cCB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpc0NvbW1lbnRUZXJtaW5hbCwgdGVybWluYWxSZWdleCB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNNdWx0aWxpbmVDb21tZW50IH0gZnJvbSAnLi4vdXRpbHMvcmVnZXhwLXV0aWxzLmpzJztcbmltcG9ydCB7IGlzVGVybWluYWxSdWxlIH0gZnJvbSAnLi9nZW5lcmF0ZWQvYXN0LmpzJztcbi8qKlxuICogQ3JlYXRlIHRoZSBkZWZhdWx0IGdyYW1tYXIgY29uZmlndXJhdGlvbiAodXNlZCBieSBgY3JlYXRlRGVmYXVsdE1vZHVsZWApLiBUaGlzIGNhbiBiZSBvdmVycmlkZGVuIGluIGFcbiAqIGxhbmd1YWdlLXNwZWNpZmljIG1vZHVsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUdyYW1tYXJDb25maWcoc2VydmljZXMpIHtcbiAgICBjb25zdCBydWxlcyA9IFtdO1xuICAgIGNvbnN0IGdyYW1tYXIgPSBzZXJ2aWNlcy5HcmFtbWFyO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiBncmFtbWFyLnJ1bGVzKSB7XG4gICAgICAgIGlmIChpc1Rlcm1pbmFsUnVsZShydWxlKSAmJiBpc0NvbW1lbnRUZXJtaW5hbChydWxlKSAmJiBpc011bHRpbGluZUNvbW1lbnQodGVybWluYWxSZWdleChydWxlKSkpIHtcbiAgICAgICAgICAgIHJ1bGVzLnB1c2gocnVsZS5uYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBtdWx0aWxpbmVDb21tZW50UnVsZXM6IHJ1bGVzLFxuICAgICAgICBuYW1lUmVnZXhwOiBEZWZhdWx0TmFtZVJlZ2V4cFxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ncmFtbWFyLWNvbmZpZy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMyBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBEZWZlcnJlZCwgT3BlcmF0aW9uQ2FuY2VsbGVkIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBFbWl0dGVyIH0gZnJvbSAnLi4vdXRpbHMvZXZlbnQuanMnO1xuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIG9mIHRoZSBhc3luYyBwYXJzZXIgd2hpY2ggc2ltcGx5IHdyYXBzIHRoZSBzeW5jIHBhcnNlciBpbiBhIHByb21pc2UuXG4gKlxuICogQHJlbWFya3NcbiAqIEEgcmVhbCBpbXBsZW1lbnRhdGlvbiB3b3VsZCBjcmVhdGUgd29ya2VyIHRocmVhZHMgb3Igd2ViIHdvcmtlcnMgdG8gb2ZmbG9hZCB0aGUgcGFyc2luZyB3b3JrLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdEFzeW5jUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLnN5bmNQYXJzZXIgPSBzZXJ2aWNlcy5wYXJzZXIuTGFuZ2l1bVBhcnNlcjtcbiAgICB9XG4gICAgcGFyc2UodGV4dCwgX2NhbmNlbFRva2VuKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5zeW5jUGFyc2VyLnBhcnNlKHRleHQpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQWJzdHJhY3RUaHJlYWRlZEFzeW5jUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRocmVhZCBjb3VudCBkZXRlcm1pbmVzIGhvdyBtYW55IHRocmVhZHMgYXJlIHVzZWQgdG8gcGFyc2UgZmlsZXMgaW4gcGFyYWxsZWwuXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IHZhbHVlIGlzIDguIERlY3JlYXNpbmcgdGhpcyB2YWx1ZSBpbmNyZWFzZXMgc3RhcnR1cCBwZXJmb3JtYW5jZSwgYnV0IGRlY3JlYXNlcyBwYXJhbGxlbCBwYXJzaW5nIHBlcmZvcm1hbmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy50aHJlYWRDb3VudCA9IDg7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGVybWluYXRpb24gZGVsYXkgZGV0ZXJtaW5lcyBob3cgbG9uZyB0aGUgcGFyc2VyIHdhaXRzIGZvciBhIHRocmVhZCB0byBmaW5pc2ggYWZ0ZXIgYSBjYW5jZWxsYXRpb24gcmVxdWVzdC5cbiAgICAgICAgICogVGhlIGRlZmF1bHQgdmFsdWUgaXMgMjAwKG1zKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudGVybWluYXRpb25EZWxheSA9IDIwMDtcbiAgICAgICAgdGhpcy53b3JrZXJQb29sID0gW107XG4gICAgICAgIHRoaXMucXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5oeWRyYXRvciA9IHNlcnZpY2VzLnNlcmlhbGl6ZXIuSHlkcmF0b3I7XG4gICAgfVxuICAgIGluaXRpYWxpemVXb3JrZXJzKCkge1xuICAgICAgICB3aGlsZSAodGhpcy53b3JrZXJQb29sLmxlbmd0aCA8IHRoaXMudGhyZWFkQ291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHdvcmtlciA9IHRoaXMuY3JlYXRlV29ya2VyKCk7XG4gICAgICAgICAgICB3b3JrZXIub25SZWFkeSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMucXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRlZmVycmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3b3JrZXIubG9jaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh3b3JrZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLndvcmtlclBvb2wucHVzaCh3b3JrZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHBhcnNlKHRleHQsIGNhbmNlbFRva2VuKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGF3YWl0IHRoaXMuYWNxdWlyZVBhcnNlcldvcmtlcihjYW5jZWxUb2tlbik7XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIGxldCB0aW1lb3V0O1xuICAgICAgICAvLyBJZiB0aGUgY2FuY2VsbGF0aW9uIHRva2VuIGlzIHJlcXVlc3RlZCwgd2Ugd2FpdCBmb3IgYSBjZXJ0YWluIHRpbWUgYmVmb3JlIHRlcm1pbmF0aW5nIHRoZSB3b3JrZXIuXG4gICAgICAgIC8vIFNpbmNlIHRoZSBjYW5jZWxsYXRpb24gdG9rZW4gbGl2ZXMgbG9uZ2VyIHRoYW4gdGhlIHBhcnNpbmcgcHJvY2Vzcywgd2UgbmVlZCB0byBkaXNwb3NlIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCB3ZSBtaWdodCBhY2NpZGVudGFsbHkgdGVybWluYXRlIHRoZSB3b3JrZXIgYWZ0ZXIgdGhlIHBhcnNpbmcgcHJvY2VzcyBoYXMgZmluaXNoZWQuXG4gICAgICAgIGNvbnN0IGNhbmNlbGxhdGlvbiA9IGNhbmNlbFRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCgpID0+IHtcbiAgICAgICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnRlcm1pbmF0ZVdvcmtlcih3b3JrZXIpO1xuICAgICAgICAgICAgfSwgdGhpcy50ZXJtaW5hdGlvbkRlbGF5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHdvcmtlci5wYXJzZSh0ZXh0KS50aGVuKHJlc3VsdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBoeWRyYXRlZCA9IHRoaXMuaHlkcmF0b3IuaHlkcmF0ZShyZXN1bHQpO1xuICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShoeWRyYXRlZCk7XG4gICAgICAgIH0pLmNhdGNoKGVyciA9PiB7XG4gICAgICAgICAgICBkZWZlcnJlZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgICAgICBjYW5jZWxsYXRpb24uZGlzcG9zZSgpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIHRlcm1pbmF0ZVdvcmtlcih3b3JrZXIpIHtcbiAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMud29ya2VyUG9vbC5pbmRleE9mKHdvcmtlcik7XG4gICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICB0aGlzLndvcmtlclBvb2wuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBhY3F1aXJlUGFyc2VyV29ya2VyKGNhbmNlbFRva2VuKSB7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZVdvcmtlcnMoKTtcbiAgICAgICAgZm9yIChjb25zdCB3b3JrZXIgb2YgdGhpcy53b3JrZXJQb29sKSB7XG4gICAgICAgICAgICBpZiAod29ya2VyLnJlYWR5KSB7XG4gICAgICAgICAgICAgICAgd29ya2VyLmxvY2soKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd29ya2VyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRlZmVycmVkID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIGNhbmNlbFRva2VuLm9uQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5xdWV1ZS5pbmRleE9mKGRlZmVycmVkKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5xdWV1ZS5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KE9wZXJhdGlvbkNhbmNlbGxlZCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnF1ZXVlLnB1c2goZGVmZXJyZWQpO1xuICAgICAgICByZXR1cm4gZGVmZXJyZWQucHJvbWlzZTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUGFyc2VyV29ya2VyIHtcbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeTtcbiAgICB9XG4gICAgZ2V0IG9uUmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uUmVhZHlFbWl0dGVyLmV2ZW50O1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzZW5kTWVzc2FnZSwgb25NZXNzYWdlLCBvbkVycm9yLCB0ZXJtaW5hdGUpIHtcbiAgICAgICAgdGhpcy5vblJlYWR5RW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLl9wYXJzaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UgPSBzZW5kTWVzc2FnZTtcbiAgICAgICAgdGhpcy5fdGVybWluYXRlID0gdGVybWluYXRlO1xuICAgICAgICBvbk1lc3NhZ2UocmVzdWx0ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gcmVzdWx0O1xuICAgICAgICAgICAgdGhpcy5kZWZlcnJlZC5yZXNvbHZlKHBhcnNlUmVzdWx0KTtcbiAgICAgICAgICAgIHRoaXMudW5sb2NrKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBvbkVycm9yKGVycm9yID0+IHtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgIHRoaXMudW5sb2NrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB0ZXJtaW5hdGUoKSB7XG4gICAgICAgIHRoaXMuZGVmZXJyZWQucmVqZWN0KE9wZXJhdGlvbkNhbmNlbGxlZCk7XG4gICAgICAgIHRoaXMuX3Rlcm1pbmF0ZSgpO1xuICAgIH1cbiAgICBsb2NrKCkge1xuICAgICAgICB0aGlzLl9yZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICB1bmxvY2soKSB7XG4gICAgICAgIHRoaXMuX3BhcnNpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uUmVhZHlFbWl0dGVyLmZpcmUoKTtcbiAgICB9XG4gICAgcGFyc2UodGV4dCkge1xuICAgICAgICBpZiAodGhpcy5fcGFyc2luZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQYXJzZXIgd29ya2VyIGlzIGJ1c3knKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXJzaW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5kZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5kZWZlcnJlZC5wcm9taXNlO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzeW5jLXBhcnNlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBMYW5naXVtQ29tcGxldGlvblBhcnNlciB9IGZyb20gJy4vbGFuZ2l1bS1wYXJzZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXItYnVpbGRlci1iYXNlLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb21wbGV0aW9uUGFyc2VyKHNlcnZpY2VzKSB7XG4gICAgY29uc3QgZ3JhbW1hciA9IHNlcnZpY2VzLkdyYW1tYXI7XG4gICAgY29uc3QgbGV4ZXIgPSBzZXJ2aWNlcy5wYXJzZXIuTGV4ZXI7XG4gICAgY29uc3QgcGFyc2VyID0gbmV3IExhbmdpdW1Db21wbGV0aW9uUGFyc2VyKHNlcnZpY2VzKTtcbiAgICBjcmVhdGVQYXJzZXIoZ3JhbW1hciwgcGFyc2VyLCBsZXhlci5kZWZpbml0aW9uKTtcbiAgICBwYXJzZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcGFyc2VyO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tcGxldGlvbi1wYXJzZXItYnVpbGRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBQb3NpdGlvbiB9IGZyb20gJ3ZzY29kZS1sYW5ndWFnZXNlcnZlci10eXBlcyc7XG5pbXBvcnQgeyB0b2tlblRvUmFuZ2UgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIENzdE5vZGVCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbXTtcbiAgICB9XG4gICAgZ2V0IGN1cnJlbnQoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMubm9kZVN0YWNrW3RoaXMubm9kZVN0YWNrLmxlbmd0aCAtIDFdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0aGlzLnJvb3ROb2RlO1xuICAgIH1cbiAgICBidWlsZFJvb3ROb2RlKGlucHV0KSB7XG4gICAgICAgIHRoaXMucm9vdE5vZGUgPSBuZXcgUm9vdENzdE5vZGVJbXBsKGlucHV0KTtcbiAgICAgICAgdGhpcy5yb290Tm9kZS5yb290ID0gdGhpcy5yb290Tm9kZTtcbiAgICAgICAgdGhpcy5ub2RlU3RhY2sgPSBbdGhpcy5yb290Tm9kZV07XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3ROb2RlO1xuICAgIH1cbiAgICBidWlsZENvbXBvc2l0ZU5vZGUoZmVhdHVyZSkge1xuICAgICAgICBjb25zdCBjb21wb3NpdGVOb2RlID0gbmV3IENvbXBvc2l0ZUNzdE5vZGVJbXBsKCk7XG4gICAgICAgIGNvbXBvc2l0ZU5vZGUuZ3JhbW1hclNvdXJjZSA9IGZlYXR1cmU7XG4gICAgICAgIGNvbXBvc2l0ZU5vZGUucm9vdCA9IHRoaXMucm9vdE5vZGU7XG4gICAgICAgIHRoaXMuY3VycmVudC5jb250ZW50LnB1c2goY29tcG9zaXRlTm9kZSk7XG4gICAgICAgIHRoaXMubm9kZVN0YWNrLnB1c2goY29tcG9zaXRlTm9kZSk7XG4gICAgICAgIHJldHVybiBjb21wb3NpdGVOb2RlO1xuICAgIH1cbiAgICBidWlsZExlYWZOb2RlKHRva2VuLCBmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IGxlYWZOb2RlID0gbmV3IExlYWZDc3ROb2RlSW1wbCh0b2tlbi5zdGFydE9mZnNldCwgdG9rZW4uaW1hZ2UubGVuZ3RoLCB0b2tlblRvUmFuZ2UodG9rZW4pLCB0b2tlbi50b2tlblR5cGUsICFmZWF0dXJlKTtcbiAgICAgICAgbGVhZk5vZGUuZ3JhbW1hclNvdXJjZSA9IGZlYXR1cmU7XG4gICAgICAgIGxlYWZOb2RlLnJvb3QgPSB0aGlzLnJvb3ROb2RlO1xuICAgICAgICB0aGlzLmN1cnJlbnQuY29udGVudC5wdXNoKGxlYWZOb2RlKTtcbiAgICAgICAgcmV0dXJuIGxlYWZOb2RlO1xuICAgIH1cbiAgICByZW1vdmVOb2RlKG5vZGUpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmNvbnRlbnQuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50LmNvbnRlbnQuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGRIaWRkZW5Ob2Rlcyh0b2tlbnMpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiB0b2tlbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWZOb2RlID0gbmV3IExlYWZDc3ROb2RlSW1wbCh0b2tlbi5zdGFydE9mZnNldCwgdG9rZW4uaW1hZ2UubGVuZ3RoLCB0b2tlblRvUmFuZ2UodG9rZW4pLCB0b2tlbi50b2tlblR5cGUsIHRydWUpO1xuICAgICAgICAgICAgbGVhZk5vZGUucm9vdCA9IHRoaXMucm9vdE5vZGU7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKGxlYWZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgbGV0IGFkZGVkID0gZmFsc2U7XG4gICAgICAgIC8vIElmIHdlIGFyZSB3aXRoaW4gYSBjb21wb3NpdGUgbm9kZSwgd2UgYWRkIHRoZSBoaWRkZW4gbm9kZXMgdG8gdGhlIGNvbnRlbnRcbiAgICAgICAgaWYgKGN1cnJlbnQuY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjdXJyZW50LmNvbnRlbnQucHVzaCguLi5ub2Rlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXJ3aXNlIHdlIGFyZSBhdCBhIG5ld2x5IGNyZWF0ZWQgbm9kZVxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGFkZGluZyB0aGUgaGlkZGVuIG5vZGVzIGhlcmUsIHdlIHNlYXJjaCBmb3IgdGhlIGZpcnN0IHBhcmVudCBub2RlIHdpdGggY29udGVudFxuICAgICAgICB3aGlsZSAoY3VycmVudC5jb250YWluZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY3VycmVudC5jb250YWluZXIuY29udGVudC5pbmRleE9mKGN1cnJlbnQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgaGlkZGVuIG5vZGVzIGJlZm9yZSB0aGUgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgY3VycmVudC5jb250YWluZXIuY29udGVudC5zcGxpY2UoaW5kZXgsIDAsIC4uLm5vZGVzKTtcbiAgICAgICAgICAgICAgICBhZGRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5jb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgd2UgYXJyaXZlIGF0IHRoZSByb290IG5vZGUsIHdlIGFkZCB0aGUgaGlkZGVuIG5vZGVzIGF0IHRoZSBiZWdpbm5pbmdcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgY2FzZSBpZiB0aGUgaGlkZGVuIG5vZGVzIGFyZSB0aGUgZmlyc3Qgbm9kZXMgaW4gdGhlIHRyZWVcbiAgICAgICAgaWYgKCFhZGRlZCkge1xuICAgICAgICAgICAgdGhpcy5yb290Tm9kZS5jb250ZW50LnVuc2hpZnQoLi4ubm9kZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdChpdGVtKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIC8vIFRoZSBzcGVjaWZpZWQgaXRlbSBjb3VsZCBiZSBhIGRhdGF0eXBlICgkdHlwZSBpcyBzeW1ib2wpIG9yIGEgZnJhZ21lbnQgKCR0eXBlIGlzIHVuZGVmaW5lZClcbiAgICAgICAgLy8gT25seSBpZiB0aGUgJHR5cGUgaXMgYSBzdHJpbmcsIHdlIGFjdHVhbGx5IGFzc2lnbiB0aGUgZWxlbWVudFxuICAgICAgICBpZiAodHlwZW9mIGl0ZW0uJHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnQuYXN0Tm9kZSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgaXRlbS4kY3N0Tm9kZSA9IGN1cnJlbnQ7XG4gICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgLy8gRW1wdHkgY29tcG9zaXRlIG5vZGVzIGFyZSBub3QgdmFsaWRcbiAgICAgICAgLy8gU2ltcGx5IHJlbW92ZSB0aGUgbm9kZSBmcm9tIHRoZSB0cmVlXG4gICAgICAgIGlmICgobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmNvbnRlbnQubGVuZ3RoKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVOb2RlKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0Q3N0Tm9kZSB7XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgY29udGFpbmVyYCBpbnN0ZWFkLiAqL1xuICAgIGdldCBwYXJlbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgZ3JhbW1hclNvdXJjZWAgaW5zdGVhZC4gKi9cbiAgICBnZXQgZmVhdHVyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbW1hclNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXQgYXN0Tm9kZSgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHR5cGVvZiAoKF9hID0gdGhpcy5fYXN0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLiR0eXBlKSA9PT0gJ3N0cmluZycgPyB0aGlzLl9hc3ROb2RlIDogKF9iID0gdGhpcy5jb250YWluZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hc3ROb2RlO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGhhcyBubyBhc3NvY2lhdGVkIEFTVCBlbGVtZW50Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIHNldCBhc3ROb2RlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2FzdE5vZGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgLyoqIEBkZXByZWNhdGVkIHVzZSBgYXN0Tm9kZWAgaW5zdGVhZC4gKi9cbiAgICBnZXQgZWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0Tm9kZTtcbiAgICB9XG4gICAgZ2V0IHRleHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuZnVsbFRleHQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCB0aGlzLmVuZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIExlYWZDc3ROb2RlSW1wbCBleHRlbmRzIEFic3RyYWN0Q3N0Tm9kZSB7XG4gICAgZ2V0IG9mZnNldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldDtcbiAgICB9XG4gICAgZ2V0IGxlbmd0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGVuZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29mZnNldCArIHRoaXMuX2xlbmd0aDtcbiAgICB9XG4gICAgZ2V0IGhpZGRlbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpZGRlbjtcbiAgICB9XG4gICAgZ2V0IHRva2VuVHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Rva2VuVHlwZTtcbiAgICB9XG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmFuZ2U7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKG9mZnNldCwgbGVuZ3RoLCByYW5nZSwgdG9rZW5UeXBlLCBoaWRkZW4gPSBmYWxzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLl9oaWRkZW4gPSBoaWRkZW47XG4gICAgICAgIHRoaXMuX29mZnNldCA9IG9mZnNldDtcbiAgICAgICAgdGhpcy5fdG9rZW5UeXBlID0gdG9rZW5UeXBlO1xuICAgICAgICB0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG4gICAgICAgIHRoaXMuX3JhbmdlID0gcmFuZ2U7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbXBvc2l0ZUNzdE5vZGVJbXBsIGV4dGVuZHMgQWJzdHJhY3RDc3ROb2RlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5jb250ZW50ID0gbmV3IENzdE5vZGVDb250YWluZXIodGhpcyk7XG4gICAgfVxuICAgIC8qKiBAZGVwcmVjYXRlZCB1c2UgYGNvbnRlbnRgIGluc3RlYWQuICovXG4gICAgZ2V0IGNoaWxkcmVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50O1xuICAgIH1cbiAgICBnZXQgb2Zmc2V0KCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5maXJzdE5vbkhpZGRlbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vZmZzZXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDA7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZCAtIHRoaXMub2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgZW5kKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5sYXN0Tm9uSGlkZGVuTm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVuZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMDtcbiAgICB9XG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICBjb25zdCBmaXJzdE5vZGUgPSB0aGlzLmZpcnN0Tm9uSGlkZGVuTm9kZTtcbiAgICAgICAgY29uc3QgbGFzdE5vZGUgPSB0aGlzLmxhc3ROb25IaWRkZW5Ob2RlO1xuICAgICAgICBpZiAoZmlyc3ROb2RlICYmIGxhc3ROb2RlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmFuZ2VDYWNoZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyByYW5nZTogZmlyc3RSYW5nZSB9ID0gZmlyc3ROb2RlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgcmFuZ2U6IGxhc3RSYW5nZSB9ID0gbGFzdE5vZGU7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmFuZ2VDYWNoZSA9IHsgc3RhcnQ6IGZpcnN0UmFuZ2Uuc3RhcnQsIGVuZDogbGFzdFJhbmdlLmVuZC5saW5lIDwgZmlyc3RSYW5nZS5zdGFydC5saW5lID8gZmlyc3RSYW5nZS5zdGFydCA6IGxhc3RSYW5nZS5lbmQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yYW5nZUNhY2hlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZSgwLCAwKSwgZW5kOiBQb3NpdGlvbi5jcmVhdGUoMCwgMCkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgZmlyc3ROb25IaWRkZW5Ob2RlKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIHRoaXMuY29udGVudCkge1xuICAgICAgICAgICAgaWYgKCFjaGlsZC5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGVudFswXTtcbiAgICB9XG4gICAgZ2V0IGxhc3ROb25IaWRkZW5Ob2RlKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gdGhpcy5jb250ZW50Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMuY29udGVudFtpXTtcbiAgICAgICAgICAgIGlmICghY2hpbGQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnRlbnRbdGhpcy5jb250ZW50Lmxlbmd0aCAtIDFdO1xuICAgIH1cbn1cbmNsYXNzIENzdE5vZGVDb250YWluZXIgZXh0ZW5kcyBBcnJheSB7XG4gICAgY29uc3RydWN0b3IocGFyZW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQ3N0Tm9kZUNvbnRhaW5lci5wcm90b3R5cGUpO1xuICAgIH1cbiAgICBwdXNoKC4uLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuYWRkUGFyZW50cyhpdGVtcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5wdXNoKC4uLml0ZW1zKTtcbiAgICB9XG4gICAgdW5zaGlmdCguLi5pdGVtcykge1xuICAgICAgICB0aGlzLmFkZFBhcmVudHMoaXRlbXMpO1xuICAgICAgICByZXR1cm4gc3VwZXIudW5zaGlmdCguLi5pdGVtcyk7XG4gICAgfVxuICAgIHNwbGljZShzdGFydCwgY291bnQsIC4uLml0ZW1zKSB7XG4gICAgICAgIHRoaXMuYWRkUGFyZW50cyhpdGVtcyk7XG4gICAgICAgIHJldHVybiBzdXBlci5zcGxpY2Uoc3RhcnQsIGNvdW50LCAuLi5pdGVtcyk7XG4gICAgfVxuICAgIGFkZFBhcmVudHMoaXRlbXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICBpdGVtLmNvbnRhaW5lciA9IHRoaXMucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFJvb3RDc3ROb2RlSW1wbCBleHRlbmRzIENvbXBvc2l0ZUNzdE5vZGVJbXBsIHtcbiAgICBnZXQgdGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LCB0aGlzLmVuZCk7XG4gICAgfVxuICAgIGdldCBmdWxsVGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3RleHQ7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGlucHV0KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuX3RleHQgPSAnJztcbiAgICAgICAgdGhpcy5fdGV4dCA9IGlucHV0ICE9PSBudWxsICYmIGlucHV0ICE9PSB2b2lkIDAgPyBpbnB1dCA6ICcnO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdC1ub2RlLWJ1aWxkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgTGFuZ2l1bVBhcnNlciB9IGZyb20gJy4vbGFuZ2l1bS1wYXJzZXIuanMnO1xuaW1wb3J0IHsgY3JlYXRlUGFyc2VyIH0gZnJvbSAnLi9wYXJzZXItYnVpbGRlci1iYXNlLmpzJztcbi8qKlxuICogQ3JlYXRlIGFuZCBmaW5hbGl6ZSBhIExhbmdpdW0gcGFyc2VyLiBUaGUgcGFyc2VyIHJ1bGVzIGFyZSBkZXJpdmVkIGZyb20gdGhlIGdyYW1tYXIsIHdoaWNoIGlzXG4gKiBhdmFpbGFibGUgYXQgYHNlcnZpY2VzLkdyYW1tYXJgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcykge1xuICAgIGNvbnN0IHBhcnNlciA9IHByZXBhcmVMYW5naXVtUGFyc2VyKHNlcnZpY2VzKTtcbiAgICBwYXJzZXIuZmluYWxpemUoKTtcbiAgICByZXR1cm4gcGFyc2VyO1xufVxuLyoqXG4gKiBDcmVhdGUgYSBMYW5naXVtIHBhcnNlciB3aXRob3V0IGZpbmFsaXppbmcgaXQuIFRoaXMgaXMgdXNlZCB0byBleHRyYWN0IG1vcmUgZGV0YWlsZWQgZXJyb3JcbiAqIGluZm9ybWF0aW9uIHdoZW4gdGhlIHBhcnNlciBpcyBpbml0aWFsbHkgdmFsaWRhdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcGFyZUxhbmdpdW1QYXJzZXIoc2VydmljZXMpIHtcbiAgICBjb25zdCBncmFtbWFyID0gc2VydmljZXMuR3JhbW1hcjtcbiAgICBjb25zdCBsZXhlciA9IHNlcnZpY2VzLnBhcnNlci5MZXhlcjtcbiAgICBjb25zdCBwYXJzZXIgPSBuZXcgTGFuZ2l1bVBhcnNlcihzZXJ2aWNlcyk7XG4gICAgcmV0dXJuIGNyZWF0ZVBhcnNlcihncmFtbWFyLCBwYXJzZXIsIGxleGVyLmRlZmluaXRpb24pO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bGFuZ2l1bS1wYXJzZXItYnVpbGRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBkZWZhdWx0UGFyc2VyRXJyb3JQcm92aWRlciwgRW1iZWRkZWRBY3Rpb25zUGFyc2VyLCBMTGtMb29rYWhlYWRTdHJhdGVneSB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuaW1wb3J0IHsgTExTdGFyTG9va2FoZWFkU3RyYXRlZ3kgfSBmcm9tICdjaGV2cm90YWluLWFsbHN0YXInO1xuaW1wb3J0IHsgaXNBc3NpZ25tZW50LCBpc0Nyb3NzUmVmZXJlbmNlLCBpc0tleXdvcmQgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBnZXRFeHBsaWNpdFJ1bGVUeXBlLCBpc0RhdGFUeXBlUnVsZSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgYXNzaWduTWFuZGF0b3J5UHJvcGVydGllcywgZ2V0Q29udGFpbmVyT2ZUeXBlLCBsaW5rQ29udGVudFRvQ29udGFpbmVyIH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IENzdE5vZGVCdWlsZGVyIH0gZnJvbSAnLi9jc3Qtbm9kZS1idWlsZGVyLmpzJztcbmV4cG9ydCBjb25zdCBEYXRhdHlwZVN5bWJvbCA9IFN5bWJvbCgnRGF0YXR5cGUnKTtcbmZ1bmN0aW9uIGlzRGF0YVR5cGVOb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbm9kZS4kdHlwZSA9PT0gRGF0YXR5cGVTeW1ib2w7XG59XG5jb25zdCBydWxlU3VmZml4ID0gJ1xcdTIwMEInO1xuY29uc3Qgd2l0aFJ1bGVTdWZmaXggPSAobmFtZSkgPT4gbmFtZS5lbmRzV2l0aChydWxlU3VmZml4KSA/IG5hbWUgOiBuYW1lICsgcnVsZVN1ZmZpeDtcbmV4cG9ydCBjbGFzcyBBYnN0cmFjdExhbmdpdW1QYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuX3Vub3JkZXJlZEdyb3VwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5hbGxSdWxlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5sZXhlciA9IHNlcnZpY2VzLnBhcnNlci5MZXhlcjtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy5sZXhlci5kZWZpbml0aW9uO1xuICAgICAgICBjb25zdCBwcm9kdWN0aW9uID0gc2VydmljZXMuTGFuZ3VhZ2VNZXRhRGF0YS5tb2RlID09PSAncHJvZHVjdGlvbic7XG4gICAgICAgIHRoaXMud3JhcHBlciA9IG5ldyBDaGV2cm90YWluV3JhcHBlcih0b2tlbnMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgc2VydmljZXMucGFyc2VyLlBhcnNlckNvbmZpZyksIHsgc2tpcFZhbGlkYXRpb25zOiBwcm9kdWN0aW9uLCBlcnJvck1lc3NhZ2VQcm92aWRlcjogc2VydmljZXMucGFyc2VyLlBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyIH0pKTtcbiAgICB9XG4gICAgYWx0ZXJuYXRpdmVzKGlkeCwgY2hvaWNlcykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcE9yKGlkeCwgY2hvaWNlcyk7XG4gICAgfVxuICAgIG9wdGlvbmFsKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLndyYXBPcHRpb24oaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIG1hbnkoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcE1hbnkoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcEF0TGVhc3RPbmUoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGdldFJ1bGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbGxSdWxlcy5nZXQobmFtZSk7XG4gICAgfVxuICAgIGlzUmVjb3JkaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLklTX1JFQ09SRElORztcbiAgICB9XG4gICAgZ2V0IHVub3JkZXJlZEdyb3VwcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Vub3JkZXJlZEdyb3VwcztcbiAgICB9XG4gICAgZ2V0UnVsZVN0YWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLlJVTEVfU1RBQ0s7XG4gICAgfVxuICAgIGZpbmFsaXplKCkge1xuICAgICAgICB0aGlzLndyYXBwZXIud3JhcFNlbGZBbmFseXNpcygpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtUGFyc2VyIGV4dGVuZHMgQWJzdHJhY3RMYW5naXVtUGFyc2VyIHtcbiAgICBnZXQgY3VycmVudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhY2tbdGhpcy5zdGFjay5sZW5ndGggLSAxXTtcbiAgICB9XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgc3VwZXIoc2VydmljZXMpO1xuICAgICAgICB0aGlzLm5vZGVCdWlsZGVyID0gbmV3IENzdE5vZGVCdWlsZGVyKCk7XG4gICAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgICAgdGhpcy5hc3NpZ25tZW50TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmxpbmtlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IHNlcnZpY2VzLnBhcnNlci5WYWx1ZUNvbnZlcnRlcjtcbiAgICAgICAgdGhpcy5hc3RSZWZsZWN0aW9uID0gc2VydmljZXMuc2hhcmVkLkFzdFJlZmxlY3Rpb247XG4gICAgfVxuICAgIHJ1bGUocnVsZSwgaW1wbCkge1xuICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5jb21wdXRlUnVsZVR5cGUocnVsZSk7XG4gICAgICAgIGNvbnN0IHJ1bGVNZXRob2QgPSB0aGlzLndyYXBwZXIuREVGSU5FX1JVTEUod2l0aFJ1bGVTdWZmaXgocnVsZS5uYW1lKSwgdGhpcy5zdGFydEltcGxlbWVudGF0aW9uKHR5cGUsIGltcGwpLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFsbFJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGVNZXRob2QpO1xuICAgICAgICBpZiAocnVsZS5lbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5tYWluUnVsZSA9IHJ1bGVNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVNZXRob2Q7XG4gICAgfVxuICAgIGNvbXB1dGVSdWxlVHlwZShydWxlKSB7XG4gICAgICAgIGlmIChydWxlLmZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0YVR5cGVSdWxlKHJ1bGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gRGF0YXR5cGVTeW1ib2w7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBleHBsaWNpdCA9IGdldEV4cGxpY2l0UnVsZVR5cGUocnVsZSk7XG4gICAgICAgICAgICByZXR1cm4gZXhwbGljaXQgIT09IG51bGwgJiYgZXhwbGljaXQgIT09IHZvaWQgMCA/IGV4cGxpY2l0IDogcnVsZS5uYW1lO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlKGlucHV0LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5idWlsZFJvb3ROb2RlKGlucHV0KTtcbiAgICAgICAgY29uc3QgbGV4ZXJSZXN1bHQgPSB0aGlzLmxleGVyUmVzdWx0ID0gdGhpcy5sZXhlci50b2tlbml6ZShpbnB1dCk7XG4gICAgICAgIHRoaXMud3JhcHBlci5pbnB1dCA9IGxleGVyUmVzdWx0LnRva2VucztcbiAgICAgICAgY29uc3QgcnVsZU1ldGhvZCA9IG9wdGlvbnMucnVsZSA/IHRoaXMuYWxsUnVsZXMuZ2V0KG9wdGlvbnMucnVsZSkgOiB0aGlzLm1haW5SdWxlO1xuICAgICAgICBpZiAoIXJ1bGVNZXRob2QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihvcHRpb25zLnJ1bGUgPyBgTm8gcnVsZSBmb3VuZCB3aXRoIG5hbWUgJyR7b3B0aW9ucy5ydWxlfSdgIDogJ05vIG1haW4gcnVsZSBhdmFpbGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcnVsZU1ldGhvZC5jYWxsKHRoaXMud3JhcHBlciwge30pO1xuICAgICAgICB0aGlzLm5vZGVCdWlsZGVyLmFkZEhpZGRlbk5vZGVzKGxleGVyUmVzdWx0LmhpZGRlbik7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkR3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMubGV4ZXJSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICAgICAgbGV4ZXJFcnJvcnM6IGxleGVyUmVzdWx0LmVycm9ycyxcbiAgICAgICAgICAgIGxleGVyUmVwb3J0OiBsZXhlclJlc3VsdC5yZXBvcnQsXG4gICAgICAgICAgICBwYXJzZXJFcnJvcnM6IHRoaXMud3JhcHBlci5lcnJvcnNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3RhcnRJbXBsZW1lbnRhdGlvbigkdHlwZSwgaW1wbGVtZW50YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IGNyZWF0ZSBhIG5ldyBBU1Qgbm9kZSBpbiBjYXNlIHRoZSBjYWxsaW5nIHJ1bGUgaXMgbm90IGEgZnJhZ21lbnQgcnVsZVxuICAgICAgICAgICAgY29uc3QgY3JlYXRlTm9kZSA9ICF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgJHR5cGUgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmIChjcmVhdGVOb2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHsgJHR5cGUgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKCR0eXBlID09PSBEYXRhdHlwZVN5bWJvbCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnZhbHVlID0gJyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gaW1wbGVtZW50YXRpb24oYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkICYmIGNyZWF0ZU5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLmNvbnN0cnVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXh0cmFjdEhpZGRlblRva2Vucyh0b2tlbikge1xuICAgICAgICBjb25zdCBoaWRkZW5Ub2tlbnMgPSB0aGlzLmxleGVyUmVzdWx0LmhpZGRlbjtcbiAgICAgICAgaWYgKCFoaWRkZW5Ub2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdG9rZW4uc3RhcnRPZmZzZXQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGlkZGVuVG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0b2tlbiA9IGhpZGRlblRva2Vuc1tpXTtcbiAgICAgICAgICAgIGlmICh0b2tlbi5zdGFydE9mZnNldCA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRkZW5Ub2tlbnMuc3BsaWNlKDAsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoaWRkZW5Ub2tlbnMuc3BsaWNlKDAsIGhpZGRlblRva2Vucy5sZW5ndGgpO1xuICAgIH1cbiAgICBjb25zdW1lKGlkeCwgdG9rZW5UeXBlLCBmZWF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuID0gdGhpcy53cmFwcGVyLndyYXBDb25zdW1lKGlkeCwgdG9rZW5UeXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgdGhpcy5pc1ZhbGlkVG9rZW4odG9rZW4pKSB7XG4gICAgICAgICAgICBjb25zdCBoaWRkZW5Ub2tlbnMgPSB0aGlzLmV4dHJhY3RIaWRkZW5Ub2tlbnModG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5hZGRIaWRkZW5Ob2RlcyhoaWRkZW5Ub2tlbnMpO1xuICAgICAgICAgICAgY29uc3QgbGVhZk5vZGUgPSB0aGlzLm5vZGVCdWlsZGVyLmJ1aWxkTGVhZk5vZGUodG9rZW4sIGZlYXR1cmUpO1xuICAgICAgICAgICAgY29uc3QgeyBhc3NpZ25tZW50LCBpc0Nyb3NzUmVmIH0gPSB0aGlzLmdldEFzc2lnbm1lbnQoZmVhdHVyZSk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb252ZXJ0ZWRWYWx1ZSA9IGlzS2V5d29yZChmZWF0dXJlKSA/IHRva2VuLmltYWdlIDogdGhpcy5jb252ZXJ0ZXIuY29udmVydCh0b2tlbi5pbWFnZSwgbGVhZk5vZGUpO1xuICAgICAgICAgICAgICAgIHRoaXMuYXNzaWduKGFzc2lnbm1lbnQub3BlcmF0b3IsIGFzc2lnbm1lbnQuZmVhdHVyZSwgY29udmVydGVkVmFsdWUsIGxlYWZOb2RlLCBpc0Nyb3NzUmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzRGF0YVR5cGVOb2RlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgICAgICAgbGV0IHRleHQgPSB0b2tlbi5pbWFnZTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzS2V5d29yZChmZWF0dXJlKSkge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGhpcy5jb252ZXJ0ZXIuY29udmVydCh0ZXh0LCBsZWFmTm9kZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY3VycmVudC52YWx1ZSArPSB0ZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3QgY29uc3VtZWQgcGFyc2VyIHRva2VucyBhcmUgdmFsaWQuIEhvd2V2ZXIgdGhlcmUgYXJlIHR3byBjYXNlcyBpbiB3aGljaCB0aGV5IGFyZSBub3QgdmFsaWQ6XG4gICAgICpcbiAgICAgKiAxLiBUaGV5IHdlcmUgaW5zZXJ0ZWQgZHVyaW5nIGVycm9yIHJlY292ZXJ5IGJ5IHRoZSBwYXJzZXIuIFRoZXNlIHRva2VucyBkb24ndCByZWFsbHkgZXhpc3QgYW5kIHNob3VsZCBub3QgYmUgZnVydGhlciBwcm9jZXNzZWRcbiAgICAgKiAyLiBUaGV5IGNvbnRhaW4gaW52YWxpZCB0b2tlbiByYW5nZXMuIFRoaXMgbWlnaHQgaW5jbHVkZSB0aGUgc3BlY2lhbCBFT0YgdG9rZW4sIG9yIG90aGVyIHRva2VucyBwcm9kdWNlZCBieSBpbnZhbGlkIHRva2VuIGJ1aWxkZXJzLlxuICAgICAqL1xuICAgIGlzVmFsaWRUb2tlbih0b2tlbikge1xuICAgICAgICByZXR1cm4gIXRva2VuLmlzSW5zZXJ0ZWRJblJlY292ZXJ5ICYmICFpc05hTih0b2tlbi5zdGFydE9mZnNldCkgJiYgdHlwZW9mIHRva2VuLmVuZE9mZnNldCA9PT0gJ251bWJlcicgJiYgIWlzTmFOKHRva2VuLmVuZE9mZnNldCk7XG4gICAgfVxuICAgIHN1YnJ1bGUoaWR4LCBydWxlLCBmcmFnbWVudCwgZmVhdHVyZSwgYXJncykge1xuICAgICAgICBsZXQgY3N0Tm9kZTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkgJiYgIWZyYWdtZW50KSB7XG4gICAgICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gY3JlYXRlIGEgbmV3IENTVCBub2RlIGlmIHRoZSBzdWJydWxlIGFjdHVhbGx5IGNyZWF0ZXMgYSBuZXcgQVNUIG5vZGUuXG4gICAgICAgICAgICAvLyBJbiBvdGhlciBjYXNlcyBsaWtlIGNhbGxzIG9mIGZyYWdtZW50IHJ1bGVzIHRoZSBjdXJyZW50IENTVC9BU1QgaXMgcG9wdWxhdGVkIGZ1cnRoZXIuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgc2tpcHBpbmcgdGhpcyBpbml0aWFsaXphdGlvbiBhbmQgbGVhdmluZyBjc3ROb2RlIHVuYXNzaWduZWQgYWxzbyBza2lwcyB0aGUgc3VicnVsZSBhc3NpZ25tZW50IGxhdGVyIG9uLlxuICAgICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbmRlZCwgYXMgZnJhZ21lbnQgcnVsZXMgb25seSBlbnJpY2ggdGhlIGN1cnJlbnQgQVNUIG5vZGVcbiAgICAgICAgICAgIGNzdE5vZGUgPSB0aGlzLm5vZGVCdWlsZGVyLmJ1aWxkQ29tcG9zaXRlTm9kZShmZWF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdWJydWxlUmVzdWx0ID0gdGhpcy53cmFwcGVyLndyYXBTdWJydWxlKGlkeCwgcnVsZSwgYXJncyk7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpICYmIGNzdE5vZGUgJiYgY3N0Tm9kZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB0aGlzLnBlcmZvcm1TdWJydWxlQXNzaWdubWVudChzdWJydWxlUmVzdWx0LCBmZWF0dXJlLCBjc3ROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwZXJmb3JtU3VicnVsZUFzc2lnbm1lbnQocmVzdWx0LCBmZWF0dXJlLCBjc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHsgYXNzaWdubWVudCwgaXNDcm9zc1JlZiB9ID0gdGhpcy5nZXRBc3NpZ25tZW50KGZlYXR1cmUpO1xuICAgICAgICBpZiAoYXNzaWdubWVudCkge1xuICAgICAgICAgICAgdGhpcy5hc3NpZ24oYXNzaWdubWVudC5vcGVyYXRvciwgYXNzaWdubWVudC5mZWF0dXJlLCByZXN1bHQsIGNzdE5vZGUsIGlzQ3Jvc3NSZWYpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFhc3NpZ25tZW50KSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBjYWxsIGEgc3VicnVsZSB3aXRob3V0IGFuIGFzc2lnbm1lbnQgd2UgZWl0aGVyOlxuICAgICAgICAgICAgLy8gMS4gYXBwZW5kIHRoZSByZXN1bHQgb2YgdGhlIHN1YnJ1bGUgKGRhdGEgdHlwZSBydWxlKVxuICAgICAgICAgICAgLy8gMi4gb3ZlcnJpZGUgdGhlIGN1cnJlbnQgb2JqZWN0IHdpdGggdGhlIG5ld2x5IHBhcnNlZCBvYmplY3RcbiAgICAgICAgICAgIC8vIElmIHRoZSBjdXJyZW50IGVsZW1lbnQgaXMgYW4gQVNUIG5vZGUgYW5kIHRoZSByZXN1bHQgb2YgdGhlIHN1YnJ1bGVcbiAgICAgICAgICAgIC8vIGlzIGEgZGF0YSB0eXBlIHJ1bGUsIHdlIGNhbiBzYWZlbHkgZGlzY2FyZCB0aGUgcmVzdWx0cy5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgICAgICBpZiAoaXNEYXRhVHlwZU5vZGUoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50LnZhbHVlICs9IHJlc3VsdC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIHJlc3VsdCA9PT0gJ29iamVjdCcgJiYgcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0ID0gdGhpcy5hc3NpZ25XaXRob3V0T3ZlcnJpZGUocmVzdWx0LCBjdXJyZW50KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJdGVtID0gb2JqZWN0O1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFjay5wdXNoKG5ld0l0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFjdGlvbigkdHlwZSwgYWN0aW9uKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBsZXQgbGFzdCA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIGlmIChhY3Rpb24uZmVhdHVyZSAmJiBhY3Rpb24ub3BlcmF0b3IpIHtcbiAgICAgICAgICAgICAgICBsYXN0ID0gdGhpcy5jb25zdHJ1Y3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVCdWlsZGVyLnJlbW92ZU5vZGUobGFzdC4kY3N0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMubm9kZUJ1aWxkZXIuYnVpbGRDb21wb3NpdGVOb2RlKGFjdGlvbik7XG4gICAgICAgICAgICAgICAgbm9kZS5jb250ZW50LnB1c2gobGFzdC4kY3N0Tm9kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV3SXRlbSA9IHsgJHR5cGUgfTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YWNrLnB1c2gobmV3SXRlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hc3NpZ24oYWN0aW9uLm9wZXJhdG9yLCBhY3Rpb24uZmVhdHVyZSwgbGFzdCwgbGFzdC4kY3N0Tm9kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGFzdC4kdHlwZSA9ICR0eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvYmogPSB0aGlzLmN1cnJlbnQ7XG4gICAgICAgIGxpbmtDb250ZW50VG9Db250YWluZXIob2JqKTtcbiAgICAgICAgdGhpcy5ub2RlQnVpbGRlci5jb25zdHJ1Y3Qob2JqKTtcbiAgICAgICAgdGhpcy5zdGFjay5wb3AoKTtcbiAgICAgICAgaWYgKGlzRGF0YVR5cGVOb2RlKG9iaikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnZlcnRlci5jb252ZXJ0KG9iai52YWx1ZSwgb2JqLiRjc3ROb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFzc2lnbk1hbmRhdG9yeVByb3BlcnRpZXModGhpcy5hc3RSZWZsZWN0aW9uLCBvYmopO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGdldEFzc2lnbm1lbnQoZmVhdHVyZSkge1xuICAgICAgICBpZiAoIXRoaXMuYXNzaWdubWVudE1hcC5oYXMoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBnZXRDb250YWluZXJPZlR5cGUoZmVhdHVyZSwgaXNBc3NpZ25tZW50KTtcbiAgICAgICAgICAgIHRoaXMuYXNzaWdubWVudE1hcC5zZXQoZmVhdHVyZSwge1xuICAgICAgICAgICAgICAgIGFzc2lnbm1lbnQ6IGFzc2lnbm1lbnQsXG4gICAgICAgICAgICAgICAgaXNDcm9zc1JlZjogYXNzaWdubWVudCA/IGlzQ3Jvc3NSZWZlcmVuY2UoYXNzaWdubWVudC50ZXJtaW5hbCkgOiBmYWxzZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzaWdubWVudE1hcC5nZXQoZmVhdHVyZSk7XG4gICAgfVxuICAgIGFzc2lnbihvcGVyYXRvciwgZmVhdHVyZSwgdmFsdWUsIGNzdE5vZGUsIGlzQ3Jvc3NSZWYpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gdGhpcy5jdXJyZW50O1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgaWYgKGlzQ3Jvc3NSZWYgJiYgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaXRlbSA9IHRoaXMubGlua2VyLmJ1aWxkUmVmZXJlbmNlKG9iaiwgZmVhdHVyZSwgY3N0Tm9kZSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgICAgIGNhc2UgJz0nOiB7XG4gICAgICAgICAgICAgICAgb2JqW2ZlYXR1cmVdID0gaXRlbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJz89Jzoge1xuICAgICAgICAgICAgICAgIG9ialtmZWF0dXJlXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICcrPSc6IHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkob2JqW2ZlYXR1cmVdKSkge1xuICAgICAgICAgICAgICAgICAgICBvYmpbZmVhdHVyZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb2JqW2ZlYXR1cmVdLnB1c2goaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXNzaWduV2l0aG91dE92ZXJyaWRlKHRhcmdldCwgc291cmNlKSB7XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIGV4aXN0aW5nVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld1ZhbHVlID0gdGFyZ2V0W25hbWVdO1xuICAgICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRbbmFtZV0gPSBleGlzdGluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXdWYWx1ZSkgJiYgQXJyYXkuaXNBcnJheShleGlzdGluZ1ZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nVmFsdWUucHVzaCguLi5uZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W25hbWVdID0gZXhpc3RpbmdWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdGFyZ2V0IHdhcyBwYXJzZWQgZnJvbSBhIHVuYXNzaWduZWQgc3VicnVsZVxuICAgICAgICAvLyBBZnRlciB0aGUgc3VicnVsZSBjb25zdHJ1Y3Rpb24sIGl0IHJlY2VpdmVkIGEgY3N0IG5vZGVcbiAgICAgICAgLy8gVGhpcyBDU1Qgbm9kZSB3aWxsIGxhdGVyIGJlIG92ZXJyaWRlbiBieSB0aGUgY3N0IG5vZGUgYnVpbGRlclxuICAgICAgICAvLyBUbyBwcmV2ZW50IHJlZmVyZW5jZXMgdG8gc3RhbGUgQVNUIG5vZGVzIGluIHRoZSBDU1QsXG4gICAgICAgIC8vIHdlIG5lZWQgdG8gcmVtb3ZlIHRoZSByZWZlcmVuY2UgaGVyZVxuICAgICAgICBjb25zdCB0YXJnZXRDc3ROb2RlID0gdGFyZ2V0LiRjc3ROb2RlO1xuICAgICAgICBpZiAodGFyZ2V0Q3N0Tm9kZSkge1xuICAgICAgICAgICAgdGFyZ2V0Q3N0Tm9kZS5hc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGFyZ2V0LiRjc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfVxuICAgIGdldCBkZWZpbml0aW9uRXJyb3JzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmRlZmluaXRpb25FcnJvcnM7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEFic3RyYWN0UGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIge1xuICAgIGJ1aWxkTWlzbWF0Y2hUb2tlbk1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGRNaXNtYXRjaFRva2VuTWVzc2FnZShvcHRpb25zKTtcbiAgICB9XG4gICAgYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2Uob3B0aW9ucyk7XG4gICAgfVxuICAgIGJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRQYXJzZXJFcnJvclByb3ZpZGVyLmJ1aWxkTm9WaWFibGVBbHRNZXNzYWdlKG9wdGlvbnMpO1xuICAgIH1cbiAgICBidWlsZEVhcmx5RXhpdE1lc3NhZ2Uob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZGVmYXVsdFBhcnNlckVycm9yUHJvdmlkZXIuYnVpbGRFYXJseUV4aXRNZXNzYWdlKG9wdGlvbnMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIgZXh0ZW5kcyBBYnN0cmFjdFBhcnNlckVycm9yTWVzc2FnZVByb3ZpZGVyIHtcbiAgICBidWlsZE1pc21hdGNoVG9rZW5NZXNzYWdlKHsgZXhwZWN0ZWQsIGFjdHVhbCB9KSB7XG4gICAgICAgIGNvbnN0IGV4cGVjdGVkTXNnID0gZXhwZWN0ZWQuTEFCRUxcbiAgICAgICAgICAgID8gJ2AnICsgZXhwZWN0ZWQuTEFCRUwgKyAnYCdcbiAgICAgICAgICAgIDogZXhwZWN0ZWQubmFtZS5lbmRzV2l0aCgnOktXJylcbiAgICAgICAgICAgICAgICA/IGBrZXl3b3JkICcke2V4cGVjdGVkLm5hbWUuc3Vic3RyaW5nKDAsIGV4cGVjdGVkLm5hbWUubGVuZ3RoIC0gMyl9J2BcbiAgICAgICAgICAgICAgICA6IGB0b2tlbiBvZiB0eXBlICcke2V4cGVjdGVkLm5hbWV9J2A7XG4gICAgICAgIHJldHVybiBgRXhwZWN0aW5nICR7ZXhwZWN0ZWRNc2d9IGJ1dCBmb3VuZCBcXGAke2FjdHVhbC5pbWFnZX1cXGAuYDtcbiAgICB9XG4gICAgYnVpbGROb3RBbGxJbnB1dFBhcnNlZE1lc3NhZ2UoeyBmaXJzdFJlZHVuZGFudCB9KSB7XG4gICAgICAgIHJldHVybiBgRXhwZWN0aW5nIGVuZCBvZiBmaWxlIGJ1dCBmb3VuZCBcXGAke2ZpcnN0UmVkdW5kYW50LmltYWdlfVxcYC5gO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBMYW5naXVtQ29tcGxldGlvblBhcnNlciBleHRlbmRzIEFic3RyYWN0TGFuZ2l1bVBhcnNlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudG9rZW5zID0gW107XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubGFzdEVsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm5leHRUb2tlbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSAwO1xuICAgIH1cbiAgICBhY3Rpb24oKSB7XG4gICAgICAgIC8vIE5PT1BcbiAgICB9XG4gICAgY29uc3RydWN0KCkge1xuICAgICAgICAvLyBOT09QXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHBhcnNlKGlucHV0KSB7XG4gICAgICAgIHRoaXMucmVzZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmxleGVyLnRva2VuaXplKGlucHV0LCB7IG1vZGU6ICdwYXJ0aWFsJyB9KTtcbiAgICAgICAgdGhpcy50b2tlbnMgPSB0b2tlbnMudG9rZW5zO1xuICAgICAgICB0aGlzLndyYXBwZXIuaW5wdXQgPSBbLi4udGhpcy50b2tlbnNdO1xuICAgICAgICB0aGlzLm1haW5SdWxlLmNhbGwodGhpcy53cmFwcGVyLCB7fSk7XG4gICAgICAgIHRoaXMudW5vcmRlcmVkR3JvdXBzLmNsZWFyKCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0b2tlbnM6IHRoaXMudG9rZW5zLFxuICAgICAgICAgICAgZWxlbWVudFN0YWNrOiBbLi4udGhpcy5sYXN0RWxlbWVudFN0YWNrXSxcbiAgICAgICAgICAgIHRva2VuSW5kZXg6IHRoaXMubmV4dFRva2VuSW5kZXhcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVsZShydWxlLCBpbXBsKSB7XG4gICAgICAgIGNvbnN0IHJ1bGVNZXRob2QgPSB0aGlzLndyYXBwZXIuREVGSU5FX1JVTEUod2l0aFJ1bGVTdWZmaXgocnVsZS5uYW1lKSwgdGhpcy5zdGFydEltcGxlbWVudGF0aW9uKGltcGwpLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLmFsbFJ1bGVzLnNldChydWxlLm5hbWUsIHJ1bGVNZXRob2QpO1xuICAgICAgICBpZiAocnVsZS5lbnRyeSkge1xuICAgICAgICAgICAgdGhpcy5tYWluUnVsZSA9IHJ1bGVNZXRob2Q7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bGVNZXRob2Q7XG4gICAgfVxuICAgIHJlc2V0U3RhdGUoKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubGFzdEVsZW1lbnRTdGFjayA9IFtdO1xuICAgICAgICB0aGlzLm5leHRUb2tlbkluZGV4ID0gMDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSAwO1xuICAgIH1cbiAgICBzdGFydEltcGxlbWVudGF0aW9uKGltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMua2VlcFN0YWNrU2l6ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbihhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRTdGFja1NpemUoc2l6ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlbW92ZVVuZXhwZWN0ZWRFbGVtZW50cygpIHtcbiAgICAgICAgdGhpcy5lbGVtZW50U3RhY2suc3BsaWNlKHRoaXMuc3RhY2tTaXplKTtcbiAgICB9XG4gICAga2VlcFN0YWNrU2l6ZSgpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuZWxlbWVudFN0YWNrLmxlbmd0aDtcbiAgICAgICAgdGhpcy5zdGFja1NpemUgPSBzaXplO1xuICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICB9XG4gICAgcmVzZXRTdGFja1NpemUoc2l6ZSkge1xuICAgICAgICB0aGlzLnJlbW92ZVVuZXhwZWN0ZWRFbGVtZW50cygpO1xuICAgICAgICB0aGlzLnN0YWNrU2l6ZSA9IHNpemU7XG4gICAgfVxuICAgIGNvbnN1bWUoaWR4LCB0b2tlblR5cGUsIGZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy53cmFwcGVyLndyYXBDb25zdW1lKGlkeCwgdG9rZW5UeXBlKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVsZW1lbnRTdGFjayA9IFsuLi50aGlzLmVsZW1lbnRTdGFjaywgZmVhdHVyZV07XG4gICAgICAgICAgICB0aGlzLm5leHRUb2tlbkluZGV4ID0gdGhpcy5jdXJySWR4ICsgMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdWJydWxlKGlkeCwgcnVsZSwgZnJhZ21lbnQsIGZlYXR1cmUsIGFyZ3MpIHtcbiAgICAgICAgdGhpcy5iZWZvcmUoZmVhdHVyZSk7XG4gICAgICAgIHRoaXMud3JhcHBlci53cmFwU3VicnVsZShpZHgsIHJ1bGUsIGFyZ3MpO1xuICAgICAgICB0aGlzLmFmdGVyKGZlYXR1cmUpO1xuICAgIH1cbiAgICBiZWZvcmUoZWxlbWVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSZWNvcmRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZnRlcihlbGVtZW50KSB7XG4gICAgICAgIGlmICghdGhpcy5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZWxlbWVudFN0YWNrLmxhc3RJbmRleE9mKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVsZW1lbnRTdGFjay5zcGxpY2UoaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBjdXJySWR4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy53cmFwcGVyLmN1cnJJZHg7XG4gICAgfVxufVxuY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcbiAgICByZWNvdmVyeUVuYWJsZWQ6IHRydWUsXG4gICAgbm9kZUxvY2F0aW9uVHJhY2tpbmc6ICdmdWxsJyxcbiAgICBza2lwVmFsaWRhdGlvbnM6IHRydWUsXG4gICAgZXJyb3JNZXNzYWdlUHJvdmlkZXI6IG5ldyBMYW5naXVtUGFyc2VyRXJyb3JNZXNzYWdlUHJvdmlkZXIoKVxufTtcbi8qKlxuICogVGhpcyBjbGFzcyB3cmFwcyB0aGUgZW1iZWRkZWQgYWN0aW9ucyBwYXJzZXIgb2YgY2hldnJvdGFpbiBhbmQgZXhwb3NlcyBwcm90ZWN0ZWQgbWV0aG9kcy5cbiAqIFRoaXMgd2F5LCB3ZSBjYW4gYnVpbGQgdGhlIGBMYW5naXVtUGFyc2VyYCBhcyBhIGNvbXBvc2l0aW9uLlxuICovXG5jbGFzcyBDaGV2cm90YWluV3JhcHBlciBleHRlbmRzIEVtYmVkZGVkQWN0aW9uc1BhcnNlciB7XG4gICAgY29uc3RydWN0b3IodG9rZW5zLCBjb25maWcpIHtcbiAgICAgICAgY29uc3QgdXNlRGVmYXVsdExvb2thaGVhZCA9IGNvbmZpZyAmJiAnbWF4TG9va2FoZWFkJyBpbiBjb25maWc7XG4gICAgICAgIHN1cGVyKHRva2VucywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWcpLCB7IGxvb2thaGVhZFN0cmF0ZWd5OiB1c2VEZWZhdWx0TG9va2FoZWFkXG4gICAgICAgICAgICAgICAgPyBuZXcgTExrTG9va2FoZWFkU3RyYXRlZ3koeyBtYXhMb29rYWhlYWQ6IGNvbmZpZy5tYXhMb29rYWhlYWQgfSlcbiAgICAgICAgICAgICAgICA6IG5ldyBMTFN0YXJMb29rYWhlYWRTdHJhdGVneSh7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHZhbGlkYXRpb25zIGFyZSBza2lwcGVkLCBkb24ndCBsb2cgdGhlIGxvb2thaGVhZCB3YXJuaW5nc1xuICAgICAgICAgICAgICAgICAgICBsb2dnaW5nOiBjb25maWcuc2tpcFZhbGlkYXRpb25zID8gKCkgPT4geyB9IDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgfSkgfSksIGNvbmZpZykpO1xuICAgIH1cbiAgICBnZXQgSVNfUkVDT1JESU5HKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5SRUNPUkRJTkdfUEhBU0U7XG4gICAgfVxuICAgIERFRklORV9SVUxFKG5hbWUsIGltcGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuUlVMRShuYW1lLCBpbXBsKTtcbiAgICB9XG4gICAgd3JhcFNlbGZBbmFseXNpcygpIHtcbiAgICAgICAgdGhpcy5wZXJmb3JtU2VsZkFuYWx5c2lzKCk7XG4gICAgfVxuICAgIHdyYXBDb25zdW1lKGlkeCwgdG9rZW5UeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWUoaWR4LCB0b2tlblR5cGUpO1xuICAgIH1cbiAgICB3cmFwU3VicnVsZShpZHgsIHJ1bGUsIGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VicnVsZShpZHgsIHJ1bGUsIHtcbiAgICAgICAgICAgIEFSR1M6IFthcmdzXVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgd3JhcE9yKGlkeCwgY2hvaWNlcykge1xuICAgICAgICB0aGlzLm9yKGlkeCwgY2hvaWNlcyk7XG4gICAgfVxuICAgIHdyYXBPcHRpb24oaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9wdGlvbihpZHgsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgd3JhcE1hbnkoaWR4LCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1hbnkoaWR4LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIHdyYXBBdExlYXN0T25lKGlkeCwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5hdExlYXN0T25lKGlkeCwgY2FsbGJhY2spO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmdpdW0tcGFyc2VyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IExleGVyIGFzIENoZXZyb3RhaW5MZXhlciwgZGVmYXVsdExleGVyRXJyb3JQcm92aWRlciB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRMZXhlckVycm9yTWVzc2FnZVByb3ZpZGVyIHtcbiAgICBidWlsZFVuZXhwZWN0ZWRDaGFyYWN0ZXJzTWVzc2FnZShmdWxsVGV4dCwgc3RhcnRPZmZzZXQsIGxlbmd0aCwgbGluZSwgY29sdW1uKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0TGV4ZXJFcnJvclByb3ZpZGVyLmJ1aWxkVW5leHBlY3RlZENoYXJhY3RlcnNNZXNzYWdlKGZ1bGxUZXh0LCBzdGFydE9mZnNldCwgbGVuZ3RoLCBsaW5lLCBjb2x1bW4pO1xuICAgIH1cbiAgICBidWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZSh0b2tlbikge1xuICAgICAgICByZXR1cm4gZGVmYXVsdExleGVyRXJyb3JQcm92aWRlci5idWlsZFVuYWJsZVRvUG9wTGV4ZXJNb2RlTWVzc2FnZSh0b2tlbik7XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IERFRkFVTFRfVE9LRU5JWkVfT1BUSU9OUyA9IHsgbW9kZTogJ2Z1bGwnIH07XG5leHBvcnQgY2xhc3MgRGVmYXVsdExleGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyID0gc2VydmljZXMucGFyc2VyLkxleGVyRXJyb3JNZXNzYWdlUHJvdmlkZXI7XG4gICAgICAgIHRoaXMudG9rZW5CdWlsZGVyID0gc2VydmljZXMucGFyc2VyLlRva2VuQnVpbGRlcjtcbiAgICAgICAgY29uc3QgdG9rZW5zID0gdGhpcy50b2tlbkJ1aWxkZXIuYnVpbGRUb2tlbnMoc2VydmljZXMuR3JhbW1hciwge1xuICAgICAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBzZXJ2aWNlcy5MYW5ndWFnZU1ldGFEYXRhLmNhc2VJbnNlbnNpdGl2ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy50b2tlblR5cGVzID0gdGhpcy50b1Rva2VuVHlwZURpY3Rpb25hcnkodG9rZW5zKTtcbiAgICAgICAgY29uc3QgbGV4ZXJUb2tlbnMgPSBpc1Rva2VuVHlwZURpY3Rpb25hcnkodG9rZW5zKSA/IE9iamVjdC52YWx1ZXModG9rZW5zKSA6IHRva2VucztcbiAgICAgICAgY29uc3QgcHJvZHVjdGlvbiA9IHNlcnZpY2VzLkxhbmd1YWdlTWV0YURhdGEubW9kZSA9PT0gJ3Byb2R1Y3Rpb24nO1xuICAgICAgICB0aGlzLmNoZXZyb3RhaW5MZXhlciA9IG5ldyBDaGV2cm90YWluTGV4ZXIobGV4ZXJUb2tlbnMsIHtcbiAgICAgICAgICAgIHBvc2l0aW9uVHJhY2tpbmc6ICdmdWxsJyxcbiAgICAgICAgICAgIHNraXBWYWxpZGF0aW9uczogcHJvZHVjdGlvbixcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZVByb3ZpZGVyOiB0aGlzLmVycm9yTWVzc2FnZVByb3ZpZGVyXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXQgZGVmaW5pdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9rZW5UeXBlcztcbiAgICB9XG4gICAgdG9rZW5pemUodGV4dCwgX29wdGlvbnMgPSBERUZBVUxUX1RPS0VOSVpFX09QVElPTlMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGNoZXZyb3RhaW5SZXN1bHQgPSB0aGlzLmNoZXZyb3RhaW5MZXhlci50b2tlbml6ZSh0ZXh0KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRva2VuczogY2hldnJvdGFpblJlc3VsdC50b2tlbnMsXG4gICAgICAgICAgICBlcnJvcnM6IGNoZXZyb3RhaW5SZXN1bHQuZXJyb3JzLFxuICAgICAgICAgICAgaGlkZGVuOiAoX2EgPSBjaGV2cm90YWluUmVzdWx0Lmdyb3Vwcy5oaWRkZW4pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLFxuICAgICAgICAgICAgcmVwb3J0OiAoX2MgPSAoX2IgPSB0aGlzLnRva2VuQnVpbGRlcikuZmx1c2hMZXhpbmdSZXBvcnQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKF9iLCB0ZXh0KVxuICAgICAgICB9O1xuICAgIH1cbiAgICB0b1Rva2VuVHlwZURpY3Rpb25hcnkoYnVpbGRUb2tlbnMpIHtcbiAgICAgICAgaWYgKGlzVG9rZW5UeXBlRGljdGlvbmFyeShidWlsZFRva2VucykpXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRUb2tlbnM7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IGlzSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvbihidWlsZFRva2VucykgPyBPYmplY3QudmFsdWVzKGJ1aWxkVG9rZW5zLm1vZGVzKS5mbGF0KCkgOiBidWlsZFRva2VucztcbiAgICAgICAgY29uc3QgcmVzID0ge307XG4gICAgICAgIHRva2Vucy5mb3JFYWNoKHRva2VuID0+IHJlc1t0b2tlbi5uYW1lXSA9IHRva2VuKTtcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG59XG4vKipcbiAqIFJldHVybnMgYSBjaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBUb2tlblZvY2FidWxhcnkgaXMgVG9rZW5UeXBlIGFycmF5XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc1Rva2VuVHlwZUFycmF5KHRva2VuVm9jYWJ1bGFyeSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRva2VuVm9jYWJ1bGFyeSkgJiYgKHRva2VuVm9jYWJ1bGFyeS5sZW5ndGggPT09IDAgfHwgJ25hbWUnIGluIHRva2VuVm9jYWJ1bGFyeVswXSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBjaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBUb2tlblZvY2FidWxhcnkgaXMgSU11bHRpTW9kZUxleGVyRGVmaW5pdGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNJTXVsdGlNb2RlTGV4ZXJEZWZpbml0aW9uKHRva2VuVm9jYWJ1bGFyeSkge1xuICAgIHJldHVybiB0b2tlblZvY2FidWxhcnkgJiYgJ21vZGVzJyBpbiB0b2tlblZvY2FidWxhcnkgJiYgJ2RlZmF1bHRNb2RlJyBpbiB0b2tlblZvY2FidWxhcnk7XG59XG4vKipcbiAqIFJldHVybnMgYSBjaGVjayB3aGV0aGVyIHRoZSBnaXZlbiBUb2tlblZvY2FidWxhcnkgaXMgVG9rZW5UeXBlRGljdGlvbmFyeVxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNUb2tlblR5cGVEaWN0aW9uYXJ5KHRva2VuVm9jYWJ1bGFyeSkge1xuICAgIHJldHVybiAhaXNUb2tlblR5cGVBcnJheSh0b2tlblZvY2FidWxhcnkpICYmICFpc0lNdWx0aU1vZGVMZXhlckRlZmluaXRpb24odG9rZW5Wb2NhYnVsYXJ5KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxleGVyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IEVNUFRZX0FMVCwgRU9GIH0gZnJvbSAnY2hldnJvdGFpbic7XG5pbXBvcnQgeyBpc0FjdGlvbiwgaXNBbHRlcm5hdGl2ZXMsIGlzRW5kT2ZGaWxlLCBpc0Fzc2lnbm1lbnQsIGlzQ29uanVuY3Rpb24sIGlzQ3Jvc3NSZWZlcmVuY2UsIGlzRGlzanVuY3Rpb24sIGlzR3JvdXAsIGlzS2V5d29yZCwgaXNOZWdhdGlvbiwgaXNQYXJhbWV0ZXJSZWZlcmVuY2UsIGlzUGFyc2VyUnVsZSwgaXNSdWxlQ2FsbCwgaXNUZXJtaW5hbFJ1bGUsIGlzVW5vcmRlcmVkR3JvdXAsIGlzQm9vbGVhbkxpdGVyYWwgfSBmcm9tICcuLi9sYW5ndWFnZXMvZ2VuZXJhdGVkL2FzdC5qcyc7XG5pbXBvcnQgeyBhc3NlcnRVbnJlYWNoYWJsZSwgRXJyb3JXaXRoTG9jYXRpb24gfSBmcm9tICcuLi91dGlscy9lcnJvcnMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IGZpbmROYW1lQXNzaWdubWVudCwgZ2V0QWxsUmVhY2hhYmxlUnVsZXMsIGdldFR5cGVOYW1lIH0gZnJvbSAnLi4vdXRpbHMvZ3JhbW1hci11dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGFyc2VyKGdyYW1tYXIsIHBhcnNlciwgdG9rZW5zKSB7XG4gICAgY29uc3QgcGFyc2VyQ29udGV4dCA9IHtcbiAgICAgICAgcGFyc2VyLFxuICAgICAgICB0b2tlbnMsXG4gICAgICAgIHJ1bGVOYW1lczogbmV3IE1hcCgpXG4gICAgfTtcbiAgICBidWlsZFJ1bGVzKHBhcnNlckNvbnRleHQsIGdyYW1tYXIpO1xuICAgIHJldHVybiBwYXJzZXI7XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVzKHBhcnNlckNvbnRleHQsIGdyYW1tYXIpIHtcbiAgICBjb25zdCByZWFjaGFibGUgPSBnZXRBbGxSZWFjaGFibGVSdWxlcyhncmFtbWFyLCBmYWxzZSk7XG4gICAgY29uc3QgcGFyc2VyUnVsZXMgPSBzdHJlYW0oZ3JhbW1hci5ydWxlcykuZmlsdGVyKGlzUGFyc2VyUnVsZSkuZmlsdGVyKHJ1bGUgPT4gcmVhY2hhYmxlLmhhcyhydWxlKSk7XG4gICAgZm9yIChjb25zdCBydWxlIG9mIHBhcnNlclJ1bGVzKSB7XG4gICAgICAgIGNvbnN0IGN0eCA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyc2VyQ29udGV4dCksIHsgY29uc3VtZTogMSwgb3B0aW9uYWw6IDEsIHN1YnJ1bGU6IDEsIG1hbnk6IDEsIG9yOiAxIH0pO1xuICAgICAgICBwYXJzZXJDb250ZXh0LnBhcnNlci5ydWxlKHJ1bGUsIGJ1aWxkRWxlbWVudChjdHgsIHJ1bGUuZGVmaW5pdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGJ1aWxkRWxlbWVudChjdHgsIGVsZW1lbnQsIGlnbm9yZUd1YXJkID0gZmFsc2UpIHtcbiAgICBsZXQgbWV0aG9kO1xuICAgIGlmIChpc0tleXdvcmQoZWxlbWVudCkpIHtcbiAgICAgICAgbWV0aG9kID0gYnVpbGRLZXl3b3JkKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQWN0aW9uKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkQWN0aW9uKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQXNzaWdubWVudChlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEVsZW1lbnQoY3R4LCBlbGVtZW50LnRlcm1pbmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDcm9zc1JlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZENyb3NzUmVmZXJlbmNlKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzUnVsZUNhbGwoZWxlbWVudCkpIHtcbiAgICAgICAgbWV0aG9kID0gYnVpbGRSdWxlQ2FsbChjdHgsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0FsdGVybmF0aXZlcyhlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEFsdGVybmF0aXZlcyhjdHgsIGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1Vub3JkZXJlZEdyb3VwKGVsZW1lbnQpKSB7XG4gICAgICAgIG1ldGhvZCA9IGJ1aWxkVW5vcmRlcmVkR3JvdXAoY3R4LCBlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNHcm91cChlbGVtZW50KSkge1xuICAgICAgICBtZXRob2QgPSBidWlsZEdyb3VwKGN0eCwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzRW5kT2ZGaWxlKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5jb25zdW1lKys7XG4gICAgICAgIG1ldGhvZCA9ICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIEVPRiwgZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3JXaXRoTG9jYXRpb24oZWxlbWVudC4kY3N0Tm9kZSwgYFVuZXhwZWN0ZWQgZWxlbWVudCB0eXBlOiAke2VsZW1lbnQuJHR5cGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB3cmFwKGN0eCwgaWdub3JlR3VhcmQgPyB1bmRlZmluZWQgOiBnZXRHdWFyZENvbmRpdGlvbihlbGVtZW50KSwgbWV0aG9kLCBlbGVtZW50LmNhcmRpbmFsaXR5KTtcbn1cbmZ1bmN0aW9uIGJ1aWxkQWN0aW9uKGN0eCwgYWN0aW9uKSB7XG4gICAgY29uc3QgYWN0aW9uVHlwZSA9IGdldFR5cGVOYW1lKGFjdGlvbik7XG4gICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuYWN0aW9uKGFjdGlvblR5cGUsIGFjdGlvbik7XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVDYWxsKGN0eCwgcnVsZUNhbGwpIHtcbiAgICBjb25zdCBydWxlID0gcnVsZUNhbGwucnVsZS5yZWY7XG4gICAgaWYgKGlzUGFyc2VyUnVsZShydWxlKSkge1xuICAgICAgICBjb25zdCBpZHggPSBjdHguc3VicnVsZSsrO1xuICAgICAgICBjb25zdCBmcmFnbWVudCA9IHJ1bGUuZnJhZ21lbnQ7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZSA9IHJ1bGVDYWxsLmFyZ3VtZW50cy5sZW5ndGggPiAwID8gYnVpbGRSdWxlQ2FsbFByZWRpY2F0ZShydWxlLCBydWxlQ2FsbC5hcmd1bWVudHMpIDogKCkgPT4gKHt9KTtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLnN1YnJ1bGUoaWR4LCBnZXRSdWxlKGN0eCwgcnVsZSksIGZyYWdtZW50LCBydWxlQ2FsbCwgcHJlZGljYXRlKGFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNUZXJtaW5hbFJ1bGUocnVsZSkpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICAgICAgY29uc3QgbWV0aG9kID0gZ2V0VG9rZW4oY3R4LCBydWxlLm5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY3R4LnBhcnNlci5jb25zdW1lKGlkeCwgbWV0aG9kLCBydWxlQ2FsbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFydWxlKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcldpdGhMb2NhdGlvbihydWxlQ2FsbC4kY3N0Tm9kZSwgYFVuZGVmaW5lZCBydWxlOiAke3J1bGVDYWxsLnJ1bGUuJHJlZlRleHR9YCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShydWxlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZFJ1bGVDYWxsUHJlZGljYXRlKHJ1bGUsIG5hbWVkQXJncykge1xuICAgIGNvbnN0IHByZWRpY2F0ZXMgPSBuYW1lZEFyZ3MubWFwKGUgPT4gYnVpbGRQcmVkaWNhdGUoZS52YWx1ZSkpO1xuICAgIHJldHVybiAoYXJncykgPT4ge1xuICAgICAgICBjb25zdCBydWxlQXJncyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWRpY2F0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVUYXJnZXQgPSBydWxlLnBhcmFtZXRlcnNbaV07XG4gICAgICAgICAgICBjb25zdCBwcmVkaWNhdGUgPSBwcmVkaWNhdGVzW2ldO1xuICAgICAgICAgICAgcnVsZUFyZ3NbcnVsZVRhcmdldC5uYW1lXSA9IHByZWRpY2F0ZShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcnVsZUFyZ3M7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbikge1xuICAgIGlmIChpc0Rpc2p1bmN0aW9uKGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3QgbGVmdCA9IGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbi5sZWZ0KTtcbiAgICAgICAgY29uc3QgcmlnaHQgPSBidWlsZFByZWRpY2F0ZShjb25kaXRpb24ucmlnaHQpO1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IChsZWZ0KGFyZ3MpIHx8IHJpZ2h0KGFyZ3MpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNDb25qdW5jdGlvbihjb25kaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBidWlsZFByZWRpY2F0ZShjb25kaXRpb24ubGVmdCk7XG4gICAgICAgIGNvbnN0IHJpZ2h0ID0gYnVpbGRQcmVkaWNhdGUoY29uZGl0aW9uLnJpZ2h0KTtcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiAobGVmdChhcmdzKSAmJiByaWdodChhcmdzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzTmVnYXRpb24oY29uZGl0aW9uKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGJ1aWxkUHJlZGljYXRlKGNvbmRpdGlvbi52YWx1ZSk7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gIXZhbHVlKGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1BhcmFtZXRlclJlZmVyZW5jZShjb25kaXRpb24pKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb25kaXRpb24ucGFyYW1ldGVyLnJlZi5uYW1lO1xuICAgICAgICByZXR1cm4gKGFyZ3MpID0+IGFyZ3MgIT09IHVuZGVmaW5lZCAmJiBhcmdzW25hbWVdID09PSB0cnVlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0Jvb2xlYW5MaXRlcmFsKGNvbmRpdGlvbikpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBCb29sZWFuKGNvbmRpdGlvbi50cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHZhbHVlO1xuICAgIH1cbiAgICBhc3NlcnRVbnJlYWNoYWJsZShjb25kaXRpb24pO1xufVxuZnVuY3Rpb24gYnVpbGRBbHRlcm5hdGl2ZXMoY3R4LCBhbHRlcm5hdGl2ZXMpIHtcbiAgICBpZiAoYWx0ZXJuYXRpdmVzLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVpbGRFbGVtZW50KGN0eCwgYWx0ZXJuYXRpdmVzLmVsZW1lbnRzWzBdKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG1ldGhvZHMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGFsdGVybmF0aXZlcy5lbGVtZW50cykge1xuICAgICAgICAgICAgY29uc3QgcHJlZGljYXRlZE1ldGhvZCA9IHtcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB3ZSBoYW5kbGUgdGhlIGd1YXJkIGNvbmRpdGlvbiBpbiB0aGUgYWx0ZXJuYXRpdmUgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIFdlIGNhbiBpZ25vcmUgdGhlIGdyb3VwIGd1YXJkIGNvbmRpdGlvbiBpbnNpZGVcbiAgICAgICAgICAgICAgICBBTFQ6IGJ1aWxkRWxlbWVudChjdHgsIGVsZW1lbnQsIHRydWUpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZ3VhcmQgPSBnZXRHdWFyZENvbmRpdGlvbihlbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChndWFyZCkge1xuICAgICAgICAgICAgICAgIHByZWRpY2F0ZWRNZXRob2QuR0FURSA9IGJ1aWxkUHJlZGljYXRlKGd1YXJkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ldGhvZHMucHVzaChwcmVkaWNhdGVkTWV0aG9kKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZHggPSBjdHgub3IrKztcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLmFsdGVybmF0aXZlcyhpZHgsIG1ldGhvZHMubWFwKG1ldGhvZCA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbHQgPSB7XG4gICAgICAgICAgICAgICAgQUxUOiAoKSA9PiBtZXRob2QuQUxUKGFyZ3MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgZ2F0ZSA9IG1ldGhvZC5HQVRFO1xuICAgICAgICAgICAgaWYgKGdhdGUpIHtcbiAgICAgICAgICAgICAgICBhbHQuR0FURSA9ICgpID0+IGdhdGUoYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWx0O1xuICAgICAgICB9KSk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnVpbGRVbm9yZGVyZWRHcm91cChjdHgsIGdyb3VwKSB7XG4gICAgaWYgKGdyb3VwLmVsZW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gYnVpbGRFbGVtZW50KGN0eCwgZ3JvdXAuZWxlbWVudHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCBtZXRob2RzID0gW107XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGdyb3VwLmVsZW1lbnRzKSB7XG4gICAgICAgIGNvbnN0IHByZWRpY2F0ZWRNZXRob2QgPSB7XG4gICAgICAgICAgICAvLyBTaW5jZSB3ZSBoYW5kbGUgdGhlIGd1YXJkIGNvbmRpdGlvbiBpbiB0aGUgYWx0ZXJuYXRpdmUgYWxyZWFkeVxuICAgICAgICAgICAgLy8gV2UgY2FuIGlnbm9yZSB0aGUgZ3JvdXAgZ3VhcmQgY29uZGl0aW9uIGluc2lkZVxuICAgICAgICAgICAgQUxUOiBidWlsZEVsZW1lbnQoY3R4LCBlbGVtZW50LCB0cnVlKVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBndWFyZCA9IGdldEd1YXJkQ29uZGl0aW9uKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZ3VhcmQpIHtcbiAgICAgICAgICAgIHByZWRpY2F0ZWRNZXRob2QuR0FURSA9IGJ1aWxkUHJlZGljYXRlKGd1YXJkKTtcbiAgICAgICAgfVxuICAgICAgICBtZXRob2RzLnB1c2gocHJlZGljYXRlZE1ldGhvZCk7XG4gICAgfVxuICAgIGNvbnN0IG9ySWR4ID0gY3R4Lm9yKys7XG4gICAgY29uc3QgaWRGdW5jID0gKGdyb3VwSWR4LCBsUGFyc2VyKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YWNrSWQgPSBsUGFyc2VyLmdldFJ1bGVTdGFjaygpLmpvaW4oJy0nKTtcbiAgICAgICAgcmV0dXJuIGB1R3JvdXBfJHtncm91cElkeH1fJHtzdGFja0lkfWA7XG4gICAgfTtcbiAgICBjb25zdCBhbHRlcm5hdGl2ZXMgPSAoYXJncykgPT4gY3R4LnBhcnNlci5hbHRlcm5hdGl2ZXMob3JJZHgsIG1ldGhvZHMubWFwKChtZXRob2QsIGlkeCkgPT4ge1xuICAgICAgICBjb25zdCBhbHQgPSB7IEFMVDogKCkgPT4gdHJ1ZSB9O1xuICAgICAgICBjb25zdCBwYXJzZXIgPSBjdHgucGFyc2VyO1xuICAgICAgICBhbHQuQUxUID0gKCkgPT4ge1xuICAgICAgICAgICAgbWV0aG9kLkFMVChhcmdzKTtcbiAgICAgICAgICAgIGlmICghcGFyc2VyLmlzUmVjb3JkaW5nKCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBpZEZ1bmMob3JJZHgsIHBhcnNlcik7XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJzZXIudW5vcmRlcmVkR3JvdXBzLmdldChrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGluaXQgYWZ0ZXIgY2xlYXIgc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VyLnVub3JkZXJlZEdyb3Vwcy5zZXQoa2V5LCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGdyb3VwU3RhdGUgPSBwYXJzZXIudW5vcmRlcmVkR3JvdXBzLmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGdyb3VwU3RhdGUgPT09IG51bGwgfHwgZ3JvdXBTdGF0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ3JvdXBTdGF0ZVtpZHhdKSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTm90IGFjY2Vzc2VkIHlldFxuICAgICAgICAgICAgICAgICAgICBncm91cFN0YXRlW2lkeF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZ2F0ZSA9IG1ldGhvZC5HQVRFO1xuICAgICAgICBpZiAoZ2F0ZSkge1xuICAgICAgICAgICAgYWx0LkdBVEUgPSAoKSA9PiBnYXRlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWx0LkdBVEUgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhY2tlZEFsdGVybmF0aXZlcyA9IHBhcnNlci51bm9yZGVyZWRHcm91cHMuZ2V0KGlkRnVuYyhvcklkeCwgcGFyc2VyKSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYWxsb3cgPSAhKHRyYWNrZWRBbHRlcm5hdGl2ZXMgPT09IG51bGwgfHwgdHJhY2tlZEFsdGVybmF0aXZlcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tlZEFsdGVybmF0aXZlc1tpZHhdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWxsb3c7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbHQ7XG4gICAgfSkpO1xuICAgIGNvbnN0IHdyYXBwZWQgPSB3cmFwKGN0eCwgZ2V0R3VhcmRDb25kaXRpb24oZ3JvdXApLCBhbHRlcm5hdGl2ZXMsICcqJyk7XG4gICAgcmV0dXJuIChhcmdzKSA9PiB7XG4gICAgICAgIHdyYXBwZWQoYXJncyk7XG4gICAgICAgIGlmICghY3R4LnBhcnNlci5pc1JlY29yZGluZygpKSB7XG4gICAgICAgICAgICBjdHgucGFyc2VyLnVub3JkZXJlZEdyb3Vwcy5kZWxldGUoaWRGdW5jKG9ySWR4LCBjdHgucGFyc2VyKSk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRHcm91cChjdHgsIGdyb3VwKSB7XG4gICAgY29uc3QgbWV0aG9kcyA9IGdyb3VwLmVsZW1lbnRzLm1hcChlID0+IGJ1aWxkRWxlbWVudChjdHgsIGUpKTtcbiAgICByZXR1cm4gKGFyZ3MpID0+IG1ldGhvZHMuZm9yRWFjaChtZXRob2QgPT4gbWV0aG9kKGFyZ3MpKTtcbn1cbmZ1bmN0aW9uIGdldEd1YXJkQ29uZGl0aW9uKGVsZW1lbnQpIHtcbiAgICBpZiAoaXNHcm91cChlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudC5ndWFyZENvbmRpdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGJ1aWxkQ3Jvc3NSZWZlcmVuY2UoY3R4LCBjcm9zc1JlZiwgdGVybWluYWwgPSBjcm9zc1JlZi50ZXJtaW5hbCkge1xuICAgIGlmICghdGVybWluYWwpIHtcbiAgICAgICAgaWYgKCFjcm9zc1JlZi50eXBlLnJlZikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgdG8gdHlwZTogJyArIGNyb3NzUmVmLnR5cGUuJHJlZlRleHQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBmaW5kTmFtZUFzc2lnbm1lbnQoY3Jvc3NSZWYudHlwZS5yZWYpO1xuICAgICAgICBjb25zdCBhc3NpZ25UZXJtaW5hbCA9IGFzc2lnbm1lbnQgPT09IG51bGwgfHwgYXNzaWdubWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXNzaWdubWVudC50ZXJtaW5hbDtcbiAgICAgICAgaWYgKCFhc3NpZ25UZXJtaW5hbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZmluZCBuYW1lIGFzc2lnbm1lbnQgZm9yIHR5cGU6ICcgKyBnZXRUeXBlTmFtZShjcm9zc1JlZi50eXBlLnJlZikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBidWlsZENyb3NzUmVmZXJlbmNlKGN0eCwgY3Jvc3NSZWYsIGFzc2lnblRlcm1pbmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNSdWxlQ2FsbCh0ZXJtaW5hbCkgJiYgaXNQYXJzZXJSdWxlKHRlcm1pbmFsLnJ1bGUucmVmKSkge1xuICAgICAgICAvLyBUaGUgdGVybWluYWwgaXMgYSBkYXRhIHR5cGUgcnVsZSBoZXJlLiBFdmVyeXRoaW5nIGVsc2Ugd2lsbCByZXN1bHQgaW4gYSB2YWxpZGF0aW9uIGVycm9yLlxuICAgICAgICBjb25zdCBydWxlID0gdGVybWluYWwucnVsZS5yZWY7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5zdWJydWxlKys7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5zdWJydWxlKGlkeCwgZ2V0UnVsZShjdHgsIHJ1bGUpLCBmYWxzZSwgY3Jvc3NSZWYsIGFyZ3MpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1J1bGVDYWxsKHRlcm1pbmFsKSAmJiBpc1Rlcm1pbmFsUnVsZSh0ZXJtaW5hbC5ydWxlLnJlZikpIHtcbiAgICAgICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICAgICAgY29uc3QgdGVybWluYWxSdWxlID0gZ2V0VG9rZW4oY3R4LCB0ZXJtaW5hbC5ydWxlLnJlZi5uYW1lKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIHRlcm1pbmFsUnVsZSwgY3Jvc3NSZWYpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0tleXdvcmQodGVybWluYWwpKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5jb25zdW1lKys7XG4gICAgICAgIGNvbnN0IGtleXdvcmQgPSBnZXRUb2tlbihjdHgsIHRlcm1pbmFsLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IGN0eC5wYXJzZXIuY29uc3VtZShpZHgsIGtleXdvcmQsIGNyb3NzUmVmKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGJ1aWxkIGNyb3NzIHJlZmVyZW5jZSBwYXJzZXInKTtcbiAgICB9XG59XG5mdW5jdGlvbiBidWlsZEtleXdvcmQoY3R4LCBrZXl3b3JkKSB7XG4gICAgY29uc3QgaWR4ID0gY3R4LmNvbnN1bWUrKztcbiAgICBjb25zdCB0b2tlbiA9IGN0eC50b2tlbnNba2V5d29yZC52YWx1ZV07XG4gICAgaWYgKCF0b2tlbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIHRva2VuIGZvciBrZXl3b3JkOiAnICsga2V5d29yZC52YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiAoKSA9PiBjdHgucGFyc2VyLmNvbnN1bWUoaWR4LCB0b2tlbiwga2V5d29yZCk7XG59XG5mdW5jdGlvbiB3cmFwKGN0eCwgZ3VhcmQsIG1ldGhvZCwgY2FyZGluYWxpdHkpIHtcbiAgICBjb25zdCBnYXRlID0gZ3VhcmQgJiYgYnVpbGRQcmVkaWNhdGUoZ3VhcmQpO1xuICAgIGlmICghY2FyZGluYWxpdHkpIHtcbiAgICAgICAgaWYgKGdhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IGN0eC5vcisrO1xuICAgICAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLmFsdGVybmF0aXZlcyhpZHgsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4gbWV0aG9kKGFyZ3MpLFxuICAgICAgICAgICAgICAgICAgICBHQVRFOiAoKSA9PiBnYXRlKGFyZ3MpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogRU1QVFlfQUxUKCksXG4gICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+ICFnYXRlKGFyZ3MpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbWV0aG9kO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChjYXJkaW5hbGl0eSA9PT0gJyonKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGN0eC5tYW55Kys7XG4gICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5tYW55KGlkeCwge1xuICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncyksXG4gICAgICAgICAgICBHQVRFOiBnYXRlID8gKCkgPT4gZ2F0ZShhcmdzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoY2FyZGluYWxpdHkgPT09ICcrJykge1xuICAgICAgICBjb25zdCBpZHggPSBjdHgubWFueSsrO1xuICAgICAgICBpZiAoZ2F0ZSkge1xuICAgICAgICAgICAgY29uc3Qgb3JJZHggPSBjdHgub3IrKztcbiAgICAgICAgICAgIC8vIEluIHRoZSBjYXNlIG9mIGEgZ3VhcmQgY29uZGl0aW9uIGZvciB0aGUgYCtgIGdyb3VwXG4gICAgICAgICAgICAvLyBXZSBjb21iaW5lIGl0IHdpdGggYW4gZW1wdHkgYWx0ZXJuYXRpdmVcbiAgICAgICAgICAgIC8vIElmIHRoZSBjb25kaXRpb24gcmV0dXJucyB0cnVlLCBpdCBuZWVkcyB0byBwYXJzZSBhdCBsZWFzdCBhIHNpbmdsZSBpdGVyYXRpb25cbiAgICAgICAgICAgIC8vIElmIGl0cyBmYWxzZSwgaXQgaXMgbm90IGFsbG93ZWQgdG8gcGFyc2UgYW55dGhpbmdcbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5hbHRlcm5hdGl2ZXMob3JJZHgsIFtcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIEFMVDogKCkgPT4gY3R4LnBhcnNlci5hdExlYXN0T25lKGlkeCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncylcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIEdBVEU6ICgpID0+IGdhdGUoYXJncylcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgQUxUOiBFTVBUWV9BTFQoKSxcbiAgICAgICAgICAgICAgICAgICAgR0FURTogKCkgPT4gIWdhdGUoYXJncylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAoYXJncykgPT4gY3R4LnBhcnNlci5hdExlYXN0T25lKGlkeCwge1xuICAgICAgICAgICAgICAgIERFRjogKCkgPT4gbWV0aG9kKGFyZ3MpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoY2FyZGluYWxpdHkgPT09ICc/Jykge1xuICAgICAgICBjb25zdCBpZHggPSBjdHgub3B0aW9uYWwrKztcbiAgICAgICAgcmV0dXJuIChhcmdzKSA9PiBjdHgucGFyc2VyLm9wdGlvbmFsKGlkeCwge1xuICAgICAgICAgICAgREVGOiAoKSA9PiBtZXRob2QoYXJncyksXG4gICAgICAgICAgICBHQVRFOiBnYXRlID8gKCkgPT4gZ2F0ZShhcmdzKSA6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFVucmVhY2hhYmxlKGNhcmRpbmFsaXR5KTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRSdWxlKGN0eCwgZWxlbWVudCkge1xuICAgIGNvbnN0IG5hbWUgPSBnZXRSdWxlTmFtZShjdHgsIGVsZW1lbnQpO1xuICAgIGNvbnN0IHJ1bGUgPSBjdHgucGFyc2VyLmdldFJ1bGUobmFtZSk7XG4gICAgaWYgKCFydWxlKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJ1bGUgXCIke25hbWV9XCIgbm90IGZvdW5kLlwiYCk7XG4gICAgcmV0dXJuIHJ1bGU7XG59XG5mdW5jdGlvbiBnZXRSdWxlTmFtZShjdHgsIGVsZW1lbnQpIHtcbiAgICBpZiAoaXNQYXJzZXJSdWxlKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50Lm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGN0eC5ydWxlTmFtZXMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBjdHgucnVsZU5hbWVzLmdldChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGxldCBpdGVtID0gZWxlbWVudDtcbiAgICAgICAgbGV0IHBhcmVudCA9IGl0ZW0uJGNvbnRhaW5lcjtcbiAgICAgICAgbGV0IHJ1bGVOYW1lID0gZWxlbWVudC4kdHlwZTtcbiAgICAgICAgd2hpbGUgKCFpc1BhcnNlclJ1bGUocGFyZW50KSkge1xuICAgICAgICAgICAgaWYgKGlzR3JvdXAocGFyZW50KSB8fCBpc0FsdGVybmF0aXZlcyhwYXJlbnQpIHx8IGlzVW5vcmRlcmVkR3JvdXAocGFyZW50KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmVsZW1lbnRzLmluZGV4T2YoaXRlbSk7XG4gICAgICAgICAgICAgICAgcnVsZU5hbWUgPSBpbmRleC50b1N0cmluZygpICsgJzonICsgcnVsZU5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpdGVtID0gcGFyZW50O1xuICAgICAgICAgICAgcGFyZW50ID0gcGFyZW50LiRjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVsZSA9IHBhcmVudDtcbiAgICAgICAgcnVsZU5hbWUgPSBydWxlLm5hbWUgKyAnOicgKyBydWxlTmFtZTtcbiAgICAgICAgY3R4LnJ1bGVOYW1lcy5zZXQoZWxlbWVudCwgcnVsZU5hbWUpO1xuICAgICAgICByZXR1cm4gcnVsZU5hbWU7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0VG9rZW4oY3R4LCBuYW1lKSB7XG4gICAgY29uc3QgdG9rZW4gPSBjdHgudG9rZW5zW25hbWVdO1xuICAgIGlmICghdG9rZW4pXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVG9rZW4gXCIke25hbWV9XCIgbm90IGZvdW5kLlwiYCk7XG4gICAgcmV0dXJuIHRva2VuO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFyc2VyLWJ1aWxkZXItYmFzZS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBMZXhlciB9IGZyb20gJ2NoZXZyb3RhaW4nO1xuaW1wb3J0IHsgaXNLZXl3b3JkLCBpc1BhcnNlclJ1bGUsIGlzVGVybWluYWxSdWxlIH0gZnJvbSAnLi4vbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMnO1xuaW1wb3J0IHsgc3RyZWFtQWxsQ29udGVudHMgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgZ2V0QWxsUmVhY2hhYmxlUnVsZXMsIHRlcm1pbmFsUmVnZXggfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmltcG9ydCB7IGdldENhc2VJbnNlbnNpdGl2ZVBhdHRlcm4sIGlzV2hpdGVzcGFjZSwgcGFydGlhbE1hdGNoZXMgfSBmcm9tICcuLi91dGlscy9yZWdleHAtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0VG9rZW5CdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBsaXN0IG9mIGRpYWdub3N0aWNzIHN0b3JlZCBkdXJpbmcgdGhlIGxleGluZyBwcm9jZXNzIG9mIGEgc2luZ2xlIHRleHQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gW107XG4gICAgfVxuICAgIGJ1aWxkVG9rZW5zKGdyYW1tYXIsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVhY2hhYmxlUnVsZXMgPSBzdHJlYW0oZ2V0QWxsUmVhY2hhYmxlUnVsZXMoZ3JhbW1hciwgZmFsc2UpKTtcbiAgICAgICAgY29uc3QgdGVybWluYWxUb2tlbnMgPSB0aGlzLmJ1aWxkVGVybWluYWxUb2tlbnMocmVhY2hhYmxlUnVsZXMpO1xuICAgICAgICBjb25zdCB0b2tlbnMgPSB0aGlzLmJ1aWxkS2V5d29yZFRva2VucyhyZWFjaGFibGVSdWxlcywgdGVybWluYWxUb2tlbnMsIG9wdGlvbnMpO1xuICAgICAgICB0ZXJtaW5hbFRva2Vucy5mb3JFYWNoKHRlcm1pbmFsVG9rZW4gPT4ge1xuICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHRlcm1pbmFsVG9rZW4uUEFUVEVSTjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ29iamVjdCcgJiYgcGF0dGVybiAmJiAndGVzdCcgaW4gcGF0dGVybiAmJiBpc1doaXRlc3BhY2UocGF0dGVybikpIHtcbiAgICAgICAgICAgICAgICB0b2tlbnMudW5zaGlmdCh0ZXJtaW5hbFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRlcm1pbmFsVG9rZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gV2UgZG9uJ3QgbmVlZCB0byBhZGQgdGhlIEVPRiB0b2tlbiBleHBsaWNpdGx5LlxuICAgICAgICAvLyBJdCBpcyBhdXRvbWF0aWNhbGx5IGF2YWlsYWJsZSBhdCB0aGUgZW5kIG9mIHRoZSB0b2tlbiBzdHJlYW0uXG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBmbHVzaExleGluZ1JlcG9ydCh0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IGRpYWdub3N0aWNzOiB0aGlzLnBvcERpYWdub3N0aWNzKCkgfTtcbiAgICB9XG4gICAgcG9wRGlhZ25vc3RpY3MoKSB7XG4gICAgICAgIGNvbnN0IGRpYWdub3N0aWNzID0gWy4uLnRoaXMuZGlhZ25vc3RpY3NdO1xuICAgICAgICB0aGlzLmRpYWdub3N0aWNzID0gW107XG4gICAgICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgICB9XG4gICAgYnVpbGRUZXJtaW5hbFRva2VucyhydWxlcykge1xuICAgICAgICByZXR1cm4gcnVsZXMuZmlsdGVyKGlzVGVybWluYWxSdWxlKS5maWx0ZXIoZSA9PiAhZS5mcmFnbWVudClcbiAgICAgICAgICAgIC5tYXAodGVybWluYWwgPT4gdGhpcy5idWlsZFRlcm1pbmFsVG9rZW4odGVybWluYWwpKS50b0FycmF5KCk7XG4gICAgfVxuICAgIGJ1aWxkVGVybWluYWxUb2tlbih0ZXJtaW5hbCkge1xuICAgICAgICBjb25zdCByZWdleCA9IHRlcm1pbmFsUmVnZXgodGVybWluYWwpO1xuICAgICAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5yZXF1aXJlc0N1c3RvbVBhdHRlcm4ocmVnZXgpID8gdGhpcy5yZWdleFBhdHRlcm5GdW5jdGlvbihyZWdleCkgOiByZWdleDtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0ge1xuICAgICAgICAgICAgbmFtZTogdGVybWluYWwubmFtZSxcbiAgICAgICAgICAgIFBBVFRFUk46IHBhdHRlcm4sXG4gICAgICAgIH07XG4gICAgICAgIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdG9rZW5UeXBlLkxJTkVfQlJFQUtTID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGVybWluYWwuaGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBPbmx5IHNraXAgdG9rZW5zIHRoYXQgYXJlIGFibGUgdG8gYWNjZXB0IHdoaXRlc3BhY2VcbiAgICAgICAgICAgIHRva2VuVHlwZS5HUk9VUCA9IGlzV2hpdGVzcGFjZShyZWdleCkgPyBMZXhlci5TS0lQUEVEIDogJ2hpZGRlbic7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VuVHlwZTtcbiAgICB9XG4gICAgcmVxdWlyZXNDdXN0b21QYXR0ZXJuKHJlZ2V4KSB7XG4gICAgICAgIGlmIChyZWdleC5mbGFncy5pbmNsdWRlcygndScpIHx8IHJlZ2V4LmZsYWdzLmluY2x1ZGVzKCdzJykpIHtcbiAgICAgICAgICAgIC8vIFVuaWNvZGUgYW5kIGRvdGFsbCByZWdleGVzIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IENoZXZyb3RhaW4uXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZWdleC5zb3VyY2UuaW5jbHVkZXMoJz88PScpIHx8IHJlZ2V4LnNvdXJjZS5pbmNsdWRlcygnPzwhJykpIHtcbiAgICAgICAgICAgIC8vIE5lZ2F0aXZlIGFuZCBwb3NpdGl2ZSBsb29rYmVoaW5kIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IENoZXZyb3RhaW4geWV0LlxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVnZXhQYXR0ZXJuRnVuY3Rpb24ocmVnZXgpIHtcbiAgICAgICAgY29uc3Qgc3RpY2t5UmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4LCByZWdleC5mbGFncyArICd5Jyk7XG4gICAgICAgIHJldHVybiAodGV4dCwgb2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICBzdGlja3lSZWdleC5sYXN0SW5kZXggPSBvZmZzZXQ7XG4gICAgICAgICAgICBjb25zdCBleGVjUmVzdWx0ID0gc3RpY2t5UmVnZXguZXhlYyh0ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiBleGVjUmVzdWx0O1xuICAgICAgICB9O1xuICAgIH1cbiAgICBidWlsZEtleXdvcmRUb2tlbnMocnVsZXMsIHRlcm1pbmFsVG9rZW5zLCBvcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBydWxlc1xuICAgICAgICAgICAgLy8gV2UgZmlsdGVyIGJ5IHBhcnNlciBydWxlcywgc2luY2Uga2V5d29yZHMgaW4gdGVybWluYWwgcnVsZXMgZ2V0IHRyYW5zZm9ybWVkIGludG8gcmVnZXggYW5kIGFyZSBub3QgYWN0dWFsIHRva2Vuc1xuICAgICAgICAgICAgLmZpbHRlcihpc1BhcnNlclJ1bGUpXG4gICAgICAgICAgICAuZmxhdE1hcChydWxlID0+IHN0cmVhbUFsbENvbnRlbnRzKHJ1bGUpLmZpbHRlcihpc0tleXdvcmQpKVxuICAgICAgICAgICAgLmRpc3RpbmN0KGUgPT4gZS52YWx1ZSkudG9BcnJheSgpXG4gICAgICAgICAgICAvLyBTb3J0IGtleXdvcmRzIGJ5IGRlc2NlbmRpbmcgbGVuZ3RoXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gYi52YWx1ZS5sZW5ndGggLSBhLnZhbHVlLmxlbmd0aClcbiAgICAgICAgICAgIC5tYXAoa2V5d29yZCA9PiB0aGlzLmJ1aWxkS2V5d29yZFRva2VuKGtleXdvcmQsIHRlcm1pbmFsVG9rZW5zLCBCb29sZWFuKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXNlSW5zZW5zaXRpdmUpKSk7XG4gICAgfVxuICAgIGJ1aWxkS2V5d29yZFRva2VuKGtleXdvcmQsIHRlcm1pbmFsVG9rZW5zLCBjYXNlSW5zZW5zaXRpdmUpIHtcbiAgICAgICAgY29uc3Qga2V5d29yZFBhdHRlcm4gPSB0aGlzLmJ1aWxkS2V5d29yZFBhdHRlcm4oa2V5d29yZCwgY2FzZUluc2Vuc2l0aXZlKTtcbiAgICAgICAgY29uc3QgdG9rZW5UeXBlID0ge1xuICAgICAgICAgICAgbmFtZToga2V5d29yZC52YWx1ZSxcbiAgICAgICAgICAgIFBBVFRFUk46IGtleXdvcmRQYXR0ZXJuLFxuICAgICAgICAgICAgTE9OR0VSX0FMVDogdGhpcy5maW5kTG9uZ2VyQWx0KGtleXdvcmQsIHRlcm1pbmFsVG9rZW5zKVxuICAgICAgICB9O1xuICAgICAgICBpZiAodHlwZW9mIGtleXdvcmRQYXR0ZXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0b2tlblR5cGUuTElORV9CUkVBS1MgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlblR5cGU7XG4gICAgfVxuICAgIGJ1aWxkS2V5d29yZFBhdHRlcm4oa2V5d29yZCwgY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICAgIHJldHVybiBjYXNlSW5zZW5zaXRpdmUgP1xuICAgICAgICAgICAgbmV3IFJlZ0V4cChnZXRDYXNlSW5zZW5zaXRpdmVQYXR0ZXJuKGtleXdvcmQudmFsdWUpKSA6XG4gICAgICAgICAgICBrZXl3b3JkLnZhbHVlO1xuICAgIH1cbiAgICBmaW5kTG9uZ2VyQWx0KGtleXdvcmQsIHRlcm1pbmFsVG9rZW5zKSB7XG4gICAgICAgIHJldHVybiB0ZXJtaW5hbFRva2Vucy5yZWR1Y2UoKGxvbmdlckFsdHMsIHRva2VuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYXR0ZXJuID0gdG9rZW4gPT09IG51bGwgfHwgdG9rZW4gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRva2VuLlBBVFRFUk47XG4gICAgICAgICAgICBpZiAoKHBhdHRlcm4gPT09IG51bGwgfHwgcGF0dGVybiA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0dGVybi5zb3VyY2UpICYmIHBhcnRpYWxNYXRjaGVzKCdeJyArIHBhdHRlcm4uc291cmNlICsgJyQnLCBrZXl3b3JkLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGxvbmdlckFsdHMucHVzaCh0b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9uZ2VyQWx0cztcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRva2VuLWJ1aWxkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgaXNDcm9zc1JlZmVyZW5jZSwgaXNSdWxlQ2FsbCB9IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IGdldENyb3NzUmVmZXJlbmNlVGVybWluYWwsIGdldFJ1bGVUeXBlIH0gZnJvbSAnLi4vdXRpbHMvZ3JhbW1hci11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdFZhbHVlQ29udmVydGVyIHtcbiAgICBjb252ZXJ0KGlucHV0LCBjc3ROb2RlKSB7XG4gICAgICAgIGxldCBmZWF0dXJlID0gY3N0Tm9kZS5ncmFtbWFyU291cmNlO1xuICAgICAgICBpZiAoaXNDcm9zc1JlZmVyZW5jZShmZWF0dXJlKSkge1xuICAgICAgICAgICAgZmVhdHVyZSA9IGdldENyb3NzUmVmZXJlbmNlVGVybWluYWwoZmVhdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzUnVsZUNhbGwoZmVhdHVyZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGUgPSBmZWF0dXJlLnJ1bGUucmVmO1xuICAgICAgICAgICAgaWYgKCFydWxlKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGNzdCBub2RlIHdhcyBub3QgcGFyc2VkIGJ5IGEgcnVsZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJ1bkNvbnZlcnRlcihydWxlLCBpbnB1dCwgY3N0Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgcnVuQ29udmVydGVyKHJ1bGUsIGlucHV0LCBjc3ROb2RlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgc3dpdGNoIChydWxlLm5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnSU5UJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnRJbnQoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnU1RSSU5HJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnRTdHJpbmcoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnSUQnOiByZXR1cm4gVmFsdWVDb252ZXJ0ZXIuY29udmVydElEKGlucHV0KTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKChfYSA9IGdldFJ1bGVUeXBlKHJ1bGUpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgY2FzZSAnbnVtYmVyJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnROdW1iZXIoaW5wdXQpO1xuICAgICAgICAgICAgY2FzZSAnYm9vbGVhbic6IHJldHVybiBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0Qm9vbGVhbihpbnB1dCk7XG4gICAgICAgICAgICBjYXNlICdiaWdpbnQnOiByZXR1cm4gVmFsdWVDb252ZXJ0ZXIuY29udmVydEJpZ2ludChpbnB1dCk7XG4gICAgICAgICAgICBjYXNlICdkYXRlJzogcmV0dXJuIFZhbHVlQ29udmVydGVyLmNvbnZlcnREYXRlKGlucHV0KTtcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBpbnB1dDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB2YXIgVmFsdWVDb252ZXJ0ZXI7XG4oZnVuY3Rpb24gKFZhbHVlQ29udmVydGVyKSB7XG4gICAgZnVuY3Rpb24gY29udmVydFN0cmluZyhpbnB1dCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXQubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgICAgaWYgKGMgPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMxID0gaW5wdXQuY2hhckF0KCsraSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGNvbnZlcnRFc2NhcGVDaGFyYWN0ZXIoYzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IGM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydFN0cmluZyA9IGNvbnZlcnRTdHJpbmc7XG4gICAgZnVuY3Rpb24gY29udmVydEVzY2FwZUNoYXJhY3RlcihjaGFyKSB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgICAgY2FzZSAnYic6IHJldHVybiAnXFxiJztcbiAgICAgICAgICAgIGNhc2UgJ2YnOiByZXR1cm4gJ1xcZic7XG4gICAgICAgICAgICBjYXNlICduJzogcmV0dXJuICdcXG4nO1xuICAgICAgICAgICAgY2FzZSAncic6IHJldHVybiAnXFxyJztcbiAgICAgICAgICAgIGNhc2UgJ3QnOiByZXR1cm4gJ1xcdCc7XG4gICAgICAgICAgICBjYXNlICd2JzogcmV0dXJuICdcXHYnO1xuICAgICAgICAgICAgY2FzZSAnMCc6IHJldHVybiAnXFwwJztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHJldHVybiBjaGFyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNvbnZlcnRJRChpbnB1dCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckF0KDApID09PSAnXicpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcoMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5wdXQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydElEID0gY29udmVydElEO1xuICAgIGZ1bmN0aW9uIGNvbnZlcnRJbnQoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydEludCA9IGNvbnZlcnRJbnQ7XG4gICAgZnVuY3Rpb24gY29udmVydEJpZ2ludChpbnB1dCkge1xuICAgICAgICByZXR1cm4gQmlnSW50KGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydEJpZ2ludCA9IGNvbnZlcnRCaWdpbnQ7XG4gICAgZnVuY3Rpb24gY29udmVydERhdGUoaW5wdXQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKGlucHV0KTtcbiAgICB9XG4gICAgVmFsdWVDb252ZXJ0ZXIuY29udmVydERhdGUgPSBjb252ZXJ0RGF0ZTtcbiAgICBmdW5jdGlvbiBjb252ZXJ0TnVtYmVyKGlucHV0KSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIoaW5wdXQpO1xuICAgIH1cbiAgICBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0TnVtYmVyID0gY29udmVydE51bWJlcjtcbiAgICBmdW5jdGlvbiBjb252ZXJ0Qm9vbGVhbihpbnB1dCkge1xuICAgICAgICByZXR1cm4gaW5wdXQudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xuICAgIH1cbiAgICBWYWx1ZUNvbnZlcnRlci5jb252ZXJ0Qm9vbGVhbiA9IGNvbnZlcnRCb29sZWFuO1xufSkoVmFsdWVDb252ZXJ0ZXIgfHwgKFZhbHVlQ29udmVydGVyID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbHVlLWNvbnZlcnRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBpc0FzdE5vZGUsIGlzQXN0Tm9kZURlc2NyaXB0aW9uLCBpc0xpbmtpbmdFcnJvciB9IGZyb20gJy4uL3N5bnRheC10cmVlLmpzJztcbmltcG9ydCB7IGZpbmRSb290Tm9kZSwgc3RyZWFtQXN0LCBzdHJlYW1SZWZlcmVuY2VzIH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IGludGVycnVwdEFuZENoZWNrIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBEb2N1bWVudFN0YXRlIH0gZnJvbSAnLi4vd29ya3NwYWNlL2RvY3VtZW50cy5qcyc7XG5jb25zdCByZWZfcmVzb2x2aW5nID0gU3ltYm9sKCdyZWZfcmVzb2x2aW5nJyk7XG5leHBvcnQgY2xhc3MgRGVmYXVsdExpbmtlciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5yZWZsZWN0aW9uID0gc2VydmljZXMuc2hhcmVkLkFzdFJlZmxlY3Rpb247XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9ICgpID0+IHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50cztcbiAgICAgICAgdGhpcy5zY29wZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5TY29wZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmFzdE5vZGVMb2NhdG9yID0gc2VydmljZXMud29ya3NwYWNlLkFzdE5vZGVMb2NhdG9yO1xuICAgIH1cbiAgICBhc3luYyBsaW5rKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHN0cmVhbUFzdChkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZSkpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHN0cmVhbVJlZmVyZW5jZXMobm9kZSkuZm9yRWFjaChyZWYgPT4gdGhpcy5kb0xpbmsocmVmLCBkb2N1bWVudCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRvTGluayhyZWZJbmZvLCBkb2N1bWVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlZiA9IHJlZkluZm8ucmVmZXJlbmNlO1xuICAgICAgICAvLyBUaGUgcmVmZXJlbmNlIG1heSBhbHJlYWR5IGhhdmUgYmVlbiByZXNvbHZlZCBsYXppbHkgYnkgYWNjZXNzaW5nIGl0cyBgcmVmYCBwcm9wZXJ0eS5cbiAgICAgICAgaWYgKHJlZi5fcmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlZi5fcmVmID0gcmVmX3Jlc29sdmluZztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB0aGlzLmdldENhbmRpZGF0ZShyZWZJbmZvKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMaW5raW5nRXJyb3IoZGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5fcmVmID0gZGVzY3JpcHRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWYuX25vZGVEZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5sYW5naXVtRG9jdW1lbnRzKCkuaGFzRG9jdW1lbnQoZGVzY3JpcHRpb24uZG9jdW1lbnRVcmkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdGFyZ2V0IGRvY3VtZW50IGlzIGFscmVhZHkgbG9hZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rZWROb2RlID0gdGhpcy5sb2FkQXN0Tm9kZShkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWYuX3JlZiA9IGxpbmtlZE5vZGUgIT09IG51bGwgJiYgbGlua2VkTm9kZSAhPT0gdm9pZCAwID8gbGlua2VkTm9kZSA6IHRoaXMuY3JlYXRlTGlua2luZ0Vycm9yKHJlZkluZm8sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBsb2FkIHRoZSB0YXJnZXQgQVNUIG5vZGUgbGF0ZXIgdXNpbmcgdGhlIGFscmVhZHkgcHJvdmlkZWQgZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlZi5fcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlc29sdmluZyByZWZlcmVuY2UgdG8gJyR7cmVmLiRyZWZUZXh0fSc6YCwgZXJyKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSAoX2EgPSBlcnIubWVzc2FnZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogU3RyaW5nKGVycik7XG4gICAgICAgICAgICAgICAgcmVmLl9yZWYgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZkluZm8pLCB7IG1lc3NhZ2U6IGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXNvbHZpbmcgcmVmZXJlbmNlIHRvICcke3JlZi4kcmVmVGV4dH0nOiAke2Vycm9yTWVzc2FnZX1gIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSByZWZlcmVuY2UgdG8gdGhlIGRvY3VtZW50J3MgYXJyYXkgb2YgcmVmZXJlbmNlc1xuICAgICAgICAgICAgLy8gT25seSBhZGQgaWYgdGhlIHJlZmVyZW5jZSBoYXMgYmVlbiBub3QgYmVlbiByZXNvbHZlZCBlYXJsaWVyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgZW5kIHVwIHdpdGggZHVwbGljYXRlc1xuICAgICAgICAgICAgLy8gU2VlIGFsc28gaW1wbGVtZW50YXRpb24gb2YgYGJ1aWxkUmVmZXJlbmNlYFxuICAgICAgICAgICAgZG9jdW1lbnQucmVmZXJlbmNlcy5wdXNoKHJlZik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5saW5rKGRvY3VtZW50KSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVmIG9mIGRvY3VtZW50LnJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIGRlbGV0ZSByZWYuX3JlZjtcbiAgICAgICAgICAgIGRlbGV0ZSByZWYuX25vZGVEZXNjcmlwdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBkb2N1bWVudC5yZWZlcmVuY2VzID0gW107XG4gICAgfVxuICAgIGdldENhbmRpZGF0ZShyZWZJbmZvKSB7XG4gICAgICAgIGNvbnN0IHNjb3BlID0gdGhpcy5zY29wZVByb3ZpZGVyLmdldFNjb3BlKHJlZkluZm8pO1xuICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHNjb3BlLmdldEVsZW1lbnQocmVmSW5mby5yZWZlcmVuY2UuJHJlZlRleHQpO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb24gIT09IG51bGwgJiYgZGVzY3JpcHRpb24gIT09IHZvaWQgMCA/IGRlc2NyaXB0aW9uIDogdGhpcy5jcmVhdGVMaW5raW5nRXJyb3IocmVmSW5mbyk7XG4gICAgfVxuICAgIGJ1aWxkUmVmZXJlbmNlKG5vZGUsIHByb3BlcnR5LCByZWZOb2RlLCByZWZUZXh0KSB7XG4gICAgICAgIC8vIFNlZSBiZWhhdmlvciBkZXNjcmlwdGlvbiBpbiBkb2Mgb2YgTGlua2VyLCB1cGRhdGUgdGhhdCBvbiBjaGFuZ2VzIGluIGhlcmUuXG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgICAgICBjb25zdCBsaW5rZXIgPSB0aGlzO1xuICAgICAgICBjb25zdCByZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICAkcmVmTm9kZTogcmVmTm9kZSxcbiAgICAgICAgICAgICRyZWZUZXh0OiByZWZUZXh0LFxuICAgICAgICAgICAgZ2V0IHJlZigpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZSh0aGlzLl9yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1vc3QgZnJlcXVlbnQgY2FzZTogdGhlIHRhcmdldCBpcyBhbHJlYWR5IHJlc29sdmVkLlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0FzdE5vZGVEZXNjcmlwdGlvbih0aGlzLl9ub2RlRGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEEgY2FuZGlkYXRlIGhhcyBiZWVuIGZvdW5kIGJlZm9yZSwgYnV0IGl0IGlzIG5vdCBsb2FkZWQgeWV0LlxuICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW5rZWROb2RlID0gbGlua2VyLmxvYWRBc3ROb2RlKHRoaXMuX25vZGVEZXNjcmlwdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZiA9IGxpbmtlZE5vZGUgIT09IG51bGwgJiYgbGlua2VkTm9kZSAhPT0gdm9pZCAwID8gbGlua2VkTm9kZSA6IGxpbmtlci5jcmVhdGVMaW5raW5nRXJyb3IoeyByZWZlcmVuY2UsIGNvbnRhaW5lcjogbm9kZSwgcHJvcGVydHkgfSwgdGhpcy5fbm9kZURlc2NyaXB0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcmVmID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHJlZmVyZW5jZSBoYXMgbm90IGJlZW4gbGlua2VkIHlldCwgc28gZG8gdGhhdCBub3cuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZiA9IHJlZl9yZXNvbHZpbmc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gZmluZFJvb3ROb2RlKG5vZGUpLiRkb2N1bWVudDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmRGF0YSA9IGxpbmtlci5nZXRMaW5rZWROb2RlKHsgcmVmZXJlbmNlLCBjb250YWluZXI6IG5vZGUsIHByb3BlcnR5IH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVmRGF0YS5lcnJvciAmJiBkb2N1bWVudCAmJiBkb2N1bWVudC5zdGF0ZSA8IERvY3VtZW50U3RhdGUuQ29tcHV0ZWRTY29wZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvY3VtZW50IHNjb3BlIGlzIG5vdCByZWFkeSwgZG9uJ3Qgc2V0IGB0aGlzLl9yZWZgIHNvIGxpbmtlciBjYW4gcmV0cnkgbGF0ZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVmID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3JlZiA9IChfYSA9IHJlZkRhdGEubm9kZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogcmVmRGF0YS5lcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbm9kZURlc2NyaXB0aW9uID0gcmVmRGF0YS5kZXNjcjtcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQgPT09IG51bGwgfHwgZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50LnJlZmVyZW5jZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcmVmID09PSByZWZfcmVzb2x2aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ3ljbGljIHJlZmVyZW5jZSByZXNvbHV0aW9uIGRldGVjdGVkOiAke2xpbmtlci5hc3ROb2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aChub2RlKX0vJHtwcm9wZXJ0eX0gKHN5bWJvbCAnJHtyZWZUZXh0fScpYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBpc0FzdE5vZGUodGhpcy5fcmVmKSA/IHRoaXMuX3JlZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgJG5vZGVEZXNjcmlwdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9kZURlc2NyaXB0aW9uO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBlcnJvcigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXNMaW5raW5nRXJyb3IodGhpcy5fcmVmKSA/IHRoaXMuX3JlZiA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHJlZmVyZW5jZTtcbiAgICB9XG4gICAgZ2V0TGlua2VkTm9kZShyZWZJbmZvKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gdGhpcy5nZXRDYW5kaWRhdGUocmVmSW5mbyk7XG4gICAgICAgICAgICBpZiAoaXNMaW5raW5nRXJyb3IoZGVzY3JpcHRpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZXJyb3I6IGRlc2NyaXB0aW9uIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsaW5rZWROb2RlID0gdGhpcy5sb2FkQXN0Tm9kZShkZXNjcmlwdGlvbik7XG4gICAgICAgICAgICBpZiAobGlua2VkTm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IG5vZGU6IGxpbmtlZE5vZGUsIGRlc2NyOiBkZXNjcmlwdGlvbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgZGVzY3I6IGRlc2NyaXB0aW9uLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogdGhpcy5jcmVhdGVMaW5raW5nRXJyb3IocmVmSW5mbywgZGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGBBbiBlcnJvciBvY2N1cnJlZCB3aGlsZSByZXNvbHZpbmcgcmVmZXJlbmNlIHRvICcke3JlZkluZm8ucmVmZXJlbmNlLiRyZWZUZXh0fSc6YCwgZXJyKTtcbiAgICAgICAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IChfYSA9IGVyci5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBTdHJpbmcoZXJyKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZXJyb3I6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVmSW5mbyksIHsgbWVzc2FnZTogYEFuIGVycm9yIG9jY3VycmVkIHdoaWxlIHJlc29sdmluZyByZWZlcmVuY2UgdG8gJyR7cmVmSW5mby5yZWZlcmVuY2UuJHJlZlRleHR9JzogJHtlcnJvck1lc3NhZ2V9YCB9KVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsb2FkQXN0Tm9kZShub2RlRGVzY3JpcHRpb24pIHtcbiAgICAgICAgaWYgKG5vZGVEZXNjcmlwdGlvbi5ub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gbm9kZURlc2NyaXB0aW9uLm5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9jID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzKCkuZ2V0RG9jdW1lbnQobm9kZURlc2NyaXB0aW9uLmRvY3VtZW50VXJpKTtcbiAgICAgICAgaWYgKCFkb2MpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZShkb2MucGFyc2VSZXN1bHQudmFsdWUsIG5vZGVEZXNjcmlwdGlvbi5wYXRoKTtcbiAgICB9XG4gICAgY3JlYXRlTGlua2luZ0Vycm9yKHJlZkluZm8sIHRhcmdldERlc2NyaXB0aW9uKSB7XG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRvY3VtZW50IGlzIHN1ZmZpY2llbnRseSBwcm9jZXNzZWQgYnkgdGhlIERvY3VtZW50QnVpbGRlci4gSWYgbm90LCB0aGlzIGlzIGEgaGludCBmb3IgYSBidWdcbiAgICAgICAgLy8gaW4gdGhlIGxhbmd1YWdlIGltcGxlbWVudGF0aW9uLlxuICAgICAgICBjb25zdCBkb2N1bWVudCA9IGZpbmRSb290Tm9kZShyZWZJbmZvLmNvbnRhaW5lcikuJGRvY3VtZW50O1xuICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuc3RhdGUgPCBEb2N1bWVudFN0YXRlLkNvbXB1dGVkU2NvcGVzKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEF0dGVtcHRlZCByZWZlcmVuY2UgcmVzb2x1dGlvbiBiZWZvcmUgZG9jdW1lbnQgcmVhY2hlZCBDb21wdXRlZFNjb3BlcyBzdGF0ZSAoJHtkb2N1bWVudC51cml9KS5gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gdGhpcy5yZWZsZWN0aW9uLmdldFJlZmVyZW5jZVR5cGUocmVmSW5mbyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlZkluZm8pLCB7IG1lc3NhZ2U6IGBDb3VsZCBub3QgcmVzb2x2ZSByZWZlcmVuY2UgdG8gJHtyZWZlcmVuY2VUeXBlfSBuYW1lZCAnJHtyZWZJbmZvLnJlZmVyZW5jZS4kcmVmVGV4dH0nLmAsIHRhcmdldERlc2NyaXB0aW9uIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxpbmtlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBmaW5kTm9kZUZvclByb3BlcnR5IH0gZnJvbSAnLi4vdXRpbHMvZ3JhbW1hci11dGlscy5qcyc7XG5leHBvcnQgZnVuY3Rpb24gaXNOYW1lZChub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlLm5hbWUgPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0IGNsYXNzIERlZmF1bHROYW1lUHJvdmlkZXIge1xuICAgIGdldE5hbWUobm9kZSkge1xuICAgICAgICBpZiAoaXNOYW1lZChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vZGUubmFtZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXROYW1lTm9kZShub2RlKSB7XG4gICAgICAgIHJldHVybiBmaW5kTm9kZUZvclByb3BlcnR5KG5vZGUuJGNzdE5vZGUsICduYW1lJyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bmFtZS1wcm92aWRlci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBmaW5kQXNzaWdubWVudCB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgaXNSZWZlcmVuY2UgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudCB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpc0NoaWxkTm9kZSwgdG9Eb2N1bWVudFNlZ21lbnQgfSBmcm9tICcuLi91dGlscy9jc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtIH0gZnJvbSAnLi4vdXRpbHMvc3RyZWFtLmpzJztcbmltcG9ydCB7IFVyaVV0aWxzIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0UmVmZXJlbmNlcyB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5uYW1lUHJvdmlkZXIgPSBzZXJ2aWNlcy5yZWZlcmVuY2VzLk5hbWVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5pbmRleCA9IHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuSW5kZXhNYW5hZ2VyO1xuICAgICAgICB0aGlzLm5vZGVMb2NhdG9yID0gc2VydmljZXMud29ya3NwYWNlLkFzdE5vZGVMb2NhdG9yO1xuICAgIH1cbiAgICBmaW5kRGVjbGFyYXRpb24oc291cmNlQ3N0Tm9kZSkge1xuICAgICAgICBpZiAoc291cmNlQ3N0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgYXNzaWdubWVudCA9IGZpbmRBc3NpZ25tZW50KHNvdXJjZUNzdE5vZGUpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZUVsZW0gPSBzb3VyY2VDc3ROb2RlLmFzdE5vZGU7XG4gICAgICAgICAgICBpZiAoYXNzaWdubWVudCAmJiBub2RlRWxlbSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlZmVyZW5jZSA9IG5vZGVFbGVtW2Fzc2lnbm1lbnQuZmVhdHVyZV07XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmZXJlbmNlKHJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZmVyZW5jZS5yZWY7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHJlZiBvZiByZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc1JlZmVyZW5jZShyZWYpICYmIHJlZi4kcmVmTm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICYmIHJlZi4kcmVmTm9kZS5vZmZzZXQgPD0gc291cmNlQ3N0Tm9kZS5vZmZzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAmJiByZWYuJHJlZk5vZGUuZW5kID49IHNvdXJjZUNzdE5vZGUuZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlZi5yZWY7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm9kZUVsZW0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lTm9kZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKG5vZGVFbGVtKTtcbiAgICAgICAgICAgICAgICAvLyBPbmx5IHJldHVybiB0aGUgdGFyZ2V0ZWQgbm9kZSBpbiBjYXNlIHRoZSB0YXJnZXRlZCBjc3Qgbm9kZSBpcyB0aGUgbmFtZSBub2RlIG9yIHBhcnQgb2YgaXRcbiAgICAgICAgICAgICAgICBpZiAobmFtZU5vZGUgJiYgKG5hbWVOb2RlID09PSBzb3VyY2VDc3ROb2RlIHx8IGlzQ2hpbGROb2RlKHNvdXJjZUNzdE5vZGUsIG5hbWVOb2RlKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVFbGVtO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kRGVjbGFyYXRpb25Ob2RlKHNvdXJjZUNzdE5vZGUpIHtcbiAgICAgICAgY29uc3QgYXN0Tm9kZSA9IHRoaXMuZmluZERlY2xhcmF0aW9uKHNvdXJjZUNzdE5vZGUpO1xuICAgICAgICBpZiAoYXN0Tm9kZSA9PT0gbnVsbCB8fCBhc3ROb2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhc3ROb2RlLiRjc3ROb2RlKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXROb2RlID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZU5vZGUoYXN0Tm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0Tm9kZSAhPT0gbnVsbCAmJiB0YXJnZXROb2RlICE9PSB2b2lkIDAgPyB0YXJnZXROb2RlIDogYXN0Tm9kZS4kY3N0Tm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBmaW5kUmVmZXJlbmNlcyh0YXJnZXROb2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZURlY2xhcmF0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmdldFJlZmVyZW5jZVRvU2VsZih0YXJnZXROb2RlKTtcbiAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICByZWZzLnB1c2gocmVmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXhSZWZlcmVuY2VzID0gdGhpcy5pbmRleC5maW5kQWxsUmVmZXJlbmNlcyh0YXJnZXROb2RlLCB0aGlzLm5vZGVMb2NhdG9yLmdldEFzdE5vZGVQYXRoKHRhcmdldE5vZGUpKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuZG9jdW1lbnRVcmkpIHtcbiAgICAgICAgICAgIGluZGV4UmVmZXJlbmNlcyA9IGluZGV4UmVmZXJlbmNlcy5maWx0ZXIocmVmID0+IFVyaVV0aWxzLmVxdWFscyhyZWYuc291cmNlVXJpLCBvcHRpb25zLmRvY3VtZW50VXJpKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVmcy5wdXNoKC4uLmluZGV4UmVmZXJlbmNlcyk7XG4gICAgICAgIHJldHVybiBzdHJlYW0ocmVmcyk7XG4gICAgfVxuICAgIGdldFJlZmVyZW5jZVRvU2VsZih0YXJnZXROb2RlKSB7XG4gICAgICAgIGNvbnN0IG5hbWVOb2RlID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZU5vZGUodGFyZ2V0Tm9kZSk7XG4gICAgICAgIGlmIChuYW1lTm9kZSkge1xuICAgICAgICAgICAgY29uc3QgZG9jID0gZ2V0RG9jdW1lbnQodGFyZ2V0Tm9kZSk7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gdGhpcy5ub2RlTG9jYXRvci5nZXRBc3ROb2RlUGF0aCh0YXJnZXROb2RlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc291cmNlVXJpOiBkb2MudXJpLFxuICAgICAgICAgICAgICAgIHNvdXJjZVBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgdGFyZ2V0VXJpOiBkb2MudXJpLFxuICAgICAgICAgICAgICAgIHRhcmdldFBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgc2VnbWVudDogdG9Eb2N1bWVudFNlZ21lbnQobmFtZU5vZGUpLFxuICAgICAgICAgICAgICAgIGxvY2FsOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVmZXJlbmNlcy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMS0yMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IHN0cmVhbUFsbENvbnRlbnRzLCBzdHJlYW1Db250ZW50cyB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBNdWx0aU1hcCB9IGZyb20gJy4uL3V0aWxzL2NvbGxlY3Rpb25zLmpzJztcbmltcG9ydCB7IGludGVycnVwdEFuZENoZWNrIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG4vKipcbiAqIFRoZSBkZWZhdWx0IHNjb3BlIGNvbXB1dGF0aW9uIGNyZWF0ZXMgYW5kIGNvbGxlY3RlcyBkZXNjcmlwdGlvbnMgb2YgdGhlIEFTVCBub2RlcyB0byBiZSBleHBvcnRlZCBpbnRvIHRoZVxuICogX2dsb2JhbF8gc2NvcGUgZnJvbSB0aGUgZ2l2ZW4gZG9jdW1lbnQuIEJ5IGRlZmF1bHQgdGhvc2UgYXJlIHRoZSBkb2N1bWVudCdzIHJvb3QgQVNUIG5vZGUgYW5kIGl0cyBkaXJlY3RseVxuICogY29udGFpbmVkIGNoaWxkIG5vZGVzLlxuICpcbiAqIEJlc2lkZXMsIGl0IGdhdGhlcnMgYWxsIEFTVCBub2RlcyB0aGF0IGhhdmUgYSBuYW1lIChhY2NvcmRpbmcgdG8gdGhlIGBOYW1lUHJvdmlkZXJgIHNlcnZpY2UpIGFuZCBpbmNsdWRlcyB0aGVtXG4gKiBpbiB0aGUgbG9jYWwgc2NvcGUgb2YgdGhlaXIgcGFydGljdWxhciBjb250YWluZXIgbm9kZXMuIEFzIGEgcmVzdWx0LCBmb3IgZXZlcnkgY3Jvc3MtcmVmZXJlbmNlIGluIHRoZSBBU1QsXG4gKiB0YXJnZXQgZWxlbWVudHMgZnJvbSB0aGUgc2FtZSBsZXZlbCAoc2libGluZ3MpIGFuZCBmdXJ0aGVyIHVwIHRvd2FyZHMgdGhlIHJvb3QgKHBhcmVudHMgYW5kIHNpYmxpbmdzIG9mIHBhcmVudHMpXG4gKiBhcmUgdmlzaWJsZS4gRWxlbWVudHMgYmVpbmcgbmVzdGVkIGluc2lkZSBsb3dlciBsZXZlbHMgKGNoaWxkcmVuLCBjaGlsZHJlbiBvZiBzaWJsaW5ncyBhbmQgcGFyZW50cycgc2libGluZ3MpXG4gKiBhcmUgX2ludmlzaWJsZV8gYnkgZGVmYXVsdCwgYnV0IHRoYXQgY2FuIGJlIGNoYW5nZWQgYnkgY3VzdG9taXppbmcgdGhpcyBzZXJ2aWNlLlxuICovXG5leHBvcnQgY2xhc3MgRGVmYXVsdFNjb3BlQ29tcHV0YXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb25zID0gc2VydmljZXMud29ya3NwYWNlLkFzdE5vZGVEZXNjcmlwdGlvblByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3luYyBjb21wdXRlRXhwb3J0cyhkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXB1dGVFeHBvcnRzRm9yTm9kZShkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZSwgZG9jdW1lbnQsIHVuZGVmaW5lZCwgY2FuY2VsVG9rZW4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIHtAbGluayBBc3ROb2RlRGVzY3JpcHRpb24gQXN0Tm9kZURlc2NyaXB0aW9uc30gZm9yIHRoZSBnaXZlbiB7QGxpbmsgQXN0Tm9kZSBwYXJlbnROb2RlfSBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIFRoZSBsaXN0IG9mIGNoaWxkcmVuIHRvIGJlIGNvbnNpZGVyZWQgaXMgZGV0ZXJtaW5lZCBieSB0aGUgZnVuY3Rpb24gcGFyYW1ldGVyIHtAbGluayBjaGlsZHJlbn0uXG4gICAgICogQnkgZGVmYXVsdCBvbmx5IHRoZSBkaXJlY3QgY2hpbGRyZW4gb2Yge0BsaW5rIHBhcmVudE5vZGV9IGFyZSB2aXNpdGVkLCBuZXN0ZWQgbm9kZXMgYXJlIG5vdCBleHBvcnRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJlbnROb2RlIEFTVCBub2RlIHRvIGJlIGV4cG9ydGVkLCBpLmUuLCBvZiB3aGljaCBhbiB7QGxpbmsgQXN0Tm9kZURlc2NyaXB0aW9ufSBzaGFsbCBiZSBhZGRlZCB0byB0aGUgcmV0dXJuZWQgbGlzdC5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnQgVGhlIGRvY3VtZW50IGNvbnRhaW5pbmcgdGhlIEFTVCBub2RlIHRvIGJlIGV4cG9ydGVkLlxuICAgICAqIEBwYXJhbSBjaGlsZHJlbiBBIGZ1bmN0aW9uIGNhbGxlZCB3aXRoIHtAbGluayBwYXJlbnROb2RlfSBhcyBzaW5nbGUgYXJndW1lbnQgYW5kIHJldHVybmluZyBhbiB7QGxpbmsgSXRlcmFibGV9IHN1cHBseWluZyB0aGUgY2hpbGRyZW4gdG8gYmUgdmlzaXRlZCwgd2hpY2ggbXVzdCBiZSBkaXJlY3RseSBvciB0cmFuc2l0aXZlbHkgY29udGFpbmVkIGluIHtAbGluayBwYXJlbnROb2RlfS5cbiAgICAgKiBAcGFyYW0gY2FuY2VsVG9rZW4gSW5kaWNhdGVzIHdoZW4gdG8gY2FuY2VsIHRoZSBjdXJyZW50IG9wZXJhdGlvbi5cbiAgICAgKiBAdGhyb3dzIGBPcGVyYXRpb25DYW5jZWxsZWRgIGlmIGEgdXNlciBhY3Rpb24gb2NjdXJzIGR1cmluZyBleGVjdXRpb24uXG4gICAgICogQHJldHVybnMgQSBsaXN0IG9mIHtAbGluayBBc3ROb2RlRGVzY3JpcHRpb24gQXN0Tm9kZURlc2NyaXB0aW9uc30gdG8gYmUgcHVibGlzaGVkIHRvIGluZGV4LlxuICAgICAqL1xuICAgIGFzeW5jIGNvbXB1dGVFeHBvcnRzRm9yTm9kZShwYXJlbnROb2RlLCBkb2N1bWVudCwgY2hpbGRyZW4gPSBzdHJlYW1Db250ZW50cywgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGV4cG9ydHMgPSBbXTtcbiAgICAgICAgdGhpcy5leHBvcnROb2RlKHBhcmVudE5vZGUsIGV4cG9ydHMsIGRvY3VtZW50KTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIGNoaWxkcmVuKHBhcmVudE5vZGUpKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICB0aGlzLmV4cG9ydE5vZGUobm9kZSwgZXhwb3J0cywgZG9jdW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleHBvcnRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzaW5nbGUgbm9kZSB0byB0aGUgbGlzdCBvZiBleHBvcnRzIGlmIGl0IGhhcyBhIG5hbWUuIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGNoYW5nZSBob3dcbiAgICAgKiBzeW1ib2xzIGFyZSBleHBvcnRlZCwgZS5nLiBieSBtb2RpZnlpbmcgdGhlaXIgZXhwb3J0ZWQgbmFtZS5cbiAgICAgKi9cbiAgICBleHBvcnROb2RlKG5vZGUsIGV4cG9ydHMsIGRvY3VtZW50KSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKG5vZGUpO1xuICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgZXhwb3J0cy5wdXNoKHRoaXMuZGVzY3JpcHRpb25zLmNyZWF0ZURlc2NyaXB0aW9uKG5vZGUsIG5hbWUsIGRvY3VtZW50KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgY29tcHV0ZUxvY2FsU2NvcGVzKGRvY3VtZW50LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgY29uc3Qgcm9vdE5vZGUgPSBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gbmV3IE11bHRpTWFwKCk7XG4gICAgICAgIC8vIEhlcmUgd2UgbmF2aWdhdGUgdGhlIGZ1bGwgQVNUIC0gbG9jYWwgc2NvcGVzIHNoYWxsIGJlIGF2YWlsYWJsZSBpbiB0aGUgd2hvbGUgZG9jdW1lbnRcbiAgICAgICAgZm9yIChjb25zdCBub2RlIG9mIHN0cmVhbUFsbENvbnRlbnRzKHJvb3ROb2RlKSkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTm9kZShub2RlLCBkb2N1bWVudCwgc2NvcGVzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzIGEgc2luZ2xlIG5vZGUgZHVyaW5nIHNjb3BlcyBjb21wdXRhdGlvbi4gVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gbWFrZXMgdGhlIG5vZGUgdmlzaWJsZVxuICAgICAqIGluIHRoZSBzdWJ0cmVlIG9mIGl0cyBjb250YWluZXIgKGlmIHRoZSBub2RlIGhhcyBhIG5hbWUpLiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBjaGFuZ2UgdGhpcyxcbiAgICAgKiBlLmcuIGJ5IGluY3JlYXNpbmcgdGhlIHZpc2liaWxpdHkgdG8gYSBoaWdoZXIgbGV2ZWwgaW4gdGhlIEFTVC5cbiAgICAgKi9cbiAgICBwcm9jZXNzTm9kZShub2RlLCBkb2N1bWVudCwgc2NvcGVzKSB7XG4gICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG5vZGUuJGNvbnRhaW5lcjtcbiAgICAgICAgaWYgKGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWUobm9kZSk7XG4gICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgIHNjb3Blcy5hZGQoY29udGFpbmVyLCB0aGlzLmRlc2NyaXB0aW9ucy5jcmVhdGVEZXNjcmlwdGlvbihub2RlLCBuYW1lLCBkb2N1bWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUtY29tcHV0YXRpb24uanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBNYXBTY29wZSwgU3RyZWFtU2NvcGUgfSBmcm9tICcuL3Njb3BlLmpzJztcbmltcG9ydCB7IGdldERvY3VtZW50IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBXb3Jrc3BhY2VDYWNoZSB9IGZyb20gJy4uL3V0aWxzL2NhY2hpbmcuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRTY29wZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLnJlZmxlY3Rpb24gPSBzZXJ2aWNlcy5zaGFyZWQuQXN0UmVmbGVjdGlvbjtcbiAgICAgICAgdGhpcy5uYW1lUHJvdmlkZXIgPSBzZXJ2aWNlcy5yZWZlcmVuY2VzLk5hbWVQcm92aWRlcjtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbnMgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZURlc2NyaXB0aW9uUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gc2VydmljZXMuc2hhcmVkLndvcmtzcGFjZS5JbmRleE1hbmFnZXI7XG4gICAgICAgIHRoaXMuZ2xvYmFsU2NvcGVDYWNoZSA9IG5ldyBXb3Jrc3BhY2VDYWNoZShzZXJ2aWNlcy5zaGFyZWQpO1xuICAgIH1cbiAgICBnZXRTY29wZShjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNjb3BlcyA9IFtdO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VUeXBlID0gdGhpcy5yZWZsZWN0aW9uLmdldFJlZmVyZW5jZVR5cGUoY29udGV4dCk7XG4gICAgICAgIGNvbnN0IHByZWNvbXB1dGVkID0gZ2V0RG9jdW1lbnQoY29udGV4dC5jb250YWluZXIpLnByZWNvbXB1dGVkU2NvcGVzO1xuICAgICAgICBpZiAocHJlY29tcHV0ZWQpIHtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Tm9kZSA9IGNvbnRleHQuY29udGFpbmVyO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbERlc2NyaXB0aW9ucyA9IHByZWNvbXB1dGVkLmdldChjdXJyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbERlc2NyaXB0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNjb3Blcy5wdXNoKHN0cmVhbShhbGxEZXNjcmlwdGlvbnMpLmZpbHRlcihkZXNjID0+IHRoaXMucmVmbGVjdGlvbi5pc1N1YnR5cGUoZGVzYy50eXBlLCByZWZlcmVuY2VUeXBlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLiRjb250YWluZXI7XG4gICAgICAgICAgICB9IHdoaWxlIChjdXJyZW50Tm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuZ2V0R2xvYmFsU2NvcGUocmVmZXJlbmNlVHlwZSwgY29udGV4dCk7XG4gICAgICAgIGZvciAobGV0IGkgPSBzY29wZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRoaXMuY3JlYXRlU2NvcGUoc2NvcGVzW2ldLCByZXN1bHQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHNjb3BlIGZvciB0aGUgZ2l2ZW4gY29sbGVjdGlvbiBvZiBBU1Qgbm9kZSBkZXNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgY3JlYXRlU2NvcGUoZWxlbWVudHMsIG91dGVyU2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1TY29wZShzdHJlYW0oZWxlbWVudHMpLCBvdXRlclNjb3BlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgc2NvcGUgZm9yIHRoZSBnaXZlbiBjb2xsZWN0aW9uIG9mIEFTVCBub2Rlcywgd2hpY2ggbmVlZCB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHJlc3BlY3RpdmVcbiAgICAgKiBkZXNjcmlwdGlvbnMgZmlyc3QuIFRoaXMgaXMgZG9uZSB1c2luZyB0aGUgYE5hbWVQcm92aWRlcmAgYW5kIGBBc3ROb2RlRGVzY3JpcHRpb25Qcm92aWRlcmAgc2VydmljZXMuXG4gICAgICovXG4gICAgY3JlYXRlU2NvcGVGb3JOb2RlcyhlbGVtZW50cywgb3V0ZXJTY29wZSwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBzID0gc3RyZWFtKGVsZW1lbnRzKS5tYXAoZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lUHJvdmlkZXIuZ2V0TmFtZShlKTtcbiAgICAgICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb25zLmNyZWF0ZURlc2NyaXB0aW9uKGUsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfSkubm9uTnVsbGFibGUoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1TY29wZShzLCBvdXRlclNjb3BlLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZ2xvYmFsIHNjb3BlIGZpbHRlcmVkIGZvciB0aGUgZ2l2ZW4gcmVmZXJlbmNlIHR5cGUuXG4gICAgICovXG4gICAgZ2V0R2xvYmFsU2NvcGUocmVmZXJlbmNlVHlwZSwgX2NvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2xvYmFsU2NvcGVDYWNoZS5nZXQocmVmZXJlbmNlVHlwZSwgKCkgPT4gbmV3IE1hcFNjb3BlKHRoaXMuaW5kZXhNYW5hZ2VyLmFsbEVsZW1lbnRzKHJlZmVyZW5jZVR5cGUpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2NvcGUtcHJvdmlkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgRU1QVFlfU1RSRUFNLCBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBzY29wZSBpbXBsZW1lbnRhdGlvbiBpcyBiYXNlZCBvbiBhIGBTdHJlYW1gLiBJdCBoYXMgYW4gb3B0aW9uYWwgX291dGVyIHNjb3BlXyBkZXNjcmliaW5nXG4gKiB0aGUgbmV4dCBsZXZlbCBvZiBlbGVtZW50cywgd2hpY2ggYXJlIHF1ZXJpZWQgd2hlbiBhIHRhcmdldCBlbGVtZW50IGlzIG5vdCBmb3VuZCBpbiB0aGUgc3RyZWFtIHByb3ZpZGVkXG4gKiB0byB0aGlzIHNjb3BlLlxuICovXG5leHBvcnQgY2xhc3MgU3RyZWFtU2NvcGUge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnRzLCBvdXRlclNjb3BlLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdGhpcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgICB0aGlzLm91dGVyU2NvcGUgPSBvdXRlclNjb3BlO1xuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXNlSW5zZW5zaXRpdmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgIH1cbiAgICBnZXRBbGxFbGVtZW50cygpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0ZXJTY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZWxlbWVudHMuY29uY2F0KHRoaXMub3V0ZXJTY29wZS5nZXRBbGxFbGVtZW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEVsZW1lbnQobmFtZSkge1xuICAgICAgICBjb25zdCBsb2NhbCA9IHRoaXMuY2FzZUluc2Vuc2l0aXZlXG4gICAgICAgICAgICA/IHRoaXMuZWxlbWVudHMuZmluZChlID0+IGUubmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICAgICAgICA6IHRoaXMuZWxlbWVudHMuZmluZChlID0+IGUubmFtZSA9PT0gbmFtZSk7XG4gICAgICAgIGlmIChsb2NhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGxvY2FsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm91dGVyU2NvcGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm91dGVyU2NvcGUuZ2V0RWxlbWVudChuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBNYXBTY29wZSB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMsIG91dGVyU2NvcGUsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmVsZW1lbnRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5jYXNlSW5zZW5zaXRpdmUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmNhc2VJbnNlbnNpdGl2ZVxuICAgICAgICAgICAgICAgID8gZWxlbWVudC5uYW1lLnRvTG93ZXJDYXNlKClcbiAgICAgICAgICAgICAgICA6IGVsZW1lbnQubmFtZTtcbiAgICAgICAgICAgIHRoaXMuZWxlbWVudHMuc2V0KG5hbWUsIGVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3V0ZXJTY29wZSA9IG91dGVyU2NvcGU7XG4gICAgfVxuICAgIGdldEVsZW1lbnQobmFtZSkge1xuICAgICAgICBjb25zdCBsb2NhbE5hbWUgPSB0aGlzLmNhc2VJbnNlbnNpdGl2ZSA/IG5hbWUudG9Mb3dlckNhc2UoKSA6IG5hbWU7XG4gICAgICAgIGNvbnN0IGxvY2FsID0gdGhpcy5lbGVtZW50cy5nZXQobG9jYWxOYW1lKTtcbiAgICAgICAgaWYgKGxvY2FsKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9jYWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3V0ZXJTY29wZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJTY29wZS5nZXRFbGVtZW50KG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldEFsbEVsZW1lbnRzKCkge1xuICAgICAgICBsZXQgZWxlbWVudFN0cmVhbSA9IHN0cmVhbSh0aGlzLmVsZW1lbnRzLnZhbHVlcygpKTtcbiAgICAgICAgaWYgKHRoaXMub3V0ZXJTY29wZSkge1xuICAgICAgICAgICAgZWxlbWVudFN0cmVhbSA9IGVsZW1lbnRTdHJlYW0uY29uY2F0KHRoaXMub3V0ZXJTY29wZS5nZXRBbGxFbGVtZW50cygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudFN0cmVhbTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgRU1QVFlfU0NPUEUgPSB7XG4gICAgZ2V0RWxlbWVudCgpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGdldEFsbEVsZW1lbnRzKCkge1xuICAgICAgICByZXR1cm4gRU1QVFlfU1RSRUFNO1xuICAgIH1cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY29wZS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyNCBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDb21wb3NpdGVDc3ROb2RlSW1wbCwgTGVhZkNzdE5vZGVJbXBsLCBSb290Q3N0Tm9kZUltcGwgfSBmcm9tICcuLi9wYXJzZXIvY3N0LW5vZGUtYnVpbGRlci5qcyc7XG5pbXBvcnQgeyBpc0Fic3RyYWN0RWxlbWVudCB9IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IGlzUm9vdENzdE5vZGUsIGlzQ29tcG9zaXRlQ3N0Tm9kZSwgaXNMZWFmQ3N0Tm9kZSwgaXNBc3ROb2RlLCBpc1JlZmVyZW5jZSB9IGZyb20gJy4uL3N5bnRheC10cmVlLmpzJztcbmltcG9ydCB7IHN0cmVhbUFzdCB9IGZyb20gJy4uL3V0aWxzL2FzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBCaU1hcCB9IGZyb20gJy4uL3V0aWxzL2NvbGxlY3Rpb25zLmpzJztcbmltcG9ydCB7IHN0cmVhbUNzdCB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdEh5ZHJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAgPSBuZXcgQmlNYXAoKTtcbiAgICAgICAgdGhpcy50b2tlblR5cGVJZE1hcCA9IG5ldyBCaU1hcCgpO1xuICAgICAgICB0aGlzLmdyYW1tYXIgPSBzZXJ2aWNlcy5HcmFtbWFyO1xuICAgICAgICB0aGlzLmxleGVyID0gc2VydmljZXMucGFyc2VyLkxleGVyO1xuICAgICAgICB0aGlzLmxpbmtlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgIH1cbiAgICBkZWh5ZHJhdGUocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZXhlckVycm9yczogcmVzdWx0LmxleGVyRXJyb3JzLFxuICAgICAgICAgICAgbGV4ZXJSZXBvcnQ6IHJlc3VsdC5sZXhlclJlcG9ydCA/IHRoaXMuZGVoeWRyYXRlTGV4ZXJSZXBvcnQocmVzdWx0LmxleGVyUmVwb3J0KSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY3JlYXRlIHNoYWxsb3cgY29waWVzIG9mIHRoZSBlcnJvcnNcbiAgICAgICAgICAgIC8vIFRoZSBvcmlnaW5hbCBlcnJvcnMgaW5oZXJpdCBmcm9tIHRoZSBgRXJyb3JgIGNsYXNzLCB3aGljaCBpcyBub3QgdHJhbnNmZXJhYmxlIGFjcm9zcyB3b3JrZXIgdGhyZWFkc1xuICAgICAgICAgICAgcGFyc2VyRXJyb3JzOiByZXN1bHQucGFyc2VyRXJyb3JzLm1hcChlID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGUpLCB7IG1lc3NhZ2U6IGUubWVzc2FnZSB9KSkpLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuZGVoeWRyYXRlQXN0Tm9kZShyZXN1bHQudmFsdWUsIHRoaXMuY3JlYXRlRGVoeXJhdGlvbkNvbnRleHQocmVzdWx0LnZhbHVlKSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZGVoeWRyYXRlTGV4ZXJSZXBvcnQobGV4ZXJSZXBvcnQpIHtcbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgbGV4ZXIgcmVwb3J0cyBhcmUgc2VyaWFsaXphYmxlXG4gICAgICAgIHJldHVybiBsZXhlclJlcG9ydDtcbiAgICB9XG4gICAgY3JlYXRlRGVoeXJhdGlvbkNvbnRleHQobm9kZSkge1xuICAgICAgICBjb25zdCBhc3ROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgY3N0Tm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGZvciAoY29uc3QgYXN0Tm9kZSBvZiBzdHJlYW1Bc3Qobm9kZSkpIHtcbiAgICAgICAgICAgIGFzdE5vZGVzLnNldChhc3ROb2RlLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUuJGNzdE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3N0Tm9kZSBvZiBzdHJlYW1Dc3Qobm9kZS4kY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjc3ROb2Rlcy5zZXQoY3N0Tm9kZSwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhc3ROb2RlcyxcbiAgICAgICAgICAgIGNzdE5vZGVzXG4gICAgICAgIH07XG4gICAgfVxuICAgIGRlaHlkcmF0ZUFzdE5vZGUobm9kZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBvYmogPSBjb250ZXh0LmFzdE5vZGVzLmdldChub2RlKTtcbiAgICAgICAgb2JqLiR0eXBlID0gbm9kZS4kdHlwZTtcbiAgICAgICAgb2JqLiRjb250YWluZXJJbmRleCA9IG5vZGUuJGNvbnRhaW5lckluZGV4O1xuICAgICAgICBvYmouJGNvbnRhaW5lclByb3BlcnR5ID0gbm9kZS4kY29udGFpbmVyUHJvcGVydHk7XG4gICAgICAgIGlmIChub2RlLiRjc3ROb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9iai4kY3N0Tm9kZSA9IHRoaXMuZGVoeWRyYXRlQ3N0Tm9kZShub2RlLiRjc3ROb2RlLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IFtuYW1lLCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobm9kZSkpIHtcbiAgICAgICAgICAgIGlmIChuYW1lLnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJyID0gW107XG4gICAgICAgICAgICAgICAgb2JqW25hbWVdID0gYXJyO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLmRlaHlkcmF0ZUFzdE5vZGUoaXRlbSwgY29udGV4dCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLmRlaHlkcmF0ZVJlZmVyZW5jZShpdGVtLCBjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvYmpbbmFtZV0gPSB0aGlzLmRlaHlkcmF0ZUFzdE5vZGUodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb2JqW25hbWVdID0gdGhpcy5kZWh5ZHJhdGVSZWZlcmVuY2UodmFsdWUsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIG9ialtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIGRlaHlkcmF0ZVJlZmVyZW5jZShyZWZlcmVuY2UsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgb2JqID0ge307XG4gICAgICAgIG9iai4kcmVmVGV4dCA9IHJlZmVyZW5jZS4kcmVmVGV4dDtcbiAgICAgICAgaWYgKHJlZmVyZW5jZS4kcmVmTm9kZSkge1xuICAgICAgICAgICAgb2JqLiRyZWZOb2RlID0gY29udGV4dC5jc3ROb2Rlcy5nZXQocmVmZXJlbmNlLiRyZWZOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cbiAgICBkZWh5ZHJhdGVDc3ROb2RlKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgY3N0Tm9kZSA9IGNvbnRleHQuY3N0Tm9kZXMuZ2V0KG5vZGUpO1xuICAgICAgICBpZiAoaXNSb290Q3N0Tm9kZShub2RlKSkge1xuICAgICAgICAgICAgY3N0Tm9kZS5mdWxsVGV4dCA9IG5vZGUuZnVsbFRleHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBOb3RlOiBUaGlzIHJldHVybnMgdW5kZWZpbmVkIGZvciBoaWRkZW4gbm9kZXMgKGkuZS4gY29tbWVudHMpXG4gICAgICAgICAgICBjc3ROb2RlLmdyYW1tYXJTb3VyY2UgPSB0aGlzLmdldEdyYW1tYXJFbGVtZW50SWQobm9kZS5ncmFtbWFyU291cmNlKTtcbiAgICAgICAgfVxuICAgICAgICBjc3ROb2RlLmhpZGRlbiA9IG5vZGUuaGlkZGVuO1xuICAgICAgICBjc3ROb2RlLmFzdE5vZGUgPSBjb250ZXh0LmFzdE5vZGVzLmdldChub2RlLmFzdE5vZGUpO1xuICAgICAgICBpZiAoaXNDb21wb3NpdGVDc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgICAgICBjc3ROb2RlLmNvbnRlbnQgPSBub2RlLmNvbnRlbnQubWFwKGNoaWxkID0+IHRoaXMuZGVoeWRyYXRlQ3N0Tm9kZShjaGlsZCwgY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTGVhZkNzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgICAgIGNzdE5vZGUudG9rZW5UeXBlID0gbm9kZS50b2tlblR5cGUubmFtZTtcbiAgICAgICAgICAgIGNzdE5vZGUub2Zmc2V0ID0gbm9kZS5vZmZzZXQ7XG4gICAgICAgICAgICBjc3ROb2RlLmxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuICAgICAgICAgICAgY3N0Tm9kZS5zdGFydExpbmUgPSBub2RlLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBjc3ROb2RlLnN0YXJ0Q29sdW1uID0gbm9kZS5yYW5nZS5zdGFydC5jaGFyYWN0ZXI7XG4gICAgICAgICAgICBjc3ROb2RlLmVuZExpbmUgPSBub2RlLnJhbmdlLmVuZC5saW5lO1xuICAgICAgICAgICAgY3N0Tm9kZS5lbmRDb2x1bW4gPSBub2RlLnJhbmdlLmVuZC5jaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzdE5vZGU7XG4gICAgfVxuICAgIGh5ZHJhdGUocmVzdWx0KSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLmNyZWF0ZUh5ZHJhdGlvbkNvbnRleHQobm9kZSk7XG4gICAgICAgIGlmICgnJGNzdE5vZGUnIGluIG5vZGUpIHtcbiAgICAgICAgICAgIHRoaXMuaHlkcmF0ZUNzdE5vZGUobm9kZS4kY3N0Tm9kZSwgY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxleGVyRXJyb3JzOiByZXN1bHQubGV4ZXJFcnJvcnMsXG4gICAgICAgICAgICBsZXhlclJlcG9ydDogcmVzdWx0LmxleGVyUmVwb3J0LFxuICAgICAgICAgICAgcGFyc2VyRXJyb3JzOiByZXN1bHQucGFyc2VyRXJyb3JzLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMuaHlkcmF0ZUFzdE5vZGUobm9kZSwgY29udGV4dClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY3JlYXRlSHlkcmF0aW9uQ29udGV4dChub2RlKSB7XG4gICAgICAgIGNvbnN0IGFzdE5vZGVzID0gbmV3IE1hcCgpO1xuICAgICAgICBjb25zdCBjc3ROb2RlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgZm9yIChjb25zdCBhc3ROb2RlIG9mIHN0cmVhbUFzdChub2RlKSkge1xuICAgICAgICAgICAgYXN0Tm9kZXMuc2V0KGFzdE5vZGUsIHt9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcm9vdDtcbiAgICAgICAgaWYgKG5vZGUuJGNzdE5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY3N0Tm9kZSBvZiBzdHJlYW1Dc3Qobm9kZS4kY3N0Tm9kZSkpIHtcbiAgICAgICAgICAgICAgICBsZXQgY3N0O1xuICAgICAgICAgICAgICAgIGlmICgnZnVsbFRleHQnIGluIGNzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0ID0gbmV3IFJvb3RDc3ROb2RlSW1wbChjc3ROb2RlLmZ1bGxUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgcm9vdCA9IGNzdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoJ2NvbnRlbnQnIGluIGNzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0ID0gbmV3IENvbXBvc2l0ZUNzdE5vZGVJbXBsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCd0b2tlblR5cGUnIGluIGNzdE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0ID0gdGhpcy5oeWRyYXRlQ3N0TGVhZk5vZGUoY3N0Tm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY3N0Tm9kZXMuc2V0KGNzdE5vZGUsIGNzdCk7XG4gICAgICAgICAgICAgICAgICAgIGNzdC5yb290ID0gcm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFzdE5vZGVzLFxuICAgICAgICAgICAgY3N0Tm9kZXNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaHlkcmF0ZUFzdE5vZGUobm9kZSwgY29udGV4dCkge1xuICAgICAgICBjb25zdCBhc3ROb2RlID0gY29udGV4dC5hc3ROb2Rlcy5nZXQobm9kZSk7XG4gICAgICAgIGFzdE5vZGUuJHR5cGUgPSBub2RlLiR0eXBlO1xuICAgICAgICBhc3ROb2RlLiRjb250YWluZXJJbmRleCA9IG5vZGUuJGNvbnRhaW5lckluZGV4O1xuICAgICAgICBhc3ROb2RlLiRjb250YWluZXJQcm9wZXJ0eSA9IG5vZGUuJGNvbnRhaW5lclByb3BlcnR5O1xuICAgICAgICBpZiAobm9kZS4kY3N0Tm9kZSkge1xuICAgICAgICAgICAgYXN0Tm9kZS4kY3N0Tm9kZSA9IGNvbnRleHQuY3N0Tm9kZXMuZ2V0KG5vZGUuJGNzdE5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnIgPSBbXTtcbiAgICAgICAgICAgICAgICBhc3ROb2RlW25hbWVdID0gYXJyO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaCh0aGlzLnNldFBhcmVudCh0aGlzLmh5ZHJhdGVBc3ROb2RlKGl0ZW0sIGNvbnRleHQpLCBhc3ROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UoaXRlbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyci5wdXNoKHRoaXMuaHlkcmF0ZVJlZmVyZW5jZShpdGVtLCBhc3ROb2RlLCBuYW1lLCBjb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnIucHVzaChpdGVtKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBhc3ROb2RlW25hbWVdID0gdGhpcy5zZXRQYXJlbnQodGhpcy5oeWRyYXRlQXN0Tm9kZSh2YWx1ZSwgY29udGV4dCksIGFzdE5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZVtuYW1lXSA9IHRoaXMuaHlkcmF0ZVJlZmVyZW5jZSh2YWx1ZSwgYXN0Tm9kZSwgbmFtZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhc3ROb2RlO1xuICAgIH1cbiAgICBzZXRQYXJlbnQobm9kZSwgcGFyZW50KSB7XG4gICAgICAgIG5vZGUuJGNvbnRhaW5lciA9IHBhcmVudDtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGh5ZHJhdGVSZWZlcmVuY2UocmVmZXJlbmNlLCBub2RlLCBuYW1lLCBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxpbmtlci5idWlsZFJlZmVyZW5jZShub2RlLCBuYW1lLCBjb250ZXh0LmNzdE5vZGVzLmdldChyZWZlcmVuY2UuJHJlZk5vZGUpLCByZWZlcmVuY2UuJHJlZlRleHQpO1xuICAgIH1cbiAgICBoeWRyYXRlQ3N0Tm9kZShjc3ROb2RlLCBjb250ZXh0LCBudW0gPSAwKSB7XG4gICAgICAgIGNvbnN0IGNzdE5vZGVPYmogPSBjb250ZXh0LmNzdE5vZGVzLmdldChjc3ROb2RlKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjc3ROb2RlLmdyYW1tYXJTb3VyY2UgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICBjc3ROb2RlT2JqLmdyYW1tYXJTb3VyY2UgPSB0aGlzLmdldEdyYW1tYXJFbGVtZW50KGNzdE5vZGUuZ3JhbW1hclNvdXJjZSk7XG4gICAgICAgIH1cbiAgICAgICAgY3N0Tm9kZU9iai5hc3ROb2RlID0gY29udGV4dC5hc3ROb2Rlcy5nZXQoY3N0Tm9kZS5hc3ROb2RlKTtcbiAgICAgICAgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShjc3ROb2RlT2JqKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjc3ROb2RlLmNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoeWRyYXRlZCA9IHRoaXMuaHlkcmF0ZUNzdE5vZGUoY2hpbGQsIGNvbnRleHQsIG51bSsrKTtcbiAgICAgICAgICAgICAgICBjc3ROb2RlT2JqLmNvbnRlbnQucHVzaChoeWRyYXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNzdE5vZGVPYmo7XG4gICAgfVxuICAgIGh5ZHJhdGVDc3RMZWFmTm9kZShjc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHRva2VuVHlwZSA9IHRoaXMuZ2V0VG9rZW5UeXBlKGNzdE5vZGUudG9rZW5UeXBlKTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gY3N0Tm9kZS5vZmZzZXQ7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGNzdE5vZGUubGVuZ3RoO1xuICAgICAgICBjb25zdCBzdGFydExpbmUgPSBjc3ROb2RlLnN0YXJ0TGluZTtcbiAgICAgICAgY29uc3Qgc3RhcnRDb2x1bW4gPSBjc3ROb2RlLnN0YXJ0Q29sdW1uO1xuICAgICAgICBjb25zdCBlbmRMaW5lID0gY3N0Tm9kZS5lbmRMaW5lO1xuICAgICAgICBjb25zdCBlbmRDb2x1bW4gPSBjc3ROb2RlLmVuZENvbHVtbjtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gY3N0Tm9kZS5oaWRkZW47XG4gICAgICAgIGNvbnN0IG5vZGUgPSBuZXcgTGVhZkNzdE5vZGVJbXBsKG9mZnNldCwgbGVuZ3RoLCB7XG4gICAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgICAgIGxpbmU6IHN0YXJ0TGluZSxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IHN0YXJ0Q29sdW1uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgbGluZTogZW5kTGluZSxcbiAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGVuZENvbHVtblxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0b2tlblR5cGUsIGhpZGRlbik7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBnZXRUb2tlblR5cGUobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sZXhlci5kZWZpbml0aW9uW25hbWVdO1xuICAgIH1cbiAgICBnZXRHcmFtbWFyRWxlbWVudElkKG5vZGUpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHcmFtbWFyRWxlbWVudElkTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JhbW1hckVsZW1lbnRJZE1hcC5nZXQobm9kZSk7XG4gICAgfVxuICAgIGdldEdyYW1tYXJFbGVtZW50KGlkKSB7XG4gICAgICAgIGlmICh0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHcmFtbWFyRWxlbWVudElkTWFwKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZ3JhbW1hckVsZW1lbnRJZE1hcC5nZXRLZXkoaWQpO1xuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9XG4gICAgY3JlYXRlR3JhbW1hckVsZW1lbnRJZE1hcCgpIHtcbiAgICAgICAgbGV0IGlkID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHN0cmVhbUFzdCh0aGlzLmdyYW1tYXIpKSB7XG4gICAgICAgICAgICBpZiAoaXNBYnN0cmFjdEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdyYW1tYXJFbGVtZW50SWRNYXAuc2V0KGVsZW1lbnQsIGlkKyspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aHlkcmF0b3IuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAndnNjb2RlLXVyaSc7XG5pbXBvcnQgeyBpc0FzdE5vZGUsIGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgZmluZE5vZGVzRm9yUHJvcGVydHkgfSBmcm9tICcuLi91dGlscy9ncmFtbWFyLXV0aWxzLmpzJztcbmV4cG9ydCBmdW5jdGlvbiBpc0FzdE5vZGVXaXRoQ29tbWVudChub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlLiRjb21tZW50ID09PSAnc3RyaW5nJztcbn1cbmZ1bmN0aW9uIGlzSW50ZXJtZWRpYXRlUmVmZXJlbmNlKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiAhIW9iaiAmJiAoJyRyZWYnIGluIG9iaiB8fCAnJGVycm9yJyBpbiBvYmopO1xufVxuZXhwb3J0IGNsYXNzIERlZmF1bHRKc29uU2VyaWFsaXplciB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgLyoqIFRoZSBzZXQgb2YgQXN0Tm9kZSBwcm9wZXJ0aWVzIHRvIGJlIGlnbm9yZWQgYnkgdGhlIHNlcmlhbGl6ZXIuICovXG4gICAgICAgIHRoaXMuaWdub3JlUHJvcGVydGllcyA9IG5ldyBTZXQoWyckY29udGFpbmVyJywgJyRjb250YWluZXJQcm9wZXJ0eScsICckY29udGFpbmVySW5kZXgnLCAnJGRvY3VtZW50JywgJyRjc3ROb2RlJ10pO1xuICAgICAgICB0aGlzLmxhbmdpdW1Eb2N1bWVudHMgPSBzZXJ2aWNlcy5zaGFyZWQud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMuYXN0Tm9kZUxvY2F0b3IgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZUxvY2F0b3I7XG4gICAgICAgIHRoaXMubmFtZVByb3ZpZGVyID0gc2VydmljZXMucmVmZXJlbmNlcy5OYW1lUHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29tbWVudFByb3ZpZGVyID0gc2VydmljZXMuZG9jdW1lbnRhdGlvbi5Db21tZW50UHJvdmlkZXI7XG4gICAgfVxuICAgIHNlcmlhbGl6ZShub2RlLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZU9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3Qgc3BlY2lmaWNSZXBsYWNlciA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5yZXBsYWNlcjtcbiAgICAgICAgY29uc3QgZGVmYXVsdFJlcGxhY2VyID0gKGtleSwgdmFsdWUpID0+IHRoaXMucmVwbGFjZXIoa2V5LCB2YWx1ZSwgc2VyaWFsaXplT3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IHJlcGxhY2VyID0gc3BlY2lmaWNSZXBsYWNlciA/IChrZXksIHZhbHVlKSA9PiBzcGVjaWZpY1JlcGxhY2VyKGtleSwgdmFsdWUsIGRlZmF1bHRSZXBsYWNlcikgOiBkZWZhdWx0UmVwbGFjZXI7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnREb2N1bWVudCA9IGdldERvY3VtZW50KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG5vZGUsIHJlcGxhY2VyLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3BhY2UpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RG9jdW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVzZXJpYWxpemUoY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBkZXNlcmlhbGl6ZU9wdGlvbnMgPSBvcHRpb25zICE9PSBudWxsICYmIG9wdGlvbnMgIT09IHZvaWQgMCA/IG9wdGlvbnMgOiB7fTtcbiAgICAgICAgY29uc3Qgcm9vdCA9IEpTT04ucGFyc2UoY29udGVudCk7XG4gICAgICAgIHRoaXMubGlua05vZGUocm9vdCwgcm9vdCwgZGVzZXJpYWxpemVPcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHJvb3Q7XG4gICAgfVxuICAgIHJlcGxhY2VyKGtleSwgdmFsdWUsIHsgcmVmVGV4dCwgc291cmNlVGV4dCwgdGV4dFJlZ2lvbnMsIGNvbW1lbnRzLCB1cmlDb252ZXJ0ZXIgfSkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gICAgICAgIGlmICh0aGlzLmlnbm9yZVByb3BlcnRpZXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWZlcmVuY2UodmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCByZWZWYWx1ZSA9IHZhbHVlLnJlZjtcbiAgICAgICAgICAgIGNvbnN0ICRyZWZUZXh0ID0gcmVmVGV4dCA/IHZhbHVlLiRyZWZUZXh0IDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHJlZlZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0RG9jdW1lbnQgPSBnZXREb2N1bWVudChyZWZWYWx1ZSk7XG4gICAgICAgICAgICAgICAgbGV0IHRhcmdldFVyaSA9ICcnO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREb2N1bWVudCAmJiB0aGlzLmN1cnJlbnREb2N1bWVudCAhPT0gdGFyZ2V0RG9jdW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVyaUNvbnZlcnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJpID0gdXJpQ29udmVydGVyKHRhcmdldERvY3VtZW50LnVyaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0VXJpID0gdGFyZ2V0RG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0UGF0aCA9IHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgocmVmVmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRyZWY6IGAke3RhcmdldFVyaX0jJHt0YXJnZXRQYXRofWAsXG4gICAgICAgICAgICAgICAgICAgICRyZWZUZXh0XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRlcnJvcjogKF9iID0gKF9hID0gdmFsdWUuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnQ291bGQgbm90IHJlc29sdmUgcmVmZXJlbmNlJyxcbiAgICAgICAgICAgICAgICAgICAgJHJlZlRleHRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIGxldCBhc3ROb2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHRleHRSZWdpb25zKSB7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZSA9IHRoaXMuYWRkQXN0Tm9kZVJlZ2lvbldpdGhBc3NpZ25tZW50c1RvKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgaWYgKCgha2V5IHx8IHZhbHVlLiRkb2N1bWVudCkgJiYgKGFzdE5vZGUgPT09IG51bGwgfHwgYXN0Tm9kZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogYXN0Tm9kZS4kdGV4dFJlZ2lvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRvY3VtZW50IFVSSSBpcyBhZGRlZCB0byB0aGUgcm9vdCBub2RlIG9mIHRoZSByZXN1bHRpbmcgSlNPTiB0cmVlXG4gICAgICAgICAgICAgICAgICAgIGFzdE5vZGUuJHRleHRSZWdpb24uZG9jdW1lbnRVUkkgPSAoX2MgPSB0aGlzLmN1cnJlbnREb2N1bWVudCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzb3VyY2VUZXh0ICYmICFrZXkpIHtcbiAgICAgICAgICAgICAgICBhc3ROb2RlICE9PSBudWxsICYmIGFzdE5vZGUgIT09IHZvaWQgMCA/IGFzdE5vZGUgOiAoYXN0Tm9kZSA9IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgYXN0Tm9kZS4kc291cmNlVGV4dCA9IChfZCA9IHZhbHVlLiRjc3ROb2RlKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudGV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb21tZW50cykge1xuICAgICAgICAgICAgICAgIGFzdE5vZGUgIT09IG51bGwgJiYgYXN0Tm9kZSAhPT0gdm9pZCAwID8gYXN0Tm9kZSA6IChhc3ROb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21tZW50ID0gdGhpcy5jb21tZW50UHJvdmlkZXIuZ2V0Q29tbWVudCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgYXN0Tm9kZS4kY29tbWVudCA9IGNvbW1lbnQucmVwbGFjZSgvXFxyL2csICcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXN0Tm9kZSAhPT0gbnVsbCAmJiBhc3ROb2RlICE9PSB2b2lkIDAgPyBhc3ROb2RlIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkQXN0Tm9kZVJlZ2lvbldpdGhBc3NpZ25tZW50c1RvKG5vZGUpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlRG9jdW1lbnRTZWdtZW50ID0gY3N0Tm9kZSA9PiAoe1xuICAgICAgICAgICAgb2Zmc2V0OiBjc3ROb2RlLm9mZnNldCxcbiAgICAgICAgICAgIGVuZDogY3N0Tm9kZS5lbmQsXG4gICAgICAgICAgICBsZW5ndGg6IGNzdE5vZGUubGVuZ3RoLFxuICAgICAgICAgICAgcmFuZ2U6IGNzdE5vZGUucmFuZ2UsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAobm9kZS4kY3N0Tm9kZSkge1xuICAgICAgICAgICAgY29uc3QgdGV4dFJlZ2lvbiA9IG5vZGUuJHRleHRSZWdpb24gPSBjcmVhdGVEb2N1bWVudFNlZ21lbnQobm9kZS4kY3N0Tm9kZSk7XG4gICAgICAgICAgICBjb25zdCBhc3NpZ25tZW50cyA9IHRleHRSZWdpb24uYXNzaWdubWVudHMgPSB7fTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG5vZGUpLmZpbHRlcihrZXkgPT4gIWtleS5zdGFydHNXaXRoKCckJykpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eUFzc2lnbm1lbnRzID0gZmluZE5vZGVzRm9yUHJvcGVydHkobm9kZS4kY3N0Tm9kZSwga2V5KS5tYXAoY3JlYXRlRG9jdW1lbnRTZWdtZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJvcGVydHlBc3NpZ25tZW50cy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzaWdubWVudHNba2V5XSA9IHByb3BlcnR5QXNzaWdubWVudHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsaW5rTm9kZShub2RlLCByb290LCBvcHRpb25zLCBjb250YWluZXIsIGNvbnRhaW5lclByb3BlcnR5LCBjb250YWluZXJJbmRleCkge1xuICAgICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eU5hbWUsIGl0ZW1dIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpdGVtKSkge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBpdGVtLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50ID0gaXRlbVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0ludGVybWVkaWF0ZVJlZmVyZW5jZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbVtpbmRleF0gPSB0aGlzLnJldml2ZVJlZmVyZW5jZShub2RlLCBwcm9wZXJ0eU5hbWUsIHJvb3QsIGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5saW5rTm9kZShlbGVtZW50LCByb290LCBvcHRpb25zLCBub2RlLCBwcm9wZXJ0eU5hbWUsIGluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzSW50ZXJtZWRpYXRlUmVmZXJlbmNlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgbm9kZVtwcm9wZXJ0eU5hbWVdID0gdGhpcy5yZXZpdmVSZWZlcmVuY2Uobm9kZSwgcHJvcGVydHlOYW1lLCByb290LCBpdGVtLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXN0Tm9kZShpdGVtKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGlua05vZGUoaXRlbSwgcm9vdCwgb3B0aW9ucywgbm9kZSwgcHJvcGVydHlOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtdXRhYmxlID0gbm9kZTtcbiAgICAgICAgbXV0YWJsZS4kY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICBtdXRhYmxlLiRjb250YWluZXJQcm9wZXJ0eSA9IGNvbnRhaW5lclByb3BlcnR5O1xuICAgICAgICBtdXRhYmxlLiRjb250YWluZXJJbmRleCA9IGNvbnRhaW5lckluZGV4O1xuICAgIH1cbiAgICByZXZpdmVSZWZlcmVuY2UoY29udGFpbmVyLCBwcm9wZXJ0eSwgcm9vdCwgcmVmZXJlbmNlLCBvcHRpb25zKSB7XG4gICAgICAgIGxldCByZWZUZXh0ID0gcmVmZXJlbmNlLiRyZWZUZXh0O1xuICAgICAgICBsZXQgZXJyb3IgPSByZWZlcmVuY2UuJGVycm9yO1xuICAgICAgICBpZiAocmVmZXJlbmNlLiRyZWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHRoaXMuZ2V0UmVmTm9kZShyb290LCByZWZlcmVuY2UuJHJlZiwgb3B0aW9ucy51cmlDb252ZXJ0ZXIpO1xuICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShyZWYpKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWZUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZlRleHQgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKHJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICRyZWZUZXh0OiByZWZUZXh0ICE9PSBudWxsICYmIHJlZlRleHQgIT09IHZvaWQgMCA/IHJlZlRleHQgOiAnJyxcbiAgICAgICAgICAgICAgICAgICAgcmVmXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGVycm9yID0gcmVmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY29uc3QgcmVmID0ge1xuICAgICAgICAgICAgICAgICRyZWZUZXh0OiByZWZUZXh0ICE9PSBudWxsICYmIHJlZlRleHQgIT09IHZvaWQgMCA/IHJlZlRleHQgOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlZi5lcnJvciA9IHtcbiAgICAgICAgICAgICAgICBjb250YWluZXIsXG4gICAgICAgICAgICAgICAgcHJvcGVydHksXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlOiByZWZcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gcmVmO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRSZWZOb2RlKHJvb3QsIHVyaSwgdXJpQ29udmVydGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudEluZGV4ID0gdXJpLmluZGV4T2YoJyMnKTtcbiAgICAgICAgICAgIGlmIChmcmFnbWVudEluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZShyb290LCB1cmkuc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDb3VsZCBub3QgcmVzb2x2ZSBwYXRoOiAnICsgdXJpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFnbWVudEluZGV4IDwgMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50VXJpID0gdXJpQ29udmVydGVyID8gdXJpQ29udmVydGVyKHVyaSkgOiBVUkkucGFyc2UodXJpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkb2N1bWVudCA9IHRoaXMubGFuZ2l1bURvY3VtZW50cy5nZXREb2N1bWVudChkb2N1bWVudFVyaSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ0NvdWxkIG5vdCBmaW5kIGRvY3VtZW50IGZvciBVUkk6ICcgKyB1cmk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50VXJpID0gdXJpQ29udmVydGVyID8gdXJpQ29udmVydGVyKHVyaS5zdWJzdHJpbmcoMCwgZnJhZ21lbnRJbmRleCkpIDogVVJJLnBhcnNlKHVyaS5zdWJzdHJpbmcoMCwgZnJhZ21lbnRJbmRleCkpO1xuICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuZ2V0RG9jdW1lbnQoZG9jdW1lbnRVcmkpO1xuICAgICAgICAgICAgaWYgKCFkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ291bGQgbm90IGZpbmQgZG9jdW1lbnQgZm9yIFVSSTogJyArIHVyaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmcmFnbWVudEluZGV4ID09PSB1cmkubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLmFzdE5vZGVMb2NhdG9yLmdldEFzdE5vZGUoZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUsIHVyaS5zdWJzdHJpbmcoZnJhZ21lbnRJbmRleCArIDEpKTtcbiAgICAgICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnQ291bGQgbm90IHJlc29sdmUgVVJJOiAnICsgdXJpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZyhlcnIpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9anNvbi1zZXJpYWxpemVyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IFVyaVV0aWxzIH0gZnJvbSAnLi91dGlscy91cmktdXRpbHMuanMnO1xuLyoqXG4gKiBHZW5lcmljIHJlZ2lzdHJ5IGZvciBMYW5naXVtIHNlcnZpY2VzLCBidXQgY2FwYWJsZSBvZiBiZWluZyB1c2VkIHdpdGggZXh0ZW5kaW5nIHNlcnZpY2Ugc2V0cyBhcyB3ZWxsIChzdWNoIGFzIHRoZSBsc3AtY29tcGxldGUgTGFuZ2l1bUNvcmVTZXJ2aWNlcyBzZXQpXG4gKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0U2VydmljZVJlZ2lzdHJ5IHtcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIG5ldyBgZmlsZUV4dGVuc2lvbk1hcGAgKG9yIGBsYW5ndWFnZUlkTWFwYCkgcHJvcGVydHkgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBnZXQgbWFwKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWxlRXh0ZW5zaW9uTWFwO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmxhbmd1YWdlSWRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZmlsZUV4dGVuc2lvbk1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy50ZXh0RG9jdW1lbnRzID0gc2VydmljZXMgPT09IG51bGwgfHwgc2VydmljZXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHNlcnZpY2VzLndvcmtzcGFjZS5UZXh0RG9jdW1lbnRzO1xuICAgIH1cbiAgICByZWdpc3RlcihsYW5ndWFnZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gbGFuZ3VhZ2UuTGFuZ3VhZ2VNZXRhRGF0YTtcbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgZGF0YS5maWxlRXh0ZW5zaW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuZmlsZUV4dGVuc2lvbk1hcC5oYXMoZXh0KSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgVGhlIGZpbGUgZXh0ZW5zaW9uICR7ZXh0fSBpcyB1c2VkIGJ5IG11bHRpcGxlIGxhbmd1YWdlcy4gSXQgaXMgbm93IGFzc2lnbmVkIHRvICcke2RhdGEubGFuZ3VhZ2VJZH0nLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5maWxlRXh0ZW5zaW9uTWFwLnNldChleHQsIGxhbmd1YWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxhbmd1YWdlSWRNYXAuc2V0KGRhdGEubGFuZ3VhZ2VJZCwgbGFuZ3VhZ2UpO1xuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZUlkTWFwLnNpemUgPT09IDEpIHtcbiAgICAgICAgICAgIHRoaXMuc2luZ2xldG9uID0gbGFuZ3VhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNpbmdsZXRvbiA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRTZXJ2aWNlcyh1cmkpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKHRoaXMuc2luZ2xldG9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpbmdsZXRvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5sYW5ndWFnZUlkTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHNlcnZpY2UgcmVnaXN0cnkgaXMgZW1wdHkuIFVzZSBgcmVnaXN0ZXJgIHRvIHJlZ2lzdGVyIHRoZSBzZXJ2aWNlcyBvZiBhIGxhbmd1YWdlLicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxhbmd1YWdlSWQgPSAoX2IgPSAoX2EgPSB0aGlzLnRleHREb2N1bWVudHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQodXJpKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmxhbmd1YWdlSWQ7XG4gICAgICAgIGlmIChsYW5ndWFnZUlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5sYW5ndWFnZUlkTWFwLmdldChsYW5ndWFnZUlkKTtcbiAgICAgICAgICAgIGlmIChzZXJ2aWNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzZXJ2aWNlcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHQgPSBVcmlVdGlscy5leHRuYW1lKHVyaSk7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5maWxlRXh0ZW5zaW9uTWFwLmdldChleHQpO1xuICAgICAgICBpZiAoIXNlcnZpY2VzKSB7XG4gICAgICAgICAgICBpZiAobGFuZ3VhZ2VJZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgcmVnaXN0cnkgY29udGFpbnMgbm8gc2VydmljZXMgZm9yIHRoZSBleHRlbnNpb24gJyR7ZXh0fScgZm9yIGxhbmd1YWdlICcke2xhbmd1YWdlSWR9Jy5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHNlcnZpY2UgcmVnaXN0cnkgY29udGFpbnMgbm8gc2VydmljZXMgZm9yIHRoZSBleHRlbnNpb24gJyR7ZXh0fScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcnZpY2VzO1xuICAgIH1cbiAgICBoYXNTZXJ2aWNlcyh1cmkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VydmljZXModXJpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfYSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhbGwoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMubGFuZ3VhZ2VJZE1hcC52YWx1ZXMoKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VydmljZS1yZWdpc3RyeS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgZnVuY3Rpb24gaXNBc3ROb2RlKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGwgJiYgdHlwZW9mIG9iai4kdHlwZSA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSZWZlcmVuY2Uob2JqKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCAmJiB0eXBlb2Ygb2JqLiRyZWZUZXh0ID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FzdE5vZGVEZXNjcmlwdGlvbihvYmopIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsXG4gICAgICAgICYmIHR5cGVvZiBvYmoubmFtZSA9PT0gJ3N0cmluZydcbiAgICAgICAgJiYgdHlwZW9mIG9iai50eXBlID09PSAnc3RyaW5nJ1xuICAgICAgICAmJiB0eXBlb2Ygb2JqLnBhdGggPT09ICdzdHJpbmcnO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzTGlua2luZ0Vycm9yKG9iaikge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogIT09IG51bGxcbiAgICAgICAgJiYgaXNBc3ROb2RlKG9iai5jb250YWluZXIpXG4gICAgICAgICYmIGlzUmVmZXJlbmNlKG9iai5yZWZlcmVuY2UpXG4gICAgICAgICYmIHR5cGVvZiBvYmoubWVzc2FnZSA9PT0gJ3N0cmluZyc7XG59XG4vKipcbiAqIEFuIGFic3RyYWN0IGltcGxlbWVudGF0aW9uIG9mIHRoZSB7QGxpbmsgQXN0UmVmbGVjdGlvbn0gaW50ZXJmYWNlLlxuICogU2VydmVzIHRvIGNhY2hlIHN1YnR5cGUgY29tcHV0YXRpb24gcmVzdWx0cyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlIHRocm91Z2hvdXQgZGlmZmVyZW50IHBhcnRzIG9mIExhbmdpdW0uXG4gKi9cbmV4cG9ydCBjbGFzcyBBYnN0cmFjdEFzdFJlZmxlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN1YnR5cGVzID0ge307XG4gICAgICAgIHRoaXMuYWxsU3VidHlwZXMgPSB7fTtcbiAgICB9XG4gICAgaXNJbnN0YW5jZShub2RlLCB0eXBlKSB7XG4gICAgICAgIHJldHVybiBpc0FzdE5vZGUobm9kZSkgJiYgdGhpcy5pc1N1YnR5cGUobm9kZS4kdHlwZSwgdHlwZSk7XG4gICAgfVxuICAgIGlzU3VidHlwZShzdWJ0eXBlLCBzdXBlcnR5cGUpIHtcbiAgICAgICAgaWYgKHN1YnR5cGUgPT09IHN1cGVydHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG5lc3RlZCA9IHRoaXMuc3VidHlwZXNbc3VidHlwZV07XG4gICAgICAgIGlmICghbmVzdGVkKSB7XG4gICAgICAgICAgICBuZXN0ZWQgPSB0aGlzLnN1YnR5cGVzW3N1YnR5cGVdID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSBuZXN0ZWRbc3VwZXJ0eXBlXTtcbiAgICAgICAgaWYgKGV4aXN0aW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuY29tcHV0ZUlzU3VidHlwZShzdWJ0eXBlLCBzdXBlcnR5cGUpO1xuICAgICAgICAgICAgbmVzdGVkW3N1cGVydHlwZV0gPSByZXN1bHQ7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldEFsbFN1YlR5cGVzKHR5cGUpIHtcbiAgICAgICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLmFsbFN1YnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZXhpc3RpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGFsbFR5cGVzID0gdGhpcy5nZXRBbGxUeXBlcygpO1xuICAgICAgICAgICAgY29uc3QgdHlwZXMgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcG9zc2libGVTdWJUeXBlIG9mIGFsbFR5cGVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNTdWJ0eXBlKHBvc3NpYmxlU3ViVHlwZSwgdHlwZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZXMucHVzaChwb3NzaWJsZVN1YlR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYWxsU3VidHlwZXNbdHlwZV0gPSB0eXBlcztcbiAgICAgICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbXBvc2l0ZUNzdE5vZGUobm9kZSkge1xuICAgIHJldHVybiB0eXBlb2Ygbm9kZSA9PT0gJ29iamVjdCcgJiYgbm9kZSAhPT0gbnVsbCAmJiBBcnJheS5pc0FycmF5KG5vZGUuY29udGVudCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNMZWFmQ3N0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBub2RlID09PSAnb2JqZWN0JyAmJiBub2RlICE9PSBudWxsICYmIHR5cGVvZiBub2RlLnRva2VuVHlwZSA9PT0gJ29iamVjdCc7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNSb290Q3N0Tm9kZShub2RlKSB7XG4gICAgcmV0dXJuIGlzQ29tcG9zaXRlQ3N0Tm9kZShub2RlKSAmJiB0eXBlb2Ygbm9kZS5mdWxsVGV4dCA9PT0gJ3N0cmluZyc7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1zeW50YXgtdHJlZS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBpc0FzdE5vZGUsIGlzUmVmZXJlbmNlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgRE9ORV9SRVNVTFQsIHN0cmVhbSwgU3RyZWFtSW1wbCwgVHJlZVN0cmVhbUltcGwgfSBmcm9tICcuL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBpblJhbmdlIH0gZnJvbSAnLi9jc3QtdXRpbHMuanMnO1xuLyoqXG4gKiBMaW5rIHRoZSBgJGNvbnRhaW5lcmAgYW5kIG90aGVyIHJlbGF0ZWQgcHJvcGVydGllcyBvZiBldmVyeSBBU1Qgbm9kZSB0aGF0IGlzIGRpcmVjdGx5IGNvbnRhaW5lZFxuICogaW4gdGhlIGdpdmVuIGBub2RlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGxpbmtDb250ZW50VG9Db250YWluZXIobm9kZSkge1xuICAgIGZvciAoY29uc3QgW25hbWUsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhub2RlKSkge1xuICAgICAgICBpZiAoIW5hbWUuc3RhcnRzV2l0aCgnJCcpKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKChpdGVtLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVtLiRjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS4kY29udGFpbmVyUHJvcGVydHkgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlbS4kY29udGFpbmVySW5kZXggPSBpbmRleDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoaXNBc3ROb2RlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHZhbHVlLiRjb250YWluZXIgPSBub2RlO1xuICAgICAgICAgICAgICAgIHZhbHVlLiRjb250YWluZXJQcm9wZXJ0eSA9IG5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIFdhbGsgYWxvbmcgdGhlIGhpZXJhcmNoeSBvZiBjb250YWluZXJzIGZyb20gdGhlIGdpdmVuIEFTVCBub2RlIHRvIHRoZSByb290IGFuZCByZXR1cm4gdGhlIGZpcnN0XG4gKiBub2RlIHRoYXQgbWF0Y2hlcyB0aGUgdHlwZSBwcmVkaWNhdGUuIElmIHRoZSBzdGFydCBub2RlIGl0c2VsZiBtYXRjaGVzLCBpdCBpcyByZXR1cm5lZC5cbiAqIElmIG5vIGNvbnRhaW5lciBtYXRjaGVzLCBgdW5kZWZpbmVkYCBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRhaW5lck9mVHlwZShub2RlLCB0eXBlUHJlZGljYXRlKSB7XG4gICAgbGV0IGl0ZW0gPSBub2RlO1xuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgIGlmICh0eXBlUHJlZGljYXRlKGl0ZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtID0gaXRlbS4kY29udGFpbmVyO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBXYWxrIGFsb25nIHRoZSBoaWVyYXJjaHkgb2YgY29udGFpbmVycyBmcm9tIHRoZSBnaXZlbiBBU1Qgbm9kZSB0byB0aGUgcm9vdCBhbmQgY2hlY2sgZm9yIGV4aXN0ZW5jZVxuICogb2YgYSBjb250YWluZXIgdGhhdCBtYXRjaGVzIHRoZSBnaXZlbiBwcmVkaWNhdGUuIFRoZSBzdGFydCBub2RlIGlzIGluY2x1ZGVkIGluIHRoZSBjaGVja3MuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoYXNDb250YWluZXJPZlR5cGUobm9kZSwgcHJlZGljYXRlKSB7XG4gICAgbGV0IGl0ZW0gPSBub2RlO1xuICAgIHdoaWxlIChpdGVtKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoaXRlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGl0ZW0gPSBpdGVtLiRjb250YWluZXI7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbi8qKlxuICogUmV0cmlldmUgdGhlIGRvY3VtZW50IGluIHdoaWNoIHRoZSBnaXZlbiBBU1Qgbm9kZSBpcyBjb250YWluZWQuIEEgcmVmZXJlbmNlIHRvIHRoZSBkb2N1bWVudCBpc1xuICogdXN1YWxseSBoZWxkIGJ5IHRoZSByb290IG5vZGUgb2YgdGhlIEFTVC5cbiAqXG4gKiBAdGhyb3dzIGFuIGVycm9yIGlmIHRoZSBub2RlIGlzIG5vdCBjb250YWluZWQgaW4gYSBkb2N1bWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldERvY3VtZW50KG5vZGUpIHtcbiAgICBjb25zdCByb290Tm9kZSA9IGZpbmRSb290Tm9kZShub2RlKTtcbiAgICBjb25zdCByZXN1bHQgPSByb290Tm9kZS4kZG9jdW1lbnQ7XG4gICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBU1Qgbm9kZSBoYXMgbm8gZG9jdW1lbnQuJyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgZ2l2ZW4gQVNUIG5vZGUgYnkgZm9sbG93aW5nIHRoZSBgJGNvbnRhaW5lcmAgcmVmZXJlbmNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmRSb290Tm9kZShub2RlKSB7XG4gICAgd2hpbGUgKG5vZGUuJGNvbnRhaW5lcikge1xuICAgICAgICBub2RlID0gbm9kZS4kY29udGFpbmVyO1xuICAgIH1cbiAgICByZXR1cm4gbm9kZTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBBU1Qgbm9kZXMgdGhhdCBhcmUgZGlyZWN0bHkgY29udGFpbmVkIGluIHRoZSBnaXZlbiBub2RlLiBUaGlzIGluY2x1ZGVzXG4gKiBzaW5nbGUtdmFsdWVkIGFzIHdlbGwgYXMgbXVsdGktdmFsdWVkIChhcnJheSkgcHJvcGVydGllcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbUNvbnRlbnRzKG5vZGUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb2RlIG11c3QgYmUgYW4gQXN0Tm9kZS4nKTtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2UgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMucmFuZ2U7XG4gICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7XG4gICAgICAgIGtleXM6IE9iamVjdC5rZXlzKG5vZGUpLFxuICAgICAgICBrZXlJbmRleDogMCxcbiAgICAgICAgYXJyYXlJbmRleDogMFxuICAgIH0pLCBzdGF0ZSA9PiB7XG4gICAgICAgIHdoaWxlIChzdGF0ZS5rZXlJbmRleCA8IHN0YXRlLmtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IHN0YXRlLmtleXNbc3RhdGUua2V5SW5kZXhdO1xuICAgICAgICAgICAgaWYgKCFwcm9wZXJ0eS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG5vZGVbcHJvcGVydHldO1xuICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleUluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0FzdE5vZGVJblJhbmdlKHZhbHVlLCByYW5nZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5hcnJheUluZGV4IDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmFycmF5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNBc3ROb2RlKGVsZW1lbnQpICYmIGlzQXN0Tm9kZUluUmFuZ2UoZWxlbWVudCwgcmFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBlbGVtZW50IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXJyYXlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUua2V5SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgfSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgQVNUIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5IGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICogVGhpcyBkb2VzIG5vdCBpbmNsdWRlIHRoZSByb290IG5vZGUgaXRzZWxmLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtQWxsQ29udGVudHMocm9vdCwgb3B0aW9ucykge1xuICAgIGlmICghcm9vdCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3Qgbm9kZSBtdXN0IGJlIGFuIEFzdE5vZGUuJyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJlZVN0cmVhbUltcGwocm9vdCwgbm9kZSA9PiBzdHJlYW1Db250ZW50cyhub2RlLCBvcHRpb25zKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgQVNUIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5IGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcm9vdCBub2RlLFxuICogaW5jbHVkaW5nIHRoZSByb290IG5vZGUgaXRzZWxmLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtQXN0KHJvb3QsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXJvb3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IG5vZGUgbXVzdCBiZSBhbiBBc3ROb2RlLicpO1xuICAgIH1cbiAgICBlbHNlIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJhbmdlKSAmJiAhaXNBc3ROb2RlSW5SYW5nZShyb290LCBvcHRpb25zLnJhbmdlKSkge1xuICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgc3RyZWFtIGlmIHRoZSByb290IG5vZGUgaXNuJ3QgaW4gcmFuZ2VcbiAgICAgICAgcmV0dXJuIG5ldyBUcmVlU3RyZWFtSW1wbChyb290LCAoKSA9PiBbXSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgVHJlZVN0cmVhbUltcGwocm9vdCwgbm9kZSA9PiBzdHJlYW1Db250ZW50cyhub2RlLCBvcHRpb25zKSwgeyBpbmNsdWRlUm9vdDogdHJ1ZSB9KTtcbn1cbmZ1bmN0aW9uIGlzQXN0Tm9kZUluUmFuZ2UoYXN0Tm9kZSwgcmFuZ2UpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCFyYW5nZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVJhbmdlID0gKF9hID0gYXN0Tm9kZS4kY3N0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJhbmdlO1xuICAgIGlmICghbm9kZVJhbmdlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGluUmFuZ2Uobm9kZVJhbmdlLCByYW5nZSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgY3Jvc3MtcmVmZXJlbmNlcyB0aGF0IGFyZSBoZWxkIGJ5IHRoZSBnaXZlbiBBU1Qgbm9kZS4gVGhpcyBpbmNsdWRlc1xuICogc2luZ2xlLXZhbHVlZCBhcyB3ZWxsIGFzIG11bHRpLXZhbHVlZCAoYXJyYXkpIHByb3BlcnRpZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJlYW1SZWZlcmVuY2VzKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHtcbiAgICAgICAga2V5czogT2JqZWN0LmtleXMobm9kZSksXG4gICAgICAgIGtleUluZGV4OiAwLFxuICAgICAgICBhcnJheUluZGV4OiAwXG4gICAgfSksIHN0YXRlID0+IHtcbiAgICAgICAgd2hpbGUgKHN0YXRlLmtleUluZGV4IDwgc3RhdGUua2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gc3RhdGUua2V5c1tzdGF0ZS5rZXlJbmRleF07XG4gICAgICAgICAgICBpZiAoIXByb3BlcnR5LnN0YXJ0c1dpdGgoJyQnKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gbm9kZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgaWYgKGlzUmVmZXJlbmNlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5rZXlJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHsgcmVmZXJlbmNlOiB2YWx1ZSwgY29udGFpbmVyOiBub2RlLCBwcm9wZXJ0eSB9IH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5hcnJheUluZGV4IDwgdmFsdWUubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHN0YXRlLmFycmF5SW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVsZW1lbnQgPSB2YWx1ZVtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWZlcmVuY2UoZWxlbWVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IHsgcmVmZXJlbmNlOiBlbGVtZW50LCBjb250YWluZXI6IG5vZGUsIHByb3BlcnR5LCBpbmRleCB9IH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuYXJyYXlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUua2V5SW5kZXgrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgfSk7XG59XG4vKipcbiAqIFJldHVybnMgYSBTdHJlYW0gb2YgcmVmZXJlbmNlcyB0byB0aGUgdGFyZ2V0IG5vZGUgZnJvbSB0aGUgQXN0Tm9kZSB0cmVlXG4gKlxuICogQHBhcmFtIHRhcmdldE5vZGUgQXN0Tm9kZSB3ZSBhcmUgbG9va2luZyBmb3JcbiAqIEBwYXJhbSBsb29rdXAgQXN0Tm9kZSB3aGVyZSB3ZSBzZWFyY2ggZm9yIHJlZmVyZW5jZXMuIElmIG5vdCBwcm92aWRlZCwgdGhlIHJvb3Qgbm9kZSBvZiB0aGUgZG9jdW1lbnQgaXMgdXNlZCBhcyB0aGUgZGVmYXVsdCB2YWx1ZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExvY2FsUmVmZXJlbmNlcyh0YXJnZXROb2RlLCBsb29rdXAgPSBnZXREb2N1bWVudCh0YXJnZXROb2RlKS5wYXJzZVJlc3VsdC52YWx1ZSkge1xuICAgIGNvbnN0IHJlZnMgPSBbXTtcbiAgICBzdHJlYW1Bc3QobG9va3VwKS5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgICBzdHJlYW1SZWZlcmVuY2VzKG5vZGUpLmZvckVhY2gocmVmSW5mbyA9PiB7XG4gICAgICAgICAgICBpZiAocmVmSW5mby5yZWZlcmVuY2UucmVmID09PSB0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICAgICAgcmVmcy5wdXNoKHJlZkluZm8ucmVmZXJlbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHN0cmVhbShyZWZzKTtcbn1cbi8qKlxuICogQXNzaWducyBhbGwgbWFuZGF0b3J5IEFTVCBwcm9wZXJ0aWVzIHRvIHRoZSBzcGVjaWZpZWQgbm9kZS5cbiAqXG4gKiBAcGFyYW0gcmVmbGVjdGlvbiBSZWZsZWN0aW9uIG9iamVjdCB1c2VkIHRvIGdhdGhlciBtYW5kYXRvcnkgcHJvcGVydGllcyBmb3IgdGhlIG5vZGUuXG4gKiBAcGFyYW0gbm9kZSBTcGVjaWZpZWQgbm9kZSBpcyBtb2RpZmllZCBpbiBwbGFjZSBhbmQgcHJvcGVydGllcyBhcmUgZGlyZWN0bHkgYXNzaWduZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBhc3NpZ25NYW5kYXRvcnlQcm9wZXJ0aWVzKHJlZmxlY3Rpb24sIG5vZGUpIHtcbiAgICBjb25zdCB0eXBlTWV0YURhdGEgPSByZWZsZWN0aW9uLmdldFR5cGVNZXRhRGF0YShub2RlLiR0eXBlKTtcbiAgICBjb25zdCBnZW5lcmljTm9kZSA9IG5vZGU7XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiB0eXBlTWV0YURhdGEucHJvcGVydGllcykge1xuICAgICAgICAvLyBPbmx5IHNldCB0aGUgdmFsdWUgaWYgdGhlIHByb3BlcnR5IGlzIG5vdCBhbHJlYWR5IHNldCBhbmQgaWYgaXQgaGFzIGEgZGVmYXVsdCB2YWx1ZVxuICAgICAgICBpZiAocHJvcGVydHkuZGVmYXVsdFZhbHVlICE9PSB1bmRlZmluZWQgJiYgZ2VuZXJpY05vZGVbcHJvcGVydHkubmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZ2VuZXJpY05vZGVbcHJvcGVydHkubmFtZV0gPSBjb3B5RGVmYXVsdFZhbHVlKHByb3BlcnR5LmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjb3B5RGVmYXVsdFZhbHVlKHByb3BlcnR5VHlwZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BlcnR5VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5wcm9wZXJ0eVR5cGUubWFwKGNvcHlEZWZhdWx0VmFsdWUpXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eVR5cGU7XG4gICAgfVxufVxuLyoqXG4gKiBDcmVhdGVzIGEgZGVlcCBjb3B5IG9mIHRoZSBzcGVjaWZpZWQgQVNUIG5vZGUuXG4gKiBUaGUgcmVzdWx0aW5nIGNvcHkgd2lsbCBvbmx5IGNvbnRhaW4gc2VtYW50aWNhbGx5IHJlbGV2YW50IGluZm9ybWF0aW9uLCBzdWNoIGFzIHRoZSBgJHR5cGVgIHByb3BlcnR5IGFuZCBBU1QgcHJvcGVydGllcy5cbiAqXG4gKiBSZWZlcmVuY2VzIGFyZSBjb3BpZWQgd2l0aG91dCByZXNvbHZlZCBjcm9zcyByZWZlcmVuY2UuIFRoZSBzcGVjaWZpZWQgZnVuY3Rpb24gaXMgdXNlZCB0byByZWJ1aWxkIHRoZW0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3B5QXN0Tm9kZShub2RlLCBidWlsZFJlZmVyZW5jZSkge1xuICAgIGNvbnN0IGNvcHkgPSB7ICR0eXBlOiBub2RlLiR0eXBlIH07XG4gICAgZm9yIChjb25zdCBbbmFtZSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5vZGUpKSB7XG4gICAgICAgIGlmICghbmFtZS5zdGFydHNXaXRoKCckJykpIHtcbiAgICAgICAgICAgIGlmIChpc0FzdE5vZGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29weVtuYW1lXSA9IGNvcHlBc3ROb2RlKHZhbHVlLCBidWlsZFJlZmVyZW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1JlZmVyZW5jZSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBjb3B5W25hbWVdID0gYnVpbGRSZWZlcmVuY2UoY29weSwgbmFtZSwgdmFsdWUuJHJlZk5vZGUsIHZhbHVlLiRyZWZUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY29waWVkQXJyYXkgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQXN0Tm9kZShlbGVtZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29waWVkQXJyYXkucHVzaChjb3B5QXN0Tm9kZShlbGVtZW50LCBidWlsZFJlZmVyZW5jZSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmZXJlbmNlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3BpZWRBcnJheS5wdXNoKGJ1aWxkUmVmZXJlbmNlKGNvcHksIG5hbWUsIGVsZW1lbnQuJHJlZk5vZGUsIGVsZW1lbnQuJHJlZlRleHQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcGllZEFycmF5LnB1c2goZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29weVtuYW1lXSA9IGNvcGllZEFycmF5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29weVtuYW1lXSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGxpbmtDb250ZW50VG9Db250YWluZXIoY29weSk7XG4gICAgcmV0dXJuIGNvcHk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QtdXRpbHMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGNsYXNzIERpc3Bvc2FibGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMudG9EaXNwb3NlID0gW107XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBvbkRpc3Bvc2UoZGlzcG9zYWJsZSkge1xuICAgICAgICB0aGlzLnRvRGlzcG9zZS5wdXNoKGRpc3Bvc2FibGUpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMudG9EaXNwb3NlLmZvckVhY2goZGlzcG9zYWJsZSA9PiBkaXNwb3NhYmxlLmRpc3Bvc2UoKSk7XG4gICAgfVxuICAgIHRocm93SWZEaXNwb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGNhY2hlIGhhcyBhbHJlYWR5IGJlZW4gZGlzcG9zZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBTaW1wbGVDYWNoZSBleHRlbmRzIERpc3Bvc2FibGVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMuY2FjaGUgPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuaGFzKGtleSk7XG4gICAgfVxuICAgIHNldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICBnZXQoa2V5LCBwcm92aWRlcikge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGUuZ2V0KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoa2V5KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlLmRlbGV0ZShrZXkpO1xuICAgIH1cbiAgICBjbGVhcigpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBDb250ZXh0Q2FjaGUgZXh0ZW5kcyBEaXNwb3NhYmxlQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnZlcnRlcikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNhY2hlID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNvbnZlcnRlciA9IGNvbnZlcnRlciAhPT0gbnVsbCAmJiBjb252ZXJ0ZXIgIT09IHZvaWQgMCA/IGNvbnZlcnRlciA6ICh2YWx1ZSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGhhcyhjb250ZXh0S2V5LCBrZXkpIHtcbiAgICAgICAgdGhpcy50aHJvd0lmRGlzcG9zZWQoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpLmhhcyhrZXkpO1xuICAgIH1cbiAgICBzZXQoY29udGV4dEtleSwga2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICB0aGlzLmNhY2hlRm9yQ29udGV4dChjb250ZXh0S2V5KS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGdldChjb250ZXh0S2V5LCBrZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIGNvbnN0IGNvbnRleHRDYWNoZSA9IHRoaXMuY2FjaGVGb3JDb250ZXh0KGNvbnRleHRLZXkpO1xuICAgICAgICBpZiAoY29udGV4dENhY2hlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gY29udGV4dENhY2hlLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3ZpZGVyKCk7XG4gICAgICAgICAgICBjb250ZXh0Q2FjaGUuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkZWxldGUoY29udGV4dEtleSwga2V5KSB7XG4gICAgICAgIHRoaXMudGhyb3dJZkRpc3Bvc2VkKCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNhY2hlRm9yQ29udGV4dChjb250ZXh0S2V5KS5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgY2xlYXIoY29udGV4dEtleSkge1xuICAgICAgICB0aGlzLnRocm93SWZEaXNwb3NlZCgpO1xuICAgICAgICBpZiAoY29udGV4dEtleSkge1xuICAgICAgICAgICAgY29uc3QgbWFwS2V5ID0gdGhpcy5jb252ZXJ0ZXIoY29udGV4dEtleSk7XG4gICAgICAgICAgICB0aGlzLmNhY2hlLmRlbGV0ZShtYXBLZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jYWNoZS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhY2hlRm9yQ29udGV4dChjb250ZXh0S2V5KSB7XG4gICAgICAgIGNvbnN0IG1hcEtleSA9IHRoaXMuY29udmVydGVyKGNvbnRleHRLZXkpO1xuICAgICAgICBsZXQgZG9jdW1lbnRDYWNoZSA9IHRoaXMuY2FjaGUuZ2V0KG1hcEtleSk7XG4gICAgICAgIGlmICghZG9jdW1lbnRDYWNoZSkge1xuICAgICAgICAgICAgZG9jdW1lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIHRoaXMuY2FjaGUuc2V0KG1hcEtleSwgZG9jdW1lbnRDYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRvY3VtZW50Q2FjaGU7XG4gICAgfVxufVxuLyoqXG4gKiBFdmVyeSBrZXkvdmFsdWUgcGFpciBpbiB0aGlzIGNhY2hlIGlzIHNjb3BlZCB0byBhIGRvY3VtZW50LlxuICogSWYgdGhpcyBkb2N1bWVudCBpcyBjaGFuZ2VkIG9yIGRlbGV0ZWQsIGFsbCBhc3NvY2lhdGVkIGtleS92YWx1ZSBwYWlycyBhcmUgZGVsZXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIERvY3VtZW50Q2FjaGUgZXh0ZW5kcyBDb250ZXh0Q2FjaGUge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgZG9jdW1lbnQgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hhcmVkU2VydmljZXMgU2VydmljZSBjb250YWluZXIgaW5zdGFuY2UgdG8gaG9vayBpbnRvIGRvY3VtZW50IGxpZmVjeWNsZSBldmVudHMuXG4gICAgICogQHBhcmFtIHN0YXRlIE9wdGlvbmFsIGRvY3VtZW50IHN0YXRlIG9uIHdoaWNoIHRoZSBjYWNoZSBzaG91bGQgZXZpY3QuXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgY2FjaGUgd2lsbCBldmljdCBvbiBgRG9jdW1lbnRCdWlsZGVyI29uVXBkYXRlYC5cbiAgICAgKiAqRGVsZXRlZCogZG9jdW1lbnRzIGFyZSBjb25zaWRlcmVkIGluIGJvdGggY2FzZXMuXG4gICAgICpcbiAgICAgKiBQcm92aWRpbmcgYSBzdGF0ZSBoZXJlIHdpbGwgdXNlIGBEb2N1bWVudEJ1aWxkZXIjb25Eb2N1bWVudFBoYXNlYCBpbnN0ZWFkLFxuICAgICAqIHdoaWNoIHRyaWdnZXJzIG9uIGFsbCBkb2N1bWVudHMgdGhhdCBoYXZlIGJlZW4gYWZmZWN0ZWQgYnkgdGhpcyBjaGFuZ2UsIGFzc3VtaW5nIHRoYXQgdGhlXG4gICAgICogc3RhdGUgaXMgYERvY3VtZW50U3RhdGUuTGlua2VkYCBvciBhIGxhdGVyIHN0YXRlLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNoYXJlZFNlcnZpY2VzLCBzdGF0ZSkge1xuICAgICAgICBzdXBlcih1cmkgPT4gdXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudG9EaXNwb3NlLnB1c2goc2hhcmVkU2VydmljZXMud29ya3NwYWNlLkRvY3VtZW50QnVpbGRlci5vbkRvY3VtZW50UGhhc2Uoc3RhdGUsIGRvY3VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKGRvY3VtZW50LnVyaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMudG9EaXNwb3NlLnB1c2goc2hhcmVkU2VydmljZXMud29ya3NwYWNlLkRvY3VtZW50QnVpbGRlci5vblVwZGF0ZSgoX2NoYW5nZWQsIGRlbGV0ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IHVyaSBvZiBkZWxldGVkKSB7IC8vIHJlYWN0IG9ubHkgb24gZGVsZXRlZCBkb2N1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcih1cmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9EaXNwb3NlLnB1c2goc2hhcmVkU2VydmljZXMud29ya3NwYWNlLkRvY3VtZW50QnVpbGRlci5vblVwZGF0ZSgoY2hhbmdlZCwgZGVsZXRlZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFsbFVyaXMgPSBjaGFuZ2VkLmNvbmNhdChkZWxldGVkKTsgLy8gcmVhY3Qgb24gYm90aCBjaGFuZ2VkIGFuZCBkZWxldGVkIGRvY3VtZW50c1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdXJpIG9mIGFsbFVyaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcih1cmkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogRXZlcnkga2V5L3ZhbHVlIHBhaXIgaW4gdGhpcyBjYWNoZSBpcyBzY29wZWQgdG8gdGhlIHdob2xlIHdvcmtzcGFjZS5cbiAqIElmIGFueSBkb2N1bWVudCBpbiB0aGUgd29ya3NwYWNlIGlzIGFkZGVkLCBjaGFuZ2VkIG9yIGRlbGV0ZWQsIHRoZSB3aG9sZSBjYWNoZSBpcyBldmljdGVkLlxuICovXG5leHBvcnQgY2xhc3MgV29ya3NwYWNlQ2FjaGUgZXh0ZW5kcyBTaW1wbGVDYWNoZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyB3b3Jrc3BhY2UgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2hhcmVkU2VydmljZXMgU2VydmljZSBjb250YWluZXIgaW5zdGFuY2UgdG8gaG9vayBpbnRvIGRvY3VtZW50IGxpZmVjeWNsZSBldmVudHMuXG4gICAgICogQHBhcmFtIHN0YXRlIE9wdGlvbmFsIGRvY3VtZW50IHN0YXRlIG9uIHdoaWNoIHRoZSBjYWNoZSBzaG91bGQgZXZpY3QuXG4gICAgICogSWYgbm90IHByb3ZpZGVkLCB0aGUgY2FjaGUgd2lsbCBldmljdCBvbiBgRG9jdW1lbnRCdWlsZGVyI29uVXBkYXRlYC5cbiAgICAgKiAqRGVsZXRlZCogZG9jdW1lbnRzIGFyZSBjb25zaWRlcmVkIGluIGJvdGggY2FzZXMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2hhcmVkU2VydmljZXMsIHN0YXRlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy50b0Rpc3Bvc2UucHVzaChzaGFyZWRTZXJ2aWNlcy53b3Jrc3BhY2UuRG9jdW1lbnRCdWlsZGVyLm9uQnVpbGRQaGFzZShzdGF0ZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIHRoaXMudG9EaXNwb3NlLnB1c2goc2hhcmVkU2VydmljZXMud29ya3NwYWNlLkRvY3VtZW50QnVpbGRlci5vblVwZGF0ZSgoX2NoYW5nZWQsIGRlbGV0ZWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZGVsZXRlZC5sZW5ndGggPiAwKSB7IC8vIHJlYWN0IG9ubHkgb24gZGVsZXRlZCBkb2N1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudG9EaXNwb3NlLnB1c2goc2hhcmVkU2VydmljZXMud29ya3NwYWNlLkRvY3VtZW50QnVpbGRlci5vblVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FjaGluZy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBSZWR1Y3Rpb24sIHN0cmVhbSB9IGZyb20gJy4vc3RyZWFtLmpzJztcbi8qKlxuICogQSBtdWx0aW1hcCBpcyBhIHZhcmlhdGlvbiBvZiBhIE1hcCB0aGF0IGhhcyBwb3RlbnRpYWxseSBtdWx0aXBsZSB2YWx1ZXMgZm9yIGV2ZXJ5IGtleS5cbiAqL1xuZXhwb3J0IGNsYXNzIE11bHRpTWFwIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50cykge1xuICAgICAgICB0aGlzLm1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgdmFsdWVzIGluIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFJlZHVjdGlvbi5zdW0oc3RyZWFtKHRoaXMubWFwLnZhbHVlcygpKS5tYXAoYSA9PiBhLmxlbmd0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciBhbGwgZW50cmllcyBpbiB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMubWFwLmNsZWFyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZXJhdGVzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB3aGV0aGVyIGEgYHZhbHVlYCBpcyBnaXZlbjpcbiAgICAgKiAgKiBXaXRoIGEgdmFsdWUsIHRoaXMgbWV0aG9kIGRlbGV0ZXMgdGhlIHNwZWNpZmljIGtleSAvIHZhbHVlIHBhaXIgZnJvbSB0aGUgbXVsdGltYXAuXG4gICAgICogICogV2l0aG91dCBhIHZhbHVlLCBhbGwgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5IGFyZSBkZWxldGVkLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYHRydWVgIGlmIGEgdmFsdWUgZXhpc3RlZCBhbmQgaGFzIGJlZW4gcmVtb3ZlZCwgb3IgYGZhbHNlYCBpZiB0aGUgc3BlY2lmaWVkXG4gICAgICogICAgIGtleSAvIHZhbHVlIGRvZXMgbm90IGV4aXN0LlxuICAgICAqL1xuICAgIGRlbGV0ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpbmRleCA9IHZhbHVlcy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5tYXAuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBhcnJheSBvZiBhbGwgdmFsdWVzIGFzc29jaWF0ZWQgd2l0aCB0aGUgZ2l2ZW4ga2V5LiBJZiBubyB2YWx1ZSBleGlzdHMsXG4gICAgICogYW4gZW1wdHkgYXJyYXkgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBfTm90ZTpfIFRoZSByZXR1cm5lZCBhcnJheSBpcyBhc3N1bWVkIG5vdCB0byBiZSBtb2RpZmllZC4gVXNlIHRoZSBgc2V0YCBtZXRob2QgdG8gYWRkIGFcbiAgICAgKiB2YWx1ZSBhbmQgYGRlbGV0ZWAgdG8gcmVtb3ZlIGEgdmFsdWUgZnJvbSB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgZ2V0KGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm1hcC5nZXQoa2V5KSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9wZXJhdGVzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB3aGV0aGVyIGEgYHZhbHVlYCBpcyBnaXZlbjpcbiAgICAgKiAgKiBXaXRoIGEgdmFsdWUsIHRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGlmIHRoZSBzcGVjaWZpYyBrZXkgLyB2YWx1ZSBwYWlyIGlzIHByZXNlbnQgaW4gdGhlIG11bHRpbWFwLlxuICAgICAqICAqIFdpdGhvdXQgYSB2YWx1ZSwgdGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGdpdmVuIGtleSBpcyBwcmVzZW50IGluIHRoZSBtdWx0aW1hcC5cbiAgICAgKi9cbiAgICBoYXMoa2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwLmhhcyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlcy5pbmRleE9mKHZhbHVlKSA+PSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCB0aGUgZ2l2ZW4ga2V5IC8gdmFsdWUgcGFpciB0byB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgYWRkKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMubWFwLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aGlzLm1hcC5nZXQoa2V5KS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubWFwLnNldChrZXksIFt2YWx1ZV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgdGhlIGdpdmVuIHNldCBvZiBrZXkgLyB2YWx1ZSBwYWlycyB0byB0aGUgbXVsdGltYXAuXG4gICAgICovXG4gICAgYWRkQWxsKGtleSwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0aGlzLm1hcC5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5tYXAuZ2V0KGtleSkucHVzaCguLi52YWx1ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgQXJyYXkuZnJvbSh2YWx1ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgZ2l2ZW4gY2FsbGJhY2sgZnVuY3Rpb24gZm9yIGV2ZXJ5IGtleSAvIHZhbHVlIHBhaXIgaW4gdGhlIG11bHRpbWFwLlxuICAgICAqL1xuICAgIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgICAgICB0aGlzLm1hcC5mb3JFYWNoKChhcnJheSwga2V5KSA9PiBhcnJheS5mb3JFYWNoKHZhbHVlID0+IGNhbGxiYWNrZm4odmFsdWUsIGtleSwgdGhpcykpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhbiBpdGVyYXRvciBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnRyaWVzKCkuaXRlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIHN0cmVhbSBvZiBrZXksIHZhbHVlIHBhaXJzIGZvciBldmVyeSBlbnRyeSBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGVudHJpZXMoKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0odGhpcy5tYXAuZW50cmllcygpKVxuICAgICAgICAgICAgLmZsYXRNYXAoKFtrZXksIGFycmF5XSkgPT4gYXJyYXkubWFwKHZhbHVlID0+IFtrZXksIHZhbHVlXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgc3RyZWFtIG9mIGtleXMgaW4gdGhlIG1hcC5cbiAgICAgKi9cbiAgICBrZXlzKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtKHRoaXMubWFwLmtleXMoKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2YgdmFsdWVzIGluIHRoZSBtYXAuXG4gICAgICovXG4gICAgdmFsdWVzKCkge1xuICAgICAgICByZXR1cm4gc3RyZWFtKHRoaXMubWFwLnZhbHVlcygpKS5mbGF0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBzdHJlYW0gb2Yga2V5LCB2YWx1ZSBzZXQgcGFpcnMgZm9yIGV2ZXJ5IGtleSBpbiB0aGUgbWFwLlxuICAgICAqL1xuICAgIGVudHJpZXNHcm91cGVkQnlLZXkoKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0odGhpcy5tYXAuZW50cmllcygpKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmlNYXAge1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuc2l6ZTtcbiAgICB9XG4gICAgY29uc3RydWN0b3IoZWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5tYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuaW52ZXJzZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBlbGVtZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLm1hcC5jbGVhcigpO1xuICAgICAgICB0aGlzLmludmVyc2UuY2xlYXIoKTtcbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmludmVyc2Uuc2V0KHZhbHVlLCBrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAuZ2V0KGtleSk7XG4gICAgfVxuICAgIGdldEtleSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbnZlcnNlLmdldCh2YWx1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLm1hcC5nZXQoa2V5KTtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWFwLmRlbGV0ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5pbnZlcnNlLmRlbGV0ZSh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29sbGVjdGlvbnMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgaXNDb21wb3NpdGVDc3ROb2RlLCBpc0xlYWZDc3ROb2RlLCBpc1Jvb3RDc3ROb2RlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgVHJlZVN0cmVhbUltcGwgfSBmcm9tICcuL3N0cmVhbS5qcyc7XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvZiBhbGwgQ1NUIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5IGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcm9vdCBub2RlLFxuICogaW5jbHVkaW5nIHRoZSByb290IG5vZGUgaXRzZWxmLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyZWFtQ3N0KG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRyZWVTdHJlYW1JbXBsKG5vZGUsIGVsZW1lbnQgPT4ge1xuICAgICAgICBpZiAoaXNDb21wb3NpdGVDc3ROb2RlKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudC5jb250ZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgfSwgeyBpbmNsdWRlUm9vdDogdHJ1ZSB9KTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgc3RyZWFtIG9mIGFsbCBsZWFmIG5vZGVzIHRoYXQgYXJlIGRpcmVjdGx5IGFuZCBpbmRpcmVjdGx5IGNvbnRhaW5lZCBpbiB0aGUgZ2l2ZW4gcm9vdCBub2RlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbkNzdChub2RlKSB7XG4gICAgcmV0dXJuIHN0cmVhbUNzdChub2RlKS5maWx0ZXIoaXNMZWFmQ3N0Tm9kZSk7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIGNzdCBub2RlIGlzIGEgY2hpbGQgb2YgdGhlIHNwZWNpZmllZCBwYXJlbnQgbm9kZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ2hpbGROb2RlKGNoaWxkLCBwYXJlbnQpIHtcbiAgICB3aGlsZSAoY2hpbGQuY29udGFpbmVyKSB7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuY29udGFpbmVyO1xuICAgICAgICBpZiAoY2hpbGQgPT09IHBhcmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRva2VuVG9SYW5nZSh0b2tlbikge1xuICAgIC8vIENoZXZyb3RhaW4gdXNlcyAxLWJhc2VkIGluZGljZXMgZXZlcnl3aGVyZVxuICAgIC8vIFNvIHdlIHN1YnRyYWN0IDEgZnJvbSBldmVyeSB2YWx1ZSB0byBhbGlnbiB3aXRoIHRoZSBMU1BcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgY2hhcmFjdGVyOiB0b2tlbi5zdGFydENvbHVtbiAtIDEsXG4gICAgICAgICAgICBsaW5lOiB0b2tlbi5zdGFydExpbmUgLSAxXG4gICAgICAgIH0sXG4gICAgICAgIGVuZDoge1xuICAgICAgICAgICAgY2hhcmFjdGVyOiB0b2tlbi5lbmRDb2x1bW4sIC8vIGVuZENvbHVtbiB1c2VzIHRoZSBjb3JyZWN0IGluZGV4XG4gICAgICAgICAgICBsaW5lOiB0b2tlbi5lbmRMaW5lIC0gMVxuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b0RvY3VtZW50U2VnbWVudChub2RlKSB7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHsgb2Zmc2V0LCBlbmQsIHJhbmdlIH0gPSBub2RlO1xuICAgIHJldHVybiB7XG4gICAgICAgIHJhbmdlLFxuICAgICAgICBvZmZzZXQsXG4gICAgICAgIGVuZCxcbiAgICAgICAgbGVuZ3RoOiBlbmQgLSBvZmZzZXRcbiAgICB9O1xufVxuZXhwb3J0IHZhciBSYW5nZUNvbXBhcmlzb247XG4oZnVuY3Rpb24gKFJhbmdlQ29tcGFyaXNvbikge1xuICAgIFJhbmdlQ29tcGFyaXNvbltSYW5nZUNvbXBhcmlzb25bXCJCZWZvcmVcIl0gPSAwXSA9IFwiQmVmb3JlXCI7XG4gICAgUmFuZ2VDb21wYXJpc29uW1JhbmdlQ29tcGFyaXNvbltcIkFmdGVyXCJdID0gMV0gPSBcIkFmdGVyXCI7XG4gICAgUmFuZ2VDb21wYXJpc29uW1JhbmdlQ29tcGFyaXNvbltcIk92ZXJsYXBGcm9udFwiXSA9IDJdID0gXCJPdmVybGFwRnJvbnRcIjtcbiAgICBSYW5nZUNvbXBhcmlzb25bUmFuZ2VDb21wYXJpc29uW1wiT3ZlcmxhcEJhY2tcIl0gPSAzXSA9IFwiT3ZlcmxhcEJhY2tcIjtcbiAgICBSYW5nZUNvbXBhcmlzb25bUmFuZ2VDb21wYXJpc29uW1wiSW5zaWRlXCJdID0gNF0gPSBcIkluc2lkZVwiO1xuICAgIFJhbmdlQ29tcGFyaXNvbltSYW5nZUNvbXBhcmlzb25bXCJPdXRzaWRlXCJdID0gNV0gPSBcIk91dHNpZGVcIjtcbn0pKFJhbmdlQ29tcGFyaXNvbiB8fCAoUmFuZ2VDb21wYXJpc29uID0ge30pKTtcbmV4cG9ydCBmdW5jdGlvbiBjb21wYXJlUmFuZ2UocmFuZ2UsIHRvKSB7XG4gICAgaWYgKHJhbmdlLmVuZC5saW5lIDwgdG8uc3RhcnQubGluZSB8fCAocmFuZ2UuZW5kLmxpbmUgPT09IHRvLnN0YXJ0LmxpbmUgJiYgcmFuZ2UuZW5kLmNoYXJhY3RlciA8PSB0by5zdGFydC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uQmVmb3JlO1xuICAgIH1cbiAgICBlbHNlIGlmIChyYW5nZS5zdGFydC5saW5lID4gdG8uZW5kLmxpbmUgfHwgKHJhbmdlLnN0YXJ0LmxpbmUgPT09IHRvLmVuZC5saW5lICYmIHJhbmdlLnN0YXJ0LmNoYXJhY3RlciA+PSB0by5lbmQuY2hhcmFjdGVyKSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VDb21wYXJpc29uLkFmdGVyO1xuICAgIH1cbiAgICBjb25zdCBzdGFydEluc2lkZSA9IHJhbmdlLnN0YXJ0LmxpbmUgPiB0by5zdGFydC5saW5lIHx8IChyYW5nZS5zdGFydC5saW5lID09PSB0by5zdGFydC5saW5lICYmIHJhbmdlLnN0YXJ0LmNoYXJhY3RlciA+PSB0by5zdGFydC5jaGFyYWN0ZXIpO1xuICAgIGNvbnN0IGVuZEluc2lkZSA9IHJhbmdlLmVuZC5saW5lIDwgdG8uZW5kLmxpbmUgfHwgKHJhbmdlLmVuZC5saW5lID09PSB0by5lbmQubGluZSAmJiByYW5nZS5lbmQuY2hhcmFjdGVyIDw9IHRvLmVuZC5jaGFyYWN0ZXIpO1xuICAgIGlmIChzdGFydEluc2lkZSAmJiBlbmRJbnNpZGUpIHtcbiAgICAgICAgcmV0dXJuIFJhbmdlQ29tcGFyaXNvbi5JbnNpZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKHN0YXJ0SW5zaWRlKSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uT3ZlcmxhcEJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVuZEluc2lkZSkge1xuICAgICAgICByZXR1cm4gUmFuZ2VDb21wYXJpc29uLk92ZXJsYXBGcm9udDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBSYW5nZUNvbXBhcmlzb24uT3V0c2lkZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaW5SYW5nZShyYW5nZSwgdG8pIHtcbiAgICBjb25zdCBjb21wYXJpc29uID0gY29tcGFyZVJhbmdlKHJhbmdlLCB0byk7XG4gICAgcmV0dXJuIGNvbXBhcmlzb24gPiBSYW5nZUNvbXBhcmlzb24uQWZ0ZXI7XG59XG4vLyBUaGUgXFxwe0x9IHJlZ2V4IG1hdGNoZXMgYW55IHVuaWNvZGUgbGV0dGVyIGNoYXJhY3RlciwgaS5lLiBjaGFyYWN0ZXJzIGZyb20gbm9uLWVuZ2xpc2ggYWxwaGFiZXRzXG4vLyBUb2dldGhlciB3aXRoIFxcdyBpdCBtYXRjaGVzIGFueSBraW5kIG9mIGNoYXJhY3RlciB3aGljaCBjYW4gY29tbW9ubHkgYXBwZWFyIGluIElEc1xuZXhwb3J0IGNvbnN0IERlZmF1bHROYW1lUmVnZXhwID0gL15bXFx3XFxwe0x9XSQvdTtcbi8qKlxuICogUGVyZm9ybXMgYGZpbmRMZWFmTm9kZUF0T2Zmc2V0YCB3aXRoIGEgbWlub3IgZGlmZmVyZW5jZTogV2hlbiBlbmNvdW50ZXJpbmcgYSBjaGFyYWN0ZXIgdGhhdCBtYXRjaGVzIHRoZSBgbmFtZVJlZ2V4cGAgYXJndW1lbnQsXG4gKiBpdCB3aWxsIGluc3RlYWQgcmV0dXJuIHRoZSBsZWFmIG5vZGUgYXQgdGhlIGBvZmZzZXQgLSAxYCBwb3NpdGlvbi5cbiAqXG4gKiBGb3IgTFNQIHNlcnZpY2VzLCB1c2VycyBleHBlY3QgdGhhdCB0aGUgZGVjbGFyYXRpb24gb2YgYW4gZWxlbWVudCBpcyBhdmFpbGFibGUgaWYgdGhlIGN1cnNvciBpcyBkaXJlY3RseSBhZnRlciB0aGUgZWxlbWVudC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmREZWNsYXJhdGlvbk5vZGVBdE9mZnNldChjc3ROb2RlLCBvZmZzZXQsIG5hbWVSZWdleHAgPSBEZWZhdWx0TmFtZVJlZ2V4cCkge1xuICAgIGlmIChjc3ROb2RlKSB7XG4gICAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBsb2NhbE9mZnNldCA9IG9mZnNldCAtIGNzdE5vZGUub2Zmc2V0O1xuICAgICAgICAgICAgY29uc3QgdGV4dEF0T2Zmc2V0ID0gY3N0Tm9kZS50ZXh0LmNoYXJBdChsb2NhbE9mZnNldCk7XG4gICAgICAgICAgICBpZiAoIW5hbWVSZWdleHAudGVzdCh0ZXh0QXRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpbmRMZWFmTm9kZUF0T2Zmc2V0KGNzdE5vZGUsIG9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZENvbW1lbnROb2RlKGNzdE5vZGUsIGNvbW1lbnROYW1lcykge1xuICAgIGlmIChjc3ROb2RlKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzID0gZ2V0UHJldmlvdXNOb2RlKGNzdE5vZGUsIHRydWUpO1xuICAgICAgICBpZiAocHJldmlvdXMgJiYgaXNDb21tZW50Tm9kZShwcmV2aW91cywgY29tbWVudE5hbWVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXZpb3VzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1Jvb3RDc3ROb2RlKGNzdE5vZGUpKSB7XG4gICAgICAgICAgICAvLyBHbyBmcm9tIHRoZSBmaXJzdCBub24taGlkZGVuIG5vZGUgdGhyb3VnaCBhbGwgbm9kZXMgaW4gcmV2ZXJzZSBvcmRlclxuICAgICAgICAgICAgLy8gV2UgZG8gdGhpcyB0byBmaW5kIHRoZSBjb21tZW50IG5vZGUgd2hpY2ggZGlyZWN0bHkgcHJlY2VkZXMgdGhlIHJvb3Qgbm9kZVxuICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBjc3ROb2RlLmNvbnRlbnQuZmluZEluZGV4KGUgPT4gIWUuaGlkZGVuKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBlbmRJbmRleCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGQgPSBjc3ROb2RlLmNvbnRlbnRbaV07XG4gICAgICAgICAgICAgICAgaWYgKGlzQ29tbWVudE5vZGUoY2hpbGQsIGNvbW1lbnROYW1lcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbWVudE5vZGUoY3N0Tm9kZSwgY29tbWVudE5hbWVzKSB7XG4gICAgcmV0dXJuIGlzTGVhZkNzdE5vZGUoY3N0Tm9kZSkgJiYgY29tbWVudE5hbWVzLmluY2x1ZGVzKGNzdE5vZGUudG9rZW5UeXBlLm5hbWUpO1xufVxuLyoqXG4gKiBGaW5kcyB0aGUgbGVhZiBDU1Qgbm9kZSBhdCB0aGUgc3BlY2lmaWVkIDAtYmFzZWQgc3RyaW5nIG9mZnNldC5cbiAqIE5vdGUgdGhhdCB0aGUgZ2l2ZW4gb2Zmc2V0IHdpbGwgYmUgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgcmV0dXJuZWQgbGVhZiBub2RlLlxuICpcbiAqIElmIHRoZSBvZmZzZXQgZG9lcyBub3QgcG9pbnQgdG8gYSBDU1Qgbm9kZSAoYnV0IGp1c3Qgd2hpdGUgc3BhY2UpLCB0aGlzIG1ldGhvZCB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBUaGUgQ1NUIG5vZGUgdG8gc2VhcmNoIHRocm91Z2guXG4gKiBAcGFyYW0gb2Zmc2V0IFRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICogQHJldHVybnMgVGhlIENTVCBub2RlIGF0IHRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExlYWZOb2RlQXRPZmZzZXQobm9kZSwgb2Zmc2V0KSB7XG4gICAgaWYgKGlzTGVhZkNzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQ29tcG9zaXRlQ3N0Tm9kZShub2RlKSkge1xuICAgICAgICBjb25zdCBzZWFyY2hSZXN1bHQgPSBiaW5hcnlTZWFyY2gobm9kZSwgb2Zmc2V0LCBmYWxzZSk7XG4gICAgICAgIGlmIChzZWFyY2hSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kTGVhZk5vZGVBdE9mZnNldChzZWFyY2hSZXN1bHQsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRmluZHMgdGhlIGxlYWYgQ1NUIG5vZGUgYXQgdGhlIHNwZWNpZmllZCAwLWJhc2VkIHN0cmluZyBvZmZzZXQuXG4gKiBJZiBubyBDU1Qgbm9kZSBleGlzdHMgYXQgdGhlIHNwZWNpZmllZCBwb3NpdGlvbiwgaXQgd2lsbCByZXR1cm4gdGhlIGxlYWYgbm9kZSBiZWZvcmUgaXQuXG4gKlxuICogSWYgdGhlcmUgaXMgbm8gbGVhZiBub2RlIGJlZm9yZSB0aGUgc3BlY2lmaWVkIG9mZnNldCwgdGhpcyBtZXRob2Qgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gKlxuICogQHBhcmFtIG5vZGUgVGhlIENTVCBub2RlIHRvIHNlYXJjaCB0aHJvdWdoLlxuICogQHBhcmFtIG9mZnNldCBUaGUgc3BlY2lmaWVkIG9mZnNldC5cbiAqIEByZXR1cm5zIFRoZSBDU1Qgbm9kZSBjbG9zZXN0IHRvIHRoZSBzcGVjaWZpZWQgb2Zmc2V0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZExlYWZOb2RlQmVmb3JlT2Zmc2V0KG5vZGUsIG9mZnNldCkge1xuICAgIGlmIChpc0xlYWZDc3ROb2RlKG5vZGUpKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0NvbXBvc2l0ZUNzdE5vZGUobm9kZSkpIHtcbiAgICAgICAgY29uc3Qgc2VhcmNoUmVzdWx0ID0gYmluYXJ5U2VhcmNoKG5vZGUsIG9mZnNldCwgdHJ1ZSk7XG4gICAgICAgIGlmIChzZWFyY2hSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiBmaW5kTGVhZk5vZGVCZWZvcmVPZmZzZXQoc2VhcmNoUmVzdWx0LCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBiaW5hcnlTZWFyY2gobm9kZSwgb2Zmc2V0LCBjbG9zZXN0KSB7XG4gICAgbGV0IGxlZnQgPSAwO1xuICAgIGxldCByaWdodCA9IG5vZGUuY29udGVudC5sZW5ndGggLSAxO1xuICAgIGxldCBjbG9zZXN0Tm9kZSA9IHVuZGVmaW5lZDtcbiAgICB3aGlsZSAobGVmdCA8PSByaWdodCkge1xuICAgICAgICBjb25zdCBtaWRkbGUgPSBNYXRoLmZsb29yKChsZWZ0ICsgcmlnaHQpIC8gMik7XG4gICAgICAgIGNvbnN0IG1pZGRsZU5vZGUgPSBub2RlLmNvbnRlbnRbbWlkZGxlXTtcbiAgICAgICAgaWYgKG1pZGRsZU5vZGUub2Zmc2V0IDw9IG9mZnNldCAmJiBtaWRkbGVOb2RlLmVuZCA+IG9mZnNldCkge1xuICAgICAgICAgICAgLy8gRm91bmQgYW4gZXhhY3QgbWF0Y2hcbiAgICAgICAgICAgIHJldHVybiBtaWRkbGVOb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaWRkbGVOb2RlLmVuZCA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgY2xvc2VzdCBub2RlIChsZXNzIHRoYW4gb2Zmc2V0KSBhbmQgbW92ZSB0byB0aGUgcmlnaHQgaGFsZlxuICAgICAgICAgICAgY2xvc2VzdE5vZGUgPSBjbG9zZXN0ID8gbWlkZGxlTm9kZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGxlZnQgPSBtaWRkbGUgKyAxO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTW92ZSB0byB0aGUgbGVmdCBoYWxmXG4gICAgICAgICAgICByaWdodCA9IG1pZGRsZSAtIDE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3ROb2RlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFByZXZpb3VzTm9kZShub2RlLCBoaWRkZW4gPSB0cnVlKSB7XG4gICAgd2hpbGUgKG5vZGUuY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuY29udGFpbmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBwYXJlbnQuY29udGVudC5pbmRleE9mKG5vZGUpO1xuICAgICAgICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgICAgICAgICBpbmRleC0tO1xuICAgICAgICAgICAgY29uc3QgcHJldmlvdXMgPSBwYXJlbnQuY29udGVudFtpbmRleF07XG4gICAgICAgICAgICBpZiAoaGlkZGVuIHx8ICFwcmV2aW91cy5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXROZXh0Tm9kZShub2RlLCBoaWRkZW4gPSB0cnVlKSB7XG4gICAgd2hpbGUgKG5vZGUuY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuY29udGFpbmVyO1xuICAgICAgICBsZXQgaW5kZXggPSBwYXJlbnQuY29udGVudC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBjb25zdCBsYXN0ID0gcGFyZW50LmNvbnRlbnQubGVuZ3RoIC0gMTtcbiAgICAgICAgd2hpbGUgKGluZGV4IDwgbGFzdCkge1xuICAgICAgICAgICAgaW5kZXgrKztcbiAgICAgICAgICAgIGNvbnN0IG5leHQgPSBwYXJlbnQuY29udGVudFtpbmRleF07XG4gICAgICAgICAgICBpZiAoaGlkZGVuIHx8ICFuZXh0LmhpZGRlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhcnRsaW5lTm9kZShub2RlKSB7XG4gICAgaWYgKG5vZGUucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyID09PSAwKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH1cbiAgICBjb25zdCBsaW5lID0gbm9kZS5yYW5nZS5zdGFydC5saW5lO1xuICAgIGxldCBsYXN0ID0gbm9kZTtcbiAgICBsZXQgaW5kZXg7XG4gICAgd2hpbGUgKG5vZGUuY29udGFpbmVyKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IG5vZGUuY29udGFpbmVyO1xuICAgICAgICBjb25zdCBzZWxmSW5kZXggPSBpbmRleCAhPT0gbnVsbCAmJiBpbmRleCAhPT0gdm9pZCAwID8gaW5kZXggOiBwYXJlbnQuY29udGVudC5pbmRleE9mKG5vZGUpO1xuICAgICAgICBpZiAoc2VsZkluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50O1xuICAgICAgICAgICAgaW5kZXggPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleCA9IHNlbGZJbmRleCAtIDE7XG4gICAgICAgICAgICBub2RlID0gcGFyZW50LmNvbnRlbnRbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLnJhbmdlLnN0YXJ0LmxpbmUgIT09IGxpbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGxhc3QgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gbGFzdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbnRlcmlvck5vZGVzKHN0YXJ0LCBlbmQpIHtcbiAgICBjb25zdCBjb21tb25QYXJlbnQgPSBnZXRDb21tb25QYXJlbnQoc3RhcnQsIGVuZCk7XG4gICAgaWYgKCFjb21tb25QYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gY29tbW9uUGFyZW50LnBhcmVudC5jb250ZW50LnNsaWNlKGNvbW1vblBhcmVudC5hICsgMSwgY29tbW9uUGFyZW50LmIpO1xufVxuZnVuY3Rpb24gZ2V0Q29tbW9uUGFyZW50KGEsIGIpIHtcbiAgICBjb25zdCBhUGFyZW50cyA9IGdldFBhcmVudENoYWluKGEpO1xuICAgIGNvbnN0IGJQYXJlbnRzID0gZ2V0UGFyZW50Q2hhaW4oYik7XG4gICAgbGV0IGN1cnJlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhUGFyZW50cy5sZW5ndGggJiYgaSA8IGJQYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGFQYXJlbnQgPSBhUGFyZW50c1tpXTtcbiAgICAgICAgY29uc3QgYlBhcmVudCA9IGJQYXJlbnRzW2ldO1xuICAgICAgICBpZiAoYVBhcmVudC5wYXJlbnQgPT09IGJQYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICBjdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIHBhcmVudDogYVBhcmVudC5wYXJlbnQsXG4gICAgICAgICAgICAgICAgYTogYVBhcmVudC5pbmRleCxcbiAgICAgICAgICAgICAgICBiOiBiUGFyZW50LmluZGV4XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG59XG5mdW5jdGlvbiBnZXRQYXJlbnRDaGFpbihub2RlKSB7XG4gICAgY29uc3QgY2hhaW4gPSBbXTtcbiAgICB3aGlsZSAobm9kZS5jb250YWluZXIpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9kZS5jb250YWluZXI7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gcGFyZW50LmNvbnRlbnQuaW5kZXhPZihub2RlKTtcbiAgICAgICAgY2hhaW4ucHVzaCh7XG4gICAgICAgICAgICBwYXJlbnQsXG4gICAgICAgICAgICBpbmRleFxuICAgICAgICB9KTtcbiAgICAgICAgbm9kZSA9IHBhcmVudDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYWluLnJldmVyc2UoKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzdC11dGlscy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5leHBvcnQgdmFyIERpc3Bvc2FibGU7XG4oZnVuY3Rpb24gKERpc3Bvc2FibGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpc3Bvc2U6IGFzeW5jICgpID0+IGF3YWl0IGNhbGxiYWNrKClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlzcG9zYWJsZS5jcmVhdGUgPSBjcmVhdGU7XG59KShEaXNwb3NhYmxlIHx8IChEaXNwb3NhYmxlID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRpc3Bvc2FibGUuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuZXhwb3J0IGNsYXNzIEVycm9yV2l0aExvY2F0aW9uIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobm9kZSA/IGAke21lc3NhZ2V9IGF0ICR7bm9kZS5yYW5nZS5zdGFydC5saW5lfToke25vZGUucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyfWAgOiBtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0VW5yZWFjaGFibGUoXykge1xuICAgIHRocm93IG5ldyBFcnJvcignRXJyb3IhIFRoZSBpbnB1dCB2YWx1ZSB3YXMgbm90IGhhbmRsZWQuJyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1lcnJvcnMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjMgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUsIGNyZWF0ZURlZmF1bHRTaGFyZWRDb3JlTW9kdWxlIH0gZnJvbSAnLi4vZGVmYXVsdC1tb2R1bGUuanMnO1xuaW1wb3J0IHsgaW5qZWN0IH0gZnJvbSAnLi4vZGVwZW5kZW5jeS1pbmplY3Rpb24uanMnO1xuaW1wb3J0ICogYXMgYXN0IGZyb20gJy4uL2xhbmd1YWdlcy9nZW5lcmF0ZWQvYXN0LmpzJztcbmltcG9ydCB7IEVtcHR5RmlsZVN5c3RlbSB9IGZyb20gJy4uL3dvcmtzcGFjZS9maWxlLXN5c3RlbS1wcm92aWRlci5qcyc7XG5pbXBvcnQgeyBVUkkgfSBmcm9tICcuL3VyaS11dGlscy5qcyc7XG5jb25zdCBtaW5pbWFsR3JhbW1hck1vZHVsZSA9IHtcbiAgICBHcmFtbWFyOiAoKSA9PiB1bmRlZmluZWQsXG4gICAgTGFuZ3VhZ2VNZXRhRGF0YTogKCkgPT4gKHtcbiAgICAgICAgY2FzZUluc2Vuc2l0aXZlOiBmYWxzZSxcbiAgICAgICAgZmlsZUV4dGVuc2lvbnM6IFsnLmxhbmdpdW0nXSxcbiAgICAgICAgbGFuZ3VhZ2VJZDogJ2xhbmdpdW0nXG4gICAgfSlcbn07XG5jb25zdCBtaW5pbWFsU2hhcmVkR3JhbW1hck1vZHVsZSA9IHtcbiAgICBBc3RSZWZsZWN0aW9uOiAoKSA9PiBuZXcgYXN0LkxhbmdpdW1HcmFtbWFyQXN0UmVmbGVjdGlvbigpXG59O1xuZnVuY3Rpb24gY3JlYXRlTWluaW1hbEdyYW1tYXJTZXJ2aWNlcygpIHtcbiAgICBjb25zdCBzaGFyZWQgPSBpbmplY3QoY3JlYXRlRGVmYXVsdFNoYXJlZENvcmVNb2R1bGUoRW1wdHlGaWxlU3lzdGVtKSwgbWluaW1hbFNoYXJlZEdyYW1tYXJNb2R1bGUpO1xuICAgIGNvbnN0IGdyYW1tYXIgPSBpbmplY3QoY3JlYXRlRGVmYXVsdENvcmVNb2R1bGUoeyBzaGFyZWQgfSksIG1pbmltYWxHcmFtbWFyTW9kdWxlKTtcbiAgICBzaGFyZWQuU2VydmljZVJlZ2lzdHJ5LnJlZ2lzdGVyKGdyYW1tYXIpO1xuICAgIHJldHVybiBncmFtbWFyO1xufVxuLyoqXG4gKiBMb2FkIGEgTGFuZ2l1bSBncmFtbWFyIGZvciB5b3VyIGxhbmd1YWdlIGZyb20gYSBKU09OIHN0cmluZy4gVGhpcyBpcyB1c2VkIGJ5IHNldmVyYWwgc2VydmljZXMsXG4gKiBtb3N0IG5vdGFibHkgdGhlIHBhcnNlciBidWlsZGVyIHdoaWNoIGludGVycHJldHMgdGhlIGdyYW1tYXIgdG8gY3JlYXRlIGEgcGFyc2VyLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbG9hZEdyYW1tYXJGcm9tSnNvbihqc29uKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHNlcnZpY2VzID0gY3JlYXRlTWluaW1hbEdyYW1tYXJTZXJ2aWNlcygpO1xuICAgIGNvbnN0IGFzdE5vZGUgPSBzZXJ2aWNlcy5zZXJpYWxpemVyLkpzb25TZXJpYWxpemVyLmRlc2VyaWFsaXplKGpzb24pO1xuICAgIHNlcnZpY2VzLnNoYXJlZC53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50RmFjdG9yeS5mcm9tTW9kZWwoYXN0Tm9kZSwgVVJJLnBhcnNlKGBtZW1vcnk6Ly8keyhfYSA9IGFzdE5vZGUubmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJ2dyYW1tYXInfS5sYW5naXVtYCkpO1xuICAgIHJldHVybiBhc3ROb2RlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhbW1hci1sb2FkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEtMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBhc3NlcnRVbnJlYWNoYWJsZSB9IGZyb20gJy4uL3V0aWxzL2Vycm9ycy5qcyc7XG5pbXBvcnQgKiBhcyBhc3QgZnJvbSAnLi4vbGFuZ3VhZ2VzL2dlbmVyYXRlZC9hc3QuanMnO1xuaW1wb3J0IHsgaXNDb21wb3NpdGVDc3ROb2RlIH0gZnJvbSAnLi4vc3ludGF4LXRyZWUuanMnO1xuaW1wb3J0IHsgZ2V0Q29udGFpbmVyT2ZUeXBlLCBzdHJlYW1BbGxDb250ZW50cyB9IGZyb20gJy4vYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IHN0cmVhbUNzdCB9IGZyb20gJy4vY3N0LXV0aWxzLmpzJztcbmltcG9ydCB7IGVzY2FwZVJlZ0V4cCwgaXNXaGl0ZXNwYWNlIH0gZnJvbSAnLi9yZWdleHAtdXRpbHMuanMnO1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBlbnRyeSBydWxlIG9mIHRoZSBnaXZlbiBncmFtbWFyLCBpZiBhbnkuIElmIHRoZSBncmFtbWFyIGZpbGUgZG9lcyBub3QgY29udGFpbiBhbiBlbnRyeSBydWxlLFxuICogdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEVudHJ5UnVsZShncmFtbWFyKSB7XG4gICAgcmV0dXJuIGdyYW1tYXIucnVsZXMuZmluZChlID0+IGFzdC5pc1BhcnNlclJ1bGUoZSkgJiYgZS5lbnRyeSk7XG59XG4vKipcbiAqIFJldHVybnMgYWxsIGhpZGRlbiB0ZXJtaW5hbCBydWxlcyBvZiB0aGUgZ2l2ZW4gZ3JhbW1hciwgaWYgYW55LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0SGlkZGVuUnVsZXMoZ3JhbW1hcikge1xuICAgIHJldHVybiBncmFtbWFyLnJ1bGVzLmZpbHRlcigoZSkgPT4gYXN0LmlzVGVybWluYWxSdWxlKGUpICYmIGUuaGlkZGVuKTtcbn1cbi8qKlxuICogUmV0dXJucyBhbGwgcnVsZXMgdGhhdCBjYW4gYmUgcmVhY2hlZCBmcm9tIHRoZSB0b3Btb3N0IHJ1bGVzIG9mIHRoZSBzcGVjaWZpZWQgZ3JhbW1hciAoZW50cnkgYW5kIGhpZGRlbiB0ZXJtaW5hbCBydWxlcykuXG4gKlxuICogQHBhcmFtIGdyYW1tYXIgVGhlIGdyYW1tYXIgdGhhdCBjb250YWlucyBhbGwgcnVsZXNcbiAqIEBwYXJhbSBhbGxUZXJtaW5hbHMgV2hldGhlciBvciBub3QgdG8gaW5jbHVkZSB0ZXJtaW5hbHMgdGhhdCBhcmUgcmVmZXJlbmNlZCBvbmx5IGJ5IG90aGVyIHRlcm1pbmFsc1xuICogQHJldHVybnMgQSBsaXN0IG9mIHJlZmVyZW5jZWQgcGFyc2VyIGFuZCB0ZXJtaW5hbCBydWxlcy4gSWYgdGhlIGdyYW1tYXIgY29udGFpbnMgbm8gZW50cnkgcnVsZSxcbiAqICAgICAgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGFsbCBydWxlcyBvZiB0aGUgc3BlY2lmaWVkIGdyYW1tYXIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRBbGxSZWFjaGFibGVSdWxlcyhncmFtbWFyLCBhbGxUZXJtaW5hbHMpIHtcbiAgICBjb25zdCBydWxlTmFtZXMgPSBuZXcgU2V0KCk7XG4gICAgY29uc3QgZW50cnlSdWxlID0gZ2V0RW50cnlSdWxlKGdyYW1tYXIpO1xuICAgIGlmICghZW50cnlSdWxlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU2V0KGdyYW1tYXIucnVsZXMpO1xuICAgIH1cbiAgICBjb25zdCB0b3BNb3N0UnVsZXMgPSBbZW50cnlSdWxlXS5jb25jYXQoZ2V0SGlkZGVuUnVsZXMoZ3JhbW1hcikpO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiB0b3BNb3N0UnVsZXMpIHtcbiAgICAgICAgcnVsZURmcyhydWxlLCBydWxlTmFtZXMsIGFsbFRlcm1pbmFscyk7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGVzID0gbmV3IFNldCgpO1xuICAgIGZvciAoY29uc3QgcnVsZSBvZiBncmFtbWFyLnJ1bGVzKSB7XG4gICAgICAgIGlmIChydWxlTmFtZXMuaGFzKHJ1bGUubmFtZSkgfHwgKGFzdC5pc1Rlcm1pbmFsUnVsZShydWxlKSAmJiBydWxlLmhpZGRlbikpIHtcbiAgICAgICAgICAgIHJ1bGVzLmFkZChydWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnVsZXM7XG59XG5mdW5jdGlvbiBydWxlRGZzKHJ1bGUsIHZpc2l0ZWRTZXQsIGFsbFRlcm1pbmFscykge1xuICAgIHZpc2l0ZWRTZXQuYWRkKHJ1bGUubmFtZSk7XG4gICAgc3RyZWFtQWxsQ29udGVudHMocnVsZSkuZm9yRWFjaChub2RlID0+IHtcbiAgICAgICAgaWYgKGFzdC5pc1J1bGVDYWxsKG5vZGUpIHx8IChhbGxUZXJtaW5hbHMgJiYgYXN0LmlzVGVybWluYWxSdWxlQ2FsbChub2RlKSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZlJ1bGUgPSBub2RlLnJ1bGUucmVmO1xuICAgICAgICAgICAgaWYgKHJlZlJ1bGUgJiYgIXZpc2l0ZWRTZXQuaGFzKHJlZlJ1bGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICBydWxlRGZzKHJlZlJ1bGUsIHZpc2l0ZWRTZXQsIGFsbFRlcm1pbmFscyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgZ3JhbW1hciBleHByZXNzaW9uIHVzZWQgdG8gcGFyc2UgYSBjcm9zcy1yZWZlcmVuY2UgKHVzdWFsbHkgYSByZWZlcmVuY2UgdG8gYSB0ZXJtaW5hbCBydWxlKS5cbiAqIEEgY3Jvc3MtcmVmZXJlbmNlIGNhbiBkZWNsYXJlIHRoaXMgZXhwcmVzc2lvbiBleHBsaWNpdGx5IGluIHRoZSBmb3JtIGBbVHlwZSA6IFRlcm1pbmFsXWAsIGJ1dCBpZiBgVGVybWluYWxgXG4gKiBpcyBvbWl0dGVkLCB0aGlzIGZ1bmN0aW9uIGF0dGVtcHRzIHRvIGluZmVyIGl0IGZyb20gdGhlIG5hbWUgb2YgdGhlIHJlZmVyZW5jZWQgYFR5cGVgICh1c2luZyBgZmluZE5hbWVBc3NpZ25tZW50YCkuXG4gKlxuICogUmV0dXJucyB0aGUgZ3JhbW1hciBleHByZXNzaW9uIHVzZWQgdG8gcGFyc2UgdGhlIGdpdmVuIGNyb3NzLXJlZmVyZW5jZSwgb3IgYHVuZGVmaW5lZGAgaWYgaXQgaXMgbm90IGRlY2xhcmVkXG4gKiBhbmQgY2Fubm90IGJlIGluZmVycmVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q3Jvc3NSZWZlcmVuY2VUZXJtaW5hbChjcm9zc1JlZikge1xuICAgIGlmIChjcm9zc1JlZi50ZXJtaW5hbCkge1xuICAgICAgICByZXR1cm4gY3Jvc3NSZWYudGVybWluYWw7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNyb3NzUmVmLnR5cGUucmVmKSB7XG4gICAgICAgIGNvbnN0IG5hbWVBc3NpZ21lbnQgPSBmaW5kTmFtZUFzc2lnbm1lbnQoY3Jvc3NSZWYudHlwZS5yZWYpO1xuICAgICAgICByZXR1cm4gbmFtZUFzc2lnbWVudCA9PT0gbnVsbCB8fCBuYW1lQXNzaWdtZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYW1lQXNzaWdtZW50LnRlcm1pbmFsO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIHRlcm1pbmFsIHJ1bGUgcmVwcmVzZW50cyBhIGNvbW1lbnQuIFRoaXMgaXMgdHJ1ZSBpZiB0aGUgcnVsZSBpcyBtYXJrZWRcbiAqIGFzIGBoaWRkZW5gIGFuZCBpdCBkb2VzIG5vdCBtYXRjaCB3aGl0ZSBzcGFjZS4gVGhpcyBtZWFucyBldmVyeSBoaWRkZW4gdG9rZW4gKGkuZS4gZXhjbHVkZWQgZnJvbSB0aGUgQVNUKVxuICogdGhhdCBjb250YWlucyB2aXNpYmxlIGNoYXJhY3RlcnMgaXMgY29uc2lkZXJlZCBhIGNvbW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW1lbnRUZXJtaW5hbCh0ZXJtaW5hbFJ1bGUpIHtcbiAgICByZXR1cm4gdGVybWluYWxSdWxlLmhpZGRlbiAmJiAhaXNXaGl0ZXNwYWNlKHRlcm1pbmFsUmVnZXgodGVybWluYWxSdWxlKSk7XG59XG4vKipcbiAqIEZpbmQgYWxsIENTVCBub2RlcyB3aXRoaW4gdGhlIGdpdmVuIG5vZGUgdGhhdCBjb250cmlidXRlIHRvIHRoZSBzcGVjaWZpZWQgcHJvcGVydHkuXG4gKlxuICogQHBhcmFtIG5vZGUgQSBDU1Qgbm9kZSBpbiB3aGljaCB0byBsb29rIGZvciBwcm9wZXJ0eSBhc3NpZ25tZW50cy4gSWYgdGhpcyBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgYXJyYXkuXG4gKiBAcGFyYW0gcHJvcGVydHkgQSBwcm9wZXJ0eSBuYW1lIG9mIHRoZSBjb25zdHJ1Y3RlZCBBU1Qgbm9kZS4gSWYgdGhpcyBpcyB1bmRlZmluZWQsIHRoZSByZXN1bHQgaXMgYW4gZW1wdHkgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kTm9kZXNGb3JQcm9wZXJ0eShub2RlLCBwcm9wZXJ0eSkge1xuICAgIGlmICghbm9kZSB8fCAhcHJvcGVydHkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICByZXR1cm4gZmluZE5vZGVzRm9yUHJvcGVydHlJbnRlcm5hbChub2RlLCBwcm9wZXJ0eSwgbm9kZS5hc3ROb2RlLCB0cnVlKTtcbn1cbi8qKlxuICogRmluZCBhIHNpbmdsZSBDU1Qgbm9kZSB3aXRoaW4gdGhlIGdpdmVuIG5vZGUgdGhhdCBjb250cmlidXRlcyB0byB0aGUgc3BlY2lmaWVkIHByb3BlcnR5LlxuICpcbiAqIEBwYXJhbSBub2RlIEEgQ1NUIG5vZGUgaW4gd2hpY2ggdG8gbG9vayBmb3IgcHJvcGVydHkgYXNzaWdubWVudHMuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGB1bmRlZmluZWRgLlxuICogQHBhcmFtIHByb3BlcnR5IEEgcHJvcGVydHkgbmFtZSBvZiB0aGUgY29uc3RydWN0ZWQgQVNUIG5vZGUuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGB1bmRlZmluZWRgLlxuICogQHBhcmFtIGluZGV4IElmIG5vIGluZGV4IGlzIHNwZWNpZmllZCBvciB0aGUgaW5kZXggaXMgbGVzcyB0aGFuIHplcm8sIHRoZSBmaXJzdCBmb3VuZCBub2RlIGlzIHJldHVybmVkLiBJZiB0aGVcbiAqICAgICAgICBzcGVjaWZpZWQgaW5kZXggZXhjZWVkcyB0aGUgbnVtYmVyIG9mIGFzc2lnbm1lbnRzIHRvIHRoZSBwcm9wZXJ0eSwgdGhlIGxhc3QgZm91bmQgbm9kZSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLFxuICogICAgICAgIHRoZSBub2RlIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleCBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2RlRm9yUHJvcGVydHkobm9kZSwgcHJvcGVydHksIGluZGV4KSB7XG4gICAgaWYgKCFub2RlIHx8ICFwcm9wZXJ0eSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IGZpbmROb2Rlc0ZvclByb3BlcnR5SW50ZXJuYWwobm9kZSwgcHJvcGVydHksIG5vZGUuYXN0Tm9kZSwgdHJ1ZSk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBub2Rlcy5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1tpbmRleF07XG59XG5mdW5jdGlvbiBmaW5kTm9kZXNGb3JQcm9wZXJ0eUludGVybmFsKG5vZGUsIHByb3BlcnR5LCBlbGVtZW50LCBmaXJzdCkge1xuICAgIGlmICghZmlyc3QpIHtcbiAgICAgICAgY29uc3Qgbm9kZUZlYXR1cmUgPSBnZXRDb250YWluZXJPZlR5cGUobm9kZS5ncmFtbWFyU291cmNlLCBhc3QuaXNBc3NpZ25tZW50KTtcbiAgICAgICAgaWYgKG5vZGVGZWF0dXJlICYmIG5vZGVGZWF0dXJlLmZlYXR1cmUgPT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gW25vZGVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChpc0NvbXBvc2l0ZUNzdE5vZGUobm9kZSkgJiYgbm9kZS5hc3ROb2RlID09PSBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBub2RlLmNvbnRlbnQuZmxhdE1hcChlID0+IGZpbmROb2Rlc0ZvclByb3BlcnR5SW50ZXJuYWwoZSwgcHJvcGVydHksIGVsZW1lbnQsIGZhbHNlKSk7XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8qKlxuICogRmluZCBhbGwgQ1NUIG5vZGVzIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSB0aGF0IGNvcnJlc3BvbmQgdG8gdGhlIHNwZWNpZmllZCBrZXl3b3JkLlxuICpcbiAqIEBwYXJhbSBub2RlIEEgQ1NUIG5vZGUgaW4gd2hpY2ggdG8gbG9vayBmb3Iga2V5d29yZHMuIElmIHRoaXMgaXMgdW5kZWZpbmVkLCB0aGUgcmVzdWx0IGlzIGFuIGVtcHR5IGFycmF5LlxuICogQHBhcmFtIGtleXdvcmQgQSBrZXl3b3JkIGFzIHNwZWNpZmllZCBpbiB0aGUgZ3JhbW1hci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2Rlc0ZvcktleXdvcmQobm9kZSwga2V5d29yZCkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBmaW5kTm9kZXNGb3JLZXl3b3JkSW50ZXJuYWwobm9kZSwga2V5d29yZCwgbm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBub2RlLmFzdE5vZGUpO1xufVxuLyoqXG4gKiBGaW5kIGEgc2luZ2xlIENTVCBub2RlIHdpdGhpbiB0aGUgZ2l2ZW4gbm9kZSB0aGF0IGNvcnJlc3BvbmRzIHRvIHRoZSBzcGVjaWZpZWQga2V5d29yZC5cbiAqXG4gKiBAcGFyYW0gbm9kZSBBIENTVCBub2RlIGluIHdoaWNoIHRvIGxvb2sgZm9yIGtleXdvcmRzLiBJZiB0aGlzIGlzIHVuZGVmaW5lZCwgdGhlIHJlc3VsdCBpcyBgdW5kZWZpbmVkYC5cbiAqIEBwYXJhbSBrZXl3b3JkIEEga2V5d29yZCBhcyBzcGVjaWZpZWQgaW4gdGhlIGdyYW1tYXIuXG4gKiBAcGFyYW0gaW5kZXggSWYgbm8gaW5kZXggaXMgc3BlY2lmaWVkIG9yIHRoZSBpbmRleCBpcyBsZXNzIHRoYW4gemVybywgdGhlIGZpcnN0IGZvdW5kIG5vZGUgaXMgcmV0dXJuZWQuIElmIHRoZVxuICogICAgICAgIHNwZWNpZmllZCBpbmRleCBleGNlZWRzIHRoZSBudW1iZXIgb2Yga2V5d29yZCBvY2N1cnJlbmNlcywgdGhlIGxhc3QgZm91bmQgbm9kZSBpcyByZXR1cm5lZC4gT3RoZXJ3aXNlLFxuICogICAgICAgIHRoZSBub2RlIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleCBpcyByZXR1cm5lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROb2RlRm9yS2V5d29yZChub2RlLCBrZXl3b3JkLCBpbmRleCkge1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBub2RlcyA9IGZpbmROb2Rlc0ZvcktleXdvcmRJbnRlcm5hbChub2RlLCBrZXl3b3JkLCBub2RlID09PSBudWxsIHx8IG5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG5vZGUuYXN0Tm9kZSk7XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IE1hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBub2Rlcy5sZW5ndGggLSAxKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpbmRleCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBub2Rlc1tpbmRleF07XG59XG5leHBvcnQgZnVuY3Rpb24gZmluZE5vZGVzRm9yS2V5d29yZEludGVybmFsKG5vZGUsIGtleXdvcmQsIGVsZW1lbnQpIHtcbiAgICBpZiAobm9kZS5hc3ROb2RlICE9PSBlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGFzdC5pc0tleXdvcmQobm9kZS5ncmFtbWFyU291cmNlKSAmJiBub2RlLmdyYW1tYXJTb3VyY2UudmFsdWUgPT09IGtleXdvcmQpIHtcbiAgICAgICAgcmV0dXJuIFtub2RlXTtcbiAgICB9XG4gICAgY29uc3QgdHJlZUl0ZXJhdG9yID0gc3RyZWFtQ3N0KG5vZGUpLml0ZXJhdG9yKCk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBjb25zdCBrZXl3b3JkTm9kZXMgPSBbXTtcbiAgICBkbyB7XG4gICAgICAgIHJlc3VsdCA9IHRyZWVJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkTm9kZSA9IHJlc3VsdC52YWx1ZTtcbiAgICAgICAgICAgIGlmIChjaGlsZE5vZGUuYXN0Tm9kZSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGlmIChhc3QuaXNLZXl3b3JkKGNoaWxkTm9kZS5ncmFtbWFyU291cmNlKSAmJiBjaGlsZE5vZGUuZ3JhbW1hclNvdXJjZS52YWx1ZSA9PT0ga2V5d29yZCkge1xuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkTm9kZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyZWVJdGVyYXRvci5wcnVuZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSB3aGlsZSAoIXJlc3VsdC5kb25lKTtcbiAgICByZXR1cm4ga2V5d29yZE5vZGVzO1xufVxuLyoqXG4gKiBJZiB0aGUgZ2l2ZW4gQ1NUIG5vZGUgd2FzIHBhcnNlZCBpbiB0aGUgY29udGV4dCBvZiBhIHByb3BlcnR5IGFzc2lnbm1lbnQsIHRoZSByZXNwZWN0aXZlIGBBc3NpZ25tZW50YCBncmFtbWFyXG4gKiBub2RlIGlzIHJldHVybmVkLiBJZiBubyBhc3NpZ25tZW50IGlzIGZvdW5kLCB0aGUgcmVzdWx0IGlzIGB1bmRlZmluZWRgLlxuICpcbiAqIEBwYXJhbSBjc3ROb2RlIEEgQ1NUIG5vZGUgZm9yIHdoaWNoIHRvIGZpbmQgYSBwcm9wZXJ0eSBhc3NpZ25tZW50LlxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEFzc2lnbm1lbnQoY3N0Tm9kZSkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBhc3ROb2RlID0gY3N0Tm9kZS5hc3ROb2RlO1xuICAgIC8vIE9ubHkgc2VhcmNoIHVudGlsIHRoZSBhc3Qgbm9kZSBvZiB0aGUgcGFyZW50IGNzdCBub2RlIGlzIG5vIGxvbmdlciB0aGUgb3JpZ2luYWwgYXN0IG5vZGVcbiAgICAvLyBUaGlzIHdvdWxkIG1ha2UgdXMganVtcCB0byBhIHByZWNlZGluZyBydWxlIGNhbGwsIHdoaWNoIGNvbnRhaW5zIG9ubHkgdW5yZWxhdGVkIGFzc2lnbm1lbnRzXG4gICAgd2hpbGUgKGFzdE5vZGUgPT09ICgoX2EgPSBjc3ROb2RlLmNvbnRhaW5lcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFzdE5vZGUpKSB7XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnQgPSBnZXRDb250YWluZXJPZlR5cGUoY3N0Tm9kZS5ncmFtbWFyU291cmNlLCBhc3QuaXNBc3NpZ25tZW50KTtcbiAgICAgICAgaWYgKGFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBhc3NpZ25tZW50O1xuICAgICAgICB9XG4gICAgICAgIGNzdE5vZGUgPSBjc3ROb2RlLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cbi8qKlxuICogRmluZCBhbiBhc3NpZ25tZW50IHRvIHRoZSBgbmFtZWAgcHJvcGVydHkgZm9yIHRoZSBnaXZlbiBncmFtbWFyIHR5cGUuIFRoaXMgcmVxdWlyZXMgdGhlIGB0eXBlYCB0byBiZSBpbmZlcnJlZFxuICogZnJvbSBhIHBhcnNlciBydWxlLCBhbmQgdGhhdCBydWxlIG11c3QgY29udGFpbiBhbiBhc3NpZ25tZW50IHRvIHRoZSBgbmFtZWAgcHJvcGVydHkuIEluIGFsbCBvdGhlciBjYXNlcyxcbiAqIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGZpbmROYW1lQXNzaWdubWVudCh0eXBlKSB7XG4gICAgbGV0IHN0YXJ0Tm9kZSA9IHR5cGU7XG4gICAgaWYgKGFzdC5pc0luZmVycmVkVHlwZShzdGFydE5vZGUpKSB7XG4gICAgICAgIC8vIGZvciBpbmZlcnJlZCB0eXBlcywgdGhlIGxvY2F0aW9uIHRvIHN0YXJ0IHNlYXJjaGluZyBmb3IgdGhlIG5hbWUtYXNzaWdubWVudCBpcyBkaWZmZXJlbnRcbiAgICAgICAgaWYgKGFzdC5pc0FjdGlvbihzdGFydE5vZGUuJGNvbnRhaW5lcikpIHtcbiAgICAgICAgICAgIC8vIGEgdHlwZSB3aGljaCBpcyBleHBsaWNpdGx5IGluZmVycmVkIGJ5IGFuIGFjdGlvbjogaW52ZXN0aWdhdGUgdGhlIHNpYmJsaW5nIG9mIHRoZSBBY3Rpb24gbm9kZSwgaS5lLiBzdGFydCBzZWFyY2hpbmcgYXQgdGhlIEFjdGlvbidzIHBhcmVudFxuICAgICAgICAgICAgc3RhcnROb2RlID0gc3RhcnROb2RlLiRjb250YWluZXIuJGNvbnRhaW5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuaXNQYXJzZXJSdWxlKHN0YXJ0Tm9kZS4kY29udGFpbmVyKSkge1xuICAgICAgICAgICAgLy8gaW52ZXN0aWdhdGUgdGhlIHBhcnNlciBydWxlIHdpdGggdGhlIGV4cGxpY2l0bHkgaW5mZXJyZWQgdHlwZVxuICAgICAgICAgICAgc3RhcnROb2RlID0gc3RhcnROb2RlLiRjb250YWluZXI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhc3NlcnRVbnJlYWNoYWJsZShzdGFydE5vZGUuJGNvbnRhaW5lcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpbmROYW1lQXNzaWdubWVudEludGVybmFsKHR5cGUsIHN0YXJ0Tm9kZSwgbmV3IE1hcCgpKTtcbn1cbmZ1bmN0aW9uIGZpbmROYW1lQXNzaWdubWVudEludGVybmFsKHR5cGUsIHN0YXJ0Tm9kZSwgY2FjaGUpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gdGhlIGNhY2hlIGlzIG9ubHkgcmVxdWlyZWQgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wc1xuICAgIGZ1bmN0aW9uIGdvKG5vZGUsIHJlZlR5cGUpIHtcbiAgICAgICAgbGV0IGNoaWxkQXNzaWdubWVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcGFyZW50QXNzaWdubWVudCA9IGdldENvbnRhaW5lck9mVHlwZShub2RlLCBhc3QuaXNBc3NpZ25tZW50KTtcbiAgICAgICAgLy8gTm8gcGFyZW50IGFzc2lnbm1lbnQgaW1wbGllcyB1bmFzc2lnbmVkIHJ1bGUgY2FsbFxuICAgICAgICBpZiAoIXBhcmVudEFzc2lnbm1lbnQpIHtcbiAgICAgICAgICAgIGNoaWxkQXNzaWdubWVudCA9IGZpbmROYW1lQXNzaWdubWVudEludGVybmFsKHJlZlR5cGUsIHJlZlR5cGUsIGNhY2hlKTtcbiAgICAgICAgfVxuICAgICAgICBjYWNoZS5zZXQodHlwZSwgY2hpbGRBc3NpZ25tZW50KTtcbiAgICAgICAgcmV0dXJuIGNoaWxkQXNzaWdubWVudDtcbiAgICB9XG4gICAgaWYgKGNhY2hlLmhhcyh0eXBlKSkge1xuICAgICAgICByZXR1cm4gY2FjaGUuZ2V0KHR5cGUpO1xuICAgIH1cbiAgICBjYWNoZS5zZXQodHlwZSwgdW5kZWZpbmVkKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygc3RyZWFtQWxsQ29udGVudHMoc3RhcnROb2RlKSkge1xuICAgICAgICBpZiAoYXN0LmlzQXNzaWdubWVudChub2RlKSAmJiBub2RlLmZlYXR1cmUudG9Mb3dlckNhc2UoKSA9PT0gJ25hbWUnKSB7XG4gICAgICAgICAgICBjYWNoZS5zZXQodHlwZSwgbm9kZSk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhc3QuaXNSdWxlQ2FsbChub2RlKSAmJiBhc3QuaXNQYXJzZXJSdWxlKG5vZGUucnVsZS5yZWYpKSB7XG4gICAgICAgICAgICByZXR1cm4gZ28obm9kZSwgbm9kZS5ydWxlLnJlZik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmlzU2ltcGxlVHlwZShub2RlKSAmJiAoKF9hID0gbm9kZS50eXBlUmVmKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVmKSkge1xuICAgICAgICAgICAgcmV0dXJuIGdvKG5vZGUsIG5vZGUudHlwZVJlZi5yZWYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWN0aW9uQXRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICBjb25zdCBwYXJlbnQgPSBlbGVtZW50LiRjb250YWluZXI7XG4gICAgaWYgKGFzdC5pc0dyb3VwKHBhcmVudCkpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwYXJlbnQuZWxlbWVudHM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBlbGVtZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChhc3QuaXNBY3Rpb24oaXRlbSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGlvbiA9IHN0cmVhbUFsbENvbnRlbnRzKGVsZW1lbnRzW2ldKS5maW5kKGFzdC5pc0FjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWN0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYXN0LmlzQWJzdHJhY3RFbGVtZW50KHBhcmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGdldEFjdGlvbkF0RWxlbWVudChwYXJlbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNPcHRpb25hbENhcmRpbmFsaXR5KGNhcmRpbmFsaXR5LCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGNhcmRpbmFsaXR5ID09PSAnPycgfHwgY2FyZGluYWxpdHkgPT09ICcqJyB8fCAoYXN0LmlzR3JvdXAoZWxlbWVudCkgJiYgQm9vbGVhbihlbGVtZW50Lmd1YXJkQ29uZGl0aW9uKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBcnJheUNhcmRpbmFsaXR5KGNhcmRpbmFsaXR5KSB7XG4gICAgcmV0dXJuIGNhcmRpbmFsaXR5ID09PSAnKicgfHwgY2FyZGluYWxpdHkgPT09ICcrJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0FycmF5T3BlcmF0b3Iob3BlcmF0b3IpIHtcbiAgICByZXR1cm4gb3BlcmF0b3IgPT09ICcrPSc7XG59XG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgZ2l2ZW4gcGFyc2VyIHJ1bGUgaXMgYSBfZGF0YSB0eXBlIHJ1bGVfLCBtZWFuaW5nIHRoYXQgaXQgaGFzIGFcbiAqIHByaW1pdGl2ZSByZXR1cm4gdHlwZSBsaWtlIGBudW1iZXJgLCBgYm9vbGVhbmAsIGV0Yy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzRGF0YVR5cGVSdWxlKHJ1bGUpIHtcbiAgICByZXR1cm4gaXNEYXRhVHlwZVJ1bGVJbnRlcm5hbChydWxlLCBuZXcgU2V0KCkpO1xufVxuZnVuY3Rpb24gaXNEYXRhVHlwZVJ1bGVJbnRlcm5hbChydWxlLCB2aXNpdGVkKSB7XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHJ1bGUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlzaXRlZC5hZGQocnVsZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBzdHJlYW1BbGxDb250ZW50cyhydWxlKSkge1xuICAgICAgICBpZiAoYXN0LmlzUnVsZUNhbGwobm9kZSkpIHtcbiAgICAgICAgICAgIGlmICghbm9kZS5ydWxlLnJlZikge1xuICAgICAgICAgICAgICAgIC8vIFJ1bGVDYWxsIHRvIHVucmVzb2x2ZWQgcnVsZS4gRG9uJ3QgYXNzdW1lIGBydWxlYCBpcyBhIERhdGFUeXBlIHJ1bGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzdC5pc1BhcnNlclJ1bGUobm9kZS5ydWxlLnJlZikgJiYgIWlzRGF0YVR5cGVSdWxlSW50ZXJuYWwobm9kZS5ydWxlLnJlZiwgdmlzaXRlZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXN0LmlzQXNzaWdubWVudChub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGFzdC5pc0FjdGlvbihub2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBCb29sZWFuKHJ1bGUuZGVmaW5pdGlvbik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNEYXRhVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuIGlzRGF0YVR5cGVJbnRlcm5hbCh0eXBlLnR5cGUsIG5ldyBTZXQoKSk7XG59XG5mdW5jdGlvbiBpc0RhdGFUeXBlSW50ZXJuYWwodHlwZSwgdmlzaXRlZCkge1xuICAgIGlmICh2aXNpdGVkLmhhcyh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpc2l0ZWQuYWRkKHR5cGUpO1xuICAgIH1cbiAgICBpZiAoYXN0LmlzQXJyYXlUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzUmVmZXJlbmNlVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1VuaW9uVHlwZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gdHlwZS50eXBlcy5ldmVyeShlID0+IGlzRGF0YVR5cGVJbnRlcm5hbChlLCB2aXNpdGVkKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1NpbXBsZVR5cGUodHlwZSkpIHtcbiAgICAgICAgaWYgKHR5cGUucHJpbWl0aXZlVHlwZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlLnN0cmluZ1R5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZS50eXBlUmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlZiA9IHR5cGUudHlwZVJlZi5yZWY7XG4gICAgICAgICAgICBpZiAoYXN0LmlzVHlwZShyZWYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlzRGF0YVR5cGVJbnRlcm5hbChyZWYudHlwZSwgdmlzaXRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RXhwbGljaXRSdWxlVHlwZShydWxlKSB7XG4gICAgaWYgKHJ1bGUuaW5mZXJyZWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBydWxlLmluZmVycmVkVHlwZS5uYW1lO1xuICAgIH1cbiAgICBlbHNlIGlmIChydWxlLmRhdGFUeXBlKSB7XG4gICAgICAgIHJldHVybiBydWxlLmRhdGFUeXBlO1xuICAgIH1cbiAgICBlbHNlIGlmIChydWxlLnJldHVyblR5cGUpIHtcbiAgICAgICAgY29uc3QgcmVmVHlwZSA9IHJ1bGUucmV0dXJuVHlwZS5yZWY7XG4gICAgICAgIGlmIChyZWZUeXBlKSB7XG4gICAgICAgICAgICAvLyBjaGVjayBpZiB3ZSBuZWVkIHRvIGNoZWNrIEFjdGlvbiBhcyByZXR1cm4gdHlwZVxuICAgICAgICAgICAgaWYgKGFzdC5pc1BhcnNlclJ1bGUocmVmVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmVHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXN0LmlzSW50ZXJmYWNlKHJlZlR5cGUpIHx8IGFzdC5pc1R5cGUocmVmVHlwZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVmVHlwZS5uYW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0VHlwZU5hbWUodHlwZSkge1xuICAgIHZhciBfYTtcbiAgICBpZiAoYXN0LmlzUGFyc2VyUnVsZSh0eXBlKSkge1xuICAgICAgICByZXR1cm4gaXNEYXRhVHlwZVJ1bGUodHlwZSkgPyB0eXBlLm5hbWUgOiAoX2EgPSBnZXRFeHBsaWNpdFJ1bGVUeXBlKHR5cGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0eXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc0ludGVyZmFjZSh0eXBlKSB8fCBhc3QuaXNUeXBlKHR5cGUpIHx8IGFzdC5pc1JldHVyblR5cGUodHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHR5cGUubmFtZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzQWN0aW9uKHR5cGUpKSB7XG4gICAgICAgIGNvbnN0IGFjdGlvblR5cGUgPSBnZXRBY3Rpb25UeXBlKHR5cGUpO1xuICAgICAgICBpZiAoYWN0aW9uVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFjdGlvblR5cGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzSW5mZXJyZWRUeXBlKHR5cGUpKSB7XG4gICAgICAgIHJldHVybiB0eXBlLm5hbWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGdldCBuYW1lIG9mIFVua25vd24gVHlwZScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGlvblR5cGUoYWN0aW9uKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChhY3Rpb24uaW5mZXJyZWRUeXBlKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uaW5mZXJyZWRUeXBlLm5hbWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKChfYSA9IGFjdGlvbi50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVmKSB7XG4gICAgICAgIHJldHVybiBnZXRUeXBlTmFtZShhY3Rpb24udHlwZS5yZWYpO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkOyAvLyBub3QgaW5mZXJyaW5nIGFuZCBub3QgcmVmZXJlbmNpbmcgYSB2YWxpZCB0eXBlXG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBhdCBkZXZlbG9wbWVudCB0aW1lIChmb3IgY29kZSBnZW5lcmF0aW9uIGFuZCB0aGUgaW50ZXJuYWwgdHlwZSBzeXN0ZW0pIHRvIGdldCB0aGUgdHlwZSBvZiB0aGUgQVNUIG5vZGUgcHJvZHVjZWQgYnkgdGhlIGdpdmVuIHJ1bGUuXG4gKiBGb3IgZGF0YSB0eXBlIHJ1bGVzLCB0aGUgbmFtZSBvZiB0aGUgcnVsZSBpcyByZXR1cm5lZCxcbiAqIGUuZy4gXCJJTlRfdmFsdWUgcmV0dXJucyBudW1iZXI6IE1ZX0lOVDtcIiByZXR1cm5zIFwiSU5UX3ZhbHVlXCIuXG4gKiBAcGFyYW0gcnVsZSB0aGUgZ2l2ZW4gcnVsZVxuICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIEFTVCBub2RlIHR5cGUgb2YgdGhlIHJ1bGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFJ1bGVUeXBlTmFtZShydWxlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKGFzdC5pc1Rlcm1pbmFsUnVsZShydWxlKSkge1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gcnVsZS50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3N0cmluZyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gaXNEYXRhVHlwZVJ1bGUocnVsZSkgPyBydWxlLm5hbWUgOiAoX2MgPSBnZXRFeHBsaWNpdFJ1bGVUeXBlKHJ1bGUpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBydWxlLm5hbWU7XG4gICAgfVxufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgYXQgcnVudGltZSB0byBnZXQgdGhlIGFjdHVhbCB0eXBlIG9mIHRoZSB2YWx1ZXMgcHJvZHVjZWQgYnkgdGhlIGdpdmVuIHJ1bGUgYXQgcnVudGltZS5cbiAqIEZvciBkYXRhIHR5cGUgcnVsZXMsIHRoZSBuYW1lIG9mIHRoZSBkZWNsYXJlZCByZXR1cm4gdHlwZSBvZiB0aGUgcnVsZSBpcyByZXR1cm5lZCAoaWYgYW55KSxcbiAqIGUuZy4gXCJJTlRfdmFsdWUgcmV0dXJucyBudW1iZXI6IE1ZX0lOVDtcIiByZXR1cm5zIFwibnVtYmVyXCIuXG4gKiBAcGFyYW0gcnVsZSB0aGUgZ2l2ZW4gcnVsZVxuICogQHJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHR5cGUgb2YgdGhlIHByb2R1Y2VkIHZhbHVlcyBvZiB0aGUgcnVsZSBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdWxlVHlwZShydWxlKSB7XG4gICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgaWYgKGFzdC5pc1Rlcm1pbmFsUnVsZShydWxlKSkge1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gcnVsZS50eXBlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3N0cmluZyc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gKF9jID0gZ2V0RXhwbGljaXRSdWxlVHlwZShydWxlKSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogcnVsZS5uYW1lO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiB0ZXJtaW5hbFJlZ2V4KHRlcm1pbmFsUnVsZSkge1xuICAgIGNvbnN0IGZsYWdzID0ge1xuICAgICAgICBzOiBmYWxzZSxcbiAgICAgICAgaTogZmFsc2UsXG4gICAgICAgIHU6IGZhbHNlXG4gICAgfTtcbiAgICBjb25zdCBzb3VyY2UgPSBhYnN0cmFjdEVsZW1lbnRUb1JlZ2V4KHRlcm1pbmFsUnVsZS5kZWZpbml0aW9uLCBmbGFncyk7XG4gICAgY29uc3QgZmxhZ1RleHQgPSBPYmplY3QuZW50cmllcyhmbGFncykuZmlsdGVyKChbLCB2YWx1ZV0pID0+IHZhbHVlKS5tYXAoKFtuYW1lXSkgPT4gbmFtZSkuam9pbignJyk7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoc291cmNlLCBmbGFnVGV4dCk7XG59XG4vLyBVc2luZyBbXFxzXFxTXSogYWxsb3dzIHRvIG1hdGNoIGV2ZXJ5dGhpbmcsIGNvbXBhcmVkIHRvIC4gd2hpY2ggZG9lc24ndCBtYXRjaCBsaW5lIHRlcm1pbmF0b3JzXG5jb25zdCBXSUxEQ0FSRCA9IC9bXFxzXFxTXS8uc291cmNlO1xuZnVuY3Rpb24gYWJzdHJhY3RFbGVtZW50VG9SZWdleChlbGVtZW50LCBmbGFncykge1xuICAgIGlmIChhc3QuaXNUZXJtaW5hbEFsdGVybmF0aXZlcyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gdGVybWluYWxBbHRlcm5hdGl2ZXNUb1JlZ2V4KGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNUZXJtaW5hbEdyb3VwKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB0ZXJtaW5hbEdyb3VwVG9SZWdleChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzQ2hhcmFjdGVyUmFuZ2UoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJhY3RlclJhbmdlVG9SZWdleChlbGVtZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzVGVybWluYWxSdWxlQ2FsbChlbGVtZW50KSkge1xuICAgICAgICBjb25zdCBydWxlID0gZWxlbWVudC5ydWxlLnJlZjtcbiAgICAgICAgaWYgKCFydWxlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgcnVsZSByZWZlcmVuY2UuJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShhYnN0cmFjdEVsZW1lbnRUb1JlZ2V4KHJ1bGUuZGVmaW5pdGlvbiksIHtcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5OiBlbGVtZW50LmNhcmRpbmFsaXR5LFxuICAgICAgICAgICAgbG9va2FoZWFkOiBlbGVtZW50Lmxvb2thaGVhZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXN0LmlzTmVnYXRlZFRva2VuKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiBuZWdhdGVUb2tlblRvUmVnZXgoZWxlbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1VudGlsVG9rZW4oZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuIHVudGlsVG9rZW5Ub1JlZ2V4KGVsZW1lbnQpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhc3QuaXNSZWdleFRva2VuKGVsZW1lbnQpKSB7XG4gICAgICAgIGNvbnN0IGxhc3RTbGFzaCA9IGVsZW1lbnQucmVnZXgubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgY29uc3Qgc291cmNlID0gZWxlbWVudC5yZWdleC5zdWJzdHJpbmcoMSwgbGFzdFNsYXNoKTtcbiAgICAgICAgY29uc3QgcmVnZXhGbGFncyA9IGVsZW1lbnQucmVnZXguc3Vic3RyaW5nKGxhc3RTbGFzaCArIDEpO1xuICAgICAgICBpZiAoZmxhZ3MpIHtcbiAgICAgICAgICAgIGZsYWdzLmkgPSByZWdleEZsYWdzLmluY2x1ZGVzKCdpJyk7XG4gICAgICAgICAgICBmbGFncy5zID0gcmVnZXhGbGFncy5pbmNsdWRlcygncycpO1xuICAgICAgICAgICAgZmxhZ3MudSA9IHJlZ2V4RmxhZ3MuaW5jbHVkZXMoJ3UnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd2l0aENhcmRpbmFsaXR5KHNvdXJjZSwge1xuICAgICAgICAgICAgY2FyZGluYWxpdHk6IGVsZW1lbnQuY2FyZGluYWxpdHksXG4gICAgICAgICAgICBsb29rYWhlYWQ6IGVsZW1lbnQubG9va2FoZWFkLFxuICAgICAgICAgICAgd3JhcDogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFzdC5pc1dpbGRjYXJkKGVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoV0lMRENBUkQsIHtcbiAgICAgICAgICAgIGNhcmRpbmFsaXR5OiBlbGVtZW50LmNhcmRpbmFsaXR5LFxuICAgICAgICAgICAgbG9va2FoZWFkOiBlbGVtZW50Lmxvb2thaGVhZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB0ZXJtaW5hbCBlbGVtZW50OiAke2VsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC4kdHlwZX1gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0ZXJtaW5hbEFsdGVybmF0aXZlc1RvUmVnZXgoYWx0ZXJuYXRpdmVzKSB7XG4gICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShhbHRlcm5hdGl2ZXMuZWxlbWVudHMubWFwKGUgPT4gYWJzdHJhY3RFbGVtZW50VG9SZWdleChlKSkuam9pbignfCcpLCB7XG4gICAgICAgIGNhcmRpbmFsaXR5OiBhbHRlcm5hdGl2ZXMuY2FyZGluYWxpdHksXG4gICAgICAgIGxvb2thaGVhZDogYWx0ZXJuYXRpdmVzLmxvb2thaGVhZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gdGVybWluYWxHcm91cFRvUmVnZXgoZ3JvdXApIHtcbiAgICByZXR1cm4gd2l0aENhcmRpbmFsaXR5KGdyb3VwLmVsZW1lbnRzLm1hcChlID0+IGFic3RyYWN0RWxlbWVudFRvUmVnZXgoZSkpLmpvaW4oJycpLCB7XG4gICAgICAgIGNhcmRpbmFsaXR5OiBncm91cC5jYXJkaW5hbGl0eSxcbiAgICAgICAgbG9va2FoZWFkOiBncm91cC5sb29rYWhlYWRcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHVudGlsVG9rZW5Ub1JlZ2V4KHVudGlsKSB7XG4gICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShgJHtXSUxEQ0FSRH0qPyR7YWJzdHJhY3RFbGVtZW50VG9SZWdleCh1bnRpbC50ZXJtaW5hbCl9YCwge1xuICAgICAgICBjYXJkaW5hbGl0eTogdW50aWwuY2FyZGluYWxpdHksXG4gICAgICAgIGxvb2thaGVhZDogdW50aWwubG9va2FoZWFkXG4gICAgfSk7XG59XG5mdW5jdGlvbiBuZWdhdGVUb2tlblRvUmVnZXgobmVnYXRlKSB7XG4gICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShgKD8hJHthYnN0cmFjdEVsZW1lbnRUb1JlZ2V4KG5lZ2F0ZS50ZXJtaW5hbCl9KSR7V0lMRENBUkR9Kj9gLCB7XG4gICAgICAgIGNhcmRpbmFsaXR5OiBuZWdhdGUuY2FyZGluYWxpdHksXG4gICAgICAgIGxvb2thaGVhZDogbmVnYXRlLmxvb2thaGVhZFxuICAgIH0pO1xufVxuZnVuY3Rpb24gY2hhcmFjdGVyUmFuZ2VUb1JlZ2V4KHJhbmdlKSB7XG4gICAgaWYgKHJhbmdlLnJpZ2h0KSB7XG4gICAgICAgIHJldHVybiB3aXRoQ2FyZGluYWxpdHkoYFske2tleXdvcmRUb1JlZ2V4KHJhbmdlLmxlZnQpfS0ke2tleXdvcmRUb1JlZ2V4KHJhbmdlLnJpZ2h0KX1dYCwge1xuICAgICAgICAgICAgY2FyZGluYWxpdHk6IHJhbmdlLmNhcmRpbmFsaXR5LFxuICAgICAgICAgICAgbG9va2FoZWFkOiByYW5nZS5sb29rYWhlYWQsXG4gICAgICAgICAgICB3cmFwOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHdpdGhDYXJkaW5hbGl0eShrZXl3b3JkVG9SZWdleChyYW5nZS5sZWZ0KSwge1xuICAgICAgICBjYXJkaW5hbGl0eTogcmFuZ2UuY2FyZGluYWxpdHksXG4gICAgICAgIGxvb2thaGVhZDogcmFuZ2UubG9va2FoZWFkLFxuICAgICAgICB3cmFwOiBmYWxzZVxuICAgIH0pO1xufVxuZnVuY3Rpb24ga2V5d29yZFRvUmVnZXgoa2V5d29yZCkge1xuICAgIHJldHVybiBlc2NhcGVSZWdFeHAoa2V5d29yZC52YWx1ZSk7XG59XG5mdW5jdGlvbiB3aXRoQ2FyZGluYWxpdHkocmVnZXgsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG9wdGlvbnMud3JhcCAhPT0gZmFsc2UgfHwgb3B0aW9ucy5sb29rYWhlYWQpIHtcbiAgICAgICAgcmVnZXggPSBgKCR7KF9hID0gb3B0aW9ucy5sb29rYWhlYWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnfSR7cmVnZXh9KWA7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmNhcmRpbmFsaXR5KSB7XG4gICAgICAgIHJldHVybiBgJHtyZWdleH0ke29wdGlvbnMuY2FyZGluYWxpdHl9YDtcbiAgICB9XG4gICAgcmV0dXJuIHJlZ2V4O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z3JhbW1hci11dGlscy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiwgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UgfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgY3VycmVudCBjb2RlIHRvIHRoZSBuZXh0IHRpY2sgb2YgdGhlIGV2ZW50IGxvb3AuXG4gKiBEb24ndCBjYWxsIHRoaXMgbWV0aG9kIGRpcmVjdGx5IGluIGEgdGlnaHQgbG9vcCB0byBwcmV2ZW50IHRvbyBtYW55IHByb21pc2VzIGZyb20gYmVpbmcgY3JlYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRlbGF5TmV4dFRpY2soKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAvLyBJbiBjYXNlIHdlIGFyZSBydW5uaW5nIGluIGEgbm9uLW5vZGUgZW52aXJvbm1lbnQsIGBzZXRJbW1lZGlhdGVgIGlzbid0IGF2YWlsYWJsZS5cbiAgICAgICAgLy8gVXNpbmcgYHNldFRpbWVvdXRgIG9mIHRoZSBicm93c2VyIEFQSSBhY2NvbXBsaXNoZXMgdGhlIHNhbWUgcmVzdWx0LlxuICAgICAgICBpZiAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXRJbW1lZGlhdGUocmVzb2x2ZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmxldCBsYXN0VGljayA9IDA7XG5sZXQgZ2xvYmFsSW50ZXJydXB0aW9uUGVyaW9kID0gMTA7XG4vKipcbiAqIFJlc2V0IHRoZSBnbG9iYWwgaW50ZXJydXB0aW9uIHBlcmlvZCBhbmQgY3JlYXRlIGEgY2FuY2VsbGF0aW9uIHRva2VuIHNvdXJjZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0YXJ0Q2FuY2VsYWJsZU9wZXJhdGlvbigpIHtcbiAgICBsYXN0VGljayA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJldHVybiBuZXcgQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2UoKTtcbn1cbi8qKlxuICogQ2hhbmdlIHRoZSBwZXJpb2QgZHVyYXRpb24gZm9yIGBpbnRlcnJ1cHRBbmRDaGVja2AgdG8gdGhlIGdpdmVuIG51bWJlciBvZiBtaWxsaXNlY29uZHMuXG4gKiBUaGUgZGVmYXVsdCB2YWx1ZSBpcyAxMG1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2V0SW50ZXJydXB0aW9uUGVyaW9kKHBlcmlvZCkge1xuICAgIGdsb2JhbEludGVycnVwdGlvblBlcmlvZCA9IHBlcmlvZDtcbn1cbi8qKlxuICogVGhpcyBzeW1ib2wgbWF5IGJlIHRocm93biBpbiBhbiBhc3luY2hyb25vdXMgY29udGV4dCBieSBhbnkgTGFuZ2l1bSBzZXJ2aWNlIHRoYXQgcmVjZWl2ZXNcbiAqIGEgYENhbmNlbGxhdGlvblRva2VuYC4gVGhpcyBtZWFucyB0aGF0IHRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHN1Y2ggYSBzZXJ2aWNlIGlzIHJlamVjdGVkIHdpdGhcbiAqIHRoaXMgc3ltYm9sIGFzIHJlamVjdGlvbiByZWFzb24uXG4gKi9cbmV4cG9ydCBjb25zdCBPcGVyYXRpb25DYW5jZWxsZWQgPSBTeW1ib2woJ09wZXJhdGlvbkNhbmNlbGxlZCcpO1xuLyoqXG4gKiBVc2UgdGhpcyBpbiBhIGBjYXRjaGAgYmxvY2sgdG8gY2hlY2sgd2hldGhlciB0aGUgdGhyb3duIG9iamVjdCBpbmRpY2F0ZXMgdGhhdCB0aGUgb3BlcmF0aW9uXG4gKiBoYXMgYmVlbiBjYW5jZWxsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc09wZXJhdGlvbkNhbmNlbGxlZChlcnIpIHtcbiAgICByZXR1cm4gZXJyID09PSBPcGVyYXRpb25DYW5jZWxsZWQ7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gZG9lcyB0d28gdGhpbmdzOlxuICogIDEuIENoZWNrIHRoZSBlbGFwc2VkIHRpbWUgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uIG9yIHRvIGBzdGFydENhbmNlbGFibGVPcGVyYXRpb25gLiBJZiB0aGUgcHJlZGVmaW5lZFxuICogICAgIHBlcmlvZCAoY29uZmlndXJlZCB3aXRoIGBzZXRJbnRlcnJ1cHRpb25QZXJpb2RgKSBpcyBleGNlZWRlZCwgZXhlY3V0aW9uIGlzIGRlbGF5ZWQgd2l0aCBgZGVsYXlOZXh0VGlja2AuXG4gKiAgMi4gSWYgdGhlIHByZWRlZmluZWQgcGVyaW9kIGlzIG5vdCBtZXQgeWV0IG9yIGV4ZWN1dGlvbiBpcyByZXN1bWVkIGFmdGVyIGFuIGludGVycnVwdGlvbiwgdGhlIGdpdmVuIGNhbmNlbGxhdGlvblxuICogICAgIHRva2VuIGlzIGNoZWNrZWQsIGFuZCBpZiBjYW5jZWxsYXRpb24gaXMgcmVxdWVzdGVkLCBgT3BlcmF0aW9uQ2FuY2VsZWRgIGlzIHRocm93bi5cbiAqXG4gKiBBbGwgc2VydmljZXMgaW4gTGFuZ2l1bSB0aGF0IHJlY2VpdmUgYSBgQ2FuY2VsbGF0aW9uVG9rZW5gIG1heSBwb3RlbnRpYWxseSBjYWxsIHRoaXMgZnVuY3Rpb24sIHNvIHRoZVxuICogYENhbmNlbGxhdGlvblRva2VuYCBtdXN0IGJlIGNhdWdodCAod2l0aCBhbiBgYXN5bmNgIHRyeS1jYXRjaCBibG9jayBvciBhIGBjYXRjaGAgY2FsbGJhY2sgYXR0YWNoZWQgdG9cbiAqIHRoZSBwcm9taXNlKSB0byBhdm9pZCB0aGF0IGV2ZW50IGJlaW5nIGV4cG9zZWQgYXMgYW4gZXJyb3IuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpbnRlcnJ1cHRBbmRDaGVjayh0b2tlbikge1xuICAgIGlmICh0b2tlbiA9PT0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICAvLyBFYXJseSBleGl0IGluIGNhc2UgY2FuY2VsbGF0aW9uIHdhcyBkaXNhYmxlZCBieSB0aGUgY2FsbGVyXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGlmIChjdXJyZW50IC0gbGFzdFRpY2sgPj0gZ2xvYmFsSW50ZXJydXB0aW9uUGVyaW9kKSB7XG4gICAgICAgIGxhc3RUaWNrID0gY3VycmVudDtcbiAgICAgICAgYXdhaXQgZGVsYXlOZXh0VGljaygpO1xuICAgICAgICAvLyBwcmV2ZW50IGNhbGxpbmcgZGVsYXlOZXh0VGljayBldmVyeSBpdGVyYXRpb24gb2YgbG9vcFxuICAgICAgICAvLyB3aGVyZSBkZWxheU5leHRUaWNrIHRha2VzIHVwIHRoZSBtYWpvcml0eSBvciBhbGwgb2YgdGhlXG4gICAgICAgIC8vIGdsb2JhbEludGVycnVwdGlvblBlcmlvZCBpdHNlbGZcbiAgICAgICAgbGFzdFRpY2sgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgaWYgKHRva2VuLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSB7XG4gICAgICAgIHRocm93IE9wZXJhdGlvbkNhbmNlbGxlZDtcbiAgICB9XG59XG4vKipcbiAqIFNpbXBsZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgZGVmZXJyZWQgcGF0dGVybi5cbiAqIEFuIG9iamVjdCB0aGF0IGV4cG9zZXMgYSBwcm9taXNlIGFuZCBmdW5jdGlvbnMgdG8gcmVzb2x2ZSBhbmQgcmVqZWN0IGl0LlxuICovXG5leHBvcnQgY2xhc3MgRGVmZXJyZWQge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmUgPSAoYXJnKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShhcmcpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvbWlzZS11dGlscy5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBSZWdFeHBQYXJzZXIsIEJhc2VSZWdFeHBWaXNpdG9yIH0gZnJvbSAnQGNoZXZyb3RhaW4vcmVnZXhwLXRvLWFzdCc7XG5leHBvcnQgY29uc3QgTkVXTElORV9SRUdFWFAgPSAvXFxyP1xcbi9nbTtcbmNvbnN0IHJlZ2V4cFBhcnNlciA9IG5ldyBSZWdFeHBQYXJzZXIoKTtcbi8qKlxuICogVGhpcyBjbGFzcyBpcyBpbiBjaGFyZ2Ugb2YgaGV1cmlzdGljYWxseSBpZGVudGlmeWluZyBzdGFydC9lbmQgdG9rZW5zIG9mIHRlcm1pbmFscy5cbiAqXG4gKiBUaGUgd2F5IHRoaXMgd29ya3MgaXMgYnkgZG9pbmcgdGhlIGZvbGxvd2luZzpcbiAqIDEuIFRyYXZlcnNlIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gaW4gdGhlIFwic3RhcnQgc3RhdGVcIlxuICogMi4gQWRkIGFueSBlbmNvdW50ZXJlZCBzZXRzL3NpbmdsZSBjaGFyYWN0ZXJzIHRvIHRoZSBcInN0YXJ0IHJlZ2V4cFwiXG4gKiAzLiBPbmNlIHdlIGVuY291bnRlciBhbnkgdmFyaWFibGUtbGVuZ3RoIGNvbnRlbnQgKGkuZS4gd2l0aCBxdWFudGlmaWVycyBzdWNoIGFzICsvPy8qKSwgd2UgZW50ZXIgdGhlIFwiZW5kIHN0YXRlXCJcbiAqIDQuIEluIHRoZSBlbmQgc3RhdGUsIGFueSBzZXRzL3NpbmdsZSBjaGFyYWN0ZXJzIGFyZSBhZGRlZCB0byBhbiBcImVuZCBzdGFja1wiLlxuICogNS4gSWYgd2UgcmUtZW5jb3VudGVyIGFueSB2YXJpYWJsZS1sZW5ndGggY29udGVudCB3ZSByZXNldCB0aGUgZW5kIHN0YWNrXG4gKiA2LiBXZSBjb250aW51ZSB2aXNpdGluZyB0aGUgcmVnZXggdW50aWwgdGhlIGVuZCwgcmVzZXRpbmcgdGhlIGVuZCBzdGFjayBhbmQgcmVidWlsZGluZyBpdCBhcyBuZWNlc3NhcnlcbiAqXG4gKiBBZnRlciB0cmF2ZXJzaW5nIGEgcmVndWxhciBleHByZXNzaW9uIHRoZSBgc3RhcnRSZWdleHAvZW5kUmVnZXhwYCBwcm9wZXJ0aWVzIGFsbG93IGFjY2VzcyB0byB0aGUgc3RvcmVkIHN0YXJ0L2VuZCBvZiB0aGUgdGVybWluYWxcbiAqL1xuY2xhc3MgVGVybWluYWxSZWdFeHBWaXNpdG9yIGV4dGVuZHMgQmFzZVJlZ0V4cFZpc2l0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrID0gW107XG4gICAgICAgIHRoaXMubXVsdGlsaW5lID0gZmFsc2U7XG4gICAgfVxuICAgIGdldCBlbmRSZWdleCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kUmVnZXhwU3RhY2suam9pbignJyk7XG4gICAgfVxuICAgIHJlc2V0KHJlZ2V4KSB7XG4gICAgICAgIHRoaXMubXVsdGlsaW5lID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVnZXggPSByZWdleDtcbiAgICAgICAgdGhpcy5zdGFydFJlZ2V4cCA9ICcnO1xuICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSB0cnVlO1xuICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrID0gW107XG4gICAgfVxuICAgIHZpc2l0R3JvdXAobm9kZSkge1xuICAgICAgICBpZiAobm9kZS5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdENoYXJhY3Rlcihub2RlKSB7XG4gICAgICAgIGNvbnN0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKG5vZGUudmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMubXVsdGlsaW5lICYmIGNoYXIgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICB0aGlzLm11bHRpbGluZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUucXVhbnRpZmllcikge1xuICAgICAgICAgICAgdGhpcy5pc1N0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmVuZFJlZ2V4cFN0YWNrID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlc2NhcGVkQ2hhciA9IGVzY2FwZVJlZ0V4cChjaGFyKTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sucHVzaChlc2NhcGVkQ2hhcik7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZ2V4cCArPSBlc2NhcGVkQ2hhcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB2aXNpdFNldChub2RlKSB7XG4gICAgICAgIGlmICghdGhpcy5tdWx0aWxpbmUpIHtcbiAgICAgICAgICAgIGNvbnN0IHNldCA9IHRoaXMucmVnZXguc3Vic3RyaW5nKG5vZGUubG9jLmJlZ2luLCBub2RlLmxvYy5lbmQpO1xuICAgICAgICAgICAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKHNldCk7XG4gICAgICAgICAgICB0aGlzLm11bHRpbGluZSA9IEJvb2xlYW4oJ1xcbicubWF0Y2gocmVnZXgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobm9kZS5xdWFudGlmaWVyKSB7XG4gICAgICAgICAgICB0aGlzLmlzU3RhcnRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuZW5kUmVnZXhwU3RhY2sgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNldCA9IHRoaXMucmVnZXguc3Vic3RyaW5nKG5vZGUubG9jLmJlZ2luLCBub2RlLmxvYy5lbmQpO1xuICAgICAgICAgICAgdGhpcy5lbmRSZWdleHBTdGFjay5wdXNoKHNldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0YXJ0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydFJlZ2V4cCArPSBzZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmlzaXRDaGlsZHJlbihub2RlKSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgPT09ICdHcm91cCcpIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBjaGlsZHJlbiBvZiBncm91cHMgd2l0aCBxdWFudGlmaWVyICgrLyovPylcbiAgICAgICAgICAgIC8vIFRoZXNlIGdyb3VwcyBhcmUgdW5yZWxhdGVkIHRvIHN0YXJ0L2VuZCB0b2tlbnMgb2YgdGVybWluYWxzXG4gICAgICAgICAgICBjb25zdCBncm91cCA9IG5vZGU7XG4gICAgICAgICAgICBpZiAoZ3JvdXAucXVhbnRpZmllcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdXBlci52aXNpdENoaWxkcmVuKG5vZGUpO1xuICAgIH1cbn1cbmNvbnN0IHZpc2l0b3IgPSBuZXcgVGVybWluYWxSZWdFeHBWaXNpdG9yKCk7XG5leHBvcnQgZnVuY3Rpb24gZ2V0VGVybWluYWxQYXJ0cyhyZWdleHApIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHJlZ2V4cCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlZ2V4cCA9IHJlZ2V4cC5zb3VyY2U7XG4gICAgICAgIH1cbiAgICAgICAgcmVnZXhwID0gYC8ke3JlZ2V4cH0vYDtcbiAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlZ2V4cFBhcnNlci5wYXR0ZXJuKHJlZ2V4cCk7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgYWx0ZXJuYXRpdmUgb2YgcGF0dGVybi52YWx1ZS52YWx1ZSkge1xuICAgICAgICAgICAgdmlzaXRvci5yZXNldChyZWdleHApO1xuICAgICAgICAgICAgdmlzaXRvci52aXNpdChhbHRlcm5hdGl2ZSk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgICAgICBzdGFydDogdmlzaXRvci5zdGFydFJlZ2V4cCxcbiAgICAgICAgICAgICAgICBlbmQ6IHZpc2l0b3IuZW5kUmVnZXhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gaXNNdWx0aWxpbmVDb21tZW50KHJlZ2V4cCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVnZXhwID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmVnZXhwID0gbmV3IFJlZ0V4cChyZWdleHApO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2V4cCA9IHJlZ2V4cC50b1N0cmluZygpO1xuICAgICAgICB2aXNpdG9yLnJlc2V0KHJlZ2V4cCk7XG4gICAgICAgIC8vIFBhcnNpbmcgdGhlIHBhdHRlcm4gbWlnaHQgZmFpbCAoc2luY2UgaXQncyB1c2VyIGNvZGUpXG4gICAgICAgIHZpc2l0b3IudmlzaXQocmVnZXhwUGFyc2VyLnBhdHRlcm4ocmVnZXhwKSk7XG4gICAgICAgIHJldHVybiB2aXNpdG9yLm11bHRpbGluZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEEgc2V0IG9mIGFsbCBjaGFyYWN0ZXJzIHRoYXQgYXJlIGNvbnNpZGVyZWQgd2hpdGVzcGFjZSBieSB0aGUgJ1xccycgUmVnRXhwIGNoYXJhY3RlciBjbGFzcy5cbiAqIFRha2VuIGZyb20gW01ETl0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9HdWlkZS9SZWd1bGFyX2V4cHJlc3Npb25zL0NoYXJhY3Rlcl9jbGFzc2VzKS5cbiAqL1xuZXhwb3J0IGNvbnN0IHdoaXRlc3BhY2VDaGFyYWN0ZXJzID0gKCdcXGZcXG5cXHJcXHRcXHZcXHUwMDIwXFx1MDBhMFxcdTE2ODBcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwNycgK1xuICAgICdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmYnKS5zcGxpdCgnJyk7XG5leHBvcnQgZnVuY3Rpb24gaXNXaGl0ZXNwYWNlKHZhbHVlKSB7XG4gICAgY29uc3QgcmVnZXhwID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IG5ldyBSZWdFeHAodmFsdWUpIDogdmFsdWU7XG4gICAgcmV0dXJuIHdoaXRlc3BhY2VDaGFyYWN0ZXJzLnNvbWUoKHdzKSA9PiByZWdleHAudGVzdCh3cykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENhc2VJbnNlbnNpdGl2ZVBhdHRlcm4oa2V5d29yZCkge1xuICAgIHJldHVybiBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwoa2V5d29yZCwgbGV0dGVyID0+IC9cXHcvLnRlc3QobGV0dGVyKSA/IGBbJHtsZXR0ZXIudG9Mb3dlckNhc2UoKX0ke2xldHRlci50b1VwcGVyQ2FzZSgpfV1gIDogZXNjYXBlUmVnRXhwKGxldHRlcikpLmpvaW4oJycpO1xufVxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGdpdmVuIGlucHV0IGhhcyBhIHBhcnRpYWwgbWF0Y2ggd2l0aCB0aGUgc3BlY2lmaWVkIHJlZ2V4LlxuICogQHBhcmFtIHJlZ2V4IFRoZSByZWdleCB0byBwYXJ0aWFsbHkgbWF0Y2ggYWdhaW5zdFxuICogQHBhcmFtIGlucHV0IFRoZSBpbnB1dCBzdHJpbmdcbiAqIEByZXR1cm5zIFdoZXRoZXIgYW55IG1hdGNoIGV4aXN0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBhcnRpYWxNYXRjaGVzKHJlZ2V4LCBpbnB1dCkge1xuICAgIGNvbnN0IHBhcnRpYWwgPSBwYXJ0aWFsUmVnRXhwKHJlZ2V4KTtcbiAgICBjb25zdCBtYXRjaCA9IGlucHV0Lm1hdGNoKHBhcnRpYWwpO1xuICAgIHJldHVybiAhIW1hdGNoICYmIG1hdGNoWzBdLmxlbmd0aCA+IDA7XG59XG4vKipcbiAqIEJ1aWxkcyBhIHBhcnRpYWwgcmVnZXggZnJvbSB0aGUgaW5wdXQgcmVnZXguIEEgcGFydGlhbCByZWdleCBpcyBhYmxlIHRvIG1hdGNoIGluY29tcGxldGUgaW5wdXQgc3RyaW5ncy4gRS5nLlxuICogYSBwYXJ0aWFsIHJlZ2V4IGNvbnN0cnVjdGVkIGZyb20gYC9hYi9gIGlzIGFibGUgdG8gbWF0Y2ggdGhlIHN0cmluZyBgYWAgd2l0aG91dCBuZWVkaW5nIGEgZm9sbG93aW5nIGBiYCBjaGFyYWN0ZXIuIEhvd2V2ZXIgaXQgd29uJ3QgbWF0Y2ggYGJgIGFsb25lLlxuICogQHBhcmFtIHJlZ2V4IFRoZSBpbnB1dCByZWdleCB0byBiZSBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJucyBBIHBhcnRpYWwgcmVnZXggY29uc3RydWN0ZWQgZnJvbSB0aGUgaW5wdXQgcmVnZXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwYXJ0aWFsUmVnRXhwKHJlZ2V4KSB7XG4gICAgaWYgKHR5cGVvZiByZWdleCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmVnZXggPSBuZXcgUmVnRXhwKHJlZ2V4KTtcbiAgICB9XG4gICAgY29uc3QgcmUgPSByZWdleCwgc291cmNlID0gcmVnZXguc291cmNlO1xuICAgIGxldCBpID0gMDtcbiAgICBmdW5jdGlvbiBwcm9jZXNzKCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0gJycsIHRtcDtcbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kUmF3KG5iQ2hhcnMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBzb3VyY2Uuc3Vic3RyKGksIG5iQ2hhcnMpO1xuICAgICAgICAgICAgaSArPSBuYkNoYXJzO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZE9wdGlvbmFsKG5iQ2hhcnMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSAnKD86JyArIHNvdXJjZS5zdWJzdHIoaSwgbmJDaGFycykgKyAnfCQpJztcbiAgICAgICAgICAgIGkgKz0gbmJDaGFycztcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoaSA8IHNvdXJjZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoc291cmNlW2ldKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnXFxcXCc6XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoc291cmNlW2kgKyAxXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnYyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCg0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZS51bmljb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb3VyY2VbaSArIDJdID09PSAneycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcGVuZE9wdGlvbmFsKHNvdXJjZS5pbmRleE9mKCd9JywgaSkgLSBpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCg2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAncCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdQJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmUudW5pY29kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbChzb3VyY2UuaW5kZXhPZignfScsIGkpIC0gaSArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnayc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoc291cmNlLmluZGV4T2YoJz4nLCBpKSAtIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwZW5kT3B0aW9uYWwoMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IC9cXFsoPzpcXFxcLnwuKSo/XFxdL2c7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sYXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAuZXhlYyhzb3VyY2UpIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCh0bXBbMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnXic6XG4gICAgICAgICAgICAgICAgY2FzZSAnJCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnKic6XG4gICAgICAgICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICAgICAgY2FzZSAnPyc6XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFJhdygxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAneyc6XG4gICAgICAgICAgICAgICAgICAgIHRtcCA9IC9cXHtcXGQrLD9cXGQqXFx9L2c7XG4gICAgICAgICAgICAgICAgICAgIHRtcC5sYXN0SW5kZXggPSBpO1xuICAgICAgICAgICAgICAgICAgICB0bXAgPSB0bXAuZXhlYyhzb3VyY2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcodG1wWzBdLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICcoJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvdXJjZVtpICsgMV0gPT09ICc/Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzb3VyY2VbaSArIDJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnKD86JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJvY2VzcygpICsgJ3wkKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJz0nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gJyg/PSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9IHByb2Nlc3MoKSArICcpJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnISc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc291cmNlLnN1YnN0cih0bXAsIGkgLSB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc8JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChzb3VyY2VbaSArIDNdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICc9JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJyEnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSArPSA0O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gc291cmNlLnN1YnN0cih0bXAsIGkgLSB0bXApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcoc291cmNlLmluZGV4T2YoJz4nLCBpKSAtIGkgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJvY2VzcygpICsgJ3wkKSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBlbmRSYXcoMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gcHJvY2VzcygpICsgJ3wkKSc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnKSc6XG4gICAgICAgICAgICAgICAgICAgICsraTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBhcHBlbmRPcHRpb25hbCgxKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAocHJvY2VzcygpLCByZWdleC5mbGFncyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yZWdleHAtdXRpbHMuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBUaGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBgU3RyZWFtYCB3b3JrcyB3aXRoIHR3byBpbnB1dCBmdW5jdGlvbnM6XG4gKiAgLSBUaGUgZmlyc3QgZnVuY3Rpb24gY3JlYXRlcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiBhbiBpdGVyYXRpb24uXG4gKiAgLSBUaGUgc2Vjb25kIGZ1bmN0aW9uIGdldHMgdGhlIGN1cnJlbnQgc3RhdGUgYXMgYXJndW1lbnQgYW5kIHJldHVybnMgYW4gYEl0ZXJhdG9yUmVzdWx0YC5cbiAqL1xuZXhwb3J0IGNsYXNzIFN0cmVhbUltcGwge1xuICAgIGNvbnN0cnVjdG9yKHN0YXJ0Rm4sIG5leHRGbikge1xuICAgICAgICB0aGlzLnN0YXJ0Rm4gPSBzdGFydEZuO1xuICAgICAgICB0aGlzLm5leHRGbiA9IG5leHRGbjtcbiAgICB9XG4gICAgaXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhcnRGbigpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4gdGhpcy5uZXh0Rm4oaXRlcmF0b3Iuc3RhdGUpLFxuICAgICAgICAgICAgW1N5bWJvbC5pdGVyYXRvcl06ICgpID0+IGl0ZXJhdG9yXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpdGVyYXRvcjtcbiAgICB9XG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLml0ZXJhdG9yKCk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICByZXR1cm4gQm9vbGVhbihpdGVyYXRvci5uZXh0KCkuZG9uZSk7XG4gICAgfVxuICAgIGNvdW50KCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IGNvdW50ID0gMDtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfVxuICAgIHRvQXJyYXkoKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQ7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobmV4dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gd2hpbGUgKCFuZXh0LmRvbmUpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICB0b1NldCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTZXQodGhpcyk7XG4gICAgfVxuICAgIHRvTWFwKGtleUZuLCB2YWx1ZUZuKSB7XG4gICAgICAgIGNvbnN0IGVudHJ5U3RyZWFtID0gdGhpcy5tYXAoZWxlbWVudCA9PiBbXG4gICAgICAgICAgICBrZXlGbiA/IGtleUZuKGVsZW1lbnQpIDogZWxlbWVudCxcbiAgICAgICAgICAgIHZhbHVlRm4gPyB2YWx1ZUZuKGVsZW1lbnQpIDogZWxlbWVudFxuICAgICAgICBdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBNYXAoZW50cnlTdHJlYW0pO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuam9pbigpO1xuICAgIH1cbiAgICBjb25jYXQob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IGZpcnN0OiB0aGlzLnN0YXJ0Rm4oKSwgZmlyc3REb25lOiBmYWxzZSwgaXRlcmF0b3I6IG90aGVyW1N5bWJvbC5pdGVyYXRvcl0oKSB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGlmICghc3RhdGUuZmlyc3REb25lKSB7XG4gICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm5leHRGbihzdGF0ZS5maXJzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgICAgIHN0YXRlLmZpcnN0RG9uZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgam9pbihzZXBhcmF0b3IgPSAnLCcpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCB2YWx1ZSA9ICcnO1xuICAgICAgICBsZXQgcmVzdWx0O1xuICAgICAgICBsZXQgYWRkU2VwYXJhdG9yID0gZmFsc2U7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWRkU2VwYXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlICs9IHNlcGFyYXRvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gdG9TdHJpbmcocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFNlcGFyYXRvciA9IHRydWU7XG4gICAgICAgIH0gd2hpbGUgKCFyZXN1bHQuZG9uZSk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaW5kZXhPZihzZWFyY2hFbGVtZW50LCBmcm9tSW5kZXggPSAwKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgaW5kZXggPSAwO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA+PSBmcm9tSW5kZXggJiYgbmV4dC52YWx1ZSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgZXZlcnkocHJlZGljYXRlKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBsZXQgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgd2hpbGUgKCFuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlKG5leHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgc29tZShwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvckVhY2goY2FsbGJhY2tmbikge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IGluZGV4ID0gMDtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBjYWxsYmFja2ZuKG5leHQudmFsdWUsIGluZGV4KTtcbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1hcChjYWxsYmFja2ZuKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLnN0YXJ0Rm4sIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gdGhpcy5uZXh0Rm4oc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGNhbGxiYWNrZm4odmFsdWUpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaWx0ZXIocHJlZGljYXRlKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3RyZWFtSW1wbCh0aGlzLnN0YXJ0Rm4sIHN0YXRlID0+IHtcbiAgICAgICAgICAgIGxldCByZXN1bHQ7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5uZXh0Rm4oc3RhdGUpO1xuICAgICAgICAgICAgICAgIGlmICghcmVzdWx0LmRvbmUgJiYgcHJlZGljYXRlKHJlc3VsdC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbm9uTnVsbGFibGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlcihlID0+IGUgIT09IHVuZGVmaW5lZCAmJiBlICE9PSBudWxsKTtcbiAgICB9XG4gICAgcmVkdWNlKGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZXZpb3VzVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzVmFsdWUgPSBuZXh0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrZm4ocHJldmlvdXNWYWx1ZSwgbmV4dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xuICAgIH1cbiAgICByZWR1Y2VSaWdodChjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdXJzaXZlUmVkdWNlKHRoaXMuaXRlcmF0b3IoKSwgY2FsbGJhY2tmbiwgaW5pdGlhbFZhbHVlKTtcbiAgICB9XG4gICAgcmVjdXJzaXZlUmVkdWNlKGl0ZXJhdG9yLCBjYWxsYmFja2ZuLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgICAgY29uc3QgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgaWYgKG5leHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIGluaXRpYWxWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcmV2aW91c1ZhbHVlID0gdGhpcy5yZWN1cnNpdmVSZWR1Y2UoaXRlcmF0b3IsIGNhbGxiYWNrZm4sIGluaXRpYWxWYWx1ZSk7XG4gICAgICAgIGlmIChwcmV2aW91c1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXh0LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjYWxsYmFja2ZuKHByZXZpb3VzVmFsdWUsIG5leHQudmFsdWUpO1xuICAgIH1cbiAgICBmaW5kKHByZWRpY2F0ZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAocHJlZGljYXRlKG5leHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5leHQudmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGZpbmRJbmRleChwcmVkaWNhdGUpIHtcbiAgICAgICAgY29uc3QgaXRlcmF0b3IgPSB0aGlzLml0ZXJhdG9yKCk7XG4gICAgICAgIGxldCBpbmRleCA9IDA7XG4gICAgICAgIGxldCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICB3aGlsZSAoIW5leHQuZG9uZSkge1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShuZXh0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9XG4gICAgaW5jbHVkZXMoc2VhcmNoRWxlbWVudCkge1xuICAgICAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcbiAgICAgICAgbGV0IG5leHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIHdoaWxlICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICBpZiAobmV4dC52YWx1ZSA9PT0gc2VhcmNoRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dCA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZsYXRNYXAoY2FsbGJhY2tmbikge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgdGhpczogdGhpcy5zdGFydEZuKCkgfSksIChzdGF0ZSkgPT4ge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5pdGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gc3RhdGUuaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IHRoaXMubmV4dEZuKHN0YXRlLnRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWQgPSBjYWxsYmFja2ZuKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUobWFwcGVkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3IgPSBtYXBwZWRbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBtYXBwZWQgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YXRlLml0ZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZsYXQoZGVwdGgpIHtcbiAgICAgICAgaWYgKGRlcHRoID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlcHRoID0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVwdGggPD0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RyZWFtID0gZGVwdGggPiAxID8gdGhpcy5mbGF0KGRlcHRoIC0gMSkgOiB0aGlzO1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgdGhpczogc3RyZWFtLnN0YXJ0Rm4oKSB9KSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gc3RyZWFtLm5leHRGbihzdGF0ZS50aGlzKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHZhbHVlW1N5bWJvbC5pdGVyYXRvcl0oKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IGZhbHNlLCB2YWx1ZTogdmFsdWUgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHN0YXRlLml0ZXJhdG9yKTtcbiAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGhlYWQoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5pdGVyYXRvcigpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICB0YWlsKHNraXBDb3VudCA9IDEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5zdGFydEZuKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNraXBDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dCA9IHRoaXMubmV4dEZuKHN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAobmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgICAgIH0sIHRoaXMubmV4dEZuKTtcbiAgICB9XG4gICAgbGltaXQobWF4U2l6ZSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgc2l6ZTogMCwgc3RhdGU6IHRoaXMuc3RhcnRGbigpIH0pLCBzdGF0ZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5zaXplKys7XG4gICAgICAgICAgICBpZiAoc3RhdGUuc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRE9ORV9SRVNVTFQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5uZXh0Rm4oc3RhdGUuc3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZGlzdGluY3QoYnkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IHNldDogbmV3IFNldCgpLCBpbnRlcm5hbFN0YXRlOiB0aGlzLnN0YXJ0Rm4oKSB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSB0aGlzLm5leHRGbihzdGF0ZS5pbnRlcm5hbFN0YXRlKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gYnkgPyBieShyZXN1bHQudmFsdWUpIDogcmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLnNldC5oYXModmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5zZXQuYWRkKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlICghcmVzdWx0LmRvbmUpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhjbHVkZShvdGhlciwga2V5KSB7XG4gICAgICAgIGNvbnN0IG90aGVyS2V5U2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2Ygb3RoZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0ga2V5ID8ga2V5KGl0ZW0pIDogaXRlbTtcbiAgICAgICAgICAgIG90aGVyS2V5U2V0LmFkZCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKGUgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3duS2V5ID0ga2V5ID8ga2V5KGUpIDogZTtcbiAgICAgICAgICAgIHJldHVybiAhb3RoZXJLZXlTZXQuaGFzKG93bktleSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRvU3RyaW5nKGl0ZW0pIHtcbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBpdGVtO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBpZiAodHlwZW9mIGl0ZW0udG9TdHJpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgcmV0dXJuIGl0ZW0udG9TdHJpbmcoKTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChpdGVtKTtcbn1cbmZ1bmN0aW9uIGlzSXRlcmFibGUob2JqKSB7XG4gICAgcmV0dXJuICEhb2JqICYmIHR5cGVvZiBvYmpbU3ltYm9sLml0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcbn1cbi8qKlxuICogQW4gZW1wdHkgc3RyZWFtIG9mIGFueSB0eXBlLlxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZXhwb3J0IGNvbnN0IEVNUFRZX1NUUkVBTSA9IG5ldyBTdHJlYW1JbXBsKCgpID0+IHVuZGVmaW5lZCwgKCkgPT4gRE9ORV9SRVNVTFQpO1xuLyoqXG4gKiBVc2UgdGhpcyBgSXRlcmF0b3JSZXN1bHRgIHdoZW4gaW1wbGVtZW50aW5nIGEgYFN0cmVhbUltcGxgIHRvIGluZGljYXRlIHRoYXQgdGhlcmUgYXJlIG5vIG1vcmUgZWxlbWVudHMgaW4gdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGNvbnN0IERPTkVfUkVTVUxUID0gT2JqZWN0LmZyZWV6ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBmcm9tIG9uZSBvciBtb3JlIGl0ZXJhYmxlcyBvciBhcnJheS1saWtlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmVhbSguLi5jb2xsZWN0aW9ucykge1xuICAgIGlmIChjb2xsZWN0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zWzBdO1xuICAgICAgICBpZiAoY29sbGVjdGlvbiBpbnN0YW5jZW9mIFN0cmVhbUltcGwpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0l0ZXJhYmxlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCksIChpdGVyYXRvcikgPT4gaXRlcmF0b3IubmV4dCgpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTdHJlYW1JbXBsKCgpID0+ICh7IGluZGV4OiAwIH0pLCAoc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuaW5kZXggPCBjb2xsZWN0aW9uLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGNvbGxlY3Rpb25bc3RhdGUuaW5kZXgrK10gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBET05FX1JFU1VMVDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29sbGVjdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm4gbmV3IFN0cmVhbUltcGwoKCkgPT4gKHsgY29sbEluZGV4OiAwLCBhcnJJbmRleDogMCB9KSwgKHN0YXRlKSA9PiB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLml0ZXJhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSBzdGF0ZS5pdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbmV4dC5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV4dDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5pdGVyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5hcnJJbmRleCA8IHN0YXRlLmFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogZmFsc2UsIHZhbHVlOiBzdGF0ZS5hcnJheVtzdGF0ZS5hcnJJbmRleCsrXSB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmFycmF5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5jb2xsSW5kZXggPCBjb2xsZWN0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IGNvbGxlY3Rpb25zW3N0YXRlLmNvbGxJbmRleCsrXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSXRlcmFibGUoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9yID0gY29sbGVjdGlvbltTeW1ib2wuaXRlcmF0b3JdKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29sbGVjdGlvbiAmJiB0eXBlb2YgY29sbGVjdGlvbi5sZW5ndGggPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5hcnJheSA9IGNvbGxlY3Rpb247XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IHdoaWxlIChzdGF0ZS5pdGVyYXRvciB8fCBzdGF0ZS5hcnJheSB8fCBzdGF0ZS5jb2xsSW5kZXggPCBjb2xsZWN0aW9ucy5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIEVNUFRZX1NUUkVBTTtcbn1cbi8qKlxuICogVGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gb2YgYFRyZWVTdHJlYW1gIHRha2VzIGEgcm9vdCBlbGVtZW50IGFuZCBhIGZ1bmN0aW9uIHRoYXQgY29tcHV0ZXMgdGhlXG4gKiBjaGlsZHJlbiBvZiBpdHMgYXJndW1lbnQuIFdoZXRoZXIgdGhlIHJvb3Qgbm9kZSBpbmNsdWRlZCBpbiB0aGUgc3RyZWFtIGlzIGNvbnRyb2xsZWQgd2l0aCB0aGVcbiAqIGBpbmNsdWRlUm9vdGAgb3B0aW9uLCB3aGljaCBkZWZhdWx0cyB0byBgZmFsc2VgLlxuICovXG5leHBvcnQgY2xhc3MgVHJlZVN0cmVhbUltcGwgZXh0ZW5kcyBTdHJlYW1JbXBsIHtcbiAgICBjb25zdHJ1Y3Rvcihyb290LCBjaGlsZHJlbiwgb3B0aW9ucykge1xuICAgICAgICBzdXBlcigoKSA9PiAoe1xuICAgICAgICAgICAgaXRlcmF0b3JzOiAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmluY2x1ZGVSb290KSA/IFtbcm9vdF1bU3ltYm9sLml0ZXJhdG9yXSgpXSA6IFtjaGlsZHJlbihyb290KVtTeW1ib2wuaXRlcmF0b3JdKCldLFxuICAgICAgICAgICAgcHJ1bmVkOiBmYWxzZVxuICAgICAgICB9KSwgc3RhdGUgPT4ge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnBydW5lZCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLml0ZXJhdG9ycy5wb3AoKTtcbiAgICAgICAgICAgICAgICBzdGF0ZS5wcnVuZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChzdGF0ZS5pdGVyYXRvcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZXJhdG9yID0gc3RhdGUuaXRlcmF0b3JzW3N0YXRlLml0ZXJhdG9ycy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gaXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChuZXh0LmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3JzLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaXRlcmF0b3JzLnB1c2goY2hpbGRyZW4obmV4dC52YWx1ZSlbU3ltYm9sLml0ZXJhdG9yXSgpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIERPTkVfUkVTVUxUO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXRlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGl0ZXJhdG9yID0ge1xuICAgICAgICAgICAgc3RhdGU6IHRoaXMuc3RhcnRGbigpLFxuICAgICAgICAgICAgbmV4dDogKCkgPT4gdGhpcy5uZXh0Rm4oaXRlcmF0b3Iuc3RhdGUpLFxuICAgICAgICAgICAgcHJ1bmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpdGVyYXRvci5zdGF0ZS5wcnVuZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdOiAoKSA9PiBpdGVyYXRvclxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaXRlcmF0b3I7XG4gICAgfVxufVxuLyoqXG4gKiBBIHNldCBvZiB1dGlsaXR5IGZ1bmN0aW9ucyB0aGF0IHJlZHVjZSBhIHN0cmVhbSB0byBhIHNpbmdsZSB2YWx1ZS5cbiAqL1xuZXhwb3J0IHZhciBSZWR1Y3Rpb247XG4oZnVuY3Rpb24gKFJlZHVjdGlvbikge1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHN1bSBvZiBhIG51bWJlciBzdHJlYW0uXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VtKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnJlZHVjZSgoYSwgYikgPT4gYSArIGIsIDApO1xuICAgIH1cbiAgICBSZWR1Y3Rpb24uc3VtID0gc3VtO1xuICAgIC8qKlxuICAgICAqIENvbXB1dGUgdGhlIHByb2R1Y3Qgb2YgYSBudW1iZXIgc3RyZWFtLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb2R1Y3Qoc3RyZWFtKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0ucmVkdWNlKChhLCBiKSA9PiBhICogYiwgMCk7XG4gICAgfVxuICAgIFJlZHVjdGlvbi5wcm9kdWN0ID0gcHJvZHVjdDtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtaW5pbXVtIG9mIGEgbnVtYmVyIHN0cmVhbS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1pbihzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWluKGEsIGIpKTtcbiAgICB9XG4gICAgUmVkdWN0aW9uLm1pbiA9IG1pbjtcbiAgICAvKipcbiAgICAgKiBDb21wdXRlIHRoZSBtYXhpbXVtIG9mIGEgbnVtYmVyIHN0cmVhbS4gUmV0dXJucyBgdW5kZWZpbmVkYCBpZiB0aGUgc3RyZWFtIGlzIGVtcHR5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1heChzdHJlYW0pIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbS5yZWR1Y2UoKGEsIGIpID0+IE1hdGgubWF4KGEsIGIpKTtcbiAgICB9XG4gICAgUmVkdWN0aW9uLm1heCA9IG1heDtcbn0pKFJlZHVjdGlvbiB8fCAoUmVkdWN0aW9uID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmVhbS5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBVUkksIFV0aWxzIH0gZnJvbSAndnNjb2RlLXVyaSc7XG5leHBvcnQgeyBVUkkgfTtcbmV4cG9ydCB2YXIgVXJpVXRpbHM7XG4oZnVuY3Rpb24gKFVyaVV0aWxzKSB7XG4gICAgVXJpVXRpbHMuYmFzZW5hbWUgPSBVdGlscy5iYXNlbmFtZTtcbiAgICBVcmlVdGlscy5kaXJuYW1lID0gVXRpbHMuZGlybmFtZTtcbiAgICBVcmlVdGlscy5leHRuYW1lID0gVXRpbHMuZXh0bmFtZTtcbiAgICBVcmlVdGlscy5qb2luUGF0aCA9IFV0aWxzLmpvaW5QYXRoO1xuICAgIFVyaVV0aWxzLnJlc29sdmVQYXRoID0gVXRpbHMucmVzb2x2ZVBhdGg7XG4gICAgZnVuY3Rpb24gZXF1YWxzKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIChhID09PSBudWxsIHx8IGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGEudG9TdHJpbmcoKSkgPT09IChiID09PSBudWxsIHx8IGIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGIudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIFVyaVV0aWxzLmVxdWFscyA9IGVxdWFscztcbiAgICBmdW5jdGlvbiByZWxhdGl2ZShmcm9tLCB0bykge1xuICAgICAgICBjb25zdCBmcm9tUGF0aCA9IHR5cGVvZiBmcm9tID09PSAnc3RyaW5nJyA/IGZyb20gOiBmcm9tLnBhdGg7XG4gICAgICAgIGNvbnN0IHRvUGF0aCA9IHR5cGVvZiB0byA9PT0gJ3N0cmluZycgPyB0byA6IHRvLnBhdGg7XG4gICAgICAgIGNvbnN0IGZyb21QYXJ0cyA9IGZyb21QYXRoLnNwbGl0KCcvJykuZmlsdGVyKGUgPT4gZS5sZW5ndGggPiAwKTtcbiAgICAgICAgY29uc3QgdG9QYXJ0cyA9IHRvUGF0aC5zcGxpdCgnLycpLmZpbHRlcihlID0+IGUubGVuZ3RoID4gMCk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZm9yICg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBiYWNrUGFydCA9ICcuLi8nLnJlcGVhdChmcm9tUGFydHMubGVuZ3RoIC0gaSk7XG4gICAgICAgIGNvbnN0IHRvUGFydCA9IHRvUGFydHMuc2xpY2UoaSkuam9pbignLycpO1xuICAgICAgICByZXR1cm4gYmFja1BhcnQgKyB0b1BhcnQ7XG4gICAgfVxuICAgIFVyaVV0aWxzLnJlbGF0aXZlID0gcmVsYXRpdmU7XG4gICAgZnVuY3Rpb24gbm9ybWFsaXplKHVyaSkge1xuICAgICAgICByZXR1cm4gVVJJLnBhcnNlKHVyaS50b1N0cmluZygpKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBVcmlVdGlscy5ub3JtYWxpemUgPSBub3JtYWxpemU7XG59KShVcmlVdGlscyB8fCAoVXJpVXRpbHMgPSB7fSkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXJpLXV0aWxzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IGZpbmROb2RlRm9yS2V5d29yZCwgZmluZE5vZGVGb3JQcm9wZXJ0eSB9IGZyb20gJy4uL3V0aWxzL2dyYW1tYXItdXRpbHMuanMnO1xuaW1wb3J0IHsgc3RyZWFtQXN0IH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IHRva2VuVG9SYW5nZSB9IGZyb20gJy4uL3V0aWxzL2NzdC11dGlscy5qcyc7XG5pbXBvcnQgeyBpbnRlcnJ1cHRBbmRDaGVjaywgaXNPcGVyYXRpb25DYW5jZWxsZWQgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IGRpYWdub3N0aWNEYXRhIH0gZnJvbSAnLi92YWxpZGF0aW9uLXJlZ2lzdHJ5LmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0RG9jdW1lbnRWYWxpZGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGlvblJlZ2lzdHJ5ID0gc2VydmljZXMudmFsaWRhdGlvbi5WYWxpZGF0aW9uUmVnaXN0cnk7XG4gICAgICAgIHRoaXMubWV0YWRhdGEgPSBzZXJ2aWNlcy5MYW5ndWFnZU1ldGFEYXRhO1xuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZURvY3VtZW50KGRvY3VtZW50LCBvcHRpb25zID0ge30sIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IGRvY3VtZW50LnBhcnNlUmVzdWx0O1xuICAgICAgICBjb25zdCBkaWFnbm9zdGljcyA9IFtdO1xuICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgIGlmICghb3B0aW9ucy5jYXRlZ29yaWVzIHx8IG9wdGlvbnMuY2F0ZWdvcmllcy5pbmNsdWRlcygnYnVpbHQtaW4nKSkge1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzTGV4aW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9wQWZ0ZXJMZXhpbmdFcnJvcnMgJiYgZGlhZ25vc3RpY3Muc29tZShkID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdFcnJvcjsgfSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnByb2Nlc3NQYXJzaW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdG9wQWZ0ZXJQYXJzaW5nRXJyb3JzICYmIGRpYWdub3N0aWNzLnNvbWUoZCA9PiB7IHZhciBfYTsgcmV0dXJuICgoX2EgPSBkLmRhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb2RlKSA9PT0gRG9jdW1lbnRWYWxpZGF0b3IuUGFyc2luZ0Vycm9yOyB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc0xpbmtpbmdFcnJvcnMoZG9jdW1lbnQsIGRpYWdub3N0aWNzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN0b3BBZnRlckxpbmtpbmdFcnJvcnMgJiYgZGlhZ25vc3RpY3Muc29tZShkID0+IHsgdmFyIF9hOyByZXR1cm4gKChfYSA9IGQuZGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvZGUpID09PSBEb2N1bWVudFZhbGlkYXRvci5MaW5raW5nRXJyb3I7IH0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFByb2Nlc3MgY3VzdG9tIHZhbGlkYXRpb25zXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKC4uLmF3YWl0IHRoaXMudmFsaWRhdGVBc3QocGFyc2VSZXN1bHQudmFsdWUsIG9wdGlvbnMsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGlzT3BlcmF0aW9uQ2FuY2VsbGVkKGVycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdmFsaWRhdGlvbjonLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNzO1xuICAgIH1cbiAgICBwcm9jZXNzTGV4aW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgX29wdGlvbnMpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGNvbnN0IGxleGVyRGlhZ25vc3RpY3MgPSBbLi4ucGFyc2VSZXN1bHQubGV4ZXJFcnJvcnMsIC4uLihfYiA9IChfYSA9IHBhcnNlUmVzdWx0LmxleGVyUmVwb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGlhZ25vc3RpY3MpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdXTtcbiAgICAgICAgZm9yIChjb25zdCBsZXhlckRpYWdub3N0aWMgb2YgbGV4ZXJEaWFnbm9zdGljcykge1xuICAgICAgICAgICAgY29uc3Qgc2V2ZXJpdHkgPSAoX2MgPSBsZXhlckRpYWdub3N0aWMuc2V2ZXJpdHkpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6ICdlcnJvcic7XG4gICAgICAgICAgICBjb25zdCBkaWFnbm9zdGljID0ge1xuICAgICAgICAgICAgICAgIHNldmVyaXR5OiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eSksXG4gICAgICAgICAgICAgICAgcmFuZ2U6IHtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyRGlhZ25vc3RpYy5saW5lIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJhY3RlcjogbGV4ZXJEaWFnbm9zdGljLmNvbHVtbiAtIDFcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lOiBsZXhlckRpYWdub3N0aWMubGluZSAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyYWN0ZXI6IGxleGVyRGlhZ25vc3RpYy5jb2x1bW4gKyBsZXhlckRpYWdub3N0aWMubGVuZ3RoIC0gMVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBsZXhlckRpYWdub3N0aWMubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkYXRhOiB0b0RpYWdub3N0aWNEYXRhKHNldmVyaXR5KSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBkaWFnbm9zdGljcy5wdXNoKGRpYWdub3N0aWMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHByb2Nlc3NQYXJzaW5nRXJyb3JzKHBhcnNlUmVzdWx0LCBkaWFnbm9zdGljcywgX29wdGlvbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJzZXJFcnJvciBvZiBwYXJzZVJlc3VsdC5wYXJzZXJFcnJvcnMpIHtcbiAgICAgICAgICAgIGxldCByYW5nZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIFdlIGNhbiBydW4gaW50byB0aGUgY2hldnJvdGFpbiBlcnJvciByZWNvdmVyeSBoZXJlXG4gICAgICAgICAgICAvLyBUaGUgdG9rZW4gY29udGFpbmVkIGluIHRoZSBwYXJzZXIgZXJyb3IgbWlnaHQgYmUgYXV0b21hdGljYWxseSBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gSW4gdGhpcyBjYXNlIGV2ZXJ5IHBvc2l0aW9uIHZhbHVlIHdpbGwgYmUgYE5hTmBcbiAgICAgICAgICAgIGlmIChpc05hTihwYXJzZXJFcnJvci50b2tlbi5zdGFydE9mZnNldCkpIHtcbiAgICAgICAgICAgICAgICAvLyBTb21lIHNwZWNpYWwgcGFyc2VyIGVycm9yIHR5cGVzIGNvbnRhaW4gYSBgcHJldmlvdXNUb2tlbmBcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc2ltcGx5IGFwcGVuZCBvdXIgZGlhZ25vc3RpYyB0byB0aGF0IHRva2VuXG4gICAgICAgICAgICAgICAgaWYgKCdwcmV2aW91c1Rva2VuJyBpbiBwYXJzZXJFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IHBhcnNlckVycm9yLnByZXZpb3VzVG9rZW47XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4odG9rZW4uc3RhcnRPZmZzZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgbGluZTogdG9rZW4uZW5kTGluZSAtIDEsIGNoYXJhY3RlcjogdG9rZW4uZW5kQ29sdW1uIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBObyB2YWxpZCBwcmV2IHRva2VuLiBNaWdodCBiZSBlbXB0eSBkb2N1bWVudCBvciBjb250YWluaW5nIG9ubHkgaGlkZGVuIHRva2Vucy5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvaW50IHRvIGRvY3VtZW50IHN0YXJ0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwb3NpdGlvbiA9IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICByYW5nZSA9IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByYW5nZSA9IHRva2VuVG9SYW5nZShwYXJzZXJFcnJvci50b2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkaWFnbm9zdGljID0ge1xuICAgICAgICAgICAgICAgICAgICBzZXZlcml0eTogdG9EaWFnbm9zdGljU2V2ZXJpdHkoJ2Vycm9yJyksXG4gICAgICAgICAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBwYXJzZXJFcnJvci5tZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBkaWFnbm9zdGljRGF0YShEb2N1bWVudFZhbGlkYXRvci5QYXJzaW5nRXJyb3IpLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuZ2V0U291cmNlKClcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2goZGlhZ25vc3RpYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvY2Vzc0xpbmtpbmdFcnJvcnMoZG9jdW1lbnQsIGRpYWdub3N0aWNzLCBfb3B0aW9ucykge1xuICAgICAgICBmb3IgKGNvbnN0IHJlZmVyZW5jZSBvZiBkb2N1bWVudC5yZWZlcmVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5raW5nRXJyb3IgPSByZWZlcmVuY2UuZXJyb3I7XG4gICAgICAgICAgICBpZiAobGlua2luZ0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZTogbGlua2luZ0Vycm9yLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHk6IGxpbmtpbmdFcnJvci5wcm9wZXJ0eSxcbiAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGxpbmtpbmdFcnJvci5pbmRleCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogRG9jdW1lbnRWYWxpZGF0b3IuTGlua2luZ0Vycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyVHlwZTogbGlua2luZ0Vycm9yLmNvbnRhaW5lci4kdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3BlcnR5OiBsaW5raW5nRXJyb3IucHJvcGVydHksXG4gICAgICAgICAgICAgICAgICAgICAgICByZWZUZXh0OiBsaW5raW5nRXJyb3IucmVmZXJlbmNlLiRyZWZUZXh0XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGRpYWdub3N0aWNzLnB1c2godGhpcy50b0RpYWdub3N0aWMoJ2Vycm9yJywgbGlua2luZ0Vycm9yLm1lc3NhZ2UsIGluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyB2YWxpZGF0ZUFzdChyb290Tm9kZSwgb3B0aW9ucywgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRpb25JdGVtcyA9IFtdO1xuICAgICAgICBjb25zdCBhY2NlcHRvciA9IChzZXZlcml0eSwgbWVzc2FnZSwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdmFsaWRhdGlvbkl0ZW1zLnB1c2godGhpcy50b0RpYWdub3N0aWMoc2V2ZXJpdHksIG1lc3NhZ2UsIGluZm8pKTtcbiAgICAgICAgfTtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUFzdEJlZm9yZShyb290Tm9kZSwgb3B0aW9ucywgYWNjZXB0b3IsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUFzdE5vZGVzKHJvb3ROb2RlLCBvcHRpb25zLCBhY2NlcHRvciwgY2FuY2VsVG9rZW4pO1xuICAgICAgICBhd2FpdCB0aGlzLnZhbGlkYXRlQXN0QWZ0ZXIocm9vdE5vZGUsIG9wdGlvbnMsIGFjY2VwdG9yLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIHJldHVybiB2YWxpZGF0aW9uSXRlbXM7XG4gICAgfVxuICAgIGFzeW5jIHZhbGlkYXRlQXN0QmVmb3JlKHJvb3ROb2RlLCBvcHRpb25zLCBhY2NlcHRvciwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgY2hlY2tzQmVmb3JlID0gdGhpcy52YWxpZGF0aW9uUmVnaXN0cnkuY2hlY2tzQmVmb3JlO1xuICAgICAgICBmb3IgKGNvbnN0IGNoZWNrQmVmb3JlIG9mIGNoZWNrc0JlZm9yZSkge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tCZWZvcmUocm9vdE5vZGUsIGFjY2VwdG9yLCAoX2EgPSBvcHRpb25zLmNhdGVnb3JpZXMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVBc3ROb2Rlcyhyb290Tm9kZSwgb3B0aW9ucywgYWNjZXB0b3IsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChzdHJlYW1Bc3Qocm9vdE5vZGUpLm1hcChhc3luYyAobm9kZSkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgY29uc3QgY2hlY2tzID0gdGhpcy52YWxpZGF0aW9uUmVnaXN0cnkuZ2V0Q2hlY2tzKG5vZGUuJHR5cGUsIG9wdGlvbnMuY2F0ZWdvcmllcyk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGNoZWNrcykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGNoZWNrKG5vZGUsIGFjY2VwdG9yLCBjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgYXN5bmMgdmFsaWRhdGVBc3RBZnRlcihyb290Tm9kZSwgb3B0aW9ucywgYWNjZXB0b3IsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGNoZWNrc0FmdGVyID0gdGhpcy52YWxpZGF0aW9uUmVnaXN0cnkuY2hlY2tzQWZ0ZXI7XG4gICAgICAgIGZvciAoY29uc3QgY2hlY2tBZnRlciBvZiBjaGVja3NBZnRlcikge1xuICAgICAgICAgICAgYXdhaXQgaW50ZXJydXB0QW5kQ2hlY2soY2FuY2VsVG9rZW4pO1xuICAgICAgICAgICAgYXdhaXQgY2hlY2tBZnRlcihyb290Tm9kZSwgYWNjZXB0b3IsIChfYSA9IG9wdGlvbnMuY2F0ZWdvcmllcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIGNhbmNlbFRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0b0RpYWdub3N0aWMoc2V2ZXJpdHksIG1lc3NhZ2UsIGluZm8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICByYW5nZTogZ2V0RGlhZ25vc3RpY1JhbmdlKGluZm8pLFxuICAgICAgICAgICAgc2V2ZXJpdHk6IHRvRGlhZ25vc3RpY1NldmVyaXR5KHNldmVyaXR5KSxcbiAgICAgICAgICAgIGNvZGU6IGluZm8uY29kZSxcbiAgICAgICAgICAgIGNvZGVEZXNjcmlwdGlvbjogaW5mby5jb2RlRGVzY3JpcHRpb24sXG4gICAgICAgICAgICB0YWdzOiBpbmZvLnRhZ3MsXG4gICAgICAgICAgICByZWxhdGVkSW5mb3JtYXRpb246IGluZm8ucmVsYXRlZEluZm9ybWF0aW9uLFxuICAgICAgICAgICAgZGF0YTogaW5mby5kYXRhLFxuICAgICAgICAgICAgc291cmNlOiB0aGlzLmdldFNvdXJjZSgpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWV0YWRhdGEubGFuZ3VhZ2VJZDtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlhZ25vc3RpY1JhbmdlKGluZm8pIHtcbiAgICBpZiAoaW5mby5yYW5nZSkge1xuICAgICAgICByZXR1cm4gaW5mby5yYW5nZTtcbiAgICB9XG4gICAgbGV0IGNzdE5vZGU7XG4gICAgaWYgKHR5cGVvZiBpbmZvLnByb3BlcnR5ID09PSAnc3RyaW5nJykge1xuICAgICAgICBjc3ROb2RlID0gZmluZE5vZGVGb3JQcm9wZXJ0eShpbmZvLm5vZGUuJGNzdE5vZGUsIGluZm8ucHJvcGVydHksIGluZm8uaW5kZXgpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgaW5mby5rZXl3b3JkID09PSAnc3RyaW5nJykge1xuICAgICAgICBjc3ROb2RlID0gZmluZE5vZGVGb3JLZXl3b3JkKGluZm8ubm9kZS4kY3N0Tm9kZSwgaW5mby5rZXl3b3JkLCBpbmZvLmluZGV4KTtcbiAgICB9XG4gICAgY3N0Tm9kZSAhPT0gbnVsbCAmJiBjc3ROb2RlICE9PSB2b2lkIDAgPyBjc3ROb2RlIDogKGNzdE5vZGUgPSBpbmZvLm5vZGUuJGNzdE5vZGUpO1xuICAgIGlmICghY3N0Tm9kZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhcnQ6IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH0sXG4gICAgICAgICAgICBlbmQ6IHsgbGluZTogMCwgY2hhcmFjdGVyOiAwIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNzdE5vZGUucmFuZ2U7XG59XG4vKipcbiAqIFRyYW5zZm9ybXMgdGhlIGRpYWdub3N0aWMgc2V2ZXJpdHkgZnJvbSB0aGUge0BsaW5rIExleGluZ0RpYWdub3N0aWNTZXZlcml0eX0gZm9ybWF0IHRvIExTUCdzIGBEaWFnbm9zdGljU2V2ZXJpdHlgIGZvcm1hdC5cbiAqXG4gKiBAcGFyYW0gc2V2ZXJpdHkgVGhlIGxleGluZyBkaWFnbm9zdGljIHNldmVyaXR5XG4gKiBAcmV0dXJucyBEaWFnbm9zdGljIHNldmVyaXR5IGFjY29yZGluZyB0byBgdnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzL2xpYi9lc20vbWFpbi5qcyNEaWFnbm9zdGljU2V2ZXJpdHlgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b0RpYWdub3N0aWNTZXZlcml0eShzZXZlcml0eSkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIGNhc2UgJ3dhcm5pbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDI7XG4gICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIGNhc2UgJ2hpbnQnOlxuICAgICAgICAgICAgcmV0dXJuIDQ7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZGlhZ25vc3RpYyBzZXZlcml0eTogJyArIHNldmVyaXR5KTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdG9EaWFnbm9zdGljRGF0YShzZXZlcml0eSkge1xuICAgIHN3aXRjaCAoc2V2ZXJpdHkpIHtcbiAgICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNEYXRhKERvY3VtZW50VmFsaWRhdG9yLkxleGluZ0Vycm9yKTtcbiAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICByZXR1cm4gZGlhZ25vc3RpY0RhdGEoRG9jdW1lbnRWYWxpZGF0b3IuTGV4aW5nV2FybmluZyk7XG4gICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgcmV0dXJuIGRpYWdub3N0aWNEYXRhKERvY3VtZW50VmFsaWRhdG9yLkxleGluZ0luZm8pO1xuICAgICAgICBjYXNlICdoaW50JzpcbiAgICAgICAgICAgIHJldHVybiBkaWFnbm9zdGljRGF0YShEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdIaW50KTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBkaWFnbm9zdGljIHNldmVyaXR5OiAnICsgc2V2ZXJpdHkpO1xuICAgIH1cbn1cbmV4cG9ydCB2YXIgRG9jdW1lbnRWYWxpZGF0b3I7XG4oZnVuY3Rpb24gKERvY3VtZW50VmFsaWRhdG9yKSB7XG4gICAgRG9jdW1lbnRWYWxpZGF0b3IuTGV4aW5nRXJyb3IgPSAnbGV4aW5nLWVycm9yJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdXYXJuaW5nID0gJ2xleGluZy13YXJuaW5nJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdJbmZvID0gJ2xleGluZy1pbmZvJztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5MZXhpbmdIaW50ID0gJ2xleGluZy1oaW50JztcbiAgICBEb2N1bWVudFZhbGlkYXRvci5QYXJzaW5nRXJyb3IgPSAncGFyc2luZy1lcnJvcic7XG4gICAgRG9jdW1lbnRWYWxpZGF0b3IuTGlua2luZ0Vycm9yID0gJ2xpbmtpbmctZXJyb3InO1xufSkoRG9jdW1lbnRWYWxpZGF0b3IgfHwgKERvY3VtZW50VmFsaWRhdG9yID0ge30pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50LXZhbGlkYXRvci5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMSBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBhc3NlcnRVbnJlYWNoYWJsZSB9IGZyb20gJy4uL2luZGV4LmpzJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnLi4vdXRpbHMvY29sbGVjdGlvbnMuanMnO1xuaW1wb3J0IHsgaXNPcGVyYXRpb25DYW5jZWxsZWQgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG4vKipcbiAqIENyZWF0ZSBEaWFnbm9zdGljRGF0YSBmb3IgYSBnaXZlbiBkaWFnbm9zdGljIGNvZGUuIFRoZSByZXN1bHQgY2FuIGJlIHB1dCBpbnRvIHRoZSBgZGF0YWAgZmllbGQgb2YgYSBEaWFnbm9zdGljSW5mby5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGRpYWdub3N0aWNEYXRhKGNvZGUpIHtcbiAgICByZXR1cm4geyBjb2RlIH07XG59XG5leHBvcnQgdmFyIFZhbGlkYXRpb25DYXRlZ29yeTtcbihmdW5jdGlvbiAoVmFsaWRhdGlvbkNhdGVnb3J5KSB7XG4gICAgVmFsaWRhdGlvbkNhdGVnb3J5LmFsbCA9IFsnZmFzdCcsICdzbG93JywgJ2J1aWx0LWluJ107XG59KShWYWxpZGF0aW9uQ2F0ZWdvcnkgfHwgKFZhbGlkYXRpb25DYXRlZ29yeSA9IHt9KSk7XG4vKipcbiAqIE1hbmFnZXMgYSBzZXQgb2YgYFZhbGlkYXRpb25DaGVja2BzIHRvIGJlIGFwcGxpZWQgd2hlbiBkb2N1bWVudHMgYXJlIHZhbGlkYXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhbGlkYXRpb25SZWdpc3RyeSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmljZXMpIHtcbiAgICAgICAgdGhpcy5lbnRyaWVzID0gbmV3IE11bHRpTWFwKCk7XG4gICAgICAgIHRoaXMuZW50cmllc0JlZm9yZSA9IFtdO1xuICAgICAgICB0aGlzLmVudHJpZXNBZnRlciA9IFtdO1xuICAgICAgICB0aGlzLnJlZmxlY3Rpb24gPSBzZXJ2aWNlcy5zaGFyZWQuQXN0UmVmbGVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgYSBzZXQgb2YgdmFsaWRhdGlvbiBjaGVja3MuIEVhY2ggdmFsdWUgaW4gdGhlIHJlY29yZCBjYW4gYmUgZWl0aGVyIGEgc2luZ2xlIHZhbGlkYXRpb24gY2hlY2sgKGkuZS4gYSBmdW5jdGlvbilcbiAgICAgKiBvciBhbiBhcnJheSBvZiB2YWxpZGF0aW9uIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGVja3NSZWNvcmQgU2V0IG9mIHZhbGlkYXRpb24gY2hlY2tzIHRvIHJlZ2lzdGVyLlxuICAgICAqIEBwYXJhbSBjYXRlZ29yeSBPcHRpb25hbCBjYXRlZ29yeSBmb3IgdGhlIHZhbGlkYXRpb24gY2hlY2tzIChkZWZhdWx0cyB0byBgJ2Zhc3QnYCkuXG4gICAgICogQHBhcmFtIHRoaXNPYmogT3B0aW9uYWwgb2JqZWN0IHRvIGJlIHVzZWQgYXMgYHRoaXNgIHdoZW4gY2FsbGluZyB0aGUgdmFsaWRhdGlvbiBjaGVjayBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgcmVnaXN0ZXIoY2hlY2tzUmVjb3JkLCB0aGlzT2JqID0gdGhpcywgY2F0ZWdvcnkgPSAnZmFzdCcpIHtcbiAgICAgICAgaWYgKGNhdGVnb3J5ID09PSAnYnVpbHQtaW4nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgJ2J1aWx0LWluJyBjYXRlZ29yeSBpcyByZXNlcnZlZCBmb3IgbGV4ZXIsIHBhcnNlciwgYW5kIGxpbmtlciBlcnJvcnMuXCIpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW3R5cGUsIGNoXSBvZiBPYmplY3QuZW50cmllcyhjaGVja3NSZWNvcmQpKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjaDtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNhbGxiYWNrcykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoZWNrIG9mIGNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrOiB0aGlzLndyYXBWYWxpZGF0aW9uRXhjZXB0aW9uKGNoZWNrLCB0aGlzT2JqKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkRW50cnkodHlwZSwgZW50cnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjYWxsYmFja3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgICAgICAgICAgY2hlY2s6IHRoaXMud3JhcFZhbGlkYXRpb25FeGNlcHRpb24oY2FsbGJhY2tzLCB0aGlzT2JqKSxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRW50cnkodHlwZSwgZW50cnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VW5yZWFjaGFibGUoY2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICB3cmFwVmFsaWRhdGlvbkV4Y2VwdGlvbihjaGVjaywgdGhpc09iaikge1xuICAgICAgICByZXR1cm4gYXN5bmMgKG5vZGUsIGFjY2VwdCwgY2FuY2VsVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXhjZXB0aW9uKCgpID0+IGNoZWNrLmNhbGwodGhpc09iaiwgbm9kZSwgYWNjZXB0LCBjYW5jZWxUb2tlbiksICdBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdmFsaWRhdGlvbicsIGFjY2VwdCwgbm9kZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIGhhbmRsZUV4Y2VwdGlvbihmdW5jdGlvbmFsaXR5LCBtZXNzYWdlQ29udGV4dCwgYWNjZXB0LCBub2RlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCBmdW5jdGlvbmFsaXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgaWYgKGlzT3BlcmF0aW9uQ2FuY2VsbGVkKGVycikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGAke21lc3NhZ2VDb250ZXh0fTpgLCBlcnIpO1xuICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yICYmIGVyci5zdGFjaykge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLnN0YWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VEZXRhaWxzID0gZXJyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnIubWVzc2FnZSA6IFN0cmluZyhlcnIpO1xuICAgICAgICAgICAgYWNjZXB0KCdlcnJvcicsIGAke21lc3NhZ2VDb250ZXh0fTogJHttZXNzYWdlRGV0YWlsc31gLCB7IG5vZGUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkRW50cnkodHlwZSwgZW50cnkpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdBc3ROb2RlJykge1xuICAgICAgICAgICAgdGhpcy5lbnRyaWVzLmFkZCgnQXN0Tm9kZScsIGVudHJ5KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHN1YnR5cGUgb2YgdGhpcy5yZWZsZWN0aW9uLmdldEFsbFN1YlR5cGVzKHR5cGUpKSB7XG4gICAgICAgICAgICB0aGlzLmVudHJpZXMuYWRkKHN1YnR5cGUsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRDaGVja3ModHlwZSwgY2F0ZWdvcmllcykge1xuICAgICAgICBsZXQgY2hlY2tzID0gc3RyZWFtKHRoaXMuZW50cmllcy5nZXQodHlwZSkpXG4gICAgICAgICAgICAuY29uY2F0KHRoaXMuZW50cmllcy5nZXQoJ0FzdE5vZGUnKSk7XG4gICAgICAgIGlmIChjYXRlZ29yaWVzKSB7XG4gICAgICAgICAgICBjaGVja3MgPSBjaGVja3MuZmlsdGVyKGVudHJ5ID0+IGNhdGVnb3JpZXMuaW5jbHVkZXMoZW50cnkuY2F0ZWdvcnkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hlY2tzLm1hcChlbnRyeSA9PiBlbnRyeS5jaGVjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGxvZ2ljIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSBiZWZvcmUgdmFsaWRhdGluZyBhbGwgdGhlIG5vZGVzIG9mIGFuIEFTVC9MYW5naXVtIGRvY3VtZW50LlxuICAgICAqIFRoaXMgaGVscHMgdG8gcHJlcGFyZSBvciBpbml0aWFsaXplIHNvbWUgaW5mb3JtYXRpb24gd2hpY2ggYXJlIHJlcXVpcmVkIG9yIHJldXNhYmxlIGZvciB0aGUgZm9sbG93aW5nIGNoZWNrcyBvbiB0aGUgQXN0Tm9kZXMuXG4gICAgICpcbiAgICAgKiBBcyBhbiBleGFtcGxlLCBmb3IgdmFsaWRhdGluZyB1bmlxdWUgZnVsbHktcXVhbGlmaWVkIG5hbWVzIG9mIG5vZGVzIGluIHRoZSBBU1QsXG4gICAgICogaGVyZSB0aGUgbWFwIGZvciBtYXBwaW5nIG5hbWVzIHRvIG5vZGVzIGNvdWxkIGJlIGVzdGFibGlzaGVkLlxuICAgICAqIER1cmluZyB0aGUgdXN1YWwgY2hlY2tzIG9uIHRoZSBub2RlcywgdGhleSBhcmUgcHV0IGludG8gdGhpcyBtYXAgd2l0aCB0aGVpciBuYW1lLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHRoaXMgYXBwcm9hY2ggbWFrZXMgdmFsaWRhdGlvbnMgc3RhdGVmdWwsIHdoaWNoIGlzIHJlbGV2YW50IGUuZy4gd2hlbiBjYW5jZWxsaW5nIHRoZSB2YWxpZGF0aW9uLlxuICAgICAqIFRoZXJlZm9yZSBpdCBpcyByZWNvbW1lbmRlZCB0byBjbGVhciBzdG9yZWQgaW5mb3JtYXRpb25cbiAgICAgKiBfYmVmb3JlXyB2YWxpZGF0aW5nIGFuIEFTVCB0byB2YWxpZGF0ZSBlYWNoIEFTVCB1bmFmZmVjdGVkIGZyb20gb3RoZXIgQVNUc1xuICAgICAqIEFORCBfYWZ0ZXJfIHZhbGlkYXRpbmcgdGhlIEFTVCB0byBmcmVlIG1lbW9yeSBieSBpbmZvcm1hdGlvbiB3aGljaCBhcmUgbm8gbG9uZ2VyIHVzZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hlY2tCZWZvcmUgYSBzZXQtdXAgZnVuY3Rpb24gd2hpY2ggd2lsbCBiZSBjYWxsZWQgb25jZSBiZWZvcmUgYWN0dWFsbHkgdmFsaWRhdGluZyBhbiBBU1RcbiAgICAgKiBAcGFyYW0gdGhpc09iaiBPcHRpb25hbCBvYmplY3QgdG8gYmUgdXNlZCBhcyBgdGhpc2Agd2hlbiBjYWxsaW5nIHRoZSB2YWxpZGF0aW9uIGNoZWNrIGZ1bmN0aW9ucy5cbiAgICAgKi9cbiAgICByZWdpc3RlckJlZm9yZURvY3VtZW50KGNoZWNrQmVmb3JlLCB0aGlzT2JqID0gdGhpcykge1xuICAgICAgICB0aGlzLmVudHJpZXNCZWZvcmUucHVzaCh0aGlzLndyYXBQcmVwYXJhdGlvbkV4Y2VwdGlvbihjaGVja0JlZm9yZSwgJ0FuIGVycm9yIG9jY3VycmVkIGR1cmluZyBzZXQtdXAgb2YgdGhlIHZhbGlkYXRpb24nLCB0aGlzT2JqKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGxvZ2ljIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSBhZnRlciB2YWxpZGF0aW5nIGFsbCB0aGUgbm9kZXMgb2YgYW4gQVNUL0xhbmdpdW0gZG9jdW1lbnQuXG4gICAgICogVGhpcyBoZWxwcyB0byBmaW5hbGx5IGV2YWx1YXRlIGluZm9ybWF0aW9uIHdoaWNoIGFyZSBjb2xsZWN0ZWQgZHVyaW5nIHRoZSBjaGVja3Mgb24gdGhlIEFzdE5vZGVzLlxuICAgICAqXG4gICAgICogQXMgYW4gZXhhbXBsZSwgZm9yIHZhbGlkYXRpbmcgdW5pcXVlIGZ1bGx5LXF1YWxpZmllZCBuYW1lcyBvZiBub2RlcyBpbiB0aGUgQVNULFxuICAgICAqIGhlcmUgdGhlIG1hcCB3aXRoIGFsbCB0aGUgY29sbGVjdGVkIG5vZGVzIGFuZCB0aGVpciBuYW1lcyBpcyBjaGVja2VkXG4gICAgICogYW5kIHZhbGlkYXRpb24gaGludHMgYXJlIGNyZWF0ZWQgZm9yIGFsbCBub2RlcyB3aXRoIHRoZSBzYW1lIG5hbWUuXG4gICAgICpcbiAgICAgKiBOb3RlIHRoYXQgdGhpcyBhcHByb2FjaCBtYWtlcyB2YWxpZGF0aW9ucyBzdGF0ZWZ1bCwgd2hpY2ggaXMgcmVsZXZhbnQgZS5nLiB3aGVuIGNhbmNlbGxpbmcgdGhlIHZhbGlkYXRpb24uXG4gICAgICogVGhlcmVmb3JlIGl0IGlzIHJlY29tbWVuZGVkIHRvIGNsZWFyIHN0b3JlZCBpbmZvcm1hdGlvblxuICAgICAqIF9iZWZvcmVfIHZhbGlkYXRpbmcgYW4gQVNUIHRvIHZhbGlkYXRlIGVhY2ggQVNUIHVuYWZmZWN0ZWQgZnJvbSBvdGhlciBBU1RzXG4gICAgICogQU5EIF9hZnRlcl8gdmFsaWRhdGluZyB0aGUgQVNUIHRvIGZyZWUgbWVtb3J5IGJ5IGluZm9ybWF0aW9uIHdoaWNoIGFyZSBubyBsb25nZXIgdXNlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGVja0JlZm9yZSBhIHNldC11cCBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBvbmNlIGJlZm9yZSBhY3R1YWxseSB2YWxpZGF0aW5nIGFuIEFTVFxuICAgICAqIEBwYXJhbSB0aGlzT2JqIE9wdGlvbmFsIG9iamVjdCB0byBiZSB1c2VkIGFzIGB0aGlzYCB3aGVuIGNhbGxpbmcgdGhlIHZhbGlkYXRpb24gY2hlY2sgZnVuY3Rpb25zLlxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWZ0ZXJEb2N1bWVudChjaGVja0FmdGVyLCB0aGlzT2JqID0gdGhpcykge1xuICAgICAgICB0aGlzLmVudHJpZXNBZnRlci5wdXNoKHRoaXMud3JhcFByZXBhcmF0aW9uRXhjZXB0aW9uKGNoZWNrQWZ0ZXIsICdBbiBlcnJvciBvY2N1cnJlZCBkdXJpbmcgdGVhci1kb3duIG9mIHRoZSB2YWxpZGF0aW9uJywgdGhpc09iaikpO1xuICAgIH1cbiAgICB3cmFwUHJlcGFyYXRpb25FeGNlcHRpb24oY2hlY2ssIG1lc3NhZ2VDb250ZXh0LCB0aGlzT2JqKSB7XG4gICAgICAgIHJldHVybiBhc3luYyAocm9vdE5vZGUsIGFjY2VwdCwgY2F0ZWdvcmllcywgY2FuY2VsVG9rZW4pID0+IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuaGFuZGxlRXhjZXB0aW9uKCgpID0+IGNoZWNrLmNhbGwodGhpc09iaiwgcm9vdE5vZGUsIGFjY2VwdCwgY2F0ZWdvcmllcywgY2FuY2VsVG9rZW4pLCBtZXNzYWdlQ29udGV4dCwgYWNjZXB0LCByb290Tm9kZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBjaGVja3NCZWZvcmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVudHJpZXNCZWZvcmU7XG4gICAgfVxuICAgIGdldCBjaGVja3NBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllc0FmdGVyO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZhbGlkYXRpb24tcmVnaXN0cnkuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgQ2FuY2VsbGF0aW9uVG9rZW4gfSBmcm9tICcuLi91dGlscy9jYW5jZWxsYXRpb24uanMnO1xuaW1wb3J0IHsgaXNMaW5raW5nRXJyb3IgfSBmcm9tICcuLi9zeW50YXgtdHJlZS5qcyc7XG5pbXBvcnQgeyBnZXREb2N1bWVudCwgc3RyZWFtQXN0LCBzdHJlYW1SZWZlcmVuY2VzIH0gZnJvbSAnLi4vdXRpbHMvYXN0LXV0aWxzLmpzJztcbmltcG9ydCB7IHRvRG9jdW1lbnRTZWdtZW50IH0gZnJvbSAnLi4vdXRpbHMvY3N0LXV0aWxzLmpzJztcbmltcG9ydCB7IGludGVycnVwdEFuZENoZWNrIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG5pbXBvcnQgeyBVcmlVdGlscyB9IGZyb20gJy4uL3V0aWxzL3VyaS11dGlscy5qcyc7XG5leHBvcnQgY2xhc3MgRGVmYXVsdEFzdE5vZGVEZXNjcmlwdGlvblByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmFzdE5vZGVMb2NhdG9yID0gc2VydmljZXMud29ya3NwYWNlLkFzdE5vZGVMb2NhdG9yO1xuICAgICAgICB0aGlzLm5hbWVQcm92aWRlciA9IHNlcnZpY2VzLnJlZmVyZW5jZXMuTmFtZVByb3ZpZGVyO1xuICAgIH1cbiAgICBjcmVhdGVEZXNjcmlwdGlvbihub2RlLCBuYW1lLCBkb2N1bWVudCkge1xuICAgICAgICBjb25zdCBkb2MgPSBkb2N1bWVudCAhPT0gbnVsbCAmJiBkb2N1bWVudCAhPT0gdm9pZCAwID8gZG9jdW1lbnQgOiBnZXREb2N1bWVudChub2RlKTtcbiAgICAgICAgbmFtZSAhPT0gbnVsbCAmJiBuYW1lICE9PSB2b2lkIDAgPyBuYW1lIDogKG5hbWUgPSB0aGlzLm5hbWVQcm92aWRlci5nZXROYW1lKG5vZGUpKTtcbiAgICAgICAgY29uc3QgcGF0aCA9IHRoaXMuYXN0Tm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgobm9kZSk7XG4gICAgICAgIGlmICghbmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIGF0IHBhdGggJHtwYXRofSBoYXMgbm8gbmFtZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmFtZU5vZGVTZWdtZW50O1xuICAgICAgICBjb25zdCBuYW1lU2VnbWVudEdldHRlciA9ICgpID0+IHsgdmFyIF9hOyByZXR1cm4gbmFtZU5vZGVTZWdtZW50ICE9PSBudWxsICYmIG5hbWVOb2RlU2VnbWVudCAhPT0gdm9pZCAwID8gbmFtZU5vZGVTZWdtZW50IDogKG5hbWVOb2RlU2VnbWVudCA9IHRvRG9jdW1lbnRTZWdtZW50KChfYSA9IHRoaXMubmFtZVByb3ZpZGVyLmdldE5hbWVOb2RlKG5vZGUpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBub2RlLiRjc3ROb2RlKSk7IH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBub2RlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGdldCBuYW1lU2VnbWVudCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmFtZVNlZ21lbnRHZXR0ZXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxlY3Rpb25TZWdtZW50OiB0b0RvY3VtZW50U2VnbWVudChub2RlLiRjc3ROb2RlKSxcbiAgICAgICAgICAgIHR5cGU6IG5vZGUuJHR5cGUsXG4gICAgICAgICAgICBkb2N1bWVudFVyaTogZG9jLnVyaSxcbiAgICAgICAgICAgIHBhdGhcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdFJlZmVyZW5jZURlc2NyaXB0aW9uUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMubm9kZUxvY2F0b3IgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuQXN0Tm9kZUxvY2F0b3I7XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZURlc2NyaXB0aW9ucyhkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGRlc2NyID0gW107XG4gICAgICAgIGNvbnN0IHJvb3ROb2RlID0gZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWU7XG4gICAgICAgIGZvciAoY29uc3QgYXN0Tm9kZSBvZiBzdHJlYW1Bc3Qocm9vdE5vZGUpKSB7XG4gICAgICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICBzdHJlYW1SZWZlcmVuY2VzKGFzdE5vZGUpLmZpbHRlcihyZWZJbmZvID0+ICFpc0xpbmtpbmdFcnJvcihyZWZJbmZvKSkuZm9yRWFjaChyZWZJbmZvID0+IHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBsb2dnaW5nIGEgd2FybmluZyBvciB0aHJvdyBhbiBleGNlcHRpb24gd2hlbiBEb2N1bWVudFN0YXRlIGlzIDwgdGhhbiBMaW5rZWRcbiAgICAgICAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IHRoaXMuY3JlYXRlRGVzY3JpcHRpb24ocmVmSW5mbyk7XG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlc2NyLnB1c2goZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXNjcjtcbiAgICB9XG4gICAgY3JlYXRlRGVzY3JpcHRpb24ocmVmSW5mbykge1xuICAgICAgICBjb25zdCB0YXJnZXROb2RlRGVzY3IgPSByZWZJbmZvLnJlZmVyZW5jZS4kbm9kZURlc2NyaXB0aW9uO1xuICAgICAgICBjb25zdCByZWZDc3ROb2RlID0gcmVmSW5mby5yZWZlcmVuY2UuJHJlZk5vZGU7XG4gICAgICAgIGlmICghdGFyZ2V0Tm9kZURlc2NyIHx8ICFyZWZDc3ROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRvY1VyaSA9IGdldERvY3VtZW50KHJlZkluZm8uY29udGFpbmVyKS51cmk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzb3VyY2VVcmk6IGRvY1VyaSxcbiAgICAgICAgICAgIHNvdXJjZVBhdGg6IHRoaXMubm9kZUxvY2F0b3IuZ2V0QXN0Tm9kZVBhdGgocmVmSW5mby5jb250YWluZXIpLFxuICAgICAgICAgICAgdGFyZ2V0VXJpOiB0YXJnZXROb2RlRGVzY3IuZG9jdW1lbnRVcmksXG4gICAgICAgICAgICB0YXJnZXRQYXRoOiB0YXJnZXROb2RlRGVzY3IucGF0aCxcbiAgICAgICAgICAgIHNlZ21lbnQ6IHRvRG9jdW1lbnRTZWdtZW50KHJlZkNzdE5vZGUpLFxuICAgICAgICAgICAgbG9jYWw6IFVyaVV0aWxzLmVxdWFscyh0YXJnZXROb2RlRGVzY3IuZG9jdW1lbnRVcmksIGRvY1VyaSlcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3QtZGVzY3JpcHRpb25zLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBjbGFzcyBEZWZhdWx0QXN0Tm9kZUxvY2F0b3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNlZ21lbnRTZXBhcmF0b3IgPSAnLyc7XG4gICAgICAgIHRoaXMuaW5kZXhTZXBhcmF0b3IgPSAnQCc7XG4gICAgfVxuICAgIGdldEFzdE5vZGVQYXRoKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUuJGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29uc3QgY29udGFpbmVyUGF0aCA9IHRoaXMuZ2V0QXN0Tm9kZVBhdGgobm9kZS4kY29udGFpbmVyKTtcbiAgICAgICAgICAgIGNvbnN0IG5ld1NlZ21lbnQgPSB0aGlzLmdldFBhdGhTZWdtZW50KG5vZGUpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZVBhdGggPSBjb250YWluZXJQYXRoICsgdGhpcy5zZWdtZW50U2VwYXJhdG9yICsgbmV3U2VnbWVudDtcbiAgICAgICAgICAgIHJldHVybiBub2RlUGF0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIGdldFBhdGhTZWdtZW50KHsgJGNvbnRhaW5lclByb3BlcnR5LCAkY29udGFpbmVySW5kZXggfSkge1xuICAgICAgICBpZiAoISRjb250YWluZXJQcm9wZXJ0eSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyAnJGNvbnRhaW5lclByb3BlcnR5JyBpbiBBU1Qgbm9kZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCRjb250YWluZXJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gJGNvbnRhaW5lclByb3BlcnR5ICsgdGhpcy5pbmRleFNlcGFyYXRvciArICRjb250YWluZXJJbmRleDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJGNvbnRhaW5lclByb3BlcnR5O1xuICAgIH1cbiAgICBnZXRBc3ROb2RlKG5vZGUsIHBhdGgpIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudHMgPSBwYXRoLnNwbGl0KHRoaXMuc2VnbWVudFNlcGFyYXRvcik7XG4gICAgICAgIHJldHVybiBzZWdtZW50cy5yZWR1Y2UoKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwcmV2aW91c1ZhbHVlIHx8IGN1cnJlbnRWYWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5SW5kZXggPSBjdXJyZW50VmFsdWUuaW5kZXhPZih0aGlzLmluZGV4U2VwYXJhdG9yKTtcbiAgICAgICAgICAgIGlmIChwcm9wZXJ0eUluZGV4ID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gY3VycmVudFZhbHVlLnN1YnN0cmluZygwLCBwcm9wZXJ0eUluZGV4KTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcnJheUluZGV4ID0gcGFyc2VJbnQoY3VycmVudFZhbHVlLnN1YnN0cmluZyhwcm9wZXJ0eUluZGV4ICsgMSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gcHJldmlvdXNWYWx1ZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5ID09PSBudWxsIHx8IGFycmF5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhcnJheVthcnJheUluZGV4XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcmV2aW91c1ZhbHVlW2N1cnJlbnRWYWx1ZV07XG4gICAgICAgIH0sIG5vZGUpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFzdC1ub2RlLWxvY2F0b3IuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjIgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgRW1pdHRlciB9IGZyb20gJy4uL3V0aWxzL2V2ZW50LmpzJztcbmltcG9ydCB7IERlZmVycmVkIH0gZnJvbSAnLi4vdXRpbHMvcHJvbWlzZS11dGlscy5qcyc7XG4vKipcbiAqIEJhc2UgY29uZmlndXJhdGlvbiBwcm92aWRlciBmb3IgYnVpbGRpbmcgdXAgb3RoZXIgY29uZmlndXJhdGlvbiBwcm92aWRlcnNcbiAqL1xuZXhwb3J0IGNsYXNzIERlZmF1bHRDb25maWd1cmF0aW9uUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5ID0gbmV3IERlZmVycmVkKCk7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSB7fTtcbiAgICAgICAgdGhpcy53b3Jrc3BhY2VDb25maWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5vbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlRW1pdHRlciA9IG5ldyBFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMuc2VydmljZVJlZ2lzdHJ5ID0gc2VydmljZXMuU2VydmljZVJlZ2lzdHJ5O1xuICAgIH1cbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICBpbml0aWFsaXplKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB0aGlzLndvcmtzcGFjZUNvbmZpZyA9IChfYiA9IChfYSA9IHBhcmFtcy5jYXBhYmlsaXRpZXMud29ya3NwYWNlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uZmlndXJhdGlvbikgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVkKHBhcmFtcykge1xuICAgICAgICBpZiAodGhpcy53b3Jrc3BhY2VDb25maWcpIHtcbiAgICAgICAgICAgIGlmIChwYXJhbXMucmVnaXN0ZXIpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJhbXMucmVnaXN0ZXIoLi4uKSBpcyBhIGZ1bmN0aW9uIHRvIGJlIHByb3ZpZGVkIGJ5IHRoZSBjYWxsaW5nIGxhbmd1YWdlIHNlcnZlciBmb3IgdGhlIHNha2Ugb2ZcbiAgICAgICAgICAgICAgICAvLyAgZGVjb3VwbGluZyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gdGhlIGNvbmNyZXRlIExTUCBpbXBsZW1lbnRhdGlvbnMsIHNwZWNpZmljYWxseSB0aGUgTFNQIENvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICBjb25zdCBsYW5ndWFnZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5hbGw7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnJlZ2lzdGVyKHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTGlzdGVuIHRvIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyBmb3IgYWxsIGxhbmd1YWdlc1xuICAgICAgICAgICAgICAgICAgICBzZWN0aW9uOiBsYW5ndWFnZXMubWFwKGxhbmcgPT4gdGhpcy50b1NlY3Rpb25OYW1lKGxhbmcuTGFuZ3VhZ2VNZXRhRGF0YS5sYW5ndWFnZUlkKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuZmV0Y2hDb25maWd1cmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyYW1zLmZldGNoQ29uZmlndXJhdGlvbiguLi4pIGlzIGEgZnVuY3Rpb24gdG8gYmUgcHJvdmlkZWQgYnkgdGhlIGNhbGxpbmcgbGFuZ3VhZ2Ugc2VydmVyIGZvciB0aGUgc2FrZSBvZlxuICAgICAgICAgICAgICAgIC8vICBkZWNvdXBsaW5nIHRoaXMgaW1wbGVtZW50YXRpb24gZnJvbSB0aGUgY29uY3JldGUgTFNQIGltcGxlbWVudGF0aW9ucywgc3BlY2lmaWNhbGx5IHRoZSBMU1AgQ29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZ1RvVXBkYXRlID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuYWxsLm1hcChsYW5nID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZldGNoIHRoZSBjb25maWd1cmF0aW9uIGNoYW5nZXMgZm9yIGFsbCBsYW5ndWFnZXNcbiAgICAgICAgICAgICAgICAgICAgc2VjdGlvbjogdGhpcy50b1NlY3Rpb25OYW1lKGxhbmcuTGFuZ3VhZ2VNZXRhRGF0YS5sYW5ndWFnZUlkKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBnZXQgd29ya3NwYWNlIGNvbmZpZ3VyYXRpb25zIChkZWZhdWx0IHNjb3BlIFVSSSlcbiAgICAgICAgICAgICAgICBjb25zdCBjb25maWdzID0gYXdhaXQgcGFyYW1zLmZldGNoQ29uZmlndXJhdGlvbihjb25maWdUb1VwZGF0ZSk7XG4gICAgICAgICAgICAgICAgY29uZmlnVG9VcGRhdGUuZm9yRWFjaCgoY29uZiwgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlU2VjdGlvbkNvbmZpZ3VyYXRpb24oY29uZi5zZWN0aW9uLCBjb25maWdzW2lkeF0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlYWR5LnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogIFVwZGF0ZXMgdGhlIGNhY2hlZCBjb25maWd1cmF0aW9ucyB1c2luZyB0aGUgYGNoYW5nZWAgbm90aWZpY2F0aW9uIHBhcmFtZXRlcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlIFRoZSBwYXJhbWV0ZXJzIG9mIGEgY2hhbmdlIGNvbmZpZ3VyYXRpb24gbm90aWZpY2F0aW9uLlxuICAgICAqIGBzZXR0aW5nc2AgcHJvcGVydHkgb2YgdGhlIGNoYW5nZSBvYmplY3QgY291bGQgYmUgZXhwcmVzc2VkIGFzIGBSZWNvcmQ8c3RyaW5nLCBSZWNvcmQ8c3RyaW5nLCBhbnk+PmBcbiAgICAgKi9cbiAgICB1cGRhdGVDb25maWd1cmF0aW9uKGNoYW5nZSkge1xuICAgICAgICBpZiAoIWNoYW5nZS5zZXR0aW5ncykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE9iamVjdC5rZXlzKGNoYW5nZS5zZXR0aW5ncykuZm9yRWFjaChzZWN0aW9uID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSBjaGFuZ2Uuc2V0dGluZ3Nbc2VjdGlvbl07XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNlY3Rpb25Db25maWd1cmF0aW9uKHNlY3Rpb24sIGNvbmZpZ3VyYXRpb24pO1xuICAgICAgICAgICAgdGhpcy5vbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlRW1pdHRlci5maXJlKHsgc2VjdGlvbiwgY29uZmlndXJhdGlvbiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVwZGF0ZVNlY3Rpb25Db25maWd1cmF0aW9uKHNlY3Rpb24sIGNvbmZpZ3VyYXRpb24pIHtcbiAgICAgICAgdGhpcy5zZXR0aW5nc1tzZWN0aW9uXSA9IGNvbmZpZ3VyYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gdmFsdWUgc3RvcmVkIGZvciB0aGUgZ2l2ZW4gbGFuZ3VhZ2UuXG4gICAgKlxuICAgICogQHBhcmFtIGxhbmd1YWdlIFRoZSBsYW5ndWFnZSBpZFxuICAgICogQHBhcmFtIGNvbmZpZ3VyYXRpb24gQ29uZmlndXJhdGlvbiBuYW1lXG4gICAgKi9cbiAgICBhc3luYyBnZXRDb25maWd1cmF0aW9uKGxhbmd1YWdlLCBjb25maWd1cmF0aW9uKSB7XG4gICAgICAgIGF3YWl0IHRoaXMucmVhZHk7XG4gICAgICAgIGNvbnN0IHNlY3Rpb25OYW1lID0gdGhpcy50b1NlY3Rpb25OYW1lKGxhbmd1YWdlKTtcbiAgICAgICAgaWYgKHRoaXMuc2V0dGluZ3Nbc2VjdGlvbk5hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZXR0aW5nc1tzZWN0aW9uTmFtZV1bY29uZmlndXJhdGlvbl07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdG9TZWN0aW9uTmFtZShsYW5ndWFnZUlkKSB7XG4gICAgICAgIHJldHVybiBgJHtsYW5ndWFnZUlkfWA7XG4gICAgfVxuICAgIGdldCBvbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vbkNvbmZpZ3VyYXRpb25TZWN0aW9uVXBkYXRlRW1pdHRlci5ldmVudDtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25maWd1cmF0aW9uLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIxIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuIH0gZnJvbSAnLi4vdXRpbHMvY2FuY2VsbGF0aW9uLmpzJztcbmltcG9ydCB7IERpc3Bvc2FibGUgfSBmcm9tICcuLi91dGlscy9kaXNwb3NhYmxlLmpzJztcbmltcG9ydCB7IE11bHRpTWFwIH0gZnJvbSAnLi4vdXRpbHMvY29sbGVjdGlvbnMuanMnO1xuaW1wb3J0IHsgT3BlcmF0aW9uQ2FuY2VsbGVkLCBpbnRlcnJ1cHRBbmRDaGVjaywgaXNPcGVyYXRpb25DYW5jZWxsZWQgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IHN0cmVhbSB9IGZyb20gJy4uL3V0aWxzL3N0cmVhbS5qcyc7XG5pbXBvcnQgeyBWYWxpZGF0aW9uQ2F0ZWdvcnkgfSBmcm9tICcuLi92YWxpZGF0aW9uL3ZhbGlkYXRpb24tcmVnaXN0cnkuanMnO1xuaW1wb3J0IHsgRG9jdW1lbnRTdGF0ZSB9IGZyb20gJy4vZG9jdW1lbnRzLmpzJztcbmV4cG9ydCBjbGFzcyBEZWZhdWx0RG9jdW1lbnRCdWlsZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLnVwZGF0ZUJ1aWxkT3B0aW9ucyA9IHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQ6IHJ1biBvbmx5IHRoZSBidWlsdC1pbiB2YWxpZGF0aW9uIGNoZWNrcyBhbmQgdGhvc2UgaW4gdGhlIF9mYXN0XyBjYXRlZ29yeSAoaW5jbHVkZXMgdGhvc2Ugd2l0aG91dCBjYXRlZ29yeSlcbiAgICAgICAgICAgIHZhbGlkYXRpb246IHtcbiAgICAgICAgICAgICAgICBjYXRlZ29yaWVzOiBbJ2J1aWx0LWluJywgJ2Zhc3QnXVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUxpc3RlbmVycyA9IFtdO1xuICAgICAgICB0aGlzLmJ1aWxkUGhhc2VMaXN0ZW5lcnMgPSBuZXcgTXVsdGlNYXAoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudFBoYXNlTGlzdGVuZXJzID0gbmV3IE11bHRpTWFwKCk7XG4gICAgICAgIHRoaXMuYnVpbGRTdGF0ZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kb2N1bWVudEJ1aWxkV2FpdGVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBEb2N1bWVudFN0YXRlLkNoYW5nZWQ7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuTGFuZ2l1bURvY3VtZW50RmFjdG9yeTtcbiAgICAgICAgdGhpcy50ZXh0RG9jdW1lbnRzID0gc2VydmljZXMud29ya3NwYWNlLlRleHREb2N1bWVudHM7XG4gICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyID0gc2VydmljZXMud29ya3NwYWNlLkluZGV4TWFuYWdlcjtcbiAgICAgICAgdGhpcy5zZXJ2aWNlUmVnaXN0cnkgPSBzZXJ2aWNlcy5TZXJ2aWNlUmVnaXN0cnk7XG4gICAgfVxuICAgIGFzeW5jIGJ1aWxkKGRvY3VtZW50cywgb3B0aW9ucyA9IHt9LCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgZm9yIChjb25zdCBkb2N1bWVudCBvZiBkb2N1bWVudHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGRvY3VtZW50LnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgaWYgKGRvY3VtZW50LnN0YXRlID09PSBEb2N1bWVudFN0YXRlLlZhbGlkYXRlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52YWxpZGF0aW9uID09PSAnYm9vbGVhbicgJiYgb3B0aW9ucy52YWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvcmNlIHJlLXJ1bm5pbmcgYWxsIHZhbGlkYXRpb24gY2hlY2tzXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LnN0YXRlID0gRG9jdW1lbnRTdGF0ZS5JbmRleGVkUmVmZXJlbmNlcztcbiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQuZGlhZ25vc3RpY3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMudmFsaWRhdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnVpbGRTdGF0ZSA9IHRoaXMuYnVpbGRTdGF0ZS5nZXQoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJldmlvdXNDYXRlZ29yaWVzID0gKF9hID0gYnVpbGRTdGF0ZSA9PT0gbnVsbCB8fCBidWlsZFN0YXRlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBidWlsZFN0YXRlLnJlc3VsdCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnZhbGlkYXRpb25DaGVja3M7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhdGVnb3JpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFZhbGlkYXRpb24gd2l0aCBleHBsaWNpdCBvcHRpb25zIHdhcyByZXF1ZXN0ZWQgZm9yIGEgZG9jdW1lbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIHBhcnRseSB2YWxpZGF0ZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHdlIG5lZWQgdG8gbWVyZ2UgdGhlIHByZXZpb3VzIHZhbGlkYXRpb24gY2F0ZWdvcmllcyB3aXRoIHRoZSBuZXcgb25lcy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NhdGVnb3JpZXMgPSAoX2IgPSBvcHRpb25zLnZhbGlkYXRpb24uY2F0ZWdvcmllcykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogVmFsaWRhdGlvbkNhdGVnb3J5LmFsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhdGVnb3JpZXMgPSBuZXdDYXRlZ29yaWVzLmZpbHRlcihjID0+ICFwcmV2aW91c0NhdGVnb3JpZXMuaW5jbHVkZXMoYykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdGVnb3JpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb246IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucy52YWxpZGF0aW9uKSwgeyBjYXRlZ29yaWVzIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDogYnVpbGRTdGF0ZS5yZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5zdGF0ZSA9IERvY3VtZW50U3RhdGUuSW5kZXhlZFJlZmVyZW5jZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEZWZhdWx0OiBmb3JnZXQgYW55IHByZXZpb3VzIGJ1aWxkIG9wdGlvbnNcbiAgICAgICAgICAgICAgICB0aGlzLmJ1aWxkU3RhdGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBEb2N1bWVudFN0YXRlLkNoYW5nZWQ7XG4gICAgICAgIGF3YWl0IHRoaXMuZW1pdFVwZGF0ZShkb2N1bWVudHMubWFwKGUgPT4gZS51cmkpLCBbXSk7XG4gICAgICAgIGF3YWl0IHRoaXMuYnVpbGREb2N1bWVudHMoZG9jdW1lbnRzLCBvcHRpb25zLCBjYW5jZWxUb2tlbik7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZShjaGFuZ2VkLCBkZWxldGVkLCBjYW5jZWxUb2tlbiA9IENhbmNlbGxhdGlvblRva2VuLk5vbmUpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSBEb2N1bWVudFN0YXRlLkNoYW5nZWQ7XG4gICAgICAgIC8vIFJlbW92ZSBhbGwgbWV0YWRhdGEgb2YgZG9jdW1lbnRzIHRoYXQgYXJlIHJlcG9ydGVkIGFzIGRlbGV0ZWRcbiAgICAgICAgZm9yIChjb25zdCBkZWxldGVkVXJpIG9mIGRlbGV0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cy5kZWxldGVEb2N1bWVudChkZWxldGVkVXJpKTtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5kZWxldGUoZGVsZXRlZFVyaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMuaW5kZXhNYW5hZ2VyLnJlbW92ZShkZWxldGVkVXJpKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgdGhlIHN0YXRlIG9mIGFsbCBjaGFuZ2VkIGRvY3VtZW50cyB0byBgQ2hhbmdlZGAgc28gdGhleSBhcmUgY29tcGxldGVseSByZWJ1aWx0XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlZFVyaSBvZiBjaGFuZ2VkKSB7XG4gICAgICAgICAgICBjb25zdCBpbnZhbGlkYXRlZCA9IHRoaXMubGFuZ2l1bURvY3VtZW50cy5pbnZhbGlkYXRlRG9jdW1lbnQoY2hhbmdlZFVyaSk7XG4gICAgICAgICAgICBpZiAoIWludmFsaWRhdGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgY3JlYXRlIGFuIHVucGFyc2VkLCBpbnZhbGlkIGRvY3VtZW50LlxuICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBiZSBwYXJzZWQgYXMgc29vbiBhcyB3ZSByZWFjaCB0aGUgZmlyc3QgZG9jdW1lbnQgYnVpbGRlciBwaGFzZS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFsbG93cyB0byBjYW5jZWwgdGhlIHBhcnNpbmcgcHJvY2VzcyBsYXRlciBpbiBjYXNlIHdlIG5lZWQgaXQuXG4gICAgICAgICAgICAgICAgY29uc3QgbmV3RG9jdW1lbnQgPSB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbU1vZGVsKHsgJHR5cGU6ICdJTlZBTElEJyB9LCBjaGFuZ2VkVXJpKTtcbiAgICAgICAgICAgICAgICBuZXdEb2N1bWVudC5zdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgICAgICAgICB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuYWRkRG9jdW1lbnQobmV3RG9jdW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5idWlsZFN0YXRlLmRlbGV0ZShjaGFuZ2VkVXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCB0aGUgc3RhdGUgb2YgYWxsIGRvY3VtZW50cyB0aGF0IHNob3VsZCBiZSByZWxpbmtlZCB0byBgQ29tcHV0ZWRTY29wZXNgIChpZiBub3QgYWxyZWFkeSBsb3dlcilcbiAgICAgICAgY29uc3QgYWxsQ2hhbmdlZFVyaXMgPSBzdHJlYW0oY2hhbmdlZCkuY29uY2F0KGRlbGV0ZWQpLm1hcCh1cmkgPT4gdXJpLnRvU3RyaW5nKCkpLnRvU2V0KCk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cy5hbGxcbiAgICAgICAgICAgIC5maWx0ZXIoZG9jID0+ICFhbGxDaGFuZ2VkVXJpcy5oYXMoZG9jLnVyaS50b1N0cmluZygpKSAmJiB0aGlzLnNob3VsZFJlbGluayhkb2MsIGFsbENoYW5nZWRVcmlzKSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGRvYyA9PiB7XG4gICAgICAgICAgICBjb25zdCBsaW5rZXIgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyhkb2MudXJpKS5yZWZlcmVuY2VzLkxpbmtlcjtcbiAgICAgICAgICAgIGxpbmtlci51bmxpbmsoZG9jKTtcbiAgICAgICAgICAgIGRvYy5zdGF0ZSA9IE1hdGgubWluKGRvYy5zdGF0ZSwgRG9jdW1lbnRTdGF0ZS5Db21wdXRlZFNjb3Blcyk7XG4gICAgICAgICAgICBkb2MuZGlhZ25vc3RpY3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3RpZnkgbGlzdGVuZXJzIG9mIHRoZSB1cGRhdGVcbiAgICAgICAgYXdhaXQgdGhpcy5lbWl0VXBkYXRlKGNoYW5nZWQsIGRlbGV0ZWQpO1xuICAgICAgICAvLyBPbmx5IGFsbG93IGludGVycnVwdGluZyB0aGUgZXhlY3V0aW9uIGFmdGVyIGFsbCBzdGF0ZSBjaGFuZ2VzIGFyZSBkb25lXG4gICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgLy8gQ29sbGVjdCBhbmQgc29ydCBhbGwgZG9jdW1lbnRzIHRoYXQgd2Ugc2hvdWxkIHJlYnVpbGRcbiAgICAgICAgY29uc3QgcmVidWlsZERvY3VtZW50cyA9IHRoaXMuc29ydERvY3VtZW50cyh0aGlzLmxhbmdpdW1Eb2N1bWVudHMuYWxsXG4gICAgICAgICAgICAuZmlsdGVyKGRvYyA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAvLyBUaGlzIGluY2x1ZGVzIHRob3NlIHRoYXQgd2VyZSByZXBvcnRlZCBhcyBjaGFuZ2VkIGFuZCB0aG9zZSB0aGF0IHdlIHNlbGVjdGVkIGZvciByZWxpbmtpbmdcbiAgICAgICAgICAgIHJldHVybiBkb2Muc3RhdGUgPCBEb2N1bWVudFN0YXRlLkxpbmtlZFxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaW5jbHVkZXMgdGhvc2UgZm9yIHdoaWNoIGEgcHJldmlvdXMgYnVpbGQgaGFzIGJlZW4gY2FuY2VsbGVkXG4gICAgICAgICAgICAgICAgfHwgISgoX2EgPSB0aGlzLmJ1aWxkU3RhdGUuZ2V0KGRvYy51cmkudG9TdHJpbmcoKSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21wbGV0ZWQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnRvQXJyYXkoKSk7XG4gICAgICAgIGF3YWl0IHRoaXMuYnVpbGREb2N1bWVudHMocmVidWlsZERvY3VtZW50cywgdGhpcy51cGRhdGVCdWlsZE9wdGlvbnMsIGNhbmNlbFRva2VuKTtcbiAgICB9XG4gICAgYXN5bmMgZW1pdFVwZGF0ZShjaGFuZ2VkLCBkZWxldGVkKSB7XG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHRoaXMudXBkYXRlTGlzdGVuZXJzLm1hcChsaXN0ZW5lciA9PiBsaXN0ZW5lcihjaGFuZ2VkLCBkZWxldGVkKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTb3J0IHRoZSBnaXZlbiBkb2N1bWVudHMgYnkgcHJpb3JpdHkuIEJ5IGRlZmF1bHQsIGRvY3VtZW50cyB3aXRoIGFuIG9wZW4gdGV4dCBkb2N1bWVudCBhcmUgcHJpb3JpdGl6ZWQuXG4gICAgICogVGhpcyBpcyB1c2VmdWwgdG8gZW5zdXJlIHRoYXQgdmlzaWJsZSBkb2N1bWVudHMgc2hvdyB0aGVpciBkaWFnbm9zdGljcyBiZWZvcmUgYWxsIG90aGVyIGRvY3VtZW50cy5cbiAgICAgKlxuICAgICAqIFRoaXMgaW1wcm92ZXMgdGhlIHJlc3BvbnNpdmVuZXNzIGluIGxhcmdlIHdvcmtzcGFjZXMgYXMgdXNlcnMgdXN1YWxseSBkb24ndCBjYXJlIGFib3V0IGRpYWdub3N0aWNzXG4gICAgICogaW4gZmlsZXMgdGhhdCBhcmUgY3VycmVudGx5IG5vdCBvcGVuZWQgaW4gdGhlIGVkaXRvci5cbiAgICAgKi9cbiAgICBzb3J0RG9jdW1lbnRzKGRvY3VtZW50cykge1xuICAgICAgICBsZXQgbGVmdCA9IDA7XG4gICAgICAgIGxldCByaWdodCA9IGRvY3VtZW50cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICB3aGlsZSAobGVmdCA8IGRvY3VtZW50cy5sZW5ndGggJiYgdGhpcy5oYXNUZXh0RG9jdW1lbnQoZG9jdW1lbnRzW2xlZnRdKSkge1xuICAgICAgICAgICAgICAgIGxlZnQrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChyaWdodCA+PSAwICYmICF0aGlzLmhhc1RleHREb2N1bWVudChkb2N1bWVudHNbcmlnaHRdKSkge1xuICAgICAgICAgICAgICAgIHJpZ2h0LS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdCA8IHJpZ2h0KSB7XG4gICAgICAgICAgICAgICAgW2RvY3VtZW50c1tsZWZ0XSwgZG9jdW1lbnRzW3JpZ2h0XV0gPSBbZG9jdW1lbnRzW3JpZ2h0XSwgZG9jdW1lbnRzW2xlZnRdXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnRzO1xuICAgIH1cbiAgICBoYXNUZXh0RG9jdW1lbnQoZG9jKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oKF9hID0gdGhpcy50ZXh0RG9jdW1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGRvYy51cmkpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gZG9jdW1lbnQgc2hvdWxkIGJlIHJlbGlua2VkIGFmdGVyIGNoYW5nZXMgd2VyZSBmb3VuZCBpbiB0aGUgZ2l2ZW4gVVJJcy5cbiAgICAgKi9cbiAgICBzaG91bGRSZWxpbmsoZG9jdW1lbnQsIGNoYW5nZWRVcmlzKSB7XG4gICAgICAgIC8vIFJlbGluayBkb2N1bWVudHMgd2l0aCBsaW5raW5nIGVycm9ycyAtLSBtYXliZSB0aG9zZSByZWZlcmVuY2VzIGNhbiBiZSByZXNvbHZlZCBub3dcbiAgICAgICAgaWYgKGRvY3VtZW50LnJlZmVyZW5jZXMuc29tZShyZWYgPT4gcmVmLmVycm9yICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBkb2N1bWVudCBpcyBhZmZlY3RlZCBieSBhbnkgb2YgdGhlIGNoYW5nZWQgVVJJc1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleE1hbmFnZXIuaXNBZmZlY3RlZChkb2N1bWVudCwgY2hhbmdlZFVyaXMpO1xuICAgIH1cbiAgICBvblVwZGF0ZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnVwZGF0ZUxpc3RlbmVycy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy51cGRhdGVMaXN0ZW5lcnMuaW5kZXhPZihjYWxsYmFjayk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlTGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCdWlsZCB0aGUgZ2l2ZW4gZG9jdW1lbnRzIGJ5IHN0ZXBwaW5nIHRocm91Z2ggYWxsIGJ1aWxkIHBoYXNlcy4gSWYgYSBkb2N1bWVudCdzIHN0YXRlIGluZGljYXRlc1xuICAgICAqIHRoYXQgYSBjZXJ0YWluIGJ1aWxkIHBoYXNlIGlzIGFscmVhZHkgZG9uZSwgdGhlIHBoYXNlIGlzIHNraXBwZWQgZm9yIHRoYXQgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIFRoZSBkb2N1bWVudHMgdG8gYnVpbGQuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgdGhlIHtAbGluayBCdWlsZE9wdGlvbnN9IHRvIHVzZS5cbiAgICAgKiBAcGFyYW0gY2FuY2VsVG9rZW4gQSBjYW5jZWxsYXRpb24gdG9rZW4gdGhhdCBjYW4gYmUgdXNlZCB0byBjYW5jZWwgdGhlIGJ1aWxkLlxuICAgICAqIEByZXR1cm5zIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGJ1aWxkIGlzIGRvbmUuXG4gICAgICovXG4gICAgYXN5bmMgYnVpbGREb2N1bWVudHMoZG9jdW1lbnRzLCBvcHRpb25zLCBjYW5jZWxUb2tlbikge1xuICAgICAgICB0aGlzLnByZXBhcmVCdWlsZChkb2N1bWVudHMsIG9wdGlvbnMpO1xuICAgICAgICAvLyAwLiBQYXJzZSBjb250ZW50XG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIERvY3VtZW50U3RhdGUuUGFyc2VkLCBjYW5jZWxUb2tlbiwgZG9jID0+IHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeS51cGRhdGUoZG9jLCBjYW5jZWxUb2tlbikpO1xuICAgICAgICAvLyAxLiBJbmRleCBjb250ZW50XG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIERvY3VtZW50U3RhdGUuSW5kZXhlZENvbnRlbnQsIGNhbmNlbFRva2VuLCBkb2MgPT4gdGhpcy5pbmRleE1hbmFnZXIudXBkYXRlQ29udGVudChkb2MsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIC8vIDIuIENvbXB1dGUgc2NvcGVzXG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIERvY3VtZW50U3RhdGUuQ29tcHV0ZWRTY29wZXMsIGNhbmNlbFRva2VuLCBhc3luYyAoZG9jKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzY29wZUNvbXB1dGF0aW9uID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0U2VydmljZXMoZG9jLnVyaSkucmVmZXJlbmNlcy5TY29wZUNvbXB1dGF0aW9uO1xuICAgICAgICAgICAgZG9jLnByZWNvbXB1dGVkU2NvcGVzID0gYXdhaXQgc2NvcGVDb21wdXRhdGlvbi5jb21wdXRlTG9jYWxTY29wZXMoZG9jLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyAzLiBMaW5raW5nXG4gICAgICAgIGF3YWl0IHRoaXMucnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIERvY3VtZW50U3RhdGUuTGlua2VkLCBjYW5jZWxUb2tlbiwgZG9jID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKGRvYy51cmkpLnJlZmVyZW5jZXMuTGlua2VyO1xuICAgICAgICAgICAgcmV0dXJuIGxpbmtlci5saW5rKGRvYywgY2FuY2VsVG9rZW4pO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gNC4gSW5kZXggcmVmZXJlbmNlc1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkNhbmNlbGFibGUoZG9jdW1lbnRzLCBEb2N1bWVudFN0YXRlLkluZGV4ZWRSZWZlcmVuY2VzLCBjYW5jZWxUb2tlbiwgZG9jID0+IHRoaXMuaW5kZXhNYW5hZ2VyLnVwZGF0ZVJlZmVyZW5jZXMoZG9jLCBjYW5jZWxUb2tlbikpO1xuICAgICAgICAvLyA1LiBWYWxpZGF0aW9uXG4gICAgICAgIGNvbnN0IHRvQmVWYWxpZGF0ZWQgPSBkb2N1bWVudHMuZmlsdGVyKGRvYyA9PiB0aGlzLnNob3VsZFZhbGlkYXRlKGRvYykpO1xuICAgICAgICBhd2FpdCB0aGlzLnJ1bkNhbmNlbGFibGUodG9CZVZhbGlkYXRlZCwgRG9jdW1lbnRTdGF0ZS5WYWxpZGF0ZWQsIGNhbmNlbFRva2VuLCBkb2MgPT4gdGhpcy52YWxpZGF0ZShkb2MsIGNhbmNlbFRva2VuKSk7XG4gICAgICAgIC8vIElmIHdlJ3ZlIG1hZGUgaXQgdG8gdGhpcyBwb2ludCB3aXRob3V0IGJlaW5nIGNhbmNlbGxlZCwgd2UgY2FuIG1hcmsgdGhlIGJ1aWxkIHN0YXRlIGFzIGNvbXBsZXRlZC5cbiAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZG9jdW1lbnRzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuYnVpbGRTdGF0ZS5nZXQoZG9jLnVyaS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHN0YXRlLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVucyBwcmlvciB0byBiZWdpbm5pbmcgdGhlIGJ1aWxkIHByb2Nlc3MgdG8gdXBkYXRlIHRoZSB7QGxpbmsgRG9jdW1lbnRCdWlsZFN0YXRlfSBmb3IgZWFjaCBkb2N1bWVudFxuICAgICAqXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyBjb2xsZWN0aW9uIG9mIGRvY3VtZW50cyB0byBiZSBidWlsdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIHRoZSB7QGxpbmsgQnVpbGRPcHRpb25zfSB0byB1c2VcbiAgICAgKi9cbiAgICBwcmVwYXJlQnVpbGQoZG9jdW1lbnRzLCBvcHRpb25zKSB7XG4gICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3VtZW50cykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZG9jLnVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmJ1aWxkU3RhdGUuZ2V0KGtleSk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZG9jdW1lbnQgaGFzIG5vIHByZXZpb3VzIGJ1aWxkIHN0YXRlLCB3ZSBzZXQgaXQuIElmIGl0IGhhcyBvbmUsIGJ1dCBpdCdzIGFscmVhZHkgbWFya2VkXG4gICAgICAgICAgICAvLyBhcyBjb21wbGV0ZWQsIHdlIG92ZXJ3cml0ZSBpdC4gSWYgdGhlIHByZXZpb3VzIGJ1aWxkIHdhcyBub3QgY29tcGxldGVkLCB3ZSBrZWVwIGl0cyBzdGF0ZVxuICAgICAgICAgICAgLy8gYW5kIGNvbnRpbnVlIHdoZXJlIGl0IHdhcyBjYW5jZWxsZWQuXG4gICAgICAgICAgICBpZiAoIXN0YXRlIHx8IHN0YXRlLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYnVpbGRTdGF0ZS5zZXQoa2V5LCB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDogc3RhdGUgPT09IG51bGwgfHwgc3RhdGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0YXRlLnJlc3VsdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJ1bnMgYSBjYW5jZWxhYmxlIG9wZXJhdGlvbiBvbiBhIHNldCBvZiBkb2N1bWVudHMgdG8gYnJpbmcgdGhlbSB0byBhIHNwZWNpZmllZCB7QGxpbmsgRG9jdW1lbnRTdGF0ZX0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIFRoZSBhcnJheSBvZiBkb2N1bWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgVGhlIHRhcmdldCB7QGxpbmsgRG9jdW1lbnRTdGF0ZX0gdG8gYnJpbmcgdGhlIGRvY3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gY2FuY2VsVG9rZW4gQSB0b2tlbiB0aGF0IGNhbiBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSBjYWxsYmFjayBBIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCBmb3IgZWFjaCBkb2N1bWVudC5cbiAgICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBkb2N1bWVudHMgaGF2ZSBiZWVuIHByb2Nlc3NlZCBvciB0aGUgb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICAgICAqIEB0aHJvd3MgV2lsbCB0aHJvdyBgT3BlcmF0aW9uQ2FuY2VsbGVkYCBpZiB0aGUgb3BlcmF0aW9uIGlzIGNhbmNlbGVkIHZpYSBhIGBDYW5jZWxsYXRpb25Ub2tlbmAuXG4gICAgICovXG4gICAgYXN5bmMgcnVuQ2FuY2VsYWJsZShkb2N1bWVudHMsIHRhcmdldFN0YXRlLCBjYW5jZWxUb2tlbiwgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgZmlsdGVyZWQgPSBkb2N1bWVudHMuZmlsdGVyKGRvYyA9PiBkb2Muc3RhdGUgPCB0YXJnZXRTdGF0ZSk7XG4gICAgICAgIGZvciAoY29uc3QgZG9jdW1lbnQgb2YgZmlsdGVyZWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGludGVycnVwdEFuZENoZWNrKGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIGF3YWl0IGNhbGxiYWNrKGRvY3VtZW50KTtcbiAgICAgICAgICAgIGRvY3VtZW50LnN0YXRlID0gdGFyZ2V0U3RhdGU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLm5vdGlmeURvY3VtZW50UGhhc2UoZG9jdW1lbnQsIHRhcmdldFN0YXRlLCBjYW5jZWxUb2tlbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IHVzZSBgZmlsdGVyZWRgIGhlcmUsIGFzIHRoYXQgd2lsbCBtaXNzIGRvY3VtZW50cyB0aGF0IGhhdmUgcHJldmlvdXNseSByZWFjaGVkIHRoZSBjdXJyZW50IHRhcmdldCBzdGF0ZVxuICAgICAgICAvLyBGb3IgZXhhbXBsZSwgdGhpcyBoYXBwZW5zIGluIGNhc2UgdGhlIGNhbmNlbGxhdGlvbiB0cmlnZ2VycyBiZXR3ZWVuIHRoZSBwcm9jZXNzaW5nIG9mIHR3byBkb2N1bWVudHNcbiAgICAgICAgLy8gT3IgZmlsZXMgdGhhdCB3ZXJlIHBpY2tlZCB1cCBkdXJpbmcgdGhlIHdvcmtzcGFjZSBpbml0aWFsaXphdGlvblxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZURvY3MgPSBkb2N1bWVudHMuZmlsdGVyKGRvYyA9PiBkb2Muc3RhdGUgPT09IHRhcmdldFN0YXRlKTtcbiAgICAgICAgYXdhaXQgdGhpcy5ub3RpZnlCdWlsZFBoYXNlKHRhcmdldFN0YXRlRG9jcywgdGFyZ2V0U3RhdGUsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSB0YXJnZXRTdGF0ZTtcbiAgICB9XG4gICAgb25CdWlsZFBoYXNlKHRhcmdldFN0YXRlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmJ1aWxkUGhhc2VMaXN0ZW5lcnMuYWRkKHRhcmdldFN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBEaXNwb3NhYmxlLmNyZWF0ZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkUGhhc2VMaXN0ZW5lcnMuZGVsZXRlKHRhcmdldFN0YXRlLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBvbkRvY3VtZW50UGhhc2UodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRQaGFzZUxpc3RlbmVycy5hZGQodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIERpc3Bvc2FibGUuY3JlYXRlKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRQaGFzZUxpc3RlbmVycy5kZWxldGUodGFyZ2V0U3RhdGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhaXRVbnRpbChzdGF0ZSwgdXJpT3JUb2tlbiwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgbGV0IHVyaSA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHVyaU9yVG9rZW4gJiYgJ3BhdGgnIGluIHVyaU9yVG9rZW4pIHtcbiAgICAgICAgICAgIHVyaSA9IHVyaU9yVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYW5jZWxUb2tlbiA9IHVyaU9yVG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsVG9rZW4gIT09IG51bGwgJiYgY2FuY2VsVG9rZW4gIT09IHZvaWQgMCA/IGNhbmNlbFRva2VuIDogKGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSk7XG4gICAgICAgIGlmICh1cmkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmdldERvY3VtZW50KHVyaSk7XG4gICAgICAgICAgICBpZiAoZG9jdW1lbnQgJiYgZG9jdW1lbnQuc3RhdGUgPiBzdGF0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodXJpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50U3RhdGUgPj0gc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjYW5jZWxUb2tlbi5pc0NhbmNlbGxhdGlvblJlcXVlc3RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KE9wZXJhdGlvbkNhbmNlbGxlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGJ1aWxkRGlzcG9zYWJsZSA9IHRoaXMub25CdWlsZFBoYXNlKHN0YXRlLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgYnVpbGREaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxEaXNwb3NhYmxlLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgICAgICBpZiAodXJpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRzLmdldERvY3VtZW50KHVyaSk7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoZG9jdW1lbnQgPT09IG51bGwgfHwgZG9jdW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRvY3VtZW50LnVyaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYW5jZWxEaXNwb3NhYmxlID0gY2FuY2VsVG9rZW4ub25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGJ1aWxkRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgY2FuY2VsRGlzcG9zYWJsZS5kaXNwb3NlKCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KE9wZXJhdGlvbkNhbmNlbGxlZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIG5vdGlmeURvY3VtZW50UGhhc2UoZG9jdW1lbnQsIHN0YXRlLCBjYW5jZWxUb2tlbikge1xuICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLmRvY3VtZW50UGhhc2VMaXN0ZW5lcnMuZ2V0KHN0YXRlKTtcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzQ29weSA9IGxpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVyc0NvcHkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgbGlzdGVuZXIoZG9jdW1lbnQsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBJZ25vcmUgY2FuY2VsbGF0aW9uIGVycm9yc1xuICAgICAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gZmluaXNoIHRoZSBsaXN0ZW5lcnMgYmVmb3JlIHRocm93aW5nXG4gICAgICAgICAgICAgICAgaWYgKCFpc09wZXJhdGlvbkNhbmNlbGxlZChlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgbm90aWZ5QnVpbGRQaGFzZShkb2N1bWVudHMsIHN0YXRlLCBjYW5jZWxUb2tlbikge1xuICAgICAgICBpZiAoZG9jdW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgLy8gRG9uJ3Qgbm90aWZ5IHdoZW4gbm8gZG9jdW1lbnQgaGFzIGJlZW4gcHJvY2Vzc2VkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5idWlsZFBoYXNlTGlzdGVuZXJzLmdldChzdGF0ZSk7XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyc0NvcHkgPSBsaXN0ZW5lcnMuc2xpY2UoKTtcbiAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnNDb3B5KSB7XG4gICAgICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICBhd2FpdCBsaXN0ZW5lcihkb2N1bWVudHMsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gZG9jdW1lbnQgc2hvdWxkIGJlIHZhbGlkYXRlZCBkdXJpbmcgYSBidWlsZC4gVGhlIGRlZmF1bHRcbiAgICAgKiBpbXBsZW1lbnRhdGlvbiBjaGVja3MgdGhlIGB2YWxpZGF0aW9uYCBwcm9wZXJ0eSBvZiB0aGUgYnVpbGQgb3B0aW9ucy4gSWYgaXQncyBzZXQgdG8gYHRydWVgXG4gICAgICogb3IgYSBgVmFsaWRhdGlvbk9wdGlvbnNgIG9iamVjdCwgdGhlIGRvY3VtZW50IGlzIGluY2x1ZGVkIGluIHRoZSB2YWxpZGF0aW9uIHBoYXNlLlxuICAgICAqL1xuICAgIHNob3VsZFZhbGlkYXRlKGRvY3VtZW50KSB7XG4gICAgICAgIHJldHVybiBCb29sZWFuKHRoaXMuZ2V0QnVpbGRPcHRpb25zKGRvY3VtZW50KS52YWxpZGF0aW9uKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUnVuIHZhbGlkYXRpb24gY2hlY2tzIG9uIHRoZSBnaXZlbiBkb2N1bWVudCBhbmQgc3RvcmUgdGhlIHJlc3VsdGluZyBkaWFnbm9zdGljcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAgICogSWYgdGhlIGRvY3VtZW50IGFscmVhZHkgY29udGFpbnMgZGlhZ25vc3RpY3MsIHRoZSBuZXcgb25lcyBhcmUgYWRkZWQgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgYXN5bmMgdmFsaWRhdGUoZG9jdW1lbnQsIGNhbmNlbFRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHZhbGlkYXRvciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKGRvY3VtZW50LnVyaSkudmFsaWRhdGlvbi5Eb2N1bWVudFZhbGlkYXRvcjtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblNldHRpbmcgPSB0aGlzLmdldEJ1aWxkT3B0aW9ucyhkb2N1bWVudCkudmFsaWRhdGlvbjtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiB2YWxpZGF0aW9uU2V0dGluZyA9PT0gJ29iamVjdCcgPyB2YWxpZGF0aW9uU2V0dGluZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZGlhZ25vc3RpY3MgPSBhd2FpdCB2YWxpZGF0b3IudmFsaWRhdGVEb2N1bWVudChkb2N1bWVudCwgb3B0aW9ucywgY2FuY2VsVG9rZW4pO1xuICAgICAgICBpZiAoZG9jdW1lbnQuZGlhZ25vc3RpY3MpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmRpYWdub3N0aWNzLnB1c2goLi4uZGlhZ25vc3RpY3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZG9jdW1lbnQuZGlhZ25vc3RpY3MgPSBkaWFnbm9zdGljcztcbiAgICAgICAgfVxuICAgICAgICAvLyBTdG9yZSBpbmZvcm1hdGlvbiBhYm91dCB0aGUgZXhlY3V0ZWQgdmFsaWRhdGlvbiBpbiB0aGUgYnVpbGQgc3RhdGVcbiAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLmJ1aWxkU3RhdGUuZ2V0KGRvY3VtZW50LnVyaS50b1N0cmluZygpKTtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgICAoX2EgPSBzdGF0ZS5yZXN1bHQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChzdGF0ZS5yZXN1bHQgPSB7fSk7XG4gICAgICAgICAgICBjb25zdCBuZXdDYXRlZ29yaWVzID0gKF9iID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNhdGVnb3JpZXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFZhbGlkYXRpb25DYXRlZ29yeS5hbGw7XG4gICAgICAgICAgICBpZiAoc3RhdGUucmVzdWx0LnZhbGlkYXRpb25DaGVja3MpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5yZXN1bHQudmFsaWRhdGlvbkNoZWNrcy5wdXNoKC4uLm5ld0NhdGVnb3JpZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUucmVzdWx0LnZhbGlkYXRpb25DaGVja3MgPSBbLi4ubmV3Q2F0ZWdvcmllc107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0QnVpbGRPcHRpb25zKGRvY3VtZW50KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLmJ1aWxkU3RhdGUuZ2V0KGRvY3VtZW50LnVyaS50b1N0cmluZygpKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm9wdGlvbnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHt9O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRvY3VtZW50LWJ1aWxkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqXG4gKiBSZS1leHBvcnQgJ1RleHREb2N1bWVudCcgZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCcgZm9yIGNvbnZlbmllbmNlLFxuICogIGluY2x1ZGluZyBib3RoIHR5cGUgX2FuZF8gc3ltYm9sIChuYW1lc3BhY2UpLCBhcyB3ZSBoZXJlIGFuZCB0aGVyZSBhbHNvIHJlZmVyIHRvIHRoZSBzeW1ib2wsXG4gKiAgdGhlIG92ZXJoZWFkIGlzIHZlcnkgc21hbGwsIGp1c3QgYSBmZXcga2lsb2J5dGVzLlxuICogRXZlcnl0aGluZyBlbHNlIG9mIHRoYXQgcGFja2FnZSAoYXQgdGhlIHRpbWUgY29udHJpYnV0aW5nKSBpcyBhbHNvIGRlZmluZWRcbiAqICBpbiAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXByb3RvY29sJyBvciAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXR5cGVzJy5cbiAqL1xuZXhwb3J0IHsgVGV4dERvY3VtZW50IH0gZnJvbSAndnNjb2RlLWxhbmd1YWdlc2VydmVyLXRleHRkb2N1bWVudCc7XG5pbXBvcnQgeyBUZXh0RG9jdW1lbnQgfSBmcm9tICcuL2RvY3VtZW50cy5qcyc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuaW1wb3J0IHsgVVJJIH0gZnJvbSAnLi4vdXRpbHMvdXJpLXV0aWxzLmpzJztcbi8qKlxuICogQSBkb2N1bWVudCBpcyBzdWJqZWN0IHRvIHNldmVyYWwgcGhhc2VzIHRoYXQgYXJlIHJ1biBpbiBwcmVkZWZpbmVkIG9yZGVyLiBBbnkgc3RhdGUgdmFsdWUgaW1wbGllcyB0aGF0XG4gKiBzbWFsbGVyIHN0YXRlIHZhbHVlcyBhcmUgZmluaXNoZWQgYXMgd2VsbC5cbiAqL1xuZXhwb3J0IHZhciBEb2N1bWVudFN0YXRlO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN0YXRlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIHRleHQgY29udGVudCBoYXMgY2hhbmdlZCBhbmQgbmVlZHMgdG8gYmUgcGFyc2VkIGFnYWluLiBUaGUgQVNUIGhlbGQgYnkgdGhpcyBvdXRkYXRlZFxuICAgICAqIGRvY3VtZW50IGluc3RhbmNlIGlzIG5vIGxvbmdlciB2YWxpZC5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXRlW0RvY3VtZW50U3RhdGVbXCJDaGFuZ2VkXCJdID0gMF0gPSBcIkNoYW5nZWRcIjtcbiAgICAvKipcbiAgICAgKiBBbiBBU1QgaGFzIGJlZW4gY3JlYXRlZCBmcm9tIHRoZSB0ZXh0IGNvbnRlbnQuIFRoZSBkb2N1bWVudCBzdHJ1Y3R1cmUgY2FuIGJlIHRyYXZlcnNlZCxcbiAgICAgKiBidXQgY3Jvc3MtcmVmZXJlbmNlcyBjYW5ub3QgYmUgcmVzb2x2ZWQgeWV0LiBJZiBuZWNlc3NhcnksIHRoZSBzdHJ1Y3R1cmUgY2FuIGJlIG1hbmlwdWxhdGVkXG4gICAgICogYXQgdGhpcyBzdGFnZSBhcyBhIHByZXByb2Nlc3Npbmcgc3RlcC5cbiAgICAgKi9cbiAgICBEb2N1bWVudFN0YXRlW0RvY3VtZW50U3RhdGVbXCJQYXJzZWRcIl0gPSAxXSA9IFwiUGFyc2VkXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBJbmRleE1hbmFnZXJgIHNlcnZpY2UgaGFzIHByb2Nlc3NlZCBBU1Qgbm9kZXMgb2YgdGhpcyBkb2N1bWVudC4gVGhpcyBtZWFucyB0aGVcbiAgICAgKiBleHBvcnRlZCBzeW1ib2xzIGFyZSBhdmFpbGFibGUgaW4gdGhlIGdsb2JhbCBzY29wZSBhbmQgY2FuIGJlIHJlc29sdmVkIGZyb20gb3RoZXIgZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIkluZGV4ZWRDb250ZW50XCJdID0gMl0gPSBcIkluZGV4ZWRDb250ZW50XCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBTY29wZUNvbXB1dGF0aW9uYCBzZXJ2aWNlIGhhcyBwcm9jZXNzZWQgdGhpcyBkb2N1bWVudC4gVGhpcyBtZWFucyB0aGUgbG9jYWwgc3ltYm9sc1xuICAgICAqIGFyZSBzdG9yZWQgaW4gYSBNdWx0aU1hcCBzbyB0aGV5IGNhbiBiZSBsb29rZWQgdXAgYnkgdGhlIGBTY29wZVByb3ZpZGVyYCBzZXJ2aWNlLlxuICAgICAqIE9uY2UgYSBkb2N1bWVudCBoYXMgcmVhY2hlZCB0aGlzIHN0YXRlLCB5b3UgbWF5IGZvbGxvdyBldmVyeSByZWZlcmVuY2UgLSBpdCB3aWxsIGxhemlseVxuICAgICAqIHJlc29sdmUgaXRzIGByZWZgIHByb3BlcnR5IGFuZCB5aWVsZCBlaXRoZXIgdGhlIHRhcmdldCBBU1Qgbm9kZSBvciBgdW5kZWZpbmVkYCBpbiBjYXNlXG4gICAgICogdGhlIHRhcmdldCBpcyBub3QgaW4gc2NvcGUuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiQ29tcHV0ZWRTY29wZXNcIl0gPSAzXSA9IFwiQ29tcHV0ZWRTY29wZXNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgYExpbmtlcmAgc2VydmljZSBoYXMgcHJvY2Vzc2VkIHRoaXMgZG9jdW1lbnQuIEFsbCBvdXRnb2luZyByZWZlcmVuY2VzIGhhdmUgYmVlblxuICAgICAqIHJlc29sdmVkIG9yIG1hcmtlZCBhcyBlcnJvbmVvdXMuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiTGlua2VkXCJdID0gNF0gPSBcIkxpbmtlZFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBgSW5kZXhNYW5hZ2VyYCBzZXJ2aWNlIGhhcyBwcm9jZXNzZWQgQVNUIG5vZGUgcmVmZXJlbmNlcyBvZiB0aGlzIGRvY3VtZW50LiBUaGlzIGlzXG4gICAgICogbmVjZXNzYXJ5IHRvIGRldGVybWluZSB3aGljaCBkb2N1bWVudHMgYXJlIGFmZmVjdGVkIGJ5IGEgY2hhbmdlIGluIG9uZSBvZiB0aGUgd29ya3NwYWNlXG4gICAgICogZG9jdW1lbnRzLlxuICAgICAqL1xuICAgIERvY3VtZW50U3RhdGVbRG9jdW1lbnRTdGF0ZVtcIkluZGV4ZWRSZWZlcmVuY2VzXCJdID0gNV0gPSBcIkluZGV4ZWRSZWZlcmVuY2VzXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGBEb2N1bWVudFZhbGlkYXRvcmAgc2VydmljZSBoYXMgcHJvY2Vzc2VkIHRoaXMgZG9jdW1lbnQuIFRoZSBsYW5ndWFnZSBzZXJ2ZXIgbGlzdGVuc1xuICAgICAqIHRvIHRoZSByZXN1bHRzIG9mIHRoaXMgcGhhc2UgYW5kIHNlbmRzIGRpYWdub3N0aWNzIHRvIHRoZSBjbGllbnQuXG4gICAgICovXG4gICAgRG9jdW1lbnRTdGF0ZVtEb2N1bWVudFN0YXRlW1wiVmFsaWRhdGVkXCJdID0gNl0gPSBcIlZhbGlkYXRlZFwiO1xufSkoRG9jdW1lbnRTdGF0ZSB8fCAoRG9jdW1lbnRTdGF0ZSA9IHt9KSk7XG5leHBvcnQgY2xhc3MgRGVmYXVsdExhbmdpdW1Eb2N1bWVudEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuc2VydmljZVJlZ2lzdHJ5ID0gc2VydmljZXMuU2VydmljZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLnRleHREb2N1bWVudHMgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuVGV4dERvY3VtZW50cztcbiAgICAgICAgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIgPSBzZXJ2aWNlcy53b3Jrc3BhY2UuRmlsZVN5c3RlbVByb3ZpZGVyO1xuICAgIH1cbiAgICBhc3luYyBmcm9tVXJpKHVyaSwgY2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLmZpbGVTeXN0ZW1Qcm92aWRlci5yZWFkRmlsZSh1cmkpO1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3luYyh1cmksIGNvbnRlbnQsIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICB9XG4gICAgZnJvbVRleHREb2N1bWVudCh0ZXh0RG9jdW1lbnQsIHVyaSwgdG9rZW4pIHtcbiAgICAgICAgdXJpID0gdXJpICE9PSBudWxsICYmIHVyaSAhPT0gdm9pZCAwID8gdXJpIDogVVJJLnBhcnNlKHRleHREb2N1bWVudC51cmkpO1xuICAgICAgICBpZiAoQ2FuY2VsbGF0aW9uVG9rZW4uaXModG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVBc3luYyh1cmksIHRleHREb2N1bWVudCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHVyaSwgdGV4dERvY3VtZW50LCB0b2tlbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnJvbVN0cmluZyh0ZXh0LCB1cmksIHRva2VuKSB7XG4gICAgICAgIGlmIChDYW5jZWxsYXRpb25Ub2tlbi5pcyh0b2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFzeW5jKHVyaSwgdGV4dCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHVyaSwgdGV4dCwgdG9rZW4pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZyb21Nb2RlbChtb2RlbCwgdXJpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh1cmksIHsgJG1vZGVsOiBtb2RlbCB9KTtcbiAgICB9XG4gICAgY3JlYXRlKHVyaSwgY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZVJlc3VsdCA9IHRoaXMucGFyc2UodXJpLCBjb250ZW50LCBvcHRpb25zKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxhbmdpdW1Eb2N1bWVudChwYXJzZVJlc3VsdCwgdXJpLCB1bmRlZmluZWQsIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCckbW9kZWwnIGluIGNvbnRlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0geyB2YWx1ZTogY29udGVudC4kbW9kZWwsIHBhcnNlckVycm9yczogW10sIGxleGVyRXJyb3JzOiBbXSB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGFuZ2l1bURvY3VtZW50KHBhcnNlUmVzdWx0LCB1cmkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSB0aGlzLnBhcnNlKHVyaSwgY29udGVudC5nZXRUZXh0KCksIG9wdGlvbnMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTGFuZ2l1bURvY3VtZW50KHBhcnNlUmVzdWx0LCB1cmksIGNvbnRlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGNyZWF0ZUFzeW5jKHVyaSwgY29udGVudCwgY2FuY2VsVG9rZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY29uc3QgcGFyc2VSZXN1bHQgPSBhd2FpdCB0aGlzLnBhcnNlQXN5bmModXJpLCBjb250ZW50LCBjYW5jZWxUb2tlbik7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVMYW5naXVtRG9jdW1lbnQocGFyc2VSZXN1bHQsIHVyaSwgdW5kZWZpbmVkLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZUFzeW5jKHVyaSwgY29udGVudC5nZXRUZXh0KCksIGNhbmNlbFRva2VuKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUxhbmdpdW1Eb2N1bWVudChwYXJzZVJlc3VsdCwgdXJpLCBjb250ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBMYW5naXVtRG9jdW1lbnQgZnJvbSBhIGdpdmVuIHBhcnNlIHJlc3VsdC5cbiAgICAgKlxuICAgICAqIEEgVGV4dERvY3VtZW50IGlzIGNyZWF0ZWQgb24gZGVtYW5kIGlmIGl0IGlzIG5vdCBwcm92aWRlZCBhcyBhcmd1bWVudCBoZXJlLiBVc3VhbGx5IHRoaXNcbiAgICAgKiBzaG91bGQgbm90IGJlIG5lY2Vzc2FyeSBiZWNhdXNlIHRoZSBtYWluIHB1cnBvc2Ugb2YgdGhlIFRleHREb2N1bWVudCBpcyB0byBjb252ZXJ0IGJldHdlZW5cbiAgICAgKiB0ZXh0IHJhbmdlcyBhbmQgb2Zmc2V0cywgd2hpY2ggaXMgZG9uZSBzb2xlbHkgaW4gTFNQIHJlcXVlc3QgaGFuZGxpbmcuXG4gICAgICpcbiAgICAgKiBXaXRoIHRoZSBpbnRyb2R1Y3Rpb24gb2Yge0BsaW5rIHVwZGF0ZX0gYmVsb3cgdGhpcyBtZXRob2QgaXMgc3VwcG9zZWQgdG8gYmUgbWFpbmx5IGNhbGxlZFxuICAgICAqIGR1cmluZyB3b3Jrc3BhY2UgaW5pdGlhbGl6YXRpb24gYW5kIG9uIGFkZGl0aW9uL3JlY29nbml0aW9uIG9mIG5ldyBmaWxlcywgd2hpbGUgY2hhbmdlcyBpblxuICAgICAqIGV4aXN0aW5nIGRvY3VtZW50cyBhcmUgcHJvY2Vzc2VkIHZpYSB7QGxpbmsgdXBkYXRlfS5cbiAgICAgKi9cbiAgICBjcmVhdGVMYW5naXVtRG9jdW1lbnQocGFyc2VSZXN1bHQsIHVyaSwgdGV4dERvY3VtZW50LCB0ZXh0KSB7XG4gICAgICAgIGxldCBkb2N1bWVudDtcbiAgICAgICAgaWYgKHRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBEb2N1bWVudFN0YXRlLlBhcnNlZCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICB0ZXh0RG9jdW1lbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnRHZXR0ZXIgPSB0aGlzLmNyZWF0ZVRleHREb2N1bWVudEdldHRlcih1cmksIHRleHQpO1xuICAgICAgICAgICAgZG9jdW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgcGFyc2VSZXN1bHQsXG4gICAgICAgICAgICAgICAgdXJpLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBEb2N1bWVudFN0YXRlLlBhcnNlZCxcbiAgICAgICAgICAgICAgICByZWZlcmVuY2VzOiBbXSxcbiAgICAgICAgICAgICAgICBnZXQgdGV4dERvY3VtZW50KCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGV4dERvY3VtZW50R2V0dGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZS4kZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGUoZG9jdW1lbnQsIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIC8vIFRoZSBDU1QgZnVsbCB0ZXh0IHByb3BlcnR5IGNvbnRhaW5zIHRoZSBvcmlnaW5hbCB0ZXh0IHRoYXQgd2FzIHVzZWQgdG8gY3JlYXRlIHRoZSBBU1QuXG4gICAgICAgIGNvbnN0IG9sZFRleHQgPSAoX2EgPSBkb2N1bWVudC5wYXJzZVJlc3VsdC52YWx1ZS4kY3N0Tm9kZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJvb3QuZnVsbFRleHQ7XG4gICAgICAgIGNvbnN0IHRleHREb2N1bWVudCA9IChfYiA9IHRoaXMudGV4dERvY3VtZW50cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldChkb2N1bWVudC51cmkudG9TdHJpbmcoKSk7XG4gICAgICAgIGNvbnN0IHRleHQgPSB0ZXh0RG9jdW1lbnQgPyB0ZXh0RG9jdW1lbnQuZ2V0VGV4dCgpIDogYXdhaXQgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIucmVhZEZpbGUoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgaWYgKHRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRvY3VtZW50LCAndGV4dERvY3VtZW50Jywge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0ZXh0RG9jdW1lbnRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50R2V0dGVyID0gdGhpcy5jcmVhdGVUZXh0RG9jdW1lbnRHZXR0ZXIoZG9jdW1lbnQudXJpLCB0ZXh0KTtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkb2N1bWVudCwgJ3RleHREb2N1bWVudCcsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IHRleHREb2N1bWVudEdldHRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBvZiB0aGVzZSBkb2N1bWVudHMgY2FuIGJlIHByZXR0eSBsYXJnZSwgc28gcGFyc2luZyB0aGVtIGFnYWluIGNhbiBiZSBxdWl0ZSBleHBlbnNpdmUuXG4gICAgICAgIC8vIFRoZXJlZm9yZSwgd2Ugb25seSBwYXJzZSBpZiB0aGUgdGV4dCBoYXMgYWN0dWFsbHkgY2hhbmdlZC5cbiAgICAgICAgaWYgKG9sZFRleHQgIT09IHRleHQpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnBhcnNlUmVzdWx0ID0gYXdhaXQgdGhpcy5wYXJzZUFzeW5jKGRvY3VtZW50LnVyaSwgdGV4dCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgICAgICAgICAgZG9jdW1lbnQucGFyc2VSZXN1bHQudmFsdWUuJGRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQuc3RhdGUgPSBEb2N1bWVudFN0YXRlLlBhcnNlZDtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgIH1cbiAgICBwYXJzZSh1cmksIHRleHQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc2VydmljZXMgPSB0aGlzLnNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyh1cmkpO1xuICAgICAgICByZXR1cm4gc2VydmljZXMucGFyc2VyLkxhbmdpdW1QYXJzZXIucGFyc2UodGV4dCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIHBhcnNlQXN5bmModXJpLCB0ZXh0LCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKHVyaSk7XG4gICAgICAgIHJldHVybiBzZXJ2aWNlcy5wYXJzZXIuQXN5bmNQYXJzZXIucGFyc2UodGV4dCwgY2FuY2VsbGF0aW9uVG9rZW4pO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0RG9jdW1lbnRHZXR0ZXIodXJpLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VSZWdpc3RyeSA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5O1xuICAgICAgICBsZXQgdGV4dERvYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0ZXh0RG9jICE9PSBudWxsICYmIHRleHREb2MgIT09IHZvaWQgMCA/IHRleHREb2MgOiAodGV4dERvYyA9IFRleHREb2N1bWVudC5jcmVhdGUodXJpLnRvU3RyaW5nKCksIHNlcnZpY2VSZWdpc3RyeS5nZXRTZXJ2aWNlcyh1cmkpLkxhbmd1YWdlTWV0YURhdGEubGFuZ3VhZ2VJZCwgMCwgdGV4dCAhPT0gbnVsbCAmJiB0ZXh0ICE9PSB2b2lkIDAgPyB0ZXh0IDogJycpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRGVmYXVsdExhbmdpdW1Eb2N1bWVudHMge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRNYXAgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50RmFjdG9yeSA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRGYWN0b3J5O1xuICAgICAgICB0aGlzLnNlcnZpY2VSZWdpc3RyeSA9IHNlcnZpY2VzLlNlcnZpY2VSZWdpc3RyeTtcbiAgICB9XG4gICAgZ2V0IGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmVhbSh0aGlzLmRvY3VtZW50TWFwLnZhbHVlcygpKTtcbiAgICB9XG4gICAgYWRkRG9jdW1lbnQoZG9jdW1lbnQpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gZG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIGlmICh0aGlzLmRvY3VtZW50TWFwLmhhcyh1cmlTdHJpbmcpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEEgZG9jdW1lbnQgd2l0aCB0aGUgVVJJICcke3VyaVN0cmluZ30nIGlzIGFscmVhZHkgcHJlc2VudC5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRvY3VtZW50TWFwLnNldCh1cmlTdHJpbmcsIGRvY3VtZW50KTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQodXJpKSB7XG4gICAgICAgIGNvbnN0IHVyaVN0cmluZyA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE1hcC5nZXQodXJpU3RyaW5nKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0T3JDcmVhdGVEb2N1bWVudCh1cmksIGNhbmNlbGxhdGlvblRva2VuKSB7XG4gICAgICAgIGxldCBkb2N1bWVudCA9IHRoaXMuZ2V0RG9jdW1lbnQodXJpKTtcbiAgICAgICAgaWYgKGRvY3VtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZG9jdW1lbnQgPSBhd2FpdCB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbVVyaSh1cmksIGNhbmNlbGxhdGlvblRva2VuKTtcbiAgICAgICAgdGhpcy5hZGREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICB9XG4gICAgY3JlYXRlRG9jdW1lbnQodXJpLCB0ZXh0LCBjYW5jZWxsYXRpb25Ub2tlbikge1xuICAgICAgICBpZiAoY2FuY2VsbGF0aW9uVG9rZW4pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxhbmdpdW1Eb2N1bWVudEZhY3RvcnkuZnJvbVN0cmluZyh0ZXh0LCB1cmksIGNhbmNlbGxhdGlvblRva2VuKS50aGVuKGRvY3VtZW50ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZERvY3VtZW50KGRvY3VtZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3VtZW50ID0gdGhpcy5sYW5naXVtRG9jdW1lbnRGYWN0b3J5LmZyb21TdHJpbmcodGV4dCwgdXJpKTtcbiAgICAgICAgICAgIHRoaXMuYWRkRG9jdW1lbnQoZG9jdW1lbnQpO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhc0RvY3VtZW50KHVyaSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kb2N1bWVudE1hcC5oYXModXJpLnRvU3RyaW5nKCkpO1xuICAgIH1cbiAgICBpbnZhbGlkYXRlRG9jdW1lbnQodXJpKSB7XG4gICAgICAgIGNvbnN0IHVyaVN0cmluZyA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBsYW5naXVtRG9jID0gdGhpcy5kb2N1bWVudE1hcC5nZXQodXJpU3RyaW5nKTtcbiAgICAgICAgaWYgKGxhbmdpdW1Eb2MpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtlciA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKHVyaSkucmVmZXJlbmNlcy5MaW5rZXI7XG4gICAgICAgICAgICBsaW5rZXIudW5saW5rKGxhbmdpdW1Eb2MpO1xuICAgICAgICAgICAgbGFuZ2l1bURvYy5zdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgICAgIGxhbmdpdW1Eb2MucHJlY29tcHV0ZWRTY29wZXMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBsYW5naXVtRG9jLmRpYWdub3N0aWNzID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYW5naXVtRG9jO1xuICAgIH1cbiAgICBkZWxldGVEb2N1bWVudCh1cmkpIHtcbiAgICAgICAgY29uc3QgdXJpU3RyaW5nID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIGNvbnN0IGxhbmdpdW1Eb2MgPSB0aGlzLmRvY3VtZW50TWFwLmdldCh1cmlTdHJpbmcpO1xuICAgICAgICBpZiAobGFuZ2l1bURvYykge1xuICAgICAgICAgICAgbGFuZ2l1bURvYy5zdGF0ZSA9IERvY3VtZW50U3RhdGUuQ2hhbmdlZDtcbiAgICAgICAgICAgIHRoaXMuZG9jdW1lbnRNYXAuZGVsZXRlKHVyaVN0cmluZyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxhbmdpdW1Eb2M7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9jdW1lbnRzLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIyIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmV4cG9ydCBjbGFzcyBFbXB0eUZpbGVTeXN0ZW1Qcm92aWRlciB7XG4gICAgcmVhZEZpbGUoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZmlsZSBzeXN0ZW0gaXMgYXZhaWxhYmxlLicpO1xuICAgIH1cbiAgICBhc3luYyByZWFkRGlyZWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxufVxuZXhwb3J0IGNvbnN0IEVtcHR5RmlsZVN5c3RlbSA9IHtcbiAgICBmaWxlU3lzdGVtUHJvdmlkZXI6ICgpID0+IG5ldyBFbXB0eUZpbGVTeXN0ZW1Qcm92aWRlcigpXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZmlsZS1zeXN0ZW0tcHJvdmlkZXIuanMubWFwIiwiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICogQ29weXJpZ2h0IDIwMjEgVHlwZUZveCBHbWJIXG4gKiBUaGlzIHByb2dyYW0gYW5kIHRoZSBhY2NvbXBhbnlpbmcgbWF0ZXJpYWxzIGFyZSBtYWRlIGF2YWlsYWJsZSB1bmRlciB0aGVcbiAqIHRlcm1zIG9mIHRoZSBNSVQgTGljZW5zZSwgd2hpY2ggaXMgYXZhaWxhYmxlIGluIHRoZSBwcm9qZWN0IHJvb3QuXG4gKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuaW1wb3J0IHsgZ2V0RG9jdW1lbnQgfSBmcm9tICcuLi91dGlscy9hc3QtdXRpbHMuanMnO1xuaW1wb3J0IHsgQ29udGV4dENhY2hlIH0gZnJvbSAnLi4vdXRpbHMvY2FjaGluZy5qcyc7XG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBzdHJlYW0gfSBmcm9tICcuLi91dGlscy9zdHJlYW0uanMnO1xuaW1wb3J0IHsgVXJpVXRpbHMgfSBmcm9tICcuLi91dGlscy91cmktdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRJbmRleE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZpY2VzKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgc3ltYm9sIGluZGV4IHN0b3JlcyBhbGwgYEFzdE5vZGVEZXNjcmlwdGlvbmAgaXRlbXMgZXhwb3J0ZWQgYnkgYSBkb2N1bWVudC5cbiAgICAgICAgICogVGhlIGtleSB1c2VkIGluIHRoaXMgbWFwIGlzIHRoZSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNwZWNpZmljIGRvY3VtZW50IFVSSS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ltYm9sSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGlzIGEgY2FjaGUgZm9yIHRoZSBgYWxsRWxlbWVudHMoKWAgbWV0aG9kLlxuICAgICAgICAgKiBJdCBjYWNoZXMgdGhlIGRlc2NyaXB0aW9ucyBmcm9tIGBzeW1ib2xJbmRleGAgZ3JvdXBlZCBieSB0eXBlcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3ltYm9sQnlUeXBlSW5kZXggPSBuZXcgQ29udGV4dENhY2hlKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIGluZGV4IGtlZXBzIHRyYWNrIG9mIGFsbCBgUmVmZXJlbmNlRGVzY3JpcHRpb25gIGl0ZW1zIGV4cG9ydGVkIGJ5IGEgZG9jdW1lbnQuXG4gICAgICAgICAqIFRoaXMgaXMgdXNlZCB0byBjb21wdXRlIHdoaWNoIGVsZW1lbnRzIGFyZSBhZmZlY3RlZCBieSBhIGRvY3VtZW50IGNoYW5nZVxuICAgICAgICAgKiBhbmQgZm9yIGZpbmRpbmcgcmVmZXJlbmNlcyB0byBhbiBBU1Qgbm9kZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVmZXJlbmNlSW5kZXggPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZG9jdW1lbnRzID0gc2VydmljZXMud29ya3NwYWNlLkxhbmdpdW1Eb2N1bWVudHM7XG4gICAgICAgIHRoaXMuc2VydmljZVJlZ2lzdHJ5ID0gc2VydmljZXMuU2VydmljZVJlZ2lzdHJ5O1xuICAgICAgICB0aGlzLmFzdFJlZmxlY3Rpb24gPSBzZXJ2aWNlcy5Bc3RSZWZsZWN0aW9uO1xuICAgIH1cbiAgICBmaW5kQWxsUmVmZXJlbmNlcyh0YXJnZXROb2RlLCBhc3ROb2RlUGF0aCkge1xuICAgICAgICBjb25zdCB0YXJnZXREb2NVcmkgPSBnZXREb2N1bWVudCh0YXJnZXROb2RlKS51cmk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICB0aGlzLnJlZmVyZW5jZUluZGV4LmZvckVhY2goZG9jUmVmcyA9PiB7XG4gICAgICAgICAgICBkb2NSZWZzLmZvckVhY2gocmVmRGVzY3IgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChVcmlVdGlscy5lcXVhbHMocmVmRGVzY3IudGFyZ2V0VXJpLCB0YXJnZXREb2NVcmkpICYmIHJlZkRlc2NyLnRhcmdldFBhdGggPT09IGFzdE5vZGVQYXRoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHJlZkRlc2NyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzdHJlYW0ocmVzdWx0KTtcbiAgICB9XG4gICAgYWxsRWxlbWVudHMobm9kZVR5cGUsIHVyaXMpIHtcbiAgICAgICAgbGV0IGRvY3VtZW50VXJpcyA9IHN0cmVhbSh0aGlzLnN5bWJvbEluZGV4LmtleXMoKSk7XG4gICAgICAgIGlmICh1cmlzKSB7XG4gICAgICAgICAgICBkb2N1bWVudFVyaXMgPSBkb2N1bWVudFVyaXMuZmlsdGVyKHVyaSA9PiAhdXJpcyB8fCB1cmlzLmhhcyh1cmkpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZG9jdW1lbnRVcmlzXG4gICAgICAgICAgICAubWFwKHVyaSA9PiB0aGlzLmdldEZpbGVEZXNjcmlwdGlvbnModXJpLCBub2RlVHlwZSkpXG4gICAgICAgICAgICAuZmxhdCgpO1xuICAgIH1cbiAgICBnZXRGaWxlRGVzY3JpcHRpb25zKHVyaSwgbm9kZVR5cGUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIW5vZGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5zeW1ib2xJbmRleC5nZXQodXJpKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzY3JpcHRpb25zID0gdGhpcy5zeW1ib2xCeVR5cGVJbmRleC5nZXQodXJpLCBub2RlVHlwZSwgKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgYWxsRmlsZURlc2NyaXB0aW9ucyA9IChfYSA9IHRoaXMuc3ltYm9sSW5kZXguZ2V0KHVyaSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgcmV0dXJuIGFsbEZpbGVEZXNjcmlwdGlvbnMuZmlsdGVyKGUgPT4gdGhpcy5hc3RSZWZsZWN0aW9uLmlzU3VidHlwZShlLnR5cGUsIG5vZGVUeXBlKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb25zO1xuICAgIH1cbiAgICByZW1vdmUodXJpKSB7XG4gICAgICAgIGNvbnN0IHVyaVN0cmluZyA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICB0aGlzLnN5bWJvbEluZGV4LmRlbGV0ZSh1cmlTdHJpbmcpO1xuICAgICAgICB0aGlzLnN5bWJvbEJ5VHlwZUluZGV4LmNsZWFyKHVyaVN0cmluZyk7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlSW5kZXguZGVsZXRlKHVyaVN0cmluZyk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUNvbnRlbnQoZG9jdW1lbnQsIGNhbmNlbFRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBzZXJ2aWNlcyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmdldFNlcnZpY2VzKGRvY3VtZW50LnVyaSk7XG4gICAgICAgIGNvbnN0IGV4cG9ydHMgPSBhd2FpdCBzZXJ2aWNlcy5yZWZlcmVuY2VzLlNjb3BlQ29tcHV0YXRpb24uY29tcHV0ZUV4cG9ydHMoZG9jdW1lbnQsIGNhbmNlbFRva2VuKTtcbiAgICAgICAgY29uc3QgdXJpID0gZG9jdW1lbnQudXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIHRoaXMuc3ltYm9sSW5kZXguc2V0KHVyaSwgZXhwb3J0cyk7XG4gICAgICAgIHRoaXMuc3ltYm9sQnlUeXBlSW5kZXguY2xlYXIodXJpKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlUmVmZXJlbmNlcyhkb2N1bWVudCwgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IHNlcnZpY2VzID0gdGhpcy5zZXJ2aWNlUmVnaXN0cnkuZ2V0U2VydmljZXMoZG9jdW1lbnQudXJpKTtcbiAgICAgICAgY29uc3QgaW5kZXhEYXRhID0gYXdhaXQgc2VydmljZXMud29ya3NwYWNlLlJlZmVyZW5jZURlc2NyaXB0aW9uUHJvdmlkZXIuY3JlYXRlRGVzY3JpcHRpb25zKGRvY3VtZW50LCBjYW5jZWxUb2tlbik7XG4gICAgICAgIHRoaXMucmVmZXJlbmNlSW5kZXguc2V0KGRvY3VtZW50LnVyaS50b1N0cmluZygpLCBpbmRleERhdGEpO1xuICAgIH1cbiAgICBpc0FmZmVjdGVkKGRvY3VtZW50LCBjaGFuZ2VkVXJpcykge1xuICAgICAgICBjb25zdCByZWZlcmVuY2VzID0gdGhpcy5yZWZlcmVuY2VJbmRleC5nZXQoZG9jdW1lbnQudXJpLnRvU3RyaW5nKCkpO1xuICAgICAgICBpZiAoIXJlZmVyZW5jZXMpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVmZXJlbmNlcy5zb21lKHJlZiA9PiAhcmVmLmxvY2FsICYmIGNoYW5nZWRVcmlzLmhhcyhyZWYudGFyZ2V0VXJpLnRvU3RyaW5nKCkpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC1tYW5hZ2VyLmpzLm1hcCIsIi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbiAqIENvcHlyaWdodCAyMDIzIFR5cGVGb3ggR21iSFxuICogVGhpcyBwcm9ncmFtIGFuZCB0aGUgYWNjb21wYW55aW5nIG1hdGVyaWFscyBhcmUgbWFkZSBhdmFpbGFibGUgdW5kZXIgdGhlXG4gKiB0ZXJtcyBvZiB0aGUgTUlUIExpY2Vuc2UsIHdoaWNoIGlzIGF2YWlsYWJsZSBpbiB0aGUgcHJvamVjdCByb290LlxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmltcG9ydCB7IENhbmNlbGxhdGlvblRva2VuLCBDYW5jZWxsYXRpb25Ub2tlblNvdXJjZSB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBEZWZlcnJlZCwgaXNPcGVyYXRpb25DYW5jZWxsZWQsIHN0YXJ0Q2FuY2VsYWJsZU9wZXJhdGlvbiB9IGZyb20gJy4uL3V0aWxzL3Byb21pc2UtdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRXb3Jrc3BhY2VMb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91c1Rva2VuU291cmNlID0gbmV3IENhbmNlbGxhdGlvblRva2VuU291cmNlKCk7XG4gICAgICAgIHRoaXMud3JpdGVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLnJlYWRRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgIH1cbiAgICB3cml0ZShhY3Rpb24pIHtcbiAgICAgICAgdGhpcy5jYW5jZWxXcml0ZSgpO1xuICAgICAgICBjb25zdCB0b2tlblNvdXJjZSA9IHN0YXJ0Q2FuY2VsYWJsZU9wZXJhdGlvbigpO1xuICAgICAgICB0aGlzLnByZXZpb3VzVG9rZW5Tb3VyY2UgPSB0b2tlblNvdXJjZTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5xdWV1ZSh0aGlzLndyaXRlUXVldWUsIGFjdGlvbiwgdG9rZW5Tb3VyY2UudG9rZW4pO1xuICAgIH1cbiAgICByZWFkKGFjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5lbnF1ZXVlKHRoaXMucmVhZFF1ZXVlLCBhY3Rpb24pO1xuICAgIH1cbiAgICBlbnF1ZXVlKHF1ZXVlLCBhY3Rpb24sIGNhbmNlbGxhdGlvblRva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uTm9uZSkge1xuICAgICAgICBjb25zdCBkZWZlcnJlZCA9IG5ldyBEZWZlcnJlZCgpO1xuICAgICAgICBjb25zdCBlbnRyeSA9IHtcbiAgICAgICAgICAgIGFjdGlvbixcbiAgICAgICAgICAgIGRlZmVycmVkLFxuICAgICAgICAgICAgY2FuY2VsbGF0aW9uVG9rZW5cbiAgICAgICAgfTtcbiAgICAgICAgcXVldWUucHVzaChlbnRyeSk7XG4gICAgICAgIHRoaXMucGVyZm9ybU5leHRPcGVyYXRpb24oKTtcbiAgICAgICAgcmV0dXJuIGRlZmVycmVkLnByb21pc2U7XG4gICAgfVxuICAgIGFzeW5jIHBlcmZvcm1OZXh0T3BlcmF0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVudHJpZXMgPSBbXTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAvLyBKdXN0IHBlcmZvcm0gdGhlIG5leHQgd3JpdGUgYWN0aW9uXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2godGhpcy53cml0ZVF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMucmVhZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIEVtcHR5IHRoZSByZWFkIHF1ZXVlIGFuZCBwZXJmb3JtIGFsbCBhY3Rpb25zIGluIHBhcmFsbGVsXG4gICAgICAgICAgICBlbnRyaWVzLnB1c2goLi4udGhpcy5yZWFkUXVldWUuc3BsaWNlKDAsIHRoaXMucmVhZFF1ZXVlLmxlbmd0aCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChlbnRyaWVzLm1hcChhc3luYyAoeyBhY3Rpb24sIGRlZmVycmVkLCBjYW5jZWxsYXRpb25Ub2tlbiB9KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgYWN0aW9uIHRvIHRoZSBuZXh0IGV2ZW50IGxvb3AgdGljayB2aWEgYFByb21pc2UucmVzb2x2ZSgpYFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oKCkgPT4gYWN0aW9uKGNhbmNlbGxhdGlvblRva2VuKSk7XG4gICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChpc09wZXJhdGlvbkNhbmNlbGxlZChlcnIpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBvcGVyYXRpb24gd2FzIGNhbmNlbGxlZCwgd2UgZG9uJ3Qgd2FudCB0byByZWplY3QgdGhlIHByb21pc2VcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVzb2x2ZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVmZXJyZWQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICAgIHRoaXMucGVyZm9ybU5leHRPcGVyYXRpb24oKTtcbiAgICB9XG4gICAgY2FuY2VsV3JpdGUoKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXNUb2tlblNvdXJjZS5jYW5jZWwoKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3Jrc3BhY2UtbG9jay5qcy5tYXAiLCIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG4gKiBDb3B5cmlnaHQgMjAyMiBUeXBlRm94IEdtYkhcbiAqIFRoaXMgcHJvZ3JhbSBhbmQgdGhlIGFjY29tcGFueWluZyBtYXRlcmlhbHMgYXJlIG1hZGUgYXZhaWxhYmxlIHVuZGVyIHRoZVxuICogdGVybXMgb2YgdGhlIE1JVCBMaWNlbnNlLCB3aGljaCBpcyBhdmFpbGFibGUgaW4gdGhlIHByb2plY3Qgcm9vdC5cbiAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5pbXBvcnQgeyBDYW5jZWxsYXRpb25Ub2tlbiB9IGZyb20gJy4uL3V0aWxzL2NhbmNlbGxhdGlvbi5qcyc7XG5pbXBvcnQgeyBEZWZlcnJlZCwgaW50ZXJydXB0QW5kQ2hlY2sgfSBmcm9tICcuLi91dGlscy9wcm9taXNlLXV0aWxzLmpzJztcbmltcG9ydCB7IFVSSSwgVXJpVXRpbHMgfSBmcm9tICcuLi91dGlscy91cmktdXRpbHMuanMnO1xuZXhwb3J0IGNsYXNzIERlZmF1bHRXb3Jrc3BhY2VNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihzZXJ2aWNlcykge1xuICAgICAgICB0aGlzLmluaXRpYWxCdWlsZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgdGhpcy5fcmVhZHkgPSBuZXcgRGVmZXJyZWQoKTtcbiAgICAgICAgdGhpcy5zZXJ2aWNlUmVnaXN0cnkgPSBzZXJ2aWNlcy5TZXJ2aWNlUmVnaXN0cnk7XG4gICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cyA9IHNlcnZpY2VzLndvcmtzcGFjZS5MYW5naXVtRG9jdW1lbnRzO1xuICAgICAgICB0aGlzLmRvY3VtZW50QnVpbGRlciA9IHNlcnZpY2VzLndvcmtzcGFjZS5Eb2N1bWVudEJ1aWxkZXI7XG4gICAgICAgIHRoaXMuZmlsZVN5c3RlbVByb3ZpZGVyID0gc2VydmljZXMud29ya3NwYWNlLkZpbGVTeXN0ZW1Qcm92aWRlcjtcbiAgICAgICAgdGhpcy5tdXRleCA9IHNlcnZpY2VzLndvcmtzcGFjZS5Xb3Jrc3BhY2VMb2NrO1xuICAgIH1cbiAgICBnZXQgcmVhZHkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeS5wcm9taXNlO1xuICAgIH1cbiAgICBnZXQgd29ya3NwYWNlRm9sZGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZm9sZGVycztcbiAgICB9XG4gICAgaW5pdGlhbGl6ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLmZvbGRlcnMgPSAoX2EgPSBwYXJhbXMud29ya3NwYWNlRm9sZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpbml0aWFsaXplZChfcGFyYW1zKSB7XG4gICAgICAgIC8vIEluaXRpYWxpemUgdGhlIHdvcmtzcGFjZSBldmVuIGlmIHRoZXJlIGFyZSBubyB3b3Jrc3BhY2UgZm9sZGVyc1xuICAgICAgICAvLyBXZSBzdGlsbCB3YW50IHRvIGxvYWQgYWRkaXRpb25hbCBkb2N1bWVudHMgKGxhbmd1YWdlIGxpYnJhcnkgb3Igc2ltaWxhcikgZHVyaW5nIGluaXRpYWxpemF0aW9uXG4gICAgICAgIHJldHVybiB0aGlzLm11dGV4LndyaXRlKHRva2VuID0+IHsgdmFyIF9hOyByZXR1cm4gdGhpcy5pbml0aWFsaXplV29ya3NwYWNlKChfYSA9IHRoaXMuZm9sZGVycykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW10sIHRva2VuKTsgfSk7XG4gICAgfVxuICAgIGFzeW5jIGluaXRpYWxpemVXb3Jrc3BhY2UoZm9sZGVycywgY2FuY2VsVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lKSB7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50cyA9IGF3YWl0IHRoaXMucGVyZm9ybVN0YXJ0dXAoZm9sZGVycyk7XG4gICAgICAgIC8vIE9ubHkgYWZ0ZXIgY3JlYXRpbmcgYWxsIGRvY3VtZW50cyBkbyB3ZSBjaGVjayB3aGV0aGVyIHdlIG5lZWQgdG8gY2FuY2VsIHRoZSBpbml0aWFsaXphdGlvblxuICAgICAgICAvLyBUaGUgZG9jdW1lbnQgYnVpbGRlciB3aWxsIGxhdGVyIHBpY2sgdXAgb24gYWxsIHVucHJvY2Vzc2VkIGRvY3VtZW50c1xuICAgICAgICBhd2FpdCBpbnRlcnJ1cHRBbmRDaGVjayhjYW5jZWxUb2tlbik7XG4gICAgICAgIGF3YWl0IHRoaXMuZG9jdW1lbnRCdWlsZGVyLmJ1aWxkKGRvY3VtZW50cywgdGhpcy5pbml0aWFsQnVpbGRPcHRpb25zLCBjYW5jZWxUb2tlbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIHRoZSB1bmludGVycnVwdGFibGUgc3RhcnR1cCBzZXF1ZW5jZSBvZiB0aGUgd29ya3NwYWNlIG1hbmFnZXIuXG4gICAgICogVGhpcyBtZXRob2RzIGxvYWRzIGFsbCBkb2N1bWVudHMgaW4gdGhlIHdvcmtzcGFjZSBhbmQgb3RoZXIgZG9jdW1lbnRzIGFuZCByZXR1cm5zIHRoZW0uXG4gICAgICovXG4gICAgYXN5bmMgcGVyZm9ybVN0YXJ0dXAoZm9sZGVycykge1xuICAgICAgICBjb25zdCBmaWxlRXh0ZW5zaW9ucyA9IHRoaXMuc2VydmljZVJlZ2lzdHJ5LmFsbC5mbGF0TWFwKGUgPT4gZS5MYW5ndWFnZU1ldGFEYXRhLmZpbGVFeHRlbnNpb25zKTtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRzID0gW107XG4gICAgICAgIGNvbnN0IGNvbGxlY3RvciA9IChkb2N1bWVudCkgPT4ge1xuICAgICAgICAgICAgZG9jdW1lbnRzLnB1c2goZG9jdW1lbnQpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmxhbmdpdW1Eb2N1bWVudHMuaGFzRG9jdW1lbnQoZG9jdW1lbnQudXJpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubGFuZ2l1bURvY3VtZW50cy5hZGREb2N1bWVudChkb2N1bWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGRvbid0IGF3YWl0IHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgd29ya3NwYWNlIG1hbmFnZXIsXG4gICAgICAgIC8vIHdlIGNhbiBzdGlsbCBhc3N1bWUgdGhhdCBhbGwgbGlicmFyeSBkb2N1bWVudHMgYW5kIGZpbGUgZG9jdW1lbnRzIGFyZSBsb2FkZWQgYnkgdGhlIHRpbWUgd2Ugc3RhcnQgYnVpbGRpbmcgZG9jdW1lbnRzLlxuICAgICAgICAvLyBUaGUgbXV0ZXggcHJldmVudHMgYW55dGhpbmcgZnJvbSBwZXJmb3JtaW5nIGEgd29ya3NwYWNlIGJ1aWxkIHVudGlsIHdlIGNoZWNrIHRoZSBjYW5jZWxsYXRpb24gdG9rZW5cbiAgICAgICAgYXdhaXQgdGhpcy5sb2FkQWRkaXRpb25hbERvY3VtZW50cyhmb2xkZXJzLCBjb2xsZWN0b3IpO1xuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChmb2xkZXJzLm1hcCh3ZiA9PiBbd2YsIHRoaXMuZ2V0Um9vdEZvbGRlcih3ZildKVxuICAgICAgICAgICAgLm1hcChhc3luYyAoZW50cnkpID0+IHRoaXMudHJhdmVyc2VGb2xkZXIoLi4uZW50cnksIGZpbGVFeHRlbnNpb25zLCBjb2xsZWN0b3IpKSk7XG4gICAgICAgIHRoaXMuX3JlYWR5LnJlc29sdmUoKTtcbiAgICAgICAgcmV0dXJuIGRvY3VtZW50cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9hZCBhbGwgYWRkaXRpb25hbCBkb2N1bWVudHMgdGhhdCBzaGFsbCBiZSB2aXNpYmxlIGluIHRoZSBjb250ZXh0IG9mIHRoZSBnaXZlbiB3b3Jrc3BhY2VcbiAgICAgKiBmb2xkZXJzIGFuZCBhZGQgdGhlbSB0byB0aGUgY29sbGVjdG9yLiBUaGlzIGNhbiBiZSB1c2VkIHRvIGluY2x1ZGUgYnVpbHQtaW4gbGlicmFyaWVzIG9mXG4gICAgICogeW91ciBsYW5ndWFnZSwgd2hpY2ggY2FuIGJlIGVpdGhlciBsb2FkZWQgZnJvbSBwcm92aWRlZCBmaWxlcyBvciBjb25zdHJ1Y3RlZCBpbiBtZW1vcnkuXG4gICAgICovXG4gICAgbG9hZEFkZGl0aW9uYWxEb2N1bWVudHMoX2ZvbGRlcnMsIF9jb2xsZWN0b3IpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgdGhlIHJvb3QgZm9sZGVyIG9mIHRoZSBzb3VyY2UgZG9jdW1lbnRzIGluIHRoZSBnaXZlbiB3b3Jrc3BhY2UgZm9sZGVyLlxuICAgICAqIFRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIHJldHVybnMgdGhlIFVSSSBvZiB0aGUgd29ya3NwYWNlIGZvbGRlciwgYnV0IHlvdSBjYW4gb3ZlcnJpZGVcbiAgICAgKiB0aGlzIHRvIHJldHVybiBhIHN1YmZvbGRlciBsaWtlIGBzcmNgIGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0Um9vdEZvbGRlcih3b3Jrc3BhY2VGb2xkZXIpIHtcbiAgICAgICAgcmV0dXJuIFVSSS5wYXJzZSh3b3Jrc3BhY2VGb2xkZXIudXJpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhdmVyc2UgdGhlIGZpbGUgc3lzdGVtIGZvbGRlciBpZGVudGlmaWVkIGJ5IHRoZSBnaXZlbiBVUkkgYW5kIGl0cyBzdWJmb2xkZXJzLiBBbGxcbiAgICAgKiBjb250YWluZWQgZmlsZXMgdGhhdCBtYXRjaCB0aGUgZmlsZSBleHRlbnNpb25zIGFyZSBhZGRlZCB0byB0aGUgY29sbGVjdG9yLlxuICAgICAqL1xuICAgIGFzeW5jIHRyYXZlcnNlRm9sZGVyKHdvcmtzcGFjZUZvbGRlciwgZm9sZGVyUGF0aCwgZmlsZUV4dGVuc2lvbnMsIGNvbGxlY3Rvcikge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgdGhpcy5maWxlU3lzdGVtUHJvdmlkZXIucmVhZERpcmVjdG9yeShmb2xkZXJQYXRoKTtcbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoY29udGVudC5tYXAoYXN5bmMgKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5pbmNsdWRlRW50cnkod29ya3NwYWNlRm9sZGVyLCBlbnRyeSwgZmlsZUV4dGVuc2lvbnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMudHJhdmVyc2VGb2xkZXIod29ya3NwYWNlRm9sZGVyLCBlbnRyeS51cmksIGZpbGVFeHRlbnNpb25zLCBjb2xsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZG9jdW1lbnQgPSBhd2FpdCB0aGlzLmxhbmdpdW1Eb2N1bWVudHMuZ2V0T3JDcmVhdGVEb2N1bWVudChlbnRyeS51cmkpO1xuICAgICAgICAgICAgICAgICAgICBjb2xsZWN0b3IoZG9jdW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmUgd2hldGhlciB0aGUgZ2l2ZW4gZm9sZGVyIGVudHJ5IHNoYWxsIGJlIGluY2x1ZGVkIHdoaWxlIGluZGV4aW5nIHRoZSB3b3Jrc3BhY2UuXG4gICAgICovXG4gICAgaW5jbHVkZUVudHJ5KF93b3Jrc3BhY2VGb2xkZXIsIGVudHJ5LCBmaWxlRXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCBuYW1lID0gVXJpVXRpbHMuYmFzZW5hbWUoZW50cnkudXJpKTtcbiAgICAgICAgaWYgKG5hbWUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudHJ5LmlzRGlyZWN0b3J5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmFtZSAhPT0gJ25vZGVfbW9kdWxlcycgJiYgbmFtZSAhPT0gJ291dCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBleHRuYW1lID0gVXJpVXRpbHMuZXh0bmFtZShlbnRyeS51cmkpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbGVFeHRlbnNpb25zLmluY2x1ZGVzKGV4dG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3Jrc3BhY2UtbWFuYWdlci5qcy5tYXAiLCIvKipcbiAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGFycmF5KTtcbiAgfVxuICByZXR1cm4gYWNjdW11bGF0b3I7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFycmF5QWdncmVnYXRvcjtcbiIsIi8qKlxuICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmV2ZXJ5YCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gKiAgZWxzZSBgZmFsc2VgLlxuICovXG5mdW5jdGlvbiBhcnJheUV2ZXJ5KGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgdmFyIGluZGV4ID0gLTEsXG4gICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIGlmICghcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYXJyYXlFdmVyeTtcbiIsIi8qKlxuICogQ29udmVydHMgYW4gQVNDSUkgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgYXJyYXkuXG4gKi9cbmZ1bmN0aW9uIGFzY2lpVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5zcGxpdCgnJyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFzY2lpVG9BcnJheTtcbiIsImltcG9ydCBiYXNlRWFjaCBmcm9tICcuL19iYXNlRWFjaC5qcyc7XG5cbi8qKlxuICogQWdncmVnYXRlcyBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAgb24gYGFjY3VtdWxhdG9yYCB3aXRoIGtleXMgdHJhbnNmb3JtZWRcbiAqIGJ5IGBpdGVyYXRlZWAgYW5kIHZhbHVlcyBzZXQgYnkgYHNldHRlcmAuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VBZ2dyZWdhdG9yKGNvbGxlY3Rpb24sIHNldHRlciwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICBzZXR0ZXIoYWNjdW11bGF0b3IsIHZhbHVlLCBpdGVyYXRlZSh2YWx1ZSksIGNvbGxlY3Rpb24pO1xuICB9KTtcbiAgcmV0dXJuIGFjY3VtdWxhdG9yO1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlQWdncmVnYXRvcjtcbiIsImltcG9ydCBTZXRDYWNoZSBmcm9tICcuL19TZXRDYWNoZS5qcyc7XG5pbXBvcnQgYXJyYXlJbmNsdWRlcyBmcm9tICcuL19hcnJheUluY2x1ZGVzLmpzJztcbmltcG9ydCBhcnJheUluY2x1ZGVzV2l0aCBmcm9tICcuL19hcnJheUluY2x1ZGVzV2l0aC5qcyc7XG5pbXBvcnQgYXJyYXlNYXAgZnJvbSAnLi9fYXJyYXlNYXAuanMnO1xuaW1wb3J0IGJhc2VVbmFyeSBmcm9tICcuL19iYXNlVW5hcnkuanMnO1xuaW1wb3J0IGNhY2hlSGFzIGZyb20gJy4vX2NhY2hlSGFzLmpzJztcblxuLyoqIFVzZWQgYXMgdGhlIHNpemUgdG8gZW5hYmxlIGxhcmdlIGFycmF5IG9wdGltaXphdGlvbnMuICovXG52YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZGlmZmVyZW5jZWAgd2l0aG91dCBzdXBwb3J0XG4gKiBmb3IgZXhjbHVkaW5nIG11bHRpcGxlIGFycmF5cyBvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGJhc2VEaWZmZXJlbmNlKGFycmF5LCB2YWx1ZXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgaXNDb21tb24gPSB0cnVlLFxuICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgcmVzdWx0ID0gW10sXG4gICAgICB2YWx1ZXNMZW5ndGggPSB2YWx1ZXMubGVuZ3RoO1xuXG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpZiAoaXRlcmF0ZWUpIHtcbiAgICB2YWx1ZXMgPSBhcnJheU1hcCh2YWx1ZXMsIGJhc2VVbmFyeShpdGVyYXRlZSkpO1xuICB9XG4gIGlmIChjb21wYXJhdG9yKSB7XG4gICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICB9XG4gIGVsc2UgaWYgKHZhbHVlcy5sZW5ndGggPj0gTEFSR0VfQVJSQVlfU0laRSkge1xuICAgIGluY2x1ZGVzID0gY2FjaGVIYXM7XG4gICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICB2YWx1ZXMgPSBuZXcgU2V0Q2FjaGUodmFsdWVzKTtcbiAgfVxuICBvdXRlcjpcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgaWYgKGlzQ29tbW9uICYmIGNvbXB1dGVkID09PSBjb21wdXRlZCkge1xuICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgd2hpbGUgKHZhbHVlc0luZGV4LS0pIHtcbiAgICAgICAgaWYgKHZhbHVlc1t2YWx1ZXNJbmRleF0gPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIWluY2x1ZGVzKHZhbHVlcywgY29tcHV0ZWQsIGNvbXBhcmF0b3IpKSB7XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VEaWZmZXJlbmNlO1xuIiwiaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYFxuICovXG5mdW5jdGlvbiBiYXNlRXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQgPSB0cnVlO1xuICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICByZXN1bHQgPSAhIXByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBiYXNlRXZlcnk7XG4iLCJpbXBvcnQgYmFzZUdldFRhZyBmcm9tICcuL19iYXNlR2V0VGFnLmpzJztcbmltcG9ydCBpc09iamVjdExpa2UgZnJvbSAnLi9pc09iamVjdExpa2UuanMnO1xuXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXG52YXIgcmVnZXhwVGFnID0gJ1tvYmplY3QgUmVnRXhwXSc7XG5cbi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNSZWdFeHBgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VJc1JlZ0V4cCh2YWx1ZSkge1xuICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VJc1JlZ0V4cDtcbiIsIi8qKlxuICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKi9cbmZ1bmN0aW9uIGJhc2VTbGljZShhcnJheSwgc3RhcnQsIGVuZCkge1xuICB2YXIgaW5kZXggPSAtMSxcbiAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgfVxuICBlbmQgPSBlbmQgPiBsZW5ndGggPyBsZW5ndGggOiBlbmQ7XG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlbmd0aDtcbiAgfVxuICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gIHN0YXJ0ID4+Pj0gMDtcblxuICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcbiAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICByZXN1bHRbaW5kZXhdID0gYXJyYXlbaW5kZXggKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IGRlZmF1bHQgYmFzZVNsaWNlO1xuIiwiaW1wb3J0IGJhc2VFYWNoIGZyb20gJy4vX2Jhc2VFYWNoLmpzJztcblxuLyoqXG4gKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFueSBlbGVtZW50IHBhc3NlcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqL1xuZnVuY3Rpb24gYmFzZVNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gIHZhciByZXN1bHQ7XG5cbiAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgcmVzdWx0ID0gcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgcmV0dXJuICFyZXN1bHQ7XG4gIH0pO1xuICByZXR1cm4gISFyZXN1bHQ7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJhc2VTb21lO1xuIiwiaW1wb3J0IGJhc2VTbGljZSBmcm9tICcuL19iYXNlU2xpY2UuanMnO1xuXG4vKipcbiAqIENhc3RzIGBhcnJheWAgdG8gYSBzbGljZSBpZiBpdCdzIG5lZWRlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBjYXN0IHNsaWNlLlxuICovXG5mdW5jdGlvbiBjYXN0U2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gIHJldHVybiAoIXN0YXJ0ICYmIGVuZCA+PSBsZW5ndGgpID8gYXJyYXkgOiBiYXNlU2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpO1xufVxuXG5leHBvcnQgZGVmYXVsdCBjYXN0U2xpY2U7XG4iLCJpbXBvcnQgYXJyYXlBZ2dyZWdhdG9yIGZyb20gJy4vX2FycmF5QWdncmVnYXRvci5qcyc7XG5pbXBvcnQgYmFzZUFnZ3JlZ2F0b3IgZnJvbSAnLi9fYmFzZUFnZ3JlZ2F0b3IuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2luaXRpYWxpemVyXSBUaGUgYWNjdW11bGF0b3Igb2JqZWN0IGluaXRpYWxpemVyLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWdncmVnYXRvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQWdncmVnYXRvcihzZXR0ZXIsIGluaXRpYWxpemVyKSB7XG4gIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICBhY2N1bXVsYXRvciA9IGluaXRpYWxpemVyID8gaW5pdGlhbGl6ZXIoKSA6IHt9O1xuXG4gICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgc2V0dGVyLCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCBhY2N1bXVsYXRvcik7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUFnZ3JlZ2F0b3I7XG4iLCJpbXBvcnQgY2FzdFNsaWNlIGZyb20gJy4vX2Nhc3RTbGljZS5qcyc7XG5pbXBvcnQgaGFzVW5pY29kZSBmcm9tICcuL19oYXNVbmljb2RlLmpzJztcbmltcG9ydCBzdHJpbmdUb0FycmF5IGZyb20gJy4vX3N0cmluZ1RvQXJyYXkuanMnO1xuaW1wb3J0IHRvU3RyaW5nIGZyb20gJy4vdG9TdHJpbmcuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmxvd2VyRmlyc3RgLlxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kTmFtZSBUaGUgbmFtZSBvZiB0aGUgYFN0cmluZ2AgY2FzZSBtZXRob2QgdG8gdXNlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FzZSBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQ2FzZUZpcnN0KG1ldGhvZE5hbWUpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICB2YXIgc3RyU3ltYm9scyA9IGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyBzdHJpbmdUb0FycmF5KHN0cmluZylcbiAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNociA9IHN0clN5bWJvbHNcbiAgICAgID8gc3RyU3ltYm9sc1swXVxuICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgdmFyIHRyYWlsaW5nID0gc3RyU3ltYm9sc1xuICAgICAgPyBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMSkuam9pbignJylcbiAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgcmV0dXJuIGNoclttZXRob2ROYW1lXSgpICsgdHJhaWxpbmc7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZUNhc2VGaXJzdDtcbiIsImltcG9ydCBhc2NpaVRvQXJyYXkgZnJvbSAnLi9fYXNjaWlUb0FycmF5LmpzJztcbmltcG9ydCBoYXNVbmljb2RlIGZyb20gJy4vX2hhc1VuaWNvZGUuanMnO1xuaW1wb3J0IHVuaWNvZGVUb0FycmF5IGZyb20gJy4vX3VuaWNvZGVUb0FycmF5LmpzJztcblxuLyoqXG4gKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc3RyaW5nVG9BcnJheShzdHJpbmcpIHtcbiAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgID8gdW5pY29kZVRvQXJyYXkoc3RyaW5nKVxuICAgIDogYXNjaWlUb0FycmF5KHN0cmluZyk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0cmluZ1RvQXJyYXk7XG4iLCIvKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2hhcmFjdGVyIGNsYXNzZXMuICovXG52YXIgcnNBc3RyYWxSYW5nZSA9ICdcXFxcdWQ4MDAtXFxcXHVkZmZmJyxcbiAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICByZUNvbWJvSGFsZk1hcmtzUmFuZ2UgPSAnXFxcXHVmZTIwLVxcXFx1ZmUyZicsXG4gICAgcnNDb21ib1N5bWJvbHNSYW5nZSA9ICdcXFxcdTIwZDAtXFxcXHUyMGZmJyxcbiAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgcnNWYXJSYW5nZSA9ICdcXFxcdWZlMGVcXFxcdWZlMGYnO1xuXG4vKiogVXNlZCB0byBjb21wb3NlIHVuaWNvZGUgY2FwdHVyZSBncm91cHMuICovXG52YXIgcnNBc3RyYWwgPSAnWycgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzQ29tYm8gPSAnWycgKyByc0NvbWJvUmFuZ2UgKyAnXScsXG4gICAgcnNGaXR6ID0gJ1xcXFx1ZDgzY1tcXFxcdWRmZmItXFxcXHVkZmZmXScsXG4gICAgcnNNb2RpZmllciA9ICcoPzonICsgcnNDb21ibyArICd8JyArIHJzRml0eiArICcpJyxcbiAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgIHJzUmVnaW9uYWwgPSAnKD86XFxcXHVkODNjW1xcXFx1ZGRlNi1cXFxcdWRkZmZdKXsyfScsXG4gICAgcnNTdXJyUGFpciA9ICdbXFxcXHVkODAwLVxcXFx1ZGJmZl1bXFxcXHVkYzAwLVxcXFx1ZGZmZl0nLFxuICAgIHJzWldKID0gJ1xcXFx1MjAwZCc7XG5cbi8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xudmFyIHJlT3B0TW9kID0gcnNNb2RpZmllciArICc/JyxcbiAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgIHJzT3B0Sm9pbiA9ICcoPzonICsgcnNaV0ogKyAnKD86JyArIFtyc05vbkFzdHJhbCwgcnNSZWdpb25hbCwgcnNTdXJyUGFpcl0uam9pbignfCcpICsgJyknICsgcnNPcHRWYXIgKyByZU9wdE1vZCArICcpKicsXG4gICAgcnNTZXEgPSByc09wdFZhciArIHJlT3B0TW9kICsgcnNPcHRKb2luLFxuICAgIHJzU3ltYm9sID0gJyg/OicgKyBbcnNOb25Bc3RyYWwgKyByc0NvbWJvICsgJz8nLCByc0NvbWJvLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyLCByc0FzdHJhbF0uam9pbignfCcpICsgJyknO1xuXG4vKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xudmFyIHJlVW5pY29kZSA9IFJlZ0V4cChyc0ZpdHogKyAnKD89JyArIHJzRml0eiArICcpfCcgKyByc1N5bWJvbCArIHJzU2VxLCAnZycpO1xuXG4vKipcbiAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcubWF0Y2gocmVVbmljb2RlKSB8fCBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdW5pY29kZVRvQXJyYXk7XG4iLCJpbXBvcnQgYXNzaWduVmFsdWUgZnJvbSAnLi9fYXNzaWduVmFsdWUuanMnO1xuaW1wb3J0IGNvcHlPYmplY3QgZnJvbSAnLi9fY29weU9iamVjdC5qcyc7XG5pbXBvcnQgY3JlYXRlQXNzaWduZXIgZnJvbSAnLi9fY3JlYXRlQXNzaWduZXIuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlIGZyb20gJy4vaXNBcnJheUxpa2UuanMnO1xuaW1wb3J0IGlzUHJvdG90eXBlIGZyb20gJy4vX2lzUHJvdG90eXBlLmpzJztcbmltcG9ydCBrZXlzIGZyb20gJy4va2V5cy5qcyc7XG5cbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbnZhciBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbi8qKiBVc2VkIHRvIGNoZWNrIG9iamVjdHMgZm9yIG93biBwcm9wZXJ0aWVzLiAqL1xudmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogQXNzaWducyBvd24gZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyB0byB0aGVcbiAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICogU3Vic2VxdWVudCBzb3VyY2VzIG92ZXJ3cml0ZSBwcm9wZXJ0eSBhc3NpZ25tZW50cyBvZiBwcmV2aW91cyBzb3VyY2VzLlxuICpcbiAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gKiBbYE9iamVjdC5hc3NpZ25gXShodHRwczovL21kbi5pby9PYmplY3QvYXNzaWduKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMTAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICogQHNlZSBfLmFzc2lnbkluXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIEZvbygpIHtcbiAqICAgdGhpcy5hID0gMTtcbiAqIH1cbiAqXG4gKiBmdW5jdGlvbiBCYXIoKSB7XG4gKiAgIHRoaXMuYyA9IDM7XG4gKiB9XG4gKlxuICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gKlxuICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gKiAvLyA9PiB7ICdhJzogMSwgJ2MnOiAzIH1cbiAqL1xudmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gIGlmIChpc1Byb3RvdHlwZShzb3VyY2UpIHx8IGlzQXJyYXlMaWtlKHNvdXJjZSkpIHtcbiAgICBjb3B5T2JqZWN0KHNvdXJjZSwga2V5cyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgc291cmNlW2tleV0pO1xuICAgIH1cbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGFzc2lnbjtcbiIsImltcG9ydCBiYXNlQ2xvbmUgZnJvbSAnLi9fYmFzZUNsb25lLmpzJztcblxuLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbnZhciBDTE9ORV9TWU1CT0xTX0ZMQUcgPSA0O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGB2YWx1ZWAuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gKiBbc3RydWN0dXJlZCBjbG9uZSBhbGdvcml0aG1dKGh0dHBzOi8vbWRuLmlvL1N0cnVjdHVyZWRfY2xvbmVfYWxnb3JpdGhtKVxuICogYW5kIHN1cHBvcnRzIGNsb25pbmcgYXJyYXlzLCBhcnJheSBidWZmZXJzLCBib29sZWFucywgZGF0ZSBvYmplY3RzLCBtYXBzLFxuICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gKiBhcnJheXMuIFRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIGBhcmd1bWVudHNgIG9iamVjdHMgYXJlIGNsb25lZFxuICogYXMgcGxhaW4gb2JqZWN0cy4gQW4gZW1wdHkgb2JqZWN0IGlzIHJldHVybmVkIGZvciB1bmNsb25lYWJsZSB2YWx1ZXMgc3VjaFxuICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgY2xvbmVkIHZhbHVlLlxuICogQHNlZSBfLmNsb25lRGVlcFxuICogQGV4YW1wbGVcbiAqXG4gKiB2YXIgb2JqZWN0cyA9IFt7ICdhJzogMSB9LCB7ICdiJzogMiB9XTtcbiAqXG4gKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUob2JqZWN0cyk7XG4gKiBjb25zb2xlLmxvZyhzaGFsbG93WzBdID09PSBvYmplY3RzWzBdKTtcbiAqIC8vID0+IHRydWVcbiAqL1xuZnVuY3Rpb24gY2xvbmUodmFsdWUpIHtcbiAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xvbmU7XG4iLCIvKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgZmFsc2V5IHZhbHVlcyByZW1vdmVkLiBUaGUgdmFsdWVzIGBmYWxzZWAsIGBudWxsYCxcbiAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5jb21wYWN0KFswLCAxLCBmYWxzZSwgMiwgJycsIDNdKTtcbiAqIC8vID0+IFsxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBjb21wYWN0KGFycmF5KSB7XG4gIHZhciBpbmRleCA9IC0xLFxuICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICByZXNJbmRleCA9IDAsXG4gICAgICByZXN1bHQgPSBbXTtcblxuICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjb21wYWN0O1xuIiwiaW1wb3J0IGJhc2VEaWZmZXJlbmNlIGZyb20gJy4vX2Jhc2VEaWZmZXJlbmNlLmpzJztcbmltcG9ydCBiYXNlRmxhdHRlbiBmcm9tICcuL19iYXNlRmxhdHRlbi5qcyc7XG5pbXBvcnQgYmFzZVJlc3QgZnJvbSAnLi9fYmFzZVJlc3QuanMnO1xuaW1wb3J0IGlzQXJyYXlMaWtlT2JqZWN0IGZyb20gJy4vaXNBcnJheUxpa2VPYmplY3QuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCB2YWx1ZXMgbm90IGluY2x1ZGVkIGluIHRoZSBvdGhlciBnaXZlbiBhcnJheXNcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuXG4gKlxuICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICogQHBhcmFtIHsuLi5BcnJheX0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICogQHNlZSBfLndpdGhvdXQsIF8ueG9yXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZGlmZmVyZW5jZShbMiwgMV0sIFsyLCAzXSk7XG4gKiAvLyA9PiBbMV1cbiAqL1xudmFyIGRpZmZlcmVuY2UgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICA6IFtdO1xufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGRpZmZlcmVuY2U7XG4iLCJpbXBvcnQgYmFzZVNsaWNlIGZyb20gJy4vX2Jhc2VTbGljZS5qcyc7XG5pbXBvcnQgdG9JbnRlZ2VyIGZyb20gJy4vdG9JbnRlZ2VyLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuNS4wXG4gKiBAY2F0ZWdvcnkgQXJyYXlcbiAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmRyb3AoWzEsIDIsIDNdKTtcbiAqIC8vID0+IFsyLCAzXVxuICpcbiAqIF8uZHJvcChbMSwgMiwgM10sIDIpO1xuICogLy8gPT4gWzNdXG4gKlxuICogXy5kcm9wKFsxLCAyLCAzXSwgNSk7XG4gKiAvLyA9PiBbXVxuICpcbiAqIF8uZHJvcChbMSwgMiwgM10sIDApO1xuICogLy8gPT4gWzEsIDIsIDNdXG4gKi9cbmZ1bmN0aW9uIGRyb3AoYXJyYXksIG4sIGd1YXJkKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgcmV0dXJuIGJhc2VTbGljZShhcnJheSwgbiA8IDAgPyAwIDogbiwgbGVuZ3RoKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZHJvcDtcbiIsImltcG9ydCBiYXNlU2xpY2UgZnJvbSAnLi9fYmFzZVNsaWNlLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gZHJvcC5cbiAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gKiAvLyA9PiBbMSwgMl1cbiAqXG4gKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICogLy8gPT4gWzFdXG4gKlxuICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAqIC8vID0+IFtdXG4gKlxuICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAqIC8vID0+IFsxLCAyLCAzXVxuICovXG5mdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgbiA9IChndWFyZCB8fCBuID09PSB1bmRlZmluZWQpID8gMSA6IHRvSW50ZWdlcihuKTtcbiAgbiA9IGxlbmd0aCAtIG47XG4gIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIDAsIG4gPCAwID8gMCA6IG4pO1xufVxuXG5leHBvcnQgZGVmYXVsdCBkcm9wUmlnaHQ7XG4iLCJpbXBvcnQgYXJyYXlFdmVyeSBmcm9tICcuL19hcnJheUV2ZXJ5LmpzJztcbmltcG9ydCBiYXNlRXZlcnkgZnJvbSAnLi9fYmFzZUV2ZXJ5LmpzJztcbmltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbGwqKiBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAuXG4gKiBJdGVyYXRpb24gaXMgc3RvcHBlZCBvbmNlIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gKlxuICogKipOb3RlOioqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgIGZvclxuICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAqIFtldmVyeXRoaW5nIGlzIHRydWVdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1ZhY3VvdXNfdHJ1dGgpIG9mXG4gKiBlbGVtZW50cyBvZiBlbXB0eSBjb2xsZWN0aW9ucy5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbGwgZWxlbWVudHMgcGFzcyB0aGUgcHJlZGljYXRlIGNoZWNrLFxuICogIGVsc2UgYGZhbHNlYC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAqIC8vID0+IGZhbHNlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogZmFsc2UgfVxuICogXTtcbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZXZlcnkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZXZlcnkodXNlcnMsICdhY3RpdmUnKTtcbiAqIC8vID0+IGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGV2ZXJ5KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZXZlcnk7XG4iLCJpbXBvcnQgYmFzZUZsYXR0ZW4gZnJvbSAnLi9fYmFzZUZsYXR0ZW4uanMnO1xuaW1wb3J0IG1hcCBmcm9tICcuL21hcC5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZsYXR0ZW5lZCBhcnJheSBvZiB2YWx1ZXMgYnkgcnVubmluZyBlYWNoIGVsZW1lbnQgaW4gYGNvbGxlY3Rpb25gXG4gKiB0aHJ1IGBpdGVyYXRlZWAgYW5kIGZsYXR0ZW5pbmcgdGhlIG1hcHBlZCByZXN1bHRzLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDQuMC4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gKiBAZXhhbXBsZVxuICpcbiAqIGZ1bmN0aW9uIGR1cGxpY2F0ZShuKSB7XG4gKiAgIHJldHVybiBbbiwgbl07XG4gKiB9XG4gKlxuICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICovXG5mdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gIHJldHVybiBiYXNlRmxhdHRlbihtYXAoY29sbGVjdGlvbiwgaXRlcmF0ZWUpLCAxKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZmxhdE1hcDtcbiIsImltcG9ydCBiYXNlQXNzaWduVmFsdWUgZnJvbSAnLi9fYmFzZUFzc2lnblZhbHVlLmpzJztcbmltcG9ydCBjcmVhdGVBZ2dyZWdhdG9yIGZyb20gJy4vX2NyZWF0ZUFnZ3JlZ2F0b3IuanMnO1xuXG4vKiogVXNlZCBmb3IgYnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMuICovXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xuXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFByb3RvLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICogaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiBgY29sbGVjdGlvbmAuIFRoZSBjb3JyZXNwb25kaW5nXG4gKiB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhbiBhcnJheSBvZiBlbGVtZW50cyByZXNwb25zaWJsZSBmb3IgZ2VuZXJhdGluZyB0aGVcbiAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmdyb3VwQnkoWzYuMSwgNC4yLCA2LjNdLCBNYXRoLmZsb29yKTtcbiAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICogLy8gPT4geyAnMyc6IFsnb25lJywgJ3R3byddLCAnNSc6IFsndGhyZWUnXSB9XG4gKi9cbnZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCBrZXkpKSB7XG4gICAgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBbdmFsdWVdKTtcbiAgfVxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGdyb3VwQnk7XG4iLCIvKipcbiAqIEdldHMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAYWxpYXMgZmlyc3RcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAqIEBleGFtcGxlXG4gKlxuICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gKiAvLyA9PiAxXG4gKlxuICogXy5oZWFkKFtdKTtcbiAqIC8vID0+IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGFycmF5WzBdIDogdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZGVmYXVsdCBoZWFkO1xuIiwiaW1wb3J0IGJhc2VJbmRleE9mIGZyb20gJy4vX2Jhc2VJbmRleE9mLmpzJztcbmltcG9ydCBpc0FycmF5TGlrZSBmcm9tICcuL2lzQXJyYXlMaWtlLmpzJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICcuL2lzU3RyaW5nLmpzJztcbmltcG9ydCB0b0ludGVnZXIgZnJvbSAnLi90b0ludGVnZXIuanMnO1xuaW1wb3J0IHZhbHVlcyBmcm9tICcuL3ZhbHVlcy5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICogY2hlY2tlZCBmb3IgYSBzdWJzdHJpbmcgb2YgYHZhbHVlYCwgb3RoZXJ3aXNlXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAqIHRoZSBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBjb2xsZWN0aW9uYC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R8c3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ucmVkdWNlYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKFsxLCAyLCAzXSwgMSwgMik7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIF8uaW5jbHVkZXMoeyAnYSc6IDEsICdiJzogMiB9LCAxKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmluY2x1ZGVzKCdhYmNkJywgJ2JjJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVzKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgsIGd1YXJkKSB7XG4gIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gIGZyb21JbmRleCA9IChmcm9tSW5kZXggJiYgIWd1YXJkKSA/IHRvSW50ZWdlcihmcm9tSW5kZXgpIDogMDtcblxuICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG4gIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgZnJvbUluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGZyb21JbmRleCwgMCk7XG4gIH1cbiAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgPyAoZnJvbUluZGV4IDw9IGxlbmd0aCAmJiBjb2xsZWN0aW9uLmluZGV4T2YodmFsdWUsIGZyb21JbmRleCkgPiAtMSlcbiAgICA6ICghIWxlbmd0aCAmJiBiYXNlSW5kZXhPZihjb2xsZWN0aW9uLCB2YWx1ZSwgZnJvbUluZGV4KSA+IC0xKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5jbHVkZXM7XG4iLCJpbXBvcnQgYmFzZUluZGV4T2YgZnJvbSAnLi9fYmFzZUluZGV4T2YuanMnO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tICcuL3RvSW50ZWdlci5qcyc7XG5cbi8qIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIGZvciB0aG9zZSB3aXRoIHRoZSBzYW1lIG5hbWUgYXMgb3RoZXIgYGxvZGFzaGAgbWV0aG9kcy4gKi9cbnZhciBuYXRpdmVNYXggPSBNYXRoLm1heDtcblxuLyoqXG4gKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXMgdGhlXG4gKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSAwLjEuMFxuICogQGNhdGVnb3J5IEFycmF5XG4gKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gKiBAcGFyYW0ge251bWJlcn0gW2Zyb21JbmRleD0wXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAqIC8vID0+IDFcbiAqXG4gKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAqIC8vID0+IDNcbiAqL1xuZnVuY3Rpb24gaW5kZXhPZihhcnJheSwgdmFsdWUsIGZyb21JbmRleCkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gIGlmICghbGVuZ3RoKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9XG4gIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAgaW5kZXggPSBuYXRpdmVNYXgobGVuZ3RoICsgaW5kZXgsIDApO1xuICB9XG4gIHJldHVybiBiYXNlSW5kZXhPZihhcnJheSwgdmFsdWUsIGluZGV4KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgaW5kZXhPZjtcbiIsImltcG9ydCBiYXNlSXNSZWdFeHAgZnJvbSAnLi9fYmFzZUlzUmVnRXhwLmpzJztcbmltcG9ydCBiYXNlVW5hcnkgZnJvbSAnLi9fYmFzZVVuYXJ5LmpzJztcbmltcG9ydCBub2RlVXRpbCBmcm9tICcuL19ub2RlVXRpbC5qcyc7XG5cbi8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG52YXIgbm9kZUlzUmVnRXhwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNSZWdFeHA7XG5cbi8qKlxuICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgTGFuZ1xuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHJlZ2V4cCwgZWxzZSBgZmFsc2VgLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLmlzUmVnRXhwKC9hYmMvKTtcbiAqIC8vID0+IHRydWVcbiAqXG4gKiBfLmlzUmVnRXhwKCcvYWJjLycpO1xuICogLy8gPT4gZmFsc2VcbiAqL1xudmFyIGlzUmVnRXhwID0gbm9kZUlzUmVnRXhwID8gYmFzZVVuYXJ5KG5vZGVJc1JlZ0V4cCkgOiBiYXNlSXNSZWdFeHA7XG5cbmV4cG9ydCBkZWZhdWx0IGlzUmVnRXhwO1xuIiwiLyoqIEVycm9yIG1lc3NhZ2UgY29uc3RhbnRzLiAqL1xudmFyIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJztcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICogYGZ1bmNgIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlXG4gKiBjcmVhdGVkIGZ1bmN0aW9uLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMy4wLjBcbiAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBwcmVkaWNhdGUgdG8gbmVnYXRlLlxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAqIEBleGFtcGxlXG4gKlxuICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gKiB9XG4gKlxuICogXy5maWx0ZXIoWzEsIDIsIDMsIDQsIDUsIDZdLCBfLm5lZ2F0ZShpc0V2ZW4pKTtcbiAqIC8vID0+IFsxLCAzLCA1XVxuICovXG5mdW5jdGlvbiBuZWdhdGUocHJlZGljYXRlKSB7XG4gIGlmICh0eXBlb2YgcHJlZGljYXRlICE9ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgIGNhc2UgMDogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzKTtcbiAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgIGNhc2UgMjogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgIGNhc2UgMzogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG4gICAgcmV0dXJuICFwcmVkaWNhdGUuYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IG5lZ2F0ZTtcbiIsImltcG9ydCBhcnJheU1hcCBmcm9tICcuL19hcnJheU1hcC5qcyc7XG5pbXBvcnQgYmFzZUl0ZXJhdGVlIGZyb20gJy4vX2Jhc2VJdGVyYXRlZS5qcyc7XG5pbXBvcnQgYmFzZVBpY2tCeSBmcm9tICcuL19iYXNlUGlja0J5LmpzJztcbmltcG9ydCBnZXRBbGxLZXlzSW4gZnJvbSAnLi9fZ2V0QWxsS2V5c0luLmpzJztcblxuLyoqXG4gKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiB0aGUgYG9iamVjdGAgcHJvcGVydGllcyBgcHJlZGljYXRlYCByZXR1cm5zXG4gKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gKlxuICogQHN0YXRpY1xuICogQG1lbWJlck9mIF9cbiAqIEBzaW5jZSA0LjAuMFxuICogQGNhdGVnb3J5IE9iamVjdFxuICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gKlxuICogXy5waWNrQnkob2JqZWN0LCBfLmlzTnVtYmVyKTtcbiAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICovXG5mdW5jdGlvbiBwaWNrQnkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHZhciBwcm9wcyA9IGFycmF5TWFwKGdldEFsbEtleXNJbihvYmplY3QpLCBmdW5jdGlvbihwcm9wKSB7XG4gICAgcmV0dXJuIFtwcm9wXTtcbiAgfSk7XG4gIHByZWRpY2F0ZSA9IGJhc2VJdGVyYXRlZShwcmVkaWNhdGUpO1xuICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHByb3BzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcGlja0J5O1xuIiwiaW1wb3J0IGFycmF5RmlsdGVyIGZyb20gJy4vX2FycmF5RmlsdGVyLmpzJztcbmltcG9ydCBiYXNlRmlsdGVyIGZyb20gJy4vX2Jhc2VGaWx0ZXIuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGlzQXJyYXkgZnJvbSAnLi9pc0FycmF5LmpzJztcbmltcG9ydCBuZWdhdGUgZnJvbSAnLi9uZWdhdGUuanMnO1xuXG4vKipcbiAqIFRoZSBvcHBvc2l0ZSBvZiBgXy5maWx0ZXJgOyB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmBcbiAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAqIEBzZWUgXy5maWx0ZXJcbiAqIEBleGFtcGxlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9XG4gKiBdO1xuICpcbiAqIF8ucmVqZWN0KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5J11cbiAqXG4gKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gKiBfLnJlamVjdCh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8ucmVqZWN0KHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gKi9cbmZ1bmN0aW9uIHJlamVjdChjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBuZWdhdGUoYmFzZUl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgcmVqZWN0O1xuIiwiaW1wb3J0IGFycmF5U29tZSBmcm9tICcuL19hcnJheVNvbWUuanMnO1xuaW1wb3J0IGJhc2VJdGVyYXRlZSBmcm9tICcuL19iYXNlSXRlcmF0ZWUuanMnO1xuaW1wb3J0IGJhc2VTb21lIGZyb20gJy4vX2Jhc2VTb21lLmpzJztcbmltcG9ydCBpc0FycmF5IGZyb20gJy4vaXNBcnJheS5qcyc7XG5pbXBvcnQgaXNJdGVyYXRlZUNhbGwgZnJvbSAnLi9faXNJdGVyYXRlZUNhbGwuanMnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYC5cbiAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAqXG4gKiBAc3RhdGljXG4gKiBAbWVtYmVyT2YgX1xuICogQHNpbmNlIDAuMS4wXG4gKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAqICBlbHNlIGBmYWxzZWAuXG4gKiBAZXhhbXBsZVxuICpcbiAqIF8uc29tZShbbnVsbCwgMCwgJ3llcycsIGZhbHNlXSwgQm9vbGVhbik7XG4gKiAvLyA9PiB0cnVlXG4gKlxuICogdmFyIHVzZXJzID0gW1xuICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAqIF07XG4gKlxuICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gKiAvLyA9PiBmYWxzZVxuICpcbiAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICogLy8gPT4gdHJ1ZVxuICpcbiAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICogXy5zb21lKHVzZXJzLCAnYWN0aXZlJyk7XG4gKiAvLyA9PiB0cnVlXG4gKi9cbmZ1bmN0aW9uIHNvbWUoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNvbWUgOiBiYXNlU29tZTtcbiAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgcHJlZGljYXRlID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGJhc2VJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgc29tZTtcbiIsImltcG9ydCBiYXNlVW5pcSBmcm9tICcuL19iYXNlVW5pcS5qcyc7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgYW4gYXJyYXksIHVzaW5nXG4gKiBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICogaXMga2VwdC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1clxuICogaW4gdGhlIGFycmF5LlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgMC4xLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxKFsyLCAxLCAyXSk7XG4gKiAvLyA9PiBbMiwgMV1cbiAqL1xuZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBiYXNlVW5pcShhcnJheSkgOiBbXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgdW5pcTtcbiIsImltcG9ydCBiYXNlSXRlcmF0ZWUgZnJvbSAnLi9fYmFzZUl0ZXJhdGVlLmpzJztcbmltcG9ydCBiYXNlVW5pcSBmcm9tICcuL19iYXNlVW5pcS5qcyc7XG5cbi8qKlxuICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAqIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlXG4gKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gKiAodmFsdWUpLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBBcnJheVxuICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAqIEBleGFtcGxlXG4gKlxuICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAqIC8vID0+IFsyLjEsIDEuMl1cbiAqXG4gKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAqIF8udW5pcUJ5KFt7ICd4JzogMSB9LCB7ICd4JzogMiB9LCB7ICd4JzogMSB9XSwgJ3gnKTtcbiAqIC8vID0+IFt7ICd4JzogMSB9LCB7ICd4JzogMiB9XVxuICovXG5mdW5jdGlvbiB1bmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCBiYXNlSXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKSA6IFtdO1xufVxuXG5leHBvcnQgZGVmYXVsdCB1bmlxQnk7XG4iLCJpbXBvcnQgY3JlYXRlQ2FzZUZpcnN0IGZyb20gJy4vX2NyZWF0ZUNhc2VGaXJzdC5qcyc7XG5cbi8qKlxuICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICpcbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJPZiBfXG4gKiBAc2luY2UgNC4wLjBcbiAqIEBjYXRlZ29yeSBTdHJpbmdcbiAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICogQGV4YW1wbGVcbiAqXG4gKiBfLnVwcGVyRmlyc3QoJ2ZyZWQnKTtcbiAqIC8vID0+ICdGcmVkJ1xuICpcbiAqIF8udXBwZXJGaXJzdCgnRlJFRCcpO1xuICogLy8gPT4gJ0ZSRUQnXG4gKi9cbnZhciB1cHBlckZpcnN0ID0gY3JlYXRlQ2FzZUZpcnN0KCd0b1VwcGVyQ2FzZScpO1xuXG5leHBvcnQgZGVmYXVsdCB1cHBlckZpcnN0O1xuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqICBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqICBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gZXhwb3J0cy5DYW5jZWxsYXRpb25Ub2tlbiA9IHZvaWQgMDtcbmNvbnN0IHJhbF8xID0gcmVxdWlyZShcIi4vcmFsXCIpO1xuY29uc3QgSXMgPSByZXF1aXJlKFwiLi9pc1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcIi4vZXZlbnRzXCIpO1xudmFyIENhbmNlbGxhdGlvblRva2VuO1xuKGZ1bmN0aW9uIChDYW5jZWxsYXRpb25Ub2tlbikge1xuICAgIENhbmNlbGxhdGlvblRva2VuLk5vbmUgPSBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgaXNDYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGZhbHNlLFxuICAgICAgICBvbkNhbmNlbGxhdGlvblJlcXVlc3RlZDogZXZlbnRzXzEuRXZlbnQuTm9uZVxuICAgIH0pO1xuICAgIENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZCA9IE9iamVjdC5mcmVlemUoe1xuICAgICAgICBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZDogdHJ1ZSxcbiAgICAgICAgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQ6IGV2ZW50c18xLkV2ZW50Lk5vbmVcbiAgICB9KTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiAoY2FuZGlkYXRlID09PSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lXG4gICAgICAgICAgICB8fCBjYW5kaWRhdGUgPT09IENhbmNlbGxhdGlvblRva2VuLkNhbmNlbGxlZFxuICAgICAgICAgICAgfHwgKElzLmJvb2xlYW4oY2FuZGlkYXRlLmlzQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKSAmJiAhIWNhbmRpZGF0ZS5vbkNhbmNlbGxhdGlvblJlcXVlc3RlZCkpO1xuICAgIH1cbiAgICBDYW5jZWxsYXRpb25Ub2tlbi5pcyA9IGlzO1xufSkoQ2FuY2VsbGF0aW9uVG9rZW4gfHwgKGV4cG9ydHMuQ2FuY2VsbGF0aW9uVG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbiA9IHt9KSk7XG5jb25zdCBzaG9ydGN1dEV2ZW50ID0gT2JqZWN0LmZyZWV6ZShmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICBjb25zdCBoYW5kbGUgPSAoMCwgcmFsXzEuZGVmYXVsdCkoKS50aW1lci5zZXRUaW1lb3V0KGNhbGxiYWNrLmJpbmQoY29udGV4dCksIDApO1xuICAgIHJldHVybiB7IGRpc3Bvc2UoKSB7IGhhbmRsZS5kaXNwb3NlKCk7IH0gfTtcbn0pO1xuY2xhc3MgTXV0YWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5faXNDYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2lzQ2FuY2VsbGVkKSB7XG4gICAgICAgICAgICB0aGlzLl9pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZmlyZSh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc0NhbmNlbGxhdGlvblJlcXVlc3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2FuY2VsbGVkO1xuICAgIH1cbiAgICBnZXQgb25DYW5jZWxsYXRpb25SZXF1ZXN0ZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9pc0NhbmNlbGxlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHNob3J0Y3V0RXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9lbWl0dGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0dGVyID0gbmV3IGV2ZW50c18xLkVtaXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZW1pdHRlci5ldmVudDtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZXIuZGlzcG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5fZW1pdHRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNsYXNzIENhbmNlbGxhdGlvblRva2VuU291cmNlIHtcbiAgICBnZXQgdG9rZW4oKSB7XG4gICAgICAgIGlmICghdGhpcy5fdG9rZW4pIHtcbiAgICAgICAgICAgIC8vIGJlIGxhenkgYW5kIGNyZWF0ZSB0aGUgdG9rZW4gb25seSB3aGVuXG4gICAgICAgICAgICAvLyBhY3R1YWxseSBuZWVkZWRcbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gbmV3IE11dGFibGVUb2tlbigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl90b2tlbjtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3Rva2VuKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFuIG9iamVjdCBieSByZXR1cm5pbmcgdGhlIGRlZmF1bHRcbiAgICAgICAgICAgIC8vIGNhbmNlbGxlZCB0b2tlbiB3aGVuIGNhbmNlbGxhdGlvbiBoYXBwZW5zXG4gICAgICAgICAgICAvLyBiZWZvcmUgc29tZW9uZSBhc2tzIGZvciB0aGUgdG9rZW5cbiAgICAgICAgICAgIHRoaXMuX3Rva2VuID0gQ2FuY2VsbGF0aW9uVG9rZW4uQ2FuY2VsbGVkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fdG9rZW4uY2FuY2VsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl90b2tlbikge1xuICAgICAgICAgICAgLy8gZW5zdXJlIHRvIGluaXRpYWxpemUgd2l0aCBhbiBlbXB0eSB0b2tlbiBpZiB3ZSBoYWQgbm9uZVxuICAgICAgICAgICAgdGhpcy5fdG9rZW4gPSBDYW5jZWxsYXRpb25Ub2tlbi5Ob25lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX3Rva2VuIGluc3RhbmNlb2YgTXV0YWJsZVRva2VuKSB7XG4gICAgICAgICAgICAvLyBhY3R1YWxseSBkaXNwb3NlXG4gICAgICAgICAgICB0aGlzLl90b2tlbi5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNhbmNlbGxhdGlvblRva2VuU291cmNlID0gQ2FuY2VsbGF0aW9uVG9rZW5Tb3VyY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW1pdHRlciA9IGV4cG9ydHMuRXZlbnQgPSB2b2lkIDA7XG5jb25zdCByYWxfMSA9IHJlcXVpcmUoXCIuL3JhbFwiKTtcbnZhciBFdmVudDtcbihmdW5jdGlvbiAoRXZlbnQpIHtcbiAgICBjb25zdCBfZGlzcG9zYWJsZSA9IHsgZGlzcG9zZSgpIHsgfSB9O1xuICAgIEV2ZW50Lk5vbmUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBfZGlzcG9zYWJsZTsgfTtcbn0pKEV2ZW50IHx8IChleHBvcnRzLkV2ZW50ID0gRXZlbnQgPSB7fSkpO1xuY2xhc3MgQ2FsbGJhY2tMaXN0IHtcbiAgICBhZGQoY2FsbGJhY2ssIGNvbnRleHQgPSBudWxsLCBidWNrZXQpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzLnB1c2goY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGJ1Y2tldCkpIHtcbiAgICAgICAgICAgIGJ1Y2tldC5wdXNoKHsgZGlzcG9zZTogKCkgPT4gdGhpcy5yZW1vdmUoY2FsbGJhY2ssIGNvbnRleHQpIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShjYWxsYmFjaywgY29udGV4dCA9IG51bGwpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0ID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSB0aGlzLl9jYWxsYmFja3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3NbaV0gPT09IGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2NvbnRleHRzW2ldID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrICYgY29udGV4dCBtYXRjaCA9PiByZW1vdmUgaXRcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY29udGV4dHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmb3VuZENhbGxiYWNrV2l0aERpZmZlcmVudENvbnRleHQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRDYWxsYmFja1dpdGhEaWZmZXJlbnRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gYWRkaW5nIGEgbGlzdGVuZXIgd2l0aCBhIGNvbnRleHQsIHlvdSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggdGhlIHNhbWUgY29udGV4dCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGludm9rZSguLi5hcmdzKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gW10sIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcy5zbGljZSgwKSwgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cy5zbGljZSgwKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXQucHVzaChjYWxsYmFja3NbaV0uYXBwbHkoY29udGV4dHNbaV0sIGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgICAgICAoMCwgcmFsXzEuZGVmYXVsdCkoKS5jb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAhdGhpcy5fY2FsbGJhY2tzIHx8IHRoaXMuX2NhbGxiYWNrcy5sZW5ndGggPT09IDA7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIHRoaXMuX2NhbGxiYWNrcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY29udGV4dHMgPSB1bmRlZmluZWQ7XG4gICAgfVxufVxuY2xhc3MgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoX29wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IF9vcHRpb25zO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGb3IgdGhlIHB1YmxpYyB0byBhbGxvdyB0byBzdWJzY3JpYmVcbiAgICAgKiB0byBldmVudHMgZnJvbSB0aGlzIEVtaXR0ZXJcbiAgICAgKi9cbiAgICBnZXQgZXZlbnQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50ID0gKGxpc3RlbmVyLCB0aGlzQXJncywgZGlzcG9zYWJsZXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSBuZXcgQ2FsbGJhY2tMaXN0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25GaXJzdExpc3RlbmVyQWRkICYmIHRoaXMuX2NhbGxiYWNrcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5vbkZpcnN0TGlzdGVuZXJBZGQodGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5hZGQobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3Bvc2U6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZGlzcG9zYWJsZSBpcyBkaXNwb3NlZCBhZnRlciBlbWl0dGVyIGlzIGRpc3Bvc2VkLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5yZW1vdmUobGlzdGVuZXIsIHRoaXNBcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5kaXNwb3NlID0gRW1pdHRlci5fbm9vcDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9vcHRpb25zICYmIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUgJiYgdGhpcy5fY2FsbGJhY2tzLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX29wdGlvbnMub25MYXN0TGlzdGVuZXJSZW1vdmUodGhpcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRpc3Bvc2FibGVzKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXNwb3NhYmxlcy5wdXNoKHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUga2VwdCBwcml2YXRlIHRvIGZpcmUgYW4gZXZlbnQgdG9cbiAgICAgKiBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIGZpcmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbGxiYWNrcykge1xuICAgICAgICAgICAgdGhpcy5fY2FsbGJhY2tzLmludm9rZS5jYWxsKHRoaXMuX2NhbGxiYWNrcywgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYWxsYmFja3MpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbGxiYWNrcy5kaXNwb3NlKCk7XG4gICAgICAgICAgICB0aGlzLl9jYWxsYmFja3MgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkVtaXR0ZXIgPSBFbWl0dGVyO1xuRW1pdHRlci5fbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5zdHJpbmdBcnJheSA9IGV4cG9ydHMuYXJyYXkgPSBleHBvcnRzLmZ1bmMgPSBleHBvcnRzLmVycm9yID0gZXhwb3J0cy5udW1iZXIgPSBleHBvcnRzLnN0cmluZyA9IGV4cG9ydHMuYm9vbGVhbiA9IHZvaWQgMDtcbmZ1bmN0aW9uIGJvb2xlYW4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlO1xufVxuZXhwb3J0cy5ib29sZWFuID0gYm9vbGVhbjtcbmZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufVxuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5mdW5jdGlvbiBudW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB2YWx1ZSBpbnN0YW5jZW9mIE51bWJlcjtcbn1cbmV4cG9ydHMubnVtYmVyID0gbnVtYmVyO1xuZnVuY3Rpb24gZXJyb3IodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBFcnJvcjtcbn1cbmV4cG9ydHMuZXJyb3IgPSBlcnJvcjtcbmZ1bmN0aW9uIGZ1bmModmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5mdW5jID0gZnVuYztcbmZ1bmN0aW9uIGFycmF5KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpO1xufVxuZXhwb3J0cy5hcnJheSA9IGFycmF5O1xuZnVuY3Rpb24gc3RyaW5nQXJyYXkodmFsdWUpIHtcbiAgICByZXR1cm4gYXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KGVsZW0gPT4gc3RyaW5nKGVsZW0pKTtcbn1cbmV4cG9ydHMuc3RyaW5nQXJyYXkgPSBzdHJpbmdBcnJheTtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICogTGljZW5zZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLiBTZWUgTGljZW5zZS50eHQgaW4gdGhlIHByb2plY3Qgcm9vdCBmb3IgbGljZW5zZSBpbmZvcm1hdGlvbi5cbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xubGV0IF9yYWw7XG5mdW5jdGlvbiBSQUwoKSB7XG4gICAgaWYgKF9yYWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIHJ1bnRpbWUgYWJzdHJhY3Rpb24gbGF5ZXIgaW5zdGFsbGVkYCk7XG4gICAgfVxuICAgIHJldHVybiBfcmFsO1xufVxuKGZ1bmN0aW9uIChSQUwpIHtcbiAgICBmdW5jdGlvbiBpbnN0YWxsKHJhbCkge1xuICAgICAgICBpZiAocmFsID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm8gcnVudGltZSBhYnN0cmFjdGlvbiBsYXllciBwcm92aWRlZGApO1xuICAgICAgICB9XG4gICAgICAgIF9yYWwgPSByYWw7XG4gICAgfVxuICAgIFJBTC5pbnN0YWxsID0gaW5zdGFsbDtcbn0pKFJBTCB8fCAoUkFMID0ge30pKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJBTDtcbiIsIi8qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKiBDb3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS4gU2VlIExpY2Vuc2UudHh0IGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIGxpY2Vuc2UgaW5mb3JtYXRpb24uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cbid1c2Ugc3RyaWN0JztcbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gdGhpcy5vZmZzZXRBdChyYW5nZS5zdGFydCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSB0aGlzLm9mZnNldEF0KHJhbmdlLmVuZCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoc3RhcnQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRlbnQ7XG4gICAgfVxuICAgIHVwZGF0ZShjaGFuZ2VzLCB2ZXJzaW9uKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgICAgIGlmIChGdWxsVGV4dERvY3VtZW50LmlzSW5jcmVtZW50YWwoY2hhbmdlKSkge1xuICAgICAgICAgICAgICAgIC8vIG1ha2VzIHN1cmUgc3RhcnQgaXMgYmVmb3JlIGVuZFxuICAgICAgICAgICAgICAgIGNvbnN0IHJhbmdlID0gZ2V0V2VsbGZvcm1lZFJhbmdlKGNoYW5nZS5yYW5nZSk7XG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlIGNvbnRlbnRcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZE9mZnNldCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gdGhpcy5fY29udGVudC5zdWJzdHJpbmcoMCwgc3RhcnRPZmZzZXQpICsgY2hhbmdlLnRleHQgKyB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhlbmRPZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGUgdGhlIG9mZnNldHNcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFydExpbmUgPSBNYXRoLm1heChyYW5nZS5zdGFydC5saW5lLCAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmRMaW5lID0gTWF0aC5tYXgocmFuZ2UuZW5kLmxpbmUsIDApO1xuICAgICAgICAgICAgICAgIGxldCBsaW5lT2Zmc2V0cyA9IHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGVkTGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHMoY2hhbmdlLnRleHQsIGZhbHNlLCBzdGFydE9mZnNldCk7XG4gICAgICAgICAgICAgICAgaWYgKGVuZExpbmUgLSBzdGFydExpbmUgPT09IGFkZGVkTGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBhZGRlZExpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpICsgc3RhcnRMaW5lICsgMV0gPSBhZGRlZExpbmVPZmZzZXRzW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGggPCAxMDAwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGluZU9mZnNldHMuc3BsaWNlKHN0YXJ0TGluZSArIDEsIGVuZExpbmUgLSBzdGFydExpbmUsIC4uLmFkZGVkTGluZU9mZnNldHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgeyAvLyBhdm9pZCB0b28gbWFueSBhcmd1bWVudHMgZm9yIHNwbGljZVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBsaW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzLnNsaWNlKDAsIHN0YXJ0TGluZSArIDEpLmNvbmNhdChhZGRlZExpbmVPZmZzZXRzLCBsaW5lT2Zmc2V0cy5zbGljZShlbmRMaW5lICsgMSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBjaGFuZ2UudGV4dC5sZW5ndGggLSAoZW5kT2Zmc2V0IC0gc3RhcnRPZmZzZXQpO1xuICAgICAgICAgICAgICAgIGlmIChkaWZmICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSBzdGFydExpbmUgKyAxICsgYWRkZWRMaW5lT2Zmc2V0cy5sZW5ndGgsIGxlbiA9IGxpbmVPZmZzZXRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0c1tpXSA9IGxpbmVPZmZzZXRzW2ldICsgZGlmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKEZ1bGxUZXh0RG9jdW1lbnQuaXNGdWxsKGNoYW5nZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb250ZW50ID0gY2hhbmdlLnRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gY2hhbmdlIGV2ZW50IHJlY2VpdmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdmVyc2lvbiA9IHZlcnNpb247XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSBjb21wdXRlTGluZU9mZnNldHModGhpcy5fY29udGVudCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpbmVPZmZzZXRzO1xuICAgIH1cbiAgICBwb3NpdGlvbkF0KG9mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBNYXRoLm1heChNYXRoLm1pbihvZmZzZXQsIHRoaXMuX2NvbnRlbnQubGVuZ3RoKSwgMCk7XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBsZXQgbG93ID0gMCwgaGlnaCA9IGxpbmVPZmZzZXRzLmxlbmd0aDtcbiAgICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiB7IGxpbmU6IDAsIGNoYXJhY3Rlcjogb2Zmc2V0IH07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICAgIGNvbnN0IG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICAgICAgICBpZiAobGluZU9mZnNldHNbbWlkXSA+IG9mZnNldCkge1xuICAgICAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGxvdyBpcyB0aGUgbGVhc3QgeCBmb3Igd2hpY2ggdGhlIGxpbmUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIHRoZSBjdXJyZW50IG9mZnNldFxuICAgICAgICAvLyBvciBhcnJheS5sZW5ndGggaWYgbm8gbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIGNvbnN0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICBvZmZzZXQgPSB0aGlzLmVuc3VyZUJlZm9yZUVPTChvZmZzZXQsIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyOiBvZmZzZXQgLSBsaW5lT2Zmc2V0c1tsaW5lXSB9O1xuICAgIH1cbiAgICBvZmZzZXRBdChwb3NpdGlvbikge1xuICAgICAgICBjb25zdCBsaW5lT2Zmc2V0cyA9IHRoaXMuZ2V0TGluZU9mZnNldHMoKTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmxpbmUgPj0gbGluZU9mZnNldHMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudC5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocG9zaXRpb24ubGluZSA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgaWYgKHBvc2l0aW9uLmNoYXJhY3RlciA8PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbGluZU9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXh0TGluZU9mZnNldCA9IChwb3NpdGlvbi5saW5lICsgMSA8IGxpbmVPZmZzZXRzLmxlbmd0aCkgPyBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lICsgMV0gOiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpO1xuICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVCZWZvcmVFT0wob2Zmc2V0LCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZW5zdXJlQmVmb3JlRU9MKG9mZnNldCwgbGluZU9mZnNldCkge1xuICAgICAgICB3aGlsZSAob2Zmc2V0ID4gbGluZU9mZnNldCAmJiBpc0VPTCh0aGlzLl9jb250ZW50LmNoYXJDb2RlQXQob2Zmc2V0IC0gMSkpKSB7XG4gICAgICAgICAgICBvZmZzZXQtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBnZXQgbGluZUNvdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRMaW5lT2Zmc2V0cygpLmxlbmd0aDtcbiAgICB9XG4gICAgc3RhdGljIGlzSW5jcmVtZW50YWwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUucmFuZ2VMZW5ndGggPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgfVxuICAgIHN0YXRpYyBpc0Z1bGwoZXZlbnQpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiZcbiAgICAgICAgICAgIHR5cGVvZiBjYW5kaWRhdGUudGV4dCA9PT0gJ3N0cmluZycgJiYgY2FuZGlkYXRlLnJhbmdlID09PSB1bmRlZmluZWQgJiYgY2FuZGlkYXRlLnJhbmdlTGVuZ3RoID09PSB1bmRlZmluZWQ7XG4gICAgfVxufVxuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgdGV4dCBkb2N1bWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqIEBwYXJhbSBsYW5ndWFnZUlkICBUaGUgZG9jdW1lbnQncyBsYW5ndWFnZSBJZC5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyBpbml0aWFsIHZlcnNpb24gbnVtYmVyLlxuICAgICAqIEBwYXJhbSBjb250ZW50IFRoZSBkb2N1bWVudCdzIGNvbnRlbnQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICByZXR1cm4gbmV3IEZ1bGxUZXh0RG9jdW1lbnQodXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCBjb250ZW50KTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIGEgVGV4dERvY3VtZW50IGJ5IG1vZGlmeWluZyBpdHMgY29udGVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBkb2N1bWVudCB0aGUgZG9jdW1lbnQgdG8gdXBkYXRlLiBPbmx5IGRvY3VtZW50cyBjcmVhdGVkIGJ5IFRleHREb2N1bWVudC5jcmVhdGUgYXJlIHZhbGlkIGlucHV0cy5cbiAgICAgKiBAcGFyYW0gY2hhbmdlcyB0aGUgY2hhbmdlcyB0byBhcHBseSB0byB0aGUgZG9jdW1lbnQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gdGhlIGNoYW5nZXMgdmVyc2lvbiBmb3IgdGhlIGRvY3VtZW50LlxuICAgICAqIEByZXR1cm5zIFRoZSB1cGRhdGVkIFRleHREb2N1bWVudC4gTm90ZTogVGhhdCdzIHRoZSBzYW1lIGRvY3VtZW50IGluc3RhbmNlIHBhc3NlZCBpbiBhcyBmaXJzdCBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUoZG9jdW1lbnQsIGNoYW5nZXMsIHZlcnNpb24pIHtcbiAgICAgICAgaWYgKGRvY3VtZW50IGluc3RhbmNlb2YgRnVsbFRleHREb2N1bWVudCkge1xuICAgICAgICAgICAgZG9jdW1lbnQudXBkYXRlKGNoYW5nZXMsIHZlcnNpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUZXh0RG9jdW1lbnQudXBkYXRlOiBkb2N1bWVudCBtdXN0IGJlIGNyZWF0ZWQgYnkgVGV4dERvY3VtZW50LmNyZWF0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRleHREb2N1bWVudC51cGRhdGUgPSB1cGRhdGU7XG4gICAgZnVuY3Rpb24gYXBwbHlFZGl0cyhkb2N1bWVudCwgZWRpdHMpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgY29uc3Qgc29ydGVkRWRpdHMgPSBtZXJnZVNvcnQoZWRpdHMubWFwKGdldFdlbGxmb3JtZWRFZGl0KSwgKGEsIGIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gMDtcbiAgICAgICAgY29uc3Qgc3BhbnMgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBlIG9mIHNvcnRlZEVkaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgaWYgKHN0YXJ0T2Zmc2V0IDwgbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGFydE9mZnNldCA+IGxhc3RNb2RpZmllZE9mZnNldCkge1xuICAgICAgICAgICAgICAgIHNwYW5zLnB1c2godGV4dC5zdWJzdHJpbmcobGFzdE1vZGlmaWVkT2Zmc2V0LCBzdGFydE9mZnNldCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubmV3VGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBzcGFucy5wdXNoKGUubmV3VGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBkb2N1bWVudC5vZmZzZXRBdChlLnJhbmdlLmVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgc3BhbnMucHVzaCh0ZXh0LnN1YnN0cihsYXN0TW9kaWZpZWRPZmZzZXQpKTtcbiAgICAgICAgcmV0dXJuIHNwYW5zLmpvaW4oJycpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuYXBwbHlFZGl0cyA9IGFwcGx5RWRpdHM7XG59KShUZXh0RG9jdW1lbnQgfHwgKFRleHREb2N1bWVudCA9IHt9KSk7XG5mdW5jdGlvbiBtZXJnZVNvcnQoZGF0YSwgY29tcGFyZSkge1xuICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgIC8vIHNvcnRlZFxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgY29uc3QgcCA9IChkYXRhLmxlbmd0aCAvIDIpIHwgMDtcbiAgICBjb25zdCBsZWZ0ID0gZGF0YS5zbGljZSgwLCBwKTtcbiAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgbWVyZ2VTb3J0KGxlZnQsIGNvbXBhcmUpO1xuICAgIG1lcmdlU29ydChyaWdodCwgY29tcGFyZSk7XG4gICAgbGV0IGxlZnRJZHggPSAwO1xuICAgIGxldCByaWdodElkeCA9IDA7XG4gICAgbGV0IGkgPSAwO1xuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgcmV0ID0gY29tcGFyZShsZWZ0W2xlZnRJZHhdLCByaWdodFtyaWdodElkeF0pO1xuICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgIC8vIHNtYWxsZXJfZXF1YWwgLT4gdGFrZSBsZWZ0IHRvIHByZXNlcnZlIG9yZGVyXG4gICAgICAgICAgICBkYXRhW2krK10gPSBsZWZ0W2xlZnRJZHgrK107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBncmVhdGVyIC0+IHRha2UgcmlnaHRcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YVtpKytdID0gbGVmdFtsZWZ0SWR4KytdO1xuICAgIH1cbiAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgZGF0YVtpKytdID0gcmlnaHRbcmlnaHRJZHgrK107XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuZnVuY3Rpb24gY29tcHV0ZUxpbmVPZmZzZXRzKHRleHQsIGlzQXRMaW5lU3RhcnQsIHRleHRPZmZzZXQgPSAwKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gaXNBdExpbmVTdGFydCA/IFt0ZXh0T2Zmc2V0XSA6IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBjaCA9IHRleHQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGlzRU9MKGNoKSkge1xuICAgICAgICAgICAgaWYgKGNoID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyAmJiBpICsgMSA8IHRleHQubGVuZ3RoICYmIHRleHQuY2hhckNvZGVBdChpICsgMSkgPT09IDEwIC8qIENoYXJDb2RlLkxpbmVGZWVkICovKSB7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0LnB1c2godGV4dE9mZnNldCArIGkgKyAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gaXNFT0woY2hhcikge1xuICAgIHJldHVybiBjaGFyID09PSAxMyAvKiBDaGFyQ29kZS5DYXJyaWFnZVJldHVybiAqLyB8fCBjaGFyID09PSAxMCAvKiBDaGFyQ29kZS5MaW5lRmVlZCAqLztcbn1cbmZ1bmN0aW9uIGdldFdlbGxmb3JtZWRSYW5nZShyYW5nZSkge1xuICAgIGNvbnN0IHN0YXJ0ID0gcmFuZ2Uuc3RhcnQ7XG4gICAgY29uc3QgZW5kID0gcmFuZ2UuZW5kO1xuICAgIGlmIChzdGFydC5saW5lID4gZW5kLmxpbmUgfHwgKHN0YXJ0LmxpbmUgPT09IGVuZC5saW5lICYmIHN0YXJ0LmNoYXJhY3RlciA+IGVuZC5jaGFyYWN0ZXIpKSB7XG4gICAgICAgIHJldHVybiB7IHN0YXJ0OiBlbmQsIGVuZDogc3RhcnQgfTtcbiAgICB9XG4gICAgcmV0dXJuIHJhbmdlO1xufVxuZnVuY3Rpb24gZ2V0V2VsbGZvcm1lZEVkaXQodGV4dEVkaXQpIHtcbiAgICBjb25zdCByYW5nZSA9IGdldFdlbGxmb3JtZWRSYW5nZSh0ZXh0RWRpdC5yYW5nZSk7XG4gICAgaWYgKHJhbmdlICE9PSB0ZXh0RWRpdC5yYW5nZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0OiB0ZXh0RWRpdC5uZXdUZXh0LCByYW5nZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdGV4dEVkaXQ7XG59XG4iLCIvKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICogQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuIFNlZSBMaWNlbnNlLnR4dCBpbiB0aGUgcHJvamVjdCByb290IGZvciBsaWNlbnNlIGluZm9ybWF0aW9uLlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG4ndXNlIHN0cmljdCc7XG5leHBvcnQgdmFyIERvY3VtZW50VXJpO1xuKGZ1bmN0aW9uIChEb2N1bWVudFVyaSkge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBEb2N1bWVudFVyaS5pcyA9IGlzO1xufSkoRG9jdW1lbnRVcmkgfHwgKERvY3VtZW50VXJpID0ge30pKTtcbmV4cG9ydCB2YXIgVVJJO1xuKGZ1bmN0aW9uIChVUkkpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcbiAgICB9XG4gICAgVVJJLmlzID0gaXM7XG59KShVUkkgfHwgKFVSSSA9IHt9KSk7XG5leHBvcnQgdmFyIGludGVnZXI7XG4oZnVuY3Rpb24gKGludGVnZXIpIHtcbiAgICBpbnRlZ2VyLk1JTl9WQUxVRSA9IC0yMTQ3NDgzNjQ4O1xuICAgIGludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpbnRlZ2VyLk1JTl9WQUxVRSA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSBpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICB9XG4gICAgaW50ZWdlci5pcyA9IGlzO1xufSkoaW50ZWdlciB8fCAoaW50ZWdlciA9IHt9KSk7XG5leHBvcnQgdmFyIHVpbnRlZ2VyO1xuKGZ1bmN0aW9uICh1aW50ZWdlcikge1xuICAgIHVpbnRlZ2VyLk1JTl9WQUxVRSA9IDA7XG4gICAgdWludGVnZXIuTUFYX1ZBTFVFID0gMjE0NzQ4MzY0NztcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiB1aW50ZWdlci5NSU5fVkFMVUUgPD0gdmFsdWUgJiYgdmFsdWUgPD0gdWludGVnZXIuTUFYX1ZBTFVFO1xuICAgIH1cbiAgICB1aW50ZWdlci5pcyA9IGlzO1xufSkodWludGVnZXIgfHwgKHVpbnRlZ2VyID0ge30pKTtcbi8qKlxuICogVGhlIFBvc2l0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIFBvc2l0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBQb3NpdGlvbjtcbihmdW5jdGlvbiAoUG9zaXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IFBvc2l0aW9uIGxpdGVyYWwgZnJvbSB0aGUgZ2l2ZW4gbGluZSBhbmQgY2hhcmFjdGVyLlxuICAgICAqIEBwYXJhbSBsaW5lIFRoZSBwb3NpdGlvbidzIGxpbmUuXG4gICAgICogQHBhcmFtIGNoYXJhY3RlciBUaGUgcG9zaXRpb24ncyBjaGFyYWN0ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxpbmUsIGNoYXJhY3Rlcikge1xuICAgICAgICBpZiAobGluZSA9PT0gTnVtYmVyLk1BWF9WQUxVRSkge1xuICAgICAgICAgICAgbGluZSA9IHVpbnRlZ2VyLk1BWF9WQUxVRTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhcmFjdGVyID09PSBOdW1iZXIuTUFYX1ZBTFVFKSB7XG4gICAgICAgICAgICBjaGFyYWN0ZXIgPSB1aW50ZWdlci5NQVhfVkFMVUU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgbGluZSwgY2hhcmFjdGVyIH07XG4gICAgfVxuICAgIFBvc2l0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFBvc2l0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5saW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuY2hhcmFjdGVyKTtcbiAgICB9XG4gICAgUG9zaXRpb24uaXMgPSBpcztcbn0pKFBvc2l0aW9uIHx8IChQb3NpdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBSYW5nZSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUmFuZ2U7XG4oZnVuY3Rpb24gKFJhbmdlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKG9uZSwgdHdvLCB0aHJlZSwgZm91cikge1xuICAgICAgICBpZiAoSXMudWludGVnZXIob25lKSAmJiBJcy51aW50ZWdlcih0d28pICYmIElzLnVpbnRlZ2VyKHRocmVlKSAmJiBJcy51aW50ZWdlcihmb3VyKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IFBvc2l0aW9uLmNyZWF0ZShvbmUsIHR3byksIGVuZDogUG9zaXRpb24uY3JlYXRlKHRocmVlLCBmb3VyKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFBvc2l0aW9uLmlzKG9uZSkgJiYgUG9zaXRpb24uaXModHdvKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhcnQ6IG9uZSwgZW5kOiB0d28gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmFuZ2UjY3JlYXRlIGNhbGxlZCB3aXRoIGludmFsaWQgYXJndW1lbnRzWyR7b25lfSwgJHt0d299LCAke3RocmVlfSwgJHtmb3VyfV1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBSYW5nZX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBQb3NpdGlvbi5pcyhjYW5kaWRhdGUuc3RhcnQpICYmIFBvc2l0aW9uLmlzKGNhbmRpZGF0ZS5lbmQpO1xuICAgIH1cbiAgICBSYW5nZS5pcyA9IGlzO1xufSkoUmFuZ2UgfHwgKFJhbmdlID0ge30pKTtcbi8qKlxuICogVGhlIExvY2F0aW9uIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIExvY2F0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBMb2NhdGlvbjtcbihmdW5jdGlvbiAoTG9jYXRpb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgTG9jYXRpb24gbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBsb2NhdGlvbidzIHVyaS5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIGxvY2F0aW9uJ3MgcmFuZ2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCByYW5nZSB9O1xuICAgIH1cbiAgICBMb2NhdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBMb2NhdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS51cmkpKTtcbiAgICB9XG4gICAgTG9jYXRpb24uaXMgPSBpcztcbn0pKExvY2F0aW9uIHx8IChMb2NhdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBMb2NhdGlvbkxpbmsgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgTG9jYXRpb25MaW5rfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBMb2NhdGlvbkxpbms7XG4oZnVuY3Rpb24gKExvY2F0aW9uTGluaykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBMb2NhdGlvbkxpbmsgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0VXJpIFRoZSBkZWZpbml0aW9uJ3MgdXJpLlxuICAgICAqIEBwYXJhbSB0YXJnZXRSYW5nZSBUaGUgZnVsbCByYW5nZSBvZiB0aGUgZGVmaW5pdGlvbi5cbiAgICAgKiBAcGFyYW0gdGFyZ2V0U2VsZWN0aW9uUmFuZ2UgVGhlIHNwYW4gb2YgdGhlIHN5bWJvbCBkZWZpbml0aW9uIGF0IHRoZSB0YXJnZXQuXG4gICAgICogQHBhcmFtIG9yaWdpblNlbGVjdGlvblJhbmdlIFRoZSBzcGFuIG9mIHRoZSBzeW1ib2wgYmVpbmcgZGVmaW5lZCBpbiB0aGUgb3JpZ2luYXRpbmcgc291cmNlIGZpbGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRhcmdldFVyaSwgdGFyZ2V0UmFuZ2UsIHRhcmdldFNlbGVjdGlvblJhbmdlLCBvcmlnaW5TZWxlY3Rpb25SYW5nZSkge1xuICAgICAgICByZXR1cm4geyB0YXJnZXRVcmksIHRhcmdldFJhbmdlLCB0YXJnZXRTZWxlY3Rpb25SYW5nZSwgb3JpZ2luU2VsZWN0aW9uUmFuZ2UgfTtcbiAgICB9XG4gICAgTG9jYXRpb25MaW5rLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIExvY2F0aW9uTGlua30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUudGFyZ2V0UmFuZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0VXJpKVxuICAgICAgICAgICAgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnRhcmdldFNlbGVjdGlvblJhbmdlKVxuICAgICAgICAgICAgJiYgKFJhbmdlLmlzKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5vcmlnaW5TZWxlY3Rpb25SYW5nZSkpO1xuICAgIH1cbiAgICBMb2NhdGlvbkxpbmsuaXMgPSBpcztcbn0pKExvY2F0aW9uTGluayB8fCAoTG9jYXRpb25MaW5rID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9yIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIENvbG9yfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb2xvcjtcbihmdW5jdGlvbiAoQ29sb3IpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IENvbG9yIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJlZCwgZ3JlZW4sIGJsdWUsIGFscGhhKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICByZWQsXG4gICAgICAgICAgICBncmVlbixcbiAgICAgICAgICAgIGJsdWUsXG4gICAgICAgICAgICBhbHBoYSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgQ29sb3IuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3J9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUucmVkLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmdyZWVuLCAwLCAxKVxuICAgICAgICAgICAgJiYgSXMubnVtYmVyUmFuZ2UoY2FuZGlkYXRlLmJsdWUsIDAsIDEpXG4gICAgICAgICAgICAmJiBJcy5udW1iZXJSYW5nZShjYW5kaWRhdGUuYWxwaGEsIDAsIDEpO1xuICAgIH1cbiAgICBDb2xvci5pcyA9IGlzO1xufSkoQ29sb3IgfHwgKENvbG9yID0ge30pKTtcbi8qKlxuICogVGhlIENvbG9ySW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3JJbmZvcm1hdGlvbjtcbihmdW5jdGlvbiAoQ29sb3JJbmZvcm1hdGlvbikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29sb3JJbmZvcm1hdGlvbiBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgY29sb3IpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgY29sb3IsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9ySW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgQ29sb3JJbmZvcm1hdGlvbn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgQ29sb3IuaXMoY2FuZGlkYXRlLmNvbG9yKTtcbiAgICB9XG4gICAgQ29sb3JJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JJbmZvcm1hdGlvbiB8fCAoQ29sb3JJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBDb2xvciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb2xvclByZXNlbnRhdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29sb3JQcmVzZW50YXRpb247XG4oZnVuY3Rpb24gKENvbG9yUHJlc2VudGF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb2xvckluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCB0ZXh0RWRpdCwgYWRkaXRpb25hbFRleHRFZGl0cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICB0ZXh0RWRpdCxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxUZXh0RWRpdHMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIENvbG9yUHJlc2VudGF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIENvbG9ySW5mb3JtYXRpb259IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhYmVsKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUudGV4dEVkaXQpIHx8IFRleHRFZGl0LmlzKGNhbmRpZGF0ZSkpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5hZGRpdGlvbmFsVGV4dEVkaXRzLCBUZXh0RWRpdC5pcykpO1xuICAgIH1cbiAgICBDb2xvclByZXNlbnRhdGlvbi5pcyA9IGlzO1xufSkoQ29sb3JQcmVzZW50YXRpb24gfHwgKENvbG9yUHJlc2VudGF0aW9uID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCByYW5nZSBraW5kcy5cbiAqL1xuZXhwb3J0IHZhciBGb2xkaW5nUmFuZ2VLaW5kO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2VLaW5kKSB7XG4gICAgLyoqXG4gICAgICogRm9sZGluZyByYW5nZSBmb3IgYSBjb21tZW50XG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5Db21tZW50ID0gJ2NvbW1lbnQnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGFuIGltcG9ydCBvciBpbmNsdWRlXG4gICAgICovXG4gICAgRm9sZGluZ1JhbmdlS2luZC5JbXBvcnRzID0gJ2ltcG9ydHMnO1xuICAgIC8qKlxuICAgICAqIEZvbGRpbmcgcmFuZ2UgZm9yIGEgcmVnaW9uIChlLmcuIGAjcmVnaW9uYClcbiAgICAgKi9cbiAgICBGb2xkaW5nUmFuZ2VLaW5kLlJlZ2lvbiA9ICdyZWdpb24nO1xufSkoRm9sZGluZ1JhbmdlS2luZCB8fCAoRm9sZGluZ1JhbmdlS2luZCA9IHt9KSk7XG4vKipcbiAqIFRoZSBmb2xkaW5nIHJhbmdlIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIEZvbGRpbmdSYW5nZX0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9sZGluZ1JhbmdlO1xuKGZ1bmN0aW9uIChGb2xkaW5nUmFuZ2UpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IEZvbGRpbmdSYW5nZSBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShzdGFydExpbmUsIGVuZExpbmUsIHN0YXJ0Q2hhcmFjdGVyLCBlbmRDaGFyYWN0ZXIsIGtpbmQsIGNvbGxhcHNlZFRleHQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICAgICAgc3RhcnRMaW5lLFxuICAgICAgICAgICAgZW5kTGluZVxuICAgICAgICB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzdGFydENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zdGFydENoYXJhY3RlciA9IHN0YXJ0Q2hhcmFjdGVyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGVuZENoYXJhY3RlcikpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lbmRDaGFyYWN0ZXIgPSBlbmRDaGFyYWN0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoa2luZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5raW5kID0ga2luZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChjb2xsYXBzZWRUZXh0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbGxhcHNlZFRleHQgPSBjb2xsYXBzZWRUZXh0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIEZvbGRpbmdSYW5nZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBGb2xkaW5nUmFuZ2V9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRMaW5lKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUuc3RhcnRMaW5lKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc3RhcnRDaGFyYWN0ZXIpIHx8IElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5zdGFydENoYXJhY3RlcikpXG4gICAgICAgICAgICAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5lbmRDaGFyYWN0ZXIpIHx8IElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS5lbmRDaGFyYWN0ZXIpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUua2luZCkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSk7XG4gICAgfVxuICAgIEZvbGRpbmdSYW5nZS5pcyA9IGlzO1xufSkoRm9sZGluZ1JhbmdlIHx8IChGb2xkaW5nUmFuZ2UgPSB7fSkpO1xuLyoqXG4gKiBUaGUgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9ufSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxvY2F0aW9uLCBtZXNzYWdlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhdGlvbixcbiAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9ufSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5tZXNzYWdlKTtcbiAgICB9XG4gICAgRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbi5pcyA9IGlzO1xufSkoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiB8fCAoRGlhZ25vc3RpY1JlbGF0ZWRJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljJ3Mgc2V2ZXJpdHkuXG4gKi9cbmV4cG9ydCB2YXIgRGlhZ25vc3RpY1NldmVyaXR5O1xuKGZ1bmN0aW9uIChEaWFnbm9zdGljU2V2ZXJpdHkpIHtcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGFuIGVycm9yLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNTZXZlcml0eS5FcnJvciA9IDE7XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyBhIHdhcm5pbmcuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5Lldhcm5pbmcgPSAyO1xuICAgIC8qKlxuICAgICAqIFJlcG9ydHMgYW4gaW5mb3JtYXRpb24uXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1NldmVyaXR5LkluZm9ybWF0aW9uID0gMztcbiAgICAvKipcbiAgICAgKiBSZXBvcnRzIGEgaGludC5cbiAgICAgKi9cbiAgICBEaWFnbm9zdGljU2V2ZXJpdHkuSGludCA9IDQ7XG59KShEaWFnbm9zdGljU2V2ZXJpdHkgfHwgKERpYWdub3N0aWNTZXZlcml0eSA9IHt9KSk7XG4vKipcbiAqIFRoZSBkaWFnbm9zdGljIHRhZ3MuXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG5leHBvcnQgdmFyIERpYWdub3N0aWNUYWc7XG4oZnVuY3Rpb24gKERpYWdub3N0aWNUYWcpIHtcbiAgICAvKipcbiAgICAgKiBVbnVzZWQgb3IgdW5uZWNlc3NhcnkgY29kZS5cbiAgICAgKlxuICAgICAqIENsaWVudHMgYXJlIGFsbG93ZWQgdG8gcmVuZGVyIGRpYWdub3N0aWNzIHdpdGggdGhpcyB0YWcgZmFkZWQgb3V0IGluc3RlYWQgb2YgaGF2aW5nXG4gICAgICogYW4gZXJyb3Igc3F1aWdnbGUuXG4gICAgICovXG4gICAgRGlhZ25vc3RpY1RhZy5Vbm5lY2Vzc2FyeSA9IDE7XG4gICAgLyoqXG4gICAgICogRGVwcmVjYXRlZCBvciBvYnNvbGV0ZSBjb2RlLlxuICAgICAqXG4gICAgICogQ2xpZW50cyBhcmUgYWxsb3dlZCB0byByZW5kZXJlZCBkaWFnbm9zdGljcyB3aXRoIHRoaXMgdGFnIHN0cmlrZSB0aHJvdWdoLlxuICAgICAqL1xuICAgIERpYWdub3N0aWNUYWcuRGVwcmVjYXRlZCA9IDI7XG59KShEaWFnbm9zdGljVGFnIHx8IChEaWFnbm9zdGljVGFnID0ge30pKTtcbi8qKlxuICogVGhlIENvZGVEZXNjcmlwdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBkZXNjcmlwdGlvbnMgZm9yIGRpYWdub3N0aWMgY29kZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIENvZGVEZXNjcmlwdGlvbjtcbihmdW5jdGlvbiAoQ29kZURlc2NyaXB0aW9uKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5ocmVmKTtcbiAgICB9XG4gICAgQ29kZURlc2NyaXB0aW9uLmlzID0gaXM7XG59KShDb2RlRGVzY3JpcHRpb24gfHwgKENvZGVEZXNjcmlwdGlvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBEaWFnbm9zdGljIG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb25zIHRvIHdvcmsgd2l0aFxuICoge0BsaW5rIERpYWdub3N0aWN9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIERpYWdub3N0aWM7XG4oZnVuY3Rpb24gKERpYWdub3N0aWMpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IERpYWdub3N0aWMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIG1lc3NhZ2UsIHNldmVyaXR5LCBjb2RlLCBzb3VyY2UsIHJlbGF0ZWRJbmZvcm1hdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyByYW5nZSwgbWVzc2FnZSB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChzZXZlcml0eSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5zZXZlcml0eSA9IHNldmVyaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGNvZGUpKSB7XG4gICAgICAgICAgICByZXN1bHQuY29kZSA9IGNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKElzLmRlZmluZWQoc291cmNlKSkge1xuICAgICAgICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoSXMuZGVmaW5lZChyZWxhdGVkSW5mb3JtYXRpb24pKSB7XG4gICAgICAgICAgICByZXN1bHQucmVsYXRlZEluZm9ybWF0aW9uID0gcmVsYXRlZEluZm9ybWF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERpYWdub3N0aWMuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgRGlhZ25vc3RpY30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm1lc3NhZ2UpXG4gICAgICAgICAgICAmJiAoSXMubnVtYmVyKGNhbmRpZGF0ZS5zZXZlcml0eSkgfHwgSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5zZXZlcml0eSkpXG4gICAgICAgICAgICAmJiAoSXMuaW50ZWdlcihjYW5kaWRhdGUuY29kZSkgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5jb2RlKSB8fCBJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvZGUpKVxuICAgICAgICAgICAgJiYgKElzLnVuZGVmaW5lZChjYW5kaWRhdGUuY29kZURlc2NyaXB0aW9uKSB8fCAoSXMuc3RyaW5nKChfYSA9IGNhbmRpZGF0ZS5jb2RlRGVzY3JpcHRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ocmVmKSkpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5zb3VyY2UpIHx8IElzLnVuZGVmaW5lZChjYW5kaWRhdGUuc291cmNlKSlcbiAgICAgICAgICAgICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLnJlbGF0ZWRJbmZvcm1hdGlvbikgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUucmVsYXRlZEluZm9ybWF0aW9uLCBEaWFnbm9zdGljUmVsYXRlZEluZm9ybWF0aW9uLmlzKSk7XG4gICAgfVxuICAgIERpYWdub3N0aWMuaXMgPSBpcztcbn0pKERpYWdub3N0aWMgfHwgKERpYWdub3N0aWMgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tbWFuZCBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBDb21tYW5kfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBDb21tYW5kO1xuKGZ1bmN0aW9uIChDb21tYW5kKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBDb21tYW5kIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHRpdGxlLCBjb21tYW5kLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IHRpdGxlLCBjb21tYW5kIH07XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKGFyZ3MpICYmIGFyZ3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LmFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29tbWFuZC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb21tYW5kfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUuY29tbWFuZCk7XG4gICAgfVxuICAgIENvbW1hbmQuaXMgPSBpcztcbn0pKENvbW1hbmQgfHwgKENvbW1hbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dEVkaXQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byBjcmVhdGUgcmVwbGFjZSxcbiAqIGluc2VydCBhbmQgZGVsZXRlIGVkaXRzIG1vcmUgZWFzaWx5LlxuICovXG5leHBvcnQgdmFyIFRleHRFZGl0O1xuKGZ1bmN0aW9uIChUZXh0RWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRleHQgdG8gYmUgcmVwbGFjZWQuXG4gICAgICogQHBhcmFtIG5ld1RleHQgVGhlIG5ldyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGxhY2UocmFuZ2UsIG5ld1RleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIG5ld1RleHQgfTtcbiAgICB9XG4gICAgVGV4dEVkaXQucmVwbGFjZSA9IHJlcGxhY2U7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnNlcnQgdGV4dCBlZGl0LlxuICAgICAqIEBwYXJhbSBwb3NpdGlvbiBUaGUgcG9zaXRpb24gdG8gaW5zZXJ0IHRoZSB0ZXh0IGF0LlxuICAgICAqIEBwYXJhbSBuZXdUZXh0IFRoZSB0ZXh0IHRvIGJlIGluc2VydGVkLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCkge1xuICAgICAgICByZXR1cm4geyByYW5nZTogeyBzdGFydDogcG9zaXRpb24sIGVuZDogcG9zaXRpb24gfSwgbmV3VGV4dCB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGRlbGV0ZSB0ZXh0IGVkaXQuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0ZXh0IHRvIGJlIGRlbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVsKHJhbmdlKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBuZXdUZXh0OiAnJyB9O1xuICAgIH1cbiAgICBUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSlcbiAgICAgICAgICAgICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmV3VGV4dClcbiAgICAgICAgICAgICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSk7XG4gICAgfVxuICAgIFRleHRFZGl0LmlzID0gaXM7XG59KShUZXh0RWRpdCB8fCAoVGV4dEVkaXQgPSB7fSkpO1xuZXhwb3J0IHZhciBDaGFuZ2VBbm5vdGF0aW9uO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBuZWVkc0NvbmZpcm1hdGlvbiwgZGVzY3JpcHRpb24pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAobmVlZHNDb25maXJtYXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0Lm5lZWRzQ29uZmlybWF0aW9uID0gbmVlZHNDb25maXJtYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlc2NyaXB0aW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kZXNjcmlwdGlvbiA9IGRlc2NyaXB0aW9uO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb24uY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpICYmXG4gICAgICAgICAgICAoSXMuYm9vbGVhbihjYW5kaWRhdGUubmVlZHNDb25maXJtYXRpb24pIHx8IGNhbmRpZGF0ZS5uZWVkc0NvbmZpcm1hdGlvbiA9PT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKElzLnN0cmluZyhjYW5kaWRhdGUuZGVzY3JpcHRpb24pIHx8IGNhbmRpZGF0ZS5kZXNjcmlwdGlvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgQ2hhbmdlQW5ub3RhdGlvbi5pcyA9IGlzO1xufSkoQ2hhbmdlQW5ub3RhdGlvbiB8fCAoQ2hhbmdlQW5ub3RhdGlvbiA9IHt9KSk7XG5leHBvcnQgdmFyIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllcikge1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuc3RyaW5nKGNhbmRpZGF0ZSk7XG4gICAgfVxuICAgIENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzID0gaXM7XG59KShDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllciB8fCAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIgPSB7fSkpO1xuZXhwb3J0IHZhciBBbm5vdGF0ZWRUZXh0RWRpdDtcbihmdW5jdGlvbiAoQW5ub3RhdGVkVGV4dEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFubm90YXRlZCByZXBsYWNlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSByZXBsYWNlZC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgbmV3IHRleHQuXG4gICAgICogQHBhcmFtIGFubm90YXRpb24gVGhlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbklkOiBhbm5vdGF0aW9uIH07XG4gICAgfVxuICAgIEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYW5ub3RhdGVkIGluc2VydCB0ZXh0IGVkaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcG9zaXRpb24gVGhlIHBvc2l0aW9uIHRvIGluc2VydCB0aGUgdGV4dCBhdC5cbiAgICAgKiBAcGFyYW0gbmV3VGV4dCBUaGUgdGV4dCB0byBiZSBpbnNlcnRlZC5cbiAgICAgKiBAcGFyYW0gYW5ub3RhdGlvbiBUaGUgYW5ub3RhdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGFubm90YXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2U6IHsgc3RhcnQ6IHBvc2l0aW9uLCBlbmQ6IHBvc2l0aW9uIH0sIG5ld1RleHQsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQgPSBpbnNlcnQ7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhbm5vdGF0ZWQgZGVsZXRlIHRleHQgZWRpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByYW5nZSBUaGUgcmFuZ2Ugb2YgdGV4dCB0byBiZSBkZWxldGVkLlxuICAgICAqIEBwYXJhbSBhbm5vdGF0aW9uIFRoZSBhbm5vdGF0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlbChyYW5nZSwgYW5ub3RhdGlvbikge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgbmV3VGV4dDogJycsIGFubm90YXRpb25JZDogYW5ub3RhdGlvbiB9O1xuICAgIH1cbiAgICBBbm5vdGF0ZWRUZXh0RWRpdC5kZWwgPSBkZWw7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBUZXh0RWRpdC5pcyhjYW5kaWRhdGUpICYmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgQW5ub3RhdGVkVGV4dEVkaXQuaXMgPSBpcztcbn0pKEFubm90YXRlZFRleHRFZGl0IHx8IChBbm5vdGF0ZWRUZXh0RWRpdCA9IHt9KSk7XG4vKipcbiAqIFRoZSBUZXh0RG9jdW1lbnRFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBoZWxwZXIgZnVuY3Rpb24gdG8gY3JlYXRlXG4gKiBhbiBlZGl0IHRoYXQgbWFuaXB1bGF0ZXMgYSB0ZXh0IGRvY3VtZW50LlxuICovXG5leHBvcnQgdmFyIFRleHREb2N1bWVudEVkaXQ7XG4oZnVuY3Rpb24gKFRleHREb2N1bWVudEVkaXQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGBUZXh0RG9jdW1lbnRFZGl0YFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0ZXh0RG9jdW1lbnQsIGVkaXRzKSB7XG4gICAgICAgIHJldHVybiB7IHRleHREb2N1bWVudCwgZWRpdHMgfTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoY2FuZGlkYXRlLnRleHREb2N1bWVudClcbiAgICAgICAgICAgICYmIEFycmF5LmlzQXJyYXkoY2FuZGlkYXRlLmVkaXRzKTtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50RWRpdC5pcyA9IGlzO1xufSkoVGV4dERvY3VtZW50RWRpdCB8fCAoVGV4dERvY3VtZW50RWRpdCA9IHt9KSk7XG5leHBvcnQgdmFyIENyZWF0ZUZpbGU7XG4oZnVuY3Rpb24gKENyZWF0ZUZpbGUpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCBvcHRpb25zLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBraW5kOiAnY3JlYXRlJyxcbiAgICAgICAgICAgIHVyaVxuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucyAhPT0gdW5kZWZpbmVkICYmIChvcHRpb25zLm92ZXJ3cml0ZSAhPT0gdW5kZWZpbmVkIHx8IG9wdGlvbnMuaWdub3JlSWZFeGlzdHMgIT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQuYW5ub3RhdGlvbklkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgY2FuZGlkYXRlLmtpbmQgPT09ICdjcmVhdGUnICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgKChjYW5kaWRhdGUub3B0aW9ucy5vdmVyd3JpdGUgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSkpICYmIChjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cyA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZFeGlzdHMpKSkpICYmIChjYW5kaWRhdGUuYW5ub3RhdGlvbklkID09PSB1bmRlZmluZWQgfHwgQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoY2FuZGlkYXRlLmFubm90YXRpb25JZCkpO1xuICAgIH1cbiAgICBDcmVhdGVGaWxlLmlzID0gaXM7XG59KShDcmVhdGVGaWxlIHx8IChDcmVhdGVGaWxlID0ge30pKTtcbmV4cG9ydCB2YXIgUmVuYW1lRmlsZTtcbihmdW5jdGlvbiAoUmVuYW1lRmlsZSkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShvbGRVcmksIG5ld1VyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ3JlbmFtZScsXG4gICAgICAgICAgICBvbGRVcmksXG4gICAgICAgICAgICBuZXdVcmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5vdmVyd3JpdGUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmRXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgUmVuYW1lRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAncmVuYW1lJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm9sZFVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5uZXdVcmkpICYmIChjYW5kaWRhdGUub3B0aW9ucyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoKGNhbmRpZGF0ZS5vcHRpb25zLm92ZXJ3cml0ZSA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLm9wdGlvbnMub3ZlcndyaXRlKSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmRXhpc3RzID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5pZ25vcmVJZkV4aXN0cykpKSkgJiYgKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQgPT09IHVuZGVmaW5lZCB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhjYW5kaWRhdGUuYW5ub3RhdGlvbklkKSk7XG4gICAgfVxuICAgIFJlbmFtZUZpbGUuaXMgPSBpcztcbn0pKFJlbmFtZUZpbGUgfHwgKFJlbmFtZUZpbGUgPSB7fSkpO1xuZXhwb3J0IHZhciBEZWxldGVGaWxlO1xuKGZ1bmN0aW9uIChEZWxldGVGaWxlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHVyaSwgb3B0aW9ucywgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgcmVzdWx0ID0ge1xuICAgICAgICAgICAga2luZDogJ2RlbGV0ZScsXG4gICAgICAgICAgICB1cmlcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMgIT09IHVuZGVmaW5lZCAmJiAob3B0aW9ucy5yZWN1cnNpdmUgIT09IHVuZGVmaW5lZCB8fCBvcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzICE9PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICByZXN1bHQub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFubm90YXRpb25JZCA9IGFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIGNhbmRpZGF0ZS5raW5kID09PSAnZGVsZXRlJyAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgKGNhbmRpZGF0ZS5vcHRpb25zID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICgoY2FuZGlkYXRlLm9wdGlvbnMucmVjdXJzaXZlID09PSB1bmRlZmluZWQgfHwgSXMuYm9vbGVhbihjYW5kaWRhdGUub3B0aW9ucy5yZWN1cnNpdmUpKSAmJiAoY2FuZGlkYXRlLm9wdGlvbnMuaWdub3JlSWZOb3RFeGlzdHMgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5vcHRpb25zLmlnbm9yZUlmTm90RXhpc3RzKSkpKSAmJiAoY2FuZGlkYXRlLmFubm90YXRpb25JZCA9PT0gdW5kZWZpbmVkIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGNhbmRpZGF0ZS5hbm5vdGF0aW9uSWQpKTtcbiAgICB9XG4gICAgRGVsZXRlRmlsZS5pcyA9IGlzO1xufSkoRGVsZXRlRmlsZSB8fCAoRGVsZXRlRmlsZSA9IHt9KSk7XG5leHBvcnQgdmFyIFdvcmtzcGFjZUVkaXQ7XG4oZnVuY3Rpb24gKFdvcmtzcGFjZUVkaXQpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hhbmdlcyAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5kb2N1bWVudENoYW5nZXMgIT09IHVuZGVmaW5lZCkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLmRvY3VtZW50Q2hhbmdlcy5ldmVyeSgoY2hhbmdlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKElzLnN0cmluZyhjaGFuZ2Uua2luZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIENyZWF0ZUZpbGUuaXMoY2hhbmdlKSB8fCBSZW5hbWVGaWxlLmlzKGNoYW5nZSkgfHwgRGVsZXRlRmlsZS5pcyhjaGFuZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFRleHREb2N1bWVudEVkaXQuaXMoY2hhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUVkaXQuaXMgPSBpcztcbn0pKFdvcmtzcGFjZUVkaXQgfHwgKFdvcmtzcGFjZUVkaXQgPSB7fSkpO1xuY2xhc3MgVGV4dEVkaXRDaGFuZ2VJbXBsIHtcbiAgICBjb25zdHJ1Y3RvcihlZGl0cywgY2hhbmdlQW5ub3RhdGlvbnMpIHtcbiAgICAgICAgdGhpcy5lZGl0cyA9IGVkaXRzO1xuICAgICAgICB0aGlzLmNoYW5nZUFubm90YXRpb25zID0gY2hhbmdlQW5ub3RhdGlvbnM7XG4gICAgfVxuICAgIGluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQuaW5zZXJ0KHBvc2l0aW9uLCBuZXdUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhhbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgaWQgPSBhbm5vdGF0aW9uO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0Lmluc2VydChwb3NpdGlvbiwgbmV3VGV4dCwgYW5ub3RhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFzc2VydENoYW5nZUFubm90YXRpb25zKHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMpO1xuICAgICAgICAgICAgaWQgPSB0aGlzLmNoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5pbnNlcnQocG9zaXRpb24sIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVwbGFjZShyYW5nZSwgbmV3VGV4dCwgYW5ub3RhdGlvbikge1xuICAgICAgICBsZXQgZWRpdDtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlZGl0ID0gVGV4dEVkaXQucmVwbGFjZShyYW5nZSwgbmV3VGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikpIHtcbiAgICAgICAgICAgIGlkID0gYW5ub3RhdGlvbjtcbiAgICAgICAgICAgIGVkaXQgPSBBbm5vdGF0ZWRUZXh0RWRpdC5yZXBsYWNlKHJhbmdlLCBuZXdUZXh0LCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LnJlcGxhY2UocmFuZ2UsIG5ld1RleHQsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlKHJhbmdlLCBhbm5vdGF0aW9uKSB7XG4gICAgICAgIGxldCBlZGl0O1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGVkaXQgPSBUZXh0RWRpdC5kZWwocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGFubm90YXRpb247XG4gICAgICAgICAgICBlZGl0ID0gQW5ub3RhdGVkVGV4dEVkaXQuZGVsKHJhbmdlLCBhbm5vdGF0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXNzZXJ0Q2hhbmdlQW5ub3RhdGlvbnModGhpcy5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICBpZCA9IHRoaXMuY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgZWRpdCA9IEFubm90YXRlZFRleHRFZGl0LmRlbChyYW5nZSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZWRpdHMucHVzaChlZGl0KTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhZGQoZWRpdCkge1xuICAgICAgICB0aGlzLmVkaXRzLnB1c2goZWRpdCk7XG4gICAgfVxuICAgIGFsbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdHM7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmVkaXRzLnNwbGljZSgwLCB0aGlzLmVkaXRzLmxlbmd0aCk7XG4gICAgfVxuICAgIGFzc2VydENoYW5nZUFubm90YXRpb25zKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRleHQgZWRpdCBjaGFuZ2UgaXMgbm90IGNvbmZpZ3VyZWQgdG8gbWFuYWdlIGNoYW5nZSBhbm5vdGF0aW9ucy5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQSBoZWxwZXIgY2xhc3NcbiAqL1xuY2xhc3MgQ2hhbmdlQW5ub3RhdGlvbnMge1xuICAgIGNvbnN0cnVjdG9yKGFubm90YXRpb25zKSB7XG4gICAgICAgIHRoaXMuX2Fubm90YXRpb25zID0gYW5ub3RhdGlvbnMgPT09IHVuZGVmaW5lZCA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiBhbm5vdGF0aW9ucztcbiAgICAgICAgdGhpcy5fY291bnRlciA9IDA7XG4gICAgICAgIHRoaXMuX3NpemUgPSAwO1xuICAgIH1cbiAgICBhbGwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hbm5vdGF0aW9ucztcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaXplO1xuICAgIH1cbiAgICBtYW5hZ2UoaWRPckFubm90YXRpb24sIGFubm90YXRpb24pIHtcbiAgICAgICAgbGV0IGlkO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoaWRPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBpZCA9IGlkT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWQgPSB0aGlzLm5leHRJZCgpO1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IGlkT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbm5vdGF0aW9uc1tpZF0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJZCAke2lkfSBpcyBhbHJlYWR5IGluIHVzZS5gKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYW5ub3RhdGlvbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIGFubm90YXRpb24gcHJvdmlkZWQgZm9yIGlkICR7aWR9YCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fYW5ub3RhdGlvbnNbaWRdID0gYW5ub3RhdGlvbjtcbiAgICAgICAgdGhpcy5fc2l6ZSsrO1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIG5leHRJZCgpIHtcbiAgICAgICAgdGhpcy5fY291bnRlcisrO1xuICAgICAgICByZXR1cm4gdGhpcy5fY291bnRlci50b1N0cmluZygpO1xuICAgIH1cbn1cbi8qKlxuICogQSB3b3Jrc3BhY2UgY2hhbmdlIGhlbHBzIGNvbnN0cnVjdGluZyBjaGFuZ2VzIHRvIGEgd29ya3NwYWNlLlxuICovXG5leHBvcnQgY2xhc3MgV29ya3NwYWNlQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3Jrc3BhY2VFZGl0KSB7XG4gICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGlmICh3b3Jrc3BhY2VFZGl0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQgPSB3b3Jrc3BhY2VFZGl0O1xuICAgICAgICAgICAgaWYgKHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMgPSBuZXcgQ2hhbmdlQW5ub3RhdGlvbnMod29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICAgICAgICAgIHdvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoVGV4dERvY3VtZW50RWRpdC5pcyhjaGFuZ2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0RWRpdENoYW5nZSA9IG5ldyBUZXh0RWRpdENoYW5nZUltcGwoY2hhbmdlLmVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNbY2hhbmdlLnRleHREb2N1bWVudC51cmldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykge1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKHdvcmtzcGFjZUVkaXQuY2hhbmdlcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHRFZGl0Q2hhbmdlID0gbmV3IFRleHRFZGl0Q2hhbmdlSW1wbCh3b3Jrc3BhY2VFZGl0LmNoYW5nZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3RleHRFZGl0Q2hhbmdlc1trZXldID0gdGV4dEVkaXRDaGFuZ2U7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0ID0ge307XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdW5kZXJseWluZyB7QGxpbmsgV29ya3NwYWNlRWRpdH0gbGl0ZXJhbFxuICAgICAqIHVzZSB0byBiZSByZXR1cm5lZCBmcm9tIGEgd29ya3NwYWNlIGVkaXQgb3BlcmF0aW9uIGxpa2UgcmVuYW1lLlxuICAgICAqL1xuICAgIGdldCBlZGl0KCkge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX2NoYW5nZUFubm90YXRpb25zICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuY2hhbmdlQW5ub3RhdGlvbnMgPSB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucy5hbGwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fd29ya3NwYWNlRWRpdDtcbiAgICB9XG4gICAgZ2V0VGV4dEVkaXRDaGFuZ2Uoa2V5KSB7XG4gICAgICAgIGlmIChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIuaXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXh0RG9jdW1lbnQgPSB7IHVyaToga2V5LnVyaSwgdmVyc2lvbjoga2V5LnZlcnNpb24gfTtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNbdGV4dERvY3VtZW50LnVyaV07XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgY29uc3QgdGV4dERvY3VtZW50RWRpdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dERvY3VtZW50LFxuICAgICAgICAgICAgICAgICAgICBlZGl0c1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaCh0ZXh0RG9jdW1lbnRFZGl0KTtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzLCB0aGlzLl9jaGFuZ2VBbm5vdGF0aW9ucyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGV4dEVkaXRDaGFuZ2VzW3RleHREb2N1bWVudC51cmldID0gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaW5pdENoYW5nZXMoKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIG5vcm1hbCB0ZXh0IGVkaXQgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XTtcbiAgICAgICAgICAgIGlmICghcmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGVkaXRzID0gW107XG4gICAgICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzW2tleV0gPSBlZGl0cztcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgVGV4dEVkaXRDaGFuZ2VJbXBsKGVkaXRzKTtcbiAgICAgICAgICAgICAgICB0aGlzLl90ZXh0RWRpdENoYW5nZXNba2V5XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdERvY3VtZW50Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQgJiYgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoYW5nZUFubm90YXRpb25zID0gbmV3IENoYW5nZUFubm90YXRpb25zKCk7XG4gICAgICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VBbm5vdGF0aW9ucyA9IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLmFsbCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRDaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMgPT09IHVuZGVmaW5lZCAmJiB0aGlzLl93b3Jrc3BhY2VFZGl0LmNoYW5nZXMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5jaGFuZ2VzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVGaWxlKHVyaSwgb3B0aW9uc09yQW5ub3RhdGlvbiwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLmluaXREb2N1bWVudENoYW5nZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV29ya3NwYWNlIGVkaXQgaXMgbm90IGNvbmZpZ3VyZWQgZm9yIGRvY3VtZW50IGNoYW5nZXMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGFubm90YXRpb247XG4gICAgICAgIGlmIChDaGFuZ2VBbm5vdGF0aW9uLmlzKG9wdGlvbnNPckFubm90YXRpb24pIHx8IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKG9wdGlvbnNPckFubm90YXRpb24pKSB7XG4gICAgICAgICAgICBhbm5vdGF0aW9uID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zT3JBbm5vdGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGxldCBvcGVyYXRpb247XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgaWYgKGFubm90YXRpb24gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gQ3JlYXRlRmlsZS5jcmVhdGUodXJpLCBvcHRpb25zLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fd29ya3NwYWNlRWRpdC5kb2N1bWVudENoYW5nZXMucHVzaChvcGVyYXRpb24pO1xuICAgICAgICBpZiAoaWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlbmFtZUZpbGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IFJlbmFtZUZpbGUuY3JlYXRlKG9sZFVyaSwgbmV3VXJpLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlkID0gQ2hhbmdlQW5ub3RhdGlvbklkZW50aWZpZXIuaXMoYW5ub3RhdGlvbikgPyBhbm5vdGF0aW9uIDogdGhpcy5fY2hhbmdlQW5ub3RhdGlvbnMubWFuYWdlKGFubm90YXRpb24pO1xuICAgICAgICAgICAgb3BlcmF0aW9uID0gUmVuYW1lRmlsZS5jcmVhdGUob2xkVXJpLCBuZXdVcmksIG9wdGlvbnMsIGlkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcy5wdXNoKG9wZXJhdGlvbik7XG4gICAgICAgIGlmIChpZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVsZXRlRmlsZSh1cmksIG9wdGlvbnNPckFubm90YXRpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5pbml0RG9jdW1lbnRDaGFuZ2VzKCk7XG4gICAgICAgIGlmICh0aGlzLl93b3Jrc3BhY2VFZGl0LmRvY3VtZW50Q2hhbmdlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dvcmtzcGFjZSBlZGl0IGlzIG5vdCBjb25maWd1cmVkIGZvciBkb2N1bWVudCBjaGFuZ2VzLicpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm5vdGF0aW9uO1xuICAgICAgICBpZiAoQ2hhbmdlQW5ub3RhdGlvbi5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSB8fCBDaGFuZ2VBbm5vdGF0aW9uSWRlbnRpZmllci5pcyhvcHRpb25zT3JBbm5vdGF0aW9uKSkge1xuICAgICAgICAgICAgYW5ub3RhdGlvbiA9IG9wdGlvbnNPckFubm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zID0gb3B0aW9uc09yQW5ub3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3BlcmF0aW9uO1xuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIGlmIChhbm5vdGF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZCA9IENoYW5nZUFubm90YXRpb25JZGVudGlmaWVyLmlzKGFubm90YXRpb24pID8gYW5ub3RhdGlvbiA6IHRoaXMuX2NoYW5nZUFubm90YXRpb25zLm1hbmFnZShhbm5vdGF0aW9uKTtcbiAgICAgICAgICAgIG9wZXJhdGlvbiA9IERlbGV0ZUZpbGUuY3JlYXRlKHVyaSwgb3B0aW9ucywgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3dvcmtzcGFjZUVkaXQuZG9jdW1lbnRDaGFuZ2VzLnB1c2gob3BlcmF0aW9uKTtcbiAgICAgICAgaWYgKGlkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBpZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogVGhlIFRleHREb2N1bWVudElkZW50aWZpZXIgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoVGV4dERvY3VtZW50SWRlbnRpZmllcikge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgVGV4dERvY3VtZW50SWRlbnRpZmllciBsaXRlcmFsLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIGRvY3VtZW50J3MgdXJpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmkpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpIH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SWRlbnRpZmllcn0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudElkZW50aWZpZXIuaXMgPSBpcztcbn0pKFRleHREb2N1bWVudElkZW50aWZpZXIgfHwgKFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyO1xuKGZ1bmN0aW9uIChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUodXJpLCB2ZXJzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHVyaSwgdmVyc2lvbiB9O1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIElzLmludGVnZXIoY2FuZGlkYXRlLnZlcnNpb24pO1xuICAgIH1cbiAgICBWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyLmlzID0gaXM7XG59KShWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyID0ge30pKTtcbi8qKlxuICogVGhlIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllciBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllcjtcbihmdW5jdGlvbiAoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgbGl0ZXJhbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSBkb2N1bWVudCdzIHVyaS5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIHZlcnNpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCB2ZXJzaW9uIH07XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXJ9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS51cmkpICYmIChjYW5kaWRhdGUudmVyc2lvbiA9PT0gbnVsbCB8fCBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSk7XG4gICAgfVxuICAgIE9wdGlvbmFsVmVyc2lvbmVkVGV4dERvY3VtZW50SWRlbnRpZmllci5pcyA9IGlzO1xufSkoT3B0aW9uYWxWZXJzaW9uZWRUZXh0RG9jdW1lbnRJZGVudGlmaWVyIHx8IChPcHRpb25hbFZlcnNpb25lZFRleHREb2N1bWVudElkZW50aWZpZXIgPSB7fSkpO1xuLyoqXG4gKiBUaGUgVGV4dERvY3VtZW50SXRlbSBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBUZXh0RG9jdW1lbnRJdGVtfSBsaXRlcmFscy5cbiAqL1xuZXhwb3J0IHZhciBUZXh0RG9jdW1lbnRJdGVtO1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnRJdGVtKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBUZXh0RG9jdW1lbnRJdGVtIGxpdGVyYWwuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgaWRlbnRpZmllci5cbiAgICAgKiBAcGFyYW0gdmVyc2lvbiBUaGUgZG9jdW1lbnQncyB2ZXJzaW9uIG51bWJlci5cbiAgICAgKiBAcGFyYW0gdGV4dCBUaGUgZG9jdW1lbnQncyB0ZXh0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgdXJpLCBsYW5ndWFnZUlkLCB2ZXJzaW9uLCB0ZXh0IH07XG4gICAgfVxuICAgIFRleHREb2N1bWVudEl0ZW0uY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgVGV4dERvY3VtZW50SXRlbX0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnVyaSkgJiYgSXMuc3RyaW5nKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSAmJiBJcy5pbnRlZ2VyKGNhbmRpZGF0ZS52ZXJzaW9uKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnRJdGVtLmlzID0gaXM7XG59KShUZXh0RG9jdW1lbnRJdGVtIHx8IChUZXh0RG9jdW1lbnRJdGVtID0ge30pKTtcbi8qKlxuICogRGVzY3JpYmVzIHRoZSBjb250ZW50IHR5cGUgdGhhdCBhIGNsaWVudCBzdXBwb3J0cyBpbiB2YXJpb3VzXG4gKiByZXN1bHQgbGl0ZXJhbHMgbGlrZSBgSG92ZXJgLCBgUGFyYW1ldGVySW5mb2Agb3IgYENvbXBsZXRpb25JdGVtYC5cbiAqXG4gKiBQbGVhc2Ugbm90ZSB0aGF0IGBNYXJrdXBLaW5kc2AgbXVzdCBub3Qgc3RhcnQgd2l0aCBhIGAkYC4gVGhpcyBraW5kc1xuICogYXJlIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2FnZS5cbiAqL1xuZXhwb3J0IHZhciBNYXJrdXBLaW5kO1xuKGZ1bmN0aW9uIChNYXJrdXBLaW5kKSB7XG4gICAgLyoqXG4gICAgICogUGxhaW4gdGV4dCBpcyBzdXBwb3J0ZWQgYXMgYSBjb250ZW50IGZvcm1hdFxuICAgICAqL1xuICAgIE1hcmt1cEtpbmQuUGxhaW5UZXh0ID0gJ3BsYWludGV4dCc7XG4gICAgLyoqXG4gICAgICogTWFya2Rvd24gaXMgc3VwcG9ydGVkIGFzIGEgY29udGVudCBmb3JtYXRcbiAgICAgKi9cbiAgICBNYXJrdXBLaW5kLk1hcmtkb3duID0gJ21hcmtkb3duJztcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSB2YWx1ZSBvZiB0aGUge0BsaW5rIE1hcmt1cEtpbmR9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgPT09IE1hcmt1cEtpbmQuUGxhaW5UZXh0IHx8IGNhbmRpZGF0ZSA9PT0gTWFya3VwS2luZC5NYXJrZG93bjtcbiAgICB9XG4gICAgTWFya3VwS2luZC5pcyA9IGlzO1xufSkoTWFya3VwS2luZCB8fCAoTWFya3VwS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIE1hcmt1cENvbnRlbnQ7XG4oZnVuY3Rpb24gKE1hcmt1cENvbnRlbnQpIHtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrdXBDb250ZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKHZhbHVlKSAmJiBNYXJrdXBLaW5kLmlzKGNhbmRpZGF0ZS5raW5kKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnZhbHVlKTtcbiAgICB9XG4gICAgTWFya3VwQ29udGVudC5pcyA9IGlzO1xufSkoTWFya3VwQ29udGVudCB8fCAoTWFya3VwQ29udGVudCA9IHt9KSk7XG4vKipcbiAqIFRoZSBraW5kIG9mIGEgY29tcGxldGlvbiBlbnRyeS5cbiAqL1xuZXhwb3J0IHZhciBDb21wbGV0aW9uSXRlbUtpbmQ7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtS2luZCkge1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5UZXh0ID0gMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuTWV0aG9kID0gMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRnVuY3Rpb24gPSAzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5Db25zdHJ1Y3RvciA9IDQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkZpZWxkID0gNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFyaWFibGUgPSA2O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5DbGFzcyA9IDc7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkludGVyZmFjZSA9IDg7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk1vZHVsZSA9IDk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlByb3BlcnR5ID0gMTA7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlVuaXQgPSAxMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuVmFsdWUgPSAxMjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRW51bSA9IDEzO1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5LZXl3b3JkID0gMTQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlNuaXBwZXQgPSAxNTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29sb3IgPSAxNjtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRmlsZSA9IDE3O1xuICAgIENvbXBsZXRpb25JdGVtS2luZC5SZWZlcmVuY2UgPSAxODtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuRm9sZGVyID0gMTk7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkVudW1NZW1iZXIgPSAyMDtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuQ29uc3RhbnQgPSAyMTtcbiAgICBDb21wbGV0aW9uSXRlbUtpbmQuU3RydWN0ID0gMjI7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLkV2ZW50ID0gMjM7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLk9wZXJhdG9yID0gMjQ7XG4gICAgQ29tcGxldGlvbkl0ZW1LaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNTtcbn0pKENvbXBsZXRpb25JdGVtS2luZCB8fCAoQ29tcGxldGlvbkl0ZW1LaW5kID0ge30pKTtcbi8qKlxuICogRGVmaW5lcyB3aGV0aGVyIHRoZSBpbnNlcnQgdGV4dCBpbiBhIGNvbXBsZXRpb24gaXRlbSBzaG91bGQgYmUgaW50ZXJwcmV0ZWQgYXNcbiAqIHBsYWluIHRleHQgb3IgYSBzbmlwcGV0LlxuICovXG5leHBvcnQgdmFyIEluc2VydFRleHRGb3JtYXQ7XG4oZnVuY3Rpb24gKEluc2VydFRleHRGb3JtYXQpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgcHJpbWFyeSB0ZXh0IHRvIGJlIGluc2VydGVkIGlzIHRyZWF0ZWQgYXMgYSBwbGFpbiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dEZvcm1hdC5QbGFpblRleHQgPSAxO1xuICAgIC8qKlxuICAgICAqIFRoZSBwcmltYXJ5IHRleHQgdG8gYmUgaW5zZXJ0ZWQgaXMgdHJlYXRlZCBhcyBhIHNuaXBwZXQuXG4gICAgICpcbiAgICAgKiBBIHNuaXBwZXQgY2FuIGRlZmluZSB0YWIgc3RvcHMgYW5kIHBsYWNlaG9sZGVycyB3aXRoIGAkMWAsIGAkMmBcbiAgICAgKiBhbmQgYCR7Mzpmb299YC4gYCQwYCBkZWZpbmVzIHRoZSBmaW5hbCB0YWIgc3RvcCwgaXQgZGVmYXVsdHMgdG9cbiAgICAgKiB0aGUgZW5kIG9mIHRoZSBzbmlwcGV0LiBQbGFjZWhvbGRlcnMgd2l0aCBlcXVhbCBpZGVudGlmaWVycyBhcmUgbGlua2VkLFxuICAgICAqIHRoYXQgaXMgdHlwaW5nIGluIG9uZSB3aWxsIHVwZGF0ZSBvdGhlcnMgdG9vLlxuICAgICAqXG4gICAgICogU2VlIGFsc286IGh0dHBzOi8vbWljcm9zb2Z0LmdpdGh1Yi5pby9sYW5ndWFnZS1zZXJ2ZXItcHJvdG9jb2wvc3BlY2lmaWNhdGlvbnMvc3BlY2lmaWNhdGlvbi1jdXJyZW50LyNzbmlwcGV0X3N5bnRheFxuICAgICAqL1xuICAgIEluc2VydFRleHRGb3JtYXQuU25pcHBldCA9IDI7XG59KShJbnNlcnRUZXh0Rm9ybWF0IHx8IChJbnNlcnRUZXh0Rm9ybWF0ID0ge30pKTtcbi8qKlxuICogQ29tcGxldGlvbiBpdGVtIHRhZ3MgYXJlIGV4dHJhIGFubm90YXRpb25zIHRoYXQgdHdlYWsgdGhlIHJlbmRlcmluZyBvZiBhIGNvbXBsZXRpb25cbiAqIGl0ZW0uXG4gKlxuICogQHNpbmNlIDMuMTUuMFxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtVGFnO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbVRhZykge1xuICAgIC8qKlxuICAgICAqIFJlbmRlciBhIGNvbXBsZXRpb24gYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIENvbXBsZXRpb25JdGVtVGFnLkRlcHJlY2F0ZWQgPSAxO1xufSkoQ29tcGxldGlvbkl0ZW1UYWcgfHwgKENvbXBsZXRpb25JdGVtVGFnID0ge30pKTtcbi8qKlxuICogVGhlIEluc2VydFJlcGxhY2VFZGl0IG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIGluc2VydCAvIHJlcGxhY2UgZWRpdHMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIEluc2VydFJlcGxhY2VFZGl0O1xuKGZ1bmN0aW9uIChJbnNlcnRSZXBsYWNlRWRpdCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zZXJ0IC8gcmVwbGFjZSBlZGl0XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5ld1RleHQsIGluc2VydCwgcmVwbGFjZSkge1xuICAgICAgICByZXR1cm4geyBuZXdUZXh0LCBpbnNlcnQsIHJlcGxhY2UgfTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuY3JlYXRlID0gY3JlYXRlO1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBsaXRlcmFsIGNvbmZvcm1zIHRvIHRoZSB7QGxpbmsgSW5zZXJ0UmVwbGFjZUVkaXR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLm5ld1RleHQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5pbnNlcnQpICYmIFJhbmdlLmlzKGNhbmRpZGF0ZS5yZXBsYWNlKTtcbiAgICB9XG4gICAgSW5zZXJ0UmVwbGFjZUVkaXQuaXMgPSBpcztcbn0pKEluc2VydFJlcGxhY2VFZGl0IHx8IChJbnNlcnRSZXBsYWNlRWRpdCA9IHt9KSk7XG4vKipcbiAqIEhvdyB3aGl0ZXNwYWNlIGFuZCBpbmRlbnRhdGlvbiBpcyBoYW5kbGVkIGR1cmluZyBjb21wbGV0aW9uXG4gKiBpdGVtIGluc2VydGlvbi5cbiAqXG4gKiBAc2luY2UgMy4xNi4wXG4gKi9cbmV4cG9ydCB2YXIgSW5zZXJ0VGV4dE1vZGU7XG4oZnVuY3Rpb24gKEluc2VydFRleHRNb2RlKSB7XG4gICAgLyoqXG4gICAgICogVGhlIGluc2VydGlvbiBvciByZXBsYWNlIHN0cmluZ3MgaXMgdGFrZW4gYXMgaXQgaXMuIElmIHRoZVxuICAgICAqIHZhbHVlIGlzIG11bHRpIGxpbmUgdGhlIGxpbmVzIGJlbG93IHRoZSBjdXJzb3Igd2lsbCBiZVxuICAgICAqIGluc2VydGVkIHVzaW5nIHRoZSBpbmRlbnRhdGlvbiBkZWZpbmVkIGluIHRoZSBzdHJpbmcgdmFsdWUuXG4gICAgICogVGhlIGNsaWVudCB3aWxsIG5vdCBhcHBseSBhbnkga2luZCBvZiBhZGp1c3RtZW50cyB0byB0aGVcbiAgICAgKiBzdHJpbmcuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYXNJcyA9IDE7XG4gICAgLyoqXG4gICAgICogVGhlIGVkaXRvciBhZGp1c3RzIGxlYWRpbmcgd2hpdGVzcGFjZSBvZiBuZXcgbGluZXMgc28gdGhhdFxuICAgICAqIHRoZXkgbWF0Y2ggdGhlIGluZGVudGF0aW9uIHVwIHRvIHRoZSBjdXJzb3Igb2YgdGhlIGxpbmUgZm9yXG4gICAgICogd2hpY2ggdGhlIGl0ZW0gaXMgYWNjZXB0ZWQuXG4gICAgICpcbiAgICAgKiBDb25zaWRlciBhIGxpbmUgbGlrZSB0aGlzOiA8MnRhYnM+PGN1cnNvcj48M3RhYnM+Zm9vLiBBY2NlcHRpbmcgYVxuICAgICAqIG11bHRpIGxpbmUgY29tcGxldGlvbiBpdGVtIGlzIGluZGVudGVkIHVzaW5nIDIgdGFicyBhbmQgYWxsXG4gICAgICogZm9sbG93aW5nIGxpbmVzIGluc2VydGVkIHdpbGwgYmUgaW5kZW50ZWQgdXNpbmcgMiB0YWJzIGFzIHdlbGwuXG4gICAgICovXG4gICAgSW5zZXJ0VGV4dE1vZGUuYWRqdXN0SW5kZW50YXRpb24gPSAyO1xufSkoSW5zZXJ0VGV4dE1vZGUgfHwgKEluc2VydFRleHRNb2RlID0ge30pKTtcbmV4cG9ydCB2YXIgQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHM7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUuZGV0YWlsKSB8fCBjYW5kaWRhdGUuZGV0YWlsID09PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5kZXNjcmlwdGlvbikgfHwgY2FuZGlkYXRlLmRlc2NyaXB0aW9uID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbUxhYmVsRGV0YWlscy5pcyA9IGlzO1xufSkoQ29tcGxldGlvbkl0ZW1MYWJlbERldGFpbHMgfHwgKENvbXBsZXRpb25JdGVtTGFiZWxEZXRhaWxzID0ge30pKTtcbi8qKlxuICogVGhlIENvbXBsZXRpb25JdGVtIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoXG4gKiBjb21wbGV0aW9uIGl0ZW1zLlxuICovXG5leHBvcnQgdmFyIENvbXBsZXRpb25JdGVtO1xuKGZ1bmN0aW9uIChDb21wbGV0aW9uSXRlbSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGNvbXBsZXRpb24gaXRlbSBhbmQgc2VlZCBpdCB3aXRoIGEgbGFiZWwuXG4gICAgICogQHBhcmFtIGxhYmVsIFRoZSBjb21wbGV0aW9uIGl0ZW0ncyBsYWJlbFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCkge1xuICAgICAgICByZXR1cm4geyBsYWJlbCB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uSXRlbS5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uSXRlbSB8fCAoQ29tcGxldGlvbkl0ZW0gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29tcGxldGlvbkxpc3QgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGhcbiAqIGNvbXBsZXRpb24gbGlzdHMuXG4gKi9cbmV4cG9ydCB2YXIgQ29tcGxldGlvbkxpc3Q7XG4oZnVuY3Rpb24gKENvbXBsZXRpb25MaXN0KSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb21wbGV0aW9uIGxpc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaXRlbXMgVGhlIGNvbXBsZXRpb24gaXRlbXMuXG4gICAgICogQHBhcmFtIGlzSW5jb21wbGV0ZSBUaGUgbGlzdCBpcyBub3QgY29tcGxldGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGl0ZW1zLCBpc0luY29tcGxldGUpIHtcbiAgICAgICAgcmV0dXJuIHsgaXRlbXM6IGl0ZW1zID8gaXRlbXMgOiBbXSwgaXNJbmNvbXBsZXRlOiAhIWlzSW5jb21wbGV0ZSB9O1xuICAgIH1cbiAgICBDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShDb21wbGV0aW9uTGlzdCB8fCAoQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuZXhwb3J0IHZhciBNYXJrZWRTdHJpbmc7XG4oZnVuY3Rpb24gKE1hcmtlZFN0cmluZykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXJrZWQgc3RyaW5nIGZyb20gcGxhaW4gdGV4dC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwbGFpblRleHQgVGhlIHBsYWluIHRleHQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnJvbVBsYWluVGV4dChwbGFpblRleHQpIHtcbiAgICAgICAgcmV0dXJuIHBsYWluVGV4dC5yZXBsYWNlKC9bXFxcXGAqX3t9W1xcXSgpIytcXC0uIV0vZywgJ1xcXFwkJicpOyAvLyBlc2NhcGUgbWFya2Rvd24gc3ludGF4IHRva2VuczogaHR0cDovL2RhcmluZ2ZpcmViYWxsLm5ldC9wcm9qZWN0cy9tYXJrZG93bi9zeW50YXgjYmFja3NsYXNoXG4gICAgfVxuICAgIE1hcmtlZFN0cmluZy5mcm9tUGxhaW5UZXh0ID0gZnJvbVBsYWluVGV4dDtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgY29uZm9ybXMgdG8gdGhlIHtAbGluayBNYXJrZWRTdHJpbmd9IHR5cGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5zdHJpbmcoY2FuZGlkYXRlKSB8fCAoSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubGFuZ3VhZ2UpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudmFsdWUpKTtcbiAgICB9XG4gICAgTWFya2VkU3RyaW5nLmlzID0gaXM7XG59KShNYXJrZWRTdHJpbmcgfHwgKE1hcmtlZFN0cmluZyA9IHt9KSk7XG5leHBvcnQgdmFyIEhvdmVyO1xuKGZ1bmN0aW9uIChIb3Zlcikge1xuICAgIC8qKlxuICAgICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBjb25mb3JtcyB0byB0aGUge0BsaW5rIEhvdmVyfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gISFjYW5kaWRhdGUgJiYgSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpICYmIChNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS5jb250ZW50cykgfHxcbiAgICAgICAgICAgIE1hcmtlZFN0cmluZy5pcyhjYW5kaWRhdGUuY29udGVudHMpIHx8XG4gICAgICAgICAgICBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5jb250ZW50cywgTWFya2VkU3RyaW5nLmlzKSkgJiYgKHZhbHVlLnJhbmdlID09PSB1bmRlZmluZWQgfHwgUmFuZ2UuaXModmFsdWUucmFuZ2UpKTtcbiAgICB9XG4gICAgSG92ZXIuaXMgPSBpcztcbn0pKEhvdmVyIHx8IChIb3ZlciA9IHt9KSk7XG4vKipcbiAqIFRoZSBQYXJhbWV0ZXJJbmZvcm1hdGlvbiBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBQYXJhbWV0ZXJJbmZvcm1hdGlvbn0gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgUGFyYW1ldGVySW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFBhcmFtZXRlckluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBwYXJhbWV0ZXIgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYWJlbCBBIGxhYmVsIHN0cmluZy5cbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRhdGlvbiBBIGRvYyBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKGxhYmVsLCBkb2N1bWVudGF0aW9uKSB7XG4gICAgICAgIHJldHVybiBkb2N1bWVudGF0aW9uID8geyBsYWJlbCwgZG9jdW1lbnRhdGlvbiB9IDogeyBsYWJlbCB9O1xuICAgIH1cbiAgICBQYXJhbWV0ZXJJbmZvcm1hdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG59KShQYXJhbWV0ZXJJbmZvcm1hdGlvbiB8fCAoUGFyYW1ldGVySW5mb3JtYXRpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2lnbmF0dXJlSW5mb3JtYXRpb24gbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgU2lnbmF0dXJlSW5mb3JtYXRpb259IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFNpZ25hdHVyZUluZm9ybWF0aW9uO1xuKGZ1bmN0aW9uIChTaWduYXR1cmVJbmZvcm1hdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShsYWJlbCwgZG9jdW1lbnRhdGlvbiwgLi4ucGFyYW1ldGVycykge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyBsYWJlbCB9O1xuICAgICAgICBpZiAoSXMuZGVmaW5lZChkb2N1bWVudGF0aW9uKSkge1xuICAgICAgICAgICAgcmVzdWx0LmRvY3VtZW50YXRpb24gPSBkb2N1bWVudGF0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChJcy5kZWZpbmVkKHBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucGFyYW1ldGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFNpZ25hdHVyZUluZm9ybWF0aW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKFNpZ25hdHVyZUluZm9ybWF0aW9uIHx8IChTaWduYXR1cmVJbmZvcm1hdGlvbiA9IHt9KSk7XG4vKipcbiAqIEEgZG9jdW1lbnQgaGlnaGxpZ2h0IGtpbmQuXG4gKi9cbmV4cG9ydCB2YXIgRG9jdW1lbnRIaWdobGlnaHRLaW5kO1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodEtpbmQpIHtcbiAgICAvKipcbiAgICAgKiBBIHRleHR1YWwgb2NjdXJyZW5jZS5cbiAgICAgKi9cbiAgICBEb2N1bWVudEhpZ2hsaWdodEtpbmQuVGV4dCA9IDE7XG4gICAgLyoqXG4gICAgICogUmVhZC1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2UgcmVhZGluZyBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5SZWFkID0gMjtcbiAgICAvKipcbiAgICAgKiBXcml0ZS1hY2Nlc3Mgb2YgYSBzeW1ib2wsIGxpa2Ugd3JpdGluZyB0byBhIHZhcmlhYmxlLlxuICAgICAqL1xuICAgIERvY3VtZW50SGlnaGxpZ2h0S2luZC5Xcml0ZSA9IDM7XG59KShEb2N1bWVudEhpZ2hsaWdodEtpbmQgfHwgKERvY3VtZW50SGlnaGxpZ2h0S2luZCA9IHt9KSk7XG4vKipcbiAqIERvY3VtZW50SGlnaGxpZ2h0IG5hbWVzcGFjZSB0byBwcm92aWRlIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgRG9jdW1lbnRIaWdobGlnaHR9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50SGlnaGxpZ2h0O1xuKGZ1bmN0aW9uIChEb2N1bWVudEhpZ2hsaWdodCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERvY3VtZW50SGlnaGxpZ2h0IG9iamVjdC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIHRoZSBoaWdobGlnaHQgYXBwbGllcyB0by5cbiAgICAgKiBAcGFyYW0ga2luZCBUaGUgaGlnaGxpZ2h0IGtpbmRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGtpbmQpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLm51bWJlcihraW5kKSkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50SGlnaGxpZ2h0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKERvY3VtZW50SGlnaGxpZ2h0IHx8IChEb2N1bWVudEhpZ2hsaWdodCA9IHt9KSk7XG4vKipcbiAqIEEgc3ltYm9sIGtpbmQuXG4gKi9cbmV4cG9ydCB2YXIgU3ltYm9sS2luZDtcbihmdW5jdGlvbiAoU3ltYm9sS2luZCkge1xuICAgIFN5bWJvbEtpbmQuRmlsZSA9IDE7XG4gICAgU3ltYm9sS2luZC5Nb2R1bGUgPSAyO1xuICAgIFN5bWJvbEtpbmQuTmFtZXNwYWNlID0gMztcbiAgICBTeW1ib2xLaW5kLlBhY2thZ2UgPSA0O1xuICAgIFN5bWJvbEtpbmQuQ2xhc3MgPSA1O1xuICAgIFN5bWJvbEtpbmQuTWV0aG9kID0gNjtcbiAgICBTeW1ib2xLaW5kLlByb3BlcnR5ID0gNztcbiAgICBTeW1ib2xLaW5kLkZpZWxkID0gODtcbiAgICBTeW1ib2xLaW5kLkNvbnN0cnVjdG9yID0gOTtcbiAgICBTeW1ib2xLaW5kLkVudW0gPSAxMDtcbiAgICBTeW1ib2xLaW5kLkludGVyZmFjZSA9IDExO1xuICAgIFN5bWJvbEtpbmQuRnVuY3Rpb24gPSAxMjtcbiAgICBTeW1ib2xLaW5kLlZhcmlhYmxlID0gMTM7XG4gICAgU3ltYm9sS2luZC5Db25zdGFudCA9IDE0O1xuICAgIFN5bWJvbEtpbmQuU3RyaW5nID0gMTU7XG4gICAgU3ltYm9sS2luZC5OdW1iZXIgPSAxNjtcbiAgICBTeW1ib2xLaW5kLkJvb2xlYW4gPSAxNztcbiAgICBTeW1ib2xLaW5kLkFycmF5ID0gMTg7XG4gICAgU3ltYm9sS2luZC5PYmplY3QgPSAxOTtcbiAgICBTeW1ib2xLaW5kLktleSA9IDIwO1xuICAgIFN5bWJvbEtpbmQuTnVsbCA9IDIxO1xuICAgIFN5bWJvbEtpbmQuRW51bU1lbWJlciA9IDIyO1xuICAgIFN5bWJvbEtpbmQuU3RydWN0ID0gMjM7XG4gICAgU3ltYm9sS2luZC5FdmVudCA9IDI0O1xuICAgIFN5bWJvbEtpbmQuT3BlcmF0b3IgPSAyNTtcbiAgICBTeW1ib2xLaW5kLlR5cGVQYXJhbWV0ZXIgPSAyNjtcbn0pKFN5bWJvbEtpbmQgfHwgKFN5bWJvbEtpbmQgPSB7fSkpO1xuLyoqXG4gKiBTeW1ib2wgdGFncyBhcmUgZXh0cmEgYW5ub3RhdGlvbnMgdGhhdCB0d2VhayB0aGUgcmVuZGVyaW5nIG9mIGEgc3ltYm9sLlxuICpcbiAqIEBzaW5jZSAzLjE2XG4gKi9cbmV4cG9ydCB2YXIgU3ltYm9sVGFnO1xuKGZ1bmN0aW9uIChTeW1ib2xUYWcpIHtcbiAgICAvKipcbiAgICAgKiBSZW5kZXIgYSBzeW1ib2wgYXMgb2Jzb2xldGUsIHVzdWFsbHkgdXNpbmcgYSBzdHJpa2Utb3V0LlxuICAgICAqL1xuICAgIFN5bWJvbFRhZy5EZXByZWNhdGVkID0gMTtcbn0pKFN5bWJvbFRhZyB8fCAoU3ltYm9sVGFnID0ge30pKTtcbmV4cG9ydCB2YXIgU3ltYm9sSW5mb3JtYXRpb247XG4oZnVuY3Rpb24gKFN5bWJvbEluZm9ybWF0aW9uKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBzeW1ib2wgaW5mb3JtYXRpb24gbGl0ZXJhbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgVGhlIHJhbmdlIG9mIHRoZSBsb2NhdGlvbiBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSB1cmkgVGhlIHJlc291cmNlIG9mIHRoZSBsb2NhdGlvbiBvZiBzeW1ib2wuXG4gICAgICogQHBhcmFtIGNvbnRhaW5lck5hbWUgVGhlIG5hbWUgb2YgdGhlIHN5bWJvbCBjb250YWluaW5nIHRoZSBzeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHJhbmdlLCB1cmksIGNvbnRhaW5lck5hbWUpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgbG9jYXRpb246IHsgdXJpLCByYW5nZSB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChjb250YWluZXJOYW1lKSB7XG4gICAgICAgICAgICByZXN1bHQuY29udGFpbmVyTmFtZSA9IGNvbnRhaW5lck5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgU3ltYm9sSW5mb3JtYXRpb24uY3JlYXRlID0gY3JlYXRlO1xufSkoU3ltYm9sSW5mb3JtYXRpb24gfHwgKFN5bWJvbEluZm9ybWF0aW9uID0ge30pKTtcbmV4cG9ydCB2YXIgV29ya3NwYWNlU3ltYm9sO1xuKGZ1bmN0aW9uIChXb3Jrc3BhY2VTeW1ib2wpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgd29ya3NwYWNlIHN5bWJvbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIFRoZSBuYW1lIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIGtpbmQgVGhlIGtpbmQgb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gdXJpIFRoZSByZXNvdXJjZSBvZiB0aGUgbG9jYXRpb24gb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gcmFuZ2UgQW4gb3B0aW9ucyByYW5nZSBvZiB0aGUgbG9jYXRpb24uXG4gICAgICogQHJldHVybnMgQSBXb3Jrc3BhY2VTeW1ib2wuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKG5hbWUsIGtpbmQsIHVyaSwgcmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIHJhbmdlICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8geyBuYW1lLCBraW5kLCBsb2NhdGlvbjogeyB1cmksIHJhbmdlIH0gfVxuICAgICAgICAgICAgOiB7IG5hbWUsIGtpbmQsIGxvY2F0aW9uOiB7IHVyaSB9IH07XG4gICAgfVxuICAgIFdvcmtzcGFjZVN5bWJvbC5jcmVhdGUgPSBjcmVhdGU7XG59KShXb3Jrc3BhY2VTeW1ib2wgfHwgKFdvcmtzcGFjZVN5bWJvbCA9IHt9KSk7XG5leHBvcnQgdmFyIERvY3VtZW50U3ltYm9sO1xuKGZ1bmN0aW9uIChEb2N1bWVudFN5bWJvbCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgc3ltYm9sIGluZm9ybWF0aW9uIGxpdGVyYWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSBUaGUgbmFtZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBkZXRhaWwgVGhlIGRldGFpbCBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBraW5kIFRoZSBraW5kIG9mIHRoZSBzeW1ib2wuXG4gICAgICogQHBhcmFtIHJhbmdlIFRoZSByYW5nZSBvZiB0aGUgc3ltYm9sLlxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb25SYW5nZSBUaGUgc2VsZWN0aW9uUmFuZ2Ugb2YgdGhlIHN5bWJvbC5cbiAgICAgKiBAcGFyYW0gY2hpbGRyZW4gQ2hpbGRyZW4gb2YgdGhlIHN5bWJvbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUobmFtZSwgZGV0YWlsLCBraW5kLCByYW5nZSwgc2VsZWN0aW9uUmFuZ2UsIGNoaWxkcmVuKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgZGV0YWlsLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIHJhbmdlLFxuICAgICAgICAgICAgc2VsZWN0aW9uUmFuZ2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJlc3VsdC5jaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIERvY3VtZW50U3ltYm9sfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmXG4gICAgICAgICAgICBJcy5zdHJpbmcoY2FuZGlkYXRlLm5hbWUpICYmIElzLm51bWJlcihjYW5kaWRhdGUua2luZCkgJiZcbiAgICAgICAgICAgIFJhbmdlLmlzKGNhbmRpZGF0ZS5yYW5nZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnNlbGVjdGlvblJhbmdlKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5kZXRhaWwgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmRldGFpbCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRlcHJlY2F0ZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5kZXByZWNhdGVkKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuY2hpbGRyZW4gPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5jaGlsZHJlbikpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLnRhZ3MgPT09IHVuZGVmaW5lZCB8fCBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS50YWdzKSk7XG4gICAgfVxuICAgIERvY3VtZW50U3ltYm9sLmlzID0gaXM7XG59KShEb2N1bWVudFN5bWJvbCB8fCAoRG9jdW1lbnRTeW1ib2wgPSB7fSkpO1xuLyoqXG4gKiBBIHNldCBvZiBwcmVkZWZpbmVkIGNvZGUgYWN0aW9uIGtpbmRzXG4gKi9cbmV4cG9ydCB2YXIgQ29kZUFjdGlvbktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25LaW5kKSB7XG4gICAgLyoqXG4gICAgICogRW1wdHkga2luZC5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5FbXB0eSA9ICcnO1xuICAgIC8qKlxuICAgICAqIEJhc2Uga2luZCBmb3IgcXVpY2tmaXggYWN0aW9uczogJ3F1aWNrZml4J1xuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlF1aWNrRml4ID0gJ3F1aWNrZml4JztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHJlZmFjdG9yaW5nIGFjdGlvbnM6ICdyZWZhY3RvcidcbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvciA9ICdyZWZhY3Rvcic7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBleHRyYWN0aW9uIGFjdGlvbnM6ICdyZWZhY3Rvci5leHRyYWN0J1xuICAgICAqXG4gICAgICogRXhhbXBsZSBleHRyYWN0IGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIEV4dHJhY3QgbWV0aG9kXG4gICAgICogLSBFeHRyYWN0IGZ1bmN0aW9uXG4gICAgICogLSBFeHRyYWN0IHZhcmlhYmxlXG4gICAgICogLSBFeHRyYWN0IGludGVyZmFjZSBmcm9tIGNsYXNzXG4gICAgICogLSAuLi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uS2luZC5SZWZhY3RvckV4dHJhY3QgPSAncmVmYWN0b3IuZXh0cmFjdCc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyBpbmxpbmUgYWN0aW9uczogJ3JlZmFjdG9yLmlubGluZSdcbiAgICAgKlxuICAgICAqIEV4YW1wbGUgaW5saW5lIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIElubGluZSBmdW5jdGlvblxuICAgICAqIC0gSW5saW5lIHZhcmlhYmxlXG4gICAgICogLSBJbmxpbmUgY29uc3RhbnRcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9ySW5saW5lID0gJ3JlZmFjdG9yLmlubGluZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciByZWZhY3RvcmluZyByZXdyaXRlIGFjdGlvbnM6ICdyZWZhY3Rvci5yZXdyaXRlJ1xuICAgICAqXG4gICAgICogRXhhbXBsZSByZXdyaXRlIGFjdGlvbnM6XG4gICAgICpcbiAgICAgKiAtIENvbnZlcnQgSmF2YVNjcmlwdCBmdW5jdGlvbiB0byBjbGFzc1xuICAgICAqIC0gQWRkIG9yIHJlbW92ZSBwYXJhbWV0ZXJcbiAgICAgKiAtIEVuY2Fwc3VsYXRlIGZpZWxkXG4gICAgICogLSBNYWtlIG1ldGhvZCBzdGF0aWNcbiAgICAgKiAtIE1vdmUgbWV0aG9kIHRvIGJhc2UgY2xhc3NcbiAgICAgKiAtIC4uLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlJlZmFjdG9yUmV3cml0ZSA9ICdyZWZhY3Rvci5yZXdyaXRlJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIHNvdXJjZSBhY3Rpb25zOiBgc291cmNlYFxuICAgICAqXG4gICAgICogU291cmNlIGNvZGUgYWN0aW9ucyBhcHBseSB0byB0aGUgZW50aXJlIGZpbGUuXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlID0gJ3NvdXJjZSc7XG4gICAgLyoqXG4gICAgICogQmFzZSBraW5kIGZvciBhbiBvcmdhbml6ZSBpbXBvcnRzIHNvdXJjZSBhY3Rpb246IGBzb3VyY2Uub3JnYW5pemVJbXBvcnRzYFxuICAgICAqL1xuICAgIENvZGVBY3Rpb25LaW5kLlNvdXJjZU9yZ2FuaXplSW1wb3J0cyA9ICdzb3VyY2Uub3JnYW5pemVJbXBvcnRzJztcbiAgICAvKipcbiAgICAgKiBCYXNlIGtpbmQgZm9yIGF1dG8tZml4IHNvdXJjZSBhY3Rpb25zOiBgc291cmNlLmZpeEFsbGAuXG4gICAgICpcbiAgICAgKiBGaXggYWxsIGFjdGlvbnMgYXV0b21hdGljYWxseSBmaXggZXJyb3JzIHRoYXQgaGF2ZSBhIGNsZWFyIGZpeCB0aGF0IGRvIG5vdCByZXF1aXJlIHVzZXIgaW5wdXQuXG4gICAgICogVGhleSBzaG91bGQgbm90IHN1cHByZXNzIGVycm9ycyBvciBwZXJmb3JtIHVuc2FmZSBmaXhlcyBzdWNoIGFzIGdlbmVyYXRpbmcgbmV3IHR5cGVzIG9yIGNsYXNzZXMuXG4gICAgICpcbiAgICAgKiBAc2luY2UgMy4xNS4wXG4gICAgICovXG4gICAgQ29kZUFjdGlvbktpbmQuU291cmNlRml4QWxsID0gJ3NvdXJjZS5maXhBbGwnO1xufSkoQ29kZUFjdGlvbktpbmQgfHwgKENvZGVBY3Rpb25LaW5kID0ge30pKTtcbi8qKlxuICogVGhlIHJlYXNvbiB3aHkgY29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBDb2RlQWN0aW9uVHJpZ2dlcktpbmQ7XG4oZnVuY3Rpb24gKENvZGVBY3Rpb25UcmlnZ2VyS2luZCkge1xuICAgIC8qKlxuICAgICAqIENvZGUgYWN0aW9ucyB3ZXJlIGV4cGxpY2l0bHkgcmVxdWVzdGVkIGJ5IHRoZSB1c2VyIG9yIGJ5IGFuIGV4dGVuc2lvbi5cbiAgICAgKi9cbiAgICBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCA9IDE7XG4gICAgLyoqXG4gICAgICogQ29kZSBhY3Rpb25zIHdlcmUgcmVxdWVzdGVkIGF1dG9tYXRpY2FsbHkuXG4gICAgICpcbiAgICAgKiBUaGlzIHR5cGljYWxseSBoYXBwZW5zIHdoZW4gY3VycmVudCBzZWxlY3Rpb24gaW4gYSBmaWxlIGNoYW5nZXMsIGJ1dCBjYW5cbiAgICAgKiBhbHNvIGJlIHRyaWdnZXJlZCB3aGVuIGZpbGUgY29udGVudCBjaGFuZ2VzLlxuICAgICAqL1xuICAgIENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMgPSAyO1xufSkoQ29kZUFjdGlvblRyaWdnZXJLaW5kIHx8IChDb2RlQWN0aW9uVHJpZ2dlcktpbmQgPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUFjdGlvbkNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUFjdGlvbkNvbnRleHR9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvZGVBY3Rpb25Db250ZXh0O1xuKGZ1bmN0aW9uIChDb2RlQWN0aW9uQ29udGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUFjdGlvbkNvbnRleHQgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUoZGlhZ25vc3RpY3MsIG9ubHksIHRyaWdnZXJLaW5kKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSB7IGRpYWdub3N0aWNzIH07XG4gICAgICAgIGlmIChvbmx5ICE9PSB1bmRlZmluZWQgJiYgb25seSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0Lm9ubHkgPSBvbmx5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0cmlnZ2VyS2luZCAhPT0gdW5kZWZpbmVkICYmIHRyaWdnZXJLaW5kICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQudHJpZ2dlcktpbmQgPSB0cmlnZ2VyS2luZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlQWN0aW9uQ29udGV4dH0gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS5kaWFnbm9zdGljcywgRGlhZ25vc3RpYy5pcylcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUub25seSA9PT0gdW5kZWZpbmVkIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLm9ubHksIElzLnN0cmluZykpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSB1bmRlZmluZWQgfHwgY2FuZGlkYXRlLnRyaWdnZXJLaW5kID09PSBDb2RlQWN0aW9uVHJpZ2dlcktpbmQuSW52b2tlZCB8fCBjYW5kaWRhdGUudHJpZ2dlcktpbmQgPT09IENvZGVBY3Rpb25UcmlnZ2VyS2luZC5BdXRvbWF0aWMpO1xuICAgIH1cbiAgICBDb2RlQWN0aW9uQ29udGV4dC5pcyA9IGlzO1xufSkoQ29kZUFjdGlvbkNvbnRleHQgfHwgKENvZGVBY3Rpb25Db250ZXh0ID0ge30pKTtcbmV4cG9ydCB2YXIgQ29kZUFjdGlvbjtcbihmdW5jdGlvbiAoQ29kZUFjdGlvbikge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0aXRsZSwga2luZE9yQ29tbWFuZE9yRWRpdCwga2luZCkge1xuICAgICAgICBsZXQgcmVzdWx0ID0geyB0aXRsZSB9O1xuICAgICAgICBsZXQgY2hlY2tLaW5kID0gdHJ1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBraW5kT3JDb21tYW5kT3JFZGl0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgY2hlY2tLaW5kID0gZmFsc2U7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmRPckNvbW1hbmRPckVkaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZC5pcyhraW5kT3JDb21tYW5kT3JFZGl0KSkge1xuICAgICAgICAgICAgcmVzdWx0LmNvbW1hbmQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LmVkaXQgPSBraW5kT3JDb21tYW5kT3JFZGl0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGVja0tpbmQgJiYga2luZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXN1bHQua2luZCA9IGtpbmQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgQ29kZUFjdGlvbi5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gY2FuZGlkYXRlICYmIElzLnN0cmluZyhjYW5kaWRhdGUudGl0bGUpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmRpYWdub3N0aWNzID09PSB1bmRlZmluZWQgfHwgSXMudHlwZWRBcnJheShjYW5kaWRhdGUuZGlhZ25vc3RpY3MsIERpYWdub3N0aWMuaXMpKSAmJlxuICAgICAgICAgICAgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS5raW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuZWRpdCAhPT0gdW5kZWZpbmVkIHx8IGNhbmRpZGF0ZS5jb21tYW5kICE9PSB1bmRlZmluZWQpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSkgJiZcbiAgICAgICAgICAgIChjYW5kaWRhdGUuaXNQcmVmZXJyZWQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pc1ByZWZlcnJlZCkpICYmXG4gICAgICAgICAgICAoY2FuZGlkYXRlLmVkaXQgPT09IHVuZGVmaW5lZCB8fCBXb3Jrc3BhY2VFZGl0LmlzKGNhbmRpZGF0ZS5lZGl0KSk7XG4gICAgfVxuICAgIENvZGVBY3Rpb24uaXMgPSBpcztcbn0pKENvZGVBY3Rpb24gfHwgKENvZGVBY3Rpb24gPSB7fSkpO1xuLyoqXG4gKiBUaGUgQ29kZUxlbnMgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgQ29kZUxlbnN9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIENvZGVMZW5zO1xuKGZ1bmN0aW9uIChDb2RlTGVucykge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgQ29kZUxlbnMgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIGRhdGEpIHtcbiAgICAgICAgbGV0IHJlc3VsdCA9IHsgcmFuZ2UgfTtcbiAgICAgICAgaWYgKElzLmRlZmluZWQoZGF0YSkpIHtcbiAgICAgICAgICAgIHJlc3VsdC5kYXRhID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBDb2RlTGVucy5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBDb2RlTGVuc30gaW50ZXJmYWNlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChJcy51bmRlZmluZWQoY2FuZGlkYXRlLmNvbW1hbmQpIHx8IENvbW1hbmQuaXMoY2FuZGlkYXRlLmNvbW1hbmQpKTtcbiAgICB9XG4gICAgQ29kZUxlbnMuaXMgPSBpcztcbn0pKENvZGVMZW5zIHx8IChDb2RlTGVucyA9IHt9KSk7XG4vKipcbiAqIFRoZSBGb3JtYXR0aW5nT3B0aW9ucyBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBGb3JtYXR0aW5nT3B0aW9uc30gbGl0ZXJhbHMuXG4gKi9cbmV4cG9ydCB2YXIgRm9ybWF0dGluZ09wdGlvbnM7XG4oZnVuY3Rpb24gKEZvcm1hdHRpbmdPcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBGb3JtYXR0aW5nT3B0aW9ucyBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh0YWJTaXplLCBpbnNlcnRTcGFjZXMpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFiU2l6ZSwgaW5zZXJ0U3BhY2VzIH07XG4gICAgfVxuICAgIEZvcm1hdHRpbmdPcHRpb25zLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICAvKipcbiAgICAgKiBDaGVja3Mgd2hldGhlciB0aGUgZ2l2ZW4gbGl0ZXJhbCBjb25mb3JtcyB0byB0aGUge0BsaW5rIEZvcm1hdHRpbmdPcHRpb25zfSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnVpbnRlZ2VyKGNhbmRpZGF0ZS50YWJTaXplKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5pbnNlcnRTcGFjZXMpO1xuICAgIH1cbiAgICBGb3JtYXR0aW5nT3B0aW9ucy5pcyA9IGlzO1xufSkoRm9ybWF0dGluZ09wdGlvbnMgfHwgKEZvcm1hdHRpbmdPcHRpb25zID0ge30pKTtcbi8qKlxuICogVGhlIERvY3VtZW50TGluayBuYW1lc3BhY2UgcHJvdmlkZXMgaGVscGVyIGZ1bmN0aW9ucyB0byB3b3JrIHdpdGhcbiAqIHtAbGluayBEb2N1bWVudExpbmt9IGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIERvY3VtZW50TGluaztcbihmdW5jdGlvbiAoRG9jdW1lbnRMaW5rKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBEb2N1bWVudExpbmsgbGl0ZXJhbC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRhcmdldCwgZGF0YSkge1xuICAgICAgICByZXR1cm4geyByYW5nZSwgdGFyZ2V0LCBkYXRhIH07XG4gICAgfVxuICAgIERvY3VtZW50TGluay5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBEb2N1bWVudExpbmt9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBsZXQgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5kZWZpbmVkKGNhbmRpZGF0ZSkgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS50YXJnZXQpIHx8IElzLnN0cmluZyhjYW5kaWRhdGUudGFyZ2V0KSk7XG4gICAgfVxuICAgIERvY3VtZW50TGluay5pcyA9IGlzO1xufSkoRG9jdW1lbnRMaW5rIHx8IChEb2N1bWVudExpbmsgPSB7fSkpO1xuLyoqXG4gKiBUaGUgU2VsZWN0aW9uUmFuZ2UgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbiB0byB3b3JrIHdpdGhcbiAqIFNlbGVjdGlvblJhbmdlIGxpdGVyYWxzLlxuICovXG5leHBvcnQgdmFyIFNlbGVjdGlvblJhbmdlO1xuKGZ1bmN0aW9uIChTZWxlY3Rpb25SYW5nZSkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgU2VsZWN0aW9uUmFuZ2VcbiAgICAgKiBAcGFyYW0gcmFuZ2UgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSBwYXJlbnQgYW4gb3B0aW9uYWwgcGFyZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgcGFyZW50KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBwYXJlbnQgfTtcbiAgICB9XG4gICAgU2VsZWN0aW9uUmFuZ2UuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGxldCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpICYmIChjYW5kaWRhdGUucGFyZW50ID09PSB1bmRlZmluZWQgfHwgU2VsZWN0aW9uUmFuZ2UuaXMoY2FuZGlkYXRlLnBhcmVudCkpO1xuICAgIH1cbiAgICBTZWxlY3Rpb25SYW5nZS5pcyA9IGlzO1xufSkoU2VsZWN0aW9uUmFuZ2UgfHwgKFNlbGVjdGlvblJhbmdlID0ge30pKTtcbi8qKlxuICogQSBzZXQgb2YgcHJlZGVmaW5lZCB0b2tlbiB0eXBlcy4gVGhpcyBzZXQgaXMgbm90IGZpeGVkXG4gKiBhbiBjbGllbnRzIGNhbiBzcGVjaWZ5IGFkZGl0aW9uYWwgdG9rZW4gdHlwZXMgdmlhIHRoZVxuICogY29ycmVzcG9uZGluZyBjbGllbnQgY2FwYWJpbGl0aWVzLlxuICpcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBTZW1hbnRpY1Rva2VuVHlwZXM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5UeXBlcykge1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm5hbWVzcGFjZVwiXSA9IFwibmFtZXNwYWNlXCI7XG4gICAgLyoqXG4gICAgICogUmVwcmVzZW50cyBhIGdlbmVyaWMgdHlwZS4gQWN0cyBhcyBhIGZhbGxiYWNrIGZvciB0eXBlcyB3aGljaCBjYW4ndCBiZSBtYXBwZWQgdG9cbiAgICAgKiBhIHNwZWNpZmljIHR5cGUgbGlrZSBjbGFzcyBvciBlbnVtLlxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVcIl0gPSBcInR5cGVcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjbGFzc1wiXSA9IFwiY2xhc3NcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJlbnVtXCJdID0gXCJlbnVtXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wiaW50ZXJmYWNlXCJdID0gXCJpbnRlcmZhY2VcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJzdHJ1Y3RcIl0gPSBcInN0cnVjdFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInR5cGVQYXJhbWV0ZXJcIl0gPSBcInR5cGVQYXJhbWV0ZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJwYXJhbWV0ZXJcIl0gPSBcInBhcmFtZXRlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInZhcmlhYmxlXCJdID0gXCJ2YXJpYWJsZVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInByb3BlcnR5XCJdID0gXCJwcm9wZXJ0eVwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImVudW1NZW1iZXJcIl0gPSBcImVudW1NZW1iZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJldmVudFwiXSA9IFwiZXZlbnRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJmdW5jdGlvblwiXSA9IFwiZnVuY3Rpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtZXRob2RcIl0gPSBcIm1ldGhvZFwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcIm1hY3JvXCJdID0gXCJtYWNyb1wiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImtleXdvcmRcIl0gPSBcImtleXdvcmRcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJtb2RpZmllclwiXSA9IFwibW9kaWZpZXJcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJjb21tZW50XCJdID0gXCJjb21tZW50XCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wic3RyaW5nXCJdID0gXCJzdHJpbmdcIjtcbiAgICBTZW1hbnRpY1Rva2VuVHlwZXNbXCJudW1iZXJcIl0gPSBcIm51bWJlclwiO1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcInJlZ2V4cFwiXSA9IFwicmVnZXhwXCI7XG4gICAgU2VtYW50aWNUb2tlblR5cGVzW1wib3BlcmF0b3JcIl0gPSBcIm9wZXJhdG9yXCI7XG4gICAgLyoqXG4gICAgICogQHNpbmNlIDMuMTcuMFxuICAgICAqL1xuICAgIFNlbWFudGljVG9rZW5UeXBlc1tcImRlY29yYXRvclwiXSA9IFwiZGVjb3JhdG9yXCI7XG59KShTZW1hbnRpY1Rva2VuVHlwZXMgfHwgKFNlbWFudGljVG9rZW5UeXBlcyA9IHt9KSk7XG4vKipcbiAqIEEgc2V0IG9mIHByZWRlZmluZWQgdG9rZW4gbW9kaWZpZXJzLiBUaGlzIHNldCBpcyBub3QgZml4ZWRcbiAqIGFuIGNsaWVudHMgY2FuIHNwZWNpZnkgYWRkaXRpb25hbCB0b2tlbiB0eXBlcyB2aWEgdGhlXG4gKiBjb3JyZXNwb25kaW5nIGNsaWVudCBjYXBhYmlsaXRpZXMuXG4gKlxuICogQHNpbmNlIDMuMTYuMFxuICovXG5leHBvcnQgdmFyIFNlbWFudGljVG9rZW5Nb2RpZmllcnM7XG4oZnVuY3Rpb24gKFNlbWFudGljVG9rZW5Nb2RpZmllcnMpIHtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiZGVjbGFyYXRpb25cIl0gPSBcImRlY2xhcmF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmluaXRpb25cIl0gPSBcImRlZmluaXRpb25cIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wicmVhZG9ubHlcIl0gPSBcInJlYWRvbmx5XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcInN0YXRpY1wiXSA9IFwic3RhdGljXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlcHJlY2F0ZWRcIl0gPSBcImRlcHJlY2F0ZWRcIjtcbiAgICBTZW1hbnRpY1Rva2VuTW9kaWZpZXJzW1wiYWJzdHJhY3RcIl0gPSBcImFic3RyYWN0XCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImFzeW5jXCJdID0gXCJhc3luY1wiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJtb2RpZmljYXRpb25cIl0gPSBcIm1vZGlmaWNhdGlvblwiO1xuICAgIFNlbWFudGljVG9rZW5Nb2RpZmllcnNbXCJkb2N1bWVudGF0aW9uXCJdID0gXCJkb2N1bWVudGF0aW9uXCI7XG4gICAgU2VtYW50aWNUb2tlbk1vZGlmaWVyc1tcImRlZmF1bHRMaWJyYXJ5XCJdID0gXCJkZWZhdWx0TGlicmFyeVwiO1xufSkoU2VtYW50aWNUb2tlbk1vZGlmaWVycyB8fCAoU2VtYW50aWNUb2tlbk1vZGlmaWVycyA9IHt9KSk7XG4vKipcbiAqIEBzaW5jZSAzLjE2LjBcbiAqL1xuZXhwb3J0IHZhciBTZW1hbnRpY1Rva2VucztcbihmdW5jdGlvbiAoU2VtYW50aWNUb2tlbnMpIHtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLm9iamVjdExpdGVyYWwoY2FuZGlkYXRlKSAmJiAoY2FuZGlkYXRlLnJlc3VsdElkID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGNhbmRpZGF0ZS5yZXN1bHRJZCA9PT0gJ3N0cmluZycpICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGNhbmRpZGF0ZS5kYXRhKSAmJiAoY2FuZGlkYXRlLmRhdGEubGVuZ3RoID09PSAwIHx8IHR5cGVvZiBjYW5kaWRhdGUuZGF0YVswXSA9PT0gJ251bWJlcicpO1xuICAgIH1cbiAgICBTZW1hbnRpY1Rva2Vucy5pcyA9IGlzO1xufSkoU2VtYW50aWNUb2tlbnMgfHwgKFNlbWFudGljVG9rZW5zID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVGV4dCBuYW1lc3BhY2UgcHJvdmlkZXMgZnVuY3Rpb25zIHRvIGRlYWwgd2l0aCBJbmxpbmVWYWx1ZVRleHRzLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVWYWx1ZVRleHQ7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVGV4dCkge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgSW5saW5lVmFsdWVUZXh0IGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCB0ZXh0KSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB0ZXh0IH07XG4gICAgfVxuICAgIElubGluZVZhbHVlVGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5zdHJpbmcoY2FuZGlkYXRlLnRleHQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlVGV4dCB8fCAoSW5saW5lVmFsdWVUZXh0ID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlVmFyaWFibGVMb29rdXAgbmFtZXNwYWNlIHByb3ZpZGVzIGZ1bmN0aW9ucyB0byBkZWFsIHdpdGggSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cHMuXG4gKlxuICogQHNpbmNlIDMuMTcuMFxuICovXG5leHBvcnQgdmFyIElubGluZVZhbHVlVmFyaWFibGVMb29rdXA7XG4oZnVuY3Rpb24gKElubGluZVZhbHVlVmFyaWFibGVMb29rdXApIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlVGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShyYW5nZSwgdmFyaWFibGVOYW1lLCBjYXNlU2Vuc2l0aXZlTG9va3VwKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCB2YXJpYWJsZU5hbWUsIGNhc2VTZW5zaXRpdmVMb29rdXAgfTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVWYXJpYWJsZUxvb2t1cC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBjYW5kaWRhdGUgIT09IHVuZGVmaW5lZCAmJiBjYW5kaWRhdGUgIT09IG51bGwgJiYgUmFuZ2UuaXMoY2FuZGlkYXRlLnJhbmdlKSAmJiBJcy5ib29sZWFuKGNhbmRpZGF0ZS5jYXNlU2Vuc2l0aXZlTG9va3VwKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUudmFyaWFibGVOYW1lKSB8fCBjYW5kaWRhdGUudmFyaWFibGVOYW1lID09PSB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwLmlzID0gaXM7XG59KShJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwIHx8IChJbmxpbmVWYWx1ZVZhcmlhYmxlTG9va3VwID0ge30pKTtcbi8qKlxuICogVGhlIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIG5hbWVzcGFjZSBwcm92aWRlcyBmdW5jdGlvbnMgdG8gZGVhbCB3aXRoIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLlxuICpcbiAqIEBzaW5jZSAzLjE3LjBcbiAqL1xuZXhwb3J0IHZhciBJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbjtcbihmdW5jdGlvbiAoSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24pIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIGxpdGVyYWwuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlKHJhbmdlLCBleHByZXNzaW9uKSB7XG4gICAgICAgIHJldHVybiB7IHJhbmdlLCBleHByZXNzaW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uLmNyZWF0ZSA9IGNyZWF0ZTtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZSAhPT0gdW5kZWZpbmVkICYmIGNhbmRpZGF0ZSAhPT0gbnVsbCAmJiBSYW5nZS5pcyhjYW5kaWRhdGUucmFuZ2UpXG4gICAgICAgICAgICAmJiAoSXMuc3RyaW5nKGNhbmRpZGF0ZS5leHByZXNzaW9uKSB8fCBjYW5kaWRhdGUuZXhwcmVzc2lvbiA9PT0gdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgSW5saW5lVmFsdWVFdmFsdWF0YWJsZUV4cHJlc3Npb24uaXMgPSBpcztcbn0pKElubGluZVZhbHVlRXZhbHVhdGFibGVFeHByZXNzaW9uIHx8IChJbmxpbmVWYWx1ZUV2YWx1YXRhYmxlRXhwcmVzc2lvbiA9IHt9KSk7XG4vKipcbiAqIFRoZSBJbmxpbmVWYWx1ZUNvbnRleHQgbmFtZXNwYWNlIHByb3ZpZGVzIGhlbHBlciBmdW5jdGlvbnMgdG8gd29yayB3aXRoXG4gKiB7QGxpbmsgSW5saW5lVmFsdWVDb250ZXh0fSBsaXRlcmFscy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgSW5saW5lVmFsdWVDb250ZXh0O1xuKGZ1bmN0aW9uIChJbmxpbmVWYWx1ZUNvbnRleHQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElubGluZVZhbHVlQ29udGV4dCBsaXRlcmFsLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShmcmFtZUlkLCBzdG9wcGVkTG9jYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIHsgZnJhbWVJZCwgc3RvcHBlZExvY2F0aW9uIH07XG4gICAgfVxuICAgIElubGluZVZhbHVlQ29udGV4dC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJbmxpbmVWYWx1ZUNvbnRleHR9IGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIElzLmRlZmluZWQoY2FuZGlkYXRlKSAmJiBSYW5nZS5pcyh2YWx1ZS5zdG9wcGVkTG9jYXRpb24pO1xuICAgIH1cbiAgICBJbmxpbmVWYWx1ZUNvbnRleHQuaXMgPSBpcztcbn0pKElubGluZVZhbHVlQ29udGV4dCB8fCAoSW5saW5lVmFsdWVDb250ZXh0ID0ge30pKTtcbi8qKlxuICogSW5sYXkgaGludCBraW5kcy5cbiAqXG4gKiBAc2luY2UgMy4xNy4wXG4gKi9cbmV4cG9ydCB2YXIgSW5sYXlIaW50S2luZDtcbihmdW5jdGlvbiAoSW5sYXlIaW50S2luZCkge1xuICAgIC8qKlxuICAgICAqIEFuIGlubGF5IGhpbnQgdGhhdCBmb3IgYSB0eXBlIGFubm90YXRpb24uXG4gICAgICovXG4gICAgSW5sYXlIaW50S2luZC5UeXBlID0gMTtcbiAgICAvKipcbiAgICAgKiBBbiBpbmxheSBoaW50IHRoYXQgaXMgZm9yIGEgcGFyYW1ldGVyLlxuICAgICAqL1xuICAgIElubGF5SGludEtpbmQuUGFyYW1ldGVyID0gMjtcbiAgICBmdW5jdGlvbiBpcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDEgfHwgdmFsdWUgPT09IDI7XG4gICAgfVxuICAgIElubGF5SGludEtpbmQuaXMgPSBpcztcbn0pKElubGF5SGludEtpbmQgfHwgKElubGF5SGludEtpbmQgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnRMYWJlbFBhcnQ7XG4oZnVuY3Rpb24gKElubGF5SGludExhYmVsUGFydCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyB2YWx1ZSB9O1xuICAgIH1cbiAgICBJbmxheUhpbnRMYWJlbFBhcnQuY3JlYXRlID0gY3JlYXRlO1xuICAgIGZ1bmN0aW9uIGlzKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMub2JqZWN0TGl0ZXJhbChjYW5kaWRhdGUpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRvb2x0aXAgPT09IHVuZGVmaW5lZCB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLnRvb2x0aXApIHx8IE1hcmt1cENvbnRlbnQuaXMoY2FuZGlkYXRlLnRvb2x0aXApKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5sb2NhdGlvbiA9PT0gdW5kZWZpbmVkIHx8IExvY2F0aW9uLmlzKGNhbmRpZGF0ZS5sb2NhdGlvbikpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLmNvbW1hbmQgPT09IHVuZGVmaW5lZCB8fCBDb21tYW5kLmlzKGNhbmRpZGF0ZS5jb21tYW5kKSk7XG4gICAgfVxuICAgIElubGF5SGludExhYmVsUGFydC5pcyA9IGlzO1xufSkoSW5sYXlIaW50TGFiZWxQYXJ0IHx8IChJbmxheUhpbnRMYWJlbFBhcnQgPSB7fSkpO1xuZXhwb3J0IHZhciBJbmxheUhpbnQ7XG4oZnVuY3Rpb24gKElubGF5SGludCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwb3NpdGlvbiwgbGFiZWwsIGtpbmQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0geyBwb3NpdGlvbiwgbGFiZWwgfTtcbiAgICAgICAgaWYgKGtpbmQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVzdWx0LmtpbmQgPSBraW5kO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIElubGF5SGludC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgUG9zaXRpb24uaXMoY2FuZGlkYXRlLnBvc2l0aW9uKVxuICAgICAgICAgICAgJiYgKElzLnN0cmluZyhjYW5kaWRhdGUubGFiZWwpIHx8IElzLnR5cGVkQXJyYXkoY2FuZGlkYXRlLmxhYmVsLCBJbmxheUhpbnRMYWJlbFBhcnQuaXMpKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS5raW5kID09PSB1bmRlZmluZWQgfHwgSW5sYXlIaW50S2luZC5pcyhjYW5kaWRhdGUua2luZCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnRleHRFZGl0cyA9PT0gdW5kZWZpbmVkKSB8fCBJcy50eXBlZEFycmF5KGNhbmRpZGF0ZS50ZXh0RWRpdHMsIFRleHRFZGl0LmlzKVxuICAgICAgICAgICAgJiYgKGNhbmRpZGF0ZS50b29sdGlwID09PSB1bmRlZmluZWQgfHwgSXMuc3RyaW5nKGNhbmRpZGF0ZS50b29sdGlwKSB8fCBNYXJrdXBDb250ZW50LmlzKGNhbmRpZGF0ZS50b29sdGlwKSlcbiAgICAgICAgICAgICYmIChjYW5kaWRhdGUucGFkZGluZ0xlZnQgPT09IHVuZGVmaW5lZCB8fCBJcy5ib29sZWFuKGNhbmRpZGF0ZS5wYWRkaW5nTGVmdCkpXG4gICAgICAgICAgICAmJiAoY2FuZGlkYXRlLnBhZGRpbmdSaWdodCA9PT0gdW5kZWZpbmVkIHx8IElzLmJvb2xlYW4oY2FuZGlkYXRlLnBhZGRpbmdSaWdodCkpO1xuICAgIH1cbiAgICBJbmxheUhpbnQuaXMgPSBpcztcbn0pKElubGF5SGludCB8fCAoSW5sYXlIaW50ID0ge30pKTtcbmV4cG9ydCB2YXIgU3RyaW5nVmFsdWU7XG4oZnVuY3Rpb24gKFN0cmluZ1ZhbHVlKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlU25pcHBldCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4geyBraW5kOiAnc25pcHBldCcsIHZhbHVlIH07XG4gICAgfVxuICAgIFN0cmluZ1ZhbHVlLmNyZWF0ZVNuaXBwZXQgPSBjcmVhdGVTbmlwcGV0O1xufSkoU3RyaW5nVmFsdWUgfHwgKFN0cmluZ1ZhbHVlID0ge30pKTtcbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvbkl0ZW07XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25JdGVtKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKGluc2VydFRleHQsIGZpbHRlclRleHQsIHJhbmdlLCBjb21tYW5kKSB7XG4gICAgICAgIHJldHVybiB7IGluc2VydFRleHQsIGZpbHRlclRleHQsIHJhbmdlLCBjb21tYW5kIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25JdGVtLmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25JdGVtIHx8IChJbmxpbmVDb21wbGV0aW9uSXRlbSA9IHt9KSk7XG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25MaXN0O1xuKGZ1bmN0aW9uIChJbmxpbmVDb21wbGV0aW9uTGlzdCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShpdGVtcykge1xuICAgICAgICByZXR1cm4geyBpdGVtcyB9O1xuICAgIH1cbiAgICBJbmxpbmVDb21wbGV0aW9uTGlzdC5jcmVhdGUgPSBjcmVhdGU7XG59KShJbmxpbmVDb21wbGV0aW9uTGlzdCB8fCAoSW5saW5lQ29tcGxldGlvbkxpc3QgPSB7fSkpO1xuLyoqXG4gKiBEZXNjcmliZXMgaG93IGFuIHtAbGluayBJbmxpbmVDb21wbGV0aW9uSXRlbVByb3ZpZGVyIGlubGluZSBjb21wbGV0aW9uIHByb3ZpZGVyfSB3YXMgdHJpZ2dlcmVkLlxuICpcbiAqIEBzaW5jZSAzLjE4LjBcbiAqIEBwcm9wb3NlZFxuICovXG5leHBvcnQgdmFyIElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZDtcbihmdW5jdGlvbiAoSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kKSB7XG4gICAgLyoqXG4gICAgICogQ29tcGxldGlvbiB3YXMgdHJpZ2dlcmVkIGV4cGxpY2l0bHkgYnkgYSB1c2VyIGdlc3R1cmUuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kLkludm9rZWQgPSAwO1xuICAgIC8qKlxuICAgICAqIENvbXBsZXRpb24gd2FzIHRyaWdnZXJlZCBhdXRvbWF0aWNhbGx5IHdoaWxlIGVkaXRpbmcuXG4gICAgICovXG4gICAgSW5saW5lQ29tcGxldGlvblRyaWdnZXJLaW5kLkF1dG9tYXRpYyA9IDE7XG59KShJbmxpbmVDb21wbGV0aW9uVHJpZ2dlcktpbmQgfHwgKElubGluZUNvbXBsZXRpb25UcmlnZ2VyS2luZCA9IHt9KSk7XG5leHBvcnQgdmFyIFNlbGVjdGVkQ29tcGxldGlvbkluZm87XG4oZnVuY3Rpb24gKFNlbGVjdGVkQ29tcGxldGlvbkluZm8pIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUocmFuZ2UsIHRleHQpIHtcbiAgICAgICAgcmV0dXJuIHsgcmFuZ2UsIHRleHQgfTtcbiAgICB9XG4gICAgU2VsZWN0ZWRDb21wbGV0aW9uSW5mby5jcmVhdGUgPSBjcmVhdGU7XG59KShTZWxlY3RlZENvbXBsZXRpb25JbmZvIHx8IChTZWxlY3RlZENvbXBsZXRpb25JbmZvID0ge30pKTtcbmV4cG9ydCB2YXIgSW5saW5lQ29tcGxldGlvbkNvbnRleHQ7XG4oZnVuY3Rpb24gKElubGluZUNvbXBsZXRpb25Db250ZXh0KSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvKSB7XG4gICAgICAgIHJldHVybiB7IHRyaWdnZXJLaW5kLCBzZWxlY3RlZENvbXBsZXRpb25JbmZvIH07XG4gICAgfVxuICAgIElubGluZUNvbXBsZXRpb25Db250ZXh0LmNyZWF0ZSA9IGNyZWF0ZTtcbn0pKElubGluZUNvbXBsZXRpb25Db250ZXh0IHx8IChJbmxpbmVDb21wbGV0aW9uQ29udGV4dCA9IHt9KSk7XG5leHBvcnQgdmFyIFdvcmtzcGFjZUZvbGRlcjtcbihmdW5jdGlvbiAoV29ya3NwYWNlRm9sZGVyKSB7XG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBJcy5vYmplY3RMaXRlcmFsKGNhbmRpZGF0ZSkgJiYgVVJJLmlzKGNhbmRpZGF0ZS51cmkpICYmIElzLnN0cmluZyhjYW5kaWRhdGUubmFtZSk7XG4gICAgfVxuICAgIFdvcmtzcGFjZUZvbGRlci5pcyA9IGlzO1xufSkoV29ya3NwYWNlRm9sZGVyIHx8IChXb3Jrc3BhY2VGb2xkZXIgPSB7fSkpO1xuZXhwb3J0IGNvbnN0IEVPTCA9IFsnXFxuJywgJ1xcclxcbicsICdcXHInXTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmV4cG9ydCB2YXIgVGV4dERvY3VtZW50O1xuKGZ1bmN0aW9uIChUZXh0RG9jdW1lbnQpIHtcbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgbmV3IElUZXh0RG9jdW1lbnQgbGl0ZXJhbCBmcm9tIHRoZSBnaXZlbiB1cmkgYW5kIGNvbnRlbnQuXG4gICAgICogQHBhcmFtIHVyaSBUaGUgZG9jdW1lbnQncyB1cmkuXG4gICAgICogQHBhcmFtIGxhbmd1YWdlSWQgVGhlIGRvY3VtZW50J3MgbGFuZ3VhZ2UgSWQuXG4gICAgICogQHBhcmFtIHZlcnNpb24gVGhlIGRvY3VtZW50J3MgdmVyc2lvbi5cbiAgICAgKiBAcGFyYW0gY29udGVudCBUaGUgZG9jdW1lbnQncyBjb250ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSh1cmksIGxhbmd1YWdlSWQsIHZlcnNpb24sIGNvbnRlbnQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGdWxsVGV4dERvY3VtZW50KHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCk7XG4gICAgfVxuICAgIFRleHREb2N1bWVudC5jcmVhdGUgPSBjcmVhdGU7XG4gICAgLyoqXG4gICAgICogQ2hlY2tzIHdoZXRoZXIgdGhlIGdpdmVuIGxpdGVyYWwgY29uZm9ybXMgdG8gdGhlIHtAbGluayBJVGV4dERvY3VtZW50fSBpbnRlcmZhY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXModmFsdWUpIHtcbiAgICAgICAgbGV0IGNhbmRpZGF0ZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gSXMuZGVmaW5lZChjYW5kaWRhdGUpICYmIElzLnN0cmluZyhjYW5kaWRhdGUudXJpKSAmJiAoSXMudW5kZWZpbmVkKGNhbmRpZGF0ZS5sYW5ndWFnZUlkKSB8fCBJcy5zdHJpbmcoY2FuZGlkYXRlLmxhbmd1YWdlSWQpKSAmJiBJcy51aW50ZWdlcihjYW5kaWRhdGUubGluZUNvdW50KVxuICAgICAgICAgICAgJiYgSXMuZnVuYyhjYW5kaWRhdGUuZ2V0VGV4dCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUucG9zaXRpb25BdCkgJiYgSXMuZnVuYyhjYW5kaWRhdGUub2Zmc2V0QXQpID8gdHJ1ZSA6IGZhbHNlO1xuICAgIH1cbiAgICBUZXh0RG9jdW1lbnQuaXMgPSBpcztcbiAgICBmdW5jdGlvbiBhcHBseUVkaXRzKGRvY3VtZW50LCBlZGl0cykge1xuICAgICAgICBsZXQgdGV4dCA9IGRvY3VtZW50LmdldFRleHQoKTtcbiAgICAgICAgbGV0IHNvcnRlZEVkaXRzID0gbWVyZ2VTb3J0KGVkaXRzLCAoYSwgYikgPT4ge1xuICAgICAgICAgICAgbGV0IGRpZmYgPSBhLnJhbmdlLnN0YXJ0LmxpbmUgLSBiLnJhbmdlLnN0YXJ0LmxpbmU7XG4gICAgICAgICAgICBpZiAoZGlmZiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhLnJhbmdlLnN0YXJ0LmNoYXJhY3RlciAtIGIucmFuZ2Uuc3RhcnQuY2hhcmFjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRpZmY7XG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgbGFzdE1vZGlmaWVkT2Zmc2V0ID0gdGV4dC5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSBzb3J0ZWRFZGl0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgbGV0IGUgPSBzb3J0ZWRFZGl0c1tpXTtcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZE9mZnNldCA9IGRvY3VtZW50Lm9mZnNldEF0KGUucmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIGlmIChlbmRPZmZzZXQgPD0gbGFzdE1vZGlmaWVkT2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KSArIGUubmV3VGV4dCArIHRleHQuc3Vic3RyaW5nKGVuZE9mZnNldCwgdGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPdmVybGFwcGluZyBlZGl0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsYXN0TW9kaWZpZWRPZmZzZXQgPSBzdGFydE9mZnNldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGV4dDtcbiAgICB9XG4gICAgVGV4dERvY3VtZW50LmFwcGx5RWRpdHMgPSBhcHBseUVkaXRzO1xuICAgIGZ1bmN0aW9uIG1lcmdlU29ydChkYXRhLCBjb21wYXJlKSB7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8PSAxKSB7XG4gICAgICAgICAgICAvLyBzb3J0ZWRcbiAgICAgICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSAoZGF0YS5sZW5ndGggLyAyKSB8IDA7XG4gICAgICAgIGNvbnN0IGxlZnQgPSBkYXRhLnNsaWNlKDAsIHApO1xuICAgICAgICBjb25zdCByaWdodCA9IGRhdGEuc2xpY2UocCk7XG4gICAgICAgIG1lcmdlU29ydChsZWZ0LCBjb21wYXJlKTtcbiAgICAgICAgbWVyZ2VTb3J0KHJpZ2h0LCBjb21wYXJlKTtcbiAgICAgICAgbGV0IGxlZnRJZHggPSAwO1xuICAgICAgICBsZXQgcmlnaHRJZHggPSAwO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGggJiYgcmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxldCByZXQgPSBjb21wYXJlKGxlZnRbbGVmdElkeF0sIHJpZ2h0W3JpZ2h0SWR4XSk7XG4gICAgICAgICAgICBpZiAocmV0IDw9IDApIHtcbiAgICAgICAgICAgICAgICAvLyBzbWFsbGVyX2VxdWFsIC0+IHRha2UgbGVmdCB0byBwcmVzZXJ2ZSBvcmRlclxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGdyZWF0ZXIgLT4gdGFrZSByaWdodFxuICAgICAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsZWZ0SWR4IDwgbGVmdC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IGxlZnRbbGVmdElkeCsrXTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAocmlnaHRJZHggPCByaWdodC5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRhdGFbaSsrXSA9IHJpZ2h0W3JpZ2h0SWR4KytdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbn0pKFRleHREb2N1bWVudCB8fCAoVGV4dERvY3VtZW50ID0ge30pKTtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSB0ZXh0IGRvY3VtZW50IGZyb20gdGhlIG5ldyB2c2NvZGUtbGFuZ3VhZ2VzZXJ2ZXItdGV4dGRvY3VtZW50IHBhY2thZ2UuXG4gKi9cbmNsYXNzIEZ1bGxUZXh0RG9jdW1lbnQge1xuICAgIGNvbnN0cnVjdG9yKHVyaSwgbGFuZ3VhZ2VJZCwgdmVyc2lvbiwgY29udGVudCkge1xuICAgICAgICB0aGlzLl91cmkgPSB1cmk7XG4gICAgICAgIHRoaXMuX2xhbmd1YWdlSWQgPSBsYW5ndWFnZUlkO1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIHRoaXMuX2xpbmVPZmZzZXRzID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgdXJpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXJpO1xuICAgIH1cbiAgICBnZXQgbGFuZ3VhZ2VJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xhbmd1YWdlSWQ7XG4gICAgfVxuICAgIGdldCB2ZXJzaW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdmVyc2lvbjtcbiAgICB9XG4gICAgZ2V0VGV4dChyYW5nZSkge1xuICAgICAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgICAgIGxldCBzdGFydCA9IHRoaXMub2Zmc2V0QXQocmFuZ2Uuc3RhcnQpO1xuICAgICAgICAgICAgbGV0IGVuZCA9IHRoaXMub2Zmc2V0QXQocmFuZ2UuZW5kKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50LnN1YnN0cmluZyhzdGFydCwgZW5kKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudDtcbiAgICB9XG4gICAgdXBkYXRlKGV2ZW50LCB2ZXJzaW9uKSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnQgPSBldmVudC50ZXh0O1xuICAgICAgICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5fbGluZU9mZnNldHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldExpbmVPZmZzZXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZU9mZnNldHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gW107XG4gICAgICAgICAgICBsZXQgdGV4dCA9IHRoaXMuX2NvbnRlbnQ7XG4gICAgICAgICAgICBsZXQgaXNMaW5lU3RhcnQgPSB0cnVlO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGluZVN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmVPZmZzZXRzLnB1c2goaSk7XG4gICAgICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBjaCA9IHRleHQuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlzTGluZVN0YXJ0ID0gKGNoID09PSAnXFxyJyB8fCBjaCA9PT0gJ1xcbicpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1xccicgJiYgaSArIDEgPCB0ZXh0Lmxlbmd0aCAmJiB0ZXh0LmNoYXJBdChpICsgMSkgPT09ICdcXG4nKSB7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNMaW5lU3RhcnQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbGluZU9mZnNldHMucHVzaCh0ZXh0Lmxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9saW5lT2Zmc2V0cyA9IGxpbmVPZmZzZXRzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9saW5lT2Zmc2V0cztcbiAgICB9XG4gICAgcG9zaXRpb25BdChvZmZzZXQpIHtcbiAgICAgICAgb2Zmc2V0ID0gTWF0aC5tYXgoTWF0aC5taW4ob2Zmc2V0LCB0aGlzLl9jb250ZW50Lmxlbmd0aCksIDApO1xuICAgICAgICBsZXQgbGluZU9mZnNldHMgPSB0aGlzLmdldExpbmVPZmZzZXRzKCk7XG4gICAgICAgIGxldCBsb3cgPSAwLCBoaWdoID0gbGluZU9mZnNldHMubGVuZ3RoO1xuICAgICAgICBpZiAoaGlnaCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFBvc2l0aW9uLmNyZWF0ZSgwLCBvZmZzZXQpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgICAgICBsZXQgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgICAgICAgIGlmIChsaW5lT2Zmc2V0c1ttaWRdID4gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG93IGlzIHRoZSBsZWFzdCB4IGZvciB3aGljaCB0aGUgbGluZSBvZmZzZXQgaXMgbGFyZ2VyIHRoYW4gdGhlIGN1cnJlbnQgb2Zmc2V0XG4gICAgICAgIC8vIG9yIGFycmF5Lmxlbmd0aCBpZiBubyBsaW5lIG9mZnNldCBpcyBsYXJnZXIgdGhhbiB0aGUgY3VycmVudCBvZmZzZXRcbiAgICAgICAgbGV0IGxpbmUgPSBsb3cgLSAxO1xuICAgICAgICByZXR1cm4gUG9zaXRpb24uY3JlYXRlKGxpbmUsIG9mZnNldCAtIGxpbmVPZmZzZXRzW2xpbmVdKTtcbiAgICB9XG4gICAgb2Zmc2V0QXQocG9zaXRpb24pIHtcbiAgICAgICAgbGV0IGxpbmVPZmZzZXRzID0gdGhpcy5nZXRMaW5lT2Zmc2V0cygpO1xuICAgICAgICBpZiAocG9zaXRpb24ubGluZSA+PSBsaW5lT2Zmc2V0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250ZW50Lmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwb3NpdGlvbi5saW5lIDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxpbmVPZmZzZXQgPSBsaW5lT2Zmc2V0c1twb3NpdGlvbi5saW5lXTtcbiAgICAgICAgbGV0IG5leHRMaW5lT2Zmc2V0ID0gKHBvc2l0aW9uLmxpbmUgKyAxIDwgbGluZU9mZnNldHMubGVuZ3RoKSA/IGxpbmVPZmZzZXRzW3Bvc2l0aW9uLmxpbmUgKyAxXSA6IHRoaXMuX2NvbnRlbnQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoTWF0aC5taW4obGluZU9mZnNldCArIHBvc2l0aW9uLmNoYXJhY3RlciwgbmV4dExpbmVPZmZzZXQpLCBsaW5lT2Zmc2V0KTtcbiAgICB9XG4gICAgZ2V0IGxpbmVDb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGluZU9mZnNldHMoKS5sZW5ndGg7XG4gICAgfVxufVxudmFyIElzO1xuKGZ1bmN0aW9uIChJcykge1xuICAgIGNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbiAgICBmdW5jdGlvbiBkZWZpbmVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnO1xuICAgIH1cbiAgICBJcy5kZWZpbmVkID0gZGVmaW5lZDtcbiAgICBmdW5jdGlvbiB1bmRlZmluZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCc7XG4gICAgfVxuICAgIElzLnVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICBmdW5jdGlvbiBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgfVxuICAgIElzLmJvb2xlYW4gPSBib29sZWFuO1xuICAgIGZ1bmN0aW9uIHN0cmluZyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IFN0cmluZ10nO1xuICAgIH1cbiAgICBJcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgZnVuY3Rpb24gbnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgTnVtYmVyXSc7XG4gICAgfVxuICAgIElzLm51bWJlciA9IG51bWJlcjtcbiAgICBmdW5jdGlvbiBudW1iZXJSYW5nZSh2YWx1ZSwgbWluLCBtYXgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiBtaW4gPD0gdmFsdWUgJiYgdmFsdWUgPD0gbWF4O1xuICAgIH1cbiAgICBJcy5udW1iZXJSYW5nZSA9IG51bWJlclJhbmdlO1xuICAgIGZ1bmN0aW9uIGludGVnZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBOdW1iZXJdJyAmJiAtMjE0NzQ4MzY0OCA8PSB2YWx1ZSAmJiB2YWx1ZSA8PSAyMTQ3NDgzNjQ3O1xuICAgIH1cbiAgICBJcy5pbnRlZ2VyID0gaW50ZWdlcjtcbiAgICBmdW5jdGlvbiB1aW50ZWdlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT09ICdbb2JqZWN0IE51bWJlcl0nICYmIDAgPD0gdmFsdWUgJiYgdmFsdWUgPD0gMjE0NzQ4MzY0NztcbiAgICB9XG4gICAgSXMudWludGVnZXIgPSB1aW50ZWdlcjtcbiAgICBmdW5jdGlvbiBmdW5jKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcbiAgICB9XG4gICAgSXMuZnVuYyA9IGZ1bmM7XG4gICAgZnVuY3Rpb24gb2JqZWN0TGl0ZXJhbCh2YWx1ZSkge1xuICAgICAgICAvLyBTdHJpY3RseSBzcGVha2luZyBjbGFzcyBpbnN0YW5jZXMgcGFzcyB0aGlzIGNoZWNrIGFzIHdlbGwuIFNpbmNlIHRoZSBMU1BcbiAgICAgICAgLy8gZG9lc24ndCB1c2UgY2xhc3NlcyB3ZSBpZ25vcmUgdGhpcyBmb3Igbm93LiBJZiB3ZSBkbyB3ZSBuZWVkIHRvIGFkZCBzb21ldGhpbmdcbiAgICAgICAgLy8gbGlrZSB0aGlzOiBgT2JqZWN0LmdldFByb3RvdHlwZU9mKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSkgPT09IG51bGxgXG4gICAgICAgIHJldHVybiB2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnO1xuICAgIH1cbiAgICBJcy5vYmplY3RMaXRlcmFsID0gb2JqZWN0TGl0ZXJhbDtcbiAgICBmdW5jdGlvbiB0eXBlZEFycmF5KHZhbHVlLCBjaGVjaykge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoY2hlY2spO1xuICAgIH1cbiAgICBJcy50eXBlZEFycmF5ID0gdHlwZWRBcnJheTtcbn0pKElzIHx8IChJcyA9IHt9KSk7XG4iLCJ2YXIgTElCOygoKT0+e1widXNlIHN0cmljdFwiO3ZhciB0PXs0NzA6dD0+e2Z1bmN0aW9uIGUodCl7aWYoXCJzdHJpbmdcIiE9dHlwZW9mIHQpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlBhdGggbXVzdCBiZSBhIHN0cmluZy4gUmVjZWl2ZWQgXCIrSlNPTi5zdHJpbmdpZnkodCkpfWZ1bmN0aW9uIHIodCxlKXtmb3IodmFyIHIsbj1cIlwiLGk9MCxvPS0xLHM9MCxoPTA7aDw9dC5sZW5ndGg7KytoKXtpZihoPHQubGVuZ3RoKXI9dC5jaGFyQ29kZUF0KGgpO2Vsc2V7aWYoNDc9PT1yKWJyZWFrO3I9NDd9aWYoNDc9PT1yKXtpZihvPT09aC0xfHwxPT09cyk7ZWxzZSBpZihvIT09aC0xJiYyPT09cyl7aWYobi5sZW5ndGg8Mnx8MiE9PWl8fDQ2IT09bi5jaGFyQ29kZUF0KG4ubGVuZ3RoLTEpfHw0NiE9PW4uY2hhckNvZGVBdChuLmxlbmd0aC0yKSlpZihuLmxlbmd0aD4yKXt2YXIgYT1uLmxhc3RJbmRleE9mKFwiL1wiKTtpZihhIT09bi5sZW5ndGgtMSl7LTE9PT1hPyhuPVwiXCIsaT0wKTppPShuPW4uc2xpY2UoMCxhKSkubGVuZ3RoLTEtbi5sYXN0SW5kZXhPZihcIi9cIiksbz1oLHM9MDtjb250aW51ZX19ZWxzZSBpZigyPT09bi5sZW5ndGh8fDE9PT1uLmxlbmd0aCl7bj1cIlwiLGk9MCxvPWgscz0wO2NvbnRpbnVlfWUmJihuLmxlbmd0aD4wP24rPVwiLy4uXCI6bj1cIi4uXCIsaT0yKX1lbHNlIG4ubGVuZ3RoPjA/bis9XCIvXCIrdC5zbGljZShvKzEsaCk6bj10LnNsaWNlKG8rMSxoKSxpPWgtby0xO289aCxzPTB9ZWxzZSA0Nj09PXImJi0xIT09cz8rK3M6cz0tMX1yZXR1cm4gbn12YXIgbj17cmVzb2x2ZTpmdW5jdGlvbigpe2Zvcih2YXIgdCxuPVwiXCIsaT0hMSxvPWFyZ3VtZW50cy5sZW5ndGgtMTtvPj0tMSYmIWk7by0tKXt2YXIgcztvPj0wP3M9YXJndW1lbnRzW29dOih2b2lkIDA9PT10JiYodD1wcm9jZXNzLmN3ZCgpKSxzPXQpLGUocyksMCE9PXMubGVuZ3RoJiYobj1zK1wiL1wiK24saT00Nz09PXMuY2hhckNvZGVBdCgwKSl9cmV0dXJuIG49cihuLCFpKSxpP24ubGVuZ3RoPjA/XCIvXCIrbjpcIi9cIjpuLmxlbmd0aD4wP246XCIuXCJ9LG5vcm1hbGl6ZTpmdW5jdGlvbih0KXtpZihlKHQpLDA9PT10Lmxlbmd0aClyZXR1cm5cIi5cIjt2YXIgbj00Nz09PXQuY2hhckNvZGVBdCgwKSxpPTQ3PT09dC5jaGFyQ29kZUF0KHQubGVuZ3RoLTEpO3JldHVybiAwIT09KHQ9cih0LCFuKSkubGVuZ3RofHxufHwodD1cIi5cIiksdC5sZW5ndGg+MCYmaSYmKHQrPVwiL1wiKSxuP1wiL1wiK3Q6dH0saXNBYnNvbHV0ZTpmdW5jdGlvbih0KXtyZXR1cm4gZSh0KSx0Lmxlbmd0aD4wJiY0Nz09PXQuY2hhckNvZGVBdCgwKX0sam9pbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVyblwiLlwiO2Zvcih2YXIgdCxyPTA7cjxhcmd1bWVudHMubGVuZ3RoOysrcil7dmFyIGk9YXJndW1lbnRzW3JdO2UoaSksaS5sZW5ndGg+MCYmKHZvaWQgMD09PXQ/dD1pOnQrPVwiL1wiK2kpfXJldHVybiB2b2lkIDA9PT10P1wiLlwiOm4ubm9ybWFsaXplKHQpfSxyZWxhdGl2ZTpmdW5jdGlvbih0LHIpe2lmKGUodCksZShyKSx0PT09cilyZXR1cm5cIlwiO2lmKCh0PW4ucmVzb2x2ZSh0KSk9PT0ocj1uLnJlc29sdmUocikpKXJldHVyblwiXCI7Zm9yKHZhciBpPTE7aTx0Lmxlbmd0aCYmNDc9PT10LmNoYXJDb2RlQXQoaSk7KytpKTtmb3IodmFyIG89dC5sZW5ndGgscz1vLWksaD0xO2g8ci5sZW5ndGgmJjQ3PT09ci5jaGFyQ29kZUF0KGgpOysraCk7Zm9yKHZhciBhPXIubGVuZ3RoLWgsYz1zPGE/czphLGY9LTEsdT0wO3U8PWM7Kyt1KXtpZih1PT09Yyl7aWYoYT5jKXtpZig0Nz09PXIuY2hhckNvZGVBdChoK3UpKXJldHVybiByLnNsaWNlKGgrdSsxKTtpZigwPT09dSlyZXR1cm4gci5zbGljZShoK3UpfWVsc2Ugcz5jJiYoNDc9PT10LmNoYXJDb2RlQXQoaSt1KT9mPXU6MD09PXUmJihmPTApKTticmVha312YXIgbD10LmNoYXJDb2RlQXQoaSt1KTtpZihsIT09ci5jaGFyQ29kZUF0KGgrdSkpYnJlYWs7NDc9PT1sJiYoZj11KX12YXIgZz1cIlwiO2Zvcih1PWkrZisxO3U8PW87Kyt1KXUhPT1vJiY0NyE9PXQuY2hhckNvZGVBdCh1KXx8KDA9PT1nLmxlbmd0aD9nKz1cIi4uXCI6Zys9XCIvLi5cIik7cmV0dXJuIGcubGVuZ3RoPjA/ZytyLnNsaWNlKGgrZik6KGgrPWYsNDc9PT1yLmNoYXJDb2RlQXQoaCkmJisraCxyLnNsaWNlKGgpKX0sX21ha2VMb25nOmZ1bmN0aW9uKHQpe3JldHVybiB0fSxkaXJuYW1lOmZ1bmN0aW9uKHQpe2lmKGUodCksMD09PXQubGVuZ3RoKXJldHVyblwiLlwiO2Zvcih2YXIgcj10LmNoYXJDb2RlQXQoMCksbj00Nz09PXIsaT0tMSxvPSEwLHM9dC5sZW5ndGgtMTtzPj0xOy0tcylpZig0Nz09PShyPXQuY2hhckNvZGVBdChzKSkpe2lmKCFvKXtpPXM7YnJlYWt9fWVsc2Ugbz0hMTtyZXR1cm4tMT09PWk/bj9cIi9cIjpcIi5cIjpuJiYxPT09aT9cIi8vXCI6dC5zbGljZSgwLGkpfSxiYXNlbmFtZTpmdW5jdGlvbih0LHIpe2lmKHZvaWQgMCE9PXImJlwic3RyaW5nXCIhPXR5cGVvZiByKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZXh0XCIgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZycpO2UodCk7dmFyIG4saT0wLG89LTEscz0hMDtpZih2b2lkIDAhPT1yJiZyLmxlbmd0aD4wJiZyLmxlbmd0aDw9dC5sZW5ndGgpe2lmKHIubGVuZ3RoPT09dC5sZW5ndGgmJnI9PT10KXJldHVyblwiXCI7dmFyIGg9ci5sZW5ndGgtMSxhPS0xO2ZvcihuPXQubGVuZ3RoLTE7bj49MDstLW4pe3ZhciBjPXQuY2hhckNvZGVBdChuKTtpZig0Nz09PWMpe2lmKCFzKXtpPW4rMTticmVha319ZWxzZS0xPT09YSYmKHM9ITEsYT1uKzEpLGg+PTAmJihjPT09ci5jaGFyQ29kZUF0KGgpPy0xPT0tLWgmJihvPW4pOihoPS0xLG89YSkpfXJldHVybiBpPT09bz9vPWE6LTE9PT1vJiYobz10Lmxlbmd0aCksdC5zbGljZShpLG8pfWZvcihuPXQubGVuZ3RoLTE7bj49MDstLW4paWYoNDc9PT10LmNoYXJDb2RlQXQobikpe2lmKCFzKXtpPW4rMTticmVha319ZWxzZS0xPT09byYmKHM9ITEsbz1uKzEpO3JldHVybi0xPT09bz9cIlwiOnQuc2xpY2UoaSxvKX0sZXh0bmFtZTpmdW5jdGlvbih0KXtlKHQpO2Zvcih2YXIgcj0tMSxuPTAsaT0tMSxvPSEwLHM9MCxoPXQubGVuZ3RoLTE7aD49MDstLWgpe3ZhciBhPXQuY2hhckNvZGVBdChoKTtpZig0NyE9PWEpLTE9PT1pJiYobz0hMSxpPWgrMSksNDY9PT1hPy0xPT09cj9yPWg6MSE9PXMmJihzPTEpOi0xIT09ciYmKHM9LTEpO2Vsc2UgaWYoIW8pe249aCsxO2JyZWFrfX1yZXR1cm4tMT09PXJ8fC0xPT09aXx8MD09PXN8fDE9PT1zJiZyPT09aS0xJiZyPT09bisxP1wiXCI6dC5zbGljZShyLGkpfSxmb3JtYXQ6ZnVuY3Rpb24odCl7aWYobnVsbD09PXR8fFwib2JqZWN0XCIhPXR5cGVvZiB0KXRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInBhdGhPYmplY3RcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcrdHlwZW9mIHQpO3JldHVybiBmdW5jdGlvbih0LGUpe3ZhciByPWUuZGlyfHxlLnJvb3Qsbj1lLmJhc2V8fChlLm5hbWV8fFwiXCIpKyhlLmV4dHx8XCJcIik7cmV0dXJuIHI/cj09PWUucm9vdD9yK246citcIi9cIituOm59KDAsdCl9LHBhcnNlOmZ1bmN0aW9uKHQpe2UodCk7dmFyIHI9e3Jvb3Q6XCJcIixkaXI6XCJcIixiYXNlOlwiXCIsZXh0OlwiXCIsbmFtZTpcIlwifTtpZigwPT09dC5sZW5ndGgpcmV0dXJuIHI7dmFyIG4saT10LmNoYXJDb2RlQXQoMCksbz00Nz09PWk7bz8oci5yb290PVwiL1wiLG49MSk6bj0wO2Zvcih2YXIgcz0tMSxoPTAsYT0tMSxjPSEwLGY9dC5sZW5ndGgtMSx1PTA7Zj49bjstLWYpaWYoNDchPT0oaT10LmNoYXJDb2RlQXQoZikpKS0xPT09YSYmKGM9ITEsYT1mKzEpLDQ2PT09aT8tMT09PXM/cz1mOjEhPT11JiYodT0xKTotMSE9PXMmJih1PS0xKTtlbHNlIGlmKCFjKXtoPWYrMTticmVha31yZXR1cm4tMT09PXN8fC0xPT09YXx8MD09PXV8fDE9PT11JiZzPT09YS0xJiZzPT09aCsxPy0xIT09YSYmKHIuYmFzZT1yLm5hbWU9MD09PWgmJm8/dC5zbGljZSgxLGEpOnQuc2xpY2UoaCxhKSk6KDA9PT1oJiZvPyhyLm5hbWU9dC5zbGljZSgxLHMpLHIuYmFzZT10LnNsaWNlKDEsYSkpOihyLm5hbWU9dC5zbGljZShoLHMpLHIuYmFzZT10LnNsaWNlKGgsYSkpLHIuZXh0PXQuc2xpY2UocyxhKSksaD4wP3IuZGlyPXQuc2xpY2UoMCxoLTEpOm8mJihyLmRpcj1cIi9cIikscn0sc2VwOlwiL1wiLGRlbGltaXRlcjpcIjpcIix3aW4zMjpudWxsLHBvc2l4Om51bGx9O24ucG9zaXg9bix0LmV4cG9ydHM9bn19LGU9e307ZnVuY3Rpb24gcihuKXt2YXIgaT1lW25dO2lmKHZvaWQgMCE9PWkpcmV0dXJuIGkuZXhwb3J0czt2YXIgbz1lW25dPXtleHBvcnRzOnt9fTtyZXR1cm4gdFtuXShvLG8uZXhwb3J0cyxyKSxvLmV4cG9ydHN9ci5kPSh0LGUpPT57Zm9yKHZhciBuIGluIGUpci5vKGUsbikmJiFyLm8odCxuKSYmT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsbix7ZW51bWVyYWJsZTohMCxnZXQ6ZVtuXX0pfSxyLm89KHQsZSk9Pk9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0LGUpLHIucj10PT57XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkodCxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkodCxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX07dmFyIG49e307KCgpPT57bGV0IHQ7aWYoci5yKG4pLHIuZChuLHtVUkk6KCk9PmYsVXRpbHM6KCk9PlB9KSxcIm9iamVjdFwiPT10eXBlb2YgcHJvY2Vzcyl0PVwid2luMzJcIj09PXByb2Nlc3MucGxhdGZvcm07ZWxzZSBpZihcIm9iamVjdFwiPT10eXBlb2YgbmF2aWdhdG9yKXtsZXQgZT1uYXZpZ2F0b3IudXNlckFnZW50O3Q9ZS5pbmRleE9mKFwiV2luZG93c1wiKT49MH1jb25zdCBlPS9eXFx3W1xcd1xcZCsuLV0qJC8saT0vXlxcLy8sbz0vXlxcL1xcLy87ZnVuY3Rpb24gcyh0LHIpe2lmKCF0LnNjaGVtZSYmcil0aHJvdyBuZXcgRXJyb3IoYFtVcmlFcnJvcl06IFNjaGVtZSBpcyBtaXNzaW5nOiB7c2NoZW1lOiBcIlwiLCBhdXRob3JpdHk6IFwiJHt0LmF1dGhvcml0eX1cIiwgcGF0aDogXCIke3QucGF0aH1cIiwgcXVlcnk6IFwiJHt0LnF1ZXJ5fVwiLCBmcmFnbWVudDogXCIke3QuZnJhZ21lbnR9XCJ9YCk7aWYodC5zY2hlbWUmJiFlLnRlc3QodC5zY2hlbWUpKXRocm93IG5ldyBFcnJvcihcIltVcmlFcnJvcl06IFNjaGVtZSBjb250YWlucyBpbGxlZ2FsIGNoYXJhY3RlcnMuXCIpO2lmKHQucGF0aClpZih0LmF1dGhvcml0eSl7aWYoIWkudGVzdCh0LnBhdGgpKXRocm93IG5ldyBFcnJvcignW1VyaUVycm9yXTogSWYgYSBVUkkgY29udGFpbnMgYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjb21wb25lbnQgbXVzdCBlaXRoZXIgYmUgZW1wdHkgb3IgYmVnaW4gd2l0aCBhIHNsYXNoIChcIi9cIikgY2hhcmFjdGVyJyl9ZWxzZSBpZihvLnRlc3QodC5wYXRoKSl0aHJvdyBuZXcgRXJyb3IoJ1tVcmlFcnJvcl06IElmIGEgVVJJIGRvZXMgbm90IGNvbnRhaW4gYW4gYXV0aG9yaXR5IGNvbXBvbmVudCwgdGhlbiB0aGUgcGF0aCBjYW5ub3QgYmVnaW4gd2l0aCB0d28gc2xhc2ggY2hhcmFjdGVycyAoXCIvL1wiKScpfWNvbnN0IGg9XCJcIixhPVwiL1wiLGM9L14oKFteOi8/I10rPyk6KT8oXFwvXFwvKFteLz8jXSopKT8oW14/I10qKShcXD8oW14jXSopKT8oIyguKikpPy87Y2xhc3MgZntzdGF0aWMgaXNVcmkodCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBmfHwhIXQmJlwic3RyaW5nXCI9PXR5cGVvZiB0LmF1dGhvcml0eSYmXCJzdHJpbmdcIj09dHlwZW9mIHQuZnJhZ21lbnQmJlwic3RyaW5nXCI9PXR5cGVvZiB0LnBhdGgmJlwic3RyaW5nXCI9PXR5cGVvZiB0LnF1ZXJ5JiZcInN0cmluZ1wiPT10eXBlb2YgdC5zY2hlbWUmJlwic3RyaW5nXCI9PXR5cGVvZiB0LmZzUGF0aCYmXCJmdW5jdGlvblwiPT10eXBlb2YgdC53aXRoJiZcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRvU3RyaW5nfXNjaGVtZTthdXRob3JpdHk7cGF0aDtxdWVyeTtmcmFnbWVudDtjb25zdHJ1Y3Rvcih0LGUscixuLGksbz0hMSl7XCJvYmplY3RcIj09dHlwZW9mIHQ/KHRoaXMuc2NoZW1lPXQuc2NoZW1lfHxoLHRoaXMuYXV0aG9yaXR5PXQuYXV0aG9yaXR5fHxoLHRoaXMucGF0aD10LnBhdGh8fGgsdGhpcy5xdWVyeT10LnF1ZXJ5fHxoLHRoaXMuZnJhZ21lbnQ9dC5mcmFnbWVudHx8aCk6KHRoaXMuc2NoZW1lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHR8fGU/dDpcImZpbGVcIn0odCxvKSx0aGlzLmF1dGhvcml0eT1lfHxoLHRoaXMucGF0aD1mdW5jdGlvbih0LGUpe3N3aXRjaCh0KXtjYXNlXCJodHRwc1wiOmNhc2VcImh0dHBcIjpjYXNlXCJmaWxlXCI6ZT9lWzBdIT09YSYmKGU9YStlKTplPWF9cmV0dXJuIGV9KHRoaXMuc2NoZW1lLHJ8fGgpLHRoaXMucXVlcnk9bnx8aCx0aGlzLmZyYWdtZW50PWl8fGgscyh0aGlzLG8pKX1nZXQgZnNQYXRoKCl7cmV0dXJuIG0odGhpcywhMSl9d2l0aCh0KXtpZighdClyZXR1cm4gdGhpcztsZXR7c2NoZW1lOmUsYXV0aG9yaXR5OnIscGF0aDpuLHF1ZXJ5OmksZnJhZ21lbnQ6b309dDtyZXR1cm4gdm9pZCAwPT09ZT9lPXRoaXMuc2NoZW1lOm51bGw9PT1lJiYoZT1oKSx2b2lkIDA9PT1yP3I9dGhpcy5hdXRob3JpdHk6bnVsbD09PXImJihyPWgpLHZvaWQgMD09PW4/bj10aGlzLnBhdGg6bnVsbD09PW4mJihuPWgpLHZvaWQgMD09PWk/aT10aGlzLnF1ZXJ5Om51bGw9PT1pJiYoaT1oKSx2b2lkIDA9PT1vP289dGhpcy5mcmFnbWVudDpudWxsPT09byYmKG89aCksZT09PXRoaXMuc2NoZW1lJiZyPT09dGhpcy5hdXRob3JpdHkmJm49PT10aGlzLnBhdGgmJmk9PT10aGlzLnF1ZXJ5JiZvPT09dGhpcy5mcmFnbWVudD90aGlzOm5ldyBsKGUscixuLGksbyl9c3RhdGljIHBhcnNlKHQsZT0hMSl7Y29uc3Qgcj1jLmV4ZWModCk7cmV0dXJuIHI/bmV3IGwoclsyXXx8aCxDKHJbNF18fGgpLEMocls1XXx8aCksQyhyWzddfHxoKSxDKHJbOV18fGgpLGUpOm5ldyBsKGgsaCxoLGgsaCl9c3RhdGljIGZpbGUoZSl7bGV0IHI9aDtpZih0JiYoZT1lLnJlcGxhY2UoL1xcXFwvZyxhKSksZVswXT09PWEmJmVbMV09PT1hKXtjb25zdCB0PWUuaW5kZXhPZihhLDIpOy0xPT09dD8ocj1lLnN1YnN0cmluZygyKSxlPWEpOihyPWUuc3Vic3RyaW5nKDIsdCksZT1lLnN1YnN0cmluZyh0KXx8YSl9cmV0dXJuIG5ldyBsKFwiZmlsZVwiLHIsZSxoLGgpfXN0YXRpYyBmcm9tKHQpe2NvbnN0IGU9bmV3IGwodC5zY2hlbWUsdC5hdXRob3JpdHksdC5wYXRoLHQucXVlcnksdC5mcmFnbWVudCk7cmV0dXJuIHMoZSwhMCksZX10b1N0cmluZyh0PSExKXtyZXR1cm4geSh0aGlzLHQpfXRvSlNPTigpe3JldHVybiB0aGlzfXN0YXRpYyByZXZpdmUodCl7aWYodCl7aWYodCBpbnN0YW5jZW9mIGYpcmV0dXJuIHQ7e2NvbnN0IGU9bmV3IGwodCk7cmV0dXJuIGUuX2Zvcm1hdHRlZD10LmV4dGVybmFsLGUuX2ZzUGF0aD10Ll9zZXA9PT11P3QuZnNQYXRoOm51bGwsZX19cmV0dXJuIHR9fWNvbnN0IHU9dD8xOnZvaWQgMDtjbGFzcyBsIGV4dGVuZHMgZntfZm9ybWF0dGVkPW51bGw7X2ZzUGF0aD1udWxsO2dldCBmc1BhdGgoKXtyZXR1cm4gdGhpcy5fZnNQYXRofHwodGhpcy5fZnNQYXRoPW0odGhpcywhMSkpLHRoaXMuX2ZzUGF0aH10b1N0cmluZyh0PSExKXtyZXR1cm4gdD95KHRoaXMsITApOih0aGlzLl9mb3JtYXR0ZWR8fCh0aGlzLl9mb3JtYXR0ZWQ9eSh0aGlzLCExKSksdGhpcy5fZm9ybWF0dGVkKX10b0pTT04oKXtjb25zdCB0PXskbWlkOjF9O3JldHVybiB0aGlzLl9mc1BhdGgmJih0LmZzUGF0aD10aGlzLl9mc1BhdGgsdC5fc2VwPXUpLHRoaXMuX2Zvcm1hdHRlZCYmKHQuZXh0ZXJuYWw9dGhpcy5fZm9ybWF0dGVkKSx0aGlzLnBhdGgmJih0LnBhdGg9dGhpcy5wYXRoKSx0aGlzLnNjaGVtZSYmKHQuc2NoZW1lPXRoaXMuc2NoZW1lKSx0aGlzLmF1dGhvcml0eSYmKHQuYXV0aG9yaXR5PXRoaXMuYXV0aG9yaXR5KSx0aGlzLnF1ZXJ5JiYodC5xdWVyeT10aGlzLnF1ZXJ5KSx0aGlzLmZyYWdtZW50JiYodC5mcmFnbWVudD10aGlzLmZyYWdtZW50KSx0fX1jb25zdCBnPXs1ODpcIiUzQVwiLDQ3OlwiJTJGXCIsNjM6XCIlM0ZcIiwzNTpcIiUyM1wiLDkxOlwiJTVCXCIsOTM6XCIlNURcIiw2NDpcIiU0MFwiLDMzOlwiJTIxXCIsMzY6XCIlMjRcIiwzODpcIiUyNlwiLDM5OlwiJTI3XCIsNDA6XCIlMjhcIiw0MTpcIiUyOVwiLDQyOlwiJTJBXCIsNDM6XCIlMkJcIiw0NDpcIiUyQ1wiLDU5OlwiJTNCXCIsNjE6XCIlM0RcIiwzMjpcIiUyMFwifTtmdW5jdGlvbiBkKHQsZSxyKXtsZXQgbixpPS0xO2ZvcihsZXQgbz0wO288dC5sZW5ndGg7bysrKXtjb25zdCBzPXQuY2hhckNvZGVBdChvKTtpZihzPj05NyYmczw9MTIyfHxzPj02NSYmczw9OTB8fHM+PTQ4JiZzPD01N3x8NDU9PT1zfHw0Nj09PXN8fDk1PT09c3x8MTI2PT09c3x8ZSYmNDc9PT1zfHxyJiY5MT09PXN8fHImJjkzPT09c3x8ciYmNTg9PT1zKS0xIT09aSYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhpLG8pKSxpPS0xKSx2b2lkIDAhPT1uJiYobis9dC5jaGFyQXQobykpO2Vsc2V7dm9pZCAwPT09biYmKG49dC5zdWJzdHIoMCxvKSk7Y29uc3QgZT1nW3NdO3ZvaWQgMCE9PWU/KC0xIT09aSYmKG4rPWVuY29kZVVSSUNvbXBvbmVudCh0LnN1YnN0cmluZyhpLG8pKSxpPS0xKSxuKz1lKTotMT09PWkmJihpPW8pfX1yZXR1cm4tMSE9PWkmJihuKz1lbmNvZGVVUklDb21wb25lbnQodC5zdWJzdHJpbmcoaSkpKSx2b2lkIDAhPT1uP246dH1mdW5jdGlvbiBwKHQpe2xldCBlO2ZvcihsZXQgcj0wO3I8dC5sZW5ndGg7cisrKXtjb25zdCBuPXQuY2hhckNvZGVBdChyKTszNT09PW58fDYzPT09bj8odm9pZCAwPT09ZSYmKGU9dC5zdWJzdHIoMCxyKSksZSs9Z1tuXSk6dm9pZCAwIT09ZSYmKGUrPXRbcl0pfXJldHVybiB2b2lkIDAhPT1lP2U6dH1mdW5jdGlvbiBtKGUscil7bGV0IG47cmV0dXJuIG49ZS5hdXRob3JpdHkmJmUucGF0aC5sZW5ndGg+MSYmXCJmaWxlXCI9PT1lLnNjaGVtZT9gLy8ke2UuYXV0aG9yaXR5fSR7ZS5wYXRofWA6NDc9PT1lLnBhdGguY2hhckNvZGVBdCgwKSYmKGUucGF0aC5jaGFyQ29kZUF0KDEpPj02NSYmZS5wYXRoLmNoYXJDb2RlQXQoMSk8PTkwfHxlLnBhdGguY2hhckNvZGVBdCgxKT49OTcmJmUucGF0aC5jaGFyQ29kZUF0KDEpPD0xMjIpJiY1OD09PWUucGF0aC5jaGFyQ29kZUF0KDIpP3I/ZS5wYXRoLnN1YnN0cigxKTplLnBhdGhbMV0udG9Mb3dlckNhc2UoKStlLnBhdGguc3Vic3RyKDIpOmUucGF0aCx0JiYobj1uLnJlcGxhY2UoL1xcLy9nLFwiXFxcXFwiKSksbn1mdW5jdGlvbiB5KHQsZSl7Y29uc3Qgcj1lP3A6ZDtsZXQgbj1cIlwiLHtzY2hlbWU6aSxhdXRob3JpdHk6byxwYXRoOnMscXVlcnk6aCxmcmFnbWVudDpjfT10O2lmKGkmJihuKz1pLG4rPVwiOlwiKSwob3x8XCJmaWxlXCI9PT1pKSYmKG4rPWEsbis9YSksbyl7bGV0IHQ9by5pbmRleE9mKFwiQFwiKTtpZigtMSE9PXQpe2NvbnN0IGU9by5zdWJzdHIoMCx0KTtvPW8uc3Vic3RyKHQrMSksdD1lLmxhc3RJbmRleE9mKFwiOlwiKSwtMT09PXQ/bis9cihlLCExLCExKToobis9cihlLnN1YnN0cigwLHQpLCExLCExKSxuKz1cIjpcIixuKz1yKGUuc3Vic3RyKHQrMSksITEsITApKSxuKz1cIkBcIn1vPW8udG9Mb3dlckNhc2UoKSx0PW8ubGFzdEluZGV4T2YoXCI6XCIpLC0xPT09dD9uKz1yKG8sITEsITApOihuKz1yKG8uc3Vic3RyKDAsdCksITEsITApLG4rPW8uc3Vic3RyKHQpKX1pZihzKXtpZihzLmxlbmd0aD49MyYmNDc9PT1zLmNoYXJDb2RlQXQoMCkmJjU4PT09cy5jaGFyQ29kZUF0KDIpKXtjb25zdCB0PXMuY2hhckNvZGVBdCgxKTt0Pj02NSYmdDw9OTAmJihzPWAvJHtTdHJpbmcuZnJvbUNoYXJDb2RlKHQrMzIpfToke3Muc3Vic3RyKDMpfWApfWVsc2UgaWYocy5sZW5ndGg+PTImJjU4PT09cy5jaGFyQ29kZUF0KDEpKXtjb25zdCB0PXMuY2hhckNvZGVBdCgwKTt0Pj02NSYmdDw9OTAmJihzPWAke1N0cmluZy5mcm9tQ2hhckNvZGUodCszMil9OiR7cy5zdWJzdHIoMil9YCl9bis9cihzLCEwLCExKX1yZXR1cm4gaCYmKG4rPVwiP1wiLG4rPXIoaCwhMSwhMSkpLGMmJihuKz1cIiNcIixuKz1lP2M6ZChjLCExLCExKSksbn1mdW5jdGlvbiB2KHQpe3RyeXtyZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHQpfWNhdGNoe3JldHVybiB0Lmxlbmd0aD4zP3Quc3Vic3RyKDAsMykrdih0LnN1YnN0cigzKSk6dH19Y29uc3QgYj0vKCVbMC05QS1aYS16XVswLTlBLVphLXpdKSsvZztmdW5jdGlvbiBDKHQpe3JldHVybiB0Lm1hdGNoKGIpP3QucmVwbGFjZShiLCh0PT52KHQpKSk6dH12YXIgQT1yKDQ3MCk7Y29uc3Qgdz1BLnBvc2l4fHxBLHg9XCIvXCI7dmFyIFA7IWZ1bmN0aW9uKHQpe3Quam9pblBhdGg9ZnVuY3Rpb24odCwuLi5lKXtyZXR1cm4gdC53aXRoKHtwYXRoOncuam9pbih0LnBhdGgsLi4uZSl9KX0sdC5yZXNvbHZlUGF0aD1mdW5jdGlvbih0LC4uLmUpe2xldCByPXQucGF0aCxuPSExO3JbMF0hPT14JiYocj14K3Isbj0hMCk7bGV0IGk9dy5yZXNvbHZlKHIsLi4uZSk7cmV0dXJuIG4mJmlbMF09PT14JiYhdC5hdXRob3JpdHkmJihpPWkuc3Vic3RyaW5nKDEpKSx0LndpdGgoe3BhdGg6aX0pfSx0LmRpcm5hbWU9ZnVuY3Rpb24odCl7aWYoMD09PXQucGF0aC5sZW5ndGh8fHQucGF0aD09PXgpcmV0dXJuIHQ7bGV0IGU9dy5kaXJuYW1lKHQucGF0aCk7cmV0dXJuIDE9PT1lLmxlbmd0aCYmNDY9PT1lLmNoYXJDb2RlQXQoMCkmJihlPVwiXCIpLHQud2l0aCh7cGF0aDplfSl9LHQuYmFzZW5hbWU9ZnVuY3Rpb24odCl7cmV0dXJuIHcuYmFzZW5hbWUodC5wYXRoKX0sdC5leHRuYW1lPWZ1bmN0aW9uKHQpe3JldHVybiB3LmV4dG5hbWUodC5wYXRoKX19KFB8fChQPXt9KSl9KSgpLExJQj1ufSkoKTtleHBvcnQgY29uc3R7VVJJLFV0aWxzfT1MSUI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9